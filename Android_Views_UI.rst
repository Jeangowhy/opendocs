

/TOC 💛 CORE AREAS - UI VIEWS, Styles and themes
================================================

DOCPATH: Android Developers -> Explore more -> Developer Guides -> Essential documentation

-  ` Styles and themes <https://developer.android.google.cn/develop/ui/views/theming/themes?hl=en>`__
-  ` Views <https://developer.android.google.cn/develop/ui/views/layout/declaring-layout?hl=en>`__

.. container::

   -  Develop your app's layout
   -  Apply themes
   -  Add components
   -  Work with text and emoji
   -  Display graphics and videos
   -  Work with animations and transitions
   -  Add support for touch and input
   -  Add notifications to your app
   -  Customize app launch
   -  Add app content to the home screen or launcher
   -  Create backward-compatible UIs

.. container:: section devsite-wrapper

   .. container:: devsite-product-description-row

      -  `Core areas <https://developer.android.google.cn/develop/core-areas>`__
      -  `UI <https://developer.android.google.cn/develop/ui>`__
      -  `Views <https://developer.android.google.cn/develop/ui/views/layout/declaring-layout>`__

.. container:: devsite-mobile-nav-bottom

   -  Develop your app's layout

      -  `About layouts <https://developer.android.google.cn/develop/ui/views/layout/declaring-layout>`__
      -  `Responsive/adaptive design with views <https://developer.android.google.cn/develop/ui/views/layout/responsive-adaptive-design-with-views>`__
      -  `Build a responsive UI with ConstraintLayout <https://developer.android.google.cn/develop/ui/views/layout/constraint-layout>`__
      -  `Create dynamic lists with RecyclerView <https://developer.android.google.cn/develop/ui/views/layout/recyclerview>`__
      -  `Customize a dynamic list <https://developer.android.google.cn/develop/ui/views/layout/recyclerview-custom>`__
      -  `Create a card-based layout <https://developer.android.google.cn/develop/ui/views/layout/cardview>`__
      -  `Create a two-pane layout <https://developer.android.google.cn/develop/ui/views/layout/twopane>`__
      -  `Create a linear layout <https://developer.android.google.cn/develop/ui/views/layout/linear>`__
      -  `Fill a layout with data <https://developer.android.google.cn/develop/ui/views/layout/binding>`__
      -  `Create a relative layout <https://developer.android.google.cn/develop/ui/views/layout/relative>`__

      -  Improve layout performance

         -  `About layout performance <https://developer.android.google.cn/develop/ui/views/layout/improving-layouts>`__
         -  `Optimize layout hierarchies <https://developer.android.google.cn/develop/ui/views/layout/improving-layouts/optimizing-layouts>`__
         -  `Reuse layouts with <include> <https://developer.android.google.cn/develop/ui/views/layout/improving-layouts/reusing-layouts>`__
         -  `Load views on demand <https://developer.android.google.cn/develop/ui/views/layout/improving-layouts/loading-ondemand>`__

      -  Create custom view components

         -  `About custom view components <https://developer.android.google.cn/develop/ui/views/layout/custom-views/custom-components>`__
         -  `How Android draws Views <https://developer.android.google.cn/guide/topics/ui/how-android-draws?hl=en>`__
         -  `Create a custom view class <https://developer.android.google.cn/develop/ui/views/layout/custom-views/create-view>`__
         -  `Implement a custom drawing <https://developer.android.google.cn/develop/ui/views/layout/custom-views/custom-drawing>`__
         -  `Make a custom view interactive <https://developer.android.google.cn/develop/ui/views/layout/custom-views/making-interactive>`__
         -  `Optimize a custom view <https://developer.android.google.cn/develop/ui/views/layout/custom-views/optimizing-view>`__

      -  Work with window insets and cutouts

         -  `Lay out your app within windows insets <https://developer.android.google.cn/develop/ui/views/layout/insets>`__
         -  `Display content edge-to-edge <https://developer.android.google.cn/develop/ui/views/layout/edge-to-edge>`__
         -  `Apply rounded corners <https://developer.android.google.cn/develop/ui/views/layout/insets/rounded-corners>`__
         -  `Hide system bars for immersive mode <https://developer.android.google.cn/develop/ui/views/layout/immersive>`__
         -  `Support display cutouts <https://developer.android.google.cn/develop/ui/views/layout/display-cutout>`__
         -  `Control and animate the software keyboard <https://developer.android.google.cn/develop/ui/views/layout/sw-keyboard>`__

      -  Add web-based content to your app

         -  `About web-based content <https://developer.android.google.cn/develop/ui/views/layout/webapps>`__
         -  `Develop web apps in WebView <https://developer.android.google.cn/develop/ui/views/layout/webapps/webview>`__
         -  `Manage WebView objects <https://developer.android.google.cn/develop/ui/views/layout/webapps/managing-webview>`__
         -  `Load local content <https://developer.android.google.cn/develop/ui/views/layout/webapps/load-local-content>`__
         -  `Darken web content <https://developer.android.google.cn/develop/ui/views/layout/webapps/dark-theme>`__
         -  `Support different screens in web apps <https://developer.android.google.cn/develop/ui/views/layout/webapps/targeting>`__
         -  `Debug web apps <https://developer.android.google.cn/develop/ui/views/layout/webapps/debugging>`__
         -  `Implement best practices <https://developer.android.google.cn/develop/ui/views/layout/webapps/best-practices>`__
         -  `User privacy in WebView crash reporting <https://developer.android.google.cn/develop/ui/views/layout/webapps/webview-privacy>`__
         -  `Beta program <https://developer.android.google.cn/develop/ui/views/layout/webapps/webview-testing>`__
         -  `Executing JavaScript and WebAssembly <https://developer.android.google.cn/develop/ui/views/layout/webapps/jsengine>`__

   -  Apply themes

      -  `About themes <https://developer.android.google.cn/develop/ui/views/theming/themes>`__
      -  `Use the device colors (Dynamic Color) <https://developer.android.google.cn/develop/ui/views/theming/dynamic-colors>`__
      -  `Select colors with the palette library <https://developer.android.google.cn/develop/ui/views/graphics/palette-colors>`__
      -  `Use Material Design as a guideline <https://developer.android.google.cn/develop/ui/views/theming/look-and-feel>`__
      -  `Implement dark theme <https://developer.android.google.cn/develop/ui/views/theming/darktheme>`__
      -  `Create shadows and clip views <https://developer.android.google.cn/develop/ui/views/theming/shadows-clipping>`__

   -  Add components

      -  Add core components

         -  `Floating action buttons (FABs) <https://developer.android.google.cn/develop/ui/views/components/floating-action-button>`__
         -  `Buttons <https://developer.android.google.cn/develop/ui/views/components/button>`__
         -  `Check boxes <https://developer.android.google.cn/develop/ui/views/components/checkbox>`__
         -  `Radio buttons <https://developer.android.google.cn/develop/ui/views/components/radiobutton>`__
         -  `Toggle buttons <https://developer.android.google.cn/develop/ui/views/components/togglebutton>`__
         -  `Pickers <https://developer.android.google.cn/develop/ui/views/components/pickers>`__
         -  `Tooltips <https://developer.android.google.cn/develop/ui/views/components/tooltips>`__
         -  `Dialogs <https://developer.android.google.cn/develop/ui/views/components/dialogs>`__
         -  `Menus <https://developer.android.google.cn/develop/ui/views/components/menus>`__

      -  Add the app bar component

         -  `About app bars <https://developer.android.google.cn/develop/ui/views/components/appbar>`__
         -  `Set up the app bar <https://developer.android.google.cn/develop/ui/views/components/appbar/setting-up>`__
         -  `Add and handle actions <https://developer.android.google.cn/develop/ui/views/components/appbar/actions>`__
         -  `Add an up action <https://developer.android.google.cn/develop/ui/views/components/appbar/up-action>`__
         -  `Use action views and action providers <https://developer.android.google.cn/develop/ui/views/components/appbar/action-views>`__

      -  Add the settings component

         -  `About settings <https://developer.android.google.cn/develop/ui/views/components/settings>`__
         -  `Organize your settings <https://developer.android.google.cn/develop/ui/views/components/settings/organize-your-settings>`__
         -  `Customize your settings <https://developer.android.google.cn/develop/ui/views/components/settings/customize-your-settings>`__
         -  `Use saved values <https://developer.android.google.cn/develop/ui/views/components/settings/use-saved-values>`__
         -  `Create a hierarchy in code <https://developer.android.google.cn/develop/ui/views/components/settings/programmatic-hierarchy>`__
         -  `Handle other device sizes <https://developer.android.google.cn/develop/ui/views/components/settings/handle-other-form-factors>`__
         -  `Implement preference best practices <https://developer.android.google.cn/develop/ui/views/components/settings/components-and-attributes>`__

      -  Integrate the Android search component

         -  `Search options <https://developer.android.google.cn/develop/ui/views/search>`__
         -  `Create a search UI <https://developer.android.google.cn/develop/ui/views/search/search-dialog>`__
         -  `Add search results from recent queries <https://developer.android.google.cn/develop/ui/views/search/adding-recent-query-suggestions>`__
         -  `Add custom search results <https://developer.android.google.cn/develop/ui/views/search/adding-custom-suggestions>`__
         -  `Provide a search configuration <https://developer.android.google.cn/develop/ui/views/search/searchable-config>`__
         -  `Use AppSearch <https://developer.android.google.cn/develop/ui/views/search/appsearch>`__

         -  Add search functionality

            -  `About search functionality <https://developer.android.google.cn/develop/ui/views/search/training>`__
            -  `Set up the search UI <https://developer.android.google.cn/develop/ui/views/search/training/setup>`__
            -  `Storing and searching for data <https://developer.android.google.cn/develop/ui/views/search/training/search>`__
            -  `Remain backward compatible with Search <https://developer.android.google.cn/develop/ui/views/search/training/backward-compat>`__

   -  Work with text and emoji

      -  `Autosize text views <https://developer.android.google.cn/develop/ui/views/text-and-emoji/autosizing-textview>`__
      -  `Download fonts on the fly <https://developer.android.google.cn/develop/ui/views/text-and-emoji/downloadable-fonts>`__
      -  `Add a font as an XML resource <https://developer.android.google.cn/develop/ui/views/text-and-emoji/fonts-in-xml>`__

      -  Add emoji support

         -  `Add support for modern emoji <https://developer.android.google.cn/develop/ui/views/text-and-emoji/emoji2>`__
         -  `Keep up to date with emoji <https://developer.android.google.cn/develop/ui/views/text-and-emoji/emoji-compat>`__
         -  `Use the Emoji Picker <https://developer.android.google.cn/develop/ui/views/text-and-emoji/emoji-picker>`__

      -  `Magnify text <https://developer.android.google.cn/develop/ui/views/text-and-emoji/magnifier>`__

      -  `Use spans to style text <https://developer.android.google.cn/develop/ui/views/text-and-emoji/spans>`__

   -  Display graphics and videos

      -  Static images

         -  `About static images <https://developer.android.google.cn/develop/ui/views/graphics/drawables>`__
         -  `Vector images <https://developer.android.google.cn/develop/ui/views/graphics/vector-drawable-resources>`__
         -  `Bitmaps <https://developer.android.google.cn/develop/ui/views/graphics>`__
         -  `Reduce image sizes <https://developer.android.google.cn/develop/ui/views/graphics/reduce-image-sizes>`__
         -  `Fix custom-drawing issues <https://developer.android.google.cn/develop/ui/views/graphics/hardware-accel>`__

      -  `Add media playback controls <https://developer.android.google.cn/develop/ui/views/playback-controls>`__

      -  `Add videos using picture-in-picture (PiP) <https://developer.android.google.cn/develop/ui/views/picture-in-picture>`__

      -  Work with advanced images and graphics

         -  Draw with AGSL shaders

            -  `About AGSL shaders <https://developer.android.google.cn/develop/ui/views/graphics/agsl>`__
            -  `About AGSL versus GLSL <https://developer.android.google.cn/develop/ui/views/graphics/agsl/agsl-vs-glsl>`__
            -  `Use AGSL in your app <https://developer.android.google.cn/develop/ui/views/graphics/agsl/using-agsl>`__
            -  `AGSL quick reference <https://developer.android.google.cn/develop/ui/views/graphics/agsl/agsl-quick-reference>`__

         -  Use OpenGL ES for graphics

            -  `Display graphics with Open GL ES <https://developer.android.google.cn/develop/ui/views/graphics/opengl/about-opengl>`__

            -  Learn how to use Open GL ES with graphics

               -  `About Open GL <https://developer.android.google.cn/develop/ui/views/graphics/opengl>`__
               -  `Build an Open GL ES environment <https://developer.android.google.cn/develop/ui/views/graphics/opengl/environment>`__
               -  `Define shapes <https://developer.android.google.cn/develop/ui/views/graphics/opengl/shapes>`__
               -  `Draw shapes <https://developer.android.google.cn/develop/ui/views/graphics/opengl/draw>`__
               -  `Apply projection and camera views <https://developer.android.google.cn/develop/ui/views/graphics/opengl/projection>`__
               -  `Add motion <https://developer.android.google.cn/develop/ui/views/graphics/opengl/motion>`__
               -  `Respond to touch events <https://developer.android.google.cn/develop/ui/views/graphics/opengl/touch>`__
               -  `Create APKs for different GL textures <https://developer.android.google.cn/develop/ui/views/graphics/multiple-apks/texture>`__

   -  Work with animations and transitions

      -  `Animations and Transitions <https://developer.android.google.cn/develop/ui/views/animations>`__
      -  `About animations in Android <https://developer.android.google.cn/develop/ui/views/animations/overview>`__
      -  `About property animations <https://developer.android.google.cn/develop/ui/views/animations/prop-animation>`__
      -  `Animate drawable graphics <https://developer.android.google.cn/develop/ui/views/animations/drawable-animation>`__

      -  Animate views

         -  `Generate images between keyframes in an animation <https://developer.android.google.cn/develop/ui/views/animations/view-animation>`__
         -  `Show or hide a view <https://developer.android.google.cn/develop/ui/views/animations/reveal-or-hide-view>`__
         -  `Move a view using animation <https://developer.android.google.cn/develop/ui/views/animations/reposition-view>`__
         -  `Move a view using fling animation <https://developer.android.google.cn/develop/ui/views/animations/fling-animation>`__
         -  `Enlarge a view using zoom animation <https://developer.android.google.cn/develop/ui/views/animations/zoom>`__

      -  `Animate movement using spring physics <https://developer.android.google.cn/develop/ui/views/animations/spring-animation>`__
      -  `Auto-animate layout updates <https://developer.android.google.cn/develop/ui/views/animations/layout>`__
      -  `Animate layout changes using a transition <https://developer.android.google.cn/develop/ui/views/animations/transitions>`__
      -  `Create a custom transition animation <https://developer.android.google.cn/develop/ui/views/animations/transitions/custom-transitions>`__
      -  `Start an activity using an animation <https://developer.android.google.cn/develop/ui/views/animations/transitions/start-activity>`__

      -  MotionLayout

         -  `Manage motion and widget animation <https://developer.android.google.cn/develop/ui/views/animations/motionlayout>`__
         -  `Add a carousel <https://developer.android.google.cn/develop/ui/views/animations/motionlayout/carousel>`__
         -  `MotionLayout examples <https://developer.android.google.cn/develop/ui/views/animations/motionlayout/examples>`__

      -  Slide between fragments

         -  `Use ViewPager2 to slide between fragments <https://developer.android.google.cn/develop/ui/views/animations/screen-slide-2>`__
         -  `Use ViewPager to slide between fragments <https://developer.android.google.cn/develop/ui/views/animations/screen-slide>`__
         -  `Migrate from ViewPager to ViewPager2 <https://developer.android.google.cn/develop/ui/views/animations/vp2-migration>`__

      -  `Use additional animation resources <https://developer.android.google.cn/develop/ui/views/animations/additional-resources>`__

   -  Add support for touch and input

      -  `Touch and input overview <https://developer.android.google.cn/develop/ui/views/touch-and-input/input>`__
      -  `About input events <https://developer.android.google.cn/develop/ui/views/touch-and-input/input-events>`__

      -  Use touch gestures

         -  `About gestures <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures>`__
         -  `Detect common gestures <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/detector>`__
         -  `Track touch and pointer movements <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/movement>`__
         -  `Handle scroll gestures <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/scroll>`__
         -  `Add support for navigation gestures <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/gesturenav>`__
         -  `Detect multi-touch gestures <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/multi>`__
         -  `Add support for drag and scale <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/scale>`__
         -  `Manage touch events in a ViewGroup <https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/viewgroup>`__

         -  Add support for swipe-to-refresh

            -  `About swipe-to-refresh <https://developer.android.google.cn/develop/ui/views/touch-and-input/swipe>`__
            -  `Add swipe-to-refresh to your app <https://developer.android.google.cn/develop/ui/views/touch-and-input/swipe/add-swipe-interface>`__
            -  `Respond to a refresh request <https://developer.android.google.cn/develop/ui/views/touch-and-input/swipe/respond-refresh-request>`__

      -  Handle keyboard input

         -  `About keyboards <https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input>`__
         -  `Specify the input method type <https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/style>`__
         -  `Handle input method visibility <https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/visibility>`__
         -  `Support keyboard navigation <https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/navigation>`__
         -  `Handle keyboard actions <https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/commands>`__

      -  `Handle stylus input <https://developer.android.google.cn/develop/ui/views/touch-and-input/stylus>`__
      -  `Use copy and paste across apps <https://developer.android.google.cn/develop/ui/views/touch-and-input/copy-paste>`__

      -  Enable drag and drop

         -  `Overview <https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop>`__
         -  `Key Concepts <https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/concepts>`__
         -  `DropHelper for simplified drag and drop <https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/drophelper>`__
         -  `Implement drag and drop with views <https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/view>`__
         -  `Drag and drop in multi-window mode <https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/multi-window>`__

      -  `Accept rich content from any source <https://developer.android.google.cn/develop/ui/views/receive-rich-content>`__

      -  Implement tactile feedback (haptics)

         -  `About haptics <https://developer.android.google.cn/develop/ui/views/haptics>`__
         -  `Haptic design principles <https://developer.android.google.cn/develop/ui/views/haptics/haptics-principles>`__
         -  `Add haptic feedback to events <https://developer.android.google.cn/develop/ui/views/haptics/haptic-feedback>`__
         -  `Vibration actuators primer <https://developer.android.google.cn/develop/ui/views/haptics/actuators>`__
         -  `Create custom haptic effects <https://developer.android.google.cn/develop/ui/views/haptics/custom-haptic-effects>`__
         -  `Haptics API reference <https://developer.android.google.cn/develop/ui/views/haptics/haptics-apis>`__

      -  Add support for game controllers

         -  `About game controllers <https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers>`__
         -  `Handle controller actions <https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/controller-input>`__
         -  `Add support across Android versions <https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/compatibility>`__
         -  `Add support for multiple controllers <https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/multiple-controllers>`__
         -  `Additional controller features <https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/controller-features>`__

      -  Work with input method editors (IMEs)

         -  `Create an input method <https://developer.android.google.cn/develop/ui/views/touch-and-input/creating-input-method>`__
         -  `Add image keyboard support <https://developer.android.google.cn/develop/ui/views/touch-and-input/image-keyboard>`__

      -  `Implement a spelling checker <https://developer.android.google.cn/develop/ui/views/touch-and-input/spell-checker-framework>`__

   -  Add notifications to your app

      -  `About notifications <https://developer.android.google.cn/develop/ui/views/notifications>`__
      -  `Request permission <https://developer.android.google.cn/develop/ui/views/notifications/notification-permission>`__
      -  `Create and manage notification channels <https://developer.android.google.cn/develop/ui/views/notifications/channels>`__

      -  Create a notification

         -  `Basic notifications <https://developer.android.google.cn/develop/ui/views/notifications/build-notification>`__
         -  `Expandable notifications <https://developer.android.google.cn/develop/ui/views/notifications/expanded>`__
         -  `Call style notifications <https://developer.android.google.cn/develop/ui/views/notifications/call-style>`__
         -  `Time-sensitive notifications <https://developer.android.google.cn/develop/ui/views/notifications/time-sensitive>`__
         -  `Custom notifications <https://developer.android.google.cn/develop/ui/views/notifications/custom-notification>`__

      -  `Create a notification group <https://developer.android.google.cn/develop/ui/views/notifications/group>`__
      -  `Start an activity from a notification <https://developer.android.google.cn/develop/ui/views/notifications/navigation>`__

      -  Add conversations

         -  `About conversations <https://developer.android.google.cn/develop/ui/views/notifications/conversations>`__
         -  `Use bubbles for conversations <https://developer.android.google.cn/develop/ui/views/notifications/bubbles>`__

      -  `Modify a badge <https://developer.android.google.cn/develop/ui/views/notifications/badges>`__

      -  Show pop-up messages

         -  `About pop-ups <https://developer.android.google.cn/develop/ui/views/notifications/snackbar>`__
         -  `Build and display a pop-up message <https://developer.android.google.cn/develop/ui/views/notifications/snackbar/showing>`__
         -  `Add an action to a message <https://developer.android.google.cn/develop/ui/views/notifications/snackbar/action>`__

   -  Customize app launch

      -  `Use adaptive launcher icons <https://developer.android.google.cn/develop/ui/views/launch/icon_design_adaptive>`__

      -  Add a splash screen

         -  `Add a splash screen to a new app <https://developer.android.google.cn/develop/ui/views/launch/splash-screen>`__
         -  `Migrate an existing splash screen to the new API <https://developer.android.google.cn/develop/ui/views/launch/splash-screen/migrate>`__

      -  Add app shortcuts

         -  `About shortcuts <https://developer.android.google.cn/develop/ui/views/launch/shortcuts>`__
         -  `Create shortcuts <https://developer.android.google.cn/develop/ui/views/launch/shortcuts/creating-shortcuts>`__
         -  `Add capabilities to shortcuts <https://developer.android.google.cn/develop/ui/views/launch/shortcuts/adding-capabilities>`__
         -  `Manage shortcuts <https://developer.android.google.cn/develop/ui/views/launch/shortcuts/managing-shortcuts>`__
         -  `Implement best practices for shortcuts <https://developer.android.google.cn/develop/ui/views/launch/shortcuts/best-practices>`__

   -  Add app content to the home screen or launcher

      -  `Create custom Quick Settings tiles <https://developer.android.google.cn/develop/ui/views/quicksettings-tiles>`__

      -  Create app widgets

         -  `About app widgets <https://developer.android.google.cn/develop/ui/views/appwidgets/overview>`__
         -  `Create a simple widget <https://developer.android.google.cn/develop/ui/views/appwidgets>`__
         -  `Enhance your widget <https://developer.android.google.cn/develop/ui/views/appwidgets/enhance>`__
         -  `Create an advanced widget <https://developer.android.google.cn/develop/ui/views/appwidgets/advanced>`__
         -  `Use widget collections <https://developer.android.google.cn/develop/ui/views/appwidgets/collections>`__
         -  `Size your widget <https://developer.android.google.cn/develop/ui/views/appwidgets/layouts>`__
         -  `Enable widget configuration <https://developer.android.google.cn/develop/ui/views/appwidgets/configuration>`__
         -  `Build a widget host <https://developer.android.google.cn/develop/ui/views/appwidgets/host>`__

      -  `Integrate content with home channels ⍈ <https://developer.android.google.cn/develop/ui/views/home-channels>`__
      -  `Control external devices <https://developer.android.google.cn/develop/ui/views/device-control>`__

   -  Create backward-compatible UIs

      -  `About backward-compatible UIs <https://developer.android.google.cn/training/backward-compatible-ui>`__
      -  `Abstract newer APIs <https://developer.android.google.cn/training/backward-compatible-ui/abstracting>`__
      -  `Proxy to newer APIs <https://developer.android.google.cn/training/backward-compatible-ui/new-implementation>`__
      -  `Create an implementation with older APIs <https://developer.android.google.cn/training/backward-compatible-ui/older-implementation>`__
      -  `Use the version-aware component <https://developer.android.google.cn/training/backward-compatible-ui/using-component>`__


/Overview: Layouts in Views
===========================

   .. container:: devsite-article-meta nocontent

      -  `Android Developers <https://developer.android.google.cn/>`__
      -  `Develop <https://developer.android.google.cn/develop>`__
      -  `Core areas <https://developer.android.google.cn/develop/core-areas>`__
      -  `UI <https://developer.android.google.cn/develop/ui>`__
      -  `Views <https://developer.android.google.cn/develop/ui/views/layout/declaring-layout>`__

   .. container:: devsite-article-body

      .. rubric:: Layouts in Views
         :name: layouts-in-views

         Try the Compose way

         Jetpack Compose is the recommended UI toolkit for Android.
         Learn how to work with layouts in Compose.

         `Learn Compose layout basics → <https://developer.android.google.cn/jetpack/compose/layouts/basics>`__

         |image-android-compose-ui-logo|

      A layout defines the structure for a user interface in your app,
      such as in an `activity <#>`__. All
      elements in the layout are built using a hierarchy of
      `View <#android.view.View>`__ and `ViewGroup <#android.view.ViewGroup>`__ objects. A
      ``View`` usually draws something the user can see and interact with.
      A ``ViewGroup`` is an invisible container that defines the layout
      structure for ``View`` and other ``ViewGroup`` objects, as shown in
      figure 1.

      .. figure:: https://developer.android.google.cn/static/images/viewgroup_2x.png
         :width: 548px

         **Figure 1.** Illustration of a view hierarchy, which defines a
         UI layout.

      ``View`` objects are often called *widgets* and can be one of many
      subclasses, such as
      `Button <#android.widget.Button>`__ or `TextView <#android.widget.TextView>`__. The
      ``ViewGroup`` objects are usually called *layouts* and can be one of
      many types that provide a different layout structure, such as
      `LinearLayout <#android.widget.LinearLayout>`__ or `ConstraintLayout <#androidx.constraintlayout.widget.ConstraintLayout>`__.

      You can declare a layout in two ways:

      -  **Declare UI elements in XML.** Android provides a
         straightforward XML vocabulary that corresponds to the ``View``
         classes and subclasses, such as those for widgets and layouts.
         You can also use Android Studio's `Layout Editor <#>`__ to build your XML layout
         using a drag-and-drop interface.
      -  **Instantiate layout elements at runtime.** Your app can create
         ``View`` and ``ViewGroup`` objects and manipulate their
         properties programmatically.

      Declaring your UI in XML lets you separate the presentation of your
      app from the code that controls its behavior. Using XML files also
      makes it easier to provide different layouts for different screen
      sizes and orientations. This is discussed further in 
      `Support different screen sizes <https://developer.android.google.cn/training/multiscreen/screensizes>`__.

      The Android framework gives you the flexibility to use either or
      both of these methods to build your app's UI. For example, you can
      declare your app's default layouts in XML, and then modify the
      layout at runtime.

      **Tip:** To debug your layout at runtime, use the `Layout Inspector <#>`__ tool.

      .. rubric:: Write the XML
         :name: write

      Using Android's XML vocabulary, you can quickly design UI layouts
      and the screen elements they contain, in the same way that you
      create web pages in HTML with a series of nested elements.

      Each layout file must contain exactly one root element, which must
      be a ``View`` or ``ViewGroup`` object. After you define the root
      element, you can add additional layout objects or widgets as child
      elements to gradually build a ``View`` hierarchy that defines your
      layout. For example, here's an XML layout that uses a vertical
      ``LinearLayout`` to hold a ``TextView`` and a ``Button``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                       android:layout_width="match_parent"
                       android:layout_height="match_parent"
                       android:orientation="vertical" >
             <TextView android:id="@+id/text"
                       android:layout_width="wrap_content"
                       android:layout_height="wrap_content"
                       android:text="Hello, I am a TextView" />
             <Button android:id="@+id/button"
                     android:layout_width="wrap_content"
                     android:layout_height="wrap_content"
                     android:text="Hello, I am a Button" />
         </LinearLayout>

      After you declare your layout in XML, save the file with the
      ``.xml`` extension in your Android project's ``res/layout/``
      directory so it properly compiles.

      For more information about the syntax for a layout XML file, see
      `Layout resource <#>`__.

      .. rubric:: Load the XML resource
         :name: load

      When you compile your app, each XML layout file is compiled into a
      ``View`` resource. Load the layout resource in your app's
      `Activity.onCreate() <#>`__ callback implementation. Do so by calling
      `setContentView() <#>`__,
      passing it the reference to your layout resource in the form:
      ``R.layout.``\ *``layout_file_name``*. For example, if your XML
      layout is saved as ``main_layout.xml``, load it for your
      ``Activity`` as follows:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  fun onCreate(savedInstanceState: Bundle) {
                      super.onCreate(savedInstanceState)
                      setContentView(R.layout.main_layout)
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public void onCreate(Bundle savedInstanceState) {
                      super.onCreate(savedInstanceState);
                      setContentView(R.layout.main_layout);
                  }

      The Android framework calls the ``onCreate()`` callback method in
      your ``Activity`` when the ``Activity`` launches. For more
      information about activity lifecycles, 
      see `Introduction to activities <#>`__.

      .. rubric:: Attributes
         :name: attributes

      Every ``View`` and ``ViewGroup`` object supports its own variety of
      XML attributes. Some attributes are specific to a ``View`` object.
      For example, ``TextView`` supports the ``textSize`` attribute.
      However, these attributes are also inherited by any ``View`` objects
      that extend this class. Some are common to all ``View`` objects,
      because they are inherited from the root ``View`` class, like the
      ``id`` attribute. Other attributes are considered *layout
      parameters*, which are attributes that describe certain layout
      orientations of the ``View`` object, as defined by that object's
      parent ``ViewGroup`` object.

      .. rubric:: ID
         :name: id

      Any ``View`` object can have an integer ID associated with it to
      uniquely identify the ``View`` within the tree. When the app is
      compiled, this ID is referenced as an integer, but the ID is
      typically assigned in the layout XML file as a string in the ``id``
      attribute. This is an XML attribute common to all ``View`` objects,
      and it is defined by the ``View`` class. You use it very often. The
      syntax for an ID inside an XML tag is the following:

      .. code:: prettyprint

         android:id="@+id/my_button"

      The *at* symbol (@) at the beginning of the string indicates that
      the XML parser parses and expands the rest of the ID string and
      identifies it as an ID resource. The *plus* symbol (+) means this is
      a new resource name that must be created and added to your resources
      in the ``R.java`` file.

      The Android framework offers many other ID resources. When
      referencing an Android resource ID, you don't need the *plus*
      symbol, but you must add the ``android`` package namespace as
      follows:

      .. code:: prettyprint

         android:id="@android:id/empty"

      The ``android`` package namespace indicates that you're referencing
      an ID from the ``android.R`` resources class, rather than the local
      resources class.

      To create views and reference them from your app, you can use a
      common pattern as follows:

      #. Define a view in the layout file and assign it a unique ID, as in
         the following example:

         .. code:: prettyprint

            <Button android:id="@+id/my_button"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/my_button_text"/>

      #. Create an instance of the view object and capture it from the
         layout, typically in the `onCreate() <#Activity>`__
         method, as shown in the following example:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     val myButton: Button = findViewById(R.id.my_button)

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     Button myButton = (Button) findViewById(R.id.my_button);

      Defining IDs for view objects is important when creating a
      `RelativeLayout <#android.widget.RelativeLayout>`__.
      In a relative layout, sibling views can define their layout relative
      to another sibling view, which is referenced by the unique ID.

      An ID doesn't need to be unique throughout the entire tree, but it
      must be unique within the part of the tree you search. It might
      often be the entire tree, so it's best to make it unique when
      possible.

      .. rubric:: Layout parameters
         :name: layout-params

      XML layout attributes named ``layout_``\ *``something``* define
      layout parameters for the ``View`` that are appropriate for the
      ``ViewGroup`` it resides in.

      Every ``ViewGroup`` class implements a nested class that extends
      `ViewGroup.LayoutParams <#android.view.ViewGroup.LayoutParams>`__.
      This subclass contains property types that define the size and
      position of each child view, as appropriate for the view group. As
      shown in figure 2, the parent view group defines layout parameters
      for each child view, including the child view group.

      .. figure:: https://developer.android.google.cn/static/images/layoutparams.png
         :width: 584px

         **Figure 2.** Visualization of a view hierarchy with layout
         parameters associated with each view.

      Every ``LayoutParams`` subclass has its own syntax for setting
      values. Each child element must define a ``LayoutParams`` that is
      appropriate for its parent, though it might also define a different
      ``LayoutParams`` for its own children.

      All view groups include a width and height, using ``layout_width``
      and ``layout_height``, and each view is required to define them.
      Many ``LayoutParams`` include optional margins and borders.

      You can specify width and height with exact measurements, but you
      might not want to do this often. More often, you use one of these
      constants to set the width or height:

      -  ``wrap_content``: tells your view to size itself to the
         dimensions required by its content.
      -  ``match_parent``: tells your view to become as big as its parent
         view group allows.

      In general, we don't recommend specifying a layout width and height
      using absolute units such as pixels. A better approach is using
      relative measurements, such as density-independent pixel units (dp),
      ``wrap_content``, or ``match_parent``, because it helps your app
      display properly across a variety of device screen sizes. The
      accepted measurement types are defined in 
      `Layout resource <#>`__.

      .. rubric:: Layout position
         :name: Position

      A view has rectangular geometry. It has a location, expressed as a
      pair of *left* and *top* coordinates, and two dimensions, expressed
      as a width and height. The unit for location and dimensions is the
      pixel.

      You can retrieve the location of a view by invoking the methods
      `getLeft() <#android.view.View>`__ and
      `getTop() <#android.view.View>`__. The former
      returns the left (*x*) coordinate of the rectangle representing the
      view. The latter returns the top (*y*) coordinate of the rectangle
      representing the view. These methods return the location of the view
      relative to its parent. For example, when ``getLeft()`` returns 20,
      this means the view is located 20 pixels to the right of the left
      edge of its direct parent.

      In addition, there are convenience methods to avoid unnecessary
      computations: namely
      `getRight() <#android.view.View>`__ and
      `getBottom() <#android.view.View>`__.
      These methods return the coordinates of the right and bottom edges
      of the rectangle representing the view. For example, calling
      ``getRight()`` is similar to the following computation:
      ``getLeft() + getWidth()``.

      .. rubric:: Size, padding, and margins
         :name: SizePaddingMargins

      The size of a view is expressed with a width and height. A view has
      two pairs of width and height values.

      The first pair is known as *measured width* and *measured height*.
      These dimensions define how big a view wants to be within its
      parent. You can obtain the measured dimensions by calling
      `getMeasuredWidth() <#android.view.View>`__
      and
      `getMeasuredHeight() <#android.view.View>`__.

      The second pair is known as *width* and *height*, or sometimes
      *drawing width* and *drawing height*. These dimensions define the
      actual size of the view on screen, at drawing time and after layout.
      These values might, but don't have to, differ from the measured
      width and height. You can obtain the width and height by calling
      `getWidth() <#android.view.View>`__ and
      `getHeight() <#android.view.View>`__.

      To measure its dimensions, a view takes into account its padding.
      The padding is expressed in pixels for the left, top, right and
      bottom parts of the view. You can use padding to offset the content
      of the view by a specific number of pixels. For instance, a left
      padding of two pushes the view's content two pixels to the right of
      the left edge. You can set padding using the
      `setPadding(int, int, int, int) <#android.view.View>`__
      method and query it by calling
      `getPaddingLeft() <#android.view.View>`__,
      `getPaddingTop() <#android.view.View>`__,
      `getPaddingRight() <#android.view.View>`__,
      and
      `getPaddingBottom() <#android.view.View>`__.

      Although a view can define a padding, it doesn't support margins.
      However, view groups do support margins. See
      `ViewGroup <#android.view.ViewGroup>`__ and
      `ViewGroup.MarginLayoutParams <#android.view.ViewGroup.MarginLayoutParams>`__
      for more information.

      For more information about dimensions, see
      `Dimension <https://developer.android.google.cn/guide/topics/resources/more-resources>`__.

      Besides setting margins and padding programmatically, you can also
      set them in your XML layouts, as shown in the following example:

      .. code:: prettyprint

           <?xml version="1.0" encoding="utf-8"?>
           <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                         android:layout_width="match_parent"
                         android:layout_height="match_parent"
                         android:orientation="vertical" >
               <TextView android:id="@+id/text"
                         android:layout_width="wrap_content"
                         android:layout_height="wrap_content"
                         android:layout_margin="16dp"
                         android:padding="8dp"
                         android:text="Hello, I am a TextView" />
               <Button android:id="@+id/button"
                       android:layout_width="wrap_content"
                       android:layout_height="wrap_content"
                       android:layout_marginTop="16dp"
                       android:paddingBottom="4dp"
                       android:paddingEnd="8dp"
                       android:paddingStart="8dp"
                       android:paddingTop="4dp"
                       android:text="Hello, I am a Button" />
           </LinearLayout>
           

      The preceding example shows margin and padding being applied. The
      ``TextView`` has uniform margins and padding applied all around, and
      the ``Button`` shows how you can apply them independently to
      different edges.

      **Note:** It is good practice to use ``paddingStart``,
      ``paddingEnd``, ``layout_marginStart``, and ``layout_marginEnd``
      instead of ``paddingLeft``, ``paddingRight``, ``layout_marginLeft``,
      and ``layout_marginRight``, as these behave better with both
      left-to-right and right-to-left language scripts.

      .. rubric:: Common layouts
         :name: CommonLayouts

      Each subclass of the ``ViewGroup`` class provides a unique way to
      display the views you nest within it. The most flexible layout type,
      and the one that provides the best tools for keeping your layout
      hierarchy shallow, is
      `ConstraintLayout <https://developer.android.google.cn/develop/ui/views/layout/constraint-layout>`__.

      The following are some of the common layout types built into the
      Android platform.

      **Note:** Although you can nest one or more layouts within another
      layout to achieve your UI design, keep your layout hierarchy as
      shallow as possible. Your layout draws faster if it has fewer nested
      layouts. A wide view hierarchy is better than a deep view hierarchy.

      .. container:: layout first

         `Create a linear layout <https://developer.android.google.cn/develop/ui/views/layout/linear>`__
         |image-linearlayout-small|
         Organizes its children into a single horizontal or vertical row
         and creates a scrollbar if the length of the window exceeds the
         length of the screen.

      .. container:: layout

         `Build web apps in WebView <#>`__ 
         |image-webview-small|
         Displays web pages.

      .. rubric:: Build dynamic lists
         :name: AdapterViews

      When the content for your layout is dynamic or not pre-determined,
      you can use
      `RecyclerView <https://developer.android.google.cn/develop/ui/views/layout/recyclerview>`__ or a
      subclass of `AdapterView <https://developer.android.google.cn/develop/ui/views/layout/binding>`__.
      ``RecyclerView`` is generally the better option, because it uses
      memory more efficiently than ``AdapterView``.

      Common layouts possible with ``RecyclerView`` and ``AdapterView``
      include the following:

      .. container:: layout first

         `List <https://developer.android.google.cn/develop/ui/views/layout/recyclerview>`__ 
         |image-listview-small|
         Displays a scrolling single column list.

      .. container:: layout

         `Grid <https://developer.android.google.cn/develop/ui/views/layout/recyclerview>`__ 
         |image-gridview-small|
         Displays a scrolling grid of columns and rows.

      ``RecyclerView`` offers more possibilities and the option to 
      `create a custom layout manager <https://developer.android.google.cn/develop/ui/views/layout/recyclerview#plan-your-layout>`__.

      .. rubric:: Fill an adapter view with data
         :name: FillingTheLayout

      You can populate an `AdapterView <#android.widget.AdapterView>`__ such as
      `ListView <#android.widget.ListView>`__ or
      `GridView <#android.widget.GridView>`__ by binding the
      ``AdapterView`` instance to an
      `Adapter <#android.widget.Adapter>`__, which retrieves
      data from an external source and creates a ``View`` that represents
      each data entry.

      Android provides several subclasses of ``Adapter`` that are useful
      for retrieving different kinds of data and building views for an
      ``AdapterView``. The two most common adapters are:

      `ArrayAdapter <#android.widget.ArrayAdapter>`__
         Use this adapter when your data source is an array. By default,
         ``ArrayAdapter`` creates a view for each array item by calling
         `toString() <#>`__ on
         each item and placing the contents in a ``TextView``.

         For example, if you have an array of strings you want to display
         in a ``ListView``, initialize a new ``ArrayAdapter`` using a
         constructor to specify the layout for each string and the string
         array:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                         val adapter = ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, myStringArray)
                         

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                         ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,
                                 android.R.layout.simple_list_item_1, myStringArray);
                         

         The arguments for this constructor are the following:

         -  Your app `Context <#android.content.Context>`__
         -  The layout that contains a ``TextView`` for each string in the array
         -  The string array

         Then call `setAdapter() <#android.widget.AdapterView>`__
         on your ``ListView``:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                         val listView: ListView = findViewById(R.id.listview)
                         listView.adapter = adapter
                         

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                         ListView listView = (ListView) findViewById(R.id.listview);
                         listView.setAdapter(adapter);
                         

         To customize the appearance of each item you can override the
         ``toString()`` method for the objects in your array. Or, to
         create a view for each item that's something other than a
         ``TextView``—for example, if you want an
         `ImageView <#android.widget.ImageView>`__ for each
         array item—extend the ``ArrayAdapter`` class and override
         `getView() <#android.widget.ArrayAdapter>`__
         to return the type of view you want for each item.

      `SimpleCursorAdapter <#android.widget.SimpleCursorAdapter>`__
         Use this adapter when your data comes from a
         `Cursor <#android.database.Cursor>`__. When using
         ``SimpleCursorAdapter``, specify a layout to use for each row in
         the ``Cursor`` and which columns in the ``Cursor`` you want
         inserted into the views of the layout you want. For example, if
         you want to create a list of people's names and phone numbers,
         you can perform a query that returns a ``Cursor`` containing a
         row for each person and columns for the names and numbers. You
         then create a string array specifying which columns from the
         ``Cursor`` you want in the layout for each result and an integer
         array specifying the corresponding views that each column need to
         be placed:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                         val fromColumns = arrayOf(ContactsContract.Data.DISPLAY_NAME,
                                                   ContactsContract.CommonDataKinds.Phone.NUMBER)
                         val toViews = intArrayOf(R.id.display_name, R.id.phone_number)
                         

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                         String[] fromColumns = {ContactsContract.Data.DISPLAY_NAME,
                                                 ContactsContract.CommonDataKinds.Phone.NUMBER};
                         int[] toViews = {R.id.display_name, R.id.phone_number};
                         

         When you instantiate the ``SimpleCursorAdapter``, pass the layout
         to use for each result, the ``Cursor`` containing the results,
         and these two arrays:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                         val adapter = SimpleCursorAdapter(this,
                                 R.layout.person_name_and_number, cursor, fromColumns, toViews, 0)
                         val listView = getListView()
                         listView.adapter = adapter
                         

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                         SimpleCursorAdapter adapter = new SimpleCursorAdapter(this,
                                 R.layout.person_name_and_number, cursor, fromColumns, toViews, 0);
                         ListView listView = getListView();
                         listView.setAdapter(adapter);
                         

         The ``SimpleCursorAdapter`` then creates a view for each row in
         the ``Cursor`` using the provided layout by inserting each
         ``fromColumns`` item into the corresponding ``toViews`` view.

      If during the course of your app's life you change the underlying
      data that is read by your adapter, call
      `notifyDataSetChanged() <#android.widget.ArrayAdapter>`__.
      This notifies the attached view that the data has been changed and
      it refreshes itself.

      .. rubric:: Handle click events
         :name: HandlingUserSelections

      You can respond to click events on each item in an ``AdapterView``
      by implementing the
      `AdapterView.OnItemClickListener <#android.widget.AdapterView.OnItemClickListener>`__
      interface. For example:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  listView.onItemClickListener = AdapterView.OnItemClickListener { parent, view, position, id ->
                      // Do something in response to the click.
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Create a message handling object as an anonymous class.
                  private OnItemClickListener messageClickedHandler = new OnItemClickListener() {
                      public void onItemClick(AdapterView parent, View v, int position, long id) {
                          // Do something in response to the click.
                      }
                  };

                  listView.setOnItemClickListener(messageClickedHandler);

      .. rubric:: Additional resources
         :name: additional-resources

      See how layouts are used in the 
      `Sunflower demo app <https://github.com/googlesamples/android-sunflower>`__ on
      GitHub.

   Last updated 2024-04-15 UTC.

.. |image-android-compose-ui-logo| image:: https://developer.android.google.cn/static/images/android-compose-ui-logo.png
   :class: android-page-banner-image
.. |image-linearlayout-small| image:: https://developer.android.google.cn/static/images/ui/linearlayout-small.png
   :target: https://developer.android.google.cn/develop/ui/views/layout/linear
.. |image-webview-small| image:: https://developer.android.google.cn/static/images/ui/webview-small.png
   :target: /guide/webapps/webview
.. |image-listview-small| image:: https://developer.android.google.cn/static/images/ui/listview-small.png
   :target: https://developer.android.google.cn/develop/ui/views/layout/recyclerview
.. |image-gridview-small| image:: https://developer.android.google.cn/static/images/ui/gridview-small.png
   :target: https://developer.android.google.cn/develop/ui/views/layout/recyclerview



/Responsive/adaptive design with views
======================================

.. https://developer.android.google.cn/develop/ui/views/layout/responsive-adaptive-design-with-views?hl=en

.. container:: devsite-article-body

   Responsive/adaptive layouts provide an optimized user experience regardless
   of screen size. Implement responsive/adaptive layouts to enable your
   view‑based app to support all display sizes, orientations, and
   configurations, including resizable configurations such as `multi-window mode <#>`__.

   .. rubric:: Responsive design
      :name: responsive_design

   The first step in supporting a variety of device form factors is to create a
   layout that is responsive to variations in the amount of display space
   available to your app.

   .. rubric:: ConstraintLayout
      :name: constraintlayout

   The best way to create a responsive layout is to use
   `ConstraintLayout <#androidx.constraintlayout.widget.ConstraintLayout>`__
   as the base layout for your UI. ``ConstraintLayout`` enables you to specify
   the position and size of each view according to spatial relationships with
   other views in the layout. All the views can then move and resize together as
   the display space changes.

   The easiest way to build a layout with ``ConstraintLayout`` is to use the
   Layout Editor in Android Studio. Layout Editor enables you to drag new views
   to the layout, apply constraints relative to parent and sibling views, and
   set view properties—all without editing any XML by hand.

   .. figure:: https://developer.android.google.cn/static/images/screens_support/layout-editor_2x.png

      **Figure 3.** The Layout Editor in Android Studio showing a
      ``ConstraintLayout``.

   For more information, see `Build a Responsive UI With ConstraintLayout <#>`__.

   .. rubric:: Responsive width and height
      :name: responsive_width_and_height

   To ensure your layout is responsive to different display sizes, use
   ``wrap_content``, ``match_parent``, or ``0dp (match constraint)`` for the
   width and height of view components instead of hard‑coded values:

   -  ``wrap_content``: The view sets its size to fit the content the view
      contains.
   -  ``match_parent``: The view expands as much as possible within the parent
      view.
   -  ``0dp (match constraint)``: In a ``ConstraintLayout``, similar to
      ``match_parent``. The view takes all the available space within the view's
      constraints.

   For example:

   .. code:: prettyprint

      <TextView
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:text="@string/lorem_ipsum" />

   Figure 4 shows how the width and height of the ``TextView`` adjust as the
   display width changes with device orientation.

   .. figure:: https://developer.android.google.cn/static/images/screens_support/layout-match-parent_2x.png

      **Figure 4.** A responsive ``TextView``.

   The ``TextView`` sets its width to fill all available space
   (``match_parent``) and its height to exactly as much space is required by the
   height of the contained text (``wrap_content``), which enables the view to
   adapt to different display dimensions and different amounts of text.

   If you're using a
   `LinearLayout <#android.widget.LinearLayout>`__, you can also
   expand the child views based on `layout weight <#Weight>`__ so the views proportionally
   fill the available space. However, using weights in a nested ``LinearLayout``
   requires the system to perform multiple layout passes to determine the size
   for each view, slowing UI performance.

   ``ConstraintLayout`` can create nearly all of the layouts possible with
   ``LinearLayout`` without the performance impact, so `convert your nested ``LinearLayout`` to
   ``ConstraintLayout`` <#convert-constraint>`__.
   Then you can `define weighted layouts with constraint chains <#constrain-chain>`__.

   **Note:**\  When using ``ConstraintLayout``, *don't use ``match_parent``*.
   Instead, set the dimension to ``0dp`` to enable a special behavior called
   "match constraints," which is generally the same as the behavior of
   ``match_parent``. For more information, 
   see `Adjust the view size <#adjust-the-view-size>`__ in `Build a Responsive UI With ConstraintLayout <#>`__.

   .. rubric:: Adaptive design
      :name: adaptive_design

   Your app's layout should always be responsive to different display sizes.
   However, even a responsive layout can't provide the best user experience on
   every device or multi‑window mode display. For example, the UI you designed
   for a phone, probably doesn't provide an optimal user experience on a tablet.
   Adaptive design provides alternative layouts optimized for different display
   dimensions.

   .. rubric:: SlidingPaneLayout for list-detail UIs
      :name: slidingpanelayout

   A list-detail UI typically provides a different user experience on
   different‑size screens. On large screens, the list and detail panes are
   usually side by side. When an item in the list is selected, item information
   is displayed in the detail pane without changing the UI—the two panes remain
   side by side. However, on small screens, the two panes are displayed
   separately, each pane occupying the entire display area. When an item in the
   list pane is selected, the detail pane (containing the selected item's
   information) replaces the list pane. Back navigation replaces the detail pane
   with the list.

   `SlidingPaneLayout <#androidx.slidingpanelayout.widget.SlidingPaneLayout>`__
   manages the logic for determining which of the two user experiences is
   appropriate for the current window size:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <androidx.slidingpanelayout.widget.SlidingPaneLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          tools:context=".MainActivity">

          <androidx.recyclerview.widget.RecyclerView
              android:id="@+id/recycler_view"
              android:layout_width="280dp"
              android:layout_height="match_parent"
              android:layout_gravity="start" />

          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/nav_host_fragment"
              android:name="androidx.navigation.fragment.NavHostFragment"
              android:layout_width="300dp"
              android:layout_height="match_parent"
              android:layout_weight="1"
              app:defaultNavHost="true"
              app:navGraph="@navigation/item_navigation" />

      </androidx.slidingpanelayout.widget.SlidingPaneLayout>

   The ``layout_width`` and ``layout_weight`` attributes of the two views
   contained in ``SlidingPaneLayout`` determine the ``SlidingPaneLayout``
   behavior. In the example, if the window is large enough (at least 580dp wide)
   to display both views, the panes are displayed side by side. But, if the
   window width is smaller than 580dp, the panes slide over one another to
   individually occupy the entire app window.

   If the window width is larger than the total specified minimum width (580dp),
   ``layout_weight`` values can be used to size the two panes proportionally. In
   the example, the list pane is always 280dp wide because it does not have a
   weight. The detail pane however, always fills any horizontal space beyond
   580dp because of the view's ``layout_weight`` setting.

   **Note:**\  The one exception to standard ``layout_weight`` behavior is when
   using ``SlidingPaneLayout``
   `v1.2.0 <#version_120_3>`__ and
   later on foldable devices, in which case ``SlidingPaneLayout`` automatically
   adjusts the size of the panes so they are on either side of any fold or
   hinge.

   .. rubric:: Alternative layout resources
      :name: alternative_layout_resources

   To adapt your UI design to widely varying display sizes, use alternative
   layouts identified by `resource qualifiers <#>`__.

   .. figure:: https://developer.android.google.cn/static/images/screens_support/sizes-phone-tablet_2x.png

      **Figure 5.** The same app using different layouts for different display
      sizes.

   You can provide adaptive, screen‑specific layouts by creating additional
   ``res/layout/`` directories in your app's source code. Create a directory for
   each screen configuration that requires a different layout. Then append a
   screen configuration qualifier to the ``layout`` directory name (for example,
   ``layout-w600dp`` for screens that have 600dp of available width).

   The configuration qualifiers represent the visible display space available
   for your app UI. The system takes into account any system decorations (such
   as the navigation bar) and window configuration changes (such as
   `multi‑window mode <#>`__) when selecting the
   layout for your app.

   To create alternative layouts in Android Studio, see `Use layout variants to
   optimize for different screens <#create-variant>`__ in `Develop a UI with Views <#>`__.

   .. rubric:: Smallest width qualifier
      :name: smallest_width

   The *smallest width* screen size qualifier enables you to provide alternative
   layouts for displays that have a minimum width measured in
   `density-independent pixels <#TaskUseDP>`__ (dp).

   By describing the screen size as a measure of dp, Android enables you to
   create layouts that are designed for specific display dimensions without
   concern for different pixel densities.

   For example, you can create a layout named ``main_activity`` that's optimized
   for phones and tablets by creating different versions of the file in
   different directories:

   .. code:: none

      res/layout/main_activity.xml           # For phones (smaller than 600dp smallest width)
      res/layout-sw600dp/main_activity.xml   # For 7" tablets (600dp wide or wider)

   The smallest width qualifier specifies the smallest of the display's two
   sides, regardless of the device's current orientation, so it's a way to
   specify the overall display size available for your layout.

   Here's how other smallest width values correspond to typical screen sizes:

   -  320dp: Small phone screen (240x320 ldpi, 320x480 mdpi, 480x800 hdpi, etc.)
   -  480dp: Large phone screen ~5" (480x800 mdpi)
   -  600dp: 7" tablet (600x1024 mdpi)
   -  720dp: 10" tablet (720x1280 mdpi, 800x1280 mdpi, etc.)

   The following figure gives a more detailed view of how different screen dp
   widths correspond to different screen sizes and orientations.

   .. figure:: https://developer.android.google.cn/static/images/screens_support/layout-adaptive-breakpoints_2x.png

      **Figure 6.** Recommended width breakpoints to support different screen
      sizes.

   Values for the *smallest width* qualifier are dp, because what matters is the
   amount of display space available after the system accounts for pixel density
   (not the raw pixel resolution).

   The sizes you specify using resource qualifiers like smallest width are *not
   the actual screen sizes*. Rather, the sizes specify the width or height in dp
   units that are *available to your app's window*. The Android system might use
   some of the screen for system UI (such as the system bar at the bottom of the
   screen or the status bar at the top), so some of the screen might not be
   available for your layout. If your app is used in multi‑window mode, the app
   only has access to the size of the window that contains the app. When the
   window is resized, it triggers a `configuration change <#>`__ with the new window size,
   which enables the system to select an appropriate layout file. So, the
   resource qualifier sizes you declare should specify only the space needed by
   your app. The system accounts for any space used by system UI when providing
   space for your layout.

   .. rubric:: Available width qualifier
      :name: available_width

   Instead of changing the layout based on the smallest width of the display,
   you might want to change your layout based on how much width or height is
   available. For example, you might want to use a two‑pane layout whenever the
   screen provides at least 600dp of width, which might change depending on
   whether the device is in landscape or portrait orientation. In that case, you
   should use the *available width* qualifier as follows:

   .. code:: none

      res/layout/main_activity.xml         # For phones (smaller than 600dp available width)
      res/layout-w600dp/main_activity.xml  # For 7" tablets or any screen with 600dp available width
                                           # (possibly landscape phones)

   If available height is a concern for your app, you can use the *available
   height* qualifier. For example, ``layout-h600dp`` for screens with at least
   600dp of screen height.

   .. rubric:: Orientation qualifiers
      :name: orientation_qualifiers

   Even though you may be able to support all size variations using only
   combinations of the *smallest width* and *available width* qualifiers, you
   might also want to change the user experience when the user switches between
   portrait and landscape orientations.

   For that, you can add the ``port`` or ``land`` qualifiers to your layout
   directory names. Just be sure the orientation qualifiers come after the size
   qualifiers. For example:

   .. code:: none

      res/layout/main_activity.xml                # For phones
      res/layout-land/main_activity.xml           # For phones in landscape
      res/layout-sw600dp/main_activity.xml        # For 7" tablets
      res/layout-sw600dp-land/main_activity.xml   # For 7" tablets in landscape

   For more information about all the screen configuration qualifiers, see `App resources overview <#>`__.

   .. rubric:: Window size classes
      :name: window_size_classes

   Window size classes are viewport breakpoints that help you create adaptive
   layouts. The breakpoints identify the display area available to your app as
   *compact*, *medium*, or *expanded*. Width and height are specified
   separately, so your app always has a window size class for width and a window
   size class for height.

   To programmatically apply adaptive layouts, do the following:

   -  Create layout resources based on the window size class breakpoints
   -  Compute your app's width and height window size classes using the
      `WindowSizeClass#compute() <#androidx.window.core.layout.WindowSizeClass>`__
      function from the `Jetpack WindowManager <#>`__ library
   -  Inflate the layout resource for the current window size classes

   **Note:**\  Most apps can implement adaptive layouts by considering only the
   width window size class.
   For more information about window size classes, see `Support different screen sizes <#>`__.

   .. rubric:: Modularized UI components using fragments
      :name: fragments

   When designing your app for multiple display sizes, use fragments to extract
   your UI logic into separate components to make sure you aren't needlessly
   duplicating UI behavior across activities. Then you can combine fragments to
   create multi‑pane layouts on large screens, or you can place fragments in
   separate activities on small screens.

   For example, the list‑detail pattern (see
   `SlidingPaneLayout <#slidingpanelayout>`__ above) could be implemented with
   one fragment containing the list and another fragment containing the list
   item details. On large screens, the fragments could be displayed side by
   side; on small screens, individually, filling the screen.

   To learn more, see the `Fragments <#>`__ overview.

   .. rubric:: Activity embedding
      :name: activity_embedding

   If your app consists of multiple activities, activity embedding enables you
   to easily create an adaptive UI.

   Activity embedding displays multiple activities or multiple instances of the
   same activity simultaneously in an application's task window. On large
   screens, activities can be displayed side by side; on small screens, stacked
   one on top of the other.

   You determine how your app displays its activities by creating an XML
   configuration file which the system uses to determine the appropriate
   presentation based on display size. Alternatively, you can make `Jetpack
   WindowManager API <#>`__ calls.

   Activity embedding supports device orientation changes and foldable devices,
   stacking and unstacking activities as the device rotates or folds and
   unfolds.

   For more information, see `Activity embedding <#>`__.

   .. rubric:: Screen sizes and aspect ratios
      :name: screen_sizes_and_aspect_ratios

   Test your app on a variety of screen sizes and aspect ratios to ensure your
   UI scales correctly.

   Android 10 (API level 29) and higher support a wide range of aspect ratios.
   Foldable form factors can vary from tall, narrow screens, such as 21:9 when
   folded, to a square aspect ratio of 1:1 when unfolded.

   To ensure compatibility with as many devices as possible, test your apps for
   as many of the following screen aspect ratios as you can:

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/foldables/fold-screen-ratios.png

      **Figure 7.** Various screen aspect ratios.

   If you don't have access to devices for all the different screen sizes you
   want to test, you can use the `Android Emulator <#>`__ to
   emulate almost any screen size.

   If you would rather test on a real device but don't have the device, you can
   use the `Firebase Test Lab <https://firebase.google.cn/docs/test-lab/>`__ to
   access devices in a Google data center.

   .. rubric:: Additional resources
      :name: additional_resources

   -  Material Design — `Understanding layout <https://m3.material.io/foundations/layout/understanding-layout/overview>`__


Last updated 2024-02-22 UTC.


/Build a responsive UI with ConstraintLayout
============================================

.. https://developer.android.google.cn/develop/ui/views/layout/constraint-layout?hl=en

.. container:: devsite-article-body

   .. rubric:: Build a responsive UI with ConstraintLayout - Part of Android Jetpack
      :name: build_a_responsive_ui_with_constraintlayout
      :class: page-title

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `ConstraintLayout in Compose → <https://developer.android.google.cn/jetpack/compose/layouts/constraintlayout>`__

      |image-android-compose-ui-logo|

   `ConstraintLayout <#androidx.constraintlayout.widget.ConstraintLayout>`__
   lets you create large, complex layouts with a flat view hierarchy—no nested
   view groups. It's similar to
   `RelativeLayout <#android.widget.RelativeLayout>`__ in that all
   views are laid out according to relationships between sibling views and the
   parent layout, but it's more flexible than ``RelativeLayout`` and easier to
   use with Android Studio's Layout Editor.

   All the power of ``ConstraintLayout`` is available directly from the Layout
   Editor's visual tools, because the layout API and the Layout Editor are
   specially built for each other. You can build your layout with
   ``ConstraintLayout`` entirely by dragging instead of editing the XML.

   .. container:: video-wrapper-left

   This page shows how to build a layout with ``ConstraintLayout`` in Android
   Studio 3.0 or higher. For more information about the Layout Editor, see
   `Build a UI with Layout Editor <#>`__.

   To see a variety of layouts you can create with ``ConstraintLayout``, see the
   `Constraint Layout Examples project on GitHub <https://github.com/android/views-widgets-samples/tree/main/ConstraintLayoutExamples>`__.

   .. rubric:: Constraints overview
      :name: constraints-overview
      :class: clear

   To define a view's position in ``ConstraintLayout``, you add at least one
   horizontal and one vertical constraint for the view. Each constraint
   represents a connection or alignment to another view, the parent layout, or
   an invisible guideline. Each constraint defines the view's position along the
   vertical or horizontal axis. Each view must have a minimum of one constraint
   for each axis, but often more are necessary.

   When you drop a view into the Layout Editor, it stays where you leave it even
   if it has no constraints. This is only to make editing easier. If a view has
   no constraints when you run your layout on a device, it is drawn at position
   [0,0] (the top-left corner).

   In figure 1, the layout looks good in the editor, but there's no vertical
   constraint on view C. When this layout draws on a device, view C horizontally
   aligns with the left and right edges of view A, but it appears at the top of
   the screen because it has no vertical constraint.

   .. container:: cols

      .. container:: col-1of2

         |image-constraint-fail_2x|
         **Figure 1.** The editor shows view C below A, but it has no vertical
         constraint.

      .. container:: col-1of2

         |image-constraint-fail-fixed_2x|
         **Figure 2.** View C is now vertically constrained below view A.

      Although a missing constraint doesn't cause a compilation error, the
      Layout Editor indicates missing constraints as an error in the toolbar. To
      view the errors and other warnings, click **Show Warnings and Errors**
      |image-layout-editor-errors|. To help you avoid missing constraints, the Layout Editor
      automatically adds constraints for you with the `Autoconnect and infer constraints <#use-autoconnect-and-infer-constraints>`__ features.

      .. rubric:: Add ConstraintLayout to your project
         :name: add-constraintlayout-to-your-project

      To use ``ConstraintLayout`` in your project, proceed as follows:

      #. Ensure you have the ``maven.google.com`` repository declared in your
         ``settings.gradle`` file:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Groovy
                     :name: groovy

                  .. code:: prettyprint

                         dependencyResolutionManagement {
                           ...
                           repositories {
                               google()
                           }
                         )
                         

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kts

                  .. code:: prettyprint

                         dependencyResolutionManagement {
                           ...
                           repositories {
                               google()
                           }
                         }
                         

      #. Add the library as a dependency in the module-level ``build.gradle``
         file, as shown in the following example. The latest version might be
         different than what is shown in the example.

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Groovy
                     :name: groovy

                  .. code:: prettyprint

                     dependencies {
                         implementation "androidx.constraintlayout:constraintlayout:2.2.0-alpha13"
                         // To use constraintlayout in compose
                         implementation "androidx.constraintlayout:constraintlayout-compose:1.1.0-alpha13"
                     }

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kts

                  .. code:: prettyprint

                     dependencies {
                         implementation("androidx.constraintlayout:constraintlayout:2.2.0-alpha13")
                         // To use constraintlayout in compose
                         implementation("androidx.constraintlayout:constraintlayout-compose:1.1.0-alpha13")
                     }

      #. In the toolbar or sync notification, click **Sync Project with Gradle
         Files**.

      Now you're ready to build your layout with ``ConstraintLayout``.

      .. rubric:: Convert a layout
         :name: convert

      .. container:: attempt-right

         |image-layout-editor-convert-to-constraint_2x|
         **Figure 3.** The menu to convert a layout to ``ConstraintLayout``.

      To convert an existing layout to a constraint layout, follow these steps:

      #. Open your layout in Android Studio and click the **Design** tab at the
         bottom of the editor window.
      #. In the **Component Tree** window, right-click the layout and click
         **Convert LinearLayout to ConstraintLayout**.

      .. rubric:: Create a new layout
         :name: createNew

      To start a new constraint layout file, follow these steps:

      #. In the **Project** window, click the module folder and select **File >
         New > XML > Layout XML**.
      #. Enter a name for the layout file and enter
         "androidx.constraintlayout.widget.ConstraintLayout" for the **Root
         Tag**.
      #. Click **Finish**.

      .. rubric:: Add or remove a constraint
         :name: add-a-constraint

      To add a constraint, do the following:

      .. container:: attempt-right

         https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-constrain-left.mov

         **Video 1.** The left side of a view is constrained to the left side of
         the parent.

      #. Drag a view from the **Palette** window into the editor.

         When you add a view in a ``ConstraintLayout``, it displays in a
         bounding box with square resizing handles on each corner and circular
         constraint handles on each side.

      #. Click the view to select it.

      #. Do one of the following:

         -  Click a constraint handle and drag it to an available anchor point.
            This point can be the edge of another view, the edge of the layout,
            or a guideline. Notice that as you drag the constraint handle, the
            Layout Editor shows potential connection anchors and blue overlays.

         -  Click one of the **Create a connection** |image-attributes-plus-icon_2x| buttons in the
            **Layout** section of the **Attributes** window, as shown in figure
            4.

            |image-constraint-layout-create-constraint-2x|

            **Figure 4.** The **Layout** section of the **Attributes** window
            lets you create connections.

      When the constraint is created, the editor gives it a 
      `default margin <#adjust-the-view-margins>`__ to separate the two views.

      When creating constraints, remember the following rules:

      -  Every view must have at least two constraints: one horizontal and one
         vertical.
      -  You can create constraints only between a constraint handle and an
         anchor point that share the same plane. A vertical plane—the left and
         right sides—of a view can be constrained only to another vertical
         plane, and baselines can constrain only to other baselines.
      -  Each constraint handle can be used for just one constraint, but you can
         create multiple constraints from different views to the same anchor
         point.

      You can delete a constraint by doing any of the following:

      -  Click a constraint to select it, and then click Delete.

      -  Control-click (Command-click on macOS) a constraint anchor. The
         constraint turns red to indicate that you can click to delete it, as
         shown in figure 5.

         |image-constraint-layout-delete-1-2x|

         **Figure 5.** A red constraint indicates that you can click to delete
         it.

      -  In the **Layout** section of the **Attributes** window, click a
         constraint anchor, as shown in figure 6.

         |image-constraint-layout-delete-2-2x|

         **Figure 6.** Click a constraint anchor to delete it.

      .. container:: attempt-right

         **Video 2.** Adding a constraint that opposes an existing one.

      If you add opposing constraints on a view, the constraint lines become
      coiled like a spring to indicate the opposing forces, as shown in video 2.
      The effect is most visible when the view size is set to "fixed" or "wrap
      content," in which case the view is centered between the constraints. If
      you instead want the view to stretch its size to meet the constraints,
      `switch the size <#adjust-the-view-size>`__ to "match constraints." If you
      want to keep the current size but move the view so that it's not centered,
      `adjust the constraint bias <#adjust-the-constraint-bias>`__.

      You can use constraints to achieve different types of layout behavior, as
      described in the following sections.

      .. rubric:: Parent position
         :name: parent

      .. container:: cols

         .. container:: col-1of2

            Constrain the side of a view to the corresponding edge of the
            layout.

            In figure 7, the left side of the view is connected to the left edge
            of the parent layout. You can define the distance from the edge with
            margin.

         .. container:: col-1of2

            |image-parent-constraint_2x|
            **Figure 7.** A horizontal constraint to the parent.

      .. rubric:: Order position
         :name: position

      .. container:: cols

         .. container:: col-1of2

            Define the order of appearance for two views, either vertically or
            horizontally.

            In figure 8, B is constrained to always be to the right of A, and C
            is constrained below A. However, these constraints don't imply
            alignment, so B can still move up and down.

         .. container:: col-1of2

            |image-position-constraint_2x|
            **Figure 8.** A horizontal and vertical constraint.

      .. rubric:: Alignment
         :name: alignment

      .. container:: cols

         .. container:: col-1of2

            Align the edge of a view to the same edge of another view.

            In figure 9, the left side of B is aligned to the left side of A. If
            you want to align the view centers, create a constraint on both
            sides.

            You can offset the alignment by dragging the view inward from the
            constraint. For example, figure 10 shows B with a 24dp offset
            alignment. The offset is defined by the constrained view's margin.

            You can also select all the views you want to align, and then click
            **Align** |image-layout-editor-align| in the toolbar to select the alignment type.

         .. container:: col-1of2

            .. container:: cols

               .. container:: col-1of2

                  |image-alignment-constraint_2x|
                  **Figure 9.** A horizontal alignment constraint.

               .. container:: col-1of2

                  |image-alignment-constraint-offset_2x|
                  **Figure 10.** An offset horizontal alignment constraint.

      .. rubric:: Baseline alignment
         :name: baseline

      .. container:: cols

         .. container:: col-1of2

            Align the text baseline of a view to the text baseline of another
            view.

            In figure 11, the first line of B is aligned with the text in A.

            To create a baseline constraint, right-click the text view you want
            to constrain and then click **Show Baseline**. Then click on the
            text baseline and drag the line to another baseline.

         .. container:: col-1of2

            |image-baseline-constraint_2x|
            **Figure 11.** A baseline alignment constraint.

      .. rubric:: Constrain to a guideline
         :name: constrain-to-a-guideline

      .. container:: cols

         .. container:: col-1of2

            You can add a vertical or horizontal guideline that lets you
            constrain your views and is invisible to your app's users. You can
            position the guideline within the layout based on either dp units or
            a percentage relative to the layout's edge.

            To create a guideline, click **Guidelines** |image-layout-editor-guidelines| in the
            toolbar, and then click either **Add Vertical Guideline** or **Add
            Horizontal Guideline**.

            Drag the dotted line to reposition it, and click the circle at the
            edge of the guideline to toggle the measurement mode.

         .. container:: col-1of2

            |image-guideline-constraint_2x|
            **Figure 12.** A view constrained to a guideline.

      .. rubric:: Constrain to a barrier
         :name: constrain-to-a-barrier

      .. container:: cols

         .. container:: col-1of2

            Similar to a guideline, a barrier is an invisible line that you can
            constrain views to, except a barrier doesn't define its own
            position. Instead, the barrier position moves based on the position
            of views contained within it. This is useful when you want to
            constrain a view to a set of views rather than to one specific view.

            For example, in figure 13 view C is constrained to the right side of
            a barrier. The barrier is set to the "end" (or the right side, in a
            left-to-right layout) of both view A and view B. The barrier moves
            depending on whether the right side of view A or of view B is is
            farthest right.

            To create a barrier, follow these steps:

            #. Click **Guidelines** |image-layout-editor-guidelines| in the toolbar, and then click
               **Add Vertical Barrier** or **Add Horizontal Barrier**.
            #. In the **Component Tree** window, select the views you want
               inside the barrier and drag them into the barrier component.
            #. Select the barrier from the **Component Tree**, open the
               **Attributes** |image-window-properties| window, and then set
               **barrierDirection**.

            Now you can create a constraint from another view to the barrier.

            You can also constrain views that are *inside* the barrier to the
            barrier. This way, you can align all the views in the barrier to
            each other, even if you don't know which view is the longest or
            tallest.

            You can also include a guideline inside a barrier to ensure a
            "minimum" position for the barrier.

         .. container:: col-1of2

            |image-barrier-constraint_2x|
            **Figure 13.** View C is constrained to a barrier, which moves based
            on the position and size of both view A and view B.

      .. rubric:: Adjust the constraint bias
         :name: adjust-the-constraint-bias

      When you add a constraint to both sides of a view, and the view size for
      the same dimension is either "fixed" or "wrap content", the view becomes
      centered between the two constraints with a bias of 50% by default. You
      can adjust the bias by dragging the bias slider in the **Attributes**
      window or by dragging the view, as shown in video 3.

      If you instead want the view to stretch its size to meet the constraints,
      `switch the size <#adjust-the-view-size>`__ to "match constraints."

      .. container::

         **Video 3.** Adjusting the constraint bias.

      .. rubric:: Adjust the view size
         :name: adjust-the-view-size

      .. container:: attempt-right

         |image-constraint-layout-editor-attributes-2x|
         **Figure 14.** When selecting a view, the **Attributes** window
         includes controls for 1 size ratio, 2 deleting constraints, 3 height or
         width mode, 4 margins, and 5 constraint bias. You can also highlight
         individual constraints in the Layout Editor by clicking them in the 6
         constraint list.

      You can use the corner handles to resize a view, but this hardcodes the
      size—the view doesn't resize for different content or screen sizes. To
      select a different sizing mode, click a view and open the **Attributes**
      |image-window-properties| window on the right side of the editor.

      Near the top of the **Attributes** window is the view inspector, which
      includes controls for several layout attributes, as shown in figure 14.
      This is available only for views in a constraint layout.

      You can change the way the height and width are calculated by clicking the
      symbols indicated with callout 3 in figure 14. These symbols represent the
      size mode as follows. Click the symbol to toggle between these settings:

      -  |image-layout-width-fixed| **Fixed**: specify a specific dimension in the following text
         box or by resizing the view in the editor.

      -  |image-layout-width-wrap| **Wrap Content**: the view expands only as much as needed to
         fit its contents.

         -  **layout_constrainedWidth**

      -  |image-layout-width-match| **Match Constraints**: the view expands as much as possible
         to meet the constraints on each side, after accounting for the view's
         margins. However, you can modify that behavior with the following
         attributes and values. These attributes take effect only when you set
         the view width to "match constraints":

         -  **layout_constraintWidth_min**

            This takes a ``dp`` dimension for the view's minimum width.

         -  **layout_constraintWidth_max**

            This takes a ``dp`` dimension for the view's maximum width.

         However, if the given dimension has only one constraint, then the view
         expands to fit its contents. Using this mode on either the height or
         width also lets you `set a size ratio <#set-size-as-a-ratio>`__.

      **Note**: You can't use ``match_parent`` for any view in a
      ``ConstraintLayout``. Instead, use "match constraints" (``0dp``).
      .. rubric:: Set size as a ratio
         :name: set-size-as-a-ratio

      .. container:: attempt-right

         |image-constraint-layout-ratio-2x|
         **Figure 15.** The view is set to a 16:9 aspect with the width based on
         a ratio of the height.

      You can set the view size to a ratio, such as 16:9, if at least one of the
      view dimensions is set to "match constraints" (``0dp``). To enable the
      ratio, click **Toggle Aspect Ratio Constraint** (callout 1 in figure 14)
      and enter the ``width``:``height`` ratio in the input that appears.

      If both the width and height are set to "match constraints," you can click
      **Toggle Aspect Ratio Constraint** to select which dimension is based on a
      ratio of the other. The view inspector indicates which dimension is set as
      a ratio by connecting the corresponding edges with a solid line.

      For example, if you set both sides to "match constraints," click **Toggle
      Aspect Ratio Constraint** twice to set the width to be a ratio of the
      height. The entire size is dictated by the height of the view, which can
      be defined in any way, as shown in figure 15.

      .. rubric:: Adjust the view margins
         :name: adjust-the-view-margins

      To make your views evenly spaced, click **Margin** |image-constraint-layout-margin-icon-2x| in the
      toolbar to select the default margin for each view that you add to the
      layout. Any change you make to the default margin applies only to the
      views you add from then on.

      You can control the margin for each view in the **Attributes** window by
      clicking the number on the line that represents each constraint. In figure
      14, callout 4 shows the bottom margin is set to 16dp.

      |image-constraint-layout-margin-2x|

      **Figure 16.** The toolbar's **Margin** button.

      All margins offered by the tool are factors of 8dp to help your views
      align to Material Design's 8dp square grid recommendations.

      .. rubric:: Control linear groups with a chain
         :name: constrain-chain

      .. container:: attempt-right

         |image-constraint-chain_2x|
         **Figure 17.** A horizontal chain with two views.

      A chain is a group of views that are linked to each other with
      bi-directional position constraints. The views within a chain can be
      distributed either vertically or horizontally.

      .. container:: attempt-right

         |image-constraint-chain-styles_2x|
         **Figure 18.** Examples of each chain style.

      Chains can be styled in one of the following ways:

      #. **Spread:** the views are evenly distributed after margins are
         accounted for. This is the default.
      #. **Spread inside:** the first and last views are affixed to the
         constraints on each end of the chain, and the rest are evenly
         distributed.
      #. **Weighted:** when the chain is set to **spread** or **spread inside**,
         you can fill the remaining space by setting one or more views to "match
         constraints" (``0dp``). By default, the space is evenly distributed
         between each view that's set to "match constraints," but you can assign
         a weight of importance to each view using the
         ``layout_constraintHorizontal_weight`` and
         ``layout_constraintVertical_weight`` attributes. This works the same
         way as ``layout_weight`` in a `linear layout <#>`__: the view with the highest
         weight value gets the most space, and views that have the same weight
         get the same amount of space.
      #. **Packed:** the views are packed together after margins are accounted
         for. You can adjust the whole chain's bias—left or right, or up or
         down—by changing the chain's "head" view bias.

      The chain's "head" view—the leftmost view in a horizontal chain (in a
      left-to-right layout) and the top-most view in a vertical chain—defines
      the chain's style in XML. However, you can toggle between **spread**,
      **spread inside**, and **packed** by selecting any view in the chain and
      clicking the chain button |image-layout-editor-action-chain| that appears below the view.

      To create a chain, do the following, as shown in video 4:

      #. Select all the views to be included in the chain.
      #. Right-click one of the views.
      #. Select **Chains**.
      #. Select either **Center Horizontally** or **Center Vertically**.

      .. container::

         **Video 4.** Creating a horizontal chain.

      Here are a few things to consider when using chains:

      -  A view can be a part of both a horizontal and a vertical chain, so you
         can build flexible grid layouts.
      -  A chain works properly only if each end of the chain is constrained to
         another object on the same axis, as shown in figure 14.
      -  Although the orientation of a chain is vertical or horizontal, using
         one doesn't align the views in that direction. To achieve the proper
         position for each view in the chain, include other constraints, such as
         `alignment constraints <#alignment>`__.

      .. rubric:: Automatically create constraints
         :name: use-autoconnect-and-infer-constraints

      Instead of adding constraints to every view as you place them in the
      layout, you can move each view into the positions you want in the Layout
      Editor and then click **Infer Constraints** |image-layout-editor-infer| to automatically
      create constraints.

      **Infer Constraints** scans the layout to determine the most effective set
      of constraints for all views. It constrains the views to their current
      positions while providing flexibility. You might need to make adjustments
      to make the layout respond as you intend for different screen sizes and
      orientations.

      **Autoconnect to Parent** is a separate feature that you can enable. When
      it's enabled and you add child views to a parent, this feature
      automatically creates two or more constraints for each view as you add
      them to the layout—but only when it's appropriate to constrain the view to
      the parent layout. Autoconnect doesn't create constraints to other views
      in the layout.

      Autoconnect is disabled by default. Enable it by clicking **Enable
      Autoconnection to Parent** |image-layout-editor-autoconnect-on| in the Layout Editor toolbar.

      .. rubric:: Keyframe animations
         :name: keyframe-animations

      .. container:: video-wrapper-left

      Within a ``ConstraintLayout``, you can animate changes to the size and
      position of elements by using
      `ConstraintSet <#androidx.constraintlayout.widget.ConstraintSet>`__
      and
      `TransitionManager <#android.transition.TransitionManager>`__.

      A ``ConstraintSet`` is a lightweight object that represents the
      constraints, margins, and padding of all child elements within a
      ``ConstraintLayout``. When you apply a ``ConstraintSet`` to a displayed
      ``ConstraintLayout``, the layout updates the constraints of all its
      children.

      To build an animation using ``ConstraintSet``, specify two layout files
      that act as start and end keyframes for the animation. You can then load a
      ``ConstraintSet`` from the second keyframe file and apply it to the
      displayed ``ConstraintLayout``.

      **Note:** ``ConstraintSet`` animations animate only the size and position
      of child elements. They don't animate other attributes, such as color.
      The following code example shows how to animate moving a single button to
      the bottom of the screen.

      .. code:: prettyprint

         // MainActivity.kt

         fun onCreate(savedInstanceState: Bundle?) {
             super.onCreate(savedInstanceState)
             setContentView(R.layout.keyframe_one)
             constraintLayout = findViewById(R.id.constraint_layout) // member variable
         }

         fun animateToKeyframeTwo() {
             val constraintSet = ConstraintSet()
             constraintSet.load(this, R.layout.keyframe_two)
             TransitionManager.beginDelayedTransition()
             constraintSet.applyTo(constraintLayout)
         }

      .. code:: prettyprint

         // layout/keyframe1.xml
         // Keyframe 1 contains the starting position for all elements in the animation
         // as well as final colors and text sizes.

         <?xml version="1.0" encoding="utf-8"?>
         <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
             xmlns:app="http://schemas.android.com/apk/res-auto"
             android:layout_width="match_parent"
             android:layout_height="match_parent">

             <Button
                 android:id="@+id/button2"
                 android:layout_width="0dp"
                 android:layout_height="wrap_content"
                 android:text="Button"
                 app:layout_constraintEnd_toEndOf="parent"
                 app:layout_constraintStart_toStartOf="parent"
                 app:layout_constraintTop_toTopOf="parent" />
         </androidx.constraintlayout.widget.ConstraintLayout>

      .. code:: prettyprint

         // layout/keyframe2.xml
         // Keyframe 2 contains another ConstraintLayout with the final positions.

         <?xml version="1.0" encoding="utf-8"?>
         <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
             xmlns:app="http://schemas.android.com/apk/res-auto"
             android:layout_width="match_parent"
             android:layout_height="match_parent">

             <Button
                 android:id="@+id/button2"
                 android:layout_width="0dp"
                 android:layout_height="wrap_content"
                 android:text="Button"
                 app:layout_constraintEnd_toEndOf="parent"
                 app:layout_constraintStart_toStartOf="parent"
                 app:layout_constraintBottom_toBottomOf="parent" />
         </androidx.constraintlayout.widget.ConstraintLayout>

      **Note:** With Android Studio 3.6 and higher, the `view binding <#>`__ feature can replace
      ``findViewById()`` calls. It also provides compile-time type safety for
      code that interacts with views. Consider using view binding instead of
      ``findViewById()``.
      .. rubric:: Additional resources
         :name: additional-resources

      ``ConstraintLayout`` is used in the
      `Sunflower <https://github.com/android/sunflower>`__ demo app.

   Last updated 2024-04-15 UTC.

.. |image-constraint-fail_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/constraint-fail_2x.png
   :width: 100.0%
.. |image-constraint-fail-fixed_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/constraint-fail-fixed_2x.png
   :width: 100.0%
.. |image-layout-editor-errors| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-editor-errors.png
   :class: inline-icon
.. |image-layout-editor-convert-to-constraint_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/layout-editor-convert-to-constraint_2x.png
   :width: 415px
.. |image-attributes-plus-icon_2x| image:: https://developer.android.google.cn/static/studio/images/buttons/attributes-plus-icon_2x.png
   :class: inline-icon
.. |image-constraint-layout-create-constraint-2x| image:: https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-create-constraint-2x.png
   :width: 404px
.. |image-constraint-layout-delete-1-2x| image:: https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-delete-1-2x.png
   :width: 248px
.. |image-constraint-layout-delete-2-2x| image:: https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-delete-2-2x.png
   :width: 404px
.. |image-parent-constraint_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/parent-constraint_2x.png
   :width: 100.0%
.. |image-position-constraint_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/position-constraint_2x.png
   :width: 100.0%
.. |image-layout-editor-align| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-editor-align.png
   :class: inline-icon
.. |image-alignment-constraint_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/alignment-constraint_2x.png
   :width: 100.0%
.. |image-alignment-constraint-offset_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/alignment-constraint-offset_2x.png
   :width: 100.0%
.. |image-baseline-constraint_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/baseline-constraint_2x.png
   :width: 100.0%
.. |image-layout-editor-guidelines| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-editor-guidelines.png
   :class: inline-icon
.. |image-guideline-constraint_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/guideline-constraint_2x.png
   :width: 100.0%
.. |image-layout-editor-guidelines| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-editor-guidelines.png
   :class: inline-icon
.. |image-window-properties| image:: https://developer.android.google.cn/static/studio/images/buttons/window-properties.png
   :class: inline-icon
.. |image-barrier-constraint_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/barrier-constraint_2x.png
   :width: 100.0%
.. |image-constraint-layout-editor-attributes-2x| image:: https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-editor-attributes-2x.png
   :width: 522px
.. |image-window-properties| image:: https://developer.android.google.cn/static/studio/images/buttons/window-properties.png
   :class: inline-icon
.. |image-layout-width-fixed| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-width-fixed.png
   :class: inline-icon
.. |image-layout-width-wrap| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-width-wrap.png
   :class: inline-icon
.. |image-layout-width-match| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-width-match.png
   :class: inline-icon
.. |image-constraint-layout-ratio-2x| image:: https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-ratio-2x.png
   :width: 420px
.. |image-constraint-layout-margin-icon-2x| image:: https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-margin-icon-2x.png
   :class: inline-icon
.. |image-constraint-layout-margin-2x| image:: https://developer.android.google.cn/static/images/training/constraint-layout/constraint-layout-margin-2x.png
   :width: 293px
.. |image-constraint-chain_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/constraint-chain_2x.png
.. |image-constraint-chain-styles_2x| image:: https://developer.android.google.cn/static/training/constraint-layout/images/constraint-chain-styles_2x.png
.. |image-layout-editor-action-chain| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-editor-action-chain.png
   :class: inline-icon
.. |image-layout-editor-infer| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-editor-infer.png
   :class: inline-icon
.. |image-layout-editor-autoconnect-on| image:: https://developer.android.google.cn/static/studio/images/buttons/layout-editor-autoconnect-on.png
   :class: inline-icon


/Create dynamic lists with RecyclerView
=======================================

.. https://developer.android.google.cn/develop/ui/views/layout/recyclerview?hl=en

.. container:: devsite-article-body

   .. rubric:: Create dynamic lists with RecyclerView - Part of Android Jetpack
      :name: create_dynamic_lists_with_recyclerview
      :class: page-title

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Lazy Lists and Grids → <https://developer.android.google.cn/jetpack/compose/lists#lazy>`__

      |image-android-compose-ui-logo|

   RecyclerView makes it easy to efficiently display large sets of data. You
   supply the data and define how each item looks, and the RecyclerView library
   dynamically creates the elements when they're needed.

   As the name implies, RecyclerView *recycles* those individual elements. When
   an item scrolls off the screen, RecyclerView doesn't destroy its view.
   Instead, RecyclerView reuses the view for new items that have scrolled
   onscreen. RecyclerView improves performance and your app's responsiveness,
   and it reduces power consumption.

   **Note:**\  RecyclerView is the name of both the class and the library that
   contains it. On this page, ``RecyclerView`` in ``code font`` always means the
   class in the RecyclerView library.

   .. rubric:: Key classes
      :name: key-classes

   Several classes work together to build your dynamic list.

   -  `RecyclerView <#androidx.recyclerview.widget.RecyclerView>`__
      is the `ViewGroup <#android.view.ViewGroup>`__ that contains
      the views corresponding to your data. It's a view itself, so you add
      ``RecyclerView`` to your layout the way you would add any other UI
      element.

   -  Each individual element in the list is defined by a *view holder* object.
      When the view holder is created, it doesn't have any data associated with
      it. After the view holder is created, the ``RecyclerView`` *binds* it to
      its data. You define the view holder by extending
      `RecyclerView.ViewHolder <#androidx.recyclerview.widget.RecyclerView.ViewHolder>`__.

   -  The ``RecyclerView`` requests views, and binds the views to their data, by
      calling methods in the *adapter.* You define the adapter by extending
      `RecyclerView.Adapter <#androidx.recyclerview.widget.RecyclerView.Adapter>`__.

   -  The *layout manager* arranges the individual elements in your list. You
      can use one of the layout managers provided by the RecyclerView library,
      or you can define your own. Layout managers are all based on the library's
      `LayoutManager <#androidx.recyclerview.widget.RecyclerView.LayoutManager>`__
      abstract class.

   You can see how all the pieces fit together in the `RecyclerView sample app (Kotlin) <https://github.com/android/views-widgets-samples/tree/main/RecyclerViewKotlin/>`__
   or `RecyclerView sample app (Java) <https://github.com/android/views-widgets-samples/tree/main/RecyclerView/>`__.

   .. rubric:: Steps for implementing your RecyclerView
      :name: steps-for-implementing

   If you're going to use RecyclerView, there are a few things you need to do.
   They are explained in detail in the following sections.

   #. Decide how the list or grid looks. Ordinarily, you can use one of the
      RecyclerView library's standard layout managers.

   #. Design how each element in the list looks and behaves. Based on this
      design, extend the ``ViewHolder`` class. Your version of ``ViewHolder``
      provides all the functionality for your list items. Your view holder is a
      wrapper around a ``View``, and that view is managed by ``RecyclerView``.

   #. Define the ``Adapter`` that associates your data with the ``ViewHolder``
      views.

   There are also `advanced customization options <#>`__ that let you tailor
   your RecyclerView to your exact needs.

   .. rubric:: Plan your layout
      :name: plan-your-layout

   The items in your RecyclerView are arranged by a
   `LayoutManager <#androidx.recyclerview.widget.RecyclerView.LayoutManager>`__
   class. The RecyclerView library provides three layout managers, which handle
   the most common layout situations:

   -  `LinearLayoutManager <#androidx.recyclerview.widget.LinearLayoutManager>`__
      arranges the items in a one-dimensional list.
   -  `GridLayoutManager <#androidx.recyclerview.widget.GridLayoutManager>`__
      arranges the items in a two-dimensional grid:

      -  If the grid is arranged vertically, ``GridLayoutManager`` tries to make
         all the elements in each row have the same width and height, but
         different rows can have different heights.
      -  If the grid is arranged horizontally, ``GridLayoutManager`` tries to
         make all the elements in each column have the same width and height,
         but different columns can have different widths.

   -  `StaggeredGridLayoutManager <#androidx.recyclerview.widget.StaggeredGridLayoutManager>`__
      is similar to ``GridLayoutManager``, but it does not require that items in
      a row have the same height (for vertical grids) or items in the same
      column have the same width (for horizontal grids). The result is that the
      items in a row or column can end up offset from each other.

   You also need to design the layout of the individual items. You need this
   layout when you design the view holder, as described in the next section.

   .. rubric:: Implement your adapter and view holder
      :name: implement-adapter

   Once you determine your layout, you need to implement your ``Adapter`` and
   ``ViewHolder``. These two classes work together to define how your data is
   displayed. The ``ViewHolder`` is a wrapper around a ``View`` that contains
   the layout for an individual item in the list. The ``Adapter`` creates
   ``ViewHolder`` objects as needed and also sets the data for those views. The
   process of associating views to their data is called *binding.*

   When you define your adapter, you override three key methods:

   -  `onCreateViewHolder() <#androidx.recyclerview.widget.RecyclerView.Adapter>`__:
      ``RecyclerView`` calls this method whenever it needs to create a new
      ``ViewHolder``. The method creates and initializes the ``ViewHolder`` and
      its associated ``View``, but does *not* fill in the view's contents—the
      ``ViewHolder`` has not yet been bound to specific data.

   -  `onBindViewHolder() <#androidx.recyclerview.widget.RecyclerView.Adapter>`__:
      ``RecyclerView`` calls this method to associate a ``ViewHolder`` with
      data. The method fetches the appropriate data and uses the data to fill in
      the view holder's layout. For example, if the ``RecyclerView`` displays a
      list of names, the method might find the appropriate name in the list and
      fill in the view holder's
      `TextView <#android.widget.TextView>`__ widget.

   -  `getItemCount() <#androidx.recyclerview.widget.RecyclerView.Adapter>`__:
      ``RecyclerView`` calls this method to get the size of the dataset. For
      example, in an address book app, this might be the total number of
      addresses. RecyclerView uses this to determine when there are no more
      items that can be displayed.

   Here's a typical example of a simple adapter with a nested ``ViewHolder``
   that displays a list of data. In this case, the RecyclerView displays a
   simple list of text elements. The adapter is passed an array of strings
   containing the text for the ``ViewHolder`` elements.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               class CustomAdapter(private val dataSet: Array<String>) :
                       RecyclerView.Adapter<CustomAdapter.ViewHolder>() {

                   /**
                    * Provide a reference to the type of views that you are using
                    * (custom ViewHolder)
                    */
                   class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
                       val textView: TextView

                       init {
                           // Define click listener for the ViewHolder's View
                           textView = view.findViewById(R.id.textView)
                       }
                   }

                   // Create new views (invoked by the layout manager)
                   override fun onCreateViewHolder(viewGroup: ViewGroup, viewType: Int): ViewHolder {
                       // Create a new view, which defines the UI of the list item
                       val view = LayoutInflater.from(viewGroup.context)
                               .inflate(R.layout.text_row_item, viewGroup, false)

                       return ViewHolder(view)
                   }

                   // Replace the contents of a view (invoked by the layout manager)
                   override fun onBindViewHolder(viewHolder: ViewHolder, position: Int) {

                       // Get element from your dataset at this position and replace the
                       // contents of the view with that element
                       viewHolder.textView.text = dataSet[position]
                   }

                   // Return the size of your dataset (invoked by the layout manager)
                   override fun getItemCount() = dataSet.size

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               public class CustomAdapter extends RecyclerView.Adapter<CustomAdapter.ViewHolder> {

                   private String[] localDataSet;

                   /**
                    * Provide a reference to the type of views that you are using
                    * (custom ViewHolder)
                    */
                   public static class ViewHolder extends RecyclerView.ViewHolder {
                       private final TextView textView;

                       public ViewHolder(View view) {
                           super(view);
                           // Define click listener for the ViewHolder's View

                           textView = (TextView) view.findViewById(R.id.textView);
                       }

                       public TextView getTextView() {
                           return textView;
                       }
                   }

                   /**
                    * Initialize the dataset of the Adapter
                    *
                    * @param dataSet String[] containing the data to populate views to be used
                    * by RecyclerView
                    */
                   public CustomAdapter(String[] dataSet) {
                       localDataSet = dataSet;
                   }

                   // Create new views (invoked by the layout manager)
                   @Override
                   public ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
                       // Create a new view, which defines the UI of the list item
                       View view = LayoutInflater.from(viewGroup.getContext())
                               .inflate(R.layout.text_row_item, viewGroup, false);

                       return new ViewHolder(view);
                   }

                   // Replace the contents of a view (invoked by the layout manager)
                   @Override
                   public void onBindViewHolder(ViewHolder viewHolder, final int position) {

                       // Get element from your dataset at this position and replace the
                       // contents of the view with that element
                       viewHolder.getTextView().setText(localDataSet[position]);
                   }

                   // Return the size of your dataset (invoked by the layout manager)
                   @Override
                   public int getItemCount() {
                       return localDataSet.length;
                   }
               }

   The layout for the each view item is defined in an XML layout file, as usual.
   In this case, the app has a ``text_row_item.xml`` file like this:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="@dimen/list_item_height"
          android:layout_marginLeft="@dimen/margin_medium"
          android:layout_marginRight="@dimen/margin_medium"
          android:gravity="center_vertical">

          <TextView
              android:id="@+id/textView"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="@string/element_text"/>
      </FrameLayout>

   .. rubric:: Next steps
      :name: next-steps

   The following code snippet shows how you can use the ``RecyclerView``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               class MainActivity : AppCompatActivity() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)

                       val dataset = arrayOf("January", "February", "March")
                       val customAdapter = CustomAdapter(dataset)

                       val recyclerView: RecyclerView = findViewById(R.id.recycler_view)
                       recyclerView.adapter = customAdapter

                   }

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               RecyclerView recyclerView = findViewById(R.id.recycler_view);
               recyclerView.setAdapter(customAdapter);

   The library also offers many ways to customize your implementation. For more
   information, see `Advanced RecyclerView customization <#>`__.

   .. rubric:: Additional resources
      :name: additional-resources

   For more information about testing on Android, consult the following
   resources.

   .. rubric:: Sample apps
      :name: resources-sample-apps

   -  `RecyclerView sample app (Kotlin) <https://github.com/android/views-widgets-samples/tree/main/RecyclerViewKotlin/>`__

   -  `RecyclerView sample app (Java) <https://github.com/android/views-widgets-samples/tree/main/RecyclerView/>`__

   -  `Sunflower demo app <https://github.com/googlesamples/android-sunflower>`__


Last updated 2024-05-03 UTC.



/Customize a dynamic list
=========================

.. https://developer.android.google.cn/develop/ui/views/layout/recyclerview-custom?hl=en

.. container:: devsite-article-body

   .. rubric:: Customize a dynamic list - Part of Android Jetpack
      :name: customizing

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Lazy Lists and Grids → <https://developer.android.google.cn/jetpack/compose/lists#lazy>`__

      |image-android-compose-ui-logo|

   You can customize
   `RecyclerView <#androidx.recyclerview.widget.RecyclerView>`__
   objects to meet your specific needs. The standard classes described in
   `Create dynamic lists with RecyclerView <#>`__ provide all the
   functionality that most developers need. In many cases, you only need to
   design the view for each view holder and write the code to update those views
   with the appropriate data. However, if your app has specific requirements,
   you can modify the standard behavior in a number of ways. This document
   describes some of the possible customizations.

   .. rubric:: Modify the layout
      :name: modifying-layout

   ``RecyclerView`` uses a layout manager to position the individual items on
   the screen and to determine when to reuse item views that are no longer
   visible to the user. To reuse—or *recycle*—a view, a layout manager might ask
   the adapter to replace the contents of the view with a different element from
   the dataset. Recycling views this way improves performance by avoiding the
   creation of unnecessary views or performing expensive
   `findViewById() <#android.app.Activity>`__
   lookups. The Android Support Library includes three standard layout managers,
   ach of which offers many customization options:

   -  `LinearLayoutManager <#androidx.recyclerview.widget.LinearLayoutManager>`__:
      arranges the items in a one-dimensional list. Using a ``RecyclerView``
      with ``LinearLayoutManager`` provides functionality like a
      `ListView <#android.widget.ListView>`__ layout.
   -  `GridLayoutManager <#androidx.recyclerview.widget.GridLayoutManager>`__:
      arranges the items in a two-dimensional grid, like the squares on a
      checkerboard. Using a ``RecyclerView`` with ``GridLayoutManager`` provides
      functionality like a `GridView <#android.widget.GridView>`__
      layout.
   -  `StaggeredGridLayoutManager <#androidx.recyclerview.widget.StaggeredGridLayoutManager>`__:
      arranges the items in a two-dimensional grid, with each column slightly
      offset from the one before, like the stars on an American flag.

   If these layout managers don't suit your needs, you can create your own by
   extending the
   `RecyclerView.LayoutManager <#androidx.recyclerview.widget.RecyclerView.LayoutManager>`__
   abstract class.

   .. rubric:: Add item animations
      :name: animations

   Whenever an item changes, ``RecyclerView`` uses an *animator* to change its
   appearance. This animator is an object that extends the abstract
   `RecyclerView.ItemAnimator <#androidx.recyclerview.widget.RecyclerView.ItemAnimator>`__
   class. By default, the ``RecyclerView`` uses
   `DefaultItemAnimator <#androidx.recyclerview.widget.DefaultItemAnimator>`__
   to provide the animation. If you want to provide custom animations, you can
   define your own animator object by extending ``RecyclerView.ItemAnimator``.

   .. rubric:: Enable list-item selection
      :name: select

   The
   `recyclerview-selection <#androidx.recyclerview.selection.package-summary>`__
   library lets users select items in a ``RecyclerView`` list using touch or
   mouse input. This lets you retain control over the visual presentation of a
   selected item. You can also retain control over policies controlling
   selection behavior, such as which items are eligible for selection and how
   many items can be selected.

   To add selection support to a ``RecyclerView`` instance, follow these steps:

   1. Determine which selection key type to use, then build an
      `ItemKeyProvider <#androidx.recyclerview.selection.ItemKeyProvider>`__.

      There are three key types you can use to identify selected items:

      -  `Parcelable <#android.os.Parcelable>`__ and its
         subclasses, like `Uri <#android.net.Uri>`__
      -  `String <#>`__
      -  `Long <#>`__

      For detailed information about selection-key types, see
      `SelectionTracker.Builder <#androidx.recyclerview.selection.SelectionTracker.Builder>`__.

   2. Implement
      `ItemDetailsLookup <#androidx.recyclerview.selection.ItemDetailsLookup>`__.

   3. Update item `View <#android.view.View>`__ objects in the
      ``RecyclerView`` to reflect whether the user selects or unselects them.

      The selection library doesn't provide a default visual decoration for the
      selected items. Provide this when you implement
      `onBindViewHolder() <#androidx.recyclerview.widget.RecyclerView.Adapter>`__.
      We recommend the following approach:

      -  In ``onBindViewHolder()``, call
         `setActivated() <#android.view.View>`__—**not**
         `setSelected() <#android.view.View>`__—on
         the ``View`` object with ``true`` or ``false``, depending on whether
         the item is selected.
      -  Update the styling of the view to represent the activated status. We
         recommend using a `color state list resource <#>`__ to configure
         the styling.

   4. Use `ActionMode <#androidx.appcompat.view.ActionMode>`__ to
      provide the user with tools to perform an action on the selection.

   5. Perform any interpreted secondary actions.

   6. Assemble everything with ``SelectionTracker.Builder``.

   7. Include selection in the `activity lifecycle <#>`__ events.

   .. rubric:: Additional resources
      :name: additional-resources

   See the following references for additional information.

   -  `Sunflower demo app <https://github.com/googlesamples/android-sunflower>`__, which uses
      ``RecyclerView``.
   -  `Use RecyclerView to display a scrollable list <https://developer.android.google.cn/odelabs/basic-android-kotlin-training-recyclerview-scrollable-list>`__
      codelab.
   -  `Android Kotlin Fundamentals: RecyclerView fundamentals <#>`__
      codelab.


Last updated 2024-05-03 UTC.



/Create a card-based layout
===========================

.. https://developer.android.google.cn/develop/ui/views/layout/cardview?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Card in Material 3 → <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#Card(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.foundation.BorderStroke,androidx.compose.ui.unit.Dp,kotlin.Function0)>`__

      |image-android-compose-ui-logo|

   **Note:**\  For a better user experience, see `Material Design Cards <https://m3.material.io/components/cards/overview>`__.
   Apps often need to display data in similarly styled containers, such as
   containers that hold information about the items in a list. The system
   provides the `CardView <#androidx.cardview.widget.CardView>`__
   API for you to show information in *cards* that have a consistent look across
   the platform. For example, cards have a default elevation above their
   containing view group, so the system draws shadows below them. Cards provide
   a way to contain a group of views while providing a consistent style for the
   container.

   .. figure::
      https://lh3.googleusercontent.com/eqldDGsvpjGd9_6OsnYI677l_W3Uj4NjBTCkttiBWxIx4GxjdX8DizUcEHDAzGYrBGM32lDrraxkYiBjLnnXly6D_UvUdyQ64FX4riSB-LYa3A=s0
      name: cardview-example
      :alt: A image showing a glimpse of an app UI based on cards
      :width: 50.0%

      **Figure 1.** An app UI based on cards.

   .. rubric:: Add the dependencies
      :name: AddDependency

   The ``CardView`` widget is part of `AndroidX <#>`__. To use
   it in your project, add the following dependency to your app module's
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.cardview:cardview:1.0.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.cardview:cardview:1.0.0")
               }

   .. rubric:: Create cards
      :name: CardView

   To use a ``CardView``, add it to your layout file. Use it as a view group to
   contain other views. In the following example, the ``CardView`` contains an
   ``ImageView`` and a few ``TextViews`` to display some information to the
   user:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <androidx.constraintlayout.widget.ConstraintLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:padding="16dp"
          android:background="#E0F7FA"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <androidx.cardview.widget.CardView
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toTopOf="parent">

              <androidx.constraintlayout.widget.ConstraintLayout
                  android:padding="4dp"
                  android:layout_width="match_parent"
                  android:layout_height="match_parent">

                  <ImageView
                      android:id="@+id/header_image"
                      android:layout_width="match_parent"
                      android:layout_height="200dp"
                      android:src="@drawable/logo"
                      app:layout_constraintEnd_toEndOf="parent"
                      app:layout_constraintStart_toStartOf="parent"
                      app:layout_constraintTop_toTopOf="parent" />

                  <TextView
                      android:id="@+id/title"
                      style="@style/TextAppearance.MaterialComponents.Headline3"
                      android:layout_width="match_parent"
                      android:layout_height="wrap_content"
                      android:layout_marginTop="4dp"
                      android:text="I'm a title"
                      app:layout_constraintEnd_toEndOf="parent"
                      app:layout_constraintStart_toStartOf="parent"
                      app:layout_constraintTop_toBottomOf="@id/header_image" />

                  <TextView
                      android:id="@+id/subhead"
                      style="@style/TextAppearance.MaterialComponents.Subtitle2"
                      android:layout_width="match_parent"
                      android:layout_height="wrap_content"
                      android:layout_marginTop="4dp"
                      android:text="I'm a subhead"
                      app:layout_constraintEnd_toEndOf="parent"
                      app:layout_constraintStart_toStartOf="parent"
                      app:layout_constraintTop_toBottomOf="@id/title" />

                  <TextView
                      android:id="@+id/body"
                      style="@style/TextAppearance.MaterialComponents.Body1"
                      android:layout_width="match_parent"
                      android:layout_height="wrap_content"
                      android:layout_marginTop="4dp"
                      android:text="I'm a supporting text. Very Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
                      app:layout_constraintEnd_toEndOf="parent"
                      app:layout_constraintStart_toStartOf="parent"
                      app:layout_constraintTop_toBottomOf="@id/subhead" />
              </androidx.constraintlayout.widget.ConstraintLayout>
          </androidx.cardview.widget.CardView>
      </androidx.constraintlayout.widget.ConstraintLayout>

   The previous code snippet produces something similar to the following,
   assuming you use the same Android logo image:

   .. figure:: https://developer.android.google.cn/static/images/cards/card_basic_example.png
      name: cards-basic-example
      :alt: An image showing a single card
      :width: 50.0%

      **Figure 2.** A basic example of CardView-based layout.

   The card in this example is drawn to the screen with a default elevation,
   which causes the system to draw a shadow under it. You can provide a custom
   elevation for a card with the ``card_view:cardElevation`` attribute. A card
   at a higher elevation has a more pronounced shadow, and a card at a lower
   elevation has a lighter shadow. ``CardView`` uses real elevation and dynamic
   shadows on Android 5.0 (API level 21) and higher.

   Use these properties to customize the appearance of the ``CardView`` widget:

   -  To set the corner radius in your layouts, use the
      ``card_view:cardCornerRadius`` attribute.
   -  To set the corner radius in your code, use the ``CardView.setRadius``
      method.
   -  To set the background color of a card, use the
      ``card_view:cardBackgroundColor`` attribute.


Last updated 2024-05-03 UTC.



/Create a two-pane layout
=========================

.. https://developer.android.google.cn/develop/ui/views/layout/twopane?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Adaptive Layouts → <https://developer.android.google.cn/jetpack/compose/layouts/adaptive>`__

      |image-android-compose-ui-logo|

   Every screen in your app must be responsive and adapt to the available space.
   You can `build a responsive UI with ``ConstraintLayout`` <#>`__ that lets a single-pane
   approach scale to many sizes, but larger devices might benefit from splitting
   the layout into multiple panes. For example, you might want a screen to show
   a list of items next to a list of details of the selected item.

   The
   `SlidingPaneLayout <#androidx.slidingpanelayout.widget.SlidingPaneLayout>`__
   component supports showing two panes side by side on larger devices and
   foldables while automatically adapting to show only one pane at a time on
   smaller devices such as phones.

   For device-specific guidance, see the `screen compatibility overview <#>`__.

   **Note:**\  For a step-by-step, hands-on experience creating a two-pane
   layout, see the `Adaptive Layouts <https://developer.android.google.cn/codelabs/basic-android-kotlin-training-adaptive-layouts>`__
   codelab.

   .. rubric:: Setup
      :name: setup

   To use ``SlidingPaneLayout``, include the following dependency in your app's
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.slidingpanelayout:slidingpanelayout:1.2.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.slidingpanelayout:slidingpanelayout:1.2.0")
               }

   .. rubric:: XML layout configuration
      :name: xml

   ``SlidingPaneLayout`` provides a horizontal, two-pane layout for use at the
   top level of a UI. This layout uses the first pane as a content list or a
   browser, subordinate to a primary detail view for displaying content in the
   other pane.

   .. figure:: https://developer.android.google.cn/static/images/ui/slidingpanelayout-example.png
      name: slidingpanelayout example
      :alt: An image showing an example of SlidingPaneLayout
      :width: 50.0%

      **Figure 1.** An example of a layout created with ``SlidingPaneLayout``.

   ``SlidingPaneLayout`` uses the width of the two panes to determine whether to
   show the panes side by side. For example, if the list pane is measured to
   have a minimum size of 200 dp and the detail pane needs 400 dp, then the
   ``SlidingPaneLayout`` automatically shows the two panes side by side as long
   as it has at least 600 dp of width available.

   Child views overlap if their combined width exceeds the available width in
   the ``SlidingPaneLayout``. In this case, the child views expand to fill the
   available width in the ``SlidingPaneLayout``. The user can slide the topmost
   view out of the way by dragging it back from the edge of the screen.

   If the views don't overlap, ``SlidingPaneLayout`` supports the use of the
   layout parameter ``layout_weight`` on child views to define how to divide
   leftover space after measurement is complete. This parameter is only relevant
   for width.

   On a foldable device that has space on the screen to show both views side by
   side, ``SlidingPaneLayout`` automatically adjusts the size of the two panes
   so they are positioned on either side of an overlapping fold or hinge. In
   this case, the set widths are considered the minimum width that must exist on
   each side of the folding feature. If there isn't enough space to maintain
   that minimum size, ``SlidingPaneLayout`` switches back to overlapping the
   views.

   Here is an example of using a ``SlidingPaneLayout`` that has a
   `RecyclerView <#androidx.recyclerview.widget.RecyclerView>`__
   as its left pane and a
   `FragmentContainerView <#androidx.fragment.app.FragmentContainerView>`__
   as its primary detail view to display content from the left pane:

   .. code:: prettyprint

      <!-- two_pane.xml -->
      <androidx.slidingpanelayout.widget.SlidingPaneLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         android:id="@+id/sliding_pane_layout"
         android:layout_width="match_parent"
         android:layout_height="match_parent">

         <!-- The first child view becomes the left pane. When the combined needed
              width, expressed using android:layout_width, doesn't fit on-screen at
              once, the right pane is permitted to overlap the left. -->
              
         <androidx.recyclerview.widget.RecyclerView
                   android:id="@+id/list_pane"
                   android:layout_width="280dp"
                   android:layout_height="match_parent"
                   android:layout_gravity="start"/>

         <!-- The second child becomes the right (content) pane. In this example,
              android:layout_weight is used to expand this detail pane to consume
              leftover available space when the entire window is wide enough to fit
              the left and right pane.-->
         <androidx.fragment.app.FragmentContainerView
             android:id="@+id/detail_container"
             android:layout_width="300dp"
             android:layout_weight="1"
             android:layout_height="match_parent"
             android:background="#ff333333"
             android:name="com.example.SelectAnItemFragment" />
      </androidx.slidingpanelayout.widget.SlidingPaneLayout>

   In this example, the ``android:name`` attribute on ``FragmentContainerView``
   adds the initial fragment to the detail pane, ensuring that users on
   large-screen devices don't see an empty right pane when the app first
   launches.

   .. rubric:: Programmatically swap out the detail pane
      :name: swap-detail

   In the preceding XML example, tapping an element in the ``RecyclerView``
   triggers a change in the detail pane. When using fragments, this requires a
   `FragmentTransaction <#androidx.fragment.app.FragmentTransaction>`__
   that replaces the right pane, calling
   `open() <#androidx.slidingpanelayout.widget.SlidingPaneLayout>`__
   on the ``SlidingPaneLayout`` to swap to the newly visible fragment:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // A method on the Fragment that owns the SlidingPaneLayout,called by the
               // adapter when an item is selected.
               fun openDetails(itemId: Int) {
                   childFragmentManager.commit {
                       setReorderingAllowed(true)
                       replace<ItemFragment>(R.id.detail_container,
                           bundleOf("itemId" to itemId))
                       // If it's already open and the detail pane is visible, crossfade
                       // between the fragments.
                       if (binding.slidingPaneLayout.isOpen) {
                           setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE)
                       }
                   }
                   binding.slidingPaneLayout.open()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // A method on the Fragment that owns the SlidingPaneLayout, called by the
               // adapter when an item is selected.
               void openDetails(int itemId) {
                   Bundle arguments = new Bundle();
                   arguments.putInt("itemId", itemId);
                   FragmentTransaction ft = getChildFragmentManager().beginTransaction()
                           .setReorderingAllowed(true)
                           .replace(R.id.detail_container, ItemFragment.class, arguments);
                   // If it's already open and the detail pane is visible, crossfade
                   // between the fragments.
                   if (binding.getSlidingPaneLayout().isOpen()) {
                       ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
                   }
                   ft.commit();
                   binding.getSlidingPaneLayout().open();
               }

   This code specifically doesn't call
   `addToBackStack() <#androidx.fragment.app.FragmentTransaction>`__
   on the ``FragmentTransaction``. This avoids building a back stack in the
   detail pane.

   .. rubric:: Navigation component implementation
      :name: navigation

   The examples in this page use ``SlidingPaneLayout`` directly and require you
   to manage fragment transactions manually. However, the `Navigation component <#>`__ provides a prebuilt implementation of a
   two-pane layout through
   `AbstractListDetailFragment <#androidx.navigation.fragment.AbstractListDetailFragment>`__,
   an API class that uses a ``SlidingPaneLayout`` under the hood to manage your
   list and detail panes.

   This lets you simplify your XML layout configuration. Instead of explicitly
   declaring a ``SlidingPaneLayout`` and both of your panes, your layout only
   needs a ``FragmentContainerView`` to hold your ``AbstractListDetailFragment``
   implementation:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/two_pane_container"
              <!-- The name of your AbstractListDetailFragment implementation.-->
              android:name="com.example.testapp.TwoPaneFragment"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              <!-- The navigation graph for your detail pane.-->
              app:navGraph="@navigation/two_pane_navigation" />
      </FrameLayout>

   Implement
   `onCreateListPaneView() <#androidx.navigation.fragment.AbstractListDetailFragment>`__
   and
   `onListPaneViewCreated() <#androidx.navigation.fragment.AbstractListDetailFragment>`__
   to provide a custom view for your list pane. For the detail pane,
   ``AbstractListDetailFragment`` uses a
   `NavHostFragment <#androidx.navigation.fragment.NavHostFragment>`__.
   This means you can define a `navigation graph <#>`__ that only contains the
   destinations to be shown in the detail pane. Then, you can use
   `NavController <#androidx.navigation.NavController>`__ to swap
   your detail pane between the destinations in the self-contained navigation
   graph:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun openDetails(itemId: Int) {
                   val navController = navHostFragment.navController
                   navController.navigate(
                       // Assume the itemId is the android:id of a destination in the graph.
                       itemId,
                       null,
                       NavOptions.Builder()
                           // Pop all destinations off the back stack.
                           .setPopUpTo(navController.graph.startDestination, true)
                           .apply {
                               // If it's already open and the detail pane is visible,
                               // crossfade between the destinations.
                               if (binding.slidingPaneLayout.isOpen) {
                                   setEnterAnim(R.animator.nav_default_enter_anim)
                                   setExitAnim(R.animator.nav_default_exit_anim)
                               }
                           }
                           .build()
                   )
                   binding.slidingPaneLayout.open()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               void openDetails(int itemId) {
                   NavController navController = navHostFragment.getNavController();
                   NavOptions.Builder builder = new NavOptions.Builder()
                           // Pop all destinations off the back stack.
                           .setPopUpTo(navController.getGraph().getStartDestination(), true);
                   // If it's already open and the detail pane is visible, crossfade between
                   // the destinations.
                   if (binding.getSlidingPaneLayout().isOpen()) {
                       builder.setEnterAnim(R.animator.nav_default_enter_anim)
                               .setExitAnim(R.animator.nav_default_exit_anim);
                   }
                   navController.navigate(
                       // Assume the itemId is the android:id of a destination in the graph.
                       itemId,
                       null,
                       builder.build()
                   );
                   binding.getSlidingPaneLayout().open();
               }

   The destinations in the detail pane's navigation graph must *not* be present
   in any outer, app-wide navigation graph. However, any deep links within the
   detail pane's navigation graph must be attached to the destination that hosts
   the ``SlidingPaneLayout``. This helps ensure that external deep links first
   navigate to the ``SlidingPaneLayout`` destination and then navigate to the
   correct detail pane destination.

   See the `TwoPaneFragment example <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:navigation/integration-tests/testapp/src/main/java/androidx/navigation/testapp/TwoPaneFragment.kt>`__
   for a full implementation of a two-pane layout using the Navigation
   component.

   .. rubric:: Integrate with the system back button
      :name: system-back

   On smaller devices where the list and detail panes overlap, make sure the
   system back button takes the user from the detail pane back to the list pane.
   Do this by `providing custom back navigation <#>`__ and connecting an
   `OnBackPressedCallback <#androidx.activity.OnBackPressedCallback>`__
   to the current state of the ``SlidingPaneLayout``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TwoPaneOnBackPressedCallback(
                   private val slidingPaneLayout: SlidingPaneLayout
               ) : OnBackPressedCallback(
                   // Set the default 'enabled' state to true only if it is slidable, such as
                   // when the panes overlap, and open, such as when the detail pane is
                   // visible.
                   slidingPaneLayout.isSlideable && slidingPaneLayout.isOpen
               ), SlidingPaneLayout.PanelSlideListener {

                   init {
                       slidingPaneLayout.addPanelSlideListener(this)
                   }

                   override fun handleOnBackPressed() {
                       // Return to the list pane when the system back button is tapped.
                       slidingPaneLayout.closePane()
                   }

                   override fun onPanelSlide(panel: View, slideOffset: Float) { }

                   override fun onPanelOpened(panel: View) {
                       // Intercept the system back button when the detail pane becomes
                       // visible.
                       isEnabled = true
                   }

                   override fun onPanelClosed(panel: View) {
                       // Disable intercepting the system back button when the user returns to
                       // the list pane.
                       isEnabled = false
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class TwoPaneOnBackPressedCallback extends OnBackPressedCallback
                       implements SlidingPaneLayout.PanelSlideListener {

                   private final SlidingPaneLayout mSlidingPaneLayout;

                   TwoPaneOnBackPressedCallback(@NonNull SlidingPaneLayout slidingPaneLayout) {
                       // Set the default 'enabled' state to true only if it is slideable, such
                       // as when the panes overlap, and open, such as when the detail pane is
                       // visible.
                       super(slidingPaneLayout.isSlideable() && slidingPaneLayout.isOpen());
                       mSlidingPaneLayout = slidingPaneLayout;
                       slidingPaneLayout.addPanelSlideListener(this);
                   }

                   @Override
                   public void handleOnBackPressed() {
                       // Return to the list pane when the system back button is tapped.
                       mSlidingPaneLayout.closePane();
                   }

                   @Override
                   public void onPanelSlide(@NonNull View panel, float slideOffset) { }

                   @Override
                   public void onPanelOpened(@NonNull View panel) {
                       // Intercept the system back button when the detail pane becomes
                       // visible.
                       setEnabled(true);
                   }

                   @Override
                   public void onPanelClosed(@NonNull View panel) {
                       // Disable intercepting the system back button when the user returns to
                       // the list pane.
                       setEnabled(false);
                   }
               }

   You can add the callback to the
   `OnBackPressedDispatcher <#androidx.activity.OnBackPressedDispatcher>`__
   using
   `addCallback() <#androidx.activity.OnBackPressedDispatcher>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TwoPaneFragment : Fragment(R.layout.two_pane) {

                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val binding = TwoPaneBinding.bind(view)

                       // Connect the SlidingPaneLayout to the system back button.
                       requireActivity().onBackPressedDispatcher.addCallback(viewLifecycleOwner,
                           TwoPaneOnBackPressedCallback(binding.slidingPaneLayout))

                       // Set up the RecyclerView adapter.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class TwoPaneFragment extends Fragment {

                   public TwoPaneFragment() {
                       super(R.layout.two_pane);
                   }

                   @Override
                   public void onViewCreated(@NonNull View view,
                            @Nullable Bundle savedInstanceState) {
                       TwoPaneBinding binding = TwoPaneBinding.bind(view);

                       // Connect the SlidingPaneLayout to the system back button.
                       requireActivity().getOnBackPressedDispatcher().addCallback(
                           getViewLifecycleOwner(),
                           new TwoPaneOnBackPressedCallback(binding.getSlidingPaneLayout()));

                       // Set up the RecyclerView adapter.
                   }
               }

   .. rubric:: Lock mode
      :name: lock-mode

   ``SlidingPaneLayout`` always lets you manually call ``open()`` and
   `close() <#androidx.slidingpanelayout.widget.SlidingPaneLayout>`__
   to transition between the list and detail panes on phones. These methods have
   no effect if both panes are visible and don't overlap.

   When the list and detail panes overlap, users can swipe in both directions by
   default, freely switching between the two panes even when not using `gesture navigation <#>`__. You can control the swipe
   direction by setting the lock mode of the ``SlidingPaneLayout``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               binding.slidingPaneLayout.lockMode = SlidingPaneLayout.LOCK_MODE_LOCKED

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               binding.getSlidingPaneLayout().setLockMode(SlidingPaneLayout.LOCK_MODE_LOCKED);

   **Note:**\  The lock mode only controls what user gestures are possible. You
   can always open or close the ``SlidingPaneLayout`` programmatically,
   regardless of which lock mode is set.

   .. rubric:: Learn more
      :name: learn-more

   To learn more about designing layouts for different form factors, see the
   following documentation:

   -  `Screen compatibility overview <#>`__
   -  `Design for different form factors <#>`__

   .. rubric:: Additional resources
      :name: additional-resources

   -  `Adaptive Layouts codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-training-adaptive-layouts>`__
   -  `SlidingPaneLayout example <https://github.com/google-developer-training/basic-android-kotlin-training-sports/tree/starter>`__
      on GitHub.


Last updated 2024-04-15 UTC.



/Create a linear layout
=======================

.. https://developer.android.google.cn/develop/ui/views/layout/linear?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Column or Row → <https://developer.android.google.cn/jetpack/compose/layouts/basics>`__

      |image-android-compose-ui-logo|

   `LinearLayout <#android.widget.LinearLayout>`__ is a view group
   that aligns all children in a single direction, vertically or horizontally.
   You can specify the layout direction with the
   `android:orientation <#android.widget.LinearLayout>`__
   attribute.

   **Note:** For better performance and tooling support, `build your layout with ConstraintLayout <#>`__. Learn more about
   advantages of using ``ConstraintLayout`` by reading `Understanding the
   performance benefits of ConstraintLayout <https://android-developers.googleblog.com/2017/08/understanding-performance-benefits-of.html>`__.
   .. figure:: https://developer.android.google.cn/static/images/ui/linearlayout.png
      name: linear-layout
      :alt: An image showing a layout split in three vertical slices
      :width: 60.0%

      **Figure 1.** A ``LinearLayout`` with three horizontally oriented
      children.

   All children of a ``LinearLayout`` are stacked one after the other, so a
   vertical list only has one child per row, no matter how wide they are. A
   horizontal list is only one row high, and it's the height of the tallest
   child, plus padding. A ``LinearLayout`` respects *margins* between children,
   and the *gravity*—right, center, or left alignment—of each child.

   .. rubric:: Layout weight
      :name: Weight

   ``LinearLayout`` also supports assigning a *weight* to individual children
   with the
   `android:layout_weight <#android.widget.LinearLayout.LayoutParams>`__
   attribute. This attribute assigns an "importance" value to a view in terms of
   how much space it occupies on the screen. A larger weight value lets it
   expand to fill the remaining space in the parent view. Child views can
   specify a weight value, and any remaining space in the view group is assigned
   to children proportionately, based on their declared weight. The default
   weight is zero.

   .. rubric:: Equal distribution
      :name: equal-weight

   To create a linear layout in which each child uses the same amount of space
   on the screen, set the
   `android:layout_height <#android.view.ViewGroup.LayoutParams>`__
   of each view to ``"0dp"`` for a vertical layout, or the
   `android:layout_width <#android.view.ViewGroup.LayoutParams>`__
   of each view to ``"0dp"`` for a horizontal layout. Then set the
   ``android:layout_weight`` of each view to ``"1"``.

   .. rubric:: Unequal distribution
      :name: prioritize-weight

   You can also create linear layouts where the child elements use different
   amounts of space on the screen. Consider the following examples:

   -  Suppose you have three text fields: two with a weight value of 1, and a
      third with the default weight value of 0. The third text field, with the
      weight value of 0, occupies only the area required by its content. The
      other two text fields, with the weight value of 1, expand equally to fill
      the space that remains after the contents of all three fields are
      measured.
   -  If instead you have three text fields where two have a weight value of 1
      and the third has a weight of 2, then the space that remains after the
      contents of all three fields are measured is allocated as follows: half to
      the field with the weight value of 2, and half divided equally between the
      fields with the weight value of 1.

   The following figure and code snippet show how layout weights might work in a
   "send message" activity. The **To** field, **Subject** line, and **Send**
   button each take up only the height they need. The message area takes up the
   rest of the activity's height.

   .. figure:: https://developer.android.google.cn/static/images/ui/sample-linearlayout.png
      name: linerar-layout-2
      :alt: An image showing three EditTexts and a Button in a vertically
      oriented LinearLayout
      :width: 40.0%

      **Figure 2.** Three text fields and a button in a vertically oriented
      ``LinearLayout``.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:paddingLeft="16dp"
          android:paddingRight="16dp"
          android:orientation="vertical" >
          <EditText
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:hint="@string/to" />
          <EditText
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:hint="@string/subject" />
          <EditText
              android:layout_width="match_parent"
              android:layout_height="0dp"
              android:layout_weight="1"
              android:gravity="top"
              android:hint="@string/message" />
          <Button
              android:layout_width="100dp"
              android:layout_height="wrap_content"
              android:layout_gravity="end"
              android:text="@string/send" />
      </LinearLayout>

   For details about the attributes available to each child view of a
   ``LinearLayout``, see
   `LinearLayout.LayoutParams <#android.widget.LinearLayout.LayoutParams>`__.


Last updated 2024-04-15 UTC.



/Fill a layout with data
========================

.. https://developer.android.google.cn/develop/ui/views/layout/binding?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Lists and Grids → <https://developer.android.google.cn/jetpack/compose/lists#lazy>`__

      |image-android-compose-ui-logo|

   ``AdapterView`` is a `ViewGroup <#android.view.ViewGroup>`__
   that displays items loaded into an adapter. The most common type of adapter
   comes from an array-based data source.

   This guide shows how to complete several key steps related to setting up an
   adapter.

   .. rubric:: Fill the layout with data
      :name: FillingTheLayout

   To add data into the layout that you create in your app's UI, add code
   similar to the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val PROJECTION = arrayOf(Contacts.People._ID, People.NAME)
               ...

               // Get a Spinner and bind it to an ArrayAdapter that
               // references a String array.
               val spinner1: Spinner = findViewById(R.id.spinner1)
               val adapter1 = ArrayAdapter.createFromResource(
                       this, R.array.colors, android.R.layout.simple_spinner_item)
               adapter1.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
               spinner1.adapter = adapter1

               // Load a Spinner and bind it to a data query.
               val spinner2: Spinner = findViewById(R.id.spinner2)
               val cursor: Cursor = managedQuery(People.CONTENT_URI, PROJECTION, null, null, null)
               val adapter2 = SimpleCursorAdapter(this,
                       // Use a template that displays a text view
                       android.R.layout.simple_spinner_item,
                       // Give the cursor to the list adapter
                       cursor,
                       // Map the NAME column in the people database to...
                       arrayOf(People.NAME),
                       // The "text1" view defined in the XML template
                       intArrayOf(android.R.id.text1))
               adapter2.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
               spinner2.adapter = adapter2

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Get a Spinner and bind it to an ArrayAdapter that
               // references a String array.
               Spinner s1 = (Spinner) findViewById(R.id.spinner1);
               ArrayAdapter adapter = ArrayAdapter.createFromResource(
                   this, R.array.colors, android.R.layout.simple_spinner_item);
               adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
               s1.setAdapter(adapter);

               // Load a Spinner and bind it to a data query.
               private static String[] PROJECTION = new String[] {
                       People._ID, People.NAME
                   };

               Spinner s2 = (Spinner) findViewById(R.id.spinner2);
               Cursor cur = managedQuery(People.CONTENT_URI, PROJECTION, null, null);

               SimpleCursorAdapter adapter2 = new SimpleCursorAdapter(this,
                   android.R.layout.simple_spinner_item, // Use a template
                                                         // that displays a
                                                         // text view
                   cur, // Give the cursor to the list adapter
                   new String[] {People.NAME}, // Map the NAME column in the
                                                        // people database to...
                   new int[] {android.R.id.text1}); // The "text1" view defined in
                                                    // the XML template

               adapter2.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
               s2.setAdapter(adapter2);

   Note that it is necessary to have the People._ID column in projection used
   with CursorAdapter or else you will get an exception.

   If, during the course of your application's life, you change the underlying
   data that is read by your Adapter, you should call
   `notifyDataSetChanged() <#android.widget.ArrayAdapter>`__.
   This will notify the attached View that the data has been changed and it
   should refresh itself.

   **Note:** With Android Studio 3.6 and higher, the `view binding <#>`__ feature can replace
   ``findViewById()`` calls and provides compile-time type safety for code that
   interacts with views. Consider using view binding instead of
   ``findViewById()``.

   .. rubric:: Handle user selections
      :name: HandlingUserSelections

   You handle the user's selection by setting the class's
   `AdapterView.OnItemClickListener <#android.widget.AdapterView.OnItemClickListener>`__
   member to a listener and catching the selection changes.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val historyView: ListView = findViewById(R.id.history)
               historyView.onItemClickListener = AdapterView.OnItemClickListener { parent, view, position, id ->
                   Toast.makeText(context, "You've got an event", Toast.LENGTH_SHORT).show()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a message handling object as an anonymous class.
               private OnItemClickListener messageClickedHandler = new OnItemClickListener() {
                   public void onItemClick(AdapterView parent, View v, int position, long id)
                   {
                       // Display a messagebox.
                       Toast.makeText(context,"You've got an event",Toast.LENGTH_SHORT).show();
                   }
               };

               // Now hook into our object and set its onItemClickListener member
               // to our class handler object.
               historyView = (ListView)findViewById(R.id.history);
               historyView.setOnItemClickListener(messageClickedHandler);

   .. container:: special

      For more discussion see the
      `Spinner <#>`__ topic.


Last updated 2024-04-15 UTC.



/Create a relative layout
=========================

.. https://developer.android.google.cn/develop/ui/views/layout/relative?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `ConstraintLayout in Compose → <https://developer.android.google.cn/jetpack/compose/layouts/constraintlayout>`__

      |image-android-compose-ui-logo|

   `RelativeLayout <#android.widget.RelativeLayout>`__ is a view
   group that displays child views in relative positions. The position of each
   view can be specified as relative to sibling elements (such as to the left-of
   or below another view) or in positions relative to the parent
   `RelativeLayout <#android.widget.RelativeLayout>`__ area (such
   as aligned to the bottom, left or center).

   **Note:** For better performance and tooling support, you should instead
   `build your layout with ConstraintLayout <#>`__.

   |image-relativelayout|
   A `RelativeLayout <#android.widget.RelativeLayout>`__ is a very
   powerful utility for designing a user interface because it can eliminate
   nested view groups and keep your layout hierarchy flat, which improves
   performance. If you find yourself using several nested
   `LinearLayout <#android.widget.LinearLayout>`__ groups, you may
   be able to replace them with a single
   `RelativeLayout <#android.widget.RelativeLayout>`__.

   .. rubric:: Positioning Views
      :name: Position

   `RelativeLayout <#android.widget.RelativeLayout>`__ lets child
   views specify their position relative to the parent view or to each other
   (specified by ID). So you can align two elements by right border, or make one
   below another, centered in the screen, centered left, and so on. By default,
   all child views are drawn at the top-left of the layout, so you must define
   the position of each view using the various layout properties available from
   `RelativeLayout.LayoutParams <#android.widget.RelativeLayout.LayoutParams>`__.

   Some of the many layout properties available to views in a
   `RelativeLayout <#android.widget.RelativeLayout>`__ include:

   `android:layout_alignParentTop <#android.widget.RelativeLayout.LayoutParams>`__
      If ``"true"``, makes the top edge of this view match the top edge of the
      parent.
   `android:layout_centerVertical <#android.widget.RelativeLayout.LayoutParams>`__
      If ``"true"``, centers this child vertically within its parent.
   `android:layout_below <#android.widget.RelativeLayout.LayoutParams>`__
      Positions the top edge of this view below the view specified with a
      resource ID.
   `android:layout_toRightOf <#android.widget.RelativeLayout.LayoutParams>`__
      Positions the left edge of this view to the right of the view specified
      with a resource ID.

   These are just a few examples. All layout attributes are documented at
   `RelativeLayout.LayoutParams <#android.widget.RelativeLayout.LayoutParams>`__.

   The value for each layout property is either a boolean to enable a layout
   position relative to the parent
   `RelativeLayout <#android.widget.RelativeLayout>`__ or an ID
   that references another view in the layout against which the view should be
   positioned.

   In your XML layout, dependencies against other views in the layout can be
   declared in any order. For example, you can declare that "view1" be
   positioned below "view2" even if "view2" is the last view declared in the
   hierarchy. The example below demonstrates such a scenario.

   .. rubric:: Example
      :name: Example

   Each of the attributes that control the relative position of each view are
   emphasized.

   .. container:: attempt-right

      |image-sample-relativelayout|

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:paddingLeft="16dp"
          android:paddingRight="16dp" >
          <EditText
              android:id="@+id/name"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:hint="@string/reminder" />
          <Spinner
              android:id="@+id/dates"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:layout_below="@id/name"
              android:layout_alignParentLeft="true"
              android:layout_toLeftOf="@+id/times" />
          <Spinner
              android:id="@id/times"
              android:layout_width="96dp"
              android:layout_height="wrap_content"
              android:layout_below="@id/name"
              android:layout_alignParentRight="true" />
          <Button
              android:layout_width="96dp"
              android:layout_height="wrap_content"
              android:layout_below="@id/times"
              android:layout_alignParentRight="true"
              android:text="@string/done" />
      </RelativeLayout>

   For details about all the layout attributes available to each child view of a
   `RelativeLayout <#android.widget.RelativeLayout>`__, see
   `RelativeLayout.LayoutParams <#android.widget.RelativeLayout.LayoutParams>`__.


Last updated 2024-04-15 UTC.

.. |image-relativelayout| image:: https://developer.android.google.cn/static/images/ui/relativelayout.png
.. |image-sample-relativelayout| image:: https://developer.android.google.cn/static/images/ui/sample-relativelayout.png


/About layout performance
=========================

.. https://developer.android.google.cn/develop/ui/views/layout/improving-layouts?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Performance in Compose → <https://developer.android.google.cn/jetpack/compose/performance>`__

      |image-android-compose-ui-logo|

   .. container:: video-wrapper

   Layouts are a key part of Android applications that directly affect the user
   experience. If implemented poorly, your layout can make your app
   memory-intensive with slow UIs. The Android SDK includes tools to help
   identify problems in your layout performance. With this documentation, you
   can implement smooth scrolling interfaces with a minimal memory footprint.

   .. rubric:: Lessons
      :name: lessons

   `Optimize layout hierarchies <#>`__
      In the same way that a complex web page can slow down load time, a complex
      layout hierarchy can also cause performance problems. This documentation
      shows how you can use SDK tools to inspect your layout and discover
      performance bottlenecks.
   `Reuse layouts with <include> <#>`__
      If your application UI repeats certain layout constructs in multiple
      places, this documentation shows you how to create efficient, reusable
      layout constructs and include them in the appropriate UI layouts.
   `Load views on demand <#>`__
      Beyond including one layout component within another layout, you might
      want to make the included layout visible only when it's needed after the
      activity is running. This documentation shows how you can improve your
      layout's initialization performance by loading portions of your layout on
      demand.


Last updated 2024-04-15 UTC.



/Optimize layout hierarchies
============================

.. https://developer.android.google.cn/develop/ui/views/layout/improving-layouts/optimizing-layouts?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Layout Inspector in Compose → <https://developer.android.google.cn/jetpack/compose/tooling/layout-inspector>`__

      |image-android-compose-ui-logo|

   It's a common misconception that using the basic layout structures leads to
   the most efficient layouts. However, each widget and layout you add to your
   app requires initialization, layout, and drawing. For example, using nested
   instances of `LinearLayout <#android.widget.LinearLayout>`__
   can lead to an excessively deep view hierarchy. Furthermore, nesting several
   instances of ``LinearLayout`` that use the ``layout_weight`` parameter can be
   especially expensive, as each child needs to be measured twice. This is
   particularly important when the layout is inflated repeatedly, such as when
   used in a
   `RecyclerView <#androidx.recyclerview.widget.RecyclerView>`__.

   This document shows how to use `Layout Inspector <#>`__ and
   `lint <#>`__ to examine and optimize your layout.

   .. rubric:: Inspect your layout
      :name: Inspect

   The Android SDK tools includes the `Layout Inspector <#>`__ tool, which lets you analyze
   your layout while your app is running. Using this tool helps you discover
   inefficiencies in the layout performance.

   Layout Inspector lets you select running processes on a connected device or
   emulator, then display the layout tree. The traffic lights on each block
   represent its Measure, Layout, and Draw performance, helping you identify
   potential issues.

   For example, figure 1 shows a layout that's used as an item in a
   ``RecyclerView``. This layout shows a small bitmap image on the left and two
   stacked items of text on the right. It is especially important that layouts
   like this that are inflated multiple times are optimized, as the performance
   benefits are multiplied.

   .. figure:: https://developer.android.google.cn/static/images/training/layout-listitem.png
      name: list-item
      :alt: An image showing a single item in a list: one image and two
      vertically aligned texts
      :width: 50.0%

      **Figure 1.** Conceptual layout for an item in a
      `RecyclerView <#androidx.recyclerview.widget.RecyclerView>`__.

   Layout Inspector shows a list of available devices and their running
   components. Choose your component from the **Windows** tab, and click
   **Layout Inspector** to view the layout hierarchy of the selected component.
   For example, figure 2 shows the layout for the list item illustrated by
   figure 1.

   .. figure:: https://developer.android.google.cn/static/images/training/hierarchy-linearlayout.png
      name: linerarlayout
      :alt: An image showing Layout Inspector and the LinearLayout composition
      :width: 80.0%

      **Figure 2.** Layout hierarchy for the layout in figure 1, using nested
      instances of ``LinearLayout``.

   .. rubric:: Revise your layout
      :name: Revise

   Because the preceding layout performance slows down due to a nested
   ``LinearLayout``, you might improve performance by flattening the layout—in
   other words, making the layout shallow and wide, rather than narrow and deep.
   A `ConstraintLayout <#>`__ as
   the root node allows for such layouts. When you convert this design to use
   ``ConstraintLayout``, the layout becomes a two-level hierarchy:

   .. code:: prettyprint

          <androidx.constraintlayout.widget.ConstraintLayout
            xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:app="http://schemas.android.com/apk/res-auto"
            xmlns:tools="http://schemas.android.com/tools"
            android:id="@+id/root"
            android:layout_width="match_parent"
            android:layout_height="52dp"
            android:background="#e4e6e4"
            android:padding="4dp">

            <ImageView
                android:id="@+id/image"
                android:layout_width="48dp"
                android:layout_height="48dp"
                android:background="#5c5c74"
                android:contentDescription="An example box"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent" />

            <TextView
                android:id="@+id/title"
                android:layout_width="0dp"
                android:layout_height="0dp"
                android:layout_marginStart="4dp"
                android:background="#745c74"
                app:layout_constraintBottom_toTopOf="@+id/subtitle"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toEndOf="@id/image"
                app:layout_constraintTop_toTopOf="parent" />

            <TextView
                android:id="@+id/subtitle"
                android:layout_width="0dp"
                android:layout_height="0dp"
                android:background="#7e8d6e"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="@id/title"
                app:layout_constraintTop_toBottomOf="@+id/title" />
        </androidx.constraintlayout.widget.ConstraintLayout>
          

   Inspection of the new layout looks like this:

   .. figure:: https://developer.android.google.cn/static/images/training/layout_inspector.png
      name: constraintlayout
      :alt: An image showing the 3D Layout Inspector
      :width: 100.0%

      **Figure 3.** Layout Inspector 3D mode.

   The benefits of this are multiplied, because this layout is used for every
   item in a list.

   Most of the difference is due to the use of ``layout_weight`` in the
   ``LinearLayout`` design, which can slow down measurement. This is one example
   of how each layout has appropriate uses. Carefully consider whether using
   layout weight is necessary.

   In some complex layouts, the system might waste effort measuring the same UI
   element more than once. This phenomenon is called *double taxation*. For more
   information about double taxation and how to prevent it, see `Performance and
   view hierarchies <#>`__.

   .. rubric:: Use lint
      :name: Lint

   It's good practice to run the `lint <#>`__ tool on your
   layout files to search for possible view hierarchy optimizations. Lint
   replaces the layoutopt tool and has greater functionality. The following are
   examples of lint `rules <http://tools.android.com/tips/lint-checks>`__:

   -  Use compound drawables. You can handle a ``LinearLayout`` that contains an
      `ImageView <#android.widget.ImageView>`__ and a
      `TextView <#android.widget.TextView>`__ more efficiently as
      a compound drawable.
   -  Merge root frame. If the root of a layout is a
      `FrameLayout <#android.widget.FrameLayout>`__ that doesn't
      provide background or padding, you can replace it with a merge tag, which
      is slightly more efficient.
   -  Remove useless leaves. You can remove a layout that has no children or no
      background—since it's invisible—for a flatter and more efficient layout
      hierarchy.
   -  Remove useless parents. You can remove a layout with a child that has no
      siblings, isn't a
      `ScrollView <#android.widget.ScrollView>`__ or a root
      layout, and doesn't have a background. You can also move the child view
      directly into the parent for a flatter and more efficient layout
      hierarchy.
   -  Avoid deep layouts. Layouts with too much nesting are bad for performance.
      Consider using flatter layouts, such as
      `ConstraintLayout <#>`__, to
      improve performance. The default maximum depth for lint checks is 10.

   Another benefit of the lint tool is its integration into Android Studio. Lint
   automatically runs whenever you compile your program. With Android Studio,
   you can also run lint inspections for a specific build variant or for all
   build variants.

   You can also manage inspection profiles and configure inspections within
   Android Studio with the **File > Settings > Project Settings** option. The
   Inspection Configuration page appears with the supported inspections:

   .. figure:: https://developer.android.google.cn/static/images/training/lint.png
      name: config
      :alt: An image showing Android Studio Inspections menu
      :width: 100.0%

      **Figure 4.** Inspection Configuration page.

   Lint can automatically fix some issues, provide suggestions for others, and
   jump directly to the offending code for review.

   For more information, see `Layouts <#>`__ and
   `Layout resource <#include-element>`__.


Last updated 2024-04-15 UTC.



/Reuse layouts with <include>
=============================

.. https://developer.android.google.cn/develop/ui/views/layout/improving-layouts/reusing-layouts?hl=en

.. container:: devsite-article-body

   Although Android offers a variety of widgets to provide small, reusable,
   interactive elements, you might also need to reuse larger components that
   require a special layout. To efficiently reuse complete layouts, use the
   ``<include>`` and ``<merge>`` tags to embed one layout inside another.

   This lets you create complex layouts—such as a yes or no button panel or a
   custom progress bar with description text. And it means that you can extract
   any elements of your application that are common across multiple layouts,
   manage them separately, and include them in each layout. While you can create
   individual UI components by writing a custom
   `View <#android.view.View>`__, you can do it more easily by
   reusing a layout file.

   .. rubric:: Create a reusable layout
      :name: Create

   Start by creating a new XML file and defining the layout you want to be able
   to reuse. For example, here's a layout that defines a title bar to include in
   each activity (``titlebar.xml``):

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:background="@color/titlebar_bg"
          tools:showIn="@layout/activity_main" >

          <ImageView android:layout_width="wrap_content"
                     android:layout_height="wrap_content"
                     android:src="@drawable/gafricalogo" />
      </FrameLayout>

   The root ``View`` must be exactly how you want it to appear in each layout
   where you plan to add this layout.

   **Note:** The
   `tools:showIn <#toolsshowin>`__ attribute in
   the preceding XML file is a special attribute that is used only at design
   time in Android Studio and is removed during compilation. It specifies a
   layout that *includes* this file, so you can preview and edit this file as it
   appears while embedded in a parent layout.

   .. rubric:: Use the <include> tag
      :name: Include

   Inside the layout where you want to add the reusable component, add the
   ``<include>`` tag. For example, here's a layout that includes the title bar
   from the preceding example:

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:background="@color/app_bg"
          android:gravity="center_horizontal">

          <include layout="@layout/titlebar"/>

          <TextView android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/hello"
                    android:padding="10dp" />
          ...
      </LinearLayout>

   You can also override all the layout parameters—any ``android:layout_*``
   attributes—of the included layout's root view by specifying them in the
   ``<include>`` tag. This is shown in the following example:

   .. code:: prettyprint

      <include android:id="@+id/news_title"
               android:layout_width="match_parent"
               android:layout_height="match_parent"
               layout="@layout/title"/>

   However, if you want to override layout attributes using the ``<include>``
   tag, also override ``android:layout_height`` and ``android:layout_width`` to
   make the other layout attributes take effect.

   .. rubric:: Use the <merge> tag
      :name: Merge

   The ``<merge>`` tag helps eliminate redundant view groups in your view
   hierarchy when including one layout within another. One use case of
   ``<merge>`` is when you implement a custom view by extending a ``ViewGroup``.

   For example, if your main layout is a vertical
   `LinearLayout <#android.widget.LinearLayout>`__ in which two
   consecutive views can be reused in multiple layouts, then the reusable layout
   where you place the two views requires its own root view. However, using
   another ``LinearLayout`` as the root for the reusable layout results in a
   vertical ``LinearLayout`` inside a vertical ``LinearLayout``. The nested
   ``LinearLayout`` serves no real purpose and slows down your UI performance.

   Instead, you can extend a ``LinearLayout`` to create a custom view and use a
   layout XML to describe its child views. The top tag in the XML is
   ``<merge>``, rather than ``LinearLayout``, as shown in the following example:

   .. code:: prettyprint

      <merge xmlns:android="http://schemas.android.com/apk/res/android">

          <Button
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:text="@string/add"/>

          <Button
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:text="@string/delete"/>

      </merge>

   When you include this layout in another layout—using the ``<include>``
   tag—the system ignores the ``<merge>`` element and places the two buttons
   directly in the layout, in place of the ``<include>`` tag.

   For more information about ``<include>``, see `Layout resource <#include-element>`__.


Last updated 2024-02-22 UTC.


/Load views on demand
=====================

.. https://developer.android.google.cn/develop/ui/views/layout/improving-layouts/loading-ondemand?hl=en

.. container:: devsite-article-body

   Sometimes your layout requires complex views that are rarely used. Whether
   they are item details, progress indicators, or undo messages, you can reduce
   memory usage and speed up rendering by loading the views only when they're
   needed.

   You can defer loading resources when you have complex views that your app
   needs in the future by defining a
   `ViewStub <#android.view.ViewStub>`__ for complex and rarely
   used views.

   .. rubric:: Define a ViewStub
      :name: ViewStub

   ``ViewStub`` is a lightweight view with no dimension that doesn't draw
   anything or participate in the layout. As such, it requires few resources to
   inflate and leave in a view hierarchy. Each ``ViewStub`` includes the
   ``android:layout`` attribute to specify the layout to inflate.

   Suppose you have a layout you want to load later in the user journey of your
   app:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <ImageView
              android:src="@drawable/logo"
              android:layout_width="match_parent"
              android:layout_height="match_parent"/>
      </FrameLayout>

   You can postpone loading using the following ``ViewStub``. To make it show or
   load anything, you must make it show the referred layout:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
      android:id="@+id/root"
      android:layout_width="match_parent"
      android:layout_height="match_parent">

      <ViewStub
          android:id="@+id/stub_import"
          android:inflatedId="@+id/panel_import"
          android:layout="@layout/heavy_layout_we_want_to_postpone"
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:layout_gravity="bottom" />
      </FrameLayout>

   .. rubric:: Load the ViewStub layout
      :name: Load

   The code snippets in the previous section produce something like figure 1:

   .. figure:: https://developer.android.google.cn/static/images/ui/viewstub_1.png
      name: viewstub_1
      :alt: An image of a empty screen
      :width: 30.0%

      **Figure 1.** Initial state of the screen: the ``ViewStub`` is hiding the
      heavy layout.

   When you want to load the layout specified by the ``ViewStub``, either set it
   to visible by calling
   `setVisibility(View.VISIBLE) <#android.view.View>`__
   or call `inflate() <#android.view.ViewStub>`__.

   The following code snippet simulates a postponed load. The screen loads as
   usual in the ``Activity`` and ``onCreate()``, then it shows the
   ``heavy_layout_we_want_to_postpone`` layout:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                 super.onCreate(savedInstanceState)
                 setContentView(R.layout.activity_old_xml)

                 Handler(Looper.getMainLooper())
                     .postDelayed({
                         findViewById<View>(R.id.stub_import).visibility = View.VISIBLE
                         
                         // Or val importPanel: View = findViewById<ViewStub>(R.id.stub_import).inflate()
                     }, 2000)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               void onCreate(savedInstanceState: Bundle?) {
                 super.onCreate(savedInstanceState);
                 setContentView(R.layout.activity_old_xml);

                 Handler(Looper.getMainLooper())
                     .postDelayed({
                         findViewById<View>(R.id.stub_import).visibility = View.VISIBLE
                         
                         // Or val importPanel: View = findViewById<ViewStub>(R.id.stub_import).inflate()
                     }, 2000);
               }

   .. figure:: https://developer.android.google.cn/static/images/ui/viewstub_2.png
      name: viewstub_2
      :width: 30.0%

      **Figure 2.** The heavy layout is visible.

   **Note:** The ``inflate()`` method returns the inflated ``View`` after it's
   complete, so you don't need to call
   `findViewById() <#android.app.Activity>`__ if
   you need to interact with the layout.
   Once visible or inflated, the ``ViewStub`` element is no longer part of the
   view hierarchy. It is replaced by the inflated layout, and the ID for the
   root view of that layout is specified by the ``android:inflatedId`` attribute
   of the ``ViewStub``. The ID ``android:id`` specified for the ``ViewStub`` is
   valid only until the ``ViewStub`` layout is visible or inflated.

   **Note:** A drawback of ``ViewStub`` is that it doesn't support the
   ``<merge>`` tag in the layouts to be inflated.
   For more information about this topic, see the blog post `Optimize with stubs <http://android-developers.blogspot.com/2009/03/android-layout-tricks-3-optimize-with.html>`__.


Last updated 2024-02-22 UTC.


/About custom view components
=============================

.. https://developer.android.google.cn/develop/ui/views/layout/custom-views/custom-components?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Custom Layouts in Compose → <https://developer.android.google.cn/jetpack/compose/layouts/custom>`__

      |image-android-compose-ui-logo|

   Android offers a sophisticated and powerful componentized model for building
   your UI, based on the fundamental layout classes
   `View <#android.view.View>`__ and
   `ViewGroup <#android.view.ViewGroup>`__. The platform includes
   a variety of prebuilt ``View`` and ``ViewGroup`` subclasses—called widgets
   and layouts, respectively—that you can use to construct your UI.

   A partial list of available widgets includes
   `Button <#android.widget.Button>`__,
   `TextView <#android.widget.TextView>`__,
   `EditText <#android.widget.EditText>`__,
   `ListView <#android.widget.ListView>`__,
   `CheckBox <#android.widget.CheckBox>`__,
   `RadioButton <#android.widget.RadioButton>`__,
   `Gallery <#android.widget.Gallery>`__,
   `Spinner <#android.widget.Spinner>`__, and the more
   special-purpose
   `AutoCompleteTextView <#android.widget.AutoCompleteTextView>`__,
   `ImageSwitcher <#android.widget.ImageSwitcher>`__, and
   `TextSwitcher <#android.widget.TextSwitcher>`__.

   Among the layouts available are
   `LinearLayout <#android.widget.LinearLayout>`__,
   `FrameLayout <#android.widget.FrameLayout>`__,
   `RelativeLayout <#android.widget.RelativeLayout>`__, and
   others. For more examples, see `Common layouts <https://developer.android.google.cn/develop/ui/views/layout/declaring-layout#CommonLayouts>`__.

   If none of the prebuilt widgets or layouts meet your needs, you can create
   your own ``View`` subclass. If you only need to make small adjustments to an
   existing widget or layout, you can subclass the widget or layout and override
   its methods.

   Creating your own ``View`` subclasses gives you precise control over the
   appearance and function of a screen element. To give an idea of the control
   you get with custom views, here are some examples of what you can do with
   them:

   -  You can create a completely custom-rendered ``View`` type—for example, a
      "volume control" knob, rendered using 2D graphics, that resembles an
      analog electronic control.
   -  You can combine a group of ``View`` components into a new single
      component, perhaps to make something like a combo box (a combination of
      popup list and free entry text field), a dual-pane selector control (a
      left and right pane with a list in each where you can reassign which item
      is in which list), and so on.
   -  You can override the way an ``EditText`` component is rendered on the
      screen. The
      `NotePad <https://android.googlesource.com/platform/development/+/master/samples/NotePad>`__
      sample app uses this to good effect to create a lined notepad page.
   -  You can capture other events—like key presses—and handle them in a custom
      way, such as for a game.

   The following sections explain how to create custom views and use them in
   your application. For detailed reference information, see the
   `View <#android.view.View>`__ class.

   .. rubric:: The basic approach
      :name: basic

   Here is a high-level overview of what you need to know to create your own
   ``View`` components:

   #. Extend an existing ``View`` class or subclass with your own class.
   #. Override some of the methods from the superclass. The superclass methods
      to override start with ``on``—for example,
      `onDraw() <#android.view.View>`__,
      `onMeasure() <#android.view.View>`__,
      and
      `onKeyDown() <#android.view.View>`__.
      This is similar to the ``on`` events in
      `Activity <#android.app.Activity>`__ or
      `ListActivity <#android.app.ListActivity>`__ that you
      override for lifecycle and other functionality hooks.
   #. Use your new extension class. Once completed, you can use your new
      extension class in place of the view it was based on.

   **Tip:** Extension classes can be defined as inner classes inside the
   activities that use them. This is useful, because it controls access to them,
   but isn't necessary. For example, perhaps you want to create a new public
   ``View`` for wider use in your application.

   .. rubric:: Fully customized components
      :name: custom

   You can create fully customized graphical components that appear however you
   want. Perhaps you want a graphical VU meter that looks like an old analog
   gauge, or a sing-along text view where a bouncing ball moves along the words
   as you sing along with a karaoke machine. You might want something that the
   built-in components can't do, no matter how you combine them.

   Fortunately, you can create components that look and behave any way you want,
   limited only by your imagination, the size of the screen, and the available
   processing power, bearing in mind that your application might have to run on
   something with significantly less power than your desktop workstation.

   To create a fully customized component, consider the following:

   -  The most generic view you can extend is ``View``, so you usually start by
      extending this to create your new super component.
   -  You can supply a constructor, which can take attributes and parameters
      from the XML, and you can consume your own such attributes and parameters,
      such as the color and range of the VU meter or the width and damping of
      the needle.
   -  You probably want to create your own event listeners, property accessors,
      and modifiers as well as more sophisticated behavior in your component
      class.
   -  You almost certainly want to override ``onMeasure()`` and are also likely
      to need to override ``onDraw()`` if you want the component to show
      something. While both have default behavior, the default ``onDraw()`` does
      nothing, and the default ``onMeasure()`` always sets a size of 100x100,
      which you probably don't want.
   -  You can also override other ``on`` methods, as required.

   .. rubric:: Extend onDraw() and onMeasure()
      :name: extend-ondraw-and-onmeasure

   The ``onDraw()`` method delivers a
   `Canvas <#android.graphics.Canvas>`__ on which you can
   implement anything you want: 2D graphics, other standard or custom
   components, styled text, or anything else you can think of.

   **Note:** This doesn't apply to 3D graphics. If you want to use 3D graphics,
   extend `SurfaceView <#android.view.SurfaceView>`__ instead of
   ``View`` and draw from a separate thread. See the ``GLSurfaceViewActivity``
   sample for details.
   ``onMeasure()`` is a little more involved. ``onMeasure()`` is a critical
   piece of the rendering contract between your component and its container.
   ``onMeasure()`` must be overridden to efficiently and accurately report the
   measurements of its contained parts. This is made slightly more complex by
   the limit requirements from the parent—which are passed into the
   ``onMeasure()`` method—and by the requirement to call the
   ``setMeasuredDimension()`` method with the measured width and height once
   they are calculated. If you don't call this method from an overridden
   ``onMeasure()`` method, it results in an exception at measurement time.

   At a high level, implementing ``onMeasure()`` looks something like this:

   -  The overridden ``onMeasure()`` method is called with width and height
      specifications, which are treated as requirements for the restrictions on
      the width and height measurements you produce. ``widthMeasureSpec`` and
      ``heightMeasureSpec`` parameters are both integer codes representing
      dimensions. A full reference to the kind of restrictions these
      specifications can require can be found in the reference documentation
      under
      `View.onMeasure(int, int) <#android.view.View>`__
      This reference documentation also explains the whole measurement
      operation.
   -  Your component's ``onMeasure()`` method calculates a measurement width and
      height, which are required to render the component. It must try to stay
      within the specifications passed in, although it can exceed them. In this
      case, the parent can choose what to do, including clipping, scrolling,
      throwing an exception, or asking the ``onMeasure()`` to try again, perhaps
      with different measurement specifications.
   -  When the width and height are calculated, call the
      ``setMeasuredDimension(int width, int height)`` method with the calculated
      measurements. Failure to do this results in an exception.

   Here's a summary of other standard methods that the framework calls on views:

   .. list-table::
      :header-rows: 1

      - 

         - Category
         - Methods
         - Description
      - 

         - Creation
         - Constructors
         - There is a form of the constructor that is called when the view is
            created from code and a form that is called when the view is
            inflated from a layout file. The second form parses and applies
            attributes defined in the layout file.
      - 

         - 
         - ``onFinishInflate()``
         - Called after a view and all of its children are inflated from XML.
      - 

         - Layout
         - ``onMeasure(int, int)``
         - Called to determine the size requirements for this view and all of
            its children.
      - 

         - 
         - ``onLayout(boolean, int, int, int, int)``
         - Called when this view must assign a size and position to all of its
            children.
      - 

         - 
         - ``onSizeChanged(int, int, int, int)``
         - Called when the size of this view is changed.
      - 

         - Drawing
         - ``onDraw(Canvas)``
         - Called when the view must render its content.
      - 

         - Event processing
         - ``onKeyDown(int, KeyEvent)``
         - Called when a key down event occurs.
      - 

         - 
         - ``onKeyUp(int, KeyEvent)``
         - Called when a key up event occurs.
      - 

         - 
         - ``onTrackballEvent(MotionEvent)``
         - Called when a trackball motion event occurs.
      - 

         - 
         - ``onTouchEvent(MotionEvent)``
         - Called when a touchscreen motion event occurs.
      - 

         - Focus
         - ``onFocusChanged(boolean, int, Rect)``
         - Called when the view gains or loses focus.
      - 

         - 
         - ``onWindowFocusChanged(boolean)``
         - Called when the window containing the view gains or loses focus.
      - 

         - Attaching
         - ``onAttachedToWindow()``
         - Called when the view is attached to a window.
      - 

         - 
         - ``onDetachedFromWindow()``
         - Called when the view is detached from its window.
      - 

         - 
         - ``onWindowVisibilityChanged(int)``
         - Called when the visibility of the window containing the view is
            changed.


   .. rubric:: Compound controls
      :name: compound

   If you don't want to create a completely customized component but instead are
   looking to put together a reusable component consisting of a group of
   existing controls, then creating a compound component (or compound control)
   might be best. In summary, this brings together a number of more atomic
   controls or views into a logical group of items that can be treated as a
   single thing. For example, a combo box can be a combination of a single line
   ``EditText`` field and an adjacent button with an attached popup list. If the
   user taps the button and selects something from the list, it populates the
   ``EditText`` field, but they can also type something directly into the
   ``EditText`` if they prefer.

   In Android, there are two other views readily available to do this:
   ``Spinner`` and ``AutoCompleteTextView``. Regardless, this concept for a
   combo box makes a good example.

   To create a compound component, do the following:

   -  Just like with an ``Activity``, use either the declarative (XML-based)
      approach to create the contained components or nest them programmatically
      from your code. The usual starting point is a ``Layout`` of some kind, so
      create a class that extends a ``Layout``. In the case of a combo box, you
      might use a ``LinearLayout`` with horizontal orientation. You can nest
      other layouts inside, so the compound component can be arbitrarily complex
      and structured.
   -  In the constructor for the new class, take whatever parameters the
      superclass expects and pass them through to the superclass constructor
      first. Then, you can set up the other views to use within your new
      component. This is where you create the ``EditText`` field and the popup
      list. You might introduce your own attributes and parameters into the XML
      that your constructor can pull and use.
   -  Optionally, create listeners for events that your contained views might
      generate. An example is a listener method for the list item click listener
      to update the contents of the ``EditText`` if a list selection is made.
   -  Optionally, create your own properties with accessors and modifiers. For
      example, let the ``EditText`` value be set initially in the component and
      query for its contents when needed.
   -  Optionally, override ``onDraw()`` and ``onMeasure()``. This is usually not
      necessary when extending a ``Layout``, since the layout has default
      behavior that likely works fine.
   -  Optionally, override other ``on`` methods, like ``onKeyDown()``, for
      example to choose certain default values from the popup list of a combo
      box when a certain key is tapped.

   There are advantages to using a ``Layout`` as the basis for a custom control,
   including the following:

   -  You can specify the layout using the declarative XML files, just like with
      an activity screen, or you can create views programmatically and nest them
      into the layout from your code.
   -  The ``onDraw()`` and ``onMeasure()`` methods, plus most of the other
      ``on`` methods, have suitable behavior, so you don't have to override
      them.
   -  You can quickly construct arbitrarily complex compound views and re-use
      them as if they were a single component.

   .. rubric:: Modify an existing view type
      :name: modifying

   If there is a component that is similar to what you want, you can extend that
   component and override the behavior that you want to change. You can do all
   the things you do with a fully customized component, but by starting with a
   more specialized class in the ``View`` hierarchy, you can get some behavior
   that does what you want for free.

   For example, the
   `NotePad <https://android.googlesource.com/platform/development/+/master/samples/NotePad>`__
   sample app demonstrates many aspects of using the Android platform. Among
   them is extending an ``EditText`` view to make a lined notepad. This isn't a
   perfect example, and the APIs for doing this might change, but it
   demonstrates the principles.

   If you haven't done so already, import the NotePad sample into Android Studio
   or look at the source using the link provided. In particular, see the
   definition of ``LinedEditText`` in the
   `NoteEditor.java <https://android.googlesource.com/platform/development/+/master/samples/NotePad/src/com/example/android/notepad/NoteEditor.java>`__
   file.

   Here are some things to note in this file:

   #. **The definition**

      | The class is defined with the following line:
      | ``public static class LinedEditText extends EditText``

      ``LinedEditText`` is defined as an inner class within the ``NoteEditor``
      activity, but it is public so that it can be accessed as
      ``NoteEditor.LinedEditText`` from outside the ``NoteEditor`` class.

      Also, ``LinedEditText`` is ``static``, meaning it doesn't generate the
      so-called "synthetic methods" that let it access data from the parent
      class. This means it behaves as a separate class rather than something
      strongly related to ``NoteEditor``. This is a cleaner way to create inner
      classes if they don't need access to state from the outer class. It keeps
      the generated class small and lets it be used easily from other classes.

      ``LinedEditText`` extends ``EditText``, which is the view to customize in
      this case. When you finish, the new class can substitute for a normal
      ``EditText`` view.

   #. **Class initialization**

      As always, the super is called first. This isn't a default constructor,
      but it is a parameterized one. The ``EditText`` is created with these
      parameters when it is inflated from an XML layout file. Thus, the
      constructor needs to take them and pass them to the superclass constructor
      as well.

   #. **Overridden methods**

      This example overrides only the ``onDraw()`` method, but you might need to
      override others as you create your own custom components.

      For this sample, overriding the ``onDraw()`` method lets you paint the
      blue lines on the ``EditText`` view canvas. The canvas is passed into the
      overridden ``onDraw()`` method. The ``super.onDraw()`` method is called
      before the method ends. The superclass method must be invoked. In this
      case, invoke it at the end after you paint the lines you want to include.

   #. **Custom component**

      You now have your custom component, but how can you use it? In the NotePad
      example, the custom component is used directly from the declarative
      layout, so look at ``note_editor.xml`` in the
      `res/layout <https://android.googlesource.com/platform/development/+/master/samples/NotePad/res/layout>`__
      folder:

      .. code:: prettyprint

         <view xmlns:android="http://schemas.android.com/apk/res/android"
             class="com.example.android.notepad.NoteEditor$LinedEditText"
             android:id="@+id/note"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             android:background="@android:color/transparent"
             android:padding="5dp"
             android:scrollbars="vertical"
             android:fadingEdge="vertical"
             android:gravity="top"
             android:textSize="22sp"
             android:capitalize="sentences"
         />

      The custom component is created as a generic view in the XML, and the
      class is specified using the full package. The inner class you define is
      referenced using the ``NoteEditor$LinedEditText`` notation, which is a
      standard way to refer to inner classes in the Java programming language.

      If your custom view component isn't defined as an inner class, you can
      declare the view component with the XML element name and exclude the
      ``class`` attribute. For example:

      .. code:: prettyprint

         <com.example.android.notepad.LinedEditText
           id="@+id/note"
           ... />

      Notice that the ``LinedEditText`` class is now a separate class file. When
      the class is nested in the ``NoteEditor`` class, this technique doesn't
      work.

      The other attributes and parameters in the definition are the ones passed
      into the custom component constructor and then passed through to the
      ``EditText`` constructor, so they are the same parameters you use for an
      ``EditText`` view. It's possible to add your own parameters as well.

   Creating custom components is only as complicated as you need it to be.

   A more sophisticated component can override even more ``on`` methods and
   introduce its own helper methods, substantially customizing its properties
   and behavior. The only limit is your imagination and what you need the
   component to do.


Last updated 2024-04-15 UTC.



/How Android draws Views
========================

.. https://developer.android.google.cn/guide/topics/ui/how-android-draws?hl=en

.. container:: devsite-article-body

   The Android framework asks an
   `Activity <#android.app.Activity>`__ to draw its layout when
   the ``Activity`` receives focus. The Android framework handles the procedure
   for drawing, but the ``Activity`` must provide the root node of its layout
   hierarchy.

   The Android framework draws the root node of the layout and measures and
   draws the layout tree. It draws by walking the tree and rendering each
   `View <#android.view.View>`__ that intersects the invalid
   region. Each `ViewGroup <#android.view.ViewGroup>`__ is
   responsible for requesting that each of its children be drawn, using the
   `draw() <#android.view.View>`__
   method, and each ``View`` is responsible for drawing itself. Because the tree
   is traversed pre-order, the framework draws parents before—in other words,
   *behind*—their children, and it draws siblings in the order they appear in
   the tree.

   **Note:** The framework doesn't draw ``View`` objects that aren't in a valid
   region. It also takes care of drawing the ``View`` background for you. You
   can force a ``View`` to draw by calling
   `invalidate() <#android.view.View>`__.
   The Android framework draws the layout in a two-pass process: a measure pass
   and a layout pass. The framework performs the measure pass in
   `measure(int, int) <#android.view.View>`__
   and performs a top-down traversal of the ``View`` tree. Each ``View`` pushes
   dimension specifications down the tree during the recursion. At the end of
   the measure pass, every ``View`` stores its measurements. The framework
   performs the second pass in
   `layout(int, int, int, int) <#android.view.View>`__
   and is also top-down. During this pass, each parent is responsible for
   positioning all of its children using the sizes computed in the measure pass.

   The two passes of the layout process are described in more detail in the
   following sections.

   .. rubric:: Initiate a measure pass
      :name: measure

   When a ``View`` object's
   `measure() <#android.view.View>`__ method
   returns, set its
   `getMeasuredWidth() <#android.view.View>`__
   and
   `getMeasuredHeight() <#android.view.View>`__
   values, along with those for all of the ``View`` object's descendants. A
   ``View`` object's measured width and measured height values must respect the
   constraints imposed by the ``View`` object's parents. This helps ensure that
   at the end of the measure pass, all parents accept all of their children's
   measurements.

   A parent ``View`` might call ``measure()`` more than once on its children.
   For example, the parent might measure the children once with unspecified
   dimensions to determine their preferred sizes. If the sum of the children's
   unconstrained sizes is too big or too small, the parent might call
   ``measure()`` again with values that constrain the children's sizes.

   The measure pass uses two classes to communicate dimensions. The
   `ViewGroup.LayoutParams <#android.view.ViewGroup.LayoutParams>`__
   class is how ``View`` objects communicate their preferred sizes and
   positions. The base ``ViewGroup.LayoutParams`` class describes the preferred
   width and height of the ``View``. For each dimension, it can specify one of
   the following:

   -  An exact dimension.
   -  `MATCH_PARENT <#android.view.ViewGroup.LayoutParams>`__,
      meaning the preferred size for the ``View`` is the size of its parent,
      minus padding.
   -  `WRAP_CONTENT <#android.view.ViewGroup.LayoutParams>`__,
      meaning the preferred size for the ``View`` is just big enough to enclose
      its content, plus padding.

   There are subclasses of ``ViewGroup.LayoutParams`` for different subclasses
   of ``ViewGroup``. For example,
   `RelativeLayout <#android.widget.RelativeLayout>`__ has its own
   subclass of ``ViewGroup.LayoutParams`` that includes the ability to center
   child ``View`` objects horizontally and vertically.

   `MeasureSpec <#android.view.View.MeasureSpec>`__ objects are
   used to push requirements down the tree from parent to child. A
   ``MeasureSpec`` can be in one of three modes:

   -  `UNSPECIFIED <#android.view.View.MeasureSpec>`__:
      the parent uses this to determine the target dimension of a child
      ``View``. For example, a
      `LinearLayout <#android.widget.LinearLayout>`__ might call
      ``measure()`` on its child with the height set to ``UNSPECIFIED`` and a
      width of
      `EXACTLY <#android.view.View.MeasureSpec>`__ 240 to
      find out how tall the child ``View`` wants to be, given a width of 240
      pixels.
   -  `EXACTLY <#android.view.View.MeasureSpec>`__: the
      parent uses this to impose an exact size on the child. The child must use
      this size and guarantee that all of its descendants fit within this size.
   -  `AT MOST <#android.view.View.MeasureSpec>`__: the
      parent uses this to impose a maximum size on the child. The child must
      guarantee that it and all of its descendants fit within this size.

   .. rubric:: Initiate a layout pass
      :name: layout

   To initiate a layout, call
   `requestLayout() <#android.view.View>`__. This
   method is typically called by a ``View`` on itself when it believes it can no
   longer fit within its bounds.

   .. rubric:: Implement a custom measurement and layout logic
      :name: custom-logic

   If you want to implement a custom measurement or layout logic, override the
   methods where the logic is implemented:
   `onMeasure(int, int) <#android.view.View>`__
   and
   `onLayout(boolean, int, int, int, int) <#android.view.View>`__.
   These methods are called by ``measure(int, int)`` and
   ``layout(int, int, int, int)``, respectively. Don't try to override the
   ``measure(int, int)`` or ``layout(int, int)`` methods—both of these methods
   are ``final``, so they can't be overridden.

   The following example shows how to do this in the
   `\`SplitLayout\` <https://github.com/android/user-interface-samples/blob/main/WindowManager/app/src/main/java/com/example/windowmanagersample/SplitLayout.kt>`__
   class from the
   `WindowManager <https://github.com/android/user-interface-samples/tree/main/WindowManager>`__
   sample app. If the ``SplitLayout`` has two or more child views, and the
   display has a fold, then it positions the two child views on either side of
   the fold. The following example shows a use case for overriding the
   measurement and layout, but for production, use
   `SlidingPaneLayout <#androidx.slidingpanelayout.widget.SlidingPaneLayout>`__
   if you want this behavior.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               /**
                * An example of split-layout for two views, separated by a display
                * feature that goes across the window. When both start and end views are
                * added, it checks whether there are display features that separate the area
                * in two—such as a fold or hinge—and places them side-by-side or
                * top-bottom.
                */
               class SplitLayout : FrameLayout {
                  private var windowLayoutInfo: WindowLayoutInfo? = null
                  private var startViewId = 0
                  private var endViewId = 0

                  private var lastWidthMeasureSpec: Int = 0
                  private var lastHeightMeasureSpec: Int = 0

                  ...

                  fun updateWindowLayout(windowLayoutInfo: WindowLayoutInfo) {
                     this.windowLayoutInfo = windowLayoutInfo
                     requestLayout()
                  }

                  override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {
                     val startView = findStartView()
                     val endView = findEndView()
                     val splitPositions = splitViewPositions(startView, endView)

                     if (startView != null && endView != null && splitPositions != null) {
                           val startPosition = splitPositions[0]
                           val startWidthSpec = MeasureSpec.makeMeasureSpec(startPosition.width(), EXACTLY)
                           val startHeightSpec = MeasureSpec.makeMeasureSpec(startPosition.height(), EXACTLY)
                           startView.measure(startWidthSpec, startHeightSpec)
                           startView.layout(
                              startPosition.left, startPosition.top, startPosition.right,
                              startPosition.bottom
                           )

                           val endPosition = splitPositions[1]
                           val endWidthSpec = MeasureSpec.makeMeasureSpec(endPosition.width(), EXACTLY)
                           val endHeightSpec = MeasureSpec.makeMeasureSpec(endPosition.height(), EXACTLY)
                           endView.measure(endWidthSpec, endHeightSpec)
                           endView.layout(
                              endPosition.left, endPosition.top, endPosition.right,
                              endPosition.bottom
                           )
                     } else {
                           super.onLayout(changed, left, top, right, bottom)
                     }
                  }

                  /**
                  * Gets the position of the split for this view.
                  * @return A rect that defines of split, or {@code null} if there is no split.
                  */
                  private fun splitViewPositions(startView: View?, endView: View?): Array? {
                     if (windowLayoutInfo == null || startView == null || endView == null) {
                           return null
                     }

                     // Calculate the area for view's content with padding.
                     val paddedWidth = width - paddingLeft - paddingRight
                     val paddedHeight = height - paddingTop - paddingBottom

                     windowLayoutInfo?.displayFeatures
                           ?.firstOrNull { feature -> isValidFoldFeature(feature) }
                           ?.let { feature ->
                              getFeaturePositionInViewRect(feature, this)?.let {
                                 if (feature.bounds.left == 0) { // Horizontal layout.
                                       val topRect = Rect(
                                          paddingLeft, paddingTop,
                                          paddingLeft + paddedWidth, it.top
                                       )
                                       val bottomRect = Rect(
                                          paddingLeft, it.bottom,
                                          paddingLeft + paddedWidth, paddingTop + paddedHeight
                                       )

                                       if (measureAndCheckMinSize(topRect, startView) &&
                                          measureAndCheckMinSize(bottomRect, endView)
                                       ) {
                                          return arrayOf(topRect, bottomRect)
                                       }
                                 } else if (feature.bounds.top == 0) { // Vertical layout.
                                       val leftRect = Rect(
                                          paddingLeft, paddingTop,
                                          it.left, paddingTop + paddedHeight
                                       )
                                       val rightRect = Rect(
                                          it.right, paddingTop,
                                          paddingLeft + paddedWidth, paddingTop + paddedHeight
                                       )

                                       if (measureAndCheckMinSize(leftRect, startView) &&
                                          measureAndCheckMinSize(rightRect, endView)
                                       ) {
                                          return arrayOf(leftRect, rightRect)
                                       }
                                 }
                              }
                           }

                     // You previously tried to fit the children and measure them. Since they
                     // don't fit, measure again to update the stored values.
                     measure(lastWidthMeasureSpec, lastHeightMeasureSpec)
                     return null
                  }

                  override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
                     super.onMeasure(widthMeasureSpec, heightMeasureSpec)
                     lastWidthMeasureSpec = widthMeasureSpec
                     lastHeightMeasureSpec = heightMeasureSpec
                  }

                  /**
                  * Measures a child view and sees if it fits in the provided rect.
                  * This method calls [View.measure] on the child view, which updates its
                  * stored values for measured width and height. If the view ends up with
                  * different values, measure again.
                  */
                  private fun measureAndCheckMinSize(rect: Rect, childView: View): Boolean {
                     val widthSpec = MeasureSpec.makeMeasureSpec(rect.width(), AT_MOST)
                     val heightSpec = MeasureSpec.makeMeasureSpec(rect.height(), AT_MOST)
                     childView.measure(widthSpec, heightSpec)
                     return childView.measuredWidthAndState and MEASURED_STATE_TOO_SMALL == 0 &&
                              childView.measuredHeightAndState and MEASURED_STATE_TOO_SMALL == 0
                  }

                  private fun isValidFoldFeature(displayFeature: DisplayFeature) =
                     (displayFeature as? FoldingFeature)?.let { feature ->
                           getFeaturePositionInViewRect(feature, this) != null
                     } ?: false 
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               /**
               * An example of split-layout for two views, separated by a display feature
               * that goes across the window. When both start and end views are added, it checks
               * whether there are display features that separate the area in two—such as
               * fold or hinge—and places them side-by-side or top-bottom.
               */
               public class SplitLayout extends FrameLayout {
                  @Nullable
                  private WindowLayoutInfo windowLayoutInfo = null;
                  private int startViewId = 0;
                  private int endViewId = 0;

                  private int lastWidthMeasureSpec = 0;
                  private int lastHeightMeasureSpec = 0;
                  
                  ...

                  void updateWindowLayout(WindowLayoutInfo windowLayoutInfo) {
                     this.windowLayoutInfo = windowLayoutInfo;
                     requestLayout();
                  }

                  @Override
                  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
                     @Nullable
                     View startView = findStartView();
                     @Nullable
                     View endView = findEndView();
                     @Nullable
                     List splitPositions = splitViewPositions(startView, endView);

                     if (startView != null && endView != null && splitPositions != null) {
                           Rect startPosition = splitPositions.get(0);
                           int startWidthSpec = MeasureSpec.makeMeasureSpec(startPosition.width(), EXACTLY);
                           int startHeightSpec = MeasureSpec.makeMeasureSpec(startPosition.height(), EXACTLY);
                           startView.measure(startWidthSpec, startHeightSpec);
                           startView.layout(
                                 startPosition.left,
                                 startPosition.top,
                                 startPosition.right,
                                 startPosition.bottom
                           );

                           Rect endPosition = splitPositions.get(1);
                           int endWidthSpec = MeasureSpec.makeMeasureSpec(endPosition.width(), EXACTLY);
                           int endHeightSpec = MeasureSpec.makeMeasureSpec(endPosition.height(), EXACTLY);
                           startView.measure(endWidthSpec, endHeightSpec);
                           startView.layout(
                                 endPosition.left,
                                 endPosition.top,
                                 endPosition.right,
                                 endPosition.bottom
                           );
                     } else {
                           super.onLayout(changed, left, top, right, bottom);
                     }
                  }

                  /**
                  * Gets the position of the split for this view.
                  * @return A rect that defines of split, or {@code null} if there is no split.
                  */
                  @Nullable
                  private List splitViewPositions(@Nullable View startView, @Nullable View endView) {
                     if (windowLayoutInfo == null || startView == null || endView == null) {
                           return null;
                     }

                     int paddedWidth = getWidth() - getPaddingLeft() - getPaddingRight();
                     int paddedHeight = getHeight() - getPaddingTop() - getPaddingBottom();

                     List displayFeatures = windowLayoutInfo.getDisplayFeatures();
                     
                     @Nullable
                     DisplayFeature feature = displayFeatures
                              .stream()
                              .filter(item ->
                                 isValidFoldFeature(item)
                              )
                              .findFirst()
                              .orElse(null);

                     if (feature != null) {
                           Rect position = SampleToolsKt.getFeaturePositionInViewRect(feature, this, true);
                           Rect featureBounds = feature.getBounds();
                           if (featureBounds.left == 0) { // Horizontal layout.
                              Rect topRect = new Rect(
                                       getPaddingLeft(),
                                       getPaddingTop(),
                                       getPaddingLeft() + paddedWidth,
                                       position.top
                              );
                              Rect bottomRect = new Rect(
                                       getPaddingLeft(),
                                       position.bottom,
                                       getPaddingLeft() + paddedWidth,
                                       getPaddingTop() + paddedHeight
                              );
                              if (measureAndCheckMinSize(topRect, startView) &&
                                       measureAndCheckMinSize(bottomRect, endView)) {
                                 ArrayList rects = new ArrayList();
                                 rects.add(topRect);
                                 rects.add(bottomRect);
                                 return rects;
                              }
                           } else if (featureBounds.top == 0) { // Vertical layout.
                              Rect leftRect = new Rect(
                                       getPaddingLeft(),
                                       getPaddingTop(),
                                       position.left,
                                       getPaddingTop() + paddedHeight
                              );
                              Rect rightRect = new Rect(
                                       position.right,
                                       getPaddingTop(),
                                       getPaddingLeft() + paddedWidth,
                                       getPaddingTop() + paddedHeight
                              );
                              if (measureAndCheckMinSize(leftRect, startView) &&
                                       measureAndCheckMinSize(rightRect, endView)) {
                                 ArrayList rects = new ArrayList();
                                 rects.add(leftRect);
                                 rects.add(rightRect);
                                 return rects;
                              }
                           }
                     }

                     // You previously tried to fit the children and measure them. Since
                     // they don't fit, measure again to update the stored values.
                     measure(lastWidthMeasureSpec, lastHeightMeasureSpec);
                     return null;
                  }

                  @Override
                  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                     super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                     lastWidthMeasureSpec = widthMeasureSpec;
                     lastHeightMeasureSpec = heightMeasureSpec;
                  }

                  /**
                  * Measures a child view and sees if it fits in the provided rect.
                  * This method calls [View.measure] on the child view, which updates
                  * its stored values for measured width and height. If the view ends up with
                  * different values, measure again.
                  */
                  private boolean measureAndCheckMinSize(Rect rect, View childView) {
                     int widthSpec = MeasureSpec.makeMeasureSpec(rect.width(), AT_MOST);
                     int heightSpec = MeasureSpec.makeMeasureSpec(rect.height(), AT_MOST);
                     childView.measure(widthSpec, heightSpec);
                     return (childView.getMeasuredWidthAndState() & MEASURED_STATE_TOO_SMALL) == 0 &&
                              (childView.getMeasuredHeightAndState() & MEASURED_STATE_TOO_SMALL) == 0;
                  }

                  private boolean isValidFoldFeature(DisplayFeature displayFeature) {
                     if (displayFeature instanceof FoldingFeature) {
                           return SampleToolsKt.getFeaturePositionInViewRect(displayFeature, this, true) != null;
                     } else {
                           return false;
                     }
                  }
               } 


Last updated 2024-02-22 UTC.



/Create a custom view class
===========================

.. https://developer.android.google.cn/develop/ui/views/layout/custom-views/create-view?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Custom Layouts in Compose → <https://developer.android.google.cn/jetpack/compose/layouts/custom>`__

      |image-android-compose-ui-logo|

   A well-designed custom view is like any other well-designed class. It
   encapsulates a specific set of functionality with a simple interface, uses
   CPU and memory efficiently, and so on. In addition to being a well-designed
   class, a custom view must do the following:

   -  Conform to Android standards.
   -  Provide custom styleable attributes that work with Android XML layouts.
   -  Send accessibility events.
   -  Be compatible with multiple Android platforms.

   The Android framework provides a set of base classes and XML tags to help you
   create a view that meets all of these requirements. This lesson discusses how
   to use the Android framework to create the core functionality of a view
   class.

   You can find additional information in `Custom view components <#>`__.

   .. rubric:: Subclass a view
      :name: subclassview

   All the view classes defined in the Android framework extend
   `View <#android.view.View>`__. Your custom view can also extend
   ``View`` directly, or you can save time by extending one of the existing view
   subclasses, such as `Button <#android.widget.Button>`__.

   To allow Android Studio to interact with your view, at a minimum you must
   provide a constructor that takes a
   `Context <#android.content.Context>`__ and an
   `AttributeSet <#android.util.AttributeSet>`__ object as
   parameters. This constructor allows the layout editor to create and edit an
   instance of your view.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class PieChart(context: Context, attrs: AttributeSet) : View(context, attrs)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class PieChart extends View {
                   public PieChart(Context context, AttributeSet attrs) {
                       super(context, attrs);
                   }
               }

   .. rubric:: Define custom attributes
      :name: customattr

   To add a built-in ``View`` to your user interface, specify it in an XML
   element and control its appearance and behavior with element attributes. You
   can also add and style custom views using XML. To enable this behavior in
   your custom view, do the following:

   -  Define custom attributes for your view in a ``<declare-styleable>``
      resource element.
   -  Specify values for the attributes in your XML layout.
   -  Retrieve attribute values at runtime.
   -  Apply the retrieved attribute values to your view.

   This section discusses how to define custom attributes and specify their
   values. The next section covers retrieving and applying the values at
   runtime.

   To define custom attributes, add ``<declare-styleable>`` resources to your
   project. It's customary to put these resources into a
   ``res/values/attrs.xml`` file. Here's an example of a ``attrs.xml`` file:

   .. code:: prettyprint

      <resources>
         <declare-styleable name="PieChart">
             <attr name="showText" format="boolean" />
             <attr name="labelPosition" format="enum">
                 <enum name="left" value="0"/>
                 <enum name="right" value="1"/>
             </attr>
         </declare-styleable>
      </resources>

   This code declares two custom attributes, ``showText`` and ``labelPosition``,
   that belong to a styleable entity named ``PieChart``. The name of the
   styleable entity is, by convention, the same name as the name of the class
   that defines the custom view. Although it's not necessary to follow this
   convention, many popular code editors depend on this naming convention to
   provide statement completion.

   Once you define custom attributes, you can use them in layout XML files just
   like built-in attributes. The only difference is that your custom attributes
   belong to a different namespace. Instead of belonging to the
   ``http://schemas.android.com/apk/res/android`` namespace, they belong to
   ``http://schemas.android.com/apk/res/[your package name]``. For example,
   here's how to use the attributes defined for ``PieChart``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:custom="http://schemas.android.com/apk/res-auto">
       <com.example.customviews.charting.PieChart
           custom:showText="true"
           custom:labelPosition="left" />
      </LinearLayout>

   To avoid having to repeat the long namespace URI, the sample uses an
   ``xmlns`` directive. This directive assigns the alias ``custom`` to the
   namespace ``http://schemas.android.com/apk/res/com.example.customviews``. You
   can choose any alias you want for your namespace.

   Notice the name of the XML tag that adds the custom view to the layout. It is
   the fully qualified name of the custom view class. If your view class is an
   inner class, further qualify it with the name of the view's outer class. For
   instance, the ``PieChart`` class has an inner class called ``PieView``. To
   use the custom attributes from this class, you use the tag
   ``com.example.customviews.charting.PieChart$PieView``.

   .. rubric:: Apply custom attributes
      :name: applyattr

   When a view is created from an XML layout, all the attributes in the XML tag
   are read from the resource bundle and passed into the view's constructor as
   an `AttributeSet <#android.util.AttributeSet>`__. Although it's
   possible to read values from the ``AttributeSet`` directly, doing so has some
   disadvantages:

   -  Resource references within attribute values are not resolved.
   -  Styles are not applied.

   Instead, pass the ``AttributeSet`` to
   `obtainStyledAttributes() <#android.content.res.Resources.Theme>`__.
   This method passes back a
   `TypedArray <#android.content.res.TypedArray>`__ array of
   values that are already dereferenced and styled.

   The Android resource compiler does a lot of work for you to make calling
   ``obtainStyledAttributes()`` easier. For each ``<declare-styleable>``
   resource in the ``res/`` directory, the generated ``R.java`` defines both an
   array of attribute IDs and a set of constants that define the index for each
   attribute in the array. You use the predefined constants to read the
   attributes from the ``TypedArray``. Here's how the ``PieChart`` class reads
   its attributes:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               init {
                   context.theme.obtainStyledAttributes(
                           attrs,
                           R.styleable.PieChart,
                           0, 0).apply {

                       try {
                           mShowText = getBoolean(R.styleable.PieChart_showText, false)
                           textPos = getInteger(R.styleable.PieChart_labelPosition, 0)
                       } finally {
                           recycle()
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public PieChart(Context context, AttributeSet attrs) {
                  super(context, attrs);
                  TypedArray a = context.getTheme().obtainStyledAttributes(
                       attrs,
                       R.styleable.PieChart,
                       0, 0);

                  try {
                      mShowText = a.getBoolean(R.styleable.PieChart_showText, false);
                      textPos = a.getInteger(R.styleable.PieChart_labelPosition, 0);
                  } finally {
                      a.recycle();
                  }
               }

   Note that ``TypedArray`` objects are a shared resource and must be recycled
   after use.

   .. rubric:: Add properties and events
      :name: addprop

   Attributes are a powerful way of controlling the behavior and appearance of
   views, but they can only be read when the view is initialized. To provide
   dynamic behavior, expose a property getter and setter pair for each custom
   attribute. The following snippet shows how ``PieChart`` exposes a property
   called ``showText``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun isShowText(): Boolean {
                   return mShowText
               }

               fun setShowText(showText: Boolean) {
                   mShowText = showText
                   invalidate()
                   requestLayout()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public boolean isShowText() {
                  return mShowText;
               }

               public void setShowText(boolean showText) {
                  mShowText = showText;
                  invalidate();
                  requestLayout();
               }

   Notice that ``setShowText`` calls
   `invalidate() <#android.view.View>`__ and
   `requestLayout() <#android.view.View>`__. These
   calls are crucial to ensure that the view behaves reliably. You need to
   invalidate the view after any change to its properties that might change its
   appearance, so that the system knows it needs to be redrawn. Likewise, you
   need to request a new layout if a property changes in a way that might affect
   the size or shape of the view. Forgetting these method calls can cause
   hard-to-find bugs.

   Custom views must also support event listeners to communicate important
   events. For instance, ``PieChart`` exposes a custom event called
   ``OnCurrentItemChanged`` to notify listeners that the user rotated the pie
   chart to focus on a new pie slice.

   It's easy to forget to expose properties and events, especially when you're
   the only user of the custom view. Taking time to carefully define your view's
   interface reduces future maintenance costs. A good rule to follow is to
   always expose any property that affects the visible appearance or behavior of
   your custom view.

   .. rubric:: Design for accessibility
      :name: accessibility

   Your custom view must support a wide range of users. This includes users with
   disabilities that prevent them from seeing or using a touchscreen. To support
   users with disabilities, do the following:

   -  Label your input fields using the ``android:contentDescription``
      attribute.
   -  Send accessibility events by calling
      `sendAccessibilityEvent() <#android.view.accessibility.AccessibilityEventSource>`__
      when appropriate.
   -  Support alternate controllers, such as a D-pad or trackball.

   For more information about creating accessible views, see `Make apps more accessible <#custom-views>`__.


Last updated 2024-04-15 UTC.



/Implement a custom drawing
===========================

.. https://developer.android.google.cn/develop/ui/views/layout/custom-views/custom-drawing?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Canvas in Compose → <https://developer.android.google.cn/jetpack/compose/graphics/draw/overview>`__

      |image-android-compose-ui-logo|

   The most important part of a custom view is its appearance. Custom drawing
   can be easy or complex according to your application's needs. This document
   covers some of the most common operations.

   For more information, see `Drawables overview <#>`__.

   .. rubric:: Override onDraw()
      :name: overrideondraw

   The most important step in drawing a custom view is to override the
   `onDraw() <#android.view.View>`__
   method. The parameter to ``onDraw()`` is a
   `Canvas <#android.graphics.Canvas>`__ object that the view can
   use to draw itself. The ``Canvas`` class defines methods for drawing text,
   lines, bitmaps, and many other graphics primitives. You can use these methods
   in ``onDraw()`` to create your custom user interface (UI).

   Start by creating a `Paint <#android.graphics.Paint>`__ object.
   The next section discusses ``Paint`` in more detail.

   .. rubric:: Create drawing objects
      :name: createobject

   The `android.graphics <#android.graphics.package-summary>`__
   framework divides drawing into two areas:

   -  *What* to draw, handled by ``Canvas``.
   -  *How* to draw, handled by ``Paint``.

   For example, ``Canvas`` provides a method to draw a line, and ``Paint``
   provides methods to define that line's color. ``Canvas`` has a method to draw
   a rectangle, and ``Paint`` defines whether to fill that rectangle with a
   color or leave it empty. ``Canvas`` defines shapes that you can draw on the
   screen, and ``Paint`` defines the color, style, font, and so forth of each
   shape you draw.

   Before you draw anything, create one or more ``Paint`` objects. The following
   example does this in a method called ``init``. This method is called from the
   constructor from Java, but it can be initialized inline in Kotlin.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @ColorInt
               private var textColor    // Obtained from style attributes.

               @Dimension
               private var textHeight   // Obtained from style attributes.

               private val textPaint = Paint(ANTI_ALIAS_FLAG).apply {
                   color = textColor
                   if (textHeight == 0f) {
                       textHeight = textSize
                   } else {
                       textSize = textHeight
                   }
               }

               private val piePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
                   style = Paint.Style.FILL
                   textSize = textHeight
               }

               private val shadowPaint = Paint(0).apply {
                   color = 0x101010
                   maskFilter = BlurMaskFilter(8f, BlurMaskFilter.Blur.NORMAL)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private Paint textPaint;
               private Paint piePaint;
               private Paint shadowPaint;

               @ColorInt
               private int textColor;       // Obtained from style attributes.

               @Dimension
               private float textHeight;    // Obtained from style attributes.

               private void init() {
                  textPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
                  textPaint.setColor(textColor);
                  if (textHeight == 0) {
                      textHeight = textPaint.getTextSize();
                  } else {
                      textPaint.setTextSize(textHeight);
                  }

                  piePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
                  piePaint.setStyle(Paint.Style.FILL);
                  piePaint.setTextSize(textHeight);

                  shadowPaint = new Paint(0);
                  shadowPaint.setColor(0xff101010);
                  shadowPaint.setMaskFilter(new BlurMaskFilter(8, BlurMaskFilter.Blur.NORMAL));
                  ...
               }

   Creating objects ahead of time is an important optimization. Views are
   redrawn frequently, and many drawing objects require expensive
   initialization. Creating drawing objects within your ``onDraw()`` method
   significantly reduces performance and can make your UI sluggish.

   .. rubric:: Handle layout events
      :name: layouteevent

   To properly draw your custom view, find out what size it is. Complex custom
   views often need to perform multiple layout calculations depending on the
   size and shape of their area on screen. Never make assumptions about the size
   of your view on the screen. Even if only one app uses your view, that app
   needs to handle different screen sizes, multiple screen densities, and
   various aspect ratios in both portrait and landscape mode.

   Although `View <#android.view.View>`__ has many methods for
   handling measurement, most of them don't need to be overridden. If your view
   doesn't need special control over its size, only override one method:
   `onSizeChanged() <#android.view.View>`__.

   ``onSizeChanged()`` is called when your view is first assigned a size, and
   again if the size of your view changes for any reason. Calculate positions,
   dimensions, and any other values related to your view's size in
   ``onSizeChanged()``, instead of recalculating them every time you draw. In
   the following example, ``onSizeChanged()`` is where the view calculates the
   bounding rectangle of the chart and the relative position of the text label
   and other visual elements.

   When your view is assigned a size, the layout manager assumes that the size
   includes the view's padding. Handle the padding values when you calculate
   your view's size. Here's a snippet from ``onSizeChanged()`` that shows how to
   do this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val showText    // Obtained from styled attributes.
               private val textWidth   // Obtained from styled attributes.

               override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
                   super.onSizeChanged(w, h, oldw, oldh)
                   // Account for padding.
                   var xpad = (paddingLeft + paddingRight).toFloat()
                   val ypad = (paddingTop + paddingBottom).toFloat()

                   // Account for the label.
                   if (showText) xpad += textWidth.toFloat()
                   val ww = w.toFloat() - xpad
                   val hh = h.toFloat() - ypad

                   // Figure out how big you can make the pie.
                   val diameter = Math.min(ww, hh)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private Boolean showText;    // Obtained from styled attributes.
               private int textWidth;       // Obtained from styled attributes.

               @Override
               protected void onSizeChanged(int w, int h, int oldw, int oldh) {
                   super.onSizeChanged(w, h, oldw, oldh);
                   // Account for padding.
                   float xpad = (float)(getPaddingLeft() + getPaddingRight());
                   float ypad = (float)(getPaddingTop() + getPaddingBottom());

                   // Account for the label.
                   if (showText) xpad += textWidth;

                   float ww = (float)w - xpad;
                   float hh = (float)h - ypad;

                   // Figure out how big you can make the pie.
                   float diameter = Math.min(ww, hh);
               }

   If you need finer control over your view's layout parameters, implement
   `onMeasure() <#android.view.View>`__.
   This method's parameters are
   `View.MeasureSpec <#android.view.View.MeasureSpec>`__ values
   that tell you how big your view's parent wants your view to be and whether
   that size is a hard maximum or just a suggestion. As an optimization, these
   values are stored as packed integers, and you use the static methods of
   ``View.MeasureSpec`` to unpack the information stored in each integer.

   Here's an example implementation of ``onMeasure()``. In this implementation,
   it attempts to make its area big enough to make the chart as big as its
   label:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
                   // Try for a width based on your minimum.
                   val minw: Int = paddingLeft + paddingRight + suggestedMinimumWidth
                   val w: Int = View.resolveSizeAndState(minw, widthMeasureSpec, 1)

                   // Whatever the width is, ask for a height that lets the pie get as big as
                   // it can.
                   val minh: Int = View.MeasureSpec.getSize(w) - textWidth.toInt() + paddingBottom + paddingTop
                   val h: Int = View.resolveSizeAndState(minh, heightMeasureSpec, 0)

                   setMeasuredDimension(w, h)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                  // Try for a width based on your minimum.
                  int minw = getPaddingLeft() + getPaddingRight() + getSuggestedMinimumWidth();
                  int w = resolveSizeAndState(minw, widthMeasureSpec, 1);

                  // Whatever the width is, ask for a height that lets the pie get as big as it
                  // can.
                  int minh = MeasureSpec.getSize(w) - (int)textWidth + getPaddingBottom() + getPaddingTop();
                  int h = resolveSizeAndState(minh, heightMeasureSpec, 0);

                  setMeasuredDimension(w, h);
               }

   There are three important things to note in this code:

   -  The calculations take into account the view's padding. As mentioned
      earlier, this is the view's responsibility.
   -  The helper method
      `resolveSizeAndState() <#android.view.View>`__
      is used to create the final width and height values. This helper returns
      an appropriate ``View.MeasureSpec`` value by comparing the view's needed
      size to the value passed into ``onMeasure()``.
   -  ``onMeasure()`` has no return value. Instead, the method communicates its
      results by calling
      `setMeasuredDimension() <#android.view.View>`__.
      Calling this method is mandatory. If you omit this call, the ``View``
      class throws a runtime exception.

   .. rubric:: Draw
      :name: draw

   After you define your object creation and measuring code, you can implement
   ``onDraw()``. Every view implements ``onDraw()`` differently, but there are
   some common operations that most views share:

   -  Draw text using
      `drawText() <#android.graphics.Canvas>`__.
      Specify the typeface by calling
      `setTypeface() <#android.graphics.Paint>`__
      and the text color by calling
      `setColor() <#android.graphics.Paint>`__.
   -  Draw primitive shapes using
      `drawRect() <#android.graphics.Canvas>`__,
      `drawOval() <#android.graphics.Canvas>`__,
      and
      `drawArc() <#android.graphics.Canvas>`__.
      Change whether the shapes are filled, outlined, or both by calling
      `setStyle() <#android.graphics.Paint>`__.
   -  Draw more complex shapes using the
      `Path <#android.graphics.Path>`__ class. Define a shape by
      adding lines and curves to a ``Path`` object, then draw the shape using
      `drawPath() <#android.graphics.Canvas>`__.
      As with primitive shapes, paths can be outlined, filled, or both,
      depending on ``setStyle()``.
   -  Define gradient fills by creating
      `LinearGradient <#android.graphics.LinearGradient>`__
      objects. Call
      `setShader() <#android.graphics.Paint>`__
      to use your ``LinearGradient`` on filled shapes.
   -  Draw bitmaps using
      `drawBitmap() <#android.graphics.Canvas>`__.

   The following code draws a mix of text, lines, and shapes:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val data = mutableListOf<Item>() // A list of items that are displayed.

               private var shadowBounds = RectF()       // Calculated in onSizeChanged.
               private var pointerRadius: Float = 2f    // Obtained from styled attributes.
               private var pointerX: Float = 0f         // Calculated in onSizeChanged.
               private var pointerY: Float = 0f         // Calculated in onSizeChanged.
               private var textX: Float = 0f            // Calculated in onSizeChanged.
               private var textY: Float = 0f            // Calculated in onSizeChanged.
               private var bounds = RectF()             // Calculated in onSizeChanged.
               private var currentItem: Int = 0         // The index of the currently selected item.

               override fun onDraw(canvas: Canvas) {
                   super.onDraw(canvas)

                   canvas.apply {
                       // Draw the shadow.
                       drawOval(shadowBounds, shadowPaint)

                       // Draw the label text.
                       drawText(data[currentItem].label, textX, textY, textPaint)

                       // Draw the pie slices.
                       data.forEach {item ->
                           piePaint.shader = item.shader
                           drawArc(
                               bounds,
                               360 - item.endAngle,
                               item.endAngle - item.startAngle,
                               true,
                               piePaint
                           )
                       }

                       // Draw the pointer.
                       drawLine(textX, pointerY, pointerX, pointerY, textPaint)
                       drawCircle(pointerX, pointerY, pointerRadius, textPaint)
                   }
               }

               // Maintains the state for a data item.
               private data class Item(
                   var label: String,      
                   var value: Float = 0f,

                   @ColorInt
                   var color: Int = 0,

                   // Computed values.
                   var startAngle: Float = 0f,
                   var endAngle: Float = 0f,

                   var shader: Shader
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private List<Item> data = new ArrayList<Item>();  // A list of items that are displayed.

               private RectF shadowBounds;                       // Calculated in onSizeChanged.
               private float pointerRadius;                      // Obtained from styled attributes.
               private float pointerX;                           // Calculated in onSizeChanged.
               private float pointerY;                           // Calculated in onSizeChanged.
               private float textX;                              // Calculated in onSizeChanged.
               private float textY;                              // Calculated in onSizeChanged.
               private RectF bounds;                             // Calculated in onSizeChanged.
               private int currentItem = 0;                      // The index of the currently selected item.

               protected void onDraw(Canvas canvas) {
                   super.onDraw(canvas);

                   // Draw the shadow.
                   canvas.drawOval(
                           shadowBounds,
                           shadowPaint
                   );

                   // Draw the label text.
                   canvas.drawText(data.get(currentItem).label, textX, textY, textPaint);

                   // Draw the pie slices.
                   for (int i = 0; i < data.size(); ++i) {
                       Item it = data.get(i);
                       piePaint.setShader(it.shader);
                       canvas.drawArc(
                               bounds,
                               360 - it.endAngle,
                               it.endAngle - it.startAngle,
                               true, 
                               piePaint
                       );
                   }

                   // Draw the pointer.
                   canvas.drawLine(textX, pointerY, pointerX, pointerY, textPaint);
                   canvas.drawCircle(pointerX, pointerY, pointerRadius, textPaint);
               }

               // Maintains the state for a data item.
               private class Item {
                   public String label;
                   public float value;
                   @ColorInt
                   public int color;

                   // Computed values.
                   public int startAngle;
                   public int endAngle;

                   public Shader shader;
               }    

   .. rubric:: Apply graphics effects
      :name: rendereffects

   Android 12 (API level 31) adds the
   `RenderEffect <#android.graphics.RenderEffect>`__ class, which
   applies common graphics effects such as blurs, color filters, Android shader
   effects, and more to `View <#android.view.View>`__ objects and
   rendering hierarchies. You can combine effects as chain effects, which
   consist of an inner and outer effect, or blended effects. Support for this
   feature varies depending on device processing power.

   You can also apply effects to the underlying
   `RenderNode <#android.graphics.RenderNode>`__ for a ``View`` by
   calling
   `View.setRenderEffect(RenderEffect) <#android.view.View>`__.

   To implement a ``RenderEffect`` object, do the following:

   .. container::

      .. code:: prettyprint

         view.setRenderEffect(RenderEffect.createBlurEffect(radiusX, radiusY, SHADER_TILE_MODE))

   You can create the view programmatically or inflate it from an XML layout and
   retrieve it using `View binding <#>`__ or
   `findViewById() <#android.view.View>`__.


Last updated 2024-04-15 UTC.



/Make a custom view interactive
===============================

.. https://developer.android.google.cn/develop/ui/views/layout/custom-views/making-interactive?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with layouts in Compose.

      `Gestures → <https://developer.android.google.cn/jetpack/compose/touch-input/pointer-input>`__

      |image-android-compose-ui-logo|

   Drawing a UI is only one part of creating a custom view. You also need to
   make your view respond to user input in a way that closely resembles the
   real-world action you're mimicking.

   Make the objects in your app act like real objects do. For example, don't let
   images in your app pop out of existence and reappear elsewhere, because
   objects in the real world don't do that. Instead, move your images from one
   place to another.

   Users sense even subtle behavior or feel in an interface and react best to
   subtleties that mimic the real world. For example, when users fling a UI
   object, give them a sense of inertia at the beginning that delays the motion.
   At the end of the motion, give them a sense of momentum that carries the
   object beyond the fling.

   This page demonstrates how to use features of the Android framework to add
   these real-world behaviors to your custom view.

   You can find additional related information in `Input events overview <#>`__ and `Property animation overview <#>`__.

   .. rubric:: Handle input gestures
      :name: inputgesture

   Like many other UI frameworks, Android supports an input event model. User
   actions turn into events that trigger callbacks, and you can override the
   callbacks to customize how your app responds to the user. The most common
   input event in the Android system is *touch*, which triggers
   `onTouchEvent(android.view.MotionEvent) <#android.view.View>`__.
   Override this method to handle the event, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onTouchEvent(event: MotionEvent): Boolean {
                   return super.onTouchEvent(event)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
                  public boolean onTouchEvent(MotionEvent event) {
                   return super.onTouchEvent(event);
                  }

   Touch events by themselves aren't particularly useful. Modern touch UIs
   define interactions in terms of gestures such as tapping, pulling, pushing,
   flinging, and zooming. To convert raw touch events into gestures, Android
   provides `GestureDetector <#android.view.GestureDetector>`__.

   Construct a ``GestureDetector`` by passing in an instance of a class that
   implements
   `GestureDetector.OnGestureListener <#android.view.GestureDetector.OnGestureListener>`__.
   If you only want to process a few gestures, you can extend
   `GestureDetector.SimpleOnGestureListener <#android.view.GestureDetector.SimpleOnGestureListener>`__
   instead of implementing the ``GestureDetector.OnGestureListener`` interface.
   For example, this code creates a class that extends
   ``GestureDetector.SimpleOnGestureListener`` and overrides
   `onDown(MotionEvent) <#android.view.GestureDetector.SimpleOnGestureListener>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val myListener =  object : GestureDetector.SimpleOnGestureListener() {
                   override fun onDown(e: MotionEvent): Boolean {
                       return true
                   }
               }

               private val detector: GestureDetector = GestureDetector(context, myListener)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class MyListener extends GestureDetector.SimpleOnGestureListener {
                  @Override
                  public boolean onDown(MotionEvent e) {
                      return true;
                  }
               }
               detector = new GestureDetector(getContext(), new MyListener());

   Whether or not you use ``GestureDetector.SimpleOnGestureListener``, always
   implement an
   `onDown() <#android.view.GestureDetector.OnGestureListener>`__
   method that returns ``true``. This is necessary because all gestures begin
   with an ``onDown()`` message. If you return ``false`` from ``onDown()``, as
   ``GestureDetector.SimpleOnGestureListener`` does, the system assumes you want
   to ignore the rest of the gesture, and the other methods of
   ``GestureDetector.OnGestureListener`` aren't called. Only return ``false``
   from ``onDown()`` if you want to ignore an entire gesture.

   After you implement ``GestureDetector.OnGestureListener`` and create an
   instance of ``GestureDetector``, you can use your ``GestureDetector`` to
   interpret the touch events you receive in
   `onTouchEvent() <#android.view.GestureDetector>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onTouchEvent(event: MotionEvent): Boolean {
                   return detector.onTouchEvent(event).let { result ->
                       if (!result) {
                           if (event.action == MotionEvent.ACTION_UP) {
                               stopScrolling()
                               true
                           } else false
                       } else true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onTouchEvent(MotionEvent event) {
                  boolean result = detector.onTouchEvent(event);
                  if (!result) {
                      if (event.getAction() == MotionEvent.ACTION_UP) {
                          stopScrolling();
                          result = true;
                      }
                  }
                  return result;
               }

   When you pass ``onTouchEvent()`` a touch event that it doesn't recognize as
   part of a gesture, it returns ``false``. You can then run your own custom
   gesture-detection code.

   .. rubric:: Create physically plausible motion
      :name: motion

   Gestures are a powerful way to control touchscreen devices, but they can be
   counterintuitive and difficult to remember unless they produce physically
   plausible results.

   For example, suppose you want to implement a horizontal fling gesture that
   sets the item drawn in the view spinning around its vertical axis. This
   gesture makes sense if the UI responds by moving quickly in the direction of
   the fling, then slowing down, as if the user pushes on a flywheel and makes
   it spin.

   The documentation on how to `animate a scroll gesture <#>`__ gives a
   detailed explanation about how to implement your own scoll behavior. But
   simulating the feel of a flywheel isn't trivial. A lot of physics and math is
   required to make a flywheel model work correctly. Fortunately, Android
   provides helper classes to simulate this and other behaviors. The
   `Scroller <#android.widget.Scroller>`__ class is the basis for
   handling flywheel-style fling gestures.

   To start a fling, call
   `fling() <#android.widget.Scroller>`__
   with the starting velocity and the minimum and maximum *x* and *y* values of
   the fling. For the velocity value, you can use the value computed by
   ``GestureDetector``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun onFling(e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean {
                   scroller.fling(
                           currentX,
                           currentY,
                           (velocityX / SCALE).toInt(),
                           (velocityY / SCALE).toInt(),
                           minX,
                           minY,
                           maxX,
                           maxY
                   )
                   postInvalidate()
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                  scroller.fling(currentX, currentY, velocityX / SCALE, velocityY / SCALE, minX, minY, maxX, maxY);
                  postInvalidate();
                   return true;
               }

   **Note:** Although the velocity calculated by ``GestureDetector`` is
   physically accurate, many developers feel that using this value makes the
   fling animation too fast. It's common to divide the *x* and *y* velocity by a
   factor of four to eight.
   The call to ``fling()`` sets up the physics model for the fling gesture.
   Afterward, update the ``Scroller`` by calling
   `Scroller.computeScrollOffset() <#android.widget.Scroller>`__
   at regular intervals. ``computeScrollOffset()`` updates the ``Scroller``
   object's internal state by reading the current time and using the physics
   model to calculate the *x* and *y* position at that time. Call
   `getCurrX() <#android.widget.Scroller>`__ and
   `getCurrY() <#android.widget.Scroller>`__ to
   retrieve these values.

   Most views pass the ``Scroller`` object's *x* and *y* positions directly to
   `scrollTo() <#android.view.View>`__. This
   example is a little different: it uses the current scroll *x* position to set
   the rotational angle of the view.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               scroller.apply {
                   if (!isFinished) {
                       computeScrollOffset()
                       setItemRotation(currX)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               if (!scroller.isFinished()) {
                   scroller.computeScrollOffset();
                   setItemRotation(scroller.getCurrX());
               }

   The ``Scroller`` class computes scroll positions for you, but it doesn't
   automatically apply those positions to your view. Apply new coordinates often
   enough to make the scrolling animation look smooth. There are two ways to do
   this:

   -  Force a redraw by calling
      `postInvalidate() <#android.view.View>`__
      after calling ``fling()``. This technique requires that you compute scroll
      offsets in
      `onDraw() <#android.view.View>`__
      and call ``postInvalidate()`` every time the scroll offset changes.
   -  Set up a
      `ValueAnimator <#android.animation.ValueAnimator>`__ to
      animate for the duration of the fling and add a listener to process
      animation updates by calling
      `addUpdateListener() <#android.animation.ValueAnimator>`__.
      This technique lets you animate properties of a
      `View <#android.view.View>`__.

   .. rubric:: Make your transitions smooth
      :name: makesmooth

   Users expect a modern UI to transition smoothly between states: UI elements
   fading in and out instead of appearing and disappearing, and motions
   beginning and ending smoothly instead of starting and stopping abruptly. The
   Android `property animation framework <#>`__ makes smooth transitions
   easier.

   To use the animation system, whenever a property changes what affects your
   view's appearance, don't change the property directly. Instead, use
   ``ValueAnimator`` to make the change. In the following example, modifying the
   selected child component in the view makes the entire rendered view rotate so
   that the selection pointer is centered. ``ValueAnimator`` changes the
   rotation over a period of several hundred milliseconds, rather than
   immediately setting the new rotation value.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               autoCenterAnimator = ObjectAnimator.ofInt(this, "Rotation", 0).apply {
                   setIntValues(targetAngle)
                   duration = AUTOCENTER_ANIM_DURATION
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               autoCenterAnimator = ObjectAnimator.ofInt(this, "Rotation", 0);
               autoCenterAnimator.setIntValues(targetAngle);
               autoCenterAnimator.setDuration(AUTOCENTER_ANIM_DURATION);
               autoCenterAnimator.start();

   If the value you want to change is one of the base ``View`` properties, doing
   the animation is even easier, because views have a built-in
   `ViewPropertyAnimator <#android.view.ViewPropertyAnimator>`__
   that is optimized for simultaneous animation of multiple properties, as in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               animate()
                   .rotation(targetAngle)
                   .duration = ANIM_DURATION
                   .start()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               animate().rotation(targetAngle).setDuration(ANIM_DURATION).start();


Last updated 2024-04-15 UTC.



/Optimize a custom view
=======================

.. https://developer.android.google.cn/develop/ui/views/layout/custom-views/optimizing-view?hl=en

.. container:: devsite-article-body

   When you have a well-designed view that responds to gestures and transitions
   between states, make sure the view runs fast. To avoid a UI that feels
   sluggish or stutters during playback, make sure animations consistently run
   at 60 frames per second.

   .. rubric:: Speed up your view
      :name: less

   To speed up your view, eliminate unnecessary code from routines that are
   called frequently. Start with
   `onDraw() <#android.view.View>`__,
   which gives you the biggest payback. In particular, eliminate allocations in
   ``onDraw()``, because allocations might lead to a garbage collection that
   causes a stutter. Allocate objects during initialization or between
   animations. Never make an allocation while an animation is running.

   In addition to making ``onDraw()`` leaner, make sure it's called as
   infrequently as possible. Most calls to ``onDraw()`` are the result of a call
   to `invalidate() <#android.view.View>`__, so
   eliminate unnecessary calls to ``invalidate()``.

   Another very expensive operation is traversing layouts. When a view calls
   `requestLayout() <#android.view.View>`__, the
   Android UI system traverses the entire view hierarchy to find how big each
   view needs to be. If it finds conflicting measurements, it might traverse the
   hierarchy multiple times. UI designers sometimes create deep hierarchies of
   nested `ViewGroup <#android.view.ViewGroup>`__ objects. These
   deep view hierarchies cause performance problems, so make your view
   hierarchies as shallow as possible.

   If you have a complex UI, consider writing a custom ``ViewGroup`` to perform
   its layout. Unlike the built-in views, your custom view can make
   application-specific assumptions about the size and shape of its children and
   therefore avoid traversing its children to calculate measurements.

   For example, if you have a custom ``ViwGroup`` that doesn't adjust its own
   size to fit all its child views, you avoid the overhead of measuring all the
   child views. This optimization isn't possible if you use the built-in layouts
   that cater to a wide range of use-cases.


Last updated 2024-02-22 UTC.


/Lay out your app within windows insets
=======================================

.. https://developer.android.google.cn/develop/ui/views/layout/insets?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with WindowInsets in Compose.

      `WindowInsets in Compose → <https://developer.android.google.cn/jetpack/compose/layouts/insets>`__

      |image-android-compose-ui-logo|

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/e2e-intro.gif
      :width: 310px

      **Figure 1.** The status bar and navigation bar, collectively called the
      *system bars*.

   By default, apps are laid out below the status bar at the top and above the
   navigation bar at the bottom. Together, the status bar and the navigation bar
   are called the *system bars*. The system bars are areas that are generally
   dedicated to the display of notifications, communication of device status,
   and device navigation. However, you can configure your app to display content
   in these areas.

   The overlaps between your app and the areas where the system UI is displayed
   is one example of *window insets*, which represent the parts of your screen
   where your app can intersect with the system UI. Intersecting with these
   parts of the UI can mean displaying above the content, but it can also inform
   your app about system gestures.

   The following types of window insets are available.

   -  Apps can opt in to expand their window to extend across the entire screen
      and draw their content `edge-to-edge <#>`__
      behind the system bars.

   -  Apps that display content such as movies or images can temporarily `hide the system bars <#>`__ for a more immersive
      experience. Carefully consider your users' needs and expectations before
      modifying the system bars, since they give users a standard way of
      navigating a device and viewing its status.

   -  A *display cutout* is an area on some devices that extends into the
      display surface to provide space for sensors on the front of the device.
      Apps can support `display cutouts <#>`__ by
      querying their positions so that no important content overlaps the cutout
      area.

   -  A keyboard transition is a common example where window insets are
      dynamically updated. Apps can observe the current keyboard state,
      programmatically toggle the states, support animations for window insets,
      and make app content animate seamlessly between keyboard transitions.


Last updated 2024-05-03 UTC.



/Display content edge-to-edge
=============================

.. https://developer.android.google.cn/develop/ui/views/layout/edge-to-edge?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with edge-to-edge in Compose.

      `Edge-to-edge in Compose → <https://developer.android.google.cn/jetpack/compose/layouts/insets>`__

      |image-android-compose-ui-logo|

   You can make your app display *edge-to-edge*—using the entire width and
   height of the display—by drawing behind the *system bars*. The system bars
   are the status bar and the navigation bar.

   To implement an edge-to-edge layout, your app must do the following:

   -  Draw behind the navigation bar to achieve a more compelling and modern
      user experience.
   -  Draw behind the status bar if it makes sense for your content and layout,
      such as in the case of full-width imagery. To do this, use APIs such as
      `AppBarLayout <#>`__,
      which defines an app bar pinned to the top of the screen.

   .. container:: float
      :name: intro

   To implement an edge-to-edge layout in your app, perform the following steps:

   #. Enable the edge-to-edge display.
   #. Handle any visual overlaps.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/e2e-imagery-behind-status-bar.png
      name: behind_1
      :alt: An image showing an app with imagery behind the status bar
      :width: 60.0%

      **Figure 2.** Example of an app with imagery behind the status bar.

   .. rubric:: Enable the edge-to-edge display.
      :name: enable-edge-to-edge-display

   You can enable the edge-to-edge display in your app by calling
   `enableEdgeToEdge <#androidx.activity.ComponentActivity>`__
   in ``onCreate`` of your ``Activity``. It should be called before
   ``setContentView``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                 override fun onCreate(savedInstanceState: Bundle?) {
                   enableEdgeToEdge()
                   super.onCreate(savedInstanceState)
                   ...
                 }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                 @Override
                 protected void onCreate(@Nullable Bundle savedInstanceState) {
                   EdgeToEdge.enable(this);
                   super.onCreate(savedInstanceState);
                   ...
                 }

   By default, ``enableEdgeToEdge`` makes the system bars transparent, except on
   3-button navigation mode where the status bar gets a translucent scrim. The
   colors of the system icons and the scrim are adjusted based on the system
   light or dark theme.

   The ``enableEdgeToEdge`` method automatically declares that the app should be
   laid out edge-to-edge and adjusts the colors of the system bars. See
   "`Manually set up the edge-to-edge
   display <#>`__" if this is
   necessary for any reason.

   .. rubric:: Handle overlaps using insets
      :name: handle-overlaps

   After you enable the edge-to-edge display, some of your app's views might
   draw behind the system bars, as shown in figure 3.

   You can address overlaps by reacting to *insets*, which specify which parts
   of the screen intersect with system UI such as the navigation bar or the
   status bar. Intersecting can mean displaying above the content, but it can
   also inform your app about system gestures.

   The types of insets that apply to displaying your app edge-to-edge are:

   -  **System bars insets:** best for views that are tappable and that must not
      be visually obscured by the system bars.

   -  **System gesture insets:** for gesture-navigational areas used by the
      system that take priority over your app.

   .. rubric:: System bars insets
      :name: system-bars-insets

   System bar insets are the most commonly used type of insets. They represent
   the area where the system UI displays in the Z-axis above your app. They are
   best used to move or pad views in your app that are tappable and that must
   not be visually obscured by the system bars.

   For example, the `floating action button <#>`__ (FAB) in figure 3 is
   partially obscured by the navigation bar:

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/e2e-after-implementation.png
      name: overlap
      :alt: An image showing edge-to-edge implemented, but the nav bar is
      covering the FAB
      :width: 60.0%

      **Figure 3.** Navigation bar overlapping an FAB in an edge-to-edge layout.

   To avoid this kind of visual overlap in either gesture mode or button mode,
   you can increase the view's margins using
   `getInsets(int) <#androidx.core.view.WindowInsetsCompat>`__
   with
   `WindowInsetsCompat.Type.systemBars() <#androidx.core.view.WindowInsetsCompat.Type>`__.

   The following code example shows how to implement system bar insets:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ViewCompat.setOnApplyWindowInsetsListener(fab) { v, windowInsets ->
                 val insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())
                 // Apply the insets as a margin to the view. This solution sets
                 // only the bottom, left, and right dimensions, but you can apply whichever
                 // insets are appropriate to your layout. You can also update the view padding
                 // if that's more appropriate.
                 v.updateLayoutParams<MarginLayoutParams>(
                     leftMargin = insets.left,
                     bottomMargin = insets.bottom,
                     rightMargin = insets.right,
                 )

                 // Return CONSUMED if you don't want want the window insets to keep passing
                 // down to descendant views.
                 WindowInsetsCompat.CONSUMED
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ViewCompat.setOnApplyWindowInsetsListener(fab, (v, windowInsets) -> {
                 Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars());
                 // Apply the insets as a margin to the view. This solution sets only the
                 // bottom, left, and right dimensions, but you can apply whichever insets are
                 // appropriate to your layout. You can also update the view padding if that's
                 // more appropriate.
                 MarginLayoutParams mlp = (MarginLayoutParams) v.getLayoutParams();
                 mlp.leftMargin = insets.left;
                 mlp.bottomMargin = insets.bottom;
                 mlp.rightMargin = insets.right;
                 v.setLayoutParams(mlp);

                 // Return CONSUMED if you don't want want the window insets to keep passing
                 // down to descendant views.
                   return WindowInsetsCompat.CONSUMED;
               });

   If you apply this solution to the example shown in figure 3, it results in no
   visual overlap in button mode, as shown in figure 4:

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/e2e-system-bars-top.png
      name: resolve-overlaps
      :alt: An image showing a translucent nav bar not covering the FAB
      :width: 60.0%

      **Figure 4.** Resolving visual overlap in button mode.

   The same applies to gesture navigation mode, as shown in figure 5:

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/e2e-system-bars-bottom.png
      name: resolve-overlaps-2
      :alt: An image showing edge-to-edge with gesture navigation
      :width: 60.0%

      **Figure 5.** Resolving visual overlap in gesture navigation mode.

   .. rubric:: System gesture insets
      :name: system-gesture-insets

   System gesture insets represent the areas of the window where system gestures
   take priority over your app. These areas are shown in orange in figure 6:

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/e2e-system-gesture-insets.png
      name: system-gesture
      :alt: An image showing system gesture insets
      :width: 30.0%

      **Figure 6.** System gesture insets.

   Like the system bar insets, you can avoid overlapping the system gesture
   insets using
   `getInsets(int) <#androidx.core.view.WindowInsetsCompat>`__
   with
   `WindowInsetsCompat.Type.systemGestures() <#androidx.core.view.WindowInsetsCompat.Type>`__.

   Use these insets to move or pad swipeable views away from the edges. Common
   use cases include `bottom sheets <https://m2.material.io/components/sheets-bottom>`__, swiping in
   games, and carousels implemented using
   `ViewPager2 <#androidx.viewpager2.widget.ViewPager2>`__.

   On Android 10 or later, system gesture insets contain a bottom inset for the
   home gesture, and a left and right inset for the back gestures:

   .. figure::
      https://developer.android.google.cn/static/images/guide/navigation/e2e-system-gesture-insets-measurements.png
      name: system-gesture-insets-measurements
      :alt: An image showing system gesture inset measurements
      :width: 50.0%

      **Figure 7.** System gesture inset measurements.

   The following code example shows how to implement system gesture insets:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ViewCompat.setOnApplyWindowInsetsListener(view) { view, windowInsets ->
                   val insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemGestures())
                   // Apply the insets as padding to the view. Here, set all the dimensions
                   // as appropriate to your layout. You can also update the view's margin if
                   // more appropriate.
                   view.updatePadding(insets.left, insets.top, insets.right, insets.bottom)

                   // Return CONSUMED if you don't want the window insets to keep passing down
                   // to descendant views.
                   WindowInsetsCompat.CONSUMED
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ViewCompat.setOnApplyWindowInsetsListener(view, (v, windowInsets) -> {
                   Insets insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemGestures());
                   // Apply the insets as padding to the view. Here, set all the dimensions
                   // as appropriate to your layout. You can also update the view's margin if
                   // more appropriate.
                   view.setPadding(insets.left, insets.top, insets.right, insets.bottom);

                   // Return CONSUMED if you don't want the window insets to keep passing down
                   // to descendant views.
                   return WindowInsetsCompat.CONSUMED;
               });

   .. rubric:: Immersive mode
      :name: immersive-mode

   Some content is best experienced in full screen, giving the user a more
   immersive experience. You can hide the system bars an for immersive mode
   using the
   `WindowInsetsController <#android.view.WindowInsetsController>`__
   and
   `WindowInsetsControllerCompat <#androidx.core.view.WindowInsetsControllerCompat>`__
   libraries:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val windowInsetsController =
                     WindowCompat.getInsetsController(window, window.decorView)

               // Hide the system bars.
               windowInsetsController.hide(Type.systemBars())

               // Show the system bars.
               windowInsetsController.show(Type.systemBars())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Window window = getWindow();
               WindowInsetsControllerCompat windowInsetsController =
                     WindowCompat.getInsetsController(window, window.getDecorView());
               if (windowInsetsController == null) {
                   return;
                 }
               // Hide the system bars.
               windowInsetsController.hide(WindowInsetsCompat.Type.systemBars());

               // Show the system bars.
               windowInsetsController.show(WindowInsetsCompat.Type.systemBars());

   Refer to `Hide system bars for immersive mode <#>`__ for more information about
   implementing this feature.

   .. rubric:: Additional resources
      :name: additional-resources

   See the following references for more information about ``WindowInsets``,
   gesture navigation, and how insets work:

   -  `WindowInsets — listeners to layouts <https://medium.com/androiddevelopers/windowinsets-listeners-to-layouts-8f9ccc8fa4d1>`__
   -  `Gesture Navigation: Insets <https://www.youtube.com/watch?v=82eH0s9UO6o>`__
   -  `How insets work on Android? <https://youtu.be/rorofoIpo1A?t=234>`__


Last updated 2024-05-03 UTC.



/Apply rounded corners
======================

.. https://developer.android.google.cn/develop/ui/views/layout/insets/rounded-corners?hl=en

.. container:: devsite-article-body

   Starting in Android 12 (API level 31), you can use
   `RoundedCorner <#android.view.RoundedCorner>`__ and
   `WindowInsets.getRoundedCorner(int position) <#android.view.WindowInsets>`__
   to get the radius and center point for rounded corners of the device screen.
   These APIs keep your app's UI elements from being truncated on screens with
   rounded corners. The framework provides the
   `getPrivacyIndicatorBounds() <#android.view.WindowInsets>`__
   API, which returns the bounded rectangle of any visible `microphone and
   camera indicators <#mic-camera-indicators>`__.

   When implemented in your app, these APIs have no effect on devices with
   non-rounded screens.

   .. figure::
      https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/rounded-corners-radius.png
      :alt: Image showing a rounded corners with radii and a center point
      :width: 200px

      **Figure 1.** Rounded corners with radii and a center point.

   To implement this feature, get the ``RoundedCorner`` info using
   ``WindowInsets.getRoundedCorner(int position)`` relative to the bounds of the
   application. If the app doesn't take up the whole screen, the API applies the
   rounded corner by basing the center point of the rounded corner on the window
   bounds of the app.

   The following code snippet shows how an app can avoid having its UI truncated
   by setting a margin of the view based on the info from ``RoundedCorner``. In
   this case, it is the top-right rounded corner.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Get the top-right rounded corner from WindowInsets.
               val insets = rootWindowInsets
               val topRight = insets.getRoundedCorner(RoundedCorner.POSITION_TOP_RIGHT) ?: return

               // Get the location of the close button in window coordinates.
               val location = IntArray(2)
               closeButton!!.getLocationInWindow(location)
               val buttonRightInWindow = location[0] + closeButton.width
               val buttonTopInWindow = location[1]

               // Find the point on the quarter circle with a 45-degree angle.
               val offset = (topRight.radius * Math.sin(Math.toRadians(45.0))).toInt()
               val topBoundary = topRight.center.y - offset
               val rightBoundary = topRight.center.x + offset

               // Check whether the close button exceeds the boundary.
               if (buttonRightInWindow < rightBoundary << buttonTopInWindow > topBoundary) {
                  return
               }

               // Set the margin to avoid truncating.
               val parentLocation = IntArray(2)
               getLocationInWindow(parentLocation)
               val lp = closeButton.layoutParams as FrameLayout.LayoutParams
               lp.rightMargin = Math.max(buttonRightInWindow - rightBoundary, 0)
               lp.topMargin = Math.max(topBoundary - buttonTopInWindow, 0)
               closeButton.layoutParams = lp

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Get the top-right rounded corner from WindowInsets.
               final WindowInsets insets = getRootWindowInsets();
               final RoundedCorner topRight = insets.getRoundedCorner(POSITION_TOP_RIGHT);
               if (topRight == null) {
                  return;
               }

               // Get the location of the close button in window coordinates.
               int [] location = new int[2];
               closeButton.getLocationInWindow(location);
               final int buttonRightInWindow = location[0] + closeButton.getWidth();
               final int buttonTopInWindow = location[1];

               // Find the point on the quarter circle with a 45-degree angle.
               final int offset = (int) (topRight.getRadius() * Math.sin(Math.toRadians(45)));
               final int topBoundary = topRight.getCenter().y - offset;
               final int rightBoundary = topRight.getCenter().x + offset;

               // Check whether the close button exceeds the boundary.
               if (buttonRightInWindow < rightBoundary << buttonTopInWindow > topBoundary) {
                  return;
               }

               // Set the margin to avoid truncating.
               int [] parentLocation = new int[2];
               getLocationInWindow(parentLocation);
               FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) closeButton.getLayoutParams();
               lp.rightMargin = Math.max(buttonRightInWindow - rightBoundary, 0);
               lp.topMargin = Math.max(topBoundary - buttonTopInWindow, 0);
               closeButton.setLayoutParams(lp);

   .. rubric:: Be careful of clipping
      :name: caution

   If your UI fills the entire display, round corners can cause issues with
   content clipping. For example, figure 2 shows an icon in the corner of the
   display with the layout being drawn behind the system bars:

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/theming/images/rounded-corners-none.png
      :alt: An icon being clipped by rounded corners

      **Figure 2.** An icon being clipped by rounded corners.

   You can avoid this by checking for rounded corners and applying padding to
   keep your app's content out of the device's corners, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class InsetsLayout(context: Context, attrs: AttributeSet) : FrameLayout(context, attrs) {

                   override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {
                       val insets = rootWindowInsets

                       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && insets != null) {
                           applyRoundedCornerPadding(insets)
                       }
                       super.onLayout(changed, left, top, right, bottom)

                   }

                   @RequiresApi(Build.VERSION_CODES.S)
                   private fun applyRoundedCornerPadding(insets: WindowInsets) {
                       val topLeft = insets.getRoundedCorner(RoundedCorner.POSITION_TOP_LEFT)
                       val topRight = insets.getRoundedCorner(RoundedCorner.POSITION_TOP_RIGHT)
                       val bottomLeft = insets.getRoundedCorner(RoundedCorner.POSITION_BOTTOM_LEFT)
                       val bottomRight = insets.getRoundedCorner(RoundedCorner.POSITION_BOTTOM_RIGHT)

                       val leftRadius = max(topLeft?.radius ?: 0, bottomLeft?.radius ?: 0)
                       val topRadius = max(topLeft?.radius ?: 0, topRight?.radius ?: 0)
                       val rightRadius = max(topRight?.radius ?: 0, bottomRight?.radius ?: 0)
                       val bottomRadius = max(bottomLeft?.radius ?: 0, bottomRight?.radius ?: 0)

                       val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
                       val windowBounds = windowManager.currentWindowMetrics.bounds
                       val safeArea = Rect(
                           windowBounds.left + leftRadius,
                           windowBounds.top + topRadius,
                           windowBounds.right - rightRadius,
                           windowBounds.bottom - bottomRadius
                       )

                       val location = intArrayOf(0, 0)
                       getLocationInWindow(location)

                       val leftMargin = location[0] - windowBounds.left
                       val topMargin = location[1] - windowBounds.top
                       val rightMargin = windowBounds.right - right - location[0]
                       val bottomMargin = windowBounds.bottom - bottom - location[1]

                       val layoutBounds = Rect(
                           location[0] + paddingLeft,
                           location[1] + paddingTop,
                           location[0] + width - paddingRight,
                           location[1] + height - paddingBottom
                       )

                       if (layoutBounds != safeArea && layoutBounds.contains(safeArea)) {
                           setPadding(
                               calculatePadding(leftRadius, leftMargin, paddingLeft),
                               calculatePadding(topRadius, topMargin, paddingTop),
                               calculatePadding(rightRadius, rightMargin, paddingRight),
                               calculatePadding(bottomRadius, bottomMargin, paddingBottom)
                           )
                       }
                   }

                   private fun calculatePadding(radius1: Int?, radius2: Int?, margin: Int, padding: Int): Int =
                       (max(radius1 ?: 0, radius2 ?: 0) - margin - padding).coerceAtLeast(0)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class InsetsLayout extends FrameLayout {
                   public InsetsLayout(@NonNull Context context) {
                       super(context);
                   }

                   public InsetsLayout(@NonNull Context context, @Nullable AttributeSet attrs) {
                       super(context, attrs);
                   }

                   @Override
                   protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
                       WindowInsets insets = getRootWindowInsets();
                       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && insets != null) {
                           applyRoundedCornerPadding(insets);
                       }
                       super.onLayout(changed, left, top, right, bottom);
                   }

                   @RequiresApi(Build.VERSION_CODES.S)
                   private void applyRoundedCornerPadding(WindowInsets insets) {
                       RoundedCorner topLeft = insets.getRoundedCorner(RoundedCorner.POSITION_TOP_LEFT);
                       RoundedCorner topRight = insets.getRoundedCorner(RoundedCorner.POSITION_TOP_RIGHT);
                       RoundedCorner bottomLeft = insets.getRoundedCorner(RoundedCorner.POSITION_BOTTOM_LEFT);
                       RoundedCorner bottomRight = insets.getRoundedCorner(RoundedCorner.POSITION_BOTTOM_RIGHT);
                       int radiusTopLeft = 0;
                       int radiusTopRight = 0;
                       int radiusBottomLeft = 0;
                       int radiusBottomRight = 0;
                       if (topLeft != null) radiusTopLeft = topLeft.getRadius();
                       if (topRight != null) radiusTopRight = topRight.getRadius();
                       if (bottomLeft != null) radiusBottomLeft = bottomLeft.getRadius();
                       if (bottomRight != null) radiusBottomRight = bottomRight.getRadius();

                       int leftRadius = Math.max(radiusTopLeft, radiusBottomLeft);
                       int topRadius = Math.max(radiusTopLeft, radiusTopRight);
                       int rightRadius = Math.max(radiusTopRight, radiusBottomRight);
                       int bottomRadius = Math.max(radiusBottomLeft, radiusBottomRight);

                       WindowManager windowManager =
                               (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
                       Rect windowBounds = windowManager.getCurrentWindowMetrics().getBounds();
                       Rect safeArea = new Rect(
                               windowBounds.left + leftRadius,
                               windowBounds.top + topRadius,
                               windowBounds.right - rightRadius,
                               windowBounds.bottom - bottomRadius
                       );
                       int[] location = {0, 0};
                       getLocationInWindow(location);

                       int leftMargin = location[0] - windowBounds.left;
                       int topMargin = location[1] - windowBounds.top;
                       int rightMargin = windowBounds.right - getRight() - location[0];
                       int bottomMargin = windowBounds.bottom - getBottom() - location[1];

                       Rect layoutBounds = new Rect(
                               location[0] + getPaddingLeft(),
                               location[1] + getPaddingTop(),
                               location[0] + getWidth() - getPaddingRight(),
                               location[1] + getHeight() - getPaddingBottom()
                       );

                       if (!layoutBounds.equals(safeArea) && layoutBounds.contains(safeArea)) {
                           setPadding(
                                   calculatePadding(radiusTopLeft, radiusBottomLeft,
                                                        leftMargin, getPaddingLeft()),
                                   calculatePadding(radiusTopLeft, radiusTopRight,
                                                        topMargin, getPaddingTop()),
                                   calculatePadding(radiusTopRight, radiusBottomRight,
                                                        rightMargin, getPaddingRight()),
                                   calculatePadding(radiusBottomLeft, radiusBottomRight,
                                                        bottomMargin, getPaddingBottom())
                           );
                       }
                   }

                   private int calculatePadding(int radius1, int radius2, int margin, int padding) {
                       return Math.max(Math.max(radius1, radius2) - margin - padding, 0);
                   }
               }

   This layout determines whether the UI extends to the area of the rounded
   corners and adds padding where it does. Figure 3 has the "Show layout bounds"
   developer option enabled to show the padding being applied more clearly:

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/theming/images/rounded-corners-both.png
      :alt: An icon with padding applied to move it away from the corner.

      **Figure 3.** An icon with padding applied to move it away from the
      corner.

   To make this determination, this layout calculates two rectangles:
   ``safeArea`` is the area within the radii of the round corners, and
   ``layoutBounds`` is the size of the layout minus any padding. If
   ``layoutArea`` fully contains ``safeArea``, then the children of the layout
   might be clipped. If this is the case, padding is added to make sure the
   layout remains inside ``safeArea``.

   By checking whether ``layoutBounds`` fully encloses ``safeArea``, you avoid
   adding padding when the layout doesn't extend to the edges of the display.
   Figure 4 shows the layout when it isn't drawn behind the navigation bar. In
   this case, the layout doesn't extend down far enough to be within the rounded
   corners, as they fit within the area occupied by the navigation bar. No
   padding is required.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/theming/images/rounded-corners-neither.png
      :alt: A layout that doesn't draw behind the system and navigation bars.

      **Figure 4.** A layout that doesn't draw behind the system and navigation
      bars.


Last updated 2024-02-22 UTC.


/Hide system bars for immersive mode
====================================

.. https://developer.android.google.cn/develop/ui/views/layout/immersive?hl=en

.. container:: devsite-article-body

   Some content is best experienced in fullscreen without any indicators on the
   status bar or the navigation bar. Some examples are videos, games, image
   galleries, books, and presentation slides. This is referred to as *immersive
   mode*. This page shows how you can engage users more deeply with content in
   fullscreen.

   .. container::

      |image-fullscreen_landing|
      **Figure 1.** Example of immersive mode.

   Immersive mode helps users avoid accidental exits during a game and delivers
   an immersive experience for enjoying images, videos, and books. However, be
   mindful of how often users jump in and out of apps to check notifications, to
   conduct impromptu searches, or to take other actions. Because immersive mode
   causes users to lose easy access to system navigation, use immersive mode
   only when the benefit to the user experience goes beyond simply using extra
   screen space.

   Use
   `WindowInsetsControllerCompat.hide() <#androidx.core.view.WindowInsetsControllerCompat>`__
   to hide the system bars and
   `WindowInsetsControllerCompat.show() <#androidx.core.view.WindowInsetsControllerCompat>`__
   to bring them back.

   The following snippet shows an example of configuring a button to hide and
   show the system bars.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   ...

                   val windowInsetsController =
                       WindowCompat.getInsetsController(window, window.decorView)
                   // Configure the behavior of the hidden system bars.
                   windowInsetsController.systemBarsBehavior =
                       WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE

                   // Add a listener to update the behavior of the toggle fullscreen button when
                   // the system bars are hidden or revealed.
                   ViewCompat.setOnApplyWindowInsetsListener(window.decorView) { view, windowInsets ->
                       // You can hide the caption bar even when the other system bars are visible.
                       // To account for this, explicitly check the visibility of navigationBars()
                       // and statusBars() rather than checking the visibility of systemBars().
                       if (windowInsets.isVisible(WindowInsetsCompat.Type.navigationBars())
                           || windowInsets.isVisible(WindowInsetsCompat.Type.statusBars())) {
                           binding.toggleFullscreenButton.setOnClickListener {
                               // Hide both the status bar and the navigation bar.
                               windowInsetsController.hide(WindowInsetsCompat.Type.systemBars())
                           }
                       } else {
                           binding.toggleFullscreenButton.setOnClickListener {
                               // Show both the status bar and the navigation bar.
                               windowInsetsController.show(WindowInsetsCompat.Type.systemBars())
                           }
                       }
                       ViewCompat.onApplyWindowInsets(view, windowInsets)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   ...

                   WindowInsetsControllerCompat windowInsetsController =
                           WindowCompat.getInsetsController(getWindow(), getWindow().getDecorView());
                   // Configure the behavior of the hidden system bars.
                   windowInsetsController.setSystemBarsBehavior(
                           WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
                   );

                   // Add a listener to update the behavior of the toggle fullscreen button when
                   // the system bars are hidden or revealed.
                   ViewCompat.setOnApplyWindowInsetsListener(
                       getWindow().getDecorView(),
                       (view, windowInsets) -> {
                       // You can hide the caption bar even when the other system bars are visible.
                       // To account for this, explicitly check the visibility of navigationBars()
                       // and statusBars() rather than checking the visibility of systemBars().
                       if (windowInsets.isVisible(WindowInsetsCompat.Type.navigationBars())
                               || windowInsets.isVisible(WindowInsetsCompat.Type.statusBars())) {
                           binding.toggleFullscreenButton.setOnClickListener(v -> {
                               // Hide both the status bar and the navigation bar.
                               windowInsetsController.hide(WindowInsetsCompat.Type.systemBars());
                           });
                       } else {
                           binding.toggleFullscreenButton.setOnClickListener(v -> {
                               // Show both the status bar and the navigation bar.
                               windowInsetsController.show(WindowInsetsCompat.Type.systemBars());
                           });
                       }
                       return ViewCompat.onApplyWindowInsets(view, windowInsets);
                   });
               }

   Optionally, you can specify the type of system bars to hide and determine
   their behavior when a user interacts with them.

   .. rubric:: Specify which system bars to hide
      :name: type

   To specify the type of system bars to hide, pass one of the following
   parameters to ``WindowInsetsControllerCompat.hide()``.

   -  Use
      `WindowInsetsCompat.Type.systemBars() <#systembars>`__
      to hide both system bars.

   -  Use
      `WindowInsetsCompat.Type.statusBars() <#statusbars>`__
      to hide only the status bar.

   -  Use
      `WindowInsetsCompat.Type.navigationBars() <#navigationbars>`__
      to hide only the navigation bar.

   .. rubric:: Specify behavior of hidden system bars
      :name: behavior

   Use
   `WindowInsetsControllerCompat.setSystemBarsBehavior() <#androidx.core.view.WindowInsetsControllerCompat>`__
   to specify how hidden system bars behave when the user interacts with them.

   -  Use
      `WindowInsetsControllerCompat.BEHAVIOR_SHOW_BARS_BY_TOUCH <#androidx.core.view.WindowInsetsControllerCompat>`__
      to reveal hidden system bars on *any* user interactions on the
      corresponding display.

   -  Use
      `WindowInsetsControllerCompat.BEHAVIOR_SHOW_BARS_BY_SWIPE <#androidx.core.view.WindowInsetsControllerCompat>`__
      to reveal hidden system bars on any system gestures, such as swiping from
      the edge of the screen where the bar is hidden from.

   -  Use
      `WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE <#androidx.core.view.WindowInsetsControllerCompat>`__
      to temporarily reveal hidden system bars with system gestures, such as
      swiping from the edge of the screen where the bar is hidden from. These
      transient system bars overlay your app’s content, might have some degree
      of transparency, and are automatically hidden after a short timeout.


Last updated 2024-05-03 UTC.

.. |image-fullscreen_landing| image:: https://developer.android.google.cn/static/design/media/fullscreen_landing.png


/Support display cutouts
========================

.. https://developer.android.google.cn/develop/ui/views/layout/display-cutout?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with display cutouts in Compose.

      `Display cutouts in Compose → <https://developer.android.google.cn/jetpack/compose/system/cutouts>`__

      |image-android-compose-ui-logo|

   A `display cutout <#>`__ is an area on some
   devices that extends into the display surface. It allows for an edge-to-edge
   experience while providing space for important sensors on the front of the
   device.

   **Note:**\  Before attempting to render your app into the cutout area, ensure
   your app is configured to `display content edge to edge <#>`__.
   Android supports display cutouts on devices running Android 9 (API level 28)
   and higher. However, device manufacturers can also support display cutouts on
   devices running Android 8.1 or lower.

   This document describes how to implement support for devices with cutouts,
   including how to work with the *cutout area*—that is, the edge-to-edge
   rectangle on the display surface that contains the cutout.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-intro.png
      name: cutout-intro
      :alt: An image showing an example of top-center display cutout
      :width: 40.0%

      **Figure 1.** 1 Display cutout.

   .. rubric:: Choose how your app handles cutout areas
      :name: handle

   If you don't want your content to overlap with a cutout area, it's generally
   sufficient to make sure your content doesn't overlap with the status bar and
   the navigation bar. If you're rendering into the cutout area, use
   `WindowInsetsCompat.getDisplayCutout() <#androidx.core.view.WindowInsetsCompat>`__
   to retrieve a `DisplayCutout <#android.view.DisplayCutout>`__
   object that contains the safe insets and bounding box for each cutout. These
   APIs let you check whether your content overlaps with the cutout so that you
   can reposition if needed.

   You can also determine whether content is laid out behind the cutout area.
   The
   `layoutInDisplayCutoutMode <#android.view.WindowManager.LayoutParams>`__
   window layout attribute controls how your content is drawn in the cutout
   area. You can set ``layoutInDisplayCutoutMode`` to one of the following
   values:

   -  `LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT <#android.view.WindowManager.LayoutParams>`__:
      content renders into the cutout area when displayed in portrait mode, but
      content is letterboxed when displayed in landscape mode.
   -  `LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES <#android.view.WindowManager.LayoutParams>`__:
      content renders into the cutout area in both portrait and landscape modes.
   -  `LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER <#android.view.WindowManager.LayoutParams>`__:
      content never renders into the cutout area.

   You can set the cutout mode either programmatically or by setting a
   `style <#>`__ in your activity. The
   following example defines a style to apply the
   ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES`` attribute to the activity.

   .. code:: prettyprint

      <style name="ActivityTheme">
        <item name="android:windowLayoutInDisplayCutoutMode">
          shortEdges <!-- default, shortEdges, or never -->
        </item>
      </style>

   The following sections describe the different cutout modes in more detail.

   .. rubric:: Default behavior
      :name: default-behaviour

   By default, in portrait mode with no special flags set, the status bar on a
   device with a cutout is resized to be at least as tall as the cutout, and
   your content displays in the area below. In landscape or fullscreen mode,
   your app window is letterboxed so that none of your content displays in the
   cutout area.

   .. rubric:: Render content in short edge cutout areas
      :name: short-edge

   For some content, such as video, photos, maps, and games, rendering in the
   cutout area can be a great way to provide a more immersive, edge-to-edge
   experience for users. With ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES``, the
   content extends into the cutout area on the short edge of the display in both
   portrait and landscape, regardless of whether the system bars are hidden or
   visible. When using this mode, be sure that no important content overlaps
   with the cutout area.

   **Note:**\  The window can never extend into a cutout area on the long edges
   of the screen.
   The following image is an example of
   ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES`` for a device in portrait:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-short-edges-1.png
      name: short-edge-1
      :alt: An image showing content rendering into the cutout area while in
      portrait mode
      :width: 30.0%

      **Figure 2.** Content rendering into the cutout area while in portrait
      mode.

   The following image is an example of
   ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES`` for a device in landscape:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-short-edges-2.png
      name: short-edge-2
      :alt: An image showing content rendering into the cutout area while in
      landscape mode
      :width: 60.0%

      **Figure 3.** Content rendering into the cutout area while in landscape
      mode.

   In this mode, the window extends under cutouts on the short edge of the
   display in both portrait and landscape, regardless of whether the window is
   hiding the system bars.

   A cutout in the corner is considered to be on the short edge:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-corner.png
      name: cutout-corner
      :alt: An image showing a device with a corner cutout
      :width: 30.0%

      **Figure 4.** A device with a corner cutout.

   .. rubric:: Never render content in the display cutout area
      :name: never

   With ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER``, the window is never allowed to
   overlap with the cutout area.

   The following is an example of ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER`` in
   portrait:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-never.png
      name: cutout-never
      :alt: An image showing the LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER for
      portrait
      :width: 30.0%

      **Figure 5.** Example of ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER`` for
      portrait mode.

   The following is an example of ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER`` in
   landscape mode:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-never-landscape.png
      name: cutout-never-landscape
      :alt: An image showing the LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER for
      landscape
      :width: 60.0%

      **Figure 6.** Example of ``LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER`` in
      landscape mode.

   .. rubric:: Best practices for display cutout support
      :name: best-practices

   When working with display cutouts, consider the following:

   -  Be mindful of the placement of critical elements of the UI. Don't let the
      cutout area obscure any important text, controls, or other information.

   -  Don't place or extend any interactive elements that require fine-touch
      recognition into the cutout area. Touch sensitivity might be lower in the
      cutout area.

   -  Where possible, use
      `WindowInsetsCompat <#androidx.core.view.WindowInsetsCompat>`__
      to retrieve the status bar height and determine the appropriate padding to
      apply to your content. Avoid hardcoding the status bar height, as this can
      lead to overlapping or cut-off content.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-status-bar-1.png
         name: cutout-status-bar
         :alt: An image showing content cut at the top for improper insets setup
         :width: 40.0%

         **Figure 7.** Use ``WindowInsetsCompat`` to avoid overlapping or
         cutting off content.

   -  Use
      `View.getLocationInWindow() <#android.view.View>`__
      to determine how much window space your app is using. Don't assume the app
      is using the entire window, and don't use
      `View.getLocationOnScreen() <#android.view.View>`__.

   -  Use ``shortEdges`` or ``never`` cutout modes if your app needs to
      transition into and out of immersive mode. Default cutout behavior can
      cause content in your app to render in the cutout area while the system
      bars are present, but not while in immersive mode. This results in the
      content moving up and down during transitions, as demonstrated in the
      following example.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-fullscreen.png
         name: cutout-fullscreen
         :alt: An image showing content moving up and down during transitions.
         :width: 40.0%

         **Figure 8.** Example of content moving up and down during transitions.

   -  In immersive mode, be careful using window versus screen coordinates,
      since your app doesn't use the whole screen when letterboxed. Because of
      the letterbox, coordinates from the screen origin aren't the same as
      coordinates from the window origin. You can transform screen coordinates
      to the view's coordinates as needed by using ``getLocationOnScreen()``.
      The following image shows how coordinates differ when content is
      letterboxed:

      .. figure::
         https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-coordinates.png
         name: cutout-coordinates
         :alt: An image showing window versus screen coordinates when content is
         letterboxed.
         :width: 40.0%

         **Figure 9.** Window versus screen coordinates when content is
         letterboxed.

   -  When handling ``MotionEvent``, use
      `MotionEvent.getX() <#android.view.MotionEvent>`__
      and
      `MotionEvent.getY() <#android.view.MotionEvent>`__ to
      avoid similar coordinate issues. Don't use
      `MotionEvent.getRawX() <#android.view.MotionEvent>`__
      or
      `MotionEvent.getRawY() <#android.view.MotionEvent>`__.

   .. rubric:: Test how your content renders
      :name: testing

   Test all of your app's screens and experiences. Test on devices with
   different types of cutouts, if possible. If you don't have a device with a
   cutout, you can simulate common cutout configurations on any device or
   emulator running Android 9 or higher by doing the following:

   #. Enable `Developer options <#>`__.

   #. In the **Developer options** screen, scroll down to the **Drawing**
      section and select **Simulate a display with a cutout**.

   #. Select the cutout type.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/views/layout/display-cutout/images/cutout-example-1.png
         name: simulate
         :alt: An image showing how to simulate a display cutout in the emulator
         :width: 40.0%

         **Figure 10.** Developer options to test how your content renders.

   .. rubric:: Additional resources
      :name: additional-resources

   -  `LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER <#android.view.WindowManager.LayoutParams>`__
   -  `LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES <#android.view.WindowManager.LayoutParams>`__


Last updated 2024-04-15 UTC.



/Control and animate the software keyboard
==========================================

.. https://developer.android.google.cn/develop/ui/views/layout/sw-keyboard?hl=en

.. container:: devsite-article-body

   Using
   `WindowInsetsCompat <#androidx.core.view.WindowInsetsCompat>`__,
   your app can query and control the on-screen keyboard (also called the
   `IME <https://en.wikipedia.org/wiki/Input_method>`__) similar to the way it
   interacts with the system bars. Your app can also use
   `WindowInsetsAnimationCompat <#androidx.core.view.WindowInsetsAnimationCompat>`__
   to create seamless transitions when the software keyboard is opened or
   closed.

   .. container:: float
      :name: open-closed

   .. rubric:: Prerequisites
      :name: prerequisites

   Before setting up control and animation for the software keyboard, configure
   your app to `display edge-to-edge <#>`__. This
   lets it handle `system window insets <#>`__
   such as the system bars and the on-screen keyboard.

   .. rubric:: Check keyboard software visibility
      :name: check-visibility

   Use `WindowInsets <#android.view.WindowInsets>`__ to check the
   software keyboard visibility.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val insets = ViewCompat.getRootWindowInsets(view) ?: return
               val imeVisible = insets.isVisible(WindowInsetsCompat.Type.ime())
               val imeHeight = insets.getInsets(WindowInsetsCompat.Type.ime()).bottom

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WindowInsetsCompat insets = ViewCompat.getRootWindowInsets(view);
               boolean imeVisible = insets.isVisible(WindowInsetsCompat.Type.ime());
               int imeHeight = insets.getInsets(WindowInsetsCompat.Type.ime()).bottom;

   Alternatively, you can use
   `ViewCompat.setOnApplyWindowInsetsListener <#androidx.core.view.ViewCompat>`__
   to observe changes to software keyboard visibility.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ViewCompat.setOnApplyWindowInsetsListener(view) { _, insets ->
                 val imeVisible = insets.isVisible(WindowInsetsCompat.Type.ime())
                 val imeHeight = insets.getInsets(WindowInsetsCompat.Type.ime()).bottom
                 insets
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ViewCompat.setOnApplyWindowInsetsListener(view, (v, insets) -> {
                 boolean imeVisible = insets.isVisible(WindowInsetsCompat.Type.ime());
                 int imeHeight = insets.getInsets(WindowInsetsCompat.Type.ime()).bottom;
                 return insets;
               });

   **Note:**\  To achieve the best backward compatibility with this AndroidX
   implementation, set ``android:windowSoftInputMode="adjustResize"`` to the
   activity in your ``AndroidManifest.xml`` file.

   .. rubric:: Synchronize animation with the software keyboard
      :name: synchronize-animation

   A user tapping a text input field causes the keyboard to slide into place
   from the bottom of the screen, as shown in the following example:

   .. container:: float
      :name: animations

   -  The example labeled "Unsynchronized" in figure 2 shows the default
      behavior in Android 10 (API level 29), in which the text field and content
      of the app snap into place instead of synchronizing with the keyboard's
      animation—behavior that can be visually jarring.

   -  In Android 11 (API level 30) and higher, you can use
      ``WindowInsetsAnimationCompat`` to synchronize the transition of the app
      with the keyboard sliding up and down from the bottom of the screen. This
      looks smoother, as shown in the example labeled "Synchronized" in figure
      2.

   **Note:**\  Don't consume ``WindowInsets`` in
   ``setWindowInsetsApplyListener`` for any parent
   `ViewGroup <#android.view.ViewGroup>`__ objects. Instead, let
   ``WindowInsetsAnimatorCompat`` handle them on Android 10 and lower.
   Configure
   `WindowInsetsAnimationCompat.Callback <#androidx.core.view.WindowInsetsAnimationCompat.Callback>`__
   with the view to be synchronized with the keyboard animation.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ViewCompat.setWindowInsetsAnimationCallback(
                 view,
                 object : WindowInsetsAnimationCompat.Callback(DISPATCH_MODE_STOP) {
                   // Override methods.
                 }
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ViewCompat.setWindowInsetsAnimationCallback(
                   view,
                   new WindowInsetsAnimationCompat.Callback(
                       WindowInsetsAnimationCompat.Callback.DISPATCH_MODE_STOP
                   ) {
                     // Override methods.
                   });

   There are several methods to override in
   ``WindowInsetsAnimationCompat.Callback``, namely
   `onPrepare() <#androidx.core.view.WindowInsetsAnimationCompat.Callback>`__,
   `onStart() <#androidx.core.view.WindowInsetsAnimationCompat.Callback>`__,
   `onProgress() <#androidx.core.view.WindowInsetsAnimationCompat.Callback>`__,
   and
   `onEnd() <#androidx.core.view.WindowInsetsAnimationCompat.Callback>`__.
   Start with calling ``onPrepare()`` before any of the layout changes.

   ``onPrepare`` is called when an insets animation is starting and before the
   views are re-laid out due to an animation. You can use it to save the start
   state, which in this case is the bottom coordinate of the view.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/software-keyboard-3.png
      name: state
      :alt: An image showing the start state bottom coordinate of the root view.
      :width: 50.0%

      **Figure 3.** Using ``onPrepare()`` to record the start state.

   The following snippet shows a sample call to ``onPrepare``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var startBottom = 0f

               override fun onPrepare(
                 animation: WindowInsetsAnimationCompat
               ) {
                 startBottom = view.bottom.toFloat()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               float startBottom;

               @Override
               public void onPrepare(
                   @NonNull WindowInsetsAnimationCompat animation
               ) {
                 startBottom = view.getBottom();
               }

   ``onStart`` is called when an insets animation starts. You can use it to set
   all the view properties to the end state of the layout changes. If you have
   an ``OnApplyWindowInsetsListener`` callback set to any of the views, it is
   already called at this point. This is a good time to save the end state of
   the view properties.

   .. figure:: https://developer.android.google.cn/static/images/guide/navigation/software-keyboard-4.png
      name: end-state
      :alt: An image showing the end state bottom coordinate of the view
      :width: 50.0%

      **Figure 4.** Using ``onStart()`` to record the end state.

   The following snippet shows a sample call to ``onStart``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var endBottom = 0f

               override fun onStart(
                 animation: WindowInsetsAnimationCompat,
                 bounds: WindowInsetsAnimationCompat.BoundsCompat
               ): WindowInsetsAnimationCompat.BoundsCompat {
                 // Record the position of the view after the IME transition.
                 endBottom = view.bottom.toFloat()

                 return bounds
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               float endBottom;

               @NonNull
               @Override
               public WindowInsetsAnimationCompat.BoundsCompat onStart(
                   @NonNull WindowInsetsAnimationCompat animation,
                   @NonNull WindowInsetsAnimationCompat.BoundsCompat bounds
               ) {
                 endBottom = view.getBottom();
                 return bounds;
               }

   ``onProgress`` is called when the insets change as part of running an
   animation, so you can override it and be notified on every frame during the
   keyboard animation. Update the view properties so that the view animates in
   synchronization with the keyboard.

   All the layout changes are complete at this point. For example, if you use
   ``View.translationY`` to shift the view, the value gradually decreases for
   every call of this method and eventually reaches ``0`` to the original layout
   position.

   .. container:: float
      :name: progress

   The following snippet shows a sample call to ``onProgress``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onProgress(
                 insets: WindowInsetsCompat,
                 runningAnimations: MutableList<WindowInsetsAnimationCompat>
               ): WindowInsetsCompat {
                 // Find an IME animation.
                 val imeAnimation = runningAnimations.find {
                   it.typeMask and WindowInsetsCompat.Type.ime() != 0
                 } ?: return insets

                 // Offset the view based on the interpolated fraction of the IME animation.
                 view.translationY =
                   (startBottom - endBottom) * (1 - imeAnimation.interpolatedFraction)

                 return insets
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @NonNull
               @Override
               public WindowInsetsCompat onProgress(
                   @NonNull WindowInsetsCompat insets,
                   @NonNull List<WindowInsetsAnimationCompat> runningAnimations
               ) {
                 // Find an IME animation.
                 WindowInsetsAnimationCompat imeAnimation = null;
                 for (WindowInsetsAnimationCompat animation : runningAnimations) {
                   if ((animation.getTypeMask() & WindowInsetsCompat.Type.ime()) != 0) {
                     imeAnimation = animation;
                     break;
                   }
                 }
                 if (imeAnimation != null) {
                   // Offset the view based on the interpolated fraction of the IME animation.
                   view.setTranslationY((startBottom - endBottom)

                       *   (1 - imeAnimation.getInterpolatedFraction()));
                 }
                 return insets;
               }

   Optionally, you can override ``onEnd``. This method is called after the
   animation is over. This is a good time to clean up any temporary changes.

   .. rubric:: Additional resources
      :name: additional-resources

   -  `WindowInsetsAnimation <https://github.com/android/user-interface-samples/tree/main/WindowInsetsAnimation>`__
      on GitHub.


Last updated 2024-05-03 UTC.


/About web-based content
========================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps?hl=en

.. container:: devsite-article-body

   Android offers a variety of ways to present content to a user. To provide a
   user experience that's consistent with the rest of the platform, it's usually
   best to build a native app that incorporates framework-provided experiences,
   such as `Android App Links <#>`__ or
   `search <#>`__. Additionally, you can use Google
   Play-based experiences, such as `App Actions <#>`__, where
   Google Play services is available. However, some apps might need increased
   control over the UI. In this case, a
   `WebView <#android.webkit.WebView>`__ is a good option for
   displaying trusted first-party content.

   Figure 1 illustrates how you can provide access to your web pages from a
   browser or your own Android app. The ``WebView`` framework lets you specify
   viewport and style properties that make your web pages appear at the proper
   size and scale on all screen configurations for all major web browsers. You
   can define an interface between your Android app and your web pages that lets
   JavaScript in the web pages call APIs in your app, providing Android APIs to
   your web-based application.

   However, don't develop an Android app as a means to view your website.
   Rather, the web pages you embed in your app must be designed specifically for
   that environment.

   .. figure:: https://developer.android.google.cn/static/images/webapps/webapps.png
      name: webapps
      :alt: An image showing how to make your web content available to users
      :width: 50.0%

      **Figure 1.** You can make your web content available to users in two
      ways:
      in a traditional web browser or in an Android application that includes a
      `WebView <#android.webkit.WebView>`__ in the layout.

   .. rubric:: Alternatives to WebView
      :name: alternatives

   Although ``WebView`` objects provide increased control over the UI, there are
   alternatives that might provide similar functionality with less
   configuration, faster loading and performance, improved privacy protections,
   and access to the browser's cookies.

   Consider using these alternatives to ``WebView`` if your app falls into the
   following use cases:

   -  If you want to send users to a mobile site, `build a progressive web app (PWA) <https://web.developers.google.cn/progressive-web-apps/>`__.
   -  If you want to display third-party web content, `send an intent to installed web browsers <#Browser>`__.
   -  If you want to avoid leaving your app to open the browser, or you want to
      customize the browser's UI, use `Custom Tabs <https://developer.chrome.google.cn/docs/android/custom-tabs/>`__.

   .. container:: float
      :name: comparison

   .. rubric:: Additional resources
      :name: additional-resources

   To develop web pages for Android-powered devices using ``WebView`` objects,
   see the following documents:

   -  `Build web apps in WebView <#>`__
   -  `Manage WebView objects <#>`__
   -  `Support different screens in web apps <#>`__
   -  `Debug web apps <#>`__
   -  `Best practices for web apps <#>`__
   -  `Opt-in to WebView Beta <https://play.google.com/apps/testing/com.google.android.webview>`__


Last updated 2024-02-22 UTC.


/Develop web apps in WebView
============================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/webview?hl=en

.. container:: devsite-article-body

   Use `WebView <#android.webkit.WebView>`__ to deliver a web
   application or a web page as a part of a client application. The ``WebView``
   class is an extension of Android's
   `View <#android.view.View>`__ class that lets you display web
   pages as a part of your activity layout. It doesn't include the features of a
   fully developed web browser, such as navigation controls or an address bar.
   All ``WebView`` does, by default, is show a web page.

   ``WebView`` can help you provide information in your app that you might need
   to update, such as an end-user agreement or a user guide. Within your Android
   app, you can create an `Activity <#android.app.Activity>`__
   that contains a ``WebView``, then use it to display your document that's
   hosted online.

   ``WebView`` can also help when your app provides data to the user that
   requires an internet connection to retrieve data, such as email. In this
   case, you might find that it's easier to build a ``WebView`` in your Android
   app that shows a web page with all the user data, rather than performing a
   network request, then parsing the data and rendering it in an Android layout.
   Instead, you can design a web page that's tailored for Android-powered
   devices and then implement a ``WebView`` in your Android app that loads the
   web page.

   This document describes how to get started with ``WebView``, how to bind
   JavaScript from your web page to client-side code in your Android app, how to
   handle page navigation, and how to manage windows when using ``WebView``.

   .. rubric:: Work with WebView on earlier versions of Android
      :name: androidx

   To safely use more-recent ``WebView`` capabilities on the device your app is
   running on, add the `AndroidX Webkit <#androidx.webkit.package-summary>`__ library. This is a
   static library you can add to your application to use ``android.webkit`` APIs
   that aren't available for earlier platform versions.

   Add it to your ``build.gradle`` file as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kts
               :class: two-line-tab

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.webkit:webkit:1.8.0")
               }

         .. container:: section

            .. rubric:: Groovy
               :name: groovy
               :class: two-line-tab

            .. code:: prettyprint

               dependencies {
                   implementation ("androidx.webkit:webkit:1.8.0")
               }

   Explore `the ``WebView``
   example <https://github.com/android/views-widgets-samples/tree/main/WebView>`__
   on GitHub for more details.

   .. rubric:: Add a WebView to your app
      :name: AddingWebView

   To add a ``WebView`` to your app, you can include the ``<WebView>`` element
   in your activity layout or set the entire ``Activity`` window as a
   ``WebView`` in
   `onCreate() <#android.app.Activity>`__.

   .. rubric:: Add a WebView in the activity layout
      :name: add-webview-layout

   To add a ``WebView`` to your app in the layout, add the following code to
   your activity's layout XML file:

   .. code:: prettyprint

      <WebView
          android:id="@+id/webview"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
      />

   To load a web page in the ``WebView``, use
   `loadUrl() <#android.webkit.WebView>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myWebView: WebView = findViewById(R.id.webview)
               myWebView.loadUrl("http://www.example.com")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WebView myWebView = (WebView) findViewById(R.id.webview);
               myWebView.loadUrl("http://www.example.com");

   .. rubric:: Add a WebView in onCreate()
      :name: add-webview-oncreate

   To add a ``WebView`` to your app in an activity's ``onCreate()`` method
   instead, use logic similar to the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myWebView = WebView(activityContext)
               setContentView(myWebView)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WebView myWebView = new WebView(activityContext);
               setContentView(myWebView);

   Then load the page:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               myWebView.loadUrl("http://www.example.com")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               myWebView.loadUrl("https://www.example.com");

   Or load the URL from an HTML string:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create an unencoded HTML string, then convert the unencoded HTML string into
               // bytes. Encode it with base64 and load the data.
               val unencodedHtml =
                    "<html><body>'%23' is the percent code for ‘#‘ </body></html>";
               val encodedHtml = Base64.encodeToString(unencodedHtml.toByteArray(), Base64.NO_PADDING)
               myWebView.loadData(encodedHtml, "text/html", "base64")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create an unencoded HTML string, then convert the unencoded HTML string into
               // bytes. Encode it with base64 and load the data.
               String unencodedHtml =
                    "<html><body>'%23' is the percent code for ‘#‘ </body></html>";
               String encodedHtml = Base64.encodeToString(unencodedHtml.getBytes(),
                       Base64.NO_PADDING);
               myWebView.loadData(encodedHtml, "text/html", "base64");

   **Note:**\  There are restrictions on what this HTML can do. See
   `loadData() <#android.webkit.WebView>`__
   and
   `loadDataWithBaseURL() <#android.webkit.WebView>`__
   for more info about encoding options.
   Your app must have access to the internet. To get internet access, request
   the `INTERNET <#android.Manifest.permission>`__
   permission in your manifest file, as shown in the following example:

   .. code:: prettyprint

      <manifest ... >
          <uses-permission android:name="android.permission.INTERNET" />
          ...
      </manifest>

   You can customize your ``WebView`` by doing any of the following:

   -  Enabling fullscreen support using
      `WebChromeClient <#android.webkit.WebChromeClient>`__. This
      class is also called when a ``WebView`` needs permission to alter the host
      app's UI, such as creating or closing windows or sending JavaScript
      dialogs to the user. To learn more about debugging in this context, read
      `Debug web apps <#>`__.
   -  Handling events that impact content rendering, such as errors on form
      submissions or navigation using
      `WebViewClient <#android.webkit.WebViewClient>`__. You can
      also use this subclass to intercept URL loading.
   -  Enabling JavaScript by modifying
      `WebSettings <#android.webkit.WebSettings>`__.
   -  Using JavaScript to access Android framework objects that you have
      injected into a ``WebView``.

   .. rubric:: Use JavaScript in WebView
      :name: UsingJavaScript

   If the web page you want to load in your ``WebView`` uses JavaScript, you
   must enable JavaScript for your ``WebView``. After you enable JavaScript, you
   can create interfaces between your app code and your JavaScript code.

   .. rubric:: Enable JavaScript
      :name: EnablingJavaScript

   JavaScript is disabled in a ``WebView`` by default. You can enable it through
   the ``WebSettings`` attached to your ``WebView``. Retrieve ``WebSettings``
   with `getSettings() <#android.webkit.WebView>`__,
   then enable JavaScript with
   `setJavaScriptEnabled() <#android.webkit.WebSettings>`__.

   See the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myWebView: WebView = findViewById(R.id.webview)
               myWebView.settings.javaScriptEnabled = true

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WebView myWebView = (WebView) findViewById(R.id.webview);
               WebSettings webSettings = myWebView.getSettings();
               webSettings.setJavaScriptEnabled(true);

   ``WebSettings`` provides access to a variety of other settings that you might
   find useful. For example, if you're developing a web application that's
   designed specifically for the ``WebView`` in your Android app, then you can
   define a custom user agent string with
   `setUserAgentString() <#android.webkit.WebSettings>`__,
   then query the custom user agent in your web page to verify that the client
   requesting your web page is your Android app.

   .. rubric:: Bind JavaScript code to Android code
      :name: BindingJavaScript

   When developing a web application that's designed specifically for the
   ``WebView`` in your Android app, you can create interfaces between your
   JavaScript code and client-side Android code. For example, your JavaScript
   code can call a method in your Android code to display a
   `Dialog <#android.app.Dialog>`__, instead of using JavaScript's
   ``alert()`` function.

   To bind a new interface between your JavaScript and Android code, call
   `addJavascriptInterface() <#android.webkit.WebView>`__,
   passing it a class instance to bind to your JavaScript and an interface name
   that your JavaScript can call to access the class.

   **Warning:**\  Using ``addJavascriptInterface()`` lets JavaScript control
   your Android app. Although this can be useful, it can also be a dangerous
   security issue. When the HTML in the ``WebView`` is untrustworthy—for
   example, part or all of the HTML is provided by an unknown person or
   process—then an attacker can include HTML that executes your client-side code
   and possibly any code of the attacker's choosing. Therefore, don't use
   ``addJavascriptInterface()`` unless you wrote all of the HTML and JavaScript
   that appears in your ``WebView``. Don't let the user navigate within your
   ``WebView`` to web pages that aren't your own. Instead, let the user's
   default browser application open foreign links. By default, the user's web
   browser opens all URL links, so this warning primarily applies if you handle
   page navigation yourself, as described in the following section.
   For example, you can include the following class in your Android app:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               /** Instantiate the interface and set the context.  */
               class WebAppInterface(private val mContext: Context) {

                   /** Show a toast from the web page.  */
                   @JavascriptInterface
                   fun showToast(toast: String) {
                       Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class WebAppInterface {
                   Context mContext;

                   /** Instantiate the interface and set the context. */
                   WebAppInterface(Context c) {
                       mContext = c;
                   }

                   /** Show a toast from the web page. */
                   @JavascriptInterface
                   public void showToast(String toast) {
                       Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();
                   }
               }

   **Caution:**\  If you set your
   `targetSdkVersion <#target>`__ to
   17 or later, add the ``@JavascriptInterface`` annotation to any method that
   you want to be available to your JavaScript. The method must be public. If
   you don't provide this annotation, the method isn't accessible by your web
   page.
   In this example, the ``WebAppInterface`` class lets the web page create a
   `Toast <#android.widget.Toast>`__ message, using the
   ``showToast()`` method.

   You can bind this class to the JavaScript that runs in your ``WebView`` with
   ``addJavascriptInterface()``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val webView: WebView = findViewById(R.id.webview)
               webView.addJavascriptInterface(WebAppInterface(this), "Android")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WebView webView = (WebView) findViewById(R.id.webview);
               webView.addJavascriptInterface(new WebAppInterface(this), "Android");

   This creates an interface called ``Android`` for JavaScript running in the
   ``WebView``. At this point, your web application has access to the
   ``WebAppInterface`` class. For example, here's some HTML and JavaScript that
   creates a toast message using the new interface when the user taps a button:

   .. code:: prettyprint

      <input type="button" value="Say hello" onClick="showAndroidToast('Hello Android!')" />

      <script type="text/javascript">
          function showAndroidToast(toast) {
              Android.showToast(toast);
          }
      </script>

   There's no need to initialize the ``Android`` interface from JavaScript. The
   ``WebView`` automatically makes it available to your web page. So, when a
   user taps the button, the ``showAndroidToast()`` function uses the
   ``Android`` interface to call the ``WebAppInterface.showToast()`` method.

   **Note:**\  The object that is bound to your JavaScript runs in another
   thread and not in the thread in which it is constructed.

   .. rubric:: Handle page navigation
      :name: HandlingNavigation

   When the user taps a link from a web page in your ``WebView``, by default,
   Android launches an app that handles URLs. Usually, the default web browser
   opens and loads the destination URL. However, you can override this behavior
   for your ``WebView`` so links open within your ``WebView``. You can then let
   the user navigate backward and forward through their web page history that's
   maintained by your ``WebView``.

   **Note:**\  For security reasons, the system's browser app doesn't share its
   application data with your app.
   To open links tapped by the user, provide a ``WebViewClient`` for your
   ``WebView`` using
   `setWebViewClient() <#android.webkit.WebView>`__.
   All links the user taps load in your ``WebView``. If you want more control
   over where a clicked link loads, create your own ``WebViewClient`` that
   overrides the
   `shouldOverrideUrlLoading() <#android.webkit.WebViewClient>`__
   method. The following example assumes that ``MyWebViewClient`` is an inner
   class of ``Activity``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private class MyWebViewClient : WebViewClient() {

                   override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
                       if (Uri.parse(url).host == "www.example.com") {
                           // This is your website, so don't override. Let your WebView load
                           // the page.
                           return false
                       }
                       // Otherwise, the link isn't for a page on your site, so launch another
                       // Activity that handles URLs.
                       Intent(Intent.ACTION_VIEW, Uri.parse(url)).apply {
                           startActivity(this)
                       }
                       return true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private class MyWebViewClient extends WebViewClient {
                   @Override
                   public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
                       if ("www.example.com".equals(request.getUrl().getHost())) {
                     // This is your website, so don't override. Let your WebView load the
                     // page.
                     return false;
                   }
                   // Otherwise, the link isn't for a page on your site, so launch another
                   // Activity that handles URLs.
                   Intent intent = new Intent(Intent.ACTION_VIEW, request.getUrl());
                   startActivity(intent);
                   return true;
                 }
               }

   Then create an instance of this new ``WebViewClient`` for the ``WebView``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myWebView: WebView = findViewById(R.id.webview)
               myWebView.webViewClient = MyWebViewClient()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WebView myWebView = (WebView) findViewById(R.id.webview);
               myWebView.setWebViewClient(new MyWebViewClient());

   Now when the user taps a link, the system calls the
   ``shouldOverrideUrlLoading()`` method, which checks whether the URL host
   matches a specific domain, as defined in the preceding example. If it does
   match, then the method returns false and doesn't override the URL loading. It
   lets the ``WebView`` load the URL as usual. If the URL host doesn't match,
   then an `Intent <#android.content.Intent>`__ is created to
   launch the default ``Activity`` for handling URLs, which resolves to the
   user's default web browser.

   .. rubric:: Handle custom URLs
      :name: custom-urls

   ``WebView`` applies restrictions when requesting resources and resolving
   links that use a custom URL scheme. For example, if you implement callbacks
   such as
   `shouldOverrideUrlLoading() <#android.webkit.WebViewClient>`__
   or
   `shouldInterceptRequest() <#android.webkit.WebViewClient>`__,
   then ``WebView`` invokes them only for valid URLs.

   For example, ``WebView`` might not call your ``shouldOverrideUrlLoading()``
   method for links like this:

   .. code:: prettyprint

      <a href="showProfile">Show Profile</a>

   Invalid URLs, like the one shown in the preceding example, are handled
   inconsistently in ``WebView``, so we recommend using a well-formed URL
   instead. You can use a custom scheme or an HTTPS URL for a domain that your
   organization controls.

   Instead of using a simple string in a link, as in the previous example, you
   can use a custom scheme such as the following:

   .. code:: prettyprint

      <a href="example-app:showProfile">Show Profile</a>

   You can then handle this URL in your ``shouldOverrideUrlLoading()`` method
   like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The URL scheme must be non-hierarchical, meaning no trailing slashes.
               const val APP_SCHEME = "example-app:"

               override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
                   return if (url?.startsWith(APP_SCHEME) == true) {
                       urlData = URLDecoder.decode(url.substring(APP_SCHEME.length), "UTF-8")
                       respondToData(urlData)
                       true
                   } else {
                       false
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The URL scheme must be non-hierarchical, meaning no trailing slashes.
               private static final String APP_SCHEME = "example-app:";

               @Override
               public boolean shouldOverrideUrlLoading(WebView view, String url) {
                   if (url.startsWith(APP_SCHEME)) {
                       urlData = URLDecoder.decode(url.substring(APP_SCHEME.length()), "UTF-8");
                       respondToData(urlData);
                       return true;
                   }
                   return false;
               }

   The ``shouldOverrideUrlLoading()`` API is primarily intended for launching
   intents for specific URLs. When implementing it, make sure to return
   ``false`` for URLs the ``WebView`` handles. You aren't limited to launching
   intents, though. You can replace launching intents with any custom behavior
   in the preceding code samples.

   **Caution:**\  Don't call ``loadUrl()``, ``reload()``, or similar methods
   from within ``shouldOverrideUrlLoading()``. This leads to inefficient apps.
   It's more efficient to return ``false`` to let ``WebView`` continue loading
   the URL with its default implementation.

   .. rubric:: Navigate web page history
      :name: NavigatingHistory

   When your ``WebView`` overrides URL loading, it automatically accumulates a
   history of visited web pages. You can navigate backward and forward through
   the history with
   `goBack() <#android.webkit.WebView>`__ and
   `goForward() <#android.webkit.WebView>`__.

   For example, the following shows how your ``Activity`` can use the device
   Back button to navigate backward:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
                   // Check whether the key event is the Back button and if there's history.
                   if (keyCode == KeyEvent.KEYCODE_BACK && myWebView.canGoBack()) {
                       myWebView.goBack()
                       return true
                   }
                   // If it isn't the Back button or there isn't web page history, bubble up to
                   // the default system behavior. Probably exit the activity.
                   return super.onKeyDown(keyCode, event)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onKeyDown(int keyCode, KeyEvent event) {
                   // Check whether the key event is the Back button and if there's history.
                   if ((keyCode == KeyEvent.KEYCODE_BACK) && myWebView.canGoBack()) {
                       myWebView.goBack();
                       return true;
                   }
                   // If it isn't the Back button or there's no web page history, bubble up to
                   // the default system behavior. Probably exit the activity.
                   return super.onKeyDown(keyCode, event);
               }

   If you app uses AndroidX ``AppCompat`` 1.6.0+, you can simplify the previous
   snippet even more:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               onBackPressedDispatcher.addCallback {
                   // Check whether there's history.
                   if (myWebView.canGoBack()) {
                       myWebView.goBack()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               onBackPressedDispatcher.addCallback {
                   // Check whether there's history.
                   if (myWebView.canGoBack()) {
                       myWebView.goBack();
                   }
               }

   The `canGoBack() <#android.webkit.WebView>`__
   method returns true if there is web page history for the user to visit.
   Likewise, you can use
   `canGoForward() <#android.webkit.WebView>`__ to
   check whether there is a forward history. If you don't perform this check,
   then after the user reaches the end of the history, ``goBack()`` and
   ``goForward()`` do nothing.

   .. rubric:: Handle device configuration changes
      :name: handling-changes

   During runtime, activity state changes occur when a device's configuration
   changes, such as when users rotate the device or dismiss an input method
   editor (IME). These changes cause a ``WebView`` object's activity to be
   destroyed and a new activity to be created, which also creates a new
   ``WebView`` object that loads the destroyed object's URL. To modify your
   activity's default behavior, you can change how it handles ``orientation``
   changes in your manifest. To learn more about handling configuration changes
   during runtime, read `Handle configuration changes <#>`__.

   .. rubric:: Manage windows
      :name: web-management

   By default, requests to open new windows are ignored. This is true whether
   they are opened by JavaScript or by the target attribute in a link. You can
   customize your ``WebChromeClient`` to provide your own behavior for opening
   multiple windows.

   To keep your app more secure, it's best to prevent popups and new windows
   from opening. The safest way to implement this behavior is to pass ``"true"``
   into
   `setSupportMultipleWindows() <#android.webkit.WebSettings>`__
   but not override the
   `onCreateWindow() <#android.webkit.WebChromeClient>`__
   method, which ``setSupportMultipleWindows()`` depends on. This logic prevents
   any page that uses ``target="_blank"`` in its links from loading.

Except as otherwise noted, the content of this page is licensed under the
`Creative Commons Attribution 4.0
License <https://creativecommons.org/licenses/by/4.0/>`__, and code samples are
licensed under the `Apache 2.0 License <https://www.apache.org/licenses/LICENSE-2.0>`__. For details, see the
`Google Developers Site
Policies <https://developers.google.cn/site-policies>`__. Java is a registered
trademark of Oracle and/or its affiliates.

Last updated 2024-05-03 UTC.


/Manage WebView objects
=======================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/managing-webview?hl=en

.. container:: devsite-article-body

   Android provides several APIs to help you manage the
   `WebView <#android.webkit.WebView>`__ objects that display web
   content in your app.

   This page describes how to use these APIs to work with ``WebView`` objects
   more effectively, improving your app's stability and security.

   .. rubric:: Version API
      :name: version

   Starting in Android 7.0 (API level 24), users can choose among several
   different packages for displaying web content in a ``WebView`` object. The
   `AndroidX.webkit <#androidx.webkit.package-summary>`__ library
   includes the
   `getCurrentWebViewPackage() <#androidx.webkit.WebViewCompat>`__
   method for fetching information related to the package that is displaying web
   content in your app. This method is useful when analyzing errors that occur
   only when your app tries to display web content using a particular package's
   implementation of ``WebView``.

   To use this method, add the logic shown in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val webViewPackageInfo = WebViewCompat.getCurrentWebViewPackage(appContext)
               Log.d("MY_APP_TAG", "WebView version: ${webViewPackageInfo.versionName}")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               PackageInfo webViewPackageInfo = WebViewCompat.getCurrentWebViewPackage(appContext);
               Log.d("MY_APP_TAG", "WebView version: " + webViewPackageInfo.versionName);

   **Note:** The ``getCurrentWebViewPackage()`` method can return ``null`` if
   the device is set up incorrectly; doesn't support using ``WebView``, such as
   a Wear OS device; or lacks an updatable ``WebView`` implementation.

   .. rubric:: Google Safe Browsing Service
      :name: safe-browsing

   To provide your users with a safer browsing experience, ``WebView`` objects
   verify URLs using `Google Safe Browsing <https://developers.google.cn/safe-browsing/>`__, which lets your
   app show users a warning when they try to navigate to a potentially unsafe
   website.

   Although the default value of ``EnableSafeBrowsing`` is true, there are cases
   when you might want to only enable Safe Browsing conditionally or disable it.
   Android 8.0 (API level 26) and later supports using
   `setSafeBrowsingEnabled() <#androidx.webkit.WebSettingsCompat>`__
   to toggle Safe Browsing for an individual ``WebView`` object.

   If you want all ``WebView`` objects to opt out of Safe Browsing checks, add
   the following ``<meta-data>`` element to your app's manifest file:

   **Note:** The safe browsing manifest opt out doesn't apply to ``WebView``
   within the `SDK Runtime. <#>`__
   .. code:: prettyprint

      <manifest>
          <application>
              <meta-data android:name="android.webkit.WebView.EnableSafeBrowsing"
                         android:value="false" />
              ...
          </application>
      </manifest>

   **Caution:** We recommend keeping Google Safe Browsing enabled at all times
   and designing your app around any constraints this causes.

   .. rubric:: Define programmatic actions
      :name: programmatic-actions

   When an instance of ``WebView`` attempts to load a page that is classified by
   Google as a known threat, the ``WebView`` by default shows an interstitial
   that warns users of the known threat. This screen gives users the option to
   load the URL anyway or return to a previous page that's safe.

   If you target Android 8.1 (API level 27) or later, you can define
   programmatically how your app responds to a known threat in the following
   ways:

   -  You can control whether your app reports known threats to Safe Browsing.
   -  You can make your app automatically perform a particular action—such as
      going back to safety—each time it encounters a URL that's classified as a
      known threat.

   **Note:** For optimal protection against known threats, wait until you
   initialize Safe Browsing before you invoke a ``WebView`` object's
   `loadUrl() <#android.webkit.WebView>`__
   method.
   The following code snippets show how to instruct your app's instances of
   ``WebView`` to always go back to safety after encountering a known threat:

   MyWebActivity.java

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private lateinit var superSafeWebView: WebView
               private var safeBrowsingIsInitialized: Boolean = false

               // ...

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)

                   superSafeWebView = WebView(this)
                   superSafeWebView.webViewClient = MyWebViewClient()
                   safeBrowsingIsInitialized = false

                   if (WebViewFeature.isFeatureSupported(WebViewFeature.START_SAFE_BROWSING)) {
                       WebViewCompat.startSafeBrowsing(this, ValueCallback<Boolean> { success ->
                           safeBrowsingIsInitialized = true
                           if (!success) {
                               Log.e("MY_APP_TAG", "Unable to initialize Safe Browsing!")
                           }
                       })
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private WebView superSafeWebView;
               private boolean safeBrowsingIsInitialized;

               // ...

               @Override
               protected void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);

                   superSafeWebView = new WebView(this);
                   superSafeWebView.setWebViewClient(new MyWebViewClient());
                   safeBrowsingIsInitialized = false;

                   if (WebViewFeature.isFeatureSupported(WebViewFeature.START_SAFE_BROWSING)) {
                       WebViewCompat.startSafeBrowsing(this, new ValueCallback<Boolean>() {
                           @Override
                           public void onReceiveValue(Boolean success) {
                               safeBrowsingIsInitialized = true;
                               if (!success) {
                                   Log.e("MY_APP_TAG", "Unable to initialize Safe Browsing!");
                               }
                           }
                       });
                   }
               }

   MyWebViewClient.java

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyWebViewClient : WebViewClientCompat() {
                   // Automatically go "back to safety" when attempting to load a website that
                   // Google identifies as a known threat. An instance of WebView calls this
                   // method only after Safe Browsing is initialized, so there's no conditional
                   // logic needed here.
                   override fun onSafeBrowsingHit(
                           view: WebView,
                           request: WebResourceRequest,
                           threatType: Int,
                           callback: SafeBrowsingResponseCompat
                   ) {
                       // The "true" argument indicates that your app reports incidents like
                       // this one to Safe Browsing.
                       if (WebViewFeature.isFeatureSupported(WebViewFeature.SAFE_BROWSING_RESPONSE_BACK_TO_SAFETY)) {
                           callback.backToSafety(true)
                           Toast.makeText(view.context, "Unsafe web page blocked.", Toast.LENGTH_LONG).show()
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyWebViewClient extends WebViewClientCompat {
                   // Automatically go "back to safety" when attempting to load a website that
                   // Google identifies as a known threat. An instance of WebView calls this
                   // method only after Safe Browsing is initialized, so there's no conditional
                   // logic needed here.
                   @Override
                   public void onSafeBrowsingHit(WebView view, WebResourceRequest request,
                           int threatType, SafeBrowsingResponseCompat callback) {
                       // The "true" argument indicates that your app reports incidents like
                       // this one to Safe Browsing.
                       if (WebViewFeature.isFeatureSupported(WebViewFeature.SAFE_BROWSING_RESPONSE_BACK_TO_SAFETY)) {
                           callback.backToSafety(true);
                           Toast.makeText(view.getContext(), "Unsafe web page blocked.",
                                   Toast.LENGTH_LONG).show();
                       }
                   }
               }

   .. rubric:: HTML5 Geolocation API
      :name: html5-geolocation

   For apps targeting Android 6.0 (API level 23) and later, the Geolocation API
   is only supported on secure origins, such as HTTPS. Any request to the
   Geolocation API on non-secure origins is automatically denied without
   invoking the corresponding ``onGeolocationPermissionsShowPrompt()`` method.

   .. rubric:: Opt out of metrics collection
      :name: metrics

   ``WebView`` has the ability to upload anonymous diagnostic data to Google
   when the user gives their consent. Data is collected on a per-app basis for
   each app that instantiates a ``WebView``. You can opt out of this feature by
   creating the following tag in the manifest's ``<application>`` element:

   .. code:: prettyprint

      <manifest>
          <application>
          ...
          <meta-data android:name="android.webkit.WebView.MetricsOptOut"
                     android:value="true" />
          </application>
      </manifest>

   Data is only uploaded from an app if the user consents **and** the app
   doesn't opt out. For more information on opting out of diagnostic data
   reporting, see `User privacy in WebView reporting <#>`__.

   .. rubric:: Termination Handling API
      :name: termination-handle

   The Termination Handling API handles cases where the renderer process for a
   ``WebView`` object goes away, either because the system kills the renderer to
   reclaim necessary memory or because the renderer process crashes. By using
   this API, you let your app continue executing, even though the renderer
   process goes away.

   **Caution:** If your app continues executing after the renderer process goes
   away, the associated instance of ``WebView`` can't be reused, even if the
   renderer process is killed or crashes. Your app must remove the instance from
   the view hierarchy and destroy the instance to continue executing. Your app
   must then create a new instance of ``WebView`` to continue rendering web
   pages.
   If a renderer crashes while loading a particular web page, attempting to load
   that same page again can cause a new ``WebView`` object to exhibit the same
   rendering crash behavior.

   The following code snippet illustrates how to use this API within an
   ``Activity``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   
               inner class MyRendererTrackingWebViewClient : WebViewClient() {
                   private var mWebView: WebView? = null

                   override fun onRenderProcessGone(view: WebView, detail: RenderProcessGoneDetail): Boolean {
                       if (!detail.didCrash()) {
                           // Renderer is killed because the system ran out of memory. The app
                           // can recover gracefully by creating a new WebView instance in the
                           // foreground.
                           Log.e("MY_APP_TAG", ("System killed the WebView rendering process " +
                               "to reclaim memory. Recreating..."))

                           mWebView?.also { webView ->
                               val webViewContainer: ViewGroup = findViewById(R.id.my_web_view_container)
                               webViewContainer.removeView(webView)
                               webView.destroy()
                               mWebView = null
                           }

                           // By this point, the instance variable "mWebView" is guaranteed to
                           // be null, so it's safe to reinitialize it.

                           return true // The app continues executing.
                       }

                       // Renderer crashes because of an internal error, such as a memory
                       // access violation.
                       Log.e("MY_APP_TAG", "The WebView rendering process crashed!")

                       // In this example, the app itself crashes after detecting that the
                       // renderer crashed. If you handle the crash more gracefully and let
                       // your app continue executing, you must destroy the current WebView
                       // instance, specify logic for how the app continues executing, and
                       // return "true" instead.
                       return false
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyRendererTrackingWebViewClient extends WebViewClient {
                   private WebView mWebView;

                   @Override
                   public boolean onRenderProcessGone(WebView view,
                           RenderProcessGoneDetail detail) {
                       if (!detail.didCrash()) {
                           // Renderer is killed because the system ran out of memory. The app
                           // can recover gracefully by creating a new WebView instance in the
                           // foreground.
                           Log.e("MY_APP_TAG", "System killed the WebView rendering process " +
                                   "to reclaim memory. Recreating...");

                           if (mWebView != null) {
                               ViewGroup webViewContainer =
                                       (ViewGroup) findViewById(R.id.my_web_view_container);
                               webViewContainer.removeView(mWebView);
                               mWebView.destroy();
                               mWebView = null;
                           }

                           // By this point, the instance variable "mWebView" is guaranteed to
                           // be null, so it's safe to reinitialize it.

                           return true; // The app continues executing.
                       }

                       // Renderer crashes because of an internal error, such as a memory
                       // access violation.
                       Log.e("MY_APP_TAG", "The WebView rendering process crashed!");

                       // In this example, the app itself crashes after detecting that the
                       // renderer crashed. If you handle the crash more gracefully and let
                       // your app continue executing, you must destroy the current WebView
                       // instance, specify logic for how the app continues executing, and
                       // return "true" instead.
                       return false;
                   }
               }

   .. rubric:: Renderer Importance API
      :name: renderer-importance

   When ``WebView`` objects `operate in multiprocess mode <#security-all>`__, you have
   some flexibility in how your app handles out-of-memory situations. You can
   use the Renderer Importance API, introduced in Android 8.0, to set a priority
   policy for the renderer assigned to a particular ``WebView`` object. In
   particular, you might want the main part of your app to continue executing
   when a renderer that displays your app's ``WebView`` objects is killed. You
   might do this, for example, if you expect to not show the ``WebView`` object
   for a long time so that the system can reclaim memory that the renderer was
   using.

   The following code snippet shows how to assign a priority to the renderer
   process associated with your app's ``WebView`` objects:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myWebView: WebView = ...
               myWebView.setRendererPriorityPolicy(RENDERER_PRIORITY_BOUND, true)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WebView myWebView;
               myWebView.setRendererPriorityPolicy(RENDERER_PRIORITY_BOUND, true);

   In this particular snippet, the renderer's priority is the same as—or is
   bound to—the default priority for the app. The ``true`` argument decreases
   the renderer's priority to
   `RENDERER_PRIORITY_WAIVED <#android.webkit.WebView>`__
   when the associated ``WebView`` object is no longer visible. In other words,
   a ``true`` argument indicates that your app doesn't care whether the system
   keeps the renderer process alive. In fact, this lower priority level makes it
   likely that the renderer process is killed in out-of-memory situations.

   **Warning:** To maintain app stability, don't change the renderer priority
   policy for a ``WebView`` object unless you also use the `Termination Handling API <#termination-handle>`__ to specify how the ``WebView`` reacts when its
   associated renderer goes away.
   To learn more about how the system handles low-memory situations, see
   `Processes and app lifecycle <#>`__.


Last updated 2024-02-22 UTC.


/Load local content
===================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/load-local-content?hl=en

.. container:: devsite-article-body

   You can provide web-based content—such as HTML, JavaScript, and CSS—for your
   app to use that you statically compile into the app rather than fetch over
   the internet.

   In-app content doesn't require internet access or consume a user's bandwidth.
   If the content is designed specifically for ``WebView`` only—that is, it
   depends on communicating with a native app—then users can't accidentally load
   it in a web browser.

   However, there are some drawbacks to in-app content. Updating web-based
   content requires shipping a new app update, and there is the possibility of
   mismatched content between what's on a website and what's in the app on your
   device if users have outdated app versions.

   .. rubric:: WebViewAssetLoader
      :name: assetloader

   `WebViewAssetLoader <#androidx.webkit.WebViewAssetLoader>`__ is
   a flexible and performant way to load in-app content in a
   `WebView <#android.webkit.WebView>`__ object. This class
   supports the following:

   -  Loading content with an HTTP(S) URL for compatibility with the
      `same-origin policy <https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy>`__.
   -  Loading subresources such as JavaScript, CSS, images, and iframes.

   Include ``WebViewAssetLoader`` in your main activity file. The following is
   an example of loading simple web content from the assets folder:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private class LocalContentWebViewClient(private val assetLoader: WebViewAssetLoader) : WebViewClientCompat() {
                   @RequiresApi(21)
                   override fun shouldInterceptRequest(
                       view: WebView,
                       request: WebResourceRequest
                   ): WebResourceResponse? {
                       return assetLoader.shouldInterceptRequest(request.url)
                   }

                   // To support API < 21.
                   override fun shouldInterceptRequest(
                       view: WebView,
                       url: String
                   ): WebResourceResponse? {
                       return assetLoader.shouldInterceptRequest(Uri.parse(url))
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static class LocalContentWebViewClient extends WebViewClientCompat {

                   private final WebViewAssetLoader mAssetLoader;

                   LocalContentWebViewClient(WebViewAssetLoader assetLoader) {
                       mAssetLoader = assetLoader;
                   }

                   @Override
                   @RequiresApi(21)
                   public WebResourceResponse shouldInterceptRequest(WebView view,
                                                    WebResourceRequest request) {
                       return mAssetLoader.shouldInterceptRequest(request.getUrl());
                   }

                   @Override
                   @SuppressWarnings("deprecation") // To support API < 21.
                   public WebResourceResponse shouldInterceptRequest(WebView view,
                                                    String url) {
                       return mAssetLoader.shouldInterceptRequest(Uri.parse(url));
                   }
               }

   Your app must configure a ``WebViewAssetLoader`` instance to suit its needs.
   The next section has an example.

   .. rubric:: Create in-app assets and resources
      :name: create-assets

   ``WebViewAssetLoader`` relies on
   `PathHandler <#androidx.webkit.WebViewAssetLoader.PathHandler>`__
   instances to load resources corresponding to a given resource path. Although
   you can implement this interface to retrieve resources as needed by your app,
   the Webkit library bundles
   `AssetsPathHandler <#>`__
   and
   `ResourcesPathHandler <#>`__
   for loading Android assets and resources, respectively.

   To get started, create assets and resources for your app. Generally, the
   following applies:

   -  Text files like HTML, JavaScript, and CSS belong in assets.
   -  Images and other binary files belong in resources.

   To add text-based web files to a project, do the following:

   #. In Android Studio, right-click the **app > src > main** folder and then
      choose **New > Directory**.
      .. figure:: https://developer.android.google.cn/static/images/guide/webapps/create-assets-directory.png
         name: create-asset-folder
         :alt: An image showing Android Studio create-directory menus
         :width: 100.0%

         **Figure 1.** Create an assets folder for your project.

   #. Name the folder "assets".
      .. figure:: https://developer.android.google.cn/static/images/guide/webapps/name-assets-directory.png
         name: folder
         :alt: An image showing the asset folder
         :width: 50.0%

         **Figure 2.** Name the assets folder.

   #. Right-click the **assets** folder and then click **New > File**. Enter
      ``index.html`` and press the Return or Enter key.
      .. figure:: https://developer.android.google.cn/static/images/guide/webapps/create-webview-file.png
         name: menu
         :alt: An image of Android Studio create file menu
         :width: 50.0%

         **Figure 3.** Create the ``index.html`` file.

   #. Repeat the previous step to create an empty file for ``stylesheet.css``.
   #. Fill in the empty files you created with the content in the next two code
      samples.

   .. code:: prettyprint

      ```html
      <!-- index.html content -->

      <html>
        <head>
          <!-- Tip: Use relative URLs when referring to other in-app content to give
                    your app code the flexibility to change the scheme or domain as
                    necessary. -->
          <link rel="stylesheet" href="/assets/stylesheet.css">
        </head>
        <body>
          <p>This file is loaded from in-app content.</p>
          <p><img src="/res/drawable/android_robot.png" alt="Android robot" width="100"></p>
        </body>
      </html>
      ```

      ```css
      <!-- stylesheet.css content -->

      body {
        background-color: lightblue;
      }
      ```

   To add an image-based web file to your project, do the following:

   #. Download the
      `Android_symbol_green_RGB.png <https://source.android.google.cn/setup/images/Android_symbol_green_RGB.png>`__
      file to your local machine.

   #. Rename the file to ``android_robot.png``.

   #. Manually move the file into your project's ``main/res/drawable`` directory
      on your hard drive.

   Figure 4 shows the image you added and the text from the preceding code
   samples rendered in an app.

   .. figure:: https://developer.android.google.cn/static/images/guide/webapps/rendered-html.png
      name: rendered
      :alt: An image showing app rendered output
      :width: 40.0%

      **Figure 4.** In-app HTML file and image file rendered in an app.

   To complete the app, do the following:

   #. Register the handlers and configure the ``AssetLoader`` by adding the
      following code to the ``onCreate()`` method:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val assetLoader = WebViewAssetLoader.Builder()
                                         .addPathHandler("/assets/", AssetsPathHandler(this))
                                         .addPathHandler("/res/", ResourcesPathHandler(this))
                                         .build()
                  webView.webViewClient = LocalContentWebViewClient(assetLoader)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  final WebViewAssetLoader assetLoader = new WebViewAssetLoader.Builder()
                           .addPathHandler("/assets/", new WebViewAssetLoader.AssetsPathHandler(this))
                           .addPathHandler("/res/", new WebViewAssetLoader.ResourcesPathHandler(this))
                           .build();
                  mWebView.setWebViewClient(new LocalContentWebViewClient(assetLoader));

   #. Load the content by adding the following code to the ``onCreate()``
      method:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  webView.loadUrl("https://appassets.androidplatform.net/assets/index.html")

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  mWebView.loadUrl("https://appassets.androidplatform.net/assets/index.html");

   .. rubric:: Mix in-app content with resources from your website
      :name: mix-content

   Your app might need to load a mix of in-app content and content from the
   internet, such as an in-app HTML page styled by your website's CSS.
   ``WebViewAssetLoader`` supports this use case. If none of the registered
   ``PathHandler`` instances can find a resource for the given path, ``WebView``
   falls back to loading content from the internet. If you mix in-app content
   with resources from your website, reserve directory paths, such as
   ``/assets/`` or ``/resources/``, for in-app resources. Avoid storing any
   resources from your website in those locations.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val assetLoader = WebViewAssetLoader.Builder()
                                       .setDomain("example.com") // Replace this with your website's domain.
                                       .addPathHandler("/assets/", AssetsPathHandler(this))
                                       .build()

               webView.webViewClient = LocalContentWebViewClient(assetLoader)
               val inAppHtmlUrl = "https://example.com/assets/index.html"
               webView.loadUrl(inAppHtmlUrl)
               val websiteUrl = "https://example.com/website/data.json"

               // JavaScript code to fetch() content from the same origin.
               val jsCode = "fetch('$websiteUrl')" +
                       ".then(resp => resp.json())" +
                       ".then(data => console.log(data));"

               webView.evaluateJavascript(jsCode, null)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               final WebViewAssetLoader assetLoader = new WebViewAssetLoader.Builder()
                          .setDomain("example.com") // Replace this with your website's domain.
                          .addPathHandler("/assets/", new AssetsPathHandler(this))
                          .build();

               mWebView.setWebViewClient(new LocalContentWebViewClient(assetLoader));
               String inAppHtmlUrl = "https://example.com/assets/index.html";
               mWebView.loadUrl(inAppHtmlUrl);
               String websiteUrl = "https://example.com/website/data.json";

               // JavaScript code to fetch() content from the same origin.
               String jsCode = "fetch('" + websiteUrl + "')" +
                     ".then(resp => resp.json())" +
                     ".then(data => console.log(data));";

               mWebView.evaluateJavascript(jsCode, null);

   See the `WebView demo on GitHub <https://github.com/android/views-widgets-samples/tree/main/WebView>`__
   for an example of an in-app HTML page fetching web-hosted JSON data.

   .. rubric:: loadDataWithBaseURL
      :name: loadDataWithBaseUrl

   When your app only needs to load an HTML page and doesn't need to intercept
   subresources, consider using
   `loadDataWithBaseURL() <#android.webkit.WebView>`__,
   which doesn't require app assets. You can use it as shown in the following
   code sample:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val html = "<html><body><p>Hello world</p></body></html>"
               val baseUrl = "https://example.com/"

               webView.loadDataWithBaseURL(baseUrl, html, "text/html", null, baseUrl)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String html = "<html><body><p>Hello world</p></body></html>";
               String baseUrl = "https://example.com/";

               mWebView.loadDataWithBaseURL(baseUrl, html, "text/html", null, baseUrl);

   Choose argument values carefully. Consider the following:

   -  ``baseUrl``: this is the URL your HTML content is loaded as. This must be
      an HTTP(S) URL.
   -  ``data``: this is the HTML content you want to display, as a string.
   -  ``mimeType``: this must usually be set to ``text/html``.
   -  ``encoding``: this is unused when ``baseUrl`` is an HTTP(S) URL, so it can
      be set to ``null``.
   -  ``historyUrl``: this is set to the same value as ``baseUrl``.

   We strongly recommend using an HTTP(S) URL as the ``baseUrl``, as this helps
   ensure your app complies with the same-origin policy.

   If you can't find a suitable ``baseUrl`` for your content and prefer to use
   `loadData() <#android.webkit.WebView>`__,
   you **must encode the content** with
   `percent-encoding <https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding>`__
   or `Base64 encoding <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs#encoding_data_into_base64_format>`__.
   We strongly recommend choosing Base64 encoding and using Android APIs to
   encode this programmatically, as shown in the following code sample:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val encodedHtml: String = Base64.encodeToString(html.toByteArray(), Base64.NO_PADDING)

               webView.loadData(encodedHtml, mimeType, "base64")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String encodedHtml = Base64.encodeToString(html.getBytes(), Base64.NO_PADDING);

               mWebView.loadData(encodedHtml, mimeType, "base64");

   **Caution:**\  By default, ``loadData()`` expects the HTML data to be
   percent-encoded. Percent-encoding by hand is error prone, and there are no
   Android APIs to do this programmatically. We strongly recommend switching to
   ``loadDataWithBaseURL()`` to avoid this requirement or using Base64 APIs to
   encode the content, as shown in the preceding code sample.

   .. rubric:: Things to avoid
      :name: antipatterns

   There are several other ways to load in-app content, but we strongly
   recommend against them:

   -  ``file://`` URLs and ``data:`` URLs are considered to be *opaque origins*,
      meaning they can't take advantage of powerful web APIs such as
      `fetch() <https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch>`__
      or
      `XMLHttpRequest <https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest>`__.
      ``loadData()`` internally uses ``data:`` URLs, so we encourage using
      ``WebViewAssetLoader`` or ``loadDataWithBaseURL()`` instead.
   -  Although
      `WebSettings.setAllowFileAccessFromFileURLs() <#android.webkit.WebSettings>`__
      and
      `WebSettings.setAllowUniversalAccessFromFileURLs() <#android.webkit.WebSettings>`__
      can work around the issues with ``file://`` URLs, we recommend against
      setting these to ``true`` because doing so leaves your app vulnerable to
      file-based exploits. We recommend explicitly setting these to ``false`` on
      all API levels for the strongest security.
   -  For the same reasons, we recommend against ``file://android_assets/`` and
      ``file://android_res/`` URLs. The ``AssetsHandler`` and
      ``ResourcesHandler`` classes are meant to be drop-in replacements.
   -  Avoid using
      `MIXED_CONTENT_ALWAYS_ALLOW <#android.webkit.WebSettings>`__.
      This setting generally isn't necessary and weakens the security of your
      app. We recommend loading your in-app content over the same scheme—HTTP or
      HTTPS—as your website's resources and using
      `MIXED_CONTENT_COMPATIBILITY_MODE <#android.webkit.WebSettings>`__
      or
      `MIXED_CONTENT_NEVER_ALLOW <#android.webkit.WebSettings>`__,
      as appropriate.


Last updated 2024-02-22 UTC.


/Darken web content
===================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/dark-theme?hl=en

.. container:: devsite-article-body

   In Android 10 and higher, an app can support a `Dark theme <#>`__ and automatically change
   between light and dark app themes according to the system theme. To match the
   current app theme, web content in
   `WebView <#android.webkit.WebView>`__ can also use light, dark, or
   default styling.

   WebView's behavior interoperates with the
   `prefers-color-scheme <https://www.w3.org/TR/mediaqueries-5/#descdef-media-prefers-color-scheme>`__
   and
   `color-scheme <https://www.w3.org/TR/css-color-adjust-1/#propdef-color-scheme>`__
   web standards. Whenever possible, if you author the web content that you want
   your app to display in WebView, you should `define a dark theme for your website <https://web.developers.google.cn/prefers-color-scheme/#supporting-dark-mode>`__
   and implement ``prefers-color-scheme`` so that WebView can match the web
   content's theme to your app's theme.

   The following table describes how WebView renders web content in your app,
   depending on the web content's styling and your app's conditions:

   .. list-table::
      :widths: 27 27 27
      :header-rows: 1

      - 

         - App conditions
         - Web content that uses ``prefers-color-scheme``
         - Web content that doesn't use ``prefers-color-scheme``
      - 

         - App is using a light theme with
            `isLightTheme <#android.R.styleable>`__
            set to ``true`` or not set.
         - WebView renders the content with the light theme that
            the content author has defined.
         - WebView renders the content with the default styling defined by the
            content author.
      - 

         - App is using `Force Dark <#force-dark>`__ to
            `algorithmically apply a dark theme <#algorithmic-darkening>`__ to
            the app.
         - WebView renders the content with the dark theme that
            the content author has defined.
         - If allowed by the content author, WebView renders the content with a
            dark theme that is generated using an algorithm.
      - 

         - 
         - 
         - 
      - 

         - App is using a dark theme with
            `isLightTheme <#android.R.styleable>`__
            set to ``false`` and the app *doesn't allow* algorithmic darkening
            for WebView.
         - WebView renders the content with the dark theme that
            the content author has defined.
         - WebView renders the content with the default styling defined by the
            content author.
      - 

         - App is using a dark theme with
            `isLightTheme <#android.R.styleable>`__
            set to ``false`` and the app *does allow* 
            `algorithmic darkening for WebView <#algorithmic-darkening>`__.
         - WebView renders the content with the dark theme that
            the content author has defined.
         - If allowed by the content author, WebView renders the content with a
            dark theme that is generated using an algorithm.

   .. rubric:: Content-author styling
      :name: author-styling

   An app's
   `isLightTheme <#android.R.styleable>`__
   attribute indicates if the app's theme is light or dark. WebView always sets
   ``prefers-color-scheme`` according to ``isLightTheme``. If ``isLightTheme``
   is ``true`` or not specified, then ``prefers-color-scheme`` is ``light``;
   otherwise, it is ``dark``.

   This means that if the web content uses ``prefers-color-scheme`` and the
   content author allows it, the light or dark theme defined by the content
   author is always automatically applied to the web content to match the app's
   theme.

   .. rubric:: Algorithmic darkening
      :name: algorithmic-darkening

   To cover cases where web content doesn't use
   `prefers-color-scheme <https://www.w3.org/TR/mediaqueries-5/#descdef-media-prefers-color-scheme>`__,
   your app can allow WebView, when necessary, to algorithmically apply a dark
   theme to web content that it renders.

   If your app is using the app-level `Force Dark <#force-dark>`__ to algorithmically
   apply a dark theme to your app, see the following section that describes how
   to `allow algorithmic darkening for web content with Force Dark <#app-force-dark>`__.

   If your app is not using Force Dark, how your app specifies when to allow
   algorithmic darkening in WebView depends on your app's `target API level <#target>`__. See the following
   sections for `apps targeting Android 13 or higher <#13>`__ and `apps targeting Android 12 or lower <#12>`__ for details.

   .. rubric:: Allow algorithmic darkening for web content with Force Dark
      :name: app-force-dark

   If your app is using the app-level `Force Dark <#force-dark>`__, WebView applies
   algorithmic darkening to web content if the following conditions are met:

   -  The WebView and its parent elements allow Force Dark.
   -  The current activity theme is marked as light with
      `isLightTheme <#android.R.styleable>`__
      set to ``true``.
   -  The web content author doesn't explicitly disable darkening.
   -  For apps targeting Android 13 (API level 33) or higher, the web content
      doesn't use ``prefers-color-scheme``.
   -  For apps targeting Android 12 (API level 32) or lower: The app has set
      `WebView's ``forceDarkMode``
      setting <#androidx.webkit.WebSettingsCompat>`__
      to
      `FORCE_DARK_AUTO <#androidx.webkit.WebSettingsCompat>`__
      and has set their Force Dark strategy to
      `DARK_STRATEGY_USER_AGENT_DARKENING_ONLY <#DARK_STRATEGY_USER_AGENT_DARKENING_ONLY()>`__.

   WebView and all its parents can allow force dark using
   `View.setForceDarkAllowed() <#android.view.View>`__.
   The default value is taken from the ``setForceDarkAllowed()`` attribute of
   the Android theme, which must also be set to ``true``.

   Force Dark mode is provided primarily for backward-compatibility in apps that
   don't `provide their own dark theme <#>`__.
   If your app uses Force Dark, we recommend `adding support for a dark theme <#support-dark-theme>`__.

   .. rubric:: Allow algorithmic darkening (apps targeting Android 13 or higher)
      :name: 13

   For apps that aren't using app-level Force Dark and target Android 13 (API
   level 33) or higher, use the AndroidX
   `setAlgorithmicDarkeningAllowed() <#androidx.webkit.WebSettingsCompat>`__
   method and pass in ``true`` to specify that a WebView should allow
   algorithmic darkening. This method has backward compatibility with previous
   Android versions.

   WebView then applies algorithmic darkening if the following conditions are
   met:

   -  The web content doesn't use ``prefers-color-scheme``.
   -  The web content author doesn't explicitly disable darkening.

   .. rubric:: Allow algorithmic darkening (apps targeting Android 12 or lower)
      :name: 12

   For apps that aren't using app-level Force Dark and target Android 12 (API
   level 32) or lower, use `FORCE_DARK_ON <#androidx.webkit.WebSettingsCompat>`__
   to allow algorithmic darkening.

   Use ``FORCE_DARK_ON`` together with `FORCE_DARK_OFF <#androidx.webkit.WebSettingsCompat>`__
   if your app provides its own method for switching between light and dark
   themes, such as a toggleable element in the UI or an automatic time-based
   selection.

   To check whether the feature is supported, add the following lines of code
   wherever you configure your WebView object, such as in ``Activity.onCreate``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK)) {
                   WebSettingsCompat.setForceDark(...)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK)) {
                   WebSettingsCompat.setForceDark(...);
               }

   If your app relies on detecting changes to system preferences, your app
   should explicitly listen for theme changes and apply these to WebView with
   ``FORCE_DARK_ON`` and ``FORCE_DARK_OFF`` states.

   The following code snippet shows how to change the theme format:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK)) {
                   when (resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK) {
                       Configuration.UI_MODE_NIGHT_YES -> {
                           WebSettingsCompat.setForceDark(myWebView.settings, FORCE_DARK_ON)
                       }
                       Configuration.UI_MODE_NIGHT_NO, Configuration.UI_MODE_NIGHT_UNDEFINED -> {
                           WebSettingsCompat.setForceDark(myWebView.settings, FORCE_DARK_OFF)
                       }
                       else -> {
                           //
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK)) {
                   switch (getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK) {
                       case Configuration.UI_MODE_NIGHT_YES:
                           WebSettingsCompat.setForceDark(myWebView.getSettings(), FORCE_DARK_ON);
                           break;
                       case Configuration.UI_MODE_NIGHT_NO:
                       case Configuration.UI_MODE_NIGHT_UNDEFINED:
                           WebSettingsCompat.setForceDark(myWebView.getSettings(), FORCE_DARK_OFF);
                           break;
                   }
               }

   .. rubric:: Customize dark theme handling
      :name: customize

   You can also use the `ForceDarkStrategy API <#androidx.webkit.WebSettingsCompat>`__
   in AndroidX to control how darkening is applied to a given WebView. This API
   is applicable only if force dark is set to ``FORCE_DARK_ON`` or
   ``FORCE_DARK_AUTO``.

   Using the API, your app can use either web theme darkening or user-agent
   darkening:

   -  **Web theme darkening**: Web developers might apply
      ``@media (prefers-color-scheme: dark)`` to control web page appearance in
      dark mode. WebView renders content according to these settings. For more
      about web theme darkening, see the
      `specification <https://drafts.csswg.org/css-color-adjust-1/#preferred>`__.
   -  **User-agent darkening**: the WebView automatically inverts colors of the
      web page. If you use user-agent darkening, the
      ``@media (prefers-color-scheme: dark)`` query evaluates to ``false``.

   To choose between the two strategies, use the following API:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK_STRATEGY)) {
                   WebSettingsCompat.setForceDarkStrategy(...)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK_STRATEGY)) {
                   WebSettingsCompat.setForceDarkStrategy(...);
               }

   The supported strategy options are:

   -  `DARK_STRATEGY_PREFER_WEB_THEME_OVER_USER_AGENT_DARKENING <#androidx.webkit.WebSettingsCompat>`__:
      This is the default option. While most browsers treat the
      ``<meta name="color-scheme" content="dark light">`` tag as optional,
      Android WebView's default mode requires the meta tag to honor the web
      page's ``prefers-color-scheme`` media queries. You can use WebViews with
      `DARK_STRATEGY_WEB_THEME_DARKENING_ONLY <#androidx.webkit.WebSettingsCompat>`__
      mode, in which case WebView always applies media queries even if the tag
      is omitted.

      However, we recommend web developers add
      ``<meta name="color-scheme" content="dark light">`` tag to their websites
      to ensure that content renders correctly in WebViews with the default
      configuration.

   -  `DARK_STRATEGY_USER_AGENT_DARKENING_ONLY <#androidx.webkit.WebSettingsCompat>`__:
      Called "user-agent darkening," the WebView ignores any web page darkening
      and applies automatic darkening.

   If your app shows first-party web content that you customized with the
   ``prefers-color-scheme`` media query, we recommend
   ``DARK_STRATEGY_WEB_THEME_DARKENING_ONLY`` to ensure WebView uses the custom
   theme.

   For an example of dark theme applied, see the 
   `WebView demo on GitHub <https://github.com/android/views-widgets-samples/tree/main/WebView>`__


Last updated 2024-02-22 UTC.


/Support different screens in web apps
======================================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/targeting?hl=en

.. container:: devsite-article-body

   Because Android is available on devices with a variety of screen sizes and
   pixel densities, account for these factors in your web design so that your
   pages are appropriately sized.
   `WebView <#android.webkit.WebView>`__ supports DOM, CSS, and
   meta tag features to help you render your web content appropriately.

   When targeting your web pages for Android-powered devices, there are two
   major factors to account for:

   `The viewport <#Viewport>`__
      The viewport is the rectangular area that provides a drawable region for
      your web page. You can specify several viewport properties, such as its
      size and initial scale. Most important is the viewport width, which
      defines the total number of horizontal pixels available from the web
      page's point of view—the number of CSS pixels available.
   `The screen density <#DensityCSS>`__
      The ``WebView`` class and most web browsers on Android convert your CSS
      pixel values to density-independent pixel values, so your web page appears
      at the same perceivable size as a medium-density screen—about 160 dpi.
      However, if graphics are an important element of your web design, pay
      attention to the scaling that occurs on different densities. For example,
      an image that is 300 px wide on a 320 dpi screen is scaled up—it uses more
      physical pixels per CSS pixel. This can produce artifacts like blurring
      and pixelation. For simplicity, Android collapses most smaller screen
      densities into a few general categories: small, medium, and large. To
      learn more about screen density, read `Support different pixel densities <#>`__.

   Refer to the following related resources:

   -  `Pixel-Perfect UI in the WebView <https://developers.google.cn/chrome/mobile/docs/webview/pixelperfect>`__
   -  `Learn Responsive Design <http://www.html5rocks.com/en/mobile/responsivedesign/>`__
   -  `High DPI images for variable pixel densities <http://www.html5rocks.com/en/mobile/high-dpi/>`__

   .. rubric:: Specify viewport properties
      :name: Viewport

   The viewport is the area in which your web page is drawn. Although the
   viewport's total visible area matches the size of the screen when zoomed all
   the way out, the viewport has its own pixel dimensions that it makes
   available to a web page. For example, although a device screen might have a
   physical width of 480 pixels, the viewport can have a width of 800 pixels.
   This lets a web page designed at 800 pixels wide be completely visible on the
   screen when the viewport scale is 1.0.

   Most web browsers on Android—including Chrome—set the viewport to a large
   size by default. This \_wide viewport mode\_ is about 980 px wide. Many
   browsers also zoom out as far as possible by default to show the full
   viewport width, known as \_overview mode\_.

   **Note:** When your page is rendered in a ``WebView``, it doesn't use wide
   viewport mode by default. You can enable wide viewport mode with
   `setUseWideViewPort() <#android.webkit.WebSettings>`__.
   You can define properties of the viewport for your web page, such as the
   width and initial zoom level, using the ``<meta name="viewport" ...>`` tag in
   your document ``<head>``.

   The following syntax shows all the supported viewport properties and the
   types of values accepted by each one:

   .. code:: prettyprint

      <meta name="viewport"
            content="
                height = [pixel_value | "device-height"] ,
                width = [pixel_value | "device-width"] ,
                initial-scale = float_value ,
                minimum-scale = float_value ,
                maximum-scale = float_value ,
                user-scalable = ["yes" | "no"]
                " />

   For example, the following ``<meta>`` tag specifies that the viewport width
   matches the device screen's width and that the ability to zoom is disabled:

   .. code:: prettyprint

      <head>
          <title>Example</title>
          <meta name="viewport" content="width=device-width, user-scalable=no" />
      </head>

   When optimizing your site for mobile devices, you usually set the width to
   ``"device-width"`` so the size fits exactly on all devices, then use CSS
   media queries to flexibly adapt layouts to suit different screen sizes.

   **Note:** Disable user scaling only when you're certain that your web page
   layout is flexible and the content fits the width of small screens.

   .. rubric:: Target device density with CSS
      :name: DensityCSS

   ``WebView`` supports ``-webkit-device-pixel-ratio``, which is a CSS media
   feature that lets you create styles for specific screen densities. The value
   you apply to this feature must be 0.75, 1, or 1.5, to indicate that the
   styles are for devices with low-, medium-, or high-density screens,
   respectively.

   You can create separate stylesheets for each density:

   .. code:: prettyprint

      <link rel="stylesheet" media="screen and (-webkit-device-pixel-ratio: 1.5)" href="hdpi.css" />
      <link rel="stylesheet" media="screen and (-webkit-device-pixel-ratio: 1.0)" href="mdpi.css" />

   Or specify the different styles in one stylesheet:

   .. code:: none

      #header {
          background:url(medium-density-image.png);
      }

      @media screen and (-webkit-device-pixel-ratio: 1.5) {
          /* CSS for high-density screens */
          #header {
              background:url(high-density-image.png);
          }
      }

      @media screen and (-webkit-device-pixel-ratio: 0.75) {
          /* CSS for low-density screens */
          #header {
              background:url(low-density-image.png);
          }
      }

   For more information about handling different screen densities, especially
   images, see `High DPI images for variable pixel densities <http://www.html5rocks.com/en/mobile/high-dpi/>`__.

   .. rubric:: Target device density with JavaScript
      :name: DensityJS

   ``WebView`` supports ``window.devicePixelRatio``, which is a DOM property
   that lets you query the density of the current device. The value of this
   property specifies the scaling factor used for the current device. If the
   value of ``window.devicePixelRatio`` is 1.0, then the device is considered a
   medium-density device, and no scaling is applied by default. If the value is
   1.5, then the device is considered a high-density device, and the page is
   scaled 1.5x by default. If the value is 0.75, then the device is considered a
   low-density device, and the page is scaled 0.75x by default.

   The scaling that the Android browser and ``WebView`` apply is based on the
   web page's target density. As described in the section `defining the viewport target density <#ViewportDensity>`__, the default target is medium-density,
   but you can change the target to affect how your web page is scaled for
   different screen densities.

   For example, here's how you can query the device density with JavaScript:

   .. code:: prettyprint

      if (window.devicePixelRatio == 1.5) {
        alert("This is a high-density screen");
      } else if (window.devicePixelRatio == 0.75) {
        alert("This is a low-density screen");
      }


Last updated 2024-02-22 UTC.


/Debug web apps
===============

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/debugging?hl=en

.. container:: devsite-article-body

   You can debug your JavaScript using the ``console`` JavaScript APIs and view
   the output messages in Logcat. If you're familiar with debugging web pages
   with Firebug or Web Inspector, then you're probably familiar with using
   ``console`` (such as ``console.log()``). Android's WebKit framework supports
   most of the same APIs, so you can receive logs from your web page when
   debugging in your `WebView <#android.webkit.WebView>`__. This
   topic describes how to use the console APIs for debugging.

   **Note:**\  You can also remotely debug your web pages in WebView with the
   Chrome Developer Tools. For more information, see `Remote debugging WebViews <https://developer.chrome.google.cn/docs/devtools/remote-debugging/webviews/>`__.

   .. rubric:: Use console APIs in WebView
      :name: WebView

   The console APIs are also supported when debugging in ``WebView``. You must
   provide a `WebChromeClient <#android.webkit.WebChromeClient>`__
   that implements the
   `onConsoleMessage() <#android.webkit.WebChromeClient>`__
   method for console messages to appear in Logcat. Then, apply the
   ``WebChromeClient`` to your ``WebView`` with
   `setWebChromeClient() <#android.webkit.WebView>`__.
   For more information, see the
   `Webview <#android.webkit.WebView>`__ documentation.

   The following example shows how to use console APIs in ``WebView``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myWebView: WebView = findViewById(R.id.webview)
               myWebView.webChromeClient = object : WebChromeClient() {

                   override fun onConsoleMessage(message: ConsoleMessage): Boolean {
                       Log.d("MyApplication", "${message.message()} -- From line " +
                             "${message.lineNumber()} of ${message.sourceId()}")
                       return true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WebView myWebView = findViewById(R.id.webview);
               myWebView.setWebChromeClient(new WebChromeClient() {
                   @Override
                   public boolean onConsoleMessage(ConsoleMessage consoleMessage) {
                       Log.d("MyApplication", consoleMessage.message() + " -- From line " +
                       consoleMessage.lineNumber() + " of " + consoleMessage.sourceId());
                       return true;
                   }
               });

   **Warning:**\  Don't include personally-identifiable information (PII) in
   console messages.
   The `ConsoleMessage <#android.webkit.ConsoleMessage>`__ also
   includes a
   `MessageLevel <#android.webkit.ConsoleMessage.MessageLevel>`__
   object to indicate the type of console message being delivered. You can query
   the message level with
   `messageLevel() <#android.webkit.ConsoleMessage>`__
   to determine the severity of the message, then use the appropriate
   `Log <#android.util.Log>`__ method or take other appropriate
   actions.

   Whether you're using
   `onConsoleMessage(String, int, String) <#android.webkit.WebChromeClient>`__
   or
   `onConsoleMessage(ConsoleMessage) <#android.webkit.WebChromeClient>`__,
   when you execute a console method in your web page, Android calls the
   appropriate ``onConsoleMessage()`` method so you can report the error. For
   instance, with the example code above, a Logcat message is printed that looks
   like this:

   .. code:: devsite-click-to-copy

      Hello World -- From line 82 of http://www.example.com/hello.html

   **Note:**\  Logcat is a tool that dumps a log of system messages. The
   messages include a stack trace when the device throws an error as well as log
   messages written from your application and those written using the JavaScript
   ``console`` APIs. For more information, see `View logs with Logcat <#>`__.
   The following are additional resources related to debugging:

   -  `Remote debug Android devices <https://developer.chrome.google.cn/docs/devtools/remote-debugging/>`__
   -  `Debug your app <#>`__

   .. rubric:: Test experimental web features
      :name: Testing

   Similar to Google Chrome's ``chrome://flags`` page, you can also test
   experimental web features in ``WebView``.

   To do this, take the following steps:

   #. `Install one of the ``WebView`` pre-release
      channels <https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/prerelease.md>`__
      (beta, dev, or canary){: .external}.

   #. `Switch the ``WebView``
      channel <https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/prerelease.md#trichrome-beta>`__
      on your test device to the installed pre-release channel.

   #. Click the **WebView DevTools** launcher:

      | |image-webview-icon|
      | **Figure 1.** WebView DevTools icon for app installed on a device.

   #. From DevTools, click **Flags** and search for any experimental features
      you'd like to enable or disable. The change applies to all ``WebView``
      instances on the device.

   #. Stop and restart your app to start testing with the new features.

   For more information about toggling flags, see the `WebView DevTools documentation <https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/developer-ui.md#Flag-UI>`__.


Last updated 2024-02-22 UTC.

.. |image-webview-icon| image:: https://developer.android.google.cn/static/images/guide/webapps/webview-icon.png
   :width: 100px


/Implement best practices
=========================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/best-practices?hl=en

.. container:: devsite-article-body

   Developing web pages and applications for mobile devices presents different
   challenges compared to developing a web page for desktop web browsers. The
   following practices can help you provide the most effective web application
   for Android and other mobile devices.

   #. **Redirect mobile devices to a dedicated mobile version of your website.**
      There are several ways to do this using server-side redirects. One common
      method is to "sniff" the User Agent string provided by the web browser. To
      determine whether to serve a mobile version of your site, look for the
      "mobile" string in the User Agent.

   #. **Use**
      `HTML5 <https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5>`__\ **for
      mobile devices.** HTML5 is the most common markup language used for mobile
      websites. This standard encourages mobile-first development to help ensure
      that websites work on a variety of devices. Unlike previous web languages,
      HTML5 uses simpler ``<DOCTYPE>`` and ``charset`` declarations:

      .. code:: prettyprint

         <!DOCTYPE html>
         ...
         <meta charset="UTF-8">

   #. **Use viewport metadata to properly resize your web page.** In your
      document ``<head>``, provide metadata that specifies how you want the
      browser's viewport to render your web page. For example, your viewport
      metadata can specify the height and width for the browser's viewport, the
      initial page scale, and the target screen density.

      The following example shows how to set viewport metadata:

      .. code:: prettyprint

         <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

      For more information about how to use viewport metadata for
      Android-powered devices, read `Support different screens in web apps <#>`__.

   #. **Use a vertical linear layout.** Avoid the need for the user to scroll
      left and right while navigating your page. Scrolling up and down is easier
      for the user and makes your page simpler.

   #. **Set the layout height and width to ``match_parent``.** Setting your
      `WebView <#android.webkit.WebView>`__ object's height and
      width to ``match_parent`` makes sure your app's views are sized correctly.
      We discourage setting the height to ``wrap_content`` because it results in
      incorrect sizing. Similarly, setting the layout width to ``wrap_content``
      isn't supported and causes your ``WebView`` to use the width of its parent
      instead. Because of this behavior, it's also important to make sure none
      of your ``WebView`` object's parent layout objects have their height and
      width set to ``wrap_content``.

   #. **Avoid multiple file requests.** Because mobile devices typically have a
      connection speed slower than desktop computers, make your page load as
      fast as possible. One way to speed it up is to avoid loading extra files
      such as stylesheets and script files in the ``<head>``. Also, consider
      `performing mobile analysis with Google's PageSpeed Insights <https://developers.google.cn/speed/docs/insights/v5/get-started>`__
      for detailed optimization suggestions specific to your app.

   .. rubric:: Additional resources
      :name: additional-resources

   -  `Pixel-Perfect UI in the WebView <https://developers.google.cn/chrome/mobile/docs/webview/pixelperfect>`__
   -  `Learn Responsive Design <http://www.html5rocks.com/en/mobile/responsivedesign/>`__
   -  `High DPI images for variable pixel densities <http://www.html5rocks.com/en/mobile/high-dpi/>`__
   -  `Mobile Web Best Practices <http://www.w3.org/TR/mobile-bp/>`__
   -  `Make the Web Faster <https://developers.google.cn/speed/overview>`__


Last updated 2024-02-22 UTC.


/User privacy in WebView crash reporting
========================================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/webview-privacy?hl=en

.. container:: devsite-article-body

   For users who `share usage statistics and diagnostics with Google <https://support.google.com/accounts/answer/6078260>`__, ``WebView``
   sends usage statistics and crash reports to Google. Usage statistics contain
   information such as system information, active field trials, feature usage,
   responsiveness, performance, and memory usage. They don't include any
   personally identifying details.

   .. rubric:: Usage statistics
      :name: statistics

   Collected usage statistics are used to improve
   `WebView <#android.webkit.WebView>`__ performance, assess the
   impact of changes to existing features, and guide the development of new
   features.

   The stable channel of ``WebView`` gathers usage statistics from a small
   percentage of users. Pre-stable channels might sample from a greater
   percentage of users.

   Starting with ``WebView`` 71, these statistics are associated with the app
   package name. This lets Google proactively monitor and address ``WebView``
   issues that might degrade the performance of specific apps without causing
   crashes.

   Before ``WebView`` 104, for any given app, at most 10% of users upload
   reports containing the package name. Other users upload blank package names
   or no upload records at all.

   Starting with ``WebView`` 104, app package names are always recorded for apps
   that are in a list of allowed popular apps. Other apps upload blank package
   names.

   .. rubric:: Opt out usage statistics
      :name: usage-statistics

   Apps can opt out of usage statistics collection by including the following in
   the ``<application>`` section of their manifest:

   .. code:: prettyprint

      <meta-data android:name="android.webkit.WebView.MetricsOptOut" android:value="true" />

   This disables usage statistics collection for all users of the app,
   regardless of whether they have the corresponding setting enabled. It doesn't
   disable crash reporting.

   **Note:**\  Opting out of usage statistics collection decreases Google's
   ability to preemptively detect and address problems in ``WebView`` updates.

   .. rubric:: Opt out of metrics collection
      :name: diagnostic

   ``WebView`` has the ability to upload anonymous diagnostic data to Google
   when the user gives their consent. Data is collected on a per-app basis for
   each app that instantiates a ``WebView``. You can opt out of this feature by
   creating the following tag in the manifest's ``<application>`` element:

   .. code:: prettyprint

      <manifest>
          <application>
          ...
          <meta-data android:name="android.webkit.WebView.MetricsOptOut"
                     android:value="true" />
          </application>
      </manifest>

   Data is only uploaded from an app if the user consents **and** the app
   doesn't opt out. For more information about opting out of diagnostic data
   reporting, see the following section on crash reports.

   .. rubric:: Crash reports
      :name: crash-reports

   Crash reports are collected when a
   `WebView <#android.webkit.WebView>`__ object is likely to be
   the cause of the crash. Crash reports contain information required to
   determine the state of the ``WebView`` at the time of the crash. This
   includes system information, active field trials, and stack memory from the
   app required to generate the sequence of calls made within the thread.

   Stack memory is sanitized to remove strings, with the intent of capturing
   only the information required to generate stack traces. No URLs are collected
   as part of usage statistics or crash reports.

   .. rubric:: Pseudonymous identifiers and data privacy
      :name: data-privacy

   Crash reports and usage statistics collected by ``WebView`` each contain a
   randomly generated 128-bit token used to pseudonymously de-duplicate reports
   and maintain accuracy in statistics. Token values aren't shared between apps,
   and crash reports and usage statistics have independent tokens. All apps'
   usage statistics tokens are cleared when the user opts out of sharing usage
   statistics and diagnostics with Google. The crash report token is cleared
   when the app cache is cleared. Both tokens are cleared when the app is
   uninstalled or app data is cleared.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about user privacy, see `Build apps to be private <#>`__.


Last updated 2024-02-22 UTC.


/Beta program
=============

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/webview-testing?hl=en

.. container:: devsite-article-body

   The WebView Beta program gives you early access to new releases of Android
   WebView. We encourage all developers using WebView in their apps to join the
   Beta program so you can try out new WebView versions 4 weeks before they're
   released to the public.

   **Caution:**\  Beta releases may be less stable than the main release track.
   Beta users are the first to try out new features, but may also experience
   more crashes and some apps may not work properly.

   .. rubric:: How do I subscribe to the Beta program?
      :name: subscribe

   You can subscribe to WebView Beta on Android 10 and higher by joining the
   `WebView testing program <https://play.google.com/apps/testing/com.google.android.webview>`__
   with the account you use on your device. You can do this by clicking the
   **"Become a tester"** button:

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/layout/webapps/beta-become-a-tester.png
      name: implementation
      :alt: Become a tester
      :width: 40.0%

      **Figure 1**: Become a tester.

   You're now a Beta tester for WebView! If you visit the Play Store on your
   device, you should now see an update available for the Beta track. Install
   this update to start using WebView Beta.

   .. rubric:: How do I unsubscribe from the Beta program?
      :name: unsubscribe

   To leave the `WebView testing program <https://play.google.com/apps/testing/com.google.android.webview>`__
   and unsubscribe from receiving Beta updates in the future, click the **"Leave
   the program"** button.

   After you unsubscribe, WebView Beta is still installed on your device, but it
   automatically updates to the main (Stable) track as soon as the next Stable
   release comes out.

   **Caution:**\  If you don't want to wait for the next Stable release, you can
   uninstall WebView updates to immediately get back to Stable. However, we
   don't recommend doing this, because uninstalling WebView updates may delete
   user data if apps on your device use WebView to store data.

   .. rubric:: Other ways to test WebView
      :name: other-channels

   -  Did you know WebView also has other testing tracks? For a more bleeding
      edge experience, try out the `Dev or Canary channels <https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/prerelease.md#trichrome-dev>`__.
   -  If you want to try out experimental features or report crashes back to
      Google, you can install the separate `WebView Beta package <https://play.google.com/store/apps/details?id=com.google.android.webview.beta>`__
      instead.
   -  If you're testing on Android 7 through 9 (Nougat/Oreo/Pie), then you can
      install Chrome Beta and set your WebView provider in developer settings.
      See `Android 7 through 9 (Nougat/Oreo/Pie) <https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/prerelease.md#android-7-through-9-nougat_oreo_pie>`__
      for detailed steps.

   .. rubric:: Webview DevTools
      :name: devtools

   WebView DevTools are a set of on-device tools to help debug your WebView
   apps.

   The best way to launch WebView DevTools is to download WebView Beta, Dev, or
   Canary. These channels contain a launcher icon which launches WebView
   DevTools.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/layout/webapps/devtools.png
      name: devtools
      :alt: You can debug your WebView apps with WebView DevTools.
      :width: 50.0%

      **Figure 2**: WebView DevTools.

   **Note:**\  The WebView DevTools icon does not appear by default on Android 7
   through 9. To enable the launcher icon, first change your WebView provider.
   Then launch the same Chrome channel or any WebView app, such as WebView shell
   browser, or open an email in Gmail.

   .. rubric:: Webview Crashes
      :name: crashes

   Within the WebView Beta, Dev, and Canary apps, you can view WebView crashes
   that have occurred on the device.

   -  Similar to ``chrome://crashes``.
   -  Crashes from all apps on the device.
   -  File a bug to provide more info.

   .. rubric:: Webview Flags
      :name: flags

   Similarly, the testing apps contain a series of
   `flags <#Testing>`__ you may use to enable/disable
   experimental features.

   .. rubric:: Using WebView on older versions of Android
      :name: jetpack-webkit

   Jetpack’s `androidx.webkit <#>`__ enables you
   to use WebView APIs on older versions of Android that would otherwise not
   support them. There are several benefits to AndroidX WebKit:

   -  It is a Jetpack library updated regularly.
   -  It is easy to use by design,
   -  It enables your WebView apps to work on more devices.

   Add the dependencies for the artifacts you need in the ``build.gradle`` file
   for your app or module:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.webkit:webkit:1.9.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.webkit:webkit:1.9.0")
               }

   .. rubric:: Developer resources
      :name: developer-resources

   The following are additional resource for developers.

   .. rubric:: Video
      :name: video

   -  `AndroidX Webkit <https://www.youtube.com/watch?v=7Wq8Lwt_Cbg>`__
   -  `Modern WebView best practices - Android Dev Summit '18 <https://www.youtube.com/watch?v=HGZYtDZhOEQ>`__

   .. rubric:: Documentation
      :name: documentation

   -  `Web-based content <#>`__
   -  `Espresso Web <#>`__
   -  `Bug template for reporting issues <https://issues.chromium.org/issues/new?component=1456456&template=1923373>`__


Last updated 2024-05-01 UTC.


/Executing JavaScript and WebAssembly
=====================================

.. https://developer.android.google.cn/develop/ui/views/layout/webapps/jsengine?hl=en

.. container:: devsite-article-body

   .. rubric:: JavaScript Evaluation
      :name: javascript-evaluation

   Jetpack library
   `JavaScriptEngine <#>`__ provides a
   way for an application to evaluate JavaScript code without creating a WebView
   instance.

   For applications requiring non-interactive JavaScript evaluation, using the
   JavaScriptEngine library has the following advantages:

   -  Lower resource consumption, since there is no need to allocate a WebView
      instance.

   -  Can be done in a Service (WorkManager task).

   -  Multiple isolated environments with low overhead, enabling the application
      to run several JavaScript snippets simultaneously.

   -  Ability to pass large amounts of data by using an API call.

   .. rubric:: Basic Usage
      :name: basic-usage

   To begin, create an instance of
   `JavaScriptSandbox <#>`__.
   This represents a connection to the out-of-process JavaScript engine.

   **Note:**\  Applications must check ``JavaScriptSandbox`` availability by
   calling
   `JavaScriptSandbox.isSupported() <#isSupported()>`__
   API. Make sure that the application verifies that the sandbox is supported on
   the device before calling any other ``JavaScriptSandbox`` methods. If
   JavaScriptEngine is unsupported, attempting to create a
   `JavaScriptSandbox <#>`__
   instance throws a
   `SandboxUnsupportedException <#>`__.
   The sandbox is supported on API 26 and above if the WebView implementation
   supports it.
   .. code:: prettyprint

      ListenableFuture<JavaScriptSandbox> jsSandboxFuture =
                     JavaScriptSandbox.createConnectedInstanceAsync(context);

   It’s recommended to align the lifecycle of the sandbox with the lifecycle of
   the component which needs JavaScript evaluation.

   For example, a component hosting the sandbox may be an ``Activity`` or a
   ``Service``. A single ``Service`` might be used to encapsulate JavaScript
   evaluation for all application components.

   Maintain the ``JavaScriptSandbox`` instance because its allocation is fairly
   expensive. Only one ``JavaScriptSandbox`` instance per application is
   allowed. An ``IllegalStateException`` is thrown when an application attempts
   to allocate a second ``JavaScriptSandbox`` instance. However, if multiple
   execution environments are required, several ``JavaScriptIsolate`` instances
   can be allocated.

   When it is no longer used, close the sandbox instance to free up resources.
   The ``JavaScriptSandbox`` instance implements an ``AutoCloseable`` interface,
   which allows try-with-resources usage for simple blocking use cases.
   Alternatively, make sure ``JavaScriptSandbox`` instance lifecycle is managed
   by the hosting component, closing it in the ``onStop()`` callback for an
   Activity or during ``onDestroy()`` for a Service:

   .. code:: prettyprint

      jsSandbox.close();

   A
   `JavaScriptIsolate <#>`__
   instance represents a context for executing JavaScript code. They can be
   allocated when necessary, providing weak security boundaries for scripts of
   different origin or enabling concurrent JavaScript execution since JavaScript
   is single-threaded by nature. Subsequent calls to the same instance share the
   same state, hence it is possible to create some data first and then process
   it later in the same instance of ``JavaScriptIsolate``.

   .. code:: prettyprint

      JavaScriptIsolate jsIsolate = jsSandbox.createIsolate();

   Release ``JavaScriptIsolate`` explicitly by calling its
   `close() <#close()>`__
   method. Closing an isolate instance running JavaScript code (having an
   incomplete ``Future``) results in an ``IsolateTerminatedException``. The
   isolate is cleaned up subsequently in the background if the implementation
   supports
   `JS_FEATURE_ISOLATE_TERMINATION <#JS_FEATURE_ISOLATE_TERMINATION()>`__,
   as described in the `handling sandbox crashes <##handling-sandbox-crashes>`__
   section later on this page. Otherwise, the cleanup is postponed until all
   pending evaluations are completed or the sandbox is closed.

   An application can create and access a
   `JavaScriptIsolate <#>`__
   instance from any thread.

   Now, the application is ready to execute some JavaScript code:

   .. code:: prettyprint

      final String code = "function sum(a, b) { let r = a + b; return r.toString(); }; sum(3, 4)";
      ListenableFuture<String> resultFuture = jsIsolate.evaluateJavaScriptAsync(code);
      String result = resultFuture.get(5, TimeUnit.SECONDS);

   The same JavaScript snippet formatted nicely:

   .. code:: prettyprint

      function sum(a, b) {
          let r = a + b;
          return r.toString(); // make sure we return String instance
      };

      // Calculate and evaluate the expression
      // NOTE: We are not in a function scope and the `return` keyword
      // should not be used. The result of the evaluation is the value
      // the last expression evaluates to.
      sum(3, 4);

   The code snippet is passed as a ``String`` and the result delivered as a
   ``String``. Note that calling
   `evaluateJavaScriptAsync() <#evaluateJavaScriptAsync(java.lang.String)>`__
   returns the evaluated result of the last expression in the JavaScript code.
   This must be of JavaScript ``String`` type; otherwise, the library API
   returns an empty value. The JavaScript code shouldn't use a ``return``
   keyword. If the sandbox supports certain features, additional return types
   (for example, a ``Promise`` that resolves to a ``String``) might be possible.

   The library also supports evaluation of scripts that are in the form of an
   ``AssetFileDescriptor`` or a ``ParcelFileDescriptor``. See
   `evaluateJavaScriptAsync(AssetFileDescriptor) <#evaluateJavaScriptAsync(android.content.res.AssetFileDescriptor)>`__
   and
   `evaluateJavaScriptAsync(ParcelFileDescriptor) <#evaluateJavaScriptAsync(android.os.ParcelFileDescriptor)>`__
   for more details. These APIs are better suited for evaluating from a file on
   disk or in app directories.

   The library also supports console logging which can be used for debugging
   purposes. This can be set up using
   `setConsoleCallback() <#setConsoleCallback(androidx.javascriptengine.JavaScriptConsoleCallback)>`__.

   Since the context persists, you can upload code and execute it several times
   during the lifetime of the ``JavaScriptIsolate``:

   **Note:**\  This example does not include exception handling.
   .. code:: prettyprint

      String jsFunction = "function sum(a, b) { let r = a + b; return r.toString(); }";
      ListenableFuture<String> func = js.evaluateJavaScriptAsync(jsFunction);
      String twoPlusThreeCode = "let five = sum(2, 3); five";
      ListenableFuture<String> r1 = Futures.transformAsync(func,
             input -> js.evaluateJavaScriptAsync(twoPlusThreeCode)
             , executor);
      String twoPlusThree = r1.get(5, TimeUnit.SECONDS);

      String fourPlusFiveCode = "sum(4, parseInt(five))";
      ListenableFuture<String> r2 = Futures.transformAsync(func,
             input -> js.evaluateJavaScriptAsync(fourPlusFiveCode)
             , executor);
      String fourPlusFive = r2.get(5, TimeUnit.SECONDS);

   Of course, variables are persistent as well, so you can continue the previous
   snippet with:

   .. code:: prettyprint

      String defineResult = "let result = sum(11, 22);";
      ListenableFuture<String> r3 = Futures.transformAsync(func,
             input -> js.evaluateJavaScriptAsync(defineResult)
             , executor);
      String unused = r3.get(5, TimeUnit.SECONDS);

      String obtainValue = "result";
      ListenableFuture<String> r4 = Futures.transformAsync(func,
             input -> js.evaluateJavaScriptAsync(obtainValue)
             , executor);
      String value = r4.get(5, TimeUnit.SECONDS);

   For example, the complete snippet for allocating all necessary objects and
   executing a JavaScript code might look like the following:

   .. code:: prettyprint

      final ListenableFuture<JavaScriptSandbox> sandbox
             = JavaScriptSandbox.createConnectedInstanceAsync(this);
      final ListenableFuture<JavaScriptIsolate> isolate
             = Futures.transform(sandbox,
                     input -> (jsSandBox = input).createIsolate(),
                     executor);
      final ListenableFuture<String> js
             = Futures.transformAsync(isolate,
                     isolate -> (jsIsolate = isolate).evaluateJavaScriptAsync("'PASS OK'"),
                     executor);
      Futures.addCallback(js,
             new FutureCallback<String>() {
                 @Override
                 public void onSuccess(String result) {
                     text.append(result);
                 }
                 @Override
                 public void onFailure(Throwable t) {
                     text.append(t.getMessage());
                 }
             },
             mainThreadExecutor);

   It’s recommended that you use try-with-resources to make sure all allocated
   resources are released and are no longer used. Closing the sandbox results in
   all pending evaluations in all
   `JavaScriptIsolate <#>`__
   instances failing with a
   `SandboxDeadException <#>`__.
   When the JavaScript evaluation encounters an error, a
   `JavaScriptException <#>`__
   is created. Refer to its subclasses for more specific exceptions.

   .. rubric:: Handling Sandbox Crashes
      :name: handling-sandbox-crashes

   All JavaScript is executed in a separate sandboxed process away from your
   application’s main process. If the JavaScript code causes this sandboxed
   process to crash, for example, by exhausting a memory limit, the
   application’s main process will be unaffected.

   A sandbox crash will cause all isolates in that sandbox to terminate. The
   most obvious symptom of this is that all evaluations will start failing with
   `IsolateTerminatedException <#>`__.
   Depending on the circumstances, more specific exceptions such as
   `SandboxDeadException <#>`__
   or
   `MemoryLimitExceededException <#>`__
   may be thrown.

   Handling crashes for each individual evaluation is not always practical.
   Furthermore, an isolate may terminate outside of an explicitly requested
   evaluation due to background tasks or evaluations in other isolates. The
   crash handling logic can be centralized by attaching a callback using
   `JavaScriptIsolate.addOnTerminatedCallback() <#androidx.javascriptengine.JavaScriptIsolate>`__.

   .. code:: prettyprint

      final ListenableFuture<JavaScriptSandbox> sandboxFuture =
          JavaScriptSandbox.createConnectedInstanceAsync(this);
      final ListenableFuture<JavaScriptIsolate> isolateFuture =
          Futures.transform(sandboxFuture, sandbox -> {
            final IsolateStartupParameters startupParams = new IsolateStartupParameters();
            if (sandbox.isFeatureSupported(JavaScriptSandbox.JS_FEATURE_ISOLATE_MAX_HEAP_SIZE)) {
              startupParams.setMaxHeapSizeBytes(100_000_000);
            }
            return sandbox.createIsolate(startupParams);
          }, executor);
      Futures.transform(isolateFuture,
          isolate -> {
            // Add a crash handler
            isolate.addOnTerminatedCallback(executor, terminationInfo -> {
              Log.e(TAG, "The isolate crashed: " + terminationInfo);
            });
            // Cause a crash (eventually)
            isolate.evaluateJavaScriptAsync("Array(1_000_000_000).fill(1)");
            return null;
          }, executor);

   **Note:**\  The callback added through
   `addOnTerminatedCallback() <#androidx.javascriptengine.JavaScriptIsolate>`__
   does not trigger when closing the isolate using
   `JavaScriptIsolate.close() <#close()>`__.

   .. rubric:: Optional Sandbox Features
      :name: optional-features

   Depending on the underlying WebView version, a sandbox implementation might
   have different sets of features available. So, it’s necessary to query each
   required feature using
   `JavaScriptSandbox.isFeatureSupported(...) <#isFeatureSupported(java.lang.String)>`__.
   It is important to check feature status before calling methods relying on
   these features.

   `JavaScriptIsolate <#>`__
   methods that might not be available everywhere are annotated with
   `RequiresFeature <#>`__
   annotation, making it easier to spot these calls in the code.

   .. rubric:: Passing Parameters
      :name: passing-parameters

   If
   `JavaScriptSandbox.JS_FEATURE_EVALUATE_WITHOUT_TRANSACTION_LIMIT <#JS_FEATURE_EVALUATE_WITHOUT_TRANSACTION_LIMIT()>`__
   is supported, the evaluation requests sent to the JavaScript engine are not
   bound by the binder transaction limits. If the feature is not supported, all
   data to the JavaScriptEngine occurs through a Binder transaction. The
   `general transaction size limit <#android.os.TransactionTooLargeException>`__ is applicable
   to every call that passes in data or returns data.

   The response is always `returned as a String <#evaluateJavaScriptAsync(java.lang.String)>`__
   and is subject to the Binder transaction maximum size limit if
   `JavaScriptSandbox.JS_FEATURE_EVALUATE_WITHOUT_TRANSACTION_LIMIT <#JS_FEATURE_EVALUATE_WITHOUT_TRANSACTION_LIMIT()>`__
   is not supported. Non-string values must be explicitly converted to a
   JavaScript String otherwise an empty string is returned. If
   `JS_FEATURE_PROMISE_RETURN <#JS_FEATURE_PROMISE_RETURN()>`__
   feature is supported, JavaScript code may alternatively return a Promise
   resolving to a ``String``.

   For passing large byte arrays to the
   `JavaScriptIsolate <#>`__
   instance, you can use the
   `provideNamedData(...) <#provideNamedData(java.lang.String,byte%5B%5D)>`__
   API. Usage of this API is not bound by the Binder transaction limits. Each
   byte array must be passed using a unique identifier which cannot be re-used.

   **Note:**\  The application must check the
   `JS_FEATURE_PROVIDE_CONSUME_ARRAY_BUFFER <#JS_FEATURE_PROVIDE_CONSUME_ARRAY_BUFFER()>`__
   feature before using this method.
   .. code:: prettyprint

      if (sandbox.isFeatureSupported(JavaScriptSandbox.JS_FEATURE_PROVIDE_CONSUME_ARRAY_BUFFER)) {
          js.provideNamedData("data-1", "Hello Android!".getBytes(StandardCharsets.US_ASCII));
          final String jsCode = "android.consumeNamedDataAsArrayBuffer('data-1').then((value) => { return String.fromCharCode.apply(null, new Uint8Array(value)); });";
          ListenableFuture<String> msg = js.evaluateJavaScriptAsync(jsCode);
          String response = msg.get(5, TimeUnit.SECONDS);
      }

   .. rubric:: Running Wasm Code
      :name: running-wasm

   WebAssembly (Wasm) code can be passed using the
   `provideNamedData(...) <#provideNamedData(java.lang.String,byte%5B%5D)>`__
   API, then compiled and executed in the usual manner, as demonstrated below.

   .. code:: prettyprint

      final byte[] hello_world_wasm = {
         0x00 ,0x61 ,0x73 ,0x6d ,0x01 ,0x00 ,0x00 ,0x00 ,0x01 ,0x0a ,0x02 ,0x60 ,0x02 ,0x7f ,0x7f ,0x01,
         0x7f ,0x60 ,0x00 ,0x00 ,0x03 ,0x03 ,0x02 ,0x00 ,0x01 ,0x04 ,0x04 ,0x01 ,0x70 ,0x00 ,0x01 ,0x05,
         0x03 ,0x01 ,0x00 ,0x00 ,0x06 ,0x06 ,0x01 ,0x7f ,0x00 ,0x41 ,0x08 ,0x0b ,0x07 ,0x18 ,0x03 ,0x06,
         0x6d ,0x65 ,0x6d ,0x6f ,0x72 ,0x79 ,0x02 ,0x00 ,0x05 ,0x74 ,0x61 ,0x62 ,0x6c ,0x65 ,0x01 ,0x00,
         0x03 ,0x61 ,0x64 ,0x64 ,0x00 ,0x00 ,0x09 ,0x07 ,0x01 ,0x00 ,0x41 ,0x00 ,0x0b ,0x01 ,0x01 ,0x0a,
         0x0c ,0x02 ,0x07 ,0x00 ,0x20 ,0x00 ,0x20 ,0x01 ,0x6a ,0x0b ,0x02 ,0x00 ,0x0b,
      };
      final String jsCode = "(async ()=>{" +
             "const wasm = await android.consumeNamedDataAsArrayBuffer('wasm-1');" +
             "const module = await WebAssembly.compile(wasm);" +
             "const instance = WebAssembly.instance(module);" +
             "return instance.exports.add(20, 22).toString();" +
             "})()";
      // Ensure that the name has not been used before.
      js.provideNamedData("wasm-1", hello_world_wasm);
      FluentFuture.from(js.evaluateJavaScriptAsync(jsCode))
                 .transform(this::println, mainThreadExecutor)
                 .catching(Throwable.class, e -> println(e.getMessage()), mainThreadExecutor);
      }

   .. rubric:: JavaScriptIsolate Separation
      :name: js-separation

   All
   `JavaScriptIsolate <#>`__
   instances are independent of each other and do not share anything. The
   following snippet results in

   ``Hi from AAA!5``

   and

   ``Uncaught Reference Error: a is not defined``

   because the ”\ ``jsTwo``\ ” instance has no visibility of the objects created
   in “\ ``jsOne``\ ”.

   .. code:: prettyprint

      JavaScriptIsolate jsOne = engine.obtainJavaScriptIsolate();
      String jsCodeOne = "let x = 5; function a() { return 'Hi from AAA!'; } a() + x";
      JavaScriptIsolate jsTwo = engine.obtainJavaScriptIsolate();
      String jsCodeTwo = "a() + x";
      FluentFuture.from(jsOne.evaluateJavaScriptAsync(jsCodeOne))
             .transform(this::println, mainThreadExecutor)
             .catching(Throwable.class, e -> println(e.getMessage()), mainThreadExecutor);

      FluentFuture.from(jsTwo.evaluateJavaScriptAsync(jsCodeTwo))
             .transform(this::println, mainThreadExecutor)
             .catching(Throwable.class, e -> println(e.getMessage()), mainThreadExecutor);

   .. rubric:: Kotlin Support
      :name: kotlin-support

   To use this Jetpack library with Kotlin coroutines, add a dependency to
   `kotlinx-coroutines-guava <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-guava/>`__.
   This allows integration with ``ListenableFuture``.

   .. code:: prettyprint

      dependencies {
          implementation "org.jetbrains.kotlinx:kotlinx-coroutines-guava:1.6.0"
      }

   The Jetpack library APIs can now be called from a coroutine scope, as
   demonstrated below:

   .. code:: prettyprint

      // Launch a coroutine
      lifecycleScope.launch {
          val jsSandbox = JavaScriptSandbox
                  .createConnectedInstanceAsync(applicationContext)
                  .await()
          val jsIsolate = jsSandbox.createIsolate()
          val resultFuture = jsIsolate.evaluateJavaScriptAsync("PASS")

          // Await the result
          textBox.text = resultFuture.await()
          // Or add a callback
          Futures.addCallback<String>(
              resultFuture, object : FutureCallback<String?> {
                  override fun onSuccess(result: String?) {
                      textBox.text = result
                  }
                  override fun onFailure(t: Throwable) {
                      // Handle errors
                  }
              },
              mainExecutor
          )
      }

   .. rubric:: Configuration Parameters
      :name: configuration-parameters

   When requesting an isolated environment instance, you can tweak its
   configuration. To tweak the configuration, pass the
   `IsolateStartupParameters <#>`__
   instance to
   `JavaScriptSandbox.createIsolate(...) <#createIsolate()>`__.

   Currently parameters allow specifying the maximum heap size and the maximum
   size for evaluation return values and errors.


Last updated 2024-02-22 UTC.


/About themes
=============

.. https://developer.android.google.cn/develop/ui/views/theming/themes?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with theming in Compose.

      `Design Systems in Compose → <https://developer.android.google.cn/jetpack/compose/designsystems>`__

      |image-android-compose-ui-logo|

   Styles and themes on Android let you separate the details of your app design
   from the UI structure and behavior, similar to stylesheets in web design.

   A *style* is a collection of attributes that specifies the appearance for a
   single `View <#android.view.View>`__. A style can specify
   attributes such as font color, font size, background color, and much more.

   A *theme* is a collection of attributes that's applied to an entire app,
   activity, or view hierarchy—not just an individual view. When you apply a
   theme, every view in the app or activity applies each of the theme's
   attributes that it supports. Themes can also apply styles to non-view
   elements, such as the status bar and window background.

   Styles and themes are declared in a `style resource file <#>`__ in ``res/values/``, usually
   named ``styles.xml``.

   |image-material-themes_2x|
   **Figure 1.** Two themes applied to the same activity: ``Theme.AppCompat``
   (left) and ``Theme.AppCompat.Light`` (right).

   .. rubric:: Themes versus styles
      :name: versus

   Themes and styles have many similarities, but they are used for different
   purposes. Themes and styles have the same basic structure—a key-value pair
   that maps *attributes* to *resources*.

   A *style* specifies attributes for a particular type of view. For example,
   one style might specify a button's attributes. Every attribute you specify in
   a style is an attribute you can set in the layout file. Extracting all the
   attributes to a style makes it easy to use and maintain them across multiple
   widgets.

   A *theme* defines a collection of named resources that can be referenced by
   styles, layouts, widgets, and so on. Themes assign semantic names, like
   ``colorPrimary``, to Android resources.

   Styles and themes are meant to work together. For example, you might have a
   style that specifies that one part of a button is ``colorPrimary``, and
   another part is ``colorSecondary``. The actual definitions of those colors
   are provided in the theme. When the device goes into night mode, your app can
   switch from its "light" theme to its "dark" theme, changing the values for
   all those resource names. You don't need to change the styles, since the
   styles are using the semantic names and not specific color definitions.

   For more information about how themes and styles work together, see the blog
   post `Android styling: themes vs styles <https://medium.com/androiddevelopers/android-styling-themes-vs-styles-ebe05f917578>`__.

   .. rubric:: Create and apply a style
      :name: Styles

   To create a new style, open your project's ``res/values/styles.xml`` file.
   For each style you want to create, follow these steps:

   #. Add a ``<style>`` element with a name that uniquely identifies the style.
   #. Add an ``<item>`` element for each style attribute you want to define. The
      ``name`` in each item specifies an attribute you otherwise use as an XML
      attribute in your layout. The value in the ``<item>`` element is the value
      for that attribute.

   For example, suppose you define the following style:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
          <style name="GreenText" parent="TextAppearance.AppCompat">
              <item name="android:textColor">#00FF00</item>
          </style>
      </resources>

   You can apply the style to a view as follows:

   .. code:: prettyprint

      <TextView
          style="@style/GreenText"
          ... />

   Each attribute specified in the style is applied to that view if the view
   accepts it. The view ignores any attributes that it doesn't accept.

   **Note:** Only the element to which you add the ``style`` attribute receives
   those style attributes. Child views don't apply the styles. If you want child
   views to inherit styles, instead apply the style with the ``android:theme``
   attribute.
   However, instead of applying a style to individual views, you typically
   `apply styles as a theme <#Theme>`__ for your entire app, activity, or
   collection of views, as described in another section of this guide.

   .. rubric:: Extend and customize a style
      :name: Customize

   When creating your own styles, always extend an existing style from the
   framework or Support Library so that you maintain compatibility with platform
   UI styles. To extend a style, specify the style you want to extend with the
   ``parent`` attribute. You can then override the inherited style attributes
   and add new ones.

   For example, you can inherit the Android platform's default text appearance
   and modify it as follows:

   .. code:: prettyprint

      <style name="GreenText" parent="@android:style/TextAppearance">
          <item name="android:textColor">#00FF00</item>
      </style>

   However, always inherit your core app styles from the Android Support
   Library. The styles in the Support Library provide compatibility by
   optimizing each style for the UI attributes available in each version. The
   Support Library styles often have a name similar to the style from the
   platform, but with ``AppCompat`` included.

   To inherit styles from a library or your own project, declare the parent
   style name *without* the ``@android:style/`` part shown in the preceding
   example. For example, the following example inherits text appearance styles
   from the Support Library:

   .. code:: prettyprint

      <style name="GreenText" parent="TextAppearance.AppCompat">
          <item name="android:textColor">#00FF00</item>
      </style>

   You can also inherit styles—except those from the platform—by extending a
   style's name with a dot notation, instead of using the ``parent`` attribute.
   That is, prefix the name of your style with the name of the style you want to
   inherit, separated by a period. You typically only do this when extending
   your own styles, not styles from other libraries. For example, the following
   style inherits all styles from the ``GreenText`` in the preceding example and
   then increases the text size:

   .. code:: prettyprint

      <style name="GreenText.Large">
          <item name="android:textSize">22dp</item>
      </style>

   You can continue inheriting styles like this as many times as you want by
   chaining on more names.

   **Note:** If you use the dot notation to extend a style and you also include
   the ``parent`` attribute, then the parent styles override any styles
   inherited through the dot notation.
   To find which attributes you can declare with an ``<item>`` tag, refer to the
   "XML attributes" table in the various class references. All views support
   `XML attributes from the base ``View``
   class <#android.view.View>`__, and many views add their own
   special attributes. For example, the `TextView XML attributes <#android.widget.TextView>`__ include the
   `android:inputType <#android.widget.TextView>`__
   attribute that you can apply to a text view that receives input, such as an
   `EditText <#android.widget.EditText>`__ widget.

   .. rubric:: Apply a style as a theme
      :name: Theme

   You can create a theme the same way you create styles. The difference is how
   you apply it: instead of applying a style with the ``style`` attribute on a
   view, you apply a theme with the ``android:theme`` attribute on either the
   ``<application>`` tag or an ``<activity>`` tag in the ``AndroidManifest.xml``
   file.

   For example, here's how to apply the Android Support Library's Material
   Design "dark" theme to the whole app:

   .. code:: prettyprint

      <manifest ... >
          <application android:theme="@style/Theme.AppCompat" ... >
          </application>
      </manifest>

   And here's how to apply the "light" theme to just one activity:

   .. code:: prettyprint

      <manifest ... >
          <application ... >
              <activity android:theme="@style/Theme.AppCompat.Light" ... >
              </activity>
          </application>
      </manifest>

   Every view in the app or activity applies the styles that it supports from
   those defined in the given theme. If a view supports only some of the
   attributes declared in the style, then it applies only those attributes and
   ignores the ones it doesn't support.

   Beginning with Android 5.0 (API level 21) and Android Support Library v22.1,
   you can also specify the ``android:theme`` attribute to a view in your layout
   file. This modifies the theme for that view and any child views, which is
   useful for altering theme color palettes in a specific portion of your
   interface.

   The previous examples show how to apply a theme such as ``Theme.AppCompat``
   that's supplied by the Android Support Library. However, you typically want
   to customize the theme to fit your app's brand. The best way to do so is to
   extend these styles from the Support Library and override some of the
   attributes, as described in the following section.

   .. rubric:: Style hierarchy
      :name: hierarchy

   Android provides a variety of ways to set attributes throughout your Android
   app. For example, you can set attributes directly in a layout, apply a style
   to a view, apply a theme to a layout, and even set attributes
   programmatically.

   When choosing how to style your app, be mindful of Android's style hierarchy.
   In general, use themes and styles as much as possible for consistency. If you
   specify the same attributes in multiple places, the following list determines
   which attributes are ultimately applied. The list is ordered from highest
   precedence to lowest.

   #. Applying character- or paragraph-level styling using text spans to
      ``TextView``-derived classes.
   #. Applying attributes programmatically.
   #. Applying individual attributes directly to a view.
   #. Applying a style to a view.
   #. Default styling.
   #. Applying a theme to a collection of views, an activity, or your entire
      app.
   #. Applying certain view-specific styling, such as setting a
      `TextAppearance <#android.R.styleable>`__ on
      a ``TextView``.

   |image-text-multiple-styles|
   **Figure 2.** Styling from a ``span`` overrides styling from a
   ``textAppearance``.

   **Caution:** If you're styling your app and not seeing the results you
   expect, it's likely that other styling is overriding your changes. For
   example, if you apply a theme to your app along with a style to an individual
   ``View``, the style attributes override any matching theme attributes for
   that ``View``. Note, however, that any theme attributes that aren't
   overridden by the style are still used.

   .. rubric:: TextAppearance
      :name: textappearance

   One limitation with styles is that you can apply only one style to a
   ``View``. In a ``TextView``, however, you can also specify a
   `TextAppearance <#android.R.styleable>`__
   attribute that functions similarly to a style, as shown in the following
   example:

   .. code:: prettyprint

      <TextView
          ...
          android:textAppearance="@android:style/TextAppearance.Material.Headline"
          android:text="This text is styled via textAppearance!" />

   ``TextAppearance`` lets you define text-specific styling while leaving the
   style of a ``View`` available for other uses. Note, however, that if you
   define any text attributes directly on the ``View`` or in a style, those
   values override the ``TextAppearance`` values.

   ``TextAppearance`` supports a subset of styling attributes that ``TextView``
   offers. For the full attribute list, see
   `TextAppearance <#android.R.styleable>`__.

   Some common ``TextView`` attributes not included are
   `lineHeight[Multiplier|Extra] <#android.widget.TextView>`__,
   `lines <#android.widget.TextView>`__,
   `breakStrategy <#android.widget.TextView>`__,
   and
   `hyphenationFrequency <#android.widget.TextView>`__.
   ``TextAppearance`` works at the character level and not the paragraph level,
   so attributes that affect the entire layout aren't supported.

   .. rubric:: Customize the default theme
      :name: CustomizeTheme

   When you create a project with Android Studio, it applies a Material Design
   theme to your app by default, as defined in your project's ``styles.xml``
   file. This ``AppTheme`` style extends a theme from the Support Library and
   includes overrides for color attributes that are used by key UI elements,
   such as the `app bar <#>`__ and the `floating action button <#>`__, if used. So, you can
   quickly customize your app's color design by updating the provided colors.

   For example, your ``styles.xml`` file looks similar to this:

   .. code:: prettyprint

      <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
          <!-- Customize your theme here. -->
          <item name="colorPrimary">@color/colorPrimary</item>
          <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
          <item name="colorAccent">@color/colorAccent</item>
      </style>

   The style values are actually references to other `color resources <#Color>`__, defined in the
   project's ``res/values/colors.xml`` file. That's the file you edit to change
   the colors. See the `Material Design Color Overview <https://m3.material.io/styles/color/overview>`__ to improve the
   user experience with dynamic color and additional custom colors.

   Once you know your colors, update the values in ``res/values/colors.xml``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
          <!--   Color for the app bar and other primary UI elements. -->
          <color name="colorPrimary">#3F51B5</color>

          <!--   A darker variant of the primary color, used for
                 the status bar (on Android 5.0+) and contextual app bars. -->
          <color name="colorPrimaryDark">#303F9F</color>

          <!--   a secondary color for controls like checkboxes and text fields. -->
          <color name="colorAccent">#FF4081</color>
      </resources>

   You can then override whatever other styles you want. For example, you can
   change the activity background color as follows:

   .. code:: prettyprint

      <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
          ...
          <item name="android:windowBackground">@color/activityBackground</item>
      </style>

   For a list of attributes you can use in your theme, see the table of
   attributes at
   `R.styleable.Theme <#android.R.styleable>`__. When adding
   styles for the views in your layout, you can also find attributes by looking
   at the "XML attributes" table in the view class references. For example, all
   views support `XML attributes from the base ``View``
   class <#android.view.View>`__.

   Most attributes are applied to specific types of views, and some apply to all
   views. However, some theme attributes listed at
   `R.styleable.Theme <#android.R.styleable>`__ apply to the
   activity window, not the views in the layout. For example,
   ``windowBackground`` changes the window background and
   ``windowEnterTransition`` defines a transition animation to use when the
   activity starts. For more details, see `Start an activity using an animation <#>`__.

   The Android Support Library also provides other attributes you can use to
   customize your theme extended from ``Theme.AppCompat``, such as the
   ``colorPrimary`` attribute shown in the preceding example. These are best
   viewed in the `library's ``attrs.xml``
   file <https://chromium.googlesource.com/android_tools/+/HEAD/sdk/extras/android/support/v7/appcompat/res/values/attrs.xml>`__.

   **Note:** Attribute names from the Support Library don't use the ``android:``
   prefix. That's used only for attributes from the Android framework.
   There are also different themes available from the Support Library that you
   might want to extend instead of the ones shown in the preceding example. The
   best place to see the available themes is the `library's ``themes.xml``
   file <https://chromium.googlesource.com/android_tools/+/HEAD/sdk/extras/android/support/v7/appcompat/res/values/themes.xml>`__.

   .. rubric:: Add version-specific styles
      :name: Versions

   If a new version of Android adds theme attributes you want to use, you can
   add them to your theme while still being compatible with old versions. All
   you need is another ``styles.xml`` file saved in a ``values`` directory that
   includes the `resource version qualifier <#AlternativeResources>`__:

   .. code:: none

      res/values/styles.xml        # themes for all versions
      res/values-v21/styles.xml    # themes for API level 21+ only

   Because the styles in the ``values/styles.xml`` file are available for all
   versions, your themes in ``values-v21/styles.xml`` can inherit them. This
   means that you can avoid duplicating styles by beginning with a "base" theme
   and then extending it in your version-specific styles.

   For example, to declare window transitions for Android 5.0 (API level 21) and
   higher, you need to use new attributes. So, your base theme in
   ``res/values/styles.xml`` can look like this:

   .. code:: prettyprint

      <resources>
          <!-- Base set of styles that apply to all versions. -->
          <style name="BaseAppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
              <item name="colorPrimary">@color/primaryColor</item>
              <item name="colorPrimaryDark">@color/primaryTextColor</item>
              <item name="colorAccent">@color/secondaryColor</item>
          </style>

          <!-- Declare the theme name that's actually applied in the manifest file. -->
          <style name="AppTheme" parent="BaseAppTheme" />
      </resources>

   Then, add the version-specific styles in ``res/values-v21/styles.xml``, as
   follows:

   .. code:: prettyprint

      <resources>
          <!-- extend the base theme to add styles available only with API level 21+ -->
          <style name="AppTheme" parent="BaseAppTheme">
              <item name="android:windowActivityTransitions">true</item>
              <item name="android:windowEnterTransition">@android:transition/slide_right</item>
              <item name="android:windowExitTransition">@android:transition/slide_left</item>
          </style>
      </resources>

   Now you can apply ``AppTheme`` in your manifest file, and the system selects
   the styles available for each system version.

   For more information about using alternative resources for different devices,
   see `Providing alternative resources <#AlternativeResources>`__.

   .. rubric:: Customize widget styles
      :name: Widgets

   Every widget in the framework and Support Library has a default style. For
   example, when you style your app using a theme from the Support Library, an
   instance of `Button <#android.widget.Button>`__ is styled using
   the ``Widget.AppCompat.Button`` style. If you want to apply a different
   widget style to a button, you can do so with the ``style`` attribute in your
   layout file. For example, the following applies the library's borderless
   button style:

   .. code:: prettyprint

      <Button
          style="@style/Widget.AppCompat.Button.Borderless"
          ... />

   If you want to apply this style to all buttons, you can declare it in your
   theme's `buttonStyle <#android.R.attr>`__ as
   follows:

   .. code:: prettyprint

      <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
          <item name="buttonStyle">@style/Widget.AppCompat.Button.Borderless</item>
          ...
      </style>

   You can also extend widget styles, just like `extending any other style <#Customize>`__, and then apply your custom widget style in your layout
   or theme.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about themes and styles, see the following additional
   resources:

   .. rubric:: Blog posts
      :name: blogs

   -  `Android styling: themes vs styles <https://medium.com/androiddevelopers/android-styling-themes-vs-styles-ebe05f917578>`__
   -  `Android styling: common theme attributes <https://medium.com/androiddevelopers/android-styling-common-theme-attributes-8f7c50c9eaba>`__
   -  `Android styling: prefer theme attributes <https://medium.com/androiddevelopers/android-styling-prefer-theme-attributes-412caa748774>`__


Last updated 2024-05-03 UTC.

.. |image-material-themes_2x| image:: https://developer.android.google.cn/static/training/material/images/material-themes_2x.png
   :class: full-width-nav-aware
   :width: 600px
.. |image-text-multiple-styles| image:: https://developer.android.google.cn/static/guide/topics/ui/images/text-multiple-styles.png


/Use the device colors (Dynamic Color)
======================================

.. https://developer.android.google.cn/develop/ui/views/theming/dynamic-colors?hl=en

.. container:: devsite-article-body

   Dynamic Color, which was added in Android 12, enables users to personalize
   their devices to align tonally with the color scheme of their personal
   wallpaper or through a selected color in the wallpaper picker.

   You can leverage this feature by adding the
   `DynamicColors <#>`__
   API, which applies this theming to your app or activity to make your app more
   personalized to the user.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/theming/images/wallpaper-differing.png
      :width: 550px

      **Figure 1.** Examples of tonal color schemes derived from different
      wallpapers

   This page includes instructions for implementing Dynamic Colors in your app.
   This feature is also available separately for `widgets and adaptive icons <#apply-widgets>`__, as described later on this page. You can also try
   out the
   `codelab <https://developers.google.cn/codelabs/codelabs/apply-dynamic-color#0>`__.

   **Note:**\  The information on this page is dependent on understanding
   styles, colors, attributes, and themes on Android. See `Styles and themes <#>`__ for details.

   .. rubric:: How Android creates color schemes
      :name: how-system-creates

   Android performs the following steps to generate color schemes from a user's
   wallpaper.

   #. The system detects the main colors in the selected wallpaper image and
      extracts a *source* color.

   #. The system uses that source color to further extrapolate five key colors
      known as *Primary*, *Secondary*, *Tertiary*, *Neutral*, and *Neutral
      variant*.

      .. figure:: https://developer.android.google.cn/static/develop/ui/views/theming/images/source-extraction.png
         :alt: Example of source color extraction
         :width: 550px

         **Figure 2.** Example of source color extraction from wallpaper image
         and extraction to five key colors

   #. The system interprets each key color into a tonal palette of 13 tones.

      .. figure:: https://developer.android.google.cn/static/develop/ui/views/theming/images/tonal-palettes.png
         :alt: Example of generating a given tonal palettes
         :width: 550px

         **Figure 3.** Example of generating a given tonal palettes

   #. The system uses this single wallpaper to derive five different color
      schemes, which provides the basis for any light and dark themes.

   .. rubric:: How color variants display on a user's device
      :name: how-variants-display

   Users can select color variants from wallpaper-extracted colors and different
   themes starting in Android 12, with more variants added in Android 13. For
   example, a user with a Pixel phone running Android 13 would select a variant
   from the **Wallpaper & style** settings, as shown in figure 4.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/theming/images/wallpaper-color.png
      :width: 550px

      **Figure 4.** Selecting color variants in wallpaper settings (shown on a
      Pixel device)

   Android 12 added the *Tonal Spot* variant, followed by the *Neutral*,
   *Vibrant Tonal*, and *Expressive* variants in Android 13. Each variant has a
   unique recipe that transforms the seed colors of a user's wallpaper through
   vibrancy and rotating the hue. The following example shows a single color
   scheme expressed through these four color variants.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/theming/images/color-variants-example.png

      **Figure 5.** Example of how different color variants look on a single
      device

   Your app still uses the same tokens to access these colors. For details about
   tokens, see `Create your theme with tokens <#create-tokens>`__ on this page.

   .. rubric:: Get started with Compose
      :name: get-started-compose

   If you're building your UI with Compose, check out `Material Theming in Compose <#m3-dynamic-color>`__ for details on
   applying Dynamic Color to your app.

   .. rubric:: Get started with Views
      :name: get-started-views

   You can apply Dynamic Color at the app or activity level. To do so, call
   `applyToActivitiesIfAvailable() <#applyToActivitiesIfAvailable(android.app.Application,%20com.google.android.material.color.DynamicColorsOptions)>`__
   to register an
   `ActivityLifeCycleCallbacks <#android.app.Application.ActivityLifecycleCallbacks>`__
   to your app.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyApplication: Application() {
                   override fun onCreate() {
                       DynamicColors.applyToActivitiesIfAvailable(this)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyApplication extends Application {
                 @Override
                 public void onCreate() {
                   super.onCreate();
                   DynamicColors.applyToActivitiesIfAvailable(this);
                 }
               }

   Next, add the theme to your app.

   .. code:: prettyprint

      <style
          name="AppTheme"
          parent="ThemeOverlay.Material3.DynamicColors.DayNight">
          ...
      </style>

   .. rubric:: Create your theme with tokens
      :name: create-tokens

   Dynamic Color takes advantage of design tokens to make assigning colors to
   different UI elements more streamlined and consistent. A design token allows
   you to semantically assign color roles, rather than a set value, to different
   elements of a UI. This enables your app's tonal system to have more
   flexibility, scalability, and consistency, and is particularly powerful when
   designing for light and dark themes and dynamic color.

   The following snippets show examples of light and dark themes, and a
   corresponding color xml, after applying dynamic color tokens.

   **Light theme**

   .. code:: prettyprint

      Themes.xml

      <resources>
        <style name="AppTheme" parent="Theme.Material3.Light.NoActionBar">
          <item name="colorPrimary">@color/md_theme_light_primary</item>
          <item name="colorOnPrimary">@color/md_theme_light_onPrimary</item>
          <item name="colorPrimaryContainer">@color/md_theme_light_primaryContainer</item>
          <item name="colorOnPrimaryContainer">@color/md_theme_light_onPrimaryContainer</item>
          <item name="colorError">@color/md_theme_light_error</item>
          <item name="colorOnError">@color/md_theme_light_onError</item>
          <item name="colorErrorContainer">@color/md_theme_light_errorContainer</item>
          <item name="colorOnErrorContainer">@color/md_theme_light_onErrorContainer</item>
          <item name="colorOnBackground">@color/md_theme_light_onBackground</item>
          <item name="colorSurface">@color/md_theme_light_surface</item>
          <item name="colorOnSurface">@color/md_theme_light_onSurface</item>
          …..
        </style>
      </resources>

   **Dark theme**

   .. code:: prettyprint

      Themes.xml

      <resources>
        <style name="AppTheme" parent="Theme.Material3.Dark.NoActionBar">
          <item name="colorPrimary">@color/md_theme_dark_primary</item>
          <item name="colorOnPrimary">@color/md_theme_dark_onPrimary</item>
          <item name="colorPrimaryContainer">@color/md_theme_dark_primaryContainer</item>
          <item name="colorOnPrimaryContainer">@color/md_theme_dark_onPrimaryContainer</item>
          <item name="colorError">@color/md_theme_dark_error</item>
          <item name="colorOnError">@color/md_theme_dark_onError</item>
          <item name="colorErrorContainer">@color/md_theme_dark_errorContainer</item>
          <item name="colorOnErrorContainer">@color/md_theme_dark_onErrorContainer</item>
          <item name="colorOnBackground">@color/md_theme_dark_onBackground</item>
          <item name="colorSurface">@color/md_theme_dark_surface</item>
          <item name="colorOnSurface">@color/md_theme_dark_onSurface</item>
          ……
        </style>
      </resources>

   **Colors xml**

   .. code:: prettyprint

      Colors.xml

      <resources>
        <color name="md_theme_light_primary">#6750A4</color>
        <color name="md_theme_light_onPrimary">#FFFFFF</color>
        <color name="md_theme_light_primaryContainer">#EADDFF</color>
        <color name="md_theme_light_onPrimaryContainer">#21005D</color>
        <color name="md_theme_light_error">#B3261E</color>
        <color name="md_theme_light_onError">#FFFFFF</color>
        <color name="md_theme_light_errorContainer">#F9DEDC</color>
        <color name="md_theme_light_onErrorContainer">#410E0B</color>
        <color name="md_theme_light_surface">#FFFBFE</color>
        <color name="md_theme_light_onSurface">#1C1B1F</color>
        <color name="md_theme_light_surfaceVariant">#E7E0EC</color>
        <color name="md_theme_dark_primary">#D0BCFF</color>
        <color name="md_theme_dark_onPrimary">#381E72</color>
        <color name="md_theme_dark_primaryContainer">#4F378B</color>
        <color name="md_theme_dark_onPrimaryContainer">#EADDFF</color>
        <color name="md_theme_dark_secondary">#CCC2DC</color>
        <color name="md_theme_dark_onSecondary">#332D41</color>
        <color name="md_theme_dark_secondaryContainer">#4A4458</color>
        <color name="md_theme_dark_onSurface">#E6E1E5</color>
        <color name="md_theme_dark_surfaceVariant">#49454F</color>
      </resources>

   For more information:

   -  To learn more about Dynamic Color, custom colors, and generating tokens,
      check out the Material 3 `Dynamic Color <https://m3.material.io/styles/color/dynamic-color/overview>`__
      page.

   -  To generate the base color palette and your app's colors and theme, check
      out the Material Theme Builder, available through a `Figma plugin <https://goo.gle/material-theme-builder-figma>`__ or `in browser <https://goo.gle/material-theme-builder-web>`__).

   -  To learn more about how using color schemes can enable better
      accessibility in your app, see the Material 3 page about `Color system accessibility <https://m3.material.io/styles/color/the-color-system/accessibility>`__.

   .. rubric:: Retain custom or brand colors
      :name: retain-custom-colors

   If your app has custom or brand colors that you don't want to change with the
   user's preferences, you can add them individually as you build out your color
   scheme. For example:

   .. code:: prettyprint

      Themes.xml

      <resources>
          <style name="AppTheme" parent="Theme.Material3.Light.NoActionBar">
              ...
              <item name="home_lamp">@color/home_yellow</item>
                ...
          </style>
      </resources>

   .. code:: prettyprint

      Colors.xml
      <resources>
         <color name="home_yellow">#E8D655</color>
      </resources>

   Alternatively, you can use the Material Theme Builder to import additional
   colors that extend your color scheme, thereby creating a unified color
   system. With this option, use
   `HarmonizedColors <#>`__
   to shift the tone of custom colors. This achieves a visual balance and
   accessible contrast when combined with user-generated colors. It occurs at
   runtime with
   `applyToContextIfAvailable() <#applyToContextIfAvailable(android.content.Context,%20com.google.android.material.color.HarmonizedColorsOptions)>`__.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/theming/images/harmonize.png
      :width: 550px

      **Figure 6.** Example of harmonizing custom colors

   See Material 3's guidance on `harmonizing custom colors <https://m3.material.io/styles/color/the-color-system/custom-colors>`__.

   .. rubric:: Apply Dynamic Color to your adaptive icons and widgets
      :name: apply-widgets

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/theming/images/dynamic-color-icons-widgets.png
      :width: 350px

   In addition to enabling Dynamic Color theming on your app, you can also
   support Dynanmic Color theming for
   `widgets <#dynamic-colors>`__ starting in
   Android 12, and for `adaptive icons <#>`__ starting in Android
   13.


Last updated 2024-05-03 UTC.


/Select colors with the palette library
=======================================

.. https://developer.android.google.cn/develop/ui/views/graphics/palette-colors?hl=en

.. container:: devsite-article-body

   Good visual design is essential for a successful app, and color schemes are a
   primary component of design. The `Palette library <#>`__ is a Jetpack library that
   extracts prominent colors from images to create visually engaging apps.

   You can use the Palette library to design layout
   `themes <#>`__ and apply custom colors to visual
   elements in your app. For example, you can use a palette to create a
   color-coordinated title card for a song based on its album cover or to adjust
   an app's toolbar color when its background image changes. The
   `Palette <#androidx.palette.graphics.Palette>`__ object gives
   you access to the colors in a
   `Bitmap <#android.graphics.Bitmap>`__ image while also
   providing six main color profiles from the bitmap to inform your `design choices <http://material.google.com>`__.

   .. rubric:: Set up the library
      :name: set-up-the-library

   To use the Palette library, add the following to your ``build.gradle``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kts
               :class: two-line-tab

            .. code:: prettyprint

               android {
                   compileSdkVersion(33)
                   ...
               }

               dependencies {
                   ...
                   implementation("androidx.palette:palette:1.0.0")
               }

         .. container:: section

            .. rubric:: Groovy
               :name: groovy
               :class: two-line-tab

            .. code:: prettyprint

               android {
                   compileSdkVersion 33
                   ...
               }

               dependencies {
                   ...
                   implementation 'androidx.palette:palette:1.0.0'
               }

   .. rubric:: Create a palette
      :name: create-a-palette

   A ``Palette`` object gives you access to the primary colors in an image as
   well as the corresponding colors for overlaid text. Use palettes to design
   your app's style and to dynamically change your app's color scheme based on a
   given source image.

   To create a palette, first instantiate a
   `Palette.Builder <#androidx.palette.graphics.Palette.Builder>`__
   from a ``Bitmap``. You can then use the ``Palette.Builder`` to customize the
   palette before generating it. This section describes palette generation and
   customization from a bitmap image.

   .. rubric:: Generate a Palette instance
      :name: generate-a-palette-instance

   Generate a ``Palette`` instance using its
   `from(Bitmap bitmap) <#androidx.palette.graphics.Palette>`__
   method to first create a ``Palette.Builder`` from a ``Bitmap``.

   The builder can generate the palette synchronously or asynchronously. Use
   synchronous palette generation if you want to create the palette on the same
   thread as the method being called. If you generate the palette
   asynchronously, on a different thread, use the
   `onGenerated() <#androidx.palette.graphics.Palette.PaletteAsyncListener>`__
   method to access the palette immediately after it is created.

   The following code snippet provides example methods for both types of palette
   generation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Generate palette synchronously and return it.
               fun createPaletteSync(bitmap: Bitmap): Palette = Palette.from(bitmap).generate()

               // Generate palette asynchronously and use it on a different thread using onGenerated().
               fun createPaletteAsync(bitmap: Bitmap) {
                   Palette.from(bitmap).generate { palette ->
                       // Use generated instance.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Generate palette synchronously and return it.
               public Palette createPaletteSync(Bitmap bitmap) {
                 Palette p = Palette.from(bitmap).generate();
                 return p;
               }

               // Generate palette asynchronously and use it on a different thread using onGenerated().
               public void createPaletteAsync(Bitmap bitmap) {
                 Palette.from(bitmap).generate(new PaletteAsyncListener() {
                   public void onGenerated(Palette p) {
                     // Use generated instance.
                   }
                 });
               }

   If you need to continuously generate palettes for a sorted list of images or
   objects, consider `caching <#android.util.LruCache>`__ the
   ``Palette`` instances to prevent slow UI performance. Don't create the
   palettes on your `main thread <#Avoiding>`__.

   .. rubric:: Customize your palette
      :name: customize-your-palette

   The ``Palette.Builder`` lets you customize your palette by choosing how many
   colors are in the resulting palette, what area of your image the builder uses
   to generate the palette, and what colors are included in the palette. For
   example, you can filter out the color black or ensure the builder only uses
   the top half of an image to generate your palette.

   Fine-tune your palette's size and colors with the following methods from the
   ``Palette.Builder`` class:

   `addFilter() <#androidx.palette.graphics.Palette.Builder>`__
      This method adds a filter that indicates what colors are allowed in the
      resulting palette. Pass in your own
      `Palette.Filter <#androidx.palette.graphics.Palette.Filter>`__
      and modify its ``isAllowed()`` method to determine which colors are
      filtered from the palette.
   `maximumColorCount() <#androidx.palette.graphics.Palette.Builder>`__
      This method sets the maximum number of colors in your palette. The default
      value is 16, and the optimal value depends on the source image. For
      landscapes, optimal values range from 8-16, while pictures with faces
      usually have values from 24-32. The ``Palette.Builder`` takes longer to
      generate palettes with more colors.
   `setRegion() <#androidx.palette.graphics.Palette.Builder>`__
      This method indicates what area of the bitmap the builder uses when
      creating the palette. You can only use this method when generating the
      palette from a bitmap, and it doesn't affect the original image.
   `addTarget() <#androidx.palette.graphics.Palette.Builder>`__
      This method lets you perform your own color matching by adding a
      `Target <#androidx.palette.graphics.Target>`__ color profile
      to the builder. If the default ``Target`` is insufficient, advanced
      developers can create their own ``Target`` using a
      `Target.Builder <#androidx.palette.graphics.Target.Builder>`__.

   .. rubric:: Extract color profiles
      :name: extract-color-profiles

   Based on the `standards of Material Design <https://material.google.com/style/color.html>`__, the Palette library
   extracts commonly used color profiles from an image. Each profile is defined
   by a ``Target``, and colors extracted from the bitmap image are scored
   against each profile based on saturation, luminance, and population (number
   of pixels in the bitmap represented by the color). For each profile, the
   color with the best score defines that color profile for the given image.

   By default, a ``Palette`` object contains 16 primary colors from a given
   image. When generating your palette, you can
   `customize <#customize-your-palette>`__ its number of colors using the
   ``Palette.Builder``. Extracting more colors provides more potential matches
   for each color profile, but it also causes ``Palette.Builder`` to take longer
   when generating the palette.

   The Palette library attempts to extract the following six color profiles:

   -  Light Vibrant
   -  Vibrant
   -  Dark Vibrant
   -  Light Muted
   -  Muted
   -  Dark Muted

   Each of the ``get<``\ *``Profile``*\ ``>Color()`` methods in ``Palette``
   returns the color in the palette associated with that particular profile,
   where ``<``\ *``Profile``*\ ``>`` is replaced by the name of one of the six
   color profiles. For example, the method to get the Dark Vibrant color profile
   is
   `getDarkVibrantColor() <#androidx.palette.graphics.Palette>`__.
   Since not all images contain all color profiles, provide a default color to
   return.

   Figure 1 displays a photo and its corresponding color profiles from the
   ``get<``\ *``Profile``*\ ``>Color()`` methods.

   .. figure::
      https://developer.android.google.cn/static/training/material/images/palette-library-color-profiles_2-1_2x.png
      name: color-profiles
      :alt: An image showing a sunset on the left and the extracted color
      palette on the right.
      :width: 100.0%

      **Figure 1.** An example image and its extracted color profiles given the
      default maximum color count (16) for the palette.

   .. rubric:: Use swatches to create color schemes
      :name: use-swatches

   The ``Palette`` class also generates
   `Palette.Swatch <#androidx.palette.graphics.Palette.Swatch>`__
   objects for each color profile. ``Palette.Swatch`` objects contain the
   associated color for that profile as well as the color's population in
   pixels.

   Swatches have additional methods for accessing more information about the
   color profile, such as HSL values and pixel population. You can use swatches
   to help create more comprehensive color schemes and app themes using the
   `getBodyTextColor() <#androidx.palette.graphics.Palette.Swatch>`__
   and
   `getTitleTextColor() <#androidx.palette.graphics.Palette.Swatch>`__
   methods. These methods return colors appropriate for use over the swatch's
   color.

   Each ``get<``\ *``Profile``*\ ``>Swatch()`` methods from ``Palette`` returns
   the swatch associated with that particular profile, where
   ``<``\ *``Profile``*\ ``>`` is replaced by the name of one of the six color
   profiles. Although the palette's ``get<``\ *``Profile``*\ ``>Swatch()``
   methods don't require default value parameters, they return ``null`` if that
   particular profile doesn't exist in the image. Therefore, check that a swatch
   isn't null before using it. For example, the following code gets the title
   text color from a palette if the Vibrant swatch isn't null:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val vibrant = myPalette.vibrantSwatch
               // In Kotlin, check for null before accessing properties on the vibrant swatch.
               val titleColor = vibrant?.titleTextColor

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Palette.Swatch vibrant = myPalette.getVibrantSwatch();
               if(vibrant != null){
                   int titleColor = vibrant.getTitleTextColor();
                   // ...
               }

   To access all colors in a palette, the
   `getSwatches() <#androidx.palette.graphics.Palette>`__
   method returns a list of all swatches generated from an image, including the
   standard six color profiles.

   The following snippet of code uses the methods from the preceding code
   snippets to synchronously generate a palette, get its vibrant swatch, and
   change the colors of a toolbar to match the bitmap image. Figure 2 displays
   the resulting image and toolbar.

   .. container:: cols

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Set the background and text colors of a toolbar given a bitmap image to
                  // match.
                  fun setToolbarColor(bitmap: Bitmap) {
                      // Generate the palette and get the vibrant swatch.
                      val vibrantSwatch = createPaletteSync(bitmap).vibrantSwatch

                      // Set the toolbar background and text colors.
                      // Fall back to default colors if the vibrant swatch isn't available.
                      with(findViewById<Toolbar>(R.id.toolbar)) {
                          setBackgroundColor(vibrantSwatch?.rgb ?:
                                  ContextCompat.getColor(context, R.color.default_title_background))
                          setTitleTextColor(vibrantSwatch?.titleTextColor ?:
                                  ContextCompat.getColor(context, R.color.default_title_color))
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Set the background and text colors of a toolbar given a bitmap image to
                  // match.
                  public void setToolbarColor(Bitmap bitmap) {
                      // Generate the palette and get the vibrant swatch.
                      // See the createPaletteSync() method from the preceding code snippet.
                      Palette p = createPaletteSync(bitmap);
                      Palette.Swatch vibrantSwatch = p.getVibrantSwatch();

                      Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);

                      // Load default colors.
                      int backgroundColor = ContextCompat.getColor(getContext(),
                          R.color.default_title_background);
                      int textColor = ContextCompat.getColor(getContext(),
                          R.color.default_title_color);

                      // Check that the Vibrant swatch is available.
                      if(vibrantSwatch != null){
                          backgroundColor = vibrantSwatch.getRgb();
                          textColor = vibrantSwatch.getTitleTextColor();
                      }

                      // Set the toolbar background and text colors.
                      toolbar.setBackgroundColor(backgroundColor);
                          toolbar.setTitleTextColor(textColor);
                  }

   .. figure::
      https://developer.android.google.cn/static/training/material/images/palette-library-title-text-color_2-1_2x.png
      name: TitleTextColor
      :alt: An image showing a sunset and a toolbar with TitleTextColor inside
      :width: 70.0%

      **Figure 2.** An example image with its vibrant-colored toolbar and
      corresponding title text color.


Last updated 2024-05-03 UTC.


/Use Material Design as a guideline
===================================

.. https://developer.android.google.cn/develop/ui/views/theming/look-and-feel?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with theming in Compose.

      `Material Design 3 → <https://developer.android.google.cn/jetpack/compose/designsystems/material3>`__

      |image-android-compose-ui-logo|

   Material Design is a comprehensive guide for visual, motion, and interaction
   design across platforms and devices. To use Material Design in your Android
   apps, follow the guidelines defined in the `Material Design specification <https://m3.material.io/>`__. If your app uses Jetpack Compose,
   you can use the `Compose Material 3 <#>`__ library. If your app uses
   views, you can use the `Android Material Components <https://github.com/material-components/material-components-android>`__
   library.

   .. container:: video-wrapper

   Android provides the following features to help you build Material Design
   apps:

   -  A Material Design app theme to style all your UI widgets
   -  Widgets for complex views, such as lists and cards
   -  APIs for custom shadows and animations

   .. rubric:: Material theme and widgets
      :name: Theme

   To take advantage of the Material features, such as styling for standard UI
   widgets, and to streamline your app's style definition, apply a
   Material-based theme to your app.

   .. container:: cols

      .. container:: col-1of2

         |image-MaterialDark|

         .. container::

            **Figure 1.** Dark Material theme.

      .. container:: col-1of2

         |image-MaterialLight|

         .. container::

            **Figure 2.** Light Material theme.

   If you use Android Studio to create your Android project, it applies a
   Material theme by default. To learn how to update your project's theme, see
   `Styles and themes <#>`__.

   To provide your users a familiar experience, use Material's most common UX
   patterns:

   -  Promote your UI's main action with a `floating action button <#>`__ (FAB).
   -  Show your brand, navigation, search, and other actions using the `app bar <#>`__.
   -  Show and hide your app's navigation with the `navigation drawer <#>`__.
   -  Choose from the many other Material Components for your app layout and
      navigation, such as collapsing toolbars, tabs, a bottom nav bar, and more.
      To see them all, see the `Material Components for Android catalog <https://m3.material.io/components>`__.

   Whenever possible, use predefined Material Icons. For example, for the
   navigation "menu" button for your navigation drawer, use the standard
   "hamburger" icon. See `Material Design Icons <https://m3.material.io/styles/icons/overview>`__ for a list of
   available icons. You can also import SVG icons from the Material Icon library
   with Android Studio's `Vector Asset Studio <#importing>`__.

   .. rubric:: Elevation shadows and cards
      :name: Shadows

   In addition to the *X* and *Y* properties, views in Android have a *Z*
   property. This property represents the elevation of a view, which determines
   the following:

   -  The size of its shadow: views with higher *Z* values cast bigger shadows.
   -  The drawing order: views with higher *Z* values appear on top of other
      views.

   |image-cast-shadows_2x|
   **Figure 3.** The *Z* value representing elevation.
   You can apply elevation to a card-based layout, which helps you display
   important pieces of information inside cards that provide a Material look.
   You can use the
   `CardView <#androidx.cardview.widget.CardView>`__ widget to
   create cards with a default elevation. For more information, see `Create a card-based layout <#>`__.

   For information about adding elevation to other views, see `Create shadows and clip views <#>`__.

   .. rubric:: Animations
      :name: Animations

   .. container:: attempt-right

      **Figure 4.** A touch feedback animation.

   Animation APIs let you create custom animations for touch feedback in UI
   controls, changes in view state, and activity transitions.

   These APIs let you:

   -  Respond to touch events in your views with **touch feedback** animations.
   -  Hide and show views with **circular reveal** animations.
   -  Switch between activities with custom **activity transition** animations.
   -  Create more natural animations with **curved motion**.
   -  Animate changes in one or more view properties with **view state change**
      animations.
   -  Show animations in **state list drawables** between view state changes.

   Touch feedback animations are built into several standard views, such as
   buttons. The animation APIs let you customize these animations and add them
   to your custom views.

   For more information, see `Introduction to animations <#>`__.

   .. rubric:: Drawables
      :name: Drawables

   .. container::

      ` <https://developer.android.google.cn/jetpack/compose/graphics/images/compare>`__

      .. container:: android-inline-link-text-container

         .. container:: android-inline-link-icon-title-container

            |image-jetpack-compose|

            .. container:: android-inline-link-title

               Try the Compose way

         .. container:: android-inline-link-horizontal-divider

         .. container:: android-inline-link-copy

            Work with Drawables in Compose

      arrow_forward

   These capabilities for drawables help you implement Material Design apps:

   -  **Vector drawables** are scalable without losing definition and are
      perfect for single-color in-app icons. Learn more about `vector drawables <#>`__.
   -  **Drawable tinting** lets you define bitmaps as an alpha mask and tint
      them with a color at runtime. See how to `add tint to drawables <#DrawableTint>`__.
   -  **Color extraction** lets you automatically extract prominent colors from
      a bitmap image. See how to `select colors with the Palette API <#>`__.


Last updated 2024-04-04 UTC.

.. |image-MaterialDark| image:: https://developer.android.google.cn/static/design/material/images/MaterialDark.png
   :width: 250px
.. |image-MaterialLight| image:: https://developer.android.google.cn/static/design/material/images/MaterialLight.png
   :width: 250px
.. |image-cast-shadows_2x| image:: https://developer.android.google.cn/static/images/ui/material-design/cast-shadows_2x.png
   :width: 700px
.. |image-jetpack-compose| image:: https://developer.android.google.cn/static/images/spot-icons/jetpack-compose.svg


/Implement dark theme
=====================

.. https://developer.android.google.cn/develop/ui/views/theming/darktheme?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with theming in Compose.

      `Color Scheme - Material Design 3 → <https://developer.android.google.cn/jetpack/compose/designsystems/material3#color-scheme>`__

      |image-android-compose-ui-logo|

   .. container:: attempt-right

      .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/look-and-feel/darktheme.png
         name: dark theme

         **Figure 1.** Dark theme.

   Dark theme is available in Android 10 (API level 29) and higher. It has the
   following benefits:

   -  Reduces power usage by a significant amount, depending on the device’s
      screen technology.
   -  Improves visibility for users with low vision and those who are sensitive
      to bright light.
   -  Makes it easier to use a device in a low-light environment.

   Dark theme applies to the Android system UI and apps running on the device.

   There are three ways to enable dark theme in Android 10 and higher:

   -  Use the system setting by navigating to **Settings > Display > Theme** to
      enable dark theme.
   -  Use the Quick Settings tile to switch themes from the notification tray,
      when enabled.
   -  On Pixel devices, enable Battery Saver mode to enable dark theme at the
      same time. Other devices might not support this behavior.

   For instructions on applying a dark theme to web-based content using a
   WebView component, see `Darken web content in WebView <#>`__.

   .. rubric:: Support dark theme in your app
      :name: support-dark-theme

   To support dark theme, set your app's theme—usually found in
   ``res/values/styles.xml``—to inherit from a ``DayNight`` theme:

   .. code:: devsite-click-to-copy

      <style name="AppTheme" parent="Theme.AppCompat.DayNight">

   You can also use the `Material Components dark theme <https://material.io/develop/android/theming/dark>`__:

   .. code:: devsite-click-to-copy

      <style name="AppTheme" parent="Theme.MaterialComponents.DayNight">

   This ties the app's main theme to the system-controlled night mode flags and
   gives the app a default dark theme when it is enabled.

   .. rubric:: Themes and styles
      :name: themes-styles

   Avoid using hardcoded colors or icons intended for use under a light theme.
   Use theme attributes or night-qualified resources instead.

   Two theme attributes are most important for dark theme:

   -  ``?android:attr/textColorPrimary``: a general-purpose text color. It is
      near-black in light theme and near-white in dark themes. It contains a
      disabled state.
   -  ``?attr/colorControlNormal``: a general-purpose icon color. It contains a
      disabled state.

   We recommend using `Material Design Components <https://material.io/develop/android/>`__, since its `color theming system <https://material.io/develop/android/theming/color/>`__, such
   as the theme attributes ``?attr/colorSurface`` and ``?attr/colorOnSurface``,
   provides easy access to suitable colors. You can customize these attributes
   in your theme.

   .. rubric:: Change themes in-app
      :name: change-themes

   You can let users change the app's theme while the app is running. The
   following are recommended options:

   -  Light
   -  Dark
   -  System default (the recommended default option)

   These options map directly to ``AppCompat.DayNight`` modes:

   -  Light:
      `MODE_NIGHT_NO <#androidx.appcompat.app.AppCompatDelegate>`__.

   -  Dark:
      `MODE_NIGHT_YES <#androidx.appcompat.app.AppCompatDelegate>`__.

   -  System default:
      `MODE_NIGHT_FOLLOW_SYSTEM <#androidx.appcompat.app.AppCompatDelegate>`__.

   To switch the theme, do the following:

   -  On API level 31 and above, use
      `UiModeManager#setApplicationNightMode <https://developer.android.google.cn/reference/android/app/UiModeManager#setApplicationNightMode(int)>`__
      to let the system know what theme your app runs. This lets the system
      match the theme during the splash screen.

   -  On API level 30 and below, use
      `AppCompatDelegate.setDefaultNightMode() <#androidx.appcompat.app.AppCompatDelegate>`__
      to switch the theme.

   **Note:**\  Starting with ``AppCompat`` v1.1.0, ``setDefaultNightMode()``
   automatically recreates any started activities.

   .. rubric:: Force Dark
      :name: force-dark

   Android 10 provides *Force Dark*, a feature for developers to quickly
   implement a dark theme without explicitly setting a ``DayNight`` theme.

   Force Dark analyzes each view of your light-themed app and applies a dark
   theme automatically before it is drawn to the screen. You can use a mix of
   Force Dark and native implementation to cut down on the time needed to
   implement dark theme.

   Apps must opt in to Force Dark by setting ``android:forceDarkAllowed="true"``
   in the activity's theme. This attribute is set on all of the system- and
   AndroidX-provided light themes, such as ``Theme.Material.Light``. When you
   use Force Dark, test your app thoroughly and exclude views as needed.

   If your app uses a dark theme, such as ``Theme.Material``), Force Dark isn't
   applied. Similarly, if your app's theme inherits from a ``DayNight`` theme,
   Force Dark isn't applied due to the automatic theme switching.

   .. rubric:: Disable Force Dark on a view
      :name: disable-force-dark

   Force Dark can be controlled on specific views with the
   ``android:forceDarkAllowed`` layout attribute or with
   `setForceDarkAllowed() <#android.view.View>`__.

   .. rubric:: Web content
      :name: web-content

   For information on using dark themes in web-based content, see `Darken web content in WebView <#>`__. For an example of dark
   theme applied to a WebView, see the `WebView demo on GitHub <https://github.com/android/views-widgets-samples/tree/main/WebView>`__
   .

   .. rubric:: Best practices
      :name: best-practices

   The following sections provide best practices for implementing dark themes.

   .. rubric:: Notifications and widgets
      :name: notifications-and-widgets

   For UI surfaces that you display on the device but don't directly control,
   make sure that any views you use reflect the host app’s theme. Two examples
   are notifications and launcher widgets.

   .. rubric:: Notifications
      :name: notifications

   Use the system-provided notification templates, such as ``MessagingStyle``.
   This means the system is responsible for applying the correct view styling.

   .. rubric:: Widgets and custom notification views
      :name: widgets

   For launcher widgets, or if your app uses custom notification content views,
   test the content on both the light and dark themes.

   Common pitfalls to look out for include the following:

   -  Assuming the background color is always light.
   -  Hardcoding text colors.
   -  Setting a hardcoded background color while using the default text color.
   -  Using a drawable icon that is a static color.

   In all these cases, use appropriate theme attributes instead of hardcoded
   colors.

   .. rubric:: Launch screens
      :name: launch-screens

   If your app has a custom launch screen, you might need to modify it so that
   it reflects the selected theme.

   Remove any hardcoded colors such as background colors set programmatically to
   white. Use the ``?android:attr/colorBackground`` theme attribute instead.

   **Note:**\  Dark-themed ``android:windowBackground`` drawables only work on
   Android 10.

   .. rubric:: Configuration changes
      :name: config-changes

   When the app’s theme changes, either through the system setting or AppCompat,
   it triggers a
   `uiMode <#android.content.res.Configuration>`__
   configuration change. This means activities are automatically recreated.

   In some cases, you might want an app to handle the configuration change. For
   example, you might want to delay a configuration change because a video is
   playing.

   An app can handle the implementation of dark theme by declaring that each
   ``Activity`` can handle the ``uiMode`` configuration change:

   .. code:: devsite-click-to-copy

      <activity
          android:name=".MyActivity"
          android:configChanges="uiMode" />

   When an ``Activity`` declares that it handles configuration changes, its
   `onConfigurationChanged() <#android.app.Activity>`__
   method is called when there is a theme change.

   To check what the current theme is, apps can run code like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val currentNightMode = configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
               when (currentNightMode) {
                   Configuration.UI_MODE_NIGHT_NO -> {} // Night mode is not active, we're using the light theme.
                   Configuration.UI_MODE_NIGHT_YES -> {} // Night mode is active, we're using dark theme.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               int currentNightMode = configuration.uiMode & Configuration.UI_MODE_NIGHT_MASK;
               switch (currentNightMode) {
                   case Configuration.UI_MODE_NIGHT_NO:
                       // Night mode is not active, we're using the light theme
                       break;
                   case Configuration.UI_MODE_NIGHT_YES:
                       // Night mode is active, we're using dark theme
                       break;
               }

   **Note:**\  To learn more about configuration changes, how to restrict
   Activity recreation if needed, and how to react to those configuration
   changes from the View system and Jetpack Compose, check out the `Handle configuration changes <#>`__ page.


Last updated 2024-05-03 UTC.



/Create shadows and clip views
==============================

.. https://developer.android.google.cn/develop/ui/views/theming/shadows-clipping?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to work with theming in Compose.

      `Modifier.shadow() → <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).shadow(androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Shape,kotlin.Boolean,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color)>`__

      |image-android-compose-ui-logo|

   Material Design introduces elevation for UI elements. Elevation helps users
   understand the relative importance of each element and focus their attention
   to the current task.

   **Note:** This page describes shadows obtained by elevation. ``Material3``
   introduces an elevation approach based on surface color. For more information
   about maintanability and approaching the user experience, see `Material Elevation <https://m3.material.io/styles/elevation/overview>`__, and consider
   migrating your project to `Jetpack Compose <#>`__.
   The elevation of a view, represented by the *Z* property, determines the
   visual appearance of its shadow. Views with higher *Z* values cast larger,
   softer shadows, and they occlude views with lower *Z* values. However, the
   *Z* value of a view doesn't affect the view's size.

   .. figure:: https://developer.android.google.cn/static/images/ui/material-design/cast-shadows_2x.png
      name: intro
      :alt: An image showing how a view elevation produces a shadow.
      :width: 80.0%

      **Figure 1.** Elevation on the *Z*-axis and the resulting shadow.

   Shadows are drawn by the parent of the elevated view. They are subject to
   standard view clipping and are clipped by the parent by default.

   Elevation is also useful to create animations where widgets temporarily rise
   above the view plane when performing actions.

   For more information, see `Elevation in Material Design <https://material.io/design/environment/elevation.html>`__.

   .. rubric:: Assign elevation to your views
      :name: Elevation

   The *Z* value for a view has two components:

   -  Elevation: the static component
   -  Translation: the dynamic component used for animations

   ``Z = elevation + translationZ``

   The *Z* values are measured in dp (density-independent pixels).

   .. figure:: https://developer.android.google.cn/static/training/material/images/shadows-depth.png
      name: depth
      :alt: An image showing different shadows for different elevations in dp
      :width: 80.0%

      **Figure 2.** Different shadows for different elevations in dp.

   To set the default (resting) elevation of a view, use the
   ``android:elevation`` attribute in the XML layout. To set the elevation of a
   view in the code of an activity, use the
   `View.setElevation() <#android.view.View>`__
   method.

   To set the translation of a view, use the
   `View.setTranslationZ() <#android.view.View>`__
   method.

   The
   `ViewPropertyAnimator.z() <#android.view.ViewPropertyAnimator>`__
   and
   `ViewPropertyAnimator.translationZ() <#android.view.ViewPropertyAnimator>`__
   methods let you animate the elevation of views. For more information, see the
   API reference for
   `ViewPropertyAnimator <#android.view.ViewPropertyAnimator>`__
   and the `property animation <#>`__
   developer guide.

   You can also use a
   `StateListAnimator <#android.animation.StateListAnimator>`__ to
   specify these animations in a declarative way. This is especially useful for
   cases where state changes trigger animations, like when the user taps a
   button. For more information, see `Animate view state changes using StateListAnimator <#ViewState>`__.

   .. rubric:: Customize view shadows and outlines
      :name: Shadows

   The bounds of a view's background drawable determine the default shape of its
   shadow. *Outlines* represent the outer shape of a graphics object and define
   the ripple area for touch feedback.

   Consider the following view, which is defined with a background drawable:

   .. code:: prettyprint

      <TextView
          android:id="@+id/myview"
          ...
          android:elevation="2dp"
          android:background="@drawable/myrect" />

   The background drawable is defined as a rectangle with rounded corners:

   .. code:: prettyprint

      <!-- res/drawable/myrect.xml -->
      <shape xmlns:android="http://schemas.android.com/apk/res/android"
             android:shape="rectangle">
          <solid android:color="#42000000" />
          <corners android:radius="5dp" />
      </shape>

   The view casts a shadow with rounded corners, since the background drawable
   defines the view's outline. Providing a custom outline overrides the default
   shape of a view's shadow.

   To define a custom outline for a view in your code, do the following:

   #. Extend the
      `ViewOutlineProvider <#android.view.ViewOutlineProvider>`__
      class.
   #. Override the
      `getOutline() <#android.view.ViewOutlineProvider>`__
      method.
   #. Assign the new outline provider to your view with the
      `View.setOutlineProvider() <#android.view.View>`__
      method.

   You can create oval and rectangular outlines with rounded corners using the
   methods in the `Outline <#android.graphics.Outline>`__ class.
   The default outline provider for views obtains the outline from the view's
   background. To prevent a view from casting a shadow, set its outline provider
   to ``null``.

   .. rubric:: Clip views
      :name: Clip

   Clipping views lets you change the shape of a view. You can clip views for
   consistency with other design elements or to change the shape of a view in
   response to user input. You can clip a view to its outline area using the
   `View.setClipToOutline() <#android.view.View>`__
   method. Only outlines that are rectangles, circles, and round rectangles
   support clipping, as determined by the
   `Outline.canClip() <#android.graphics.Outline>`__
   method.

   To clip a view to the shape of a drawable, set the drawable as the background
   of the view—as shown in the preceding example—and call the
   ``View.setClipToOutline()`` method.

   Clipping views is an expensive operation, so don't animate the shape you use
   to clip a view. To achieve this effect, use the `reveal animation <#Reveal>`__.


Last updated 2024-04-15 UTC.



/Floating action buttons (FABs)
===============================

.. https://developer.android.google.cn/develop/ui/views/components/floating-action-button?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `Floating Action Button → <https://developer.android.google.cn/jetpack/compose/layouts/material#fab>`__

      |image-android-compose-ui-logo|

   A floating action button (FAB) is a circular button that triggers the primary
   action in your app's UI. This document shows how to add a FAB to your layout,
   customize some of its appearance, and respond to button taps.

   To learn more about how to design a FAB for your app according to the
   Material Design Guidelines, see `Material Design FAB <https://m3.material.io/components/floating-action-button/overview>`__ .

   .. figure:: https://developer.android.google.cn/static/training/material/images/fab.png
      name: fab
      :alt: An image showing an app screen containing a red FloatingActionButton
      :width: 50.0%

      **Figure 1.** A floating action button (FAB).

   .. rubric:: Add the floating action button to your layout
      :name: CreateFAB

   The following code shows how the
   `FloatingActionButton <#>`__
   appears in your layout file:

   .. code:: prettyprint

      <com.google.android.material.floatingactionbutton.FloatingActionButton
              android:id="@+id/fab"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="end|bottom"
              android:src="@drawable/ic_my_icon"
              android:contentDescription="@string/submit"
              android:layout_margin="16dp" />

   By default, a FAB is colored by the ``colorAccent`` attribute, which you can
   `customize with the theme's color palette <#ColorPalette>`__.

   You can configure other FAB properties using XML attributes or corresponding
   methods, such as the following:

   -  The size of the FAB, using the ``app:fabSize`` attribute or the
      `setSize() <#setSize(int)>`__
      method
   -  The ripple color of the FAB, using the ``app:rippleColor`` attribute or
      the
      `setRippleColor() <#setRippleColor(int)>`__
      method
   -  The FAB icon, using the ``android:src`` attribute or the
      `setImageDrawable() <#android.widget.ImageView>`__
      method

   .. rubric:: Respond to button taps
      :name: HandleFabClick

   You can then apply an
   `View.OnClickListener <#android.view.View.OnClickListener>`__
   to handle FAB taps. For example, the following code displays a
   `Snackbar <#>`__
   when the user taps the FAB:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fab: View = findViewById(R.id.fab)
               fab.setOnClickListener { view ->
                   Snackbar.make(view, "Here's a Snackbar", Snackbar.LENGTH_LONG)
                           .setAction("Action", null)
                           .show()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FloatingActionButton fab = findViewById(R.id.fab);
               fab.setOnClickListener(new View.OnClickListener() {
                   @Override
                   public void onClick(View view) {
                       Snackbar.make(view, "Here's a Snackbar", Snackbar.LENGTH_LONG)
                               .setAction("Action", null).show();
                   }
               });

   For more information about the capabilities of the FAB, see the API reference
   for the
   `FloatingActionButton <#>`__.


Last updated 2024-05-03 UTC.



/Buttons
========

.. https://developer.android.google.cn/develop/ui/views/components/button?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `Button → <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Button(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ButtonColors,androidx.compose.material3.ButtonElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__

      |image-android-compose-ui-logo|

   A button consists of text or an icon, or both, that communicates what action
   occurs when the user taps it.

   **Note:** For a better UI and user experience, see the `Material Design button <https://m3.material.io/components/all-buttons>`__ documentation.
   You can create a button in your layout in one of three ways, depending on
   whether you want a button with text, an icon, or both:

   .. code:: prettyprint

        
        <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:app="http://schemas.android.com/apk/res-auto"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:paddingLeft="16dp"
            android:paddingRight="16dp"
            android:orientation="vertical" >
        
            <Button
                android:id="@+id/supabutton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="I'm a button" />
        
            <ImageButton
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:contentDescription="A tiny Android icon"
                android:src="@drawable/baseline_android_24"
                app:tint="#ff0000" />
        
            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:drawableStart="@drawable/baseline_android_24"
                android:drawablePadding="4dp"
                android:drawableTint="#ff0000"
                android:text="I'm a button with an icon" />
        </LinearLayout>

   The previous code generates something like this:

   .. figure:: https://developer.android.google.cn/static/images/ui/buttons.png
      name: buttons
      :alt: An image showing three types of buttons
      :width: 40.0%

      **Figure 1.** Three styles of buttons.

   .. rubric:: Respond to click events
      :name: HandlingEvents

   When the user taps a button, the
   `Button <#android.widget.Button>`__ object receives an on-click
   event.

   To declare the event handler programmatically, create an
   `View.OnClickListener <#android.view.View.OnClickListener>`__
   object and assign it to the button by calling
   `setOnClickListener(View.OnClickListener) <#android.view.View>`__,
   as in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<Button>(R.id.supabutton)
                 .setOnClickListener {
                     Log.d("BUTTONS", "User tapped the Supabutton")
                 }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Button button = (Button) findViewById(R.id.supabutton);
               button.setOnClickListener(new View.OnClickListener() {
                   public void onClick(View v) {
                     Log.d("BUTTONS", "User tapped the Supabutton");
                   }
               });

   .. rubric:: Style your button
      :name: Style

   The appearance of your button—the background image and font—varies between
   devices, because devices by different manufacturers often have different
   default styles for input controls.

   To customize individual buttons with a different background, specify the
   `android:background <#android.R.attr>`__ attribute
   with a drawable or color resource. Alternatively, you can apply a *style* for
   the button, which works in similarly to HTML styles to define multiple style
   properties such as the background, font, and size. For more information about
   applying styles, see `Styles and themes <#>`__.

   .. rubric:: Borderless button
      :name: Borderless

   One design that can be useful is a "borderless" button. Borderless buttons
   resemble basic buttons except that they have no borders or background but
   still change appearance during different states, such as when tapped.

   To create a borderless button, apply the
   `borderlessButtonStyle <#android.R.attr>`__
   style to the button, as in the following example:

   .. code:: prettyprint

      <Button
        android:id="@+id/supabutton"
        style="?android:attr/borderlessButtonStyle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="I'm a button" />

   .. rubric:: Custom background
      :name: CustomBackground

   If you want to truly redefine the appearance of your button, you can specify
   a custom background. Instead of supplying a simple bitmap or color, however,
   your background must be a state list resource that changes appearance
   depending on the button's current state.

   You can define the state list in an XML file that defines three images or
   colors to use for the different button states.

   To create a state list drawable for your button background, do the following:

   #. Create three bitmaps for the button background that represent the default,
      tapped, and focused button states. To ensure that your images fit buttons
      of various sizes, create the bitmaps as
      `nine-patch <#nine-patch>`__ bitmaps.

   #. Place the bitmaps into your project's ``res/drawable/`` directory. Name
      each bitmap to reflect the button state it represents, such as
      ``button_default.9.png``, ``button_pressed.9.png``, and
      ``button_focused.9.png``.

   #. Create a new XML file in the ``res/drawable/`` directory. Name it
      something like ``button_custom.xml``. Insert XML like the following:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <selector xmlns:android="http://schemas.android.com/apk/res/android">
             <item android:drawable="@drawable/button_pressed"
                   android:state_pressed="true" />
             <item android:drawable="@drawable/button_focused"
                   android:state_focused="true" />
             <item android:drawable="@drawable/button_default" />
         </selector>

      This defines a single drawable resource that changes its image based on
      the current state of the button.

      -  The first ``<item>`` defines the bitmap to use when the button is
         tapped (activated).
      -  The second ``<item>`` defines the bitmap to use when the button is
         focused, such as when the button is highlighted using the trackball or
         directional pad.
      -  The third ``<item>`` defines the bitmap to use when the button is in
         the default state, neither tapped nor focused.

      **Note:** The order of the ``<item>`` elements is important. When this
      drawable is referenced, the ``<item>`` elements are traversed in order to
      determine which one is appropriate for the current button state. Because
      the default bitmap is last, it is only applied when the conditions
      ``android:state_pressed`` and ``android:state_focused`` are evaluated as
      false.

      This XML file represents a single drawable resource. When referenced by a
      ``Button`` for its background, the image displayed changes based on the
      button's state.

   #. Apply the drawable XML file as the button background:

      .. code:: prettyprint

         <Button
             android:id="@+id/button_send"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:text="@string/button_send"
             android:onClick="sendMessage"
             android:background="@drawable/button_custom"  />

   For more information about this XML syntax, including how to define a button
   that is disabled, hovered, or in another state, read about
   `StateListDrawable <#StateList>`__.


Last updated 2024-04-15 UTC.



/Check boxes
============

.. https://developer.android.google.cn/develop/ui/views/components/checkbox?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `Checkbox → <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Checkbox(kotlin.Boolean,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.material3.CheckboxColors,androidx.compose.foundation.interaction.MutableInteractionSource)>`__

      |image-android-compose-ui-logo|

   **Note:** For a better user experience, see the `Material Design Checkbox <https://m3.material.io/components/checkbox/overview>`__
   documentation.
   Checkboxes let the user select one or more options from a set. Typically, you
   present checkbox options in a vertical list.

   .. figure::
      https://lh3.googleusercontent.com/5myEkgWrS1SEYui5V_VRDXNyYFr25CRPVAKm5sCPhapurUx9EgorjTWNx8s-Sj1Mb4mHw9stQ6Bo6Nkg3LpF0NRZRH1qVOU2r-Nbjr27S3CT=s0
      name: checkboxes
      :alt: An image showing an example of checkboxes from material.io
      :width: 100.0%

      **Figure 1.** An example of checkboxes from `Material Design Checkbox <https://m3.material.io/components/checkbox/guidelines>`__.

   To create each checkbox option, create a
   `CheckBox <#android.widget.CheckBox>`__ in your layout. Because
   a set of checkbox options lets the user select multiple items, each checkbox
   is managed separately, and you must register a click listener for each one.

   .. rubric:: Respond to click events
      :name: HandlingEvents

   Begin by creating a layout with ``CheckBox`` objects in a list:

   .. code:: prettyprint


      <?xml version="1.0" encoding="utf-8"?>
      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
          <CheckBox android:id="@+id/checkbox_meat"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Meat" />
          <CheckBox android:id="@+id/checkbox_cheese"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Cheese"/>
      </LinearLayout>

   Once your layout is ready, head to your ``Activity`` or ``Fragment``, find
   your ``CheckBox`` views, and set a change listener, as in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<CheckBox>(R.id.checkbox_meat)
                   .setOnCheckedChangeListener { buttonView, isChecked ->
                       Log.d("CHECKBOXES", "Meat is checked: $isChecked")
                   }

               findViewById<CheckBox>(R.id.checkbox_cheese)
                   .setOnCheckedChangeListener { buttonView, isChecked ->
                       Log.d("CHECKBOXES", "Cheese is checked: $isChecked")
                   }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               findViewById<CheckBox>(R.id.checkbox_meat)
                   .setOnCheckedChangeListener { buttonView, isChecked ->
                       Log.d("CHECKBOXES", "Meat is checked: $isChecked");
                   }

               findViewById<CheckBox>(R.id.checkbox_cheese)
                   .setOnCheckedChangeListener { buttonView, isChecked ->
                       Log.d("CHECKBOXES", "Cheese is checked: $isChecked");
                   }

   The previous code prints a message in Logcat every time the checkboxes change
   status.

   **Tip:** If you need to change the checkbox state yourself, use the
   `setChecked(boolean) <#android.widget.CompoundButton>`__
   or `toggle() <#android.widget.CompoundButton>`__
   method.


Last updated 2024-04-15 UTC.



/Radio buttons
==============

.. https://developer.android.google.cn/develop/ui/views/components/radiobutton?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `RadioButton → <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#RadioButton(kotlin.Boolean,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.material3.RadioButtonColors,androidx.compose.foundation.interaction.MutableInteractionSource)>`__

      |image-android-compose-ui-logo|

   Radio buttons let the user select one option from a set of mutually exclusive
   options. Use radio buttons if the user needs to see all available options
   listed. If it's not necessary to show all options, use a
   `spinner <#>`__ instead.

   **Note:** For a better user experience, see the Material Design `Radio button <https://m3.material.io/components/radio-button/overview>`__
   documentation.
   .. figure::
      https://lh3.googleusercontent.com/axlkVaJVMYP-eyhYyeGfy9OOtWQgrBbA3AvwyPc5muL8-_pjkzbvum1cHH8sNVES7fBsXyg3S8K9ptWH1LB_oyAbBdQ29N_Uurp9C7Mbc521gw=s0
      name: radiobuttons
      :alt: An example of radio buttons from material.io
      :width: 100.0%

      **Figure 1.** An example of radio buttons from `Material Design <https://m3.material.io/components/radio-button/overview>`__.

   To create each radio button option, create a
   `RadioButton <#android.widget.RadioButton>`__ in your layout.
   Because radio buttons are mutually exclusive, group them inside a
   `RadioGroup <#android.widget.RadioGroup>`__. The system ensures
   that only one radio button within a group can be selected at a time.

   .. rubric:: Respond to click events
      :name: HandlingEvents

   When the user selects a radio button, the corresponding ``RadioButton``
   object receives an on-click event.

   The following example shows a reaction to the user tapping a ``RadioButton``
   object in a group:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <RadioGroup
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:orientation="vertical">
          <RadioButton android:id="@+id/radio_pirates"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Pirates"/>
          <RadioButton android:id="@+id/radio_ninjas"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Ninjas"/>
      </RadioGroup>

   **Note:** ``RadioGroup`` is a subclass of
   `LinearLayout <#android.widget.LinearLayout>`__ that has a
   vertical orientation by default.
   Within the ``Activity`` or ``Fragment`` that hosts this layout, find your
   radio buttons and set a change listener for each of them, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<RadioButton>(R.id.radio_pirates).setOnCheckedChangeListener { buttonView, isChecked ->
                   Log.d("RADIO", "Pirates is checked: $isChecked")
               }

               findViewById<RadioButton>(R.id.radio_ninjas).setOnCheckedChangeListener { buttonView, isChecked ->
                   Log.d("RADIO", "Ninjas is checked: $isChecked")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               findViewById<RadioButton>(R.id.radio_pirates).setOnCheckedChangeListener { buttonView, isChecked ->
                   Log.d("RADIO", "Pirates is checked: $isChecked");
               }

               findViewById<RadioButton>(R.id.radio_ninjas).setOnCheckedChangeListener { buttonView, isChecked ->
                   Log.d("RADIO", "Ninjas is checked: $isChecked");
               }

   In this example, when the user taps one of the radio buttons, a message
   prints in Logcat.

   **Tip:** If you need to change the radio button state yourself, use the
   `setChecked(boolean) <#android.widget.CompoundButton>`__
   or `toggle() <#android.widget.CompoundButton>`__
   method.


Last updated 2024-04-15 UTC.



/Toggle buttons
===============

.. https://developer.android.google.cn/develop/ui/views/components/togglebutton?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `Switch → <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Switch(kotlin.Boolean,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Boolean,androidx.compose.material3.SwitchColors,androidx.compose.foundation.interaction.MutableInteractionSource)>`__

      |image-android-compose-ui-logo|

   If you're using a ``View``-based layout, there are three main choices for
   implementing toggles. We recommend using the
   `SwitchMaterial <https://m3.material.io/components/switch/overview>`__
   component from the `Material Components <https://m3.material.io/develop/android/mdc-android>`__ library:

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:padding="16dp">

          <com.google.android.material.switchmaterial.SwitchMaterial
              android:id="@+id/material_switch"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="@string/material_switch"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toTopOf="parent" />

      </androidx.constraintlayout.widget.ConstraintLayout>

   Legacy apps might still use the older
   `SwitchCompat <#androidx.appcompat.widget.SwitchCompat>`__
   AppCompat component, as shown in the following example:

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:padding="16dp">

          <androidx.appcompat.widget.SwitchCompat
              android:id="@+id/switchcompat"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="@string/switchcompat"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toTopOf="parent" />

      </androidx.constraintlayout.widget.ConstraintLayout>

   The following example shows
   `AppCompatToggleButton <#androidx.appcompat.widget.AppCompatToggleButton>`__,
   which is another legacy component that has a noticeably different UI:

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:padding="16dp">

          <TextView
              android:id="@+id/toggle_button_label"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintEnd_toStartOf="@id/toggle"
              app:layout_constraintHorizontal_chainStyle="packed"
              app:layout_constraintBaseline_toBaselineOf="@id/toggle"
              android:text="@string/toggle_button" />

          <androidx.appcompat.widget.AppCompatToggleButton
              android:id="@+id/toggle"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintStart_toEndOf="@id/toggle_button_label"
              app:layout_constraintTop_toTopOf="parent"
              app:layout_constraintBottom_toBottomOf="parent"/>

      </androidx.constraintlayout.widget.ConstraintLayout>

   These three components offer the same behavior but look different. The
   differences between the ``SwitchMaterial`` and ``SwitchCompat`` are subtle,
   but ``AppCompatToggleButton`` is noticeably different:

   |The SwitchMaterial, SwitchCompat, and AppCompatToggleButton Controls|
   **Figure 1.** Three toggle button types.

   .. rubric:: Handle state changes
      :name: state-changes

   ``SwitchMaterial``, ``SwitchCompat``, and ``AppCompatToggleButton`` are all
   subclasses of
   `CompoundButton <#android.widget.CompoundButton>`__, which
   gives them a common mechanism for handling checked state changes. You
   implement an instance of
   `CompoundButton.OnCheckedChangeListener <#android.widget.CompoundButton.OnCheckedChangeListener>`__
   and add it to the button, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       val binding: SwitchLayoutBinding = SwitchLayoutBinding.inflate(layoutInflater)
                       setContentView(binding.root)

                       binding.materialSwitch.setOnCheckedChangeListener { _, isChecked ->
                           if (isChecked) {
                               // The switch is checked.
                           } else {
                               // The switch isn't checked.
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       SwitchLayoutBinding binding = SwitchLayoutBinding.inflate(getLayoutInflater());
                       setContentView(binding.getRoot());

                       binding.materialSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
                           if (isChecked) {
                               // The switch is checked.
                           } else {
                               // The switch isn't checked.
                           }
                       });
                   }
               }

   ``CompoundButton.OnCheckedChangeListener`` is a single abstract method
   interface (or *SAM interface*), so you can implement it as a lambda. The
   lambda is called whenever the checked state changes, and the value of the
   ``isChecked`` boolean that is passed to the lambda indicates the new checked
   state.


Last updated 2024-04-15 UTC.

.. |The SwitchMaterial, SwitchCompat, and AppCompatToggleButton Controls| image:: https://developer.android.google.cn/static/images/ui/toggles.png
   :width: 264px


/Pickers
========

.. https://developer.android.google.cn/develop/ui/views/components/pickers?hl=en

.. container:: devsite-article-body

   Android provides controls for the user to pick a time or date as ready-to-use
   dialogs. These *pickers* provide controls for selecting each part of the time
   (hour, minute, AM/PM) or date (month, day, year).

   **Note:** For a better user experience, see the Material Design `date picker <https://m3.material.io/components/date-pickers/overview>`__ and `time picker <https://m3.material.io/components/time-pickers/overview>`__
   documentation.
   .. figure::
      https://lh3.googleusercontent.com/zc0VQbWKABZLd8xag4YoJd_oHUvxJoEz3s3UHlVPYU4oT_Tlrh9F5r-546Hf_AOfEEbA-iCxEJgAFBeuLvwGRs4F_guyW1JZob_WhMR5CMukcQ=s0
      name: time-picker
      :alt: An example of time picker from material.io
      :width: 50.0%

      **Figure 1.** Hour selection in a mobile calendar picker.

   Using these pickers helps ensure that your users can pick a time or date that
   is valid, formatted correctly, and adjusted to the user's locale.

   .. figure::
      https://lh3.googleusercontent.com/cEgaDjOwIz7l1a2E7vuBocyVDbpSsBtkVG5iQepRyiaoSzTZbL5JWbywwxKf1KLCPFFnfLbZ5Vnm3dT9HDczHCXyGOxqudikKXFe7miiuQg=s0
      name: date-picker
      :alt: An example of modal date picker from material.io
      :width: 50.0%

      **Figure 2.** Modal date picker.

   We recommend you use
   `DialogFragment <#androidx.fragment.app.DialogFragment>`__ to
   host each time or date picker. The ``DialogFragment`` manages the dialog
   lifecycle for you and lets you display pickers in different layout
   configurations, such as in a basic dialog on handsets or as an embedded part
   of the layout on large screens.

   .. rubric:: Create a time picker
      :name: TimePicker

   To display a
   `TimePickerDialog <#android.app.TimePickerDialog>`__ using
   ``DialogFragment``, define a fragment class that extends ``DialogFragment``
   and return a ``TimePickerDialog`` from the fragment's
   `onCreateDialog() <#androidx.fragment.app.DialogFragment>`__
   method.

   .. rubric:: Extend DialogFragment for a time picker
      :name: TimePickerFragment

   To define a ``DialogFragment`` for a ``TimePickerDialog``, do the following:

   -  Define the ``onCreateDialog()`` method to return an instance of
      ``TimePickerDialog``.
   -  Implement the
      `TimePickerDialog.OnTimeSetListener <#android.app.TimePickerDialog.OnTimeSetListener>`__
      interface to receive a callback when the user sets the time.

   Here's an example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TimePickerFragment : DialogFragment(), TimePickerDialog.OnTimeSetListener {

                   override fun onCreateDialog(savedInstanceState: Bundle): Dialog {
                       // Use the current time as the default values for the picker.
                       val c = Calendar.getInstance()
                       val hour = c.get(Calendar.HOUR_OF_DAY)
                       val minute = c.get(Calendar.MINUTE)

                       // Create a new instance of TimePickerDialog and return it.
                       return TimePickerDialog(activity, this, hour, minute, DateFormat.is24HourFormat(activity))
                   }

                   override fun onTimeSet(view: TimePicker, hourOfDay: Int, minute: Int) {
                       // Do something with the time the user picks.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public static class TimePickerFragment extends DialogFragment
                                           implements TimePickerDialog.OnTimeSetListener {

                   @Override
                   public Dialog onCreateDialog(Bundle savedInstanceState) {
                       // Use the current time as the default values for the picker.
                       final Calendar c = Calendar.getInstance();
                       int hour = c.get(Calendar.HOUR_OF_DAY);
                       int minute = c.get(Calendar.MINUTE);

                       // Create a new instance of TimePickerDialog and return it.
                       return new TimePickerDialog(getActivity(), this, hour, minute,
                               DateFormat.is24HourFormat(getActivity()));
                   }

                   public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
                       // Do something with the time the user picks.
                   }
               }

   See the ``TimePickerDialog`` class for information about the constructor
   arguments.

   Now you just need an event that adds an instance of this fragment to your
   activity.

   .. rubric:: Show the time picker
      :name: ShowingTheTimePicker

   After you define a ``DialogFragment`` like the one in the preceding example,
   you can display the time picker by creating an instance of the
   ``DialogFragment`` and calling the
   `show() <#androidx.fragment.app.DialogFragment>`__
   method.

   For example, here's a button that, when tapped, calls a method to show the
   dialog:

   .. code:: prettyprint

      <Button
          android:id="@+id/pickTime"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Pick time" />

   When the user taps this button, the system calls the following method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<Button>(R.id.pickTime).setOnClickListener {
                   TimePickerFragment().show(supportFragmentManager, "timePicker")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               findViewById<Button>(R.id.pickTime).setOnClickListener {
                   TimePickerFragment().show(supportFragmentManager, "timePicker");
               }

   This method calls ``show()`` on a new instance of the ``DialogFragment``
   defined in the preceding example. The ``show()`` method requires an instance
   of `FragmentManager <#androidx.fragment.app.FragmentManager>`__
   and a unique tag name for the fragment.

   .. rubric:: Create a date picker
      :name: DatePicker

   Creating a `DatePickerDialog <#android.app.DatePickerDialog>`__
   is like creating a ``TimePickerDialog``. The difference is the dialog you
   create for the fragment.

   To display a ``DatePickerDialog`` using ``DialogFragment``, define a fragment
   class that extends ``DialogFragment`` and return a ``DatePickerDialog`` from
   the fragment's ``onCreateDialog()`` method.

   .. rubric:: Extend DialogFragment for a date picker
      :name: DatePickerFragment

   To define a ``DialogFragment`` for a ``DatePickerDialog``, do the following:

   -  Define the ``onCreateDialog()`` method to return an instance of
      ``DatePickerDialog``.
   -  Implement the
      `DatePickerDialog.OnDateSetListener <#android.app.DatePickerDialog.OnDateSetListener>`__
      interface to receive a callback when the user sets the date.

   Here's an example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class DatePickerFragment : DialogFragment(), DatePickerDialog.OnDateSetListener {

                   override fun onCreateDialog(savedInstanceState: Bundle): Dialog {
                       // Use the current date as the default date in the picker.
                       val c = Calendar.getInstance()
                       val year = c.get(Calendar.YEAR)
                       val month = c.get(Calendar.MONTH)
                       val day = c.get(Calendar.DAY_OF_MONTH)

                       // Create a new instance of DatePickerDialog and return it.
                       return DatePickerDialog(requireContext(), this, year, month, day)

                   }

                   override fun onDateSet(view: DatePicker, year: Int, month: Int, day: Int) {
                       // Do something with the date the user picks.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public static class DatePickerFragment extends DialogFragment
                                           implements DatePickerDialog.OnDateSetListener {

                   @Override
                   public Dialog onCreateDialog(Bundle savedInstanceState) {
                       // Use the current date as the default date in the picker.
                       final Calendar c = Calendar.getInstance();
                       int year = c.get(Calendar.YEAR);
                       int month = c.get(Calendar.MONTH);
                       int day = c.get(Calendar.DAY_OF_MONTH);

                       // Create a new instance of DatePickerDialog and return it.
                       return new DatePickerDialog(requireContext(), this, year, month, day);
                   }

                   public void onDateSet(DatePicker view, int year, int month, int day) {
                       // Do something with the date the user picks.
                   }
               }

   See the `DatePickerDialog <#android.app.DatePickerDialog>`__
   class for information about the constructor arguments.

   You just need an event that adds an instance of this fragment to your
   activity.

   .. rubric:: Show the date picker
      :name: ShowingTheDatePicker

   After you define a ``DialogFragment`` like the preceding example, you can
   display the date picker by creating an instance of the ``DialogFragment`` and
   calling ``show()``.

   For example, here's a button that, when tapped, calls a method to show the
   dialog:

   .. code:: prettyprint

      <Button
          android:id="@+id/pickDate"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Pick date"/>

   When the user taps this button, the system calls the following method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<Button>(R.id.pickDate).setOnClickListener {
                   val newFragment = DatePickerFragment()
                   newFragment.show(supportFragmentManager, "datePicker")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               findViewById<Button>(R.id.pickDate).setOnClickListener {
                   val newFragment = DatePickerFragment();
                   newFragment.show(supportFragmentManager, "datePicker");
               }

   This method calls ``show()`` on a new instance of the ``DialogFragment``
   defined in the preceding example. The ``show()`` method requires an instance
   of ``FragmentManager`` and a unique tag name for the fragment.

   .. rubric:: Use pickers with autofill
      :name: PickerAutofill

   In 2017, Android introduced the `Autofill framework <#>`__, which lets users save data that
   can be used to fill out forms in different apps. Pickers can be useful in
   autofill scenarios by providing a UI that lets users change the value of a
   field that stores date or time data. For example, in a credit card form, a
   date picker lets users enter or change the expiration date of their credit
   card.

   Because pickers are dialogs, they aren't displayed in an activity along with
   other fields. To display the picker data when the picker isn't visible, you
   can use another view, such as an
   `EditText <#android.widget.EditText>`__, which can display the
   value when the picker isn't visible.

   An ``EditText`` object natively expects autofill data of type
   `AUTOFILL_TYPE_TEXT <#android.view.View>`__.
   In contrast, autofill services save the data as
   `AUTOFILL_TYPE_DATE <#android.view.View>`__
   to create an appropriate representation of it. To solve the inconsistency in
   types, we recommended that you create a custom view that inherits from
   ``EditText`` and implements the methods required to correctly handle values
   of type ``AUTOFILL_TYPE_DATE``.

   Take the following steps to create a subclass of ``EditText`` that can handle
   values of type ``AUTOFILL_TYPE_DATE``:

   #. Create a class that inherits from ``EditText``.
   #. Implement the
      `getAutofillType() <#android.view.View>`__
      method, which returns ``AUTOFILL_TYPE_DATE``.
   #. Implement the
      `getAutofillValue() <#android.view.View>`__
      method, which returns an
      `AutofillValue <#android.view.autofill.AutofillValue>`__
      object that represents the date in milliseconds. To create the return
      object, use the
      `forDate() <#android.view.autofill.AutofillValue>`__
      method to generate an ``AutofillValue`` object.
   #. Implement the
      `autofill() <#android.view.View>`__
      method. This method provides the logic to handle the ``AutofillValue``
      parameter, which is of type ``AUTOFILL_TYPE_DATE``. To handle the
      parameter, create a proper string representation of it, such as
      ``mm/yyyy``. Use the string representation to set the ``text`` property of
      your view.
   #. Implement functionality that displays a picker when the user wants to edit
      the date in the custom subclass of ``EditText``. The view updates the
      ``text`` property with a string representation of the value that the user
      selects on the picker.

   For an example of a subclass of ``EditText`` that handles
   ``AUTOFILL_TYPE_DATE`` values, see the Autofill Framework sample in
   `Java <https://github.com/android/input-samples/tree/main/AutofillFramework>`__
   or
   `Kotlin <https://github.com/android/input-samples/tree/main/AutofillFrameworkKotlin>`__.

   To learn more about proving autofill support for your custom views, see
   `Autofill framework <#support_for_custom_views>`__.


Last updated 2024-02-22 UTC.


/Tooltips
=========

.. https://developer.android.google.cn/develop/ui/views/components/tooltips?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `Popup → <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/window/package-summary#Popup(androidx.compose.ui.window.PopupPositionProvider,kotlin.Function0,androidx.compose.ui.window.PopupProperties,kotlin.Function0)>`__

      |image-android-compose-ui-logo|

   A tooltip is a small descriptive message that appears near a view when users
   long press the view or hover their mouse over it. This is useful when your
   app uses an icon to represent an action or piece of information to save space
   in the layout. This page shows you how to add these tooltips on Android 8.0
   (API level 26) and higher.

   Some scenarios, such as those in productivity apps, require a descriptive
   method of communicating ideas and actions. You can use tooltips to display a
   descriptive message, as shown in figure 1.

   |tooltip screenshot|

   **Figure 1.** Tooltip displayed in an Android app.

   Some standard widgets display tooltips based on the content of the ``title``
   or ``content description`` properties. Starting in Android 8.0, you can
   specify the text displayed in the tooltip regardless of the value of other
   properties.

   .. rubric:: Setting the tooltip text
      :name: setting_the_tooltip_text

   You can specify the tooltip text in a
   `View <#android.view.View>`__ by calling the
   `setTooltipText() <#android.view.View>`__
   method. You can set the ``tooltipText`` property using the corresponding XML
   attribute or API.

   To specify the tooltip text in your XML files, set the
   `android:tooltipText <#android.R.styleable>`__
   attribute, as shown in the following example:

   .. code:: prettyprint

      <android.support.design.widget.FloatingActionButton
              android:id="@+id/fab"
              android:tooltipText="Send an email" />

   To specify the tooltip text in your code, use the
   `setTooltipText(CharSequence) <#android.view.View>`__
   method, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fab: FloatingActionButton = findViewById(R.id.fab)
               fab.tooltipText = "Send an email"

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
               fab.setTooltipText("Send an email");

   The API also includes a
   `getTooltipText() <#android.view.View>`__
   method that you can use to retrieve the value of the ``tooltipText``
   property.

   Android displays the value of the ``tooltipText`` property when users hover
   their mouse over the view or long press the view.


Last updated 2024-04-15 UTC.

.. |tooltip screenshot| image:: https://developer.android.google.cn/static/guide/topics/ui/images/tooltip_framed.png


/Dialogs
========

.. https://developer.android.google.cn/develop/ui/views/components/dialogs?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `AlertDialog → <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#AlertDialog(kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.ui.window.DialogProperties)>`__

      |image-android-compose-ui-logo|

   A *dialog* is a small window that prompts the user to make a decision or
   enter additional information. A dialog doesn't fill the screen and is
   normally used for modal events that require users to take an action before
   they can proceed.

   **Note:** For information about how to design your dialogs, including
   recommendations for language, read the `Material Design Dialogs <https://m3.material.io/components/dialogs/guidelines>`__ guidelines.
   .. figure::
      https://lh3.googleusercontent.com/fIXXFT91EOxFZU9bo9eIPY1icVtiiPzmKMKEF2PJT7FAKucMUiG6L3z-ny-vLp8sYgHxwFbl6ZOGZYgRwaP72xVMefVoeWr6i_lOySPuBcZnkQ=s0
      name: dialog_1
      :alt: An image showing a basic dialog
      :width: 50.0%

      **Figure 1.** A basic dialog.

   The `Dialog <#android.app.Dialog>`__ class is the base class
   for dialogs, but don't instantiate ``Dialog`` directly. Instead, use one of
   the following subclasses:

   `AlertDialog <#android.app.AlertDialog>`__
      A dialog that can show a title, up to three buttons, a list of selectable
      items, or a custom layout.
   `DatePickerDialog <#android.app.DatePickerDialog>`__ or `TimePickerDialog <#android.app.TimePickerDialog>`__
      A dialog with a predefined UI that lets the user select a date or time.

   **Caution:** Android includes another dialog class called
   `ProgressDialog <#android.app.ProgressDialog>`__ that shows a
   dialog with a progress bar. This widget is deprecated, because it prevents
   users from interacting with the app while progress is being displayed. If you
   need to indicate loading or indeterminate progress, follow the design
   guidelines in `Progress & activity <https://material.io/archive/guidelines/components/progress-activity.html>`__
   and use a `ProgressBar <#android.widget.ProgressBar>`__ in your
   layout instead of using ``ProgressDialog``.
   These classes define the style and structure for your dialog. You also need a
   `DialogFragment <#androidx.fragment.app.DialogFragment>`__ as a
   container for your dialog. The ``DialogFragment`` class provides all the
   controls you need to create your dialog and manage its appearance, instead of
   calling methods on the ``Dialog`` object.

   Using ``DialogFragment`` to manage the dialog makes it correctly handle
   lifecycle events such as when the user taps the Back button or rotates the
   screen. The ``DialogFragment`` class also lets you reuse the dialog's UI as
   an embeddable component in a larger UI—just like a traditional
   `Fragment <#androidx.fragment.app.Fragment>`__—such as when you
   want the dialog UI to appear differently on large and small screens.

   The following sections in this document describe how to use a
   ``DialogFragment`` in combination with an ``AlertDialog`` object. If you want
   to create a date or time picker, read `Add pickers to your app <#>`__.

   .. rubric:: Create a dialog fragment
      :name: DialogFragment

   You can accomplish a wide variety of dialog designs—including custom layouts
   and those described in `Material Design Dialogs <https://m3.material.io/components/dialogs/guidelines>`__—by
   extending ``DialogFragment`` and creating an ``AlertDialog`` in the
   `onCreateDialog() <#androidx.fragment.app.DialogFragment>`__
   callback method.

   For example, here's a basic ``AlertDialog`` that's managed within a
   ``DialogFragment``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class StartGameDialogFragment : DialogFragment() {
                   override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
                       return activity?.let {
                           // Use the Builder class for convenient dialog construction.
                           val builder = AlertDialog.Builder(it)
                           builder.setMessage("Start game")
                               .setPositiveButton("Start") { dialog, id ->
                                   // START THE GAME!
                               }
                               .setNegativeButton("Cancel") { dialog, id ->
                                   // User cancelled the dialog.
                               }
                           // Create the AlertDialog object and return it.
                           builder.create()
                       } ?: throw IllegalStateException("Activity cannot be null")
                   }
               }

               class OldXmlActivity : AppCompatActivity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_old_xml)

                       StartGameDialogFragment().show(supportFragmentManager, "GAME_DIALOG")
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class StartGameDialogFragment extends DialogFragment {
                   @Override
                   public Dialog onCreateDialog(Bundle savedInstanceState) {
                       // Use the Builder class for convenient dialog construction.
                       AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
                       builder.setMessage(R.string.dialog_start_game)
                              .setPositiveButton(R.string.start, new DialogInterface.OnClickListener() {
                                  public void onClick(DialogInterface dialog, int id) {
                                      // START THE GAME!
                                  }
                              })
                              .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                                  public void onClick(DialogInterface dialog, int id) {
                                      // User cancels the dialog.
                                  }
                              });
                       // Create the AlertDialog object and return it.
                       return builder.create();
                   }
               }
               // ...

               StartGameDialogFragment().show(supportFragmentManager, "GAME_DIALOG");

   When you create an instance of this class and call
   `show() <#androidx.fragment.app.DialogFragment>`__
   on that object, the dialog appears as shown in the following figure.

   .. figure:: https://developer.android.google.cn/static/images/ui/dialog_buttons.png
      :alt: An image showing a basic dialog with two action buttons
      :width: 50.0%

      **Figure 2.** A dialog with a message and two action buttons.

   The next section provides more detail about using the
   `AlertDialog.Builder <#android.app.AlertDialog.Builder>`__ APIs
   to create the dialog.

   Depending on how complex your dialog is, you can implement a variety of other
   callback methods in the ``DialogFragment``, including all the basic `fragment lifecycle methods <#>`__.

   .. rubric:: Build an alert dialog
      :name: AlertDialog

   The ``AlertDialog`` class lets you build a variety of dialog designs and is
   often the only dialog class you need. As shown in the following figure, there
   are three regions of an alert dialog:

   -  **Title:** this is optional and only used when the content area is
      occupied by a detailed message, list, or custom layout. If you need to
      state a simple message or question, you don't need a title.
   -  **Content area:** this can display a message, list, or other custom
      layout.
   -  **Action buttons:** there can be up to three action buttons in a dialog.

   The ``AlertDialog.Builder`` class provides APIs that let you create an
   ``AlertDialog`` with these kinds of content, including a custom layout.

   To build an ``AlertDialog``, do the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val builder: AlertDialog.Builder = AlertDialog.Builder(context)
               builder
                   .setMessage("I am the message")
                   .setTitle("I am the title")

               val dialog: AlertDialog = builder.create()
               dialog.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // 1. Instantiate an AlertDialog.Builder with its constructor.
               AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

               // 2. Chain together various setter methods to set the dialog characteristics.
               builder.setMessage(R.string.dialog_message)
                      .setTitle(R.string.dialog_title);

               // 3. Get the AlertDialog.
               AlertDialog dialog = builder.create();

   The previous code snippet generates this dialog:

   .. figure:: https://developer.android.google.cn/static/images/ui/alert_dialog_1.png
      :alt: An image showing a dialog with title, content area and two action
      buttons.
      :width: 50.0%

      **Figure 3.** The layout of a basic alert dialog.

   .. rubric:: Add buttons
      :name: AddButtons

   To add action buttons like those in figure 2, call the
   `setPositiveButton() <#android.app.AlertDialog.Builder>`__
   and
   `setNegativeButton() <#android.app.AlertDialog.Builder>`__
   methods:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val builder: AlertDialog.Builder = AlertDialog.Builder(context)
               builder
                   .setMessage("I am the message")
                   .setTitle("I am the title")
                   .setPositiveButton("Positive") { dialog, which ->
                       // Do something.
                   }
                   .setNegativeButton("Negative") { dialog, which ->
                       // Do something else.
                   }

               val dialog: AlertDialog = builder.create()
               dialog.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
               // Add the buttons.
               builder.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
                          public void onClick(DialogInterface dialog, int id) {
                              // User taps OK button.
                          }
                      });
               builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                          public void onClick(DialogInterface dialog, int id) {
                              // User cancels the dialog.
                          }
                      });
               // Set other dialog properties.
               ...

               // Create the AlertDialog.
               AlertDialog dialog = builder.create();

   The ``set...Button()`` methods require a title for the button—supplied by a
   `string resource <#>`__—and a
   `DialogInterface.OnClickListener <#android.content.DialogInterface.OnClickListener>`__
   that defines the action to take when the user taps the button.

   There are three action buttons you can add:

   -  **Positive:** use this to accept and continue with the action (the "OK"
      action).
   -  **Negative:** use this to cancel the action.
   -  **Neutral:** use this when the user might not want to proceed with the
      action but doesn't necessarily want to cancel. It appears between the
      positive and negative buttons. For example, the action might be "Remind me
      later."

   You can add only one of each button type to an ``AlertDialog``. For example,
   you can't have more than one "positive" button.

   The previous code snippet gives you an alert dialog like the following:

   .. figure:: https://developer.android.google.cn/static/images/ui/alert_dialog_2.png
      :alt: An image showing an alert dialog with title, message, and two action
      buttons.
      :width: 50.0%

      **Figure 4.** An alert dialog with title, message, and two action buttons.

   .. rubric:: Add a list
      :name: AddAList

   There are three kinds of lists available with the ``AlertDialog`` APIs:

   -  A traditional single-choice list.
   -  A persistent single-choice list (radio buttons).
   -  A persistent multiple-choice list (checkboxes).

   To create a single-choice list like the one in figure 5, use the
   `setItems() <#android.app.AlertDialog.Builder>`__
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val builder: AlertDialog.Builder = AlertDialog.Builder(context)
               builder
                   .setTitle("I am the title")
                   .setPositiveButton("Positive") { dialog, which ->
                       // Do something.
                   }
                   .setNegativeButton("Negative") { dialog, which ->
                       // Do something else.
                   }
                   .setItems(arrayOf("Item One", "Item Two", "Item Three")) { dialog, which ->
                       // Do something on item tapped.
                   }

               val dialog: AlertDialog = builder.create()
               dialog.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public Dialog onCreateDialog(Bundle savedInstanceState) {
                   AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
                   builder.setTitle(R.string.pick_color)
                          .setItems(R.array.colors_array, new DialogInterface.OnClickListener() {
                              public void onClick(DialogInterface dialog, int which) {
                              // The 'which' argument contains the index position of the selected item.
                          }
                   });
                   return builder.create();
               }

   This code snippet generates a dialog like the following:

   .. figure:: https://developer.android.google.cn/static/images/ui/alert_dialog_3.png
      :alt: An image showing a dialog with a title and list.
      :width: 50.0%

      **Figure 5.** A dialog with a title and list.

   Because the list appears in the dialog's content area, the dialog can't show
   both a message and a list. Set a title for the dialog with
   `setTitle() <#android.app.AlertDialog.Builder>`__.
   To specify the items for the list, call ``setItems()``, passing an array.
   Alternatively, you can specify a list using
   `setAdapter() <#android.app.AlertDialog.Builder>`__.
   This lets you back the list with dynamic data—such as from a database—using a
   `ListAdapter <#android.widget.ListAdapter>`__.

   If you back your list with a ``ListAdapter``, always use a
   `Loader <#androidx.loader.content.Loader>`__ so that the
   content loads asynchronously. This is described further in `Build layouts with an adapter <#AdapterViews>`__ and
   `Loaders <#>`__.

   **Note:** By default, tapping a list item dismisses the dialog, unless you
   use one of the following persistent-choice lists.

   .. rubric:: Add a persistent multiple-choice or single-choice list
      :name: Checkboxes

   To add a list of multiple-choice items (checkboxes) or single-choice items
   (radio buttons), use the
   `setMultiChoiceItems() <#android.app.AlertDialog.Builder>`__
   or
   `setSingleChoiceItems() <#android.app.AlertDialog.Builder>`__
   methods, respectively.

   For example, here's how you can create a multiple-choice list like the one
   shown in figure 6 that saves the selected items in an
   `ArrayList <#>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val builder: AlertDialog.Builder = AlertDialog.Builder(context)
               builder
                   .setTitle("I am the title")
                   .setPositiveButton("Positive") { dialog, which ->
                       // Do something.
                   }
                   .setNegativeButton("Negative") { dialog, which ->
                       // Do something else.
                   }
                   .setMultiChoiceItems(
                       arrayOf("Item One", "Item Two", "Item Three"), null) { dialog, which, isChecked ->
                       // Do something.
                   }

               val dialog: AlertDialog = builder.create()
               dialog.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public Dialog onCreateDialog(Bundle savedInstanceState) {
                   selectedItems = new ArrayList();  // Where we track the selected items
                   AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
                   // Set the dialog title.
                   builder.setTitle(R.string.pick_toppings)
                   // Specify the list array, the items to be selected by default (null for
                   // none), and the listener through which to receive callbacks when items
                   // are selected.
                          .setMultiChoiceItems(R.array.toppings, null,
                                     new DialogInterface.OnMultiChoiceClickListener() {
                              @Override
                              public void onClick(DialogInterface dialog, int which,
                                      boolean isChecked) {
                                  if (isChecked) {
                                      // If the user checks the item, add it to the selected
                                      // items.
                                      selectedItems.add(which);
                                  } else if (selectedItems.contains(which)) {
                                      // If the item is already in the array, remove it.
                                      selectedItems.remove(which);
                                  }
                              }
                          })
                   // Set the action buttons
                          .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
                              @Override
                              public void onClick(DialogInterface dialog, int id) {
                                  // User taps OK, so save the selectedItems results
                                  // somewhere or return them to the component that opens the
                                  // dialog.
                                  ...
                              }
                          })
                          .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                              @Override
                              public void onClick(DialogInterface dialog, int id) {
                                  ...
                              }
                          });

                   return builder.create();
               }

   .. figure:: https://developer.android.google.cn/static/images/ui/alert_dialog_4.png
      :alt: An image showing a dialog containing a list of multiple-choice
      items.
      :width: 40.0%

      **Figure 6.** A list of multiple-choice items.

   A single-choice alert dialog can be obtained like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val builder: AlertDialog.Builder = AlertDialog.Builder(context)
               builder
                   .setTitle("I am the title")
                   .setPositiveButton("Positive") { dialog, which ->
                       // Do something.
                   }
                   .setNegativeButton("Negative") { dialog, which ->
                       // Do something else.
                   }
                   .setSingleChoiceItems(
                       arrayOf("Item One", "Item Two", "Item Three"), 0
                   ) { dialog, which ->
                       // Do something.
                   }

               val dialog: AlertDialog = builder.create()
               dialog.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                       String[] choices = {"Item One", "Item Two", "Item Three"};
                       
                       AlertDialog.Builder builder = AlertDialog.Builder(context);
                       builder
                               .setTitle("I am the title")
                               .setPositiveButton("Positive", (dialog, which) -> {

                               })
                               .setNegativeButton("Negative", (dialog, which) -> {

                               })
                               .setSingleChoiceItems(choices, 0, (dialog, which) -> {

                               });

                       AlertDialog dialog = builder.create();
                       dialog.show();

   This results in the following example:

   .. figure:: https://developer.android.google.cn/static/images/ui/alert_dialog_5.png
      :alt: An image showing a dialog containing a list of single-choice items.
      :width: 40.0%

      **Figure 7.** A list of single-choice items.

   .. rubric:: Create a custom layout
      :name: CustomLayout

   If you want a custom layout in a dialog, create a layout and add it to an
   ``AlertDialog`` by calling
   `setView() <#android.app.AlertDialog.Builder>`__
   on your ``AlertDialog.Builder`` object.

   .. figure:: https://developer.android.google.cn/static/images/ui/dialog_custom.png
      :alt: An image showing a custom dialog layout.
      :width: 50.0%

      **Figure 8.** A custom dialog layout.

   By default, the custom layout fills the dialog window, but you can still use
   ``AlertDialog.Builder`` methods to add buttons and a title.

   For example, here's the layout file for the preceding custom dialog layout:

   res/layout/dialog_signin.xml

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content">
          <ImageView
              android:src="@drawable/header_logo"
              android:layout_width="match_parent"
              android:layout_height="64dp"
              android:scaleType="center"
              android:background="#FFFFBB33"
              android:contentDescription="@string/app_name" />
          <EditText
              android:id="@+id/username"
              android:inputType="textEmailAddress"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_marginTop="16dp"
              android:layout_marginLeft="4dp"
              android:layout_marginRight="4dp"
              android:layout_marginBottom="4dp"
              android:hint="@string/username" />
          <EditText
              android:id="@+id/password"
              android:inputType="textPassword"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_marginTop="4dp"
              android:layout_marginLeft="4dp"
              android:layout_marginRight="4dp"
              android:layout_marginBottom="16dp"
              android:fontFamily="sans-serif"
              android:hint="@string/password"/>
      </LinearLayout>

   **Tip:** By default, when you set an
   `EditText <#android.widget.EditText>`__ element to use the
   ``"textPassword"`` input type, the font family is set to monospace. Change
   its font family to ``"sans-serif"`` so that both text fields use a matching
   font style.
   To inflate the layout in your ``DialogFragment``, get a
   `LayoutInflater <#android.view.LayoutInflater>`__ with
   `getLayoutInflater() <#android.app.Activity>`__
   and call
   `inflate() <#android.view.LayoutInflater>`__.
   The first parameter is the layout resource ID, and the second parameter is a
   parent view for the layout. You can then call
   `setView() <#android.app.AlertDialog>`__
   to place the layout in the dialog. This is shown in the following example.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
                   return activity?.let {
                       val builder = AlertDialog.Builder(it)
                       // Get the layout inflater.
                       val inflater = requireActivity().layoutInflater;

                       // Inflate and set the layout for the dialog.
                       // Pass null as the parent view because it's going in the dialog
                       // layout.
                       builder.setView(inflater.inflate(R.layout.dialog_signin, null))
                               // Add action buttons.
                               .setPositiveButton(R.string.signin,
                                       DialogInterface.OnClickListener { dialog, id ->
                                           // Sign in the user.
                                       })
                               .setNegativeButton(R.string.cancel,
                                       DialogInterface.OnClickListener { dialog, id ->
                                           getDialog().cancel()
                                       })
                       builder.create()
                   } ?: throw IllegalStateException("Activity cannot be null")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public Dialog onCreateDialog(Bundle savedInstanceState) {
                   AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
                   // Get the layout inflater.
                   LayoutInflater inflater = requireActivity().getLayoutInflater();

                   // Inflate and set the layout for the dialog.
                   // Pass null as the parent view because it's going in the dialog layout.
                   builder.setView(inflater.inflate(R.layout.dialog_signin, null))
                   // Add action buttons
                          .setPositiveButton(R.string.signin, new DialogInterface.OnClickListener() {
                              @Override
                              public void onClick(DialogInterface dialog, int id) {
                                  // Sign in the user.
                              }
                          })
                          .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                              public void onClick(DialogInterface dialog, int id) {
                                  LoginDialogFragment.this.getDialog().cancel();
                              }
                          });
                   return builder.create();
               }

   If you want a custom dialog, you can instead display an
   `Activity <#android.app.Activity>`__ as a dialog instead of
   using the ``Dialog`` APIs. Create an activity and set its theme to
   `Theme.Holo.Dialog <#android.R.style>`__ in
   the `<activity> <#>`__ manifest
   element:

   .. code:: prettyprint

      <activity android:theme="@android:style/Theme.Holo.Dialog" >

   The activity now displays in a dialog window instead of fullscreen.

   .. rubric:: Pass events back to the dialog's host
      :name: PassingEvents

   When the user taps one of the dialog's action buttons or selects an item from
   its list, your ``DialogFragment`` might perform the necessary action itself,
   but often you want to deliver the event to the activity or fragment that
   opens the dialog. To do this, define an interface with a method for each type
   of click event. Then, implement that interface in the host component that
   receives the action events from the dialog.

   For example, here's a ``DialogFragment`` that defines an interface through
   which it delivers the events back to the host activity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class NoticeDialogFragment : DialogFragment() {
                   // Use this instance of the interface to deliver action events.
                   internal lateinit var listener: NoticeDialogListener

                   // The activity that creates an instance of this dialog fragment must
                   // implement this interface to receive event callbacks. Each method passes
                   // the DialogFragment in case the host needs to query it.
                   interface NoticeDialogListener {
                       fun onDialogPositiveClick(dialog: DialogFragment)
                       fun onDialogNegativeClick(dialog: DialogFragment)
                   }

                   // Override the Fragment.onAttach() method to instantiate the
                   // NoticeDialogListener.
                   override fun onAttach(context: Context) {
                       super.onAttach(context)
                       // Verify that the host activity implements the callback interface.
                       try {
                           // Instantiate the NoticeDialogListener so you can send events to
                           // the host.
                           listener = context as NoticeDialogListener
                       } catch (e: ClassCastException) {
                           // The activity doesn't implement the interface. Throw exception.
                           throw ClassCastException((context.toString() +
                                   " must implement NoticeDialogListener"))
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class NoticeDialogFragment extends DialogFragment {

                   // The activity that creates an instance of this dialog fragment must
                   // implement this interface to receive event callbacks. Each method passes
                   // the DialogFragment in case the host needs to query it.
                   public interface NoticeDialogListener {
                       public void onDialogPositiveClick(DialogFragment dialog);
                       public void onDialogNegativeClick(DialogFragment dialog);
                   }

                   // Use this instance of the interface to deliver action events.
                   NoticeDialogListener listener;

                   // Override the Fragment.onAttach() method to instantiate the
                   // NoticeDialogListener.
                   @Override
                   public void onAttach(Context context) {
                       super.onAttach(context);
                       // Verify that the host activity implements the callback interface.
                       try {
                           // Instantiate the NoticeDialogListener so you can send events to
                           // the host.
                           listener = (NoticeDialogListener) context;
                       } catch (ClassCastException e) {
                           // The activity doesn't implement the interface. Throw exception.
                           throw new ClassCastException(activity.toString()
                                   + " must implement NoticeDialogListener");
                       }
                   }
                   ...
               }

   The activity hosting the dialog creates an instance of the dialog with the
   dialog fragment's constructor and receives the dialog's events through an
   implementation of the ``NoticeDialogListener`` interface:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : FragmentActivity(),
                       NoticeDialogFragment.NoticeDialogListener {

                   fun showNoticeDialog() {
                       // Create an instance of the dialog fragment and show it.
                       val dialog = NoticeDialogFragment()
                       dialog.show(supportFragmentManager, "NoticeDialogFragment")
                   }

                   // The dialog fragment receives a reference to this Activity through the
                   // Fragment.onAttach() callback, which it uses to call the following
                   // methods defined by the NoticeDialogFragment.NoticeDialogListener
                   // interface.
                   override fun onDialogPositiveClick(dialog: DialogFragment) {
                       // User taps the dialog's positive button.
                   }

                   override fun onDialogNegativeClick(dialog: DialogFragment) {
                       // User taps the dialog's negative button.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends FragmentActivity
                                         implements NoticeDialogFragment.NoticeDialogListener{
                   ...
                   public void showNoticeDialog() {
                       // Create an instance of the dialog fragment and show it.
                       DialogFragment dialog = new NoticeDialogFragment();
                       dialog.show(getSupportFragmentManager(), "NoticeDialogFragment");
                   }

                   // The dialog fragment receives a reference to this Activity through the
                   // Fragment.onAttach() callback, which it uses to call the following
                   // methods defined by the NoticeDialogFragment.NoticeDialogListener
                   // interface.
                   @Override
                   public void onDialogPositiveClick(DialogFragment dialog) {
                       // User taps the dialog's positive button.
                       ...
                   }

                   @Override
                   public void onDialogNegativeClick(DialogFragment dialog) {
                       // User taps the dialog's negative button.
                       ...
                   }
               }

   Because the host activity implements the ``NoticeDialogListener``—which is
   enforced by the
   `onAttach() <#androidx.fragment.app.Fragment>`__
   callback method shown in the preceding example—the dialog fragment can use
   the interface callback methods to deliver click events to the activity:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   override fun onCreateDialog(savedInstanceState: Bundle): Dialog {
                       return activity?.let {
                           // Build the dialog and set up the button click handlers.
                           val builder = AlertDialog.Builder(it)

                           builder.setMessage(R.string.dialog_start_game)
                                   .setPositiveButton(R.string.start,
                                           DialogInterface.OnClickListener { dialog, id ->
                                               // Send the positive button event back to the
                                               // host activity.
                                               listener.onDialogPositiveClick(this)
                                           })
                                   .setNegativeButton(R.string.cancel,
                                           DialogInterface.OnClickListener { dialog, id ->
                                               // Send the negative button event back to the
                                               // host activity.
                                               listener.onDialogNegativeClick(this)
                                           })

                           builder.create()
                       } ?: throw IllegalStateException("Activity cannot be null")
                   }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class NoticeDialogFragment extends DialogFragment {
                   ...
                   @Override
                   public Dialog onCreateDialog(Bundle savedInstanceState) {
                       // Build the dialog and set up the button click handlers.
                       AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
                       builder.setMessage(R.string.dialog_start_game)
                              .setPositiveButton(R.string.start, new DialogInterface.OnClickListener() {
                                  public void onClick(DialogInterface dialog, int id) {
                                      // Send the positive button event back to the host activity.
                                      listener.onDialogPositiveClick(NoticeDialogFragment.this);
                                  }
                              })
                              .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                                  public void onClick(DialogInterface dialog, int id) {
                                      // Send the negative button event back to the host activity.
                                      listener.onDialogNegativeClick(NoticeDialogFragment.this);
                                  }
                              });
                       return builder.create();
                   }
               }

   .. rubric:: Show a dialog
      :name: ShowADialog

   When you want to show your dialog, create an instance of your
   ``DialogFragment`` and call
   `show() <#androidx.fragment.app.DialogFragment>`__,
   passing the
   `FragmentManager <#androidx.fragment.app.FragmentManager>`__
   and a tag name for the dialog fragment.

   You can get the ``FragmentManager`` by calling
   `getSupportFragmentManager() <#androidx.fragment.app.FragmentActivity>`__
   from the
   `FragmentActivity <#androidx.fragment.app.FragmentActivity>`__
   or by calling
   `getParentFragmentManager() <#androidx.fragment.app.Fragment>`__
   from a ``Fragment``. See the following for an example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun confirmStartGame() {
                   val newFragment = StartGameDialogFragment()
                   newFragment.show(supportFragmentManager, "game")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void confirmStartGame() {
                   DialogFragment newFragment = new StartGameDialogFragment();
                   newFragment.show(getSupportFragmentManager(), "game");
               }

   The second argument, ``"game"``, is a unique tag name that the system uses to
   save and restore the fragment state when necessary. The tag also lets you get
   a handle to the fragment by calling
   `findFragmentByTag() <#androidx.fragment.app.FragmentManager>`__.

   .. rubric:: Show a dialog fullscreen or as an embedded fragment
      :name: FullscreenDialog

   You might want a piece of your UI design to appear as a dialog in some
   situations and as a fullscreen or embedded fragment in others. You might also
   want it to appear differently depending on the device's screen size. The
   ``DialogFragment`` class offers flexibility to accomplish this, because it
   can behave as an embeddable ``Fragment``.

   However, you can't use ``AlertDialog.Builder`` or other ``Dialog`` objects to
   build the dialog in this case. If you want the ``DialogFragment`` to be
   embeddable, define the dialog's UI in a layout, then load the layout in the
   `onCreateView() <#androidx.fragment.app.Fragment>`__
   callback.

   Here's an example ``DialogFragment`` that can appear as a dialog or an
   embeddable fragment, using a layout named ``purchase_items.xml``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CustomDialogFragment : DialogFragment() {

                   // The system calls this to get the DialogFragment's layout, regardless of
                   // whether it's being displayed as a dialog or an embedded fragment.
                   override fun onCreateView(
                           inflater: LayoutInflater,
                           container: ViewGroup?,
                           savedInstanceState: Bundle?
                   ): View {
                       // Inflate the layout to use as a dialog or embedded fragment.
                       return inflater.inflate(R.layout.purchase_items, container, false)
                   }

                   // The system calls this only when creating the layout in a dialog.
                   override fun onCreateDialog(savedInstanceState: Bundle): Dialog {
                       // The only reason you might override this method when using
                       // onCreateView() is to modify the dialog characteristics. For example,
                       // the dialog includes a title by default, but your custom layout might
                       // not need it. Here, you can remove the dialog title, but you must
                       // call the superclass to get the Dialog.
                       val dialog = super.onCreateDialog(savedInstanceState)
                       dialog.requestWindowFeature(Window.FEATURE_NO_TITLE)
                       return dialog
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CustomDialogFragment extends DialogFragment {
                   // The system calls this to get the DialogFragment's layout, regardless of
                   // whether it's being displayed as a dialog or an embedded fragment.
                   @Override
                   public View onCreateView(LayoutInflater inflater, ViewGroup container,
                           Bundle savedInstanceState) {
                       // Inflate the layout to use as a dialog or embedded fragment.
                       return inflater.inflate(R.layout.purchase_items, container, false);
                   }

                   // The system calls this only when creating the layout in a dialog.
                   @Override
                   public Dialog onCreateDialog(Bundle savedInstanceState) {
                       // The only reason you might override this method when using
                       // onCreateView() is to modify the dialog characteristics. For example,
                       // the dialog includes a title by default, but your custom layout might
                       // not need it. Here, you can remove the dialog title, but you must
                       // call the superclass to get the Dialog.
                       Dialog dialog = super.onCreateDialog(savedInstanceState);
                       dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
                       return dialog;
                   }
               }

   The following example determines whether to show the fragment as a dialog or
   a fullscreen UI, based on the screen size:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun showDialog() {
                   val fragmentManager = supportFragmentManager
                   val newFragment = CustomDialogFragment()
                   if (isLargeLayout) {
                       // The device is using a large layout, so show the fragment as a
                       // dialog.
                       newFragment.show(fragmentManager, "dialog")
                   } else {
                       // The device is smaller, so show the fragment fullscreen.
                       val transaction = fragmentManager.beginTransaction()
                       // For a polished look, specify a transition animation.
                       transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN)
                       // To make it fullscreen, use the 'content' root view as the container
                       // for the fragment, which is always the root view for the activity.
                       transaction
                               .add(android.R.id.content, newFragment)
                               .addToBackStack(null)
                               .commit()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void showDialog() {
                   FragmentManager fragmentManager = getSupportFragmentManager();
                   CustomDialogFragment newFragment = new CustomDialogFragment();

                   if (isLargeLayout) {
                       // The device is using a large layout, so show the fragment as a
                       // dialog.
                       newFragment.show(fragmentManager, "dialog");
                   } else {
                       // The device is smaller, so show the fragment fullscreen.
                       FragmentTransaction transaction = fragmentManager.beginTransaction();
                       // For a polished look, specify a transition animation.
                       transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
                       // To make it fullscreen, use the 'content' root view as the container
                       // for the fragment, which is always the root view for the activity.
                       transaction.add(android.R.id.content, newFragment)
                                  .addToBackStack(null).commit();
                   }
               }

   For more information about performing fragment transactions, see
   `Fragments <#>`__.

   In this example, the ``mIsLargeLayout`` boolean specifies whether the current
   device must use the app's large layout design and thus show this fragment as
   a dialog rather than fullscreen. The best way to set this kind of boolean is
   to declare a `bool resource value <#Bool>`__ with an `alternative resource <#AlternativeResources>`__
   value for different screen sizes. For example, here are two versions of the
   bool resource for different screen sizes:

   res/values/bools.xml

   .. code:: prettyprint

      <!-- Default boolean values -->
      <resources>
          <bool name="large_layout">false</bool>
      </resources>

   res/values-large/bools.xml

   .. code:: prettyprint

      <!-- Large screen boolean values -->
      <resources>
          <bool name="large_layout">true</bool>
      </resources>

   Then you can initialize the ``mIsLargeLayout`` value during the activity's
   `onCreate() <#android.app.Activity>`__
   method, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   setContentView(R.layout.activity_main)

                   isLargeLayout = resources.getBoolean(R.bool.large_layout)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               boolean isLargeLayout;

               @Override
               public void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   setContentView(R.layout.activity_main);

                   isLargeLayout = getResources().getBoolean(R.bool.large_layout);
               }

   .. rubric:: Show an activity as a dialog on large screens
      :name: ActivityAsDialog

   Instead of showing a dialog as a fullscreen UI on small screens, you can get
   the same result by showing an ``Activity`` as a dialog on large screens. The
   approach you choose depends on your app design, but showing an activity as a
   dialog is often useful when your app is designed for small screens and you
   want to improve the experience on tablets by showing a short-lived activity
   as a dialog.

   To show an activity as a dialog only on large screens, apply the
   `Theme.Holo.DialogWhenLarge <#android.R.style>`__
   theme to the ``<activity>`` manifest element:

   .. code:: prettyprint

      <activity android:theme="@android:style/Theme.Holo.DialogWhenLarge" >

   For more information about styling your activities with themes, see `Styles and themes <#>`__.

   .. rubric:: Dismiss a dialog
      :name: DismissADialog

   When the user taps an action button created with an ``AlertDialog.Builder``,
   the system dismisses the dialog for you.

   The system also dismisses the dialog when the user taps an item in a dialog
   list, except when the list uses radio buttons or checkboxes. Otherwise, you
   can manually dismiss your dialog by calling
   `dismiss() <#androidx.fragment.app.DialogFragment>`__
   on your ``DialogFragment``.

   If you need to perform certain actions when the dialog goes away, you can
   implement the
   `onDismiss() <#androidx.fragment.app.DialogFragment>`__
   method in your ``DialogFragment``.

   You can also *cancel* a dialog. This is a special event that indicates that
   the user is leaving the dialog without completing the task. This occurs if
   the user taps the Back button or taps the screen outside the dialog area or
   if you explicitly call
   `cancel() <#android.app.Dialog>`__ on the ``Dialog``,
   such as in response to a "Cancel" button in the dialog.

   As shown in the preceding example, you can respond to the cancel event by
   implementing
   `onCancel() <#androidx.fragment.app.DialogFragment>`__
   in your ``DialogFragment`` class.

   **Note:** The system calls ``onDismiss()`` on each event that invokes the
   ``onCancel()`` callback. However, if you call
   `Dialog.dismiss() <#android.app.Dialog>`__ or
   `DialogFragment.dismiss() <#androidx.fragment.app.DialogFragment>`__,
   the system calls
   `onDismiss() <#androidx.fragment.app.DialogFragment>`__
   but *not* ``onCancel()``. You generally call ``dismiss()`` when the user taps
   the *positive* button in your dialog to remove the dialog from view.


Last updated 2024-04-15 UTC.



/Menus
======

.. https://developer.android.google.cn/develop/ui/views/components/menus?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `TopAppBar → <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#TopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__

      |image-android-compose-ui-logo|

   Menus are a common user interface component in many types of apps. To provide
   a familiar and consistent user experience, use the
   `Menu <#android.view.Menu>`__ APIs to present user actions and
   other options in your activities.

   **Note:** For a better user experience, see `Material Design Menus <https://m3.material.io/components/menus/overview>`__.
   .. figure::
      https://lh3.googleusercontent.com/kyUjfdA4kbCLZTJCQY0gqPCCVdTr74WMzCScfyuZkFGx8GQXU6uVvcSExckK28csQqWAdLXvLiQpD1a_DpJlX2c15GD4bLYrNu4c_W7-AOE6og=s0
      name: overflow
      :alt: An image showing an example of overflow menu
      :width: 50.0%

      **Figure 1.** A menu triggered by an icon tap, appearing below the
      overflow menu icon.

   This document shows how to create the three fundamental types of menus or
   action presentations on all versions of Android:

   **Options menu and app bar**
      The options menu is the primary collection of menu items for an activity.
      It's where you place actions that have a global impact on the app, such as
      "Search," "Compose email," and "Settings."

      See the `Create an options menu <#options-menu>`__ section.

   **Context menu and contextual action mode**
      A context menu is a `floating menu <#FloatingContextMenu>`__ that appears
      when the user performs a touch & hold on an element. It provides actions
      that affect the selected content or context frame.

      The `contextual action mode <#CAB>`__ displays action items that affect
      the selected content in a bar at the top of the screen and lets the user
      select multiple items.

      See the `Create a contextual menu <#context-menu>`__ section.

   **Popup menu**
      A popup menu displays a vertical list of items that's anchored to the view
      that invokes the menu. It's good for providing an overflow of actions that
      relate to specific content or to provide options for the second part of a
      command. Actions in a popup menu don't directly affect the corresponding
      content—that's what contextual actions are for. Rather, the popup menu is
      for extended actions that relate to regions of content in your activity.

      See the `Create a popup menu <#PopupMenu>`__ section.

   .. rubric:: Define a menu in XML
      :name: xml

   For all menu types, Android provides a standard XML format to define menu
   items. Instead of building a menu in your activity's code, define a menu and
   all its items in an XML `menu resource <#>`__. You can then inflate the
   menu resource—loading it as a ``Menu`` object—in your activity or fragment.

   Using a menu resource is good practice for the following reasons:

   -  It's easier to visualize the menu structure in XML.
   -  It separates the content for the menu from your app's behavioral code.
   -  It lets you create alternative menu configurations for different platform
      versions, screen sizes, and other configurations by leveraging the `app resources <#>`__ framework.

   To define a menu, create an XML file inside your project's ``res/menu/``
   directory and build the menu with the following elements:

   ``<menu>``
      Defines a ``Menu``, which is a container for menu items. A ``<menu>``
      element must be the root node for the file, and it can hold one or more
      ``<item>`` and ``<group>`` elements.
   ``<item>``
      Creates a `MenuItem <#android.view.MenuItem>`__, which
      represents a single item in a menu. This element can contain a nested
      ``<menu>`` element to create a submenu.
   ``<group>``
      An optional, invisible container for ``<item>`` elements. It lets you
      categorize menu items so they share properties, such as active state and
      visibility. For more information, see the `Create a menu group <#groups>`__ section.

   Here's an example menu named ``game_menu.xml``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <menu xmlns:android="http://schemas.android.com/apk/res/android">
          <item android:id="@+id/new_game"
                android:icon="@drawable/ic_new_game"
                android:title="@string/new_game"
                app:showAsAction="ifRoom"/>
          <item android:id="@+id/help"
                android:icon="@drawable/ic_help"
                android:title="@string/help" />
      </menu>

   The ``<item>`` element supports several attributes you can use to define an
   item's appearance and behavior. The items in the preceding menu include the
   following attributes:

   ``android:id``
      A resource ID that's unique to the item, which lets the app recognize the
      item when the user selects it.
   ``android:icon``
      A reference to a drawable to use as the item's icon.
   ``android:title``
      A reference to a string to use as the item's title.
   ``android:showAsAction``
      The specification for when and how this item appears as an action item in
      the app bar.

   These are the most important attributes you use, but there are many more
   available. For information about all the supported attributes, see the `Menu resource <#>`__ documentation.

   You can add a submenu to an item in any menu by adding a ``<menu>`` element
   as the child of an ``<item>``. Submenus are useful when your app has a lot of
   functions that can be organized into topics, like items in a PC app's menu
   bar—such as **File**, **Edit**, and **View**. See the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <menu xmlns:android="http://schemas.android.com/apk/res/android">
          <item android:id="@+id/file"
                android:title="@string/file" >
              <!-- "file" submenu -->
              <menu>
                  <item android:id="@+id/create_new"
                        android:title="@string/create_new" />
                  <item android:id="@+id/open"
                        android:title="@string/open" />
              </menu>
          </item>
      </menu>

   To use the menu in your activity, \_inflate\_ the menu resource, converting
   the XML resource into a programmable object using
   `MenuInflater.inflate() <#android.view.MenuInflater>`__.
   The following sections show how to inflate a menu for each menu type.

   .. rubric:: Create an options menu
      :name: options-menu

   The options menu, like the one shown in figure 1, is where you include
   actions and other options that are relevant to the current activity context,
   such as "Search," "Compose email," and "Settings."

   .. figure:: https://developer.android.google.cn/static/images/training/appbar/appbar_sheets_2x.png
      name: appbar
      :alt: An image showing the app bar for the Google Sheets app
      :width: 50.0%

      **Figure 2.** The Google Sheets app, showing several buttons, including
      the action overflow button.

   You can declare items for the options menu from your
   `Activity <#android.app.Activity>`__ subclass or a
   `Fragment <#android.app.Fragment>`__ subclass. If both your
   activity and your fragments declare items for the options menu, the items are
   combined in the UI. The activity's items appear first, followed by those of
   each fragment, in the order in which the fragments are added to the activity.
   If necessary, you can reorder the menu items with the
   ``android:orderInCategory`` attribute in each ``<item>`` you need to move.

   To specify the options menu for an activity, override
   `onCreateOptionsMenu() <#android.app.Activity>`__.
   Fragments provide their own
   `onCreateOptionsMenu() <#android.app.Fragment>`__
   callback. In this method, you can inflate your menu resource, `defined in XML <#xml>`__, into the ``Menu`` provided in the callback. This is shown in
   the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateOptionsMenu(menu: Menu): Boolean {
                   val inflater: MenuInflater = menuInflater
                   inflater.inflate(R.menu.game_menu, menu)
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onCreateOptionsMenu(Menu menu) {
                   MenuInflater inflater = getMenuInflater();
                   inflater.inflate(R.menu.game_menu, menu);
                   return true;
               }

   You can also add menu items using
   `add() <#android.view.Menu>`__
   and retrieve items with
   `findItem() <#android.view.Menu>`__ to revise
   their properties with ``MenuItem`` APIs.

   .. rubric:: Handle click events
      :name: RespondingOptionsMenu

   When the user selects an item from the options menu, including action items
   in the app bar, the system calls your activity's
   `onOptionsItemSelected() <#android.app.Activity>`__
   method. This method passes the ``MenuItem`` selected. You can identify the
   item by calling
   `getItemId() <#android.view.MenuItem>`__, which
   returns the unique ID for the menu item, defined by the ``android:id``
   attribute in the menu resource or with an integer given to the ``add()``
   method. You can match this ID against known menu items to perform the
   appropriate action.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onOptionsItemSelected(item: MenuItem): Boolean {
                   // Handle item selection.
                   return when (item.itemId) {
                       R.id.new_game -> {
                           newGame()
                           true
                       }
                       R.id.help -> {
                           showHelp()
                           true
                       }
                       else -> super.onOptionsItemSelected(item)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onOptionsItemSelected(MenuItem item) {
                   // Handle item selection.
                   switch (item.getItemId()) {
                       case R.id.new_game:
                           newGame();
                           return true;
                       case R.id.help:
                           showHelp();
                           return true;
                       default:
                           return super.onOptionsItemSelected(item);
                   }
               }

   When you successfully handle a menu item, return ``true``. If you don't
   handle the menu item, call the superclass implementation of
   ``onOptionsItemSelected()``. The default implementation returns false.

   If your activity includes fragments, the system first calls
   ``onOptionsItemSelected()`` for the activity, then for each fragment in the
   order the fragments are added, until one returns ``true`` or all fragments
   are called.

   **Tip:** If your app contains multiple activities and some of them provide
   the same options menu, consider creating an activity that implements only the
   ``onCreateOptionsMenu()`` and ``onOptionsItemSelected()`` methods. Then
   extend this class for each activity that shares the same options menu. This
   way, you can manage one set of code for handling menu actions, and each
   descendant class inherits the menu behaviors. If you want to add menu items
   to one of the descendant activities, override ``>onCreateOptionsMenu()`` in
   that activity. Call ``super.onCreateOptionsMenu(menu)`` so the original menu
   items are created, then add new menu items with ``menu.add()``. You can also
   override the superclass's behavior for individual menu items.

   .. rubric:: Change menu items at runtime
      :name: ChangingTheMenu

   After the system calls ``onCreateOptionsMenu()``, it retains an instance of
   the ``Menu`` you populate and doesn't call ``onCreateOptionsMenu()`` again
   unless the menu is invalidated. However, use ``onCreateOptionsMenu()`` only
   to create the initial menu state and not to make changes during the activity
   lifecycle.

   If you want to modify the options menu based on events that occur during the
   activity lifecycle, you can do so in the
   `onPrepareOptionsMenu() <#android.app.Activity>`__
   method. This method passes you the ``Menu`` object as it currently exists so
   you can modify it, such as by adding, removing, or disabling items. Fragments
   also provide an
   `onPrepareOptionsMenu() <#android.app.Fragment>`__
   callback.

   The options menu is considered always open when menu items are presented in
   the app bar. When an event occurs and you want to perform a menu update, call
   `invalidateOptionsMenu() <#android.app.Activity>`__
   to request that the system call ``onPrepareOptionsMenu()``.

   **Note:** Never change items in the options menu based on the
   `View <#android.view.View>`__ in focus. When in touch mode—when
   the user isn't using a trackball or D-pad—views can't take focus, so never
   use focus as the basis for modifying items in the options menu. If you want
   to provide menu items that are context-sensitive to a ``View``, use a
   contextual menu as described in the following section.

   .. rubric:: Create a contextual menu
      :name: context-menu

   .. figure::
      https://lh3.googleusercontent.com/9vaFdlcuUvC9JNnGZEHmXlM4DOu6DJkvoTYaihQIrCDC37YIr9JaS7vqjKanP8UsoEoGqVrZ29bCOFLmvA9-UksQe9FU3RCbjhqUTVFkAn3w=s0
      name: contextual
      :alt: An image showing a floating context menu
      :width: 70.0%

      **Figure 3.** A floating context menu.

   A contextual menu offers actions that affect a specific item or context frame
   in the UI. You can provide a context menu for any view, but they are most
   often used for items in a
   `RecylerView <#>`__ or other view
   collections in which the user can perform direct actions on each item.

   There are two ways to provide contextual actions:

   -  In a `floating context menu <#FloatingContextMenu>`__. A menu appears as a
      floating list of menu items, similar to a dialog, when the user performs a
      touch & hold on a view that declares support for a context menu. Users can
      perform a contextual action on one item at a time.
   -  In the `contextual action mode <#CAB>`__. This mode is a system
      implementation of `ActionMode <#android.view.ActionMode>`__
      that displays a *contextual action bar*, or CAB, at the top of the screen
      with action items that affect the selected item(s). When this mode is
      active, users can perform an action on multiple items at once, if your app
      supports that.

   .. rubric:: Create a floating context menu
      :name: FloatingContextMenu

   To provide a floating context menu, do the following:

   #. Register the ``View`` the context menu is associated with by calling
      `registerForContextMenu() <#android.app.Activity>`__
      and passing it the ``View``.

      If your activity uses a ``RecyclerView`` and you want each item to provide
      the same context menu, register all items for a context menu by passing
      the ``RecyclerView`` to ``registerForContextMenu()``.

   #. Implement the
      `onCreateContextMenu() <#android.view.View.OnCreateContextMenuListener>`__
      method in your ``Activity`` or ``Fragment``.

      When the registered view receives a touch & hold event, the system calls
      your ``onCreateContextMenu()`` method. This is where you define the menu
      items, usually by inflating a menu resource, as in the following example:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                      override fun onCreateContextMenu(menu: ContextMenu, v: View,
                                              menuInfo: ContextMenu.ContextMenuInfo) {
                          super.onCreateContextMenu(menu, v, menuInfo)
                          val inflater: MenuInflater = menuInflater
                          inflater.inflate(R.menu.context_menu, menu)
                      }
                      

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                      @Override
                      public void onCreateContextMenu(ContextMenu menu, View v,
                                                      ContextMenuInfo menuInfo) {
                          super.onCreateContextMenu(menu, v, menuInfo);
                          MenuInflater inflater = getMenuInflater();
                          inflater.inflate(R.menu.context_menu, menu);
                      }
                      

      `MenuInflater <#android.view.MenuInflater>`__ lets you
      inflate the context menu from a menu resource. The callback method
      parameters include the ``View`` that the user selects and a
      `ContextMenu.ContextMenuInfo <#android.view.ContextMenu.ContextMenuInfo>`__
      object that provides additional information about the item selected. If
      your activity has several views that each provide a different context
      menu, you might use these parameters to determine which context menu to
      inflate.

   #. Implement
      `onContextItemSelected() <#android.app.Activity>`__,
      as shown in the following example. When the user selects a menu item, the
      system calls this method so you can perform the appropriate action.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                      override fun onContextItemSelected(item: MenuItem): Boolean {
                          val info = item.menuInfo as AdapterView.AdapterContextMenuInfo
                          return when (item.itemId) {
                              R.id.edit -> {
                                  editNote(info.id)
                                  true
                              }
                              R.id.delete -> {
                                  deleteNote(info.id)
                                  true
                              }
                              else -> super.onContextItemSelected(item)
                          }
                      }
                      

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                      @Override
                      public boolean onContextItemSelected(MenuItem item) {
                          AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
                          switch (item.getItemId()) {
                              case R.id.edit:
                                  editNote(info.id);
                                  return true;
                              case R.id.delete:
                                  deleteNote(info.id);
                                  return true;
                              default:
                                  return super.onContextItemSelected(item);
                          }
                      }
                      

      The `getItemId() <#android.view.MenuItem>`__
      method queries the ID for the selected menu item, which you assign to each
      menu item in XML using the ``android:id`` attribute, as shown in `Define a menu in XML <#xml>`__.

      When you successfully handle a menu item, return ``true``. If you don't
      handle the menu item, pass the menu item to the superclass implementation.
      If your activity includes fragments, the activity receives this callback
      first. By calling the superclass when unhandled, the system passes the
      event to the respective callback method in each fragment, one at a time,
      in the order each fragment is added, until ``true`` or ``false`` is
      returned. The default implementations for ``Activity`` and
      ``android.app.Fragment`` return ``false``, so always call the superclass
      when unhandled.

   .. rubric:: Use the contextual action mode
      :name: CAB

   The contextual action mode is a system implementation of ``ActionMode`` that
   focuses user interaction toward performing contextual actions. When a user
   enables this mode by selecting an item, a *contextual action bar* appears at
   the top of the screen to present actions the user can perform on the selected
   items. While this mode is enabled, the user can select multiple items, if
   your app supports that, and can deselect items and continue to navigate
   within the activity. The action mode is disabled and the contextual action
   bar disappears when the user deselects all items, taps the Back button, or
   taps the **Done** action on the left side of the bar.

   **Note:** The contextual action bar isn't necessarily associated with the app
   bar. They operate independently, although the contextual action bar visually
   overtakes the app bar position.
   For views that provide contextual actions, you usually invoke the contextual
   action mode when one or both of these two events occurs:

   -  The user performs a touch & hold on the view.
   -  The user selects a checkbox or similar UI component within the view.

   How your app invokes the contextual action mode and defines the behavior for
   each action depends on your design. There are two designs:

   -  For contextual actions on individual, arbitrary views.
   -  For batch contextual actions on groups of items in a ``RecyclerView``,
      letting the user select multiple items and perform an action on them all.

   The following sections describe the setup required for each scenario.

   .. rubric:: Enable the contextual action mode for individual views
      :name: CABforViews

   If you want to invoke the contextual action mode only when the user selects
   specific views, do the following:

   #. Implement the ``ActionMode.Callback`` interface as shown in the following
      example. In its callback methods, you can specify the actions for the
      contextual action bar, respond to click events on action items, and handle
      other lifecycle events for the action mode.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                      private val actionModeCallback = object : ActionMode.Callback {
                          // Called when the action mode is created. startActionMode() is called.
                          override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
                              // Inflate a menu resource providing context menu items.
                              val inflater: MenuInflater = mode.menuInflater
                              inflater.inflate(R.menu.context_menu, menu)
                              return true
                          }

                          // Called each time the action mode is shown. Always called after
                          // onCreateActionMode, and might be called multiple times if the mode
                          // is invalidated.
                          override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
                              return false // Return false if nothing is done
                          }

                          // Called when the user selects a contextual menu item.
                          override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
                              return when (item.itemId) {
                                  R.id.menu_share -> {
                                      shareCurrentItem()
                                      mode.finish() // Action picked, so close the CAB.
                                      true
                                  }
                                  else -> false
                              }
                          }

                          // Called when the user exits the action mode.
                          override fun onDestroyActionMode(mode: ActionMode) {
                              actionMode = null
                          }
                      }
                      

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                      private ActionMode.Callback actionModeCallback = new ActionMode.Callback() {

                          // Called when the action mode is created. startActionMode() is called.
                          @Override
                          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                              // Inflate a menu resource providing context menu items.
                              MenuInflater inflater = mode.getMenuInflater();
                              inflater.inflate(R.menu.context_menu, menu);
                              return true;
                          }

                          // Called each time the action mode is shown. Always called after
                          // onCreateActionMode, and might be called multiple times if the mode
                          // is invalidated.
                          @Override
                          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                              return false; // Return false if nothing is done.
                          }

                          // Called when the user selects a contextual menu item.
                          @Override
                          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
                             switch (item.getItemId()) {
                                  case R.id.menu_share:
                                      shareCurrentItem();
                                      mode.finish(); // Action picked, so close the CAB.
                                      return true;
                                  default:
                                      return false;
                              }
                          }

                          // Called when the user exits the action mode.
                          @Override
                          public void onDestroyActionMode(ActionMode mode) {
                              actionMode = null;
                          }
                      };
                      

      These event callbacks are almost exactly the same as the callbacks for the
      `options menu <#options-menu>`__, except that each of these also passes
      the ``ActionMode`` object associated with the event. You can use
      ``ActionMode`` APIs to make various changes to the CAB, such as revising
      the title and subtitle with
      `setTitle() <#android.view.ActionMode>`__ and
      `setSubtitle() <#android.view.ActionMode>`__,
      which is useful to indicate how many items are selected.

      The preceding sample sets the ``actionMode`` variable to ``null`` when the
      action mode is destroyed. In the next step, see how it's initialized and
      how saving the member variable in your activity or fragment can be useful.

   #. Call
      `startActionMode() <#android.app.Activity>`__
      when you want to show the bar, such as when the user performs a touch &
      hold on the view.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                      someView.setOnLongClickListener { view ->
                          // Called when the user performs a touch & hold on someView.
                          when (actionMode) {
                              null -> {
                                  // Start the CAB using the ActionMode.Callback defined earlier.
                                  actionMode = activity?.startActionMode(actionModeCallback)
                                  view.isSelected = true
                                  true
                              }
                              else -> false
                          }
                      }
                      

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                      someView.setOnLongClickListener(new View.OnLongClickListener() {
                          // Called when the user performs a touch & hold on someView.
                          public boolean onLongClick(View view) {
                              if (actionMode != null) {
                                  return false;
                              }

                              // Start the CAB using the ActionMode.Callback defined earlier.
                              actionMode = getActivity().startActionMode(actionModeCallback);
                              view.setSelected(true);
                              return true;
                          }
                      });
                      

      When you call ``startActionMode()``, the system returns the ``ActionMode``
      created. By saving this in a member variable, you can make changes to the
      contextual action bar in response to other events. In the preceding
      sample, the ``ActionMode`` is used to ensure that the ``ActionMode``
      instance isn't recreated if it's already active, by checking whether the
      member is null before starting the action mode.

   .. rubric:: Create a popup menu
      :name: PopupMenu

   .. figure:: https://developer.android.google.cn/static/images/ui/popupmenu.png
      name: gmail
      :alt: An image showing a popup menu in the Gmail app, anchored to the
      overflow button at the top-right.
      :width: 30.0%

      **Figure 4.** A popup menu in the Gmail app, anchored to the overflow
      button in the top-right corner.

   A `PopupMenu <#android.widget.PopupMenu>`__ is a modal menu
   anchored to a ``View``. It appears below the anchor view if there is room, or
   above the view otherwise. It's useful for the following:

   -  Providing an overflow-style menu for actions that *relate to* specific
      content, such as Gmail's email headers, shown in figure 4.
      **Note:** This isn't the same as a context menu, which is generally for
      actions that *affect* selected content. For actions that affect selected
      content, use the `contextual action mode <#CAB>`__ or `floating context menu <#FloatingContextMenu>`__.
   -  Providing a second part of a command sentence, such as a button marked
      **Add** that produces a popup menu with different **Add** options.
   -  Providing a menu similar to a
      `Spinner <#android.widget.Spinner>`__ that doesn't retain a
      persistent selection.

   If you `define your menu in XML <#xml>`__, here's how you can show the popup
   menu:

   #. Instantiate a ``PopupMenu`` with its constructor, which takes the current
      app `Context <#android.content.Context>`__ and the ``View``
      to which the menu is anchored.
   #. Use ``MenuInflater`` to inflate your menu resource into the ``Menu``
      object returned by
      `PopupMenu.getMenu() <#android.widget.PopupMenu>`__.
   #. Call
      `PopupMenu.show() <#android.widget.PopupMenu>`__.

   For example, here's a button that shows a popup menu:

   .. code:: prettyprint

      <ImageButton
          android:id="@+id/dropdown_menu"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:contentDescription="@string/descr_overflow_button"
          android:src="@drawable/arrow_drop_down" />

   The activity can then show the popup menu like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<ImageButton>(R.id.dropdown_menu).setOnClickListener {
                   val popup = PopupMenu(this, it)
                   val inflater: MenuInflater = popup.menuInflater
                   inflater.inflate(R.menu.actions, popup.menu)
                   popup.show()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               findViewById(R.id.dropdown_menu).setOnClickListener(v -> {
                   PopupMenu popup = new PopupMenu(this, v);
                   popup.getMenuInflater().inflate(R.menu.actions, popup.getMenu());
                   popup.show();
               });

   The menu is dismissed when the user selects an item or taps outside the menu
   area. You can listen for the dismiss event using
   `PopupMenu.OnDismissListener <#android.widget.PopupMenu.OnDismissListener>`__.

   .. rubric:: Handle click events
      :name: PopupEvents

   To perform an action when the user selects a menu item, implement the
   `PopupMenu.OnMenuItemClickListener <#android.widget.PopupMenu.OnMenuItemClickListener>`__
   interface and register it with your ``PopupMenu`` by calling
   `setOnMenuItemclickListener() <#android.widget.PopupMenu>`__.
   When the user selects an item, the system calls the
   `onMenuItemClick() <#android.widget.PopupMenu.OnMenuItemClickListener>`__
   callback in your interface.

   This is shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun showMenu(v: View) {
                   PopupMenu(this, v).apply {
                       // MainActivity implements OnMenuItemClickListener.
                       setOnMenuItemClickListener(this@MainActivity)
                       inflate(R.menu.actions)
                       show()
                   }
               }

               override fun onMenuItemClick(item: MenuItem): Boolean {
                   return when (item.itemId) {
                       R.id.archive -> {
                           archive(item)
                           true
                       }
                       R.id.delete -> {
                           delete(item)
                           true
                       }
                       else -> false
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void showMenu(View v) {
                   PopupMenu popup = new PopupMenu(this, v);

                   // This activity implements OnMenuItemClickListener.
                   popup.setOnMenuItemClickListener(this);
                   popup.inflate(R.menu.actions);
                   popup.show();
               }

               @Override
               public boolean onMenuItemClick(MenuItem item) {
                   switch (item.getItemId()) {
                       case R.id.archive:
                           archive(item);
                           return true;
                       case R.id.delete:
                           delete(item);
                           return true;
                       default:
                           return false;
                   }
               }

   .. rubric:: Create a menu group
      :name: groups

   A menu group is a collection of menu items that share certain traits. With a
   group, you can do the following:

   -  Show or hide all items using
      `setGroupVisible() <#android.view.Menu>`__.
   -  Enable or disable all items using
      `setGroupEnabled() <#android.view.Menu>`__.
   -  Specify whether all items are checkable using
      `setGroupCheckable() <#android.view.Menu>`__.

   You can create a group by nesting ``<item>`` elements inside a ``<group>``
   element in your menu resource or by specifying a group ID with the
   `add() <#android.view.Menu>`__
   method.

   Here's an example of a menu resource that includes a group:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <menu xmlns:android="http://schemas.android.com/apk/res/android">
          <item android:id="@+id/menu_save"
                android:icon="@drawable/menu_save"
                android:title="@string/menu_save" />
          <!-- menu group -->
          <group android:id="@+id/group_delete">
              <item android:id="@+id/menu_archive"
                    android:title="@string/menu_archive" />
              <item android:id="@+id/menu_delete"
                    android:title="@string/menu_delete" />
          </group>
      </menu>

   The items that are in the group appear at the same level as the first
   item—all three items in the menu are siblings. However, you can modify the
   traits of the two items in the group by referencing the group ID and using
   the preceding methods. The system also never separates grouped items. For
   example, if you declare ``android:showAsAction="ifRoom"`` for each item, they
   both appear in the action bar or both appear in the action overflow.

   .. rubric:: Use checkable menu items
      :name: checkable

   .. container::

      **Figure 5.** A submenu with checkable items.

   A menu can be useful as an interface for turning options on and off, using a
   checkbox for standalone options, or radio buttons for groups of mutually
   exclusive options. Figure 5 shows a submenu with items that are checkable
   with radio buttons.

   **Note:** Menu items in an options menu can't display a checkbox or radio
   button. If you make items in an options menu checkable, manually indicate the
   checked state by swapping the icon or text, or both, each time the state
   changes.
   You can define the checkable behavior for individual menu items using the
   ``android:checkable`` attribute in the ``<item>`` element, or for an entire
   group with the ``android:checkableBehavior`` attribute in the ``<group>``
   element. For example, all items in this menu group are checkable with a radio
   button:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <menu xmlns:android="http://schemas.android.com/apk/res/android">
          <group android:checkableBehavior="single">
              <item android:id="@+id/red"
                    android:title="@string/red" />
              <item android:id="@+id/blue"
                    android:title="@string/blue" />
          </group>
      </menu>

   The ``android:checkableBehavior`` attribute accepts one of the following:

   ``single``
      Only one item from the group can be checked, resulting in radio buttons.
   ``all``
      All items can be checked, resulting in checkboxes.
   ``none``
      No items are checkable.

   You can apply a default checked state to an item using the
   ``android:checked`` attribute in the ``<item>`` element and change it in code
   with the
   `setChecked() <#android.view.MenuItem>`__
   method.

   When a checkable item is selected, the system calls your respective
   item-selected callback method, such as ``onOptionsItemSelected()``. This is
   where you set the state of the checkbox, because a checkbox or radio button
   doesn't change its state automatically. You can query the current state of
   the item—as it was before the user selected it—with
   `isChecked() <#android.view.MenuItem>`__ and then
   set the checked state with ``setChecked()``. This is shown in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onOptionsItemSelected(item: MenuItem): Boolean {
                   return when (item.itemId) {
                       R.id.vibrate, R.id.dont_vibrate -> {
                           item.isChecked = !item.isChecked
                           true
                       }
                       else -> super.onOptionsItemSelected(item)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onOptionsItemSelected(MenuItem item) {
                   switch (item.getItemId()) {
                       case R.id.vibrate:
                       case R.id.dont_vibrate:
                           if (item.isChecked()) item.setChecked(false);
                           else item.setChecked(true);
                           return true;
                       default:
                           return super.onOptionsItemSelected(item);
                   }
               }

   If you don't set the checked state this way, then the visible state of the
   checkbox or radio button doesn't change when the user selects it. When you do
   set the state, the activity preserves the checked state of the item so that
   when the user opens the menu later, the checked state that you set is
   visible.

   **Note:** Checkable menu items are intended to be used only on a per-session
   basis and not saved after the app is destroyed. If you have app settings that
   you want to save for the user, store the data using `shared storage <#>`__.

   .. rubric:: Add menu items based on an intent
      :name: intents

   Sometimes you want a menu item to launch an activity using an
   `Intent <#android.content.Intent>`__, whether it's an activity
   in your app or another app. When you know the intent you want to use and have
   a specific menu item that initiates the intent, you can execute the intent
   with
   `startActivity() <#android.app.Activity>`__
   during the appropriate on-item-selected callback method, such as the
   ``onOptionsItemSelected()`` callback.

   However, if you aren't certain that the user's device contains an app that
   handles the intent, then adding a menu item that invokes it can result in a
   non-functioning menu item, because the intent might not resolve to an
   activity. To solve this, Android lets you dynamically add menu items to your
   menu when Android finds activities on the device that handle your intent.

   To add menu items based on available activities that accept an intent, do the
   following:

   #. Define an intent with the category
      `CATEGORY_ALTERNATIVE <#android.content.Intent>`__
      or
      `CATEGORY_SELECTED_ALTERNATIVE <#android.content.Intent>`__,
      or both, plus any other requirements.
   #. Call
      `Menu.addIntentOptions() <#android.view.Menu>`__.
      Android then searches for any apps that can perform the intent and adds
      them to your menu.

   If there are no apps installed that satisfy the intent, then no menu items
   are added.

   **Note:** ``CATEGORY_SELECTED_ALTERNATIVE`` is used to handle the selected
   element on the screen. Only use it when creating a menu in
   `onCreateContextMenu() <#android.app.Activity>`__.
   This is shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateOptionsMenu(menu: Menu): Boolean {
                   super.onCreateOptionsMenu(menu)

                   // Create an Intent that describes the requirements to fulfill, to be
                   // included in the menu. The offering app must include a category value
                   // of Intent.CATEGORY_ALTERNATIVE.
                   val intent = Intent(null, dataUri).apply {
                       addCategory(Intent.CATEGORY_ALTERNATIVE)
                   }

                   // Search and populate the menu with acceptable offering apps.
                   menu.addIntentOptions(
                           R.id.intent_group,  // Menu group to which new items are added.
                           0,                  // Unique item ID (none).
                           0,                  // Order for the items (none).
                           this.componentName, // The current activity name.
                           null,               // Specific items to place first (none).
                           intent,             // Intent created above that describes the requirements.
                           0,                  // Additional flags to control items (none).
                           null)               // Array of MenuItems that correlate to specific items (none).

                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onCreateOptionsMenu(Menu menu){
                   super.onCreateOptionsMenu(menu);

                   // Create an Intent that describes the requirements to fulfill, to be
                   // included in the menu. The offering app must include a category value
                   // of Intent.CATEGORY_ALTERNATIVE.
                   Intent intent = new Intent(null, dataUri);
                   intent.addCategory(Intent.CATEGORY_ALTERNATIVE);

                   // Search and populate the menu with acceptable offering apps.
                   menu.addIntentOptions(
                        R.id.intent_group,         // Menu group to which new items are added.
                        0,                         // Unique item ID (none).
                        0,                         // Order for the items (none).
                        this.getComponentName(),   // The current activity name.
                        null,                      // Specific items to place first (none).
                        intent,                    // Intent created above that describes the requirements.
                        0,                         // Additional flags to control items (none).
                        null);                     // Array of MenuItems that correlate to specific items (none).

                   return true;
               }

   For each activity found that provides an intent filter matching the intent
   defined, a menu item is added, using the value in the intent filter's
   ``android:label`` as the menu item title and the app icon as the menu item
   icon. The ``addIntentOptions()`` method returns the number of menu items
   added.

   **Note:** When you call ``addIntentOptions()``, it overrides all menu items
   by the menu group specified in the first argument.

   .. rubric:: Let your activity be added to other menus
      :name: AllowingToAdd

   You can offer the services of your activity to other apps so your app can be
   included in the menu of others—reversing the roles described earlier.

   To be included in other app menus, define an intent filter as usual, but
   include the ``CATEGORY_ALTERNATIVE`` or ``CATEGORY_SELECTED_ALTERNATIVE``
   values, or both, for the intent filter category. This is shown in the
   following example:

   .. code:: prettyprint

      <intent-filter label="@string/resize_image">
          ...
          <category android:name="android.intent.category.ALTERNATIVE" />
          <category android:name="android.intent.category.SELECTED_ALTERNATIVE" />
          ...
      </intent-filter>

   Read more about writing intent filters in `Intents and intent filters <#>`__.


Last updated 2024-04-15 UTC.



/About app bars
===============

.. https://developer.android.google.cn/develop/ui/views/components/appbar?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `App Bar → <https://developer.android.google.cn/jetpack/compose/layouts/material#app-bars>`__

      |image-android-compose-ui-logo|

   The *app bar*, also known as the *action bar*, is one of the most important
   design elements in your app's activities, because it provides a visual
   structure and interactive elements that are familiar to users. Using the app
   bar makes your app consistent with other Android apps, letting users quickly
   understand how to operate your app and have a great experience.

   **Note:** With the release of Android 9.0 (API level 28), there is a version
   of the Support Library called `AndroidX <#>`__ that is part
   of `Jetpack <#>`__. The AndroidX library contains the existing Support
   Library and includes Jetpack components.
   You can continue to use the Support Library. Historical artifacts—those
   versioned 27 and earlier, and packaged as ``android.support.*``—remain
   available on Google Maven. However, all newer library development occurs in
   the AndroidX library.
   We recommend using the AndroidX libraries in all new projects. Consider
   `migrating <#>`__ existing projects to AndroidX as
   well.
   The key functions of the app bar are as follows:

   -  Dedicated space for giving your app an identity and indicating the user's
      location in the app.
   -  Predictable access to important actions, such as search.
   -  Support for navigation and view switching, using tabs or menus.

   .. figure:: https://developer.android.google.cn/static/images/training/appbar/appbar_sheets_2x.png
      name: appbar
      :alt: An image showing a green app bar, with hamburger menu, and three
      action icons
      :width: 70.0%

      **Figure 1.** The app bar from the Google Sheets app.

   This documentation section describes how to use the AndroidX
   `Toolbar <#androidx.appcompat.widget.Toolbar>`__ widget as an
   app bar. There are other ways to implement an app bar—for example, some
   themes set up an `ActionBar <#android.app.ActionBar>`__ as an
   app bar by default—but using the AppCompat ``Toolbar`` makes it easier to set
   up an app bar that works on the widest range of devices. It also gives you
   room to customize your app bar later in your app's development.

   .. rubric:: Topics
      :name: topics

   `Set up the app bar <#>`__
      Learn how to add a ``Toolbar`` widget to your activity and set it as the
      activity's app bar.
   `Add and handle actions <#>`__
      Learn how to add actions to the app bar and its overflow menu, and how to
      respond when users choose those actions.
   `Add an Up action <#>`__
      Learn how to add an *Up* button to your app bar so users can navigate back
      to the app's home screen.
   `Use action views and action providers <#>`__
      Learn how to use these widgets to provide advanced functionality in your
      app bar.


Last updated 2024-04-15 UTC.



/Set up the app bar
===================

.. https://developer.android.google.cn/develop/ui/views/components/appbar/setting-up?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add components in Compose.

      `App Bar → <https://developer.android.google.cn/jetpack/compose/layouts/material#app-bars>`__

      |image-android-compose-ui-logo|

   In its most basic form, the action bar displays the title for the activity on
   one side and an overflow menu on the other. Even in this basic form, the app
   bar provides useful information to users and gives Android apps a consistent
   look and feel.

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/actions_actionbar.png
      name: actionbar
      :alt: An image showing the app bar in the Now in Android app
      :width: 50.0%

      **Figure 1.** An app bar with an action icon in the "Now in Android" app.

   All activities that use the default theme have an
   `ActionBar <#android.app.ActionBar>`__ as an app bar. App bar
   features are added to the native ``ActionBar`` over various Android releases.
   As a result, the native ``ActionBar`` behaves differently depending on what
   version of Android a device is using.

   On the other hand, features are added to the AndroidX AppCompat library's
   version of `Toolbar <#androidx.appcompat.widget.Toolbar>`__,
   which means those features are available on devices that use the AndroidX
   libraries.

   Use the AndroidX library's ``Toolbar`` class to implement your activities'
   app bars for this reason. Using the AndroidX library's toolbar makes your
   app's behavior consistent across the widest range of devices.

   .. rubric:: Add a Toolbar to an Activity
      :name: add-toolbar

   These steps describe how to set up a ``Toolbar`` as your activity's app bar:

   #. Add the AndroidX library to your project, as described in `AndroidX overview <#>`__.

   #. Make sure the activity extends
      `AppCompatActivity <#androidx.appcompat.app.AppCompatActivity>`__:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  class MyActivity : AppCompatActivity() {
                    // ...
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public class MyActivity extends AppCompatActivity {
                    // ...
                  }

      **Note:** Make this change for every activity in your app that uses a
      ``Toolbar`` as an app bar.

   #. In the app manifest, set the
      `<application> <#>`__ element
      to use one of AppCompat's
      `NoActionBar <#android.R.style>`__
      themes, as shown in the following example. Using one of these themes
      prevents the app from using the native ``ActionBar`` class to provide the
      app bar.

      .. code:: prettyprint

         <application
             android:theme="@style/Theme.AppCompat.Light.NoActionBar"
             />

   #. Add a ``Toolbar`` to the activity's layout. For example, the following
      layout code adds a ``Toolbar`` and gives it the appearance of floating
      above the activity:

      .. code:: prettyprint

         <androidx.appcompat.widget.Toolbar
            android:id="@+id/my_toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            android:elevation="4dp"
            android:theme="@style/ThemeOverlay.AppCompat.ActionBar"
            app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>

      See the `Material Design specification <https://material.io/design/components/app-bars-bottom.html>`__
      for recommendations regarding app bar elevation.

      Position the toolbar at the top of the activity's
      `layout <#>`__, since you are using it as
      an app bar.

   #. In the activity's
      `onCreate() <#android.app.Activity>`__
      method, call the activity's
      `setSupportActionBar() <#androidx.appcompat.app.AppCompatActivity>`__
      method and pass the activity's toolbar, as shown in the following example.
      This method sets the toolbar as the app bar for the activity.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  override fun onCreate(savedInstanceState: Bundle?) {
                      super.onCreate(savedInstanceState)
                      setContentView(R.layout.activity_my)
                      // The Toolbar defined in the layout has the id "my_toolbar".
                      setSupportActionBar(findViewById(R.id.my_toolbar))
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  @Override
                  protected void onCreate(Bundle savedInstanceState) {
                      super.onCreate(savedInstanceState);
                      setContentView(R.layout.activity_my);
                      Toolbar myToolbar = (Toolbar) findViewById(R.id.my_toolbar);
                      setSupportActionBar(myToolbar);
                  }

   Your app now has a basic action bar. By default, the action bar contains the
   name of the app and an overflow menu, which initially contains the
   **Settings** item. You can add more actions to the action bar and the
   overflow menu, as described in `Add and handle actions <#>`__.

   .. rubric:: Use app bar utility methods
      :name: utility

   Once you set the toolbar as an activity's app bar, you have access to the
   utility methods provided by the AndroidX library's
   `ActionBar <#androidx.appcompat.app.ActionBar>`__ class. This
   approach lets you do useful things, like hide and show the app bar.

   To use the ``ActionBar`` utility methods, call the activity's
   `getSupportActionBar() <#androidx.appcompat.app.AppCompatActivity>`__
   method. This method returns a reference to an AppCompat ``ActionBar`` object.
   Once you have that reference, you can call any of the ``ActionBar`` methods
   to adjust the app bar. For example, to hide the app bar, call
   `ActionBar.hide() <#androidx.appcompat.app.ActionBar>`__.


Last updated 2024-04-29 UTC.



/Add and handle actions
=======================

.. https://developer.android.google.cn/develop/ui/views/components/appbar/actions?hl=en

.. container:: devsite-article-body

   The app bar lets you add buttons for user actions. This feature lets you put
   the most important *actions* for the current context at the top of the app.
   For example, a photo browsing app might show *share* and *create album*
   buttons at the top when the user is looking at their photo roll. When the
   user looks at an individual photo, the app might show *crop* and *filter*
   buttons.

   Space in the app bar is limited. If an app declares more actions than can fit
   in the app bar, the app bar sends the excess actions to an *overflow* menu.
   The app can also specify that an action always shows in the overflow menu,
   instead of displaying on the app bar.

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/actions_actionbar.png
      name: actionbar
      :alt: An image showing Now in Android app with a action bar icon
      :width: 50.0%

      **Figure 1.** An action icon in the "Now in Android" app.

   .. rubric:: Add action buttons
      :name: add-actions

   All action buttons and other items available in the action overflow are
   defined in an XML `menu resource <#>`__.
   To add actions to the action bar, create a new XML file in your project's
   ``res/menu/`` directory.

   Add an `<item> <#item-element>`__
   element for each item you want to include in the action bar, as shown in the
   following sample menu XML file:

   .. code:: prettyprint

      <menu xmlns:android="http://schemas.android.com/apk/res/android" 
      xmlns:app="http://schemas.android.com/apk/res-auto">

          <!-- "Mark Favorite", must appear as action button if possible. -->
          <item
              android:id="@+id/action_favorite"
              android:icon="@drawable/ic_favorite_black_48dp"
              android:title="@string/action_favorite"
              app:showAsAction="ifRoom"/>

          <!-- Settings, must always be in the overflow. -->
          <item android:id="@+id/action_settings"
                android:title="@string/action_settings"
                app:showAsAction="never"/>

      </menu>

   The ``app:showAsAction`` attribute specifies whether the action is shown as a
   button on the app bar. If you set ``app:showAsAction="ifRoom"``—as in the
   example code's *favorite* action—the action displays as a button if there is
   room in the app bar for it. If there isn't enough room, excess actions are
   sent to the overflow menu. If you set ``app:showAsAction="never"``—as in the
   example code's *settings* action—the action is always listed in the overflow
   menu and not displayed in the app bar.

   The system uses the action's icon as the action button if the action displays
   in the app bar. You can find many useful icons in `Material Icons <https://www.google.com/design/icons/>`__.

   .. rubric:: Respond to actions
      :name: handle-actions

   When the user selects one of the app bar items, the system calls your
   activity's
   `onOptionsItemSelected() <#android.app.Activity>`__
   callback method and passes a
   `MenuItem <#android.view.MenuItem>`__ object to indicate which
   item was tapped. In your implementation of ``onOptionsItemSelected()``, call
   the
   `MenuItem.getItemId() <#android.view.MenuItem>`__
   method to determine which item was tapped. The ID returned matches the value
   you declare in the corresponding ``<item>`` element's ``android:id``
   attribute.

   For example, the following code snippet checks which action the user selects.
   If the method doesn't recognize the user's action, it invokes the superclass
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {
                   R.id.action_settings -> {
                       // User chooses the "Settings" item. Show the app settings UI.
                       true
                   }

                   R.id.action_favorite -> {
                       // User chooses the "Favorite" action. Mark the current item as a
                       // favorite.
                       true
                   }

                   else -> {
                       // The user's action isn't recognized.
                       // Invoke the superclass to handle it.
                       super.onOptionsItemSelected(item)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onOptionsItemSelected(MenuItem item) {
                   switch (item.getItemId()) {
                       case R.id.action_settings:
                           // User chooses the "Settings" item. Show the app settings UI.
                           return true;

                       case R.id.action_favorite:
                           // User chooses the "Favorite" action. Mark the current item as a
                           // favorite.
                           return true;

                       default:
                           // The user's action isn't recognized.
                           // Invoke the superclass to handle it.
                           return super.onOptionsItemSelected(item);

                   }
               }


Last updated 2024-04-29 UTC.


/Add an up action
=================

.. https://developer.android.google.cn/develop/ui/views/components/appbar/up-action?hl=en

.. container:: devsite-article-body

   Users need an easy way to get back to your app's main screen. To do this,
   provide an *Up* button |image-up-button| on the app bar for all activities except the
   main one. When the user selects the Up button, the app navigates to the
   parent activity.

   This page shows you how to add an Up button to an app bar using the Jetpack
   Navigation component. For a more detailed explanation, see `Update UI components with NavigationUI <#>`__.

   **Note:** We recommend using the Jetpack Navigation component to handle your
   app navigation. This component handles navigating up from the current screen
   in your app when the user taps the Up button. To learn more, see the
   documentation for the `Jetpack Navigation component <#>`__.

   .. rubric:: Configure your app bar
      :name: configure-app-bar

   Configure your app bar using an
   `AppBarConfiguration <#androidx.navigation.ui.AppBarConfiguration>`__.
   From the ``AppBarConfiguration``, you can inform the app bar of your
   top-level destinations. If the navigation drawer is configured, the drawer
   menu icon |image-drawer-icon| displays on the app bar on top-level destinations. If the
   navigation drawer isn't configured, the navigation button is hidden on
   top-level destinations.

   In both cases, the Up button displays on all other destinations. Pressing the
   Up button calls
   `navigateUp() <#androidx.navigation.NavController>`__.

   The following example shows how to configure an app bar using
   ``AppBarConfiguration``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                 override fun onCreate(savedInstanceState: Bundle?) {
                   ...
                   val navController = findNavController(R.id.nav_host_fragment_activity_main)
                   
                   val appBarConfiguration = AppBarConfiguration(
                       setOf(
                           R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications
                       )
                   )
                   binding.myToolbar.setupWithNavController(navController, appBarConfiguration)
                 }
                 

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                 @Override
                 protected void onCreate(Bundle savedInstanceState) {
                     ...
                     NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment_activity_main);

                     AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(
                             R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications)
                             .build();
                     NavigationUI.setupWithNavController(binding.myToolbar, navController, appBarConfiguration);
                 }
                 


Last updated 2024-04-29 UTC.

.. |image-up-button| image:: https://developer.android.google.cn/static/images/guide/navigation/up-button.png
   :class: inline-icon
.. |image-drawer-icon| image:: https://developer.android.google.cn/static/images/guide/navigation/drawer-icon.png
   :class: inline-icon


/Use action views and action providers
======================================

.. https://developer.android.google.cn/develop/ui/views/components/appbar/action-views?hl=en

.. container:: devsite-article-body

   **Note:** For a better approach and user experience, consider gradually
   migrating your projects to `Jetpack Compose <#>`__.
   The `AndroidX <#>`__ library's
   `Toolbar <#androidx.appcompat.widget.Toolbar>`__ provides
   different ways for users to interact with your app. `Add and handle actions <#>`__ describes how to
   define an *action*, which can be a button or a menu item. This document
   describes how to add two versatile components:

   -  An *action view* is an action that provides rich functionality within the
      app bar. For example, a search action view lets the user type their search
      text in the app bar without having to change activities or fragments.
   -  An *action provider* is an action with its own customized layout. The
      action initially appears as a button or menu item; when the user taps the
      action, the action provider controls the action's behavior any way you
      define. For example, the action provider might respond to a tap by
      displaying a menu.

   AndroidX provides several specialized action view and action provider
   widgets. For example, the
   `SearchView <#androidx.appcompat.widget.SearchView>`__ widget
   implements an action view for entering search queries. The
   `ShareActionProvider <#androidx.appcompat.widget.ShareActionProvider>`__
   widget implements an action provider for sharing information with other apps.
   You can also define your own action views and action providers.

   .. rubric:: Add an action view
      :name: action-view

   To add an action view, create an
   `<item> <#item-element>`__ element
   in the toolbar's menu resource, as described in `Add and handle actions <#>`__. Add one of the
   following attributes to the ``<item>`` element:

   -  ``actionViewClass``: the class of a widget that implements the action
   -  ``actionLayout``: a layout resource describing the action's components

   Set the ``showAsAction`` attribute to ``"ifRoom|collapseActionView"`` or
   ``"never|collapseActionView"``. The ``collapseActionView`` flag indicates how
   to display the widget when the user isn't interacting with it. If the widget
   is on the app bar, the app displays the widget as an icon. If the widget is
   in the overflow menu, the app displays the widget as a menu item. When the
   user interacts with the action view, it expands to fill the app bar.

   For example, the following code adds a ``SearchView`` widget to the app bar:

   .. code:: prettyprint

      <item android:id="@+id/action_search"
           android:title="@string/action_search"
           android:icon="@drawable/ic_search"
           app:showAsAction="ifRoom|collapseActionView"
           app:actionViewClass="androidx.appcompat.widget.SearchView" />

   If the user isn't interacting with the widget, the app displays the widget as
   the icon specified by ``android:icon``. If there isn't room in the app bar,
   the app adds the action to the overflow menu.

   .. figure::
      https://lh3.googleusercontent.com/zTb1ACT-j6EAGJqu2OEqbkLnLMrdSyHRlRaUYJMwB-vBKc1E6_Bz_bS2rC76Ivyavm7Bs5638cIG0m-aMBux0yovjt2eDxLabF6xm8DxvVU8=s0
      :alt: An image showing a search bar with a leading and trailing icons.
      :width: 70.0%

      **Figure 1.** Search bar with leading and trailing icons.

   When the user taps the icon or menu item, the widget expands to fill the
   toolbar, letting the user interact with it.

   .. figure::
      https://lh3.googleusercontent.com/YnYHSwRbp4CE19IxdkgtvlB7oc4R1Tl5T-QY_-9VddsyLIUa6Xd9KY5AMwBclWYY354_v5XEDOjDOsHYe7uAsoF43MAb9Bp-dzlof7ZNecux=s0
      :alt: An image showing a search view open once the search bar is focused.
      :width: 70.0%

      **Figure 2.** Search view opens once the search bar is focused.

   If you need to configure the action, do so in your activity's
   `onCreateOptionsMenu() <#android.app.Activity>`__
   callback. You can get the action view's object reference by calling the
   `getActionView() <#android.view.MenuItem>`__
   method. For example, the following code gets the object reference for the
   ``SearchView`` widget defined in the previous code example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateOptionsMenu(menu: Menu?): Boolean {
                   menuInflater.inflate(R.menu.main_activity_actions, menu)

                   val searchItem = menu?.findItem(R.id.action_search)
                   val searchView = searchItem?.actionView as SearchView

                   // Configure the search info and add any event listeners.

                   return super.onCreateOptionsMenu(menu)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onCreateOptionsMenu(Menu menu) {
                   getMenuInflater().inflate(R.menu.main_activity_actions, menu);

                   MenuItem searchItem = menu.findItem(R.id.action_search);
                   SearchView searchView =
                           (SearchView) searchItem.getActionView();

                   // Configure the search info and add any event listeners.

                   return super.onCreateOptionsMenu(menu);
               }

   **Note:** To improve the look and feel for your ``SearchView``, see the
   `Search component <https://m3.material.io/components/search/overview>`__ in
   Material Design 3.

   .. rubric:: Respond to action view expansion
      :name: view-expansion

   If the action's ``<item>`` element has a ``collapseActionView`` flag, the app
   displays the action view as an icon until the user interacts with the action
   view. When the user taps the icon, the built-in handler for
   `onOptionsItemSelected() <#android.app.Activity>`__
   expands the action view. If your activity subclass overrides the
   ``onOptionsItemSelected()`` method, your override method must call
   ``super.onOptionsItemSelected()`` so the superclass can expand the action
   view.

   If you want to do something when the action is expanded or collapsed, you can
   define a class that implements
   `MenuItem.OnActionExpandListener <#android.view.MenuItem.OnActionExpandListener>`__,
   and pass a member of that class to
   `setOnActionExpandListener() <#android.view.MenuItem>`__.
   For example, you might want to update the activity based on whether an action
   view is expanded or collapsed. The following code snippet shows how to define
   and pass a listener:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateOptionsMenu(menu: Menu?): Boolean {
                   menuInflater.inflate(R.menu.options, menu)

                   // Define the listener.
                   val expandListener = object : MenuItem.OnActionExpandListener {
                       override fun onMenuItemActionCollapse(item: MenuItem): Boolean {
                           // Do something when the action item collapses.
                           return true // Return true to collapse the action view.
                       }

                       override fun onMenuItemActionExpand(item: MenuItem): Boolean {
                           // Do something when it expands.
                           return true // Return true to expand the action view.
                       }
                   }

                   // Get the MenuItem for the action item.
                   val actionMenuItem = menu?.findItem(R.id.myActionItem)

                   // Assign the listener to that action item.
                   actionMenuItem?.setOnActionExpandListener(expandListener)

                   // For anything else you have to do when creating the options menu,
                   // do the following:

                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onCreateOptionsMenu(Menu menu) {
                   getMenuInflater().inflate(R.menu.options, menu);

                   // Define the listener.
                   OnActionExpandListener expandListener = new OnActionExpandListener() {
                       @Override
                       public boolean onMenuItemActionCollapse(MenuItem item) {
                           // Do something when the action item collapses.
                           return true;  // Return true to collapse action view.
                       }

                       @Override
                       public boolean onMenuItemActionExpand(MenuItem item) {
                           // Do something when it expands.
                           return true;  // Return true to expand the action view.
                       }
                   };

                   // Get the MenuItem for the action item.
                   MenuItem actionMenuItem = menu.findItem(R.id.myActionItem);

                   // Assign the listener to that action item.
                   MenuItemCompat.setOnActionExpandListener(actionMenuItem, expandListener);

                   // For anything else you have to do when creating the options menu,
                   // do the following:

                   return true;
               }

   .. rubric:: Add an action provider
      :name: action-provider

   To declare an action provider, create an ``<item>`` element in the toolbar's
   menu resource, as described in `Add and handle actions <#>`__. Add an
   ``actionProviderClass`` attribute, and set it to the fully qualified class
   name for the action provider class.

   For example, the following code declares a ``ShareActionProvider``, which is
   a widget defined in the AndroidX library that lets your app share data with
   other apps:

   .. code:: prettyprint

      <item android:id="@+id/action_share"
          android:title="@string/share"
          app:showAsAction="ifRoom"
          app:actionProviderClass="androidx.appcompat.widget.ShareActionProvider"/>

   In this case, it's unnecessary to declare an icon for the widget, since
   ``ShareActionProvider`` provides its own graphics. If you are using a custom
   action, declare an icon.

   .. rubric:: Additional resources
      :name: additional-resources

   -  See
      `ShareActionProvider <#androidx.appcompat.widget.ShareActionProvider>`__
      for an example of adding a share action to your top app bar.
   -  See `ActionProvider <#androidx.core.view.ActionProvider>`__
      for more information about creating a custom action provider.


Last updated 2024-04-29 UTC.


/About settings
===============

.. https://developer.android.google.cn/develop/ui/views/components/settings?hl=en

.. container:: devsite-article-body

   .. rubric:: Settings - Part of Android Jetpack
      :name: settings
      :class: page-title

   Settings let users change the functionality and behavior of an app. Settings
   can affect background behavior, such as how often the app synchronizes data
   with the cloud, or they can be wider-reaching, such as changing the contents
   and presentation of the user interface.

   **Note:**\  This document explains how to use the `AndroidX Preference library <#androidx.preference.package-summary>`__. Starting with
   Android 10, the platform ``android.preference`` library is deprecated.
   To integrate user configurable settings into your app, use the AndroidX
   Preference library. This library manages the user interface and interacts
   with storage so that you define only the individual settings that the user
   can configure. The library comes with a Material Design theme that provides a
   consistent user experience across devices and OS versions.

   .. rubric:: Get started
      :name: getting-started

   A `Preference <#>`__ is the basic
   building block of the Preference library. A settings screen contains a
   ``Preference`` *hierarchy*. You can define this hierarchy as an XML resource,
   or you can `build a hierarchy in code <#>`__.

   The following sections describe how to build a simple settings screen using
   the AndroidX Preference library.

   Before you start, add the Preference library dependency to your
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.preference:preference-ktx:1.2.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.preference:preference-ktx:1.2.0")
               }

   After a Gradle Sync, you can move on to the XML part of the task.

   .. rubric:: Create a hierarchy
      :name: create-hierarchy

   In your project, navigate to ``res/xml`` folder, create a ``preferences.xml``
   file, and add the following code to it:

   .. code:: prettyprint

      <PreferenceScreen
          xmlns:app="http://schemas.android.com/apk/res-auto">

          <SwitchPreferenceCompat
              app:key="notifications"
              app:title="Enable message notifications"/>

          <Preference
              app:key="feedback"
              app:title="Send feedback"
              app:summary="Report technical issues or suggest new features"/>

      </PreferenceScreen>

   This hierarchy contains two ``Preference`` objects: a
   `SwitchPreferenceCompat <#androidx.preference.SwitchPreferenceCompat>`__
   that lets users toggle a setting on and off, and a basic ``Preference`` with
   no widget.

   When building a hierarchy, each ``Preference`` must have a unique key.

   **Note:**\  See the `Android Settings Design Guidelines <https://source.android.google.cn/devices/tech/settings/settings-guidelines>`__
   for recommendations on how to organize your settings screen.

   .. rubric:: Inflate the hierarchy
      :name: inflate-hierarchy

   To inflate a hierarchy from an XML attribute, create a
   `PreferenceFragmentCompat <#androidx.preference.PreferenceFragmentCompat>`__,
   override
   `onCreatePreferences() <#androidx.preference.PreferenceFragmentCompat>`__,
   and provide the XML resource to inflate, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MySettingsFragment : PreferenceFragmentCompat() {
                   override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
                       setPreferencesFromResource(R.xml.preferences, rootKey)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MySettingsFragment extends PreferenceFragmentCompat {
                   @Override
                   public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
                       setPreferencesFromResource(R.xml.preferences, rootKey);
                   }
               }

   You can then add this ``Fragment`` to your ``Activity`` as you do with any
   other ``Fragment``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MySettingsActivity : AppCompatActivity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       supportFragmentManager
                               .beginTransaction()
                               .replace(R.id.settings_container, MySettingsFragment())
                               .commit()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MySettingsActivity extends AppCompatActivity {
                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       getSupportFragmentManager()
                               .beginTransaction()
                               .replace(R.id.settings_container, new MySettingsFragment())
                               .commit();
                   }
               }

   The result is shown in the following image:
   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/components/settings/images/settings-simple.png
      name: example
      :alt: An image showing an example of Preference screen
      :width: 40.0%

      **Figure 1.** A settings screen created using two ``Preference`` objects.

   .. rubric:: Monitor the preferences
      :name: monitor

   You can get an event when a preference changes by registering a listener for
   it:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findPreference<SwitchPreferenceCompat>("notifications")
                   ?.setOnPreferenceChangeListener { _, newValue ->
                       Log.d("Preferences", "Notifications enabled: $newValue")
                       true // Return true if the event is handled.
                   }

               findPreference<Preference>("feedback")
                   ?.setOnPreferenceClickListener {
                       Log.d("Preferences", "Feedback was clicked")
                       true // Return true if the click is handled.
                   }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SwitchPreferenceCompat notificationsPref = findPreference("notifications");

               if (notificationsPref != null) {
                   notificationsPref.setOnPreferenceChangeListener((preference, newValue) -> {
                       Log.d("Preferences", String.format("Notifications enabled: %s", newValue));
                       return true; // Return true if the event is handled.
                   });
               }

               Preference feedbackPref = findPreference("feedback");

               if (feedbackPref != null) {
                   feedbackPref.setOnPreferenceClickListener((preference) -> {
                       Log.d("Preferences", "Feedback was clicked");
                       return true; // Return true if the event is handled.
                   });
               }

   .. rubric:: Read the current preference value
      :name: read

   ``PreferenceFragmentCompat`` hides much of the machinery involved in saving
   and reading the preferences. However, everything is stored using
   ``SharedPreferences``, and you can read these values as you normally do with
   ``SharedPreferences``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val preferences = PreferenceManager.getDefaultSharedPreferences(this).all

               preferences.forEach {
                   Log.d("Preferences", "${it.key} -> ${it.value}")
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               var preferences = PreferenceManager.getDefaultSharedPreferences(context).getAll();

               preferences.forEach((key, value) ->{
                   Log.d("Preferences", String.format("%s -> %s", key, value));
               });

   The previous snippet obtains an instance of the default ``SharedPreferences``
   for the app, accesses all the stored values, loops over them, and prints them
   in Logcat.


Last updated 2024-05-03 UTC.


/Organize your settings
=======================

.. https://developer.android.google.cn/develop/ui/views/components/settings/organize-your-settings?hl=en

.. container:: devsite-article-body

   .. rubric:: Organize your settings - Part of Android Jetpack
      :name: organize_your_settings
      :class: page-title

   Large and complex settings screens can make it difficult for a user to find a
   specific setting they want to change. The Preference library offers the
   following ways to better organize your settings screens.

   .. rubric:: Preference categories
      :name: categories

   If you have several related
   `Preference <#>`__ objects on a
   single screen, you can group them using a
   `PreferenceCategory <#androidx.preference.PreferenceCategory>`__.
   A ``PreferenceCategory`` displays a category title and visually separates the
   category.

   To define a ``PreferenceCategory`` in XML, wrap the ``Preference`` tags with
   a ``PreferenceCategory``, as follows:

   .. code:: prettyprint

      <PreferenceScreen
          xmlns:app="http://schemas.android.com/apk/res-auto">

          <PreferenceCategory
              app:key="notifications_category"
              app:title="Notifications">

              <SwitchPreferenceCompat
                  app:key="notifications"
                  app:title="Enable message notifications"/>

          </PreferenceCategory>

          <PreferenceCategory
              app:key="help_category"
              app:title="Help">

              <Preference
                  app:key="feedback"
                  app:summary="Report technical issues or suggest new features"
                  app:title="Send feedback"/>

          </PreferenceCategory>

      </PreferenceScreen>

   The result looks like the following:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/components/settings/images/settings-preferencecategory.png
      name: categories
      :alt: An image showing preferences with categories
      :width: 30.0%

      **Figure 1.** Preferences within categories.

   .. rubric:: Split your hierarchy into multiple screens
      :name: multiple-screens

   If you have a large number of ``Preference`` objects or distinct categories,
   you can display them on separate screens. Each screen is a
   ``PreferenceFragmentCompat`` with its own separate hierarchy. ``Preference``
   objects on your initial screen can then link to subscreens that contain
   related preferences.

   Figure 2 shows a simple hierarchy that contains two categories: **Messages**
   and **Sync**.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/components/settings/images/settings-simplehierarchy.png
      name: category_hierarchy
      :alt: An image showing a preference screen with hierarchies
      :width: 30.0%

      **Figure 2.** A simple hierarchy with two categories.

   Figure 3 shows the same set of preferences split into multiple screens:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/components/settings/images/settings-screens.png
      name: multiple_screens
      :alt: An image showing a hierarchy split into multiple screens
      :width: 100.0%

      **Figure 3.** A hierarchy split into multiple screens.

   To link screens with a ``Preference``, you can declare an ``app:fragment`` in
   XML or you can use
   `Preference.setFragment() <#androidx.preference.Preference>`__.
   Launch the full package name of the ``PreferenceFragmentCompat`` when the
   ``Preference`` is tapped, as shown in the following example:

   .. code:: prettyprint

      <Preference
              app:fragment="com.example.SyncFragment"
              .../>

   When a user taps a ``Preference`` with an associated ``Fragment``, the
   interface method
   `PreferenceFragmentCompat.OnPreferenceStartFragmentCallback.onPreferenceStartFragment() <#androidx.preference.PreferenceFragmentCompat.OnPreferenceStartFragmentCallback>`__
   is called. This method is where you handle displaying the new screen and
   where the screen is implemented in the surrounding ``Activity``.

   **Note:**\  if you don't implement ``onPreferenceStartFragment()``, a
   fallback implementation is used instead. While this works in most cases, we
   strongly recommend implementing this method so you can fully configure
   transitions between ``Fragment`` objects and update the title displayed in
   your ``Activity`` toolbar, if applicable.
   A typical implementation looks similar to the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyActivity : AppCompatActivity(),
                   PreferenceFragmentCompat.OnPreferenceStartFragmentCallback {
                   ...
                   override fun onPreferenceStartFragment(caller: PreferenceFragmentCompat, pref: Preference): Boolean {
                       // Instantiate the new Fragment.
                       val args = pref.extras
                       val fragment = supportFragmentManager.fragmentFactory.instantiate(
                               classLoader,
                               pref.fragment)
                       fragment.arguments = args
                       fragment.setTargetFragment(caller, 0)
                       // Replace the existing Fragment with the new Fragment.
                       supportFragmentManager.beginTransaction()
                               .replace(R.id.settings_container, fragment)
                               .addToBackStack(null)
                               .commit()
                       return true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyActivity extends AppCompatActivity implements
                       PreferenceFragmentCompat.OnPreferenceStartFragmentCallback {
                   ...
                   @Override
                   public boolean onPreferenceStartFragment(PreferenceFragmentCompat caller, Preference pref) {
                       // Instantiate the new Fragment.
                       final Bundle args = pref.getExtras();
                       final Fragment fragment = getSupportFragmentManager().getFragmentFactory().instantiate(
                               getClassLoader(),
                               pref.getFragment());
                       fragment.setArguments(args);
                       fragment.setTargetFragment(caller, 0);
                       // Replace the existing Fragment with the new Fragment.
                       getSupportFragmentManager().beginTransaction()
                               .replace(R.id.settings_container, fragment)
                               .addToBackStack(null)
                               .commit();
                       return true;
                   }
               }

   .. rubric:: PreferenceScreens
      :name: preferencescreens

   Declaring nested hierarchies within the same XML resource using a nested
   ``&lt;PreferenceScreen&gt;`` is no longer supported. Use nested ``Fragment``
   objects instead.

   .. rubric:: Use separate Activities
      :name: separateactivities

   Alternatively, if you need to heavily customize each screen, or if you want
   full ``Activity`` transitions between screens, you can use a separate
   ``Activity`` for each ``PreferenceFragmentCompat``. By doing this, you can
   fully customize each ``Activity`` and its corresponding settings screen. For
   most apps, we don't recommended this; instead, use ``Fragments`` as
   previously described.

   For more information about launching an ``Activity`` from a ``Preference``,
   see `Preference actions <#actions>`__.


Last updated 2024-02-22 UTC.


/Customize your settings
========================

.. https://developer.android.google.cn/develop/ui/views/components/settings/customize-your-settings?hl=en

.. container:: devsite-article-body

   .. rubric:: Customize your settings - Part of Android Jetpack
      :name: customize_your_settings
      :class: page-title

   This document describes how to customize
   `Preference <#>`__ objects in your
   hierarchy.

   .. rubric:: Find preferences
      :name: finding-references

   To access an individual ``Preference``, such as when getting or setting a
   ``Preference`` value, use
   `PreferenceFragmentCompat.findPreference() <#androidx.preference.PreferenceFragmentCompat>`__.
   This method searches the entire hierarchy for a ``Preference`` with the given
   key.

   For example, to access an
   `EditTextPreference <#androidx.preference.EditTextPreference>`__
   with a key of ``"signature"``, do the following:

   .. code:: prettyprint

      <EditTextPreference
              app:key="signature"
              app:title="Your signature"/>

   Retrieve this ``Preference`` by using the following code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
                   setPreferencesFromResource(R.xml.preferences, rootKey)
                   val signaturePreference: EditTextPreference? = findPreference("signature")
                   // Do something with this preference.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
                   setPreferencesFromResource(R.xml.preferences, rootKey);
                   EditTextPreference signaturePreference = findPreference("signature");
                   // Do something with this preference.
               }

   .. rubric:: Control Preference visibility
      :name: visibility

   You can control which ``Preference`` objects are visible to the user when
   they navigate to a settings screen. For example, if a particular
   ``Preference`` is meaningful only when a corresponding feature is enabled,
   you might want to hide that ``Preference`` when the feature is disabled.

   To show a ``Preference`` only when a condition is met, first set the
   ``Preference`` visibility to false in the XML, as shown in the following
   example:

   .. code:: prettyprint

      <EditTextPreference
              app:key="signature"
              app:title="Your signature"
              app:isPreferenceVisible="false"/>

   In ``onCreatePreferences()``, show the ``Preference`` when the corresponding
   condition is met:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
                   setPreferencesFromResource(R.xml.preferences, rootKey)
                   if(/*some feature*/) {
                       val signaturePreference: EditTextPreference? = findPreference("signature")
                       signaturePreference?.isVisible = true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
                   setPreferencesFromResource(R.xml.preferences, rootKey);
                   if(/*some feature*/) {
                       EditTextPreference signaturePreference = findPreference("signature");
                       if (signaturePreference != null) {
                           signaturePreference.setVisible(true);
                       }
                   }
               }

   .. rubric:: Dynamically update summaries
      :name: summaries

   A ``Preference`` that persists data must display the current value in its
   *summary* to help the user better understand the current state of the
   ``Preference``. For example, an ``EditTextPreference`` must show the saved
   text value, and a ``ListPreference`` must show the selected list entry. You
   might also have ``Preference`` objects that need to update their summary
   based on internal or external app state—for example, a ``Preference`` that
   displays a version number. You can do this by using a
   `SummaryProvider <#androidx.preference.Preference.SummaryProvider>`__.

   .. rubric:: Use a SimpleSummaryProvider
      :name: simplesummaryprovider

   `ListPreference <#androidx.preference.ListPreference.SimpleSummaryProvider>`__
   and
   `EditTextPreference <#androidx.preference.EditTextPreference.SimpleSummaryProvider>`__
   include simple ``SummaryProvider`` implementations that automatically display
   the saved ``Preference`` value as the summary. If no value is saved, they
   display "Not set."

   To enable these implementations from XML, set
   ``app:useSimpleSummaryProvider="true"``.

   Alternatively, in code you can use
   `ListPreference.SimpleSummaryProvider.getInstance() <#androidx.preference.ListPreference.SimpleSummaryProvider>`__
   and
   `EditTextPreference.SimpleSummaryProvider.getInstance() <#androidx.preference.EditTextPreference.SimpleSummaryProvider>`__
   to get the simple ``SummaryProvider`` instance and then set it on the
   ``Preference``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               listPreference.summaryProvider = ListPreference.SimpleSummaryProvider.getInstance()
               editTextPreference.summaryProvider = EditTextPreference.SimpleSummaryProvider.getInstance()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               listPreference.setSummaryProvider(ListPreference.SimpleSummaryProvider.getInstance());
               editTextPreference.setSummaryProvider(EditTextPreference.SimpleSummaryProvider.getInstance());

   .. rubric:: Use a custom SummaryProvider
      :name: custom-simplesummaryprovider

   You can create your own ``SummaryProvider`` and override
   `provideSummary() <#androidx.preference.Preference.SummaryProvider>`__
   to customize the summary whenever it is requested by the ``Preference``. For
   example, the following ``EditTextPreference`` displays the length of its
   saved value as the summary:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/components/settings/images/settings-customsummaryprovider.png
      name: edittextpreference
      :alt: An image showing an example EditTextPreference
      :width: 50.0%

      **Figure 1.** An example ``EditTextPreference``.

   As an example, assume the following ``EditTextPreference``:

   .. code:: prettyprint

      <EditTextPreference
              app:key="counting"
              app:title="Counting preference"/>

   In ``onCreatePreferences()``, you can create a new ``SummaryProvider`` and
   override ``provideSummary()`` to return the summary to be displayed:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val countingPreference: EditTextPreference? = findPreference("counting")

               countingPreference?.summaryProvider = SummaryProvider<EditTextPreference> { preference ->
                   val text = preference.text
                   if (text.isNullOrEmpty()) {
                       "Not set"
                   } else {
                       "Length of saved value: " + text.length
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               EditTextPreference countingPreference = findPreference("counting");

               if (countingPreference != null) {
                   countingPreference.setSummaryProvider(new SummaryProvider<EditTextPreference>() {
                       @Override
                       public CharSequence provideSummary(EditTextPreference preference) {
                           String text = preference.getText();
                           if (TextUtils.isEmpty(text) || text == null){
                               return "Not set";
                           }
                           return "Length of saved value: " + text.length();
                       }
                   });
               }

   The ``Preference`` summary displays the length of the saved value or "Not
   set" when no saved value exists.

   .. rubric:: Customize an EditTextPreference dialog
      :name: custom-edittextpreference

   Within an ``EditTextPreference`` dialog, you can customize text field
   behavior by attaching an
   `OnBindEditTextListener <#androidx.preference.EditTextPreference.OnBindEditTextListener>`__.
   This listener is invoked when the dialog is shown to the user.

   As an example, you can customize a dialog to accept only numbers. First,
   create the ``EditTextPreference``:

   .. code:: prettyprint

      <EditTextPreference
              app:key="number"
              app:title="Numbers only preference"/>

   Next, in ``onCreatePreferences()``, create a new ``OnBindEditTextListener``
   and override ``onBindEditText()`` to customize the ``EditText`` when it is
   shown to the user.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val numberPreference: EditTextPreference? = findPreference("number")

               numberPreference?.setOnBindEditTextListener { editText ->
                   editText.inputType = InputType.TYPE_CLASS_NUMBER
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               EditTextPreference numberPreference = findPreference("number");

               if (numberPreference != null) {
                   numberPreference.setOnBindEditTextListener(
                           new EditTextPreference.OnBindEditTextListener() {
                               @Override
                               public void onBindEditText(@NonNull EditText editText) {
                                   editText.setInputType(InputType.TYPE_CLASS_NUMBER);
                               }
                           });
               }

   Now, when the dialog is shown to the user, the keyboard opens in numeric-only
   mode, so the user can enter only numbers into the ``EditText``.

   .. rubric:: Preference actions
      :name: actions

   A ``Preference`` can have a specific action when tapped. For example, a
   ``Preference`` can act as a link to a separate part of your app. To add an
   action to a ``Preference``, you can set an ``Intent`` on the ``Preference``
   directly or you can set an
   `OnPreferenceClickListener <#androidx.preference.Preference.OnPreferenceClickListener>`__
   for more specific logic.

   .. rubric:: Set an Intent
      :name: set-an-intent

   You can set an ``Intent`` on a ``Preference`` to launch a new ``Fragment``,
   ``Activity``, or separate app whenever the ``Preference`` is tapped. This is
   the same as using
   `Context.startActivity() <#android.content.Context>`__
   with a given ``Intent``.

   You can set an ``Intent`` in XML using a nested ``<intent>`` tag. The
   following example defines an ``Intent`` that launches an ``Activity``:

   .. code:: prettyprint

      <Preference
              app:key="activity"
              app:title="Launch activity">
          <intent
                  android:targetPackage="com.example"
                  android:targetClass="com.example.ExampleActivity"/>
      </Preference>

   Alternatively, you can use ``setIntent()`` directly on a ``Preference``, as
   follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(context, ExampleActivity::class.java)
               activityPreference.setIntent(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(getContext(), ExampleActivity.class);
               activityPreference.setIntent(intent);

   You can also include extras with an ``Intent`` using XML:

   .. code:: prettyprint

      <Preference
              app:key="activity"
              app:title="Launch activity">
          <intent
                  android:targetPackage="com.example"
                  android:targetClass="com.example.ExampleActivity">
              <extra
                      android:name="example_key"
                      android:value="example_value"/>
          </intent>
      </Preference>

   Here is an example of a ``Preference`` with an ``Intent`` that launches a web
   page:

   .. code:: prettyprint

      <Preference
              app:key="webpage"
              app:title="View webpage">
          <intent
                  android:action="android.intent.action.VIEW"
                  android:data="http://www.google.com" />
      </Preference>

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(Intent.ACTION_VIEW)
               intent.data = Uri.parse("http://www.google.com")

               val webpagePreference = findPreference("webpage")
               webpagePreference?.intent = intent

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(Intent.ACTION_VIEW);
               intent.setData(Uri.parse("http://www.google.com"));
               webpagePreference.setIntent(intent);

   .. rubric:: OnPreferenceClickListener
      :name: onpreferenceclicklistener

   You can set an ``OnPreferenceClickListener`` on a ``Preference``, which adds
   a callback to ``onPreferenceClick()`` when the ``Preference`` is tapped. For
   example, you can use the listener to navigate to another ``Fragment`` or
   ``Activity`` if you have more complex logic for handling navigation.

   To set an ``OnPreferenceClickListener``, use code similar to the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               onClickPreference.setOnPreferenceClickListener({
                   // Do something.
                   true
               })

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               onClickPreference.setOnPreferenceClickListener(preference -> {
                   // Do something.
                   return true;
               });


Last updated 2024-02-22 UTC.


/Use saved values
=================

.. https://developer.android.google.cn/develop/ui/views/components/settings/use-saved-values?hl=en

.. container:: devsite-article-body

   .. rubric:: Use saved Preference values - Part of Android Jetpack
      :name: use_saved_preference_values
      :class: page-title

   This document describes how to store and use
   `Preference <#>`__ values that are
   saved by the Preference library.

   .. rubric:: Preference data storage
      :name: storage

   This section describes how a ``Preference`` can persist data.

   .. rubric:: SharedPreferences
      :name: shared-preferences

   By default, a ``Preference`` uses
   `SharedPreferences <#android.content.SharedPreferences>`__ to
   save values. The ``SharedPreferences`` API supports reading and writing
   simple key-value pairs from a file that is saved across application sessions.
   The Preference library uses a private ``SharedPreferences`` instance so that
   only your application can access it.

   As an example, assume the following
   `SwitchPreferenceCompat <#androidx.preference.SwitchPreferenceCompat>`__:

   .. code:: prettyprint

      <SwitchPreferenceCompat
              app:key="notifications"
              app:title="Enable message notifications"/>

   When a user toggles this switch to the "on" state, the ``SharedPreferences``
   file updates with a key-value pair of ``"notifications" : "true"``. The key
   used is the same as the key set for the ``Preference``.

   For more information about the ``SharedPreferences`` API, see `Save key-value data <#>`__.

   For information about the different ways of storing data on Android, see
   `Data and file storage overview <#>`__.

   .. rubric:: PreferenceDataStore
      :name: prederence-datastore

   Although the Preference library persists data with ``SharedPreferences`` by
   default, ``SharedPreferences`` aren't always an ideal solution. For example,
   if your application requires a user to sign in, you might want to persist
   application settings in the cloud so that the settings are reflected across
   other devices and platforms. Similarly, if your application has configuration
   options that are device-specific, each user on the device has separate
   settings, making ``SharedPreferences`` a less-than-ideal solution.

   A
   `PreferenceDataStore <#androidx.preference.PreferenceDataStore>`__
   lets you use a custom storage backend to persist ``Preference`` values. For
   more information, see `Use a custom datastore <#custom-data-store>`__.

   .. rubric:: Read Preference values
      :name: reading

   To retrieve the ``SharedPreferences`` object that is being used, call
   `PreferenceManager.getDefaultSharedPreferences() <#androidx.preference.PreferenceManager>`__.
   Although this method works from anywhere in your application, we recommend
   that you split your app into layers. For more information, see `Data layer <#>`__.

   For example, given an ``EditTextPreference`` with a key of ``"signature"``,
   as follows:

   .. code:: prettyprint

      <EditTextPreference
              app:key="signature"
              app:title="Your signature"/>

   You can retrieve the saved value for this ``Preference`` globally, as
   follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this /* Activity context */)
               val name = sharedPreferences.getString("signature", "")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SharedPreferences sharedPreferences =
                       PreferenceManager.getDefaultSharedPreferences(this /* Activity context */);
               String name = sharedPreferences.getString("signature", "");

   .. rubric:: Listen for changes to Preference values
      :name: changes

   To listen for changes to ``Preference`` values, you can choose between two
   interfaces:

   -  `Preference.OnPreferenceChangeListener <#androidx.preference.Preference.OnPreferenceChangeListener>`__
   -  `SharedPreferences.OnSharedPreferenceChangeListener <#android.content.SharedPreferences.OnSharedPreferenceChangeListener>`__

   The following table shows how the two interfaces differ:

   +--------------------------------------+--------------------------------------+
   | ``OnPreferenceChangeListener``       | ``OnSharedPreferenceChangeListener`` |
   +======================================+======================================+
   | Set on a single ``Preference``.      | Applies to all ``Preference``        |
   |                                      | objects.                             |
   +--------------------------------------+--------------------------------------+
   | Called when a ``Preference`` is      | Called only when the value saved for |
   | about to change its saved value,     | a ``Preference`` changes.            |
   | even if the pending value is the     |                                      |
   | same as the saved value.             |                                      |
   +--------------------------------------+--------------------------------------+
   | Only called through the              | Called whenever the saved value      |
   | ``Preference`` library. A separate   | changes, even if it is from a        |
   | part of the application can change   | separate part of the application.    |
   | the saved value.                     |                                      |
   +--------------------------------------+--------------------------------------+
   | Called before the pending value is   | Called after the value is saved.     |
   | saved.                               |                                      |
   +--------------------------------------+--------------------------------------+
   | Called when using                    | Called only when using               |
   | ``SharedPreferences`` or a           | ``SharedPreferences``.               |
   | ``PreferenceDataStore``.             |                                      |
   +--------------------------------------+--------------------------------------+

   .. rubric:: Implement OnPreferenceChangeListener
      :name: change-listener

   Implementing an ``OnPreferenceChangeListener`` lets you listen for a pending
   change to the value of a ``Preference``. Then, you can validate whether the
   change occurs. For example, the following code shows how to listen for a
   change to the value of an ``EditTextPreference`` with a key of ``"name"``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onPreferenceChange(preference: Preference, newValue: Any): Boolean {
                   Log.e("preference", "Pending Preference value is: $newValue")
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onPreferenceChange(Preference preference, Object newValue) {
                   Log.e("preference", "Pending Preference value is: " + newValue);
                   return true;
               }

   Next, you need to set this listener directly with
   `setOnPreferenceChangeListener() <#androidx.preference.Preference>`__,
   as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               preference.onPreferenceChangeListener = ...

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               preference.setOnPreferenceChangeListener(...);

   .. rubric:: Implement OnSharedPreferenceChangeListener
      :name: listener

   When persisting ``Preference`` values using ``SharedPreferences``, you can
   also use a ``SharedPreferences.OnSharedPreferenceChangeListener`` to listen
   for changes. This lets you listen for when the values saved by your
   ``Preference`` are changed, such as when syncing settings with a server. The
   following example shows how to listen for a change to the value of an
   ``EditTextPreference`` with a key of ``"name"``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences, key: String) {
                   if (key == "signature") {
                       Log.i(TAG, "Preference value was updated to: " + sharedPreferences.getString(key, ""))
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
                   if (key.equals("signature")) {
                       Log.i(TAG, "Preference value was updated to: " + sharedPreferences.getString(key, ""));
                   }
               }

   Register the listener using
   `registerOnSharedPreferenceChangedListener() <#android.content.SharedPreferences>`__,
   as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               preferenceManager.sharedPreferences.registerOnSharedPreferenceChangeListener(...)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               getPreferenceManager().getSharedPreferences().registerOnSharedPreferenceChangeListener(...);

   **Warning:**\  To prevent unintended garbage collection, store a strong
   reference to the listener. When you call
   ``registerOnSharedPreferenceChangeListener()``, the
   ``SharedPreferenceManager`` doesn't store a strong reference to the listener.
   To address this, you can implement ``onSharedPreferenceChanged()`` directly
   in your ``PreferenceFragmentCompat``. You can also create an instance
   variable, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   val listener: SharedPreferences.OnSharedPreferenceChangeListener =
                           SharedPreferences.OnSharedPreferenceChangeListener {...}
                   

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                   SharedPreferences.OnSharedPreferenceChangeListener listener =
                           new SharedPreferences.OnSharedPreferenceChangeListener() {...}
                   

   For proper lifecycle management in your ``Activity`` or ``Fragment``,
   register and unregister this listener in the ``onResume()`` and ``onPause()``
   callbacks, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onResume() {
                   super.onResume()
                   preferenceManager.sharedPreferences.registerOnSharedPreferenceChangeListener(this)
               }

               override fun onPause() {
                   super.onPause()
                   preferenceManager.sharedPreferences.unregisterOnSharedPreferenceChangeListener(this)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onResume() {
                   super.onResume();
                   getPreferenceManager().getSharedPreferences().registerOnSharedPreferenceChangeListener(this);
               }

               @Override
               public void onPause() {
                   super.onPause();
                   getPreferenceManager().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this);
               }

   .. rubric:: Use a custom datastore
      :name: custom-data-store

   Although we recommend persisting ``Preference`` objects using
   ``SharedPreferences``, you can also use a custom datastore. A custom
   datastore can be useful if your application persists values to a database or
   if values are device-specific, as shown in the following examples.

   .. rubric:: Implement the datastore
      :name: implement

   To implement a custom datastore, create a class that extends
   ``PreferenceDataStore``. The following example creates a datastore that
   handles ``String`` values:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class DataStore : PreferenceDataStore() {
                   override fun putString(key: String, value: String?) {
                       // Save the value somewhere.
                   }

                   override fun getString(key: String, defValue: String?): String? {
                       // Retrieve the value.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class DataStore extends PreferenceDataStore {
                   @Override
                   public void putString(String key, @Nullable String value) {
                       // Save the value somewhere.
                   }
                   @Override
                   @Nullable
                   public String getString(String key, @Nullable String defValue) {
                       // Retrieve the value.
                   }
               }

   **Note:**\  Only override methods that are used by your ``Preference``
   objects. Calling a method that you didn't implement results in an
   ``UnsupportedOperationException``.
   Run any time-consuming operations off the main thread to avoid blocking the
   user interface. Since it's possible for the ``Fragment`` or ``Activity``
   containing the datastore to be destroyed while persisting a value, serialize
   the data so you don't lose any values changed by the user.

   .. rubric:: Enable the datastore
      :name: enable

   After you implement your datastore, set the new datastore in
   ``onCreatePreferences()`` so that ``Preference`` objects persist values with
   the datastore instead of using the default ``SharedPreferences``. You can
   enable a datastore for each ``Preference`` or for the entire hierarchy.

   To enable a custom datastore for a specific ``Preference``, call
   `setPreferenceDataStore() <#androidx.preference.Preference>`__
   on the ``Preference``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val preference: Preference? = findPreference("key")
               preference?.preferenceDataStore = dataStore

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Preference preference = findPreference("key");
               if (preference != null) {
                   preference.setPreferenceDataStore(dataStore);
               }

   To enable a custom datastore for an entire hierarchy, call
   ``setPreferenceDataStore()`` on the ``PreferenceManager``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val preferenceManager = preferenceManager
               preferenceManager.preferenceDataStore = dataStore

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               PreferenceManager preferenceManager = getPreferenceManager();
               preferenceManager.setPreferenceDataStore(dataStore);

   A datastore that is set for a specific ``Preference`` overrides any datastore
   that is set for the corresponding hierarchy. In most cases, you set a
   datastore for the whole hierarchy.

   **Note:**\  If you set a datastore for a ``Preference`` after the
   ``Preference`` is attached to the hierarchy, the initial value for the
   ``Preference`` isn't propagated again.


Last updated 2024-02-22 UTC.


/Create a hierarchy in code
===========================

.. https://developer.android.google.cn/develop/ui/views/components/settings/programmatic-hierarchy?hl=en

.. container:: devsite-article-body

   .. rubric:: Create a hierarchy in code - Part of Android Jetpack
      :name: create_a_hierarchy_in_code
      :class: page-title

   You can create a hierarchy programmatically in
   `onCreatePreferences() <#androidx.preference.PreferenceFragmentCompat>`__.
   The following example demonstrates a programmatic approach to creating the
   same preference screen created through XML on the
   `overview <#create_a_hierarchy>`__ page.
   To create the screen programmatically, create each setting and set its
   relevant properties, then add it to the preference screen:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
                   val context = preferenceManager.context
                   val screen = preferenceManager.createPreferenceScreen(context)

                   val notificationPreference = SwitchPreferenceCompat(context)
                   notificationPreference.key = "notifications"
                   notificationPreference.title = "Enable message notifications"

                   val feedbackPreference = Preference(context)
                   feedbackPreference.key = "feedback"
                   feedbackPreference.title = "Send feedback"
                   feedbackPreference.summary = "Report technical issues or suggest new features"

                   screen.addPreference(notificationPreference)
                   screen.addPreference(feedbackPreference)

                   preferenceScreen = screen
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
                   Context context = getPreferenceManager().getContext();
                   PreferenceScreen screen = getPreferenceManager().createPreferenceScreen(context);

                   SwitchPreferenceCompat notificationPreference = new SwitchPreferenceCompat(context);
                   notificationPreference.setKey("notifications");
                   notificationPreference.setTitle("Enable message notifications");

                   Preference feedbackPreference = new Preference(context);
                   feedbackPreference.setKey("feedback");
                   feedbackPreference.setTitle("Send feedback");
                   feedbackPreference.setSummary("Report technical issues or suggest new features");

                   screen.addPreference(notificationPreference);
                   screen.addPreference(feedbackPreference);

                   setPreferenceScreen(screen);
               }

   Adding a
   `PreferenceCategory <#androidx.preference.PreferenceCategory>`__
   is similar. The following example demonstrates a programmatic approach to
   creating the preference screen seen in `Organize your settings <#preference_categories>`__.
   The children are added to the ``PreferenceCategory`` and not to the root
   ``PreferenceScreen``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
                   val context = preferenceManager.context
                   val screen = preferenceManager.createPreferenceScreen(context)

                   val notificationPreference = SwitchPreferenceCompat(context)
                   notificationPreference.key = "notifications"
                   notificationPreference.title = "Enable message notifications"

                   val notificationCategory = PreferenceCategory(context)
                   notificationCategory.key = "notifications_category"
                   notificationCategory.title = "Notifications"
                   screen.addPreference(notificationCategory)
                   notificationCategory.addPreference(notificationPreference)

                   val feedbackPreference = Preference(context)
                   feedbackPreference.key = "feedback"
                   feedbackPreference.title = "Send feedback"
                   feedbackPreference.summary = "Report technical issues or suggest new features"

                   val helpCategory = PreferenceCategory(context)
                   helpCategory.key = "help"
                   helpCategory.title = "Help"
                   screen.addPreference(helpCategory)
                   helpCategory.addPreference(feedbackPreference)

                   preferenceScreen = screen
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
                   Context context = getPreferenceManager().getContext();
                   PreferenceScreen screen = getPreferenceManager().createPreferenceScreen(context);

                   SwitchPreferenceCompat notificationPreference = new SwitchPreferenceCompat(context);
                   notificationPreference.setKey("notifications");
                   notificationPreference.setTitle("Enable message notifications");

                   PreferenceCategory notificationCategory = new PreferenceCategory(context);
                   notificationCategory.setKey("notifications_category");
                   notificationCategory.setTitle("Notifications");
                   screen.addPreference(notificationCategory);
                   notificationCategory.addPreference(notificationPreference);

                   Preference feedbackPreference = new Preference(context);
                   feedbackPreference.setKey("feedback");
                   feedbackPreference.setTitle("Send feedback");
                   feedbackPreference.setSummary("Report technical issues or suggest new features");

                   PreferenceCategory helpCategory = new PreferenceCategory(context);
                   helpCategory.setKey("help");
                   helpCategory.setTitle("Help");
                   screen.addPreference(helpCategory);
                   helpCategory.addPreference(feedbackPreference);

                   setPreferenceScreen(screen);
               }

   **Warning:**\  Add the ``PreferenceCategory`` to the ``PreferenceScreen``
   before adding children to it. Preferences can't be added to a
   ``PreferenceCategory`` that isn't attached to the root screen.


Last updated 2024-02-22 UTC.


/Handle other device sizes
==========================

.. https://developer.android.google.cn/develop/ui/views/components/settings/handle-other-form-factors?hl=en

.. container:: devsite-article-body

   .. rubric:: Handle other form factors - Part of Android Jetpack
      :name: handle_other_form_factors
      :class: page-title

   This topic outlines using the Preference Library with other supported form
   factors.

   .. rubric:: Android TV
      :name: android_tv

   You should use the `AndroidX Leanback Preference Library <#>`__
   for building settings on Android TV devices. As the Leanback Preference
   Library shares many of the same concepts as this library, you can use many of
   the same attributes to customize your settings screens.


Last updated 2024-02-22 UTC.


/Implement preference best practices
====================================

.. https://developer.android.google.cn/develop/ui/views/components/settings/components-and-attributes?hl=en

.. container:: devsite-article-body

   .. rubric:: Preference components and attributes - Part of Android Jetpack
      :name: preference_components_and_attributes
      :class: page-title

   This topic describes some of the most commonly-used ``Preference`` components
   and attributes used when building a settings screen.

   .. rubric:: Preference components
      :name: preference_components

   This section describes common ``Preference`` components. For more
   information, see the corresponding reference pages for each component.

   .. rubric:: Preference infrastructure
      :name: preference_infrastructure

   `PreferenceFragmentCompat <#androidx.preference.PreferenceFragmentCompat>`__
   - a `Fragment <#>`__ that
   handles displaying an interactive hierarchy of ``Preference`` objects.

   .. rubric:: Preference containers
      :name: preference_containers

   `PreferenceScreen <#androidx.preference.PreferenceScreen>`__ -
   a top-level container that represents a settings screen. This is the root
   component of your ``Preference`` hierarchy.

   `PreferenceCategory <#androidx.preference.PreferenceCategory>`__
   - a container that is used to group similar ``Preferences``. A
   ``PreferenceCategory`` displays a category title and visually separates
   groups of ``Preferences``.

   .. rubric:: Individual Preferences
      :name: individual_preferences

   `Preference <#androidx.preference.Preference>`__ - the basic
   building block that represents an individual setting. If a ``Preference`` is
   set to persist, it has a corresponding key-value pair that holds the user’s
   choice for the setting that can be accessed elsewhere in the application.

   `EditTextPreference <#androidx.preference.EditTextPreference>`__
   - a ``Preference`` that persists a ``String`` value. Users can tap on the
   ``Preference`` to launch a dialog containing the text field that allows the
   user to change the persisted value.

   `ListPreference <#androidx.preference.ListPreference>`__ - a
   ``Preference`` that persists a String value. Users can change this value in a
   dialog that contains a list of radio buttons with corresponding labels.

   `MultiSelectListPreference <#androidx.preference.MultiSelectListPreference>`__
   - a ``Preference`` that persists a set of Strings. Users can change these
   values in a dialog that contains a list of checkboxes with corresponding
   labels.

   `SeekBarPreference <#androidx.preference.SeekBarPreference>`__
   - a ``Preference`` that persists an integer value. This value can be changed
   by dragging a corresponding seekbar that is displayed in the ``Preference``
   layout.

   `SwitchPreferenceCompat <#androidx.preference.SwitchPreferenceCompat>`__
   - a ``Preference`` that persists a boolean value. This value can be changed
   by interacting with the corresponding switch widget or by tapping on the
   ``Preference`` layout.

   `CheckBoxPreference <#androidx.preference.CheckBoxPreference>`__
   - a ``Preference`` that persists a boolean value. This value can be changed
   by interacting with the corresponding checkbox or by tapping on the
   ``Preference`` layout.

   **Note:**\  Although ``SwitchPreferenceCompat`` and ``CheckBoxPreference``
   store a boolean value and function in similar ways, we recommend using a
   ``SwitchPreferenceCompat`` where possible. For more information, see the
   `Android Settings Design Guidelines <https://source.android.google.cn/devices/tech/settings/settings-guidelines#checkbox>`__.

   .. rubric:: Preference attributes
      :name: preference_attributes

   Listed below are some of the most commonly-used attributes that configure
   ``Preference`` appearance and behavior.

   **Note:**\  Each attribute listed below has a corresponding getter and
   setter. For mostly static hierarchies, however, we recommend configuring
   these attributes via the ``Preference`` XML resource.

   .. rubric:: Generic attributes
      :name: generic_attributes

   ``title``
      A ``String`` value that represents the title of the ``Preference``.

      **Example:** ``app:title="Title"``

   ``summary``
      A ``String`` value that represents the ``Preference`` summary.

      **Example:** ``app:summary="Summary"``

   ``icon``
      A ``Drawable`` that represents the ``Preference`` icon.

      **Example:** ``app:icon="@drawable/ic_camera"``

   ``key``
      A ``String`` value that represents the key that is used to persist the
      value for the associated ``Preference``. A key allows you to further
      customize the ``Preference`` during runtime. You should set a key for each
      ``Preference`` in your hierarchy.

      **Example:** ``app:key="key"``

   ``enabled``
      A boolean value that indicates whether users can interact with the
      ``Preference``. When this value is ``false``, the ``Preference`` appears
      grayed out, and users cannot interact with it. The default value is
      ``true``.

      **Example:** ``app:enabled="false"``

   ``selectable``
      A boolean value that indicates whether users can interact with the
      ``Preference``. The default value is ``true``.

      **Example:** ``app:selectable="false"``

   ``isPreferenceVisible``
      A boolean value that indicates whether a ``Preference`` or ``Preference``
      category is visible. This is equivalent to calling
      `setVisible() <#androidx.preference.Preference>`__.

      **Example:** ``app:isPreferenceVisible="false"``

   ``defaultValue``
      Represents the default value for a ``Preference``. This value is set and
      persisted when no other persisted value for this ``Preference`` is found.
      The value type depends on the associated ``Preference``.

      **Example:** ``app:defaultValue="true"``

   ``dependency``
      Represents the key of a ``SwitchPreferenceCompat`` that controls the state
      of this ``Preference``. When the corresponding switch is turned off, this
      ``Preference`` is disabled and is unable to be modified.

      **Example:** ``app:dependency="parent"``

   .. rubric:: PreferenceCategory attributes
      :name: preferencecategory_attributes

   ``initialExpandedChildrenCount``
      An integer value that enables expandable ``Preference`` behavior. This
      value represents the maximum number of children to show in the
      ``PreferenceGroup``. Any extra children are collapsed and can be shown by
      tapping the expand button. By default, this value is
      ``Integer.MAX_VALUE``, and all children are shown.

      **Warning:** Ensure that you set a key on the ``PreferenceCategory`` if
      using this attribute so that the state is correctly saved and restored
      when the configuration changes (such as when rotating the screen).

      **Example:** ``app:initialExpandedChildrenCount="0"``

   .. rubric:: ListPreference / MultiSelectListPreference attributes
      :name: listpreference_multiselectlistpreference_attributes

   ``entries``
      An array of Strings that corresponds to the list entries to be displayed
      to the user. Each of these values correspond by index to the array of
      values that are internally persisted. For example, when a user selects the
      first list entry, the first element in the corresponding array of values
      is persisted.

      **Example:** ``app:entries="@array/entries"``

      **Warning:** Ensure the length of both arrays are the same, and the
      indexes of each array match the correct entry / value pair.

   ``entryValues``
      The array of entries to be persisted. Each of these values correspond by
      index to the array of list entries that are displayed to the user.

      **Example:** ``app:entryValues="@array/values"``


Last updated 2024-02-22 UTC.


/Search options
===============

.. https://developer.android.google.cn/develop/ui/views/search?hl=en

.. container:: devsite-article-body

   Search is a core user feature on Android. Users must be able to search any
   data that is available to them, whether the content is located on the device
   or the internet. To help create a consistent search experience for users,
   Android provides a search framework that helps you implement search for your
   application.

   .. container:: attempt-right

      |image-search-suggest-custom|
      **Figure 1.** A search dialog with custom search suggestions.

   The search framework offers two modes of search input: a search dialog at the
   top of the screen or a search widget
   (`SearchView <#android.widget.SearchView>`__) that you can
   embed in your activity layout. In either case, the Android system assists
   your search implementation by delivering search queries to a specific
   activity that performs searches. You can also enable the search dialog or
   widget to provide search suggestions as the user types. Figure 1 shows an
   example of the search dialog with optional search suggestions.

   Once you set up either the search dialog or the search widget, you can do the
   following:

   -  Enable voice search.
   -  Provide search suggestions based on recent user queries.
   -  Provide custom search suggestions that match actual results in your
      application data.
   -  Offer your application's search suggestions in the system-wide Quick
      Search Box.

   | **Note**: The search framework does *not* provide APIs to search your data.
     To perform a search, you need to use APIs appropriate for your data. For
     example, if your data is stored in an SQLite database, use the
     `android.database.sqlite <#android.database.sqlite.package-summary>`__
     APIs to perform searches.
   | Also, there is no guarantee that a device provides a dedicated SEARCH
     button that invokes the search interface in your application. When using
     the search dialog or a custom interface, you must provide a search button
     in your UI that activates the search interface. For more information, see
     `Invoke the search dialog <#InvokingTheSearchDialog>`__.

   The following pages show you how to use Android's framework to implement
   search:

   `Create a search interface <#>`__
      How to set up your application to use the search dialog or search widget.
   `Add recent query suggestions <#>`__
      How to provide suggestions based on queries previously used.
   `Add custom suggestions <#>`__
      How to provide suggestions based on custom data from your application and
      offer them in the system-wide Quick Search Box.
   `Searchable configuration <#>`__
      A reference document for the searchable configuration file. The other
      documents also discuss the configuration file in terms of specific
      behaviors.

   .. rubric:: Protect user privacy
      :name: protect-user-privacy

   When you implement search in your application, take steps to protect the
   user's privacy. Many users consider their activities on their phone—including
   searches—to be private information. To protect users' privacy, abide by the
   following principles:

   -  **Don't send personal information to servers‐and if you must, don't log
      it.**

      Personal information is any information that can personally identify your
      users, such as their names, email addresses, billing information, or other
      data that can be reasonably linked to such information. If your
      application implements search with the assistance of a server, avoid
      sending personal information along with the search queries. For example,
      if you are searching for businesses near a ZIP code, you don't need to
      send the user ID as well; send only the ZIP code to the server. If you
      must send personal information, avoid logging it. If you must log it,
      protect that data very carefully and erase it as soon as possible.

   -  **Provide users with a way to clear their search history.**

      The search framework helps your application provide context-specific
      suggestions while the user types. Sometimes these suggestions are based on
      previous searches or other actions taken by the user in an earlier
      session. A user might not want previous searches to be revealed to other
      device users. If your application provides suggestions that can reveal
      previous search activities, implement a way for the user to clear their
      search history. If you are using
      `SearchRecentSuggestions <#android.provider.SearchRecentSuggestions>`__,
      you can call the
      `clearHistory() <#android.provider.SearchRecentSuggestions>`__
      method. If you are implementing custom suggestions, you need to provide a
      similar "clear history" method in your content provider that the user can
      execute.


Last updated 2024-02-22 UTC.

.. |image-search-suggest-custom| image:: https://developer.android.google.cn/static/images/search/search-suggest-custom.png
   :height: 417px


/Create a search UI
===================

.. https://developer.android.google.cn/develop/ui/views/search/search-dialog?hl=en

.. container:: devsite-article-body

   When you're ready to add search functionality to your app, Android helps you
   implement the user interface with either a search dialog that appears at the
   top of the activity window or a search widget that you can insert in your
   layout. Both the search dialog and the widget can deliver the user's search
   query to a specific activity in your app. This way, the user can initiate a
   search from any activity where the search dialog or widget is available, and
   the system starts the appropriate activity to perform the search and present
   results.

   Other features available for the search dialog and widget include:

   -  Voice search
   -  Search suggestions based on recent queries
   -  Search suggestions that match actual results in your app data

   This document shows how to set up your app to provide a search interface
   that's assisted by the Android system to deliver search queries, using either
   the search dialog or the search widget.

   Related resources:

   -  `Material Design icons <https://material.io/icons/>`__

   .. rubric:: The basics
      :name: TheBasics

   Before you begin, decide whether you want to implement your search interface
   using the search dialog or the search widget. They provide the same search
   features, but in slightly different ways:

   -  The **search dialog** is a UI component that's controlled by the Android
      system. When activated by the user, the search dialog appears at the top
      of the activity.

      The Android system controls all events in the search dialog. When the user
      submits a query, the system delivers the query to the activity that you
      specify to handle searches. The dialog can also provide search suggestions
      while the user types.

   -  The **search widget** is an instance of
      `SearchView <#android.widget.SearchView>`__ that you can
      place anywhere in your layout. By default, the search widget behaves like
      a standard `EditText <#android.widget.EditText>`__ widget
      and doesn't do anything, but you can configure it so that the Android
      system handles all input events, delivers queries to the appropriate
      activity, and provides search suggestions—just like the search dialog.

   **Note:** This document focuses on how to integrate the search widget with
   the system for an assisted search implementation. But you can also handle all
   user input into the search widget yourself, using various callback methods
   and listeners. If you want to handle user input yourself, read the reference
   document for ``SearchView`` and its nested interfaces.
   When the user executes a search from the search dialog or a search widget,
   the system creates an `Intent <#android.content.Intent>`__ and
   stores the user query in it. The system then starts the activity that you
   declare to handle searches—the "searchable activity"—and delivers it the
   intent. To set up your app for this kind of assisted search, you need the
   following:

   A search configuration
      An XML file that configures some settings for the search dialog or widget.
      It includes settings for features such as voice search, search suggestion,
      and hint text for the search box.
   A searchable activity
      The `Activity <#android.app.Activity>`__ that receives the
      search query, searches your data, and displays the search results.
   A search interface, provided by either of the following:
   The search dialog
      By default, the search dialog is hidden. It appears at the top of the
      screen when you call
      `onSearchRequested() <#android.app.Activity>`__
      when the user taps your **Search** button.
   A `SearchView <#android.widget.SearchView>`__ widget
      Using the search widget lets you put the search box anywhere in your
      activity, including as an action view in the app bar.

   The rest of this document shows you how to create the search configuration
   and searchable activity and how to implement a search interface with either
   the search dialog or search widget.

   .. rubric:: Create a searchable configuration
      :name: SearchableConfiguration

   The first thing you need is an XML file called a `search configuration <#>`__. It configures
   certain UI aspects of the search dialog or widget and defines how features
   such as suggestions and voice search behave. This file is traditionally named
   ``searchable.xml`` and must be saved in the ``res/xml/`` project directory.

   **Note:** The system uses this file to instantiate a
   `SearchableInfo <#android.app.SearchableInfo>`__ object. You
   can't create this object yourself at runtime. You must declare the search
   configuration in XML.
   The search configuration file must include the
   `<searchable> <#searchable-element>`__
   element as its root node and specify one or more attributes, as shown in the
   following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <searchable xmlns:android="http://schemas.android.com/apk/res/android"
          android:label="@string/app_label"
          android:hint="@string/search_hint" >
      </searchable>

   The ``android:label`` attribute is the only required attribute. It points to
   a string resource, which must be the app name. This label isn't visible to
   the user until you enable search suggestions for Quick Search Box, at which
   point the label is visible in the list of Searchable items in the system
   settings.

   Although it's not required, we recommend that you always include the
   ``android:hint`` attribute, which provides a hint string in the search box
   before users enter a query. The hint is important because it provides
   important clues to users about what they can search.

   **Tip:** For consistency with other Android apps, format the string for
   ``android:hint`` as "Search <content-or-product>". For example, "Search songs
   and artists" or "Search YouTube."
   The ``<searchable>`` element accepts several other attributes. However, you
   don't need most attributes until you add features such as `search suggestions <#SearchSuggestions>`__ and `voice search <#VoiceSearch>`__. For
   detailed information about the search configuration file, see the `Search configuration <#>`__ reference document.

   .. rubric:: Create a searchable activity
      :name: SearchableActivity

   A searchable activity is the ``Activity`` in your app that performs searches
   based on a query string and presents the search results.

   When the user executes a search in the search dialog or widget, the system
   starts your searchable activity and delivers it the search query in an
   ``Intent`` with the
   `ACTION_SEARCH <#android.content.Intent>`__
   action. Your searchable activity retrieves the query from the intent's
   `QUERY <#android.app.SearchManager>`__ extra, then
   searches your data and presents the results.

   Because you can include the search dialog or widget in any other activity in
   your app, the system must know which activity is your searchable activity so
   that it can properly deliver the search query. So, first declare your
   searchable activity in the Android manifest file.

   .. rubric:: Declare a searchable activity
      :name: DeclaringSearchableActivity

   If you don't have one already, create an ``Activity`` that performs searches
   and presents results. You don't need to implement the search functionality
   yet—just create an activity that you can declare in the manifest. Inside the
   manifest's `<activity> <#>`__
   element, do the following:

   #. Declare the activity to accept the ``ACTION_SEARCH`` intent in an
      `<intent-filter> <#>`__
      element.
   #. Specify the search configuration to use in a
      `<meta-data> <#>`__ element.

   This is shown in the following example:

   .. code:: prettyprint

      <application ... >
          <activity android:name=".SearchableActivity" >
              <intent-filter>
                  <action android:name="android.intent.action.SEARCH" />
              </intent-filter>
              <meta-data android:name="android.app.searchable"
                         android:resource="@xml/searchable"/>
          </activity>
          ...
      </application>

   The ``<meta-data>`` element must include the ``android:name`` attribute with
   a value of ``"android.app.searchable"`` and the ``android:resource``
   attribute with a reference to the searchable configuration file. In the
   preceding example, it refers to the ``res/xml/searchable.xml`` file.

   **Note:** The ``<intent-filter>`` doesn't need a
   `<category> <#>`__ with the
   ``DEFAULT`` value—which you usually see in ``<activity>`` elements—because
   the system delivers the ``ACTION_SEARCH`` intent explicitly to your
   searchable activity using its component name.

   .. rubric:: Perform a search
      :name: PerformingSearch

   After you declare your searchable activity in the manifest, follow this
   procedure to perform a search in your searchable activity:

   #. `Receive the query <#ReceivingTheQuery>`__.
   #. `Search your data <#SearchingYourData>`__.
   #. `Present the results <#PresentingTheResults>`__.

   .. rubric:: Receive the query
      :name: ReceivingTheQuery

   When a user executes a search from the search dialog or widget, the system
   starts your searchable activity and sends it an ``ACTION_SEARCH`` intent.
   This intent carries the search query in the ``QUERY`` string extra. Check for
   this intent when the activity starts and extract the string. For example,
   here's how you can get the search query when your searchable activity starts:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   setContentView(R.layout.search)

                   // Verify the action and get the query.
                   if (Intent.ACTION_SEARCH == intent.action) {
                       intent.getStringExtra(SearchManager.QUERY)?.also { query ->
                           doMySearch(query)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   setContentView(R.layout.search);

                   // Get the intent, verify the action, and get the query.
                   Intent intent = getIntent();
                   if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
                     String query = intent.getStringExtra(SearchManager.QUERY);
                     doMySearch(query);
                   }
               }

   The ``QUERY`` string is always included with the ``ACTION_SEARCH`` intent. In
   the preceding example, the query is retrieved and passed to a local
   ``doMySearch()`` method where the actual search operation is done.

   .. rubric:: Search your data
      :name: SearchingYourData

   The process of storing and searching your data is unique to your app. You can
   store and search your data in many ways, and this document doesn't show you
   how. Consider how you store and search your data in terms of your needs and
   your data format. The following are tips you might be able to apply:

   -  If your data is stored in a SQLite database on the device, performing a
      full-text search—using FTS3, rather than a ``LIKE`` query—can provide a
      more robust search across text data and can produce results significantly
      faster. See `sqlite.org <http://sqlite.org/fts3.html>`__ for information
      about FTS3 and the
      `SQLiteDatabase <#android.database.sqlite.SQLiteDatabase>`__
      class for information about SQLite on Android.
   -  If your data is stored online, then the perceived search performance might
      be inhibited by the user's data connection. You might want to display a
      progress indicator until your search returns. See
      `android.net <#android.net.package-summary>`__ for a
      reference of network APIs and
      `ProgressBar <#android.widget.ProgressBar>`__ for
      information about how to display a progress indicator.

   **Note:** If you plan to use a local database, see `Save data in a local database using Room <#>`__.

   .. rubric:: Present the results
      :name: PresentingTheResults

   Regardless of where your data lives and how you search it, we recommend that
   you return search results to your searchable activity with an
   `Adapter <#android.widget.Adapter>`__. This way, you can
   present all the search results in a
   `RecyclerView <#>`__. If your data
   comes from a SQLite database query, you can apply your results to a
   ``RecyclerView`` using a
   `CursorAdapter <#android.widget.CursorAdapter>`__. If your data
   comes in a different format, then you can create an extension of
   `BaseAdapter <#android.widget.BaseAdapter>`__.

   An ``Adapter`` binds each item from a set of data into a
   `View <#android.view.View>`__ object. When the ``Adapter`` is
   applied to a ``RecyclerView``, each piece of data is inserted as an
   individual view into the list. ``Adapter`` is just an interface, so
   implementations such as ``CursorAdapter``—for binding data from a
   `Cursor <#android.database.Cursor>`__—are needed. If none of
   the existing implementations work for your data, then you can implement your
   own from ``BaseAdapter``.

   .. rubric:: Use the search dialog
      :name: SearchDialog

   The search dialog provides a floating search box at the top of the screen,
   with the app icon on the left. The search dialog can provide search
   suggestions as the user types. When the user executes a search, the system
   sends the search query to a searchable activity that performs the search.

   By default, the search dialog is always hidden until the user activates it.
   Your app can activate the search dialog by calling ``onSearchRequested()``.
   However, this method doesn't work until you enable the search dialog for the
   activity.

   To enable the search dialog to perform searches, indicate to the system which
   searchable activity must receive search queries from the search dialog. For
   example, in the preceding section about `creating a searchable activity <#SearchableActivity>`__, a searchable activity named
   ``SearchableActivity`` is created. If you want a separate activity, such as
   one named ``OtherActivity``, to show the search dialog and deliver searches
   to ``SearchableActivity``, declare in the manifest that
   ``SearchableActivity`` is the searchable activity to use for the search
   dialog in ``OtherActivity``.

   To declare the searchable activity for an activity's search dialog, add a
   ``<meta-data>`` element inside the respective activity's ``<activity>``
   element. The ``<meta-data>`` element must include the ``android:value``
   attribute that specifies the searchable activity's class name and the
   ``android:name`` attribute with a value of
   ``"android.app.default_searchable"``.

   For example, here is the declaration for both a searchable activity,
   ``SearchableActivity``, and another activity, ``OtherActivity``, which uses
   ``SearchableActivity`` to perform searches executed from its search dialog:

   .. code:: prettyprint

      <application ... >
          <!-- This is the searchable activity; it performs searches. -->
          <activity android:name=".SearchableActivity" >
              <intent-filter>
                  <action android:name="android.intent.action.SEARCH" />
              </intent-filter>
              <meta-data android:name="android.app.searchable"
                         android:resource="@xml/searchable"/>
          </activity>

          <!-- This activity enables the search dialog to initiate searches
               in the SearchableActivity. -->
          <activity android:name=".OtherActivity" ... >
              <!-- Enable the search dialog to send searches to SearchableActivity. -->
              <meta-data android:name="android.app.default_searchable"
                         android:value=".SearchableActivity" />
          </activity>
          ...
      </application>

   Because ``OtherActivity`` now includes a ``<meta-data>`` element to declare
   which searchable activity to use for searches, the activity enables the
   search dialog. Although the user is in this activity, the
   ``onSearchRequested()`` method activates the search dialog. When the user
   executes the search, the system starts ``SearchableActivity`` and delivers it
   the ``ACTION_SEARCH`` intent.

   **Note:** The searchable activity itself provides the search dialog by
   default, so you don't need to add this declaration to ``SearchableActivity``.
   If you want every activity in your app to provide the search dialog, insert
   the preceding ``<meta-data>`` element as a child of the
   `<application> <#>`__ element,
   instead of each ``<activity>``. This way, every activity inherits the value,
   provides the search dialog, and delivers searches to the same searchable
   activity. If you have multiple searchable activities, you can override the
   default searchable activity by placing a different ``<meta-data>``
   declaration inside individual activities.

   With the search dialog now enabled for your activities, your app is ready to
   perform searches.

   .. rubric:: Invoke the search dialog
      :name: InvokingTheSearchDialog

   Although some devices provide a dedicated search button, the behavior of the
   button might vary between devices, and many devices don't provide a search
   button at all. So when using the search dialog, you must provide a search
   button in your UI that activates the search dialog by calling
   ``onSearchRequested()``.

   For example, add a search button in your `options menu <#options-menu>`__ or UI layout that calls
   ``onSearchRequested()``.

   **Note:** If your app uses an `app bar <#>`__, then don't use
   the search dialog for your search interface. Instead, use the `search widget <#UsingSearchWidget>`__ as a collapsible view in the app bar.
   You can also enable "type-to-search" functionality, which activates the
   search dialog when the user starts typing on the keyboard. The keystrokes are
   inserted into the search dialog. You can enable type-to-search in your
   activity by calling
   `setDefaultKeyMode <#android.app.Activity>`__—or
   `DEFAULT_KEYS_SEARCH_LOCAL <#android.app.Activity>`__—during
   your activity's
   `onCreate() <#android.app.Activity>`__
   method.

   .. rubric:: The impact of the search dialog on your activity lifecycle
      :name: LifeCycle

   The search dialog is a `Dialog <#android.app.Dialog>`__ that
   floats at the top of the screen. It doesn't cause any change in the activity
   stack, so when the search dialog appears, no lifecycle methods—such as
   `onPause() <#android.app.Activity>`__—are called.
   Your activity loses input focus, because input focus is given to the search
   dialog.

   If you want to be notified when the search dialog is activated, override the
   ``onSearchRequested()`` method. When the system calls this method, it is an
   indication that your activity loses input focus to the search dialog, so you
   can do any work appropriate for the event, such as pausing a game. Unless you
   are `passing search context data <#SearchContextData>`__—discussed in another
   section of this document—end the method by calling the superclass
   implementation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onSearchRequested(): Boolean {
                   pauseSomeStuff()
                   return super.onSearchRequested()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onSearchRequested() {
                   pauseSomeStuff();
                   return super.onSearchRequested();
               }

   If the user cancels search by tapping the Back button, the search dialog
   closes and the activity regains input focus. You can register to be notified
   when the search dialog is closed with
   `setOnDismissListener() <#android.app.SearchManager>`__,
   `setOnCancelListener() <#android.app.SearchManager>`__,
   or both. You only need to register the
   `OnDismissListener <#android.app.SearchManager.OnDismissListener>`__,
   because it is called every time the search dialog closes. The
   `OnCancelListener <#android.app.SearchManager.OnCancelListener>`__
   only pertains to events in which the user explicitly exits the search dialog,
   so it's not called when a search is executed. When the search is executed,
   the search dialog automatically disappears.

   If the current activity isn't the searchable activity, then the normal
   activity lifecycle events are triggered when the user executes a search—the
   current activity receives ``onPause()``, as described in `Introduction to activities <#Lifecycle>`__. However, if the
   current activity is the searchable activity, then one of two things happens:

   -  By default, the searchable activity receives the ``ACTION_SEARCH`` intent
      with a call to ``onCreate()``, and a new instance of the activity is
      brought to the top of the activity stack. There are now two instances of
      your searchable activity in the activity stack, so tapping the Back button
      takes you back to the previous instance of the searchable activity, rather
      than exiting the searchable activity.

   -  If you set ``android:launchMode`` to ``"singleTop"``, then the searchable
      activity receives the ``ACTION_SEARCH`` intent with a call to
      `onNewIntent(Intent) <#android.app.Activity>`__,
      passing the new ``ACTION_SEARCH`` intent. For example, here's how you
      might handle this case, in which the searchable activity's launch mode is
      ``"singleTop"``:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  override fun onCreate(savedInstanceState: Bundle?) {
                      super.onCreate(savedInstanceState)
                      setContentView(R.layout.search)
                      handleIntent(intent)
                  }

                  override fun onNewIntent(intent: Intent) {
                      super.onNewIntent(intent)
                      setIntent(intent)
                      handleIntent(intent)
                  }

                  private fun handleIntent(intent: Intent) {
                      if (Intent.ACTION_SEARCH == intent.action) {
                          intent.getStringExtra(SearchManager.QUERY)?.also { query ->
                              doMySearch(query)
                          }
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  @Override
                  public void onCreate(Bundle savedInstanceState) {
                      super.onCreate(savedInstanceState);
                      setContentView(R.layout.search);
                      handleIntent(getIntent());
                  }

                  @Override
                  protected void onNewIntent(Intent intent) {
                      super.onNewIntent(intent);
                      setIntent(intent);
                      handleIntent(intent);
                  }

                  private void handleIntent(Intent intent) {
                      if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
                        String query = intent.getStringExtra(SearchManager.QUERY);
                        doMySearch(query);
                      }
                  }

      Compared to the example code in the section about `performing a search <#PerformingSearch>`__, all the code to handle the search intent is
      now in the ``handleIntent()`` method, so that both ``onCreate()`` and
      ``onNewIntent()`` can execute it.

      When the system calls ``onNewIntent(Intent)``, the activity isn't
      restarted, so the
      `getIntent() <#android.app.Activity>`__ method
      returns the same intent that is received with ``onCreate()``. This is why
      you must call
      `setIntent(Intent) <#android.app.Activity>`__
      inside ``onNewIntent(Intent)``: so that the intent saved by the activity
      is updated in case you call ``getIntent()`` in the future.

   The second scenario, using ``"singleTop"`` launch mode, is usually
   preferable, because after a search is done, the user might perform additional
   searches, and you don't want your app to create multiple instances of the
   searchable activity. We recommend that you set your searchable activity to
   ``"singleTop"`` launch mode in the app manifest, as shown in the following
   example:

   .. code:: prettyprint

      <activity android:name=".SearchableActivity"
                android:launchMode="singleTop" >
          <intent-filter>
              <action android:name="android.intent.action.SEARCH" />
          </intent-filter>
          <meta-data
                android:name="android.app.searchable"
                android:resource="@xml/searchable"/>
        </activity>

   .. rubric:: Pass search context data
      :name: SearchContextData

   In some cases, you can make necessary refinements to the search query inside
   the searchable activity for every search made. However, if you want to refine
   your search criteria based on the activity from which the user is performing
   a search, you can provide additional data in the intent that the system sends
   to your searchable activity. You can pass the additional data in the
   `APP_DATA <#android.app.SearchManager>`__
   `Bundle <#android.os.Bundle>`__, which is included in the
   ``ACTION_SEARCH`` intent.

   To pass this kind of data to your searchable activity, override the
   ``onSearchRequested()`` method for the activity from which the user can
   perform a search, create a ``Bundle`` with the additional data, and call
   `startSearch() <#android.app.Activity>`__
   to activate the search dialog. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onSearchRequested(): Boolean {
                   val appData = Bundle().apply {
                       putBoolean(JARGON, true)
                   }
                   startSearch(null, false, appData, false)
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onSearchRequested() {
                    Bundle appData = new Bundle();
                    appData.putBoolean(SearchableActivity.JARGON, true);
                    startSearch(null, false, appData, false);
                    return true;
                }

   Returning true indicates that you successfully handle this callback event and
   call ``startSearch()`` to activate the search dialog. After the user submits
   a query, it is delivered to your searchable activity along with the data you
   add. You can extract the extra data from the ``APP_DATA`` ``Bundle`` to
   refine the search, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val jargon: Boolean = intent.getBundleExtra(SearchManager.APP_DATA)?.getBoolean(JARGON) ?: false

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Bundle appData = getIntent().getBundleExtra(SearchManager.APP_DATA);
               if (appData != null) {
                   boolean jargon = appData.getBoolean(SearchableActivity.JARGON);
               }

   **Caution:** Never call the ``startSearch()`` method from outside the
   ``onSearchRequested()`` callback method. To activate the search dialog in
   your activity, always call ``onSearchRequested()``. Otherwise,
   ``onSearchRequested()`` isn't called and customizations—such as the addition
   of ``appData`` in the preceding example—are missed.

   .. rubric:: Use the search widget
      :name: UsingSearchWidget

   .. container:: attempt-right

      |An image showing a search view in the app top bar|
      **Figure 1.** The ``SearchView``\ widget as an action view in the app bar.

   The search widget provides the same functionality as the search dialog. It
   starts the appropriate activity when the user executes a search, and it can
   provide search suggestions and perform voice search. If it's not an option
   for you to put the search widget in the app bar, you can instead put the
   search widget somewhere in your activity layout.

   **Note:** When you use the search widget as an action view, you still might
   need to support using the search dialog for cases when the search widget
   doesn't fit in the app bar. See the section about `using both the widget and the dialog <#UsingBoth>`__.

   .. rubric:: Configure the search widget
      :name: ConfiguringWidget

   After you create a `search configuration <#SearchableConfiguration>`__ and a
   `searchable activity <#SearchableActivity>`__, enable assisted search for
   each ``SearchView`` by calling
   `setSearchableInfo() <#android.widget.SearchView>`__
   and passing it the ``SearchableInfo`` object that represents your searchable
   configuration.

   You can get a reference to the ``SearchableInfo`` by calling
   `getSearchableInfo() <#android.app.SearchManager>`__
   on `SearchManager <#android.app.SearchManager>`__.

   For example, if you're using a ``SearchView`` as an action view in the app
   bar, enable the widget during the
   `onCreateOptionsMenu() <#android.app.Activity>`__
   callback, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateOptionsMenu(menu: Menu): Boolean {
                   // Inflate the options menu from XML.
                   val inflater = menuInflater
                   inflater.inflate(R.menu.options_menu, menu)

                   // Get the SearchView and set the searchable configuration.
                   val searchManager = getSystemService(Context.SEARCH_SERVICE) as SearchManager
                   (menu.findItem(R.id.menu_search).actionView as SearchView).apply {
                       // Assumes current activity is the searchable activity.
                       setSearchableInfo(searchManager.getSearchableInfo(componentName))
                       setIconifiedByDefault(false) // Don't iconify the widget. Expand it by default.
                   }

                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onCreateOptionsMenu(Menu menu) {
                   // Inflate the options menu from XML.
                   MenuInflater inflater = getMenuInflater();
                   inflater.inflate(R.menu.options_menu, menu);

                   // Get the SearchView and set the searchable configuration.
                   SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
                   SearchView searchView = (SearchView) menu.findItem(R.id.menu_search).getActionView();
                   // Assumes current activity is the searchable activity.
                   searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));
                   searchView.setIconifiedByDefault(false); // Don't iconify the widget. Expand it by default.

                   return true;
               }

   The search widget is now configured, and the system delivers search queries
   to your searchable activity. You can also enable `search suggestions <#SearchSuggestions>`__ for the search widget.

   **Note:** If you want to handle all user input yourself, you can do so with
   some callback methods and event listeners. For more information, see the
   reference documentation for ``SearchView`` and its nested interfaces.
   For more information about action views in the app bar, see `Use action views and action providers <#>`__.

   .. rubric:: Other search widget features
      :name: WidgetFeatures

   The ``SearchView`` widget provides a few additional features you might want:

   A submit button
      By default, there's no button to submit a search query, so the user has to
      press the Return key on the keyboard to initiate a search. You can add a
      "submit" button by calling
      `setSubmitButtonEnabled(true) <#android.widget.SearchView>`__.
   Query refinement for search suggestions
      When you enable search suggestions, you usually expect users to select a
      suggestion, but they might also want to refine the suggested search query.
      You can add a button alongside each suggestion that inserts the suggestion
      in the search box for refinement by the user by calling
      `setQueryRefinementEnabled(true) <#android.widget.SearchView>`__.
   The ability to toggle search box visibility
      By default, the search widget is "iconified," meaning that it is
      represented only by a search icon—a magnifying glass. It expands to show
      the search box when the user taps the icon. As shown in the preceding
      example, you can show the search box by default by calling
      `setIconifiedByDefault(false) <#android.widget.SearchView>`__.
      You can also toggle the search widget appearance by calling
      `setIconified() <#android.widget.SearchView>`__.

   There are several other APIs in the ``SearchView`` class that let you
   customize the search widget. However, most of them are used only when you
   handle all user input yourself, instead of using the Android system to
   deliver search queries and display search suggestions.

   .. rubric:: Use both the widget and the dialog
      :name: UsingBoth

   If you insert the search widget in the app bar as an `action view <#ActionView>`__ and enable it to appear in
   the app bar if there is room—by setting
   ``android:showAsAction="ifRoom"``—then the search widget might not appear as
   an action view. Instead, a menu item might appear in the overflow menu. For
   example, when your app runs on a smaller screen, there might not be enough
   room in the app bar to display the search widget along with other action
   items or navigation elements, so the menu item instead appears in the
   overflow menu. When placed in the overflow menu, the item works like an
   ordinary menu item and doesn't display the action view—that is, the search
   widget.

   To handle this situation, the menu item to which you attach the search widget
   must activate the search dialog when the user selects it from the overflow
   menu. To make this happen, implement
   `onOptionsItemSelected() <#android.app.Activity>`__
   to handle the "Search" menu item and open the search dialog by calling
   ``onSearchRequested()``.

   For more information about how items in the app bar work and how to handle
   this situation, see `Add the app bar <#>`__.

   .. rubric:: Add voice search
      :name: VoiceSearch

   You can add voice search functionality to your search dialog or widget by
   adding the ``android:voiceSearchMode`` attribute to your searchable
   configuration. This adds a voice search button that launches a voice prompt.
   When the user finishes speaking, the transcribed search query is sent to your
   searchable activity.

   This is shown in the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <searchable xmlns:android="http://schemas.android.com/apk/res/android"
          android:label="@string/search_label"
          android:hint="@string/search_hint"
          android:voiceSearchMode="showVoiceSearchButton|launchRecognizer" >
      </searchable>

   The value ``showVoiceSearchButton`` is required to enable voice search. The
   second value, ``launchRecognizer``, specifies that the voice search button
   must launch a *recognizer* that returns the transcribed text to the
   searchable activity.

   You can provide additional attributes to specify the voice search behavior,
   such as the expected language and the maximum number of results to return.
   See the `Search configuration <#>`__
   reference for more information about the available attributes.

   **Note:** Carefully consider whether voice search is appropriate for your
   app. Searches performed with the voice search button are immediately sent to
   your searchable activity, without a chance for the user to review the
   transcribed query. Test the voice recognition and ensure that it understands
   the types of queries that the user might submit in your app.

   .. rubric:: Add search suggestions
      :name: SearchSuggestions

   Both the search dialog and the search widget can provide search suggestions
   as the user types, with assistance from the Android system. The system
   manages the list of suggestions and handles the event when the user selects a
   suggestion.

   You can provide two kinds of search suggestions:

   Recent query search suggestions
      These suggestions are words that the user previously used as search
      queries in your app. See `Add custom search suggestions <#>`__
      for more information.
   Custom search suggestions
      These are search suggestions that you provide from your own data source to
      help users immediately select the correct spelling or item they are
      searching for. See `Add custom search suggestions <#>`__ for
      more information.


Last updated 2024-02-22 UTC.

.. |An image showing a search view in the app top bar| image:: https://developer.android.google.cn/static/images/ui/search-ui-topbar-33.png


/Add search results from recent queries
=======================================

.. https://developer.android.google.cn/develop/ui/views/search/adding-recent-query-suggestions?hl=en

.. container:: devsite-article-body

   You can provide search suggestions based on recent search queries in the
   Android search dialog or search widget. For example, if a user queries
   "puppies," the query appears as a suggestion when they type the same query
   again. Figure 1 shows an example of a search dialog with recent query
   suggestions.

   Before you begin, implement the search dialog or a search widget for basic
   searches in your application. To learn how, see `Create a search interface <#>`__.

   .. rubric:: The basics
      :name: TheBasics

   .. container:: attempt-right

      |image-search-suggest-recent-queries|
      **Figure 1.** Screenshot of a search dialog with recent query suggestions.

   Recent query suggestions are saved searches. When the user selects a
   suggestion, your searchable activity receives an
   `ACTION_SEARCH <#android.content.Intent>`__
   intent with the suggestion as the search query that your searchable activity
   already handles.

   To provide recent queries suggestions, you need to:

   -  Implement a searchable activity.
   -  Create a content provider that extends
      `SearchRecentSuggestionsProvider <#android.content.SearchRecentSuggestionsProvider>`__
      and declare it in your application manifest.
   -  Modify the searchable configuration with information about the content
      provider that provides search suggestions.
   -  Save queries to your content provider each time a search is executed.

   Just as the Android system displays the search dialog, it displays the search
   suggestions below the dialog or search widget. You provide the source the
   system retrieves the suggestions from.

   When the system identifies that your activity is searchable and provides
   search suggestions, the following happens when the user types a query:

   #. The system takes the search query text—whatever the user begins typing—and
      performs a query to the content provider that contains your suggestions.
   #. Your content provider returns a
      `Cursor <#android.database.Cursor>`__ that points to all
      suggestions that match the search query text.
   #. The system displays the list of suggestions provided by the ``Cursor``.

   Once the recent query suggestions are displayed, the following might happen:

   -  If the user types another key or changes the query in any way, the
      preceding steps are repeated and the suggestion list is updated.
   -  If the user executes the search, the suggestions are ignored and the
      search is delivered to your searchable activity using the normal
      ``ACTION_SEARCH`` intent.
   -  If the user selects a suggestion, an ``ACTION_SEARCH`` intent is delivered
      to your searchable activity using the suggested text as the query.

   The ``SearchRecentSuggestionsProvider`` class that you extend for your
   content provider automatically does the work in the preceding steps, so
   there's little code to write.

   .. rubric:: Create a content provider
      :name: RecentQueryContentProvider

   The content provider you need for recent query suggestions is an
   implementation of ``SearchRecentSuggestionsProvider``. This class does
   everything for you. You just need to write a class constructor that executes
   one line of code.

   For example, here's a complete implementation of a content provider for
   recent query suggestions:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MySuggestionProvider : SearchRecentSuggestionsProvider() {
                   init {
                       setupSuggestions(AUTHORITY, MODE)
                   }

                   companion object {
                       const val AUTHORITY = "com.example.MySuggestionProvider"
                       const val MODE: Int = SearchRecentSuggestionsProvider.DATABASE_MODE_QUERIES
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MySuggestionProvider extends SearchRecentSuggestionsProvider {
                   public final static String AUTHORITY = "com.example.MySuggestionProvider";
                   public final static int MODE = DATABASE_MODE_QUERIES;

                   public MySuggestionProvider() {
                       setupSuggestions(AUTHORITY, MODE);
                   }
               }

   The call to
   `setupSuggestions() <#android.content.SearchRecentSuggestionsProvider>`__
   passes the name of the search authority and a database mode. The search
   authority can be any unique string, but the best practice is to use a fully
   qualified name for your content provider, such as the package name followed
   by the provider's class name. For example,
   ``"com.example.MySuggestionProvider"``.

   The database mode must include
   `DATABASE_MODE_QUERIES <#android.content.SearchRecentSuggestionsProvider>`__
   and can optionally include
   `DATABASE_MODE_2LINES <#android.content.SearchRecentSuggestionsProvider>`__,
   which adds a column to the suggestions table so you can provide a second line
   of text with each suggestion. If you want to provide two lines in each
   suggestion, see the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               const val MODE: Int = DATABASE_MODE_QUERIES or DATABASE_MODE_2LINES

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public final static int MODE = DATABASE_MODE_QUERIES | DATABASE_MODE_2LINES;

   Declare the content provider in your application manifest with the same
   authority string used in your ``SearchRecentSuggestionsProvider`` class and
   in the searchable configuration. For example:

   .. code:: prettyprint

      <application>
          <provider android:name=".MySuggestionProvider"
                    android:authorities="com.example.MySuggestionProvider" />
          ...
      </application>

   .. rubric:: Modify the searchable configuration
      :name: RecentQuerySearchableConfiguration

   To configure the system to use your suggestions provider, add the
   ``android:searchSuggestAuthority`` and ``android:searchSuggestSelection``
   attributes to the ``<searchable>`` element in your searchable configuration
   file. For example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <searchable xmlns:android="http://schemas.android.com/apk/res/android"
          android:label="@string/app_label"
          android:hint="@string/search_hint"
          android:searchSuggestAuthority="com.example.MySuggestionProvider"
          android:searchSuggestSelection=" ?" >
      </searchable>

   The value for ``android:searchSuggestAuthority`` must be a fully qualified
   name for your content provider that exactly matches the authority used in the
   content provider, such as ``"com.example.MySuggestionProvider"`` in the
   preceding examples.

   The value for ``android:searchSuggestSelection`` must be a single question
   mark preceded by a space: ``" ?"``. This is a placeholder for the SQLite
   selection argument, and it is automatically replaced by the query text
   entered by the user.

   .. rubric:: Save queries
      :name: SavingQueries

   To populate your collection of recent queries, add each query received by
   your searchable activity to your ``SearchRecentSuggestionsProvider``. To do
   this, create an instance of
   `SearchRecentSuggestions <#android.provider.SearchRecentSuggestions>`__
   and call
   `saveRecentQuery() <#android.provider.SearchRecentSuggestions>`__
   each time your searchable activity receives a query. For example, here's how
   you can save the query during your activity's
   `onCreate() <#android.app.Activity>`__
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   setContentView(R.layout.main)

                   if (Intent.ACTION_SEARCH == intent.action) {
                       intent.getStringExtra(SearchManager.QUERY)?.also { query ->
                           SearchRecentSuggestions(this, MySuggestionProvider.AUTHORITY, MySuggestionProvider.MODE)
                                   .saveRecentQuery(query, null)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreate(Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   setContentView(R.layout.main);

                   Intent intent  = getIntent();

                   if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
                       String query = intent.getStringExtra(SearchManager.QUERY);
                       SearchRecentSuggestions suggestions = new SearchRecentSuggestions(this,
                               MySuggestionProvider.AUTHORITY, MySuggestionProvider.MODE);
                       suggestions.saveRecentQuery(query, null);
                   }
               }

   The ``SearchRecentSuggestionsProvider`` constructor requires the same
   authority and database mode declared by your content provider.

   The ``saveRecentQuery()`` method takes the search query string as the first
   parameter and, optionally, a second string to include as the second line of
   the suggestion or null. The second parameter is only used if you enable
   two-line mode for the search suggestions with ``DATABASE_MODE_2LINES``. If
   you enable two-line mode, then the query text matches against the second line
   when the system looks for matching suggestions.

   .. rubric:: Clear the suggestion data
      :name: ClearingSuggestionData

   To protect the user's privacy, always provide a way for the user to clear the
   recent query suggestions. To clear the query history, call
   `clearHistory() <#android.provider.SearchRecentSuggestions>`__.
   For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               SearchRecentSuggestions(this, HelloSuggestionsProvider.AUTHORITY, HelloSuggestionsProvider.MODE)
                       .clearHistory()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SearchRecentSuggestions suggestions = new SearchRecentSuggestions(this,
                       HelloSuggestionProvider.AUTHORITY, HelloSuggestionProvider.MODE);
               suggestions.clearHistory();

   Execute this from your choice of a "Clear Search History" menu item,
   preference item, or button. Provide a confirmation dialog to verify that the
   user wants to delete their search history.


Last updated 2024-02-22 UTC.

.. |image-search-suggest-recent-queries| image:: https://developer.android.google.cn/static/images/search/search-suggest-recent-queries.png
   :height: 417px


/Add custom search results
==========================

.. https://developer.android.google.cn/develop/ui/views/search/adding-custom-suggestions?hl=en

.. container:: devsite-article-body

   When using the Android search dialog or search widget, you can provide custom
   search suggestions that are created from data in your app. For example, if
   your app is a dictionary, you can suggest words from the dictionary that
   match the text entered in the search field before the user finishes entering
   their query. These suggestions are valuable because they can effectively
   predict what the user wants and provide instant access to it. Figure 1 shows
   an example of a search dialog with custom suggestions.

   Once you provide custom suggestions, you can also make them available to the
   system-wide Quick Search Box, providing access to your content from outside
   your app.

   Before you add custom suggestions, implement the Android search dialog or a
   search widget for searches in your app. See `Create a search interface <#>`__ and `Content providers <#>`__.

   .. rubric:: The basics
      :name: TheBasics

   .. container:: attempt-right

      |image-search-suggest-custom|
      **Figure 1.** Screenshot of a search dialog with custom search
      suggestions.

   When the user selects a custom suggestion, the system sends an
   `Intent <#android.content.Intent>`__ to your searchable
   activity. Unlike a normal search query that sends an intent with the
   `ACTION_SEARCH <#android.content.Intent>`__
   action, you can instead define your custom suggestions to use
   `ACTION_VIEW <#android.content.Intent>`__—or any
   other intent action—and also include data that's relevant to the selected
   suggestion. In the dictionary example, when the user selects a suggestion,
   the app can immediately open the definition for that word, instead of
   searching the dictionary for matches.

   To provide custom suggestions, perform the following steps:

   -  Implement a basic searchable activity, as described in `Create a search interface <#>`__.
   -  Modify the searchable configuration with information about the content
      provider that provides custom suggestions.
   -  Build a table, such as in a
      `SQLiteDatabase <#android.database.sqlite.SQLiteDatabase>`__,
      for your suggestions and format the table with required columns.
   -  Create a `content provider <#>`__
      that has access to your suggestions table and declare the provider in your
      manifest.
   -  Declare the type of ``Intent`` to be sent when the user selects a
      suggestion, including a custom action and custom data.

   Just as the Android system displays the search dialog, it also displays your
   search suggestions. You need a content provider from which the system can
   retrieve your suggestions. Read `Content providers <#>`__ to learn how to
   create a content provider.

   When the system identifies that your activity is searchable and provides
   search suggestions, the following procedure takes place when the user enters
   a query:

   #. The system takes the search query text—meaning, whatever is entered so
      far—and performs a query to your content provider that manages your
      suggestions.
   #. Your content provider returns a
      `Cursor <#android.database.Cursor>`__ that points to all
      suggestions that are relevant to the search query text.
   #. The system displays the list of suggestions provided by the ``Cursor``.

   Once the custom suggestions are displayed, the following might happen:

   -  If the user enters another letter or changes the query in any way, the
      preceding steps repeat and the suggestion list updates accordingly.
   -  If the user executes the search, the suggestions are ignored and the
      search is delivered to your searchable activity using the normal
      ``ACTION_SEARCH`` intent.
   -  If the user selects a suggestion, an intent is sent to your searchable
      activity, carrying a custom action and custom data so that your app can
      open the suggested content.

   .. rubric:: Modify the searchable configuration
      :name: CustomSearchableConfiguration

   To add support for custom suggestions, add the
   ``android:searchSuggestAuthority`` attribute to the ``<searchable>`` element
   in your searchable configuration file, as shown in the following example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <searchable xmlns:android="http://schemas.android.com/apk/res/android"
          android:label="@string/app_label"
          android:hint="@string/search_hint"
          android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider">
      </searchable>

   You might need additional attributes, depending on the type of intent you
   attach to each suggestion and how you want to format queries to your content
   provider. The other optional attributes are discussed in the following
   sections.

   .. rubric:: Create a content provider
      :name: CustomContentProvider

   To create a content provider for custom suggestions, first see `Content providers <#>`__ to learn how to
   create a content provider. A content provider for custom suggestions is
   similar to any other content provider. However, for each suggestion you
   provide, the respective row in the ``Cursor`` must include specific columns
   that the system understands and uses to format the suggestions.

   When the user enters text in the search dialog or search widget, the system
   queries your content provider for suggestions by calling
   `query() <#android.content.ContentProvider>`__
   each time a letter is entered. In your implementation of ``query()``, your
   content provider must search your suggestion data and return a ``Cursor``
   that points to the rows that it determines are good suggestions.

   Details about creating a content provider for custom suggestions are
   discussed in the following two sections:

   `Handle the suggestion query <#HandleSuggestionQuery>`__
      How the system sends requests to your content provider and how to handle
      them.
   `Build a suggestion table <#SuggestionTable>`__
      How to define the columns that the system expects in the ``Cursor``
      returned with each query.

   .. rubric:: Handle the suggestion query
      :name: HandleSuggestionQuery

   When the system requests suggestions from your content provider, it calls
   your content provider's ``query()`` method. Implement this method to search
   your suggestion data and return a ``Cursor`` pointing to the suggestions you
   deem relevant.

   Here's a summary of the parameters the system passes to your ``query()``
   method, listed in order:

   ``uri``

   Always a content `Uri <#android.net.Uri>`__, formatted as
   follows:

   .. code:: none

      content://your.authority/optional.suggest.path/SUGGEST_URI_PATH_QUERY

   The default behavior is for the system to pass this URI and append the query
   text to it:

   .. code:: none

      content://your.authority/optional.suggest.path/SUGGEST_URI_PATH_QUERY/puppies

   The query text on the end is encoded using URI encoding rules, so you might
   need to decode it before performing a search.

   The *``optional.suggest.path``* portion is only included in the URI if you
   set such a path in your searchable configuration file with the
   ``android:searchSuggestPath`` attribute. It's only necessary if you use the
   same content provider for multiple searchable activities. If this is the
   case, disambiguate the source of the suggestion query.

   **Note:** ``SUGGEST_URI_PATH_QUERY`` isn't the literal string provided in the
   URI; it is a constant. Use it if you need to refer to this path.
   ``projection``
   Always null.
   ``selection``
   The value provided in the ``android:searchSuggestSelection`` attribute of
   your searchable configuration file, or null if you don't declare the
   ``android:searchSuggestSelection`` attribute. The following section discusses
   this further.
   ``selectionArgs``
   Contains the search query as the first and only element of the array if you
   declare the ``android:searchSuggestSelection`` attribute in your searchable
   configuration. If you don't declare ``android:searchSuggestSelection``, then
   this parameter is null. The following section discusses this further.
   ``sortOrder``
   Always null.
   The system can send you the search query text in two ways. The default way is
   for the query text to be included as the last path of the content URI passed
   in the ``uri`` parameter. However, if you include a selection value in your
   searchable configuration's ``android:searchSuggestSelection`` attribute, then
   the query text instead passes as the first element of the ``selectionArgs``
   string array. These two options are described next.

   .. rubric:: Get the query in the Uri
      :name: GetTheQueryUri

   By default, the query is appended as the last segment of the ``uri``
   parameter—a ``Uri`` object. To retrieve the query text in this case, use
   `getLastPathSegment() <#android.net.Uri>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val query: String = uri.lastPathSegment.toLowerCase()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String query = uri.getLastPathSegment().toLowerCase();

   This returns the last segment of the ``Uri``, which is the query text the
   user enters.

   .. rubric:: Get the query in the selection arguments
      :name: GetTheQuery

   Instead of using the URI, it might make more sense for your ``query()``
   method to receive everything it needs to perform the look-up, and you might
   want the ``selection`` and ``selectionArgs`` parameters to carry the
   appropriate values. In this case, add the ``android:searchSuggestSelection``
   attribute to your searchable configuration with your SQLite selection string.
   In the selection string, include a question mark (*?*) as a placeholder for
   the actual search query. The system calls ``query()`` with the selection
   string as the ``selection`` parameter and the search query as the first
   element in the ``selectionArgs`` array.

   For example, here's how you might form the ``android:searchSuggestSelection``
   attribute to create a full-text search statement:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <searchable xmlns:android="http://schemas.android.com/apk/res/android"
          android:label="@string/app_label"
          android:hint="@string/search_hint"
          android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
          android:searchSuggestIntentAction="android.intent.action.VIEW"
          android:searchSuggestSelection="word MATCH ?">
      </searchable>

   With this configuration, your ``query()`` method delivers the ``selection``
   parameter as ``"word MATCH ?"`` and the ``selectionArgs`` parameter as the
   search query. When you pass these to a SQLite
   `query() <#android.database.sqlite.SQLiteDatabaseery>`__
   method, as their respective arguments, they are synthesized together—meaning,
   the question mark is replaced with the query text. If you receive suggestion
   queries this way and need to add wildcards to the query text, append or
   prefix them to the ``selectionArgs`` parameter, because this value is wrapped
   in quotes and inserted in place of the question mark.

   Another attribute in the preceding example is
   ``android:searchSuggestIntentAction``, which defines the intent action sent
   with each intent when the user selects a suggestion. This is discussed
   further in the `Declare an intent for suggestions <#IntentForSuggestions>`__
   section.

   **Tip:** If you don't want to define a selection clause in the
   ``android:searchSuggestSelection`` attribute, but you still want to receive
   the query text in the ``selectionArgs`` parameter, provide a non-null value
   for the ``android:searchSuggestSelection`` attribute. This triggers the query
   to pass in ``selectionArgs``, and you can ignore the ``selection`` parameter.
   This way, you can instead define the actual selection clause at a lower level
   so that your content provider doesn't have to handle it.

   .. rubric:: Build a suggestion table
      :name: SuggestionTable

   When you return suggestions to the system with a ``Cursor``, the system
   expects specific columns in each row. Regardless of whether you store your
   suggestion data in a SQLite database on the device, a database on a web
   server, or another format on the device or web, format the suggestions as
   rows in a table and present them with a ``Cursor``.

   **Note:** If your search suggestions aren't stored in a table format—such as
   a SQLite table—using the columns required by the system, then you can search
   your suggestion data for matches and then format them into the necessary
   table on each request. To do so, create a
   `MatrixCursor <#android.database.MatrixCursor>`__ using the
   required column names and then add a row for each suggestion using
   `addRow(Object[]) <#android.database.MatrixCursor>`__.
   Return the final product from your content provider's ``query()`` method.
   The system understands several columns, but only two of them are required:

   `_ID <#android.provider.BaseColumns>`__
      A unique integer row ID for each suggestion. The system requires this to
      present suggestions in a
      `ListView <#android.widget.ListView>`__.
   `SUGGEST_COLUMN_TEXT_1 <#android.app.SearchManager>`__
      The string that is presented as a suggestion.

   The following columns are all optional. Most are discussed further in the
   following sections.

   `SUGGEST_COLUMN_TEXT_2 <#android.app.SearchManager>`__
      A string. If your ``Cursor`` includes this column, then all suggestions
      are provided in a two-line format. The string in this column is displayed
      as a second, smaller line of text below the primary suggestion text. It
      can be null or empty to indicate no secondary text.
   `SUGGEST_COLUMN_ICON_1 <#android.app.SearchManager>`__
      A drawable resource, content, or file URI string. If your ``Cursor``
      includes this column, then all suggestions are provided in an
      icon-plus-text format with the drawable icon on the left side. This can be
      null or zero to indicate no icon in this row.
   `SUGGEST_COLUMN_ICON_2 <#android.app.SearchManager>`__
      A drawable resource, content, or file URI string. If your ``Cursor``
      includes this column, then all suggestions are provided in an
      icon-plus-text format with the icon on the right side. This can be null or
      zero to indicate no icon in this row.
   `SUGGEST_COLUMN_INTENT_ACTION <#android.app.SearchManager>`__
      An intent action string. If this column exists and contains a value at the
      given row, the action defined here is used when forming the suggestion's
      intent. If the element isn't provided, the action is taken from the
      ``android:searchSuggestIntentAction`` field in your searchable
      configuration. If your action is the same for all suggestions, it's more
      efficient to specify the action using
      ``android:searchSuggestIntentAction`` and omit this column.
   `SUGGEST_COLUMN_INTENT_DATA <#android.app.SearchManager>`__
      A data URI string. If this column exists and contains a value at the given
      row, this data is used when forming the suggestion's intent. If the
      element isn't provided, the data is taken from the
      ``android:searchSuggestIntentData`` field in your searchable
      configuration. If neither source is provided, the intent's data field is
      null. If your data is the same for all suggestions, or can be described
      using a constant part and a specific ID, it's more efficient to specify it
      using ``android:searchSuggestIntentData`` and omit this column.
   `SUGGEST_COLUMN_INTENT_DATA_ID <#android.app.SearchManager>`__
      A URI path string. If this column exists and contains a value at the given
      row, then "/" and this value is appended to the data field in the intent.
      Only use this if the data field specified by the
      ``android:searchSuggestIntentData`` attribute in the searchable
      configuration is already set to an appropriate base string.
   `SUGGEST_COLUMN_INTENT_EXTRA_DATA <#android.app.SearchManager>`__
      Arbitrary data. If this column exists and contains a value at a given row,
      this is the *extra* data used when forming the suggestion's intent. If not
      provided, the intent's extra data field is null. This column lets
      suggestions provide additional data that is included as an extra in the
      intent's
      `EXTRA_DATA_KEY <#android.app.SearchManager>`__
      key.
   `SUGGEST_COLUMN_QUERY <#android.app.SearchManager>`__
      If this column exists and this element exists at the given row, this is
      the data that is used when forming the suggestion's query, included as an
      extra in the intent's
      `QUERY <#android.app.SearchManager>`__ key. It's
      required if the suggestion's action is ``ACTION_SEARCH``, but optional
      otherwise.
   `SUGGEST_COLUMN_SHORTCUT_ID <#android.app.SearchManager>`__
      Only used when providing suggestions for Quick Search Box. This column
      indicates whether a search suggestion must be stored as a shortcut and
      whether it must be validated. Shortcuts are usually formed when the user
      taps a suggestion from Quick Search Box. If missing, the result is stored
      as a shortcut and never refreshed. If set to
      `SUGGEST_NEVER_MAKE_SHORTCUT <#android.app.SearchManager>`__,
      the result isn't stored as a shortcut. Otherwise, the shortcut ID is used
      to check back for an up-to-date suggestion using
      `SUGGEST_URI_PATH_SHORTCUT <#android.app.SearchManager>`__.
   `SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING <#android.app.SearchManager>`__
      Only used when providing suggestions for Quick Search Box. This column
      specifies that a spinner must be shown instead of an icon from
      ``SUGGEST_COLUMN_ICON_2`` while the shortcut of this suggestion is
      refreshing in Quick Search Box.

   Most of these columns are discussed further in the following sections.

   .. rubric:: Declare an intent for suggestions
      :name: IntentForSuggestions

   When the user selects a suggestion from the list that appears under the
   search dialog or widget, the system sends a custom ``Intent`` to your
   searchable activity. You must define the action and data for the intent.

   .. rubric:: Declare the intent action
      :name: IntentAction

   The most common intent action for a custom suggestion is ``ACTION_VIEW``,
   which is appropriate when you want to open something, like the definition for
   a word, a person's contact information, or a web page. However, the intent
   action can be any other action and can be different for each suggestion.

   Depending on whether you want all suggestions to use the same intent action,
   you can define the action in two ways:

   -  Use the ``android:searchSuggestIntentAction`` attribute of your searchable
      configuration file to define the action for all suggestions, as shown in
      the following example:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <searchable xmlns:android="http://schemas.android.com/apk/res/android"
             android:label="@string/app_label"
             android:hint="@string/search_hint"
             android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
             android:searchSuggestIntentAction="android.intent.action.VIEW" >
         </searchable>

   -  Use the ``SUGGEST_COLUMN_INTENT_ACTION`` column to define the action for
      individual suggestions. To do this, add the
      ``SUGGEST_COLUMN_INTENT_ACTION`` column to your suggestions table and, for
      each suggestion, place in it the action to use—such as
      ``"android.intent.action.VIEW"``.

   You can also combine these two techniques. For example, you can include the
   ``android:searchSuggestIntentAction`` attribute with an action to be used
   with all suggestions by default, then override this action for some
   suggestions by declaring a different action in the
   ``SUGGEST_COLUMN_INTENT_ACTION`` column. If you don't include a value in the
   ``SUGGEST_COLUMN_INTENT_ACTION`` column, then the intent provided in the
   ``android:searchSuggestIntentAction`` attribute is used.

   **Note:** If you don't include the ``android:searchSuggestIntentAction``
   attribute in your searchable configuration, then you *must* include a value
   in the ``SUGGEST_COLUMN_INTENT_ACTION`` column for every suggestion, or else
   the intent fails.

   .. rubric:: Declare intent data
      :name: IntentData

   When the user selects a suggestion, your searchable activity receives the
   intent with the action you define—as discussed in the previous section—but
   the intent must also carry data for your activity to identify which
   suggestion is selected. Specifically, the data must be something unique for
   each suggestion, such as the row ID for the suggestion in your SQLite table.
   When the intent is received, you can retrieve the attached data with
   `getData() <#android.content.Intent>`__ or
   `getDataString() <#android.content.Intent>`__.

   You can define the data included with the intent in two ways:

   -  Define the data for each suggestion inside the
      ``SUGGEST_COLUMN_INTENT_DATA`` column of your suggestions table.

      Provide all necessary data information for each intent in the suggestions
      table by including the ``SUGGEST_COLUMN_INTENT_DATA`` column and then
      populating it with unique data for each row. The data from this column is
      attached to the intent exactly as you define it in this column. You can
      then retrieve it with ``getData()`` or ``getDataString()``.

      **Tip**: It's usually easier to use the table's row ID as the intent data,
      because it's always unique. The easiest way to do this is by using the
      ``SUGGEST_COLUMN_INTENT_DATA`` column name as an alias for the row ID
      column.

   -  Fragment a data URI into two pieces: the portion common to all suggestions
      and the portion unique to each suggestion. Place these parts into the
      ``android:searchSuggestintentData`` attribute of the searchable
      configuration and the ``SUGGEST_COLUMN_INTENT_DATA_ID`` column of your
      suggestions table, respectively.

      The following example shows how to declare the piece of the URI that is
      common to all suggestions in the ``android:searchSuggestIntentData``
      attribute of your searchable configuration:

      .. code:: prettyprint

           <?xml version="1.0" encoding="utf-8"?>
           <searchable xmlns:android="http://schemas.android.com/apk/res/android"
               android:label="@string/app_label"
               android:hint="@string/search_hint"
               android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
               android:searchSuggestIntentAction="android.intent.action.VIEW"
               android:searchSuggestIntentData="content://com.example/datatable" >
           </searchable>
           

      Include the final path for each suggestion—the unique part—in the
      ``SUGGEST_COLUMN_INTENT_DATA_ID`` column of your suggestions table. When
      the user selects a suggestion, the system takes the string from
      ``android:searchSuggestIntentData``, appends a slash (*/*), and then adds
      the respective value from the ``SUGGEST_COLUMN_INTENT_DATA_ID`` column to
      form a complete content URI. You can then retrieve the ``Uri`` with
      ``getData()``.

   .. rubric:: Add more data
      :name: add-more-data

   If you need to express more information with your intent, you can add another
   table column, such as ``SUGGEST_COLUMN_INTENT_EXTRA_DATA``, which can store
   additional information about the suggestion. The data saved in this column is
   placed in the ``EXTRA_DATA_KEY`` of the intent's extra bundle.

   .. rubric:: Handle the intent
      :name: HandlingIntent

   After you provide custom search suggestions with custom intents, you need
   your searchable activity to handle these intents when the user selects a
   suggestion. This is in addition to handling the ``ACTION_SEARCH`` intent,
   which your searchable activity already does. Here's an example of how you can
   handle the intents during your activity's
   `onCreate() <#android.app.Activity>`__
   callback:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               when(intent.action) {
                   Intent.ACTION_SEARCH -> {
                       // Handle the normal search query case.
                       intent.getStringExtra(SearchManager.QUERY)?.also { query ->
                           doSearch(query)
                       }
                   }
                   Intent.ACTION_VIEW -> {
                       // Handle a suggestions click, because the suggestions all use ACTION_VIEW.
                       showResult(intent.data)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = getIntent();
               if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
                   // Handle the normal search query case.
                   String query = intent.getStringExtra(SearchManager.QUERY);
                   doSearch(query);
               } else if (Intent.ACTION_VIEW.equals(intent.getAction())) {
                   // Handle a suggestions click, because the suggestions all use ACTION_VIEW.
                   Uri data = intent.getData();
                   showResult(data);
               }

   In this example, the intent action is ``ACTION_VIEW`` and the data carries a
   complete URI pointing to the suggested item, as synthesized by the
   ``android:searchSuggestIntentData`` string and
   ``SUGGEST_COLUMN_INTENT_DATA_ID`` column. The URI then passes to the local
   ``showResult()`` method that queries the content provider for the item
   specified by the URI.

   **Note:** You do *not* need to add an intent filter to your Android manifest
   file for the intent action you defined with the
   ``android:searchSuggestIntentAction`` attribute or
   ``SUGGEST_COLUMN_INTENT_ACTION`` column. The system opens your searchable
   activity by name to deliver the suggestion's intent, so the activity doesn't
   need to declare the accepted action.

   .. rubric:: Rewrite the query text
      :name: RewritingQueryText

   By default, if the user navigates through the suggestions list using
   directional controls, such as with a trackball or D-pad, the query text
   doesn't update. However, you can temporarily rewrite the user's query text as
   it appears in the text box with a query that matches the suggestion in focus.
   This lets the user see the query being suggested, and they can select the
   search box and edit the query before dispatching it as a search.

   You can rewrite the query text in the following ways:

   -  Add the ``android:searchMode`` attribute to your searchable configuration
      with the ``"queryRewriteFromText"`` value. In this case, the content from
      the suggestion's ``SUGGEST_COLUMN_TEXT_1`` column is used to rewrite the
      query text.
   -  Add the ``android:searchMode`` attribute to your searchable\\
      configuration with the ``"queryRewriteFromData"`` value. In this case, the
      content from the suggestion's ``SUGGEST_COLUMN_INTENT_DATA`` column is
      used to rewrite the query text. Only use this with URIs or other data
      formats that are intended to be user-visible, such as HTTP URLs. Don't use
      internal URI schemes to rewrite the query in this way.
   -  Provide a unique query text string in the ``SUGGEST_COLUMN_QUERY`` column
      of your suggestions table. If this column is present and contains a value
      for the current suggestion, it is used to rewrite the query text and
      override either of the previous implementations.

   .. rubric:: Expose search suggestions to Quick Search Box
      :name: QSB

   Once you configure your app to provide custom search suggestions, making them
   available to the globally accessible Quick Search Box is as easy as modifying
   your searchable configuration to include ``android:includeInGlobalSearch``
   with the value ``"true"``.

   The only scenario in which additional work is necessary is when your content
   provider demands a read permission. In that case, you need to add a
   ``<path-permission>`` element for the provider to grant Quick Search Box read
   access to your content provider, as shown in the following example:

   .. code:: prettyprint

      <provider android:name="MySuggestionProvider"
                android:authorities="com.example.MyCustomSuggestionProvider"
                android:readPermission="com.example.provider.READ_MY_DATA"
                android:writePermission="com.example.provider.WRITE_MY_DATA">
        <path-permission android:pathPrefix="/search_suggest_query"
                         android:readPermission="android.permission.GLOBAL_SEARCH" />
      </provider>

   In this example, the provider restricts read and write access to the content.
   The ``<path-permission>`` element amends the restriction by granting read
   access to content inside the ``"/search_suggest_query"`` path prefix when the
   ``"android.permission.GLOBAL_SEARCH"`` permission exists. This grants access
   to Quick Search Box so that it can query your content provider for
   suggestions.

   If your content provider doesn't enforce read permissions, then Quick Search
   Box reads it by default.

   .. rubric:: Enable suggestions on a device
      :name: EnablingSuggestions

   By default, apps aren't enabled to provide suggestions in Quick Search Box,
   even if they are configured to do so. The user chooses whether to include
   suggestions from your app in Quick Search Box by opening **Searchable
   items**—located in **Settings > Search**—and enabling your app as a
   searchable item.

   Each app that is available to Quick Search Box has an entry in the
   **Searchable items** settings page. The entry includes the name of the app
   and a short description of what content is searchable from the app and made
   available for suggestions in Quick Search Box. To define the description text
   for your searchable app, add the ``android:searchSettingsDescription``
   attribute to your searchable configuration, as shown in the following
   example:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <searchable xmlns:android="http://schemas.android.com/apk/res/android"
          android:label="@string/app_label"
          android:hint="@string/search_hint"
          android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
          android:searchSuggestIntentAction="android.intent.action.VIEW"
          android:includeInGlobalSearch="true"
          android:searchSettingsDescription="@string/search_description" >
      </searchable>

   Make the string for ``android:searchSettingsDescription`` as concise as
   possible and state the content that is searchable. For example, "Artists,
   albums, and tracks" for a music app, or "Saved notes" for a notepad app.
   Providing this description is important so that the user knows what kind of
   suggestions are provided. Always include this attribute when
   ``android:includeInGlobalSearch`` is true.

   Because the user must visit the settings menu to enable search suggestions
   for your app, if search is an important aspect of your app consider how to
   convey that to your users. For example, you might provide a note the first
   time a user launches the app that explains how to enable search suggestions
   for Quick Search Box.

   .. rubric:: Manage Quick Search Box suggestion shortcuts
      :name: ManagingShortcuts

   Suggestions that the user selects from Quick Search Box can be automatically
   made into shortcuts. These are suggestions that the system copies from your
   content provider so it can quickly access the suggestion without needing to
   re-query your content provider.

   By default, this is enabled for all suggestions retrieved by Quick Search
   Box, but if your suggestion data changes over time, then you can request that
   the shortcuts be refreshed. For example, if your suggestions refer to dynamic
   data, such as a contact's presence status, then request that the suggestion
   shortcuts be refreshed when shown to the user. To do this, include the
   ``SUGGEST_COLUMN_SHORTCUT_ID`` in your suggestions table. You can use this
   column to configure the shortcut behavior for each suggestion in one of the
   following ways:

   -  Make Quick Search Box re-query your content provider for a fresh version
      of the suggestion shortcut.

      Provide a value in the ``SUGGEST_COLUMN_SHORTCUT_ID`` column for the
      suggestion to be re-queried for a fresh version each time the shortcut is
      displayed. The shortcut quickly displays with whatever data is most
      recently available until the refresh query returns, at which point the
      suggestion is refreshed with the new information. The refresh query is
      sent to your content provider with a URI path of
      ``SUGGEST_URI_PATH_SHORTCUT``—instead of ``SUGGEST_URI_PATH_QUERY``.

      Make the ``Cursor`` you return contain one suggestion using the same
      columns as the original suggestion or be empty, indicating that the
      shortcut is no longer valid—in which case, the suggestion disappears and
      the shortcut is removed.

      If a suggestion refers to data that can take longer to refresh, such as a
      network-based refresh, you can also add the
      ``SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING`` column to your suggestions
      table with a value of true to show a progress spinner for the right-hand
      icon until the refresh is complete. Any value other than true doesn't show
      the progress spinner.

   -  Prevent the suggestion from being copied into a shortcut at all.

      Provide a value of ``SUGGEST_NEVER_MAKE_SHORTCUT`` in the
      ``SUGGEST_COLUMN_SHORTCUT_ID`` column. In this case, the suggestion is
      never copied into a shortcut. This is only necessary if you absolutely
      don't want the previously copied suggestion to appear. If you provide a
      normal value for the column, then the suggestion shortcut appears only
      until the refresh query returns.

   -  Let the default shortcut behavior apply.

      Leave the ``SUGGEST_COLUMN_SHORTCUT_ID`` empty for each suggestion that
      doesn't change and that can be saved as a shortcut.

   If none of your suggestions ever change, then you don't need the
   ``SUGGEST_COLUMN_SHORTCUT_ID`` column.

   **Note:** Quick Search Box ultimately decides whether to create a shortcut
   for a suggestion, considering these values as a strong request from your app.
   There is no guarantee that the behavior you request for your suggestion
   shortcuts are fulfilled.

   .. rubric:: About Quick Search Box suggestion ranking
      :name: AboutRanking

   Once you make your app's search suggestions available to Quick Search Box,
   the Quick Search Box ranking determines how the suggestions are surfaced to
   the user for a particular query. This might depend on how many other apps
   have results for that query and how often the user selects your results
   compared to those from other apps. There is no guarantee regarding how your
   suggestions are ranked or whether your app's suggestions show at all for a
   given query. In general, providing quality results increases the likelihood
   that your app's suggestions are provided in a prominent position, and apps
   that provide low-quality suggestions are more likely to be ranked lower or
   not displayed.


Last updated 2024-02-22 UTC.

.. |image-search-suggest-custom| image:: https://developer.android.google.cn/static/images/search/search-suggest-custom.png
   :height: 417px


/Provide a search configuration
===============================

.. https://developer.android.google.cn/develop/ui/views/search/searchable-config?hl=en

.. container:: devsite-article-body

   To implement search with assistance from the Android system—that is, to
   deliver search queries to an activity and provide search suggestions—your
   application must provide a search configuration in the form of an XML file.

   This page describes the search configuration file in terms of its syntax and
   usage. For more information about how to implement search features for your
   application, see `Create a search interface <#>`__.

   file location:
      ``res/xml/``\ *``filename``*\ ``.xml``
      Android uses the filename as the resource ID.
   syntax:
      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <searchable xmlns:android="http://schemas.android.com/apk/res/android"
             android:label="string resource"
             android:hint="string resource"
             android:searchMode=["queryRewriteFromData" | "queryRewriteFromText"]
             android:searchButtonText="string resource"
             android:inputType="inputType"
             android:imeOptions="imeOptions"
             android:searchSuggestAuthority="string"
             android:searchSuggestPath="string"
             android:searchSuggestSelection="string"
             android:searchSuggestIntentAction="string"
             android:searchSuggestIntentData="string"
             android:searchSuggestThreshold="int"
             android:includeInGlobalSearch=["true" | "false"]
             android:searchSettingsDescription="string resource"
             android:queryAfterZeroResults=["true" | "false"]
             android:voiceSearchMode=["showVoiceSearchButton" | "launchWebSearch" | "launchRecognizer"]
             android:voiceLanguageModel=["free-form" | "web_search"]
             android:voicePromptText="string resource"
             android:voiceLanguage="string"
             android:voiceMaxResults="int"
             >
             <actionkey
                 android:keycode="KEYCODE"
                 android:queryActionMsg="string"
                 android:suggestActionMsg="string"
                 android:suggestActionMsgColumn="string" />
         </searchable>

   elements:
      ``<searchable>``
         Defines all search configurations used by the Android system to provide
         assisted search.

         **Attributes:**

         ``android:label``
            *String resource*. (Required.) The name of your application. It must
            be the same as the name applied to the ``android:label`` attribute
            of your
            `<activity> <#label>`__
            or
            `<application> <#label>`__
            manifest element. This label is only visible to the user when you
            set ``android:includeInGlobalSearch`` to ``"true"``, in which case,
            this label is used to identify your application as a searchable item
            in the system's search settings.
         ``android:hint``
            *String resource*. (Recommended.) The text to display in the search
            text field when no text is entered. It provides a hint to the user
            about what content is searchable. For consistency with other Android
            applications, format the string for ``android:hint`` as "Search
            *<content-or-product>*". For example, "Search songs and artists" or
            "Search YouTube".
         ``android:searchMode``
            *Keyword*. Sets additional modes that control the search
            presentation. Available modes define how the query text needs to be
            rewritten when a custom suggestion receives focus. The following
            mode values are accepted:
            Value
         ``android:searchButtonText``
            *String resource*. The text to display in the button that executes
            search. By default, the button shows a search icon (a magnifying
            glass), which is ideal for internationalization. So don't use this
            attribute to change the button unless the behavior is something
            other than a search, such as a URL request in a web browser.
         ``android:inputType``
            *Keyword*. Defines the type of input method to use, such as the type
            of soft keyboard. For most searches, in which free-form text is
            expected, you don't need this attribute. See
            `inputType <#android.R.attr>`__ for a list
            of suitable values for this attribute.
         ``android:imeOptions``
            *Keyword*. Supplies additional options for the input method. For
            most searches, in which free-form text is expected, you don't need
            this attribute. The default IME is ``actionSearch``, which provides
            the "search" button instead of a carriage return in the soft
            keyboard. See
            `imeOptions <#android.R.attr>`__ for a list
            of suitable values for this attribute.

         .. rubric:: Search suggestion attributes
            :name: search-suggestion-attributes

         If you define a content provider to generate search suggestions, you
         need to define additional attributes that configure communications with
         the content provider. When providing search suggestions, you need some
         of the following ``<searchable>`` attributes:

         | 

         ``android:searchSuggestAuthority``
            *String*. (Required to provide search suggestions.) This value must
            match the authority string provided in the ``android:authorities``
            attribute of the Android manifest ``<provider>`` element.
         ``android:searchSuggestPath``
            *String*. This path is used as a portion of the suggestions query
            `Uri <#android.net.Uri>`__, after the prefix and
            authority and before the standard suggestions path. This is only
            required if you have a single content provider issuing different
            types of suggestions—such as for different data types—and you need a
            way to disambiguate the suggestions queries when you receive them.
         ``android:searchSuggestSelection``
            *String*. This value is passed into your query function as the
            ``selection`` parameter. Typically this is a WHERE clause for your
            database, and must contain a single question mark as a placeholder
            for the actual query string entered by the user—for example,
            ``"query=?"``. However, you can also use any non-null value to
            trigger the delivery of the query text using the ``selectionArgs``
            parameter, and then ignore the ``selection`` parameter).
         ``android:searchSuggestIntentAction``
            *String*. The default intent action to be used when a user taps on a
            custom search suggestion—such as ``"android.intent.action.VIEW"``.
            If this value is not overridden by the selected suggestion using the
            `SUGGEST_COLUMN_INTENT_ACTION <#android.app.SearchManager>`__
            column, the value is placed in the action field of the
            `Intent <#android.content.Intent>`__ when the user
            taps a suggestion.
         ``android:searchSuggestIntentData``
            *String*. The default intent data to be used when a user taps on a
            custom search suggestion. If not overridden by the selected
            suggestion—via the
            `SUGGEST_COLUMN_INTENT_DATA <#android.app.SearchManager>`__
            column—this value is placed in the data field of the
            `Intent <#android.content.Intent>`__ when the user
            taps a suggestion.
         ``android:searchSuggestThreshold``
            *Integer*. The minimum number of characters needed to trigger a
            suggestion look-up. This only guarantees that the system doesn't
            query your content provider for anything shorter than the threshold.
            The default value is 0.

         For more information about the above attributes for search suggestions,
         see the documentation for `adding custom search suggestions <#>`__
         and `adding custom suggestions <#>`__.

         .. rubric:: Quick Search Box attributes
            :name: quick-search-box-attributes

         To make your custom search suggestions available to Quick Search Box,
         you need some of the following ``<searchable>`` attributes:

         | 

         ``android:includeInGlobalSearch``
            *Boolean*. (Required to provide search suggestions in the Quick
            Search Box.) Set to ``"true"`` if you want your suggestions to be
            included in the globally accessible Quick Search Box. The user must
            still enable your application as a searchable item in the system
            search settings before your suggestions appear in Quick Search Box.
         ``android:searchSettingsDescription``
            *String resource*. Provides a brief description of the search
            suggestions that you provide to Quick Search Box, which is displayed
            in the searchable items entry for your application. Your description
            must concisely describe the content that is searchable. For example,
            "Artists, albums, and tracks" for a music application, or "Saved
            notes" for a notepad application.
         ``android:queryAfterZeroResults``
            *Boolean*. Set to ``"true"`` if you want your content provider to be
            invoked for supersets of queries that previously returned zero
            results. For example, if your content provider returns zero results
            for "bo", it must be requeried for "bob". If set to ``"false"``,
            supersets are ignored for a single session—"bob" doesn't invoke a
            requery. This lasts only for the life of the search dialog or the
            life of the activity when using the search widget. When the search
            dialog or activity is reopened, "bo" queries your content provider
            again. The default value is false.

         .. rubric:: Voice search attributes
            :name: voice-search-attributes

         To enable voice search, you need some of the following ``<searchable>``
         attributes:

         | 

         ``android:voiceSearchMode``
            *Keyword*. (Required to provide voice search capabilities.) Enables
            voice search, with a specific mode for voice search. Voice search
            might not be provided by the device, in which case these flags have
            no effect. The following mode values are accepted:

            +-----------------------------+-----------------------------------------------+
            | Value                       | Description                                   |
            +=============================+===============================================+
            | ``"showVoiceSearchButton"`` | Display a voice search button, if voice       |
            |                             | search is available on the device. If set,    |
            |                             | then either ``"launchWebSearch"`` or          |
            |                             | ``"launchRecognizer"`` must also be set,      |
            |                             | separated by the pipe (``|``) character.      |
            +-----------------------------+-----------------------------------------------+
            | ``"launchWebSearch"``       | The voice search button takes the user        |
            |                             | directly to a built-in voice web search       |
            |                             | activity. Most applications don't use this    |
            |                             | flag, as it takes the user away from the      |
            |                             | activity in which search was invoked.         |
            +-----------------------------+-----------------------------------------------+
            | ``"launchRecognizer"``      | The voice search button takes the user        |
            |                             | directly to a built-in voice recording        |
            |                             | activity. This activity prompts the user to   |
            |                             | speak, transcribes the spoken text, and       |
            |                             | forwards the resulting query text to the      |
            |                             | searchable activity, just as if the user      |
            |                             | typed it into the search UI and tapped the    |
            |                             | search button.                                |
            +-----------------------------+-----------------------------------------------+

         ``android:voiceLanguageModel``
            *Keyword*. The language model that must be used by the voice
            recognition system. The following values are accepted:

            +------------------+----------------------------------------------------------+
            | Value            | Description                                              |
            +==================+==========================================================+
            | ``"free_form"``  | Use free-form speech recognition for dictating queries.  |
            |                  | This is primarily optimized for English. This is the     |
            |                  | default.                                                 |
            +------------------+----------------------------------------------------------+
            | ``"web_search"`` | Use web-search-term recognition for shorter, search-like |
            |                  | phrases. This is available in more languages than        |
            |                  | ``"free_form"``.                                         |
            +------------------+----------------------------------------------------------+

            See
            `EXTRA_LANGUAGE_MODEL <#android.speech.RecognizerIntent>`__
            for more information.

         ``android:voicePromptText``
            *String resource*. An additional message to display in the voice
            input dialog.
         ``android:voiceLanguage``
            *String*. The spoken language to be expected, expressed as the
            string value of a constant in
            `Locale <#>`__, such as ``"de"`` for
            German or ``"fr"`` for French. This is needed only if it is
            different from the current value of
            `Locale.getDefault() <#getDefault()>`__.
         ``android:voiceMaxResults``
            *Integer*. Sets the maximum number of results to return, including
            the "best" result, which is always provided as the
            `ACTION_SEARCH <#android.content.Intent>`__
            intent's primary query. Must be 1 or greater. Use
            `EXTRA_RESULTS <#android.speech.RecognizerIntent>`__
            to get the results from the intent. If not provided, the recognizer
            chooses how many results to return.

      ``<actionkey>``
         Defines a device key and behavior for a search action. A search action
         provides a special behavior at the tap of a button on the device, based
         on the current query or focused suggestion. For example, the Contacts
         application provides a search action to initiate a phone call to the
         currently focused contact suggestion when the CALL button is tapped.

         Not all action keys are available on every device, and not all keys can
         be overridden in this way. For example, the "Home" key can't be
         overridden and must always return to the home screen. Also, be sure not
         to define an action key for a key that's needed for typing a search
         query. This limits the available and reasonable action keys to the call
         button and menu button.

         **Note:** Action keys are not generally discoverable, so don't provide
         them as a core user feature.

         You must define the ``android:keycode`` to define the key and at least
         one of the other three attributes to define the search action.

         **Attributes:**

         ``android:keycode``
            *String*. (Required.) A key code from
            `KeyEvent <#android.view.KeyEvent>`__ that represents
            the action key you want to respond to—for example,
            ``"KEYCODE_CALL"``. This is added to the
            `ACTION_SEARCH <#android.content.Intent>`__
            intent that is passed to your searchable activity. To examine the
            key code, use
            `getIntExtra(SearchManager.ACTION_KEY) <#android.content.Intent>`__.
            Not all keys are supported for a search action, as many of them are
            used for typing, navigation, or system functions.
         ``android:queryActionMsg``
            *String*. An action message to be sent if the action key is pressed
            while the user is entering query text. This is added to the
            `ACTION_SEARCH <#android.content.Intent>`__
            intent that the system passes to your searchable activity. To
            examine the string, use
            `getStringExtra(SearchManager.ACTION_MSG) <#android.content.Intent>`__.
         ``android:suggestActionMsg``
            *String*. An action message to be sent if the action key is pressed
            while a suggestion is in focus. This is added to the intent that the
            system passes to your searchable activity—using the action you
            define for the suggestion. To examine the string, use
            `getStringExtra(SearchManager.ACTION_MSG) <#android.content.Intent>`__.
            This must only be used if all your suggestions support this action
            key. If not all suggestions can handle the same action key, then you
            must instead use the following ``android:suggestActionMsgColumn``
            attribute.
         ``android:suggestActionMsgColumn``
            *String*. The name of the column in your content provider that
            defines the action message for this action key, which is to be sent
            if the user presses the action key while a suggestion is in focus.
            This attribute lets you control the action key on a
            suggestion-by-suggestion basis, because, instead of using the
            ``android:suggestActionMsg`` attribute to define the action message
            for all suggestions, each entry in your content provider provides
            its own action message.

            First, you must define a column in your content provider for each
            suggestion to provide an action message for, then provide the name
            of that column in this attribute. The system looks at your
            suggestion cursor, using the string provided here to select your
            action message column, and then selects the action message string
            from the cursor. That string is added to the intent that the system
            passes to your searchable activity, using the action you define for
            suggestions. To examine the string, use
            `getStringExtra(SearchManager.ACTION_MSG) <#android.content.Intent>`__.
            If the data doesn't exist for the selected suggestion, the action
            key is ignored.

   example:
      XML file saved at ``res/xml/searchable.xml``:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <searchable xmlns:android="http://schemas.android.com/apk/res/android"
             android:label="@string/search_label"
             android:hint="@string/search_hint"
             android:searchSuggestAuthority="dictionary"
             android:searchSuggestIntentAction="android.intent.action.VIEW"
             android:includeInGlobalSearch="true"
             android:searchSettingsDescription="@string/settings_description" >
         </searchable>


Last updated 2024-02-22 UTC.


/Use AppSearch
==============

.. https://developer.android.google.cn/develop/ui/views/search/appsearch?hl=en

.. container:: devsite-article-body

   AppSearch is a high-performance on-device search solution for managing
   locally stored, structured data. It contains APIs for indexing data and
   retrieving data using full-text search. Applications can use AppSearch to
   offer custom in-app search capabilities, allowing users to search for content
   even while offline.

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/search/appsearch.png
      :alt: Diagram illustrating indexing and searching within AppSearch
      :width: 700px

   AppSearch provides the following features:

   -  A fast, mobile-first storage implementation with low I/O use
   -  Highly efficient indexing and querying over large data sets
   -  Multi-language support, such as English and Spanish
   -  Relevance ranking and usage scoring

   Due to lower I/O use, AppSearch offers lower latency for indexing and
   searching over large datasets compared to SQLite. AppSearch simplifies
   cross-type queries by supporting single queries whereas SQLite merges results
   from multiple tables.

   To illustrate AppSearch’s features, let’s take the example of a music
   application that manages users’ favorite songs and allows users to easily
   search for them. Users enjoy music from around the world with song titles in
   different languages, which AppSearch natively supports indexing and querying
   for. When the user searches for a song by title or artist name, the
   application simply passes the request to AppSearch to quickly and efficiently
   retrieve matching songs. The application surfaces the results, allowing its
   users to quickly start playing their favorite songs.

   .. rubric:: Setup
      :name: setup

   To use AppSearch in your application, add the following dependencies to your
   application's ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   def appsearch_version = "1.1.0-alpha03"

                   implementation "androidx.appsearch:appsearch:$appsearch_version"
                   // Use kapt instead of annotationProcessor if writing Kotlin classes
                   annotationProcessor "androidx.appsearch:appsearch-compiler:$appsearch_version"

                   implementation "androidx.appsearch:appsearch-local-storage:$appsearch_version"
                   // PlatformStorage is compatible with Android 12+ devices, and offers additional features
                   // to LocalStorage.
                   implementation "androidx.appsearch:appsearch-platform-storage:$appsearch_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   val appsearch_version = "1.1.0-alpha03"

                   implementation("androidx.appsearch:appsearch:$appsearch_version")
                   // Use annotationProcessor instead of kapt if writing Java classes
                   kapt("androidx.appsearch:appsearch-compiler:$appsearch_version")

                   implementation("androidx.appsearch:appsearch-local-storage:$appsearch_version")
                   // PlatformStorage is compatible with Android 12+ devices, and offers additional features
                   // to LocalStorage.
                   implementation("androidx.appsearch:appsearch-platform-storage:$appsearch_version")
               }

   .. rubric:: AppSearch concepts
      :name: appsearch-concepts

   The following diagram illustrates AppSearch concepts and their interactions.

   |Diagram outline of a client application and its interactions with the
   following AppSearch concepts: AppSearch database, schema, schema types,
   documents, session, and search.| **Figure 1.** Diagram of AppSearch concepts:
   AppSearch database, schema, schema types, documents, session, and search.

   .. rubric:: Database and session
      :name: database

   An AppSearch database is a collection of documents that conforms to the
   database schema. Client applications create a database by providing their
   application context and a database name. Databases can be opened only by the
   application that created them. When a database is opened, a session is
   returned to interact with the database. The session is the entry point for
   calling the AppSearch APIs and remains open until it’s closed by the client
   application.

   .. rubric:: Schema and schema types
      :name: schema

   A schema represents the organizational structure of data within an AppSearch
   database.

   The schema is composed of schema types that represent unique types of data.
   Schema types consist of properties that contain a name, data type, and
   cardinality. Once a schema type is added to the database schema, documents of
   that schema type can be created and added to the database.

   .. rubric:: Documents
      :name: documents

   In AppSearch, a unit of data is represented as a document. Each document in
   an AppSearch database is uniquely identified by its namespace and ID.
   Namespaces are used to separate data from different sources when only one
   source needs to be queried, such as user accounts.

   Documents contain a creation timestamp, a time-to-live (TTL), and a score
   that can be used for ranking during retrieval. A document is also assigned a
   schema type that describes additional data properties the document must have.

   A document class is an abstraction of a document. It contains annotated
   fields that represent the contents of a document. By default, the name of the
   document class sets the name of the schema type.

   .. rubric:: Search
      :name: search

   Documents are indexed and can be searched by providing a query. A document is
   matched and included in the search results if it contains the terms in the
   query or matches another search specification. Results are ordered based on
   their score and ranking strategy. Search results are represented by pages
   that you can retrieve sequentially.

   AppSearch offers
   `customizations <#androidx.appsearch.app.SearchSpec>`__ for search,
   such as filters, page size configuration, and snippeting.

   .. rubric:: Platform Storage vs Local Storage
      :name: platform-storage

   AppSearch offers two storage solutions: LocalStorage and PlatformStorage.
   With LocalStorage, your application manages an app-specific index that lives
   in your application data directory. With PlatformStorage, your application
   contributes to a system-wide central index. Data access within the central
   index is restricted to data your application has contributed and data that
   has been explicitly shared with you by another application. Both LocalStorage
   and PlatformStorage share the same API and can be interchanged based on a
   device's version:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               if (BuildCompat.isAtLeastS()) {
                   appSearchSessionFuture.setFuture(
                       PlatformStorage.createSearchSession(
                           PlatformStorage.SearchContext.Builder(mContext, DATABASE_NAME)
                              .build()
                       )
                   )
               } else {
                   appSearchSessionFuture.setFuture(
                       LocalStorage.createSearchSession(
                           LocalStorage.SearchContext.Builder(mContext, DATABASE_NAME)
                               .build()
                       )
                   )
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               if (BuildCompat.isAtLeastS()) {
                   mAppSearchSessionFuture.setFuture(PlatformStorage.createSearchSession(
                           new PlatformStorage.SearchContext.Builder(mContext, DATABASE_NAME)
                                   .build()));
               } else {
                   mAppSearchSessionFuture.setFuture(LocalStorage.createSearchSession(
                           new LocalStorage.SearchContext.Builder(mContext, DATABASE_NAME)
                                   .build()));
               }

   Using PlatformStorage, your application can securely share data with other
   applications to allow them to search over your app's data as well. Read-only
   application data sharing is granted via a certificate handshake to ensure
   that the other application has permission to read the data. Read more about
   this API in the documentation for
   `setSchemaTypeVisibilityForPackage() <#androidx.appsearch.app.SetSchemaRequest.Builder>`__.

   Additionally, data that is indexed can be displayed on System UI surfaces.
   Applications can opt out of some or all of their data being displayed on
   System UI surfaces. Read more about this API in the documentation for
   `setSchemaTypeDisplayedBySystem() <#androidx.appsearch.app.SetSchemaRequest.Builder>`__.

   +----------------------------+-----------------+-----------------+
   | Features                   |   LocalStorage  | PlatformStorage |
   |                            |  (Android 4.0+) |  (Android 12+)  |
   +============================+=================+=================+
   | Efficient full-text search | ✔              | ✔              |
   +----------------------------+-----------------+-----------------+
   | Multi-language support     | ✔              | ✔              |
   +----------------------------+-----------------+-----------------+
   | Reduced binary size        | ❌              | ✔              |
   +----------------------------+-----------------+-----------------+
   | Application-to-app         | ❌              | ✔              |
   | lication data sharing      |                 |                 |
   +----------------------------+-----------------+-----------------+
   | Capability to display data | ❌              | ✔              |
   | on System UI surfaces      |                 |                 |
   +----------------------------+-----------------+-----------------+
   | Unlimited document size    | ✔              | ❌              |
   | and count can be indexed   |                 |                 |
   +----------------------------+-----------------+-----------------+
   | Fasteroperations without   | ✔              | ❌              |
   | additional binder latency  |                 |                 |
   +----------------------------+-----------------+-----------------+

   There are additional trade-offs to consider when choosing between
   LocalStorage and PlatformStorage. Because PlatformStorage wraps Jetpack APIs
   over the AppSearch system service, the APK size impact is minimal compared to
   using LocalStorage. However, this also means AppSearch operations incur
   additional binder latency when calling the AppSearch system service. With
   PlatformStorage, AppSearch limits the number of documents and size of
   documents an application can index to ensure an efficient central index.

   .. rubric:: Get started with AppSearch
      :name: use-appsearch

   The example in this section showcases how to use AppSearch APIs to integrate
   with a hypothetical note-keeping application.

   .. rubric:: Write a document class
      :name: sample-document-class

   The first step to integrate with AppSearch is to write a document class to
   describe the data to insert into the database. Mark a class as a document
   class by using the
   `@Document <#androidx.appsearch.annotation.Document>`__
   annotation.You can use instances of the document class to put documents in
   and retrieve documents from the database.

   The following code defines a Note document class with a
   `@Document.StringProperty <#androidx.appsearch.annotation.Document.StringProperty>`__
   annotated field for indexing a Note object’s text.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Document
               public data class Note(

                   // Required field for a document class. All documents MUST have a namespace.
                   @Document.Namespace
                   val namespace: String,

                   // Required field for a document class. All documents MUST have an Id.
                   @Document.Id
                   val id: String,

                   // Optional field for a document class, used to set the score of the
                   // document. If this is not included in a document class, the score is set
                   // to a default of 0.
                   @Document.Score
                   val score: Int,

                   // Optional field for a document class, used to index a note's text for this
                   // document class.
                   @Document.StringProperty(indexingType = AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_PREFIXES)
                   val text: String
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Document
               public class Note {

                 // Required field for a document class. All documents MUST have a namespace.
                 @Document.Namespace
                 private final String namespace;

                 // Required field for a document class. All documents MUST have an Id.
                 @Document.Id
                 private final String id;

                 // Optional field for a document class, used to set the score of the
                 // document. If this is not included in a document class, the score is set
                 // to a default of 0.
                 @Document.Score
                 private final int score;

                 // Optional field for a document class, used to index a note's text for this
                 // document class.
                 @Document.StringProperty(indexingType = StringPropertyConfig.INDEXING_TYPE_PREFIXES)
                 private final String text;

                 Note(@NonNull String id, @NonNull String namespace, int score, @NonNull String text) {
                   this.id = Objects.requireNonNull(id);
                   this.namespace = Objects.requireNonNull(namespace);
                   this.score = score;
                   this.text = Objects.requireNonNull(text);
                 }

                 @NonNull
                 public String getNamespace() {
                   return namespace;
                 }

                 @NonNull
                 public String getId() {
                   return id;
                 }

                 public int getScore() {
                   return score;
                 }

                 @NonNull
                 public String getText() {
                    return text;
                 }
               }

   .. rubric:: Open a database
      :name: sample-open-database

   You must create a database before working with documents. The following code
   creates a new database with the name ``notes_app`` and gets a
   ``ListenableFuture`` for an
   `AppSearchSession <#androidx.appsearch.app.AppSearchSession>`__,
   which represents the connection to the database and provides the APIs for
   database operations.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val context: Context = getApplicationContext()
               val sessionFuture = LocalStorage.createSearchSession(
                   LocalStorage.SearchContext.Builder(context, /*databaseName=*/"notes_app")
                   .build()
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Context context = getApplicationContext();
               ListenableFuture<AppSearchSession> sessionFuture = LocalStorage.createSearchSession(
                      new LocalStorage.SearchContext.Builder(context, /*databaseName=*/ "notes_app")
                              .build()
               );

   .. rubric:: Set a schema
      :name: sample-set-schema

   You must set a schema before you can put documents in and retrieve documents
   from the database. The database schema consists of different types of
   structured data, referred to as "schema types." The following code sets the
   schema by providing the document class as a schema type.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val setSchemaRequest = SetSchemaRequest.Builder().addDocumentClasses(Note::class.java)
                   .build()
               val setSchemaFuture = Futures.transformAsync(
                   sessionFuture,
                   { session ->
                       session?.setSchema(setSchemaRequest)
                   }, mExecutor
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SetSchemaRequest setSchemaRequest = new SetSchemaRequest.Builder().addDocumentClasses(Note.class)
                      .build();
               ListenableFuture<SetSchemaResponse> setSchemaFuture =
                      Futures.transformAsync(sessionFuture, session -> session.setSchema(setSchemaRequest), mExecutor);

   .. rubric:: Put a document in the database
      :name: sample-put-document

   Once a schema type is added, you can add documents of that type to the
   database. The following code builds a document of schema type ``Note`` using
   the ``Note`` document class builder. It sets the document namespace ``user1``
   to represent an arbitrary user of this sample. The document is then inserted
   into the database and a listener is attached to process the result of the put
   operation.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val note = Note(
                   namespace="user1",
                   id="noteId",
                   score=10,
                   text="Buy fresh fruit"
               )

               val putRequest = PutDocumentsRequest.Builder().addDocuments(note).build()
               val putFuture = Futures.transformAsync(
                   sessionFuture,
                   { session ->
                       session?.put(putRequest)
                   }, mExecutor
               )

               Futures.addCallback(
                   putFuture,
                   object : FutureCallback<AppSearchBatchResult<String, Void>?> {
                       override fun onSuccess(result: AppSearchBatchResult<String, Void>?) {

                           // Gets map of successful results from Id to Void
                           val successfulResults = result?.successes

                           // Gets map of failed results from Id to AppSearchResult
                           val failedResults = result?.failures
                       }

                       override fun onFailure(t: Throwable) {
                           Log.e(TAG, "Failed to put documents.", t)
                       }
                   },
                   mExecutor
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Note note = new Note(/*namespace=*/"user1", /*id=*/
                               "noteId", /*score=*/ 10, /*text=*/ "Buy fresh fruit!");

               PutDocumentsRequest putRequest = new PutDocumentsRequest.Builder().addDocuments(note)
                      .build();
               ListenableFuture<AppSearchBatchResult<String, Void>> putFuture =
                      Futures.transformAsync(sessionFuture, session -> session.put(putRequest), mExecutor);

               Futures.addCallback(putFuture, new FutureCallback<AppSearchBatchResult<String, Void>>() {
                  @Override
                  public void onSuccess(@Nullable AppSearchBatchResult<String, Void> result) {

                    // Gets map of successful results from Id to Void
                    Map<String, Void> successfulResults = result.getSuccesses();

                    // Gets map of failed results from Id to AppSearchResult
                    Map<String, AppSearchResult<Void>> failedResults = result.getFailures();
                  }

                  @Override
                  public void onFailure(@NonNull Throwable t) {
                     Log.e(TAG, "Failed to put documents.", t);
                  }
               }, mExecutor);

   .. rubric:: Search
      :name: sample-search

   You can search documents that are indexed using the search operations covered
   in this section. The following code performs queries for the term "fruit"
   over the database for documents that belong to the ``user1`` namespace.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val searchSpec = SearchSpec.Builder()
                   .addFilterNamespaces("user1")
                   .build();

               val searchFuture = Futures.transform(
                   sessionFuture,
                   { session ->
                       session?.search("fruit", searchSpec)
                   },
                   mExecutor
               )
               Futures.addCallback(
                   searchFuture,
                   object : FutureCallback<SearchResults> {
                       override fun onSuccess(searchResults: SearchResults?) {
                           iterateSearchResults(searchResults)
                       }

                       override fun onFailure(t: Throwable?) {
                           Log.e("TAG", "Failed to search notes in AppSearch.", t)
                       }
                   },
                   mExecutor
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SearchSpec searchSpec = new SearchSpec.Builder()
                      .addFilterNamespaces("user1")
                      .build();

               ListenableFuture<SearchResults> searchFuture =
                      Futures.transform(sessionFuture, session -> session.search("fruit", searchSpec),
                      mExecutor);

               Futures.addCallback(searchFuture,
                      new FutureCallback<SearchResults>() {
                          @Override
                          public void onSuccess(@Nullable SearchResults searchResults) {
                              iterateSearchResults(searchResults);
                          }

                          @Override
                          public void onFailure(@NonNull Throwable t) {
                              Log.e(TAG, "Failed to search notes in AppSearch.", t);
                          }
                      }, mExecutor);

   .. rubric:: Iterate through SearchResults
      :name: sample-search-results

   Searches return a
   `SearchResults <#androidx.appsearch.app.SearchResults>`__
   instance, which gives access to the pages of
   `SearchResult <#androidx.appsearch.app.SearchResult>`__
   objects. Each ``SearchResult`` holds its matched
   `GenericDocument <#androidx.appsearch.app.GenericDocument>`__,
   the general form of a document that all documents are converted to. The
   following code gets the first page of search results and converts the result
   back into a ``Note`` document.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               Futures.transform(
                   searchResults?.nextPage,
                   { page: List<SearchResult>? ->
                       // Gets GenericDocument from SearchResult.
                       val genericDocument: GenericDocument = page!![0].genericDocument
                       val schemaType = genericDocument.schemaType
                       val note: Note? = try {
                           if (schemaType == "Note") {
                               // Converts GenericDocument object to Note object.
                               genericDocument.toDocumentClass(Note::class.java)
                           } else null
                       } catch (e: AppSearchException) {
                           Log.e(
                               TAG,
                               "Failed to convert GenericDocument to Note",
                               e
                           )
                           null
                       }
                       note
                   },
                   mExecutor
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Futures.transform(searchResults.getNextPage(), page -> {
                 // Gets GenericDocument from SearchResult.
                 GenericDocument genericDocument = page.get(0).getGenericDocument();
                 String schemaType = genericDocument.getSchemaType();

                 Note note = null;

                 if (schemaType.equals("Note")) {
                   try {
                     // Converts GenericDocument object to Note object.
                     note = genericDocument.toDocumentClass(Note.class);
                   } catch (AppSearchException e) {
                     Log.e(TAG, "Failed to convert GenericDocument to Note", e);
                   }
                 }

                 return note;
               }, mExecutor);

   .. rubric:: Remove a document
      :name: sample-remove-document

   When the user deletes a note, the application deletes the corresponding
   ``Note`` document from the database. This ensures the note will no longer be
   surfaced in queries. The following code makes an explicit request to remove
   the ``Note`` document from the database by Id.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val removeRequest = RemoveByDocumentIdRequest.Builder("user1")
                   .addIds("noteId")
                   .build()

               val removeFuture = Futures.transformAsync(
                   sessionFuture, { session ->
                       session?.remove(removeRequest)
                   },
                   mExecutor
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               RemoveByDocumentIdRequest removeRequest = new RemoveByDocumentIdRequest.Builder("user1")
                      .addIds("noteId")
                      .build();

               ListenableFuture<AppSearchBatchResult<String, Void>> removeFuture =
                      Futures.transformAsync(sessionFuture, session -> session.remove(removeRequest), mExecutor);

   .. rubric:: Persist to disk
      :name: sample-persist-disk

   Updates to a database should be periodically persisted to disk by calling
   `requestFlush() <#androidx.appsearch.app.AppSearchSession>`__.
   The following code calls ``requestFlush()`` with a listener to determine if
   the call was successful.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val requestFlushFuture = Futures.transformAsync(
                   sessionFuture,
                   { session -> session?.requestFlush() }, mExecutor
               )

               Futures.addCallback(requestFlushFuture, object : FutureCallback<Void?> {
                   override fun onSuccess(result: Void?) {
                       // Success! Database updates have been persisted to disk.
                   }

                   override fun onFailure(t: Throwable) {
                       Log.e(TAG, "Failed to flush database updates.", t)
                   }
               }, mExecutor)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ListenableFuture<Void> requestFlushFuture = Futures.transformAsync(sessionFuture,
                       session -> session.requestFlush(), mExecutor);

               Futures.addCallback(requestFlushFuture, new FutureCallback<Void>() {
                   @Override
                   public void onSuccess(@Nullable Void result) {
                       // Success! Database updates have been persisted to disk.
                   }

                   @Override
                   public void onFailure(@NonNull Throwable t) {
                       Log.e(TAG, "Failed to flush database updates.", t);
                   }
               }, mExecutor);

   .. rubric:: Close a session
      :name: sample-close-session

   An
   `AppSearchSession <#androidx.appsearch.app.AppSearchSession>`__
   should be closed when an application will no longer be calling any database
   operations. The following code closes the AppSearch session that was opened
   previously and persists all updates to disk.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val closeFuture = Futures.transform<AppSearchSession, Unit>(sessionFuture,
                   { session ->
                       session?.close()
                       Unit
                   }, mExecutor
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ListenableFuture<Void> closeFuture = Futures.transform(sessionFuture, session -> {
                  session.close();
                  return null;
               }, mExecutor);

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about AppSearch, see the following additional resources:

   .. rubric:: Samples
      :name: samples

   -  `Android AppSearch Sample (Kotlin) <https://github.com/android/search-samples/tree/main/AppSearchSample>`__,
      a note taking app that uses AppSearch to index a user's notes and allows
      users to search over their notes.

   .. rubric:: Provide feedback
      :name: feedback

   Share your feedback and ideas with us through these resources:

   `Issue tracker <https://issuetracker.google.com/issues/new?component=1012737&template=1551039>`__

   Report bugs so we can fix them.


Last updated 2024-02-22 UTC.

.. |Diagram outline of a client application and its interactions with the following AppSearch concepts: AppSearch database, schema, schema types, documents, session, and search.| image:: https://developer.android.google.cn/static/images/search/appsearch_overview_diagram.png


/About search functionality
===========================

.. https://developer.android.google.cn/develop/ui/views/search/training?hl=en

.. container:: devsite-article-body

   Android's built-in search features offer apps an easy way to provide a
   consistent search experience for all users. There are two ways to implement
   search in your app, depending on the version of Android that is running on
   the device. This documentation covers how to add search with
   `SearchView <#android.widget.SearchView>`__ while maintaining
   backward compatibility with older versions of Android by using the system's
   default search dialog.

   .. rubric:: Lessons
      :name: lessons

   `Set up the search interface <#>`__
      Learn how to add a search interface to your app and how to configure an
      activity to handle search queries.
   `Store and search for data <#>`__
      Learn a simple way to store and search for data in a SQLite virtual
      database table.
   `Remain backward compatible <#>`__
      Learn how to keep search features backward compatible with older devices.


Last updated 2024-02-22 UTC.


/Set up the search UI
=====================

.. https://developer.android.google.cn/develop/ui/views/search/training/setup?hl=en

.. container:: devsite-article-body

   .. container:: video-wrapper

   We recommend using the
   `SearchView <#android.widget.SearchView>`__ widget as an item
   in the app bar to provide search functionality in your app. As with all items
   in the app bar, you can define the ``SearchView`` to show at all times or
   only when there is room. You can also define it as a collapsible action,
   which displays the ``SearchView`` as an icon initially and then takes up the
   entire app bar as a search field when the user taps the icon.

   .. rubric:: Add the SearchView to the app bar
      :name: add-sv

   To add a ``SearchView`` widget to the app bar, create a file in your project
   named ``res/menu/options_menu.xml`` and add the following code to the file.
   This code defines how to create the search item, such as the icon to use and
   the title of the item. The ``collapseActionView`` attribute lets your
   ``SearchView`` expand to take up the whole app bar and collapse back down
   into a normal app bar item when not in use. Because of the limited app bar
   space on handset devices, we recommend using the ``collapsibleActionView``
   attribute to provide a better user experience.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <menu xmlns:android="http://schemas.android.com/apk/res/android">
      <item android:id="@+id/search"
              android:title="@string/search_title"
              android:icon="@drawable/ic_search"
              android:showAsAction="collapseActionView|ifRoom"
              android:actionViewClass="androidx.appcompat.widget.SearchView" />
      </menu>

   **Note:** If you already have an XML file for your menu items, you can add
   the ``<item>`` element to that file instead.
   If you want a more accessible search icon, create an ``ic_search.xml`` file
   in the ``/res/drawable`` folder and include the following code in it:

   .. code:: prettyprint

      <vector
          android:height="24dp"
          android:tint="#000000"
          android:viewportHeight="24"
          android:viewportWidth="24"
          android:width="24dp"
          xmlns:android="http://schemas.android.com/apk/res/android">
              <path android:fillColor="@android:color/white" android:pathData="M15.5,14h-0.79l-0.28,-0.27C15.41,12.59 16,11.11 16,9.5 16,5.91 13.09,3 9.5,3S3,5.91 3,9.5 5.91,16 9.5,16c1.61,0 3.09,-0.59 4.23,-1.57l0.27,0.28v0.79l5,4.99L20.49,19l-4.99,-5zM9.5,14C7.01,14 5,11.99 5,9.5S7.01,5 9.5,5 14,7.01 14,9.5 11.99,14 9.5,14z"/>
      </vector>

   To display the ``SearchView`` in the app bar, inflate the XML menu resource
   ``res/menu/options_menu.xml`` in the
   `onCreateOptionsMenu() <#android.app.Activity>`__
   method of your activity:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onCreateOptionsMenu(menu: Menu): Boolean {
                menuInflater.inflate(R.menu.options_menu, menu)

                return true
            }

   Running the app generates something like this:

   .. figure:: https://developer.android.google.cn/static/images/ui/searchview_1.png
      name: searchview_1
      :alt: An image showing an empty screen with a search icon in the app top
      bar
      :width: 40.0%

      **Figure 1.** A search icon in the app top bar.

   The ``SearchView`` appears in your app's app bar, but it isn't functional. If
   you tap the search icon, you get something like this:

   .. figure:: https://developer.android.google.cn/static/images/ui/searchview_2.png
      name: searchview_2
      :alt: An image showing the search view in action
      :width: 40.0%

      **Figure 2.** ``SearchView`` in action.

   To make the ``SearchView`` functional, you must define how the ``SearchView``
   behaves.

   .. rubric:: Create a search configuration
      :name: create-sc

   A `search configuration <#>`__ specifies
   how the ``SearchView`` behaves and is defined in a ``res/xml/searchable.xml``
   file. A search configuration must contain, at minimum, an ``android:label``
   attribute that has the same value as the ``android:label`` attribute of the
   `<application> <#>`__ or
   `<activity> <#>`__ element in your
   Android manifest. However, we also recommend adding an ``android:hint``
   attribute to give the user an idea of what to enter into the search box.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>

      <searchable xmlns:android="http://schemas.android.com/apk/res/android"
              android:label="@string/app_name"
              android:hint="@string/search_hint" />

   In your app's manifest file, declare a
   `<meta-data> <#>`__ element that
   points to the ``res/xml/searchable.xml`` file. Declare the element in an
   ``<activity>`` in which you want to display the ``SearchView``.

   .. code:: prettyprint

      <activity
      android:name=".SearchResultsActivity"
      android:exported="false"
      android:label="@string/title_activity_search_results"
      android:launchMode="singleTop"
      android:theme="@style/Theme.AppCompat.Light">
          <intent-filter>
              <action android:name="android.intent.action.SEARCH" />
          </intent-filter>
          <meta-data
              android:name="android.app.searchable"
              android:resource="@xml/searchable" />
      </activity>

   In the ``onCreateOptionsMenu()`` method that you create, associate the search
   configuration with the ``SearchView`` by calling
   `setSearchableInfo(SearchableInfo) <#android.widget.SearchView>`__:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onCreateOptionsMenu(menu: Menu): Boolean {
                menuInflater.inflate(R.menu.options_menu, menu)

                val searchManager = getSystemService(Context.SEARCH_SERVICE) as SearchManager
                val searchView = menu.findItem(R.id.search).actionView as SearchView
                val component = ComponentName(this, SearchResultsActivity::class.java)
                val searchableInfo = searchManager.getSearchableInfo(component)
                searchView.setSearchableInfo(searchableInfo)
                return true
            }

   The call to
   `getSearchableInfo() <#android.app.SearchManager>`__
   obtains a `SearchableInfo <#android.app.SearchableInfo>`__
   object that is created from the search configuration XML file. When the
   search configuration is correctly associated with your ``SearchView`` and the
   user submits a query, the ``SearchView`` starts an activity with the
   `ACTION_SEARCH <#android.content.Intent>`__
   intent. You then need an activity that can filter for this intent and handle
   the search query.

   .. rubric:: Create a searchable activity
      :name: create-sa

   A searchable activity filters for the ``ACTION_SEARCH`` intent and searches
   for the query in a data set. To create a searchable activity, declare an
   activity of your choice to filter for the ``ACTION_SEARCH`` intent:

   .. code:: prettyprint

      <activity android:name=".SearchResultsActivity" ... >
          ...
          <intent-filter>
              <action android:name="android.intent.action.SEARCH" />
          </intent-filter>
          ...
      </activity>

   In your searchable activity, handle the ``ACTION_SEARCH`` intent by checking
   for it in your
   `onCreate() <#android.app.Activity>`__
   method.

   **Note:** If your searchable activity launches in single top
   mode—``android:launchMode="singleTop"``—also handle the ``ACTION_SEARCH``
   intent in the
   `onNewIntent() <#android.app.Activity>`__
   method. In single top mode, only one instance of your activity is created.
   Subsequent calls to start your activity don't create a new activity on the
   stack. This launch helps users perform searches from the same activity
   without creating a new activity instance every time.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class SearchResultsActivity : AppCompatActivity() {

                override fun onCreate(savedInstanceState: Bundle?) {
                    super.onCreate(savedInstanceState)
                    setContentView(R.layout.activity_search_results)
                    handleIntent(intent)
                }

                override fun onNewIntent(intent: Intent) {
                    super.onNewIntent(intent)
                    handleIntent(intent)
                }

                private fun handleIntent(intent: Intent) {
                    if (Intent.ACTION_SEARCH == intent.action) {
                        val query = intent.getStringExtra(SearchManager.QUERY)
                        Log.d("SEARCH", "Search query was: $query")
                    }
                }
            }

   Now, the ``SearchView`` can accept the user's query and start your searchable
   activity with the ``ACTION_SEARCH`` intent.

   After you obtain the search query, you can pass it to the ``ViewModel``,
   where you can use it in other layers of your architecture to retrieve the
   search results to display.


Last updated 2024-02-22 UTC.


/Storing and searching for data
===============================

.. https://developer.android.google.cn/develop/ui/views/search/training/search?hl=en

.. container:: devsite-article-body

   There are many ways to store your data, such as in an online database, in a
   local SQLite database, or even in a text file. It is up to you to decide what
   is the best solution for your application. This lesson shows you how to
   create a SQLite virtual table that can provide robust full-text searching.
   The table is populated with data from a text file that contains a word and
   definition pair on each line in the file.

   .. rubric:: Create the Virtual Table
      :name: create

   A virtual table behaves similarly to a SQLite table, but reads and writes to
   an object in memory via callbacks, instead of to a database file. To create a
   virtual table, create a class for the table:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class DatabaseTable(context: Context) {

                private val databaseOpenHelper = DatabaseOpenHelper(context)

            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class DatabaseTable {
                private final DatabaseOpenHelper databaseOpenHelper;

                public DatabaseTable(Context context) {
                    databaseOpenHelper = new DatabaseOpenHelper(context);
                }
            }

   Create an inner class in ``DatabaseTable`` that extends
   `SQLiteOpenHelper <#android.database.sqlite.SQLiteOpenHelper>`__.
   The
   `SQLiteOpenHelper <#android.database.sqlite.SQLiteOpenHelper>`__
   class defines abstract methods that you must override so that your database
   table can be created and upgraded when necessary. For example, here is some
   code that declares a database table that will contain words for a dictionary
   app:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private const val TAG = "DictionaryDatabase"

            // The columns we'll include in the dictionary table
            const val COL_WORD = "WORD"
            const val COL_DEFINITION = "DEFINITION"

            private const val DATABASE_NAME = "DICTIONARY"
            private const val FTS_VIRTUAL_TABLE = "FTS"
            private const val DATABASE_VERSION = 1

            private const val FTS_TABLE_CREATE =
                    "CREATE VIRTUAL TABLE $FTS_VIRTUAL_TABLE USING fts3 ($COL_WORD, $COL_DEFINITION)"

            class DatabaseTable(context: Context) {

                private val databaseOpenHelper: DatabaseOpenHelper

                init {
                    databaseOpenHelper = DatabaseOpenHelper(context)
                }

                private class DatabaseOpenHelper internal constructor(private val helperContext: Context) :
                        SQLiteOpenHelper(helperContext, DATABASE_NAME, null, DATABASE_VERSION) {
                    private lateinit var mDatabase: SQLiteDatabase

                    override fun onCreate(db: SQLiteDatabase) {
                        mDatabase = db
                        mDatabase.execSQL(FTS_TABLE_CREATE)
                    }

                    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
                        Log.w(
                                TAG,
                                "Upgrading database from version $oldVersion to $newVersion , which will " +
                                        "destroy all old data"
                        )

                        db.execSQL("DROP TABLE IF EXISTS $FTS_VIRTUAL_TABLE")
                        onCreate(db)
                    }

                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class DatabaseTable {

                private static final String TAG = "DictionaryDatabase";

                // The columns we'll include in the dictionary table
                public static final String COL_WORD = "WORD";
                public static final String COL_DEFINITION = "DEFINITION";

                private static final String DATABASE_NAME = "DICTIONARY";
                private static final String FTS_VIRTUAL_TABLE = "FTS";
                private static final int DATABASE_VERSION = 1;

                private final DatabaseOpenHelper databaseOpenHelper;

                public DatabaseTable(Context context) {
                    databaseOpenHelper = new DatabaseOpenHelper(context);
                }

                private static class DatabaseOpenHelper extends SQLiteOpenHelper {

                    private final Context helperContext;
                    private SQLiteDatabase mDatabase;

                    private static final String FTS_TABLE_CREATE =
                                "CREATE VIRTUAL TABLE " + FTS_VIRTUAL_TABLE +
                                " USING fts3 (" +
                                COL_WORD + ", " +
                                COL_DEFINITION + ")";

                    DatabaseOpenHelper(Context context) {
                        super(context, DATABASE_NAME, null, DATABASE_VERSION);
                        helperContext = context;
                    }

                    @Override
                    public void onCreate(SQLiteDatabase db) {
                        mDatabase = db;
                        mDatabase.execSQL(FTS_TABLE_CREATE);
                    }

                    @Override
                    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                        Log.w(TAG, "Upgrading database from version " + oldVersion + " to "
                                + newVersion + ", which will destroy all old data");
                        db.execSQL("DROP TABLE IF EXISTS " + FTS_VIRTUAL_TABLE);
                        onCreate(db);
                    }
                }
            }

   .. rubric:: Populate the Virtual Table
      :name: populate

   The table now needs data to store. The following code shows you how to read a
   text file (located in ``res/raw/definitions.txt``) that contains words and
   their definitions, how to parse that file, and how to insert each line of
   that file as a row in the virtual table. This is all done in another thread
   to prevent the UI from locking. Add the following code to your
   ``DatabaseOpenHelper`` inner class.

   **Tip:** You also might want to set up a callback to notify your UI activity
   of this thread's completion.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private fun loadDictionary() {
                Thread(Runnable {
                    try {
                        loadWords()
                    } catch (e: IOException) {
                        throw RuntimeException(e)
                    }
                }).start()
            }

            @Throws(IOException::class)
            private fun loadWords() {
                val inputStream = helperContext.resources.openRawResource(R.raw.definitions)

                BufferedReader(InputStreamReader(inputStream)).use { reader ->
                    var line: String? = reader.readLine()
                    while (line != null) {
                        val strings: List<String> = line.split("-").map { it.trim() }
                        if (strings.size < 2) continue
                        val id = addWord(strings[0], strings[1])
                        if (id < 0) {
                            Log.e(TAG, "unable to add word: ${strings[0]}")
                        }
                        line = reader.readLine()
                    }
                }
            }

            fun addWord(word: String, definition: String): Long {
                val initialValues = ContentValues().apply {
                    put(COL_WORD, word)
                    put(COL_DEFINITION, definition)
                }

                return database.insert(FTS_VIRTUAL_TABLE, null, initialValues)
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private void loadDictionary() {
                    new Thread(new Runnable() {
                        public void run() {
                            try {
                                loadWords();
                            } catch (IOException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }).start();
                }

            private void loadWords() throws IOException {
                final Resources resources = helperContext.getResources();
                InputStream inputStream = resources.openRawResource(R.raw.definitions);
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));

                try {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        String[] strings = TextUtils.split(line, "-");
                        if (strings.length < 2) continue;
                        long id = addWord(strings[0].trim(), strings[1].trim());
                        if (id < 0) {
                            Log.e(TAG, "unable to add word: " + strings[0].trim());
                        }
                    }
                } finally {
                    reader.close();
                }
            }

            public long addWord(String word, String definition) {
                ContentValues initialValues = new ContentValues();
                initialValues.put(COL_WORD, word);
                initialValues.put(COL_DEFINITION, definition);

                return database.insert(FTS_VIRTUAL_TABLE, null, initialValues);
            }

   Call the ``loadDictionary()`` method wherever appropriate to populate the
   table. A good place would be in the
   `onCreate() <#android.database.sqlite.SQLiteOpenHelper>`__
   method of the ``DatabaseOpenHelper`` class, right after you create the table:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onCreate(db: SQLiteDatabase) {
                database = db
                database.execSQL(FTS_TABLE_CREATE)
                loadDictionary()
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            @Override
            public void onCreate(SQLiteDatabase db) {
                database = db;
                database.execSQL(FTS_TABLE_CREATE);
                loadDictionary();
            }

   .. rubric:: Search for the Query
      :name: search

   When you have the virtual table created and populated, use the query supplied
   by your `SearchView <#android.widget.SearchView>`__ to search
   the data. Add the following methods to the ``DatabaseTable`` class to build a
   SQL statement that searches for the query:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            fun getWordMatches(query: String, columns: Array<String>?): Cursor? {
                val selection = "$COL_WORD MATCH ?"
                val selectionArgs = arrayOf("$query*")

                return query(selection, selectionArgs, columns)
            }

            private fun query(
                    selection: String,
                    selectionArgs: Array<String>,
                    columns: Array<String>?
            ): Cursor? {
                val cursor: Cursor? = SQLiteQueryBuilder().run {
                    tables = FTS_VIRTUAL_TABLE
                    query(databaseOpenHelper.readableDatabase,
                            columns, selection, selectionArgs, null, null, null)
                }

                return cursor?.run {
                    if (!moveToFirst()) {
                        close()
                        null
                    } else {
                        this
                    }
                } ?: null
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public Cursor getWordMatches(String query, String[] columns) {
                String selection = COL_WORD + " MATCH ?";
                String[] selectionArgs = new String[] {query+"*"};

                return query(selection, selectionArgs, columns);
            }

            private Cursor query(String selection, String[] selectionArgs, String[] columns) {
                SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
                builder.setTables(FTS_VIRTUAL_TABLE);

                Cursor cursor = builder.query(databaseOpenHelper.getReadableDatabase(),
                        columns, selection, selectionArgs, null, null, null);

                if (cursor == null) {
                    return null;
                } else if (!cursor.moveToFirst()) {
                    cursor.close();
                    return null;
                }
                return cursor;
            }

   Search for a query by calling ``getWordMatches()``. Any matching results are
   returned in a `Cursor <#android.database.Cursor>`__ that you
   can iterate through or use to build a
   `ListView <#android.widget.ListView>`__. This example calls
   ``getWordMatches()`` in the ``handleIntent()`` method of the searchable
   activity. Remember that the searchable activity receives the query inside of
   the `ACTION_SEARCH <#android.content.Intent>`__
   intent as an extra, because of the intent filter that you previously created:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private val db = DatabaseTable(this)

            ...

            private fun handleIntent(intent: Intent) {

                if (Intent.ACTION_SEARCH == intent.action) {
                    val query = intent.getStringExtra(SearchManager.QUERY)
                    val c = db.getWordMatches(query, null)
                    // process Cursor and display results
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            DatabaseTable db = new DatabaseTable(this);

            ...

            private void handleIntent(Intent intent) {

                if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
                    String query = intent.getStringExtra(SearchManager.QUERY);
                    Cursor c = db.getWordMatches(query, null);
                    // process Cursor and display results
                }
            }


Last updated 2024-02-22 UTC.


/Remain backward compatible with Search
=======================================

.. https://developer.android.google.cn/develop/ui/views/search/training/backward-compat?hl=en

.. container:: devsite-article-body

   The `SearchView <#android.widget.SearchView>`__ and action bar
   are only available on Android 3.0 and later. To support older platforms, you
   can fall back to the search dialog. The search dialog is a system provided UI
   that overlays on top of your application when invoked.

   .. rubric:: Set Minimum and Target API levels
      :name: set-sdk

   To setup the search dialog, first declare in your manifest that you want to
   support older devices, but want to target Android 3.0 or later versions. When
   you do this, your application automatically uses the action bar on Android
   3.0 or later and uses the traditional menu system on older devices:

   .. code:: prettyprint

      <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="15" />

      <application>
      ...

   .. rubric:: Provide the Search Dialog for Older Devices
      :name: provide-sd

   To invoke the search dialog on older devices, call
   `onSearchRequested() <#android.app.Activity>`__
   whenever a user selects the search menu item from the options menu. Because
   Android 3.0 and higher devices show the
   `SearchView <#android.widget.SearchView>`__ in the action bar
   (as demonstrated in the first lesson), only versions older than 3.0 call
   `onOptionsItemSelected() <#android.app.Activity>`__
   when the user selects the search menu item.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onOptionsItemSelected(item: MenuItem): Boolean {
                return when (item.itemId) {
                    R.id.search -> {
                        onSearchRequested()
                        true
                    }
                    else -> false
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            @Override
            public boolean onOptionsItemSelected(MenuItem item) {
                switch (item.getItemId()) {
                    case R.id.search:
                        onSearchRequested();
                        return true;
                    default:
                        return false;
                }
            }

   .. rubric:: Check the Android Build Version at Runtime
      :name: check-ver

   At runtime, check the device version to make sure an unsupported use of
   `SearchView <#android.widget.SearchView>`__ does not occur on
   older devices. In our example code, this happens in the
   `onCreateOptionsMenu() <#android.app.Activity>`__
   method:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            override fun onCreateOptionsMenu(menu: Menu): Boolean {

                menuInflater.inflate(R.menu.options_menu, menu)

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                    val searchManager = getSystemService(Context.SEARCH_SERVICE) as SearchManager
                    (menu.findItem(R.id.search).actionView as SearchView).apply {
                        setSearchableInfo(searchManager.getSearchableInfo(componentName))
                        setIconifiedByDefault(false)
                    }
                }
                return true
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            @Override
            public boolean onCreateOptionsMenu(Menu menu) {

                MenuInflater inflater = getMenuInflater();
                inflater.inflate(R.menu.options_menu, menu);

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                    SearchManager searchManager =
                            (SearchManager) getSystemService(Context.SEARCH_SERVICE);
                    SearchView searchView =
                            (SearchView) menu.findItem(R.id.search).getActionView();
                    searchView.setSearchableInfo(
                            searchManager.getSearchableInfo(getComponentName()));
                    searchView.setIconifiedByDefault(false);
                }
                return true;
            }


Last updated 2024-02-22 UTC.


/Autosize text views
====================

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/autosizing-textview?hl=en

.. container:: devsite-article-body

   With Android 8.0 (API level 26) and higher, you can instruct a
   `TextView <#android.widget.TextView>`__ to let the text size
   expand or contract automatically to fill its layout based on the
   ``TextView``'s characteristics and boundaries. This setting makes it easier
   to optimize text size on different screens with dynamic content.

   Support Library 26.0 fully supports the autosizing ``TextView`` feature on
   devices running Android versions 8.0 (API level 26) or lower. The
   ``android.support.v4.widget`` package contains the ``TextViewCompat`` class
   to access features in a backward-compatible fashion.

   .. rubric:: Set up TextView autosize
      :name: setting-textview-autosize

   You can either use the framework or Support Library to set up the autosizing
   of ``TextView`` programmatically or in XML. To set the XML attributes, you
   can also use the **Properties** window in Android Studio.

   There are three ways you can set up the autosizing of ``TextView``, described
   in the sections that follow:

   -  `Default <#default>`__
   -  `Granularity <#granularity>`__
   -  `Preset sizes <#preset-sizes>`__

   **Note**: If you set autosizing in an XML file, we do not recommended using
   the value "wrap_content" for the ``layout_width`` or ``layout_height``
   attributes of a ``TextView``. Doing so might produce unexpected results.

   .. rubric:: Default
      :name: default

   The default setting lets the autosizing of ``TextView`` scale uniformly on
   horizontal and vertical axes.

   -  To define the default setting programmatically, call the
      `setAutoSizeTextTypeWithDefaults(int autoSizeTextType) <#android.widget.TextView>`__
      method. Provide ``AUTO_SIZE_TEXT_TYPE_NONE`` to turn off the autosizing
      feature or ``AUTO_SIZE_TEXT_TYPE_UNIFORM`` to scale the horizontal and the
      vertical axes uniformly.
   -  To define the default setting in XML, use the ``android`` namespace and
      set the
      `autoSizeTextType <#android.widget.TextView>`__
      attribute to *none* or *uniform*.

   .. rubric:: Define the default setting using the Support Library
      :name: define-the-default-setting-using-the-support-library

   -  To define the default setting programmatically through the Support
      Library, call the
      `TextViewCompat.setAutoSizeTextTypeWithDefaults(TextView textview, int autoSizeTextType) <#androidx.core.widget.TextViewCompat>`__
      method. Provide an instance of the ``TextView`` widget and one of the text
      types, such as ``TextViewCompat.AUTO_SIZE_TEXT_TYPE_NONE`` or
      ``TextViewCompat.AUTO_SIZE_TEXT_TYPE_UNIFORM``.
   -  To define the default setting in XML through the Support Library, use the
      ``app`` namespace and set the ``autoSizeTextType`` attribute to *none* or
      *uniform*.

   .. rubric:: Granularity
      :name: granularity

   You can define a range of minimum and maximum text sizes and a dimension that
   specifies the size of each step. The ``TextView`` scales uniformly in a range
   between the minimum and maximum size attributes. Each increment occurs as the
   step size set in the granularity attribute.

   -  To define a range of text sizes and a dimension programmatically, call the
      `setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit) <#android.widget.TextView>`__
      method. Provide the maximum value, the minimum value, the granularity
      value, and any `TypedValue <#android.util.TypedValue>`__
      dimension unit.
   -  To define a range of text sizes and a dimension in XML, use the
      ``android`` namespace and set the following attributes:

      -  Set the ``autoSizeTextType`` attribute to either *none* or *uniform*.
         The *none* value is the default, and *uniform* lets ``TextView`` scale
         uniformly on horizontal and vertical axes.
      -  Set the
         `autoSizeMinTextSize <#android.widget.TextView>`__,
         `autoSizeMaxTextSize <#android.widget.TextView>`__,
         and
         `autoSizeStepGranularity <#android.widget.TextView>`__
         attributes to define the dimensions for the autosizing of ``TextView``.

   .. rubric:: Define granularity using the Support Library
      :name: define-granularity-using-the-support-library

   -  To define a range of text sizes and a dimension programmatically through
      the Support Library, call the
      `TextViewCompat.setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize, int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit) <#androidx.core.widget.TextViewCompat>`__
      method. Provide the maximum value, the minimum value, the granularity
      value, and any ``TypedValue`` dimension unit.
   -  To define a range of text sizes and a dimension in XML through the Support
      Library, use the ``app`` namespace and set the ``autoSizeText``,
      ``autoSizeMinTextSize``, ``autoSizeMaxTextSize``, and
      ``autoSizeStepGranularity`` attributes in the layout XML file.

   .. rubric:: Preset sizes
      :name: preset-sizes

   Preset sizes let you specify the values that the ``TextView`` picks when
   autosizing text.

   -  To use preset sizes to set up the autosizing of ``TextView``
      programmatically, call the
      `setAutoSizeTextTypeUniformWithPresetSizes(int[] presetSizes, int unit) <#android.widget.TextView>`__
      method. Provide an array of sizes and any ``TypedValue`` dimension unit
      for the size.
   -  To use preset sizes to set up the autosizing of ``TextView`` in XML, use
      the ``android`` namespace and set the following attributes:

      -  Set the ``autoSizeTextType`` attribute to either *none* or *uniform*.
         The *none* value is the default, and *uniform* lets ``TextView`` scale
         uniformly on horizontal and vertical axes.
      -  Set the
         `autoSizePresetSizes <#android.widget.TextView>`__
         attribute to an array of preset sizes. To access the array as a
         resource, define the array in the ``res/values/arrays.xml`` file.

   .. rubric:: Set up preset sizes using the Support Library
      :name: set-up-preset-sizes-using-the-support-library

   -  To use preset sizes to set up the autosizing of ``TextView``
      programmatically through the Support Library, call the
      `TextViewCompat.setAutoSizeTextTypeUniformWithPresetSizes(TextView textView, int[] presetSizes, int unit) <#androidx.core.widget.TextViewCompat>`__
      method. Provide an instance of the ``TextView`` class, an array of sizes,
      and any ``TypedValue`` dimension unit for the size.
   -  To use preset sizes to set up the autosizing of ``TextView`` in XML
      through the Support Library, use the ``app`` namespace and set the
      ``autoSizeTextType`` and ``autoSizePresetSizes`` attributes in the layout
      XML file.

   .. rubric:: Additional resources
      :name: additional-resources

   For additional information on autosizing a ``TextView`` when working with
   dynamic content, watch `Android Jetpack: Autosizing TextView <https://www.youtube.com/watch?v=JYrpEAz_A1U>`__.


Last updated 2024-04-29 UTC.


/Download fonts on the fly
==========================

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/downloadable-fonts?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use text in Compose.

      `Downloadable Fonts → <https://developer.android.google.cn/jetpack/compose/text/fonts#downloadable-fonts>`__

      |image-android-compose-ui-logo|

   **Note:** This page describes how to use downloadable fonts with a
   ``View``-based UI. If you're using Jetpack Compose, see the `Downloadable fonts in Compose <#downloadable-fonts>`__
   documentation.
   The Downloadable Fonts feature lets APIs request fonts from a provider
   application instead of bundling files into the app or letting the app
   download fonts. Downloadable Fonts is available on devices running Android
   API versions 14 and higher through the AndroidX Core library.

   Downloadable Fonts offers the following benefits:

   -  Reduces the app size, therefore increasing the app installation success
      rate.
   -  Improves the overall system health, as multiple apps can share the same
      font through a provider. This saves users cellular data, phone memory, and
      disk space. In this model, the font is fetched over the network when
      needed.

   For hands-on experience with Downloadable Fonts, see the
   `DownloadableFonts <https://github.com/android/user-interface-samples/tree/main/DownloadableFonts>`__
   sample app.

   .. rubric:: How does Downloadable Fonts work?
      :name: downloadable-fonts-process

   A font provider is an application that retrieves fonts and caches them
   locally so other apps can request and share fonts. The following figure
   illustrates the process.

   .. figure::
      https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/downloadable-fonts/downloadable-fonts-process.png
      name: process
      :alt: An images showing the main components in Emoji compat process
      :width: 50.0%

      **Figure 1.** Downloadable Fonts process.

   .. rubric:: The basics
      :name: the-basics

   You can use the Downloadable Fonts feature in the following ways, which are
   discussed in detail' in later sections:

   -  `Using Android Studio and Google Play Services <#via-android-studio>`__
   -  `Programmatically <#programmatically>`__
   -  `Using the AndroidX Core library <#via-support-lib>`__

   .. rubric:: Use Downloadable Fonts with Android Studio and Google Play
      services
      :name: via-android-studio

   You can set your application to download fonts by using Android Studio 3.0 or
   higher. To help you get started with Downloadable Fonts features, you can use
   the font provider from Google Play services.

   **Note:** A device must have Google Play services version 11 or higher to use
   the Google Fonts provider.

   #. In the **Layout Editor**, select a ``TextView``. Then, under
      **Attributes**, select **fontFamily > More Fonts**.
      .. figure::
         https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/downloadable-fonts/layout-editor.png
         name: layout-editor
         :alt: An image showing Android Studio Layout Editor
         :width: 100.0%

         **Figure 2.** Using the **Layout Editor**.

      The **Resources** window appears.
   #. In the **Source** menu, select **Google Fonts**.
   #. In the **Fonts** box, select a font under the "Downloadable" area.
   #. Select **Create downloadable font** and click **OK**.
      .. figure::
         https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/downloadable-fonts/resources-window.png
         name: resources-window
         :alt: An image showing how to select fonts from the Resources window
         :width: 100.0%

         **Figure 3.** Selecting a font from the **Resources** window.

   .. rubric:: Use Downloadable Fonts programmatically
      :name: programmatically

   As of Android 8.0 (API level 26), AndroidX Core provides full support for
   Downloadable Fonts. For more information about using the AndroidX Core
   library, see the `Downloadable Fonts AndroidX Core library section <#via-support-lib>`__ on this page.

   To use the Downloadable Fonts feature programmatically, interact with two key
   classes:

   -  `android.graphics.fonts.FontRequest <#>`__:
      this class lets you create a font request.
   -  `FontsContractCompat <#androidx.core.provider.FontsContractCompat>`__:
      this class lets you create a new
      `Typeface <#android.graphics.Typeface>`__ object based on
      the font request.

   Your app retrieves fonts from the font provider by using the
   ``FontsContract`` API. Each provider has its own set of restrictions on the
   Android versions and query language it supports. For more information on the
   Android versions and query format, refer to your provider's documentation.

   To download a font, complete the following steps:

   #. Create an instance of the ``android.graphics.fonts.FontRequest`` class to
      request the font from the provider. To create a request, pass the
      following parameters:

      -  The font provider authority.
      -  The font provider package to verify the identity of the provider.
      -  The string query of the font. For more information about query formats,
         see your font provider's documentation, such as `Google Fonts <https://developers.google.cn/fonts/docs/android>`__.
      -  A list of sets of hashes for the certificates to verify the identity of
         the provider.
         **Note**: It's unnecessary to add a certificate if you request fonts
         from preinstalled providers. However, always provide a certificate if
         you request fonts through AndroidX Core library.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val request = FontRequest(
                          "com.example.fontprovider.authority",
                          "com.example.fontprovider",
                          "my font",
                          certs
                  )

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  FontRequest request = new FontRequest("com.example.fontprovider",
                                     "com.example.fontprovider", "my font", certs);

      **Note**: You can receive the parameter values from your font provider.
      Android Studio automatically populates these values for the providers it
      supports in its UI.
   #. Create an instance of the
      `FontsContract.FontRequestCallback <#android.provider.FontsContract.FontRequestCallback>`__
      class.
   #. Override the
      `onTypefaceRetrieved() <#android.provider.FontsContract.FontRequestCallback>`__
      method to indicate the font request is complete. Provide the retrieved
      font as the parameter. You can use this method to set the font as needed.
      For example, you can set the font on a
      `TextView <#android.widget.TextView>`__.
   #. Override the
      `onTypefaceRequestFailed() <#android.provider.FontsContract.FontRequestCallback>`__
      method to receive information about errors in the font request process.
      For more information about error codes, refer to the `error code constants <#android.provider.FontsContract.FontRequestCallback>`__.
   #. Call the ``FontsContract.requestFont()`` method to retrieve the font from
      the font provider. The method initiates a check to determine whether the
      font exists in the cache. If the font isn't available locally, it calls
      the font provider, retrieves the font asynchronously, and passes the
      result to the callback. Pass the following parameters:

      -  An instance of the `Context <#android.content.Context>`__
         class
      -  An instance of the ``android.graphics.fonts.FontRequest`` class
      -  A callback to receive the results of the font request
      -  A handler to fetch fonts on a thread

   The following sample code illustrates the overall Downloadable Fonts process:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val request = FontRequest(
                       "com.example.fontprovider.authority",
                       "com.example.fontprovider",
                       "my font",
                       certs
               )
               val callback = object : FontsContract.FontRequestCallback() {

                   override fun onTypefaceRetrieved(typeface: Typeface) {
                       // Your code to use the font goes here.
                       ...
                   }

                   override fun onTypefaceRequestFailed(reason: Int) {
                       // Your code to deal with the failure goes here.
                       ...
                   }
               }
               FontsContract.requestFonts(context, request, handler, null, callback)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               FontRequest request = new FontRequest("com.example.fontprovider.authority",
                       "com.example.fontprovider", "my font", certs);
               FontsContract.FontRequestCallback callback =
                   new FontsContract.FontRequestCallback() {
                       @Override
                       public void onTypefaceRetrieved(Typeface typeface) {
                           // Your code to use the font goes here.
                           ...
                       }

                       @Override
                       public void onTypefaceRequestFailed(int reason) {
                           // Your code to deal with the failure goes here.
                           ...
                       }
               };
               FontsContract.requestFonts(context, request, handler, null, callback);

   For more information about how to download a font from a font provider, see
   the
   `DownloadableFonts <https://github.com/android/user-interface-samples/tree/main/DownloadableFonts>`__
   sample app.

   .. rubric:: Use Downloadable Fonts with AndroidX Core
      :name: via-support-lib

   The AndroidX Core provides support for the Downloadable Fonts feature on
   devices running Android API versions 14 or higher. The
   `androidx.core.provider <#androidx.core.provider.package-summary>`__
   package contains ``FontsContractCompat`` and ``FontRequest`` classes to
   implement the backward-compatible Downloadable Fonts feature support. The
   AndroidX classes contain methods similar to the framework methods, and the
   process for downloading fonts is similar to the one described in the section
   on this page about `using Downloadable Fonts programmatically <#programmatically>`__.

   To download fonts using AndroidX, import the ``FontsContractCompat`` and
   ``FontRequest`` classes from the ``androidx.core.provider`` package. Create
   instances of these classes instead of
   `FontsContract <#android.provider.FontsContract>`__ and
   ``android.graphics.fonts.FontRequest`` framework classes.

   **Note:** You *must* provide a certificate when you request fonts through the
   AndroidX Core library. This is applicable even for the preinstalled font
   providers.

   .. rubric:: Add AndroidX Core dependency
      :name: adding-dependency

   To use the ``FontsContractCompat`` and ``FontRequest`` classes, you must
   modify your app project's classpath dependencies within your development
   environment.

   To add AndroidX Core to your application project, add the following
   dependency to your app's ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation "androidx.core:core-ktx:2.2.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation("androidx.core:core-ktx:2.2.0")
               }

   .. rubric:: Use Downloadable Fonts as resources in XML
      :name: using-downloadable-fonts-as-resources

   Android 8.0 (API level 26) and AndroidX Core offer a faster and more
   convenient way to declare a custom font as a resource in the XML layout. This
   means that there is no need to bundle the font as an asset. You can define a
   custom font for your entire theme, which accelerates usability for multiple
   weights and styles, such as bold, medium, or light, when provided.

   #. Create a new XML file in the ``res/font`` folder.
   #. Add a ``<font-family>`` root element and set the font-related attributes,
      as shown in the following sample XML file:
   #. Refer to the file as ``@font/font_file_name`` in the layout XML file. You
      can also use the
      `getFont() <#android.content.res.Resources>`__
      method to retrieve the file programmatically, such as
      ``getFont(R.font.font_file_name)``.

   .. rubric:: Pre-declare fonts in the manifest
      :name: predeclaring-fonts

   Layout inflation and resource retrieval are synchronous tasks. By default,
   the first attempt to retrieve fonts triggers a request to the font provider,
   and therefore increases the first layout time. To avoid the delay, you can
   pre-declare fonts that need to be retrieved in your manifest. After the
   system retrieves the font from the provider, it is available immediately. If
   font retrieval takes longer than expected, the system aborts the fetching
   process and uses the default font.

   To pre-declare fonts in the manifest, complete the following steps:

   #. Create a resources array in ``res/values/arrays.xml`` and declare the
      fonts that you want to prefetch.
   #. Use a ``meta-data`` tag to declare the resource array in your manifest.

   .. rubric:: Add certificates
      :name: adding-certificates

   When a font provider isn't preinstalled, or if you are using the AndroidX
   Core library, declare the certificates the font provider is signed with. The
   system uses the certificates to verify the font provider's identity.

   **Note**: Android Studio can automatically populate the values for the Google
   Play services provider if you use the font selector tool in Android Studio.
   For more information about using Android Studio for downloading fonts, see
   the `Use Downloadable Fonts with Android Studio and Google Play services <#via-android-studio>`__ section on this page.
   Perform the following steps to add certificates:

   #. Create a string array with the certificate details. For more information
      about certificate details, refer to your font provider's documentation.
   #. Set the ``fontProviderCerts`` attribute to the array.

   .. rubric:: Downloadable Fonts in Compose
      :name: compose

   Starting in `Compose 1.2-alpha07 <https://developer.android.google.cn/jetpack/androidx/releases/compose-ui#1.2.0-alpha07>`__,
   you can use the Downloadable Fonts API in your Compose app to download
   `Google Fonts <https://fonts.google.com/>`__ asynchronously and use them in
   your app. For more information, see the `Compose Downloadable Fonts <#downloadable-fonts>`__ documentation.


Last updated 2024-05-03 UTC.



/Add a font as an XML resource
==============================

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/fonts-in-xml?hl=en

.. container:: devsite-article-body

   Android 8.0 (API level 26) introduces fonts in XML, a feature that lets you
   use fonts as resources. You can add the ``font`` file in the ``res/font/``
   folder to bundle fonts as resources. These fonts are compiled in your ``R``
   file and are automatically available in Android Studio. You can access the
   font resources using the ``font`` resource type. For example, to access a
   font resource, use ``@font/myfont``, or ``R.font.myfont``.

   To use the fonts in XML feature on devices running Android 4.1 (API level 16)
   and higher, use Support Library 26.0. For more information on using the
   Support Library, refer to the `Use the Support Library <#using-support-lib>`__ section.

   To add fonts as resources, perform the following steps in Android Studio:

   #. Right-click the **res** folder and go to **New > Android resource
      directory**. The **New Resource Directory** window appears.

   #. In the **Resource type** list, select **font**, then click **OK**.

      **Note**: The name of the resource directory must be **font**.

      |Adding the font resource directory|

      **Figure 1.** Adding the font resource directory.

   #. Add your font files in the ``font`` folder.

      The folder structure below generates ``R.font.dancing_script``,
      ``R.font.lobster``, and ``R.font.typo_graphica``.

      |Adding the font files in the resource directory|

      **Figure 2.** Adding the font files in the ``res/font`` directory.

   #. Double-click a font file to preview the file's fonts in the editor.
      |Previewing the font file|

      **Figure 3.** Previewing the font file.

   .. rubric:: Create a font family
      :name: font-family

   A font family is a set of font files along with style and weight details. In
   Android, you can create a new font family as an XML resource and access it as
   a single unit, instead of referencing each style and weight as separate
   resources. By doing this, you let the system select the correct font based on
   the text style you are using.

   To create a font family, perform the following steps in Android Studio:

   #. Right-click the ``font`` folder and select **New > Font resource file**.
      The **New Resource File** window appears.

   #. Enter the filename, then click **OK**. The new font resource XML opens in
      the editor.

   #. Enclose each font file, style, and weight attribute in the ``<font>``
      element. The following XML illustrates adding font-related attributes in
      the font resource XML:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <font-family xmlns:android="http://schemas.android.com/apk/res/android">
             <font
                 android:fontStyle="normal"
                 android:fontWeight="400"
                 android:font="@font/lobster_regular" />
             <font
                 android:fontStyle="italic"
                 android:fontWeight="400"
                 android:font="@font/lobster_italic" />
         </font-family>

   .. rubric:: Use fonts in XML layouts
      :name: fonts-in-xml

   Use your fonts, either a single font file or a font from a font family, in
   `TextView <#android.widget.TextView>`__ objects or in styles by
   using the ``fontFamily`` attribute.

   **Note:** When you use a font family, the ``TextView`` switches on its own,
   as needed, to use the font files from that family.

   .. rubric:: Add fonts to a TextView
      :name: add-fonts-to-a-textview

   To set a font for a ``TextView``, do one of the following:

   -  In the layout XML file, set the ``fontFamily`` attribute to the font file
      you want to access.

      .. code:: prettyprint

         <TextView
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:fontFamily="@font/lobster"/>

   -  Open the **Properties** window to set the font for the ``TextView``.

      #. Select a view to open the **Properties** window.

         **Note:** The **Properties** window is available only when the design
         editor is open. Select the **Design** tab at the bottom of the window.

      #. Expand the **textAppearance** property, and then select the font from
         the *fontFamily* list.

      #. |Selecting the font from Properties|

         **Figure 4.** Selecting the font from the **Properties** window.

   The Android Studio layout preview, shown in the rightmost pane in Figure 5,
   lets you preview the font set in the ``TextView``.

   |Previewing fonts in layout preview|
   **Figure 5.** Previewing fonts in layout preview.

   .. rubric:: Add fonts to a style
      :name: add-fonts-to-a-style

   Open the ``styles.xml`` file and set the ``fontFamily`` attribute to the font
   file you want to access.

   .. code:: prettyprint

      <style name="customfontstyle" parent="@android:style/TextAppearance.Small">
          <item name="android:fontFamily">@font/lobster</item>
      </style>

   .. rubric:: Use fonts programmatically
      :name: fonts-in-code

   To retrieve fonts programmatically, call the
   `getFont(int) <#android.content.res.Resources>`__
   method and provide the resource identifier of the font you want to retrieve.
   This method returns a `Typeface <#android.graphics.Typeface>`__
   object. Although the system picks the best style for you from the fonts'
   information, you can use the
   `setTypeface(android.graphics.Typeface, int) <#android.widget.TextView>`__
   method to set the typeface with specific styles.

   **Note:** The ``TextView`` does this for you.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val typeface = resources.getFont(R.font.myfont)
               textView.typeface = typeface

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Typeface typeface = getResources().getFont(R.font.myfont);
               textView.setTypeface(typeface);

   .. rubric:: Use the Support Library
      :name: using-support-lib

   The Support Library 26.0 supports fonts in XML on devices running Android 4.1
   (API level 16) and higher.

   **Note**: When you declare font families in XML layout through the Support
   Library, use the **app** namespace to ensure that your fonts load.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <font-family xmlns:app="http://schemas.android.com/apk/res-auto">
          <font app:fontStyle="normal" app:fontWeight="400" app:font="@font/myfont-Regular"/>
          <font app:fontStyle="italic" app:fontWeight="400" app:font="@font/myfont-Italic" />
      </font-family>

   To retrieve fonts programmatically, call the
   ``ResourceCompat.getFont(Context, int)`` method and provide an instance of
   ``Context`` and the resource identifier.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val typeface = ResourcesCompat.getFont(context, R.font.myfont)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Typeface typeface = ResourcesCompat.getFont(context, R.font.myfont);


Last updated 2024-04-29 UTC.

.. |Adding the font resource directory| image:: https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/fonts-in-xml/resource-directory-font.png
.. |Adding the font files in the resource directory| image:: https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/fonts-in-xml/font-files-structure.png
.. |Previewing the font file| image:: https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/fonts-in-xml/preview-font.png
.. |Selecting the font from Properties| image:: https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/fonts-in-xml/property-window.png
.. |Previewing fonts in layout preview| image:: https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/fonts-in-xml/xml-font-preview.png


/Add support for modern emoji
=============================

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/emoji2?hl=en

.. container:: devsite-article-body

   **Important:**\  This page describes the
   `androidx.emoji2:emoji2 <#>`__ library,
   which replaces the deprecated androidx.emoji:emoji library.
   The standard set of emoji is `refreshed annually by Unicode <https://emojipedia.org/new/>`__, as emoji usage is increasing
   rapidly for all types of apps.

   If your app displays internet content or provides text input, *we strongly
   recommend supporting the latest emoji fonts.* Otherwise, later emoji might be
   displayed as a small square box called *tofu* (☐) or other incorrectly
   rendered emoji sequences.

   Android versions 11 (API level 30) and lower can't update the emoji font, so
   apps that display them on those versions must be updated manually.

   The following are examples of modern emoji.

   ======== ==============================================================
   Examples Version
   ======== ==============================================================
   🫠 🫱🏼‍🫲🏿 🫰🏽 `14.0 <https://emojipedia.org/emoji-14.0/>`__ (September 2021)
   😶‍🌫️ 🧔🏻‍♀️ 🧑🏿‍❤️‍🧑🏾 `13.1 <https://emojipedia.org/emoji-13.1/>`__ (September 2020)
   🥲 🥷🏿 🐻‍❄️ `13.0 <https://emojipedia.org/unicode-13.0/>`__ (March 2020)
   🧑🏻‍🦰 🧑🏿‍🦯 👩🏻‍🤝‍👩🏼 `12.1 <https://emojipedia.org/emoji-12.1/>`__ (October 2019)
   🦩 🦻🏿 👩🏼‍🤝‍👩🏻 `12.0 <https://emojipedia.org/emoji-12.0/>`__ (February 2019)
   ======== ==============================================================

   The ``androidx.emoji2:emoji2`` library provides simpler
   backward-compatibility with lower versions of Android. The ``emoji2`` library
   is a dependency of the
   `AppCompat <#>`__ library and requires
   no further configuration to work.

   .. rubric:: Emoji support in Compose
      :name: emoji-compose

   `BOM March 2023 <#>`__ (`Compose UI
   1.4 <#version_14_2)>`__) brings support
   for the latest emoji version, including backwards compatibility with older
   Android versions down to API 21. This page covers how to configure modern
   emoji in the View system. See the `Emoji in Compose <#>`__ page for more.

   .. rubric:: Prerequisites
      :name: prerequsities

   To confirm that your app properly displays newer emoji, launch it on a device
   running Android 10 (API level 29) or lower. This page includes modern emoji
   you can display for testing.

   .. rubric:: Use AppCompat to support the latest emoji
      :name: appcompat

   ``AppCompat`` 1.4 includes support for emoji.

   To use ``AppCompat`` to support emoji, do the following:

   #. Check that your module depends on the ``AppCompat`` library version
      `1.4.0-alpha01 <#1.4.0-alpha01>`__ or
      higher.

      .. code:: prettyprint

         build.gradle

         // Ensure version is 1.4.0-alpha01 or higher.
         implementation "androidx.appcompat:appcompat.$appcompatVersion"

   #. Ensure all activities that display text extend the
      `AppCompatActivity <#androidx.appcompat.app.AppCompatActivity>`__
      class.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  MyActivity.kt

                  class MyActivity: AppCompatActivity {
                  ...
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  MyActivity.java

                  class MyActivity extends AppCompatActivity {
                  ...
                  }

   #. Test your integration by launching your app on a device running Android 10
      or lower and displaying the following test string. Make sure all
      characters render correctly.

      -  14.0: 🫠, 🫱🏼‍🫲🏿, 🫰🏽
      -  13.1: 😶‍🌫️, 🧔🏻‍♀️, 🧑🏿‍❤️‍🧑🏾
      -  13.0: 🥲, 🥷🏿, 🐻‍❄️
      -  12.1: 🧑🏻‍🦰, 🧑🏿‍🦯, 👩🏻‍🤝‍👩🏼
      -  12.0: 🦩, 🦻🏿, 👩🏼‍🤝‍👩🏻

   Your app automatically displays backward-compatible emoji on all devices that
   provide an ``emoji2``-compatible downloadable fonts provider, such as devices
   powered by `Google Play services <https://developers.google.cn/android>`__.

   .. rubric:: If your app is using AppCompat but displays tofu (☐)
      :name: appcompat-displays-tofu

   In some cases, your app might display tofu instead of the proper emoji, even
   if you add the ``AppCompat`` library. The following are possible explanations
   and solutions.

   .. rubric:: You're running the app on a recently flashed device or a new
      emulator
      :name: appcompat-displays-tofu-new-or-flashed-device

   Clear the app's Google Play services data to clear any font caching that
   might happen during startup. This typically resolves the issue after a few
   hours.

   To clear the app data, do the following:

   #. Open **Settings** on your Android-powered device.

   #. Tap **Apps & notifications**.

   #. Tap **See all apps** or **App info**.

   #. Scroll through the apps and tap **Google Play services**.

   #. Tap **Storage & cache**.

   #. Tap **Clear cache**.

   .. rubric:: Your app isn't using an AppCompat text-related class
      :name: appcompat-displays-tofu-not-using-appcompat

   This can happen if you don't extend ``AppCompatActivity`` or if you
   instantiate a view in code, such as ``TextView``. Check for the following:

   -  The activity extends ``AppCompatActivity``.
   -  If creating the view in code, use the correct `AppCompat subclass <#custom-views-appcompat>`__.

   ``AppCompatActivity`` automatically inflates ``AppCompatTextView`` in place
   of ``TextView`` when inflating XML, so you don't need to update your XML.

   .. rubric:: The test phone doesn't support downloadable fonts
      :name: appcompat-displays-tofu-no-downloadable-font-support

   Verify that ``DefaultEmojiCompatConfig.create`` returns a non-null
   configuration.

   .. rubric:: An emulator on an earlier API level hasn't upgraded Google Play
      services
      :name: appcompat-displays-tofu-earlier-emulator-has-early-google-play-services

   When using an emulator on an earlier API level, you might need to update the
   bundled Google Play services for ``emoji2`` to find the font provider. To do
   this, log in to the Google Play Store on the emulator.

   To verify that a compatible version is installed, do the following:

   #. Run the following command:

      .. code:: prettyprint

         adb shell dumpsys package com.google.android.gms | grep version

   #. Check that the ``versionCode`` is higher than ``211200000``.

   .. rubric:: Support emoji without AppCompat
      :name: support-without-appcompat

   If your app can't include ``AppCompat``, it can use ``emoji2`` directly. This
   requires more work, so only use this method if your app *can't* use
   ``AppCompat``.

   To support emoji without the ``AppCompat`` library, do the following:

   #. In your app's ``build.gradle`` file, include ``emoji2`` and
      ``emoji2-views``.

      .. code:: prettyprint

         build.gradle

         def emojiVersion = "1.0.0-alpha03"
         implementation "androidx.emoji2:emoji2:$emojiVersion"
         implementation "androidx.emoji2:emoji2-views:$emojiVersion"

      The ``emoji2-views`` module provides
      `subclasses <#androidx.emoji2.widget.package-summary>`__ of
      ``TextView``, ``Button``, and ``EditText`` that implement
      `EmojiCompat <#androidx.emoji2.text.EmojiCompat>`__. Don't
      use it in an app that includes ``AppCompat``, because it already
      implements ``EmojiCompat``.

   #. In XML and code—wherever you use ``TextView``, ``EditText``, or
      ``Button``—use
      `EmojiTextView <#androidx.emoji2.widget.EmojiTextView>`__,
      `EmojiEditText <#androidx.emoji2.widget.EmojiEditText>`__,
      or `EmojiButton <#androidx.emoji2.widget.EmojiButton>`__
      instead.

      .. code:: prettyprint

         activity_main.xml

         <androidx.emoji2.widget.EmojiTextView ... />
         <androidx.emoji2.widget.EmojiEditText ... />
         <androidx.emoji2.widget.EmojiButton ... />

      By including the ``emoji2`` module, the system uses the default
      downloadable fonts provider to `load the emoji font automatically <#impact-automatic-config>`__ shortly after app startup. No
      further configuration is needed.

   #. To test your integration, launch your app on a device running Android 11
      or lower and displaying the following test strings. Make sure all
      characters render correctly.

      -  14.0: 🫠, 🫱🏼‍🫲🏿, 🫰🏽
      -  13.1: 😶‍🌫️, 🧔🏻‍♀️, 🧑🏿‍❤️‍🧑🏾
      -  13.0: 🥲, 🥷🏿, 🐻‍❄️
      -  12.1: 🧑🏻‍🦰, 🧑🏿‍🦯, 👩🏻‍🤝‍👩🏼
      -  12.0: 🦩, 🦻🏿, 👩🏼‍🤝‍👩🏻

   .. rubric:: Use EmojiCompat without widgets
      :name: no-widgets

   ``EmojiCompat`` uses
   `EmojiSpan <#androidx.emoji2.text.EmojiSpan>`__ to render
   correct images. Therefore, it has to convert any given
   `CharSequence <#>`__ object into a
   `Spanned <#android.text.Spanned>`__ object with ``EmojiSpan``
   objects. The EmojiCompat class provides the ``process()`` method to convert
   ``CharSequences`` into ``Spanned`` instances. Using this method, you can call
   ``process()`` in the background and cache the results, which improves the
   performance of your app.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val processed = EmojiCompat.get().process("neutral face \uD83D\uDE10")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               CharSequence processed = EmojiCompat.get().process("neutral face \uD83D\uDE10");

   .. rubric:: Use EmojiCompat for input method editors
      :name: ime

   The ``EmojiCompat`` class lets keyboards render the emoji supported by the
   app they are interacting with. `Input method editors (IMEs) <#>`__ can use the
   `getEmojiMatch() <#androidx.emoji2.text.EmojiCompat>`__
   method to check whether an instance of ``EmojiCompat`` is capable of
   rendering an emoji. This method takes a
   `CharSequence <#>`__ of an emoji and
   returns ``true`` if ``EmojiCompat`` can detect and render the emoji.

   The keyboard can also check the version of ``EmojiCompat`` that the app
   supports to determine which emoji to render in the palette. To check the
   version, if available, the keyboard can look for the following keys in the
   `EditorInfo.extras <#android.view.inputmethod.EditorInfo>`__
   bundle:

   -  `EDITOR_INFO_METAVERSION_KEY <#androidx.emoji2.text.EmojiCompat>`__:
      represents the version of the emoji metadata that the app uses. If this
      key doesn't exist, then the app isn't using ``EmojiCompat``.
   -  `EDITOR_INFO_REPLACE_ALL_KEY <#androidx.emoji2.text.EmojiCompat>`__:
      if the key exists and is set to ``true``, then the app configures
      ``EmojiCompat`` to replace all emoji, even if they are present in the
      system.

   Learn more about how to `configure an instance of EmojiCompat <#modify-behavior>`__.

   .. rubric:: Use emoji in custom views
      :name: custom-views

   If your app has `custom views <#>`__ that
   are direct or indirect subclasses of ``TextView``—for example, ``Button``,
   ``Switch``, or ``EditText``—and those views can display user-generated
   content, they must each implement
   `EmojiCompat <#>`__.

   The process varies depending on whether your app uses the ``AppCompat``
   library.

   .. rubric:: Add custom views for apps with AppCompat
      :name: custom-views-appcompat

   If your app uses ``AppCompat``, extend the ``AppCompat`` implementation
   instead of the platform implementation. Use the following table as a guide
   for how to extend your views in ``AppCompat``:

   ============================= ======================================
   **Instead of extending...**   **Extend**
   ============================= ======================================
   ``TextView``                  ``AppCompatTextView``
   ``EditText``                  ``AppCompatEditText``
   ``ToggleButton``              ``AppCompatToggleButton``
   ``Switch``                    ``SwitchCompat``
   ``Button``                    ``AppCompatButton``
   ``CheckedTextView``           ``AppCompatCheckedTextView``
   ``RadioButton``               ``AppCompatRadioButton``
   ``CheckBox``                  ``AppCompatCheckBox``
   ``AutoCompleteTextView``      ``AppCompatAutoCompleteTextView``
   ``MultiAutoCompleteTextView`` ``AppCompatMultiAutoCompleteTextView``
   ============================= ======================================

   .. rubric:: Add custom views for apps without AppCompat
      :name: custom-views-no-appcompat

   If your app doesn't use ``AppCompat``, use the view integration helpers in
   the ``emoji2-views-helper`` module that are designed for use in custom views.
   These are the helpers that the ``AppCompat`` library uses to implement emoji
   support.

   Complete the following steps to support custom views for apps that don't use
   ``AppCompat``.

   #. Add the ``emoji2-views-helper`` library:

      .. code:: prettyprint

         implementation "androidx.emoji2:emoji2-views-helper:$emojiVersion"

   #. Follow the instructions to include
      `EmojiTextViewHelper <#androidx.emoji2.viewsintegration.EmojiTextViewHelper>`__
      or
      `EmojiEditTextHelper <#androidx.emoji2.viewsintegration.EmojiEditTextHelper>`__
      in your app's custom views.

   #. Test your integration by launching your app on a device running Android 10
      or lower and displaying the following test string. Make sure all
      characters render correctly.

      -  14.0: 🫠, 🫱🏼‍🫲🏿, 🫰🏽
      -  13.1: 😶‍🌫️, 🧔🏻‍♀️, 🧑🏿‍❤️‍🧑🏾
      -  13.0: 🥲, 🥷🏿, 🐻‍❄️
      -  12.1: 🧑🏻‍🦰, 🧑🏿‍🦯, 👩🏻‍🤝‍👩🏼
      -  12.0: 🦩, 🦻🏿, 👩🏼‍🤝‍👩🏻

   **Note:**\  For apps not using ``AppCompat``, you can either extend the
   ``EmojiCompat*View`` classes or use view helper classes to integrate
   manually.

   .. rubric:: Optional features for handling emoji2
      :name: optional-features

   After you include the ``emoji2`` library in your app, you can add the
   optional features that are described in this section.

   .. rubric:: Configure emoji2 to use a different font or downloadable font
      provider
      :name: use-different-font-provider

   To configure ``emoji2`` to use a different font or downloadable font
   provider, do the following:

   #. Disable the
      `EmojiCompatInitializer <#androidx.emoji2.text.EmojiCompatInitializer>`__
      by adding the following to your manifest:

      .. code:: prettyprint

         <provider
         android:name="androidx.startup.InitializationProvider"
         android:authorities="${applicationId}.androidx-startup"
         android:exported="false"
         tools:node="merge">
         <meta-data android:name="androidx.emoji2.text.EmojiCompatInitializer"
                    tools:node="remove" />
         </provider>

   #. Do one of the following:

      -  Use the default configuration by calling
         `DefaultEmojiCompatConfiguration.create(context) <#androidx.emoji2.text.DefaultEmojiCompatConfig>`__.

      -  Create your own configuration to load fonts from another source using
         `EmojiCompat.Config <#androidx.emoji2.text.EmojiCompat.Config>`__.
         This class provides several options to modify your ``EmojiCompat``
         behavior, as described in the following section.

   **Caution:**\  If you disable the default configuration, verify that emoji
   appear correctly in your app. Call ``EmojiCompat.init`` shortly after
   startup. You can safely call ``init()`` from ``Application.onCreate()``,
   passing in
   `LOAD_STRATEGY_MANUAL <#androidx.emoji2.text.EmojiCompat>`__,
   and then later call
   `EmojiCompat.load() <#androidx.emoji2.text.EmojiCompat>`__
   from a background thread.

   .. rubric:: Modify your EmojiCompat behavior
      :name: modify-behavior

   You can use an instance of ``EmojiCompat.Config`` to modify ``EmojiCompat``
   behavior.

   The most important configuration option is
   `setMetadataLoadStrategy() <#androidx.emoji2.text.EmojiCompat.Config>`__,
   which controls when ``EmojiCompat`` loads the font. Font loading begins as
   soon as ``EmojiCompat.load()`` is called, and this triggers any necessary
   downloads. The system creates a thread for font downloading unless your app
   provides one.

   ``LOAD_STRATEGY_MANUAL`` lets you control when ``EmojiCompat.load()`` is
   called, and
   `LOAD_STRATEGY_DEFAULT <#androidx.emoji2.text.EmojiCompat>`__
   makes loading start synchronously in the call to
   `EmojiCompat.init() <#androidx.emoji2.text.EmojiCompat>`__.

   Most apps use ``LOAD_STRATEGY_MANUAL`` so they can control the thread and
   timing of font loading. Your app must defer until after the first screen
   displays to avoid introducing startup latency. ``EmojiCompatInitializer``
   follows this practice and defers loading the emoji font until after the first
   screen resumes.

   Use the following methods from the base class to set other aspects of the
   configuration:

   -  `setReplaceAll() <#androidx.emoji2.text.EmojiCompat.Config>`__:
      determines whether ``EmojiCompat`` replaces all emoji it finds with
      instances of ``EmojiSpan``. By default, when ``EmojiCompat`` infers that
      the system can render an emoji, it doesn't replace that emoji. When set to
      ``true``, ``EmojiCompat`` replaces all emoji with ``EmojiSpan`` objects.
   -  `setEmojiSpanIndicatorEnabled() <#androidx.emoji2.text.EmojiCompat.Config>`__:
      indicates whether ``EmojiCompat`` replaces an emoji with an ``EmojiSpan``
      object. When set to ``true``, ``EmojiCompat`` draws a background for the
      ``EmojiSpan``. This method is mainly used for debugging purposes.
   -  `setEmojiSpanIndicatorColor <#androidx.emoji2.text.EmojiCompat.Config>`__:
      sets the color to indicate an ``EmojiSpan``. The default value is
      `GREEN <#android.graphics.Color>`__.
   -  `registerInitCallback() <#androidx.emoji2.text.EmojiCompat.Config>`__:
      informs an app about the state of the ``EmojiCompat`` initialization.

   .. rubric:: Add initialization listeners
      :name: add-initialization-listeners

   ``EmojiCompat`` and ``EmojiCompat.Config`` classes provide the
   `registerInitCallback() <#androidx.emoji2.text.EmojiCompat>`__
   and
   `unregisterInitCallback() <#androidx.emoji2.text.EmojiCompat>`__
   methods to register and unregister initialization callbacks. Your app uses
   these callbacks to wait until ``EmojiCompat`` is initialized before you
   process emoji on a background thread or in a custom view.

   To use these methods, create an instance of the
   `EmojiCompat.InitCallback <#androidx.emoji2.text.EmojiCompat.InitCallback>`__
   class. Call these methods and pass in the instance of the
   ``EmojiCompat.InitCallback`` class. When the initialization is successful,
   the ``EmojiCompat`` class calls the
   `onInitialized() <#androidx.emoji2.text.EmojiCompat.InitCallback>`__
   method. If the library fails to initialize, the ``EmojiCompat`` class calls
   the
   `onFailed() <#androidx.emoji2.text.EmojiCompat.InitCallback>`__
   method.

   To check the initialization state at any point, call the
   `getLoadState() <#androidx.emoji2.text.EmojiCompat>`__
   method. This method returns one of the following values:
   `LOAD_STATE_LOADING <#androidx.emoji2.text.EmojiCompat>`__,
   `LOAD_STATE_SUCCEEDED <#androidx.emoji2.text.EmojiCompat>`__,
   or
   `LOAD_STATE_FAILED <#androidx.emoji2.text.EmojiCompat>`__.

   .. rubric:: Support bundled fonts with emoji2
      :name: support-bundled-fonts

   You can use the ``emoji2-bundled`` artifact to bundle an emoji font into your
   app. **However, because the ``NotoColorEmoji`` font is over 10 MB, we
   strongly recommend that your app use downloadable fonts when possible.** The
   ``emoji2-bundled`` artifact is intended for apps on devices that don't
   support downloadable fonts.

   To use the ``emoji2-bundled`` artifact, do the following:

   #. Include ``emoji2-bundled`` and ``emoji2`` artifacts:

      .. code:: prettyprint

         implementation "androidx.emoji2:emoji2:$emojiVersion"
         implementation "androidx.emoji2:emoji2-bundled:$emojiVersion"

      **Caution:**\  Including the ``emoji2-bundled`` artifact disables the
      ``EmojiCompatInitializer``, so your app must call ``EmojiCompat.init()``.

   #. Configure ``emoji2`` to use the bundled configuration:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  EmojiCompat.init(BundledEmojiCompatConfig(context))

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  EmojiCompat.init(new BundledEmojiCompatConfig(context));

   #. Test the integration by following the preceding steps for including
      ``emojicompat`` with or without ``AppCompat``. Make sure the test string
      displays correctly.

      -  14.0: 🫠, 🫱🏼‍🫲🏿, 🫰🏽
      -  13.1: 😶‍🌫️, 🧔🏻‍♀️, 🧑🏿‍❤️‍🧑🏾
      -  13.0: 🥲, 🥷🏿, 🐻‍❄️
      -  12.1: 🧑🏻‍🦰, 🧑🏿‍🦯, 👩🏻‍🤝‍👩🏼
      -  12.0: 🦩, 🦻🏿, 👩🏼‍🤝‍👩🏻

   .. rubric:: Impact of automatic EmojiCompat configuration
      :name: impact-automatic-config

   The system applies default configuration using the startup library,
   ``EmojiCompatInitializer``, and
   `DefaultEmojiCompatConfig <#androidx.emoji2.text.DefaultEmojiCompatConfig>`__.

   After the first activity resumes in your app, the initializer schedules emoji
   font loading. This brief delay lets your app display its initial content
   without any potential latency due to font loading in a background thread.

   ``DefaultEmojiCompatConfig`` looks for a system-installed downloadable font
   provider that implements the ``EmojiCompat`` interface, such as Google Play
   services. On devices powered by Google Play services, this loads the font
   using Google Play services.

   **Note:**\  The default ``emoji2`` configuration uses downloadable fonts to
   fetch a compatible font file. On devices powered by Google Play services, the
   app sends this query at startup to Google Play services. The request for a
   font is logged by Google Play services and downloadable fonts.
   The initializer creates a background thread to load the emoji font, and font
   download can take up to 10 seconds before timing out. After the font is
   downloaded, it takes approximately 150 milliseconds on a background thread to
   initialize ``EmojiCompat``.

   Defer the initialization of ``EmojiCompat``, even if you disable
   ``EmojiCompatInitializer``. If you `manually configure ``EmojiCompat`` <#modify-behavior>`__, call ``EmojiCompat.load()`` after it
   displays the first screen of your app to avoid background contention with the
   first screen load.

   After loading, ``EmojiCompat`` uses about 300 KB of RAM to hold the emoji
   metadata.


Last updated 2024-05-03 UTC.


/Keep up to date with emoji
===========================

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/emoji-compat?hl=en

.. container:: devsite-article-body

   **Caution:** As of late 2021, the ``androidx.emoji:emoji`` library is
   deprecated in favor of ``androidx.emoji2:emoji2``, which provides integration
   into ``androidx.appcompat``.

   To support modern emoji and simplify backward-compatibility with lower
   versions of Android, it's recommended that you migrate to the
   `androidx.emoji2:emoji2 <#>`__ library.
   For details on how to implement, see `Support modern emoji <#>`__.

   The `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ support
   library aims to keep Android devices up to date with the latest emoji. It
   prevents your app from showing missing emoji characters in the form of ☐,
   which indicates that your device does not have a font to display the text. By
   using the `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
   support library, your app users do not need to wait for Android OS updates to
   get the latest emoji.

   .. figure::
      https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/emoji-compat/emoji-comparison.png
      :alt: Devices showing emoji

      **Figure 1.** Emoji comparison

   Refer to the following related resources:

   -  Emoji Compatibility sample app
      `Java <https://github.com/android/user-interface-samples/tree/main/EmojiCompat>`__
      \|
      `Kotlin <https://github.com/android/user-interface-samples/tree/main/EmojiCompatKotlin>`__

   .. rubric:: How does EmojiCompat work?
      :name: how-does-emojicompat-work

   The `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ support
   library provides classes to implement backward-compatible emoji support on
   devices running Android 4.4 (API level 19) and higher. You can configure
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ with either
   bundled or downloadable fonts. For more information about configuration,
   refer to the following sections:

   -  `Downloadable fonts configuration <#downloadable-fonts>`__
   -  `Bundled fonts configuration <#bundled-fonts>`__

   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ identifies
   emoji for a given `CharSequence <#>`__,
   replaces them with
   `EmojiSpans <#androidx.emoji.text.EmojiSpan>`__, if required,
   and finally renders the emoji glyphs. Figure 2 demonstrates the process.

   .. figure::
      https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/emoji-compat/architecture.png
      :alt: EmojiCompat process

      **Figure 2.** EmojiCompat process

   .. rubric:: Downloadable fonts configuration
      :name: downloadable-fonts

   The downloadable fonts configuration uses the Downloadable Fonts support
   library feature to download an emoji font. It also updates the necessary
   emoji metadata that the
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ support
   library needs to keep up with the latest versions of the Unicode
   specification.

   .. rubric:: Adding support library dependency
      :name: downloadable-fonts-supplib-dependency

   To use the `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
   support library, you must modify your app project's classpath dependencies
   within your development environment.

   To add a support library to your application project:

   #. Open the ``build.gradle`` file of your application.
   #. Add the support library to the ``dependencies`` section.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation "androidx.emoji:emoji:28.0.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   ...
                   implementation("androidx.emoji:emoji:28.0.0")
               }

   .. rubric:: Initializing the downloadable font configuration
      :name: downloadable-fonts-config

   You need to initialize
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ to load the
   metadata and the typeface. Since initialization can take some time, the
   initialization process runs on a background thread.

   To initialize
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ with the
   downloadable font configuration, perform the following steps:

   #. Create an instance of the
      `FontRequest <#androidx.core.provider.FontRequest>`__ class
      and provide the font provider authority, the font provider package, the
      font query, and a list of sets of hashes for the certificate. For more
      information about
      `FontRequest <#androidx.core.provider.FontRequest>`__, refer
      to the `Using Downloadable Fonts programmatically <#programmatically>`__
      section in the `Downloadable Fonts <#>`__
      documentation.
   #. Create an instance of
      `FontRequestEmojiCompatConfig <#androidx.emoji.text.FontRequestEmojiCompatConfig>`__
      and provide instances of
      `Context <#android.content.Context>`__ and
      `FontRequest <#androidx.core.provider.FontRequest>`__.
   #. Initialize
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ by
      calling the
      `init() <#androidx.emoji.text.EmojiCompat>`__
      method and pass the instance of
      `FontRequestEmojiCompatConfig <#androidx.emoji.text.FontRequestEmojiCompatConfig>`__.
   #. Use `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
      widgets in layout XMLs. If you are using
      `AppCompat <#android.support.v7.appcompat.package-summary>`__,
      refer to the `Using EmojiCompat widgets with AppCompat <#using-widgets-with-appcompat>`__ section.

   For more information about how to configure
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ with the
   downloadable font configuration, go to Emoji Compatibility sample app
   `Java <https://github.com/android/user-interface-samples/tree/main/EmojiCompat>`__
   \|
   `Kotlin <https://github.com/android/user-interface-samples/tree/main/EmojiCompatKotlin>`__.

   .. rubric:: Library components
      :name: library-components

   .. figure::
      https://developer.android.google.cn/static/guide/topics/ui/images/look-and-feel/emoji-compat/basic-components.png
      :alt: Library components in EmojiCompat process

      **Figure 3.** Library components in the EmojiCompat process

   Widgets: `EmojiEditText <#androidx.emoji.widget.EmojiEditText>`__, `EmojiTextView <#androidx.emoji.widget.EmojiTextView>`__, `EmojiButton <#androidx.emoji.widget.EmojiButton>`__
      Default widget implementations to use
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ with
      `TextView <#android.widget.TextView>`__,
      `EditText <#android.widget.EditText>`__, and
      `Button <#android.widget.Button>`__.
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
      Main public surface for the support library. It performs all the external
      calls and coordinates with the other parts of the system.
   `EmojiCompat.Config <#androidx.emoji.text.EmojiCompat.Config>`__
      Configures the singleton instance to be created.
   `EmojiSpan <#androidx.emoji.text.EmojiSpan>`__
      A `ReplacementSpan <#android.text.style.ReplacementSpan>`__
      subclass that replaces the character (sequences) and renders the glyph.
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ Font
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ uses a
      font to display emoji. This font is a modified version of the `Android Emoji font <https://www.google.com/get/noto/help/emoji/>`__. The font is
      modified as follows:

      -  To provide backward compatibility to render emoji, all emoji characters
         are represented with a single Unicode code point in Unicode’s
         Supplemental Private Use Area-A starting with U+F0001.
      -  Extra emoji metadata is inserted in a binary format into the font and
         is parsed at runtime by
         `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__. The
         data is embedded in the font’s ``meta`` table, with the private tag
         *Emji*.

   .. rubric:: Configuration options
      :name: configuration-options

   You can use the
   `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ instance to
   modify `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
   behavior. You can use the following methods from the base class to set the
   configuration:

   -  `setReplaceAll() <#androidx.emoji.text.EmojiCompat.Config>`__:
      Determines whether
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ should
      replace all emoji it finds with
      `EmojiSpans <#androidx.emoji.text.EmojiSpan>`__. By default,
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ tries its
      best to understand if the system can render an emoji and does not replace
      those emoji. When set to ``true``,
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ replaces
      all emoji it finds with
      `EmojiSpans <#androidx.emoji.text.EmojiSpan>`__.
   -  `setEmojiSpanIndicatorEnabled() <#androidx.emoji.text.EmojiCompat.Config>`__:
      Indicates whether
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ has
      replaced an emoji with an
      `EmojiSpan <#androidx.emoji.text.EmojiSpan>`__. When set to
      ``true``, `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
      draws a background for the
      `EmojiSpan <#androidx.emoji.text.EmojiSpan>`__. This method
      is mainly used for debugging purposes.
   -  `setEmojiSpanIndicatorColor() <#androidx.emoji.text.EmojiCompat.Config>`__:
      Sets the color to indicate an
      `EmojiSpan <#androidx.emoji.text.EmojiSpan>`__. The default
      value is `GREEN <#android.graphics.Color>`__.
   -  `registerInitCallback <#androidx.emoji.text.EmojiCompat>`__:
      Informs app about the state of the
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
      initialization.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val config = FontRequestEmojiCompatConfig(...)
                       .setReplaceAll(true)
                       .setEmojiSpanIndicatorEnabled(true)
                       .setEmojiSpanIndicatorColor(Color.GREEN)
                       .registerInitCallback(object: EmojiCompat.InitCallback() {
                           ...
                       })

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               EmojiCompat.Config config = new FontRequestEmojiCompatConfig(...)
                      .setReplaceAll(true)
                      .setEmojiSpanIndicatorEnabled(true)
                      .setEmojiSpanIndicatorColor(Color.GREEN)
                      .registerInitCallback(new InitCallback() {...})

      .. rubric:: Adding initialization listeners
         :name: adding-listeners

      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ and
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ classes
      provide
      `registerInitCallback() <#androidx.emoji.text.EmojiCompat>`__
      and
      `unregisterInitCallback() <#androidx.emoji.text.EmojiCompat>`__
      methods to register an initialization callback. To use these methods,
      create an instance of the
      `EmojiCompat.InitCallback <#androidx.emoji.text.EmojiCompat.InitCallback>`__
      class. Call these methods and pass the instance of the
      `EmojiCompat.InitCallback <#androidx.emoji.text.EmojiCompat.InitCallback>`__
      class. When the initialization of the
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ support
      library is successful, the
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ class
      calls the
      `onInitialized() <#androidx.emoji.text.EmojiCompat.InitCallback>`__
      method. If the library fails to initialize, the
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ class
      calls the
      `onFailed() <#androidx.emoji.text.EmojiCompat.InitCallback>`__
      method.

      To check the initialization state at any point, call the
      `getLoadState() <#androidx.emoji.text.EmojiCompat>`__
      method. It returns one of the following values:
      `LOAD_STATE_LOADING <#androidx.emoji.text.EmojiCompat>`__,
      `LOAD_STATE_SUCCEEDED <#androidx.emoji.text.EmojiCompat>`__,
      or
      `LOAD_STATE_FAILED <#androidx.emoji.text.EmojiCompat>`__.

      .. rubric:: Using EmojiCompat with AppCompat widgets
         :name: using-widgets-with-appcompat

      If you are using
      `AppCompat widgets <#android.support.v7.widget.package-summary>`__,
      you can use
      `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__ widgets
      that extend from
      `AppCompat widgets <#android.support.v7.widget.package-summary>`__.

      Add the support library to the dependencies section.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy

               .. code:: prettyprint

                  dependencies {
                      ...
                      implementation "androidx.emoji:emoji-bundled:$version"
                  }

            .. container:: section

               .. rubric:: Kotlin
                  :name: kts

               .. code:: prettyprint

                        dependencies {
                            implementation("androidx.emoji:emoji-appcompat:$version")
                        }
                        

               .. container:: ds-selector-tabs

                  .. container:: section

                     .. rubric:: Groovy
                        :name: groovy

                     .. code:: prettyprint

                              dependencies {
                                  implementation "androidx.emoji:emoji-appcompat:$version"
                              }
                              

               Use
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               `AppCompat Widget <#android.support.v7.widget.package-summary>`__
               widgets in layout XMLs.
               .. code:: prettyprint

                  <android.support.text.emoji.widget.EmojiAppCompatTextView
                     android:layout_width="wrap_content"
                     android:layout_height="wrap_content"/>

                  <android.support.text.emoji.widget.EmojiAppCompatEditText
                     android:layout_width="wrap_content"
                     android:layout_height="wrap_content"/>

                  <android.support.text.emoji.widget.EmojiAppCompatButton
                     android:layout_width="wrap_content"
                     android:layout_height="wrap_content"/>

               .. rubric:: Bundled fonts configuration
                  :name: bundled-fonts

               The
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               support library is also available in a bundled font version. This
               package includes the font with the embedded metadata. The package
               also includes a
               `BundledEmojiCompatConfig <#androidx.emoji.bundled.BundledEmojiCompatConfig>`__
               that uses the
               `AssetManager <#android.content.res.AssetManager>`__
               to load the metadata and fonts.

               **Note:** The size of the font is in multiple megabytes.

               .. rubric:: Adding support library dependency
                  :name: bundled-fonts-supplib-dependency

               To use the
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               support library with bundled font configuration, you *must*
               modify your app project's classpath dependencies within your
               development environment.

               To add a support library to your application project:

               #. Open the ``build.gradle`` file of your application.
               #. Add the support library to the ``dependencies`` section.

               .. container::

                  .. container:: ds-selector-tabs

                     .. container:: section

                        .. rubric:: Groovy
                           :name: groovy

                        .. code:: prettyprint

                           dependencies {
                               ...
                               implementation "androidx.emoji:emoji:28.0.0"
                           }

                     .. container:: section

                        .. rubric:: Kotlin
                           :name: kts

                        .. code:: prettyprint

                           dependencies {
                               ...
                               implementation("androidx.emoji:emoji:28.0.0")
                           }

               .. rubric:: Using bundled fonts to configure EmojiCompat
                  :name: bundled-fonts-config

               To use bundled fonts to configure
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__,
               perform the following steps:

               #. Use
                  `BundledEmojiCompatConfig <#androidx.emoji.bundled.BundledEmojiCompatConfig>`__
                  to create an instance of
                  `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
                  and provide an instance of
                  `Context <#android.content.Context>`__.
               #. Call the
                  `init() <#androidx.emoji.text.EmojiCompat>`__
                  method to initialize
                  `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
                  and pass the instance of
                  `BundledEmojiCompatConfig <#androidx.emoji.bundled.BundledEmojiCompatConfig>`__.

               .. container::

                  .. container:: ds-selector-tabs

                     .. container:: section

                        .. rubric:: Kotlin
                           :name: kotlin

                        .. code:: prettyprint

                           class MyApplication : Application() {

                               override fun onCreate() {
                                   super.onCreate()
                                   val config = BundledEmojiCompatConfig(this)
                                   EmojiCompat.init(config)
                               }
                           }

                     .. container:: section

                        .. rubric:: Java
                           :name: java

                        .. code:: prettyprint

                           public class MyApplication extends Application {
                               @Override
                               public void onCreate() {
                                   super.onCreate();
                                   EmojiCompat.Config config = new BundledEmojiCompatConfig(this);
                                   EmojiCompat.init(config);
                                   ...
                               }
                           }

               .. rubric:: Using EmojiCompat without widgets
                  :name: using-emojicompat-without-widgets

               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               uses `EmojiSpan <#androidx.emoji.text.EmojiSpan>`__
               to render correct images. Therefore, it has to convert any given
               `CharSequence <#>`__ into
               `Spanned <#android.text.Spanned>`__ instances with
               `EmojiSpans <#androidx.emoji.text.EmojiSpan>`__.
               The
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               class provides a method to convert
               `CharSequences <#>`__ into
               `Spanned <#android.text.Spanned>`__ instances with
               `EmojiSpans <#androidx.emoji.text.EmojiSpan>`__.
               Using this method, you can process and cache the processed
               instances instead of the raw string, which improves the
               performance of your application.

               .. container::

                  .. container:: ds-selector-tabs

                     .. container:: section

                        .. rubric:: Kotlin
                           :name: kotlin

                        .. code:: prettyprint

                           val processed = EmojiCompat.get().process("neutral face \uD83D\uDE10")

                     .. container:: section

                        .. rubric:: Java
                           :name: java

                        .. code:: prettyprint

                           CharSequence processed = EmojiCompat.get().process("neutral face \uD83D\uDE10");

               .. rubric:: Using EmojiCompat for IMEs
                  :name: using-emojicompat-for-imes

               Using the
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               support library, keyboards can render the emoji supported by the
               application they are interacting with. IMEs can use the
               `hasEmojiGlyph() <#androidx.emoji.text.EmojiCompat>`__
               method to check if
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               is capable of rendering an emoji. This method takes a
               `CharSequence <#>`__ of an
               emoji and returns ``true`` if
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               can detect and render the emoji.

               The keyboard can also check the version of the
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               support library that the app supports to determine which emoji to
               render in the palette. To check the version, if available, the
               keyboard needs to check whether the following keys exist in the
               `EditorInfo.extras <#android.view.inputmethod.EditorInfo>`__
               bundle:

               -  `EDITOR_INFO_METAVERSION_KEY <#androidx.emoji.text.EmojiCompat>`__
               -  `EDITOR_INFO_REPLACE_ALL_KEY <#androidx.emoji.text.EmojiCompat>`__

               After receiving the keys in the
               `EditorInfo.extras <#android.view.inputmethod.EditorInfo>`__
               bundle, the keyboard can use the
               `hasEmojiGlyph() <#androidx.emoji.text.EmojiCompat>`__
               method, where ``metadataVersion`` is the value for
               `EDITOR_INFO_METAVERSION_KEY <#androidx.emoji.text.EmojiCompat>`__,
               to check whether the app can render a specific emoji.

               .. rubric:: Using EmojiCompat with custom widgets
                  :name: using-emojicompat-with-custom-widgets

               You can always use the
               `process() <#androidx.emoji.text.EmojiCompat>`__
               method to preprocess the
               `CharSequence <#>`__ in your
               app and add it to any widget that can render
               `Spanned <#android.text.Spanned>`__ instances; for
               example, `TextView <#android.widget.TextView>`__.
               In addition,
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               provides the following widget helper classes to let you enrich
               your custom widgets with emoji support with minimum effort.

               -  `EmojiTextViewHelper <#androidx.emoji.widget.EmojiTextViewHelper>`__
               -  `EmojiEditTextHelper <#androidx.emoji.widget.EmojiEditTextHelper>`__

               **Sample TextView**

               .. container::

                  .. container:: ds-selector-tabs

                     .. container:: section

                        .. rubric:: Kotlin
                           :name: kotlin

                        .. code:: prettyprint

                           class MyTextView(context: Context) : AppCompatTextView(context) {

                               private val emojiTextViewHelper: EmojiTextViewHelper by lazy(LazyThreadSafetyMode.NONE) {
                                   EmojiTextViewHelper(this).apply {
                                       updateTransformationMethod()
                                   }
                               }

                               override fun setFilters(filters: Array<InputFilter>) {
                                   super.setFilters(emojiTextViewHelper.getFilters(filters))
                               }

                               override fun setAllCaps(allCaps: Boolean) {
                                   super.setAllCaps(allCaps)
                                   emojiTextViewHelper.setAllCaps(allCaps)
                               }
                           }

                     .. container:: section

                        .. rubric:: Java
                           :name: java

                        .. code:: prettyprint

                           public class MyTextView extends AppCompatTextView {
                              ...
                              public MyTextView(Context context) {
                                  super(context);
                                  init();
                              }
                              ...
                              private void init() {
                                  getEmojiTextViewHelper().updateTransformationMethod();
                              }

                              @Override
                              public void setFilters(InputFilter[] filters) {
                                  super.setFilters(getEmojiTextViewHelper().getFilters(filters));
                              }

                              @Override
                              public void setAllCaps(boolean allCaps) {
                                  super.setAllCaps(allCaps);
                                  getEmojiTextViewHelper().setAllCaps(allCaps);
                              }

                              private EmojiTextViewHelper getEmojiTextViewHelper() {
                                  ...
                              }
                           }

               **Sample EditText**

               .. container::

                  .. container:: ds-selector-tabs

                     .. container:: section

                        .. rubric:: Kotlin
                           :name: kotlin

                        .. code:: prettyprint

                           class MyEditText(context: Context) : AppCompatEditText(context) {

                               private val emojiEditTextHelper: EmojiEditTextHelper by lazy(LazyThreadSafetyMode.NONE) {
                                   EmojiEditTextHelper(this).also {
                                       super.setKeyListener(it.getKeyListener(keyListener))
                                   }
                               }

                               override fun setKeyListener(input: KeyListener?) {
                                   input?.also {
                                       super.setKeyListener(emojiEditTextHelper.getKeyListener(it))
                                   }
                               }

                               override fun onCreateInputConnection(outAttrs: EditorInfo): InputConnection {
                                   val inputConnection: InputConnection = super.onCreateInputConnection(outAttrs)
                                   return emojiEditTextHelper.onCreateInputConnection(
                                           inputConnection,
                                           outAttrs
                                   ) as InputConnection
                               }
                           }

                     .. container:: section

                        .. rubric:: Java
                           :name: java

                        .. code:: prettyprint

                           public class MyEditText extends AppCompatEditText {
                              ...
                              public MyEditText(Context context) {
                                  super(context);
                                  init();
                              }
                              ...
                              private void init() {
                                  super.setKeyListener(getEmojiEditTextHelper().getKeyListener(getKeyListener()));
                              }

                              @Override
                              public void setKeyListener(android.text.method.KeyListener keyListener) {
                                  super.setKeyListener(getEmojiEditTextHelper().getKeyListener(keyListener));
                              }

                              @Override
                              public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
                                  InputConnection inputConnection = super.onCreateInputConnection(outAttrs);
                                  return getEmojiEditTextHelper().onCreateInputConnection(inputConnection, outAttrs);
                              }

                              private EmojiEditTextHelper getEmojiEditTextHelper() {
                                  ...
                              }
                           }

               .. rubric:: Frequently asked questions
                  :name: frequently-asked-questions

               -  **How do I initiate the font download?**
               -  **How much time does it take to initialize?**
               -  **How much memory does the EmojiCompat support library use?**
               -  **Can I use EmojiCompat for a custom TextView?**
               -  **What happens if I add widgets in layout XMLs on devices that
                  run on Android 4.4 (API level 19) or lower?**

               .. rubric:: Additional resources
                  :name: additional-resources

               For additional information on using the
               `EmojiCompat <#androidx.emoji.text.EmojiCompat>`__
               library, watch
               `EmojiCompat <https://www.youtube.com/watch?v=sYGKUtM2ga8>`__.

               Last updated 2024-05-03 UTC.


/Use the Emoji Picker
=====================

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/emoji-picker?hl=en

.. container:: devsite-article-body

   The Emoji Picker is a UI solution that offers a modern look and feel,
   up-to-date emojis, and ease of use. Users can browse and select emojis and
   their variants or choose from their recently-used emojis.

   .. container:: float attempt-right

   With this library, apps from a variety of sources can provide an inclusive
   and unified emoji experience to their users without developers having to
   build and maintain their own emoji picker from scratch.

   .. rubric:: Features
      :name: features

   .. rubric:: Up-to-date Emojis
      :name: up-to-date_emojis

   Newly-released emojis are selectively included in the Emoji Picker. The Emoji
   Picker library is compatible across multiple Android versions and devices.

   .. rubric:: Sticky variants
      :name: sticky_variants

   Long-press an emoji to display a menu of variants, such as different genders
   or skin tones. The variant you choose is saved in the Emoji Picker, and the
   last selected variant is used in the main panel.

   With this feature, users can send their preferred emoji variants with one
   tap.

   .. figure:: https://developer.android.google.cn/static/images/develop/ui/views/text-and-emoji/emoji-variants.png
      name: emoji-variants
      :alt: emoji variants
      :width: 300px

      **Figure 2.** Emoji variants

   .. rubric:: Recent emoji
      :name: recent_emoji

   .. figure:: https://developer.android.google.cn/static/images/develop/ui/views/text-and-emoji/recent-emoji.png
      name: recent-emoji
      :alt: recent emoji
      :width: 300px

      **Figure 3.** Recent emojis

   The ``RecentEmojiProvider`` is responsible for providing emojis in the
   **Recently Used** category. The library has a default recent emoji provider
   that satisfies the most common use case:

   -  All selected emojis are saved per-app in shared preferences.
   -  The picker displays at most 3 rows of selected emojis, deduped, in reverse
      chronological order.

   If this default behavior is sufficient, then you don't need to use
   ``setRecentEmojiProvider()``.

   You might need to customize the provider behavior, however. Here are some
   common scenarios:

   -  You want to store different selected emojis per user account.
   -  You want to use data storage other than shared preferences.
   -  You want to display recent emojis sorted by frequency.

   You can then implement the ``RecentEmojiProvider`` interface and set it using
   ``setRecentEmojiProvider()``.

   .. rubric:: Compatibility with ``EmojiCompat``
      :name: compatibility_with_emojicompat

   If enabled, an ``EmojiCompat`` instance is used in the Emoji Picker to render
   as many emojis as possible. The Emoji Picker does not require
   ``EmojiCompat``, however.

   .. rubric:: Prerequisites
      :name: prerequisites

   Your app must target Android 5.0 (API level 21) or higher.

   .. rubric:: Use the library
      :name: how-use

   #. Import ``androidx.emoji2:emojipicker:$version`` in your app's
      ``build.gradle`` file.

      .. code:: prettyprint

         dependencies {
             implementation "androidx.emoji2:emojipicker:$version"
         }

   #. Inflate the Emoji Picker view, and optionally set ``emojiGridRows`` and
      ``emojiGridColumns``.

      -  The default number of ``emojiGridColumns`` is 9.
      -  Row count is calculated based on the parent view height and the value
         of ``emojiGridColumns``.
      -  Use a float value for ``emojiGridRows`` to indicate that the user can
         scroll down for more emojis.

      .. code:: prettyprint

         <androidx.emoji2.emojipicker.EmojiPickerView
             android:id="@+id/emoji_picker"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             app:emojiGridColumns="9" />

      .. code:: prettyprint

         val emojiPickerView = EmojiPickerView(context).apply {
             emojiGridColumns = 15
             layoutParams = ViewGroup.LayoutParams(
                 ViewGroup.LayoutParams.MATCH_PARENT,
                 ViewGroup.LayoutParams.MATCH_PARENT
             )
         }

         findViewById<ViewGroup>(R.id.emoji_picker_layout).addView(emojiPickerView)

   #. Use ``setOnEmojiPickedListener()`` to append the selected emojis to a
      view. For example, to append to an ``EditText``, do the following:

      .. code:: prettyprint

         emojiPickerView.setOnEmojiPickedListener {
             findViewById<EditText>(R.id.edit_text).append(it.emoji)
         }

   #. Optionally set ``RecentEmojiProvider``, see sample app for an example
      implementation.

   #. Optionally customize styles. Create your own style to override common
      theme attributes and apply the style to the ``EmojiPickerView``. For
      example, overriding ``colorControlNormal`` changes the category icon
      color.

      .. code:: prettyprint

         <style name="CustomStyle" >
             <item name="colorControlNormal">#FFC0CB</item>
         </style>
         <androidx.emoji2.emojipicker.EmojiPickerView
             android:id="@+id/emoji_picker"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             android:theme="@style/CustomStyle"
             app:emojiGridColumns="9" />

   .. rubric:: Sample App
      :name: sample-app

   The `Emoji Picker sample app <https://github.com/androidx/androidx/tree/androidx-main/emoji2/emoji2-emojipicker/samples>`__
   demonstrates basic use cases along with the following additional scenarios:

   -  Layout recalculation when ``emojiGridRows`` or ``emojiGridColumns`` are
      reset.
   -  An overridden recent emoji provider that sorts by frequency.
   -  Additional style customization.


Last updated 2024-05-03 UTC.


/Magnify text
=============

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/magnifier?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use text in Compose.

      `Modifier.magnifier() → <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).magnifier(kotlin.Function1,kotlin.Function1,kotlin.Float,androidx.compose.foundation.MagnifierStyle,kotlin.Function1)>`__

      |image-android-compose-ui-logo|

   Available in Android 9 (API level 28) and later, the magnifier widget is a
   virtual magnifying glass that displays an enlarged copy of a ``View`` through
   an overlay pane that represents the lens. The feature improves the text
   insertion and selection user experience. When applying the magnifier to text,
   a user can precisely position the cursor or the selection handles by viewing
   the magnified text in a pane that follows their finger.

   Figure 1 shows how the magnifier facilitates selecting text. The magnifier
   APIs aren't tied to text, and you can use this widget in a variety of use
   cases, such as reading small text or enlarging hard-to-see place names on
   maps.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/magnifier-1.png
      name: text
      :alt: An image showing how the magnifier appears after grabbing the right
      selection handle
      :width: 80.0%

      **Figure 1.** Magnifying text. When the user drags the right selection
      handle, the magnifier pops up to help with accurate placement.

   The magnifier is already integrated with platform widgets such as
   ``TextView``, ``EditText``, and ``WebView``. It provides consistent text
   manipulation across apps. The widget comes with a simple API and can be used
   to magnify any ``View`` depending on your app's context.

   .. rubric:: API usage
      :name: usage

   You can use the magnifier programmatically on an arbitrary view as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val view: View = findViewById(R.id.view)
               val magnifier = Magnifier.Builder(view).build()
               magnifier.show(view.width / 2.0f, view.height / 2.0f)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               View view = findViewById(R.id.view);
               Magnifier magnifier = new Magnifier.Builder(view).build();
               magnifier.show(view.getWidth() / 2, view.getHeight() / 2);

   Assuming the view hierarchy has the first layout, the magnifier displays on
   the screen and contains a region centered on the given coordinates within the
   view. The pane appears above the center point of the content being copied.
   The magnifier persists indefinitely until the user dismisses it.

   **Note:**\  The arguments of
   `show() <#android.widget.Magnifier>`__ are
   relative to the top-left corner of the view being magnified.
   The following code snippet shows how to change the background of the
   magnified view:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               view.setBackgroundColor(...)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               view.setBackgroundColor(...);

   Assuming the background color is visible within the magnifier, the
   magnifier's content is stale, as a region of the view with the old background
   still displays. To refresh the content, use the
   `update() <#android.widget.Magnifier>`__ method, as
   follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               view.post { magnifier.update() }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               view.post(magnifier::update);

   **Note:**\  Post the update operation to make sure that by the time this
   executes, the view with the new background color is already drawn. This is
   because the magnifier content always stays a frame behind the magnified view.
   When finished, close the magnifier by calling the
   `dismiss() <#android.widget.Magnifier>`__ method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               magnifier.dismiss()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               magnifier.dismiss();

   .. rubric:: Magnify on user interaction
      :name: user-interaction

   A common use case for the magnifier is to let the user enlarge a view region
   by touching it, as shown in figure 2.

   .. container:: float
      :name: user-touch

   You can do this by updating the magnifier according to the touch events
   received by the view, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               imageView.setOnTouchListener { v, event ->
                 when (event.actionMasked) {
                   MotionEvent.ACTION_DOWN, MotionEvent.ACTION_MOVE -> {
                     val viewPosition = IntArray(2)
                     v.getLocationOnScreen(viewPosition)
                     magnifier.show(event.rawX - viewPosition[0], event.rawY - viewPosition[1])
                   }
                   MotionEvent.ACTION_CANCEL, MotionEvent.ACTION_UP -> {
                     magnifier.dismiss()
                   }
                 }
                 true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               imageView.setOnTouchListener(new View.OnTouchListener() {
                   @Override
                   public boolean onTouch(View v, MotionEvent event) {
                       switch (event.getActionMasked()) {
                           case MotionEvent.ACTION_DOWN:
                               // Fall through.
                           case MotionEvent.ACTION_MOVE: {
                               final int[] viewPosition = new int[2];
                               v.getLocationOnScreen(viewPosition);
                               magnifier.show(event.getRawX() - viewPosition[0],
                                              event.getRawY() - viewPosition[1]);
                               break;
                           }
                           case MotionEvent.ACTION_CANCEL:
                               // Fall through.
                           case MotionEvent.ACTION_UP: {
                               magnifier.dismiss();
                           }
                       }
                       return true;
                   }
               });

   **Note:**\  The magnifier never displays magnified content that doesn't
   belong to the view, even when the view is included in scrollable containers
   and partially masked. When the coordinates passed to ``show()`` imply copying
   outside content, they are coerced inside the visible region of the view.

   .. rubric:: Additional considerations when magnifying text
      :name: additional

   For the platform text widgets, it's important to understand specific
   magnifier behaviors and to enable the magnifier for your custom text view
   consistently across the Android platform. Consider the following:

   -  The magnifier is triggered immediately when the user grabs an insertion or
      selection handle.
   -  The magnifier always smoothly follows the user's finger horizontally,
      while vertically it is fixed to the center of the current text line.
   -  When moving horizontally, the magnifier moves only between the left and
      right bounds of the current line. Moreover, when the user's touch leaves
      these bounds and the horizontal distance between the touch and the closest
      bound is larger than half of the original width of the magnifier content,
      the magnifier is dismissed, as the cursor is no longer visible inside the
      magnifier.
   -  The magnifier is never triggered when the text font is too large. Text is
      considered too large when the difference between the font's descent and
      ascent is larger than the height of the content that fits in the
      magnifier. Triggering the magnifier in this case doesn't add value.


Last updated 2024-04-15 UTC.



/Use spans to style text
========================

.. https://developer.android.google.cn/develop/ui/views/text-and-emoji/spans?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use text in Compose.

      `Multiple styles in text → <https://developer.android.google.cn/jetpack/compose/text/style-text#multiple-styles>`__

      |image-android-compose-ui-logo|

   Spans are powerful markup objects that you can use to style text at the
   character or paragraph level. By attaching spans to text objects, you can
   change text in a variety of ways, including adding color, making the text
   clickable, scaling the text size, and drawing text in a customized way. Spans
   can also change `TextPaint <#android.text.TextPaint>`__
   properties, draw on a `Canvas <#android.graphics.Canvas>`__,
   and change text layout.

   Android provides several types of spans that cover a variety of common text
   styling patterns. You can also create your own spans to apply custom styling.

   **Note:**\  To help you create a modern and maintainable codebase, Android
   KTX contains extension functions that make working with spans easier. To
   learn more, see the
   `androidx.core.text <#>`__
   package documentation and the `Spantastic text styling with Spans <https://medium.com/androiddevelopers/spantastic-text-styling-with-spans-17b0c16b4568>`__
   blog post.

   .. rubric:: Create and apply a span
      :name: create-and-apply

   To create a span, you can use one of the classes listed in the following
   table. The classes differ based on whether the text itself is mutable,
   whether the text markup is mutable, and what underlying data structure
   contains the span data.

   +-----------------------------+--------------+----------------+----------------+
   | Class                       | Mutable text | Mutable markup | Data structure |
   +=============================+==============+================+================+
   | `SpannedString          | No           | No             | Linear array   |
   +-----------------------------+--------------+----------------+----------------+ | `SpannableString        | No           | Yes            | Linear array   |
   +-----------------------------+--------------+----------------+----------------+ | `SpannableStringBuilder | Yes          | Yes            | Interval tree  |
   +-----------------------------+--------------+----------------+----------------+

   All three classes extend the `Spanned <#android.text.Spanned>`__ interface.
   ``SpannableString`` and ``SpannableStringBuilder`` also extend the
   `Spannable <#android.text.Spannable>`__ interface.

   Here's how to decide which one to use:

   -  If you aren't modifying the text or markup after creation, use
      ``SpannedString``.
   -  If you need to attach a small number of spans to a single text object and
      the text itself is read-only, use ``SpannableString``.
   -  If you need to modify text after creation and you need to attach spans to
      the text, use ``SpannableStringBuilder``.
   -  If you need to attach a large number of spans to a text object, regardless
      of whether the text itself is read-only, use ``SpannableStringBuilder``.

   To apply a span, call
   `setSpan(Object _what_, int _start_, int _end_, int _flags_) <#android.text.Spannable>`__
   on a ``Spannable`` object. The *what* parameter refers to the span you are
   applying to the text, and the *start* and *end* parameters indicate the
   portion of the text you are applying the span to.

   If you insert text inside a span's boundaries, the span automatically expands
   to include the inserted text. When inserting text *at* the span
   boundaries—that is, at the *start* or *end* indices—the *flags* parameter
   determines whether the span expands to include the inserted text. Use the
   `Spannable.SPAN_EXCLUSIVE_INCLUSIVE <#android.text.Spanned>`__
   flag to include inserted text, and use
   `Spannable.SPAN_EXCLUSIVE_EXCLUSIVE <#android.text.Spanned>`__
   to exclude the inserted text.

   The following example shows how to attach a
   `ForegroundColorSpan <#android.text.style.ForegroundColorSpan>`__
   to a string:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val spannable = SpannableStringBuilder("Text is spantastic!")
               spannable.setSpan(
                   ForegroundColorSpan(Color.RED),
                   8, // start
                   12, // end
                   Spannable.SPAN_EXCLUSIVE_INCLUSIVE
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SpannableStringBuilder spannable = new SpannableStringBuilder("Text is spantastic!");
               spannable.setSpan(
                   new ForegroundColorSpan(Color.RED),
                   8, // start
                   12, // end
                   Spannable.SPAN_EXCLUSIVE_INCLUSIVE
               );

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-fg-color.png
      name: ForegroundColorSpan
      :alt: An image showing a grey text, partially red.
      :width: 30.0%

      **Figure 1.** Text styled with a ``ForegroundColorSpan``.

   Because the span is set using ``Spannable.SPAN_EXCLUSIVE_INCLUSIVE``, the
   span expands to include inserted text at the span boundaries, as shown in the
   following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val spannable = SpannableStringBuilder("Text is spantastic!")
               spannable.setSpan(
                   ForegroundColorSpan(Color.RED),
                   8, // start
                   12, // end
                   Spannable.SPAN_EXCLUSIVE_INCLUSIVE
               )
               spannable.insert(12, "(& fon)")

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SpannableStringBuilder spannable = new SpannableStringBuilder("Text is spantastic!");
               spannable.setSpan(
                   new ForegroundColorSpan(Color.RED),
                   8, // start
                   12, // end
                   Spannable.SPAN_EXCLUSIVE_INCLUSIVE
               );
               spannable.insert(12, "(& fon)");

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-fg-color-2.png
      name: inclusive
      :alt: An image showing how the span include more text when
      SPAN_EXCLUSIVE_INCLUSIVE is used.
      :width: 30.0%

      **Figure 2.** The span expands to include additional text when using
      ``Spannable.SPAN_EXCLUSIVE_INCLUSIVE``.

   You can attach multiple spans to the same text. The following example shows
   how to create text that is bold and red:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val spannable = SpannableString("Text is spantastic!")
               spannable.setSpan(ForegroundColorSpan(Color.RED), 8, 12, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
               spannable.setSpan(
                   StyleSpan(Typeface.BOLD),
                   8,
                   spannable.length,
                   Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SpannableString spannable = new SpannableString("Text is spantastic!");
               spannable.setSpan(
                   new ForegroundColorSpan(Color.RED),
                   8, 12,
                   Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
               );
               spannable.setSpan(
                   new StyleSpan(Typeface.BOLD),
                   8, spannable.length(),
                   Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
               );

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-bold-red.png
      name: bold
      :alt: An image showing a text with multiple spans:
      \`ForegroundColorSpan(Color.RED)\` and \`StyleSpan(BOLD)\`
      :width: 30.0%

      **Figure 3.** Text with multiple spans: ``ForegroundColorSpan(Color.RED)``
      and ``StyleSpan(BOLD)``.

   .. rubric:: Android span types
      :name: span-types

   Android provides over 20 span types in the
   `android.text.style <#android.text.style.package-summary>`__
   package. Android categorizes spans in two primary ways:

   -  How the span affects text: a span can affect text appearance or text
      metrics.
   -  Span scope: some spans can be applied to individual characters, while
      others must be applied to an entire paragraph.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-span-categories.png
      name: categories
      :alt: An image showing different span categories
      :width: 100.0%

      **Figure 4.** Categories of Android spans.

   The following sections describe these categories in more detail.

   .. rubric:: Spans that affect text appearance
      :name: appearance-spans

   Some spans that apply at the character level affect text appearance, such as
   changing text or background color and adding underlines or strikethroughs.
   These spans extend the
   `CharacterStyle <#android.text.style.CharacterStyle>`__ class.

   The following code example shows how to apply an ``UnderlineSpan`` to
   underline the text:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val string = SpannableString("Text with underline span")
               string.setSpan(UnderlineSpan(), 10, 19, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SpannableString string = new SpannableString("Text with underline span");
               string.setSpan(new UnderlineSpan(), 10, 19, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-underlinespan.png
      name: underline
      :alt: An image showing how to underline text using an \`UnderlineSpan\`
      :width: 80.0%

      **Figure 5.** Text underlined using an ``UnderlineSpan``.

   Spans that affect only text appearance trigger a redraw of the text without
   triggering a recalculation of the layout. These spans implement
   `UpdateAppearance <#android.text.style.UpdateAppearance>`__ and
   extend `CharacterStyle <#android.text.style.CharacterStyle>`__.
   ``CharacterStyle`` subclasses define how to draw text by providing access to
   update the ``TextPaint``.

   .. rubric:: Spans that affect text metrics
      :name: metric-spans

   Other spans that apply at the character level affect text metrics, such as
   line height and text size. These spans extend the
   `MetricAffectingSpan <#android.text.style.MetricAffectingSpan>`__
   class.

   The following code example creates a
   `RelativeSizeSpan <#android.text.style.RelativeSizeSpan>`__
   that increases text size by 50%:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val string = SpannableString("Text with relative size span")
               string.setSpan(RelativeSizeSpan(1.5f), 10, 24, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               SpannableString string = new SpannableString("Text with relative size span");
               string.setSpan(new RelativeSizeSpan(1.5f), 10, 24, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-relativesizespan.png
      name: relativesize
      :alt: An image showing the usage of RelativeSizeSpan
      :width: 80.0%

      **Figure 6.** Text made larger using a ``RelativeSizeSpan``.

   Applying a span that affects text metrics causes an observing object to
   re-measure the text for correct layout and rendering—for example, changing
   text size might cause words to appear on different lines. Applying the
   preceding span triggers a remeasure, recalculation of the text layout, and
   redrawing of the text.

   Spans that affect text metrics extend the ``MetricAffectingSpan`` class, an
   abstract class that lets subclasses define how the span affects text
   measurement by providing access to the ``TextPaint``. Since
   ``MetricAffectingSpan`` extends ``CharacterSpan``, subclasses affect the
   appearance of the text at the character level.

   .. rubric:: Spans that affect paragraphs
      :name: paragraph-spans

   A span can also affect text at the paragraph level, such as changing the
   alignment or the margin of a block of text. Spans that affect entire
   paragraphs implement
   `ParagraphStyle <#android.text.style.ParagraphStyle>`__. To use
   these spans, you attach them to the entire paragraph, excluding the ending
   new line character. If you try to apply a paragraph span to something other
   than a whole paragraph, Android doesn't apply the span at all.

   Figure 8 shows how Android separates paragraphs in text.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-paragraphs.png
      name: paragraph-separation
      :width: 50.0%

      **Figure 7.** In Android, paragraphs end with a new line (``\n``)
      character.

   The following code example applies a
   `QuoteSpan <#android.text.style.QuoteSpan>`__ to a paragraph.
   Note that if you attach the span to any position other than the beginning or
   end of a paragraph, Android doesn't apply the style at all.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               spannable.setSpan(QuoteSpan(color), 8, text.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               spannable.setSpan(new QuoteSpan(color), 8, text.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

   .. figure::
      https://developer.android.google.cn/static/develop/ui/views/text-and-emoji/images/spans-quotespan.png
      name: quotespan
      :alt: An image showing an example of QuoteSpan
      :width: 30.0%

      **Figure 8.** A ``QuoteSpan`` applied to a paragraph.

   .. rubric:: Create custom spans
      :name: custom-spans

   If you need more functionality than what is provided in the existing Android
   spans, you can implement a custom span. When implementing your own span,
   decide whether your span affects text at the character level or the paragraph
   level and also whether it affects the layout or appearance of the text. This
   helps you determine which base classes you can extend and which interfaces
   you might need to implement. Use the following table for reference:

   ============================================== ====================
   Scenario                                       Class or interface
   ============================================== ====================
   Your span affects text at the character level. ``CharacterStyle``
   Your span affects text appearance.             ``UpdateAppearance``
   Your span affects text metrics.                ``UpdateLayout``
   Your span affects text at the paragraph level. ``ParagraphStyle``
   ============================================== ====================

   For example, if you need to implement a custom span that modifies text size
   and color, extend ``RelativeSizeSpan``. Through inheritance,
   ``RelativeSizeSpan`` extends ``CharacterStyle`` and implements the two
   ``Update`` interfaces. Since this class already provides callbacks for
   ``updateDrawState`` and ``updateMeasureState``, you can override these
   callbacks to implement your custom behavior. The following code creates a
   custom span that extends ``RelativeSizeSpan`` and overrides the
   ``updateDrawState`` callback to set the color of the ``TextPaint``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class RelativeSizeColorSpan(
                   size: Float,
                   @ColorInt private val color: Int
               ) : RelativeSizeSpan(size) {
                   override fun updateDrawState(textPaint: TextPaint) {
                       super.updateDrawState(textPaint)
                       textPaint.color = color
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class RelativeSizeColorSpan extends RelativeSizeSpan {
                   private int color;
                   public RelativeSizeColorSpan(float spanSize, int spanColor) {
                       super(spanSize);
                       color = spanColor;
                   }
                   @Override
                   public void updateDrawState(TextPaint textPaint) {
                       super.updateDrawState(textPaint);
                       textPaint.setColor(color);
                   }
               }

   This example illustrates how to create a custom span. You can achieve the
   same effect by applying a ``RelativeSizeSpan`` and ``ForegroundColorSpan`` to
   the text.

   .. rubric:: Test span usage
      :name: test-spans

   The ``Spanned`` interface lets you both set spans and also retrieve spans
   from text. When testing, implement an `Android JUnit test <#>`__ to verify that the correct spans are
   added at the correct locations. The `Text Styling sample app <https://github.com/android/user-interface-samples/tree/main/TextStyling>`__
   contains a span that applies markup to bullet points by attaching
   ``BulletPointSpan`` to the text. The following code example shows how to test
   whether the bullet points appear as expected:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Test fun textWithBulletPoints() {
                  val result = builder.markdownToSpans("Points\n* one\n+ two")

                  // Check whether the markup tags are removed.
                  assertEquals("Points\none\ntwo", result.toString())

                  // Get all the spans attached to the SpannedString.
                  val spans = result.getSpans<Any>(0, result.length, Any::class.java)

                  // Check whether the correct number of spans are created.
                  assertEquals(2, spans.size.toLong())

                  // Check whether the spans are instances of BulletPointSpan.
                  val bulletSpan1 = spans[0] as BulletPointSpan
                  val bulletSpan2 = spans[1] as BulletPointSpan

                  // Check whether the start and end indices are the expected ones.
                  assertEquals(7, result.getSpanStart(bulletSpan1).toLong())
                  assertEquals(11, result.getSpanEnd(bulletSpan1).toLong())
                  assertEquals(11, result.getSpanStart(bulletSpan2).toLong())
                  assertEquals(14, result.getSpanEnd(bulletSpan2).toLong())
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Test
               public void textWithBulletPoints() {
                   SpannedString result = builder.markdownToSpans("Points\n* one\n+ two");

                   // Check whether the markup tags are removed.
                   assertEquals("Points\none\ntwo", result.toString());

                   // Get all the spans attached to the SpannedString.
                   Object[] spans = result.getSpans(0, result.length(), Object.class);

                   // Check whether the correct number of spans are created.
                   assertEquals(2, spans.length);

                   // Check whether the spans are instances of BulletPointSpan.
                   BulletPointSpan bulletSpan1 = (BulletPointSpan) spans[0];
                   BulletPointSpan bulletSpan2 = (BulletPointSpan) spans[1];

                   // Check whether the start and end indices are the expected ones.
                   assertEquals(7, result.getSpanStart(bulletSpan1));
                   assertEquals(11, result.getSpanEnd(bulletSpan1));
                   assertEquals(11, result.getSpanStart(bulletSpan2));
                   assertEquals(14, result.getSpanEnd(bulletSpan2));
               }

   For more test examples, see
   `MarkdownBuilderTest <https://github.com/android/user-interface-samples/blob/master/TextStyling/app/src/androidTest/java/com/android/example/text/styling/renderer/MarkdownBuilderTest.kt>`__
   on GitHub.

   **Note:**\  If you need to iterate through spans outside of testing, use
   `nextSpanTransition() <#android.text.Spanned>`__
   instead of
   `getSpans() <#android.text.Spanned>`__,
   as ``nextSpanTransition()`` is more performant.

   .. rubric:: Test custom spans
      :name: test-custom-spans

   When testing spans, verify that the ``TextPaint`` contains the expected
   modifications and that the correct elements appear on your ``Canvas``. For
   example, consider a custom span implementation that prepends a bullet point
   to some text. The bullet point has a specified size and color, and there is a
   gap between the left margin of the drawable area and the bullet point.

   You can test the behavior of this class by implementing an AndroidJUnit test,
   checking for the following:

   -  If you correctly apply the span, a bullet point of the specified size and
      color appears on the canvas, and the proper space exists between the left
      margin and the bullet point.
   -  If you don't apply the span, none of the custom behavior appears.

   You can see the implementation of these tests in the `TextStyling sample <https://github.com/android/user-interface-samples/blob/master/TextStyling/app/src/main/java/com/android/example/text/styling/renderer/spans/BulletPointSpan.kt>`__
   on GitHub.

   You can test Canvas interactions by mocking the canvas, passing the mocked
   object to the
   `drawLeadingMargin() <https://github.com/android/user-interface-samples/blob/17015982de5c31b24613aff4078d39cfdd366351/TextStyling/app/src/main/java/com/android/example/text/styling/renderer/spans/BulletPointSpan.kt#L54>`__
   method, and verifying that the correct methods are called with the correct
   parameters.

   You can find more span test samples in
   `BulletPointSpanTest <https://github.com/android/user-interface-samples/blob/master/TextStyling/app/src/androidTest/java/com/android/example/text/styling/renderer/spans/BulletPointSpanTest.kt>`__.

   .. rubric:: Best practices for using spans
      :name: best-practices

   There are several memory-efficient ways to set text in a ``TextView``,
   depending on your needs.

   .. rubric:: Attach or detach a span without changing the underlying text
      :name: attach-or-detach

   `TextView.setText() <#android.widget.TextView>`__
   contains multiple overloads that handle spans differently. For example, you
   can set a ``Spannable`` text object with the following code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               textView.setText(spannableObject)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               textView.setText(spannableObject);

   When calling this overload of ``setText()``, the ``TextView`` creates a copy
   of your ``Spannable`` as a ``SpannedString`` and keeps it in memory as a
   ``CharSequence``. This means that your text and the spans are immutable, so
   when you need to update the text or the spans, create a new ``Spannable``
   object and call ``setText()`` again, which also triggers a re-measuring and
   re-drawing of the layout.

   To indicate that the spans must be mutable, you can instead use
   `setText(CharSequence text, TextView.BufferType type) <#android.widget.TextView>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               textView.setText(spannable, BufferType.SPANNABLE)
               val spannableText = textView.text as Spannable
               spannableText.setSpan(
                    ForegroundColorSpan(color),
                    8, spannableText.length,
                    SPAN_INCLUSIVE_INCLUSIVE
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               textView.setText(spannable, BufferType.SPANNABLE);
               Spannable spannableText = (Spannable) textView.getText();
               spannableText.setSpan(
                    new ForegroundColorSpan(color),
                    8, spannableText.getLength(),
                    SPAN_INCLUSIVE_INCLUSIVE);

   In this example, the
   `BufferType.SPANNABLE <#android.widget.TextView.BufferType>`__
   parameter causes the ``TextView`` to create a ``SpannableString``, and the
   ``CharSequence`` object kept by the ``TextView`` now has mutable markup and
   immutable text. To update the span, retrieve the text as a ``Spannable`` and
   then update the spans as needed.

   When you attach, detach, or reposition spans, the ``TextView`` automatically
   updates to reflect the change to the text. If you change an internal
   attribute of an existing span, call ``invalidate()`` to make
   appearance-related changes or ``requestLayout()`` to make metric-related
   changes.

   .. rubric:: Set text in a TextView multiple times
      :name: set-text-multiple

   In some cases, such as when using a
   `RecyclerView.ViewHolder <#androidx.recyclerview.widget.RecyclerView.ViewHolder>`__,
   you might want to reuse a ``TextView`` and set the text multiple times. By
   default, regardless of whether you set the ``BufferType``, the ``TextView``
   creates a copy of the ``CharSequence`` object and holds it in memory. This
   makes all ``TextView`` updates intentional—you can't update the original
   ``CharSequence`` object to update the text. This means every time you set new
   text, the ``TextView`` creates a new object.

   If want to take more control over this process and avoid the extra object
   creation, you can implement your own
   `Spannable.Factory <#android.text.Spannable.Factory>`__ and
   override
   `newSpannable() <#android.text.Spannable.Factory>`__.
   Instead of creating a new text object, you can cast and return the existing
   ``CharSequence`` as a ``Spannable``, as demonstrated in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val spannableFactory = object : Spannable.Factory() {
                   override fun newSpannable(source: CharSequence?): Spannable {
                       return source as Spannable
                   }
               }
               Java

               Spannable.Factory spannableFactory = new Spannable.Factory(){
                   @Override
                   public Spannable newSpannable(CharSequence source) {
                       return (Spannable) source;
                   }
               };

   You must use ``textView.setText(spannableObject, BufferType.SPANNABLE)`` when
   setting the text. Otherwise, the source ``CharSequence`` is created as a
   ``Spanned`` instance and can't be cast to ``Spannable``, causing
   ``newSpannable()`` to throw a ``ClassCastException``.

   After overriding ``newSpannable()``, tell the ``TextView`` to use the new
   ``Factory``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               textView.setSpannableFactory(spannableFactory)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               textView.setSpannableFactory(spannableFactory);

   Set the ``Spannable.Factory`` object once, right after you get a reference to
   your ``TextView``. If you're using a ``RecyclerView``, set the ``Factory``
   object when you first inflate your views. This avoids extra object creation
   when your ``RecyclerView`` binds a new item to your ``ViewHolder``.

   .. rubric:: Change internal span attributes
      :name: change-internal-attributes

   If you need to change only an internal attribute of a mutable span, such as
   the bullet color in a custom bullet span, you can avoid the overhead from
   calling ``setText()`` multiple times by keeping a reference to the span as
   it's created. When you need to modify the span, you can modify the reference
   and then call ``invalidate()`` or ``requestLayout()`` on the ``TextView``,
   depending on the type of attribute you changed.

   In the following code example, a custom bullet point implementation has a
   default color of red that changes to gray when a button is tapped:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : AppCompatActivity() {

                   // Keeping the span as a field.
                   val bulletSpan = BulletPointSpan(color = Color.RED)

                   override fun onCreate(savedInstanceState: Bundle?) {
                       ...
                       val spannable = SpannableString("Text is spantastic")
                       // Setting the span to the bulletSpan field.
                       spannable.setSpan(
                           bulletSpan,
                           0, 4,
                           Spanned.SPAN_INCLUSIVE_INCLUSIVE
                       )
                       styledText.setText(spannable)
                       button.setOnClickListener {
                           // Change the color of the mutable span.
                           bulletSpan.color = Color.GRAY
                           // Color doesn't change until invalidate is called.
                           styledText.invalidate()
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends AppCompatActivity {

                   private BulletPointSpan bulletSpan = new BulletPointSpan(Color.RED);

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       ...
                       SpannableString spannable = new SpannableString("Text is spantastic");
                       // Setting the span to the bulletSpan field.
                       spannable.setSpan(bulletSpan, 0, 4, Spanned.SPAN_INCLUSIVE_INCLUSIVE);
                       styledText.setText(spannable);
                       button.setOnClickListener(new View.OnClickListener() {
                           @Override
                           public void onClick(View view) {
                               // Change the color of the mutable span.
                               bulletSpan.setColor(Color.GRAY);
                               // Color doesn't change until invalidate is called.
                               styledText.invalidate();
                           }
                       });
                   }
               }

   .. rubric:: Use Android KTX extension functions
      :name: android-ktx

   Android KTX also contains extension functions that make working with spans
   easier. To learn more, see the documentation for the
   `androidx.core.text <#>`__
   package.


Last updated 2024-04-15 UTC.



/About static images
====================

.. https://developer.android.google.cn/develop/ui/views/graphics/drawables?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to display graphics in Compose.

      `Loading Images → <https://developer.android.google.cn/jetpack/compose/graphics/images/loading>`__

      |image-android-compose-ui-logo|

   When you need to display static images in your app, you can use the
   `Drawable <#android.graphics.drawable.Drawable>`__ class and
   its subclasses to draw shapes and images. A
   `Drawable <#android.graphics.drawable.Drawable>`__ is a general
   abstraction for *something that can be drawn*. The various subclasses help
   with specific image scenarios, and you can extend them to define your own
   drawable objects that behave in unique ways.

   There are two ways to define and instantiate a
   `Drawable <#android.graphics.drawable.Drawable>`__ besides
   using the class constructors:

   -  Inflate an image resource (a bitmap file) saved in your project.
   -  Inflate an XML resource that defines the drawable properties.

   **Note:** You might instead prefer using a vector drawable, which defines an
   image with a set of points, lines, and curves, along with associated color
   information. This allows vector drawables to be scaled for different sizes
   without a loss of quality. For more information, see `Vector drawables overview <#>`__.

   .. rubric:: Create drawables from resource images
      :name: drawables-from-images

   You can add graphics to your app by referencing an image file from your
   project resources. Supported file types are PNG (preferred), JPG
   (acceptable), and GIF (discouraged). App icons, logos, and other graphics,
   such as those used in games, are well suited for this technique.

   To use an image resource, add your file to the ``res/drawable/`` directory of
   your project. Once in your project, you can reference the image resource from
   your code or your XML layout. Either way, it's referred to using a resource
   ID, which is the file name without the file type extension. For example,
   refer to ``my_image.png`` as ``my_image``.

   **Note:** Image resources placed in the ``res/drawable/`` directory may be
   automatically optimized with lossless image compression by the ``aapt`` tool
   during the build process. For example, a true-color PNG that doesn't require
   more than 256 colors may be converted to an 8-bit PNG with a color palette.
   This results in an image of equal quality but which requires less memory. As
   a result, the image binaries placed in this directory can change at build
   time. If you plan on reading an image as a bitstream in order to convert it
   to a bitmap, put your images in the ``res/raw/`` folder instead, where the
   ``aapt`` tool doesn't modify them.

   The following code snippet demonstrates how to build an
   `ImageView <#android.widget.ImageView>`__ that uses an image
   created from a drawable resource and adds it to the layout:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private lateinit var constraintLayout: ConstraintLayout

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)

                   // Instantiate an ImageView and define its properties
                   val i = ImageView(this).apply {
                       setImageResource(R.drawable.my_image)
                       contentDescription = resources.getString(R.string.my_image_desc)

                       // set the ImageView bounds to match the Drawable's dimensions
                       adjustViewBounds = true
                       layoutParams = ViewGroup.LayoutParams(
                               ViewGroup.LayoutParams.WRAP_CONTENT,
                               ViewGroup.LayoutParams.WRAP_CONTENT)
                   }

                   // Create a ConstraintLayout in which to add the ImageView
                   constraintLayout = ConstraintLayout(this).apply {

                       // Add the ImageView to the layout.
                       addView(i)
                   }

                   // Set the layout as the content view.
                   setContentView(constraintLayout)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ConstraintLayout constraintLayout;

               protected void onCreate(Bundle savedInstanceState) {
                 super.onCreate(savedInstanceState);

                 // Create a ConstraintLayout in which to add the ImageView
                 constraintLayout = new ConstraintLayout(this);

                 // Instantiate an ImageView and define its properties
                 ImageView i = new ImageView(this);
                 i.setImageResource(R.drawable.my_image);
                 i.setContentDescription(getResources().getString(R.string.my_image_desc));

                 // set the ImageView bounds to match the Drawable's dimensions
                 i.setAdjustViewBounds(true);
                 i.setLayoutParams(new ViewGroup.LayoutParams(
                         ViewGroup.LayoutParams.WRAP_CONTENT,
                         ViewGroup.LayoutParams.WRAP_CONTENT));

                 // Add the ImageView to the layout and set the layout as the content view.
                 constraintLayout.addView(i);
                 setContentView(constraintLayout);
               }

   In other cases, you may want to handle your image resource as a
   `Drawable <#android.graphics.drawable.Drawable>`__ object, as
   shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myImage: Drawable = ResourcesCompat.getDrawable(context.resources, R.drawable.my_image, null)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = context.getResources();
               Drawable myImage = ResourcesCompat.getDrawable(res, R.drawable.my_image, null);

   **Warning:** Each unique resource in your project can maintain only one
   state, no matter how many different objects you instantiate for it. For
   example, if you instantiate two
   `Drawable <#android.graphics.drawable.Drawable>`__ objects from
   the same image resource and change a property (such as the alpha) for one
   object, then it also affects the other. When dealing with multiple instances
   of an image resource, instead of directly transforming the ``Drawable``
   object you should perform a `tween animation <#tween-animation>`__.

   The XML snippet below shows how to add a drawable resource to an
   `ImageView <#android.widget.ImageView>`__ in the XML layout:

   .. code:: prettyprint

      <ImageView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:src="@drawable/my_image"
              android:contentDescription="@string/my_image_desc" />

   For more information about using project resources, see `Resources and assets <#>`__.

   **Note:** When using image resources as the source of your drawables, be sure
   the images are the appropriate size for various pixel densities. If the
   images are not correct they will be scaled up to fit, which can cause
   artifacting in your drawables. For more information, read `Support different pixel densities <#>`__.

   .. rubric:: Create drawables from XML resources
      :name: drawables-from-xml

   If there is a
   `Drawable <#android.graphics.drawable.Drawable>`__ object that
   you'd like to create, which isn't initially dependent on variables defined by
   your code or user interaction, then defining the ``Drawable`` in XML is a
   good option. Even if you expect your ``Drawable`` to change its properties
   during the user's interaction with your app, you should consider defining the
   object in XML, as you can modify properties after the object has been
   instantiated.

   After you've defined your ``Drawable`` in XML, save the file in the
   ``res/drawable/`` directory of your project. The following example shows the
   XML that defines a
   `TransitionDrawable <#android.graphics.drawable.TransitionDrawable>`__
   resource, which inherits from ``Drawable``:

   .. code:: prettyprint

      <!-- res/drawable/expand_collapse.xml -->
      <transition xmlns:android="http://schemas.android.com/apk/res/android">
          <item android:drawable="@drawable/image_expand"/>
          <item android:drawable="@drawable/image_collapse"/>
      </transition>

   Then, retrieve and instantiate the object by calling
   `Resources#getDrawable() <#android.content.res.Resources>`__
   and passing the resource ID of your XML file. Any
   `Drawable <#android.graphics.drawable.Drawable>`__ subclass
   that supports the ``inflate()`` method can be defined in XML and instantiated
   by your app.

   **Important:** Custom classes that extend subclasses of ``Drawable`` must
   override the
   `getConstantState() <#android.graphics.drawable.Drawable>`__
   method. See the key point in `Custom drawables <#Custom>`__ below.
   Each drawable class that supports XML inflation utilizes specific XML
   attributes that help define the object properties. The following code
   instantiates the
   `TransitionDrawable <#android.graphics.drawable.TransitionDrawable>`__
   and sets it as the content of an
   `ImageView <#android.widget.ImageView>`__ object:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val transition= ResourcesCompat.getDrawable(
                       context.resources,
                       R.drawable.expand_collapse,
                       null
               ) as TransitionDrawable

               val image: ImageView = findViewById(R.id.toggle_image)
               image.setImageDrawable(transition)

               // Description of the initial state that the drawable represents.
               image.contentDescription = resources.getString(R.string.collapsed)

               // Then you can call the TransitionDrawable object's methods.
               transition.startTransition(1000)

               // After the transition is complete, change the image's content description
               // to reflect the new state.

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Resources res = context.getResources();
               TransitionDrawable transition =
                   (TransitionDrawable) ResourcesCompat.getDrawable(res, R.drawable.expand_collapse, null);

               ImageView image = (ImageView) findViewById(R.id.toggle_image);
               image.setImageDrawable(transition);

               // Description of the initial state that the drawable represents.
               image.setContentDescription(getResources().getString(R.string.collapsed));

               // Then you can call the TransitionDrawable object's methods.
               transition.startTransition(1000);

               // After the transition is complete, change the image's content description
               // to reflect the new state.

   For more information about the XML attributes supported, refer to the classes
   listed above.

   .. rubric:: Shape drawables
      :name: shape-drawable

   A `ShapeDrawable <#android.graphics.drawable.ShapeDrawable>`__
   object can be a good option when you want to dynamically draw a
   two-dimensional graphic. You can programmatically draw primitive shapes on a
   ``ShapeDrawable`` object and apply the styles that your app needs.

   `ShapeDrawable <#android.graphics.drawable.ShapeDrawable>`__ is
   a subclass of
   `Drawable <#android.graphics.drawable.Drawable>`__. For this
   reason, you can use a ``ShapeDrawable`` wherever a ``Drawable`` is expected.
   For example, you can use a ``ShapeDrawable`` object to set the background of
   a view by passing it to the
   `setBackgroundDrawable() <#android.view.View>`__
   method of the view. You can also draw your shape as its own custom view and
   add it to a layout in your app.

   Because
   `ShapeDrawable <#android.graphics.drawable.ShapeDrawable>`__
   has its own
   `draw() <#android.graphics.drawable.ShapeDrawable>`__
   method, you can create a subclass of
   `View <#android.view.View>`__ that draws the ``ShapeDrawable``
   object during the
   `onDraw() <#android.view.View>`__
   event, as shown in the following code example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CustomDrawableView(context: Context) : View(context) {
                   private val drawable: ShapeDrawable = run {
                       val x = 10
                       val y = 10
                       val width = 300
                       val height = 50
                       contentDescription = context.resources.getString(R.string.my_view_desc)

                       ShapeDrawable(OvalShape()).apply {
                           // If the color isn't set, the shape uses black as the default.
                           paint.color = 0xff74AC23.toInt()
                           // If the bounds aren't set, the shape can't be drawn.
                           setBounds(x, y, x + width, y + height)
                       }
                   }

                   override fun onDraw(canvas: Canvas) {
                       drawable.draw(canvas)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CustomDrawableView extends View {
                 private ShapeDrawable drawable;

                 public CustomDrawableView(Context context) {
                   super(context);

                   int x = 10;
                   int y = 10;
                   int width = 300;
                   int height = 50;
                   setContentDescription(context.getResources().getString(
                           R.string.my_view_desc));

                   drawable = new ShapeDrawable(new OvalShape());
                   // If the color isn't set, the shape uses black as the default.
                   drawable.getPaint().setColor(0xff74AC23);
                   // If the bounds aren't set, the shape can't be drawn.
                   drawable.setBounds(x, y, x + width, y + height);
                 }

                 protected void onDraw(Canvas canvas) {
                   drawable.draw(canvas);
                 }
               }

   You can use the ``CustomDrawableView`` class in the code sample above as you
   would use any other custom view. For example, you can programmatically add it
   to an activity in your app, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private lateinit var customDrawableView: CustomDrawableView

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   customDrawableView = CustomDrawableView(this)

                   setContentView(customDrawableView)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               CustomDrawableView customDrawableView;

               protected void onCreate(Bundle savedInstanceState) {
                 super.onCreate(savedInstanceState);
                 customDrawableView = new CustomDrawableView(this);

                 setContentView(customDrawableView);
               }

   If you want to use the custom view in the XML layout instead, then the
   ``CustomDrawableView`` class must override the
   `View(Context, AttributeSet) <#android.view.View>`__
   constructor, which is called when the class is inflated from XML. The
   following example shows how to declare the ``CustomDrawableView`` in the XML
   layout:

   .. code:: prettyprint

      <com.example.shapedrawable.CustomDrawableView
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              />

   The
   `ShapeDrawable <#android.graphics.drawable.ShapeDrawable>`__
   class, like many other drawable types in the
   `android.graphics.drawable <#android.graphics.drawable.package-summary>`__
   package, allows you to define various properties of the object by using
   public methods. Some example properties you might want to adjust include
   alpha transparency, color filter, dither, opacity, and color.

   You can also define primitive drawable shapes using XML resources. For more
   information, see `Shape drawable <#Shape>`__ in `Drawable resource types <#>`__.

   .. rubric:: NinePatch drawables
      :name: nine-patch

   A
   `NinePatchDrawable <#android.graphics.drawable.NinePatchDrawable>`__
   graphic is a stretchable bitmap image that you can use as the background of a
   view. Android automatically resizes the graphic to accommodate the contents
   of the view. An example use of a NinePatch image is the background used by
   standard Android buttons—buttons must stretch to accommodate strings of
   various lengths. A NinePatch graphic is a standard PNG image that includes an
   extra 1-pixel border. It must be saved with the ``9.png`` extension in the
   ``res/drawable/`` directory of your project.

   Use the border to define the stretchable and static areas of the image. You
   indicate a stretchable section by drawing one (or more) 1-pixel wide black
   line(s) in the left and top part of the border (the other border pixels
   should be fully transparent or white). You can have as many stretchable
   sections as you want. The relative size of the stretchable sections stays the
   same, so the largest section always remains the largest.

   You can also define an optional drawable section of the image (effectively,
   the padding lines) by drawing a line on the right and a line on the bottom.
   If a `View <#android.view.View>`__ object sets the NinePatch
   graphic as its background and then specifies the view's text, it stretches
   itself so that all the text occupies only the area designated by the right
   and bottom lines (if included). If the padding lines aren't included, Android
   uses the left and top lines to define this drawable area.

   To clarify the difference between the lines, the left and top lines define
   which pixels of the image are allowed to be replicated in order to stretch
   the image. The bottom and right lines define the relative area within the
   image that the contents of the view are allowed to occupy.

   Figure 1 shows an example of a NinePatch graphic used to define a button:

   |Image of stretchable area and padding box|
   **Figure 1:** Example of a NinePatch graphic that defines a button

   This NinePatch graphic defines one stretchable area with the left and top
   lines, and the drawable area with the bottom and right lines. In the top
   image, the dotted grey lines identify the regions of the image that are
   replicated in order to stretch the image. The pink rectangle in the bottom
   image identifies the region in which the contents of the view are allowed. If
   the contents don't fit in this region, then the image is stretched to make
   them fit.

   The `Draw 9-patch <#>`__ tool offers an extremely handy
   way to create your NinePatch images, using a WYSIWYG graphics editor. It even
   raises warnings if the region you've defined for the stretchable area is at
   risk of producing drawing artifacts as a result of the pixel replication.

   The following sample layout XML demonstrates how to add a NinePatch graphic
   to a couple of buttons. The NinePatch image is saved to
   ``res/drawable/my_button_background.9.png``.

   .. code:: prettyprint

      <Button android:id="@+id/tiny"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_alignParentTop="true"
              android:layout_centerInParent="true"
              android:text="Tiny"
              android:textSize="8sp"
              android:background="@drawable/my_button_background"/>

      <Button android:id="@+id/big"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_alignParentBottom="true"
              android:layout_centerInParent="true"
              android:text="Biiiiiiig text!"
              android:textSize="30sp"
              android:background="@drawable/my_button_background"/>

   Note that the ``layout_width`` and ``layout_height`` attributes are set to
   ``wrap_content`` to make the button fit neatly around the text.

   Figure 2 shows the two buttons rendered from the XML and NinePatch image
   shown above. Notice how the width and height of the button varies with the
   text, and the background image stretches to accommodate it.

   |Image of tiny and normal-sized buttons|
   **Figure 2:** Buttons rendered using an XML resource and a NinePatch graphic

   .. rubric:: Custom drawables
      :name: Custom

   When you want to create some custom drawings, you can do so by extending the
   `Drawable <#android.graphics.drawable.Drawable>`__ class (or
   any of its subclasses).

   The most important method to implement is
   `draw(Canvas) <#android.graphics.drawable.Drawable>`__
   because this provides the `Canvas <#android.graphics.Canvas>`__
   object you must use to provide your drawing instructions.

   The following code shows a simple subclass of
   `Drawable <#android.graphics.drawable.Drawable>`__ that draws a
   circle:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyDrawable : Drawable() {
                   private val redPaint: Paint = Paint().apply { setARGB(255, 255, 0, 0) }

                   override fun draw(canvas: Canvas) {
                       // Get the drawable's bounds
                       val width: Int = bounds.width()
                       val height: Int = bounds.height()
                       val radius: Float = Math.min(width, height).toFloat() / 2f

                       // Draw a red circle in the center
                       canvas.drawCircle((width / 2).toFloat(), (height / 2).toFloat(), radius, redPaint)
                   }

                   override fun setAlpha(alpha: Int) {
                       // This method is required
                   }

                   override fun setColorFilter(colorFilter: ColorFilter?) {
                       // This method is required
                   }

                   override fun getOpacity(): Int =
                       // Must be PixelFormat.UNKNOWN, TRANSLUCENT, TRANSPARENT, or OPAQUE
                       PixelFormat.OPAQUE
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyDrawable extends Drawable {
                   private final Paint redPaint;

                   public MyDrawable() {
                       // Set up color and text size
                       redPaint = new Paint();
                       redPaint.setARGB(255, 255, 0, 0);
                   }

                   @Override
                   public void draw(Canvas canvas) {
                       // Get the drawable's bounds
                       int width = getBounds().width();
                       int height = getBounds().height();
                       float radius = Math.min(width, height) / 2;

                       // Draw a red circle in the center
                       canvas.drawCircle(width/2, height/2, radius, redPaint);
                   }

                   @Override
                   public void setAlpha(int alpha) {
                       // This method is required
                   }

                   @Override
                   public void setColorFilter(ColorFilter colorFilter) {
                       // This method is required
                   }

                   @Override
                   public int getOpacity() {
                       // Must be PixelFormat.UNKNOWN, TRANSLUCENT, TRANSPARENT, or OPAQUE
                       return PixelFormat.OPAQUE;
                   }
               }

   Then you can add your drawable wherever you'd like, such as to an
   `ImageView <#android.widget.ImageView>`__ as shown here:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myDrawing = MyDrawable()
               val image: ImageView = findViewById(R.id.imageView)
               image.setImageDrawable(myDrawing)
               image.contentDescription = resources.getString(R.string.my_image_desc)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               MyDrawable mydrawing = new MyDrawable();
               ImageView image = findViewById(R.id.imageView);
               image.setImageDrawable(mydrawing);
               image.setContentDescription(getResources().getString(R.string.my_image_desc));

   On Android 7.0 (API level 24) and higher, you can also define instances of
   your custom drawable with XML in the following ways:

   -  Using the fully-qualified class name as the XML element name. For this
      approach, the custom drawable class must be a public top-level class:

      .. code:: prettyprint

         <com.myapp.MyDrawable xmlns:android="http://schemas.android.com/apk/res/android"
             android:color="#ffff0000" />

   -  Using ``drawable`` as the XML tag name and specifying the fully-qualified
      class name from the class attribute. This approach may be used for both
      public top-level classes and public static inner classes:

      .. code:: prettyprint

         <drawable xmlns:android="http://schemas.android.com/apk/res/android"
             class="com.myapp.MyTopLevelClass$MyDrawable"
             android:color="#ffff0000" />

   **Key point:** Custom classes that extend subclasses of ``Drawable`` (such as
   `ColorDrawable <#android.graphics.drawable.ColorDrawable>`__)
   must override the
   `getConstantState() <#android.graphics.drawable.Drawable>`__
   method and return null (or an appropriate
   `Drawable.ConstantState <#android.graphics.drawable.Drawable.ConstantState>`__)
   to ensure that all inflated instances of the custom class are the correct
   type. The first call to ``Resources#getDrawable()`` to inflate a custom class
   always correctly creates an instance that is the custom type (for example,
   ``MyColorDrawable``). However, subsequent calls create instances that are the
   parent type (for example, ``ColorDrawable``) if ``getConstantState()`` is not
   overridden. Custom classes that directly subclass ``Drawable`` do not need to
   override ``getConstantState()``.

   .. rubric:: Add tint to drawables
      :name: DrawableTint

   With Android 5.0 (API level 21) and above, you can tint bitmaps and
   nine-patches defined as alpha masks. You can tint them with color resources
   or theme attributes that resolve to color resources (for example,
   ``?android:attr/colorPrimary``). Usually, you create these assets only once
   and color them automatically to match your theme.

   You can apply a tint to
   `BitmapDrawable <#android.graphics.drawable.BitmapDrawable>`__,
   `NinePatchDrawable <#android.graphics.drawable.NinePatchDrawable>`__
   or
   `VectorDrawable <#android.graphics.drawable.VectorDrawable>`__
   objects with the ``setTint()`` method. You can also set the tint color and
   mode in your layouts with the ``android:tint`` and ``android:tintMode``
   attributes.

   .. rubric:: Extract prominent colors from an image
      :name: ColorExtract

   The Android Support Library includes the
   `Palette <#androidx.palette.graphics.Palette>`__ class, which
   lets you extract prominent colors from an image. You can load your drawables
   as a `Bitmap <#android.graphics.Bitmap>`__ and pass it to
   `Palette <#androidx.palette.graphics.Palette>`__ to access its
   colors. For more information, read `Selecting colors with the Palette API <#>`__.


Last updated 2024-04-15 UTC.

.. |Image of stretchable area and padding box| image:: https://developer.android.google.cn/static/images/ninepatch_raw.png
   :width: 439px
.. |Image of tiny and normal-sized buttons| image:: https://developer.android.google.cn/static/images/ninepatch_examples.png
   :width: 235px


/Vector images
==============

.. https://developer.android.google.cn/develop/ui/views/graphics/vector-drawable-resources?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to display graphics in Compose.

      `ImageVector → <https://developer.android.google.cn/jetpack/compose/graphics/images/compare>`__

      |image-android-compose-ui-logo|

   .. rubric:: Key points
      :name: key-points

   -  A vector drawable is a vector graphic defined in an XML file as a set of
      points, lines, and curves along with its associated color information.
   -  Vector drawables are scalable, meaning they can be resized without loss of
      display quality. This makes them ideal for use in Android apps, as it can
      help to reduce the size of your APK files and improve performance.
   -  You can create vector drawables in Android Studio by right-clicking on the
      drawable folder in your project and selecting New > Vector Asset. You can
      also import SVG files into Android Studio as vector drawables.

   Summary generated by Google Bard on 24 July, 2023
   .. rubric:: Introduction
      :name: introduction

   A
   `VectorDrawable <#android.graphics.drawable.VectorDrawable>`__
   is a vector graphic defined in an XML file as a set of points, lines, and
   curves along with its associated color information. The major advantage of
   using a vector drawable is image scalability. It can be scaled without loss
   of display quality, which means the same file is resized for different screen
   densities without loss of image quality. This results in smaller APK files
   and less developer maintenance. You can also use vector images for animation
   by using multiple XML files instead of multiple images for each display
   resolution.
   This page and the video below provide an overview of how to create vector
   drawables in XML. Android Studio can also convert SVG files to the vector
   drawable format, as described in using `Add multi-density vector graphics <#>`__.

   .. container:: video-wrapper-left

   Android 5.0 (API level 21) was the first version to officially support vector
   drawables with
   `VectorDrawable <#android.graphics.drawable.VectorDrawable>`__
   and
   `AnimatedVectorDrawable <#android.graphics.drawable.AnimatedVectorDrawable>`__,
   but you can support older versions with the Android support library, which
   provides the
   `VectorDrawableCompat <#androidx.vectordrawable.graphics.drawable.VectorDrawableCompat>`__
   and
   `AnimatedVectorDrawableCompat <#androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat>`__
   classes.

   .. rubric:: About VectorDrawable class
      :name: vector-drawable-class

   `VectorDrawable <#android.graphics.drawable.VectorDrawable>`__
   defines a static drawable object. Similar to the SVG format, each vector
   graphic is defined as a tree hierarchy, which is made up of ``path`` and
   ``group`` objects. Each ``path`` contains the geometry of the object's
   outline and ``group`` contains details for transformation. All paths are
   drawn in the same order as they appear in the XML file.

   |image-vectorpath|
   **Figure 1.** Sample hierarchy of a vector drawable asset

   The `Vector asset studio <#>`__ tool offers a
   simple way to add a vector graphic to the project as an XML file.

   .. rubric:: Example XML
      :name: example-xml

   Here is a sample ``VectorDrawable`` XML file that renders an image of a
   battery in the charging mode.

   .. code:: prettyprint

      <!-- res/drawable/battery_charging.xml -->
      <vector xmlns:android="http://schemas.android.com/apk/res/android"
          android:height="24dp"
          android:width="24dp"
          android:viewportWidth="24.0"
          android:viewportHeight="24.0">
         <group
               android:name="rotationGroup"
               android:pivotX="10.0"
               android:pivotY="10.0"
               android:rotation="15.0" >
            <path
              android:name="vect"
              android:fillColor="#FF000000"
              android:pathData="M15.67,4H14V2h-4v2H8.33C7.6,4 7,4.6 7,5.33V9h4.93L13,7v2h4V5.33C17,4.6 16.4,4 15.67,4z"
              android:fillAlpha=".3"/>
            <path
              android:name="draw"
              android:fillColor="#FF000000"
              android:pathData="M13,12.5h2L11,20v-5.5H9L11.93,9H7v11.67C7,21.4 7.6,22 8.33,22h7.33c0.74,0 1.34,-0.6 1.34,-1.33V9h-4v3.5z"/>
         </group>
      </vector>

   This XML renders the following image:

   |image-ic_battery_charging_80_black_24dp|
   .. rubric:: About AnimatedVectorDrawable class
      :name: animated-vector-drawable-class

   `AnimatedVectorDrawable <#android.graphics.drawable.AnimatedVectorDrawable>`__
   adds animation to the properties of a vector graphic. You can define an
   animated vector graphic as three separate resource files or as a single XML
   file defining the entire drawable. Let's look at both the approaches for
   better understanding: `Multiple XML files <#multiple-files>`__ and `Single XML file <#single-file>`__.

   .. rubric:: Multiple XML files
      :name: multiple-files

   By using this approach, you can define three separate XML files:

   -  A
      `VectorDrawable <#android.graphics.drawable.VectorDrawable>`__
      XML file.
   -  An
      `AnimatedVectorDrawable <#android.graphics.drawable.AnimatedVectorDrawable>`__
      XML file that defines the target
      `VectorDrawable <#android.graphics.drawable.VectorDrawable>`__,
      the target paths and groups to animate, the properties, and the animations
      defined as
      `ObjectAnimator <#android.animation.ObjectAnimator>`__
      objects or `AnimatorSet <#android.animation.AnimatorSet>`__
      objects.
   -  An animator XML file.

   .. rubric:: Example of multiple XML files
      :name: example-of-multiple-xml-files

   The following XML files demonstrate the animation of a vector graphic.

   -  VectorDrawable's XML file: ``vd.xml``

   -  .. code:: prettyprint

         <vector xmlns:android="http://schemas.android.com/apk/res/android"
            android:height="64dp"
            android:width="64dp"
            android:viewportHeight="600"
            android:viewportWidth="600" >
            <group
               android:name="rotationGroup"
               android:pivotX="300.0"
               android:pivotY="300.0"
               android:rotation="45.0" >
               <path
                  android:name="vectorPath"
                  android:fillColor="#000000"
                  android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
            </group>
         </vector>

   -  AnimatedVectorDrawable's XML file: ``avd.xml``

   -  .. code:: prettyprint

         <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
            android:drawable="@drawable/vd" >
              <target
                  android:name="rotationGroup"
                  android:animation="@anim/rotation" />
              <target
                  android:name="vectorPath"
                  android:animation="@anim/path_morph" />
         </animated-vector>

   -  Animator XML files that are used in the AnimatedVectorDrawable's XML file:
      ``rotation.xml`` and ``path_morph.xml``

   -  .. code:: prettyprint

         <objectAnimator
            android:duration="6000"
            android:propertyName="rotation"
            android:valueFrom="0"
            android:valueTo="360" />

      .. code:: prettyprint

         <set xmlns:android="http://schemas.android.com/apk/res/android">
            <objectAnimator
               android:duration="3000"
               android:propertyName="pathData"
               android:valueFrom="M300,70 l 0,-70 70,70 0,0   -70,70z"
               android:valueTo="M300,70 l 0,-70 70,0  0,140 -70,0 z"
               android:valueType="pathType"/>
         </set>

   .. rubric:: Single XML file
      :name: single-file

   By using this approach, you can merge the related XML files into a single XML
   file through the XML Bundle Format. At the time of building the app, the
   ``aapt`` tag creates separate resources and references them in the animated
   vector. This approach requires Build Tools 24 or higher, and the output is
   backward compatible.

   .. rubric:: Example of a single XML file
      :name: example-of-a-single-xml-file

   .. code:: prettyprint

      <animated-vector
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:aapt="http://schemas.android.com/aapt">
          <aapt:attr name="android:drawable">
              <vector
                  android:width="24dp"
                  android:height="24dp"
                  android:viewportWidth="24"
                  android:viewportHeight="24">
                  <path
                      android:name="root"
                      android:strokeWidth="2"
                      android:strokeLineCap="square"
                      android:strokeColor="?android:colorControlNormal"
                      android:pathData="M4.8,13.4 L9,17.6 M10.4,16.2 L19.6,7" />
              </vector>
          </aapt:attr>
          <target android:name="root">
              <aapt:attr name="android:animation">
                  <objectAnimator
                      android:propertyName="pathData"
                      android:valueFrom="M4.8,13.4 L9,17.6 M10.4,16.2 L19.6,7"
                      android:valueTo="M6.4,6.4 L17.6,17.6 M6.4,17.6 L17.6,6.4"
                      android:duration="300"
                      android:interpolator="@android:interpolator/fast_out_slow_in"
                      android:valueType="pathType" />
              </aapt:attr>
          </target>
      </animated-vector>

   .. rubric:: Vector drawables backward compatibility solution
      :name: vector-drawables-backward-solution

   To support vector drawable and animated vector drawable on devices running
   platform versions lower than Android 5.0 (API level 21), or use
   ``fillColor``, ``fillType`` and ``strokeColor`` functionalities below Android
   7.0 (API level 24),
   `VectorDrawableCompat <#androidx.vectordrawable.graphics.drawable.VectorDrawableCompat>`__
   and
   `AnimatedVectorDrawableCompat <#androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat>`__
   are available through two support libraries: ``support-vector-drawable`` and
   ``animated-vector-drawable``, respectively.

   Android Studio 1.4 introduced limited compatibility support for vector
   drawables by generating PNG files at build time. However, the vector drawable
   and animated vector drawable support Libraries offer both flexibility and
   broad compatibility — it's a support library, so you can use it with all
   Android platform versions back to Android 2.1 (API level 7+). To configure
   your app to use vector support libraries, add the ``vectorDrawables`` element
   to your ``build.gradle`` file in the app module.

   Use the following code snippet to configure the ``vectorDrawables`` element:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               // For Gradle Plugin 2.0+
               android {
                   defaultConfig {
                       vectorDrawables.useSupportLibrary = true
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               // For Gradle Plugin 2.0+
               android {
                   defaultConfig {
                       vectorDrawables.useSupportLibrary = true
                   }
               }

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               // For Gradle Plugin 1.5 or below
               android {
                   defaultConfig {
                       // Stops the Gradle plugin’s automatic rasterization of vectors
                       generatedDensities = []
                   }
                   // Flag notifies aapt to keep the attribute IDs around
                   aaptOptions {
                       additionalParameters "--no-version-vectors"
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               // For Gradle Plugin 1.5 or below
               android {
                   defaultConfig {
                       // Stops the Gradle plugin’s automatic rasterization of vectors
                       generatedDensities()
                   }
                   // Flag notifies aapt to keep the attribute IDs around
                   aaptOptions {
                       additionalParameters("--no-version-vectors")
                   }
               }

   You can use
   `VectorDrawableCompat <#androidx.vectordrawable.graphics.drawable.VectorDrawableCompat>`__
   and
   `AnimatedVectorDrawableCompat <#androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat>`__
   on all on devices running Android 4.0 (API level 14) and higher. The way
   Android loads drawables, not every place that accepts a drawable ID, such as
   in an XML file, supports loading vector drawables. The
   `android.support.v7.appcompat <#android.support.v7.appcompat.package-summary>`__
   package has added a number of features to make it easy to use vector
   drawables. Firstly, when you use
   `android.support.v7.appcompat <#android.support.v7.appcompat.package-summary>`__
   package with `ImageView <#android.widget.ImageView>`__ or with
   subclasses such as
   `ImageButton <#android.widget.ImageButton>`__ and
   `FloatingActionButton <#>`__,
   you can use the new ``app:srcCompat`` attribute to reference vector drawables
   as well as any other drawable available to ``android:src``:

   .. code:: prettyprint

      <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:srcCompat="@drawable/ic_add" />

   To change drawables at runtime, you can use the
   `setImageResource() <#android.widget.ImageView>`__
   method as before. Using ``AppCompat`` and ``app:srcCompat`` is the most
   foolproof method of integrating vector drawables into your app.

   Support Library 25.4.0 and higher supports the following features:

   -  **Path Morphing (PathType evaluator)** Used to morph one path into another
      path.
   -  **Path Interpolation** Used to define a flexible interpolator (represented
      as a path) instead of the system-defined interpolators like
      LinearInterpolator.

   Support Library 26.0.0-beta1 and higher supports the following features:

   -  **Move along path** The geometry object can move around, along an
      arbitrary path, as part of an animation.

   .. rubric:: Example of multiple XML files using the support library
      :name: example-of-multiple-xml-files-using-the-support-library

   The following XML files demonstrate the approach of using multiple XML files
   to animate a vector graphic.

   -  VectorDrawable's XML file: ``vd.xml``

   -  .. code:: prettyprint

         <vector xmlns:android="http://schemas.android.com/apk/res/android"
            android:height="64dp"
            android:width="64dp"
            android:viewportHeight="600"
            android:viewportWidth="600" >
            <group
               android:name="rotationGroup"
               android:pivotX="300.0"
               android:pivotY="300.0"
               android:rotation="45.0" >
               <path
                  android:name="vectorPath"
                  android:fillColor="#000000"
                  android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
            </group>
         </vector>

   -  AnimatedVectorDrawable's XML file: ``avd.xml``

   -  .. code:: prettyprint

         <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
            android:drawable="@drawable/vd" >
              <target
                  android:name="rotationGroup"
                  android:animation="@anim/rotation" />
         </animated-vector>

   -  Animator XML file that is used in the AnimatedVectorDrawable's XML file:
      ``rotation.xml``

   -  .. code:: prettyprint

         <objectAnimator
            android:duration="6000"
            android:propertyName="rotation"
            android:valueFrom="0"
            android:valueTo="360" />

   .. rubric:: Single XML file
      :name: single-file

   The following XML file demonstrates the approach of using a single XML file
   to animate a vector graphic. At the time of building the app, the ``aapt``
   tag creates separate resources and references them in the animated vector.
   This approach requires Build Tools 24 or higher, and the output is backward
   compatible.

   .. rubric:: Example of a single XML file using the support library
      :name: example-of-a-single-xml-file-using-the-support-library

   .. code:: prettyprint

      <animated-vector
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:aapt="http://schemas.android.com/aapt">
          <aapt:attr name="android:drawable">
              <vector xmlns:android="http://schemas.android.com/apk/res/android"
                  android:width="64dp"
                  android:height="64dp"
                  android:viewportWidth="600"
                  android:viewportHeight="600">
                  <group
                      android:name="rotationGroup"
                      android:pivotX="300"
                      android:pivotY="300"
                      android:rotation="45.0" >
                      <path
                          android:name="vectorPath"
                          android:fillColor="#000000"
                          android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
                  </group>
              </vector>
          </aapt:attr>
          <target android:name="rotationGroup">
              <aapt:attr name="android:animation">
                  <objectAnimator
                      android:propertyName="rotation"
                      android:valueFrom="0"
                      android:valueTo="360"
                      android:duration="6000"
                      android:interpolator="@android:interpolator/fast_out_slow_in" />
              </aapt:attr>
          </target>
      </animated-vector>


Last updated 2024-05-03 UTC.

.. |image-vectorpath| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/vectorpath.png
.. |image-ic_battery_charging_80_black_24dp| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/ic_battery_charging_80_black_24dp.png


/Bitmaps
========

.. https://developer.android.google.cn/develop/ui/views/graphics?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to display graphics in Compose.

      `ImageBitmap → <https://developer.android.google.cn/jetpack/compose/graphics/images/compare>`__

      |image-android-compose-ui-logo|

   .. container:: video-wrapper

   There are a number of reasons why loading bitmaps in your Android app is
   tricky:

   -  Bitmaps can very easily exhaust an app's memory budget. For example, the
      camera on the `Pixel <https://www.android.com/phones/pixel/>`__ phone
      takes photos of up to 4048x3036 pixels (12 megapixels). If the bitmap
      configuration used is
      `ARGB_8888 <#android.graphics.Bitmap.Config>`__, the default
      for Android 2.3 (API level 9) and higher, loading a single photo into
      memory takes about 48MB of memory (4048*3036*4 bytes). Such a large memory
      demand can immediately use up all the memory available to the app.
   -  Loading bitmaps on the UI thread can degrade your app's performance,
      causing slow responsiveness or even ANR messages. It is therefore
      important to manage threading appropriately when working with bitmaps.
   -  If your app is loading multiple bitmaps into memory, you need to
      skillfully manage memory and disk caching. Otherwise, the responsiveness
      and fluidity of your app's UI may suffer.

   For most cases, we recommend that you use the
   `Glide <https://github.com/bumptech/glide>`__ library to fetch, decode, and
   display bitmaps in your app. Glide abstracts out most of the complexity in
   handling these and other tasks related to working with bitmaps and other
   images on Android. For information about using and downloading Glide, visit
   the `Glide repository <https://github.com/bumptech/glide>`__ on GitHub.

   You can also opt to work directly with the lower-level APIs built into the
   Android framework. For more information on doing so, refer to `Loading Large Bitmaps Efficiently <#>`__, `Caching Bitmaps <#>`__, and `Managing Bitmap Memory <#>`__.

   .. container:: section dac-section dac-small
      :name: graphics-cards

      .. container:: wrap

         .. rubric:: More resources
            :name: more-resources
            :class: norule


Last updated 2024-04-15 UTC.



/Reduce image sizes
===================

.. https://developer.android.google.cn/develop/ui/views/graphics/reduce-image-sizes?hl=en

.. container:: devsite-article-body

   Most download traffic consists of images. As a result, the smaller you can
   make your downloadable images, the better a network experience your app can
   provide for users. This page provides guidance on making image files smaller
   and more network-friendly.

   .. rubric:: About image formats
      :name: uif

   Android apps typically use images that are in one or more of the following
   file formats: AVIF, PNG, JPG, and WebP. For each of these formats, there are
   steps you can take to reduce image sizes.

   .. rubric:: AVIF
      :name: avif

   Android 12 (API level 31) and higher support images that use the AV1 Image
   File Format (AVIF). AVIF is a container format for images and sequences of
   images encoded using AV1. AVIF takes advantage of the intra-frame encoded
   content from video compression. This dramatically improves image quality for
   the same file size when compared to older image formats, such as JPEG. For an
   in-depth look at the advantages of this format, see Jake Archibald's `blog post <https://jakearchibald.com/2020/avif-has-landed/>`__.

   .. rubric:: PNG
      :name: png

   A key to making your PNG files smaller is reducing the number of unique
   colors used in each row of pixels that comprises the image. By using fewer
   colors, you improve the compression potential at all of the other stages of
   the pipeline.

   Reducing the number of unique colors makes a significant difference because
   PNG compression effectiveness is partly a function of the degree to which
   horizontally adjacent pixel colors vary. Thus, reducing the number of unique
   colors in each row of your PNG images can help in reducing their file sizes.

   When deciding whether to pursue this strategy, you should keep in mind that
   reducing the number of unique colors effectively amounts to applying a lossy
   encoding stage to the image. However, an encoding tool may not be a good
   judge of how bad a seemingly small error looks to the human eye. Therefore,
   you should perform this work manually in order to help ensure the right
   balance between efficient compression and acceptable image quality.

   There are two particularly useful approaches you can take: striving for
   indexed formats, and applying vector quantization.

   .. rubric:: Strive for indexed formats
      :name: strive

   Any attempt at color reduction should start with trying to optimize your
   colors so that you can use the INDEXED format when exporting the image as a
   PNG. The INDEXED color mode works by choosing the best 256 colors to use, and
   replacing all pixel values with indices into that color palette. The result
   is a reduction from 16 million (potential) colors to only 256 colors: from 3
   (without transparency) or 4 (with transparency) bytes per pixel to 1 byte per
   pixel. This change is a significant first-step file size reduction.

   Figure 1 shows shows an image and its indexed variant.

   |image-beforeafterindexed|
   Figure 1. An image before and after conversion to the INDEXED format.

   Figure 2 shows the color palette for the image in Figure 1:

   |image-palette|
   Figure 2. The color palette for the image in Figure 1.

   Representing your image as a paletted image goes a long way toward
   significantly improving the file size, so it's worth investigating if the
   majority of your images can be converted.

   Of course, not every image can be accurately represented with only 256
   colors. Some images, for example, might need 257, 310, 512, or 912 colors to
   look correct. In such cases, vector quantization can also be helpful.

   .. rubric:: Vector quantization
      :name: vq

   The process of creating an indexed image may be better described as vector
   quantization (VQ). VQ serves as a rounding process for multidimensional
   numbers. In this process, all the colors in your image get grouped based upon
   their similarity. For a given group, all colors in that group are replaced by
   a single *center point* value, which minimizes error for colors in that cell
   (or "site" if you're using the Voronoi terminology). In Figure 3, the green
   dots represent input colors, and the red dots are the center points that
   replace the input colors. Each cell is bounded by blue lines.

   |image-vq|
   Figure 3. Applying vector quantization to the colors in an image.

   The result of applying VQ to an image reduces the number of unique colors,
   replacing each group of colors with a single color that's "pretty close" in
   visual quality.

   This technique also allows you to define the maximum number of unique colors
   in your image. For example, Figure 4 shows the a parrot head in 16.7 million
   colors (24 bits per pixel, or bpp) alongside a version that only allows only
   16 (3 bpp) unique colors to be used.

   |image-parrot|
   Figure 4. Image before and after application of vector quantification.

   Immediately, you can see that there's a loss of quality; most of the gradient
   colors have been replaced, imparting a banding effect to the image. This
   image needs more than 16 unique colors.

   Setting up a VQ step in your pipeline can help you get a better sense of the
   true number of unique colors that your image uses, and can help you reduce
   them significantly. There are a number of readily available tools that you
   can use to help you implement this technique.

   .. rubric:: JPG
      :name: jpg

   If you are using JPG images, there are several small changes you can make
   that potentially provide significant file-size savings. These include:

   -  Producing a smaller file size through different encoding methods (without
      impacting quality).
   -  Adjusting quality slightly in order to yield better compression.

   Pursuing these strategies can often net you file-size reductions of up to
   25%.

   When choosing tools, remember that photo exporting tools can insert
   unnecessary metadata, such as GPS information, into your images. At a
   minimum, try to leverage existing tools to help strip out this information
   from your files.

   .. rubric:: WebP
      :name: webp

   WebP is a newer image format supported from Android 4.2.1 (API level 17).
   This format provides superior lossless and lossy compression for images on
   the web. Using WebP, developers can create smaller, richer images. WebP
   lossless image files are, on average, `26% smaller <https://developers.google.cn/speed/webp/docs/webp_lossless_alpha_study#conclusions>`__
   than PNGs. These image files also support transparency (also known as alpha
   channel) at a cost of just `22% more <https://developers.google.cn/speed/webp/docs/webp_lossless_alpha_study#results>`__
   bytes.

   WebP lossy images are `25-34% smaller <https://developers.google.cn/speed/webp/docs/webp_study#experiment_1_webp_vs_jpeg_at_equal_ssim_index>`__
   than comparable JPG images at equivalent
   `SSIM <https://en.wikipedia.org/wiki/Structural_similarity>`__ quality
   indices. For cases when lossy RGB compression is acceptable, lossy WebP also
   supports transparency, typically producing file sizes 3 times smaller than
   PNG.

   For more information about WebP, visit the `WebP site <https://developers.google.cn/speed/webp/>`__.

   You can convert existing BMP, JPG, PNG or static GIF images to WebP format
   using Android Studio. For more information, see `Create WebP images Using Android Studio <#>`__.

   .. rubric:: Selecting a format
      :name: sf

   Different image formats are suitable for different types of images. JPG and
   PNG have very different compression processes, and they produce quite
   different results.

   The decision between PNG and JPG often comes down to the complexity of the
   image itself. Figure 5 shows two images that come out quite differently
   depending on which compression scheme the developer applies. The image on the
   left has many small details, and thus compresses more efficiently with JPG.
   The image on the right, with runs of the same color, compresses more
   efficiently with PNG.

   |image-comparison|
   Figure 5. Suitable cases for JPG vs. PNG

   WebP as a format can support both lossy and lossless modes, making it an
   ideal replacement for both PNG and JPG. The only thing to keep in mind is
   that it only has native support on devices running Android 4.2.1 (API level
   17) and higher. Fortunately, the large `majority of devices <https://developer.android.google.cn/about/dashboards/index.html#Platform>`__
   satisfy that requirement.

   Figure 6 provides a simple visualization to help you decide which compression
   scheme to use.

   |image-decisions|
   Figure 6. Deciding on a compression scheme

   .. rubric:: Determine optimal quality values
      :name: doqv

   There are several techniques you can use to achieve the right balance between
   compression and image quality. One technique uses scalar values and therefore
   only works for JPG and WebP. The other technique takes advantage of the
   Butteraugli library, and is usable for all image formats.

   .. rubric:: Scalar values (JPG and WebP only)
      :name: sv

   The power of JPG and WebP comes from the fact that you can use a scalar value
   to balance quality against file size. The trick is finding out what the
   correct quality value is for your image. Too low a quality level produces a
   small file at the cost of image quality. Too high a quality level increases
   file size without providing a noticeable benefit to the user.

   The most straightforward solution is to pick some non-maximum value, and use
   that value. However, be aware that the quality value affects every image
   differently. While a quality of 75%, for example, may look fine on most
   images, there may be some cases do not fare as well. You should make sure to
   test your chosen maximum value against a representative sample of images.
   Also, make sure to perform all of your tests against the original images, and
   not on compressed versions.

   For large media applications that upload and re-send millions of JPGs a day,
   hand-tuning for each asset is impractical. You might address this challenge
   by specifying several different quality levels, according to image category.
   For example, you might set 35% as the quality setting for thumbnails, since a
   smaller image hides more compression artifacts.

   .. rubric:: Butteraugli
      :name: butter

   The Butteraugli project is a library to test an image's Psychovisual Error
   Threshold: the point at which a viewer starts to notice image degradation. In
   other words, this project attempts to quantify how distorted your compressed
   image is.

   Butteraugli allows you to define a goal for visual quality, and then run PNG,
   JPG, WebP lossy, and WebP lossless compressions. You can then choose the
   image that is the best balance of file size and Butteraugli level. Figure 7
   shows an example of how Butteraugli was used to find the minimal JPG quality
   level before the visual distortion was high enough for a user could perceive
   a problem; the result is a roughly 65% reduction in file size.

   |image-moarparrots|
   Figure 7. An image before and after application of Butteraugli technology.

   Butteraugli allows you to proceed based on either output or input. That is,
   you can look for the lowest quality setting before a user perceives
   noticeable distortion in the resulting image, or you can iteratively set
   image-distortion levels to learn their associated quality levels.

   .. rubric:: Serving sizes
      :name: sizes

   It is tempting to keep only a single resolution of an image on a server. When
   a device accesses the image, the server serves it at that one resolution and
   leaves downscaling to the device.

   This solution is convenient for the developer, but potentially painful for
   the user, because the solution forces the user to download much more data
   than they need. You should instead store multiple sizes of images, and serve
   the size that is most appropriate for a particular use case. For example, for
   a thumbnail, serving an actual thumbnail image instead of serving and
   downscaling a full-size version consumes much less network bandwidth

   This approach is good for download speed, and is less costly for users who
   may be using limited or metered data plans. Proceeding like this also results
   in the image's taking less space on the device and in main memory. In the
   case of large images, such as 4K ones, this approach also saves the device
   from having to resize images before loading them.

   Implementing this approach requires that you have a backend image service to
   provide images at various resolutions with proper caching. There are existing
   services that can provide help with this task. For example, `App Engine <https://cloud.google.com/appengine/>`__ comes with image resizing
   functionality already installed.


Last updated 2024-02-22 UTC.

.. |image-beforeafterindexed| image:: https://developer.android.google.cn/static/topic/performance/images/beforeafterindexed.png
.. |image-palette| image:: https://developer.android.google.cn/static/topic/performance/images/palette.png
.. |image-vq| image:: https://developer.android.google.cn/static/topic/performance/images/vq.gif
.. |image-parrot| image:: https://developer.android.google.cn/static/topic/performance/images/parrot.png
.. |image-comparison| image:: https://developer.android.google.cn/static/topic/performance/images/comparison.png
.. |image-decisions| image:: https://developer.android.google.cn/static/topic/performance/images/decisions.png
.. |image-moarparrots| image:: https://developer.android.google.cn/static/topic/performance/images/moarparrots.png


/Fix custom-drawing issues
==========================

.. https://developer.android.google.cn/develop/ui/views/graphics/hardware-accel?hl=en

.. container:: devsite-article-body

   Beginning in Android 3.0 (API level 11), the Android 2D rendering pipeline
   supports hardware acceleration, meaning that all drawing operations that are
   performed on a `View <#android.view.View>`__'s canvas use the
   GPU. Because of the increased resources required to enable hardware
   acceleration, your app will consume more RAM.

   Hardware acceleration is enabled by default if your Target API level is >=14,
   but can also be explicitly enabled. If your application uses only standard
   views and
   `Drawable <#android.graphics.drawable.Drawable>`__\ s, turning
   it on globally should not cause any adverse drawing effects. However, because
   hardware acceleration is not supported for all of the 2D drawing operations,
   turning it on might affect some of your custom views or drawing calls.
   Problems usually manifest themselves as invisible elements, exceptions, or
   wrongly rendered pixels. To remedy this, Android gives you the option to
   enable or disable hardware acceleration at multiple levels. See `Control hardware acceleration <#controlling>`__.

   If your application performs custom drawing, test your application on actual
   hardware devices with hardware acceleration turned on to find any problems.
   The `Support for drawing operations <#drawing-support>`__ section describes
   known issues with hardware acceleration and how to work around them.

   Also see `OpenGL with the Framework APIs <#>`__ and
   `Renderscript <#>`__

   .. rubric:: Control hardware acceleration
      :name: controlling

   You can control hardware acceleration at the following levels:

   -  Application
   -  Activity
   -  Window
   -  View

   .. rubric:: Application level
      :name: application-level

   In your Android manifest file, add the following attribute to the
   `<application> <#>`__ tag to
   enable hardware acceleration for your entire application:

   .. code:: prettyprint

      <application android:hardwareAccelerated="true" ...>

   .. rubric:: Activity level
      :name: activity-level

   If your application does not behave properly with hardware acceleration
   turned on globally, you can control it for individual activities as well. To
   enable or disable hardware acceleration at the activity level, you can use
   the ``android:hardwareAccelerated`` attribute for the
   `<activity> <#>`__ element. The
   following example enables hardware acceleration for the entire application
   but disables it for one activity:

   .. code:: prettyprint

      <application android:hardwareAccelerated="true">
          <activity ... />
          <activity android:hardwareAccelerated="false" />
      </application>

   .. rubric:: Window level
      :name: window-level

   If you need even more fine-grained control, you can enable hardware
   acceleration for a given window with the following code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               window.setFlags(
                       WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
                       WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               getWindow().setFlags(
                   WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
                   WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);

   **Note**: You currently cannot disable hardware acceleration at the window
   level.

   .. rubric:: View level
      :name: view-level

   You can disable hardware acceleration for an individual view at runtime with
   the following code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);

   **Note**: You currently cannot enable hardware acceleration at the view
   level. View layers have other functions besides disabling hardware
   acceleration. See `View layers <#layers>`__ for more information about their
   uses.

   .. rubric:: Determine if a view is hardware accelerated
      :name: determining

   It is sometimes useful for an application to know whether it is currently
   hardware accelerated, especially for things such as custom views. This is
   particularly useful if your application does a lot of custom drawing and not
   all operations are properly supported by the new rendering pipeline.

   There are two different ways to check whether the application is hardware
   accelerated:

   -  `View.isHardwareAccelerated() <#android.view.View>`__
      returns ``true`` if the `View <#android.view.View>`__ is
      attached to a hardware accelerated window.
   -  `Canvas.isHardwareAccelerated() <#android.graphics.Canvas>`__
      returns ``true`` if the
      `Canvas <#android.graphics.Canvas>`__ is hardware
      accelerated

   If you must do this check in your drawing code, use
   `Canvas.isHardwareAccelerated() <#android.graphics.Canvas>`__
   instead of
   `View.isHardwareAccelerated() <#android.view.View>`__
   when possible. When a view is attached to a hardware accelerated window, it
   can still be drawn using a non-hardware accelerated Canvas. This happens, for
   instance, when drawing a view into a bitmap for caching purposes.

   .. rubric:: Android drawing models
      :name: model

   When hardware acceleration is enabled, the Android framework utilizes a new
   drawing model that utilizes *display lists* to render your application to the
   screen. To fully understand display lists and how they might affect your
   application, it is useful to understand how Android draws views without
   hardware acceleration as well. The following sections describe the
   software-based and hardware-accelerated drawing models.

   .. rubric:: Software-based drawing model
      :name: software-model

   In the software drawing model, views are drawn with the following two steps:

   #. Invalidate the hierarchy
   #. Draw the hierarchy

   Whenever an application needs to update a part of its UI, it invokes
   `invalidate() <#android.view.View>`__ (or one of
   its variants) on any view that has changed content. The invalidation messages
   are propagated all the way up the view hierarchy to compute the regions of
   the screen that need to be redrawn (the dirty region). The Android system
   then draws any view in the hierarchy that intersects with the dirty region.
   Unfortunately, there are two drawbacks to this drawing model:

   -  First, this model requires execution of a lot of code on every draw pass.
      For example, if your application calls
      `invalidate() <#android.view.View>`__ on a
      button and that button sits on top of another view, the Android system
      redraws the view even though it hasn't changed.
   -  The second issue is that the drawing model can hide bugs in your
      application. Since the Android system redraws views when they intersect
      the dirty region, a view whose content you changed might be redrawn even
      though `invalidate() <#android.view.View>`__
      was not called on it. When this happens, you are relying on another view
      being invalidated to obtain the proper behavior. This behavior can change
      every time you modify your application. Because of this, you should always
      call `invalidate() <#android.view.View>`__ on
      your custom views whenever you modify data or state that affects the
      view’s drawing code.

   **Note**: Android views automatically call
   `invalidate() <#android.view.View>`__ when their
   properties change, such as the background color or the text in a
   `TextView <#android.widget.TextView>`__.

   .. rubric:: Hardware accelerated drawing model
      :name: hardware-model

   The Android system still uses
   `invalidate() <#android.view.View>`__ and
   `draw() <#android.view.View>`__
   to request screen updates and to render views, but handles the actual drawing
   differently. Instead of executing the drawing commands immediately, the
   Android system records them inside display lists, which contain the output of
   the view hierarchy’s drawing code. Another optimization is that the Android
   system only needs to record and update display lists for views marked dirty
   by an `invalidate() <#android.view.View>`__ call.
   Views that have not been invalidated can be redrawn simply by re-issuing the
   previously recorded display list. The new drawing model contains three
   stages:

   #. Invalidate the hierarchy
   #. Record and update display lists
   #. Draw the display lists

   With this model, you cannot rely on a view intersecting the dirty region to
   have its
   `draw() <#android.view.View>`__
   method executed. To ensure that the Android system records a view’s display
   list, you must call
   `invalidate() <#android.view.View>`__. Forgetting
   to do so causes a view to look the same even after it has been changed.

   Using display lists also benefits animation performance because setting
   specific properties, such as alpha or rotation, does not require invalidating
   the targeted view (it is done automatically). This optimization also applies
   to views with display lists (any view when your application is hardware
   accelerated.) For example, assume there is a
   `LinearLayout <#android.widget.LinearLayout>`__ that contains a
   `ListView <#android.widget.ListView>`__ above a
   `Button <#android.widget.Button>`__. The display list for the
   `LinearLayout <#android.widget.LinearLayout>`__ looks like
   this:

   -  DrawDisplayList(ListView)
   -  DrawDisplayList(Button)

   Assume now that you want to change the
   `ListView <#android.widget.ListView>`__'s opacity. After
   invoking ``setAlpha(0.5f)`` on the
   `ListView <#android.widget.ListView>`__, the display list now
   contains this:

   -  SaveLayerAlpha(0.5)
   -  DrawDisplayList(ListView)
   -  Restore
   -  DrawDisplayList(Button)

   The complex drawing code of
   `ListView <#android.widget.ListView>`__ was not executed.
   Instead, the system only updated the display list of the much simpler
   `LinearLayout <#android.widget.LinearLayout>`__. In an
   application without hardware acceleration enabled, the drawing code of both
   the list and its parent are executed again.

   .. rubric:: Support for drawing operations
      :name: drawing-support

   When hardware accelerated, the 2D rendering pipeline supports the most
   commonly used `Canvas <#android.graphics.Canvas>`__ drawing
   operations as well as many less-used operations. All of the drawing
   operations that are used to render applications that ship with Android,
   default widgets and layouts, and common advanced visual effects such as
   reflections and tiled textures are supported.

   The following table describes the support level of various operations across
   API levels:

   ====================================== =========================
   \                                                                  
   \                                      First supported API level   
   Canvas                                                             
   drawBitmapMesh() (colors array)        18                          
   drawPicture()                          23                          
   drawPosText()                          16                          
   drawTextOnPath()                       16                          
   drawVertices()                         29                          
   setDrawFilter()                        16                          
   clipPath()                             18                          
   clipRegion()                           18                          
   clipRect(Region.Op.XOR)                18                          
   clipRect(Region.Op.Difference)         18                          
   clipRect(Region.Op.ReverseDifference)  18                          
   clipRect() with rotation/perspective   18                          
   Paint                                                              
   setAntiAlias() (for text)              18                          
   setAntiAlias() (for lines)             16                          
   setFilterBitmap()                      17                          
   setLinearText()                        ✗                           
   setMaskFilter()                        ✗                           
   setPathEffect() (for lines)            28                          
   setShadowLayer() (other than text)     28                          
   setStrokeCap() (for lines)             18                          
   setStrokeCap() (for points)            19                          
   setSubpixelText()                      28                          
   Xfermode                                                           
   PorterDuff.Mode.DARKEN (framebuffer)   28                          
   PorterDuff.Mode.LIGHTEN (framebuffer)  28                          
   PorterDuff.Mode.OVERLAY (framebuffer)  28                          
   Shader                                                             
   ComposeShader inside ComposeShader     28                          
   Same type shaders inside ComposeShader 28                          
   Local matrix on ComposeShader          18                          
   ====================================== =========================

   .. rubric:: Canvas scaling
      :name: scaling

   The hardware accelerated 2D rendering pipeline was built first to support
   unscaled drawing, with some drawing operations degrading quality
   significantly at higher scale values. These operations are implemented as
   textures drawn at scale 1.0, transformed by the GPU. Starting in API level
   28, all drawing operations can scale without issue.

   The following table shows when implementation was changed to correctly handle
   large scales:

   ============================== =========================
   \                              
   Drawing operation to be scaled First supported API level
   drawText()                     18
   drawPosText()                  28
   drawTextOnPath()               28
   Simple Shapes\*                17
   Complex Shapes\*               28
   drawPath()                     28
   Shadow layer                   28
   ============================== =========================

   **Note**: 'Simple' shapes are ``drawRect()``, ``drawCircle()``,
   ``drawOval()``, ``drawRoundRect()``, and ``drawArc()`` (with useCenter=false)
   commands issued with a Paint that doesn't have a PathEffect, and doesn't
   contain non-default joins (via ``setStrokeJoin()`` / ``setStrokeMiter()``).
   Other instances of those draw commands fall under 'Complex,' in the above
   chart.

   If your application is affected by any of these missing features or
   limitations, you can turn off hardware acceleration for just the affected
   portion of your application by calling
   `setLayerType(View.LAYER_TYPE_SOFTWARE, null) <#android.view.View>`__.
   This way, you can still take advantage of hardware acceleration everywhere
   else. See `Control hardware acceleration <#controlling>`__ for more
   information on how to enable and disable hardware acceleration at different
   levels in your application.

   .. rubric:: View layers
      :name: layers

   In all versions of Android, views have had the ability to render into
   off-screen buffers, either by using a view's drawing cache, or by using
   `Canvas.saveLayer() <#android.graphics.Canvas>`__.
   Off-screen buffers, or layers, have several uses. You can use them to get
   better performance when animating complex views or to apply composition
   effects. For instance, you can implement fade effects using
   ``Canvas.saveLayer()`` to temporarily render a view into a layer and then
   composite it back on screen with an opacity factor.

   Beginning in Android 3.0 (API level 11), you have more control on how and
   when to use layers with the
   `View.setLayerType() <#android.view.View>`__
   method. This API takes two parameters: the type of layer you want to use and
   an optional `Paint <#android.graphics.Paint>`__ object that
   describes how the layer should be composited. You can use the
   `Paint <#android.graphics.Paint>`__ parameter to apply color
   filters, special blending modes, or opacity to a layer. A view can use one of
   three layer types:

   -  `LAYER_TYPE_NONE <#android.view.View>`__:
      The view is rendered normally and is not backed by an off-screen buffer.
      This is the default behavior.
   -  `LAYER_TYPE_HARDWARE <#android.view.View>`__:
      The view is rendered in hardware into a hardware texture if the
      application is hardware accelerated. If the application is not hardware
      accelerated, this layer type behaves the same as
      `LAYER_TYPE_SOFTWARE <#android.view.View>`__.
   -  `LAYER_TYPE_SOFTWARE <#android.view.View>`__:
      The view is rendered in software into a bitmap.

   The type of layer you use depends on your goal:

   -  **Performance**: Use a hardware layer type to render a view into a
      hardware texture. Once a view is rendered into a layer, its drawing code
      does not have to be executed until the view calls
      `invalidate() <#android.view.View>`__. Some
      animations, such as alpha animations, can then be applied directly onto
      the layer, which is very efficient for the GPU to do.
   -  **Visual effects**: Use a hardware or software layer type and a
      `Paint <#android.graphics.Paint>`__ to apply special visual
      treatments to a view. For instance, you can draw a view in black and white
      using a
      `ColorMatrixColorFilter <#android.graphics.ColorMatrixColorFilter>`__.
   -  **Compatibility**: Use a software layer type to force a view to be
      rendered in software. If a view that is hardware accelerated (for
      instance, if your whole application is hardware acclerated), is having
      rendering problems, this is an easy way to work around limitations of the
      hardware rendering pipeline.

   .. rubric:: View layers and animations
      :name: layers-anims

   Hardware layers can deliver faster and smoother animations when your
   application is hardware accelerated. Running an animation at 60 frames per
   second is not always possible when animating complex views that issue a lot
   of drawing operations. This can be alleviated by using hardware layers to
   render the view to a hardware texture. The hardware texture can then be used
   to animate the view, eliminating the need for the view to constantly redraw
   itself when it is being animated. The view is not redrawn unless you change
   the view's properties, which calls
   `invalidate() <#android.view.View>`__, or if you
   call `invalidate() <#android.view.View>`__
   manually. If you are running an animation in your application and do not
   obtain the smooth results you want, consider enabling hardware layers on your
   animated views.

   When a view is backed by a hardware layer, some of its properties are handled
   by the way the layer is composited on screen. Setting these properties will
   be efficient because they do not require the view to be invalidated and
   redrawn. The following list of properties affect the way the layer is
   composited. Calling the setter for any of these properties results in optimal
   invalidation and no redrawing of the targeted view:

   -  ``alpha``: Changes the layer's opacity
   -  ``x``, ``y``, ``translationX``, ``translationY``: Changes the layer's
      position
   -  ``scaleX``, ``scaleY``: Changes the layer's size
   -  ``rotation``, ``rotationX``, ``rotationY``: Changes the layer's
      orientation in 3D space
   -  ``pivotX``, ``pivotY``: Changes the layer's transformations origin

   These properties are the names used when animating a view with an
   `ObjectAnimator <#android.animation.ObjectAnimator>`__. If you
   want to access these properties, call the appropriate setter or getter. For
   instance, to modify the alpha property, call
   `setAlpha() <#android.view.View>`__. The
   following code snippet shows the most efficient way to rotate a viewiew in 3D
   around the Y-axis:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               view.setLayerType(View.LAYER_TYPE_HARDWARE, null)
               ObjectAnimator.ofFloat(view, "rotationY", 180f).start()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               view.setLayerType(View.LAYER_TYPE_HARDWARE, null);
               ObjectAnimator.ofFloat(view, "rotationY", 180).start();

   Because hardware layers consume video memory, it is highly recommended that
   you enable them only for the duration of the animation and then disable them
   after the animation is done. You can accomplish this using animation
   listeners:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               view.setLayerType(View.LAYER_TYPE_HARDWARE, null)
               ObjectAnimator.ofFloat(view, "rotationY", 180f).apply {
                   addListener(object : AnimatorListenerAdapter() {
                       override fun onAnimationEnd(animation: Animator) {
                           view.setLayerType(View.LAYER_TYPE_NONE, null)
                       }
                   })
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               view.setLayerType(View.LAYER_TYPE_HARDWARE, null);
               ObjectAnimator animator = ObjectAnimator.ofFloat(view, "rotationY", 180);
               animator.addListener(new AnimatorListenerAdapter() {
                   @Override
                   public void onAnimationEnd(Animator animation) {
                       view.setLayerType(View.LAYER_TYPE_NONE, null);
                   }
               });
               animator.start();

   For more information on property animation, see `Property animation <#>`__.

   .. rubric:: Tips and tricks
      :name: tips

   Switching to hardware accelerated 2D graphics can instantly increase
   performance, but you should still design your application to use the GPU
   effectively by following these recommendations:

   **Reduce the number of views in your application**
      The more views the system has to draw, the slower it will be. This applies
      to the software rendering pipeline as well. Reducing views is one of the
      easiest ways to optimize your UI.
   **Avoid overdraw**
      Do not draw too many layers on top of each other. Remove any views that
      are completely obscured by other opaque views on top of it. If you need to
      draw several layers blended on top of each other, consider merging them
      into a single layer. A good rule of thumb with current hardware is to not
      draw more than 2.5 times the number of pixels on screen per frame
      (transparent pixels in a bitmap count!).
   **Don't create render objects in draw methods**
      A common mistake is to create a new
      `Paint <#android.graphics.Paint>`__ or a new
      `Path <#android.graphics.Path>`__ every time a rendering
      method is invoked. This forces the garbage collector to run more often and
      also bypasses caches and optimizations in the hardware pipeline.
   **Don't modify shapes too often**
      Complex shapes, paths, and circles for instance, are rendered using
      texture masks. Every time you create or modify a path, the hardware
      pipeline creates a new mask, which can be expensive.
   **Don't modify bitmaps too often**
      Every time you change the content of a bitmap, it is uploaded again as a
      GPU texture the next time you draw it.
   **Use alpha with care**
      When you make a view translucent using
      `setAlpha() <#android.view.View>`__,
      `AlphaAnimation <#android.view.animation.AlphaAnimation>`__,
      or `ObjectAnimator <#android.animation.ObjectAnimator>`__,
      it is rendered in an off-screen buffer which doubles the required
      fill-rate. When applying alpha on very large views, consider setting the
      view's layer type to ``LAYER_TYPE_HARDWARE``.


Last updated 2024-02-22 UTC.


/Add media playback controls
============================

.. https://developer.android.google.cn/develop/ui/views/playback-controls?hl=en

.. container:: devsite-article-body

   If your app plays back audio and video, you must add UI components for
   displaying media and controlling playback.

   AndroidX Media3 offers a
   `PlayerView <#androidx.media3.ui.PlayerView>`__ that displays
   playback controls, video, subtitles, and album art during playback. To make
   it work properly, connect ``PlayerView`` to a
   `Player <#androidx.media3.common.Player>`__ instance such as
   `ExoPlayer <#androidx.media3.exoplayer.ExoPlayer>`__.

   To learn more about media playback controls, see the following documentation:

   -  `Media developer center <#>`__: Review best practices and
      step-by-step guides for writing a media app.
   -  `Audio and Video guide <#>`__: Learn about
      AndroidX Media3.
   -  `Media3 ExoPlayer guide <#>`__ Develop a
      player.
   -  `Media3 UI guide <#>`__ Browse details
      about the ``PlayerView`` and customization options.


Last updated 2024-05-03 UTC.


/Add videos using picture-in-picture (PiP)
==========================================

.. https://developer.android.google.cn/develop/ui/views/picture-in-picture?hl=en

.. container:: devsite-article-body

   Starting in Android 8.0 (API level 26), Android allows activities to launch
   in picture-in-picture (PiP) mode. PiP is a special type of multi-window mode
   mostly used for video playback. It lets the user watch a video in a small
   window pinned to a corner of the screen while navigating between apps or
   browsing content on the main screen.

   **Caution:**\  Do not use a system alert window (SAW) for implementing a
   Picture-in-Picture experience. SAW is reserved for the framework's
   system-level user interactions.

   .. container::

      Alas, your browser doesn't support HTML5 video. That's OK! You can still
      `download the video <#>`__ and watch it with a video
      player.

   PiP leverages the multi-window APIs made available in Android 7.0 to provide
   the pinned video overlay window. To add PiP to your app, you need to register
   your activities that support PiP, switch your activity to PiP mode as needed,
   and make sure UI elements are hidden and video playback continues when the
   activity is in PiP mode.

   The PiP window appears in the topmost layer of the screen, in a corner chosen
   by the system.

   **Tip:**\  While this guide describes implementing PiP in views, see `Add PiP
   to your app with a Compose video player <#>`__ to do this in Compose.

   .. rubric:: How users can interact with the PiP window
      :name: gestures

   Users can drag the PiP window to another location. Starting in Android 12,
   users can also:

   -  Single-tap the window to display a full-screen toggle, a close button, a
      settings button, and custom actions provided by your app (for example,
      play controls).

   -  Double-tap the window to toggle between the current PiP size and the
      maximum or minimum PiP size—for example, double-tapping a maximized window
      minimizes it, and the converse is true as well.

   -  Stash the window by dragging it to the left or right edge. To unstash the
      window, either tap the visible part of the stashed window or drag it out.

   -  Resize the PiP window using pinch-to-zoom.

   Your app controls when the current activity enters PiP mode. Here are some
   examples:

   -  An activity can enter PiP mode when the user taps the home button or
      swipes up to home. This is how Google Maps continues to display directions
      while the user runs another activity at the same time.

   -  Your app can move a video into PiP mode when the user navigates back from
      the video to browse other content.

   -  Your app can switch a video into PiP mode while a user watches the end of
      an episode of content. The main screen displays promotional or summary
      information about the next episode in the series.

   -  Your app can provide a way for users to queue up additional content while
      they watch a video. The video continues playing in PiP mode while the main
      screen displays a content selection activity.

   .. rubric:: Declare PiP support
      :name: declaring

   By default, the system does not automatically support PiP for apps. If you
   want support PiP in your app, register your video activity in your manifest
   by setting ``android:supportsPictureInPicture`` to ``true``. Also, specify
   that your activity handles layout configuration changes so that your activity
   doesn't relaunch when layout changes occur during PiP mode transitions.

   .. code:: prettyprint

      <activity android:name="VideoActivity"
          android:supportsPictureInPicture="true"
          android:configChanges=
              "screenSize|smallestScreenSize|screenLayout|orientation"
          ...

   **Note:**\  To learn more about configuration changes, how to restrict
   Activity recreation if needed, and how to react to those configuration
   changes from the View system and Jetpack Compose, check out the `Handle configuration changes <#>`__ page.

   .. rubric:: Switch your activity to PiP
      :name: pip_button

   Starting with Android 12, you can switch your activity to PiP mode by setting
   the
   `setAutoEnterEnabled <#android.app.PictureInPictureParams.Builder>`__
   flag to ``true``. With this setting, an activity automatically switches to
   PiP mode as needed without having to explicitly call
   `enterPictureInPictureMode() <#android.app.Activity>`__
   in
   `onUserLeaveHint <#android.app.Activity>`__.
   And this has the added benefit of providing much smoother transitions. For
   details, see `Make transitions to PiP mode smoother from gesture navigation <#setautoenterenabled>`__.

   If you're targeting Android 11 or lower, an activity must call
   `enterPictureInPictureMode() <#android.app.Activity>`__
   to switch to PiP mode. For example, the following code switches an activity
   to PiP mode when the user clicks a dedicated button in the app's UI:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onActionClicked(action: Action) {
                   if (action.id.toInt() == R.id.lb_control_picture_in_picture) {
                       activity?.enterPictureInPictureMode()
                       return
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onActionClicked(Action action) {
                   if (action.getId() == R.id.lb_control_picture_in_picture) {
                       getActivity().enterPictureInPictureMode();
                       return;
                   }
                   ...
               }

   You might want to include logic that switches an activity into PiP mode
   instead of going into the background. For example, Google Maps switches to
   PiP mode if the user presses the home or recents button while the app is
   navigating. You can catch this case by overriding
   `onUserLeaveHint() <#android.app.Activity>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onUserLeaveHint() {
                   if (iWantToBeInPipModeNow()) {
                       enterPictureInPictureMode()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onUserLeaveHint () {
                   if (iWantToBeInPipModeNow()) {
                       enterPictureInPictureMode();
                   }
               }

   .. rubric:: Recommended: provide users a polished PiP transition experience
      :name: smoother-transition

   Android 12 added significant cosmetic improvements to the animated
   transitions between fullscreen and PiP windows. We strongly recommend
   implementing all applicable changes; once you've done so, these changes
   automatically scale to large screens such as foldables and tablets without
   any further required work.

   If your app doesn't include applicable updates, PiP transitions are still
   functional, but the animations are less polished. For example, transitioning
   from fullscreen to PiP mode can cause the PiP window to disappear during the
   transition before it reappears when the transition is complete.

   These changes involve the following.

   -  Making transitions to PiP mode smoother from gesture navigation
   -  Setting a proper ``sourceRectHint`` for entering and exiting PiP mode
   -  Disabling seamless resizing for non-video content

   Refer to the `Android Kotlin PictureInPicture sample <https://github.com/android/media-samples/tree/main/PictureInPictureKotlin/#readme>`__
   as a reference for enabling a polished transition experience.

   .. rubric:: Make transitions to PiP mode smoother from gesture navigation
      :name: setautoenterenabled

   Starting in Android 12, the
   `setAutoEnterEnabled <#android.app.PictureInPictureParams.Builder>`__
   flag provides much smoother animation for transitioning to video content in
   PiP mode using gesture navigation—for example, when swiping up to home from
   fullscreen.

   Complete the following steps to make this change and refer to this
   `sample <https://github.com/android/media-samples/tree/main/PictureInPictureKotlin/#readme>`__
   for a reference:

   #. Use ``setAutoEnterEnabled`` to construct
      `PictureInPictureParams.Builder <#android.app.PictureInPictureParams.Builder>`__:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  setPictureInPictureParams(PictureInPictureParams.Builder()
                      .setAspectRatio(aspectRatio)
                      .setSourceRectHint(sourceRectHint)
                      .setAutoEnterEnabled(true)
                      .build())

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  setPictureInPictureParams(new PictureInPictureParams.Builder()
                      .setAspectRatio(aspectRatio)
                      .setSourceRectHint(sourceRectHint)
                      .setAutoEnterEnabled(true)
                      .build());

      **Note:**\  When ``setAutoEnterEnabled`` is enabled, you don’t need to
      explicitly call
      `enterPictureInPictureMode <#android.app.Activity>`__
      in
      `onUserLeaveHint <#android.app.Activity>`__.

   #. Call ``setPictureInPictureParams`` with the up-to-date
      ``PictureInPictureParams`` early. The app doesn't wait for the
      ``onUserLeaveHint`` callback (as it would have done in Android 11).

      For example, you may want to call ``setPictureInPictureParams`` on the
      very first playback and any following playback if the aspect ratio is
      changed.

   #. Call ``setAutoEnterEnabled(false)``, but only as it's necessary. For
      example, you probably don't want to enter PiP if the current playback is
      in a paused state.

   .. rubric:: Set a proper ``sourceRectHint`` for entering and exiting PiP mode
      :name: set-sourcerecthint

   Starting with the introduction of PiP in Android 8.0,
   `setSourceRectHint <#android.app.PictureInPictureParams.Builder>`__
   indicated the area of the activity that is visible following the transition
   into picture-in-picture—for example, the video view bounds in a video player.

   With Android 12, the system uses ``sourceRectHint`` to implement a much
   smoother animation both when entering and exiting PiP mode.

   **Note:**\  If your app doesn't provide a proper ``sourceRectHint``, the
   system tries to apply a content overlay during the PiP entering animation,
   which makes for a poor user experience.
   To properly set ``sourceRectHint`` for entering and exiting PiP mode:

   #. Construct
      `PictureInPictureParams <#android.app.PictureInPictureParams>`__
      using the proper bounds as ``sourceRectHint``. We recommend also attaching
      a layout change listener to the video player:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val mOnLayoutChangeListener =
                  OnLayoutChangeListener { v: View?, oldLeft: Int,
                          oldTop: Int, oldRight: Int, oldBottom: Int, newLeft: Int, newTop:
                          Int, newRight: Int, newBottom: Int ->
                      val sourceRectHint = Rect()
                      mYourVideoView.getGlobalVisibleRect(sourceRectHint)
                      val builder = PictureInPictureParams.Builder()
                          .setSourceRectHint(sourceRectHint)
                      setPictureInPictureParams(builder.build())
                  }

                  mYourVideoView.addOnLayoutChangeListener(mOnLayoutChangeListener)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  private final View.OnLayoutChangeListener mOnLayoutChangeListener =
                          (v, oldLeft, oldTop, oldRight, oldBottom, newLeft, newTop, newRight,
                          newBottom) -> {
                      final Rect sourceRectHint = new Rect();
                      mYourVideoView.getGlobalVisibleRect(sourceRectHint);
                      final PictureInPictureParams.Builder builder =
                          new PictureInPictureParams.Builder()
                              .setSourceRectHint(sourceRectHint);
                      setPictureInPictureParams(builder.build());
                  };

                  mYourVideoView.addOnLayoutChangeListener(mOnLayoutChangeListener);

   #. If necessary, update the
      `sourceRectHint <#android.app.PictureInPictureParams.Builder>`__
      before the system starts the exit transition. When the system is about to
      exit PiP mode, the activity’s view hierarchy is laid out to its
      destination configuration (for example, full screen). The app can attach a
      layout change listener to its root view or target view (such as the video
      player view) to detect the event and update the ``sourceRectHint`` before
      the animation begins.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Listener is called immediately after the user exits PiP but before animating.
                  playerView.addOnLayoutChangeListener { _, left, top, right, bottom,
                                      oldLeft, oldTop, oldRight, oldBottom ->
                      if (left != oldLeft
                          || right != oldRight
                          || top != oldTop
                          || bottom != oldBottom) {
                          // The playerView's bounds changed, update the source hint rect to
                          // reflect its new bounds.
                          val sourceRectHint = Rect()
                          playerView.getGlobalVisibleRect(sourceRectHint)
                          setPictureInPictureParams(
                              PictureInPictureParams.Builder()
                                  .setSourceRectHint(sourceRectHint)
                                  .build()
                          )
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Listener is called right after the user exits PiP but before
                  // animating.
                  playerView.addOnLayoutChangeListener((v, left, top, right, bottom,
                                      oldLeft, oldTop, oldRight, oldBottom) -> {
                      if (left != oldLeft
                          || right != oldRight
                          || top != oldTop
                          || bottom != oldBottom) {
                          // The playerView's bounds changed, update the source hint rect to
                          // reflect its new bounds.
                          final Rect sourceRectHint = new Rect();
                          playerView.getGlobalVisibleRect(sourceRectHint);
                          setPictureInPictureParams(
                              new PictureInPictureParams.Builder()
                                  .setSourceRectHint(sourceRectHint)
                                  .build());
                      }
                  });

   **Note:**\  The Jetpack library ``androidx.activity`` exposes the method
   `trackPipAnimationHintView <https://developer.android.google.cn/reference/kotlin/androidx/activity/package-summary#(android.app.Activity).trackPipAnimationHintView(android.view.View)>`__
   that does the work of setting the
   `sourceRectHint <https://developer.android.google.cn/reference/android/app/PictureInPictureParams.Builder.html#setSourceRectHint(android.graphics.Rect)>`__.
   It implements the work outlined in the preceding steps, using the view passed
   into that method.

   .. rubric:: Disable seamless resizing for non-video content
      :name: seamless-resizing

   Android 12 adds the
   `setSeamlessResizeEnabled <#android.app.PictureInPictureParams.Builder>`__
   flag, which provides a much smoother cross-fading animation when resizing
   non-video content in the PiP window. Previously, resizing non-video content
   in a PiP window could create jarring visual artifacts.

   **Note:**\  The ``setSeamlessResizeEnabled`` flag is set to ``true`` by
   default for backward compatibility. Leave this set to ``true`` for video
   content, and change it to ``false`` for non-video content.
   To disable seamless resizing for non-video content:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               setPictureInPictureParams(PictureInPictureParams.Builder()
                   .setSeamlessResizeEnabled(false)
                   .build())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               setPictureInPictureParams(new PictureInPictureParams.Builder()
                   .setSeamlessResizeEnabled(false)
                   .build());

   .. rubric:: Handle UI during PiP
      :name: handling_ui

   When the activity enters or exits PiP mode, the system calls
   `Activity.onPictureInPictureModeChanged() <#android.app.Activity>`__
   or
   `Fragment.onPictureInPictureModeChanged() <#android.app.Fragment>`__.

   You should override these callbacks to redraw the activity's UI elements.
   Keep in mind that in PiP mode your activity is shown in a small window. Users
   cannot interact with your app's UI elements when it's in PiP mode and the
   details of small UI elements may be difficult to see. Video playback
   activities with minimal UI provide the best user experience.

   If your app needs to provide custom actions for PiP, see `Add controls <#add_controls>`__ on this page. Remove other UI elements before
   your activity enters PiP and restore them when your activity becomes
   fullscreen again:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onPictureInPictureModeChanged(isInPictureInPictureMode: Boolean,
                                                          newConfig: Configuration) {
                   if (isInPictureInPictureMode) {
                       // Hide the full-screen UI (controls, etc.) while in PiP mode.
                   } else {
                       // Restore the full-screen UI.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onPictureInPictureModeChanged (boolean isInPictureInPictureMode, Configuration newConfig) {
                   if (isInPictureInPictureMode) {
                       // Hide the full-screen UI (controls, etc.) while in PiP mode.
                   } else {
                       // Restore the full-screen UI.
                       ...
                   }
               }

   .. rubric:: Add controls
      :name: add_controls

   The PiP window can display controls when the user opens the window's menu (by
   tapping the window on a mobile device, or selecting the menu from the TV
   remote.)

   If an app has an `active media session <#>`__, then
   play, pause, next, and previous controls will appear.

   You can also specify custom actions explicitly by building
   `PictureInPictureParams <#android.app.PictureInPictureParams>`__
   with
   `PictureInPictureParams.Builder.setActions() <#android.app.PictureInPictureParams.Builder>`__
   before entering PiP mode, and pass the params when you enter PiP mode using
   `enterPictureInPictureMode(android.app.PictureInPictureParams) <#android.app.Activity>`__
   or
   `setPictureInPictureParams(android.app.PictureInPictureParams) <#android.app.Activity>`__.
   Be careful. If you try to add more than
   `getMaxNumPictureInPictureActions() <#android.app.Activity>`__,
   you'll only get the maximum number.

   .. rubric:: Continuing video playback while in PiP
      :name: continuing_playback

   When your activity switches to PiP, the system places the activity in the
   paused state and calls the activity's
   `onPause() <#android.app.Activity>`__ method. Video
   playback should not be paused and should continue playing if the activity is
   paused while in PiP mode.

   In Android 7.0 and later, you should pause and resume video playback when the
   system calls your activity's
   `onStop() <#android.app.Activity>`__ and
   `onStart() <#android.app.Activity>`__. By doing this,
   you can avoid having to check if your app is in PiP mode in onPause() and
   explicitly continuing playback.

   If you haven't set the
   `setAutoEnterEnabled <#android.app.PictureInPictureParams.Builder>`__
   flag to ``true`` and you need to pause playback in your ``onPause()``
   implementation, check for PiP mode by calling ``isInPictureInPictureMode()``
   and handle playback appropriately. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onPause() {
                   super.onPause()
                   // If called while in PiP mode, do not pause playback
                   if (isInPictureInPictureMode) {
                       // Continue playback
                   } else {
                       // Use existing playback logic for paused Activity behavior.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onPause() {
                   // If called while in PiP mode, do not pause playback
                   if (isInPictureInPictureMode()) {
                       // Continue playback
                       ...
                   } else {
                       // Use existing playback logic for paused Activity behavior.
                       ...
                   }
               }

   When your activity switches out of PiP mode back to full-screen mode, the
   system resumes your activity and calls your
   `onResume() <#android.app.Activity>`__ method.

   .. rubric:: Use a single playback activity for PiP
      :name: single_playback

   In your app, a user might select a new video when browsing for content on the
   main screen, while a video playback activity is in PiP mode. Play the new
   video in the existing playback activity in full screen mode, instead of
   launching a new activity that might confuse the user.

   To ensure a single activity is used for video playback requests and switched
   into or out of PiP mode as needed, set the activity's ``android:launchMode``
   to ``singleTask`` in your manifest:

   .. code:: prettyprint

      <activity android:name="VideoActivity"
          ...
          android:supportsPictureInPicture="true"
          android:launchMode="singleTask"
          ...

   In your activity, override
   `onNewIntent() <#android.app.Activity>`__
   and handle the new video, stopping any existing video playback if needed.

   .. rubric:: Best practices
      :name: best

   PiP might be disabled on devices that have low RAM. Before your app uses PiP,
   check to be sure it is available by calling
   `hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE) <#android.content.pm.PackageManager>`__.

   PiP is intended for activities that play full-screen video. When switching
   your activity into PiP mode, avoid showing anything except video content.
   Track when your activity enters PiP mode and hide UI elements, as described
   in `Handling UI during PiP <#handling_ui>`__.

   When an activity is in PiP mode, by default it doesn't get input focus. To
   receive input events while in PiP mode, use
   `MediaSession.setCallback() <#android.media.session.MediaSession>`__.
   For more information on using ``setCallback()`` see `Display a Now Playing card <#>`__.

   When your app is in PiP mode, video playback in the PiP window can cause
   audio interference with another app, such as a music player app or voice
   search app. To avoid this, request audio focus when you start playing the
   video, and handle audio focus change notifications, as described in `Managing Audio Focus <#>`__. If you receive
   notification of audio focus loss when in PiP mode, pause or stop video
   playback.

   When your app is about to enter PiP, note only the top activity enters
   picture-in-picture. In some situations such as on multi-window devices, it is
   possible the activity below will now be shown and become visible again
   alongside the PiP activity. You should handle this case accordingly,
   including the activity below getting an ``onResume()`` or an ``onPause()``
   callback. It is also possible that the user may interact with the activity.
   For example, if you have a video list activity displayed and the playing
   video activity in PiP mode, the user might select a new video from the list
   and the PiP activity should update accordingly.

   .. rubric:: Additional sample code
      :name: sample

   To download a sample app written in Android, see `Picture-in-Picture Sample <https://github.com/android/media-samples/tree/main/PictureInPicture/#readme>`__.
   To download a sample app written in Kotlin, see `Android PictureInPicture
   Sample (Kotlin) <https://github.com/android/media-samples/tree/main/PictureInPictureKotlin/#readme>`__.


Last updated 2024-05-03 UTC.


/About AGSL shaders
===================

.. https://developer.android.google.cn/develop/ui/views/graphics/agsl?hl=en

.. container:: devsite-article-body

   Android Graphics Shading Language (AGSL) is used by Android 13 and above to
   define the behavior of programmable
   `RuntimeShader <#android.graphics.RuntimeShader>`__ objects.
   AGSL shares much of its syntax with GLSL fragment shaders, but works within
   the Android graphics rendering system to both customize painting within
   ``Canvas`` and filter ``View`` content.

   .. rubric:: Theory of operation
      :name: theory_of_operation

   AGSL effects exist as part of the larger Android graphics pipeline. When
   Android issues a GPU accelerated drawing operation, it assembles a single GPU
   fragment shader to do the required work. This shader typically includes
   several pieces. For example, it might include:

   -  Evaluating whether a pixel falls inside or outside of the shape being
      drawn (or on the border, where it might apply anti-aliasing).
   -  Evaluating whether a pixel falls inside or outside of the clipping region
      (again, with possible anti-aliasing logic for border pixels).
   -  Logic for the `Shader <#android.graphics.Shader>`__ on the
      `Paint <#android.graphics.Paint>`__. The Shader can actually
      be a tree of objects (due to
      `ComposeShader <#android.graphics.ComposeShader>`__ and
      other features described below).
   -  Similar logic for the
      `ColorFilter <#android.graphics.ColorFilter>`__.
   -  Blending code (for certain types of
      `BlendMode <#android.graphics.BlendMode>`__).
   -  Color space conversion code, as part of Android's color management.
   -  When the ``Paint`` has a complex tree of objects in the ``Shader``,
      ``ColorFilter``, or ``BlendMode`` fields, there is still only a single GPU
      fragment shader. Each node in that tree creates a single function. The
      clipping code and geometry code each create a function. The blending code
      might create a function. The overall fragment shader then calls all of
      these functions (which may call other functions, e.g. in the case of a
      shader tree).

   Your AGSL effect contributes a function (or functions) to the GPU’s fragment
   shader.

   .. rubric:: Basic syntax
      :name: basic_syntax

   AGSL (and GLSL) are C-style domain specific languages. Types such as ``bool``
   and ``int`` closely track their C equivalents; there are additional types to
   support vectors and matrices that support domain functionality.

   Qualifiers can be applied to types for precision hints in a way that's unique
   to shading languages. Control structures such as ``if-else`` statements work
   much like they do in C; the language also provides support for ``switch``
   statements and ``for`` loops with limitations. Some control structures
   require constant expressions that can be evaluated at compile time.

   AGSL supports functions; every shader program begins with the ``main``
   function. User defined functions are supported, without support for recursion
   of any kind. Functions use a "value-return" calling convention; values passed
   to functions are copied into parameters when the function is called, and
   outputs are copied back; this is determined by the ``in``, ``out``, and
   ``inout`` qualifiers.


Last updated 2024-02-22 UTC.


/About AGSL versus GLSL
=======================

.. https://developer.android.google.cn/develop/ui/views/graphics/agsl/agsl-vs-glsl?hl=en

.. container:: devsite-article-body

   AGSL and GLSL are very similar in syntax, allowing many GLSL fragment shader
   effects to be brought over to Android with minimal changes. AGSL fixes its
   GLSL feature set at GLSL ES 1.0 (the shading language used by OpenGL ES 2.0)
   to provide for maximum device reach.

   A GLSL fragment shader controls the entire behavior of the GPU between the
   rasterizer and the blending hardware. That shader does all the work to
   compute a color, and the color it generates is exactly what is fed to the
   blending stage of the pipeline. When you write a shader in AGSL, you are
   programming a stage of the Android graphics pipeline. Many of the language
   differences stem from this.

   .. rubric:: Shader execution
      :name: shader_execution

   Just like in a GLSL shader, an AGSL shader begins execution in a main
   function. Unlike GLSL, the function takes the shader position in "local"
   coordinates as a parameter. This is similar to ``gl_FragCoord``, but rather
   than framebuffer coordinates, these coordinates may have been translated
   prior to calling your shader. Your shader then returns the pixel color as a
   ``vec4`` in medium or high precision (similar to ``out vec4 color`` or
   ``gl_FragColor`` in GLSL).

   .. code:: prettyprint

      mediump vec4 main(in vec2 fragCoord)

   .. rubric:: Coordinate space
      :name: coordinate_space

   |GLSL vs AGSL coordinate spaces|

   *Shader drawn using GLSL vs* `Near identical shader drawn using AGSL <https://shaders.skia.org/?id=9dc5c7170e82d49c47a3ee20d679ad5bef45b5ca7e23c4327dd93b8d3101256f>`__

   AGSL and GLSL use different coordinate spaces by default. In GLSL, the
   fragment coordinate (fragCoord) is relative to the lower left. AGSL matches
   the screen coordinate system of
   `Canvas <#android.graphics.Canvas>`__, which means that the Y axis
   begins from the upper left corner. If needed, you can convert between these
   two spaces by passing in the resolution as a uniform and using
   ``resolution.y - fragCoord.y`` for the Y axis value. Alternatively, you can
   apply a local transformation matrix to your shader.

   .. code:: prettyprint

      // AGSL to GLSL coordinate space transformation matrix
      val localMatrix = Matrix()
      localMatrix.postScale(1.0f, -1.0f)
      localMatrix.postTranslate(0.0f, viewHeight)
      gridShader.setLocalMatrix(localMatrix)

   .. rubric:: Precision and types
      :name: precision_and_types

   GLSL compatible precision modifiers are supported, but AGSL introduces
   ``half`` and ``short`` types which also represent medium precision.

   Vector types can be declared as named <base type><columns>. You can use
   ``float2`` instead of ``vec2`` and ``bool4`` instead of ``bvec4``. Matrix
   types can be declared as named <base type><columns>x<rows>, so ``float3x3``
   instead of ``mat3``. AGSL also allows GLSL-style declarations for ``mat`` and
   ``vec`` and these types are mapped to their float equivalents.

   .. rubric:: Preprocessor
      :name: preprocessor

   AGSL doesn't support GLSL style
   `preprocessor <https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)#Preprocessor_directives>`__
   directives. Convert #define statements to const variables. AGSL's compiler
   supports constant folding and branch elimination for const variables, so
   these will be efficient.

   .. rubric:: Color spaces
      :name: color_spaces

   Android Applications are color managed. The color space of a Canvas
   determines the working color space for drawing. Source content (like shaders,
   including `BitmapShader <#android.graphics.BitmapShader>`__) also
   have color spaces.

   For certain effects, such as physically accurate lighting, math should be
   done in a linear color space. To help with this, AGSL provides these
   intrinsic functions:

   .. code:: prettyprint

      half3 toLinearSrgb(half3 color)
      half3 fromLinearSrgb(half3 color)

   These convert colors between the working color space and Android's
   `LINEAR_EXTENDED_SRGB <#android.graphics.ColorSpace.Named>`__
   color space. That space uses the sRGB color primaries (gamut), and a linear
   transfer function. It represents values outside of the sRGB gamut using
   extended range values (below 0.0 and above 1.0).

   .. rubric:: Uniforms
      :name: uniforms

   Since AGSL doesn't know if uniforms contain colors, it won't automatically
   apply a color conversion to them. You can label ``half4``/``float4``/``vec4``
   with ``layout(color)``, which lets Android know that the uniform will be used
   as a color, allowing Android to transform the uniform value to the working
   color space.

   In AGSL, declare the uniform like this:

   .. code:: prettyprint

      layout(color) uniform half4 iColor;  // Input color
      uniform float2 iResolution;          // Viewport resolution (pixels)

   In Android code, you can then set the uniform like this:

   .. code:: prettyprint

      shader.setColorUniform("iColor", Color.GREEN)
      shader.setFloatUniform("iResolution", canvas.width.toFloat(), canvas.height.toFloat())


Last updated 2024-02-22 UTC.

.. |GLSL vs AGSL coordinate spaces| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/agsl/agsl-coordinate-glsl-vs-agsl.png


/Use AGSL in your app
=====================

.. https://developer.android.google.cn/develop/ui/views/graphics/agsl/using-agsl?hl=en

.. container:: devsite-article-body

   This page covers AGSL basics, and different ways to use AGSL in your Android
   app.

   .. rubric:: A simple AGSL shader
      :name: a_simple_agsl_shader

   Your shader code is called for each drawn pixel, and returns the color the
   pixel should be painted with. An extremely simple shader is one that always
   returns a single color; this example uses red. The shader is defined inside
   of a ``String``.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private const val COLOR_SHADER_SRC =
               """half4 main(float2 fragCoord) {
                  return half4(1,0,0,1);
               }"""

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private static final String COLOR_SHADER_SRC =
               "half4 main(float2 fragCoord) {\n" +
                  "return half4(1,0,0,1);\n" +
               "}";

   The next step is to create a `RuntimeShader <#android.graphics.RuntimeShader>`__
   object initialized with your shader string. This also compiles the shader.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            val fixedColorShader = RuntimeShader(COLOR_SHADER_SRC)

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            RuntimeShader fixedColorShader = new RuntimeShader(COLOR_SHADER_SRC);

   Your ``RuntimeShader`` can be used anywhere a standard
   Android shader can. As an example, you can use it to draw
   into a custom ``View`` using a `Canvas <#android.graphics.Canvas>`__.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            val paint = Paint()
            paint.shader = fixedColorShader
            override fun onDrawForeground(canvas: Canvas?) {
               canvas?.let {
                  canvas.drawPaint(paint) // fill the Canvas with the shader
               }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            Paint paint = new Paint();
            paint.setShader(fixedColorShader);
            public void onDrawForeground(@Nullable Canvas canvas) {
               if (canvas != null) {
                  canvas.drawPaint(paint); // fill the Canvas with the shader
               }
            }

   This draws a red ``View``. You can use a ``uniform`` to pass a color parameter into the
   shader to be drawn. First, add the color ``uniform`` to the shader:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private const val COLOR_SHADER_SRC =
            """layout(color) uniform half4 iColor;
               half4 main(float2 fragCoord) {
                  return iColor;
               }"""

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private static final String COLOR_SHADER_SRC =
               "layout(color) uniform half4 iColor;\n"+
                  "half4 main(float2 fragCoord) {\n" +
                  "return iColor;\n" +
               "}";

   Then, call ``setColorUniform`` from your custom ``View`` to pass the desired color
   into the AGSL shader.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            fixedColorShader.setColorUniform("iColor", Color.GREEN )

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            fixedColorShader.setColorUniform("iColor", Color.GREEN );

   Now, you get a green ``View``; the ``View`` color is controlled
   using a parameter from code in your custom ``View`` instead of
   being embedded in the shader.

   You can create a color gradient effect instead. You'll first
   need to change the shader to accept the ``View`` resolution
   as input:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private const val COLOR_SHADER_SRC =
            """uniform float2 iResolution;
               half4 main(float2 fragCoord) {
                  float2 scaled = fragCoord/iResolution.xy;
                  return half4(scaled, 0, 1);
               }"""

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private static final String COLOR_SHADER_SRC =
               "uniform float2 iResolution;\n" +
                  "half4 main(float2 fragCoord) {\n" +
                  "float2 scaled = fragCoord/iResolution.xy;\n" +
                  "return half4(scaled, 0, 1);\n" +
               "}";

         .. rubric:: Drawing the
            gradient
            :name: drawing_the_gradient

   This shader does something slightly fancy. For each pixel,
   it creates a ``float2`` vector that contains the x and y coordinates
   divided by the resolution, which will create a value between
   zero and one. It then uses that scaled vector to construct the red
   and green components of the return color.

   You pass the resolution of the ``View`` into an
   AGSL shader ``uniform`` by calling ``setFloatUniform``.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            val paint = Paint()
            paint.shader = fixedColorShader
            override fun onDrawForeground(canvas: Canvas?) {
               canvas?.let {
                  fixedColorShader.setFloatUniform("iResolution", width.toFloat(), height.toFloat())
                  canvas.drawPaint(paint)
               }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            Paint paint = new Paint();
            paint.setShader(fixedColorShader);
            public void onDrawForeground(@Nullable Canvas canvas) {
               if (canvas != null) {
                  fixedColorShader.setFloatUniform("iResolution", (float)getWidth(), (float()getHeight()));
                  canvas.drawPaint(paint);
               }
            }

         .. figure::
            https://developer.android.google.cn/static/images/guide/topics/graphics/agsl/agsl-gradient.png
            :alt: Red and Green gradient 
            :figclass: screenshot
            :width: 75.0%

            Red and green gradient

         .. rubric:: Animating
            the shader
            :name: animating_the_shader

   You can use a similar technique to animate the shader by
   modifying it to receive ``iTime`` and ``iDuration`` uniforms. The
   shader will use these values to create a triangular wave for the colors,
   causing them to cycle back and forth across their gradient values.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private const val DURATION = 4000f
            private const val COLOR_SHADER_SRC = """
               uniform float2 iResolution;
               uniform float iTime;
               uniform float iDuration;
               half4 main(in float2 fragCoord) {
                  float2 scaled = abs(1.0-mod(fragCoord/iResolution.xy+iTime/(iDuration/2.0),2.0));
                  return half4(scaled, 0, 1.0);
               }
            """

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private static final float DURATION = 4000f;
            private static final String COLOR_SHADER_SRC =
               "uniform float2 iResolution;\n"+
               "uniform float iTime;\n"+
               "uniform float iDuration;\n"+
               "half4 main(in float2 fragCoord) {\n"+
                  "float2 scaled = abs(1.0-mod(fragCoord/iResolution.xy+iTime/(iDuration/2.0),2.0));\n"+
                  "return half4(scaled, 0, 1.0);\n"+
               "}";

   From the custom view source code, a `ValueAnimator <#android.animation.ValueAnimator>`__
   updates the ``iTime`` uniform.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            // declare the ValueAnimator
            private val shaderAnimator = ValueAnimator.ofFloat(0f, DURATION)

            // use it to animate the time uniform
            shaderAnimator.duration = DURATION.toLong()
            shaderAnimator.repeatCount = ValueAnimator.INFINITE
            shaderAnimator.repeatMode = ValueAnimator.RESTART
            shaderAnimator.interpolator = LinearInterpolator()

            animatedShader.setFloatUniform("iDuration", DURATION )
            shaderAnimator.addUpdateListener { animation ->
                animatedShader.setFloatUniform("iTime", animation.animatedValue as Float )
            }
            shaderAnimator.start()

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            // declare the ValueAnimator
            private final ValueAnimator shaderAnimator = ValueAnimator.ofFloat(0f, DURATION);

            // use it to animate the time uniform
            shaderAnimator.setDuration((long)DURATION);
            shaderAnimator.setRepeatCount(ValueAnimator.INFINITE);
            shaderAnimator.setRepeatMode(ValueAnimator.RESTART);
            shaderAnimator.setInterpolator(new LinearInterpolator());

            animatedShader.setFloatUniform("iDuration", DURATION );
            shaderAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
               public final void onAnimationUpdate(ValueAnimator animation) {
                  animatedShader.setFloatUniform("iTime", (float)animation.getAnimatedValue());
               }
            });

         .. figure::
            https://developer.android.google.cn/static/images/guide/topics/graphics/agsl/agsl-animated-gradient.gif
            :alt: Red and Green animated gradient
            :figclass: screenshot

            Red and Green animated gradient

         .. rubric:: Painting complex objects
            :name: painting_complex_objects

   You don't have to draw the shader to fill the background;
   it can be used in any place that accepts a `Paint <#android.graphics.Paint>`__
   object, such as `drawText <#android.graphics.Canvas>`__.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            canvas.drawText(ANIMATED_TEXT, TEXT_MARGIN_DP, TEXT_MARGIN_DP + bounds.height(), paint)

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            canvas.drawText(ANIMATED_TEXT, TEXT_MARGIN_DP, TEXT_MARGIN_DP + bounds.height(), paint);

         .. figure::
            https://developer.android.google.cn/static/images/guide/topics/graphics/agsl/agsl-animated-gradient-text.gif
            :alt: Red and Green animated gradient text
            :figclass: screenshot

            Red and Green animated gradient text

         .. rubric:: Shading and Canvas transformations
            :name: shading_and_canvas_transformations

   You can apply additional ``Canvas`` transformations on your shaded text,
   such as rotation. In the ``ValueAnimator``, you can update a matrix
   for 3D rotations using the built-in `android.graphics.Camera <#android.graphics.Camera>`__ class.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            // in the ValueAnimator
            camera.rotate(0.0f, animation.animatedValue as Float / DURATION * 360f, 0.0f)

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            // in the ValueAnimator
            camera.rotate(0.0f, (Float)animation.getAnimatedValue() / DURATION * 360f, 0.0f);

   Since you want to rotate the text from the center axis rather than from
   the corner, get the text bounds and then use ``preTranslate`` and ``postTranslate``
   to alter the matrix to translate the text so that 0,0 is the center of the
   rotation without changing the position the text is drawn on the screen.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            linearColorPaint.getTextBounds(ANIMATED_TEXT, 0, ANIMATED_TEXT.length, bounds)
            camera.getMatrix(rotationMatrix)
            val centerX = (bounds.width().toFloat())/2
            val centerY = (bounds.height().toFloat())/2
            rotationMatrix.preTranslate(-centerX, -centerY)
            rotationMatrix.postTranslate(centerX, centerY)
            canvas.save()
            canvas.concat(rotationMatrix)
            canvas.drawText(ANIMATED_TEXT, 0f, 0f + bounds.height(), paint)
            canvas.restore()

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            linearColorPaint.getTextBounds(ANIMATED_TEXT, 0, ANIMATED_TEXT.length(), bounds);
            camera.getMatrix(rotationMatrix);
            float centerX = (float)bounds.width()/2.0f;
            float centerY = (float)bounds.height()/2.0f;
            rotationMatrix.preTranslate(-centerX, -centerY);
            rotationMatrix.postTranslate(centerX, centerY);
            canvas.save();
            canvas.concat(rotationMatrix);
            canvas.drawText(ANIMATED_TEXT, 0f, 0f + bounds.height(), paint);
            canvas.restore();

         .. figure::
            https://developer.android.google.cn/static/images/guide/topics/graphics/agsl/agsl-rotating-animated-gradient-text.gif
            :alt: Red and Green rotating animated gradient text
            :figclass: screenshot

            Red and Green rotating animated gradient text

         .. rubric:: Using RuntimeShader with Jetpack Compose
            :name: using_runtimeshader_with_jetpack_compose

   It's even easier to use ``RuntimeShader`` if you're rendering your UI using
   `Jetpack Compose <#>`__. Starting with the same gradient shader from before:

   .. code:: prettyprint

      private const val COLOR_SHADER_SRC =
          """uniform float2 iResolution;
         half4 main(float2 fragCoord) {
         float2 scaled = fragCoord/iResolution.xy;
         return half4(scaled, 0, 1);
      }"""

   You can apply that shader to a `ShaderBrush <#>`__.
   You then use the ``ShaderBrush`` as a parameter to the drawing commands
   within your ``Canvas``'s draw scope.

   .. code:: prettyprint

      // created as top level constants
      val colorShader = RuntimeShader(COLOR_SHADER_SRC)
      val shaderBrush = ShaderBrush(colorShader)

      Canvas(
         modifier = Modifier.fillMaxSize()
      ) {
         colorShader.setFloatUniform("iResolution",
         size.width, size.height)
         drawCircle(brush = shaderBrush)
      }

   .. figure::
      https://developer.android.google.cn/static/images/guide/topics/graphics/agsl/agsl-compose-gradient-circle.png
      :alt: AGSL Compose gradient circle
      :figclass: screenshot
      :width: 75.0%

      Red and green gradient circle

   .. rubric:: Using RuntimeShader with RenderEffect
      :name: using_runtimeshader_with_rendereffect

   You can use `RenderEffect <#android.graphics.RenderEffect>`__ to apply a
   `RuntimeShader <#android.graphics.RuntimeShader>`__ to a parent ``View`` *and* all child views. This is more
   expensive than drawing a custom ``View``. but it allows you to easily create an
   effect that incorporates what would have originally been drawn using
   `createRuntimeShaderEffect <#android.graphics.RenderEffect>`__.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            view.setRenderEffect(RenderEffect.createRuntimeShaderEffect(myShader, "background"))

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            view.setRenderEffect(RenderEffect.createRuntimeShaderEffect(myShader, "background"));

   The second parameter is the name of a shader uniform that you can ``eval``
   with a coordinate parameter (such as the passed in fragCoord) to get the original color of the
   `RenderNode <#android.graphics.RenderNode>`__
   (the View and its child views), allowing you to perform all sorts of effects.

   .. code:: prettyprint

      uniform shader background;       // Root node of View tree to be altered
      return mix(returnColor, background.eval(fragCoord), 0.5);

   .. figure::
      https://developer.android.google.cn/static/images/guide/topics/graphics/agsl/agsl-grid-blend.png
      :alt: Grid blended over button
      :figclass: screenshot
      :width: 50.0%

      AGSL grid blended over button

   A grid effect mixed over a button, but underneath a floating
   action button (since it's in a different ``View`` hierarchy).

   Last updated 2024-02-22 UTC.


/AGSL quick reference
=====================

.. https://developer.android.google.cn/develop/ui/views/graphics/agsl/agsl-quick-reference?hl=en

.. container:: devsite-article-body

   AGSL is designed to be largely compatible with GLSL ES 1.0. For more
   information, see the equivalent function in the 
   `OpenGL ES Shading Language documentation <https://www.khronos.org/files/opengles_shading_language.pdf>`__.
   When possible, this documentation attempts to call out differences between
   AGSL and GLSL.

   .. rubric:: Types
      :name: types

   AGSL supports GLSL ES 1.0 types along with an additional way to represent
   vector and matrix types. AGSL supports additional ``short`` and ``half``
   types to represent medium precision.

   .. rubric:: Basic types
      :name: basic_types

   +----------------------------------------+---------------------------------------+
   | Type                                   | Description                           |
   +========================================+=======================================+
   | **``void``**                           | No function return value or empty     |
   |                                        | parameter list. Unlike in GLSL,       |
   |                                        | functions without a void return type  |
   |                                        | must return a value.                  |
   +----------------------------------------+---------------------------------------+
   | **``bool, bvec2, bvec3, bvec4``**      | Boolean scalar/vector                 |
   | **``(bool2, bool3, bool4)``**.         |                                       |
   +----------------------------------------+---------------------------------------+
   | **``int, ivec2, ivec3, ivec4``**       | ``highp`` signed integer/vector       |
   | **``(int2, int3, int4)``**             |                                       |
   +----------------------------------------+---------------------------------------+
   | **``float, vec2, vec3, vec4``**        | ``highp`` (single precision) floating |
   | **``(float2, float3, float4)``**       | point scalar/vector                   |
   +----------------------------------------+---------------------------------------+
   | **``short, short2, short3, short4``**  | equivalent to ``mediump int`` signed  |
   |                                        | integer/vector                        |
   +----------------------------------------+---------------------------------------+
   | **``half, half2, half3, half4``**      | equivalent to ``mediump float``       |
   |                                        | scalar/vector                         |
   +----------------------------------------+---------------------------------------+
   | **``mat2, mat3, mat4``**               | 2x2, 3x3, 4x4 ``float`` matrix        |
   | **``(float2x2, float3x3, float4x4)``** |                                       |
   +----------------------------------------+---------------------------------------+
   | **``half2x2, half3x3, half4x4``**      | Equivalent to ``mediump float``       |
   |                                        | matrix types                          |
   +----------------------------------------+---------------------------------------+

   .. rubric:: Precision and range minimums
      :name: precision_and_range_minimums

   These are the minimum guaranteed precision and range associated with each
   modifier based upon the OpenGL ES 2.0 specification. Since most devices
   support ES 3.0, they will have more guaranteed ``highp`` precision/range and
   ``int mediump`` range. Precision modifiers can be applied to scalar, vector,
   and matrix variables and parameters. Only the minimums listed below are
   guaranteed; ``lowp`` is not necessarily actually lower precision than
   ``mediump``, and ``mediump`` is not necessarily lower precision than
   ``highp``. AGSL currently converts ``lowp`` to ``mediump`` in the final
   output.

   .. list-table::
      :header-rows: 1

      - 

         - Modifier
         - 'float' range
         - 'float' magnitude range
         - 'float' precision
         - 'int' range
      - 

         - highp
         - \\(\\left\\{-2^{62},2^{62}\\right\\}\\)
         - \\(\\left\\{2^{-62},2^{62}\\right\\}\\)
         - Relative: \\(2^{-16}\\)
         - \\(\\left\\{-2^{16},2^{16}\\right\\}\\)
      - 

         - mediump
         - \\(\\left\\{-2^{14},2^{14}\\right\\}\\)
         - \\(\\left\\{2^{-14},2^{14}\\right\\}\\)
         - Relative: \\(2^{-10}\\)
         - \\(\\left\\{-2^{10},2^{10}\\right\\}\\)
      - 

         - lowp
         - \\(\\left\\{-2,2\\right\\}\\)
         - \\(\\left\\{2^{-8},2\\right\\}\\)
         - Absolute: \\(2^{-8}\\)
         - \\(\\left\\{-2^{8},2^{8}\\right\\}\\)

   In addition to array numeric subscript syntax ex:
   var[num]\ ``, names of vector components for vectors of length 2 - 4 are denoted by a single letter. Components can be swizzled and replicated. ex:``\ vect.yx\ ``,``\ vect.yy\`

   **``vect.xyzw``** - Use when accessing vectors that represent points/normals

   **``vect.rgba``** - Use when accessing vectors that represent colors

   **``vect.LTRB``** - Use when the vector represents a rectangle (not in GLSL)

   In AGSL, 0 and 1 can be used to produce a constant 0 or 1 in that channel.
   Ex: ``vect.rgb1 == vec4(vect.rgb,1)``

   .. rubric:: Structures and arrays
      :name: structures_and_arrays

   Structures are declared with the same syntax as GLSL, but AGSL only supports
   structures at global scope.

   .. code:: prettyprint

      struct type-name {
       members
      } struct-name; // optional variable declaration.

   Only 1-dimensional arrays are supported with an explicit array size, using
   either C-style or GLSL style syntax:

   <base type>[<array size>] variable name - ex: ``half[10] x;``

   <base type> variable name[<array size>] - ex: ``half x[10];``

   Arrays cannot be returned from a function, copied, assigned or compared.
   Array restrictions propagate out to structures containing arrays. Arrays can
   only be indexed using a constant or a loop variable.

   .. rubric:: Qualifiers
      :name: qualifiers

   **Note:**\  ``attribute``, ``varying``, and ``invariant`` are not supported.

   +-----------------+-----------------------------------------------------------+
   | Type            | Description                                               |
   +=================+===========================================================+
   | **``const``**   | Compile-time constant, or read-only function parameter.   |
   +-----------------+-----------------------------------------------------------+
   | **``uniform``** | Value does not change across the primitive being          |
   |                 | processed. Uniforms are passed from Android using         |
   |                 | `RuntimeShader <#android.graphics.RuntimeShader>`__       |
   |                 | methods for ``setColorUniform``, ``setFloatUniform``,     |
   |                 | ``setIntUniform``, ``setInputBuffer``, and                |
   |                 | ``setInputShader``.                                       |
   +-----------------+-----------------------------------------------------------+
   | **``in``**      | For passed-in function parameters. This is the default.   |
   +-----------------+-----------------------------------------------------------+
   | **``out``**     | For passed-out function parameters. Must use the same     |
   |                 | precision as the function definition.                     |
   +-----------------+-----------------------------------------------------------+
   | **``inout``**   | For parameters that are both passed in and out of a       |
   |                 | function. Must use the same precision as the function     |
   |                 | definition.                                               |
   +-----------------+-----------------------------------------------------------+

   .. rubric:: Variable declaration
      :name: variable_declaration

   Declarations must be in an explicit braced scope. The declaration of
   **``y``** in the following sample is disallowed:

   .. code:: prettyprint

      if (condition)
          int y = 0;

   .. rubric:: Matrix/structure/array basics
      :name: matrixstructurearray_basics

   .. rubric:: Matrix constructor examples
      :name: matrix_constructor_examples

   When a matrix is constructed with a single value, all values along the
   diagonal are given that value, while the rest are given zeros.
   ``float2x2(1.0)`` would therefore create a 2x2 identity matrix.

   When a matrix is constructed with multiple values, columns are filled first
   (column-major order).

   Note that, unlike GLSL, constructors that reduce the number of components of
   a passed-in vector are not supported, but you can use swizzling to have the
   same effect. To construct a ``vec3`` from a ``vec4`` in AGSL with the same
   behavior as GLSL, specify ``vec3 nv = quadVec.xyz``.

   .. rubric:: Structure constructor example
      :name: structure_constructor_example

   .. code:: prettyprint

      struct light { float intensity; float3 pos; };
      // literal integer constants auto-converted to floating point
      light lightVar = light(3, float3(1, 2, 3.0));

   .. rubric:: Matrix components
      :name: matrix_components

   Access components of a matrix with array subscripting syntax.

   .. code:: prettyprint

      float4x4 m; // represents a matrix
      m[1] = float4(2.0); // sets second column to all 2.0
      m[0][0] = 1.0; // sets upper left element to 1.0
      m[2][3] = 2.0; // sets 4th element of 3rd column to 2.0

   .. rubric:: Structure fields
      :name: structure_fields

   Select structure fields using the period **``.``** operator. Operators
   include:

   ============== ==============
   Operator       Description
   ============== ==============
   **``.``**      field selector
   **``==, !=``** equality
   **``=``**      assignment
   ============== ==============

   .. rubric:: Array elements
      :name: array_elements

   Array elements are accessed using the array subscript operator ``[ ]``. For
   example:

   .. code:: prettyprint

      diffuseColor += lightIntensity[3] * NdotL;

   .. rubric:: Operators
      :name: operators

   Numbered in order of precedence. The relational and equality operators > < <=
   >= == != evaluate to a Boolean. To compare vectors component-wise, use
   functions such as ``lessThan()``, ``equal()``, etc.

   +----+-----------------------+--------------------------+---------------+
   |    | Operator              | Description              | Associativity |
   +====+=======================+==========================+===============+
   | 1  | **``()``**            | parenthetical grouping   | N/A           |
   +----+-----------------------+--------------------------+---------------+
   | 2  | **``[] () . ++ --``** | array subscript function | Left to Right |
   |    |                       | call & constructor       |               |
   |    |                       | structure field or       |               |
   |    |                       | method selector, swizzle |               |
   |    |                       | postfix increment and    |               |
   |    |                       | decrement                |               |
   +----+-----------------------+--------------------------+---------------+
   | 3  | **``++ -- + - !``**   | prefix increment and     | Right to Left |
   |    |                       | decrement unary          |               |
   +----+-----------------------+--------------------------+---------------+
   | 4  | **``* /``**           | multiply and divide      | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 5  | **``+ -``**           | add and subtract         | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 7  | **``< > <= >=``**     | relational               | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 8  | **``== !=``**         | equality/inequality      | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 12 | **``&&``**            | logical AND              | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 13 | **``^^``**            | logical XOR              | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 14 | **``||``**            | logical OR               | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 15 | **``?\:``**           | selection (one entire    | Left to Right |
   |    |                       | operand)                 |               |
   +----+-----------------------+--------------------------+---------------+
   | 16 | **``= += -= *= /=``** | assignment arithmetic    | Left to Right |
   +----+-----------------------+--------------------------+---------------+
   | 17 | **``,``**             | sequence                 | Left to Right |
   +----+-----------------------+--------------------------+---------------+

   .. rubric:: Matrix and vector operations
      :name: matrix_and_vector_operations

   When applied to scalar values, the arithmetic operators result in a scalar.
   For operators other than modulo, if one operand is a scalar and the other is
   a vector or matrix, the operation is performed componentwise and results in
   the same vector or matrix type. If both operations are vectors of the same
   size, the operation is performed componentwise (and returns the same vector
   type).

   ============= ======================================================
   Operation     Description
   ============= ======================================================
   ``m = f * m`` Component-wise matrix multiplication by a scalar value
   ``v = f * v`` Component-wise vector multiplication by a scalar value
   ``v = v * v`` Component-wise vector multiplication by a vector value
   ``m = m + m`` Matrix component-wise addition
   ``m = m - m`` Matrix component-wise subtraction
   ``m = m * m`` Linear algebraic multiply
   ============= ======================================================

   If one operand is a vector matching the row or column size of our matrix, the
   multiplication operator can be used to do algebraic row and column
   multiplication.

   ============= =================================================
   Operation     Description
   ============= =================================================
   ``m = v * m`` Row vector \* matrix linear algebraic multiply
   ``m = m * v`` Matrix \* column vector linear algebraic multiply
   ============= =================================================

   Use the built-in functions for vector dot product, cross product, and
   component-wise multiplication:

   ============================ =======================
   Function                     Description
   ============================ =======================
   ``f = dot(v, v)``            Vector dot product
   ``v = cross(v, v)``          Vector cross product
   ``m = matrixCompMult(m, m)`` Component-wise multiply
   ============================ =======================

   .. rubric:: Program control
      :name: program_control

   +---------------------------------------+---------------------------------------+
   | Function call                         | Call by value-return                  |
   +=======================================+=======================================+
   | Iteration                             | ``for (<init>;<test>;<next>)``        |
   |                                       | ``{ break, continue }``               |
   +---------------------------------------+---------------------------------------+
   | Selection                             | ``if ( ) { }``                        |
   |                                       | ``if ( ) { } else { }``               |
   |                                       | ``switch () { break, case }`` -       |
   |                                       | default case last                     |
   +---------------------------------------+---------------------------------------+
   | Jump                                  | ``break, continue, return``           |
   |                                       | (discard is not allowed)              |
   +---------------------------------------+---------------------------------------+
   | Entry                                 | ``half4 main(float2 fragCoord)``      |
   +---------------------------------------+---------------------------------------+

   .. rubric:: For loop limitations
      :name: for_loop_limitations

   Similar to GLSL ES 1.0, 'for' loops are quite limited; the compiler must be
   able to unroll the loop. This means that the initializer, the test condition,
   and the ``next`` statement must use constants so that everything can be
   computed at compile time. The ``next`` statement is further limited to using
   ``++, --, +=, or -=``.

   .. rubric:: Built-in functions
      :name: built-in_functions

   **``GT``** (generic type) is **``float``**, **``float2``**, **``float3``**,
   **``float4``** or **``half``**, **``half2``**, **``half3``**, **``half4``**.

   Most of these functions operate component-wise (the function is applied
   per-component). It's noted when that is not the case.

   .. rubric:: Angle & trigonometric functions
      :name: angle_trigonometric_functions

   Function parameters specified as an angle are assumed to be in units of
   radians. In no case will any of these functions result in a divide by zero
   error. If the divisor of a ratio is 0, then results will be undefined.

   +--------------------------------+--------------------------------------------+
   | Function                       | Description                                |
   +================================+============================================+
   | **``GT radians(GT degrees)``** | Converts degrees to radians                |
   +--------------------------------+--------------------------------------------+
   | **``GT degrees(GT radians)``** | Converts radians to degrees                |
   +--------------------------------+--------------------------------------------+
   | **``GT sin(GT angle)``**       | Standard sine                              |
   +--------------------------------+--------------------------------------------+
   | **``GT cos(GT angle)``**       | Standard cosine                            |
   +--------------------------------+--------------------------------------------+
   | **``GT tan(GT angle)``**       | Standard tangent                           |
   +--------------------------------+--------------------------------------------+
   | **``GT asin(GT x)``**          | Returns an angle whose sine is x in the    |
   |                                | range of $ \\left[-{\\pi\\over             |
   |                                | 2},{\\pi\\over 2}\\right] $                |
   +--------------------------------+--------------------------------------------+
   | **``GT acos(GT x)``**          | Returns an angle whose cosine is x in the  |
   |                                | range of $ \\left[0,\\pi\\right] $         |
   +--------------------------------+--------------------------------------------+
   | **``GT atan(GT y, GT x)``**    | Returns an angle whose trigonometric       |
   |                                | arctangent is $ \\left[{y\\over x}\\right] |
   |                                | $ in the range of $                        |
   |                                | \\left[-\\pi,\\pi\\right] $                |
   +--------------------------------+--------------------------------------------+
   | **``GT atan(GT y_over_x)``**   | Returns an angle whose trigonometric       |
   |                                | arctangent is **``y_over_x``** in the      |
   |                                | range of $ \\left[-{\\pi\\over             |
   |                                | 2},{\\pi\\over 2}\\right] $                |
   +--------------------------------+--------------------------------------------+

   .. rubric:: Exponential functions
      :name: exponential_functions

   ============================ ==============================
   Function                     Description
   ============================ ==============================
   **``GT pow(GT x, GT y)``**   Returns $ x^y $
   **``GT exp(GT x)``**         Returns $ e^x $
   **``GT log(GT x)``**         Returns $ ln(x) $
   **``GT exp2(GT x)``**        Returns $ 2^x $
   **``GT log2(GT x)``**        Returns $ log_2(x) $
   **``GT sqrt(GT x)``**        Returns $ \\sqrt{x} $
   **``GT inversesqrt(GT x)``** Returns $ 1\\over{\\sqrt{x}} $
   ============================ ==============================

   .. rubric:: Common functions
      :name: common_functions

   +--------------------------------------+--------------------------------------+
   | Function                             | Description                          |
   +======================================+======================================+
   | **``GT abs(GT x)``**                 | Absolute value                       |
   +--------------------------------------+--------------------------------------+
   | **``GT sign(GT x)``**                | Returns -1.0, 0.0, or 1.0 based on   |
   |                                      | sign of x                            |
   +--------------------------------------+--------------------------------------+
   | **``GT floor(GT x)``**               | Nearest integer <= x                 |
   +--------------------------------------+--------------------------------------+
   | **``GT ceil(GT x)``**                | Nearest integer >= x                 |
   +--------------------------------------+--------------------------------------+
   | **``GT fract(GT x)``**               | Returns the fractional part of x     |
   +--------------------------------------+--------------------------------------+
   | **``GT mod(GT x, GT y)``**           | Returns value of x modulo y          |
   +--------------------------------------+--------------------------------------+
   | **``GT mod(GT x, float y)``**        | Returns value of x modulo y          |
   +--------------------------------------+--------------------------------------+
   | **``GT min(GT x, GT y)``**           | Returns minimum value of x or y      |
   +--------------------------------------+--------------------------------------+
   | **``GT min(GT x, float y)``**        | Returns minimum value of x or y      |
   +--------------------------------------+--------------------------------------+
   | **``GT max(GT x, GT y)``**           | Returns maximum value of x or y      |
   +--------------------------------------+--------------------------------------+
   | **``GT max(GT x, float y)``**        | Returns maximum value of x or y      |
   +--------------------------------------+--------------------------------------+
   | **``GT clamp(GT x, GT``**            | Returns x clamped between minVal and |
   | **``minVal, GT maxVal)``**           | maxVal.                              |
   +--------------------------------------+--------------------------------------+
   | **``GT clamp(GT x, float``**         | Returns x clamped between minVal and |
   | **``minVal, float maxVal)``**        | maxVal                               |
   +--------------------------------------+--------------------------------------+
   | **``GT saturate(GT x)``**            | Returns x clamped between 0.0 and    |
   |                                      | 1.0                                  |
   +--------------------------------------+--------------------------------------+
   | **``GT mix(GT x, GT y``**            | Returns linear blend of x and y      |
   | **``GT a)``**                        |                                      |
   +--------------------------------------+--------------------------------------+
   | **``GT mix(GT x, GT y,``**           | Returns linear blend of x and y      |
   | **``float a)``**                     |                                      |
   +--------------------------------------+--------------------------------------+
   | **``GT step(GT edge, GT x)``**       | Returns 0.0 if x < edge, else 1.0    |
   +--------------------------------------+--------------------------------------+
   | **``GT step(float edge,``**          | Returns 0.0 if x < edge, else 1.0    |
   | **``GT x)``**                        |                                      |
   +--------------------------------------+--------------------------------------+
   | **``GT smoothstep(GT edge0,``**      | Performs Hermite interpolation       |
   | **``GT edge1, GT x)``**              | between 0 and 1 when edge0 < x <     |
   |                                      | edge1                                |
   +--------------------------------------+--------------------------------------+
   | **``GT smoothstep(float``**          | Performs Hermite interpolation       |
   | **``edge0, float edge1,``**          | between 0 and 1 when edge0 < x <     |
   | **``GT x)``**                        | edge1                                |
   +--------------------------------------+--------------------------------------+

   .. rubric:: Geometric functions
      :name: geometric_functions

   These functions operate on vectors as vectors, not component-wise. GT is
   float/half vectors in sizes 2-4.

   +--------------------------------------+--------------------------------------+
   | Function                             | Description                          |
   +======================================+======================================+
   | **``float/half length``**            | Returns length of vector             |
   | **``(GT x)``**                       |                                      |
   +--------------------------------------+--------------------------------------+
   | **``float/half distance(GT``**       | Returns distance between points      |
   | **``p0, GT p1)``**                   |                                      |
   +--------------------------------------+--------------------------------------+
   | **``float/half dot(GT x,``**         | Returns dot product                  |
   | **``GT y)``**                        |                                      |
   +--------------------------------------+--------------------------------------+
   | **``float3/half3``**                 | Returns cross product                |
   | **``cross(float3/half3 x,``**        |                                      |
   | **``float3/half3 y)``**              |                                      |
   +--------------------------------------+--------------------------------------+
   | **``GT normalize(GT x)``**           | Normalize vector to length 1         |
   +--------------------------------------+--------------------------------------+
   | **``GT faceforward(GT N,``**         | Returns N if dot(Nref, I) < 0, else  |
   | **``GT I, GT Nref)``**               | -N.                                  |
   +--------------------------------------+--------------------------------------+
   | **``GT reflect(GT I, GT N)``**       | Reflection direction I - 2 \*        |
   |                                      | dot(N,I) \* N.                       |
   +--------------------------------------+--------------------------------------+
   | **``GT refract(GT I, GT N,``**       | Returns `refraction vector`_         |
   | **``float/half eta)``**              |                                      |
   +--------------------------------------+--------------------------------------+

   .. _refraction vector: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml

   .. rubric:: Matrix functions
      :name: matrix_functions

   Type mat is any square matrix type.

   ================================================ ==============================
   Function                                         Description
   ================================================ ==============================
   **``mat matrixCompMult(mat``** **``x, mat y)``** Multiply x by y component-wise
   **``mat inverse(mat m)``**                       Returns the inverse of m
   ================================================ ==============================

   .. rubric:: Vector relational functions
      :name: vector_relational_functions

   Compare x and y component-wise. Sizes of input and return vectors for a
   particular call must match. T is the union of integer and floating point
   vector types. BV is a boolean vector that matches the size of the input
   vectors.

   +--------------------------------------+--------------------------------------+
   | Function                             | Description                          |
   +======================================+======================================+
   | **``BV lessThan(T x, T y)``**        | x < y                                |
   +--------------------------------------+--------------------------------------+
   | **``BV lessThanEqual(T x,``**        | x <= y                               |
   | **``T y)``**                         |                                      |
   +--------------------------------------+--------------------------------------+
   | **``BV greaterThan(T x,``**          | x > y                                |
   | **``T y)``**                         |                                      |
   +--------------------------------------+--------------------------------------+
   | **``BV greaterThanEqual(T``**        | x >= y                               |
   | **``x, T y)``**                      |                                      |
   +--------------------------------------+--------------------------------------+
   | **``BV equal(T x, T y)``**           | x == y                               |
   +--------------------------------------+--------------------------------------+
   | **``BV equal(BV x, BV y)``**         | x == y                               |
   +--------------------------------------+--------------------------------------+
   | **``BV notEqual(T x, T y)``**        | x != y                               |
   +--------------------------------------+--------------------------------------+
   | **``BV notEqual(BV x,``**            | x != y                               |
   | **``BV y)``**                        |                                      |
   +--------------------------------------+--------------------------------------+
   | **``bool any(BV x)``**               | ``true`` if any component of x is    |
   |                                      | ``true``                             |
   +--------------------------------------+--------------------------------------+
   | **``bool all(BV x)``**               | ``true`` if all components of x are  |
   |                                      | ``true``.                            |
   +--------------------------------------+--------------------------------------+
   | **``BV not(BV x)``**                 | logical complement of x              |
   +--------------------------------------+--------------------------------------+

   .. rubric:: Color functions
      :name: color_functions

   +--------------------------------------+--------------------------------------+
   | Function                             | Description                          |
   +======================================+======================================+
   | **``vec4 unpremul(vec4``**           | Converts color value to              |
   | **``color)``**                       | non-premultiplied alpha              |
   +--------------------------------------+--------------------------------------+
   | **``half3 toLinearSrgb(half3``**     | Color space transformation to linear |
   | **``color)``**                       | SRGB                                 |
   +--------------------------------------+--------------------------------------+
   | **``half3 fromLinearSrgb(half3``**   | Color space transformation           |
   | **``color)``**                       |                                      |
   +--------------------------------------+--------------------------------------+

   .. rubric:: Shader sampling (evaluation)
      :name: shader_sampling_evaluation

   Sampler types aren't supported, but you can evaluate other shaders. If you
   need to sample a texture, you can create a
   `BitmapShader <#android.graphics.BitmapShader>`__ object, and add
   it as a uniform. You can do this for any shader, which means you can directly
   evaluate any Android Shader without turning it into a
   `Bitmap <#android.graphics.Bitmap>`__ first, including other
   `RuntimeShader <#android.graphics.RuntimeShader>`__ objects. This
   allows for a huge amount of flexibility, but complex shaders can be expensive
   to evaluate, particularly in a loop.

   .. code:: prettyprint

      uniform shader image;

      image.eval(coord).a   // The alpha channel from the evaluated image shader

   .. rubric:: Raw buffer sampling
      :name: raw_buffer_sampling

   Although most images contain colors that should be color-managed, some images
   contain data that isn’t actually colors, including images storing normals,
   material properties (e.g., roughness), heightmaps, or any other purely
   mathematical data that happens to be stored in an image. When using these
   kinds of images in AGSL, you can use a BitmapShader as a generic raw buffer
   using
   `RuntimeShader#setInputBuffer <#android.graphics.RuntimeShader>`__.
   This will avoid color space transformations and filtering.


Last updated 2024-02-22 UTC.


/Display graphics with Open GL ES
=================================

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl/about-opengl?hl=en

.. container:: devsite-article-body

   Android includes support for high performance 2D and 3D graphics with the
   Open Graphics Library (OpenGL®), specifically, the OpenGL ES API. OpenGL is a
   cross-platform graphics API that specifies a standard software interface for
   3D graphics processing hardware. OpenGL ES is a flavor of the OpenGL
   specification intended for embedded devices. Android supports several
   versions of the OpenGL ES API:

   -  OpenGL ES 2.0 - This API specification is supported by Android 2.2 (API
      level 8) and higher.
   -  OpenGL ES 3.0 - This API specification is supported by Android 4.3 (API
      level 18) and higher.
   -  OpenGL ES 3.1 - This API specification is supported by Android 5.0 (API
      level 21) and higher.
   -  OpenGL ES 3.2 - This API specification is supported by Android 7.0 (API
      level 24) and higher.

   **Caution:** Regardless of the Android platform version, a device cannot
   support the OpenGL ES 3.0 API unless the device manufacturer provides an
   implementation of this graphics pipeline. If you specify in the manifest that
   OpenGL ES 3.0 is required, you can be sure that that version will be present
   on the device. If you specify that a lower-level version is required but you
   want to use 3.0 features if they're available, you should check at run time
   to see what version of OpenGL the device supports. For information on how to
   do this, see `Checking OpenGL ES version <#version-check>`__.

   **Note:** Android includes support for OpenGL ES 1.0 and 1.1, but these
   versions of the API are deprecated and shouldn't be used by modern
   applications.

   **Note:** The specific API provided by the Android framework is similar to
   the J2ME JSR239 OpenGL ES API, but isn't identical. If you are familiar with
   J2ME JSR239 specification, be alert for variations.

   Also see

   -  `Displaying graphics with OpenGL ES <#>`__
   -  `OpenGL ES <http://www.khronos.org/opengles/>`__
   -  `OpenGL ES 2.x specification <http://www.khronos.org/opengles/2_X/>`__
   -  `OpenGL ES 3.x specification <http://www.khronos.org/opengles/3_X/>`__

   .. rubric:: The basics
      :name: basics

   Android supports OpenGL both through its framework API and the Native
   Development Kit (NDK). This topic focuses on the Android framework
   interfaces. For more information about the NDK, see the `Android NDK <#>`__.

   There are two foundational classes in the Android framework that let you
   create and manipulate graphics with the OpenGL ES API:
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ and
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__.
   If your goal is to use OpenGL in your Android application, understanding how
   to implement these classes in an activity should be your first objective.

   `GLSurfaceView <#android.opengl.GLSurfaceView>`__
      This class is a `View <#android.view.View>`__ where you can
      draw and manipulate objects using OpenGL API calls and is similar in
      function to a `SurfaceView <#android.view.SurfaceView>`__.
      You can use this class by creating an instance of
      `GLSurfaceView <#android.opengl.GLSurfaceView>`__ and adding
      your `Renderer <#android.opengl.GLSurfaceView.Renderer>`__
      to it. However, if you want to capture touch screen events, you should
      extend the `GLSurfaceView <#android.opengl.GLSurfaceView>`__
      class to implement the touch listeners, as shown in OpenGL training
      lesson, `Responding to touch events <#>`__.
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
      This interface defines the methods required for drawing graphics in a
      `GLSurfaceView <#android.opengl.GLSurfaceView>`__. You must
      provide an implementation of this interface as a separate class and attach
      it to your `GLSurfaceView <#android.opengl.GLSurfaceView>`__
      instance using
      `GLSurfaceView.setRenderer() <#android.opengl.GLSurfaceView>`__.

      The
      `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
      interface requires that you implement the following methods:

      -  `onSurfaceCreated() <#android.opengl.GLSurfaceView.Renderer>`__:
         The system calls this method once, when creating the
         `GLSurfaceView <#android.opengl.GLSurfaceView>`__. Use
         this method to perform actions that need to happen only once, such as
         setting OpenGL environment parameters or initializing OpenGL graphic
         objects.
      -  `onDrawFrame() <#android.opengl.GLSurfaceView.Renderer>`__:
         The system calls this method on each redraw of the
         `GLSurfaceView <#android.opengl.GLSurfaceView>`__. Use
         this method as the primary execution point for drawing (and re-drawing)
         graphic objects.
      -  `onSurfaceChanged() <#android.opengl.GLSurfaceView.Renderer>`__:
         The system calls this method when the
         `GLSurfaceView <#android.opengl.GLSurfaceView>`__
         geometry changes, including changes in size of the
         `GLSurfaceView <#android.opengl.GLSurfaceView>`__ or
         orientation of the device screen. For example, the system calls this
         method when the device changes from portrait to landscape orientation.
         Use this method to respond to changes in the
         `GLSurfaceView <#android.opengl.GLSurfaceView>`__
         container.

   .. rubric:: OpenGL ES packages
      :name: packages

   Once you have established a container view for OpenGL ES using
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ and
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__,
   you can begin calling OpenGL APIs using the following classes:

   -  OpenGL ES 2.0 API Class

      -  `android.opengl.GLES20 <#android.opengl.GLES20>`__ - This
         package provides the interface to OpenGL ES 2.0 and is available
         starting with Android 2.2 (API level 8).

   -  OpenGL ES 3.0/3.1/3.2 API Packages

      -  `android.opengl <#android.opengl.package-summary>`__ -
         This package provides the interface to the OpenGL ES 3.0/3.1 classes.
         Version 3.0 is available starting with Android 4.3 (API level 18).
         Version 3.1 is available starting with Android 5.0 (API level 21).
         Version 3.2 is available starting with Android 7.0 (API level 24).

         -  `GLES30 <#android.opengl.GLES30>`__
         -  `GLES31 <#android.opengl.GLES31>`__
         -  `GLES31Ext <#android.opengl.GLES31Ext>`__ (`Android
            Extension Pack <#aep>`__)
         -  `GLES32 <#android.opengl.GLES32>`__

   If you want to start building an app with OpenGL ES right away, follow the
   `Displaying graphics with OpenGL ES <#>`__ class.

   .. rubric:: Declaring OpenGL requirements
      :name: manifest

   If your application uses OpenGL features that are not available on all
   devices, you must include these requirements in your
   `AndroidManifest.xml <#>`__ file. Here
   are the most common OpenGL manifest declarations:

   -  **OpenGL ES version requirements** - If your application requires a
      specific version of OpenGL ES, you must declare that requirement by adding
      the following settings to your manifest as shown below.

      For OpenGL ES 2.0:

      .. code:: prettyprint

         <!-- Tell the system this app requires OpenGL ES 2.0. -->
         <uses-feature android:glEsVersion="0x00020000" android:required="true" />

      Adding this declaration causes Google Play to restrict your application
      from being installed on devices that do not support OpenGL ES 2.0. If your
      application is exclusively for devices that support OpenGL ES 3.0, you can
      also specify this in your manifest:

      For OpenGL ES 3.0:

      .. code:: prettyprint

         <!-- Tell the system this app requires OpenGL ES 3.0. -->
         <uses-feature android:glEsVersion="0x00030000" android:required="true" />

      For OpenGL ES 3.1:

      .. code:: prettyprint

         <!-- Tell the system this app requires OpenGL ES 3.1. -->
         <uses-feature android:glEsVersion="0x00030001" android:required="true" />

      For OpenGL ES 3.2:

      .. code:: prettyprint

         <!-- Tell the system this app requires OpenGL ES 3.2. -->
         <uses-feature android:glEsVersion="0x00030002" android:required="true" />

      **Note:** The OpenGL ES 3.x API is backwards-compatible with the 2.0 API,
      which means you can be more flexible with your implementation of OpenGL ES
      in your application. By declaring the OpenGL ES 2.0 API as a requirement
      in your manifest, you can use that API version as a default, check for the
      availability of the 3.x API at run time and then use OpenGL ES 3.x
      features if the device supports it. For more information about checking
      the OpenGL ES version supported by a device, see `Checking OpenGL ES version <#version-check>`__.

   -  **Texture compression requirements** - If your application uses texture
      compression formats, you must declare the formats your application
      supports in your manifest file using
      `<supports-gl-texture> <#>`__.
      For more information about available texture compression formats, see
      `Texture compression support <#textures>`__.

      Declaring texture compression requirements in your manifest hides your
      application from users with devices that do not support at least one of
      your declared compression types. For more information on how Google Play
      filtering works for texture compressions, see the 
      `Google Play and texture compression filtering <#market-texture-filtering>`__
      section of the ``<supports-gl-texture>`` documentation.

   .. rubric:: Mapping coordinates for drawn objects
      :name: coordinate-mapping

   One of the basic problems in displaying graphics on Android devices is that
   their screens can vary in size and shape. OpenGL assumes a square, uniform
   coordinate system and, by default, happily draws those coordinates onto your
   typically non-square screen as if it is perfectly square.

   |image-coordinates|
   **Figure 1.** Default OpenGL coordinate system (left) mapped to a typical
   Android device screen (right).

   The illustration above shows the uniform coordinate system assumed for an
   OpenGL frame on the left, and how these coordinates actually map to a typical
   device screen in landscape orientation on the right. To solve this problem,
   you can apply OpenGL projection modes and camera views to transform
   coordinates so your graphic objects have the correct proportions on any
   display.

   In order to apply projection and camera views, you create a projection matrix
   and a camera view matrix and apply them to the OpenGL rendering pipeline. The
   projection matrix recalculates the coordinates of your graphics so that they
   map correctly to Android device screens. The camera view matrix creates a
   transformation that renders objects from a specific eye position.

   .. rubric:: Projection and camera view in OpenGL ES 2.0 and higher
      :name: proj-es2

   In the ES 2.0 and 3.0 APIs, you apply projection and camera view by first
   adding a matrix member to the vertex shaders of your graphics objects. With
   this matrix member added, you can then generate and apply projection and
   camera viewing matrices to your objects.

   #. **Add matrix to vertex shaders** - Create a variable for the view
      projection matrix and include it as a multiplier of the shader's position.
      In the following example vertex shader code, the included ``uMVPMatrix``
      member allows you to apply projection and camera viewing matrices to the
      coordinates of objects that use this shader.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  private val vertexShaderCode =

                      // This matrix member variable provides a hook to manipulate
                      // the coordinates of objects that use this vertex shader.
                      "uniform mat4 uMVPMatrix;   \n" +

                      "attribute vec4 vPosition;  \n" +
                      "void main(){               \n" +
                      // The matrix must be included as part of gl_Position
                      // Note that the uMVPMatrix factor *must be first* in order
                      // for the matrix multiplication product to be correct.
                      " gl_Position = uMVPMatrix * vPosition; \n" +

                      "}  \n"

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  private final String vertexShaderCode =

                      // This matrix member variable provides a hook to manipulate
                      // the coordinates of objects that use this vertex shader.
                      "uniform mat4 uMVPMatrix;   \n" +

                      "attribute vec4 vPosition;  \n" +
                      "void main(){               \n" +
                      // The matrix must be included as part of gl_Position
                      // Note that the uMVPMatrix factor *must be first* in order
                      // for the matrix multiplication product to be correct.
                      " gl_Position = uMVPMatrix * vPosition; \n" +

                      "}  \n";

      **Note:** The example above defines a single transformation matrix member
      in the vertex shader into which you apply a combined projection matrix and
      camera view matrix. Depending on your application requirements, you may
      want to define separate projection matrix and camera viewing matrix
      members in your vertex shaders so you can change them independently.

   #. **Access the shader matrix** - After creating a hook in your vertex
      shaders to apply projection and camera view, you can then access that
      variable to apply projection and camera viewing matrices. The following
      code shows how to modify the
      `onSurfaceCreated() <#android.opengl.GLSurfaceView.Renderer>`__
      method of a
      `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
      implementation to access the matrix variable defined in the vertex shader
      above.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  override fun onSurfaceCreated(gl: GL10, config: EGLConfig) {
                      ...
                      muMVPMatrixHandle = GLES20.glGetUniformLocation(program, "uMVPMatrix")
                      ...
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public void onSurfaceCreated(GL10 unused, EGLConfig config) {
                      ...
                      muMVPMatrixHandle = GLES20.glGetUniformLocation(program, "uMVPMatrix");
                      ...
                  }

   #. **Create projection and camera viewing matrices** - Generate the
      projection and viewing matrices to be applied the graphic objects. The
      following example code shows how to modify the
      `onSurfaceCreated() <#android.opengl.GLSurfaceView.Renderer>`__
      and
      `onSurfaceChanged() <#android.opengl.GLSurfaceView.Renderer>`__
      methods of a
      `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
      implementation to create camera view matrix and a projection matrix based
      on the screen aspect ratio of the device.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  override fun onSurfaceCreated(gl: GL10, config: EGLConfig) {
                      ...
                      // Create a camera view matrix
                      Matrix.setLookAtM(vMatrix, 0, 0f, 0f, -3f, 0f, 0f, 0f, 0f, 1.0f, 0.0f)
                  }

                  override fun onSurfaceChanged(gl: GL10, width: Int, height: Int) {
                      GLES20.glViewport(0, 0, width, height)

                      val ratio: Float = width.toFloat() / height.toFloat()

                      // create a projection matrix from device screen geometry
                      Matrix.frustumM(projMatrix, 0, -ratio, ratio, -1f, 1f, 3f, 7f)
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public void onSurfaceCreated(GL10 unused, EGLConfig config) {
                      ...
                      // Create a camera view matrix
                      Matrix.setLookAtM(vMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
                  }

                  public void onSurfaceChanged(GL10 unused, int width, int height) {
                      GLES20.glViewport(0, 0, width, height);

                      float ratio = (float) width / height;

                      // create a projection matrix from device screen geometry
                      Matrix.frustumM(projMatrix, 0, -ratio, ratio, -1, 1, 3, 7);
                  }

   #. **Apply projection and camera viewing matrices** - To apply the projection
      and camera view transformations, multiply the matrices together and then
      set them into the vertex shader. The following example code shows how
      modify the
      `onDrawFrame() <#android.opengl.GLSurfaceView.Renderer>`__
      method of a
      `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
      implementation to combine the projection matrix and camera view created in
      the code above and then apply it to the graphic objects to be rendered by
      OpenGL.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  override fun onDrawFrame(gl: GL10) {
                      ...
                      // Combine the projection and camera view matrices
                      Matrix.multiplyMM(vPMatrix, 0, projMatrix, 0, vMatrix, 0)

                      // Apply the combined projection and camera view transformations
                      GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, vPMatrix, 0)

                      // Draw objects
                      ...
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public void onDrawFrame(GL10 unused) {
                      ...
                      // Combine the projection and camera view matrices
                      Matrix.multiplyMM(vPMatrix, 0, projMatrix, 0, vMatrix, 0);

                      // Apply the combined projection and camera view transformations
                      GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, vPMatrix, 0);

                      // Draw objects
                      ...
                  }

   For a complete example of how to apply projection and camera view with OpenGL
   ES 2.0, see the `Displaying graphics with OpenGL ES <#>`__ class.

   .. rubric:: Shape faces and winding
      :name: faces-winding

   In OpenGL, the face of a shape is a surface defined by three or more points
   in three-dimensional space. A set of three or more three-dimensional points
   (called vertices in OpenGL) have a front face and a back face. How do you
   know which face is front and which is the back? Good question. The answer has
   to do with winding, or, the direction in which you define the points of a
   shape.

   |Coordinates at vertices of a triangle|
   **Figure 1.** Illustration of a coordinate list which translates into a
   counterclockwise drawing order.

   In this example, the points of the triangle are defined in an order such that
   they are drawn in a counterclockwise direction. The order in which these
   coordinates are drawn defines the winding direction for the shape. By
   default, in OpenGL, the face which is drawn counterclockwise is the front
   face. The triangle shown in Figure 1 is defined so that you are looking at
   the front face of the shape (as interpreted by OpenGL) and the other side is
   the back face.

   Why is it important to know which face of a shape is the front face? The
   answer has to do with a commonly used feature of OpenGL, called face culling.
   Face culling is an option for the OpenGL environment which allows the
   rendering pipeline to ignore (not calculate or draw) the back face of a
   shape, saving time, memory and processing cycles:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               gl.apply {
                   // enable face culling feature
                   glEnable(GL10.GL_CULL_FACE)
                   // specify which faces to not draw
                   glCullFace(GL10.GL_BACK)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // enable face culling feature
               gl.glEnable(GL10.GL_CULL_FACE);
               // specify which faces to not draw
               gl.glCullFace(GL10.GL_BACK);

   If you try to use the face culling feature without knowing which sides of
   your shapes are the front and back, your OpenGL graphics are going to look a
   bit thin, or possibly not show up at all. So, always define the coordinates
   of your OpenGL shapes in a counterclockwise drawing order.

   **Note:** It is possible to set an OpenGL environment to treat the clockwise
   face as the front face, but doing so requires more code and is likely to
   confuse experienced OpenGL developers when you ask them for help. So don’t do
   that.

   .. rubric:: OpenGL versions and device compatibility
      :name: compatibility

   The OpenGL ES 1.0 and 1.1 API specifications have been supported since
   Android 1.0. Graphics programming with OpenGL ES 1.0/1.1 API is significantly
   different than using the 2.0 and higher versions. OpenGL ES 2.0 is supported
   by all Android devices beginning with Android 2.2 (API level 8) and is the
   earliest version recommended for new applications being developed with OpenGL
   ES. OpenGL ES 3.0 is supported with Android 4.3 (API level 18) and higher, on
   devices that provide an implementation of the OpenGL ES 3.0 API. For
   information about the relative number of Android-powered devices that support
   a given version of OpenGL ES, see the 
   `OpenGL ES version dashboard <#OpenGL>`__.

   You should carefully consider the graphics requirements and choose the API
   version that works best for your application. For more information, see
   `Choosing an OpenGL API version <#choosing-version>`__.

   The OpenGL ES 3.0 API provides additional features and better performance
   than the 2.0 API and is also backward compatible. This means that you can
   potentially write your application targeting OpenGL ES 2.0 and conditionally
   include OpenGL ES 3.0 graphics features if they are available. For more
   information on checking for availability of the 3.0 API, see `Checking OpenGL ES version <#version-check>`__

   .. rubric:: Texture compression support
      :name: textures

   Texture compression can significantly increase the performance of your OpenGL
   application by reducing memory requirements and making more efficient use of
   memory bandwidth. The Android framework provides support for the ETC1
   compression format as a standard feature, including a
   `ETC1Util <#android.opengl.ETC1Util>`__ utility class and the
   ``etc1tool`` compression tool (located in the Android SDK at
   ``<sdk>/tools/``). For an example of an Android application that uses texture
   compression, see the ``CompressedTextureActivity`` code sample in Android SDK
   (``<sdk>/samples/<version>/ApiDemos/src/com/example/android/apis/graphics/``).

   The ETC1 format is supported by all Android devices that support OpenGL ES
   2.0 or higher.

   **Note:** The ETC1 texture compression format does not support textures with
   a transparency (alpha channel). If your application requires textures with
   transparency, you should investigate other texture compression formats
   available on your target devices. A method of rendering alpha channel
   textures using ETC1 is to bind two ETC1 texture objects: the first with color
   data, the second with alpha channel data and then combine the values from the
   two textures in the fragment shader.

   The ETC2/EAC texture compression formats are guaranteed to be available when
   using the OpenGL ES 3.0 API. This texture format offers excellent compression
   ratios with high visual quality and the format also supports transparency
   (alpha channel).

   Beyond the ETC formats, Android devices have varied support for texture
   compression based on their GPU chipsets and OpenGL implementations. You
   should investigate texture compression support on the devices you are are
   targeting to determine what compression types your application should
   support. In order to determine what texture formats are supported on a given
   device, you must `query the device <#gl-extension-query>`__ and review the
   *OpenGL extension names*, which identify what texture compression formats
   (and other OpenGL features) are supported by the device. Some commonly
   supported texture compression formats are as follows:

   -  **Adaptable Scalable Texture Compression (ASTC)** - A texture compression
      format designed to supersede prior formats. More flexible than previous
      formats due to support for various block sizes.

      -  ``GL_KHR_texture_compression_astc_ldr``
      -  ``GL_KHR_texture_compression_astc_hdr``\ (high dynamic range)

   -  **S3TC (DXT\ n/DXTC)** - S3 texture compression (S3TC) has several format
      variations (DXT1 to DXT5) and is less widely available. The format
      supports RGB textures with 4-bit alpha or 8-bit alpha channels. These
      formats are represented by the following OpenGL extension name:

      -  ``GL_EXT_texture_compression_s3tc``

      Some devices only support the DXT1 format variation; this limited support
      is represented by the following OpenGL extension name:

      -  ``GL_EXT_texture_compression_dxt1``

   The following texture compression formats are considered legacy formats and
   aren't recommended for use in new applications:

   -  **ATITC (ATC)** - ATI texture compression (ATITC or ATC) is available on a
      wide variety of devices and supports fixed rate compression for RGB
      textures with and without an alpha channel. This format may be represented
      by several OpenGL extension names, for example:

      -  ``GL_AMD_compressed_ATC_texture``
      -  ``GL_ATI_texture_compression_atitc``

   -  **PVRTC** - PowerVR texture compression (PVRTC) is available on a wide
      variety of devices and supports 2-bit and 4-bit per pixel textures with or
      without an alpha channel. This format is represented by the following
      OpenGL extension name:

      -  ``GL_IMG_texture_compression_pvrtc``

   -  **3DC** - 3DC texture compression (3DC) is a less widely available format
      that supports RGB textures with an alpha channel. This format is
      represented by the following OpenGL extension name:

      -  ``GL_AMD_compressed_3DC_texture``

   **Warning:** These texture compression formats are *not supported* on all
   devices. Support for these formats can vary by manufacturer and device. For
   information on how to determine what texture compression formats are on a
   particular device, see the next section.

   **Note:** Once you decide which texture compression formats your application
   will support, make sure you declare them in your manifest using
   `<supports-gl-texture> <#>`__
   . Using this declaration enables filtering by external services such as
   Google Play, so that your app is installed only on devices that support the
   formats your app requires. For details, see `OpenGL manifest declarations <#manifest>`__.

   .. rubric:: Determining OpenGL extensions
      :name: gl-extension-query

   Implementations of OpenGL vary by Android device in terms of the extensions
   to the OpenGL ES API that are supported. These extensions include texture
   compressions, but typically also include other extensions to the OpenGL
   feature set.

   To determine what texture compression formats, and other OpenGL extensions,
   are supported on a particular device:

   #. Run the following code on your target devices to determine what texture
      compression formats are supported:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  var extensions = gl.glGetString(GL10.GL_EXTENSIONS)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  String extensions = gl.glGetString(GL10.GL_EXTENSIONS);

      **Warning:** The results of this call *vary by device model!* You must run
      this call on several target devices to determine what compression types
      are commonly supported.

   #. Review the output of this method to determine what OpenGL extensions are
      supported on the device.

   .. rubric:: Android Extension Pack (AEP)
      :name: aep

   The AEP ensures that your application supports a standardized set of OpenGL
   extensions above and beyond the core set described in the OpenGL 3.1
   specification. Packaging these extensions together encourages a consistent
   set of functionality across devices, while allowing developers to take full
   advantage of the latest crop of mobile GPU devices.

   The AEP also improves support for images, shader storage buffers, and atomic
   counters in fragment shaders.

   For your app to be able to use the AEP, the app's manifest must declare that
   the AEP is required. In addition, the platform version must support it.

   All of the additional features specified in the AEP are included in the base
   OpenGL ES 3.2 specification. If your app requires OpenGL ES 3.2 you do not
   need to require the AEP.

   Declare the AEP requirement in the manifest as follows:

   .. code:: prettyprint

      <uses-feature android:name="android.hardware.opengles.aep"
                    android:required="true" />

   To verify that the platform version supports the AEP, use the
   `hasSystemFeature(String) <#android.content.pm.PackageManager>`__
   method, passing in
   `FEATURE_OPENGLES_EXTENSION_PACK <#android.content.pm.PackageManager>`__
   as the argument. The following code snippet shows an example of how to do so:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var deviceSupportsAEP: Boolean =
                       packageManager.hasSystemFeature(PackageManager.FEATURE_OPENGLES_EXTENSION_PACK)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               boolean deviceSupportsAEP = getPackageManager().hasSystemFeature
                    (PackageManager.FEATURE_OPENGLES_EXTENSION_PACK);

   If the method returns true, AEP is supported.

   For more information about the AEP, visit its page at the 
   `Khronos OpenGL ES Registry <https://www.khronos.org/registry/gles/extensions/ANDROID/ANDROID_extension_pack_es31a.txt>`__.

   .. rubric:: Checking the OpenGL ES version
      :name: version-check

   There are several versions of OpenGL ES available on Android devices. You can
   specify the minimum version of the API your application requires in your
   `manifest <#manifest>`__, but you may also want to take advantage of features
   in a newer API at the same time. For example, the OpenGL ES 3.0 API is
   backward-compatible with the 2.0 version of the API, so you may want to write
   your application so that it uses OpenGL ES 3.0 features, but falls back to
   the 2.0 API if the 3.0 API is not available.

   Before using OpenGL ES features from a version higher than the minimum
   required in your application manifest, your application should check the
   version of the API available on the device. You can do this in one of two
   ways:

   #. Attempt to create the higher-level OpenGL ES context
      (`EGLContext <#android.opengl.EGLContext>`__) and check the
      result.
   #. Create a minimum-supported OpenGL ES context and check the version value.

   The following example code demonstrates how to check the available OpenGL ES
   version by creating an
   `EGLContext <#android.opengl.EGLContext>`__ and checking the
   result. This example shows how to check for OpenGL ES 3.0 version:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val EGL_CONTEXT_CLIENT_VERSION = 0x3098
               private const val glVersion = 3.0
               private class ContextFactory : GLSurfaceView.EGLContextFactory {

                   override fun createContext(egl: EGL10, display: EGLDisplay, eglConfig: EGLConfig): EGLContext {

                       Log.w(TAG, "creating OpenGL ES $glVersion context")
                       return egl.eglCreateContext(
                               display,
                               eglConfig,
                               EGL10.EGL_NO_CONTEXT,
                               intArrayOf(EGL_CONTEXT_CLIENT_VERSION, glVersion.toInt(), EGL10.EGL_NONE)
                       ) // returns null if 3.0 is not supported
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static double glVersion = 3.0;

               private static class ContextFactory implements GLSurfaceView.EGLContextFactory {

                 private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;

                 public EGLContext createContext(
                         EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {

                     Log.w(TAG, "creating OpenGL ES " + glVersion + " context");
                     int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, (int) glVersion,
                             EGL10.EGL_NONE };
                     // attempt to create a OpenGL ES 3.0 context
                     EGLContext context = egl.eglCreateContext(
                             display, eglConfig, EGL10.EGL_NO_CONTEXT, attrib_list);
                     return context; // returns null if 3.0 is not supported;
                 }
               }

   If the ``createContext()`` method show above returns null, your code should
   create a OpenGL ES 2.0 context instead and fall back to using only that API.

   The following code example demonstrates how to check the OpenGL ES version by
   creating a minimum supported context first, and then checking the version
   string:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a minimum supported OpenGL ES context, then check:
               gl.glGetString(GL10.GL_VERSION).also {
                   Log.w(TAG, "Version: $it")
               }
                // The version format is displayed as: "OpenGL ES <major>.<minor>"
                // followed by optional content provided by the implementation.

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a minimum supported OpenGL ES context, then check:
               String version = gl.glGetString(GL10.GL_VERSION);
               Log.w(TAG, "Version: " + version );
               // The version format is displayed as: "OpenGL ES <major>.<minor>"
               // followed by optional content provided by the implementation.

   With this approach, if you discover that the device supports a higher-level
   API version, you must destroy the minimum OpenGL ES context and create a new
   context with the higher available API version.

   .. rubric:: Choosing an OpenGL API version
      :name: choosing-version

   OpenGL ES version 2.0, and version 3.0 both provide high performance graphics
   interfaces for creating 3D games, visualizations and user interfaces.
   Graphics progamming for OpenGL ES 2.0 and 3.0 is largely similar, with
   version 3.0 representing a superset of the 2.0 API with additional features.
   Programming for the OpenGL ES 1.0/1.1 API versus OpenGL ES 2.0 and 3.0
   differs significantly, and isn't recommended for new applications. Developers
   should carefully consider the following factors before starting development
   with these APIs:

   -  **Device Compatibility** - Developers should consider the types of
      devices, Android versions and the OpenGL ES versions available to their
      customers. For more information on OpenGL compatibility across devices,
      see the `OpenGL versions and device compatibility <#compatibility>`__
      section.
   -  **Texture Support** - The OpenGL ES 3.0 API has the best support for
      texture compression because it guarantees availability of the ETC2
      compression format, which supports transparency. The 2.0 API
      implementations include support for ETC1, however this texture format
      doesn't support transparency. To implement transparency with compressed
      textures you must either use two ETC1 textures (split between color and
      alpha) or provide resources in other compression formats supported by the
      devices you are targeting. For more information, see `Texture compression support <#textures>`__.

   While compatibility, and texture support may influence your decision, you
   should pick an OpenGL API version based on what you think provides the best
   experience for your users.


Last updated 2024-03-26 UTC.

.. |image-coordinates| image:: https://developer.android.google.cn/static/images/opengl/coordinates.png
.. |Coordinates at vertices of a triangle| image:: https://developer.android.google.cn/static/images/opengl/ccw-winding.png
   :width: 579px


/About Open GL
==============

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl?hl=en

.. container:: devsite-article-body

   The Android framework provides plenty of standard tools for creating
   attractive, functional graphical user interfaces. However, if you want more
   control of what your application draws on screen, or are venturing into three
   dimensional graphics, you need to use a different tool. The OpenGL ES APIs
   provided by the Android framework offers a set of tools for displaying
   high-end, animated graphics that are limited only by your imagination and can
   also benefit from the acceleration of graphics processing units (GPUs)
   provided on many Android devices.

   This class walks you through the basics of developing applications that use
   OpenGL, including setup, drawing objects, moving drawn elements and
   responding to touch input.

   The example code in this class uses the OpenGL ES 2.0 APIs, which is the
   recommended API version to use with current Android devices. For more
   information about versions of OpenGL ES, see the `OpenGL developer guide <#choosing-version>`__.

   **Note:** Be careful not to mix OpenGL ES 1.x API calls with OpenGL ES 2.0
   methods! The two APIs are not interchangeable and trying to use them together
   only results in frustration and sadness.

   .. rubric:: Lessons
      :name: lessons

   `Build an OpenGL ES environment <#>`__
      Learn how to set up an Android application to be able to draw OpenGL
      graphics.
   `Define shapes <#>`__
      Learn how to define shapes and why you need to know about faces and
      winding.
   `Draw shapes <#>`__
      Learn how to draw OpenGL shapes in your application.
   `Apply projection and camera views <#>`__
      Learn how to use projection and camera views to get a new perspective on
      your drawn objects.
   `Add motion <#>`__
      Learn how to do basic movement and animation of drawn objects with OpenGL.
   `Respond to touch events <#>`__
      Learn how to do basic interaction with OpenGL graphics.

   .. rubric:: Additional sample code
      :name: sample

   To download NDK samples, see `NDK Samples <https://github.com/googlesamples/android-ndk/>`__.


Last updated 2024-02-22 UTC.


/Build an Open GL ES environment
================================

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl/environment?hl=en

.. container:: devsite-article-body

   In order to draw graphics with OpenGL ES in your Android application, you
   must create a view container for them. One of the more straight-forward ways
   to do this is to implement both a
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ and a
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__.
   A `GLSurfaceView <#android.opengl.GLSurfaceView>`__ is a view
   container for graphics drawn with OpenGL and
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
   controls what is drawn within that view. For more information about these
   classes, see the `OpenGL ES <#>`__ developer guide.

   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ is just one
   way to incorporate OpenGL ES graphics into your application. For a
   full-screen or near-full screen graphics view, it is a reasonable choice.
   Developers who want to incorporate OpenGL ES graphics in a small portion of
   their layouts should take a look at
   `TextureView <#android.view.TextureView>`__. For real,
   do-it-yourself developers, it is also possible to build up an OpenGL ES view
   using `SurfaceView <#android.view.SurfaceView>`__, but this
   requires writing quite a bit of additional code.

   This lesson explains how to complete a minimal implementation of
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ and
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
   in a simple application activity.

   .. rubric:: Declare OpenGL ES use in the manifest
      :name: manifest

   In order for your application to use the OpenGL ES 2.0 API, you must add the
   following declaration to your manifest:

   .. code:: prettyprint

      <uses-feature android:glEsVersion="0x00020000" android:required="true" />

   If your application uses texture compression, you must also declare which
   compression formats your app supports, so that it is only installed on
   compatible devices.

   .. code:: prettyprint

      <supports-gl-texture android:name="GL_OES_compressed_ETC1_RGB8_texture" />
      <supports-gl-texture android:name="GL_OES_compressed_paletted_texture" />

   For more information about texture compression formats, see the
   `OpenGL <#textures>`__
   developer guide.

   .. rubric:: Create an activity for OpenGL ES graphics
      :name: activity

   Android applications that use OpenGL ES have activities just like any other
   application that has a user interface. The main difference from other
   applications is what you put in the layout for your activity. While in many
   applications you might use
   `TextView <#android.widget.TextView>`__,
   `Button <#android.widget.Button>`__ and
   `ListView <#android.widget.ListView>`__, in an app that uses
   OpenGL ES, you can also add a
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__.

   The following code example shows a minimal implementation of an activity that
   uses a `GLSurfaceView <#android.opengl.GLSurfaceView>`__ as its
   primary view:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class OpenGLES20Activity : Activity() {

                   private lateinit var gLView: GLSurfaceView

                   public override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)

                       // Create a GLSurfaceView instance and set it
                       // as the ContentView for this Activity.
                       gLView = MyGLSurfaceView(this)
                       setContentView(gLView)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class OpenGLES20Activity extends Activity {

                   private GLSurfaceView gLView;

                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       // Create a GLSurfaceView instance and set it
                       // as the ContentView for this Activity.
                       gLView = new MyGLSurfaceView(this);
                       setContentView(gLView);
                   }
               }

   **Note:** OpenGL ES 2.0 requires Android 2.2 (API Level 8) or higher, so make
   sure your Android project targets that API or higher.

   .. rubric:: Build a GLSurfaceView object
      :name: glsurfaceview

   A `GLSurfaceView <#android.opengl.GLSurfaceView>`__ is a
   specialized view where you can draw OpenGL ES graphics. It does not do much
   by itself. The actual drawing of objects is controlled in the
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
   that you set on this view. In fact, the code for this object is so thin, you
   may be tempted to skip extending it and just create an unmodified
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ instance, but
   don’t do that. You need to extend this class in order to capture touch
   events, which is covered in the `Respond to touch events <#touch.html>`__
   lesson.

   The essential code for a
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ is minimal,
   so for a quick implementation, it is common to just create an inner class in
   the activity that uses it:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import android.content.Context
               import android.opengl.GLSurfaceView

               class MyGLSurfaceView(context: Context) : GLSurfaceView(context) {

                   private val renderer: MyGLRenderer

                   init {

                       // Create an OpenGL ES 2.0 context
                       setEGLContextClientVersion(2)

                       renderer = MyGLRenderer()

                       // Set the Renderer for drawing on the GLSurfaceView
                       setRenderer(renderer)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import android.content.Context;
               import android.opengl.GLSurfaceView;

               class MyGLSurfaceView extends GLSurfaceView {

                   private final MyGLRenderer renderer;

                   public MyGLSurfaceView(Context context){
                       super(context);

                       // Create an OpenGL ES 2.0 context
                       setEGLContextClientVersion(2);

                       renderer = new MyGLRenderer();

                       // Set the Renderer for drawing on the GLSurfaceView
                       setRenderer(renderer);
                   }
               }

   One other optional addition to your
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__
   implementation is to set the render mode to only draw the view when there is
   a change to your drawing data using the
   `GLSurfaceView.RENDERMODE_WHEN_DIRTY <#android.opengl.GLSurfaceView>`__
   setting:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Render the view only when there is a change in the drawing data
               renderMode = GLSurfaceView.RENDERMODE_WHEN_DIRTY

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Render the view only when there is a change in the drawing data
               setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);

   This setting prevents the
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ frame from
   being redrawn until you call
   `requestRender() <#android.opengl.GLSurfaceView>`__,
   which is more efficient for this sample app.

   .. rubric:: Build a renderer class
      :name: renderer

   The implementation of the
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
   class, or renderer, within an application that uses OpenGL ES is where things
   start to get interesting. This class controls what gets drawn on the
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ with which it
   is associated. There are three methods in a renderer that are called by the
   Android system in order to figure out what and how to draw on a
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__:

   -  `onSurfaceCreated() <#android.opengl.GLSurfaceView.Renderer>`__
      - Called once to set up the view's OpenGL ES environment.
   -  `onDrawFrame() <#android.opengl.GLSurfaceView.Renderer>`__
      - Called for each redraw of the view.
   -  `onSurfaceChanged() <#android.opengl.GLSurfaceView.Renderer>`__
      - Called if the geometry of the view changes, for example when the
      device's screen orientation changes.

   Here is a very basic implementation of an OpenGL ES renderer, that does
   nothing more than draw a black background in the
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import javax.microedition.khronos.egl.EGLConfig
               import javax.microedition.khronos.opengles.GL10

               import android.opengl.GLES20
               import android.opengl.GLSurfaceView

               class MyGLRenderer : GLSurfaceView.Renderer {

                   override fun onSurfaceCreated(unused: GL10, config: EGLConfig) {
                       // Set the background frame color
                       GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
                   }

                   override fun onDrawFrame(unused: GL10) {
                       // Redraw background color
                       GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)
                   }

                   override fun onSurfaceChanged(unused: GL10, width: Int, height: Int) {
                       GLES20.glViewport(0, 0, width, height)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import javax.microedition.khronos.egl.EGLConfig;
               import javax.microedition.khronos.opengles.GL10;

               import android.opengl.GLES20;
               import android.opengl.GLSurfaceView;

               public class MyGLRenderer implements GLSurfaceView.Renderer {

                   public void onSurfaceCreated(GL10 unused, EGLConfig config) {
                       // Set the background frame color
                       GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
                   }

                   public void onDrawFrame(GL10 unused) {
                       // Redraw background color
                       GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
                   }

                   public void onSurfaceChanged(GL10 unused, int width, int height) {
                       GLES20.glViewport(0, 0, width, height);
                   }
               }

   That’s all there is to it! The code examples above create a simple Android
   application that displays a black screen using OpenGL. While this code does
   not do anything very interesting, by creating these classes, you have laid
   the foundation you need to start drawing graphic elements with OpenGL.

   **Note:** You may wonder why these methods have a
   `GL10 <#>`__ parameter,
   when you are using the OpengGL ES 2.0 APIs. These method signatures are
   simply reused for the 2.0 APIs to keep the Android framework code simpler.

   If you are familiar with the OpenGL ES APIs, you should now be able to set up
   a OpenGL ES environment in your app and start drawing graphics. However, if
   you need a bit more help getting started with OpenGL, head on to the next
   lessons for a few more hints.


Last updated 2024-02-22 UTC.


/Define shapes
==============

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl/shapes?hl=en

.. container:: devsite-article-body

   Being able to define shapes to be drawn in the context of an OpenGL ES view
   is the first step in creating high-end graphics for your app. Drawing with
   OpenGL ES can be a little tricky without knowing a few basic things about how
   OpenGL ES expects you to define graphic objects.

   This lesson explains the OpenGL ES coordinate system relative to an Android
   device screen, the basics of defining a shape, shape faces, as well as
   defining a triangle and a square.

   .. rubric:: Define a triangle
      :name: triangle

   OpenGL ES allows you to define drawn objects using coordinates in
   three-dimensional space. So, before you can draw a triangle, you must define
   its coordinates. In OpenGL, the typical way to do this is to define a vertex
   array of floating point numbers for the coordinates. For maximum efficiency,
   you write these coordinates into a
   `ByteBuffer <#>`__, that is passed into the
   OpenGL ES graphics pipeline for processing.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // number of coordinates per vertex in this array
               const val COORDS_PER_VERTEX = 3
               var triangleCoords = floatArrayOf(     // in counterclockwise order:
                       0.0f, 0.622008459f, 0.0f,      // top
                       -0.5f, -0.311004243f, 0.0f,    // bottom left
                       0.5f, -0.311004243f, 0.0f      // bottom right
               )

               class Triangle {

                   // Set color with red, green, blue and alpha (opacity) values
                   val color = floatArrayOf(0.63671875f, 0.76953125f, 0.22265625f, 1.0f)

                   private var vertexBuffer: FloatBuffer =
                           // (number of coordinate values * 4 bytes per float)
                           ByteBuffer.allocateDirect(triangleCoords.size * 4).run {
                               // use the device hardware's native byte order
                               order(ByteOrder.nativeOrder())

                               // create a floating point buffer from the ByteBuffer
                               asFloatBuffer().apply {
                                   // add the coordinates to the FloatBuffer
                                   put(triangleCoords)
                                   // set the buffer to read the first coordinate
                                   position(0)
                               }
                           }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Triangle {

                   private FloatBuffer vertexBuffer;

                   // number of coordinates per vertex in this array
                   static final int COORDS_PER_VERTEX = 3;
                   static float triangleCoords[] = {   // in counterclockwise order:
                            0.0f,  0.622008459f, 0.0f, // top
                           -0.5f, -0.311004243f, 0.0f, // bottom left
                            0.5f, -0.311004243f, 0.0f  // bottom right
                   };

                   // Set color with red, green, blue and alpha (opacity) values
                   float color[] = { 0.63671875f, 0.76953125f, 0.22265625f, 1.0f };

                   public Triangle() {
                       // initialize vertex byte buffer for shape coordinates
                       ByteBuffer bb = ByteBuffer.allocateDirect(
                               // (number of coordinate values * 4 bytes per float)
                               triangleCoords.length * 4);
                       // use the device hardware's native byte order
                       bb.order(ByteOrder.nativeOrder());

                       // create a floating point buffer from the ByteBuffer
                       vertexBuffer = bb.asFloatBuffer();
                       // add the coordinates to the FloatBuffer
                       vertexBuffer.put(triangleCoords);
                       // set the buffer to read the first coordinate
                       vertexBuffer.position(0);
                   }
               }

   By default, OpenGL ES assumes a coordinate system where [0,0,0] (X,Y,Z)
   specifies the center of the
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ frame,
   [1,1,0] is the top right corner of the frame and [-1,-1,0] is bottom left
   corner of the frame. For an illustration of this coordinate system, see the
   `OpenGL ES developer guide <#coordinate-mapping>`__.

   Note that the coordinates of this shape are defined in a counterclockwise
   order. The drawing order is important because it defines which side is the
   front face of the shape, which you typically want to have drawn, and the back
   face, which you can choose to not draw using the OpenGL ES cull face feature.
   For more information about faces and culling, see the `OpenGL ES <#faces-winding>`__
   developer guide.

   .. rubric:: Define a square
      :name: square

   Defining triangles is pretty easy in OpenGL, but what if you want to get a
   just a little more complex? Say, a square? There are a number of ways to do
   this, but a typical path to drawing such a shape in OpenGL ES is to use two
   triangles drawn together:

   |image-ccw-square|
   **Figure 1.** Drawing a square using two triangles.

   Again, you should define the vertices in a counterclockwise order for both
   triangles that represent this shape, and put the values in a
   `ByteBuffer <#>`__. In order to avoid
   defining the two coordinates shared by each triangle twice, use a drawing
   list to tell the OpenGL ES graphics pipeline how to draw these vertices.
   Here’s the code for this shape:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // number of coordinates per vertex in this array
               const val COORDS_PER_VERTEX = 3
               var squareCoords = floatArrayOf(
                       -0.5f,  0.5f, 0.0f,      // top left
                       -0.5f, -0.5f, 0.0f,      // bottom left
                        0.5f, -0.5f, 0.0f,      // bottom right
                        0.5f,  0.5f, 0.0f       // top right
               )

               class Square2 {

                   private val drawOrder = shortArrayOf(0, 1, 2, 0, 2, 3) // order to draw vertices

                   // initialize vertex byte buffer for shape coordinates
                   private val vertexBuffer: FloatBuffer =
                           // (# of coordinate values * 4 bytes per float)
                           ByteBuffer.allocateDirect(squareCoords.size * 4).run {
                               order(ByteOrder.nativeOrder())
                               asFloatBuffer().apply {
                                   put(squareCoords)
                                   position(0)
                               }
                           }

                   // initialize byte buffer for the draw list
                   private val drawListBuffer: ShortBuffer =
                           // (# of coordinate values * 2 bytes per short)
                           ByteBuffer.allocateDirect(drawOrder.size * 2).run {
                               order(ByteOrder.nativeOrder())
                               asShortBuffer().apply {
                                   put(drawOrder)
                                   position(0)
                               }
                           }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Square {

                   private FloatBuffer vertexBuffer;
                   private ShortBuffer drawListBuffer;

                   // number of coordinates per vertex in this array
                   static final int COORDS_PER_VERTEX = 3;
                   static float squareCoords[] = {
                           -0.5f,  0.5f, 0.0f,   // top left
                           -0.5f, -0.5f, 0.0f,   // bottom left
                            0.5f, -0.5f, 0.0f,   // bottom right
                            0.5f,  0.5f, 0.0f }; // top right

                   private short drawOrder[] = { 0, 1, 2, 0, 2, 3 }; // order to draw vertices

                   public Square() {
                       // initialize vertex byte buffer for shape coordinates
                       ByteBuffer bb = ByteBuffer.allocateDirect(
                       // (# of coordinate values * 4 bytes per float)
                               squareCoords.length * 4);
                       bb.order(ByteOrder.nativeOrder());
                       vertexBuffer = bb.asFloatBuffer();
                       vertexBuffer.put(squareCoords);
                       vertexBuffer.position(0);

                       // initialize byte buffer for the draw list
                       ByteBuffer dlb = ByteBuffer.allocateDirect(
                       // (# of coordinate values * 2 bytes per short)
                               drawOrder.length * 2);
                       dlb.order(ByteOrder.nativeOrder());
                       drawListBuffer = dlb.asShortBuffer();
                       drawListBuffer.put(drawOrder);
                       drawListBuffer.position(0);
                   }
               }

   This example gives you a peek at what it takes to create more complex shapes
   with OpenGL. In general, you use collections of triangles to draw objects. In
   the next lesson, you learn how to draw these shapes on screen.


Last updated 2024-02-22 UTC.

.. |image-ccw-square| image:: https://developer.android.google.cn/static/images/opengl/ccw-square.png


/Draw shapes
============

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl/draw?hl=en

.. container:: devsite-article-body

   After you define shapes to be drawn with OpenGL, you probably want to draw
   them. Drawing shapes with the OpenGL ES 2.0 takes a bit more code than you
   might imagine, because the API provides a great deal of control over the
   graphics rendering pipeline.

   This lesson explains how to draw the shapes you defined in the previous
   lesson using the OpenGL ES 2.0 API.

   .. rubric:: Initialize shapes
      :name: initialize

   Before you do any drawing, you must initialize and load the shapes you plan
   to draw. Unless the structure (the original coordinates) of the shapes you
   use in your program change during the course of execution, you should
   initialize them in the
   `onSurfaceCreated() <#android.opengl.GLSurfaceView.Renderer>`__
   method of your renderer for memory and processing efficiency.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyGLRenderer : GLSurfaceView.Renderer {
                   ...
                   private lateinit var mTriangle: Triangle
                   private lateinit var mSquare: Square

                   override fun onSurfaceCreated(unused: GL10, config: EGLConfig) {
                       ...
                       // initialize a triangle
                       mTriangle = Triangle()
                       // initialize a square
                       mSquare = Square()
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyGLRenderer implements GLSurfaceView.Renderer {

                   ...
                   private Triangle mTriangle;
                   private Square   mSquare;

                   public void onSurfaceCreated(GL10 unused, EGLConfig config) {
                       ...
                       // initialize a triangle
                       mTriangle = new Triangle();
                       // initialize a square
                       mSquare = new Square();
                   }
                   ...
               }

   .. rubric:: Draw a shape
      :name: draw

   Drawing a defined shape using OpenGL ES 2.0 requires a significant amount of
   code, because you must provide a lot of details to the graphics rendering
   pipeline. Specifically, you must define the following:

   -  *Vertex Shader* - OpenGL ES graphics code for rendering the vertices of a
      shape.
   -  *Fragment Shader* - OpenGL ES code for rendering the face of a shape with
      colors or textures.
   -  *Program* - An OpenGL ES object that contains the shaders you want to use
      for drawing one or more shapes.

   You need at least one vertex shader to draw a shape and one fragment shader
   to color that shape. These shaders must be compiled and then added to an
   OpenGL ES program, which is then used to draw the shape. Here is an example
   of how to define basic shaders you can use to draw a shape in the
   ``Triangle`` class:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Triangle {

                   private val vertexShaderCode =
                           "attribute vec4 vPosition;" +
                           "void main() {" +
                           "  gl_Position = vPosition;" +
                           "}"

                   private val fragmentShaderCode =
                           "precision mediump float;" +
                           "uniform vec4 vColor;" +
                           "void main() {" +
                           "  gl_FragColor = vColor;" +
                           "}"

                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Triangle {

                   private final String vertexShaderCode =
                       "attribute vec4 vPosition;" +
                       "void main() {" +
                       "  gl_Position = vPosition;" +
                       "}";

                   private final String fragmentShaderCode =
                       "precision mediump float;" +
                       "uniform vec4 vColor;" +
                       "void main() {" +
                       "  gl_FragColor = vColor;" +
                       "}";

                   ...
               }

   Shaders contain OpenGL Shading Language (GLSL) code that must be compiled
   prior to using it in the OpenGL ES environment. To compile this code, create
   a utility method in your renderer class:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun loadShader(type: Int, shaderCode: String): Int {

                   // create a vertex shader type (GLES20.GL_VERTEX_SHADER)
                   // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER)
                   return GLES20.glCreateShader(type).also { shader ->

                       // add the source code to the shader and compile it
                       GLES20.glShaderSource(shader, shaderCode)
                       GLES20.glCompileShader(shader)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public static int loadShader(int type, String shaderCode){

                   // create a vertex shader type (GLES20.GL_VERTEX_SHADER)
                   // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER)
                   int shader = GLES20.glCreateShader(type);

                   // add the source code to the shader and compile it
                   GLES20.glShaderSource(shader, shaderCode);
                   GLES20.glCompileShader(shader);

                   return shader;
               }

   In order to draw your shape, you must compile the shader code, add them to a
   OpenGL ES program object and then link the program. Do this in your drawn
   object’s constructor, so it is only done once.

   **Note:** Compiling OpenGL ES shaders and linking programs is expensive in
   terms of CPU cycles and processing time, so you should avoid doing this more
   than once. If you do not know the content of your shaders at runtime, you
   should build your code such that they only get created once and then cached
   for later use.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Triangle {
                   ...

                   private var mProgram: Int

                   init {
                       ...

                       val vertexShader: Int = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode)
                       val fragmentShader: Int = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode)

                       // create empty OpenGL ES Program
                       mProgram = GLES20.glCreateProgram().also {

                           // add the vertex shader to program
                           GLES20.glAttachShader(it, vertexShader)

                           // add the fragment shader to program
                           GLES20.glAttachShader(it, fragmentShader)

                           // creates OpenGL ES program executables
                           GLES20.glLinkProgram(it)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Triangle() {
                   ...

                   private final int mProgram;

                   public Triangle() {
                       ...

                       int vertexShader = MyGLRenderer.loadShader(GLES20.GL_VERTEX_SHADER,
                                                       vertexShaderCode);
                       int fragmentShader = MyGLRenderer.loadShader(GLES20.GL_FRAGMENT_SHADER,
                                                       fragmentShaderCode);

                       // create empty OpenGL ES Program
                       mProgram = GLES20.glCreateProgram();

                       // add the vertex shader to program
                       GLES20.glAttachShader(mProgram, vertexShader);

                       // add the fragment shader to program
                       GLES20.glAttachShader(mProgram, fragmentShader);

                       // creates OpenGL ES program executables
                       GLES20.glLinkProgram(mProgram);
                   }
               }

   At this point, you are ready to add the actual calls that draw your shape.
   Drawing shapes with OpenGL ES requires that you specify several parameters to
   tell the rendering pipeline what you want to draw and how to draw it. Since
   drawing options can vary by shape, it's a good idea to have your shape
   classes contain their own drawing logic.

   Create a ``draw()`` method for drawing the shape. This code sets the position
   and color values to the shape’s vertex shader and fragment shader, and then
   executes the drawing function.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private var positionHandle: Int = 0
               private var mColorHandle: Int = 0

               private val vertexCount: Int = triangleCoords.size / COORDS_PER_VERTEX
               private val vertexStride: Int = COORDS_PER_VERTEX * 4 // 4 bytes per vertex

               fun draw() {
                   // Add program to OpenGL ES environment
                   GLES20.glUseProgram(mProgram)

                   // get handle to vertex shader's vPosition member
                   positionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition").also {

                       // Enable a handle to the triangle vertices
                       GLES20.glEnableVertexAttribArray(it)

                       // Prepare the triangle coordinate data
                       GLES20.glVertexAttribPointer(
                               it,
                               COORDS_PER_VERTEX,
                               GLES20.GL_FLOAT,
                               false,
                               vertexStride,
                               vertexBuffer
                       )

                       // get handle to fragment shader's vColor member
                       mColorHandle = GLES20.glGetUniformLocation(mProgram, "vColor").also { colorHandle ->

                           // Set color for drawing the triangle
                           GLES20.glUniform4fv(colorHandle, 1, color, 0)
                       }

                       // Draw the triangle
                       GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount)

                       // Disable vertex array
                       GLES20.glDisableVertexAttribArray(it)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private int positionHandle;
               private int colorHandle;

               private final int vertexCount = triangleCoords.length / COORDS_PER_VERTEX;
               private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex

               public void draw() {
                   // Add program to OpenGL ES environment
                   GLES20.glUseProgram(mProgram);

                   // get handle to vertex shader's vPosition member
                   positionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition");

                   // Enable a handle to the triangle vertices
                   GLES20.glEnableVertexAttribArray(positionHandle);

                   // Prepare the triangle coordinate data
                   GLES20.glVertexAttribPointer(positionHandle, COORDS_PER_VERTEX,
                                                GLES20.GL_FLOAT, false,
                                                vertexStride, vertexBuffer);

                   // get handle to fragment shader's vColor member
                   colorHandle = GLES20.glGetUniformLocation(mProgram, "vColor");

                   // Set color for drawing the triangle
                   GLES20.glUniform4fv(colorHandle, 1, color, 0);

                   // Draw the triangle
                   GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);

                   // Disable vertex array
                   GLES20.glDisableVertexAttribArray(positionHandle);
               }

   Once you have all this code in place, drawing this object just requires a
   call to the ``draw()`` method from within your renderer’s
   `onDrawFrame() <#android.opengl.GLSurfaceView.Renderer>`__
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onDrawFrame(unused: GL10) {
                   ...

                   mTriangle.draw()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void onDrawFrame(GL10 unused) {
                   ...

                   mTriangle.draw();
               }

   When you run the application, it should look something like this:

   |image-ogl-triangle|
   **Figure 1.** Triangle drawn without a projection or camera view.

   There are a few problems with this code example. First of all, it is not
   going to impress your friends. Secondly, the triangle is a bit squashed and
   changes shape when you change the screen orientation of the device. The
   reason the shape is skewed is due to the fact that the object’s vertices have
   not been corrected for the proportions of the screen area where the
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ is displayed.
   You can fix that problem using a projection and camera view in the next
   lesson.

   Lastly, the triangle is stationary, which is a bit boring. In the `Add motion <#>`__ lesson, you make this shape
   rotate and make more interesting use of the OpenGL ES graphics pipeline.


Last updated 2024-02-22 UTC.

.. |image-ogl-triangle| image:: https://developer.android.google.cn/static/images/opengl/ogl-triangle.png


/Apply projection and camera views
==================================

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl/projection?hl=en

.. container:: devsite-article-body

   In the OpenGL ES environment, projection and camera views allow you to
   display drawn objects in a way that more closely resembles how you see
   physical objects with your eyes. This simulation of physical viewing is done
   with mathematical transformations of drawn object coordinates:

   -  *Projection* - This transformation adjusts the coordinates of drawn
      objects based on the width and height of the
      `GLSurfaceView <#android.opengl.GLSurfaceView>`__ where they
      are displayed. Without this calculation, objects drawn by OpenGL ES are
      skewed by the unequal proportions of the view window. A projection
      transformation typically only has to be calculated when the proportions of
      the OpenGL view are established or changed in the
      `onSurfaceChanged() <#android.opengl.GLSurfaceView.Renderer>`__
      method of your renderer. For more information about OpenGL ES projections
      and coordinate mapping, see `Mapping coordinates for drawn objects <#coordinate-mapping>`__.
   -  *Camera View* - This transformation adjusts the coordinates of drawn
      objects based on a virtual camera position. It’s important to note that
      OpenGL ES does not define an actual camera object, but instead provides
      utility methods that simulate a camera by transforming the display of
      drawn objects. A camera view transformation might be calculated only once
      when you establish your
      `GLSurfaceView <#android.opengl.GLSurfaceView>`__, or might
      change dynamically based on user actions or your application’s function.

   This lesson describes how to create a projection and camera view and apply it
   to shapes drawn in your
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__.

   .. rubric:: Define a projection
      :name: projection

   The data for a projection transformation is calculated in the
   `onSurfaceChanged() <#android.opengl.GLSurfaceView.Renderer>`__
   method of your
   `GLSurfaceView.Renderer <#android.opengl.GLSurfaceView.Renderer>`__
   class. The following example code takes the height and width of the
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ and uses it
   to populate a projection transformation
   `Matrix <#android.opengl.Matrix>`__ using the
   `Matrix.frustumM() <#android.opengl.Matrix>`__
   method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // vPMatrix is an abbreviation for "Model View Projection Matrix"
               private val vPMatrix = FloatArray(16)
               private val projectionMatrix = FloatArray(16)
               private val viewMatrix = FloatArray(16)

               override fun onSurfaceChanged(unused: GL10, width: Int, height: Int) {
                   GLES20.glViewport(0, 0, width, height)

                   val ratio: Float = width.toFloat() / height.toFloat()

                   // this projection matrix is applied to object coordinates
                   // in the onDrawFrame() method
                   Matrix.frustumM(projectionMatrix, 0, -ratio, ratio, -1f, 1f, 3f, 7f)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // vPMatrix is an abbreviation for "Model View Projection Matrix"
               private final float[] vPMatrix = new float[16];
               private final float[] projectionMatrix = new float[16];
               private final float[] viewMatrix = new float[16];

               @Override
               public void onSurfaceChanged(GL10 unused, int width, int height) {
                   GLES20.glViewport(0, 0, width, height);

                   float ratio = (float) width / height;

                   // this projection matrix is applied to object coordinates
                   // in the onDrawFrame() method
                   Matrix.frustumM(projectionMatrix, 0, -ratio, ratio, -1, 1, 3, 7);
               }

   This code populates a projection matrix, ``mProjectionMatrix`` which you can
   then combine with a camera view transformation in the
   `onDrawFrame() <#android.opengl.GLSurfaceView.Renderer>`__
   method, which is shown in the next section.

   **Note:** Just applying a projection transformation to your drawing objects
   typically results in a very empty display. In general, you must also apply a
   camera view transformation in order for anything to show up on screen.

   .. rubric:: Define a camera view
      :name: camera-view

   Complete the process of transforming your drawn objects by adding a camera
   view transformation as part of the drawing process in your renderer. In the
   following example code, the camera view transformation is calculated using
   the
   `Matrix.setLookAtM() <#android.opengl.Matrix>`__
   method and then combined with the previously calculated projection matrix.
   The combined transformation matrices are then passed to the drawn shape.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onDrawFrame(unused: GL10) {
                   ...
                   // Set the camera position (View matrix)
                   Matrix.setLookAtM(viewMatrix, 0, 0f, 0f, 3f, 0f, 0f, 0f, 0f, 1.0f, 0.0f)

                   // Calculate the projection and view transformation
                   Matrix.multiplyMM(vPMatrix, 0, projectionMatrix, 0, viewMatrix, 0)

                   // Draw shape
                   triangle.draw(vPMatrix)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onDrawFrame(GL10 unused) {
                   ...
                   // Set the camera position (View matrix)
                   Matrix.setLookAtM(viewMatrix, 0, 0, 0, 3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);

                   // Calculate the projection and view transformation
                   Matrix.multiplyMM(vPMatrix, 0, projectionMatrix, 0, viewMatrix, 0);

                   // Draw shape
                   triangle.draw(vPMatrix);
               }

   .. rubric:: Apply projection and camera transformations
      :name: #transform

   In order to use the combined projection and camera view transformation matrix
   shown in the previews sections, first add a matrix variable to the *vertex
   shader* previously defined in the ``Triangle`` class:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class Triangle {

                   private val vertexShaderCode =
                           // This matrix member variable provides a hook to manipulate
                           // the coordinates of the objects that use this vertex shader
                           "uniform mat4 uMVPMatrix;" +
                           "attribute vec4 vPosition;" +
                           "void main() {" +
                           // the matrix must be included as a modifier of gl_Position
                           // Note that the uMVPMatrix factor *must be first* in order
                           // for the matrix multiplication product to be correct.
                           "  gl_Position = uMVPMatrix * vPosition;" +
                           "}"

                   // Use to access and set the view transformation
                   private var vPMatrixHandle: Int = 0

                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class Triangle {

                   private final String vertexShaderCode =
                       // This matrix member variable provides a hook to manipulate
                       // the coordinates of the objects that use this vertex shader
                       "uniform mat4 uMVPMatrix;" +
                       "attribute vec4 vPosition;" +
                       "void main() {" +
                       // the matrix must be included as a modifier of gl_Position
                       // Note that the uMVPMatrix factor *must be first* in order
                       // for the matrix multiplication product to be correct.
                       "  gl_Position = uMVPMatrix * vPosition;" +
                       "}";

                   // Use to access and set the view transformation
                   private int vPMatrixHandle;

                   ...
               }

   Next, modify the ``draw()`` method of your graphic objects to accept the
   combined transformation matrix and apply it to the shape:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun draw(mvpMatrix: FloatArray) { // pass in the calculated transformation matrix

                   // get handle to shape's transformation matrix
                   vPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix")

                   // Pass the projection and view transformation to the shader
                   GLES20.glUniformMatrix4fv(vPMatrixHandle, 1, false, mvpMatrix, 0)

                   // Draw the triangle
                   GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount)

                   // Disable vertex array
                   GLES20.glDisableVertexAttribArray(positionHandle)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void draw(float[] mvpMatrix) { // pass in the calculated transformation matrix
                   ...

                   // get handle to shape's transformation matrix
                   vPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix");

                   // Pass the projection and view transformation to the shader
                   GLES20.glUniformMatrix4fv(vPMatrixHandle, 1, false, mvpMatrix, 0);

                   // Draw the triangle
                   GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);

                   // Disable vertex array
                   GLES20.glDisableVertexAttribArray(positionHandle);
               }

   Once you have correctly calculated and applied the projection and camera view
   transformations, your graphic objects are drawn in correct proportions and
   should look like this:

   |image-ogl-triangle-projected|
   **Figure 1.** Triangle drawn with a projection and camera view applied.

   Now that you have an application that displays your shapes in correct
   proportions, it's time to add motion to your shapes.


Last updated 2024-02-22 UTC.

.. |image-ogl-triangle-projected| image:: https://developer.android.google.cn/static/images/opengl/ogl-triangle-projected.png


/Add motion
===========

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl/motion?hl=en

.. container:: devsite-article-body

   Drawing objects on screen is a pretty basic feature of OpenGL, but you can do
   this with other Android graphics framework classes, including
   `Canvas <#android.graphics.Canvas>`__ and
   `Drawable <#android.graphics.drawable.Drawable>`__ objects.
   OpenGL ES provides additional capabilities for moving and transforming drawn
   objects in three dimensions or in other unique ways to create compelling user
   experiences.

   In this lesson, you take another step forward into using OpenGL ES by
   learning how to add motion to a shape with rotation.

   .. rubric:: Rotate a shape
      :name: rotate

   Rotating a drawing object with OpenGL ES 2.0 is relatively simple. In your
   renderer, create another transformation matrix (a rotation matrix) and then
   combine it with your projection and camera view transformation matrices:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val rotationMatrix = FloatArray(16)

               override fun onDrawFrame(gl: GL10) {
                   val scratch = FloatArray(16)

                   ...

                   // Create a rotation transformation for the triangle
                   val time = SystemClock.uptimeMillis() % 4000L
                   val angle = 0.090f * time.toInt()
                   Matrix.setRotateM(rotationMatrix, 0, angle, 0f, 0f, -1.0f)

                   // Combine the rotation matrix with the projection and camera view
                   // Note that the vPMatrix factor *must be first* in order
                   // for the matrix multiplication product to be correct.
                   Matrix.multiplyMM(scratch, 0, vPMatrix, 0, rotationMatrix, 0)

                   // Draw triangle
                   mTriangle.draw(scratch)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private float[] rotationMatrix = new float[16];
               @Override
               public void onDrawFrame(GL10 gl) {
                   float[] scratch = new float[16];

                   ...

                   // Create a rotation transformation for the triangle
                   long time = SystemClock.uptimeMillis() % 4000L;
                   float angle = 0.090f * ((int) time);
                   Matrix.setRotateM(rotationMatrix, 0, angle, 0, 0, -1.0f);

                   // Combine the rotation matrix with the projection and camera view
                   // Note that the vPMatrix factor *must be first* in order
                   // for the matrix multiplication product to be correct.
                   Matrix.multiplyMM(scratch, 0, vPMatrix, 0, rotationMatrix, 0);

                   // Draw triangle
                   mTriangle.draw(scratch);
               }

   If your triangle does not rotate after making these changes, make sure you
   have commented out the
   `GLSurfaceView.RENDERMODE_WHEN_DIRTY <#android.opengl.GLSurfaceView>`__
   setting, as described in the next section.

   .. rubric:: Enable continuous rendering
      :name: cont-render

   If you have diligently followed along with the example code in this class to
   this point, make sure you comment out the line that sets the render mode only
   draw when dirty, otherwise OpenGL rotates the shape only one increment and
   then waits for a call to
   `requestRender() <#android.opengl.GLSurfaceView>`__
   from the `GLSurfaceView <#android.opengl.GLSurfaceView>`__
   container:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyGLSurfaceView(context: Context) : GLSurfaceView(context) {

                   init {
                       ...
                       // Render the view only when there is a change in the drawing data.
                       // To allow the triangle to rotate automatically, this line is commented out:
                       // renderMode = GLSurfaceView.RENDERMODE_WHEN_DIRTY
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyGLSurfaceView(Context context) extends GLSurfaceView {
                   ...
                   // Render the view only when there is a change in the drawing data.
                   // To allow the triangle to rotate automatically, this line is commented out:
                   //setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
               }

   Unless you have objects changing without any user interaction, it’s usually a
   good idea have this flag turned on. Be ready to uncomment this code, because
   the next lesson makes this call applicable once again.


Last updated 2024-02-22 UTC.


/Respond to touch events
========================

.. https://developer.android.google.cn/develop/ui/views/graphics/opengl/touch?hl=en

.. container:: devsite-article-body

   Making objects move according to a preset program like the rotating triangle
   is useful for getting some attention, but what if you want to have users
   interact with your OpenGL ES graphics? The key to making your OpenGL ES
   application touch interactive is expanding your implementation of
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ to override
   the
   `onTouchEvent() <#android.view.View>`__
   to listen for touch events.

   This lesson shows you how to listen for touch events to let users rotate an
   OpenGL ES object.

   .. rubric:: Setup a touch listener
      :name: listener

   In order to make your OpenGL ES application respond to touch events, you must
   implement the
   `onTouchEvent() <#android.view.View>`__
   method in your
   `GLSurfaceView <#android.opengl.GLSurfaceView>`__ class. The
   example implementation below shows how to listen for
   `MotionEvent.ACTION_MOVE <#android.view.MotionEvent>`__
   events and translate them to an angle of rotation for a shape.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val TOUCH_SCALE_FACTOR: Float = 180.0f / 320f
               ...
               private var previousX: Float = 0f
               private var previousY: Float = 0f

               override fun onTouchEvent(e: MotionEvent): Boolean {
                   // MotionEvent reports input details from the touch screen
                   // and other input controls. In this case, you are only
                   // interested in events where the touch position changed.

                   val x: Float = e.x
                   val y: Float = e.y

                   when (e.action) {
                       MotionEvent.ACTION_MOVE -> {

                           var dx: Float = x - previousX
                           var dy: Float = y - previousY

                           // reverse direction of rotation above the mid-line
                           if (y > height / 2) {
                               dx *= -1
                           }

                           // reverse direction of rotation to left of the mid-line
                           if (x < width / 2) {
                               dy *= -1
                           }

                           renderer.angle += (dx + dy) * TOUCH_SCALE_FACTOR
                           requestRender()
                       }
                   }

                   previousX = x
                   previousY = y
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private final float TOUCH_SCALE_FACTOR = 180.0f / 320;
               private float previousX;
               private float previousY;

               @Override
               public boolean onTouchEvent(MotionEvent e) {
                   // MotionEvent reports input details from the touch screen
                   // and other input controls. In this case, you are only
                   // interested in events where the touch position changed.

                   float x = e.getX();
                   float y = e.getY();

                   switch (e.getAction()) {
                       case MotionEvent.ACTION_MOVE:

                           float dx = x - previousX;
                           float dy = y - previousY;

                           // reverse direction of rotation above the mid-line
                           if (y > getHeight() / 2) {
                             dx = dx * -1 ;
                           }

                           // reverse direction of rotation to left of the mid-line
                           if (x < getWidth() / 2) {
                             dy = dy * -1 ;
                           }

                           renderer.setAngle(
                                   renderer.getAngle() +
                                   ((dx + dy) * TOUCH_SCALE_FACTOR));
                           requestRender();
                   }

                   previousX = x;
                   previousY = y;
                   return true;
               }

   Notice that after calculating the rotation angle, this method calls
   `requestRender() <#android.opengl.GLSurfaceView>`__
   to tell the renderer that it is time to render the frame. This approach is
   the most efficient in this example because the frame does not need to be
   redrawn unless there is a change in the rotation. However, it does not have
   any impact on efficiency unless you also request that the renderer only
   redraw when the data changes using the
   `setRenderMode() <#android.opengl.GLSurfaceView>`__
   method, so make sure this line is uncommented in the renderer:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyGlSurfaceView(context: Context) : GLSurfaceView(context) {

                   init {
                       // Render the view only when there is a change in the drawing data
                       renderMode = GLSurfaceView.RENDERMODE_WHEN_DIRTY
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public MyGLSurfaceView(Context context) {
                   ...
                   // Render the view only when there is a change in the drawing data
                   setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
               }

   .. rubric:: Expose the rotation angle
      :name: angle

   The example code above requires that you expose the rotation angle through
   your renderer by adding a public member. Since the renderer code is running
   on a separate thread from the main user interface thread of your application,
   you must declare this public variable as ``volatile``. Here is the code to
   declare the variable and expose the getter and setter pair:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyGLRenderer4 : GLSurfaceView.Renderer {

                   @Volatile
                   var angle: Float = 0f
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyGLRenderer implements GLSurfaceView.Renderer {
                   ...

                   public volatile float mAngle;

                   public float getAngle() {
                       return mAngle;
                   }

                   public void setAngle(float angle) {
                       mAngle = angle;
                   }
               }

   .. rubric:: Apply rotation
      :name: rotate

   To apply the rotation generated by touch input, comment out the code that
   generates an angle and add a variable that contains the touch input generated
   angle:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onDrawFrame(gl: GL10) {
                   ...
                   val scratch = FloatArray(16)

                   // Create a rotation for the triangle
                   // long time = SystemClock.uptimeMillis() % 4000L;
                   // float angle = 0.090f * ((int) time);
                   Matrix.setRotateM(rotationMatrix, 0, angle, 0f, 0f, -1.0f)

                   // Combine the rotation matrix with the projection and camera view
                   // Note that the mvpMatrix factor *must be first* in order
                   // for the matrix multiplication product to be correct.
                   Matrix.multiplyMM(scratch, 0, mvpMatrix, 0, rotationMatrix, 0)

                   // Draw triangle
                   triangle.draw(scratch)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void onDrawFrame(GL10 gl) {
                   ...
                   float[] scratch = new float[16];

                   // Create a rotation for the triangle
                   // long time = SystemClock.uptimeMillis() % 4000L;
                   // float angle = 0.090f * ((int) time);
                   Matrix.setRotateM(rotationMatrix, 0, mAngle, 0, 0, -1.0f);

                   // Combine the rotation matrix with the projection and camera view
                   // Note that the vPMatrix factor *must be first* in order
                   // for the matrix multiplication product to be correct.
                   Matrix.multiplyMM(scratch, 0, vPMatrix, 0, rotationMatrix, 0);

                   // Draw triangle
                   mTriangle.draw(scratch);
               }

   When you have completed the steps described above, run the program and drag
   your finger over the screen to rotate the triangle:

   |image-ogl-triangle-touch|
   **Figure 1.** Triangle being rotated with touch input (circle shows touch
   location).


Last updated 2024-02-22 UTC.

.. |image-ogl-triangle-touch| image:: https://developer.android.google.cn/static/images/opengl/ogl-triangle-touch.png


/Create APKs for different GL textures
======================================

.. https://developer.android.google.cn/develop/ui/views/graphics/multiple-apks/texture?hl=en

.. container:: devsite-article-body

   If you publish your app to Google Play, you should build and upload an
   `Android App Bundle <#>`__. When you do so, Google Play
   automatically generates and serves optimized APKs for each user’s device
   configuration, so they download only the code and resources they need to run
   your app. Publishing multiple APKs is useful if you are not publishing to
   Google Play, but you must build, sign, and manage each APK yourself.

   When developing your Android application to take advantage of multiple APKs
   on Google Play, it’s important to adopt some good practices from the get-go,
   and prevent unnecessary headaches further into the development process. This
   lesson shows you how to create multiple APKs of your app, each supporting a
   different subset of OpenGL texture formats. You will also gain some tools
   necessary to make maintaining a multiple APK codebase as painless as
   possible.

   .. rubric:: Confirm you need multiple APKs
      :name: Confirm

   When trying to create an application that works across all available
   Android-powered devices, naturally you want your application look its best on
   each individual device, regardless of the fact they don’t all support the
   same set of GL textures. It may seem at the outset as though multiple APK
   support is the best solution, but this often isn’t the case. 
   The `Using Single APK Instead <#ApiLevelOptions>`__
   section of the multiple APK developer guide includes some useful information
   on how to accomplish this with a single APK, including how to `detect
   supported texture formats at runtime <#TextureOptions>`__. Depending
   on your situation, it might be easier to bundle all formats with your
   application, and simply pick which one to use at runtime.

   If you can manage it, confining your application to a single APK has several
   advantages, including:

   -  Publishing and Testing are easier
   -  There’s only one codebase to maintain
   -  Your application can adapt to device configuration changes
   -  App restore across devices just works
   -  You don’t have to worry about market preference, behavior from "upgrades"
      from one APK to the next, or which APK goes with which class of devices

   The rest of this lesson assumes that you’ve researched the topic, studiously
   absorbed the material in the resources linked, and determined that multiple
   APKs are the right path for your application.

   .. rubric:: Chart your requirements
      :name: ChartReqs

   The Android Developer Guide provides a handy reference of some of common
   supported textures on the `supports-gl-texture page <#>`__. This page also
   contains some hints as to which phones (or families of phones) support
   particular texture formats. Note that it’s generally a good idea for one of
   your APKs to support ETC1, as that texture format is supported by all
   Android-powered devices that support the OpenGL ES 2.0 spec.

   Since most Android-powered devices support more than one texture format, you
   need to establish an order of preference. Create a chart including all the
   formats that your application is going to support. The left-most cell is
   going to be the lowest priority (It will probably be ETC1, a really solid
   default in terms of performance and compatibility). Then color in the chart
   such that each cell represents an APK.

   ==== === =======
   ETC1 ATI PowerVR
   ==== === =======

   Coloring in the chart does more than just make this guide less monochromatic
   - It also has a way of making intra-team communication easier- You can now
   simply refer to each APK as "blue", "green", or "red", instead of "The one
   that supports ETC1 texture formats", etc.

   .. rubric:: Put all common code and resources in a library project
      :name: CreateLibrary

   Whether you’re modifying an existing Android application or starting one from
   scratch, this is the first thing that you should do to the codebase, and by
   the far the most important. Everything that goes into the library project
   only needs to be updated once (think language-localized strings, color
   themes, bugs fixed in shared code), which improves your development time and
   reduces the likelihood of mistakes that could have been easily avoided.

   **Note:** While the implementation details of how to create and include
   library projects are beyond the scope of this lesson, you can get up to speed
   by reading `Create an Android Library <#>`__.

   If you’re converting an existing application to use multiple APK support,
   scour your codebase for every localized string file, list of values, theme
   colors, menu icons and layout that isn’t going to change across APKs, and put
   it all in the library project. Code that isn’t going to change much should
   also go in the library project. You’ll likely find yourself extending these
   classes to add a method or two from APK to APK.

   If, on the other hand, you’re creating the application from scratch, try as
   much as possible to write code in the library project *first*, then only move
   it down to an individual APK if necessary. This is much easier to manage in
   the long run than adding it to one, then another, then another, then months
   later trying to figure out whether this blob can be moved up to the library
   section without screwing anything up.

   .. rubric:: Create new APK projects
      :name: CreateAPKs

   There should be a separate Android project for each APK you’re going to
   release. For easy organization, place the library project and all related APK
   projects under the same parent folder. Also remember that each APK needs to
   have the same package name, although they don’t necessarily need to share the
   package name with the library. If you were to have 3 APKs following the
   scheme described earlier, your root directory might look like this:

   .. code:: none

      alexlucas:~/code/multi-apks-root$ ls
      foo-blue
      foo-green
      foo-lib
      foo-red

   Once the projects are created, add the library project as a reference to each
   APK project. If possible, define your starting Activity in the library
   project, and extend that Activity in your APK project. Having a starting
   activity defined in the library project gives you a chance to put all your
   application initialization in one place, so that each individual APK doesn’t
   have to re-implement "universal" tasks like initializing Analytics, running
   licensing checks, and any other initialization procedures that don’t change
   much from APK to APK.

   .. rubric:: Adjust the manifests
      :name: AdjustManifests

   When a user downloads an application which uses multiple APKs through Google
   Play, the correct APK to use is chosen using some simple rules:

   -  The manifest has to show that particular APK is eligible
   -  Of the eligible APKs, highest version number wins
   -  If *any* of the texture formats listed in your APK are supported by the
      device on market, that device is considered eligible

   With regards to GL Textures, that last rule is important. It means that you
   should, for instance, be *very* careful about using different GL formats in
   the same application. If you were to use PowerVR 99% of the time, but use
   ETC1 for, say, your splash screen... Then your manifest would necessarily
   indicate support for both formats. A device that *only* supported ETC1 would
   be deemed compatible, your app would download, and the user would see some
   thrilling crash messages. The common case is going to be that if you’re using
   multiple APKs specifically to target different devices based on GL texture
   support, it’s going to be one texture format per APK.

   This actually makes texture support a little bit different than the other two
   multiple APK dimensions, API level and screen size. Any given device only has
   one API level, and one screen size, and it’s up to the APK to support a range
   of them. With textures, the APK will generally support one texture, and the
   device will support many. There will often be overlap in terms of one device
   supporting many APKs, but the solution is the same: Version codes.

   By way of example, take a few devices, and see how many of the APKs defined
   earlier fit each device.

   ======== ======= ======
   FooPhone Nexus S Evo
   ETC1     ETC1    ETC1
   \        PowerVR ATI TC
   ======== ======= ======

   Assuming that PowerVR and ATI formats are both preferred over ETC1 when
   available, than according to the "highest version number wins" rule, if we
   set the versionCode attribute in each APK such that red ≥ green ≥ blue, then
   both Red and Green will always be chosen over Blue on devices which support
   them, and should a device ever come along which supports both Red and Green,
   red will be chosen.

   In order to keep all your APKs on separate "tracks," it’s important to have a
   good version code scheme. The recommended one can be found on the Version
   Codes area of our developer guide. Since the example set of APKs is only
   dealing with one of 3 possible dimensions, it would be sufficient to separate
   each APK by 1000 and increment from there. This might look like:

   | Blue: 1001, 1002, 1003, 1004...
   | Green: 2001, 2002, 2003, 2004...
   | Red:3001, 3002, 3003, 3004...

   Putting this all together, your Android Manifests would likely look something
   like the following:

   Blue:

   .. code:: prettyprint

      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1001" android:versionName="1.0" package="com.example.foo">
          <supports-gl-texture android:name="GL_OES_compressed_ETC1_RGB8_texture" />
          ...

   Green:

   .. code:: prettyprint

      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="2001" android:versionName="1.0" package="com.example.foo">
          <supports-gl-texture android:name="GL_AMD_compressed_ATC_texture" />
          ...

   Red:

   .. code:: prettyprint

      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="3001" android:versionName="1.0" package="com.example.foo">
          <supports-gl-texture android:name="GL_IMG_texture_compression_pvrtc" />
          ...

   .. rubric:: Review your pre-launch checklist
      :name: PreLaunch

   Before uploading to Google Play, double-check the following items. Remember
   that these are specifically relevant to multiple APKs, and in no way
   represent a complete checklist for all applications being uploaded to Google
   Play.

   -  All APKs must have the same package name
   -  All APKs must be signed with the same certificate
   -  Double check your manifest filters for conflicting information (an APK
      that only supports cupcake on XLARGE screens isn’t going to be seen by
      anybody)
   -  Each APK's manifest must be unique across at least one of supported
      screen, OpenGL texture, or platform version
   -  Try to test each APK on at least one device. Barring that, you have one of
      the most customizable device emulators in the business sitting on your
      development machine. Go nuts!

   It’s also worth inspecting the compiled APK before pushing to market, to make
   sure there aren’t any surprises that could hide your application on Google
   Play. This is actually quite simple using the "aapt" tool. Aapt (the Android
   Asset Packaging Tool) is part of the build process for creating and packaging
   your Android applications, and is also a very handy tool for inspecting them.

   .. code:: none

      >aapt dump badging
      package: name='com.example.hello' versionCode='1' versionName='1.0'
      sdkVersion:'11'
      uses-permission:'android.permission.SEND_SMS'
      application-label:'Hello'
      application-icon-120:'res/drawable-ldpi/icon.png'
      application-icon-160:'res/drawable-mdpi/icon.png'
      application-icon-240:'res/drawable-hdpi/icon.png'
      application: label='Hello' icon='res/drawable-mdpi/icon.png'
      launchable-activity: name='com.example.hello.HelloActivity'  label='Hello' icon=''
      uses-feature:'android.hardware.telephony'
      uses-feature:'android.hardware.touchscreen'
      main
      supports-screens: 'xlarge'
      supports-any-density: 'true'
      locales: '--_--'
      densities: '120' '160' '240'

   When you examine aapt output, be sure to check that you don’t have
   conflicting values for supports-screens and compatible-screens, and that you
   don’t have unintended "uses-feature" values that were added as a result of
   permissions you set in the manifest. In the example above, the APK will be
   invisible to most, if not all devices.

   Why? By adding the required permission SEND_SMS, the feature requirement of
   android.hardware.telephony was implicitly added. Since most (if not all)
   xlarge devices are tablets without telephony hardware in them, Google Play
   will filter out this APK in these cases, until future devices come along
   which are both large enough to report as xlarge screen size, and possess
   telephony hardware.

   Fortunately this is easily fixed by adding the following to your manifest:

   .. code:: prettyprint

      <uses-feature android:name="android.hardware.telephony" android:required="false" />

   The ``android.hardware.touchscreen`` requirement is also implicitly added. If
   you want your APK to be visible on TVs which are non-touchscreen devices you
   should add the following to your manifest:

   .. code:: prettyprint

      <uses-feature android:name="android.hardware.touchscreen" android:required="false" />

   Once you’ve completed the pre-launch checklist, upload your APKs to Google
   Play. It may take a bit for the application to show up when browsing Google
   Play, but when it does, perform one last check. Download the application onto
   any test devices you may have to make sure that the APKs are targeting the
   intended devices. Congratulations, you’re done!


Last updated 2024-02-22 UTC.


/Animations and Transitions
===========================

.. https://developer.android.google.cn/develop/ui/views/animations?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add animations in Compose.

      `Animations in Compose → <https://developer.android.google.cn/jetpack/compose/animation>`__

      |image-android-compose-ui-logo|

   .. container:: video-wrapper

   When your UI changes in response to user action, you should animate the
   layout transitions. These animations give users feedback on their actions and
   help keep them oriented to the UI.

   Android includes the *transitions framework*, which enables you to easily
   animate changes between two view hierarchies. The framework animates the
   views at runtime by changing some of their property values over time. The
   framework includes built-in animations for common effects and lets you create
   custom animations and transition lifecycle callbacks.

   To get started, watch the video embedded here and read the `Animations Overview <#>`__.

   .. container:: wrap

      .. rubric:: Documentation
         :name: documentation
         :class: norule

      -  `Animations Overview <#>`__
      -  `Property Animation Overview <#>`__
      -  `Animate drawable graphics <#>`__
      -  `Reveal or hide a view using animation <#>`__
      -  `Move a View with Animation <#>`__
      -  `Move views using a fling animation <#>`__
      -  `Enlarge a view using a zoom animation <#>`__
      -  `Animate movement using spring physics <#>`__
      -  `Auto animate layout updates <#>`__
      -  `Animate layout changes using a transition <#>`__
      -  `Create a custom transition animation <#>`__
      -  `Start an activity using an animation <#>`__
      -  `Slide between fragments using ViewPager <#>`__
      -  `Slide between fragments using ViewPager2 <#>`__
      -  `Migrate from ViewPager to ViewPager2 <#>`__

   .. container:: wrap

      .. rubric:: Videos
         :name: videos
         :class: norule

   .. rubric:: Additional resources
      :name: additional-resources

   For more information about animation, consult the following resources.

   .. rubric:: Video
      :name: video

   -  `Get Animated (Android Dev Summit '18) <https://www.youtube.com/watch?v=N_x7SV3I3P0>`__: Overview of the
      various animation technologies available. Includes a summary of `how to
      choose between the different animation options <https://www.youtube.com/watch?v=N_x7SV3I3P0&t=2265>`__.

   .. rubric:: Samples
      :name: samples

   -  `Navigation > Shared element <https://github.com/android/animation-samples/tree/main/Motion/app/src/main/java/com/example/android/motion/demo/sharedelement>`__
   -  `Navigation > Fade through <https://github.com/android/animation-samples/tree/main/Motion/app/src/main/java/com/example/android/motion/demo/navfadethrough>`__
   -  `Layout > Fade through <https://github.com/android/animation-samples/tree/main/Motion/app/src/main/java/com/example/android/motion/demo/fadethrough>`__
   -  `more... <#>`__


Last updated 2024-04-15 UTC.



/About animations in Android
============================

.. https://developer.android.google.cn/develop/ui/views/animations/overview?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `Animations in Compose → <https://developer.android.google.cn/jetpack/compose/animation>`__

      |image-android-compose-ui-logo|

   Animations can add visual cues that notify users about what's going on in
   your app. They are especially useful when the UI changes state, such as when
   new content loads or new actions become available. Animations also add a
   polished look to your app, which gives it a higher quality look and feel.

   Android includes different animation APIs depending on what type of animation
   you want. This documentation provides an overview of the different ways you
   can add motion to your UI.

   To better understand when you should use animations, also see the 
   `Material Design guide about motion <#>`__.

   **Note:**\  For guidance on animations in Jetpack Compose, see
   `Animation <https://developer.android.google.cn/jetpack/compose/animation>`__.

   .. rubric:: Animate bitmaps
      :name: drawables

   .. container:: attempt-right

      **Figure 1.** An animated drawable.

   To animate a bitmap graphic such as an icon or illustration, use the drawable
   animation APIs. Usually, these animations are defined statically with a
   drawable resource, but you can also define the animation behavior at runtime.

   For example, a nice way to communicate to the user that two actions are
   related is to animate a play button that transforms into a pause button when
   it's tapped.

   For more information, read `Animate drawable graphics <#>`__.

   .. rubric:: Animate UI visibility and motion
      :name: ui-changes

   .. container:: attempt-right

      **Figure 2.** A subtle animation when a dialog appears and disappears
      makes the UI change less jarring.

   When you need to change the visibility or position of views in your layout,
   it's best to include subtle animations to help the user understand how the UI
   is changing.

   To move, reveal, or hide views within the current layout, you can use the
   property animation system provided by the
   `android.animation <#android.animation.package-summary>`__
   package, available in Android 3.0 (API level 11) and higher. These APIs
   update the properties of your `View <#android.view.View>`__
   objects over a period of time, continuously redrawing the view as the
   properties change. For example, when you change the position properties, the
   view moves across the screen. When you change the alpha property, the view
   fades in or out.

   For the simplest way to create these animations, enable animations on your
   layout so that when you change the visibility of a view, an animation applies
   automatically. For more information, see `Auto animate layout updates <#>`__.

   To learn how to build animations using the property animation system, read
   the `Property animation overview <#>`__.
   You can also see the following pages to create common animations:

   -  `Change a view visibility with a crossfade <#Crossfade>`__.
   -  `Change a view visibility with a circular reveal <#Reveal>`__.
   -  `Swap views with a card flip <#Cardflip>`__.
   -  `Change the view size with a zoom animation <#>`__.

   .. rubric:: Physics-based motion
      :name: physics-based

   .. container:: attempt-right

      .. container::

         **Figure 3.** Animation built with ObjectAnimator.

      .. container::

         **Figure 4.** Animation built with physics-based APIs.

   Whenever possible, apply real-world physics to your animations so that they
   are natural-looking. For example, they should maintain momentum when their
   target changes and make smooth transitions during any changes.

   To provide these behaviors, the Android Support library includes
   physics-based animation APIs that rely on the laws of physics to control how
   your animations occur.

   Two common physics-based animations are the following:

   -  `Spring animation <#>`__.
   -  `Fling animation <#>`__.

   Animations not based on physics—such as those built with
   `ObjectAnimator <#android.animation.ObjectAnimator>`__ APIs—are
   fairly static and have a fixed duration. If the target value changes, you
   must cancel the animation at the time of target value change, re-configure
   the animation with a new value as the new start value, and add the new target
   value. Visually, this process creates an abrupt stop in the animation, and a
   disjointed movement afterwards, as shown in figure 3.

   Animations built by with physics-based animation APIs, such as
   `DynamicAnimation <#androidx.dynamicanimation.animation.DynamicAnimation>`__,
   are driven by force. The change in the target value results in a change in
   force. The new force applies on the existing velocity, which makes a
   continuous transition to the new target. This process results in a more
   natural-looking animation, as shown in figure 4.

   .. rubric:: Animate layout changes
      :name: transitions

   .. container:: attempt-right

      **Figure 5.** An animation to show more details can be achieved by either
      changing the layout or starting a new activity.

   On Android 4.4 (API level 19) and higher, you can use the transition
   framework to create animations when you swap the layout within the current
   activity or fragment. All you need to do is specify the starting and ending
   layout and what type of animation you want to use. Then the system figures
   out and executes an animation between the two layouts. You can use this to
   swap out the entire UI or to move or replace just some views.

   For example, when the user taps an item to see more information, you can
   replace the layout with the item details, applying a transition like the one
   shown in figure 5.

   The starting and ending layout are each stored in a
   `Scene <#android.transition.Scene>`__, though the starting
   scene is usually determined automatically from the current layout. You create
   a `Transition <#android.transition.Transition>`__ to tell the
   system what type of animation you want, then call
   `TransitionManager.go() <#android.transition.TransitionManager>`__
   and the system runs the animation to swap the layouts.

   For more information, read `Animate layout changes using a transition <#>`__. For sample code,
   check out
   `BasicTransition <https://github.com/android/animation-samples/tree/main/BasicTransition>`__
   .

   .. rubric:: Animate between activities
      :name: animate-activities

   On Android 5.0 (API level 21) and higher, you can also create animations that
   transition between your activities. This is based on the same transition
   framework described in the previous section, but it lets you create
   animations between layouts in *separate activities*.

   You can apply simple animations such as sliding the new activity in from the
   side or fading it in, but you can also create animations that transition
   between shared views in each activity. For example, when the user taps an
   item to see more information, you can transition into a new activity with an
   animation that seamlessly grows that item to fill the screen, like the
   animation shown in figure 5.

   As usual, you call
   `startActivity() <#android.app.Activity>`__,
   but pass it a bundle of options provided by
   `ActivityOptions.makeSceneTransitionAnimation() <#android.app.ActivityOptions>`__.
   This bundle of options might include which views are shared between the
   activities so the transition framework can connect them during the animation.

   For additional resources, see:

   -  `Start an activity using an animation <#>`__
   -  `ActivitySceneTransitionBasic <https://github.com/android/animation/tree/main/ActivitySceneTransitionBasic>`__


Last updated 2024-05-03 UTC.



/About property animations
==========================

.. https://developer.android.google.cn/develop/ui/views/animations/prop-animation?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `animate*AsState → <https://developer.android.google.cn/jetpack/compose/animation/value-based#animate-as-state>`__

      |image-android-compose-ui-logo|

   The property animation system is a robust framework that allows you to
   animate almost anything. You can define an animation to change any object
   property over time, regardless of whether it draws to the screen or not. A
   property animation changes a property's (a field in an object) value over a
   specified length of time. To animate something, you specify the object
   property that you want to animate, such as an object's position on the
   screen, how long you want to animate it for, and what values you want to
   animate between.

   The property animation system lets you define the following characteristics
   of an animation:

   -  Duration: You can specify the duration of an animation. The default length
      is 300 ms.
   -  Time interpolation: You can specify how the values for the property are
      calculated as a function of the animation's current elapsed time.
   -  Repeat count and behavior: You can specify whether or not to have an
      animation repeat when it reaches the end of a duration and how many times
      to repeat the animation. You can also specify whether you want the
      animation to play back in reverse. Setting it to reverse plays the
      animation forwards then backwards repeatedly, until the number of repeats
      is reached.
   -  Animator sets: You can group animations into logical sets that play
      together or sequentially or after specified delays.
   -  Frame refresh delay: You can specify how often to refresh frames of your
      animation. The default is set to refresh every 10 ms, but the speed in
      which your application can refresh frames is ultimately dependent on how
      busy the system is overall and how fast the system can service the
      underlying timer.

   To see a full example of property animation, see the ``ChangeColor`` class in the
   `CustomTransition <https://github.com/android/animation-samples/tree/main/CustomTransition>`__
   sample on GitHub.

   .. rubric:: How property animation works
      :name: how

   First, let's go over how an animation works with a simple example. Figure 1
   depicts a hypothetical object that is animated with its ``x`` property, which
   represents its horizontal location on a screen. The duration of the animation
   is set to 40 ms and the distance to travel is 40 pixels. Every 10 ms, which
   is the default frame refresh rate, the object moves horizontally by 10
   pixels. At the end of 40ms, the animation stops, and the object ends at
   horizontal position 40. This is an example of an animation with linear
   interpolation, meaning the object moves at a constant speed.

   |image-animation-linear|
   **Figure 1.** Example of a linear animation

   You can also specify animations to have a non-linear interpolation. Figure 2
   illustrates a hypothetical object that accelerates at the beginning of the
   animation, and decelerates at the end of the animation. The object still
   moves 40 pixels in 40 ms, but non-linearly. In the beginning, this animation
   accelerates up to the halfway point then decelerates from the halfway point
   until the end of the animation. As Figure 2 shows, the distance traveled at
   the beginning and end of the animation is less than in the middle.

   |image-animation-nonlinear|
   **Figure 2.** Example of a non-linear animation

   Let's take a detailed look at how the important components of the property
   animation system would calculate animations like the ones illustrated above.
   Figure 3 depicts how the main classes work with one another.

   |image-valueanimator|
   **Figure 3.** How animations are calculated

   The `ValueAnimator <#android.animation.ValueAnimator>`__ object
   keeps track of your animation's timing, such as how long the animation has
   been running, and the current value of the property that it is animating.

   The `ValueAnimator <#android.animation.ValueAnimator>`__
   encapsulates a
   `TimeInterpolator <#android.animation.TimeInterpolator>`__,
   which defines animation interpolation, and a
   `TypeEvaluator <#android.animation.TypeEvaluator>`__, which
   defines how to calculate values for the property being animated. For example,
   in Figure 2, the
   `TimeInterpolator <#android.animation.TimeInterpolator>`__ used
   would be
   `AccelerateDecelerateInterpolator <#android.view.animation.AccelerateDecelerateInterpolator>`__
   and the `TypeEvaluator <#android.animation.TypeEvaluator>`__
   would be `IntEvaluator <#android.animation.IntEvaluator>`__.

   To start an animation, create a
   `ValueAnimator <#android.animation.ValueAnimator>`__ and give
   it the starting and ending values for the property that you want to animate,
   along with the duration of the animation. When you call
   `start() <#android.animation.ValueAnimator>`__ the
   animation begins. During the whole animation, the
   `ValueAnimator <#android.animation.ValueAnimator>`__ calculates
   an *elapsed fraction* between 0 and 1, based on the duration of the animation
   and how much time has elapsed. The elapsed fraction represents the percentage
   of time that the animation has completed, 0 meaning 0% and 1 meaning 100%.
   For example, in Figure 1, the elapsed fraction at t = 10 ms would be .25
   because the total duration is t = 40 ms.

   When the `ValueAnimator <#android.animation.ValueAnimator>`__
   is done calculating an elapsed fraction, it calls the
   `TimeInterpolator <#android.animation.TimeInterpolator>`__ that
   is currently set, to calculate an *interpolated fraction*. An interpolated
   fraction maps the elapsed fraction to a new fraction that takes into account
   the time interpolation that is set. For example, in Figure 2, because the
   animation slowly accelerates, the interpolated fraction, about .15, is less
   than the elapsed fraction, .25, at t = 10 ms. In Figure 1, the interpolated
   fraction is always the same as the elapsed fraction.

   When the interpolated fraction is calculated,
   `ValueAnimator <#android.animation.ValueAnimator>`__ calls the
   appropriate
   `TypeEvaluator <#android.animation.TypeEvaluator>`__, to
   calculate the value of the property that you are animating, based on the
   interpolated fraction, the starting value, and the ending value of the
   animation. For example, in Figure 2, the interpolated fraction was .15 at t =
   10 ms, so the value for the property at that time would be .15 × (40 - 0), or
   6.

   .. rubric:: How property animation differs from view animation
      :name: property-vs-view

   The view animation system provides the capability to only animate
   `View <#android.view.View>`__ objects, so if you wanted to
   animate non-`View <#android.view.View>`__ objects, you have to
   implement your own code to do so. The view animation system is also
   constrained in the fact that it only exposes a few aspects of a
   `View <#android.view.View>`__ object to animate, such as the
   scaling and rotation of a View but not the background color, for instance.

   Another disadvantage of the view animation system is that it only modified
   where the View was drawn, and not the actual View itself. For instance, if
   you animated a button to move across the screen, the button draws correctly,
   but the actual location where you can click the button does not change, so
   you have to implement your own logic to handle this.

   With the property animation system, these constraints are completely removed,
   and you can animate any property of any object (Views and non-Views) and the
   object itself is actually modified. The property animation system is also
   more robust in the way it carries out animation. At a high level, you assign
   animators to the properties that you want to animate, such as color,
   position, or size and can define aspects of the animation such as
   interpolation and synchronization of multiple animators.

   The view animation system, however, takes less time to setup and requires
   less code to write. If view animation accomplishes everything that you need
   to do, or if your existing code already works the way you want, there is no
   need to use the property animation system. It also might make sense to use
   both animation systems for different situations if the use case arises.

   .. rubric:: API overview
      :name: api-overview

   You can find most of the property animation system's APIs in
   `android.animation <#android.animation.package-summary>`__.
   Because the view animation system already defines many interpolators in
   `android.view.animation <#android.view.animation.package-summary>`__,
   you can use those interpolators in the property animation system as well. The
   following tables describe the main components of the property animation
   system.

   The `Animator <#android.animation.Animator>`__ class provides
   the basic structure for creating animations. You normally do not use this
   class directly as it only provides minimal functionality that must be
   extended to fully support animating values. The following subclasses extend
   `Animator <#android.animation.Animator>`__:

   **Table 1.** Animators


   .. list-table::
      :header-rows: 1

      - 

         - Class
         - Description
      - 

         - ``ValueAnimator``
         - The main timing engine for property animation that also computes the
            values for the property to be animated. It has all of the core
            functionality that calculates animation values and contains the
            timing details of each animation, information about whether an
            animation repeats, listeners that receive update events, and the
            ability to set custom types to evaluate. There are two pieces to
            animating properties: calculating the animated values and setting
            those values on the object and property that is being animated.
            ``ValueAnimator``
            does not carry out the second piece, so you must listen for updates
            to values calculated by the
            ``ValueAnimator``
            and modify the objects that you want to animate with your own logic.
            See the section about `Animating with
            ValueAnimator <#value-animator>`__ for more information.
      - 

         - ``ObjectAnimator``
         - A subclass of
            ``ValueAnimator``
            that allows you to set a target object and object property to
            animate. This class updates the property accordingly when it
            computes a new value for the animation. You want to use
            ``ObjectAnimator``
            most of the time, because it makes the process of animating values
            on target objects much easier. However, you sometimes want to use
            ``ValueAnimator``
            directly because
            ``ObjectAnimator``
            has a few more restrictions, such as requiring specific accessor
            methods to be present on the target object.
      - 

         - ``AnimatorSet``
         - Provides a mechanism to group animations together so that they run in
            relation to one another. You can set animations to play together,
            sequentially, or after a specified delay. See the section about
            `Choreographing multiple animations with Animator Sets <#choreography>`__ 
            for more information.

   Evaluators tell the property animation system how to calculate values for a
   given property. They take the timing data that is provided by an
   `Animator <#android.animation.Animator>`__ class, the
   animation's start and end value, and calculate the animated values of the
   property based on this data. The property animation system provides the
   following evaluators:

   **Table 2.** Evaluators

   .. list-table::
      :header-rows: 1

      - 

         - Class/Interface
         - Description
      - 

         - ``IntEvaluator``
         - The default evaluator to calculate values for ``int`` properties.
      - 

         - ``FloatEvaluator``
         - The default evaluator to calculate values for ``float`` properties.
      - 

         - ``ArgbEvaluator``
         - The default evaluator to calculate values for color properties that
            are represented as hexadecimal values.
      - 

         - ``TypeEvaluator``
         - An interface that allows you to create your own evaluator. If you are
            animating an object property that is *not* an ``int``, ``float``, or
            color, you must implement the
            ``TypeEvaluator``
            interface to specify how to compute the object property's animated
            values. You can also specify a custom
            ``TypeEvaluator``
            for ``int``, ``float``, and color values as well, if you want to
            process those types differently than the default behavior. See the
            section about `Using a TypeEvaluator <#type-evaluator>`__ for more
            information on how to write a custom evaluator.

   A time interpolator defines how specific values in an animation are
   calculated as a function of time. For example, you can specify animations to
   happen linearly across the whole animation, meaning the animation moves
   evenly the entire time, or you can specify animations to use non-linear time,
   for example, accelerating at the beginning and decelerating at the end of the
   animation. Table 3 describes the interpolators that are contained in
   `android.view.animation <#android.view.animation.package-summary>`__.
   If none of the provided interpolators suits your needs, implement the
   `TimeInterpolator <#android.animation.TimeInterpolator>`__
   interface and create your own. See `Using interpolators <#interpolators>`__
   for more information on how to write a custom interpolator.

   **Table 3.** Interpolators

   .. list-table::
      :header-rows: 1

      - 

         - Class/Interface
         - Description
      - 

         - ``AccelerateDecelerateInterpolator``
         - An interpolator whose rate of change starts and ends slowly but
            accelerates through the middle.
      - 

         - ``AccelerateInterpolator``
         - An interpolator whose rate of change starts out slowly and then
            accelerates.
      - 

         - ``AnticipateInterpolator``
         - An interpolator whose change starts backward then flings forward.
      - 

         - ``AnticipateOvershootInterpolator``
         - An interpolator whose change starts backward, flings forward and
            overshoots the target value, then finally goes back to the final
            value.
      - 

         - ``BounceInterpolator``
         - An interpolator whose change bounces at the end.
      - 

         - ``CycleInterpolator``
         - An interpolator whose animation repeats for a specified number of
            cycles.
      - 

         - ``DecelerateInterpolator``
         - An interpolator whose rate of change starts out quickly and then
            decelerates.
      - 

         - ``LinearInterpolator``
         - An interpolator whose rate of change is constant.
      - 

         - ``OvershootInterpolator``
         - An interpolator whose change flings forward and overshoots the last
            value then comes back.
      - 

         - ``TimeInterpolator``
         - An interface that allows you to implement your own interpolator.

   .. rubric:: Animate using ValueAnimator
      :name: value-animator

   The `ValueAnimator <#android.animation.ValueAnimator>`__ class
   lets you animate values of some type for the duration of an animation by
   specifying a set of ``int``, ``float``, or color values to animate through.
   You obtain a
   `ValueAnimator <#android.animation.ValueAnimator>`__ by calling
   one of its factory methods:
   `ofInt() <#android.animation.ValueAnimator>`__,
   `ofFloat() <#android.animation.ValueAnimator>`__,
   or
   `ofObject() <#android.animation.ValueAnimator>`__.
   For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ValueAnimator.ofFloat(0f, 100f).apply {
                   duration = 1000
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);
               animation.setDuration(1000);
               animation.start();

   In this code, the
   `ValueAnimator <#android.animation.ValueAnimator>`__ starts
   calculating the values of the animation, between 0 and 100, for a duration of
   1000 ms, when the
   `start() <#android.animation.ValueAnimator>`__ method
   runs.

   You can also specify a custom type to animate by doing the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ValueAnimator.ofObject(MyTypeEvaluator(), startPropertyValue, endPropertyValue).apply {
                   duration = 1000
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);
               animation.setDuration(1000);
               animation.start();

   In this code, the
   `ValueAnimator <#android.animation.ValueAnimator>`__ starts
   calculating the values of the animation, between ``startPropertyValue`` and
   ``endPropertyValue`` using the logic supplied by ``MyTypeEvaluator`` for a
   duration of 1000 ms, when the
   `start() <#android.animation.ValueAnimator>`__ method
   runs.

   You can use the values of the animation by adding an
   `AnimatorUpdateListener <#android.animation.ValueAnimator.AnimatorUpdateListener>`__
   to the `ValueAnimator <#android.animation.ValueAnimator>`__
   object, as shown in the following code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ValueAnimator.ofObject(...).apply {
                   ...
                   addUpdateListener { updatedAnimation ->
                       // You can use the animated value in a property that uses the
                       // same type as the animation. In this case, you can use the
                       // float value in the translationX property.
                       textView.translationX = updatedAnimation.animatedValue as Float
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
                   @Override
                   public void onAnimationUpdate(ValueAnimator updatedAnimation) {
                       // You can use the animated value in a property that uses the
                       // same type as the animation. In this case, you can use the
                       // float value in the translationX property.
                       float animatedValue = (float)updatedAnimation.getAnimatedValue();
                       textView.setTranslationX(animatedValue);
                   }
               });

   In the
   `onAnimationUpdate() <#android.animation.ValueAnimator.AnimatorUpdateListener>`__
   method you can access the updated animation value and use it in a property of
   one of your views. For more information on listeners, see the section about
   `Animation listeners <#listeners>`__.

   .. rubric:: Animate using ObjectAnimator
      :name: object-animator

   The `ObjectAnimator <#android.animation.ObjectAnimator>`__ is a
   subclass of the
   `ValueAnimator <#android.animation.ValueAnimator>`__ (discussed
   in the previous section) and combines the timing engine and value computation
   of `ValueAnimator <#android.animation.ValueAnimator>`__ with
   the ability to animate a named property of a target object. This makes
   animating any object much easier, as you no longer need to implement the
   `ValueAnimator.AnimatorUpdateListener <#android.animation.ValueAnimator.AnimatorUpdateListener>`__,
   because the animated property updates automatically.

   Instantiating an
   `ObjectAnimator <#android.animation.ObjectAnimator>`__ is
   similar to a
   `ValueAnimator <#android.animation.ValueAnimator>`__, but you
   also specify the object and the name of that object's property (as a String)
   along with the values to animate between:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ObjectAnimator.ofFloat(textView, "translationX", 100f).apply {
                   duration = 1000
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ObjectAnimator animation = ObjectAnimator.ofFloat(textView, "translationX", 100f);
               animation.setDuration(1000);
               animation.start();

   To have the
   `ObjectAnimator <#android.animation.ObjectAnimator>`__ update
   properties correctly, you must do the following:

   -  The object property that you are animating must have a setter function (in
      camel case) in the form of ``set<PropertyName>()``. Because the
      `ObjectAnimator <#android.animation.ObjectAnimator>`__
      automatically updates the property during animation, it must be able to
      access the property with this setter method. For example, if the property
      name is ``foo``, you need to have a ``setFoo()`` method. If this setter
      method does not exist, you have three options:

      -  Add the setter method to the class if you have the rights to do so.
      -  Use a wrapper class that you have rights to change and have that
         wrapper receive the value with a valid setter method and forward it to
         the original object.
      -  Use `ValueAnimator <#android.animation.ValueAnimator>`__
         instead.

   -  If you specify only one value for the ``values...`` parameter in one of
      the `ObjectAnimator <#android.animation.ObjectAnimator>`__
      factory methods, it is assumed to be the ending value of the animation.
      Therefore, the object property that you are animating must have a getter
      function that is used to obtain the starting value of the animation. The
      getter function must be in the form of ``get<PropertyName>()``. For
      example, if the property name is ``foo``, you need to have a ``getFoo()``
      method.

   -  The getter (if needed) and setter methods of the property that you are
      animating must operate on the same type as the starting and ending values
      that you specify to
      `ObjectAnimator <#android.animation.ObjectAnimator>`__. For
      example, you must have ``targetObject.setPropName(float)`` and
      ``targetObject.getPropName()`` if you construct the following
      `ObjectAnimator <#android.animation.ObjectAnimator>`__:

      .. code:: prettyprint

         ObjectAnimator.ofFloat(targetObject, "propName", 1f)

   -  Depending on what property or object you are animating, you might need to
      call the `invalidate() <#android.view.View>`__
      method on a View to force the screen to redraw itself with the updated
      animated values. You do this in the
      `onAnimationUpdate() <#android.animation.ValueAnimator.AnimatorUpdateListener>`__
      callback. For example, animating the color property of a Drawable object
      only causes updates to the screen when that object redraws itself. All of
      the property setters on View, such as
      `setAlpha() <#android.view.View>`__ and
      `setTranslationX() <#android.view.View>`__
      invalidate the View properly, so you do not need to invalidate the View
      when calling these methods with new values. For more information on
      listeners, see the section about `Animation listeners <#listeners>`__.

   .. rubric:: Choreograph multiple animations using an AnimatorSet
      :name: choreography

   In many cases, you want to play an animation that depends on when another
   animation starts or finishes. The Android system lets you bundle animations
   together into an
   `AnimatorSet <#android.animation.AnimatorSet>`__, so that you
   can specify whether to start animations simultaneously, sequentially, or
   after a specified delay. You can also nest
   `AnimatorSet <#android.animation.AnimatorSet>`__ objects within
   each other.

   The following code snippet plays the following
   `Animator <#android.animation.Animator>`__ objects in the
   following manner:

   #. Plays ``bounceAnim``.
   #. Plays ``squashAnim1``, ``squashAnim2``, ``stretchAnim1``, and
      ``stretchAnim2`` at the same time.
   #. Plays ``bounceBackAnim``.
   #. Plays ``fadeAnim``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val bouncer = AnimatorSet().apply {
                   play(bounceAnim).before(squashAnim1)
                   play(squashAnim1).with(squashAnim2)
                   play(squashAnim1).with(stretchAnim1)
                   play(squashAnim1).with(stretchAnim2)
                   play(bounceBackAnim).after(stretchAnim2)
               }
               val fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f).apply {
                   duration = 250
               }
               AnimatorSet().apply {
                   play(bouncer).before(fadeAnim)
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AnimatorSet bouncer = new AnimatorSet();
               bouncer.play(bounceAnim).before(squashAnim1);
               bouncer.play(squashAnim1).with(squashAnim2);
               bouncer.play(squashAnim1).with(stretchAnim1);
               bouncer.play(squashAnim1).with(stretchAnim2);
               bouncer.play(bounceBackAnim).after(stretchAnim2);
               ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f);
               fadeAnim.setDuration(250);
               AnimatorSet animatorSet = new AnimatorSet();
               animatorSet.play(bouncer).before(fadeAnim);
               animatorSet.start();

   .. rubric:: Animation listeners
      :name: listeners

   You can listen for important events during an animation's duration with the
   listeners described below.

   -  `Animator.AnimatorListener <#android.animation.Animator.AnimatorListener>`__

      -  `onAnimationStart() <#android.animation.Animator.AnimatorListener>`__
         - Called when the animation starts.
      -  `onAnimationEnd() <#android.animation.Animator.AnimatorListener>`__
         - Called when the animation ends.
      -  `onAnimationRepeat() <#android.animation.Animator.AnimatorListener>`__
         - Called when the animation repeats itself.
      -  `onAnimationCancel() <#android.animation.Animator.AnimatorListener>`__
         - Called when the animation is canceled. A cancelled animation also
         calls
         `onAnimationEnd() <#android.animation.Animator.AnimatorListener>`__,
         regardless of how they were ended.

   -  `ValueAnimator.AnimatorUpdateListener <#android.animation.ValueAnimator.AnimatorUpdateListener>`__

      -  `onAnimationUpdate() <#android.animation.ValueAnimator.AnimatorUpdateListener>`__
         - called on every frame of the animation. Listen to this event to use
         the calculated values generated by
         `ValueAnimator <#android.animation.ValueAnimator>`__
         during an animation. To use the value, query the
         `ValueAnimator <#android.animation.ValueAnimator>`__
         object passed into the event to get the current animated value with the
         `getAnimatedValue() <#android.animation.ValueAnimator>`__
         method. Implementing this listener is required if you use
         `ValueAnimator <#android.animation.ValueAnimator>`__.

         Depending on what property or object you are animating, you might need
         to call
         `invalidate() <#android.view.View>`__ on a
         View to force that area of the screen to redraw itself with the new
         animated values. For example, animating the color property of a
         Drawable object only cause updates to the screen when that object
         redraws itself. All of the property setters on View, such as
         `setAlpha() <#android.view.View>`__ and
         `setTranslationX() <#android.view.View>`__
         invalidate the View properly, so you do not need to invalidate the View
         when calling these methods with new values.

   You can extend the
   `AnimatorListenerAdapter <#android.animation.AnimatorListenerAdapter>`__
   class instead of implementing the
   `Animator.AnimatorListener <#android.animation.Animator.AnimatorListener>`__
   interface, if you do not want to implement all of the methods of the
   `Animator.AnimatorListener <#android.animation.Animator.AnimatorListener>`__
   interface. The
   `AnimatorListenerAdapter <#android.animation.AnimatorListenerAdapter>`__
   class provides empty implementations of the methods that you can choose to
   override.

   For example, the following code snippet creates an
   `AnimatorListenerAdapter <#android.animation.AnimatorListenerAdapter>`__
   for just the
   `onAnimationEnd() <#android.animation.Animator.AnimatorListener>`__
   callback:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f).apply {
                   duration = 250
                   addListener(object : AnimatorListenerAdapter() {
                       override fun onAnimationEnd(animation: Animator) {
                           balls.remove((animation as ObjectAnimator).target)
                       }
                   })
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f);
               fadeAnim.setDuration(250);
               fadeAnim.addListener(new AnimatorListenerAdapter() {
               public void onAnimationEnd(Animator animation) {
                   balls.remove(((ObjectAnimator)animation).getTarget());
               }

   .. rubric:: Animate layout changes to ViewGroup objects
      :name: layout

   The property animation system provides the capability to animate changes to
   ViewGroup objects as well as provide an easy way to animate View objects
   themselves.

   You can animate layout changes within a ViewGroup with the
   `LayoutTransition <#android.animation.LayoutTransition>`__
   class. Views inside a ViewGroup can go through an appearing and disappearing
   animation when you add them to or remove them from a ViewGroup or when you
   call a View's
   `setVisibility() <#android.view.View>`__
   method with `VISIBLE <#android.view.View>`__,
   `INVISIBLE <#android.view.View>`__, or
   `GONE <#android.view.View>`__. The remaining Views in the
   ViewGroup can also animate into their new positions when you add or remove
   Views. You can define the following animations in a
   `LayoutTransition <#android.animation.LayoutTransition>`__
   object by calling
   `setAnimator() <#android.animation.LayoutTransition>`__
   and passing in an `Animator <#android.animation.Animator>`__
   object with one of the following
   `LayoutTransition <#android.animation.LayoutTransition>`__
   constants:

   -  ``APPEARING`` - A flag indicating the animation that runs on items that
      are appearing in the container.
   -  ``CHANGE_APPEARING`` - A flag indicating the animation that runs on items
      that are changing due to a new item appearing in the container.
   -  ``DISAPPEARING`` - A flag indicating the animation that runs on items that
      are disappearing from the container.
   -  ``CHANGE_DISAPPEARING`` - A flag indicating the animation that runs on
      items that are changing due to an item disappearing from the container.

   You can define your own custom animations for these four types of events to
   customize the look of your layout transitions or just tell the animation
   system to use the default animations.

   To set the ``android:animateLayoutchanges`` attribute to ``true`` for the
   ViewGroup do the following:

   .. code:: prettyprint

      <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:id="@+id/verticalContainer"
          android:animateLayoutChanges="true" />

   Setting this attribute to true automatically animates Views that are added or
   removed from the ViewGroup as well as the remaining Views in the ViewGroup.

   .. rubric:: Animate view state changes using StateListAnimator
      :name: ViewState

   The
   `StateListAnimator <#android.animation.StateListAnimator>`__
   class lets you define animators that run when the state of a view changes.
   This object behaves as a wrapper for an
   `Animator <#android.animation.Animator>`__ object, calling that
   animation whenever the specified view state (such as "pressed" or "focused")
   changes.

   The
   `StateListAnimator <#android.animation.StateListAnimator>`__
   can be defined in an XML resource with a root ``<selector>`` element and
   child ``<item>`` elements that each specify a different view state defined by
   the
   `StateListAnimator <#android.animation.StateListAnimator>`__
   class. Each ``<item>`` contains the definition for a `property animation set <#Property>`__.

   For example, the following file creates a state list animator that changes
   the x and y scale of the view when it's pressed:

   res/xml/animate_scale.xml

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <selector xmlns:android="http://schemas.android.com/apk/res/android">
          <!-- the pressed state; increase x and y size to 150% -->
          <item android:state_pressed="true">
              <set>
                  <objectAnimator android:propertyName="scaleX"
                      android:duration="@android:integer/config_shortAnimTime"
                      android:valueTo="1.5"
                      android:valueType="floatType"/>
                  <objectAnimator android:propertyName="scaleY"
                      android:duration="@android:integer/config_shortAnimTime"
                      android:valueTo="1.5"
                      android:valueType="floatType"/>
              </set>
          </item>
          <!-- the default, non-pressed state; set x and y size to 100% -->
          <item android:state_pressed="false">
              <set>
                  <objectAnimator android:propertyName="scaleX"
                      android:duration="@android:integer/config_shortAnimTime"
                      android:valueTo="1"
                      android:valueType="floatType"/>
                  <objectAnimator android:propertyName="scaleY"
                      android:duration="@android:integer/config_shortAnimTime"
                      android:valueTo="1"
                      android:valueType="floatType"/>
              </set>
          </item>
      </selector>

   To attach the state list animator to a view, add the
   `android:stateListAnimator <#android.view.View>`__
   attribute as follows:

   .. code:: prettyprint

      <Button android:stateListAnimator="@xml/animate_scale"
              ... />

   Now the animations defined in ``animate_scale.xml`` are used when this
   button's state changes.

   Or to instead assign a state list animator to a view in your code, use the
   `AnimatorInflater.loadStateListAnimator() <#android.animation.AnimatorInflater>`__
   method, and assign the animator to your view with the
   `View.setStateListAnimator() <#android.view.View>`__
   method.

   Or instead of animating properties of the view, you can play a drawable
   animation between state changes, using
   `AnimatedStateListDrawable <#android.graphics.drawable.AnimatedStateListDrawable>`__.
   Some of the system widgets in Android 5.0 use these animations by default.
   The following example shows how to define an
   `AnimatedStateListDrawable <#android.graphics.drawable.AnimatedStateListDrawable>`__
   as an XML resource:

   .. code:: prettyprint

      <!-- res/drawable/myanimstatedrawable.xml -->
      <animated-selector
          xmlns:android="http://schemas.android.com/apk/res/android">

          <!-- provide a different drawable for each state-->
          <item android:id="@+id/pressed" android:drawable="@drawable/drawableP"
              android:state_pressed="true"/>
          <item android:id="@+id/focused" android:drawable="@drawable/drawableF"
              android:state_focused="true"/>
          <item android:id="@id/default"
              android:drawable="@drawable/drawableD"/>

          <!-- specify a transition -->
          <transition android:fromId="@+id/default" android:toId="@+id/pressed">
              <animation-list>
                  <item android:duration="15" android:drawable="@drawable/dt1"/>
                  <item android:duration="15" android:drawable="@drawable/dt2"/>
                  ...
              </animation-list>
          </transition>
          ...
      </animated-selector>

   .. rubric:: Use a TypeEvaluator
      :name: type-evaluator

   If you want to animate a type that is unknown to the Android system, you can
   create your own evaluator by implementing the
   `TypeEvaluator <#android.animation.TypeEvaluator>`__ interface.
   The types that are known by the Android system are ``int``, ``float``, or a
   color, which are supported by the
   `IntEvaluator <#android.animation.IntEvaluator>`__,
   `FloatEvaluator <#android.animation.FloatEvaluator>`__, and
   `ArgbEvaluator <#android.animation.ArgbEvaluator>`__ type
   evaluators.

   There is only one method to implement in the
   `TypeEvaluator <#android.animation.TypeEvaluator>`__ interface,
   the
   `evaluate() <#android.animation.TypeEvaluator>`__
   method. This allows the animator that you are using to return an appropriate
   value for your animated property at the current point of the animation. The
   `FloatEvaluator <#android.animation.FloatEvaluator>`__ class
   demonstrates how to do this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private class FloatEvaluator : TypeEvaluator<Any> {

                   override fun evaluate(fraction: Float, startValue: Any, endValue: Any): Any {
                       return (startValue as Number).toFloat().let { startFloat ->
                           startFloat + fraction * ((endValue as Number).toFloat() - startFloat)
                       }
                   }

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class FloatEvaluator implements TypeEvaluator {

                   public Object evaluate(float fraction, Object startValue, Object endValue) {
                       float startFloat = ((Number) startValue).floatValue();
                       return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
                   }
               }

   **Note:** When
   `ValueAnimator <#android.animation.ValueAnimator>`__ (or
   `ObjectAnimator <#android.animation.ObjectAnimator>`__) runs,
   it calculates a current elapsed fraction of the animation (a value between 0
   and 1) and then calculates an interpolated version of that depending on what
   interpolator that you are using. The interpolated fraction is what your
   `TypeEvaluator <#android.animation.TypeEvaluator>`__ receives
   through the ``fraction`` parameter, so you do not have to take into account
   the interpolator when calculating animated values.

   .. rubric:: Use Interpolators
      :name: interpolators

   An interpolator define how specific values in an animation are calculated as
   a function of time. For example, you can specify animations to happen
   linearly across the whole animation, meaning the animation moves evenly the
   entire time, or you can specify animations to use non-linear time, for
   example, using acceleration or deceleration at the beginning or end of the
   animation.

   Interpolators in the animation system receive a fraction from Animators that
   represent the elapsed time of the animation. Interpolators modify this
   fraction to coincide with the type of animation that it aims to provide. The
   Android system provides a set of common interpolators in the
   `android.view.animation package <#android.view.animation.package-summary>`__.
   If none of these suit your needs, you can implement the
   `TimeInterpolator <#android.animation.TimeInterpolator>`__
   interface and create your own.

   As an example, how the default interpolator
   `AccelerateDecelerateInterpolator <#android.view.animation.AccelerateDecelerateInterpolator>`__
   and the
   `LinearInterpolator <#android.view.animation.LinearInterpolator>`__
   calculate interpolated fractions are compared below. The
   `LinearInterpolator <#android.view.animation.LinearInterpolator>`__
   has no effect on the elapsed fraction. The
   `AccelerateDecelerateInterpolator <#android.view.animation.AccelerateDecelerateInterpolator>`__
   accelerates into the animation and decelerates out of it. The following
   methods define the logic for these interpolators:

   **AccelerateDecelerateInterpolator**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun getInterpolation(input: Float): Float =
                       (Math.cos((input + 1) * Math.PI) / 2.0f).toFloat() + 0.5f

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public float getInterpolation(float input) {
                   return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
               }

   **LinearInterpolator**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun getInterpolation(input: Float): Float = input

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public float getInterpolation(float input) {
                   return input;
               }

   The following table represents the approximate values that are calculated by
   these interpolators for an animation that lasts 1000ms:

   +------------+-------------------------------+-------------------------------+
   | ms elapsed | Elapsed fraction/Interpolated | Interpolated fraction         |
   |            | fraction (Linear)             | (Accelerate/Decelerate)       |
   +============+===============================+===============================+
   | 0          | 0                             | 0                             |
   +------------+-------------------------------+-------------------------------+
   | 200        | .2                            | .1                            |
   +------------+-------------------------------+-------------------------------+
   | 400        | .4                            | .345                          |
   +------------+-------------------------------+-------------------------------+
   | 600        | .6                            | .8                            |
   +------------+-------------------------------+-------------------------------+
   | 800        | .8                            | .9                            |
   +------------+-------------------------------+-------------------------------+
   | 1000       | 1                             | 1                             |
   +------------+-------------------------------+-------------------------------+

   As the table shows, the
   `LinearInterpolator <#android.view.animation.LinearInterpolator>`__
   changes the values at the same speed, .2 for every 200ms that passes. The
   `AccelerateDecelerateInterpolator <#android.view.animation.AccelerateDecelerateInterpolator>`__
   changes the values faster than
   `LinearInterpolator <#android.view.animation.LinearInterpolator>`__
   between 200ms and 600ms and slower between 600ms and 1000ms.

   .. rubric:: Specify keyframes
      :name: keyframes

   A `Keyframe <#android.animation.Keyframe>`__ object consists of
   a time/value pair that lets you define a specific state at a specific time of
   an animation. Each keyframe can also have its own interpolator to control the
   behavior of the animation in the interval between the previous keyframe's
   time and the time of this keyframe.

   To instantiate a `Keyframe <#android.animation.Keyframe>`__
   object, you must use one of the factory methods,
   `ofInt() <#android.animation.Keyframe>`__,
   `ofFloat() <#android.animation.Keyframe>`__, or
   `ofObject() <#android.animation.Keyframe>`__ to
   obtain the appropriate type of
   `Keyframe <#android.animation.Keyframe>`__. You then call the
   `ofKeyframe() <#android.animation.PropertyValuesHolder>`__
   factory method to obtain a
   `PropertyValuesHolder <#android.animation.PropertyValuesHolder>`__
   object. Once you have the object, you can obtain an animator by passing in
   the
   `PropertyValuesHolder <#android.animation.PropertyValuesHolder>`__
   object and the object to animate. The following code snippet demonstrates how
   to do this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val kf0 = Keyframe.ofFloat(0f, 0f)
               val kf1 = Keyframe.ofFloat(.5f, 360f)
               val kf2 = Keyframe.ofFloat(1f, 0f)
               val pvhRotation = PropertyValuesHolder.ofKeyframe("rotation", kf0, kf1, kf2)
               ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation).apply {
                   duration = 5000
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Keyframe kf0 = Keyframe.ofFloat(0f, 0f);
               Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);
               Keyframe kf2 = Keyframe.ofFloat(1f, 0f);
               PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe("rotation", kf0, kf1, kf2);
               ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation);
               rotationAnim.setDuration(5000);

   .. rubric:: Animate views
      :name: views

   The property animation system allow streamlined animation of View objects and
   offers a few advantages over the view animation system. The view animation
   system transformed View objects by changing the way that they were drawn.
   This was handled in the container of each View, because the View itself had
   no properties to manipulate. This resulted in the View being animated, but
   caused no change in the View object itself. This led to behavior such as an
   object still existing in its original location, even though it was drawn on a
   different location on the screen. In Android 3.0, new properties and the
   corresponding getter and setter methods were added to eliminate this
   drawback.

   The property animation system can animate Views on the screen by changing the
   actual properties in the View objects. In addition, Views also automatically
   call the `invalidate() <#android.view.View>`__
   method to refresh the screen whenever its properties are changed. The new
   properties in the `View <#android.view.View>`__ class that
   facilitate property animations are:

   -  ``translationX`` and ``translationY``: These properties control where the
      View is located as a delta from its left and top coordinates which are set
      by its layout container.
   -  ``rotation``, ``rotationX``, and ``rotationY``: These properties control
      the rotation in 2D (``rotation`` property) and 3D around the pivot point.
   -  ``scaleX`` and ``scaleY``: These properties control the 2D scaling of a
      View around its pivot point.
   -  ``pivotX`` and ``pivotY``: These properties control the location of the
      pivot point, around which the rotation and scaling transforms occur. By
      default, the pivot point is located at the center of the object.
   -  ``x`` and ``y``: These are simple utility properties to describe the final
      location of the View in its container, as a sum of the left and top values
      and translationX and translationY values.
   -  ``alpha``: Represents the alpha transparency on the View. This value is 1
      (opaque) by default, with a value of 0 representing full transparency (not
      visible).

   To animate a property of a View object, such as its color or rotation value,
   all you need to do is create a property animator and specify the View
   property that you want to animate. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ObjectAnimator.ofFloat(myView, "rotation", 0f, 360f)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ObjectAnimator.ofFloat(myView, "rotation", 0f, 360f);

   For more information on creating animators, see the sections on animating
   with `ValueAnimator <#value-animator>`__ and
   `ObjectAnimator <#object-animator>`__.

   .. rubric:: Animate using ViewPropertyAnimator
      :name: view-prop-animator

   The
   `ViewPropertyAnimator <#android.view.ViewPropertyAnimator>`__
   provides a simple way to animate several properties of a
   `View <#android.view.View>`__ in parallel, using a single
   underlying `Animator <#android.animation.Animator>`__ object.
   It behaves much like an
   `ObjectAnimator <#android.animation.ObjectAnimator>`__, because
   it modifies the actual values of the view's properties, but is more efficient
   when animating many properties at once. In addition, the code for using the
   `ViewPropertyAnimator <#android.view.ViewPropertyAnimator>`__
   is much more concise and easier to read. The following code snippets show the
   differences in using multiple
   `ObjectAnimator <#android.animation.ObjectAnimator>`__ objects,
   a single
   `ObjectAnimator <#android.animation.ObjectAnimator>`__, and the
   `ViewPropertyAnimator <#android.view.ViewPropertyAnimator>`__
   when simultaneously animating the ``x`` and ``y`` property of a view.

   **Multiple ObjectAnimator objects**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val animX = ObjectAnimator.ofFloat(myView, "x", 50f)
               val animY = ObjectAnimator.ofFloat(myView, "y", 100f)
               AnimatorSet().apply {
                   playTogether(animX, animY)
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ObjectAnimator animX = ObjectAnimator.ofFloat(myView, "x", 50f);
               ObjectAnimator animY = ObjectAnimator.ofFloat(myView, "y", 100f);
               AnimatorSet animSetXY = new AnimatorSet();
               animSetXY.playTogether(animX, animY);
               animSetXY.start();

   **One ObjectAnimator**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val pvhX = PropertyValuesHolder.ofFloat("x", 50f)
               val pvhY = PropertyValuesHolder.ofFloat("y", 100f)
               ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat("x", 50f);
               PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat("y", 100f);
               ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start();

   **ViewPropertyAnimator**

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               myView.animate().x(50f).y(100f)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               myView.animate().x(50f).y(100f);

   For more detailed information about
   `ViewPropertyAnimator <#android.view.ViewPropertyAnimator>`__,
   see the corresponding Android Developers 
   `blog post <http://android-developers.blogspot.com/2011/05/introducing-viewpropertyanimator.html>`__.

   .. rubric:: Declare animations in XML
      :name: declaring-xml

   The property animation system lets you declare property animations with XML
   instead of doing it programmatically. By defining your animations in XML, you
   can easily reuse your animations in multiple activities and more easily edit
   the animation sequence.

   To distinguish animation files that use the new property animation APIs from
   those that use the legacy `view animation <#>`__ framework, starting with
   Android 3.1, you should save the XML files for property animations in the
   ``res/animator/`` directory.

   The following property animation classes have XML declaration support with
   the following XML tags:

   -  `ValueAnimator <#android.animation.ValueAnimator>`__ -
      ``<animator>``
   -  `ObjectAnimator <#android.animation.ObjectAnimator>`__ -
      ``<objectAnimator>``
   -  `AnimatorSet <#android.animation.AnimatorSet>`__ - ``<set>``

   To find the attributes that you can use in your XML declaration, see
   `Animation resources <#Property>`__. The
   following example plays the two sets of object animations sequentially, with
   the first nested set playing two object animations together:

   .. code:: prettyprint

      <set android:ordering="sequentially">
          <set>
              <objectAnimator
                  android:propertyName="x"
                  android:duration="500"
                  android:valueTo="400"
                  android:valueType="intType"/>
              <objectAnimator
                  android:propertyName="y"
                  android:duration="500"
                  android:valueTo="300"
                  android:valueType="intType"/>
          </set>
          <objectAnimator
              android:propertyName="alpha"
              android:duration="500"
              android:valueTo="1f"/>
      </set>

   In order to run this animation, you must inflate the XML resources in your
   code to an `AnimatorSet <#android.animation.AnimatorSet>`__
   object, and then set the target objects for all of the animations before
   starting the animation set. Calling
   `setTarget() <#android.animation.AnimatorSet>`__
   sets a single target object for all children of the
   `AnimatorSet <#android.animation.AnimatorSet>`__ as a
   convenience. The following code shows how to do this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               (AnimatorInflater.loadAnimator(myContext, R.animator.property_animator) as AnimatorSet).apply {
                   setTarget(myObject)
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
                   R.animator.property_animator);
               set.setTarget(myObject);
               set.start();

   You can also declare a
   `ValueAnimator <#android.animation.ValueAnimator>`__ in XML, as
   shown in the following example:

   .. code:: prettyprint

      <animator xmlns:android="http://schemas.android.com/apk/res/android"
          android:duration="1000"
          android:valueType="floatType"
          android:valueFrom="0f"
          android:valueTo="-100f" />

   To use the previous
   `ValueAnimator <#android.animation.ValueAnimator>`__ in your
   code, you must inflate the object, add an
   `AnimatorUpdateListener <#android.animation.ValueAnimator.AnimatorUpdateListener>`__,
   get the updated animation value, and use it in a property of one of your
   views, as shown in the following code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               (AnimatorInflater.loadAnimator(this, R.animator.animator) as ValueAnimator).apply {
                   addUpdateListener { updatedAnimation ->
                       textView.translationX = updatedAnimation.animatedValue as Float
                   }

                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ValueAnimator xmlAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(this,
                       R.animator.animator);
               xmlAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
                   @Override
                   public void onAnimationUpdate(ValueAnimator updatedAnimation) {
                       float animatedValue = (float)updatedAnimation.getAnimatedValue();
                       textView.setTranslationX(animatedValue);
                   }
               });

               xmlAnimator.start();

   For information about the XML syntax for defining property animations, see
   `Animation resources <#Property>`__
   .

   .. rubric:: Potential effects on UI performance
      :name: app-health

   Animators that update the UI cause extra rendering work for every frame in
   which the animation runs. For this reason, using resource intensive
   animations can negatively impact the performance of your app.

   Work required to animate your UI is added to the `animation stage <#at>`__ of the rendering
   pipeline. You can find out if your animations impact the performance of your
   app by enabling **Profile GPU Rendering** and monitoring the animation stage.
   For more information, see `Profile GPU rendering walkthrough <#>`__.


Last updated 2024-04-15 UTC.

.. |image-animation-linear| image:: https://developer.android.google.cn/static/images/animation/animation-linear.png
.. |image-animation-nonlinear| image:: https://developer.android.google.cn/static/images/animation/animation-nonlinear.png
.. |image-valueanimator| image:: https://developer.android.google.cn/static/images/animation/valueanimator.png


/Animate drawable graphics
==========================

.. https://developer.android.google.cn/develop/ui/views/animations/drawable-animation?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `Animate vector drawables → <https://developer.android.google.cn/jetpack/compose/animation#animated-vector-resources>`__

      |image-android-compose-ui-logo|

   .. container:: attempt-right

      |image-drawable-animation|
      **Figure 1.** An animated drawable.

   In some situations, images need to be animated. This is useful if you want to
   display a custom loading animation composed of several images or if you want
   an icon to morph after a user's action. Android provides two options for
   animating drawables.

   The first option is to use an `AnimationDrawable <#AnimationDrawable>`__.
   This lets you specify several static `drawable files <#>`__ that display one at a time to
   create an animation. The second option is to use an
   `AnimatedVectorDrawable <#AnimVector>`__, which lets you animate the
   properties of a `vector drawable <#>`__.

   .. rubric:: Use AnimationDrawable
      :name: AnimationDrawable

   One way to create an animation is to load a sequence of drawable resources,
   like a roll of film. The `AnimationDrawable class <#android.graphics.drawable.AnimationDrawable>`__ is the
   basis for these kinds of drawable animations.

   You can define the frames of an animation in your code by using the
   ``AnimationDrawable`` class API, but it's easier to define them with a single
   XML file that lists the frames that make up the animation. The XML file for
   this kind of animation belongs in the ``res/drawable/`` directory of your
   Android project. In this case, the instructions give the order and duration
   for each frame in the animation.

   The XML file consists of an ``<animation-list>`` element as the root node and
   a series of child ``<item>`` nodes that each define a frame—a drawable
   resource and its duration. Here's an example XML file for a ``Drawable``
   animation:

   .. code:: prettyprint

      <animation-list xmlns:android="http://schemas.android.com/apk/res/android"
          android:oneshot="true">
          <item android:drawable="@drawable/rocket_thrust1" android:duration="200" />
          <item android:drawable="@drawable/rocket_thrust2" android:duration="200" />
          <item android:drawable="@drawable/rocket_thrust3" android:duration="200" />
      </animation-list>

   This animation runs for three frames. Setting the ``android:oneshot``
   attribute of the list to ``true`` makes it cycle once and then stop and hold
   on the last frame. If you set ``android:oneshot`` to ``false``, the animation
   loops.

   If you save this XML as ``rocket_thrust.xml`` in the ``res/drawable/``
   directory of the project, you can add it as the background image to a
   ``View`` and then call ``start()`` to make it play. Here's an example of an
   activity in which the animation is added to an
   `ImageView <#android.widget.ImageView>`__ and then animated
   when the screen is touched:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private lateinit var rocketAnimation: AnimationDrawable

            override fun onCreate(savedInstanceState: Bundle?) {
                super.onCreate(savedInstanceState)
                setContentView(R.layout.main)

                val rocketImage = findViewById<ImageView>(R.id.rocket_image).apply {
                    setBackgroundResource(R.drawable.rocket_thrust)
                    rocketAnimation = background as AnimationDrawable
                }

                rocketImage.setOnClickListener({ rocketAnimation.start() })
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            AnimationDrawable rocketAnimation;

            public void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.main);

              ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image);
              rocketImage.setBackgroundResource(R.drawable.rocket_thrust);
              rocketAnimation = (AnimationDrawable) rocketImage.getBackground();

              rocketImage.setOnClickListener(new View.OnClickListener() {
                  @Override
                  public void onClick(View view) {
                    rocketAnimation.start();
                  }
              });
            }

   It's important to note that the ``start()`` method called on the
   ``AnimationDrawable`` can't be called during the ``onCreate()`` method of
   your ``Activity``, because the ``AnimationDrawable`` is not yet fully
   attached to the window. To play the animation immediately, without requiring
   interaction, you can call it from the
   `onStart() <#android.app.Activity>`__ method in your
   ``Activity``, which is called when Android makes the view visible on screen.

   For more information on the XML syntax and available tags and attributes, see
   `Animation resources <#>`__.

   .. rubric:: Use AnimatedVectorDrawable
      :name: AnimVector

   A `vector drawable <#>`__ is a
   type of drawable that is scalable without getting pixelated or blurry. The
   `AnimatedVectorDrawable class <#android.graphics.drawable.AnimatedVectorDrawable>`__—and
   `AnimatedVectorDrawableCompat <#androidx.vectordrawable.graphics.drawable.AnimatedVectorDrawableCompat>`__
   for backward compatibility—lets you animate the properties of a vector
   drawable, such as rotating it or changing the path data to morph it into a
   different image.

   You normally define animated vector drawables in three XML files:

   -  A vector drawable with the ``<vector>`` element in ``res/drawable/``.
   -  An animated vector drawable with the ``<animated-vector>`` element in
      ``res/drawable/``.
   -  One or more object animators with the ``<objectAnimator>`` element in
      ``res/animator/``.

   Animated vector drawables can animate the attributes of the ``<group>`` and
   ``<path>`` elements. The ``<group>`` element defines a set of paths or
   subgroups, and the ``<path>`` element defines paths to be drawn.

   When you define a vector drawable that you want to animate, use the
   ``android:name`` attribute to assign a unique name to groups and paths, so
   you can refer to them from your animator definitions. For example:

   res/drawable/vectordrawable.xml

   .. code:: prettyprint

      <vector xmlns:android="http://schemas.android.com/apk/res/android"
          android:height="64dp"
          android:width="64dp"
          android:viewportHeight="600"
          android:viewportWidth="600">
          <group
              android:name="rotationGroup"
              android:pivotX="300.0"
              android:pivotY="300.0"
              android:rotation="45.0" >
              <path
                  android:name="v"
                  android:fillColor="#000000"
                  android:pathData="M300,70 l 0,-70 70,70 0,0 -70,70z" />
          </group>
      </vector>

   The animated vector drawable definition refers to the groups and paths in the
   vector drawable by their names:

   res/drawable/animatorvectordrawable.xml

   .. code:: prettyprint

      <animated-vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:drawable="@drawable/vectordrawable" >
          <target
              android:name="rotationGroup"
              android:animation="@animator/rotation" />
          <target
              android:name="v"
              android:animation="@animator/path_morph" />
      </animated-vector>

   The animation definitions represent
   `ObjectAnimator <#android.animation.ObjectAnimator>`__ or
   `AnimatorSet <#android.animation.AnimatorSet>`__ objects. The
   first animator in this example rotates the target group 360 degrees:

   res/animator/rotation.xml

   .. code:: prettyprint

      <objectAnimator
          android:duration="6000"
          android:propertyName="rotation"
          android:valueFrom="0"
          android:valueTo="360" />

   The second animator in this example morphs the vector drawable's path from
   one shape to another. The paths must be compatible for morphing: they must
   have the same number of commands and the same number of parameters for each
   command.

   res/animator/path_morph.xml

   .. code:: prettyprint

      <set xmlns:android="http://schemas.android.com/apk/res/android">
          <objectAnimator
              android:duration="3000"
              android:propertyName="pathData"
              android:valueFrom="M300,70 l 0,-70 70,70 0,0   -70,70z"
              android:valueTo="M300,70 l 0,-70 70,0  0,140 -70,0 z"
              android:valueType="pathType" />
      </set>

   Here is the resulting ``AnimatedVectorDrawable``:

   .. container::

      **Figure 2.** An ``AnimatedVectorDrawable``.

   .. rubric:: Animated Vector Drawable (AVD) preview
      :name: AnimVectorPreview

   The Animated Vector Drawable tool in Android Studio lets you preview animated
   drawable resources. This tool helps you preview ``<animation-list>``,
   ``<animated-vector>``, and ``<animated-selector>`` resources in Android
   Studio and makes it easier to refine your custom animations.

   .. container::

      |User previewing and playing an animation inside Android Studio|
      **Figure 3.** The Animated Vector Drawable tool in Android Studio.

   For more information, see the API reference for
   `AnimatedVectorDrawable <#android.graphics.drawable.AnimatedVectorDrawable>`__.


Last updated 2024-03-27 UTC.

.. |image-drawable-animation| image:: https://developer.android.google.cn/static/training/animation/videos/drawable-animation.gif
   :width: 150px
   :height: 150px
.. |User previewing and playing an animation inside Android Studio| image:: https://developer.android.google.cn/static/studio/images/releases/avd-preview.gif


/Generate images between keyframes in an animation
==================================================

.. https://developer.android.google.cn/develop/ui/views/animations/view-animation?hl=en

.. container:: devsite-article-body

   You can use the view animation system to perform tweened animation on Views.
   Tween animation calculates the animation with information such as the start
   point, end point, size, rotation, and other common aspects of an animation.

   A tween animation can perform a series of simple transformations (position,
   size, rotation, and transparency) on the contents of a View object. So, if
   you have a `TextView <#android.widget.TextView>`__ object, you
   can move, rotate, grow, or shrink the text. If it has a background image, the
   background image will be transformed along with the text. The
   `animation package <#android.view.animation.package-summary>`__
   provides all the classes used in a tween animation.

   A sequence of animation instructions defines the tween animation, defined by
   either XML or Android code. As with defining a layout, an XML file is
   recommended because it's more readable, reusable, and swappable than
   hard-coding the animation. In the example below, we use XML. (To learn more
   about defining an animation in your application code, instead of XML, refer
   to the `AnimationSet <#android.view.animation.AnimationSet>`__
   class and other
   `Animation <#android.view.animation.Animation>`__ subclasses.)

   The animation instructions define the transformations that you want to occur,
   when they will occur, and how long they should take to apply. Transformations
   can be sequential or simultaneous - for example, you can have the contents of
   a TextView move from left to right, and then rotate 180 degrees, or you can
   have the text move and rotate simultaneously. Each transformation takes a set
   of parameters specific for that transformation (starting size and ending size
   for size change, starting angle and ending angle for rotation, and so on),
   and also a set of common parameters (for instance, start time and duration).
   To make several transformations happen simultaneously, give them the same
   start time; to make them sequential, calculate the start time plus the
   duration of the preceding transformation.

   The animation XML file belongs in the ``res/anim/`` directory of your Android
   project. The file must have a single root element: this will be either a
   single ``<alpha>``, ``<scale>``, ``<translate>``, ``<rotate>``, interpolator
   element, or ``<set>`` element that holds groups of these elements (which may
   include another ``<set>``). By default, all animation instructions are
   applied simultaneously. To make them occur sequentially, you must specify the
   ``startOffset`` attribute, as shown in the example below.

   The following XML from one of the ApiDemos is used to stretch, then
   simultaneously spin and rotate a View object.

   .. code:: prettyprint

      <set android:shareInterpolator="false">
          <scale
              android:interpolator="@android:anim/accelerate_decelerate_interpolator"
              android:fromXScale="1.0"
              android:toXScale="1.4"
              android:fromYScale="1.0"
              android:toYScale="0.6"
              android:pivotX="50%"
              android:pivotY="50%"
              android:fillAfter="false"
              android:duration="700" />
          <set android:interpolator="@android:anim/decelerate_interpolator">
              <scale
                 android:fromXScale="1.4"
                 android:toXScale="0.0"
                 android:fromYScale="0.6"
                 android:toYScale="0.0"
                 android:pivotX="50%"
                 android:pivotY="50%"
                 android:startOffset="700"
                 android:duration="400"
                 android:fillBefore="false" />
              <rotate
                 android:fromDegrees="0"
                 android:toDegrees="-45"
                 android:toYScale="0.0"
                 android:pivotX="50%"
                 android:pivotY="50%"
                 android:startOffset="700"
                 android:duration="400" />
          </set>
      </set>

   Screen coordinates (not used in this example) are (0,0) at the upper left
   hand corner, and increase as you go down and to the right.

   Some values, such as pivotX, can be specified relative to the object itself
   or relative to the parent. Be sure to use the proper format for what you want
   ("50" for 50% relative to the parent, or "50%" for 50% relative to itself).

   You can determine how a transformation is applied over time by assigning an
   `Interpolator <#android.view.animation.Interpolator>`__.
   Android includes several Interpolator subclasses that specify various speed
   curves: for instance,
   `AccelerateInterpolator <#android.view.animation.AccelerateInterpolator>`__
   tells a transformation to start slow and speed up. Each one has an attribute
   value that can be applied in the XML.

   With this XML saved as ``hyperspace_jump.xml`` in the ``res/anim/`` directory
   of the project, the following code will reference it and apply it to an
   `ImageView <#android.widget.ImageView>`__ object from the
   layout.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump).also { hyperspaceJumpAnimation ->
                findViewById<ImageView>(R.id.spaceshipImage).startAnimation(hyperspaceJumpAnimation)
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            ImageView spaceshipImage = (ImageView) findViewById(R.id.spaceshipImage);
            Animation hyperspaceJumpAnimation = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);
            spaceshipImage.startAnimation(hyperspaceJumpAnimation);

   As an alternative to ``startAnimation()``, you can define a starting time for
   the animation with
   `Animation.setStartTime() <#android.view.animation.Animation>`__,
   then assign the animation to the View with
   `View.setAnimation() <#android.view.View>`__.

   For more information on the XML syntax, available tags and attributes, see
   `Animation Resources <#>`__.

   **Note:** Regardless of how your animation may move or resize, the bounds of
   the View that holds your animation will not automatically adjust to
   accommodate it. Even so, the animation will still be drawn beyond the bounds
   of its View and will not be clipped. However, clipping *will occur* if the
   animation exceeds the bounds of the parent View.


Last updated 2024-02-22 UTC.


/Show or hide a view
====================

.. https://developer.android.google.cn/develop/ui/views/animations/reveal-or-hide-view?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `Crossfade → <https://developer.android.google.cn/jetpack/compose/animation/composables-modifiers#crossfade>`__

      |image-android-compose-ui-logo|

   While your app is being used, new information appears on the screen and old
   information is removed. Changing what shows on the screen immediately can be
   jarring, and users can miss new content that appears suddenly. Animations
   slow down the changes and draw the user's eye with motion so that the updates
   are more obvious.

   **Note:**\  `Jetpack Compose <#>`__ is the preferred way to
   build Android apps. See the Compose
   `Animations <#>`__ documentation.
   There are three common animations you can use to show or hide a view: reveal
   animations, crossfade animations, and cardflip animations.

   .. rubric:: Create a crossfade animation
      :name: Crossfade

   A crossfade animation—also known as a *dissolve*—gradually fades out one
   `View <#android.view.View>`__ or
   `ViewGroup <#android.view.ViewGroup>`__ while simultaneously
   fading in another. This animation is useful for situations where you want to
   switch content or views in your app. The crossfade animation shown here uses
   `ViewPropertyAnimator <#android.view.ViewPropertyAnimator>`__,
   which is available for Android 3.1 (API level 12) and higher.

   Here's an example of a crossfade from a progress indicator to text content:

   .. container:: framed-galaxynexus-land-span-8

      https://developer.android.google.cn/static/training/animation/anim_crossfade.mp4

      **Figure 1.** Crossfade animation.

   .. rubric:: Create the views
      :name: CrossfadeViews

   Create the two views that you want to crossfade. The following example
   creates a progress indicator and a scrollable text view:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
              android:id="@+id/content"
              android:layout_width="match_parent"
              android:layout_height="match_parent">

              <TextView style="?android:textAppearanceMedium"
                  android:lineSpacingMultiplier="1.2"
                  android:layout_width="match_parent"
                  android:layout_height="wrap_content"
                  android:text="@string/lorem_ipsum"
                  android:padding="16dp" />

          </ScrollView>

          <ProgressBar android:id="@+id/loading_spinner"
              style="?android:progressBarStyleLarge"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center" />

      </FrameLayout>

   .. rubric:: Set up the crossfade animation
      :name: CrossfadeSetup

   To set up the crossfade animation, do the following:

   #. Create member variables for the views that you want to crossfade. You need
      these references later when modifying the views during the animation.
   #. Set the visibility of the view that is being faded in to
      `GONE <#android.view.View>`__. This prevents the view
      from using layout space and omits it from layout calculations, which
      speeds up processing
   #. Cache the
      `config_shortAnimTime <#android.R.integer>`__
      system property in a member variable. This property defines a standard
      "short" duration for the animation. This duration is ideal for subtle
      animations or animations that occur frequently.
      `config_longAnimTime <#android.R.integer>`__
      and
      `config_mediumAnimTime <#android.R.integer>`__
      are also available.

   Here's an example using the layout from the previous code snippet as the
   activity content view:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CrossfadeActivity : Activity() {

                   private lateinit var contentView: View
                   private lateinit var loadingView: View
                   private var shortAnimationDuration: Int = 0
                   ...
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_crossfade)

                       contentView = findViewById(R.id.content)
                       loadingView = findViewById(R.id.loading_spinner)

                       // Initially hide the content view.
                       contentView.visibility = View.GONE

                       // Retrieve and cache the system's default "short" animation time.
                       shortAnimationDuration = resources.getInteger(android.R.integer.config_shortAnimTime)
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CrossfadeActivity extends Activity {

                   private View contentView;
                   private View loadingView;
                   private int shortAnimationDuration;
                   ...
                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_crossfade);

                       contentView = findViewById(R.id.content);
                       loadingView = findViewById(R.id.loading_spinner);

                       // Initially hide the content view.
                       contentView.setVisibility(View.GONE);

                       // Retrieve and cache the system's default "short" animation time.
                       shortAnimationDuration = getResources().getInteger(
                               android.R.integer.config_shortAnimTime);
                   }
                   ...
               }

   .. rubric:: Crossfade the views
      :name: CrossfadeAnimate

   When the views are properly set up, crossfade them by doing the following:

   #. For the view that is fading in, set the alpha value to 0 and the
      visibility to `VISIBLE <#android.view.View>`__ from
      its initial setting of ``GONE``. This makes the view visible but
      transparent.
   #. For the view that is fading in, animate its alpha value from 0 to 1. For
      the view that is fading out, animate the alpha value from 1 to 0.
   #. Using
      `onAnimationEnd() <#android.animation.Animator.AnimatorListener>`__
      in an
      `Animator.AnimatorListener <#android.animation.Animator.AnimatorListener>`__,
      set the visibility of the view that is fading out to ``GONE``. Even though
      the alpha value is 0, setting the view's visibility to ``GONE`` prevents
      the view from using layout space and omits it from layout calculations,
      which speeds up processing.

   The following method shows an example of how to do this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CrossfadeActivity : Activity() {

                   private lateinit var contentView: View
                   private lateinit var loadingView: View
                   private var shortAnimationDuration: Int = 0
                   ...
                   private fun crossfade() {
                       contentView.apply {
                           // Set the content view to 0% opacity but visible, so that it is
                           // visible but fully transparent during the animation.
                           alpha = 0f
                           visibility = View.VISIBLE

                           // Animate the content view to 100% opacity and clear any animation
                           // listener set on the view.
                           animate()
                                   .alpha(1f)
                                   .setDuration(shortAnimationDuration.toLong())
                                   .setListener(null)
                       }
                       // Animate the loading view to 0% opacity. After the animation ends,
                       // set its visibility to GONE as an optimization step so it doesn't
                       // participate in layout passes.
                       loadingView.animate()
                               .alpha(0f)
                               .setDuration(shortAnimationDuration.toLong())
                               .setListener(object : AnimatorListenerAdapter() {
                                   override fun onAnimationEnd(animation: Animator) {
                                       loadingView.visibility = View.GONE
                                   }
                               })
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CrossfadeActivity extends Activity {

                   private View contentView;
                   private View loadingView;
                   private int shortAnimationDuration;
                   ...
                   private void crossfade() {

                       // Set the content view to 0% opacity but visible, so that it is
                       // visible but fully transparent during the animation.
                       contentView.setAlpha(0f);
                       contentView.setVisibility(View.VISIBLE);

                       // Animate the content view to 100% opacity and clear any animation
                       // listener set on the view.
                       contentView.animate()
                               .alpha(1f)
                               .setDuration(shortAnimationDuration)
                               .setListener(null);

                       // Animate the loading view to 0% opacity. After the animation ends,
                       // set its visibility to GONE as an optimization step so it doesn't
                       // participate in layout passes.
                       loadingView.animate()
                               .alpha(0f)
                               .setDuration(shortAnimationDuration)
                               .setListener(new AnimatorListenerAdapter() {
                                   @Override
                                   public void onAnimationEnd(Animator animation) {
                                       loadingView.setVisibility(View.GONE);
                                   }
                               });
                   }
               }

   .. rubric:: Create a card flip animation
      :name: CardFlip

   Card flips switch between views of content by showing an animation that
   emulates a card flipping over. The card flip animation shown here uses
   `FragmentTransaction <#androidx.fragment.app.FragmentTransaction>`__.

   Here's what a card flip looks like:

   .. container:: framed-galaxynexus-land-span-8

      https://developer.android.google.cn/static/develop/ui/views/animations/anim_card_flip.mp4

      **Figure 2.** Card flip animation.

   .. rubric:: Create the animator objects
      :name: CardFlipAnimators

   To create the card flip animation, you need four animators. Two animators are
   for when the front of the card animates out and to the left and when it
   animates in and from the left. The other two animators are for when the back
   of the card animates in and from the right and when it animates out and to
   the right.

   card_flip_left_in.xml

   .. code:: prettyprint

      <set xmlns:android="http://schemas.android.com/apk/res/android">
          <!-- Before rotating, immediately set the alpha to 0. -->
          <objectAnimator
              android:valueFrom="1.0"
              android:valueTo="0.0"
              android:propertyName="alpha"
              android:duration="0" />

          <!-- Rotate. -->
          <objectAnimator
              android:valueFrom="-180"
              android:valueTo="0"
              android:propertyName="rotationY"
              android:interpolator="@android:interpolator/accelerate_decelerate"
              android:duration="@integer/card_flip_time_full" />

          <!-- Halfway through the rotation, set the alpha to 1. See startOffset. -->
          <objectAnimator
              android:valueFrom="0.0"
              android:valueTo="1.0"
              android:propertyName="alpha"
              android:startOffset="@integer/card_flip_time_half"
              android:duration="1" />
      </set>

   card_flip_left_out.xml

   .. code:: prettyprint

      <set xmlns:android="http://schemas.android.com/apk/res/android">
          <!-- Rotate. -->
          <objectAnimator
              android:valueFrom="0"
              android:valueTo="180"
              android:propertyName="rotationY"
              android:interpolator="@android:interpolator/accelerate_decelerate"
              android:duration="@integer/card_flip_time_full" />

          <!-- Halfway through the rotation, set the alpha to 0. See startOffset. -->
          <objectAnimator
              android:valueFrom="1.0"
              android:valueTo="0.0"
              android:propertyName="alpha"
              android:startOffset="@integer/card_flip_time_half"
              android:duration="1" />
      </set>

   card_flip_right_in.xml

   .. code:: prettyprint

      <set xmlns:android="http://schemas.android.com/apk/res/android">
          <!-- Before rotating, immediately set the alpha to 0. -->
          <objectAnimator
              android:valueFrom="1.0"
              android:valueTo="0.0"
              android:propertyName="alpha"
              android:duration="0" />

          <!-- Rotate. -->
          <objectAnimator
              android:valueFrom="180"
              android:valueTo="0"
              android:propertyName="rotationY"
              android:interpolator="@android:interpolator/accelerate_decelerate"
              android:duration="@integer/card_flip_time_full" />

          <!-- Halfway through the rotation, set the alpha to 1. See startOffset. -->
          <objectAnimator
              android:valueFrom="0.0"
              android:valueTo="1.0"
              android:propertyName="alpha"
              android:startOffset="@integer/card_flip_time_half"
              android:duration="1" />
      </set>

   card_flip_right_out.xml

   .. code:: prettyprint

      <set xmlns:android="http://schemas.android.com/apk/res/android">
          <!-- Rotate. -->
          <objectAnimator
              android:valueFrom="0"
              android:valueTo="-180"
              android:propertyName="rotationY"
              android:interpolator="@android:interpolator/accelerate_decelerate"
              android:duration="@integer/card_flip_time_full" />

          <!-- Halfway through the rotation, set the alpha to 0. See startOffset. -->
          <objectAnimator
              android:valueFrom="1.0"
              android:valueTo="0.0"
              android:propertyName="alpha"
              android:startOffset="@integer/card_flip_time_half"
              android:duration="1" />
      </set>

   .. rubric:: Create the views
      :name: CardFlipViews

   Each side of the card is a separate layout that can contain any content you
   want, such as two text views, two images, or any combination of views to flip
   between. Use the two layouts in the fragments that you animate later. The
   following layout creates one side of a card, which shows text:

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:orientation="vertical"
          android:background="#a6c"
          android:padding="16dp"
          android:gravity="bottom">

          <TextView android:id="@android:id/text1"
              style="?android:textAppearanceLarge"
              android:textStyle="bold"
              android:textColor="#fff"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="@string/card_back_title" />

          <TextView style="?android:textAppearanceSmall"
              android:textAllCaps="true"
              android:textColor="#80ffffff"
              android:textStyle="bold"
              android:lineSpacingMultiplier="1.2"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="@string/card_back_description" />

      </LinearLayout>

   And the next layout creates the other side of the card, which displays an
   `ImageView <#android.widget.ImageView>`__:

   .. code:: prettyprint

      <ImageView xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:src="@drawable/image1"
          android:scaleType="centerCrop"
          android:contentDescription="@string/description_image_1" />

   .. rubric:: Create the fragments
      :name: CardFlipFragment

   Create fragment classes for the front and back of the card. In your fragment
   classes, return the layouts that you created from the
   `onCreateView() <#android.app.Fragment>`__
   method. You can then create instances of this fragment in the parent activity
   where you want to show the card.

   The following example shows nested fragment classes inside the parent
   activity that uses them:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CardFlipActivity : FragmentActivity() {
                   ...
                   /**

                                   *   A fragment representing the front of the card.
                    */
                   class CardFrontFragment : Fragment() {

                   override fun onCreateView(
                               inflater: LayoutInflater,
                               container: ViewGroup?,
                               savedInstanceState: Bundle?
                   ): View = inflater.inflate(R.layout.fragment_card_front, container, false)
                   }

                   /**
                   *   A fragment representing the back of the card.
                   */
                   class CardBackFragment : Fragment() {

                   override fun onCreateView(
                               inflater: LayoutInflater,
                               container: ViewGroup?,
                               savedInstanceState: Bundle?
                   ): View = inflater.inflate(R.layout.fragment_card_back, container, false)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CardFlipActivity extends FragmentActivity {
                   ...
                   /**
                   *   A fragment representing the front of the card.
                   */
                   public class CardFrontFragment extends Fragment {
                   @Override
                   public View onCreateView(LayoutInflater inflater, ViewGroup container,
                               Bundle savedInstanceState) {
                           return inflater.inflate(R.layout.fragment_card_front, container, false);
                   }
                   }

                   /**
                   *   A fragment representing the back of the card.
                   */
                   public class CardBackFragment extends Fragment {
                   @Override
                   public View onCreateView(LayoutInflater inflater, ViewGroup container,
                               Bundle savedInstanceState) {
                           return inflater.inflate(R.layout.fragment_card_back, container, false);
                   }
                   }
               }

   .. rubric:: Animate the card flip
      :name: CardFlipAnimate

   Display the fragments inside a parent activity. To do this, create the layout
   for your activity. The following example creates a
   `FrameLayout <#android.widget.FrameLayout>`__ that you can add
   fragments to at runtime:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/container"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   In the activity code, set the content view to be the layout that you create.
   It's good practice to show a default fragment when the activity is created.
   The following example activity shows how to display the front of the card by
   default:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CardFlipActivity : FragmentActivity() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_activity_card_flip)
                       if (savedInstanceState == null) {
                           supportFragmentManager.beginTransaction()
                                   .add(R.id.container, CardFrontFragment())
                                   .commit()
                       }
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CardFlipActivity extends FragmentActivity {

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_activity_card_flip);

                       if (savedInstanceState == null) {
                           getSupportFragmentManager()
                                   .beginTransaction()
                                   .add(R.id.container, new CardFrontFragment())
                                   .commit();
                       }
                   }
                   ...
               }

   With the front of the card showing, you can show the back of the card with
   the flip animation at an appropriate time. Create a method to show the other
   side of the card that does the following things:

   -  Sets the custom animations that you created for the fragment transitions.
   -  Replaces the displayed fragment with a new fragment and animates this
      event with the custom animations you created.
   -  Adds the previously displayed fragment to the fragment back stack, so when
      the user taps the Back button, the card flips back over.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CardFlipActivity : FragmentActivity() {
                   ...
                   private fun flipCard() {
                       if (showingBack) {
                           supportFragmentManager.popBackStack()
                           return
                       }

                       // Flip to the back.

                       showingBack = true

                       // Create and commit a new fragment transaction that adds the fragment
                       // for the back of the card, uses custom animations, and is part of the
                       // fragment manager's back stack.

                       supportFragmentManager.beginTransaction()

                               // Replace the default fragment animations with animator
                               // resources representing rotations when switching to the back
                               // of the card, as well as animator resources representing
                               // rotations when flipping back to the front, such as when the
                               // system Back button is tapped.
                               .setCustomAnimations(
                                       R.animator.card_flip_right_in,
                                       R.animator.card_flip_right_out,
                                       R.animator.card_flip_left_in,
                                       R.animator.card_flip_left_out
                               )

                               // Replace any fragments in the container view with a fragment
                               // representing the next page, indicated by the just-incremented
                               // currentPage variable.
                               .replace(R.id.container, CardBackFragment())

                               // Add this transaction to the back stack, letting users press
                               // the Back button to get to the front of the card.
                               .addToBackStack(null)

                               // Commit the transaction.
                               .commit()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CardFlipActivity extends FragmentActivity {
                   ...
                   private void flipCard() {
                       if (showingBack) {
                           getSupportFragmentManager().popBackStack();
                           return;
                       }

                       // Flip to the back.

                       showingBack = true;

                       // Create and commit a new fragment transaction that adds the fragment
                       // for the back of the card, uses custom animations, and is part of the
                       // fragment manager's back stack.

                       getSupportFragmentManager()
                               .beginTransaction()

                               // Replace the default fragment animations with animator
                               // resources representing rotations when switching to the back
                               // of the card, as well as animator resources representing
                               // rotations when flipping back to the front, such as when the
                               // system Back button is pressed.
                               .setCustomAnimations(
                                       R.animator.card_flip_right_in,
                                       R.animator.card_flip_right_out,
                                       R.animator.card_flip_left_in,
                                       R.animator.card_flip_left_out)

                               // Replace any fragments in the container view with a fragment
                               // representing the next page, indicated by the just-incremented
                               // currentPage variable.
                               .replace(R.id.container, new CardBackFragment())

                               // Add this transaction to the back stack, letting users press
                               // Back to get to the front of the card.
                               .addToBackStack(null)

                               // Commit the transaction.
                               .commit();
                   }
               }

   .. rubric:: Create a circular reveal animation
      :name: Reveal

   Reveal animations provide users visual continuity when you show or hide a
   group of UI elements. The
   `ViewAnimationUtils.createCircularReveal() <#android.view.ViewAnimationUtils>`__
   method lets you animate a clipping circle to reveal or hide a view. This
   animation is provided in the
   `ViewAnimationUtils <#android.view.ViewAnimationUtils>`__
   class, which is available for Android 5.0 (API level 21) and higher.

   Here is an example showing how to reveal a previously invisible view:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // A previously invisible view.
               val myView: View = findViewById(R.id.my_view)

               // Check whether the runtime version is at least Android 5.0.
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   // Get the center for the clipping circle.
                   val cx = myView.width / 2
                   val cy = myView.height / 2

                   // Get the final radius for the clipping circle.
                   val finalRadius = Math.hypot(cx.toDouble(), cy.toDouble()).toFloat()

                   // Create the animator for this view. The start radius is 0.
                   val anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0f, finalRadius)
                   // Make the view visible and start the animation.
                   myView.visibility = View.VISIBLE
                   anim.start()
               } else {
                   // Set the view to invisible without a circular reveal animation below
                   // Android 5.0.
                   myView.visibility = View.INVISIBLE
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // A previously invisible view.
               View myView = findViewById(R.id.my_view);

               // Check whether the runtime version is at least Android 5.0.
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   // Get the center for the clipping circle.
                   int cx = myView.getWidth() / 2;
                   int cy = myView.getHeight() / 2;

                   // Get the final radius for the clipping circle.
                   float finalRadius = (float) Math.hypot(cx, cy);

                   // Create the animator for this view. The start radius is 0.
                   Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0f, finalRadius);

                   // Make the view visible and start the animation.
                   myView.setVisibility(View.VISIBLE);
                   anim.start();
               } else {
                   // Set the view to invisible without a circular reveal animation below
                   // Android 5.0.
                   myView.setVisibility(View.INVISIBLE);
               }

   The ``ViewAnimationUtils.createCircularReveal()`` animation takes five
   parameters. The first parameter is the view that you want to hide or show on
   the screen. The next two parameters are the X and Y coordinates for the
   center of the clipping circle. Typically, this is the center of the view, but
   you can also use the point that the user taps so that the animation starts
   where they select. The fourth parameter is the starting radius of the
   clipping circle.

   In the previous example, the initial radius is set to zero so that the view
   being displayed is hidden by the circle. The last parameter is the final
   radius of the circle. When displaying a view, make the final radius larger
   than the view so that the view can be fully revealed before the animation
   finishes.

   To hide a previously visible view, do the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // A previously visible view.
               val myView: View = findViewById(R.id.my_view)

               // Check whether the runtime version is at least Android 5.0.
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   // Get the center for the clipping circle.
                   val cx = myView.width / 2
                   val cy = myView.height / 2

                   // Get the initial radius for the clipping circle.
                   val initialRadius = Math.hypot(cx.toDouble(), cy.toDouble()).toFloat()

                   // Create the animation. The final radius is 0.
                   val anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0f)

                   // Make the view invisible when the animation is done.
                   anim.addListener(object : AnimatorListenerAdapter() {

                       override fun onAnimationEnd(animation: Animator) {
                           super.onAnimationEnd(animation)
                           myView.visibility = View.INVISIBLE
                       }
                   })

                   // Start the animation.
                   anim.start()
               } else {
                   // Set the view to visible without a circular reveal animation below
                   // Android 5.0.
                   myView.visibility = View.VISIBLE
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // A previously visible view.
               final View myView = findViewById(R.id.my_view);

               // Check whether the runtime version is at least Android 5.0.
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   // Get the center for the clipping circle.
                   int cx = myView.getWidth() / 2;
                   int cy = myView.getHeight() / 2;

                   // Get the initial radius for the clipping circle.
                   float initialRadius = (float) Math.hypot(cx, cy);

                   // Create the animation. The final radius is 0.
                   Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, initialRadius, 0f);

                   // Make the view invisible when the animation is done.
                   anim.addListener(new AnimatorListenerAdapter() {
                       @Override
                       public void onAnimationEnd(Animator animation) {
                           super.onAnimationEnd(animation);
                           myView.setVisibility(View.INVISIBLE);
                       }
                   });

                   // Start the animation.
                   anim.start();
               } else {
                   // Set the view to visible without a circular reveal animation below Android
                   // 5.0.
                   myView.setVisibility(View.VISIBLE);
               }

   In this case, the initial radius of the clipping circle is set to be as large
   as the view so that the view is visible before the animation starts. The
   final radius is set to zero so that the view is hidden when the animation
   finishes. Add a listener to the animation so that the view's visibility can
   be set to `INVISIBLE <#android.view.View>`__ when the
   animation completes.

   .. rubric:: Additional resources
      :name: additional-resources

   -  `Animation <#>`__ with Jetpack Compose.
   -  `Gestures <#>`__ with Jetpack Compose.


Last updated 2024-04-15 UTC.



/Move a view using animation
============================

.. https://developer.android.google.cn/develop/ui/views/animations/reposition-view?hl=en

.. container:: devsite-article-body

   Objects on screen often need to be repositioned due to user interaction or
   processing behind the scenes. Instead of immediately updating the object's
   position, which causes it to blink from one area to another, use an animation
   to move it from the starting position to its end position.

   One way that Android lets you reposition your view objects on screen is by
   using `ObjectAnimator <#UseObjectAnimator>`__. You provide the end
   position you want the object to settle in as well as the duration of the
   animation. You can also use time interpolators to control the acceleration or
   deceleration of the animation.

   .. rubric:: Change the view position with ObjectAnimator
      :name: UseObjectAnimator

   The `ObjectAnimator <#android.animation.ObjectAnimator>`__ API
   provides a way to change the properties of a view with a specified duration.
   It contains static methods to create instances of ``ObjectAnimator``
   depending on what type of attribute you are animating. When repositioning
   your views on screen, use the ``translationX`` and ``translationY``
   attributes.

   Here's an example of an ``ObjectAnimator`` that moves the view to a position
   100 pixels from the left of the screen in 2 seconds:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               ObjectAnimator.ofFloat(view, "translationX", 100f).apply {
                   duration = 2000
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ObjectAnimator animation = ObjectAnimator.ofFloat(view, "translationX", 100f);
               animation.setDuration(2000);
               animation.start();

   This example uses the
   `ObjectAnimator.ofFloat() <#android.animation.ObjectAnimator>`__
   method, because the translation values have to be floats. The first parameter
   is the view you want to animate. The second parameter is the property you are
   animating. Since the view needs to move horizontally, the ``translationX``
   property is used. The last parameter is the end value of the animation. In
   this example, the value of 100 indicates a position that many pixels from the
   left of the screen.

   The next method specifies how long the animation takes, in milliseconds. In
   this example, the animation runs for 2 seconds (2000 milliseconds).

   The last method causes the animation to run, which updates the view's
   position on screen.

   For more information about using ``ObjectAnimator``, see `Animate using ObjectAnimator <#object-animator>`__.

   .. rubric:: Add curved motion
      :name: CurvedMotion

   While using the ``ObjectAnimator`` is convenient, by default it repositions
   the view along a straight line between the starting and ending points.
   Material design relies on curves for spatial movement of objects on the
   screen and the timing of an animation. Using curved motion gives your app a
   more material feel while making your animations more interesting.

   .. rubric:: Define your own path
      :name: UsePath

   The ``ObjectAnimator`` class has constructors that let you animate
   coordinates using two or more properties at once along with a path. For
   example, the following animator uses a
   `Path <#android.graphics.Path>`__ object to animate the X and Y
   properties of a view:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   val path = Path().apply {
                       arcTo(0f, 0f, 1000f, 1000f, 270f, -180f, true)
                   }
                   val animator = ObjectAnimator.ofFloat(view, View.X, View.Y, path).apply {
                       duration = 2000
                       start()
                   }
               } else {
                   // Create animator without using curved path
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                 Path path = new Path();
                 path.arcTo(0f, 0f, 1000f, 1000f, 270f, -180f, true);
                 ObjectAnimator animator = ObjectAnimator.ofFloat(view, View.X, View.Y, path);
                 animator.setDuration(2000);
                 animator.start();
               } else {
                 // Create animator without using curved path
               }

   Here is what the arc animation looks like:

   https://developer.android.google.cn/static/training/animation/videos/curved_path_animation.mp4

   **Figure 1.** A curved path animation.

   An `Interpolator <#interpolators>`__
   is an implementation of an easing curve. See the 
   `Material Design documentation <https://m3.material.io/styles/motion/easing-and-duration/applying-easing-and-duration>`__
   for more information about the concept of easing curves. An ``Interpolator``
   defines how specific values in an animation are calculated as a function of
   time. The system provides XML resources for the three basic curves in the
   Material Design specification:

   -  ``@interpolator/fast_out_linear_in.xml``
   -  ``@interpolator/fast_out_slow_in.xml``
   -  ``@interpolator/linear_out_slow_in.xml``

   .. rubric:: Use PathInterpolator
      :name: UsePathInterpolator

   The
   `PathInterpolator <#android.view.animation.PathInterpolator>`__
   class is an interpolator introduced in Android 5.0 (API 21). It is based on a
   `Bézier curve <https://en.wikipedia.org/wiki/B%C3%A9zier_curve>`__ or a
   ``Path`` object. The Android examples in the 
   `Material Design documentation for easing <https://m3.material.io/styles/motion/easing-and-duration/tokens-specs#433b1153-2ea3-4fe2-9748-803a47bc97ee>`__
   use ``PathInterpolator``.

   ``PathInterpolator`` has constructors based on different types of Bézier
   curves. All Bézier curves have start and end points fixed at ``(0,0)`` and
   ``(1,1)``, respectively. The other constructor arguments depend on the type
   of Bézier curve being created.

   For example, for a quadratic Bézier curve only the X and Y coordinates of one
   control point are needed:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myInterpolator = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   PathInterpolator(0.67f, 0.33f)
               } else {
                   LinearInterpolator()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Interpolator myInterpolator = null;
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                 myInterpolator = new PathInterpolator(0.67f, 0.33f);
               } else {
                 myInterpolator = new LinearInterpolator();
               }

   This produces an easing curve that starts quickly and decelerates as it
   approaches the end.

   The cubic Bézier constructor similarly has fixed start and end points, but it
   requires two control points:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myInterpolator = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   PathInterpolator(0.5f, 0.7f, 0.1f, 1.0f)
               } else {
                   LinearInterpolator()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Interpolator myInterpolator = null;
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                 myInterpolator = new PathInterpolator(0.5f, 0.7f, 0.1f, 1.0f);
               } else {
                 myInterpolator = new LinearInterpolator();
               }

   This is an implementation of the Material Design 
   `emphasized decelerate <https://m3.material.io/styles/motion/easing-and-duration/tokens-specs#cbea5c6e-7b0d-47a0-98c3-767080a38d95>`__
   easing curve.

   For greater control, an arbitrary ``Path`` can be used to define the curve:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val myInterpolator = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                 val path = Path().apply {
                   moveTo(0.0f, 0.0f)
                   cubicTo(0.5f, 0.7f, 0.1f, 1.0f, 1.0f, 1.0f)
                 }
                 PathInterpolator(path)
               } else {
                 LinearInterpolator()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Interpolator myInterpolator = null;
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                 Path path = new Path();
                 path.moveTo(0.0f, 0.0f);
                 path.cubicTo(0.5f, 0.7f, 0.1f, 1.0f, 1.0f, 1.0f);
                 myInterpolator = new PathInterpolator(path);
               } else {
                 myInterpolator = new LinearInterpolator();
               }

   This produces the same easing curve as the cubic Bézier example, but it uses
   a ``Path`` instead.

   You can also define a path interpolator as an XML resource:

   .. code:: prettyprint

      <pathInterpolator xmlns:android="http://schemas.android.com/apk/res/android"
          android:controlX1="0.5"
          android:controlY1="0.7"
          android:controlX2="0.1f"
          android:controlY2="1.0f"/>

   Once you create a ``PathInterpolator`` object, you can pass it to the
   `Animator.setInterpolator() <#android.animation.Animator>`__
   method. The ``Animator`` uses the interpolator to determine the timing or
   path curve when it is started.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val animation = ObjectAnimator.ofFloat(view, "translationX", 100f).apply {
                   interpolator = myInterpolator
                   start()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ObjectAnimator animation = ObjectAnimator.ofFloat(view, "translationX", 100f);
               animation.setInterpolator(myInterpolator);
               animation.start();


Last updated 2024-02-22 UTC.


/Move a view using fling animation
==================================

.. https://developer.android.google.cn/develop/ui/views/animations/fling-animation?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `Spring AnimationSpec → <https://developer.android.google.cn/jetpack/compose/animation#spring>`__

      |image-android-compose-ui-logo|

   Fling-based animation uses a friction force that is proportional to an
   object's velocity. Use it to animate a property of an object and to end the
   animation gradually. It has an initial momentum, which is mostly received
   from the gesture velocity, and gradually slows down. The animation comes to
   an end when the velocity of the animation is low enough that it makes no
   visible change on the device screen.

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/graphics/fling-animation.gif

      **Figure 1.** Fling animation

   To learn about related topics, read the following guides:

   -  `Physics-based motion <#physics-based>`__
   -  `Animate movement using spring physics <#>`__

   .. rubric:: Add the AndroidX library
      :name: add-support-library

   To use the physics-based animations, you must add the AndroidX library to
   your project as follows:

   #. Open the ``build.gradle`` file for your app module.
   #. Add the AndroidX library to the ``dependencies`` section.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy

               .. code:: prettyprint

                    dependencies {
                        implementation 'androidx.dynamicanimation:dynamicanimation:1.0.0'
                    }
                    

            .. container:: section

               .. rubric:: Kotlin
                  :name: kts

               .. code:: prettyprint

                    dependencies {
                        implementation("androidx.dynamicanimation:dynamicanimation:1.0.0")
                    }
                          

   .. rubric:: Create a fling animation
      :name: creating-fling-animation

   The `FlingAnimation <#androidx.dynamicanimation.animation.FlingAnimation>`__
   class lets you create a fling animation for an object. To build a fling
   animation, create an instance of the
   `FlingAnimation <#androidx.dynamicanimation.animation.FlingAnimation>`__
   class and provide an object and the object's property that you want to
   animate.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            val fling = FlingAnimation(view, DynamicAnimation.SCROLL_X)

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X);

   .. rubric:: Set velocity
      :name: setting-velocity

   The starting velocity defines the speed at which an animation property
   changes at the beginning of the animation. The default starting velocity is
   set to zero pixels per second. Therefore, you must define a start velocity to
   ensure the animation does not end right away.

   You can use a fixed value as the starting velocity, or you can base it off of
   the velocity of a touch gesture. If you choose to provide a fixed value, you
   should define the value in dp per second, then convert it to pixels per
   second. Defining the value in dp per second allows the velocity to be
   independent of a device's density and form factors. For more information
   about converting the starting velocity to pixels per second, refer to the
   `Converting dp per second to pixels per second <#converting-value>`__
   section in `Spring Animation <#>`__.

   To set the velocity, call the ``setStartVelocity()`` method and pass the
   velocity in pixels per second. The method returns the fling object on which
   the velocity is set.

   **Note:** Use the
   `GestureDetector.OnGestureListener <#android.view.GestureDetector.OnGestureListener>`__
   and the `VelocityTracker <#android.view.VelocityTracker>`__
   classes to retrieve and compute the velocity of touch gestures, respectively.

   .. rubric:: Set an animation value range
      :name: setting-animation-value-range

   You can set the minimum and the maximum animation values when you want to
   restrain the property value to a certain range. This range control is
   particularly useful when you animate properties that have an intrinsic range,
   such as alpha (from 0 to 1).

   **Note**: When the value of a fling animation reaches the minimum or maximum
   value, the animation ends.

   To set the minimum and maximum values, call the ``setMinValue()`` and
   ``setMaxValue()`` methods, respectively. Both methods return the animation
   object for which you have set the value.

   .. rubric:: Set friction
      :name: setting-friction

   The ``setFriction()`` method lets you change the animation's friction. It
   defines how quickly the velocity decreases in an animation.

   **Note**: If you don't set the friction at the beginning of the animation,
   the animation uses a default friction value of 1.

   The method returns the object whose animation uses the friction value you
   provide.

   .. rubric:: Sample code
      :name: sample-code

   The example below illustrates a horizontal fling. The velocity captured from
   the velocity tracker is ``velocityX`` and, the scroll bounds are set to 0 and
   maxScroll. The friction is set to 1.1.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            FlingAnimation(view, DynamicAnimation.SCROLL_X).apply {
                setStartVelocity(-velocityX)
                setMinValue(0f)
                setMaxValue(maxScroll)
                friction = 1.1f
                start()
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            FlingAnimation fling = new FlingAnimation(view, DynamicAnimation.SCROLL_X);
            fling.setStartVelocity(-velocityX)
                    .setMinValue(0)
                    .setMaxValue(maxScroll)
                    .setFriction(1.1f)
                    .start();

   .. rubric:: Set the minimum visible change
      :name: setting-minimum-visible-change

   When you animate a custom property that isn't defined in pixels, you should
   set the minimal change of animation value that is visible to users. It
   determines a reasonable threshold for ending the animation.

   It isn't necessary to call this method when animating
   `DynamicAnimation.ViewProperty <#androidx.dynamicanimation.animation.DynamicAnimation.ViewProperty>`__
   because the minimum visible change is derived from the property. For example:

   -  The default minimum visible change value is 1 pixel for view properties
      such as ``TRANSLATION_X``, ``TRANSLATION_Y``, ``TRANSLATION_Z``,
      ``SCROLL_X``, and ``SCROLL_Y``.
   -  For animations that use rotation, such as ``ROTATION``, ``ROTATION_X``,
      and ``ROTATION_Y``, the minimum visible change is
      ``MIN_VISIBLE_CHANGE_ROTATION_DEGREES``, or 1/10 pixel.
   -  For animations that use opacity, the minimum visible change is
      ``MIN_VISIBLE_CHANGE_ALPHA``, or 1/256.

   To set the minimum visible change for an animation, call the
   ``setMinimumVisibleChange()`` method and pass either one of the minimum
   visible constants or a value that you need to calculate for a custom
   property. For more information on calculating this value, refer to the
   `Calculating a minimum visible change value <#calculating-mvc-value>`__
   section.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            anim.minimumVisibleChange = DynamicAnimation.MIN_VISIBLE_CHANGE_SCALE

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            anim.setMinimumVisibleChange(DynamicAnimation.MIN_VISIBLE_CHANGE_SCALE);

   **Note**: You need to pass a value only when you animate a custom property
   that is not defined in pixels.

   .. rubric:: Calculating a minimum visible change value
      :name: calculating-mvc-value

   To calculate the minimum visible change value for a custom property, use the
   following formula:

   Minimum visible change = Range of custom property value / Range of animiation
   in pixels

   For example, the property that you want to animate progresses from 0 to 100.
   This corresponds to a 200-pixel change. Per the formula, the minimum visible
   change value is 100 / 200 is equal to 0.5 pixels.


Last updated 2024-05-03 UTC.



/Enlarge a view using zoom animation
====================================

.. https://developer.android.google.cn/develop/ui/views/animations/zoom?hl=en

.. container:: devsite-article-body

   **Note:** `Jetpack Compose <#>`__ is the best way to build
   Android apps. It makes animating views easier and intuitive. Learn about
   `multi-touch in the Gestures document <#multitouch>`__.
   This guide demonstrates how to implement a tap-to-zoom animation. Tap-to-zoom
   lets apps, such as photo galleries, animate a view from a thumbnail to fill
   the screen.

   Here's what a tap-to-zoom animation looks like when it expands a thumbnail to
   fill the screen:

   For a full working example, see the ``UIAnimation`` class from the
   `WearSpeakerSample <https://github.com/android/wear-os-samples/tree/main/WearSpeakerSample>`__
   project on GitHub.

   .. rubric:: Create the views
      :name: views

   Create a layout file that contains the small and large version of the content
   you want to zoom. The following example creates an
   `ImageButton <#android.widget.ImageButton>`__ for a tappable
   image thumbnail and an
   `ImageView <#android.widget.ImageView>`__ that displays the
   enlarged view of the image:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/container"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <LinearLayout android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:orientation="vertical"
              android:padding="16dp">

              <ImageButton
                  android:id="@+id/thumb_button_1"
                  android:layout_width="100dp"
                  android:layout_height="75dp"
                  android:layout_marginRight="1dp"
                  android:src="@drawable/thumb1"
                  android:scaleType="centerCrop"
                  android:contentDescription="@string/description_image_1" />

          </LinearLayout>

          <!-- This initially hidden ImageView holds the zoomed version of
               the preceding images. Without transformations applied, it fills the entire
               screen. To achieve the zoom animation, this view's bounds are animated
               from the bounds of the preceding thumbnail button to its final laid-out
               bounds.
               -->

          <ImageView
              android:id="@+id/expanded_image"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:visibility="invisible"
              android:contentDescription="@string/description_zoom_touch_close" />

      </FrameLayout>

   .. rubric:: Set up the zoom animation
      :name: setup

   Once you apply your layout, set up the event handlers that trigger the zoom
   animation. The following example adds a
   `View.OnClickListener <#android.view.View.OnClickListener>`__
   to the ``ImageButton`` to execute the zoom animation when the user taps the
   image button:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class ZoomActivity : FragmentActivity() {

                // Hold a reference to the current animator so that it can be canceled
                // midway.
                private var currentAnimator: Animator? = null

                // The system "short" animation time duration in milliseconds. This duration
                // is ideal for subtle animations or animations that occur frequently.
                private var shortAnimationDuration: Int = 0

                override fun onCreate(savedInstanceState: Bundle?) {
                    super.onCreate(savedInstanceState)
                    setContentView(R.layout.activity_zoom)

                    // Hook up taps on the thumbnail views.

                    binding.thumbButton1.setOnClickListener {
                        zoomImageFromThumb(thumb1View, R.drawable.image1)
                    }

                    // Retrieve and cache the system's default "short" animation time.
                    shortAnimationDuration = resources.getInteger(android.R.integer.config_shortAnimTime)
                }
                ...
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class ZoomActivity extends FragmentActivity {
                // Hold a reference to the current animator so that it can be canceled
                // mid-way.
                private Animator currentAnimator;

                // The system "short" animation time duration in milliseconds. This duration
                // is ideal for subtle animations or animations that occur frequently.
                private int shortAnimationDuration;

                @Override
                protected void onCreate(Bundle savedInstanceState) {
                    super.onCreate(savedInstanceState);
                    setContentView(R.layout.activity_zoom);

                    // Hook up taps on the thumbnail views.

                    binding.thumbButton1.setOnClickListener(new View.OnClickListener() {
                        @Override
                        public void onClick(View view) {
                            zoomImageFromThumb(thumb1View, R.drawable.image1);
                        }
                    });

                    // Retrieve and cache the system's default "short" animation time.
                    shortAnimationDuration = getResources().getInteger(
                            android.R.integer.config_shortAnimTime);
                }
                ...
            }

   .. rubric:: Zoom the view
      :name: animate

   Animate from the normal-sized view to the zoomed view when appropriate. In
   general, you need to animate from the bounds of the normal-sized view to the
   bounds of the larger-sized view. The following methods show how to implement
   a zoom animation that zooms from a thumbnail to an enlarged view. To do so,
   assign the high-res image to the hidden "zoomed-in" (enlarged)
   `ImageView <#android.widget.ImageView>`__.

   The following example loads a large image resource on the UI thread for
   simplicity. Load it in a separate thread to prevent blocking on the UI
   thread, and then set the bitmap on the UI thread. Generally, the bitmap must
   not be larger than the screen size. Next, calculate the starting and ending
   bounds for the ``ImageView``.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

             private fun zoomImageFromThumb(thumbView: View, imageResId: Int) {
                 // If there's an animation in progress, cancel it immediately and
                 // proceed with this one.
                 currentAnimator?.cancel()

                 // Load the high-resolution "zoomed-in" image.
                 binding.expandedImage.setImageResource(imageResId)

                 // Calculate the starting and ending bounds for the zoomed-in image.
                 val startBoundsInt = Rect()
                 val finalBoundsInt = Rect()
                 val globalOffset = Point()

                 // The start bounds are the global visible rectangle of the thumbnail,
                 // and the final bounds are the global visible rectangle of the
                 // container view. Set the container view's offset as the origin for the
                 // bounds, since that's the origin for the positioning animation
                 // properties (X, Y).
                 thumbView.getGlobalVisibleRect(startBoundsInt)
                 binding.container.getGlobalVisibleRect(finalBoundsInt, globalOffset)
                 startBoundsInt.offset(-globalOffset.x, -globalOffset.y)
                 finalBoundsInt.offset(-globalOffset.x, -globalOffset.y)

                 val startBounds = RectF(startBoundsInt)
                 val finalBounds = RectF(finalBoundsInt)

                 // Using the "center crop" technique, adjust the start bounds to be the
                 // same aspect ratio as the final bounds. This prevents unwanted
                 // stretching during the animation. Calculate the start scaling factor.
                 // The end scaling factor is always 1.0.
                 val startScale: Float
                 if ((finalBounds.width() / finalBounds.height() > startBounds.width() / startBounds.height())) {
                     // Extend start bounds horizontally.
                     startScale = startBounds.height() / finalBounds.height()
                     val startWidth: Float = startScale * finalBounds.width()
                     val deltaWidth: Float = (startWidth - startBounds.width()) / 2
                     startBounds.left -= deltaWidth.toInt()
                     startBounds.right += deltaWidth.toInt()
                 } else {
                     // Extend start bounds vertically.
                     startScale = startBounds.width() / finalBounds.width()
                     val startHeight: Float = startScale * finalBounds.height()
                     val deltaHeight: Float = (startHeight - startBounds.height()) / 2f
                     startBounds.top -= deltaHeight.toInt()
                     startBounds.bottom += deltaHeight.toInt()
                 }

                 // Hide the thumbnail and show the zoomed-in view. When the animation
                 // begins, it positions the zoomed-in view in the place of the
                 // thumbnail.
                 thumbView.alpha = 0f

                 animateZoomToLargeImage(startBounds, finalBounds, startScale)

                 setDismissLargeImageAnimation(thumbView, startBounds, startScale)
             }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

             private void zoomImageFromThumb(final View thumbView, int imageResId) {
                 // If there's an animation in progress, cancel it immediately and
                 // proceed with this one.
                 if (currentAnimator != null) {
                     currentAnimator.cancel();
                 }

                 // Load the high-resolution "zoomed-in" image.
                 binding.expandedImage.setImageResource(imageResId);

                 // Calculate the starting and ending bounds for the zoomed-in image.
                 final Rect startBounds = new Rect();
                 final Rect finalBounds = new Rect();
                 final Point globalOffset = new Point();

                 // The start bounds are the global visible rectangle of the thumbnail,
                 // and the final bounds are the global visible rectangle of the
                 // container view. Set the container view's offset as the origin for the
                 // bounds, since that's the origin for the positioning animation
                 // properties (X, Y).
                 thumbView.getGlobalVisibleRect(startBounds);
                 findViewById(R.id.container)
                         .getGlobalVisibleRect(finalBounds, globalOffset);
                 startBounds.offset(-globalOffset.x, -globalOffset.y);
                 finalBounds.offset(-globalOffset.x, -globalOffset.y);

                 // Using the "center crop" technique, adjust the start bounds to be the
                 // same aspect ratio as the final bounds. This prevents unwanted
                 // stretching during the animation. Calculate the start scaling factor.
                 // The end scaling factor is always 1.0.
                 float startScale;
                 if ((float) finalBounds.width() / finalBounds.height()
                         > (float) startBounds.width() / startBounds.height()) {
                     // Extend start bounds horizontally.
                     startScale = (float) startBounds.height() / finalBounds.height();
                     float startWidth = startScale * finalBounds.width();
                     float deltaWidth = (startWidth - startBounds.width()) / 2;
                     startBounds.left -= deltaWidth;
                     startBounds.right += deltaWidth;
                 } else {
                     // Extend start bounds vertically.
                     startScale = (float) startBounds.width() / finalBounds.width();
                     float startHeight = startScale * finalBounds.height();
                     float deltaHeight = (startHeight - startBounds.height()) / 2;
                     startBounds.top -= deltaHeight;
                     startBounds.bottom += deltaHeight;
                 }

                 // Hide the thumbnail and show the zoomed-in view. When the animation
                 // begins, it positions the zoomed-in view in the place of the
                 // thumbnail.
                 thumbView.setAlpha(0f);

                 animateZoomToLargeImage(startBounds, finalBounds, startScale);

                 setDismissLargeImageAnimation(thumbView, startBounds, startScale);
             }

   Animate the four positioning and sizing
   properties—`X <#android.view.View>`__, `Y <#android.view.View>`__,
   `SCALE_X <#android.view.View>`__, and
   `SCALE_Y <#android.view.View>`__—simultaneously, from
   the starting bounds to the ending bounds. Add these four animations to an
   `AnimatorSet <#android.animation.AnimatorSet>`__ so that they
   start at the same time.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

             private fun animateZoomToLargeImage(startBounds: RectF, finalBounds: RectF, startScale: Float) {
                 binding.expandedImage.visibility = View.VISIBLE

                 // Set the pivot point for SCALE_X and SCALE_Y transformations to the
                 // top-left corner of the zoomed-in view. The default is the center of
                 // the view.
                 binding.expandedImage.pivotX = 0f
                 binding.expandedImage.pivotY = 0f

                 // Construct and run the parallel animation of the four translation and
                 // scale properties: X, Y, SCALE_X, and SCALE_Y.
                 currentAnimator = AnimatorSet().apply {
                     play(
                         ObjectAnimator.ofFloat(
                             binding.expandedImage,
                             View.X,
                             startBounds.left,
                             finalBounds.left)
                     ).apply {
                         with(ObjectAnimator.ofFloat(binding.expandedImage, View.Y, startBounds.top, finalBounds.top))
                         with(ObjectAnimator.ofFloat(binding.expandedImage, View.SCALE_X, startScale, 1f))
                         with(ObjectAnimator.ofFloat(binding.expandedImage, View.SCALE_Y, startScale, 1f))
                     }
                     duration = shortAnimationDuration.toLong()
                     interpolator = DecelerateInterpolator()
                     addListener(object : AnimatorListenerAdapter() {

                         override fun onAnimationEnd(animation: Animator) {
                             currentAnimator = null
                         }

                         override fun onAnimationCancel(animation: Animator) {
                             currentAnimator = null
                         }
                     })
                     start()
                 }
             }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

             private void animateZoomToLargeImage(Rect startBounds, Rect finalBounds, Float startScale) {

                 binding.expandedImage.setVisibility(View.VISIBLE);

                 // Set the pivot point for SCALE_X and SCALE_Y transformations to the
                 // top-left corner of the zoomed-in view. The default is the center of
                 // the view.
                 binding.expandedImage.setPivotX(0f);
                 binding.expandedImage.setPivotY(0f);

                 // Construct and run the parallel animation of the four translation and
                 // scale properties: X, Y, SCALE_X, and SCALE_Y.
                 AnimatorSet set = new AnimatorSet();
                 set
                         .play(ObjectAnimator.ofFloat(binding.expandedImage, View.X,
                                 startBounds.left, finalBounds.left))
                         .with(ObjectAnimator.ofFloat(binding.expandedImage, View.Y,
                                 startBounds.top, finalBounds.top))
                         .with(ObjectAnimator.ofFloat(binding.expandedImage, View.SCALE_X,
                                 startScale, 1f))
                         .with(ObjectAnimator.ofFloat(binding.expandedImage,
                                 View.SCALE_Y, startScale, 1f));
                 set.setDuration(shortAnimationDuration);
                 set.setInterpolator(new DecelerateInterpolator());
                 set.addListener(new AnimatorListenerAdapter() {
                     @Override
                     public void onAnimationEnd(Animator animation) {
                         currentAnimator = null;
                     }

                     @Override
                     public void onAnimationCancel(Animator animation) {
                         currentAnimator = null;
                     }
                 });
                 set.start();
                 currentAnimator = set;
             }

   Zoom out by running a similar animation in reverse when the user taps the
   screen while the image is zoomed in. Add a ``View.OnClickListener`` to the
   ``ImageView``. When tapped, the ``ImageView`` minimizes to the size of the
   image thumbnail and sets its visibility to
   `GONE <#android.view.View>`__ to hide it.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

                private fun setDismissLargeImageAnimation(thumbView: View, startBounds: RectF, startScale: Float) {
                    // When the zoomed-in image is tapped, it zooms down to the original
                    // bounds and shows the thumbnail instead of the expanded image.
                    binding.expandedImage.setOnClickListener {
                        currentAnimator?.cancel()

                        // Animate the four positioning and sizing properties in parallel,
                        // back to their original values.
                        currentAnimator = AnimatorSet().apply {
                            play(ObjectAnimator.ofFloat(binding.expandedImage, View.X, startBounds.left)).apply {
                                with(ObjectAnimator.ofFloat(binding.expandedImage, View.Y, startBounds.top))
                                with(ObjectAnimator.ofFloat(binding.expandedImage, View.SCALE_X, startScale))
                                with(ObjectAnimator.ofFloat(binding.expandedImage, View.SCALE_Y, startScale))
                            }
                            duration = shortAnimationDuration.toLong()
                            interpolator = DecelerateInterpolator()
                            addListener(object : AnimatorListenerAdapter() {

                                override fun onAnimationEnd(animation: Animator) {
                                    thumbView.alpha = 1f
                                    binding.expandedImage.visibility = View.GONE
                                    currentAnimator = null
                                }

                                override fun onAnimationCancel(animation: Animator) {
                                    thumbView.alpha = 1f
                                    binding.expandedImage.visibility = View.GONE
                                    currentAnimator = null
                                }
                            })
                            start()
                        }
                    }
                }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

                private void setDismissLargeImageAnimation(View thumbView, Rect startBounds, Float startScale) {
                    // When the zoomed-in image is tapped, it zooms down to the original
                    // bounds and shows the thumbnail instead of the expanded image.
                    final float startScaleFinal = startScale;
                    binding.expandedImage.setOnClickListener(new View.OnClickListener() {
                        @Override
                        public void onClick(View view) {
                            if (currentAnimator != null) {
                                currentAnimator.cancel();
                            }

                            // Animate the four positioning and sizing properties in
                            // parallel, back to their original values.
                            AnimatorSet set = new AnimatorSet();
                            set.play(ObjectAnimator
                                            .ofFloat(binding.expandedImage, View.X, startBounds.left))
                                    .with(ObjectAnimator
                                            .ofFloat(binding.expandedImage,
                                                    View.Y,startBounds.top))
                                    .with(ObjectAnimator
                                            .ofFloat(binding.expandedImage,
                                                    View.SCALE_X, startScaleFinal))
                                    .with(ObjectAnimator
                                            .ofFloat(binding.expandedImage,
                                                    View.SCALE_Y, startScaleFinal));
                            set.setDuration(shortAnimationDuration);
                            set.setInterpolator(new DecelerateInterpolator());
                            set.addListener(new AnimatorListenerAdapter() {
                                @Override
                                public void onAnimationEnd(Animator animation) {
                                    thumbView.setAlpha(1f);
                                    binding.expandedImage.setVisibility(View.GONE);
                                    currentAnimator = null;
                                }

                                @Override
                                public void onAnimationCancel(Animator animation) {
                                    thumbView.setAlpha(1f);
                                    binding.expandedImage.setVisibility(View.GONE);
                                    currentAnimator = null;
                                }
                            });
                            set.start();
                            currentAnimator = set;
                        }
                    });
                }


Last updated 2024-02-22 UTC.


/Animate movement using spring physics
======================================

.. https://developer.android.google.cn/develop/ui/views/animations/spring-animation?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `Spring AnimationSpec → <https://developer.android.google.cn/jetpack/compose/animation/customize#spring>`__

      |image-android-compose-ui-logo|

   `Physics-based motion <#physics-based>`__ is
   driven by force. Spring force is one such force that guides interactivity and
   motion. A spring force has the following properties: damping and stiffness.
   In a spring-based animation, the value and the velocity are calculated based
   on the spring force that are applied on each frame.

   If you'd like your app's animations to slow down in only one direction,
   consider using a friction-based `fling animation <#>`__ instead.

   .. rubric:: Lifecycle of a spring animation
      :name: lifecycle-of-spring-animation

   In a spring-based animation, the
   `SpringForce <#androidx.dynamicanimation.animation.SpringForce>`__
   class lets you customize spring's stiffness, its damping ratio, and its final
   position. As soon as the animation begins, the spring force updates the
   animation value and the velocity on each frame. The animation continues until
   the spring force reaches an equilibrium.

   For example, if you drag an app icon around the screen and later release it
   by lifting your finger from the icon, the icon tugs back to its original
   place by an invisible but a familiar force.

   Figure 1 demonstrates a similar spring effect. The plus sign (+) sign in the
   middle of the circle indicates the force applied through a touch gesture.

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/graphics/spring-release.gif
      :alt: Spring release

      **Figure 1.** Spring release effect

   .. rubric:: Build a spring animation
      :name: building-spring-animation

   The general steps for building a spring animation for your application are as
   follows:

   -  `Add the support library <#adding-support-library>`__ You must add the
      support library to your project to use the spring animation classes.

   -  `Create a spring animation: <#creating-spring-animation>`__ The primary
      step is to create an instance of the
      `SpringAnimation <#androidx.dynamicanimation.animation.SpringAnimation>`__
      class and set the motion behavior parameters.

   -  `(Optional) Register listeners: <#registering-listeners>`__ Register
      listeners to watch for animation lifecycle changes and animation value
      updates.

      **Note:** Update listener should be registered only if you need per-frame
      update on the animation value changes. An update listener prevents the
      animation from potentially running on a separate thread.

   -  `(Optional) Remove listeners: <#removing-listeners>`__ Remove listeners
      that are no longer in use.

   -  `(Optional) Set a start value: <#setting-start-value>`__ Customize the
      animation start value.

   -  `(Optional) Set a value range: <#setting-value-range>`__ Set the animation
      value range to restrain values within the minimum and the maximum range.

   -  `(Optional) Set start velocity: <#setting-velocity>`__ Set the start
      velocity for the animation.

   -  `(Optional) Set spring properties: <#setting-properties>`__ Set the
      damping ratio and the stiffness on the spring.

   -  `(Optional) Create a custom spring: <#using-custom-spring>`__ Create a
      custom spring in case you do not intend to use the default spring or want
      to use a common spring throughout the animation.

   -  `Start animation: <#starting-animation>`__ Start the spring animation.

   -  `(Optional) Cancel animation: <#cancelling-animation>`__ Cancel the
      animation in case the user abruptly exits the app or the view becomes
      invisble.

   The following sections discuss the general steps of building a spring
   animation in detail.

   .. rubric:: Add the support library
      :name: add-support-library

   To use the physics-based support library, you must add the support library to
   your project as follows:

   #. Open the ``build.gradle`` file for your app module.

   #. Add the support library to the ``dependencies`` section.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy

               .. code:: prettyprint

                  dependencies {
                     def dynamicanimation_version = '1.0.0'
                     implementation "androidx.dynamicanimation:dynamicanimation:$dynamicanimation_version"
                  }
                          

            .. container:: section

               .. rubric:: Kotlin
                  :name: kts

               .. code:: prettyprint

                  dependencies {
                     val dynamicanimation_version = "1.0.0"
                     implementation("androidx.dynamicanimation:dynamicanimation:$dynamicanimation_version")
                  }
                          

      To view the current versions for this library, see the information about
      Dynamicanimation on the `versions <#>`__ page.

   .. rubric:: Create a spring animation
      :name: creating-spring-animation

   The
   `SpringAnimation <#androidx.dynamicanimation.animation.SpringAnimation>`__
   class lets you create a spring animation for an object. To build a spring
   animation, you need to create an instance of the
   `SpringAnimation <#androidx.dynamicanimation.animation.SpringAnimation>`__
   class and provide an object, an object’s property that you want to animate,
   and an optional final spring position where you want the animation to rest.

   **Note:** At the time of creating a spring animation, the final position of
   the spring is optional. Though, it *must* be defined before starting the
   animation.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val springAnim = findViewById<View>(R.id.imageView).let { img ->
                   // Setting up a spring animation to animate the view’s translationY property with the final
                   // spring position at 0.
                   SpringAnimation(img, DynamicAnimation.TRANSLATION_Y, 0f)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               final View img = findViewById(R.id.imageView);
               // Setting up a spring animation to animate the view’s translationY property with the final
               // spring position at 0.
               final SpringAnimation springAnim = new SpringAnimation(img, DynamicAnimation.TRANSLATION_Y, 0);

   The spring-based animation can animate views on the screen by changing the
   actual properties in the view objects. The following views are available in
   the system:

   -  `ALPHA <#androidx.dynamicanimation.animation.DynamicAnimation>`__:
      Represents the alpha transparency on the view. The value is 1 (opaque) by
      default, with a value of 0 representing full transparency (not visible).
   -  `TRANSLATION_X <#>`__, `TRANSLATION_Y <#>`__, and `TRANSLATION_Z <#>`__:
      These properties control where the view is located as a delta from its
      left coordinate, top coordinate, and elevation, which are set by its
      layout container.

      -  `TRANSLATION_X <#>`__ describes the left coordinate.
      -  `TRANSLATION_Y <#>`__ describes the top coordinate.
      -  `TRANSLATION_Z <#>`__ describes the depth of the view relative to its elevation.

   -  `ROTATION <#>`__, `ROTATION_X <#>`__, and `ROTATION_Y <#>`__:
      These properties control the rotation in 2D (``rotation`` property) and 3D
      around the pivot point.
   -  `SCROLL_X <#>`__ and `SCROLL_Y <#>`__:
      These properties indicate the scroll offset of the source left and the top
      edge in pixels. It also indicates the position in terms how much the page
      is scrolled.
   -  `SCALE_X <#>`__ and `SCALE_Y <#>`__:
      These properties control the 2D scaling of a view around its pivot point.
   -  `X <#>`__, `Y <#>`__, and `Z <#>`__:
      These are basic utility properties to describe the final location of the
      view in its container.

      -  `X <#>`__ is a sum of the left value and `TRANSLATION_X <#>`__.
      -  `Y <#>`__ is a sum of the top value and `TRANSLATION_Y <#>`__.
      -  `Z <#>`__ is a sum of the elevation value and `TRANSLATION_Z <#>`__.

   .. rubric:: Register listeners
      :name: registering-listeners

   The `DynamicAnimation <#androidx.dynamicanimation.animation.DynamicAnimation>`__ 
   class provides two listeners:
   `OnAnimationUpdateListener <#>`__ and
   `OnAnimationEndListener <#>`__.
   These listeners listen to the updates in animation such as when there is a
   change in the animation value and when the animation comes to an end.

   .. rubric:: OnAnimationUpdateListener
      :name: update-listener

   When you want to animate multiple views to create a chained animation, you
   can set up `OnAnimationUpdateListener <#>`__
   to receive a callback every time there is a change in the current view’s
   property. The callback notifies the other view to update its spring position
   based on the change incurred in the current view’s property. To register the
   listener, perform the following steps:

   #. Call the `addUpdateListener() <#>`__
      method and attach the listener to the animation.

      **Note:** You need to register the update listener before the animation
      begins. Though, update listener should be registered only if you need
      per-frame update on the animation value changes. An update listener
      prevents the animation from potentially running on a separate thread.

   #. Override the `onAnimationUpdate() <#>`__
      method to notify the caller about the change in the current object. The
      following sample code illustrates the overall use of
      `OnAnimationUpdateListener <#>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Setting up a spring animation to animate the view1 and view2 translationX and translationY properties
               val (anim1X, anim1Y) = findViewById<View>(R.id.view1).let { view1 ->
                   SpringAnimation(view1, DynamicAnimation.TRANSLATION_X) to
                           SpringAnimation(view1, DynamicAnimation.TRANSLATION_Y)
               }
               val (anim2X, anim2Y) = findViewById<View>(R.id.view2).let { view2 ->
                   SpringAnimation(view2, DynamicAnimation.TRANSLATION_X) to
                           SpringAnimation(view2, DynamicAnimation.TRANSLATION_Y)
               }

               // Registering the update listener
               anim1X.addUpdateListener { _, value, _ ->
                   // Overriding the method to notify view2 about the change in the view1’s property.
                   anim2X.animateToFinalPosition(value)
               }

               anim1Y.addUpdateListener { _, value, _ -> anim2Y.animateToFinalPosition(value) }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Creating two views to demonstrate the registration of the update listener.
               final View view1 = findViewById(R.id.view1);
               final View view2 = findViewById(R.id.view2);

               // Setting up a spring animation to animate the view1 and view2 translationX and translationY properties
               final SpringAnimation anim1X = new SpringAnimation(view1,
                       DynamicAnimation.TRANSLATION_X);
               final SpringAnimation anim1Y = new SpringAnimation(view1,
                   DynamicAnimation.TRANSLATION_Y);
               final SpringAnimation anim2X = new SpringAnimation(view2,
                       DynamicAnimation.TRANSLATION_X);
               final SpringAnimation anim2Y = new SpringAnimation(view2,
                       DynamicAnimation.TRANSLATION_Y);

               // Registering the update listener
               anim1X.addUpdateListener(new DynamicAnimation.OnAnimationUpdateListener() {

               // Overriding the method to notify view2 about the change in the view1’s property.
                   @Override
                   public void onAnimationUpdate(DynamicAnimation dynamicAnimation, float value,
                                                 float velocity) {
                       anim2X.animateToFinalPosition(value);
                   }
               });

               anim1Y.addUpdateListener(new DynamicAnimation.OnAnimationUpdateListener() {

                 @Override
                   public void onAnimationUpdate(DynamicAnimation dynamicAnimation, float value,
                                                 float velocity) {
                       anim2Y.animateToFinalPosition(value);
                   }
               });

   .. rubric:: OnAnimationEndListener
      :name: end-listener

   `OnAnimationEndListener <#androidx.dynamicanimation.animation.DynamicAnimation.OnAnimationEndListener>`__
   notifies the end of an animation. You can set up the listener to receive
   callback whenever the animation reaches equilibrium or it is canceled. To
   register the listener, perform the following steps:

   #. Call the `addEndListener() <#>`__
      method and attach the listener to the animation.
   #. Override the
      `onAnimationEnd() <#androidx.dynamicanimation.animation.DynamicAnimation.OnAnimationEndListener>`__
      method to receive notification whenever an animation reaches equilibrium
      or is canceled.

   .. rubric:: Remove listeners
      :name: removing-listeners

   To stop receiving animation update callbacks and animation end callbacks,
   call `removeUpdateListener() <#>`__ and `removeEndListener() <#>`__
   methods, respectively.

   .. rubric:: Set animation start value
      :name: setting-start-value

   To set the start value of the animation, call the `setStartValue() <#>`__
   method and pass the start value of the animation. If you do not set the start
   value, the animation uses the current value of the object’s property as the
   start value.

   .. rubric:: Set animation value range
      :name: setting-value-range

   You can set the minimum and the maximum animation values when you want to
   restrain the property value to a certain range. It also helps to control the
   range in case you animate properties that have an intrinsic range, such as
   alpha (from 0 to 1).

   -  To set the minimum value, call the `setMinValue() <#>`__
      method and pass the minimum value of the property.
   -  To set the maximum value, call the `setMaxValue() <#>`__
      method and pass the maximum value of the property.

   Both methods return the animation for which the value is being set.

   **Note:** If you have set the start value and have defined an animation value
   range, ensure the start value is within the minimum and the maximum value
   range.

   .. rubric:: Set start velocity
      :name: setting-velocity

   Start velocity defines the speed at which the animation property changes at
   the beginning of the animation. The default start velocity is set to zero
   pixels per second. You can set the velocity either with the velocity of touch
   gestures or by using a fixed value as the start velocity. If you choose to
   provide a fixed value, we recommend to define the value in dp per second and
   then convert it to pixels per second. Defining the value in dp per second
   allows velocity to be independent of density and form factors. For more
   information about converting value to pixels per second, refer to the
   `Converting dp per second to pixels per second <#converting-value>`__
   section.

   To set the velocity, call the `setStartVelocity() <#>`__
   method and pass the velocity in pixels per second. The method returns the
   spring force object on which the velocity is set.

   **Note:** Use the
   `GestureDetector.OnGestureListener <#android.view.GestureDetector.OnGestureListener>`__
   or the `VelocityTracker <#android.view.VelocityTracker>`__
   class methods to retrieve and compute the velocity of touch gestures.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<View>(R.id.imageView).also { img ->
                   SpringAnimation(img, DynamicAnimation.TRANSLATION_Y).apply {
                       …
                       // Compute velocity in the unit pixel/second
                       vt.computeCurrentVelocity(1000)
                       val velocity = vt.yVelocity
                       setStartVelocity(velocity)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               final View img = findViewById(R.id.imageView);
               final SpringAnimation anim = new SpringAnimation(img, DynamicAnimation.TRANSLATION_Y);
               …
               // Compute velocity in the unit pixel/second
               vt.computeCurrentVelocity(1000);
               float velocity = vt.getYVelocity();
               anim.setStartVelocity(velocity);

   .. rubric:: Converting dp per second to pixels per second
      :name: converting-value

   Velocity of a spring must be in pixels per second. If you choose to provide a
   fixed value as the start of the velocity, provide the value in dp per second
   and then convert it to pixels per second. For conversion, use the
   `applyDimension() <#android.util.TypedValue>`__
   method from the `TypedValue <#android.util.TypedValue>`__
   class. Refer to the following sample code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val pixelPerSecond: Float =
                   TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpPerSecond, resources.displayMetrics)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               float pixelPerSecond = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpPerSecond, getResources().getDisplayMetrics());

   .. rubric:: Set spring properties
      :name: setting-properties

   The `SpringForce <#androidx.dynamicanimation.animation.SpringForce>`__
   class defines the getter and the setter methods for each of the spring
   properties, such as damping ratio and stiffness. To set the spring
   properties, it is important to either retrieve the spring force object or
   create a custom spring force on which you can set the properties. For more
   information about creating a custom spring force, refer to the 
   `Creating a custom spring force <#creating-custom-spring>`__ section.

   **Tip:** While using the setter methods, you can create a method chain as all
   the setter methods return the spring force object.

   .. rubric:: Damping ratio
      :name: damping-ratio

   The damping ratio describes a gradual reduction in a spring oscillation. By
   using the damping ratio, you can define how rapidly the oscillations decay
   from one bounce to the next. There are four different ways you can damp a
   spring:

   -  Overdamping occurs when the damping ratio is greater than one. It lets the
      object gently return to the rest position.
   -  Critical damping occurs when the damping ratio is equal to one. It lets
      the object return to the rest position within the shortest amount of time.
   -  Underdamping occurs when the damping ratio is less than one. It lets
      object overshoot multiple times by passing the rest position, and then
      gradually reaches the rest position.
   -  Undamped occurs when the damping ratio is equal to zero. It lets the
      object oscillate forever.

   To add the damping ratio to the spring, perform the following steps:

   #. Call the
      `getSpring() <#androidx.dynamicanimation.animation.SpringAnimation>`__
      method to retrieve the spring to add the damping ratio.

   #. Call the
      `setDampingRatio() <#androidx.dynamicanimation.animation.SpringForce>`__
      method and pass the damping ratio that you want to add to the spring. The
      method returns the spring force object on which the damping ratio is set.

      **Note:** The damping ratio *must* be a non-negative number. If you set
      the damping ratio to zero, the spring will never reach the rest position.
      In other words, it oscillates forever.

   The following damping ratio constants are available in the system:

   -  `DAMPING_RATIO_HIGH_BOUNCY <#androidx.dynamicanimation.animation.SpringForce>`__
   -  `DAMPING_RATIO_MEDIUM_BOUNCY <#androidx.dynamicanimation.animation.SpringForce>`__
   -  `DAMPING_RATIO_LOW_BOUNCY <#androidx.dynamicanimation.animation.SpringForce>`__
   -  `DAMPING_RATIO_NO_BOUNCY <#androidx.dynamicanimation.animation.SpringForce>`__

   |image-high_bounce|\ Figure 2: High bounce

   |image-medium_bounce|\ Figure 3: Medium bounce

   |image-low_bounce|\ Figure 4: Low bounce

   |image-no_bounce|\ Figure 5: No bounce

   The default damping ratio is set to
   `DAMPING_RATIO_MEDIUM_BOUNCY <#androidx.dynamicanimation.animation.SpringForce>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<View>(R.id.imageView).also { img ->
                   SpringAnimation(img, DynamicAnimation.TRANSLATION_Y).apply {
                       …
                       // Setting the damping ratio to create a low bouncing effect.
                       spring.dampingRatio = SpringForce.DAMPING_RATIO_LOW_BOUNCY
                       …
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               final View img = findViewById(R.id.imageView);
               final SpringAnimation anim = new SpringAnimation(img, DynamicAnimation.TRANSLATION_Y);
               …
               // Setting the damping ratio to create a low bouncing effect.
               anim.getSpring().setDampingRatio(SpringForce.DAMPING_RATIO_LOW_BOUNCY);
               …

   .. rubric:: Stiffness
      :name: stiffness

   Stiffness defines the spring constant, which measures the strength of the
   spring. A stiff spring applies more force to the object that is attached when
   the spring is not at the rest position. To add the stiffness to the spring,
   perform the following steps:

   #. Call the
      `getSpring() <#androidx.dynamicanimation.animation.SpringAnimation>`__
      method to retrieve the spring to add the stiffness.

   #. Call the
      `setStiffness() <#androidx.dynamicanimation.animation.SpringForce>`__
      method and pass the stiffness value that you want to add to the spring.
      The method returns the spring force object on which the stiffness is set.

      **Note:** The stiffness must be a positive number.

   The following stiffness constants are available in the system:

   -  `STIFFNESS_HIGH <#androidx.dynamicanimation.animation.SpringForce>`__
   -  `STIFFNESS_MEDIUM <#androidx.dynamicanimation.animation.SpringForce>`__
   -  `STIFFNESS_LOW <#androidx.dynamicanimation.animation.SpringForce>`__
   -  `STIFFNESS_VERY_LOW <#androidx.dynamicanimation.animation.SpringForce>`__

   |image-high_stiffness|\ Figure 6: High stiffness

   |image-medium_stiffness|\ Figure 7: Medium stiffness

   |image-low_stiffness|\ Figure 8: Low stiffness

   |image-very_low_stiffness|\ Figure 9: Very low stiffness

   The default stiffness is set to
   `STIFFNESS_MEDIUM <#androidx.dynamicanimation.animation.SpringForce>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<View>(R.id.imageView).also { img ->
                   SpringAnimation(img, DynamicAnimation.TRANSLATION_Y).apply {
                       …
                       // Setting the spring with a low stiffness.
                       spring.stiffness = SpringForce.STIFFNESS_LOW
                       …
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               final View img = findViewById(R.id.imageView);
               final SpringAnimation anim = new SpringAnimation(img, DynamicAnimation.TRANSLATION_Y);
               …
               // Setting the spring with a low stiffness.
               anim.getSpring().setStiffness(SpringForce.STIFFNESS_LOW);
               …

   .. rubric:: Create a custom spring force
      :name: using-custom-spring

   You can create a custom spring force as an alternative to using the default
   spring force. The custom spring force lets you share the same spring force
   instance across multiple spring animations. Once you have created the spring
   force, you can set properties such as damping ratio and stiffness.

   #. Create a
      `SpringForce <#androidx.dynamicanimation.animation.SpringForce>`__
      object.

      ``SpringForce force = new SpringForce();``

   #. Assign the properties by calling the respective methods. You can also
      create a method chain.

      ``force.setDampingRatio(DAMPING_RATIO_LOW_BOUNCY).setStiffness(STIFFNESS_LOW);``

   #. Call the
      `setSpring() <#androidx.dynamicanimation.animation.SpringAnimation>`__
      method to set the spring to the animation.

      ``setSpring(force);``

   .. rubric:: Start animation
      :name: starting-animation

   There are two ways you can start a spring animation: By calling the
   `start() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   or by calling the
   `animateToFinalPosition() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method. Both the methods need to be called on the main thread.

   `animateToFinalPosition() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method performs two tasks:

   -  Sets the final position of the spring.
   -  Starts the animation, if it has not started.

   Since the method updates the final position of the spring and starts the
   animation if needed, you can call this method any time to change the course
   of an animation. For example, in a chained spring animation, the animation of
   one view depends on another view. For such an animation, it's more convenient
   to use the
   `animateToFinalPosition() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method. By using this method in a chained spring animation, you don't need to
   worry if the animation you want to update next is currently running.

   Figure 10 illustrates a chained spring animation, where the animation of one
   view depends on another view.

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/graphics/spring_chain.gif
      :alt: Chained spring demo
      :width: 300px
      :height: 500px

      **Figure 10.** Chained spring demo

   To use the
   `animateToFinalPosition() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method, call the
   `animateToFinalPosition() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method and pass the rest position of the spring. You can also set the rest
   position of the spring by calling the
   `setFinalPosition() <#androidx.dynamicanimation.animation.SpringForce>`__
   method.

   The
   `start() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method does not set the property value to the start value immediately. The
   property value changes at each animation pulse, which happens before the draw
   pass. As a result, the changes are reflected in the next frame, as if the
   values are set immediately.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<View>(R.id.imageView).also { img ->
                   SpringAnimation(img, DynamicAnimation.TRANSLATION_Y).apply {
                       …
                       // Starting the animation
                       start()
                       …
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               final View img = findViewById(R.id.imageView);
               final SpringAnimation anim = new SpringAnimation(img, DynamicAnimation.TRANSLATION_Y);
               …
               // Starting the animation
               anim.start();
               …

   .. rubric:: Cancel animation
      :name: cancelling-animation

   You can cancel or skip to the end of the animation. An ideal situation where
   you need to cancel or skip to the end of the amiation is when a user
   interaction demands the animation to be terminated immediately. This is
   mostly when a user exits an app abruptly or the view becomes invisible.

   There are two methods that you can use to terminate the animation. The
   `cancel() <#>`__
   method terminates the animation at the value where it is. The
   `skipToEnd() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method skips the animation to the final value and then terminates it.

   Before you can terminate the animation, it is important to first check the
   state of the spring. If the state is undamped, the animation can never reach
   the rest position. To check the state of the spring, call the
   `canSkipToEnd() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method. If the spring is damped, the method returns ``true``, otherwise
   ``false``.

   Once you know the state of the spring, you can terminate an animation by
   using either
   `skipToEnd() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method or the
   `cancel() <#>`__
   method. The
   `cancel() <#>`__
   method *must* be called only on the main thread.

   **Note:** In general, the
   `skipToEnd() <#androidx.dynamicanimation.animation.SpringAnimation>`__
   method causes a visual jump.


Last updated 2024-04-15 UTC.

.. |image-high_bounce| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/high_bounce.gif
.. |image-medium_bounce| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/medium_bounce.gif
.. |image-low_bounce| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/low_bounce.gif
.. |image-no_bounce| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/no_bounce.gif
.. |image-high_stiffness| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/high_stiffness.gif
.. |image-medium_stiffness| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/medium_stiffness.gif
.. |image-low_stiffness| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/low_stiffness.gif
.. |image-very_low_stiffness| image:: https://developer.android.google.cn/static/images/guide/topics/graphics/very_low_stiffness.gif


/Auto-animate layout updates
============================

.. https://developer.android.google.cn/develop/ui/views/animations/layout?hl=en

.. container:: devsite-article-body

   Android offers preloaded animation that runs when you change the layout. Set
   an attribute in the layout to tell the Android system to animate these layout
   changes, and it carries out system-default animations for you.

   **Tip**: If you want to supply custom layout animations, create a
   `LayoutTransition <#android.animation.LayoutTransition>`__
   object and supply it to the layout with the
   `setLayoutTransition() <#android.view.ViewGroup>`__
   method.
   Here's what a default layout animation looks like when adding items to a
   list:

   .. container:: framed-galaxynexus-land-span-8

   .. container:: figure-caption

      **Figure 1.** Layout animation.

      .. container:: video-instructions

          

   .. rubric:: Create the layout
      :name: views

   In your activity's layout XML file, set the ``android:animateLayoutChanges``
   attribute to ``true`` for the layout that you want to enable animations for:

   .. code:: prettyprint

      <LinearLayout android:id="@+id/container"
          android:animateLayoutChanges="true"
          ...
      />

   .. rubric:: Add, update, or remove items from the layout
      :name: activity

   Add, remove, or update items in the layout, and the items are animated
   automatically:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            lateinit var containerView: ViewGroup
            ...
            private fun addItem() {
                val newView: View = ...

                containerView.addView(newView, 0)
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private ViewGroup containerView;
            ...
            private void addItem() {
                View newView;
                ...
                containerView.addView(newView, 0);
            }


Last updated 2024-02-22 UTC.


/Animate layout changes using a transition
==========================================

.. https://developer.android.google.cn/develop/ui/views/animations/transitions?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `AnimatedContent → <https://developer.android.google.cn/jetpack/compose/animation/composables-modifiers#animatedcontent>`__

      |image-android-compose-ui-logo|

   **Note:**\  This documentation describes how to build transitions between
   layouts within the same activity. If the user is moving between activities,
   read `Start an activity using an animation <#>`__.
   Android's transition framework lets you animate all kinds of motion in your
   UI by providing the starting and ending layouts. You can select what type of
   animation you want—such as to fade views in or out, or to change view
   sizes—and the transition framework determines how to animate from the
   starting layout to the ending layout.

   The transition framework includes the following features:

   -  **Group-level animations:** apply animation effects to all the views in a
      view hierarchy.
   -  **Built-in animations:** use predefined animations for common effects such
      as fade out or movement.
   -  **Resource file support:** load view hierarchies and built-in animations
      from layout resource files.
   -  **Lifecycle callbacks:** receive callbacks that provide control over the
      animation and hierarchy change process.

   For sample code that animates between layout changes, see
   `BasicTransition <https://github.com/android/animation-samples/tree/main/BasicTransition>`__.

   The basic process to animate between two layouts is as follows:

   #. Create a `Scene <#android.transition.Scene>`__ object for
      the starting and ending layouts. However, the starting layout's scene is
      often determined automatically from the current layout.
   #. Create a `Transition <#android.transition.Transition>`__
      object to define what type of animation you want.
   #. Call
      `TransitionManager.go() <#android.transition.TransitionManager>`__,
      and the system runs the animation to swap the layouts.

   The diagram in figure 1 illustrates the relationship between your layouts,
   the scenes, the transition, and the final animation.

   |image-transitions_diagram|

   **Figure 1.** Basic illustration of how the transition framework creates an
   animation.

   .. rubric:: Create a scene
      :name: CreateScene

   Scenes store the state of a view hierarchy, including all its views and their
   property values. The transitions framework can run animations between a
   starting and an ending scene.

   You can create your scenes from a layout resource file or from a group of
   views in your code. However, the starting scene for your transition is often
   determined automatically from the current UI.

   A scene can also define its own actions that run when you make a scene
   change. This feature is useful for cleaning up view settings after you
   transition to a scene.

   **Note:**\  The framework can animate changes in a single view hierarchy
   without using scenes, as described in the 
   `Apply a transition without scenes <#NoScenes>`__ section. 
   However, understanding scenes is essential to
   working with transitions.

   .. rubric:: Create a scene from a layout resource
      :name: FromLayout

   You can create a ``Scene`` instance directly from a layout resource file. Use
   this technique when the view hierarchy in the file is mostly static. The
   resulting scene represents the state of the view hierarchy at the time you
   created the ``Scene`` instance. If you change the view hierarchy, recreate
   the scene. The framework creates the scene from the entire view hierarchy in
   the file. You can't create a scene from part of a layout file.

   To create a ``Scene`` instance from a layout resource file, retrieve the
   scene root from your layout as a
   `ViewGroup <#android.view.ViewGroup>`__. Then, call the
   `Scene.getSceneForLayout() <#android.transition.Scene>`__
   function with the scene root and the resource ID of the layout file that
   contains the view hierarchy for the scene.

   .. rubric:: Define layouts for scenes
      :name: define_layouts_for_scenes

   The code snippets in the rest of this section show how to create two
   different scenes with the same scene root element. The snippets also
   demonstrate that you can load multiple unrelated ``Scene`` objects without
   implying that they are related to each other.

   The example consists of the following layout definitions:

   -  The main layout of an activity with a text label and a child
      `FrameLayout <#android.widget.FrameLayout>`__.
   -  A `ConstraintLayout <#>`__
      for the first scene with two text fields.
   -  A ``ConstraintLayout`` for the second scene with the same two text fields
      in different order.

   The example is designed so that all of the animation occurs within the child
   layout of the main layout for the activity. The text label in the main layout
   remains static.

   The main layout for the activity is defined as follows:

   res/layout/activity_main.xml

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/master_layout">
          <TextView
              android:id="@+id/title"
              ...
              android:text="Title"/>
          <FrameLayout
              android:id="@+id/scene_root">
              <include layout="@layout/a_scene" />
          </FrameLayout>
      </LinearLayout>

   This layout definition contains a text field and a child ``FrameLayout`` for
   the scene root. The layout for the first scene is included in the main layout
   file. This lets the app display it as part of the initial user interface and
   also load it into a scene, since the framework can only load a whole layout
   file into a scene.

   The layout for the first scene is defined as follows:

   res/layout/a_scene.xml

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout 
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/scene_container"
          android:layout_width="match_parent"
          android:layout_height="match_parent" >
          
          
      </androidx.constraintlayout.widget.ConstraintLayout>

   The layout for the second scene contains the same two text fields—with the
   same IDs—placed in a different order. It is defined as follows:

   res/layout/another_scene.xml

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout 
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/scene_container"
          android:layout_width="match_parent"
          android:layout_height="match_parent" >
          
          
      </androidx.constraintlayout.widget.ConstraintLayout>

   .. rubric:: Generate scenes from layouts
      :name: generate_scenes_from_layouts

   After you create definitions for the two constraint layouts, you can obtain a
   scene for each of them. This lets you transition between the two UI
   configurations. To obtain a scene, you need a reference to the scene root and
   the layout resource ID.

   The following code snippet shows how to get a reference to the scene root and
   create two ``Scene`` objects from the layout files:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val sceneRoot: ViewGroup = findViewById(R.id.scene_root)
               val aScene: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.a_scene, this)
               val anotherScene: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.another_scene, this)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Scene aScene;
               Scene anotherScene;

               // Create the scene root for the scenes in this app.
               sceneRoot = (ViewGroup) findViewById(R.id.scene_root);

               // Create the scenes.
               aScene = Scene.getSceneForLayout(sceneRoot, R.layout.a_scene, this);
               anotherScene =
                   Scene.getSceneForLayout(sceneRoot, R.layout.another_scene, this);

   In the app, there are now two ``Scene`` objects based on view hierarchies.
   Both scenes use the scene root defined by the ``FrameLayout`` element in
   ``res/layout/activity_main.xml``.

   .. rubric:: Create a scene in your code
      :name: FromCode

   You can also create a ``Scene`` instance in your code from a ``ViewGroup``
   object. Use this technique when you modify the view hierarchies directly in
   your code or when you generate them dynamically.

   To create a scene from a view hierarchy in your code, use the
   `Scene(sceneRoot, viewHierarchy) <#android.transition.Scene>`__
   constructor. Calling this constructor is equivalent to calling the
   `Scene.getSceneForLayout() <#android.transition.Scene>`__
   function when you already inflated a layout file.

   The following code snippet demonstrates how to create a ``Scene`` instance
   from the scene root element and the view hierarchy for the scene in your
   code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val sceneRoot = someLayoutElement as ViewGroup
               val viewHierarchy = someOtherLayoutElement as ViewGroup
               val scene: Scene = Scene(sceneRoot, viewHierarchy)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Scene mScene;

               // Obtain the scene root element.
               sceneRoot = (ViewGroup) someLayoutElement;

               // Obtain the view hierarchy to add as a child of
               // the scene root when this scene is entered.
               viewHierarchy = (ViewGroup) someOtherLayoutElement;

               // Create a scene.
               mScene = new Scene(sceneRoot, mViewHierarchy);

   .. rubric:: Create scene actions
      :name: Actions

   The framework lets you define custom scene actions that the system runs when
   entering or exiting a scene. In many cases, defining custom scene actions is
   unnecessary, since the framework animates the change between scenes
   automatically.

   Scene actions are useful for handling these cases:

   -  To animate views that are not in the same hierarchy. You can animate views
      for the starting and ending scenes using exit and entry scene actions.
   -  To animate views that the transitions framework can't animate
      automatically, such as
      `ListView <#android.widget.ListView>`__ objects. For more
      information, see the section about `limitations <#Limitations>`__.

   To provide custom scene actions, define your actions as
   `Runnable <#>`__ objects and pass them to the
   `Scene.setExitAction() <#android.transition.Scene>`__
   or
   `Scene.setEnterAction() <#android.transition.Scene>`__
   functions. The framework calls the ``setExitAction()`` function on the
   starting scene before running the transition animation and the
   ``setEnterAction()`` function on the ending scene after running the
   transition animation.

   **Note:**\  Don't use scene actions to pass data between views in the
   starting and ending scenes. For more information, see the section about
   `defining transition lifecycle callbacks <#Callbacks>`__.

   .. rubric:: Apply a transition
      :name: ApplyingTransition

   The transition framework represents the style of animation between scenes
   with a ``Transition`` object. You can instantiate a ``Transition`` using
   built-in subclasses, such as
   `AutoTransition <#android.transition.AutoTransition>`__ and
   `Fade <#android.transition.Fade>`__, or `define your own transition <#>`__. Then, you can run
   the animation between scenes by passing your end ``Scene`` and the
   ``Transition`` to ``TransitionManager.go()``.

   The transition lifecycle is similar to the activity lifecycle, and it
   represents the transition states that the framework monitors between the
   start and the completion of an animation. At important lifecycle states, the
   framework invokes callback functions that you can implement to adjust your
   user interface at different phases of the transition.

   .. rubric:: Create a transition
      :name: CreateTransition

   The previous section shows how to create scenes that represent the state of
   different view hierarchies. Once you define the starting and ending scenes
   you want to change between, create a ``Transition`` object that defines an
   animation. The framework lets you either specify a built-in transition in a
   resource file and inflate it in your code or create an instance of a built-in
   transition directly in your code.

   **Table 1.** Built-in transition types.


   .. list-table::
      :widths: 27 27 27
      :header-rows: 1

      - 

         - Class
         - Tag
         - Effect
      - 

         - `AutoTransition <#android.transition.AutoTransition>`__
         - ``<autoTransition/>``
         - Default transition. Fades out, moves and resizes, and fades in views,
            in that order.
      - 

         - `ChangeBounds <#android.transition.ChangeBounds>`__
         - ``<changeBounds/>``
         - Moves and resizes views.
      - 

         - `ChangeClipBounds <#android.transition.ChangeClipBounds>`__
         - ``<changeClipBounds/>``
         - Captures the ``View.getClipBounds()`` before and after the scene
            change and animates those changes during the transition.
      - 

         - `ChangeImageTransform <#android.transition.ChangeImageTransform>`__
         - ``<changeImageTransform/>``
         - Captures the matrix of an ``ImageView`` before and after the scene
            change and animates it during the transition.
      - 

         - `ChangeScroll <#android.transition.ChangeScroll>`__
         - ``<changeScroll/>``
         - Captures the scroll properties of targets before and after the scene
            change and animates any changes.
      - 

         - `ChangeTransform <#android.transition.ChangeTransform>`__
         - ``<changeTransform/>``
         - Captures scale and rotation of views before and after the scene
            change and animates those changes during the transition.
      - 

         - `Explode <#android.transition.Explode>`__
         - ``<explode/>``
         - Tracks changes to the visibility of target views in the start and end
            scenes and moves views in or out from the edges of the scene.
      - 

         - `Fade <#android.transition.Fade>`__
         - ``<fade/>``
         - ``fade_in`` fades in views.
            ``fade_out`` fades out views.
            ``fade_in_out`` (default) does a ``fade_out`` followed by a
            ``fade_in``.
      - 

         - `Slide <#android.transition.Slide>`__
         - ``<slide/>``
         - Tracks changes to the visibility of target views in the start and end
            scenes and moves views in or out from one of the edges of the scene.

   .. rubric:: Create a transition instance from a resource file
      :name: FromFile

   This technique lets you modify your transition definition without changing
   the code of your activity. This technique is also useful to separate complex
   transition definitions from your application code, as shown in the section
   about `specifying multiple transitions <#Multiple>`__.

   To specify a built-in transition in a resource file, follow these steps:

   -  Add the ``res/transition/`` directory to your project.
   -  Create a new XML resource file inside this directory.
   -  Add an XML node for one of the built-in transitions.

   For example, the following resource file specifies the ``Fade`` transition:

   res/transition/fade_transition.xml

   .. code:: prettyprint

      <fade xmlns:android="http://schemas.android.com/apk/res/android" />

   The following code snippet shows how to inflate a ``Transition`` instance
   inside your activity from a resource file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var fadeTransition: Transition =
                   TransitionInflater.from(this)
                                     .inflateTransition(R.transition.fade_transition)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Transition fadeTransition =
                       TransitionInflater.from(this).
                       inflateTransition(R.transition.fade_transition);

   .. rubric:: Create a transition instance in your code
      :name: FromCode

   This technique is useful for creating transition objects dynamically if you
   modify the user interface in your code and to create simple built-in
   transition instances with few or no parameters.

   To create an instance of a built-in transition, invoke one of the public
   constructors in the subclasses of the ``Transition`` class. For example, the
   following code snippet creates an instance of the ``Fade`` transition:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var fadeTransition: Transition = Fade()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Transition fadeTransition = new Fade();

   .. rubric:: Apply a transition
      :name: ApplyTransition

   You typically apply a transition to change between different view hierarchies
   in response to an event, such as a user action. For example, consider a
   search app: when the user enters a search term and taps the search button,
   the app changes to a scene that represents the results layout while applying
   a transition that fades out the search button and fades in the search
   results.

   To make a scene change while applying a transition in response to an event in
   your activity, call the ``TransitionManager.go()`` class function with the
   ending scene and the transition instance to use for the animation, as shown
   in the following snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               TransitionManager.go(endingScene, fadeTransition)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TransitionManager.go(endingScene, fadeTransition);

   The framework changes the view hierarchy inside the scene root with the view
   hierarchy from the ending scene while running the animation specified by the
   transition instance. The starting scene is the ending scene from the last
   transition. If there is no previous transition, the starting scene is
   determined automatically from the current state of the user interface.

   If you don't specify a transition instance, the transition manager can apply
   an automatic transition that does something reasonable for most situations.
   For more information, see the API reference for the
   `TransitionManager <#android.transition.TransitionManager>`__
   class.

   .. rubric:: Choose specific target views
      :name: Targets

   The framework applies transitions to all views in the starting and ending
   scenes by default. In some cases, you might only want to apply an animation
   to a subset of views in a scene. The framework lets you select specific views
   you want to animate. For example, the framework doesn't support animating
   changes to ``ListView`` objects, so don't try to animate them during a
   transition.

   Each view that the transition animates is called a *target*. You can only
   select targets that are part of the view hierarchy associated with a scene.

   To remove one or more views from the list of targets, call the
   `removeTarget() <#android.transition.Transition>`__
   method before starting the transition. To add only the views you specify to
   the list of targets, call the
   `addTarget() <#android.transition.Transition>`__
   function. For more information, see the API reference for the
   `Transition <#android.transition.Transition>`__ class.

   .. rubric:: Specify multiple transitions
      :name: Multiple

   To get the most impact from an animation, match it to the type of changes
   that occur between the scenes. For example, if you are removing some views
   and adding others between scenes, a fade out or fade in animation provides a
   noticeable indication that some views are no longer available. If you are
   moving views to different points on the screen, it's better to animate the
   movement so that users notice the new location of the views.

   You don't have to choose only one animation, since the transitions framework
   lets you combine animation effects in a transition set that contains a group
   of individual built-in or custom transitions.

   To define a transition set from a collection of transitions in XML, create a
   resource file in the ``res/transitions/`` directory and list the transitions
   under the ``TransitionSet`` element. For example, the following snippet shows
   how to specify a transition set that has the same behavior as the
   ``AutoTransition`` class:

   .. code:: prettyprint

      <transitionSet xmlns:android="http://schemas.android.com/apk/res/android"
          android:transitionOrdering="sequential">
          <fade android:fadingMode="fade_out" />
          <changeBounds />
          <fade android:fadingMode="fade_in" />
      </transitionSet>

   To inflate the transition set into a
   `TransitionSet <#android.transition.TransitionSet>`__ object in
   your code, call the
   `TransitionInflater.from() <#android.transition.TransitionInflater>`__
   function in your activity. The ``TransitionSet`` class extends from the
   ``Transition`` class, so you can use it with a transition manager just like
   any other ``Transition`` instance.

   .. rubric:: Apply a transition without scenes
      :name: NoScenes

   Changing view hierarchies isn't the only way to modify your user interface.
   You can also make changes by adding, modifying, and removing child views
   within the current hierarchy.

   For example, you can implement a search interaction with a single layout.
   Start with the layout showing a search entry field and a search icon. To
   change the user interface to show the results, remove the search button when
   the user taps it by calling the
   `ViewGroup.removeView() <#android.view.ViewGroup>`__
   function and add the search results by calling
   `ViewGroup.addView() <#android.view.ViewGroup>`__
   function.

   You can use this approach if the alternative is to have two hierarchies that
   are nearly identical. Rather than creating and maintain two separate layout
   files for a minor difference in the user interface, you can have one layout
   file containing a view hierarchy that you modify in code.

   If you make changes within the current view hierarchy in this fashion, you
   don't need to create a scene. Instead, you can create and apply a transition
   between two states of a view hierarchy using a *delayed transition*. This
   feature of the transitions framework starts with the current view hierarchy
   state, records changes you make to its views, and applies a transition that
   animates the changes when the system redraws the user interface.

   To create a delayed transition within a single view hierarchy, follow these
   steps:

   #. When the event that triggers the transition occurs, call the
      `TransitionManager.beginDelayedTransition() <#android.transition.TransitionManager>`__
      function, providing the parent view of all the views you want to change
      and the transition to use. The framework stores the current state of the
      child views and their property values.
   #. Make changes to the child views as required by your use case. The
      framework records the changes you make to the child views and their
      properties.
   #. When the system redraws the user interface according to your changes, the
      framework animates the changes between the original state and the new
      state.

   The following example shows how to animate the addition of a text view to a
   view hierarchy using a delayed transition. The first snippet shows the layout
   definition file:

   res/layout/activity_main.xml

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/mainLayout"
          android:layout_width="match_parent"
          android:layout_height="match_parent" >
          <EditText
              android:id="@+id/inputText"
              android:layout_alignParentLeft="true"
              android:layout_alignParentTop="true"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              app:layout_constraintTop_toTopOf="parent"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintEnd_toEndOf="parent" />
          ...
      </androidx.constraintlayout.widget.ConstraintLayout>

   The next snippet shows the code that animates the addition of the text view:

   MainActivity

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               setContentView(R.layout.activity_main)
               val labelText = TextView(this).apply {
                   text = "Label"
                   id = R.id.text
               }
               val rootView: ViewGroup = findViewById(R.id.mainLayout)
               val mFade: Fade = Fade(Fade.IN)
               TransitionManager.beginDelayedTransition(rootView, mFade)
               rootView.addView(labelText)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private TextView labelText;
               private Fade mFade;
               private ViewGroup rootView;
               ...
               // Load the layout.
               setContentView(R.layout.activity_main);
               ...
               // Create a new TextView and set some View properties.
               labelText = new TextView(this);
               labelText.setText("Label");
               labelText.setId(R.id.text);

               // Get the root view and create a transition.
               rootView = (ViewGroup) findViewById(R.id.mainLayout);
               mFade = new Fade(Fade.IN);

               // Start recording changes to the view hierarchy.
               TransitionManager.beginDelayedTransition(rootView, mFade);

               // Add the new TextView to the view hierarchy.
               rootView.addView(labelText);

               // When the system redraws the screen to show this update,
               // the framework animates the addition as a fade in.

   .. rubric:: Define transition lifecycle callbacks
      :name: Callbacks

   The transition lifecycle is similar to the activity lifecycle. It represents
   the transition states that the framework monitors during the period between a
   call to the ``TransitionManager.go()`` function and the completion of the
   animation. At important lifecycle states, the framework invokes callbacks
   defined by the ``TransitionListener`` interface.

   Transition lifecycle callbacks are useful, for example, for copying a view
   property value from the starting view hierarchy to the ending view hierarchy
   during a scene change. You can't simply copy the value from its starting view
   to the view in the ending view hierarchy, because the ending view hierarchy
   is not inflated until the transition is complete. Instead, you need to store
   the value in a variable and then copy it into the ending view hierarchy when
   the framework has finished the transition. To be notified when the transition
   is completed, implement the
   `TransitionListener.onTransitionEnd() <#android.transition.Transition.TransitionListener>`__
   function in your activity.

   For more information, see the API reference for the
   `TransitionListener <#android.transition.Transition.TransitionListener>`__
   class.

   .. rubric:: Limitations
      :name: Limitations

   This section lists some known limitations of the transitions framework:

   -  Animations applied to a
      `SurfaceView <#android.view.SurfaceView>`__ might not appear
      correctly. ``SurfaceView`` instances are updated from a non-UI thread, so
      the updates might be out of sync with the animations of other views.
   -  Some specific transition types might not produce the desired animation
      effect when applied to a
      `TextureView <#android.view.TextureView>`__.
   -  Classes that extend
      `AdapterView <#android.widget.AdapterView>`__, such as
      ``ListView``, manage their child views in ways that are incompatible with
      the transitions framework. If you try to animate a view based on
      ``AdapterView``, the device display might stop responding.
   -  If you try to resize a
      `TextView <#android.widget.TextView>`__ with an animation,
      the text pops to a new location before the object is completely resized.
      To avoid this problem, don't animate the resizing of views that contain
      text.


Last updated 2024-04-15 UTC.

.. |image-transitions_diagram| image:: https://developer.android.google.cn/static/images/transitions/transitions_diagram.png
   :width: 506px
   :height: 234px


/Create a custom transition animation
=====================================

.. https://developer.android.google.cn/develop/ui/views/animations/transitions/custom-transitions?hl=en

.. container:: devsite-article-body

   A custom transition lets you create an animation that is not available from
   any of the built-in transition classes. For example, you can define a custom
   transition that turns the foreground color of text and input fields to gray
   to indicate that the fields are disabled in the new screen. This type of
   change helps users see the fields you disabled.

   A custom transition, like one of the built-in transition types, applies
   animations to child views of both the starting and ending scenes. However,
   unlike built-in transition types, you have to provide the code that captures
   property values and generates animations. You might also want to define a
   subset of target views for your animation.

   This page teaches you how to capture property values and generate animations
   to create custom transitions.

   .. rubric:: Extend the Transition class
      :name: Extend

   To create a custom transition, add a class to your project that extends the
   `Transition <#android.transition.Transition>`__ class and
   override the functions shown in the following snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CustomTransition : Transition() {

                   override fun captureStartValues(transitionValues: TransitionValues) {}

                   override fun captureEndValues(transitionValues: TransitionValues) {}

                   override fun createAnimator(
                       sceneRoot: ViewGroup,
                       startValues: TransitionValues?,
                       endValues: TransitionValues?
                   ): Animator? {}

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CustomTransition extends Transition {

                   @Override
                   public void captureStartValues(TransitionValues values) {}

                   @Override
                   public void captureEndValues(TransitionValues values) {}

                   @Override
                   public Animator createAnimator(ViewGroup sceneRoot,
                                                  TransitionValues startValues,
                                                  TransitionValues endValues) {}
               }

   The following sections explain how to override these functions.

   .. rubric:: Capture view property values
      :name: CaptureProperties

   Transition animations use the property animation system described in
   `Property animation overview <#>`__.
   Property animations change a view property from a starting value to an ending
   value over a specified period of time, so the framework needs to have both
   the starting and ending values of the property to construct the animation.

   However, a property animation usually needs only a small subset of all the
   view's property values. For example, a color animation needs color property
   values, while a movement animation needs position property values. Since the
   property values needed for an animation are specific to a transition, the
   transitions framework does not provide every property value to a transition.
   Instead, the framework invokes callback functions that allow a transition to
   capture only the property values it needs and store them in the framework.

   .. rubric:: Capture starting values
      :name: StartingValues

   To pass the starting view values to the framework, implement the
   `captureStartValues(transitionValues) <#android.transition.Transition>`__
   function. The framework calls this function for every view in the starting
   scene. The function argument is a
   `TransitionValues <#android.transition.TransitionValues>`__
   object that contains a reference to the view and a
   `Map <#>`__ instance in which you can store the
   view values you want. In your implementation, retrieve these property values
   and pass them back to the framework by storing them in the map.

   To ensure that the key for a property value does not conflict with other
   ``TransitionValues`` keys, use the following naming scheme:

   .. code:: prettyprint

      package_name:transition_name:property_name

   The following snippet shows an implementation of the ``captureStartValues()``
   function:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CustomTransition : Transition() {

                   // Define a key for storing a property value in
                   // TransitionValues.values with the syntax
                   // package_name:transition_class:property_name to avoid collisions
                   private val PROPNAME_BACKGROUND = "com.example.android.customtransition:CustomTransition:background"

                   override fun captureStartValues(transitionValues: TransitionValues) {
                       // Call the convenience method captureValues
                       captureValues(transitionValues)
                   }

                   // For the view in transitionValues.view, get the values you
                   // want and put them in transitionValues.values
                   private fun captureValues(transitionValues: TransitionValues) {
                       // Get a reference to the view
                       val view = transitionValues.view
                       // Store its background property in the values map
                       transitionValues.values[PROPNAME_BACKGROUND] = view.background
                   }

                   ...

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CustomTransition extends Transition {

                   // Define a key for storing a property value in
                   // TransitionValues.values with the syntax
                   // package_name:transition_class:property_name to avoid collisions
                   private static final String PROPNAME_BACKGROUND =
                           "com.example.android.customtransition:CustomTransition:background";

                   @Override
                   public void captureStartValues(TransitionValues transitionValues) {
                       // Call the convenience method captureValues
                       captureValues(transitionValues);
                   }


                   // For the view in transitionValues.view, get the values you
                   // want and put them in transitionValues.values
                   private void captureValues(TransitionValues transitionValues) {
                       // Get a reference to the view
                       View view = transitionValues.view;
                       // Store its background property in the values map
                       transitionValues.values.put(PROPNAME_BACKGROUND, view.getBackground());
                   }
                   ...
               }

   .. rubric:: Capture ending values
      :name: EndingValues

   The framework calls the
   `captureEndValues(TransitionValues) <#android.transition.Transition>`__
   function once for every target view in the ending scene. In all other
   respects, ``captureEndValues()`` works the same as ``captureStartValues()``.

   The following code snippet shows an implementation of the
   ``captureEndValues()`` function:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun captureEndValues(transitionValues: TransitionValues) {
                   captureValues(transitionValues)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void captureEndValues(TransitionValues transitionValues) {
                   captureValues(transitionValues);
               }

   In this example, both the ``captureStartValues()`` and ``captureEndValues()``
   functions invoke ``captureValues()`` to retrieve and store values. The view
   property that ``captureValues()`` retrieves is the same, but it has different
   values in the starting and ending scenes. The framework maintains separate
   maps for the starting and ending states of a view.

   .. rubric:: Create a custom animator
      :name: CreateAnimator

   To animate the changes to a view between its state in the starting scene and
   its state in the ending scene, provide an animator by overriding the
   `createAnimator() <#android.transition.Transition>`__
   function. When the framework calls this function, it passes in the scene root
   view and the ``TransitionValues`` objects that contain the starting and
   ending values you captured.

   The number of times the framework calls the ``createAnimator()`` function
   depends on the changes that occur between the starting and ending scenes.

   For example, consider a fade-out or fade-in animation implemented as a custom
   transition. If the starting scene has five targets, of which two are removed
   from the ending scene, and the ending scene has the three targets from the
   starting scene plus a new target, then the framework calls
   ``createAnimator()`` six times. Three of the calls animate the fade-out and
   fade-in of the targets that stay in both scene objects. Two more calls
   animate the fade-out of the targets removed from the ending scene. One call
   animates the fade-in of the new target in the ending scene.

   For target views that exist in both the starting and ending scenes, the
   framework provides a ``TransitionValues`` object for both the ``startValues``
   and ``endValues`` arguments. For target views that only exist in the starting
   or the ending scene, the framework provides a ``TransitionValues`` object for
   the corresponding argument and ``null`` for the other.

   To implement the
   `createAnimator(ViewGroup, TransitionValues, TransitionValues) <#android.transition.Transition>`__
   function when you create a custom transition, use the view property values
   you captured to create an
   `Animator <#android.animation.Animator>`__ object and return it
   to the framework. For an example implementation, see the
   `ChangeColor <https://github.com/android/animation-samples/blob/master/CustomTransition/Application/src/main/java/com/example/android/customtransition/ChangeColor.java>`__
   class in the
   `CustomTransition <https://github.com/android/animation-samples/tree/main/CustomTransition>`__
   sample. For more information about property animators, see `Property animation <#>`__.

   .. rubric:: Apply a custom transition
      :name: Apply

   Custom transitions work the same as built-in transitions. You can apply a
   custom transition using a transition manager, as described in `Apply a transition <#Apply>`__.


Last updated 2024-02-22 UTC.


/Start an activity using an animation
=====================================

.. https://developer.android.google.cn/develop/ui/views/animations/transitions/start-activity?hl=en

.. container:: devsite-article-body

   Activity transitions in Material Design apps provide visual connections
   between different states through motion and transformations between common
   elements. You can specify custom animations for enter and exit transitions
   and for transitions of shared elements between activities.

   .. container:: attempt-right

      **Figure 1**. A transition with shared elements.

   -  An *enter* transition determines how views in an activity enter the scene.
      For example, in the ``explode`` enter transition, the views enter the
      scene from the outside and fly inward to the center of the screen.
   -  An *exit* transition determines how views in an activity exit the scene.
      For example, in the ``explode`` exit transition, the views exit the scene
      away from the center.
   -  A *shared elements* transition determines how views that are shared
      between two activities transition between these activities. For example,
      if two activities have the same image in different positions and sizes,
      the ``changeImageTransform`` shared element transition translates and
      scales the image smoothly between these activities.

   Android supports these enter and exit transitions:

   -  ``explode``: moves views in toward or out from the center of the scene.
   -  ``slide``: moves views in or out from one of the edges of the scene.
   -  ``fade``: adds or removes a view from the scene by changing its opacity.

   Any transition that extends the
   `Visibility <#android.transition.Visibility>`__ class is
   supported as an enter or exit transition. For more information, see the API
   reference for the
   `Transition <#android.transition.Transition>`__ class.

   Android also supports these shared elements transitions:

   -  ``changeBounds``: animates the changes in layout bounds of target views.
   -  ``changeClipBounds``: animates the changes in clip bounds of target views.
   -  ``changeTransform``: animates the changes in scale and rotation of target
      views.
   -  ``changeImageTransform``: animates the changes in size and scale of target
      images.

   When you enable activity transitions in your app, the default cross-fading
   transition activates between the entering and exiting activities.

   |image-SceneTransition|

   **Figure 2.** A scene transition with one shared element.

   For sample code that animates between activities using shared elements, see
   `ActivitySceneTransitionBasic <https://github.com/android/animation/tree/main/ActivitySceneTransitionBasic>`__.

   .. rubric:: Check the system version
      :name: CheckVersion

   Activity transition APIs are available on Android 5.0 (API 21) and up. To
   preserve compatibility with earlier versions of Android, check the system
   `version <#android.os.Build.VERSION>`__ at runtime
   before you invoke the APIs for any of these features:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Check if we're running on Android 5.0 or higher
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   // Apply activity transition
               } else {
                   // Swap without transition
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Check if we're running on Android 5.0 or higher
               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                   // Apply activity transition
               } else {
                   // Swap without transition
               }

   .. rubric:: Specify custom transitions
      :name: custom-trans

   First, enable window content transitions with the
   ``android:windowActivityTransitions`` attribute when you define a style that
   inherits from the Material theme. You can also specify enter, exit, and
   shared element transitions in your style definition:

   .. code:: prettyprint

      <style name="BaseAppTheme" parent="android:Theme.Material">
        <!-- enable window content transitions -->
        <item name="android:windowActivityTransitions">true</item>

        <!-- specify enter and exit transitions -->
        <item name="android:windowEnterTransition">@transition/explode</item>
        <item name="android:windowExitTransition">@transition/explode</item>

        <!-- specify shared element transitions -->
        <item name="android:windowSharedElementEnterTransition">
          @transition/change_image_transform</item>
        <item name="android:windowSharedElementExitTransition">
          @transition/change_image_transform</item>
      </style>

   The ``change_image_transform`` transition in this example is defined as
   follows:

   .. code:: prettyprint

      <!-- res/transition/change_image_transform.xml -->
      <!-- (see also Shared Transitions below) -->
      <transitionSet xmlns:android="http://schemas.android.com/apk/res/android">
        <changeImageTransform/>
      </transitionSet>

   The ``changeImageTransform`` element corresponds to the
   `ChangeImageTransform <#android.transition.ChangeImageTransform>`__
   class. For more information, see the API reference for
   `Transition <#android.transition.Transition>`__.

   To enable window content transitions in your code instead, call the
   `Window.requestFeature() <#android.view.Window>`__
   function:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Inside your activity (if you did not enable transitions in your theme)
               with(window) {
                   requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS)

                   // Set an exit transition
                   exitTransition = Explode()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Inside your activity (if you did not enable transitions in your theme)
               getWindow().requestFeature(Window.FEATURE_ACTIVITY_TRANSITIONS);

               // Set an exit transition
               getWindow().setExitTransition(new Explode());

   To specify transitions in your code, call these functions with a
   ``Transition`` object:

   -  `Window.setEnterTransition() <#android.view.Window>`__
   -  `Window.setExitTransition() <#android.view.Window>`__
   -  `Window.setSharedElementEnterTransition() <#android.view.Window>`__
   -  `Window.setSharedElementExitTransition() <#android.view.Window>`__

   The ``setExitTransition()`` and ``setSharedElementExitTransition()``
   functions define the exit transition for the calling activity. The
   ``setEnterTransition()`` and ``setSharedElementEnterTransition()`` functions
   define the enter transition for the called activity.

   To get the full effect of a transition, you must enable window content
   transitions on both the calling and called activities. Otherwise, the calling
   activity starts the exit transition, but then you see the window
   transitions—like scale or fade.

   To start an enter transition as soon as possible, use the
   `Window.setAllowEnterTransitionOverlap() <#android.view.Window>`__
   function on the called activity. This lets you have more dramatic enter
   transitions.

   .. rubric:: Start an activity using transitions
      :name: start-transition

   If you enable transitions and set an exit transition for an activity, the
   transition activates when you launch another activity, as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               startActivity(intent,
                             ActivityOptions.makeSceneTransitionAnimation(this).toBundle())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               startActivity(intent,
                             ActivityOptions.makeSceneTransitionAnimation(this).toBundle());

   If you set an enter transition for the second activity, that transition also
   activates when the activity starts. To disable transitions when you start
   another activity, provide a ``null`` options bundle.

   .. rubric:: Start an activity with a shared element
      :name: start-with-element

   To make a screen transition animation between two activities that have a
   shared element, do the following:

   #. Enable window content transitions in your theme.
   #. Specify a shared elements transition in your style.
   #. Define your transition as an XML resource.
   #. Assign a common name to the shared elements in both layouts with the
      ``android:transitionName`` attribute.
   #. Use the
      `ActivityOptions.makeSceneTransitionAnimation() <#android.app.ActivityOptions>`__
      function.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Get the element that receives the click event
               val imgContainerView = findViewById<View>(R.id.img_container)

               // Get the common element for the transition in this activity
               val androidRobotView = findViewById<View>(R.id.image_small)

               // Define a click listener
               imgContainerView.setOnClickListener( {
                   val intent = Intent(this, Activity2::class.java)
                   // Create the transition animation - the images in the layouts
                   // of both activities are defined with android:transitionName="robot"
                   val options = ActivityOptions
                           .makeSceneTransitionAnimation(this, androidRobotView, "robot")
                   // Start the new activity
                   startActivity(intent, options.toBundle())
               })

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Get the element that receives the click event
               final View imgContainerView = findViewById(R.id.img_container);

               // Get the common element for the transition in this activity
               final View androidRobotView = findViewById(R.id.image_small);

               // Define a click listener
               imgContainerView.setOnClickListener(new View.OnClickListener() {
                   @Override
                   public void onClick(View view) {
                       Intent intent = new Intent(this, Activity2.class);
                       // Create the transition animation - the images in the layouts
                       // of both activities are defined with android:transitionName="robot"
                       ActivityOptions options = ActivityOptions
                           .makeSceneTransitionAnimation(this, androidRobotView, "robot");
                       // Start the new activity
                       startActivity(intent, options.toBundle());
                   }
               });

   For shared dynamic views that you generate in your code, use the
   `View.setTransitionName() <#android.view.View>`__
   function to specify a common element name in both activities.

   To reverse the scene transition animation when you finish the second
   activity, call the
   `Activity.finishAfterTransition() <#android.app.Activity>`__
   function instead of
   `Activity.finish() <#android.app.Activity>`__.

   .. rubric:: Start an activity with multiple shared elements
      :name: start-with-multiple

   To make a scene transition animation between two activities that have more
   than one shared element, define the shared elements in both layouts with the
   ``android:transitionName`` attribute—or use the ``View.setTransitionName()``
   function in both activities—and create an
   `ActivityOptions <#android.app.ActivityOptions>`__ object as
   follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Rename the Pair class from the Android framework to avoid a name clash
               import android.util.Pair as UtilPair
               ...
               val options = ActivityOptions.makeSceneTransitionAnimation(this,
                       UtilPair.create(view1, "agreedName1"),
                       UtilPair.create(view2, "agreedName2"))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(this,
                       Pair.create(view1, "agreedName1"),
                       Pair.create(view2, "agreedName2"));


Last updated 2024-02-22 UTC.

.. |image-SceneTransition| image:: https://developer.android.google.cn/static/training/material/images/SceneTransition.png
   :width: 600px
   :height: 405px


/Manage motion and widget animation
===================================

.. https://developer.android.google.cn/develop/ui/views/animations/motionlayout?hl=en

.. container:: devsite-article-body

   .. container:: video-wrapper

   `MotionLayout <#androidx.constraintlayout.motion.widget.MotionLayout>`__
   is a layout type that helps you manage motion and widget animation in your
   app. ``MotionLayout`` is a subclass of
   `ConstraintLayout <#>`__ and builds on its rich
   layout capabilities. As part of the ``ConstraintLayout`` library,
   ``MotionLayout`` is available as a support library.

   ``MotionLayout`` bridges the gap between layout transitions and complex
   motion handling, offering a mix of features between the `property animation framework <#>`__,
   `TransitionManager <#>`__, and
   `CoordinatorLayout <#androidx.coordinatorlayout.widget.CoordinatorLayout>`__.

   .. container:: float
      :name: simple

   In addition to describing transitions between layouts, ``MotionLayout`` lets
   you animate any layout properties. Moreover, it inherently supports *seekable
   transitions*. This means you can instantly show any point within the
   transition based on some condition, such as touch input. ``MotionLayout``
   also supports keyframes, enabling fully customized transitions to suit your
   needs.

   ``MotionLayout`` is fully declarative, meaning you can describe any
   transitions in XML, no matter how complex.

   **Note:**\  ``MotionLayout`` works only with its direct children. It doesn't
   support nested layout hierarchies or activity transitions.

   .. rubric:: Design considerations
      :name: design-considerations

   ``MotionLayout`` is intended to move, resize, and animate UI elements with
   which users interact, such as buttons and title bars. Don't use motion in
   your app as a gratuitous special effect. Use it to help users understand what
   your app is doing. For more information about designing your app with motion,
   see the Material Design section `Understanding motion <https://material.io/design/motion>`__.

   .. rubric:: Get started
      :name: getting-started

   Follow these steps to start using ``MotionLayout`` in your project.

   #. **Add the ``ConstraintLayout`` dependency:** to use ``MotionLayout`` in
      your project, add the ``ConstraintLayout`` 2.0 dependency to your app's
      ``build.gradle`` file. If you're using AndroidX, add the following
      dependency:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy

               .. code:: prettyprint

                  dependencies {
                      implementation "androidx.constraintlayout:constraintlayout:2.2.0-alpha13"
                      // To use constraintlayout in compose
                      implementation "androidx.constraintlayout:constraintlayout-compose:1.1.0-alpha13"
                  }

            .. container:: section

               .. rubric:: Kotlin
                  :name: kts

               .. code:: prettyprint

                  dependencies {
                      implementation("androidx.constraintlayout:constraintlayout:2.2.0-alpha13")
                      // To use constraintlayout in compose
                      implementation("androidx.constraintlayout:constraintlayout-compose:1.1.0-alpha13")
                  }

   #. **Create a ``MotionLayout`` file:** ``MotionLayout`` is a subclass of
      ``ConstraintLayout``, so you can transform any existing
      ``ConstraintLayout`` into a ``MotionLayout`` by replacing the class name
      in your layout resource file, as shown in the following examples:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: AndroidX
               :name: androidx

            .. code:: prettyprint

               <!-- before: ConstraintLayout -->
               <androidx.constraintlayout.widget.ConstraintLayout .../>
               <!-- after: MotionLayout -->
               <androidx.constraintlayout.motion.widget.MotionLayout .../>
                         

         .. container:: section

            .. rubric:: Support library
               :name: supportlib

            .. code:: prettyprint

               <!-- before: ConstraintLayout -->
               <android.support.constraint.ConstraintLayout .../>
               <!-- after: MotionLayout -->
               <android.support.constraint.motion.MotionLayout .../>
                         

      Here's a full example of a ``MotionLayout`` file, which defines the layout
      shown in figure 1:

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: AndroidX
               :name: androidx

            .. code:: prettyprint

               <?xml version="1.0" encoding="utf-8"?>
               <!-- activity_main.xml -->
               <androidx.constraintlayout.motion.widget.MotionLayout
                   xmlns:android="http://schemas.android.com/apk/res/android"
                   xmlns:app="http://schemas.android.com/apk/res-auto"
                   xmlns:tools="http://schemas.android.com/tools"
                   android:id="@+id/motionLayout"
                   android:layout_width="match_parent"
                   android:layout_height="match_parent"
                   app:layoutDescription="@xml/scene_01"
                   tools:showPaths="true">

                   <View
                       android:id="@+id/button"
                       android:layout_width="64dp"
                       android:layout_height="64dp"
                       android:background="@color/colorAccent"
                       android:text="Button" />

               </androidx.constraintlayout.motion.widget.MotionLayout>
                       

         .. container:: section

            .. rubric:: Support library
               :name: supportlib

            .. code:: prettyprint

               <?xml version="1.0" encoding="utf-8"?>
               <!-- activity_main.xml -->
               <android.support.constraint.motion.MotionLayout
                   xmlns:android="http://schemas.android.com/apk/res/android"
                   xmlns:app="http://schemas.android.com/apk/res-auto"
                   xmlns:tools="http://schemas.android.com/tools"
                   android:id="@+id/motionLayout"
                   android:layout_width="match_parent"
                   android:layout_height="match_parent"
                   app:layoutDescription="@xml/scene_01"
                   tools:showPaths="true">

                   <View
                       android:id="@+id/button"
                       android:layout_width="64dp"
                       android:layout_height="64dp"
                       android:background="@color/colorAccent"
                       android:text="Button" />

               </android.support.constraint.motion.MotionLayout>
                       

   #. **Create a MotionScene:** in the previous ``MotionLayout`` example, the
      ``app:layoutDescription`` attribute references a *motion scene*. A motion
      scene is an XML resource file. Within its
      `<MotionScene> <#>`__
      root element, a motion scene contains all the motion descriptions for the
      corresponding layout. To keep layout information separate from motion
      descriptions, each ``MotionLayout`` references a separate motion scene.
      The definitions in the motion scene take precedence over any similar
      definitions in the ``MotionLayout``.

      Here's an example motion scene file that describes the basic horizontal
      motion in figure 1:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <MotionScene xmlns:android="http://schemas.android.com/apk/res/android"
             xmlns:motion="http://schemas.android.com/apk/res-auto">

             <Transition
                 motion:constraintSetStart="@+id/start"
                 motion:constraintSetEnd="@+id/end"
                 motion:duration="1000">
                 <OnSwipe
                     motion:touchAnchorId="@+id/button"
                     motion:touchAnchorSide="right"
                     motion:dragDirection="dragRight" />
             </Transition>

             <ConstraintSet android:id="@+id/start">
                 <Constraint
                     android:id="@+id/button"
                     android:layout_width="64dp"
                     android:layout_height="64dp"
                     android:layout_marginStart="8dp"
                     motion:layout_constraintBottom_toBottomOf="parent"
                     motion:layout_constraintStart_toStartOf="parent"
                     motion:layout_constraintTop_toTopOf="parent" />
             </ConstraintSet>

             <ConstraintSet android:id="@+id/end">
                 <Constraint
                     android:id="@+id/button"
                     android:layout_width="64dp"
                     android:layout_height="64dp"
                     android:layout_marginEnd="8dp"
                     motion:layout_constraintBottom_toBottomOf="parent"
                     motion:layout_constraintEnd_toEndOf="parent"
                     motion:layout_constraintTop_toTopOf="parent" />
             </ConstraintSet>

         </MotionScene>
             

      Note the following:

      -  `<Transition> <#>`__
         contains the base definition of the motion.

         -  ``motion:constraintSetStart`` and ``motion:constraintSetEnd`` are
            references to the endpoints of the motion. These endpoints are
            defined in the ``<ConstraintSet>`` elements later in the motion
            scene.

         -  ``motion:duration`` specifies the number of milliseconds it takes
            for the motion to complete.

      -  `<OnSwipe> <#>`__
         lets you create touch control for the motion.

         -  ``motion:touchAnchorId`` refers to the view the user can swipe and
            drag.

         -  ``motion:touchAnchorSide`` means the view is being dragged from the
            right side.

         -  ``motion:dragDirection`` refers to the *progress* direction of the
            drag. For example, ``motion:dragDirection="dragRight"`` means
            progress increases as the view is dragged to the right.

      -  `<ConstraintSet> <#>`__
         is where you define the various constraints that describe your motion.
         In this example, one ``<ConstraintSet>`` is defined for each endpoint
         of your motion. These endpoints are centered vertically using
         ``app:layout_constraintTop_toTopOf="parent"`` and
         ``app:layout_constraintBottom_toBottomOf="parent"``. Horizontally, the
         endpoints are at the far left and right sides of the screen.

      For a more detailed look at the various elements that a motion scene
      supports, see the `MotionLayout examples <#>`__.

   .. rubric:: Interpolated attributes
      :name: interpolated

   Within a motion scene file, ``ConstraintSet`` elements can contain additional
   attributes that are interpolated during transition. In addition to position
   and bounds, the following attributes are interpolated by ``MotionLayout``:

   -  ``alpha``
   -  ``visibility``
   -  ``elevation``
   -  ``rotation``, ``rotationX``, ``rotationY``
   -  ``translationX``, ``translationY``, ``translationZ``
   -  ``scaleX``, ``scaleY``

   .. rubric:: Custom attributes
      :name: custom-attributes

   Within a ``<Constraint>``, you can use the ``<CustomAttribute>`` element to
   specify a transition for attributes that aren't simply related to position or
   ``View`` attributes.

   .. code:: prettyprint

      <Constraint
          android:id="@+id/button" ...>
          <CustomAttribute
              motion:attributeName="backgroundColor"
              motion:customColorValue="#D81B60"/>
      </Constraint>

   A ``<CustomAttribute>`` contains two attributes of its own:

   -  ``motion:attributeName`` is required and must match an object with getter
      and setter methods. The getter and setter must match a specific pattern.
      For example, ``backgroundColor`` is supported, since the view has
      underlying ``getBackgroundColor()`` and ``setBackgroundColor()`` methods.
   -  The other attribute you must provide is based on the value type. Choose
      from the following supported types:

      -  ``motion:customColorValue`` for colors
      -  ``motion:customIntegerValue`` for integers
      -  ``motion:customFloatValue`` for floats
      -  ``motion:customStringValue`` for strings
      -  ``motion:customDimension`` for dimensions
      -  ``motion:customBoolean`` for booleans

   When specifying a custom attribute, define endpoint values in both the start
   and end ``<ConstraintSet>`` elements.

   .. rubric:: Change background color
      :name: change-bg-color

   Building on the previous example, suppose you want the view's colors to
   change as part of its motion, as shown in figure 2.

   .. container:: float
      :name: custom

   Add a ``<CustomAttribute>`` element to each ``ConstraintSet`` elements, as
   shown in the following code snippet:

   .. code:: prettyprint

      <ConstraintSet android:id="@+id/start">
          <Constraint
              android:id="@+id/button"
              android:layout_width="64dp"
              android:layout_height="64dp"
              android:layout_marginStart="8dp"
              motion:layout_constraintBottom_toBottomOf="parent"
              motion:layout_constraintStart_toStartOf="parent"
              motion:layout_constraintTop_toTopOf="parent">
              <CustomAttribute
                  motion:attributeName="backgroundColor"
                  motion:customColorValue="#D81B60" />
          </Constraint>
      </ConstraintSet>

      <ConstraintSet android:id="@+id/end">
          <Constraint
              android:id="@+id/button"
              android:layout_width="64dp"
              android:layout_height="64dp"
              android:layout_marginEnd="8dp"
              motion:layout_constraintBottom_toBottomOf="parent"
              motion:layout_constraintEnd_toEndOf="parent"
              motion:layout_constraintTop_toTopOf="parent">
              <CustomAttribute
                  motion:attributeName="backgroundColor"
                  motion:customColorValue="#9999FF" />
          </Constraint>
      </ConstraintSet>

   .. rubric:: Additional MotionLayout attributes
      :name: additional-attributes

   In addition to the attributes in the preceding example, ``MotionLayout`` has
   other attributes you might want to specify:

   -  ``app:applyMotionScene="boolean"`` indicates whether to apply the motion
      scene. The default value for this attribute is ``true``.
   -  ``app:showPaths="boolean"`` indicates whether to show the motion paths as
      the motion is running. The default value for this attribute is ``false``.
   -  ``app:progress="float"`` lets you explicitly specify transition progress.
      You can use any floating-point value from ``0`` (the start of the
      transition) to ``1`` (the end of the transition).
   -  ``app:currentState="reference"`` lets you specify a specific
      ``ConstraintSet``.
   -  ``app:motionDebug`` lets you display additional debug information about
      the motion. Possible values are ``"SHOW_PROGRESS"``, ``"SHOW_PATH"``, or
      ``"SHOW_ALL"``.

   .. rubric:: Additional resources
      :name: additional-resources

   For more information about ``MotionLayout``, see the following resources:

   -  `Advanced Android in Kotlin 03.2: Animation with MotionLayout <https://developers.google.cn/codelabs/codelabs/motion-layout>`__
   -  `MotionLayout examples <#>`__
   -  `MotionLayout/ConstraintLayout Samples <https://github.com/android/views-widgets-samples/tree/main/ConstraintLayoutExamples>`__
      on GitHub
   -  `Introduction to MotionLayout (part I) <https://medium.com/google-developers/introduction-to-motionlayout-part-i-29208674b10d>`__
   -  `Introduction to MotionLayout (part II) <https://medium.com/google-developers/introduction-to-motionlayout-part-ii-a31acc084f59>`__
   -  `Introduction to MotionLayout (part III) <https://medium.com/google-developers/introduction-to-motionlayout-part-iii-47cd64d51a5>`__
   -  `Introduction to MotionLayout (part IV) <https://medium.com/google-developers/defining-motion-paths-in-motionlayout-6095b874d37>`__


Last updated 2024-02-22 UTC.


/Add a carousel
===============

.. https://developer.android.google.cn/develop/ui/views/animations/motionlayout/carousel?hl=en

.. container:: devsite-article-body

   `Carousel <#androidx.constraintlayout.helper.widget.Carousel>`__
   is a motion helper object to build custom carousel views that show a list of
   elements that the user can skim through. Compared to other ways to implement
   such views, this helper lets you quickly create complex motion and dimension
   changes for your ``Carousel`` by taking advantage of
   `MotionLayout <#androidx.constraintlayout.motion.widget.MotionLayout>`__.

   .. container:: float
      :name: carousel-example

   The ``Carousel`` widget supports lists with a start and end as well as
   circular wrap-around lists.

   **Note:**\  For a more hands-on approach, see the `CarouselExperiments sample project <https://github.com/androidx/constraintlayout/tree/main/projects/CarouselExperiments>`__
   on GitHub.

   .. rubric:: How Carousel with MotionLayout works
      :name: concept

   Suppose you want to build a horizontal ``Carousel`` view, with the center
   item enlarged:

   .. figure:: https://developer.android.google.cn/static/images/training/constraint-layout/carousel-ex1.png
      name: carousel-example2
      :alt: An image showing a carousel wireframe
      :width: 50.0%

      **Figure 2.** Example of an image ``Carousel`` showing a larger image in
      the center.

   This basic layout contains several views representing the ``Carousel`` items:

   .. figure:: https://developer.android.google.cn/static/images/training/constraint-layout/carousel-ex2.png
      name: carousel-example3
      :alt: An image showing a carousel wireframe
      :width: 100.0%

      **Figure 3.** Widget details.

   Create a ``MotionLayout`` with the following three states and give them IDs:

   -  **previous**
   -  **start**
   -  **next**

   If the **start** state corresponds to the base layout, in the **previous**
   state and the **next** state the ``Carousel`` items are shifted by one to the
   left and to the right, respectively.

   For example, take the five views in figure 3 and assume that in the **start**
   state, views B, C, and D are visible, and A and E are outside of the screen.
   Set up the **previous** state so that the positions of A, B, C, and D are
   where B, C, D, and E were, with the views moving from left to right. In the
   **next** state, the opposite needs to happen, with B, C, D, and E moving to
   where A, B, C, and D were, and the views moving from right to left. This is
   shown in figure 4:

   .. figure:: https://developer.android.google.cn/static/images/training/constraint-layout/carousel-ex3.png
      name: carousel-example4
      :alt: An image showing a carousel back and forward transition
      :width: 100.0%

      **Figure 4.** ``Carousel`` swiping transitions.

   It's critical that the views end up exactly where the original views start.
   ``Carousel`` gives the illusion of an infinite collection of elements by
   moving the *actual* views back to where they were, but reinitializing them
   with the new matching content. The following diagram shows this mechanism.
   Pay attention to the "item #" values):

   .. figure:: https://developer.android.google.cn/static/images/training/constraint-layout/carousel-ex4.png
      name: carousel-example5
      :alt: An image showing a carousel back and forward transition
      :width: 100.0%

      **Figure 5.** ``Carousel`` swiping transitions and state reset.

   .. rubric:: Transitions
      :name: transitions

   With these three constraint sets defined in your motion scene file, create
   two transitions—forward and backward—between the **start** and **next**
   states and the **start** and **previous** states. Add an
   `OnSwipe <#>`__
   handler to trigger the transitions in response to a gesture, as shown in the
   following example:

   .. code:: prettyprint

          <Transition
              motion:constraintSetStart="@id/start"
              motion:constraintSetEnd="@+id/next"
              motion:duration="1000"
              android:id="@+id/forward">
              <OnSwipe
                  motion:dragDirection="dragLeft"
                  motion:touchAnchorSide="left" />
          </Transition>

          <Transition
              motion:constraintSetStart="@+id/start"
              motion:constraintSetEnd="@+id/previous"
              android:id="@+id/backward">
              <OnSwipe
                  motion:dragDirection="dragRight"
                  motion:touchAnchorSide="right" />
          </Transition>

   .. rubric:: Add the Carousel
      :name: adding-the-carousel

   After this basic motion scene is created, add a ``Carousel`` helper to the
   layout and reference the views in the same order you implement your previous
   and next animation.

   Set the following attributes for the ``Carousel`` helper:

   -  ``app:carousel_firstView``: the view that represents the first element of
      the ``Carousel``—in this example, C.
   -  ``app:carousel_previousState``: the ``ConstraintSet`` ID of the
      **previous** state.
   -  ``app:carousel_nextState``: the ``ConstraintSet`` ID of the **next**
      state.
   -  ``app:carousel_backwardTransition``: the
      `Transition <#androidx.constraintlayout.motion.widget.MotionLayout>`__
      ID applied between the **start** and **previous** states.
   -  ``app:carousel_forwardTransition``: the ``Transition`` ID applied between
      the **start** and **next** states.

   For example, you have something like this in your layout XML file:

   .. code:: prettyprint

          <androidx.constraintlayout.motion.widget.MotionLayout ... >

              <ImageView  android:id="@+id/imageView0" .. />
              <ImageView  android:id="@+id/imageView1" .. />
              <ImageView  android:id="@+id/imageView2" .. />
              <ImageView  android:id="@+id/imageView3" .. />
              <ImageView  android:id="@+id/imageView4" .. />

              <androidx.constraintlayout.helper.widget.Carousel
                  android:id="@+id/carousel"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  app:carousel_forwardTransition="@+id/forward"
                  app:carousel_backwardTransition="@+id/backward"
                  app:carousel_previousState="@+id/previous"
                  app:carousel_nextState="@+id/next"
                  app:carousel_infinite="true"
                  app:carousel_firstView="@+id/imageView2"
                  app:constraint_referenced_ids="imageView0,imageView1,imageView2,imageView3,imageView4" />

          </androidx.constraintlayout.motion.widget.MotionLayout>

   Set up a ``Carousel`` adapter in code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               carousel.setAdapter(object : Carousel.Adapter {
                           override fun count(): Int {
                             // Return the number of items in the Carousel.
                           }

                           override fun populate(view: View, index: Int) {
                               // Implement this to populate the view at the given index.
                           }

                           override fun onNewItem(index: Int) {
                               // Called when an item is set.
                           }
                       })

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               carousel.setAdapter(new Carousel.Adapter() {
                           @Override
                           public int count() {
                               // Return the number of items in the Carousel.
                           }

                           @Override
                           public void populate(View view, int index) {
                               // Populate the view at the given index.
                           }

                           @Override
                           public void onNewItem(int index) {
                                // Called when an item is set.
                           }
                       });

   .. rubric:: Additional notes
      :name: notes

   Depending on the current item "selected" in the ``Carousel``, the views
   representing the items before or after might need to be hidden to correctly
   account for the ``Carousel`` **start** and **end**. The ``Carousel`` helper
   handles this automatically. By default, it marks those views as
   ``View.INVISIBLE`` in these situations, so the overall layout doesn't change.

   An alternative mode is available in which the ``Carousel`` helper instead
   marks those views as ``View.GONE``. You can set this mode using the following
   property:

   .. code:: prettyprint

      app:carousel_emptyViewsBehavior="gone"

   .. rubric:: Examples
      :name: examples

   For more examples using the Carousel helper, see the `example projects <https://github.com/androidx/constraintlayout/tree/main/projects/CarouselExperiments>`__
   on GitHub.


Last updated 2024-02-22 UTC.


/MotionLayout examples
======================

.. https://developer.android.google.cn/develop/ui/views/animations/motionlayout/examples?hl=en

.. container:: devsite-article-body

   This document contains examples of how to use
   `MotionLayout <#androidx.constraintlayout.motion.widget.MotionLayout>`__.
   Each example includes a video demonstrating the motion, along with
   corresponding code for the motion scene and layouts.

   .. rubric:: Basic motion
      :name: basic

   This example contains a single view that you can touch and drag to move
   horizontally.

   -  View the `layout XML <https://github.com/android/platform-samples/blob/main/samples/user-interface/constraintlayout/src/main/res/layout/motion_02_basic.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/platform-samples/blob/main/samples/user-interface/constraintlayout/src/main/res/xml/scene_02.xml>`__.

   .. container:: float
      :name: horizontal

   .. rubric:: Custom attribute - backgroundColor
      :name: custom-attribute

   This example is similar to the `Basic motion <#basic>`__ example. In addition
   to the basic motion, the background color of the view changes as the view
   moves.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_03_custom_attribute.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_03.xml>`__.

   .. container:: float
      :name: custom-attribute

   .. rubric:: ImageFilterView - image transition
      :name: ImageFilterView

   This example shows how to transition the saturation value of an
   ``ImageFilterView``.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_05_imagefilter.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_05.xml>`__.

   .. container:: float
      :name: imagefilter

   .. rubric:: Keyframe position
      :name: keyframe-position

   This example uses ``<KeyFrameSet>`` to alter the Y position of the view
   during motion.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_06_keyframe.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_06.xml>`__.

   .. container:: float
      :name: keyframe

   .. rubric:: Keyframe interpolation
      :name: keyframe-interpolation

   This example builds on the `Keyframe position <#keyframe-position>`__
   example, adding rotation and scaling to the view transition.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_07_keyframe.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_07.xml>`__.

   .. container:: float
      :name: keyframe2

   .. rubric:: Keyframe cycle
      :name: keyframe-cycle

   This example adds ``<KeyCycle>`` elements to add wavelike motion to the view.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_08_cycle.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_08.xml>`__.

   .. container:: float
      :name: keyframe3

   .. rubric:: CoordinatorLayout (1/2)
      :name: coortinatorlayout1

   This example adds a ``MotionLayout`` to an existing ``AppBarLayout`` to add
   motion to the app bar. This example is further described in `Introduction to
   MotionLayout (part III) <https://medium.com/google-developers/introduction-to-motionlayout-part-iii-47cd64d51a5>`__.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_09_coordinatorlayout.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_09.xml>`__.

   .. container:: float
      :name: coordinatorlayout1

   .. rubric:: CoordinatorLayout (2/2)
      :name: coordinatorlayout2

   This example adds a ``MotionLayout`` to an existing ``AppBarLayout`` to add
   motion to the app bar.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_10_coordinatorlayout.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_10_header.xml>`__.

   .. container:: float
      :name: coordinatorlayout2

   .. rubric:: DrawerLayout (1/2)
      :name: drawerlayout

   This example shows how to add motion to a ``DrawerLayout``. This example is
   further described in `Introduction to MotionLayout (part III) <https://medium.com/google-developers/introduction-to-motionlayout-part-iii-47cd64d51a5>`__.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_12_drawerlayout.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_12_content.xml>`__.

   .. container:: float
      :name: drawerlayout1

   .. rubric:: DrawerLayout (2/2)
      :name: drawerlayout2

   This example shows how to add motion to a ``DrawerLayout``.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_13_drawerlayout.xml>`__.
   -  View the `MotionScene XML for the main content <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_12_content.xml>`__.
   -  View the `MotionScene XML for the menu <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_13_menu.xml>`__.

   .. container:: float
      :name: drawerlayout2

   .. rubric:: Side panel
      :name: sidepanel

   This example shows how to display a side panel when dragging the main content
   area to the right.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_14_side_panel.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_14.xml>`__.

   .. container:: float
      :name: drawerlayout2

   .. rubric:: Parallax
      :name: parallax

   This example demonstrates a parallax background, where different background
   layers move at different speeds.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_15_parallax.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_15.xml>`__.

   .. container:: float
      :name: parallax

   .. rubric:: ViewPager
      :name: viewpager

   This example shows how you can add motion when swiping between ``ViewPager``
   tabs. This example is further described in `Introduction to MotionLayout
   (part III) <https://medium.com/google-developers/introduction-to-motionlayout-part-iii-47cd64d51a5>`__.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_16_viewpager.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_15.xml>`__.

   .. container:: float
      :name: viewpager

   .. rubric:: ViewPager - Lottie
      :name: viewpager-lottie

   This example shows how you can add motion when swiping between ``ViewPager``
   tabs.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_23_viewpager.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_23.xml>`__.

   .. container:: float
      :name: viewpager-lottie

   .. rubric:: Complex motion (1/3)
      :name: complex-1

   This example combines elements from previous examples to demonstrate complex
   motion.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_17_coordination.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_17.xml>`__.

   .. container:: float
      :name: complex

   .. rubric:: Complex motion (2/3)
      :name: complex-2

   This example combines elements from previous examples to demonstrate complex
   motion.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_18_coordination.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_18.xml>`__.

   .. container:: float
      :name: complex2

   .. rubric:: Complex motion (3/3)
      :name: complex3

   This example combines elements from previous examples to demonstrate complex
   motion.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_19_coordination.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_19.xml>`__.

   .. container:: float
      :name: complex3

   .. rubric:: Fragment transition (1/2)
      :name: fragment-transition

   This example shows how you can use ``MotionLayout`` to transition between
   fragments.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/main_activity.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/main_scene.xml>`__.

   .. container:: float
      :name: fragment-transition-1

   .. rubric:: Fragment transition (2/2)
      :name: fragment-transition2

   This example shows how you can use ``MotionLayout`` to transition between
   fragments.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/main_activity.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/main_scene.xml>`__.

   .. container:: float
      :name: fragment-transition-2

   .. rubric:: YouTube-like motion
      :name: youtube-motion

   This example demonstrates transitioning between a compact view and a
   full-screen experience with additional content.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_24_youtube.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_24.xml>`__.

   .. container:: float
      :name: youtube-motion

   .. rubric:: KeyTrigger
      :name: keytrigger

   This example demonstrates how to show and hide a floating action button when
   the transition crosses a progress threshold.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_25_keytrigger.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_25.xml>`__.

   .. container:: float
      :name: keytrigger

   .. rubric:: Multi-state
      :name: multistate

   This example shows how to use state to determine which motion to apply.

   -  View the `layout XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/layout/motion_26_multistate.xml>`__.
   -  View the `MotionScene XML <https://github.com/android/views-widgets-samples/blob/master/ConstraintLayoutExamples/motionlayout/src/main/res/xml/scene_26.xml>`__.

   .. container:: float
      :name: multistate


Last updated 2024-02-22 UTC.


/Use ViewPager2 to slide between fragments
==========================================

.. https://developer.android.google.cn/develop/ui/views/animations/screen-slide-2?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Pager in Compose.

      `Pager → <https://developer.android.google.cn/jetpack/compose/layouts/pager>`__

      |image-android-compose-ui-logo|

   Screen slides are transitions from one entire screen to another and are
   common with UIs like setup wizards and slideshows. This topic shows you how
   to do screen slides with a
   `ViewPager2 <#>`__
   object. ``ViewPager2`` objects can animate screen slides automatically.
   Here's an example of a screen slide that transitions from one screen of
   content to the next:

   .. container:: framed-galaxynexus-land-span-8

   .. container:: figure-caption

      **Figure 1.** Screen slide animation.

      .. container:: video-instructions

          

   If you want to jump ahead and see a full working example, `view this sample app <https://github.com/android/views-widgets-samples/tree/main/ViewPager2>`__
   on GitHub.

   **Note:** If your app already uses
   `ViewPager <#>`__,
   see `Migrate from ViewPager to ViewPager2 <#>`__.
   To use ``ViewPager2``, you need to add some `AndroidX dependencies <#androidx-deps>`__ to your
   project. Then follow the steps outlined in the following sections.

   .. rubric:: Create the views
      :name: views

   Create a layout file to use later for the content of a fragment. You also
   need to define a string for the contents of the fragment. The following
   example contains a text view that displays some text:

   .. code:: prettyprint

      <!-- fragment_screen_slide_page.xml -->
      <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/content"
          android:layout_width="match_parent"
          android:layout_height="match_parent" >

          <TextView style="?android:textAppearanceMedium"
              android:padding="16dp"
              android:lineSpacingMultiplier="1.2"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="@string/lorem_ipsum" />
      </ScrollView>

   .. rubric:: Create the fragment
      :name: fragment

   Create a `Fragment <#>`__
   class that returns the layout that you created in the
   `onCreateView() <#onCreateView(android.view.LayoutInflater,%20android.view.ViewGroup,%20android.os.Bundle)>`__
   method. You can then create instances of this fragment in the parent activity
   whenever you need a new page to display to the user:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import androidx.fragment.app.Fragment

               class ScreenSlidePageFragment : Fragment() {

                   override fun onCreateView(
                           inflater: LayoutInflater,
                           container: ViewGroup?,
                           savedInstanceState: Bundle?
                   ): View = inflater.inflate(R.layout.fragment_screen_slide_page, container, false)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.fragment.app.Fragment;
               ...
               public class ScreenSlidePageFragment extends Fragment {

                   @Override
                   public View onCreateView(LayoutInflater inflater, ViewGroup container,
                           Bundle savedInstanceState) {
                       return (ViewGroup) inflater.inflate(
                               R.layout.fragment_screen_slide_page, container, false);
                   }
               }

   .. rubric:: Add a ViewPager2
      :name: viewpager

   ``ViewPager2`` objects have built-in swipe gestures to transition through
   pages, and they display screen slide animations by default, so you don't need
   to create your own animation. ``ViewPager2`` uses
   `FragmentStateAdapter <#>`__
   objects as a supply for new pages to display, so the ``FragmentStateAdapter``
   uses the fragment class that you created.

   To begin, create a layout that contains a ``ViewPager2`` object:

   .. code:: prettyprint

      <!-- activity_screen_slide.xml -->
      <androidx.viewpager2.widget.ViewPager2
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   Create an activity that does the following:

   -  Sets the content view to be the layout with the ``ViewPager2``.
   -  Creates a class that extends the ``FragmentStateAdapter`` abstract class
      and implements the
      `createFragment() <#createFragment(int)>`__
      method to supply instances of ``ScreenSlidePageFragment`` as new pages.
      You must implement the
      `getItemCount() <#getItemCount()>`__
      method for the pager adapter, which returns the number of pages the
      adapter creates. There are five in the example.
   -  Hooks up the ``FragmentStateAdapter`` to the ``ViewPager2`` objects.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import androidx.fragment.app.Fragment
               import androidx.fragment.app.FragmentActivity
               ...
               /**
                * The number of pages (wizard steps) to show in this demo.
                */
               private const val NUM_PAGES = 5

               class ScreenSlidePagerActivity : FragmentActivity() {

                   /**
                    * The pager widget, which handles animation and allows swiping horizontally
                    * to access previous and next wizard steps.
                    */
                   private lateinit var viewPager: ViewPager2

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_screen_slide)

                       // Instantiate a ViewPager2 and a PagerAdapter.
                       viewPager = findViewById(R.id.pager)

                       // The pager adapter, which provides the pages to the view pager widget.
                       val pagerAdapter = ScreenSlidePagerAdapter(this)
                       viewPager.adapter = pagerAdapter
                   }

                   override fun onBackPressed() {
                       if (viewPager.currentItem == 0) {
                           // If the user is currently looking at the first step, allow the system to handle
                           // the Back button. This calls finish() on this activity and pops the back stack.
                           super.onBackPressed()
                       } else {
                           // Otherwise, select the previous step.
                           viewPager.currentItem = viewPager.currentItem - 1
                       }
                   }

                   /**
                    * A simple pager adapter that represents 5 ScreenSlidePageFragment objects, in
                    * sequence.
                    */
                   private inner class ScreenSlidePagerAdapter(fa: FragmentActivity) : FragmentStateAdapter(fa) {
                       override fun getItemCount(): Int = NUM_PAGES

                       override fun createFragment(position: Int): Fragment = ScreenSlidePageFragment()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import androidx.fragment.app.Fragment;
               import androidx.fragment.app.FragmentActivity;
               ...
               public class ScreenSlidePagerActivity extends FragmentActivity {
                   /**
                    * The number of pages (wizard steps) to show in this demo.
                    */
                   private static final int NUM_PAGES = 5;

                   /**
                    * The pager widget, which handles animation and allows swiping horizontally to access previous
                    * and next wizard steps.
                    */
                   private ViewPager2 viewPager;

                   /**
                    * The pager adapter, which provides the pages to the view pager widget.
                    */
                   private FragmentStateAdapter pagerAdapter;

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_screen_slide);

                       // Instantiate a ViewPager2 and a PagerAdapter.
                       viewPager = findViewById(R.id.pager);
                       pagerAdapter = new ScreenSlidePagerAdapter(this);
                       viewPager.setAdapter(pagerAdapter);
                   }

                   @Override
                   public void onBackPressed() {
                       if (viewPager.getCurrentItem() == 0) {
                           // If the user is currently looking at the first step, allow the system to handle the
                           // Back button. This calls finish() on this activity and pops the back stack.
                           super.onBackPressed();
                       } else {
                           // Otherwise, select the previous step.
                           viewPager.setCurrentItem(viewPager.getCurrentItem() - 1);
                       }
                   }

                   /**
                    * A simple pager adapter that represents 5 ScreenSlidePageFragment objects, in
                    * sequence.
                    */
                   private class ScreenSlidePagerAdapter extends FragmentStateAdapter {
                       public ScreenSlidePagerAdapter(FragmentActivity fa) {
                           super(fa);
                       }

                       @Override
                       public Fragment createFragment(int position) {
                           return new ScreenSlidePageFragment();
                       }

                       @Override
                       public int getItemCount() {
                           return NUM_PAGES;
                       }
                   }
               }

   .. rubric:: Customize the animation using PageTransformer
      :name: pagetransformer

   To display a different animation from the default screen slide animation,
   implement the
   `ViewPager2.PageTransformer <#>`__
   interface and supply it to the ``ViewPager2`` object. The interface exposes a
   single method,
   `transformPage() <#transformPage(android.view.View,%20float)>`__.
   At each point in the screen's transition, this method is called once for each
   visible page—there's usually only one visible page—and for adjacent pages off
   the screen. For example, if page three is visible and the user drags towards
   page four, ``transformPage()`` is called for pages two, three, and four at
   each step of the gesture.

   In your implementation of ``transformPage()``, you can then create custom
   slide animations by determining which pages need to be transformed based on
   the position of the page on the screen. Obtain the page position from the
   ``position`` parameter of the ``transformPage()`` method.

   The ``position`` parameter indicates where a given page is located relative
   to the center of the screen. This parameter is a dynamic property that
   changes as the user scrolls through a series of pages. When a page fills the
   screen, its position value is ``0``. When a page is drawn off the right side
   of the screen, its position value is ``1``. If the user scrolls halfway
   between pages one and two, page one has a position of ``-0.5``, and page two
   has a position of ``0.5``. Based on the position of the pages on the screen,
   you can create custom slide animations by setting page properties with
   methods such as
   `setAlpha() <#setalpha>`__,
   `setTranslationX() <#settranslationx>`__,
   or `setScaleY() <#setscaley>`__.

   When you have an implementation of a
   `PageTransformer <#>`__,
   call
   `setPageTransformer() <#setPageTransformer(androidx.viewpager2.widget.ViewPager2.PageTransformer)>`__
   with your implementation to apply your custom animations. For example, if you
   have a ``PageTransformer`` named ``ZoomOutPageTransformer``, you can set your
   custom animations like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val viewPager: ViewPager2 = findViewById(R.id.pager)
               ...
               viewPager.setPageTransformer(ZoomOutPageTransformer())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ViewPager2 viewPager = findViewById(R.id.pager);
               ...
               viewPager.setPageTransformer(new ZoomOutPageTransformer());

   See the `Zoom-out page transformer <#zoom-out>`__ and `Depth page transformer <#depth-page>`__ sections for examples of a ``PageTransformer``.

   .. rubric:: Zoom-out page transformer
      :name: zoom-out

   This page transformer shrinks and fades pages when scrolling between adjacent
   pages. As a page gets closer to the center, it grows back to its normal size
   and fades in.

   .. container:: framed-galaxynexus-land-span-8

   .. container:: figure-caption

      **Figure 2.** ``ZoomOutPageTransformer`` example.

      .. container:: video-instructions

          

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val MIN_SCALE = 0.85f
               private const val MIN_ALPHA = 0.5f

               class ZoomOutPageTransformer : ViewPager2.PageTransformer {

                   override fun transformPage(view: View, position: Float) {
                       view.apply {
                           val pageWidth = width
                           val pageHeight = height
                           when {
                               position < -1 -> { // [-Infinity,-1)
                                   // This page is way off-screen to the left.
                                   alpha = 0f
                               }
                               position <= 1 -> { // [-1,1]
                                   // Modify the default slide transition to shrink the page as well.
                                   val scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position))
                                   val vertMargin = pageHeight * (1 - scaleFactor) / 2
                                   val horzMargin = pageWidth * (1 - scaleFactor) / 2
                                   translationX = if (position < 0) {
                                       horzMargin - vertMargin / 2
                                   } else {
                                       horzMargin + vertMargin / 2
                                   }

                                   // Scale the page down (between MIN_SCALE and 1).
                                   scaleX = scaleFactor
                                   scaleY = scaleFactor

                                   // Fade the page relative to its size.
                                   alpha = (MIN_ALPHA +
                                           (((scaleFactor - MIN_SCALE) / (1 - MIN_SCALE)) * (1 - MIN_ALPHA)))
                               }
                               else -> { // (1,+Infinity]
                                   // This page is way off-screen to the right.
                                   alpha = 0f
                               }
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ZoomOutPageTransformer implements ViewPager2.PageTransformer {
                   private static final float MIN_SCALE = 0.85f;
                   private static final float MIN_ALPHA = 0.5f;

                   public void transformPage(View view, float position) {
                       int pageWidth = view.getWidth();
                       int pageHeight = view.getHeight();

                       if (position < -1) { // [-Infinity,-1)
                           // This page is way off-screen to the left.
                           view.setAlpha(0f);

                       } else if (position <= 1) { // [-1,1]
                           // Modify the default slide transition to shrink the page as well.
                           float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
                           float vertMargin = pageHeight * (1 - scaleFactor) / 2;
                           float horzMargin = pageWidth * (1 - scaleFactor) / 2;
                           if (position < 0) {
                               view.setTranslationX(horzMargin - vertMargin / 2);
                           } else {
                               view.setTranslationX(-horzMargin + vertMargin / 2);
                           }

                           // Scale the page down (between MIN_SCALE and 1).
                           view.setScaleX(scaleFactor);
                           view.setScaleY(scaleFactor);

                           // Fade the page relative to its size.
                           view.setAlpha(MIN_ALPHA +
                                   (scaleFactor - MIN_SCALE) /
                                   (1 - MIN_SCALE) * (1 - MIN_ALPHA));

                       } else { // (1,+Infinity]
                           // This page is way off-screen to the right.
                           view.setAlpha(0f);
                       }
                   }
               }

   .. rubric:: Depth page transformer
      :name: depth-page

   This page transformer uses the default slide animation for sliding pages to
   the left, while using a "depth" animation for sliding pages to the right.
   This depth animation fades the page out and scales it down linearly.

   .. container:: framed-galaxynexus-land-span-8

   .. container:: figure-caption

      **Figure 3.** ``DepthPageTransformer`` example.

      .. container:: video-instructions

          

   During the depth animation, the default animation (a screen slide) still
   takes place, so you must counteract the screen slide with a negative X
   translation. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               view.translationX = -1 * view.width * position

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               view.setTranslationX(-1 * view.getWidth() * position);

   The following example shows how to counteract the default screen slide
   animation in a working page transformer:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val MIN_SCALE = 0.75f

               @RequiresApi(21)
               class DepthPageTransformer : ViewPager2.PageTransformer {

                   override fun transformPage(view: View, position: Float) {
                       view.apply {
                           val pageWidth = width
                           when {
                               position < -1 -> { // [-Infinity,-1)
                                   // This page is way off-screen to the left.
                                   alpha = 0f
                               }
                               position <= 0 -> { // [-1,0]
                                   // Use the default slide transition when moving to the left page.
                                   alpha = 1f
                                   translationX = 0f
                                   translationZ = 0f
                                   scaleX = 1f
                                   scaleY = 1f
                               }
                               position <= 1 -> { // (0,1]
                                   // Fade the page out.
                                   alpha = 1 - position

                                   // Counteract the default slide transition.
                                   translationX = pageWidth * -position
                                   // Move it behind the left page.
                                   translationZ = -1f

                                   // Scale the page down (between MIN_SCALE and 1).
                                   val scaleFactor = (MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)))
                                   scaleX = scaleFactor
                                   scaleY = scaleFactor
                               }
                               else -> { // (1,+Infinity]
                                   // This page is way off-screen to the right.
                                   alpha = 0f
                               }
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @RequiresApi(21)
               public class DepthPageTransformer implements ViewPager2.PageTransformer {
                   private static final float MIN_SCALE = 0.75f;

                   public void transformPage(View view, float position) {
                       int pageWidth = view.getWidth();

                       if (position < -1) { // [-Infinity,-1)
                           // This page is way off-screen to the left.
                           view.setAlpha(0f);

                       } else if (position <= 0) { // [-1,0]
                           // Use the default slide transition when moving to the left page.
                           view.setAlpha(1f);
                           view.setTranslationX(0f);
                           view.setTranslationZ(0f);
                           view.setScaleX(1f);
                           view.setScaleY(1f);

                       } else if (position <= 1) { // (0,1]
                           // Fade the page out.
                           view.setAlpha(1 - position);

                           // Counteract the default slide transition.
                           view.setTranslationX(pageWidth * -position);
                           // Move it behind the left page
                           view.setTranslationZ(-1f);

                           // Scale the page down (between MIN_SCALE and 1).
                           float scaleFactor = MIN_SCALE
                                   + (1 - MIN_SCALE) * (1 - Math.abs(position));
                           view.setScaleX(scaleFactor);
                           view.setScaleY(scaleFactor);

                       } else { // (1,+Infinity]
                           // This page is way off-screen to the right.
                           view.setAlpha(0f);
                       }
                   }
               }

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about ``ViewPager2``, see the following additional resources.

   .. rubric:: Samples
      :name: samples

   -  `ViewPager2 samples <https://goo.gle/viewpager2-sample>`__ on GitHub.

   .. rubric:: Videos
      :name: videos

   -  `Turning the Page: Migrating to ViewPager2 <https://www.youtube.com/watch?v=lAP6cz1HSzA>`__ (Android Dev
      Summit '19)


Last updated 2024-04-15 UTC.



/Use ViewPager to slide between fragments
=========================================

.. https://developer.android.google.cn/develop/ui/views/animations/screen-slide?hl=en

.. container:: devsite-article-body

   Screen slides are transitions between one entire screen to another and are
   common with UIs like setup wizards or slideshows. This lesson shows you how
   to do screen slides with a
   `ViewPager <#androidx.viewpager.widget.ViewPager>`__ provided
   by the `support library <#>`__.
   `ViewPager <#androidx.viewpager.widget.ViewPager>`__ objects
   can animate screen slides automatically. Here's what a screen slide looks
   like that transitions from one screen of content to the next:

   .. container:: framed-galaxynexus-land-span-8

   .. container:: figure-caption

      Screen slide animation

      .. container:: video-instructions

          

   `ViewPager <#androidx.viewpager.widget.ViewPager>`__ is part of
   AndroidX. For more information, see `Using AndroidX <#using_androidx>`__.

   **Note:** For sliding screens, we recommend the improved
   `ViewPager2 <#>`__
   library. For more information, see `Slide between fragments using ViewPager2 <#>`__ and `the ViewPager2 migration guide <#>`__.

   .. rubric:: Create the views
      :name: views

   Create a layout file that you'll later use for the content of a fragment. You
   also need to define a string for the contents of the fragment. The following
   example contains a text view to display some text:

   .. code:: prettyprint

      <!-- fragment_screen_slide_page.xml -->
      <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/content"
          android:layout_width="match_parent"
          android:layout_height="match_parent" >

          <TextView style="?android:textAppearanceMedium"
              android:padding="16dp"
              android:lineSpacingMultiplier="1.2"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="@string/lorem_ipsum" />
      </ScrollView>

   .. rubric:: Create the fragment
      :name: fragment

   Create a `Fragment <#androidx.fragment.app.Fragment>`__ class
   that returns the layout that you just created in the
   `onCreateView() <#android.app.Fragment>`__
   method. You can then create instances of this fragment in the parent activity
   whenever you need a new page to display to the user:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import android.support.v4.app.Fragment

               class ScreenSlidePageFragment : Fragment() {

                   override fun onCreateView(
                           inflater: LayoutInflater,
                           container: ViewGroup?,
                           savedInstanceState: Bundle?
                   ): View = inflater.inflate(R.layout.fragment_screen_slide_page, container, false)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import android.support.v4.app.Fragment;
               ...
               public class ScreenSlidePageFragment extends Fragment {

                   @Override
                   public View onCreateView(LayoutInflater inflater, ViewGroup container,
                           Bundle savedInstanceState) {
                       ViewGroup rootView = (ViewGroup) inflater.inflate(
                               R.layout.fragment_screen_slide_page, container, false);

                       return rootView;
                   }
               }

   .. rubric:: Add a ViewPager
      :name: viewpager

   `ViewPager <#androidx.viewpager.widget.ViewPager>`__ objects
   have built-in swipe gestures to transition through pages, and they display
   screen slide animations by default, so you don't need to create your own
   animation. `ViewPager <#androidx.viewpager.widget.ViewPager>`__
   uses `PagerAdapter <#androidx.viewpager.widget.PagerAdapter>`__
   objects as a supply for new pages to display, so the
   `PagerAdapter <#androidx.viewpager.widget.PagerAdapter>`__ will
   use the fragment class that you created earlier.

   To begin, create a layout that contains a
   `ViewPager <#androidx.viewpager.widget.ViewPager>`__:

   .. code:: prettyprint

      <!-- activity_screen_slide.xml -->
      <android.support.v4.view.ViewPager
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   Create an activity that does the following things:

   -  Sets the content view to be the layout with the
      `ViewPager <#androidx.viewpager.widget.ViewPager>`__.
   -  Creates a class that extends the
      `FragmentStatePagerAdapter <#androidx.legacy.app.FragmentStatePagerAdapter>`__
      abstract class and implements the
      `getItem() <#androidx.fragment.app.FragmentStatePagerAdapter>`__
      method to supply instances of ``ScreenSlidePageFragment`` as new pages.
      The pager adapter also requires that you implement the
      `getCount() <#androidx.viewpager.widget.PagerAdapter>`__
      method, which returns the amount of pages the adapter will create (five in
      the example).
   -  Hooks up the
      `PagerAdapter <#androidx.viewpager.widget.PagerAdapter>`__
      to the `ViewPager <#androidx.viewpager.widget.ViewPager>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import android.support.v4.app.Fragment
               import android.support.v4.app.FragmentManager
               ...
               /**
                * The number of pages (wizard steps) to show in this demo.
                */
               private const val NUM_PAGES = 5

               class ScreenSlidePagerActivity : FragmentActivity() {

                   /**
                    * The pager widget, which handles animation and allows swiping horizontally to access previous
                    * and next wizard steps.
                    */
                   private lateinit var mPager: ViewPager

                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_screen_slide)

                       // Instantiate a ViewPager and a PagerAdapter.
                       mPager = findViewById(R.id.pager)

                       // The pager adapter, which provides the pages to the view pager widget.
                       val pagerAdapter = ScreenSlidePagerAdapter(supportFragmentManager)
                       mPager.adapter = pagerAdapter
                   }

                   override fun onBackPressed() {
                       if (mPager.currentItem == 0) {
                           // If the user is currently looking at the first step, allow the system to handle the
                           // Back button. This calls finish() on this activity and pops the back stack.
                           super.onBackPressed()
                       } else {
                           // Otherwise, select the previous step.
                           mPager.currentItem = mPager.currentItem - 1
                       }
                   }

                   /**
                    * A simple pager adapter that represents 5 ScreenSlidePageFragment objects, in
                    * sequence.
                    */
                   private inner class ScreenSlidePagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) {
                       override fun getCount(): Int = NUM_PAGES

                       override fun getItem(position: Int): Fragment = ScreenSlidePageFragment()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import android.support.v4.app.Fragment;
               import android.support.v4.app.FragmentManager;
               ...
               public class ScreenSlidePagerActivity extends FragmentActivity {
                   /**
                    * The number of pages (wizard steps) to show in this demo.
                    */
                   private static final int NUM_PAGES = 5;

                   /**
                    * The pager widget, which handles animation and allows swiping horizontally to access previous
                    * and next wizard steps.
                    */
                   private ViewPager mPager;

                   /**
                    * The pager adapter, which provides the pages to the view pager widget.
                    */
                   private PagerAdapter pagerAdapter;

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_screen_slide);

                       // Instantiate a ViewPager and a PagerAdapter.
                       mPager = (ViewPager) findViewById(R.id.pager);
                       pagerAdapter = new ScreenSlidePagerAdapter(getSupportFragmentManager());
                       mPager.setAdapter(pagerAdapter);
                   }

                   @Override
                   public void onBackPressed() {
                       if (mPager.getCurrentItem() == 0) {
                           // If the user is currently looking at the first step, allow the system to handle the
                           // Back button. This calls finish() on this activity and pops the back stack.
                           super.onBackPressed();
                       } else {
                           // Otherwise, select the previous step.
                           mPager.setCurrentItem(mPager.getCurrentItem() - 1);
                       }
                   }

                   /**
                    * A simple pager adapter that represents 5 ScreenSlidePageFragment objects, in
                    * sequence.
                    */
                   private class ScreenSlidePagerAdapter extends FragmentStatePagerAdapter {
                       public ScreenSlidePagerAdapter(FragmentManager fm) {
                           super(fm);
                       }

                       @Override
                       public Fragment getItem(int position) {
                           return new ScreenSlidePageFragment();
                       }

                       @Override
                       public int getCount() {
                           return NUM_PAGES;
                       }
                   }
               }

   .. rubric:: Customize the animation using PageTransformer
      :name: pagetransformer

   To display a different animation from the default screen slide animation,
   implement the
   `ViewPager.PageTransformer <#androidx.viewpager.widget.ViewPager.PageTransformer>`__
   interface and supply it to the view pager. The interface exposes a single
   method,
   `transformPage() <#androidx.viewpager.widget.ViewPager.PageTransformer>`__.
   At each point in the screen's transition, this method is called once for each
   visible page (generally there's only one visible page) and for adjacent pages
   just off the screen. For example, if page three is visible and the user drags
   towards page four,
   `transformPage() <#androidx.viewpager.widget.ViewPager.PageTransformer>`__
   is called for pages two, three, and four at each step of the gesture.

   In your implementation of
   `transformPage() <#androidx.viewpager.widget.ViewPager.PageTransformer>`__,
   you can then create custom slide animations by determining which pages need
   to be transformed based on the position of the page on the screen, which is
   obtained from the ``position`` parameter of the
   `transformPage() <#androidx.viewpager.widget.ViewPager.PageTransformer>`__
   method.

   The ``position`` parameter indicates where a given page is located relative
   to the center of the screen. It is a dynamic property that changes as the
   user scrolls through the pages. When a page fills the screen, its position
   value is ``0``. When a page is drawn just off the right side of the screen,
   its position value is ``1``. If the user scrolls halfway between pages one
   and two, page one has a position of -0.5 and page two has a position of 0.5.
   Based on the position of the pages on the screen, you can create custom slide
   animations by setting page properties with methods such as
   `setAlpha() <#android.view.View>`__,
   `setTranslationX() <#android.view.View>`__,
   or `setScaleY() <#android.view.View>`__.

   When you have an implementation of a
   `PageTransformer <#androidx.viewpager.widget.ViewPager.PageTransformer>`__,
   call
   `setPageTransformer() <#androidx.viewpager.widget.ViewPager>`__
   with your implementation to apply your custom animations. For example, if you
   have a
   `PageTransformer <#androidx.viewpager.widget.ViewPager.PageTransformer>`__
   named ``ZoomOutPageTransformer``, you can set your custom animations like
   this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val mPager: ViewPager = findViewById(R.id.pager)
               ...
               mPager.setPageTransformer(true, ZoomOutPageTransformer())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ViewPager mPager = (ViewPager) findViewById(R.id.pager);
               ...
               mPager.setPageTransformer(true, new ZoomOutPageTransformer());

   See the `Zoom-out page transformer <#zoom-out>`__ and `Depth page transformer <#depth-page>`__ sections for examples and videos of a
   `PageTransformer <#androidx.viewpager.widget.ViewPager.PageTransformer>`__.

   .. rubric:: Zoom-out page transformer
      :name: zoom-out

   This page transformer shrinks and fades pages when scrolling between adjacent
   pages. As a page gets closer to the center, it grows back to its normal size
   and fades in.

   .. container:: framed-galaxynexus-land-span-8

   .. container:: figure-caption

      ``ZoomOutPageTransformer`` example

      .. container:: video-instructions

          

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val MIN_SCALE = 0.85f
               private const val MIN_ALPHA = 0.5f

               class ZoomOutPageTransformer : ViewPager.PageTransformer {

                   override fun transformPage(view: View, position: Float) {
                       view.apply {
                           val pageWidth = width
                           val pageHeight = height
                           when {
                               position < -1 -> { // [-Infinity,-1)
                                   // This page is way off-screen to the left.
                                   alpha = 0f
                               }
                               position <= 1 -> { // [-1,1]
                                   // Modify the default slide transition to shrink the page as well
                                   val scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position))
                                   val vertMargin = pageHeight * (1 - scaleFactor) / 2
                                   val horzMargin = pageWidth * (1 - scaleFactor) / 2
                                   translationX = if (position < 0) {
                                       horzMargin - vertMargin / 2
                                   } else {
                                       horzMargin + vertMargin / 2
                                   }

                                   // Scale the page down (between MIN_SCALE and 1)
                                   scaleX = scaleFactor
                                   scaleY = scaleFactor

                                   // Fade the page relative to its size.
                                   alpha = (MIN_ALPHA +
                                           (((scaleFactor - MIN_SCALE) / (1 - MIN_SCALE)) * (1 - MIN_ALPHA)))
                               }
                               else -> { // (1,+Infinity]
                                   // This page is way off-screen to the right.
                                   alpha = 0f
                               }
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ZoomOutPageTransformer implements ViewPager.PageTransformer {
                   private static final float MIN_SCALE = 0.85f;
                   private static final float MIN_ALPHA = 0.5f;

                   public void transformPage(View view, float position) {
                       int pageWidth = view.getWidth();
                       int pageHeight = view.getHeight();

                       if (position < -1) { // [-Infinity,-1)
                           // This page is way off-screen to the left.
                           view.setAlpha(0f);

                       } else if (position <= 1) { // [-1,1]
                           // Modify the default slide transition to shrink the page as well
                           float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
                           float vertMargin = pageHeight * (1 - scaleFactor) / 2;
                           float horzMargin = pageWidth * (1 - scaleFactor) / 2;
                           if (position < 0) {
                               view.setTranslationX(horzMargin - vertMargin / 2);
                           } else {
                               view.setTranslationX(-horzMargin + vertMargin / 2);
                           }

                           // Scale the page down (between MIN_SCALE and 1)
                           view.setScaleX(scaleFactor);
                           view.setScaleY(scaleFactor);

                           // Fade the page relative to its size.
                           view.setAlpha(MIN_ALPHA +
                                   (scaleFactor - MIN_SCALE) /
                                   (1 - MIN_SCALE) * (1 - MIN_ALPHA));

                       } else { // (1,+Infinity]
                           // This page is way off-screen to the right.
                           view.setAlpha(0f);
                       }
                   }
               }

   .. rubric:: Depth page transformer
      :name: depth-page

   This page transformer uses the default slide animation for sliding pages to
   the left, while using a "depth" animation for sliding pages to the right.
   This depth animation fades the page out, and scales it down linearly.

   .. container:: framed-galaxynexus-land-span-8

   .. container:: figure-caption

      ``DepthPageTransformer`` example

      .. container:: video-instructions

          

   During the depth animation, the default animation (a screen slide) still
   takes place, so you must counteract the screen slide with a negative X
   translation. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               view.translationX = -1 * view.width * position

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               view.setTranslationX(-1 * view.getWidth() * position);

   The following example shows how to counteract the default screen slide
   animation in a working page transformer:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val MIN_SCALE = 0.75f

               class DepthPageTransformer : ViewPager.PageTransformer {

                   override fun transformPage(view: View, position: Float) {
                       view.apply {
                           val pageWidth = width
                           when {
                               position < -1 -> { // [-Infinity,-1)
                                   // This page is way off-screen to the left.
                                   alpha = 0f
                               }
                               position <= 0 -> { // [-1,0]
                                   // Use the default slide transition when moving to the left page
                                   alpha = 1f
                                   translationX = 0f
                                   scaleX = 1f
                                   scaleY = 1f
                               }
                               position <= 1 -> { // (0,1]
                                   // Fade the page out.
                                   alpha = 1 - position

                                   // Counteract the default slide transition
                                   translationX = pageWidth * -position

                                   // Scale the page down (between MIN_SCALE and 1)
                                   val scaleFactor = (MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)))
                                   scaleX = scaleFactor
                                   scaleY = scaleFactor
                               }
                               else -> { // (1,+Infinity]
                                   // This page is way off-screen to the right.
                                   alpha = 0f
                               }
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class DepthPageTransformer implements ViewPager.PageTransformer {
                   private static final float MIN_SCALE = 0.75f;

                   public void transformPage(View view, float position) {
                       int pageWidth = view.getWidth();

                       if (position < -1) { // [-Infinity,-1)
                           // This page is way off-screen to the left.
                           view.setAlpha(0f);

                       } else if (position <= 0) { // [-1,0]
                           // Use the default slide transition when moving to the left page
                           view.setAlpha(1f);
                           view.setTranslationX(0f);
                           view.setScaleX(1f);
                           view.setScaleY(1f);

                       } else if (position <= 1) { // (0,1]
                           // Fade the page out.
                           view.setAlpha(1 - position);

                           // Counteract the default slide transition
                           view.setTranslationX(pageWidth * -position);

                           // Scale the page down (between MIN_SCALE and 1)
                           float scaleFactor = MIN_SCALE
                                   + (1 - MIN_SCALE) * (1 - Math.abs(position));
                           view.setScaleX(scaleFactor);
                           view.setScaleY(scaleFactor);

                       } else { // (1,+Infinity]
                           // This page is way off-screen to the right.
                           view.setAlpha(0f);
                       }
                   }
               }


Last updated 2024-02-22 UTC.


/Migrate from ViewPager to ViewPager2
=====================================

.. https://developer.android.google.cn/develop/ui/views/animations/vp2-migration?hl=en

.. container:: devsite-article-body

   `ViewPager2 <#>`__ is an improved
   version of the ``ViewPager`` library that offers enhanced functionality and
   addresses common difficulties with using ``ViewPager``. If your app already
   uses ``ViewPager``, read this page to learn more about migrating to
   ``ViewPager2``.

   If you want to use ``ViewPager2`` in your app and are not currently using
   ``ViewPager``, read `Slide between fragments using ViewPager2 <#>`__ and `Create swipe views with tabs using ViewPager2 <#>`__ for
   more information.

   .. rubric:: Benefits of migrating to ViewPager2
      :name: benefits

   The primary reason to migrate is that ``ViewPager2`` is receiving active
   development support and ``ViewPager`` is not. However, ``ViewPager2`` also
   offers several other specific advantages.

   .. rubric:: Vertical orientation support
      :name: vertical-support

   ``ViewPager2`` supports vertical paging in addition to traditional horizontal
   paging. You can enable vertical paging for a ``ViewPager2`` element by
   setting its ``android:orientation`` attribute:

   .. code:: prettyprint

      <androidx.viewpager2.widget.ViewPager2
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:orientation="vertical" />

   You can also set this attribute programmatically using the
   `setOrientation() <#setorientation>`__
   method.

   .. rubric:: Right-to-left support
      :name: rtl-support

   ``ViewPager2`` supports right-to-left (RTL) paging. RTL paging is enabled
   automatically where appropriate based on locale, but you can also manually
   enable RTL paging for a ``ViewPager2`` element by setting its
   ``android:layoutDirection`` attribute:

   .. code:: prettyprint

      <androidx.viewpager2.widget.ViewPager2
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layoutDirection="rtl" />

   You can also set this attribute programmatically using the
   `setLayoutDirection() <#setlayoutdirection>`__
   method.

   .. rubric:: Modifiable fragment collections
      :name: modifiable-fragments

   ``ViewPager2`` supports paging through a modifiable collection of fragments,
   calling
   `notifyDatasetChanged() <#notifydatasetchanged>`__
   to update the UI when the underlying collection changes.

   This means that your app can dynamically modify the fragment collection at
   runtime, and ``ViewPager2`` will correctly display the modified collection.

   .. rubric:: DiffUtil
      :name: diffutil

   ``ViewPager2`` is built on
   `RecyclerView <#>`__,
   which means it has access to the
   `DiffUtil <#>`__
   utility class. This results in several benefits, but most notably it means
   that ``ViewPager2`` objects natively take advantage of the dataset change
   animations from the ``RecyclerView`` class.

   .. rubric:: Migrate your app to ViewPager2
      :name: migrate

   Follow these steps to update ``ViewPager`` objects in your app to
   ``ViewPager2``:

   .. rubric:: Update XML layout files
      :name: layout-files

   First, replace the ``ViewPager`` elements in your XML layout files with
   ``ViewPager2`` elements:

   .. code:: prettyprint

      <!-- A ViewPager element -->
      <android.support.v4.view.ViewPager
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

      <!-- A ViewPager2 element -->
      <androidx.viewpager2.widget.ViewPager2
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   .. rubric:: Update adapter classes
      :name: adapter-classes

   When using ``ViewPager``, you had to extend the adapter class that supplied
   new pages to the object. Depending on the use case, ``ViewPager`` used three
   different abstract classes. ``ViewPager2`` only uses two abstract classes.

   For each ``ViewPager`` object you are converting to a ``ViewPager2`` object,
   update the adapter class to extend the appropriate abstract class as follows:

   -  When ``ViewPager`` used
      `PagerAdapter <#>`__
      to page through views, use
      `RecyclerView.Adapter <#>`__
      with ``ViewPager2``.
   -  When ``ViewPager`` used
      `FragmentPagerAdapter <#>`__
      to page through a small, fixed number of fragments, use
      `FragmentStateAdapter <#>`__
      with ``ViewPager2``.
   -  When ``ViewPager`` used
      `FragmentStatePagerAdapter <#>`__
      to page through a large or unknown number of fragment, use
      `FragmentStateAdapter <#>`__
      with ``ViewPager2``.

   .. rubric:: Constructor parameters
      :name: adapter-constructors

   Fragment-based adapter classes inheriting from ``FragmentPagerAdapter`` or
   ``FragmentStatePagerAdapter`` always accept a single
   `FragmentManager <#>`__
   object as a constructor parameter. When you extend ``FragmentStateAdapter``
   for a ``ViewPager2`` adapter class, you have the following options for
   constructor parameters instead:

   -  The
      `FragmentActivity <#>`__
      object or
      `Fragment <#>`__ object
      where the ``ViewPager2`` object resides. In most cases, this is the better
      option.
   -  A ``FragmentManager`` object and a
      `Lifecycle <#>`__ object.

   View-based adapter classes inheriting directly from ``RecyclerView.Adapter``
   do not require a constructor parameter.

   .. rubric:: Override methods
      :name: adapter-methods

   Your adapter classes also need to override different methods for
   ``ViewPager2`` than they did for ``ViewPager``:

   -  Instead of ``getCount()``, override
      `getItemCount() <#getitemcount>`__.
      Other than the name, this method is unchanged.
   -  Instead of ``getItem()``, override
      `createFragment() <#createfragment>`__
      in fragment-based adapter classes. Make sure that your new
      ``createFragment()`` method always supplies a new fragment instance each
      time the function is called instead of reusing instances.

   **Note:**\  The
   `DiffUtil <#>`__
   utility class relies on identifying items by ID. If you are using
   ``ViewPager2`` to page through a mutable collection, you must also override
   `getItemId() <#getitemid>`__
   and
   `containsItem() <#containsitem>`__.
   Additionally, The
   `getPageWidth() <#getpagewidth>`__
   method is not supported for use with ``ViewPager2``. If you currently use
   ``getPageWidth()`` with ``ViewPager`` to enable peeking on adjacent pages,
   you must instead use the
   `clipToPadding <#getcliptopadding>`__
   attribute of ``RecyclerView`` as demonstrated in the `sample app <https://github.com/android/views-widgets-samples/blob/87e58d1c6d0c832c5b362d33390148679182d314/ViewPager2/app/src/main/java/androidx/viewpager2/integration/testapp/PreviewPagesActivity.kt>`__.

   .. rubric:: Summary
      :name: adapter-summary

   In summary, to convert a ``ViewPager`` adapter class for use with
   ``ViewPager2``, you must make the following changes:

   #. Change the superclass to ``RecyclerView.Adapter`` for paging through
      views, or ``FragmentStateAdapter`` for paging through fragments.
   #. Change the constructor parameters in fragment-based adapter classes.
   #. Override ``getItemCount()`` instead of ``getCount()``.
   #. Override ``createFragment()`` instead of ``getItem()`` in fragment-based
      adapter classes.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // A simple ViewPager adapter class for paging through fragments
               class ScreenSlidePagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) {
                   override fun getCount(): Int = NUM_PAGES

                   override fun getItem(position: Int): Fragment = ScreenSlidePageFragment()
               }

               // An equivalent ViewPager2 adapter class
               class ScreenSlidePagerAdapter(fa: FragmentActivity) : FragmentStateAdapter(fa) {
                   override fun getItemCount(): Int = NUM_PAGES

                   override fun createFragment(position: Int): Fragment = ScreenSlidePageFragment()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // A simple ViewPager adapter class for paging through fragments
               public class ScreenSlidePagerAdapter extends FragmentStatePagerAdapter {
                   public ScreenSlidePagerAdapter(FragmentManager fm) {
                       super(fm);
                   }

                   @Override
                   public Fragment getItem(int position) {
                       return new ScreenSlidePageFragment();
                   }

                   @Override
                   public int getCount() {
                       return NUM_PAGES;
                   }
               }

               // An equivalent ViewPager2 adapter class
               private class ScreenSlidePagerAdapter extends FragmentStateAdapter {
                   public ScreenSlidePagerAdapter(FragmentActivity fa) {
                       super(fa);
                   }

                   @Override
                   public Fragment createFragment(int position) {
                       return new ScreenSlidePageFragment();
                   }

                   @Override
                   public int getItemCount() {
                       return NUM_PAGES;
                   }
               }

   .. rubric:: Refactor TabLayout interfaces
      :name: tablayout

   ``ViewPager2`` introduces changes to
   `TabLayout <#>`__
   integration. If you currently use a ``ViewPager`` with a ``TabLayout`` object
   to display horizontal tabs for navigation, you need to refactor the
   ``TabLayout`` object for integration with ``ViewPager2``.

   ``TabLayout`` has been decoupled from ``ViewPager2`` and is now available as
   part of `Material components <#>`__. This means
   that in order to use it, you need to add the appropriate dependency to your
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               implementation "com.google.android.material:material:1.1.0-beta01"

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               implementation("com.google.android.material:material:1.1.0-beta01")

   You also need to change the ``TabLayout`` element's location in the hierarchy
   of your XML layout file. With ``ViewPager``, the ``TabLayout`` element is
   declared as a child of the ``ViewPager`` element; but with ``ViewPager2``,
   the ``TabLayout`` element is declared directly above the ``ViewPager2``
   element, on the same level:

   .. code:: prettyprint

      <!-- A ViewPager element with a TabLayout -->
      <androidx.viewpager.widget.ViewPager
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/pager"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <com.google.android.material.tabs.TabLayout
              android:id="@+id/tab_layout"
              android:layout_width="match_parent"
              android:layout_height="wrap_content" />

      </androidx.viewpager.widget.ViewPager>

      <!-- A ViewPager2 element with a TabLayout -->
      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:orientation="vertical">

          <com.google.android.material.tabs.TabLayout
              android:id="@+id/tab_layout"
              android:layout_width="match_parent"
              android:layout_height="wrap_content" />

          <androidx.viewpager2.widget.ViewPager2
              android:id="@+id/pager"
              android:layout_width="match_parent"
              android:layout_height="0dp"
              android:layout_weight="1" />

      </LinearLayout>

   Finally, you must update the code that attaches the ``TabLayout`` object to
   the ``ViewPager`` object. While ``TabLayout`` uses its own
   `setupWithViewPager() <#setupwithviewpager>`__
   method to integrate with ``ViewPager``, it requires a
   `TabLayoutMediator <#>`__
   instance to integrate with ``ViewPager2``.

   The ``TabLayoutMediator`` object also handles the task of generating page
   titles for the ``TabLayout`` object, which means that the adapter class does
   not need to override ``getPageTitle()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Integrating TabLayout with ViewPager
               class CollectionDemoFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val tabLayout = view.findViewById(R.id.tab_layout)
                       tabLayout.setupWithViewPager(viewPager)
                   }
                   ...
               }

               class DemoCollectionPagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) {

                   override fun getCount(): Int  = 4

                   override fun getPageTitle(position: Int): CharSequence {
                       return "OBJECT ${(position + 1)}"
                   }
                   ...
               }

               // Integrating TabLayout with ViewPager2
               class CollectionDemoFragment : Fragment() {
                   ...
                   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                       val tabLayout = view.findViewById(R.id.tab_layout)
                       TabLayoutMediator(tabLayout, viewPager) { tab, position ->
                           tab.text = "OBJECT ${(position + 1)}"
                       }.attach()
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Integrating TabLayout with ViewPager
               public class CollectionDemoFragment extends Fragment {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       TabLayout tabLayout = view.findViewById(R.id.tab_layout);
                       tabLayout.setupWithViewPager(viewPager);
                   }
                   ...
               }

               public class DemoCollectionPagerAdapter extends FragmentStatePagerAdapter {
                   ...
                   @Override
                   public int getCount() {
                       return 4;
                   }

                   @Override
                   public CharSequence getPageTitle(int position) {
                       return "OBJECT " + (position + 1);
                   }
                   ...
               }

               // Integrating TabLayout with ViewPager2
               public class CollectionDemoFragment : Fragment() {
                   ...
                   @Override
                   public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
                       TabLayout tabLayout = view.findViewById(R.id.tab_layout);
                       new TabLayoutMediator(tabLayout, viewPager,
                               (tab, position) -> tab.setText("OBJECT " + (position + 1))
                       ).attach();
                   }
                   ...
               }

   .. rubric:: Support nested scrollable elements
      :name: nested-scrollables

   ``ViewPager2`` does not natively support nested scroll views in cases where
   the scroll view has the same orientation as the ``ViewPager2`` object that
   contains it. For example, scrolling would not work for a vertical scroll view
   inside a vertically-oriented ``ViewPager2`` object.

   To support a scroll view inside a ``ViewPager2`` object with the same
   orientation, you must call
   `requestDisallowInterceptTouchEvent() <#android.view.ViewGroup>`__
   on the ``ViewPager2`` object when you expect to scroll the nested element
   instead. The `ViewPager2 nested scrolling sample <https://github.com/android/views-widgets-samples/blob/master/ViewPager2/app/src/main/res/layout/item_nested_recyclerviews.xml#L43>`__
   demonstrates one way of solving this problem with a versatile `custom wrapper layout <https://github.com/android/views-widgets-samples/blob/master/ViewPager2/app/src/main/java/androidx/viewpager2/integration/testapp/NestedScrollableHost.kt>`__.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about ``ViewPager2``, see the following additional resources.

   .. rubric:: Samples
      :name: samples

   -  `ViewPager2 samples <https://goo.gle/viewpager2-sample>`__ on GitHub

   .. rubric:: Videos
      :name: videos

   -  `Turning the Page: Migrating to ViewPager2 <https://www.youtube.com/watch?v=lAP6cz1HSzA>`__ (Android Dev
      Summit '19)


Last updated 2024-02-22 UTC.


/Use additional animation resources
===================================

.. https://developer.android.google.cn/develop/ui/views/animations/additional-resources?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use Animations in Compose.

      `Animations in Compose → <https://developer.android.google.cn/jetpack/compose/animation>`__

      |image-android-compose-ui-logo|

   For more information about animation, consult the following resources.

   .. rubric:: Videos
      :name: videos

   -  `Five quick animations to make your Compose app stand out <https://www.youtube.com/watch?v=0mfCbXrYBPE>`__
   -  `Jetpack Compose: Animation <https://www.youtube.com/watch?v=7yY2OocGiQU>`__
   -  `Motion Layout (MAD Skills playlist) <https://www.youtube.com/playlist?list=PLWz5rJ2EKKc_PEOEHNBEyy6tPX1EgtUw2>`__
   -  `Motional intelligence: Build smarter animations (Google I/O '19) <https://www.youtube.com/watch?v=f3Lm8iOr4mE>`__
   -  `Get animated (Android Dev Summit '18) <https://www.youtube.com/watch?v=N_x7SV3I3P0>`__
   -  `A window into transitions - Google I/O '16 <https://www.youtube.com/watch?v=4L4fLrWDvAU>`__

   .. rubric:: Samples
      :name: samples

   There are many code samples available in the `Android Animation samples GitHub repository <https://github.com/android/animation-samples>`__ that
   demonstrate specific animation techniques. There are a number of separate
   sample projects within this repository:

   .. list-table::
      :header-rows: 1

      - 

         - Project
         - Description
      - 

         - `ActivitySceneTransitionBasic <https://github.com/android/animation-samples/tree/main/ActivitySceneTransitionBasic>`__
         - Shows how to use shared element transitions from one ``Activity`` to
            another.
      - 

         - `BasicTransition <https://github.com/android/animation-samples/tree/main/BasicTransition>`__
         - Shows how to use the Transitions library to create smooth transitions
            between UI states.
      - 

         - `CustomTransition <https://github.com/android/animation-samples/tree/main/CustomTransition>`__
         - Shows how to create custom transitions using the Transitions library.
      - 

         - `DrawableAnimations <https://github.com/android/animation-samples/tree/main/DrawableAnimations>`__
         - Shows how to create animated vector drawables.
      - 

         - `GridToPager <https://github.com/android/animation-samples/tree/main/GridToPager>`__
         - Shows how to create shared element transitions from a
            ``RecyclerView`` to a ``ViewPager`` and back again.
      - 

         - `Interpolator <https://github.com/android/animation-samples/tree/main/Interpolator>`__
         - Shows how different interpolators affect the dynamics of your
            animations.
      - 

         - `Motion <https://github.com/android/animation-samples/tree/main/Motion>`__
         - Shows how to implement various types of Material Design Motion for
            layouts, lists, and navigation.
      - 

         - `MotionCompose <https://github.com/android/animation-samples/tree/main/MotionCompose>`__
         - Shows how to implement various different types of Material Design
            Motion for Jetpack Compose.
      - 

         - `OurStreets <https://github.com/android/animation-samples/tree/main/OurStreets>`__
         - Showcases shared element transitions throughout the app.
      - 

         - `RevealEffectBasic <https://github.com/android/animation-samples/tree/main/RevealEffectBasic>`__
         - Shows how to implement the circular reveal effect.
      - 

         - `Unsplash <https://github.com/android/animation-samples/tree/main/Unsplash>`__
         - The example code from the Google I/O '16 talk `A window into transitions <https://www.youtube.com/watch?v=4L4fLrWDvAU>`__.


Last updated 2024-04-15 UTC.



/Touch and input overview
=========================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/input?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Handling user interactions → <https://developer.android.google.cn/jetpack/compose/touch-input/handling-interactions>`__

      |image-android-compose-ui-logo|

   The following pages cover everything about user input, from basic touch input
   and gestures to keyboards and game controllers. You can add convenient
   features such as copy and paste and spell checking to your app. You can also
   develop your own text services to offer custom keyboards (Input Method
   Editors), dictionaries, and spell checkers that you can distribute to users
   as applications.

   For more information, see `Best practices for accessibility <#>`__.

   .. container:: wrap

      .. rubric:: Documentation
         :name: documentation
         :class: norule

      -  `Input events overview <#>`__
      -  `Use touch gestures <#>`__
      -  `Handle keyboard input <#>`__
      -  `Support game controllers <#>`__
      -  `Create an input method <#>`__
      -  `Spell checker framework <#>`__


Last updated 2024-04-15 UTC.



/About input events
===================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/input-events?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Handling user interactions → <https://developer.android.google.cn/jetpack/compose/touch-input/user-interactions/handling-interactions>`__

      |image-android-compose-ui-logo|

   On Android, there's more than one way to intercept the events from a user's
   interaction with your application. When considering events within your user
   interface, the approach is to capture the events from the specific View
   object that the user interacts with. The View class provides the means to do
   so.

   Within the various View classes that you'll use to compose your layout, you
   may notice several public callback methods that look useful for UI events.
   These methods are called by the Android framework when the respective action
   occurs on that object. For instance, when a View (such as a Button) is
   touched, the ``onTouchEvent()`` method is called on that object. However, in
   order to intercept this, you must extend the class and override the method.
   However, extending every View object in order to handle such an event would
   not be practical. This is why the View class also contains a collection of
   nested interfaces with callbacks that you can much more easily define. These
   interfaces, called `event listeners <#EventListeners>`__, are your ticket to
   capturing the user interaction with your UI.

   While you will more commonly use the event listeners to listen for user
   interaction, there may come a time when you do want to extend a View class,
   in order to build a custom component. Perhaps you want to extend the
   `Button <#android.widget.Button>`__ class to make something
   more fancy. In this case, you'll be able to define the default event
   behaviors for your class using the class `event handlers <#EventHandlers>`__.

   .. rubric:: Event listeners
      :name: EventListeners

   An event listener is an interface in the
   `View <#android.view.View>`__ class that contains a single
   callback method. These methods will be called by the Android framework when
   the View to which the listener has been registered is triggered by user
   interaction with the item in the UI.

   Included in the event listener interfaces are the following callback methods:

   ``onClick()``
      From
      `View.OnClickListener <#android.view.View.OnClickListener>`__.
      This is called when the user either touches the item (when in touch mode),
      or focuses upon the item with the navigation-keys or trackball and presses
      the suitable "enter" key or presses down on the trackball.
   ``onLongClick()``
      From
      `View.OnLongClickListener <#android.view.View.OnLongClickListener>`__.
      This is called when the user either touches and holds the item (when in
      touch mode), or focuses upon the item with the navigation-keys or
      trackball and presses and holds the suitable "enter" key or presses and
      holds down on the trackball (for one second).
   ``onFocusChange()``
      From
      `View.OnFocusChangeListener <#android.view.View.OnFocusChangeListener>`__.
      This is called when the user navigates onto or away from the item, using
      the navigation-keys or trackball.
   ``onKey()``
      From
      `View.OnKeyListener <#android.view.View.OnKeyListener>`__.
      This is called when the user is focused on the item and presses or
      releases a hardware key on the device.
   ``onTouch()``
      From
      `View.OnTouchListener <#android.view.View.OnTouchListener>`__.
      This is called when the user performs an action qualified as a touch
      event, including a press, a release, or any movement gesture on the screen
      (within the bounds of the item).
   ``onCreateContextMenu()``
      From
      `View.OnCreateContextMenuListener <#android.view.View.OnCreateContextMenuListener>`__.
      This is called when a Context Menu is being built (as the result of a
      sustained "long click"). See the discussion on context menus in the
      `Menus <#context-menu>`__ developer guide.

   These methods are the sole inhabitants of their respective interface. To
   define one of these methods and handle your events, implement the nested
   interface in your Activity or define it as an anonymous class. Then, pass an
   instance of your implementation to the respective ``View.set...Listener()``
   method. (E.g., call
   `setOnClickListener() <#android.view.View>`__
   and pass it your implementation of the
   `OnClickListener <#android.view.View.OnClickListener>`__.)

   The example below shows how to register an on-click listener for a Button.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               protected void onCreate(savedValues: Bundle) {
                   ...
                   val button: Button = findViewById(R.id.corky)
                   // Register the onClick listener with the implementation above
                   button.setOnClickListener { view ->
                       // do something when the button is clicked
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create an anonymous implementation of OnClickListener
               private OnClickListener corkyListener = new OnClickListener() {
                   public void onClick(View v) {
                     // do something when the button is clicked
                   }
               };

               protected void onCreate(Bundle savedValues) {
                   ...
                   // Capture our button from layout
                   Button button = (Button)findViewById(R.id.corky);
                   // Register the onClick listener with the implementation above
                   button.setOnClickListener(corkyListener);
                   ...
               }

   You may also find it more convenient to implement OnClickListener as a part
   of your Activity. This will avoid the extra class load and object allocation.
   For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleActivity : Activity(), OnClickListener {
                 
                   protected fun onCreate(savedValues: Bundle) {
                       val button: Button = findViewById(R.id.corky)
                       button.setOnClickListener(this)
                   }

                   // Implement the OnClickListener callback
                   fun onClick(v: View) {
                       // do something when the button is clicked
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleActivity extends Activity implements OnClickListener {
                   protected void onCreate(Bundle savedValues) {
                       ...
                       Button button = (Button)findViewById(R.id.corky);
                       button.setOnClickListener(this);
                   }

                   // Implement the OnClickListener callback
                   public void onClick(View v) {
                     // do something when the button is clicked
                   }
                   ...
               }

   Notice that the ``onClick()`` callback in the above example has no return
   value, but some other event listener methods must return a boolean. The
   reason depends on the event. For the few that do, here's why:

   -  `onLongClick() <#android.view.View.OnLongClickListener>`__
      - This returns a boolean to indicate whether you have consumed the event
      and it should not be carried further. That is, return *true* to indicate
      that you have handled the event and it should stop here; return *false* if
      you have not handled it and/or the event should continue to any other
      on-click listeners.
   -  `onKey() <#android.view.View.OnKeyListener>`__
      - This returns a boolean to indicate whether you have consumed the event
      and it should not be carried further. That is, return *true* to indicate
      that you have handled the event and it should stop here; return *false* if
      you have not handled it and/or the event should continue to any other
      on-key listeners.
   -  `onTouch() <#android.view.View.OnTouchListener>`__
      - This returns a boolean to indicate whether your listener consumes this
      event. The important thing is that this event can have multiple actions
      that follow each other. So, if you return *false* when the down action
      event is received, you indicate that you have not consumed the event and
      are also not interested in subsequent actions from this event. Thus, you
      will not be called for any other actions within the event, such as a
      finger gesture, or the eventual up action event.

   Remember that hardware key events are always delivered to the View currently
   in focus. They are dispatched starting from the top of the View hierarchy,
   and then down, until they reach the appropriate destination. If your View (or
   a child of your View) currently has focus, then you can see the event travel
   through the
   `dispatchKeyEvent() <#android.view.View>`__
   method. As an alternative to capturing key events through your View, you can
   also receive all of the events inside your Activity with
   `onKeyDown() <#android.app.Activity>`__
   and
   `onKeyUp() <#android.app.Activity>`__.

   Also, when thinking about text input for your application, remember that many
   devices only have software input methods. Such methods are not required to be
   key-based; some may use voice input, handwriting, and so on. Even if an input
   method presents a keyboard-like interface, it will generally **not** trigger
   the
   `onKeyDown() <#android.app.Activity>`__
   family of events. You should never build a UI that requires specific key
   presses to be controlled unless you want to limit your application to devices
   with a hardware keyboard. In particular, do not rely on these methods to
   validate input when the user presses the return key; instead, use actions
   like
   `IME_ACTION_DONE <#android.view.inputmethod.EditorInfo>`__
   to signal the input method how your application expects to react, so it may
   change its UI in a meaningful way. Avoid assumptions about how a software
   input method should work and just trust it to supply already formatted text
   to your application.

   **Note:** Android will call event handlers first and then the appropriate
   default handlers from the class definition second. As such, returning *true*
   from these event listeners will stop the propagation of the event to other
   event listeners and will also block the callback to the default event handler
   in the View. So be certain that you want to terminate the event when you
   return *true*.

   .. rubric:: Event handlers
      :name: EventHandlers

   If you're building a custom component from View, then you'll be able to
   define several callback methods used as default event handlers. In the
   document about `Custom View Components <#>`__, you'll learn some of the
   common callbacks used for event handling, including:

   -  `onKeyDown(int, KeyEvent) <#android.view.View>`__
      - Called when a new key event occurs.
   -  `onKeyUp(int, KeyEvent) <#android.view.View>`__
      - Called when a key up event occurs.
   -  `onTrackballEvent(MotionEvent) <#android.view.View>`__
      - Called when a trackball motion event occurs.
   -  `onTouchEvent(MotionEvent) <#android.view.View>`__
      - Called when a touch screen motion event occurs.
   -  `onFocusChanged(boolean, int, Rect) <#android.view.View>`__
      - Called when the view gains or loses focus.

   There are some other methods that you should be aware of, which are not part
   of the View class, but can directly impact the way you're able to handle
   events. So, when managing more complex events inside a layout, consider these
   other methods:

   -  `Activity.dispatchTouchEvent(MotionEvent) <#android.app.Activity>`__
      - This allows your `Activity <#android.app.Activity>`__ to
      intercept all touch events before they are dispatched to the window.
   -  `ViewGroup.onInterceptTouchEvent(MotionEvent) <#android.view.ViewGroup>`__
      - This allows a `ViewGroup <#android.view.ViewGroup>`__ to
      watch events as they are dispatched to child Views.
   -  `ViewParent.requestDisallowInterceptTouchEvent(boolean) <#android.view.ViewParent>`__
      - Call this upon a parent View to indicate that it should not intercept
      touch events with
      `onInterceptTouchEvent(MotionEvent) <#android.view.ViewGroup>`__.

   .. rubric:: Touch mode
      :name: TouchMode

   When a user is navigating a user interface with directional keys or a
   trackball, it is necessary to give focus to actionable items (like buttons)
   so the user can see what will accept input. If the device has touch
   capabilities, however, and the user begins interacting with the interface by
   touching it, then it is no longer necessary to highlight items, or give focus
   to a particular View. Thus, there is a mode for interaction named "touch
   mode."

   For a touch-capable device, once the user touches the screen, the device will
   enter touch mode. From this point onward, only Views for which
   `isFocusableInTouchMode() <#android.view.View>`__
   is true will be focusable, such as text editing widgets. Other Views that are
   touchable, like buttons, will not take focus when touched; they will simply
   fire their on-click listeners when pressed.

   Any time a user hits a directional key or scrolls with a trackball, the
   device will exit touch mode, and find a view to take focus. Now, the user may
   resume interacting with the user interface without touching the screen.

   The touch mode state is maintained throughout the entire system (all windows
   and activities). To query the current state, you can call
   `isInTouchMode() <#android.view.View>`__ to see
   whether the device is currently in touch mode.

   .. rubric:: Handling focus
      :name: HandlingFocus

   The framework will handle routine focus movement in response to user input.
   This includes changing the focus as Views are removed or hidden, or as new
   Views become available. Views indicate their willingness to take focus
   through the
   `isFocusable() <#android.view.View>`__ method. To
   change whether a View can take focus, call
   `setFocusable() <#android.view.View>`__.
   When in touch mode, you may query whether a View allows focus with
   `isFocusableInTouchMode() <#android.view.View>`__.
   You can change this with
   `setFocusableInTouchMode() <#android.view.View>`__.

   On devices running Android 9 (API level 28) or higher, activities don't
   assign an initial focus. Instead, you must explicitly request initial focus,
   if desired.

   Focus movement is based on an algorithm which finds the nearest neighbor in a
   given direction. In rare cases, the default algorithm may not match the
   intended behavior of the developer. In these situations, you can provide
   explicit overrides with the following XML attributes in the layout file:
   ``nextFocusDown``, ``nextFocusLeft``, ``nextFocusRight``, and
   ``nextFocusUp``. Add one of these attributes to the View *from* which the
   focus is leaving. Define the value of the attribute to be the id of the View
   *to* which focus should be given. For example:

   .. code:: prettyprint

      <LinearLayout
          android:orientation="vertical"
          ... >
        <Button android:id="@+id/top"
                android:nextFocusUp="@+id/bottom"
                ... />
        <Button android:id="@+id/bottom"
                android:nextFocusDown="@+id/top"
                ... />
      </LinearLayout>

   Ordinarily, in this vertical layout, navigating up from the first Button
   would not go anywhere, nor would navigating down from the second Button. Now
   that the top Button has defined the bottom one as the ``nextFocusUp`` (and
   vice versa), the navigation focus will cycle from top-to-bottom and
   bottom-to-top.

   If you'd like to declare a View as focusable in your UI (when it is
   traditionally not), add the ``android:focusable`` XML attribute to the View,
   in your layout declaration. Set the value ``true``. You can also declare a
   View as focusable while in Touch Mode with ``android:focusableInTouchMode``.

   To request a particular View to take focus, call
   `requestFocus() <#android.view.View>`__.

   To listen for focus events (be notified when a View receives or loses focus),
   use
   `onFocusChange() <#android.view.View.OnFocusChangeListener>`__,
   as discussed in the `Event listeners <#EventListeners>`__ section.


Last updated 2024-04-15 UTC.



/About gestures
===============

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Gestures → <https://developer.android.google.cn/jetpack/compose/touch-input/pointer-input>`__

      |image-android-compose-ui-logo|

   This document describes how to write apps that let users interact with an app
   using touch gestures. Android provides a variety of APIs to help you create
   and detect gestures.

   Although your app must not depend on touch gestures for basic behaviors—since
   the gestures might not be available to all users in all contexts—adding
   touch-based interaction to your app can greatly increase its usefulness and
   appeal.

   To provide users with a consistent, intuitive experience, your app must
   follow the accepted Android conventions for touch gestures. The `Material Design Gestures <https://material.io/design/interaction/gestures.html>`__
   document shows you how to use common gestures in Android apps. Also, see
   `Material Motion <https://material.io/guidelines/motion/material-motion.html>`__.

   For more information about this topic, read the following related guides:

   -  `Input events overview <#>`__
   -  `Sensors overview <#>`__
   -  `Make a custom view interactive <#>`__

   .. rubric:: Topics
      :name: topics

   `Detect common gestures <#>`__
      Learn how to detect basic touch gestures, such as scrolling, flinging, and
      double-tapping, using
      `GestureDetector <#android.view.GestureDetector>`__.
   `Track touch and pointer movements <#>`__
      Learn how to track movement.
   `Animate a scroll gesture <#>`__
      Learn how to use
      scrollers—`Scroller <#android.widget.Scroller>`__ or
      `OverScroller <#android.widget.OverScroller>`__—to produce a
      scrolling animation in response to a touch event.
   `Handle multi-touch gestures <#>`__
      Learn how to detect multi-pointer (finger) gestures.
   `Drag and scale <#>`__
      Learn how to implement touch-based dragging and scaling.
   `Manage touch events in a ViewGroup <#>`__
      Learn how to manage touch events in a
      `ViewGroup <#android.view.ViewGroup>`__ to ensure that touch
      events are correctly dispatched to their target views.


Last updated 2024-04-15 UTC.



/Detect common gestures
=======================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/detector?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Gestures → <https://developer.android.google.cn/jetpack/compose/touch-input/pointer-input>`__

      |image-android-compose-ui-logo|

   A *touch gesture* occurs when a user places one or more fingers on the
   touchscreen and your app interprets this pattern of touches as a gesture.
   There are two phases to gesture detection:

   #. Gathering touch event data.
   #. Interpreting the data to determine whether it meets the criteria for the
      gestures your app supports.

   .. rubric:: AndroidX classes
      :name: androidx-classes

   The examples in this document use the
   `GestureDetectorCompat <#androidx.core.view.GestureDetectorCompat>`__
   and
   `MotionEventCompat <#androidx.core.view.MotionEventCompat>`__
   classes. These classes are in the `AndroidX Library <#>`__.
   Use AndroidX classes where possible to provide compatibility with earlier
   devices. ``MotionEventCompat`` is *not* a replacement for the
   `MotionEvent <#android.view.MotionEvent>`__ class. Rather, it
   provides static utility methods to which you pass your ``MotionEvent`` object
   to receive the action associated with that event.

   .. rubric:: Gather data
      :name: data

   When a user places one or more fingers on the screen, this triggers the
   callback
   `onTouchEvent() <#android.view.View>`__
   on the view that receives the touch events. For each sequence of touch
   events—such as position, pressure, size, and addition of another finger—that
   is identified as a gesture, ``onTouchEvent()`` is fired several times.

   The gesture starts when the user first touches the screen, continues as the
   system tracks the position of the user's finger or fingers, and ends by
   capturing the final event of the user's last finger leaving the screen.
   Throughout this interaction, the ``MotionEvent`` delivered to
   ``onTouchEvent()`` provides the details of every interaction. Your app can
   use the data provided by the ``MotionEvent`` to determine whether a gesture
   it cares about happens.

   .. rubric:: Capture touch events for an Activity or View
      :name: capture-touch-events-for-an-activity-or-view

   To intercept touch events in an ``Activity`` or ``View``, override the
   ``onTouchEvent()`` callback.

   The following code snippet uses
   `getAction() <#android.view.MotionEvent>`__ to
   extract the action the user performs from the ``event`` parameter. This gives
   you the raw data you need to determine whether a gesture you care about
   occurs.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MainActivity : Activity() {
                   ...
                   // This example shows an Activity. You can use the same approach if you are 
                   // subclassing a View.
                   override fun onTouchEvent(event: MotionEvent): Boolean {
                       return when (event.action) {
                           MotionEvent.ACTION_DOWN -> {
                               Log.d(DEBUG_TAG, "Action was DOWN")
                               true
                           }
                           MotionEvent.ACTION_MOVE -> {
                               Log.d(DEBUG_TAG, "Action was MOVE")
                               true
                           }
                           MotionEvent.ACTION_UP -> {
                               Log.d(DEBUG_TAG, "Action was UP")
                               true
                           }
                           MotionEvent.ACTION_CANCEL -> {
                               Log.d(DEBUG_TAG, "Action was CANCEL")
                               true
                           }
                           MotionEvent.ACTION_OUTSIDE -> {
                               Log.d(DEBUG_TAG, "Movement occurred outside bounds of current screen element")
                               true
                           }
                           else -> super.onTouchEvent(event)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends Activity {
               ...
               // This example shows an Activity. You can use the same approach if you are
               // subclassing a View.
               @Override
               public boolean onTouchEvent(MotionEvent event){
                   switch(event.getAction()) {
                       case (MotionEvent.ACTION_DOWN) :
                           Log.d(DEBUG_TAG,"Action was DOWN");
                           return true;
                       case (MotionEvent.ACTION_MOVE) :
                           Log.d(DEBUG_TAG,"Action was MOVE");
                           return true;
                       case (MotionEvent.ACTION_UP) :
                           Log.d(DEBUG_TAG,"Action was UP");
                           return true;
                       case (MotionEvent.ACTION_CANCEL) :
                           Log.d(DEBUG_TAG,"Action was CANCEL");
                           return true;
                       case (MotionEvent.ACTION_OUTSIDE) :
                           Log.d(DEBUG_TAG,"Movement occurred outside bounds of current screen element");
                           return true;
                       default :
                           return super.onTouchEvent(event);
                   }
               }

   This code produces messages like the following in Logcat as the user taps,
   touches & holds, and drags:

   .. code:: prettyprint

      GESTURES D   Action was DOWN
      GESTURES D   Action was UP
      GESTURES D   Action was MOVE

   For custom gestures, you can then do your own processing on these events to
   determine whether they represent a gesture you need to handle. However, if
   your app uses common gestures, such as double-tap, touch & hold, fling, and
   so on, you can take advantage of the
   `GestureDetector <#android.view.GestureDetector>`__ class.
   ``GestureDetector`` makes it easier for you to detect common gestures without
   processing the individual touch events yourself. This is discussed further in
   `Detect gestures <#detect>`__.

   .. rubric:: Capture touch events for a single view
      :name: capture-touch-events-for-a-single-view

   As an alternative to ``onTouchEvent()``, you can attach a
   `View.OnTouchListener <#android.view.View.OnTouchListener>`__
   object to any `View <#android.view.View>`__ object using the
   `setOnTouchListener() <#android.view.View>`__
   method. This makes it possible to listen for touch events without subclassing
   an existing ``View``, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<View>(R.id.my_view).setOnTouchListener { v, event ->
                   // Respond to touch events.
                   true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               View myView = findViewById(R.id.my_view);
               myView.setOnTouchListener(new OnTouchListener() {
                   public boolean onTouch(View v, MotionEvent event) {
                       // Respond to touch events.
                       return true;
                   }
               });

   Beware of creating a listener that returns ``false`` for the
   `ACTION_DOWN <#android.view.MotionEvent>`__ event.
   If you do this, the listener isn't called for the subsequent
   `ACTION_MOVE <#android.view.MotionEvent>`__ and
   `ACTION_UP <#android.view.MotionEvent>`__ sequence of
   events. This is because ``ACTION_DOWN`` is the starting point for all touch
   events.

   If you are creating a custom view, you can override ``onTouchEvent()``, as
   described earlier.

   .. rubric:: Detect gestures
      :name: detect

   Android provides the ``GestureDetector`` class for detecting common gestures.
   Some of the gestures it supports include
   `onDown() <#android.view.GestureDetector.OnGestureListener>`__,
   `onLongPress() <#android.view.GestureDetector.OnGestureListener>`__,
   and
   `onFling() <#android.view.GestureDetector.OnGestureListener>`__.
   You can use ``GestureDetector`` in conjunction with the ``onTouchEvent()``
   method described earlier.

   .. rubric:: Detect all supported gestures
      :name: detect-all-supported-gestures

   When you instantiate a ``GestureDetectorCompat`` object, one of the
   parameters it takes is a class that implements the
   `GestureDetector.OnGestureListener <#android.view.GestureDetector.OnGestureListener>`__
   interface. ``GestureDetector.OnGestureListener`` notifies users when a
   particular touch event occurs. To make it possible for your
   ``GestureDetector`` object to receive events, override the view or activity's
   ``onTouchEvent()`` method and pass along all observed events to the detector
   instance.

   In the following snippet, a return value of ``true`` from the individual
   ``on``\ *``<TouchEvent>``* methods indicates that the touch event is handled.
   A return value of ``false`` passes events down through the view stack until
   the touch is successfully handled.

   If you run the following snippet in a test app, you can get a feel for how
   actions are triggered when you interact with the touch screen and what the
   contents of the ``MotionEvent`` are for each touch event. You then see how
   much data is being generated for simple interactions.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val DEBUG_TAG = "Gestures"

               class MainActivity :
                       Activity(),
                       GestureDetector.OnGestureListener,
                       GestureDetector.OnDoubleTapListener {

                   private lateinit var mDetector: GestureDetectorCompat

                   // Called when the activity is first created.
                   public override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)
                       // Instantiate the gesture detector with the
                       // application context and an implementation of
                       // GestureDetector.OnGestureListener.
                       mDetector = GestureDetectorCompat(this, this)
                       // Set the gesture detector as the double-tap
                       // listener.
                       mDetector.setOnDoubleTapListener(this)
                   }

                   override fun onTouchEvent(event: MotionEvent): Boolean {
                       return if (mDetector.onTouchEvent(event)) {
                           true
                       } else {
                           super.onTouchEvent(event)
                       }
                   }

                   override fun onDown(event: MotionEvent): Boolean {
                       Log.d(DEBUG_TAG, "onDown: $event")
                       return true
                   }

                   override fun onFling(
                           event1: MotionEvent,
                           event2: MotionEvent,
                           velocityX: Float,
                           velocityY: Float
                   ): Boolean {
                       Log.d(DEBUG_TAG, "onFling: $event1 $event2")
                       return true
                   }

                   override fun onLongPress(event: MotionEvent) {
                       Log.d(DEBUG_TAG, "onLongPress: $event")
                   }

                   override fun onScroll(
                           event1: MotionEvent,
                           event2: MotionEvent,
                           distanceX: Float,
                           distanceY: Float
                   ): Boolean {
                       Log.d(DEBUG_TAG, "onScroll: $event1 $event2")
                       return true
                   }

                   override fun onShowPress(event: MotionEvent) {
                       Log.d(DEBUG_TAG, "onShowPress: $event")
                   }

                   override fun onSingleTapUp(event: MotionEvent): Boolean {
                       Log.d(DEBUG_TAG, "onSingleTapUp: $event")
                       return true
                   }

                   override fun onDoubleTap(event: MotionEvent): Boolean {
                       Log.d(DEBUG_TAG, "onDoubleTap: $event")
                       return true
                   }

                   override fun onDoubleTapEvent(event: MotionEvent): Boolean {
                       Log.d(DEBUG_TAG, "onDoubleTapEvent: $event")
                       return true
                   }

                   override fun onSingleTapConfirmed(event: MotionEvent): Boolean {
                       Log.d(DEBUG_TAG, "onSingleTapConfirmed: $event")
                       return true
                   }

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends Activity implements
                       GestureDetector.OnGestureListener,
                       GestureDetector.OnDoubleTapListener{

                   private static final String DEBUG_TAG = "Gestures";
                   private GestureDetectorCompat mDetector;

                   // Called when the activity is first created.
                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);
                       // Instantiate the gesture detector with the
                       // application context and an implementation of
                       // GestureDetector.OnGestureListener.
                       mDetector = new GestureDetectorCompat(this,this);
                       // Set the gesture detector as the double-tap
                       // listener.
                       mDetector.setOnDoubleTapListener(this);
                   }

                   @Override
                   public boolean onTouchEvent(MotionEvent event){
                       if (this.mDetector.onTouchEvent(event)) {
                           return true;
                       }
                       return super.onTouchEvent(event);
                   }

                   @Override
                   public boolean onDown(MotionEvent event) {
                       Log.d(DEBUG_TAG,"onDown: " + event.toString());
                       return true;
                   }

                   @Override
                   public boolean onFling(MotionEvent event1, MotionEvent event2,
                           float velocityX, float velocityY) {
                       Log.d(DEBUG_TAG, "onFling: " + event1.toString() + event2.toString());
                       return true;
                   }

                   @Override
                   public void onLongPress(MotionEvent event) {
                       Log.d(DEBUG_TAG, "onLongPress: " + event.toString());
                   }

                   @Override
                   public boolean onScroll(MotionEvent event1, MotionEvent event2, float distanceX,
                           float distanceY) {
                       Log.d(DEBUG_TAG, "onScroll: " + event1.toString() + event2.toString());
                       return true;
                   }

                   @Override
                   public void onShowPress(MotionEvent event) {
                       Log.d(DEBUG_TAG, "onShowPress: " + event.toString());
                   }

                   @Override
                   public boolean onSingleTapUp(MotionEvent event) {
                       Log.d(DEBUG_TAG, "onSingleTapUp: " + event.toString());
                       return true;
                   }

                   @Override
                   public boolean onDoubleTap(MotionEvent event) {
                       Log.d(DEBUG_TAG, "onDoubleTap: " + event.toString());
                       return true;
                   }

                   @Override
                   public boolean onDoubleTapEvent(MotionEvent event) {
                       Log.d(DEBUG_TAG, "onDoubleTapEvent: " + event.toString());
                       return true;
                   }

                   @Override
                   public boolean onSingleTapConfirmed(MotionEvent event) {
                       Log.d(DEBUG_TAG, "onSingleTapConfirmed: " + event.toString());
                       return true;
                   }
               }

   .. rubric:: Detect a subset of supported gestures
      :name: detect-a-subset-of-supported-gestures

   If you only want to process a few gestures, you can extend
   `GestureDetector.SimpleOnGestureListener <#android.view.GestureDetector.SimpleOnGestureListener>`__
   instead of implementing the ``GestureDetector.OnGestureListener`` interface.

   ``GestureDetector.SimpleOnGestureListener`` provides an implementation for
   all of the ``on``\ *``<TouchEvent>``* methods by returning ``false`` for all
   of them. This lets you override only the methods you care about. For example,
   the following code snippet creates a class that extends
   ``GestureDetector.SimpleOnGestureListener`` and overrides ``onFling()`` and
   ``onDown()``.

   Whether you use ``GestureDetector.OnGestureListener`` or
   ``GestureDetector.SimpleOnGestureListener``, it's a best practice to
   implement an ``onDown()`` method that returns ``true``. This is because all
   gestures begin with an ``onDown()`` message. If you return ``false`` from
   ``onDown()``, as ``GestureDetector.SimpleOnGestureListener`` does by default,
   the system assumes you want to ignore the rest of the gesture, and the other
   methods of ``GestureDetector.OnGestureListener`` aren't called. This might
   cause unexpected problems in your app. Only return ``false`` from
   ``onDown()`` if you truly want to ignore an entire gesture.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val DEBUG_TAG = "Gestures"

               class MainActivity : Activity() {

                   private lateinit var mDetector: GestureDetectorCompat

                   public override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)
                       mDetector = GestureDetectorCompat(this, MyGestureListener())
                   }

                   override fun onTouchEvent(event: MotionEvent): Boolean {
                       mDetector.onTouchEvent(event)
                       return super.onTouchEvent(event)
                   }

                   private class MyGestureListener : GestureDetector.SimpleOnGestureListener() {

                       override fun onDown(event: MotionEvent): Boolean {
                           Log.d(DEBUG_TAG, "onDown: $event")
                           return true
                       }

                       override fun onFling(
                               event1: MotionEvent,
                               event2: MotionEvent,
                               velocityX: Float,
                               velocityY: Float
                       ): Boolean {
                           Log.d(DEBUG_TAG, "onFling: $event1 $event2")
                           return true
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends Activity {

                   private GestureDetectorCompat mDetector;

                   @Override
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);
                       mDetector = new GestureDetectorCompat(this, new MyGestureListener());
                   }

                   @Override
                   public boolean onTouchEvent(MotionEvent event){
                       if (this.mDetector.onTouchEvent(event)) {
                             return true;
                       }
                       return super.onTouchEvent(event);
                   }

                   class MyGestureListener extends GestureDetector.SimpleOnGestureListener {
                       private static final String DEBUG_TAG = "Gestures";

                       @Override
                       public boolean onDown(MotionEvent event) {
                           Log.d(DEBUG_TAG,"onDown: " + event.toString());
                           return true;
                       }

                       @Override
                       public boolean onFling(MotionEvent event1, MotionEvent event2,
                               float velocityX, float velocityY) {
                           Log.d(DEBUG_TAG, "onFling: " + event1.toString() + event2.toString());
                           return true;
                       }
                   }
               }

   .. rubric:: Additional resources
      :name: additional-resources

   -  `Input events overview <#>`__
   -  `Sensors overview <#>`__
   -  `Make a custom view interactive <#>`__


Last updated 2024-04-15 UTC.



/Track touch and pointer movements
==================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/movement?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Gestures → <https://developer.android.google.cn/jetpack/compose/touch-input/pointer-input>`__

      |image-android-compose-ui-logo|

   This lesson describes how to track movement in touch events.

   A new
   `onTouchEvent() <#android.view.View>`__
   is triggered with an
   `ACTION_MOVE <#android.view.MotionEvent>`__ event
   whenever the current touch contact position, pressure, or size changes. As
   described in `Detect common gestures <#>`__, all
   these events are recorded in the
   `MotionEvent <#android.view.MotionEvent>`__ parameter of
   ``onTouchEvent()``.

   Because finger-based touch isn't always the most precise form of interaction,
   detecting touch events is often based more on movement than on simple
   contact. To help apps distinguish between movement-based gestures (such as a
   swipe) and non-movement gestures (such as a single tap), Android includes the
   notion of *touch slop*. Touch slop refers to the distance in pixels a user's
   touch can wander before the gesture is interpreted as a movement-based
   gesture. For more information about this topic, see `Manage touch events in a ViewGroup <#vc>`__.

   There are several ways to track movement in a gesture, depending on the needs
   of your application. The following are examples:

   -  The starting and ending position of a pointer, such as moving an on-screen
      object from point A to point B.
   -  The direction the pointer is traveling in, as determined by the X and Y
      coordinates.
   -  History. You can find the size of a gesture's history by calling the
      ``MotionEvent`` method
      `getHistorySize() <#android.view.MotionEvent>`__.
      You can then obtain the positions, sizes, time, and pressures of each of
      the historical events by using the motion event's
      ``getHistorical``\ *``<Value>``* methods. History is useful when rendering
      a trail of the user's finger, such as for touch drawing. See the
      ``MotionEvent`` reference for details.
   -  The velocity of the pointer as it moves across the touchscreen.

   Refer to the following related resources:

   -  `Input events overview <#>`__
   -  `Sensors overview <#>`__
   -  `Make a custom view interactive <#>`__

   .. rubric:: Track velocity
      :name: velocity

   You can have a movement-based gesture that is based on the distance or
   direction the pointer travels. However, velocity is often a determining
   factor in tracking a gesture's characteristics or deciding whether the
   gesture occurred. To make velocity calculation easier, Android provides the
   `VelocityTracker <#android.view.VelocityTracker>`__ class.
   ``VelocityTracker`` helps you track the velocity of touch events. This is
   useful for gestures in which velocity is part of the criteria for the
   gesture, such as a fling.

   Here is an example that illustrates the purpose of the methods in the
   ``VelocityTracker`` API:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val DEBUG_TAG = "Velocity"

               class MainActivity : Activity() {
                   private var mVelocityTracker: VelocityTracker? = null

                   override fun onTouchEvent(event: MotionEvent): Boolean {

                       when (event.actionMasked) {
                           MotionEvent.ACTION_DOWN -> {
                               // Reset the velocity tracker back to its initial state.
                               mVelocityTracker?.clear()
                               // If necessary, retrieve a new VelocityTracker object to watch
                               // the velocity of a motion.
                               mVelocityTracker = mVelocityTracker ?: VelocityTracker.obtain()
                               // Add a user's movement to the tracker.
                               mVelocityTracker?.addMovement(event)
                           }
                           MotionEvent.ACTION_MOVE -> {
                               mVelocityTracker?.apply {
                                   val pointerId: Int = event.getPointerId(event.actionIndex)
                                   addMovement(event)
                                   // When you want to determine the velocity, call
                                   // computeCurrentVelocity(). Then, call getXVelocity() and
                                   // getYVelocity() to retrieve the velocity for each pointer
                                   // ID.
                                   computeCurrentVelocity(1000)
                                   // Log velocity of pixels per second. It's best practice to
                                   // use VelocityTrackerCompat where possible.
                                   Log.d("", "X velocity: ${getXVelocity(pointerId)}")
                                   Log.d("", "Y velocity: ${getYVelocity(pointerId)}")
                               }
                           }
                           MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                               // Return a VelocityTracker object back to be re-used by others.
                               mVelocityTracker?.recycle()
                               mVelocityTracker = null
                           }
                       }
                       return true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends Activity {
                   private static final String DEBUG_TAG = "Velocity";
                       ...
                   private VelocityTracker mVelocityTracker = null;
                   @Override
                   public boolean onTouchEvent(MotionEvent event) {
                       int index = event.getActionIndex();
                       int action = event.getActionMasked();
                       int pointerId = event.getPointerId(index);

                       switch(action) {
                           case MotionEvent.ACTION_DOWN:
                               if(mVelocityTracker == null) {
                                   // Retrieve a new VelocityTracker object to watch the
                                   // velocity of a motion.
                                   mVelocityTracker = VelocityTracker.obtain();
                               }
                               else {
                                   // Reset the velocity tracker back to its initial state.
                                   mVelocityTracker.clear();
                               }
                               // Add a user's movement to the tracker.
                               mVelocityTracker.addMovement(event);
                               break;
                           case MotionEvent.ACTION_MOVE:
                               mVelocityTracker.addMovement(event);
                               // When you want to determine the velocity, call
                               // computeCurrentVelocity(). Then call getXVelocity() and
                               // getYVelocity() to retrieve the velocity for each pointer ID.
                               mVelocityTracker.computeCurrentVelocity(1000);
                               // Log velocity of pixels per second. It's best practice to use
                               // VelocityTrackerCompat where possible.
                               Log.d("", "X velocity: " + mVelocityTracker.getXVelocity(pointerId));
                               Log.d("", "Y velocity: " + mVelocityTracker.getYVelocity(pointerId));
                               break;
                           case MotionEvent.ACTION_UP:
                           case MotionEvent.ACTION_CANCEL:
                               // Return a VelocityTracker object back to be re-used by others.
                               mVelocityTracker.recycle();
                               break;
                       }
                       return true;
                   }
               }

   **Note:**\  Calculate velocity after an ``ACTION_MOVE`` event, not after
   `ACTION_UP <#android.view.MotionEvent>`__. After an
   ``ACTION_UP``, the X and Y velocities are 0.

   .. rubric:: Use pointer capture
      :name: pointer-capture

   Some apps, such as games and remote desktop and virtualization clients,
   benefit from getting control over the mouse pointer. Pointer capture is a
   feature available in Android 8.0 (API level 26) and higher that provides this
   control by delivering all mouse events to a focused view in your app.

   .. rubric:: Request pointer capture
      :name: pointer-capture

   A view in your app can request pointer capture only when the view hierarchy
   that contains it has focus. For this reason, request pointer capture when
   there's a specific user action on the view, such as during an
   `onClick() <#android.view.View.OnClickListener>`__
   event or in the
   `onWindowFocusChanged() <#android.app.Activity>`__
   event handler of your activity.

   To request pointer capture, call the
   `requestPointerCapture() <#android.view.View>`__
   method on the view. The following code example shows how to request pointer
   capture when the user clicks a view:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun onClick(view: View) {
                   view.requestPointerCapture()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onClick(View view) {
                   view.requestPointerCapture();
               }

   Once the request to capture the pointer is successful, Android calls
   `onPointerCaptureChange(true) <#android.view.View>`__.
   The system delivers the mouse events to the focused view in your app as long
   as it's in the same view hierarchy as the view that requested the capture.
   Other apps stop receiving mouse events until the capture is released,
   including
   `ACTION_OUTSIDE <#android.view.MotionEvent>`__
   events. Android delivers pointer events from sources other than the mouse as
   normal, but the mouse pointer is no longer visible.

   .. rubric:: Handle captured pointer events
      :name: captured-pointer-movements

   Once a view successfully acquires the pointer capture, Android delivers the
   mouse events. Your focused view can handle the events by performing one of
   the following tasks:

   -  If you're using a custom view, override
      `onCapturedPointerEvent(MotionEvent) <#android.view.View>`__.
   -  Otherwise, register an
      `OnCapturedPointerListener <#android.view.View.OnCapturedPointerListener>`__.

   The following code example shows how to implement
   `onCapturedPointerEvent(MotionEvent) <#android.view.View>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCapturedPointerEvent(motionEvent: MotionEvent): Boolean {
                   // Get the coordinates required by your app.
                   val verticalOffset: Float = motionEvent.y
                   // Use the coordinates to update your view and return true if the event is
                   // successfully processed.
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onCapturedPointerEvent(MotionEvent motionEvent) {
                 // Get the coordinates required by your app.
                 float verticalOffset = motionEvent.getY();
                 // Use the coordinates to update your view and return true if the event is
                 // successfully processed.
                 return true;
               }

   The following code example shows how to register an
   `OnCapturedPointerListener <#android.view.View.OnCapturedPointerListener>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               myView.setOnCapturedPointerListener { view, motionEvent ->
                   // Get the coordinates required by your app.
                   val horizontalOffset: Float = motionEvent.x
                   // Use the coordinates to update your view and return true if the event is
                   // successfully processed.
                   true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               myView.setOnCapturedPointerListener(new View.OnCapturedPointerListener() {
                 @Override
                 public boolean onCapturedPointer (View view, MotionEvent motionEvent) {
                   // Get the coordinates required by your app.
                   float horizontalOffset = motionEvent.getX();
                   // Use the coordinates to update your view and return true if the event is
                   // successfully processed.
                   return true;
                 }
               });

   Whether you use a custom view or register a listener, your view receives a
   ``MotionEvent`` with pointer coordinates that specify relative movements such
   as X or Y deltas, similar to the coordinates delivered by a trackball device.
   You can retrieve the coordinates by using
   `getX() <#android.view.MotionEvent>`__ and
   `getY() <#android.view.MotionEvent>`__.

   .. rubric:: Release pointer capture
      :name: release_pointer_capture

   The view in your app can release the pointer capture by calling
   `releasePointerCapture() <#android.view.View>`__,
   as shown in the following code example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onClick(view: View) {
                   view.releasePointerCapture()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onClick(View view) {
                   view.releasePointerCapture();
               }

   The system can take the capture away from the view without you explicitly
   calling ``releasePointerCapture()``, commonly because the view hierarchy
   containing the view that requests capture loses focus.


Last updated 2024-04-15 UTC.



/Handle scroll gestures
=======================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/scroll?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Scrolling → <https://developer.android.google.cn/jetpack/compose/touch-input/pointer-input#scrolling>`__

      |image-android-compose-ui-logo|

   In Android, scrolling is typically achieved by using the
   `ScrollView <#android.widget.ScrollView>`__ class. Nest any
   standard layout that might extend beyond the bounds of its container in a
   ``ScrollView`` to provide a scrollable view managed by the framework.
   Implementing a custom scroller is only necessary for special scenarios. This
   document describes how to display a scrolling effect in response to touch
   gestures using *scrollers*.

   Your app can use
   scrollers—`Scroller <#android.widget.Scroller>`__ or
   `OverScroller <#android.widget.OverScroller>`__—to collect the
   data needed to produce a scrolling animation in response to a touch event.
   They are similar, but ``OverScroller`` also includes methods for indicating
   to users when they reach the content edges after a pan or fling gesture.

   -  Starting in Android 12 (API level 31), the visual elements stretch and
      bounce back on a drag event and fling and bounce back on a fling event.
   -  On Android 11 (API level 30) and earlier, the boundaries display a "glow"
      effect after a drag or fling gesture to the edge.

   The ``InteractiveChart`` sample in this document uses the
   `EdgeEffect <#android.widget.EdgeEffect>`__ class to display
   these overscroll effects.

   **Note:** Use ``OverScroller`` instead of ``Scroller`` for scrolling
   animations. ``OverScroller`` provides the best backward compatibility with
   earlier devices.

   You generally only need to use scrollers when implementing scrolling
   yourself. ``ScrollView`` and
   `HorizontalScrollView <#android.widget.HorizontalScrollView>`__
   do all of this for you if you nest your layout within them.

   You can use a scroller to animate scrolling over time, using
   platform-standard scrolling physics such as friction, velocity, and other
   qualities. The scroller itself doesn't draw anything. Scrollers track scroll
   offsets for you over time, but they don't automatically apply those positions
   to your view. You must get and apply new coordinates at a rate that makes the
   scrolling animation look smooth.

   .. rubric:: Understand scrolling terminology
      :name: term

   Scrolling is a word that can mean different things in Android, depending on
   the context.

   *Scrolling* is the general process of moving the viewport—that is, the
   "window" of content you're looking at. When scrolling is in both the *x*- and
   *y*-axes, it's called *panning*. The ``InteractiveChart`` sample app in this
   document illustrates two different types of scrolling, dragging and flinging:

   -  **Dragging:** this is the type of scrolling that occurs when a user drags
      their finger across the touchscreen. You can implement dragging by
      overriding
      `onScroll() <#android.view.GestureDetector.OnGestureListener>`__
      in
      `GestureDetector.OnGestureListener <#android.view.GestureDetector.OnGestureListener>`__.
      For more information about dragging, see `Drag and scale <#>`__.
   -  **Flinging:** this is the type of scrolling that occurs when a user drags
      and lifts their finger quickly. After the user lifts their finger, you
      generally want to keep moving the viewport, but decelerate until the
      viewport stops moving. You can implement flinging by overriding
      `onFling() <#android.view.GestureDetector.OnGestureListener>`__
      in ``GestureDetector.OnGestureListener`` and using a scroller object.
   -  **Panning:** scrolling simultaneously along both the *x*- and *y*-axes is
      called *panning*.

   It's common to use scroller objects in conjunction with a fling gesture, but
   you can use them in any context where you want the UI to display scrolling in
   response to a touch event. For example, you can override
   `onTouchEvent() <#android.view.View>`__
   to process touch events directly and produce a scrolling effect or a
   "snap-to-page" animation in response to those touch events.

   .. rubric:: Components that contain built-in scrolling implementations
      :name: components-built-in-support

   The following Android components contain built-in support for scrolling and
   overscrolling behavior:

   -  `GridView <#android.widget.GridView>`__
   -  `HorizontalScrollView <#android.widget.HorizontalScrollView>`__
   -  `ListView <#android.widget.ListView>`__
   -  `NestedScrollView <#androidx.core.widget.NestedScrollView>`__
   -  `RecyclerView <#androidx.recyclerview.widget.RecyclerView>`__
   -  `ScrollView <#android.widget.ScrollView>`__
   -  `ViewPager <#>`__
   -  `ViewPager2 <#androidx.viewpager2.widget.ViewPager2>`__

   If your app needs to support scrolling and overscrolling inside a different
   component, complete the following steps:

   #. `Create a custom touch-based scrolling implementation <#scroll>`__.
   #. To support devices that run Android 12 and later, `implement the stretch overscroll effect <#implement-stretch-overscroll>`__.

   .. rubric:: Create a custom touch-based scrolling implementation
      :name: scroll

   This section describes how to create your own scroller if your app uses a
   component that doesn't `contain built-in support <#components-built-in-support>`__ for scrolling and overscrolling.

   The following snippet comes from the `InteractiveChart sample <https://android.googlesource.com/platform/frameworks/base/+/8c4a8243c77bcbd434fb30587be2feffd2835728/docs/html/training/gestures/scroll.jd>`__.
   It uses a `GestureDetector <#android.view.GestureDetector>`__
   and overrides the
   `GestureDetector.SimpleOnGestureListener <#android.view.GestureDetector.SimpleOnGestureListener>`__
   method ``onFling()``. It uses ``OverScroller`` to track the fling gesture. If
   the user reaches the content edges after they perform the fling gesture, the
   container indicates when the user reaches the end of the content. The
   indication depends on the version of Android that a device runs:

   -  On Android 12 and later, the visual elements stretch and bounce back.
   -  On Android 11 and earlier, the visual elements display a glow effect.

   **Note:** The ``InteractiveChart`` sample app displays a chart that you can
   zoom, pan, or scroll. In the following snippet, ``contentRect`` represents
   the rectangle coordinates within the view that the chart is drawn into. At
   any given time, a subset of the total chart domain and range are drawn into
   this rectangular area. ``currentViewport`` represents the portion of the
   chart that is visible on the screen. Because pixel offsets are generally
   treated as integers, ``contentRect`` is of the type
   `Rect <#android.graphics.Rect>`__. Because the graph domain and
   range are decimal or float values, ``currentViewport`` is of the type
   `RectF <#android.graphics.RectF>`__.
   The first part of the following snippet shows the implementation of
   ``onFling()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Viewport extremes. See currentViewport for a discussion of the viewport.
               private val AXIS_X_MIN = -1f
               private val AXIS_X_MAX = 1f
               private val AXIS_Y_MIN = -1f
               private val AXIS_Y_MAX = 1f

               // The current viewport. This rectangle represents the visible chart
               // domain and range. The viewport is the part of the app that the
               // user manipulates via touch gestures.
               private val currentViewport = RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX)

               // The current destination rectangle—in pixel coordinates—into which
               // the chart data must be drawn.
               private lateinit var contentRect: Rect

               private lateinit var scroller: OverScroller
               private lateinit var scrollerStartViewport: RectF
               ...
               private val gestureListener = object : GestureDetector.SimpleOnGestureListener() {

                   override fun onDown(e: MotionEvent): Boolean {
                       // Initiates the decay phase of any active edge effects.
                       if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
                           releaseEdgeEffects()
                       }
                       scrollerStartViewport.set(currentViewport)
                       // Aborts any active scroll animations and invalidates.
                       scroller.forceFinished(true)
                       ViewCompat.postInvalidateOnAnimation(this@InteractiveLineGraphView)
                       return true
                   }
                   ...
                   override fun onFling(
                           e1: MotionEvent,
                           e2: MotionEvent,
                           velocityX: Float,
                           velocityY: Float
                   ): Boolean {
                       fling((-velocityX).toInt(), (-velocityY).toInt())
                       return true
                   }
               }

               private fun fling(velocityX: Int, velocityY: Int) {
                   // Initiates the decay phase of any active edge effects.
                   // On Android 12 and later, the edge effect (stretch) must
                   // continue.
                   if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
                           releaseEdgeEffects()
                   }
                   // Flings use math in pixels, as opposed to math based on the viewport.
                   val surfaceSize: Point = computeScrollSurfaceSize()
                   val (startX: Int, startY: Int) = scrollerStartViewport.run {
                       set(currentViewport)
                       (surfaceSize.x * (left - AXIS_X_MIN) / (AXIS_X_MAX - AXIS_X_MIN)).toInt() to
                               (surfaceSize.y * (AXIS_Y_MAX - bottom) / (AXIS_Y_MAX - AXIS_Y_MIN)).toInt()
                   }
                   // Before flinging, stops the current animation.
                   scroller.forceFinished(true)
                   // Begins the animation.
                   scroller.fling(
                           // Current scroll position.
                           startX,
                           startY,
                           velocityX,
                           velocityY,
                           /*
                            * Minimum and maximum scroll positions. The minimum scroll
                            * position is generally 0 and the maximum scroll position
                            * is generally the content size less the screen size. So if the
                            * content width is 1000 pixels and the screen width is 200
                            * pixels, the maximum scroll offset is 800 pixels.
                            */
                           0, surfaceSize.x - contentRect.width(),
                           0, surfaceSize.y - contentRect.height(),
                           // The edges of the content. This comes into play when using
                           // the EdgeEffect class to draw "glow" overlays.
                           contentRect.width() / 2,
                           contentRect.height() / 2
                   )
                   // Invalidates to trigger computeScroll().
                   ViewCompat.postInvalidateOnAnimation(this)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Viewport extremes. See currentViewport for a discussion of the viewport.
               private static final float AXIS_X_MIN = -1f;
               private static final float AXIS_X_MAX = 1f;
               private static final float AXIS_Y_MIN = -1f;
               private static final float AXIS_Y_MAX = 1f;

               // The current viewport. This rectangle represents the visible chart
               // domain and range. The viewport is the part of the app that the
               // user manipulates via touch gestures.
               private RectF currentViewport =
                 new RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);

               // The current destination rectangle—in pixel coordinates—into which
               // the chart data must be drawn.
               private final Rect contentRect = new Rect();

               private final OverScroller scroller;
               private final RectF scrollerStartViewport =
                 new RectF(); // Used only for zooms and flings.
               ...
               private final GestureDetector.SimpleOnGestureListener gestureListener
                       = new GestureDetector.SimpleOnGestureListener() {
                   @Override
                   public boolean onDown(MotionEvent e) {
                        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
                           releaseEdgeEffects();
                       }
                       scrollerStartViewport.set(currentViewport);
                       scroller.forceFinished(true);
                       ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.this);
                       return true;
                   }
               ...
                   @Override
                   public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                       fling((int) -velocityX, (int) -velocityY);
                       return true;
                   }
               };

               private void fling(int velocityX, int velocityY) {
                   // Initiates the decay phase of any active edge effects.
                   // On Android 12 and later, the edge effect (stretch) must
                   // continue.
                   if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
                           releaseEdgeEffects();
                   }
                   // Flings use math in pixels, as opposed to math based on the viewport.
                   Point surfaceSize = computeScrollSurfaceSize();
                   scrollerStartViewport.set(currentViewport);
                   int startX = (int) (surfaceSize.x * (scrollerStartViewport.left -
                           AXIS_X_MIN) / (
                           AXIS_X_MAX - AXIS_X_MIN));
                   int startY = (int) (surfaceSize.y * (AXIS_Y_MAX -
                           scrollerStartViewport.bottom) / (
                           AXIS_Y_MAX - AXIS_Y_MIN));
                   // Before flinging, stops the current animation.
                   scroller.forceFinished(true);
                   // Begins the animation.
                   scroller.fling(
                           // Current scroll position.
                           startX,
                           startY,
                           velocityX,
                           velocityY,
                           /*
                            * Minimum and maximum scroll positions. The minimum scroll
                            * position is generally 0 and the maximum scroll position
                            * is generally the content size less the screen size. So if the
                            * content width is 1000 pixels and the screen width is 200
                            * pixels, the maximum scroll offset is 800 pixels.
                            */
                           0, surfaceSize.x - contentRect.width(),
                           0, surfaceSize.y - contentRect.height(),
                           // The edges of the content. This comes into play when using
                           // the EdgeEffect class to draw "glow" overlays.
                           contentRect.width() / 2,
                           contentRect.height() / 2);
                   // Invalidates to trigger computeScroll().
                   ViewCompat.postInvalidateOnAnimation(this);
               }

   When ``onFling()`` calls
   `postInvalidateOnAnimation() <#androidx.core.view.ViewCompat>`__,
   it triggers
   `computeScroll() <#android.view.View>`__ to
   update the values for *x* and *y*. This is typically done when a view child
   is animating a scroll using a scroller object, as shown the preceding
   example.

   Most views pass the scroller object's *x* and *y* position directly to
   `scrollTo() <#android.view.View>`__. The
   following implementation of ``computeScroll()`` takes a different approach:
   it calls
   `computeScrollOffset() <#android.widget.OverScroller>`__
   to get the current location of *x* and *y*. When the criteria for displaying
   an overscroll "glow" edge effect are met— that is, the display is zoomed in,
   *x* or *y* is out of bounds, and the app isn't already showing an
   overscroll—the code sets up the overscroll glow effect and calls
   ``postInvalidateOnAnimation()`` to trigger an invalidate on the view.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Edge effect/overscroll tracking objects.
               private lateinit var edgeEffectTop: EdgeEffect
               private lateinit var edgeEffectBottom: EdgeEffect
               private lateinit var edgeEffectLeft: EdgeEffect
               private lateinit var edgeEffectRight: EdgeEffect

               private var edgeEffectTopActive: Boolean = false
               private var edgeEffectBottomActive: Boolean = false
               private var edgeEffectLeftActive: Boolean = false
               private var edgeEffectRightActive: Boolean = false

               override fun computeScroll() {
                   super.computeScroll()

                   var needsInvalidate = false

                   // The scroller isn't finished, meaning a fling or
                   // programmatic pan operation is active.
                   if (scroller.computeScrollOffset()) {
                       val surfaceSize: Point = computeScrollSurfaceSize()
                       val currX: Int = scroller.currX
                       val currY: Int = scroller.currY

                       val (canScrollX: Boolean, canScrollY: Boolean) = currentViewport.run {
                           (left > AXIS_X_MIN || right < AXIS_X_MAX) to (top > AXIS_Y_MIN || bottom < AXIS_Y_MAX)
                       }

                       /*
                        * If you are zoomed in, currX or currY is
                        * outside of bounds, and you aren't already
                        * showing overscroll, then render the overscroll
                        * glow edge effect.
                        */
                       if (canScrollX
                               && currX < 0
                               && edgeEffectLeft.isFinished
                               && !edgeEffectLeftActive) {
                           edgeEffectLeft.onAbsorb(scroller.currVelocity.toInt())
                           edgeEffectLeftActive = true
                           needsInvalidate = true
                       } else if (canScrollX
                               && currX > surfaceSize.x - contentRect.width()
                               && edgeEffectRight.isFinished
                               && !edgeEffectRightActive) {
                           edgeEffectRight.onAbsorb(scroller.currVelocity.toInt())
                           edgeEffectRightActive = true
                           needsInvalidate = true
                       }

                       if (canScrollY
                               && currY < 0
                               && edgeEffectTop.isFinished
                               && !edgeEffectTopActive) {
                           edgeEffectTop.onAbsorb(scroller.currVelocity.toInt())
                           edgeEffectTopActive = true
                           needsInvalidate = true
                       } else if (canScrollY
                               && currY > surfaceSize.y - contentRect.height()
                               && edgeEffectBottom.isFinished
                               && !edgeEffectBottomActive) {
                           edgeEffectBottom.onAbsorb(scroller.currVelocity.toInt())
                           edgeEffectBottomActive = true
                           needsInvalidate = true
                       }
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Edge effect/overscroll tracking objects.
               private EdgeEffectCompat edgeEffectTop;
               private EdgeEffectCompat edgeEffectBottom;
               private EdgeEffectCompat edgeEffectLeft;
               private EdgeEffectCompat edgeEffectRight;

               private boolean edgeEffectTopActive;
               private boolean edgeEffectBottomActive;
               private boolean edgeEffectLeftActive;
               private boolean edgeEffectRightActive;

               @Override
               public void computeScroll() {
                   super.computeScroll();

                   boolean needsInvalidate = false;

                   // The scroller isn't finished, meaning a fling or
                   // programmatic pan operation is active.
                   if (scroller.computeScrollOffset()) {
                       Point surfaceSize = computeScrollSurfaceSize();
                       int currX = scroller.getCurrX();
                       int currY = scroller.getCurrY();

                       boolean canScrollX = (currentViewport.left > AXIS_X_MIN
                               || currentViewport.right < AXIS_X_MAX);
                       boolean canScrollY = (currentViewport.top > AXIS_Y_MIN
                               || currentViewport.bottom < AXIS_Y_MAX);

                       /*
                        * If you are zoomed in, currX or currY is
                        * outside of bounds, and you aren't already
                        * showing overscroll, then render the overscroll
                        * glow edge effect.
                        */
                       if (canScrollX
                               && currX < 0
                               && edgeEffectLeft.isFinished()
                               && !edgeEffectLeftActive) {
                           edgeEffectLeft.onAbsorb((int)mScroller.getCurrVelocity());
                           edgeEffectLeftActive = true;
                           needsInvalidate = true;
                       } else if (canScrollX
                               && currX > (surfaceSize.x - contentRect.width())
                               && edgeEffectRight.isFinished()
                               && !edgeEffectRightActive) {
                           edgeEffectRight.onAbsorb((int)mScroller.getCurrVelocity());
                           edgeEffectRightActive = true;
                           needsInvalidate = true;
                       }

                       if (canScrollY
                               && currY < 0
                               && edgeEffectTop.isFinished()
                               && !edgeEffectTopActive) {
                           edgeEffectRight.onAbsorb((int)mScroller.getCurrVelocity());
                           edgeEffectTopActive = true;
                           needsInvalidate = true;
                       } else if (canScrollY
                               && currY > (surfaceSize.y - contentRect.height())
                               && edgeEffectBottom.isFinished()
                               && !edgeEffectBottomActive) {
                           edgeEffectRight.onAbsorb((int)mScroller.getCurrVelocity());
                           edgeEffectBottomActive = true;
                           needsInvalidate = true;
                       }
                       ...
                   }

   Here is the section of the code that performs the actual zoom:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               lateinit var zoomer: Zoomer
               val zoomFocalPoint = PointF()
               ...
               // If a zoom is in progress—either programmatically
               // or through double touch—this performs the zoom.
               if (zoomer.computeZoom()) {
                   val newWidth: Float = (1f - zoomer.currZoom) * scrollerStartViewport.width()
                   val newHeight: Float = (1f - zoomer.currZoom) * scrollerStartViewport.height()
                   val pointWithinViewportX: Float =
                           (zoomFocalPoint.x - scrollerStartViewport.left) / scrollerStartViewport.width()
                   val pointWithinViewportY: Float =
                           (zoomFocalPoint.y - scrollerStartViewport.top) / scrollerStartViewport.height()
                   currentViewport.set(
                           zoomFocalPoint.x - newWidth * pointWithinViewportX,
                           zoomFocalPoint.y - newHeight * pointWithinViewportY,
                           zoomFocalPoint.x + newWidth * (1 - pointWithinViewportX),
                           zoomFocalPoint.y + newHeight * (1 - pointWithinViewportY)
                   )
                   constrainViewport()
                   needsInvalidate = true
               }
               if (needsInvalidate) {
                   ViewCompat.postInvalidateOnAnimation(this)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Custom object that is functionally similar to Scroller.
               Zoomer zoomer;
               private PointF zoomFocalPoint = new PointF();
               ...
               // If a zoom is in progress—either programmatically
               // or through double touch—this performs the zoom.
               if (zoomer.computeZoom()) {
                   float newWidth = (1f - zoomer.getCurrZoom()) *
                           scrollerStartViewport.width();
                   float newHeight = (1f - zoomer.getCurrZoom()) *
                           scrollerStartViewport.height();
                   float pointWithinViewportX = (zoomFocalPoint.x -
                           scrollerStartViewport.left)
                           / scrollerStartViewport.width();
                   float pointWithinViewportY = (zoomFocalPoint.y -
                           scrollerStartViewport.top)
                           / scrollerStartViewport.height();
                   currentViewport.set(
                           zoomFocalPoint.x - newWidth * pointWithinViewportX,
                           zoomFocalPoint.y - newHeight * pointWithinViewportY,
                           zoomFocalPoint.x + newWidth * (1 - pointWithinViewportX),
                           zoomFocalPoint.y + newHeight * (1 - pointWithinViewportY));
                   constrainViewport();
                   needsInvalidate = true;
               }
               if (needsInvalidate) {
                   ViewCompat.postInvalidateOnAnimation(this);
               }

   This is the ``computeScrollSurfaceSize()`` method that's called in the
   preceding snippet. It computes the current scrollable surface size in pixels.
   For example, if the entire chart area is visible, this is the current size of
   ``mContentRect``. If the chart is zoomed in 200% in both directions, the
   returned size is twice as large horizontally and vertically.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun computeScrollSurfaceSize(): Point {
                   return Point(
                           (contentRect.width() * (AXIS_X_MAX - AXIS_X_MIN) / currentViewport.width()).toInt(),
                           (contentRect.height() * (AXIS_Y_MAX - AXIS_Y_MIN) / currentViewport.height()).toInt()
                   )
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private Point computeScrollSurfaceSize() {
                   return new Point(
                           (int) (contentRect.width() * (AXIS_X_MAX - AXIS_X_MIN)
                                   / currentViewport.width()),
                           (int) (contentRect.height() * (AXIS_Y_MAX - AXIS_Y_MIN)
                                   / currentViewport.height()));
               }

   For another example of scroller usage, see the `source code <https://android.googlesource.com/platform/frameworks/support/+/5b614a46f6ffb3e9ca5ab6321c12412550a4e13a/viewpager/src/main/java/androidx/viewpager/widget/ViewPager.java>`__
   for the ``ViewPager`` class. It scrolls in response to flings and uses
   scrolling to implement the "snap-to-page" animation.

   .. rubric:: Implement the stretch overscroll effect
      :name: implement-stretch-overscroll

   Starting in Android 12, ``EdgeEffect`` adds the following APIs for
   implementing the stretch overscroll effect:

   -  ``getDistance()``
   -  ``onPullDistance()``

   To provide the best user experience with stretch overscroll, do the
   following:

   #. When the stretch animation is in effect when the user touches the
      contents, register the touch as a "catch." The user stops the animation
      and begins manipulating the stretch again.
   #. When the user moves their finger in the opposite direction of the stretch,
      release the stretch until it's fully gone, and then begin scrolling.
   #. When the user flings during a stretch, fling the ``EdgeEffect`` to enhance
      the stretch effect.

   .. rubric:: Catch the animation
      :name: catch-animation

   When a user catches an active stretch animation, ``EdgeEffect.getDistance()``
   returns ``0``. This condition indicates that the stretch must be manipulated
   by the touch motion. In most containers, the catch is detected in
   ``onInterceptTouchEvent()``, as shown in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onInterceptTouchEvent(ev: MotionEvent): Boolean {
                 ...
                 when (action and MotionEvent.ACTION_MASK) {
                   MotionEvent.ACTION_DOWN ->
                     ...
                     isBeingDragged = EdgeEffectCompat.getDistance(edgeEffectBottom) > 0f ||
                         EdgeEffectCompat.getDistance(edgeEffectTop) > 0f
                     ...
                 }
                 return isBeingDragged
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onInterceptTouchEvent(MotionEvent ev) {
                 ...
                 switch (action & MotionEvent.ACTION_MASK) {
                   case MotionEvent.ACTION_DOWN:
                     ...
                     isBeingDragged = EdgeEffectCompat.getDistance(edgeEffectBottom) > 0
                         || EdgeEffectCompat.getDistance(edgeEffectTop) > 0;
                     ...
                 }
               }

   In the preceding example, ``onInterceptTouchEvent()`` returns ``true`` when
   ``mIsBeingDragged`` is ``true``, so it's sufficient to consume the event
   before the child has an opportunity to consume it.

   .. rubric:: Release the overscroll effect
      :name: release-overscroll-effect

   It's important to release the stretch effect prior to scrolling to prevent
   the stretch from being applied to the scrolling content. The following code
   sample applies this best practice:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onTouchEvent(ev: MotionEvent): Boolean {
                 val activePointerIndex = ev.actionIndex

                 when (ev.getActionMasked()) {
                   MotionEvent.ACTION_MOVE ->
                     val x = ev.getX(activePointerIndex)
                     val y = ev.getY(activePointerIndex)
                     var deltaY = y - lastMotionY
                     val pullDistance = deltaY / height
                     val displacement = x / width

                     if (deltaY < 0f && EdgeEffectCompat.getDistance(edgeEffectTop) > 0f) {
                       deltaY -= height * EdgeEffectCompat.onPullDistance(edgeEffectTop,
                           pullDistance, displacement);
                     }
                     if (deltaY > 0f && EdgeEffectCompat.getDistance(edgeEffectBottom) > 0f) {
                       deltaY += height * EdgeEffectCompat.onPullDistance(edgeEffectBottom,
                           -pullDistance, 1 - displacement);
                     }
                     ...
                 }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onTouchEvent(MotionEvent ev) {

                 final int actionMasked = ev.getActionMasked();

                 switch (actionMasked) {
                   case MotionEvent.ACTION_MOVE:
                     final float x = ev.getX(activePointerIndex);
                     final float y = ev.getY(activePointerIndex);
                     float deltaY = y - lastMotionY;
                     float pullDistance = deltaY / getHeight();
                     float displacement = x / getWidth();

                     if (deltaY < 0 && EdgeEffectCompat.getDistance(edgeEffectTop) > 0) {
                       deltaY -= getHeight() * EdgeEffectCompat.onPullDistance(edgeEffectTop,
                           pullDistance, displacement);
                     }
                     if (deltaY > 0 && EdgeEffectCompat.getDistance(edgeEffectBottom) > 0) {
                       deltaY += getHeight() * EdgeEffectCompat.onPullDistance(edgeEffectBottom,
                           -pullDistance, 1 - displacement);
                     }
                           ...

   When the user is dragging, consume the ``EdgeEffect`` pull distance before
   you pass the touch event to a nested scrolling container or drag the scroll.
   In the preceding code sample, ``getDistance()`` returns a positive value when
   an edge effect is being displayed and can be released with motion. When the
   touch event releases the stretch, it is first consumed by the ``EdgeEffect``
   so that it is completely released before other effects, such as nested
   scrolling, are displayed. You can use ``getDistance()`` to learn how much
   pull distance is required to release the current effect.

   Unlike ``onPull()``, ``onPullDistance()`` returns the consumed amount of the
   passed delta. Starting in Android 12, if ``onPull()`` or ``onPullDistance()``
   are passed negative ``deltaDistance`` values when ``getDistance()`` is ``0``,
   the stretch effect doesn't change. On Android 11 and earlier, ``onPull()``
   lets negative values for the total distance show glow effects.

   .. rubric:: Opt out of overscroll
      :name: overscroll-opt-out

   You can opt out of overscroll in your layout file or programmatically.

   To opt out in your layout file, set ``android:overScrollMode`` as shown in
   the following example:

   .. code:: prettyprint

      <MyCustomView android:overScrollMode="never">
          ...
      </MyCustomView>

   To opt out programmatically, use code like the following:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               customView.overScrollMode = View.OVER_SCROLL_NEVER

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               customView.setOverScrollMode(View.OVER_SCROLL_NEVER);

   .. rubric:: Additional resources
      :name: additional-resources

   Refer to the following related resources:

   -  `Input events overview <#>`__
   -  `Sensors overview <#>`__
   -  `Make a custom view interactive <#>`__


Last updated 2024-05-03 UTC.



/Add support for navigation gestures
====================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/gesturenav?hl=en

.. container:: devsite-article-body

   Beginning with Android 10 (API level 29), the Android system supports fully
   gesture-based navigation. There are two things app developers must do to
   ensure their apps are compatible with this feature:

   -  Extend app content from edge to edge.
   -  Handle conflicting app gestures.

   In addition, Android 13 (API level 33) introduces a `predictive back gesture <#>`__ for Android devices
   such as phones, large screens, and foldables that is part of a multiyear
   release. App developers can take steps to ensure that their apps support the
   predictive back gesture.

   .. rubric:: Provide edge-to-edge app content
      :name: edge-to-edge

   To take advantage of the additional screen space made available by the
   floating navigation bar, you need to configure certain changes in your app.

   See `Display content edge-to-edge in your app <#>`__ for details.

   .. rubric:: Handle conflicting app gestures
      :name: conflicting-gestures

   The gesture navigation model might conflict with gestures that were
   previously used by app developers. You might need to make adjustments to your
   app's user interface as a result.

   .. rubric:: Conflicts with back gestures
      :name: back-gestures

   The new system gesture for back is an inward swipe from either the left or
   the right edge of the screen. This might interfere with app navigation
   elements in those areas. To maintain functionality of elements on the left
   and right edges of the screen, opt out of the back gesture selectively by
   indicating to the system which regions need to receive touch input. You can
   do this by passing a ``List<Rect>`` to the
   `View.setSystemGestureExclusionRects() <#android.view.View>`__
   API introduced in Android 10. This method is also available in
   `ViewCompat <#androidx.core.view.ViewCompat>`__ as of
   ``androidx.core:core:1.1.0-dev01``.

   For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var exclusionRects = listOf(rect1, rect2, rect3)

               fun onLayout(
                       changedCanvas: Boolean, left: Int, top: Int, right: Int, bottom: Int) {
                 // Update rect bounds and the exclusionRects list
                 setSystemGestureExclusionRects(exclusionRects)
               }

               fun onDraw(canvas: Canvas) {
                 // Update rect bounds and the exclusionRects list
                 setSystemGestureExclusionRects(exclusionRects)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               List<Rect> exclusionRects;

               public void onLayout(
                       boolean changedCanvas, int left, int top, int right, int bottom) {
                   // Update rect bounds and the exclusionRects list
                   setSystemGestureExclusionRects(exclusionRects);
               }

               public void onDraw(Canvas canvas) {
                   // Update rect bounds and the exclusionRects list
                   setSystemGestureExclusionRects(exclusionRects);
               }

   **Note:**\  The ``DrawerLayout`` and ``SeekBar`` components support automatic
   opt-out behavior out of the box.

   .. rubric:: Conflicts with home or quick-switch gestures
      :name: home-gestures

   The new system gestures for home and quick switch both involve swipes at the
   bottom of the screen in the space previously occupied by the nav bar. Apps
   can't opt out of these gestures as they can with the back gesture.

   To mitigate this problem, Android 10 introduces the
   `WindowInsets.getMandatorySystemGestureInsets() <#android.view.WindowInsets.Type>`__
   API, which informs apps of the touch recognition thresholds.

   .. rubric:: Games and other non-View apps
      :name: games

   Games and other apps that don't have a view hierarchy often require the user
   to swipe near the system gesture areas. In those cases, games can use
   `Window.setSystemGestureExclusionRects() <#android.view.Window>`__
   to exclude areas that overlap with areas reserved for system gestures. Games
   must make sure to only exclude these areas when necessary, such as during
   gameplay.

   If a game requires the user to swipe near the home gesture area, the app can
   request to be laid out in `immersive mode <#immersive>`__. This disables the system
   gestures while the user is interacting with the game, but lets the user
   re-enable the system gestures by swiping from the bottom of the screen.

   .. rubric:: Update your app to support the predictive back gesture
      :name: predictive-back

   Android 13 (API level 33) introduces a predictive back gesture for Android
   devices such as phones, large screens, and foldables. The predictive back
   gesture is part of a multiyear release. When fully implemented, this feature
   lets users preview the destination or other result of a back gesture before
   they fully complete it, allowing them to decide whether to continue or stay
   in the current view.

   See `Add support for the predictive back gesture <#>`__ for details.

   .. rubric:: Additional resources
      :name: additional-resources

   To learn more about gesture navigation, see the following:

   .. rubric:: Blog posts
      :name: blogs

   -  `Gesture Navigation: handling visual overlaps (II) <https://medium.com/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c>`__

   .. rubric:: Videos
      :name: videos

   -  `Android 10: Gestural navigation <https://www.youtube.com/watch?v=Ljtz7T8R_Hk>`__
   -  `Dark theme & gesture navigation (Google I/O ’19) <https://www.youtube.com/watch?v=OCHEjeLC_UY>`__


Last updated 2024-05-03 UTC.


/Detect multi-touch gestures
============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/multi?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Multi-touch gestures → <https://developer.android.google.cn/jetpack/compose/touch-input/pointer-input#multi-touch>`__

      |image-android-compose-ui-logo|

   A multi-touch gesture is when multiple pointers (fingers) tap the screen at
   the same time. This document describes how to detect gestures that involve
   multiple pointers.

   .. rubric:: Track multiple pointers
      :name: track

   When multiple pointers tap the screen at the same time, the system generates
   the following touch events:

   -  `ACTION_DOWN <#android.view.MotionEvent>`__:
      sent when the first pointer taps the screen. This starts the gesture. The
      pointer data for this pointer is always at index ``0`` in the
      `MotionEvent <#android.view.MotionEvent>`__.
   -  `ACTION_POINTER_DOWN <#android.view.MotionEvent>`__:
      sent when extra pointers enter the screen after the first. You can obtain
      the index of the pointer that just went down using
      `getActionIndex() <#android.view.MotionEvent>`__.
   -  `ACTION_MOVE <#android.view.MotionEvent>`__:
      sent when a change occurs in a gesture, involving any number of pointers.
   -  `ACTION_POINTER_UP <#android.view.MotionEvent>`__:
      sent when a non-primary pointer goes up. You can obtain the index of the
      pointer that just went up using ``getActionIndex()``.
   -  `ACTION_UP <#android.view.MotionEvent>`__: sent
      when the last pointer leaves the screen.
   -  `ACTION_CANCEL <#android.view.MotionEvent>`__:
      indicates that the entire gesture, including all pointers, is canceled.

   .. rubric:: Start and end gestures
      :name: start-and-end-gestures

   A gesture is a series of events starting with an ``ACTION_DOWN`` event and
   ending with either an ``ACTION_UP`` or ``ACTION_CANCEL`` event. There is one
   active gesture at a time. The actions DOWN, MOVE, UP, and CANCEL apply to the
   entire gesture. For example, an event with ``ACTION_MOVE`` can indicate a
   movement for all pointers down at that moment.

   .. rubric:: Keep track of pointers
      :name: keep-track-of-pointers

   Use the pointer's index and ID to keep track of the individual pointers
   positions within a ``MotionEvent``.

   -  **Index**: a ``MotionEvent`` stores pointer information in an array. The
      index of a pointer is its position within this array. Most of the
      ``MotionEvent`` methods take the pointer index as a parameter, rather than
      the pointer ID.
   -  **ID**: each pointer also has an ID mapping that stays persistent across
      touch events to allow for tracking of an individual pointer across the
      entire gesture.

   Individual pointers appear within a motion event in an undefined order. Thus,
   the index of a pointer can change from one event to the next, but the pointer
   ID of a pointer is guaranteed to remain constant as long as the pointer
   remains active. Use the
   `getPointerId() <#android.view.MotionEvent>`__
   method to obtain a pointer's ID to track the pointer across all subsequent
   motion events in a gesture. Then, for successive motion events, use the
   `findPointerIndex() <#android.view.MotionEvent>`__
   method to obtain the pointer index for a given pointer ID in that motion
   event. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private var mActivePointerId: Int = 0

               override fun onTouchEvent(event: MotionEvent): Boolean {
                   ...
                   // Get the pointer ID.
                   mActivePointerId = event.getPointerId(0)

                   // ... Many touch events later...

                   // Use the pointer ID to find the index of the active pointer
                   // and fetch its position.
                   val (x: Float, y: Float) = event.findPointerIndex(mActivePointerId).let { pointerIndex ->
                       // Get the pointer's current position.
                       event.getX(pointerIndex) to event.getY(pointerIndex)
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private int mActivePointerId;

               public boolean onTouchEvent(MotionEvent event) {
                   ...
                   // Get the pointer ID.
                   mActivePointerId = event.getPointerId(0);

                   // ... Many touch events later...

                   // Use the pointer ID to find the index of the active pointer
                   // and fetch its position.
                   int pointerIndex = event.findPointerIndex(mActivePointerId);
                   // Get the pointer's current position.
                   float x = event.getX(pointerIndex);
                   float y = event.getY(pointerIndex);
                   ...
               }

   To support multiple touch pointers, you can cache all active pointers with
   their IDs at their individual ``ACTION_POINTER_DOWN`` and ``ACTION_DOWN``
   event time. Remove the pointers from your cache at their
   ``ACTION_POINTER_UP`` and ``ACTION_UP``\ events. You might find these cached
   IDs helpful to handle other action events correctly. For example, when
   processing an ``ACTION_MOVE`` event, find the index for each cached active
   pointer ID, retrieve the pointer's coordinates using the
   `getX() <#android.view.MotionEvent>`__ and
   `getY() <#android.view.MotionEvent>`__ functions,
   then compare these coordinates with your cached coordinates to discover which
   pointers moved.

   Use the ``getActionIndex()`` function with ``ACTION_POINTER_UP`` and
   ``ACTION_POINTER_DOWN`` events only. Don't use this function with
   ``ACTION_MOVE`` events, as this always returns ``0``.

   .. rubric:: Retrieve ``MotionEvent`` actions
      :name: action

   Use the
   `getActionMasked() <#android.view.MotionEvent>`__
   method or the compatibility version
   `MotionEventCompat.getActionMasked() <#androidx.core.view.MotionEventCompat>`__
   to retrieve the action of a ``MotionEvent``. Unlike the earlier
   `getAction() <#android.view.MotionEvent>`__ method,
   ``getActionMasked()`` is designed to work with multiple pointers. It returns
   the action without the pointer indices. For actions with a valid pointer
   index, use ``getActionIndex()`` to return the index of the pointers
   associated with the action as shown in the following snippet:

   **Note:** This example uses the
   `MotionEventCompat <#androidx.core.view.MotionEventCompat>`__
   class, a class in the `Support Library <#>`__. Use
   ``MotionEventCompat`` to provide the best support for a wide range of
   platforms. ``MotionEventCompat`` is *not* a replacement for the
   ``MotionEvent`` class. Rather, it provides static utility methods to which
   you pass your ``MotionEvent`` object to receive the desired action associated
   with that event.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val (xPos: Int, yPos: Int) = MotionEventCompat.getActionMasked(event).let { action ->
                   Log.d(DEBUG_TAG, "The action is ${actionToString(action)}")
                   // Get the index of the pointer associated with the action.
                   MotionEventCompat.getActionIndex(event).let { index ->
                       // The coordinates of the current screen contact, relative to
                       // the responding View or Activity.
                       MotionEventCompat.getX(event, index).toInt() to MotionEventCompat.getY(event, index).toInt()
                   }
               }

               if (event.pointerCount > 1) {
                   Log.d(DEBUG_TAG, "Multitouch event")

               } else {
                   // Single touch event.
                   Log.d(DEBUG_TAG, "Single touch event")
               }

               ...

               // Given an action int, returns a string description.
               fun actionToString(action: Int): String {
                   return when (action) {
                       MotionEvent.ACTION_DOWN -> "Down"
                       MotionEvent.ACTION_MOVE -> "Move"
                       MotionEvent.ACTION_POINTER_DOWN -> "Pointer Down"
                       MotionEvent.ACTION_UP -> "Up"
                       MotionEvent.ACTION_POINTER_UP -> "Pointer Up"
                       MotionEvent.ACTION_OUTSIDE -> "Outside"
                       MotionEvent.ACTION_CANCEL -> "Cancel"
                       else -> ""
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               int action = MotionEventCompat.getActionMasked(event);
               // Get the index of the pointer associated with the action.
               int index = MotionEventCompat.getActionIndex(event);
               int xPos = -1;
               int yPos = -1;

               Log.d(DEBUG_TAG,"The action is " + actionToString(action));

               if (event.getPointerCount() > 1) {
                   Log.d(DEBUG_TAG,"Multitouch event");
                   // The coordinates of the current screen contact, relative to
                   // the responding View or Activity.
                   xPos = (int)MotionEventCompat.getX(event, index);
                   yPos = (int)MotionEventCompat.getY(event, index);

               } else {
                   // Single touch event.
                   Log.d(DEBUG_TAG,"Single touch event");
                   xPos = (int)MotionEventCompat.getX(event, index);
                   yPos = (int)MotionEventCompat.getY(event, index);
               }
               ...

               // Given an action int, returns a string description
               public static String actionToString(int action) {
                   switch (action) {

                       case MotionEvent.ACTION_DOWN: return "Down";
                   case MotionEvent.ACTION_MOVE: return "Move";
                   case MotionEvent.ACTION_POINTER_DOWN: return "Pointer Down";
                   case MotionEvent.ACTION_UP: return "Up";
                   case MotionEvent.ACTION_POINTER_UP: return "Pointer Up";
                   case MotionEvent.ACTION_OUTSIDE: return "Outside";
                   case MotionEvent.ACTION_CANCEL: return "Cancel";
                   }
                   return "";
               }

   .. container:: float
      :name: multitouch

   .. rubric:: Additional resources
      :name: additionalResources

   For more information related to input events, see the following references:

   -  `Input events overview <#>`__
   -  `Sensors overview <#>`__
   -  `Make a custom view interactive <#>`__
   -  `Drag and scale <#>`__


Last updated 2024-04-15 UTC.



/Add support for drag and scale
===============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/scale?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Draggable → <https://developer.android.google.cn/jetpack/compose/touch-input/pointer-input#dragging>`__

      |image-android-compose-ui-logo|

   .. container:: video-wrapper

   This document describes how to use touch gestures to drag and scale on-screen
   objects, using
   `onTouchEvent() <#android.view.View>`__
   to intercept touch events.

   .. rubric:: Drag an object
      :name: drag

   **Important:** We recomment using `Receive rich content <#>`__ to implement drag and
   drop.
   A common operation for a touch gesture is to use it to drag an object across
   the screen.

   In a drag or scroll operation, the app has to keep track of the original
   pointer, even if additional fingers touch the screen. For example, imagine
   that while dragging the image, the user places a second finger on the touch
   screen and lifts the first finger. If your app is only tracking individual
   pointers, it regards the second pointer as the default and moves the image to
   that location.

   To prevent this from happening, your app needs to distinguish between the
   original pointer and any subsequent pointers. To do this, it tracks the
   `ACTION_POINTER_DOWN <#android.view.MotionEvent>`__
   and
   `ACTION_POINTER_UP <#android.view.MotionEvent>`__
   events as described in `Handle multi-touch gestures <#>`__.
   ``ACTION_POINTER_DOWN`` and ``ACTION_POINTER_UP`` are passed to the
   ``onTouchEvent()`` callback whenever a secondary pointer goes down or up.

   In the ``ACTION_POINTER_UP`` case, you can extract this index and ensure that
   the active pointer ID isn't referring to a pointer that is no longer touching
   the screen. If it is, you can select a different pointer to be active and
   save its current X and Y position. Use this saved position in the
   `ACTION_MOVE <#android.view.MotionEvent>`__ case to
   calculate the distance to move the on-screen object. This way, the app always
   calculates the distance to move using data from the correct pointer.

   The following code snippet lets a user drag an object on the screen. It
   records the initial position of the active pointer, calculates the distance
   the pointer travels, and moves the object to the new position. It also
   correctly manages the possibility of additional pointers.

   The snippet uses the
   `getActionMasked() <#android.view.MotionEvent>`__
   method. Always use this method to retrieve the action of a
   `MotionEvent <#android.view.MotionEvent>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The "active pointer" is the one moving the object.
               private var mActivePointerId = INVALID_POINTER_ID

               override fun onTouchEvent(ev: MotionEvent): Boolean {
                   // Let the ScaleGestureDetector inspect all events.
                   mScaleDetector.onTouchEvent(ev)

                   val action = MotionEventCompat.getActionMasked(ev)

                   when (action) {
                       MotionEvent.ACTION_DOWN -> {
                           MotionEventCompat.getActionIndex(ev).also { pointerIndex ->
                               // Remember where you start for dragging.
                               mLastTouchX = MotionEventCompat.getX(ev, pointerIndex)
                               mLastTouchY = MotionEventCompat.getY(ev, pointerIndex)
                           }

                           // Save the ID of this pointer for dragging.
                           mActivePointerId = MotionEventCompat.getPointerId(ev, 0)
                       }

                       MotionEvent.ACTION_MOVE -> {
                           // Find the index of the active pointer and fetch its position.
                           val (x: Float, y: Float) =
                                   MotionEventCompat.findPointerIndex(ev, mActivePointerId).let { pointerIndex ->
                                       // Calculate the distance moved.
                                       MotionEventCompat.getX(ev, pointerIndex) to
                                               MotionEventCompat.getY(ev, pointerIndex)
                                   }

                           mPosX += x - mLastTouchX
                           mPosY += y - mLastTouchY

                           invalidate()

                           // Remember this touch position for the next move event.
                           mLastTouchX = x
                           mLastTouchY = y
                       }
                       MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                           mActivePointerId = INVALID_POINTER_ID
                       }
                       MotionEvent.ACTION_POINTER_UP -> {

                           MotionEventCompat.getActionIndex(ev).also { pointerIndex ->
                               MotionEventCompat.getPointerId(ev, pointerIndex)
                                       .takeIf { it == mActivePointerId }
                                       ?.run {
                                           // This is the active pointer going up. Choose a new
                                           // active pointer and adjust it accordingly.
                                           val newPointerIndex = if (pointerIndex == 0) 1 else 0
                                           mLastTouchX = MotionEventCompat.getX(ev, newPointerIndex)
                                           mLastTouchY = MotionEventCompat.getY(ev, newPointerIndex)
                                           mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex)
                                       }
                           }
                       }
                   }
                   return true
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The "active pointer" is the one moving the object.
               private int mActivePointerId = INVALID_POINTER_ID;

               @Override
               public boolean onTouchEvent(MotionEvent ev) {
                   // Let the ScaleGestureDetector inspect all events.
                   mScaleDetector.onTouchEvent(ev);

                   final int action = MotionEventCompat.getActionMasked(ev);

                   switch (action) {
                   case MotionEvent.ACTION_DOWN: {
                       final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                       final float x = MotionEventCompat.getX(ev, pointerIndex);
                       final float y = MotionEventCompat.getY(ev, pointerIndex);

                       // Remember the starting position of the pointer.
                       mLastTouchX = x;
                       mLastTouchY = y;
                       // Save the ID of this pointer for dragging.
                       mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
                       break;
                   }

                   case MotionEvent.ACTION_MOVE: {
                       // Find the index of the active pointer and fetch its position.
                       final int pointerIndex =
                               MotionEventCompat.findPointerIndex(ev, mActivePointerId);

                       final float x = MotionEventCompat.getX(ev, pointerIndex);
                       final float y = MotionEventCompat.getY(ev, pointerIndex);

                       // Calculate the distance moved.
                       final float dx = x - mLastTouchX;
                       final float dy = y - mLastTouchY;

                       mPosX += dx;
                       mPosY += dy;

                       invalidate();

                       // Remember this touch position for the next move event.
                       mLastTouchX = x;
                       mLastTouchY = y;

                       break;
                   }

                   case MotionEvent.ACTION_UP: {
                       mActivePointerId = INVALID_POINTER_ID;
                       break;
                   }

                   case MotionEvent.ACTION_CANCEL: {
                       mActivePointerId = INVALID_POINTER_ID;
                       break;
                   }

                   case MotionEvent.ACTION_POINTER_UP: {

                       final int pointerIndex = MotionEventCompat.getActionIndex(ev);
                       final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);

                       if (pointerId == mActivePointerId) {
                           // This is the active pointer going up. Choose a new
                           // active pointer and adjust it accordingly.
                           final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                           mLastTouchX = MotionEventCompat.getX(ev, newPointerIndex);
                           mLastTouchY = MotionEventCompat.getY(ev, newPointerIndex);
                           mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
                       }
                       break;
                   }
                   }
                   return true;
               }

   .. rubric:: Drag to pan
      :name: pan

   The previous section shows an example of dragging an object on the screen.
   Another common scenario is panning, which is when a user's dragging motion
   causes scrolling in both the X- and Y-axes. The preceding snippet directly
   intercepts the ``MotionEvent`` actions to implement dragging. The snippet in
   this section takes advantage of the platform's built-in support for common
   gestures by overriding
   `onScroll() <#android.view.GestureDetector.OnGestureListener>`__
   in
   `GestureDetector.SimpleOnGestureListener <#android.view.GestureDetector.SimpleOnGestureListener>`__.

   To provide more context, ``onScroll()`` is called when a user drags a finger
   to pan the content. ``onScroll()`` is only called when a finger is down. As
   soon as the finger is lifted from the screen, either the gesture either ends
   or a fling gesture starts, if the finger is moving with some speed just
   before it is lifted. For more information about scrolling versus flinging,
   see `Animate a scroll gesture <#>`__.

   The following is the code snippet for ``onScroll()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The current viewport. This rectangle represents the visible
               // chart domain and range.
               private val mCurrentViewport = RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX)

               // The current destination rectangle, in pixel coordinates, into which the
               // chart data must be drawn.
               private val mContentRect: Rect? = null

               private val mGestureListener = object : GestureDetector.SimpleOnGestureListener() {
                   ...
                   override fun onScroll(
                           e1: MotionEvent,
                           e2: MotionEvent,
                           distanceX: Float,
                           distanceY: Float
                   ): Boolean {
                       // Scrolling uses math based on the viewport, as opposed to math using
                       // pixels.

                       mContentRect?.apply {
                           // Pixel offset is the offset in screen pixels, while viewport offset is the
                           // offset within the current viewport.
                           val viewportOffsetX = distanceX * mCurrentViewport.width() / width()
                           val viewportOffsetY = -distanceY * mCurrentViewport.height() / height()


                           // Updates the viewport and refreshes the display.
                           setViewportBottomLeft(
                                   mCurrentViewport.left + viewportOffsetX,
                                   mCurrentViewport.bottom + viewportOffsetY
                           )
                       }

                       return true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The current viewport. This rectangle represents the visible
               // chart domain and range.
               private RectF mCurrentViewport =
                       new RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);

               // The current destination rectangle, in pixel coordinates, into which the
               // chart data must be drawn.
               private Rect mContentRect;

               private final GestureDetector.SimpleOnGestureListener mGestureListener
                           = new GestureDetector.SimpleOnGestureListener() {
               ...

               @Override
               public boolean onScroll(MotionEvent e1, MotionEvent e2,
                           float distanceX, float distanceY) {
                   // Scrolling uses math based on the viewport, as opposed to math using
                   // pixels.

                   // Pixel offset is the offset in screen pixels, while viewport offset is the
                   // offset within the current viewport.
                   float viewportOffsetX = distanceX * mCurrentViewport.width()
                           / mContentRect.width();
                   float viewportOffsetY = -distanceY * mCurrentViewport.height()
                           / mContentRect.height();
                   ...
                   // Updates the viewport, refreshes the display.
                   setViewportBottomLeft(
                           mCurrentViewport.left + viewportOffsetX,
                           mCurrentViewport.bottom + viewportOffsetY);
                   ...
                   return true;
               }

   The implementation of ``onScroll()`` scrolls the viewport in response to the
   touch gesture:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               /**
                * Sets the current viewport, defined by mCurrentViewport, to the given
                * X and Y positions. The Y value represents the topmost pixel position,
                * and thus the bottom of the mCurrentViewport rectangle.
                */
               private fun setViewportBottomLeft(x: Float, y: Float) {
                   /*
                    * Constrains within the scroll range. The scroll range is the viewport
                    * extremes, such as AXIS_X_MAX, minus the viewport size. For example, if
                    * the extremes are 0 and 10 and the viewport size is 2, the scroll range
                    * is 0 to 8.
                    */

                   val curWidth: Float = mCurrentViewport.width()
                   val curHeight: Float = mCurrentViewport.height()
                   val newX: Float = Math.max(AXIS_X_MIN, Math.min(x, AXIS_X_MAX - curWidth))
                   val newY: Float = Math.max(AXIS_Y_MIN + curHeight, Math.min(y, AXIS_Y_MAX))

                   mCurrentViewport.set(newX, newY - curHeight, newX + curWidth, newY)

                   // Invalidates the View to update the display.
                   ViewCompat.postInvalidateOnAnimation(this)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               /**
                * Sets the current viewport (defined by mCurrentViewport) to the given
                * X and Y positions. Note that the Y value represents the topmost pixel
                * position, and thus the bottom of the mCurrentViewport rectangle.
                */
               private void setViewportBottomLeft(float x, float y) {
                   /*
                    * Constrains within the scroll range. The scroll range is the viewport
                    * extremes, such as AXIS_X_MAX, minus the viewport size. For example, if
                    * the extremes are 0 and 10 and the viewport size is 2, the scroll range
                    * is 0 to 8.
                    */

                   float curWidth = mCurrentViewport.width();
                   float curHeight = mCurrentViewport.height();
                   x = Math.max(AXIS_X_MIN, Math.min(x, AXIS_X_MAX - curWidth));
                   y = Math.max(AXIS_Y_MIN + curHeight, Math.min(y, AXIS_Y_MAX));

                   mCurrentViewport.set(x, y - curHeight, x + curWidth, y);

                   // Invalidates the View to update the display.
                   ViewCompat.postInvalidateOnAnimation(this);
               }

   .. rubric:: Use touch to perform scaling
      :name: scale

   As discussed in `Detect common gestures <#>`__, use
   `GestureDetector <#android.view.GestureDetector>`__ to detect
   common gestures used by Android, such as scrolling, flinging, and touch and
   hold. For scaling, Android provides
   `ScaleGestureDetector <#android.view.ScaleGestureDetector>`__.
   You can use ``GestureDetector`` and ``ScaleGestureDetector`` together when
   you want a view to recognize additional gestures.

   To report detected gesture events, gesture detectors use listener objects
   passed to their constructors. ``ScaleGestureDetector`` uses
   `ScaleGestureDetector.OnScaleGestureListener <#android.view.ScaleGestureDetector.OnScaleGestureListener>`__.
   Android provides
   `ScaleGestureDetector.SimpleOnScaleGestureListener <#android.view.ScaleGestureDetector.SimpleOnScaleGestureListener>`__
   as a helper class that you can extend if you don't need all of the reported
   events.

   .. rubric:: Basic scaling example
      :name: basic-scaling-example

   The following snippet illustrates the basic elements involved in scaling.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private var mScaleFactor = 1f

               private val scaleListener = object : ScaleGestureDetector.SimpleOnScaleGestureListener() {

                   override fun onScale(detector: ScaleGestureDetector): Boolean {
                       mScaleFactor *= detector.scaleFactor

                       // Don't let the object get too small or too large.
                       mScaleFactor = Math.max(0.1f, Math.min(mScaleFactor, 5.0f))

                       invalidate()
                       return true
                   }
               }

               private val mScaleDetector = ScaleGestureDetector(context, scaleListener)

               override fun onTouchEvent(ev: MotionEvent): Boolean {
                   // Let the ScaleGestureDetector inspect all events.
                   mScaleDetector.onTouchEvent(ev)
                   return true
               }

               override fun onDraw(canvas: Canvas?) {
                   super.onDraw(canvas)

                   canvas?.apply {
                       save()
                       scale(mScaleFactor, mScaleFactor)
                       // onDraw() code goes here.
                       restore()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private ScaleGestureDetector mScaleDetector;
               private float mScaleFactor = 1.f;

               public MyCustomView(Context mContext){
                   ...
                   // View code goes here.
                   ...
                   mScaleDetector = new ScaleGestureDetector(context, new ScaleListener());
               }

               @Override
               public boolean onTouchEvent(MotionEvent ev) {
                   // Let the ScaleGestureDetector inspect all events.
                   mScaleDetector.onTouchEvent(ev);
                   return true;
               }

               @Override
               public void onDraw(Canvas canvas) {
                   super.onDraw(canvas);

                   canvas.save();
                   canvas.scale(mScaleFactor, mScaleFactor);
                   ...
                   // onDraw() code goes here.
                   ...
                   canvas.restore();
               }

               private class ScaleListener
                       extends ScaleGestureDetector.SimpleOnScaleGestureListener {
                   @Override
                   public boolean onScale(ScaleGestureDetector detector) {
                       mScaleFactor *= detector.getScaleFactor();

                       // Don't let the object get too small or too large.
                       mScaleFactor = Math.max(0.1f, Math.min(mScaleFactor, 5.0f));

                       invalidate();
                       return true;
                   }
               }

   .. rubric:: More complex scaling example
      :name: more-complex-scaling-example

   The following is a more complex example from the ``InteractiveChart`` sample
   shown in `Animate a scroll gesture <#>`__. The
   ``InteractiveChart`` sample supports scrolling, panning, and scaling with
   multiple fingers, using the ``ScaleGestureDetector`` span
   (`getCurrentSpanX <#android.view.ScaleGestureDetector>`__
   and
   `getCurrentSpanY <#android.view.ScaleGestureDetector>`__)
   and "focus"
   (`getFocusX <#android.view.ScaleGestureDetector>`__
   and
   `getFocusY <#android.view.ScaleGestureDetector>`__)
   features.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val mCurrentViewport = RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX)
               private val mContentRect: Rect? = null
               ...
               override fun onTouchEvent(event: MotionEvent): Boolean {
                   return mScaleGestureDetector.onTouchEvent(event)
                           || mGestureDetector.onTouchEvent(event)
                           || super.onTouchEvent(event)
               }

               /**
                * The scale listener, used for handling multi-finger scale gestures.
                */
               private val mScaleGestureListener = object : ScaleGestureDetector.SimpleOnScaleGestureListener() {

                   /**
                    * This is the active focal point in terms of the viewport. It can be a
                    * local variable, but keep it here to minimize per-frame allocations.
                    */
                   private val viewportFocus = PointF()
                   private var lastSpanX: Float = 0f
                   private var lastSpanY: Float = 0f

                   // Detects new pointers are going down.
                   override fun onScaleBegin(scaleGestureDetector: ScaleGestureDetector): Boolean {
                       lastSpanX = scaleGestureDetector.currentSpanX
                       lastSpanY = scaleGestureDetector.currentSpanY
                       return true
                   }

                   override fun onScale(scaleGestureDetector: ScaleGestureDetector): Boolean {
                       val spanX: Float = scaleGestureDetector.currentSpanX
                       val spanY: Float = scaleGestureDetector.currentSpanY

                       val newWidth: Float = lastSpanX / spanX * mCurrentViewport.width()
                       val newHeight: Float = lastSpanY / spanY * mCurrentViewport.height()

                       val focusX: Float = scaleGestureDetector.focusX
                       val focusY: Float = scaleGestureDetector.focusY
                       // Ensures the chart point is within the chart region.
                       // See the sample for the implementation of hitTest().
                       hitTest(focusX, focusY, viewportFocus)

                       mContentRect?.apply {
                           mCurrentViewport.set(
                                   viewportFocus.x - newWidth * (focusX - left) / width(),
                                   viewportFocus.y - newHeight * (bottom - focusY) / height(),
                                   0f,
                                   0f
                           )
                       }
                       mCurrentViewport.right = mCurrentViewport.left + newWidth
                       mCurrentViewport.bottom = mCurrentViewport.top + newHeight
                       // Invalidates the View to update the display.
                       ViewCompat.postInvalidateOnAnimation(this@InteractiveLineGraphView)

                       lastSpanX = spanX
                       lastSpanY = spanY
                       return true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private RectF mCurrentViewport =
                       new RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);
               private Rect mContentRect;
               private ScaleGestureDetector mScaleGestureDetector;
               ...
               @Override
               public boolean onTouchEvent(MotionEvent event) {
                   boolean retVal = mScaleGestureDetector.onTouchEvent(event);
                   retVal = mGestureDetector.onTouchEvent(event) || retVal;
                   return retVal || super.onTouchEvent(event);
               }

               /**
                * The scale listener, used for handling multi-finger scale gestures.
                */
               private final ScaleGestureDetector.OnScaleGestureListener mScaleGestureListener
                       = new ScaleGestureDetector.SimpleOnScaleGestureListener() {
                   /**
                    * This is the active focal point in terms of the viewport. It can be a
                    * local variable, but keep it here to minimize per-frame allocations.
                    */
                   private PointF viewportFocus = new PointF();
                   private float lastSpanX;
                   private float lastSpanY;

                   // Detects new pointers are going down.
                   @Override
                   public boolean onScaleBegin(ScaleGestureDetector scaleGestureDetector) {
                       lastSpanX = ScaleGestureDetectorCompat.
                               getCurrentSpanX(scaleGestureDetector);
                       lastSpanY = ScaleGestureDetectorCompat.
                               getCurrentSpanY(scaleGestureDetector);
                       return true;
                   }

                   @Override
                   public boolean onScale(ScaleGestureDetector scaleGestureDetector) {

                       float spanX = ScaleGestureDetectorCompat.
                               getCurrentSpanX(scaleGestureDetector);
                       float spanY = ScaleGestureDetectorCompat.
                               getCurrentSpanY(scaleGestureDetector);

                       float newWidth = lastSpanX / spanX * mCurrentViewport.width();
                       float newHeight = lastSpanY / spanY * mCurrentViewport.height();

                       float focusX = scaleGestureDetector.getFocusX();
                       float focusY = scaleGestureDetector.getFocusY();
                       // Ensures the chart point is within the chart region.
                       // See the sample for the implementation of hitTest().
                       hitTest(scaleGestureDetector.getFocusX(),
                               scaleGestureDetector.getFocusY(),
                               viewportFocus);

                       mCurrentViewport.set(
                               viewportFocus.x
                                       - newWidth * (focusX - mContentRect.left)
                                       / mContentRect.width(),
                               viewportFocus.y
                                       - newHeight * (mContentRect.bottom - focusY)
                                       / mContentRect.height(),
                               0,
                               0);
                       mCurrentViewport.right = mCurrentViewport.left + newWidth;
                       mCurrentViewport.bottom = mCurrentViewport.top + newHeight;
                       ...
                       // Invalidates the View to update the display.
                       ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.this);

                       lastSpanX = spanX;
                       lastSpanY = spanY;
                       return true;
                   }
               };

   .. rubric:: Additional resources
      :name: additional-resources

   See the following references for more information about input events,
   sensors, and making custom views interactive.

   -  `Input events overview <#>`__
   -  `Sensors overview <#>`__
   -  `Make a custom view interactive <#>`__


Last updated 2024-04-15 UTC.



/Manage touch events in a ViewGroup
===================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/gestures/viewgroup?hl=en

.. container:: devsite-article-body

   Handling touch events in a
   `ViewGroup <#android.view.ViewGroup>`__ takes special care
   because it's common for a ``ViewGroup`` to have children that are targets for
   different touch events than the ``ViewGroup`` itself. To make sure each view
   correctly receives the touch events intended for it, override the
   `onInterceptTouchEvent() <#android.view.ViewGroup>`__
   method.

   .. container::
      :name: additionalResources

      Refer to the following related resources:

      -  `Input events overview <#>`__
      -  `Sensors overview <#>`__
      -  `Make a custom view interactive <#>`__

   .. rubric:: Intercept touch events in a ViewGroup
      :name: intercept

   The ``onInterceptTouchEvent()`` method is called whenever a touch event is
   detected on the surface of a ``ViewGroup``, including on the surface of its
   children. If ``onInterceptTouchEvent()`` returns ``true``, the
   `MotionEvent <#android.view.MotionEvent>`__ is intercepted,
   meaning it isn't passed onto the child but rather to the
   `onTouchEvent() <#android.view.View>`__
   method of the parent.

   The ``onInterceptTouchEvent()`` method gives a parent the chance to see touch
   events before its children do. If you return ``true`` from
   ``onInterceptTouchEvent()``, the child view that was previously handling
   touch events receives an
   `ACTION_CANCEL <#android.view.MotionEvent>`__,
   and the events from that point forward are sent to the parent's
   ``onTouchEvent()`` method for the usual handling. ``onInterceptTouchEvent()``
   can also return ``false`` and spy on events as they travel down the view
   hierarchy to their usual targets, which handle the events with their own
   ``onTouchEvent()``.

   In the following snippet, the ``MyViewGroup`` class extends ``ViewGroup``.
   ``MyViewGroup`` contains multiple child views. If you drag your finger across
   a child view horizontally, the child view no longer gets touch events, and
   ``MyViewGroup`` handles touch events by scrolling its contents. However, if
   you tap buttons in the child view, or scroll the child view vertically, the
   parent doesn't intercept those touch events because the child is the intended
   target. In those cases, ``onInterceptTouchEvent()`` returns ``false``, and
   the ``MyViewGroup`` class's ``onTouchEvent()`` isn't called.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyViewGroup @JvmOverloads constructor(
                       context: Context,
                       private val mTouchSlop: Int = ViewConfiguration.get(context).scaledTouchSlop
               ) : ViewGroup(context) {
                   ...
                   override fun onInterceptTouchEvent(ev: MotionEvent): Boolean {
                       // This method only determines whether you want to intercept the motion.
                       // If this method returns true, onTouchEvent is called and you can do
                       // the actual scrolling there.
                       return when (ev.actionMasked) {
                           // Always handle the case of the touch gesture being complete.
                           MotionEvent.ACTION_CANCEL, MotionEvent.ACTION_UP -> {
                               // Release the scroll.
                               mIsScrolling = false
                               false // Don't intercept the touch event. Let the child handle it.
                           }
                           MotionEvent.ACTION_MOVE -> {
                               if (mIsScrolling) {
                                   // You're currently scrolling, so intercept the touch event.
                                   true
                               } else {

                                   // If the user drags their finger horizontally more than the
                                   // touch slop, start the scroll.

                                   // Left as an exercise for the reader.
                                   val xDiff: Int = calculateDistanceX(ev)

                                   // Touch slop is calculated using ViewConfiguration constants.
                                   if (xDiff > mTouchSlop) {
                                       // Start scrolling!
                                       mIsScrolling = true
                                       true
                                   } else {
                                       false
                                   }
                               }
                           }
                           ...
                           else -> {
                               // In general, don't intercept touch events. The child view
                               // handles them.
                               false
                           }
                       }
                   }

                   override fun onTouchEvent(event: MotionEvent): Boolean {
                       // Here, you actually handle the touch event. For example, if the action
                       // is ACTION_MOVE, scroll this container. This method is only called if
                       // the touch event is intercepted in onInterceptTouchEvent.
                       ...
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyViewGroup extends ViewGroup {

                   private int mTouchSlop;
                   ...
                   ViewConfiguration vc = ViewConfiguration.get(view.getContext());
                   mTouchSlop = vc.getScaledTouchSlop();
                   ...
                   @Override
                   public boolean onInterceptTouchEvent(MotionEvent ev) {
                       // This method only determines whether you want to intercept the motion.
                       // If this method returns true, onTouchEvent is called and you can do
                       // the actual scrolling there.

                       final int action = MotionEventCompat.getActionMasked(ev);

                       // Always handle the case of the touch gesture being complete.
                       if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
                           // Release the scroll.
                           mIsScrolling = false;
                           return false; // Don't intercept touch event. Let the child handle it.
                       }

                       switch (action) {
                           case MotionEvent.ACTION_MOVE: {
                               if (mIsScrolling) {
                                   // You're currently scrolling, so intercept the touch event.
                                   return true;
                               }

                               // If the user drags their finger horizontally more than the
                               // touch slop, start the scroll.

                               // Left as an exercise for the reader.
                               final int xDiff = calculateDistanceX(ev);

                               // Touch slop is calculated using ViewConfiguration constants.
                               if (xDiff > mTouchSlop) {
                                   // Start scrolling.
                                   mIsScrolling = true;
                                   return true;
                               }
                               break;
                           }
                           ...
                       }

                       // In general, don't intercept touch events. The child view handles them.
                       return false;
                   }

                   @Override
                   public boolean onTouchEvent(MotionEvent ev) {
                       // Here, you actually handle the touch event. For example, if the
                       // action is ACTION_MOVE, scroll this container. This method is only
                       // called if the touch event is intercepted in onInterceptTouchEvent.
                       ...
                   }
               }

   Note that ``ViewGroup`` also provides a
   `requestDisallowInterceptTouchEvent() <#android.view.ViewGroup>`__
   method. The ``ViewGroup`` calls this method when a child doesn't want the
   parent and its ancestors to intercept touch events with
   ``onInterceptTouchEvent()``.

   .. rubric:: Process ACTION_OUTSIDE events
      :name: ao

   If a ``ViewGroup`` receives a ``MotionEvent`` with an
   `ACTION_OUTSIDE <#android.view.MotionEvent>`__,
   the event isn't dispatched to its children by default. To process a
   ``MotionEvent`` with ``ACTION_OUTSIDE``, either override
   `dispatchTouchEvent(MotionEvent event) <#android.view.ViewGroup>`__
   to dispatch to the appropriate `View <#android.view.View>`__ or
   handle it in the relevant
   `Window.Callback <#android.view.Window.Callback>`__—for
   example, `Activity <#android.app.Activity>`__.

   .. rubric:: Use ViewConfiguration constants
      :name: vc

   The preceding snippet uses the current ``ViewConfiguration`` to initialize a
   variable called ``mTouchSlop``. You can use the ``ViewConfiguration`` class
   to access common distances, speeds, and times used by the Android system.

   "Touch slop" refers to the distance in pixels a user's touch can wander
   before the gesture is interpreted as scrolling. Touch slop is typically used
   to prevent accidental scrolling when the user is performing another touch
   operation, such as touching on-screen elements.

   Two other commonly used ``ViewConfiguration`` methods are
   `getScaledMinimumFlingVelocity() <#android.view.ViewConfiguration>`__
   and
   `getScaledMaximumFlingVelocity() <#android.view.ViewConfiguration>`__.
   These methods return the minimum and maximum velocity, respectively, to
   initiate a fling measured in pixels per second. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val vc: ViewConfiguration = ViewConfiguration.get(context)
               private val mSlop: Int = vc.scaledTouchSlop
               private val mMinFlingVelocity: Int = vc.scaledMinimumFlingVelocity
               private val mMaxFlingVelocity: Int = vc.scaledMaximumFlingVelocity
               ...
               MotionEvent.ACTION_MOVE -> {
                   ...
                   val deltaX: Float = motionEvent.rawX - mDownX
                   if (Math.abs(deltaX) > mSlop) {
                       // A swipe occurs, do something.
                   }
                   return false
               }
               ...
               MotionEvent.ACTION_UP -> {
                   ...
                   if (velocityX in mMinFlingVelocity..mMaxFlingVelocity && velocityY < velocityX) {
                       // The criteria are satisfied, do something.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ViewConfiguration vc = ViewConfiguration.get(view.getContext());
               private int mSlop = vc.getScaledTouchSlop();
               private int mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
               private int mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
               ...
               case MotionEvent.ACTION_MOVE: {
                   ...
                   float deltaX = motionEvent.getRawX() - mDownX;
                   if (Math.abs(deltaX) > mSlop) {
                       // A swipe occurs, do something.
                   }
               ...
               case MotionEvent.ACTION_UP: {
                   ...
                   } if (mMinFlingVelocity <= velocityX && velocityX <= mMaxFlingVelocity
                           && velocityY < velocityX) {
                       // The criteria are satisfied, do something.
                   }
               }

   .. rubric:: Extend a child view's touchable area
      :name: delegate

   Android provides the
   `TouchDelegate <#android.view.TouchDelegate>`__ class to make
   it possible for a parent to extend the touchable area of a child view beyond
   the child's bounds. This is useful when the child has to be small but needs a
   larger touch region. You can also use this approach to shrink the child's
   touch region.

   In the following example, an
   `ImageButton <#android.widget.ImageButton>`__ is the \_delegate
   view\_—that is, the child whose touch area the parent extends. Here is the
   layout file:

   .. code:: prettyprint

      <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
           android:id="@+id/parent_layout"
           android:layout_width="match_parent"
           android:layout_height="match_parent"
           tools:context=".MainActivity" >

           <ImageButton android:id="@+id/button"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:background="@null"
                android:src="@drawable/icon" />
      </RelativeLayout>

   The following snippet completes these tasks:

   -  Gets the parent view and posts a
      `Runnable <#>`__ on the UI thread. This
      makes sure that the parent lays out its children before calling the
      `getHitRect() <#android.view.View>`__
      method. The ``getHitRect()`` method gets the child's *hit rectangle* (or
      touchable area) in the parent's coordinates.
   -  Finds the ``ImageButton`` child view and calls ``getHitRect()`` to get the
      bounds of the child's touchable area.
   -  Extends the bounds of the ``ImageButton`` child view's hit rectangle.
   -  Instantiates a ``TouchDelegate``, passing in the expanded hit rectangle
      and the ``ImageButton`` child view as parameters.
   -  Sets the ``TouchDelegate`` on the parent view so that touches within the
      touch delegate bounds are routed to the child.

   In its capacity as touch delegate for the ``ImageButton`` child view, the
   parent view receives all touch events. If the touch event occurs within the
   child's hit rectangle, the parent passes the touch event to the child for
   handling.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               public class MainActivity : Activity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       setContentView(R.layout.activity_main)

                       // Post in the parent's message queue to make sure the parent lays out
                       // its children before you call getHitRect().
                       findViewById<View>(R.id.parent_layout).post {
                           // The bounds for the delegate view, which is an ImageButton in this
                           // example.
                           val delegateArea = Rect()
                           val myButton = findViewById<ImageButton>(R.id.button).apply {
                               isEnabled = true
                               setOnClickListener {
                                   Toast.makeText(
                                           this@MainActivity,
                                           "Touch occurred within ImageButton touch region.",
                                           Toast.LENGTH_SHORT
                                   ).show()
                               }

                               // The hit rectangle for the ImageButton.
                               getHitRect(delegateArea)
                           }

                           // Extend the touch area of the ImageButton beyond its bounds on the
                           // right and bottom.
                           delegateArea.right += 100
                           delegateArea.bottom += 100

                           // Set the TouchDelegate on the parent view so that touches within
                           // the touch delegate bounds are routed to the child.
                           (myButton.parent as? View)?.apply {
                               // Instantiate a TouchDelegate. "delegateArea" is the bounds in
                               // local coordinates of the containing view to be mapped to the
                               // delegate view. "myButton" is the child view that receives
                               // motion events.
                               touchDelegate = TouchDelegate(delegateArea, myButton)
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends Activity {

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);
                       setContentView(R.layout.activity_main);
                       // Get the parent view.
                       View parentView = findViewById(R.id.parent_layout);

                       parentView.post(new Runnable() {
                           // Post in the parent's message queue to make sure the parent lays
                           // out its children before you call getHitRect().
                           @Override
                           public void run() {
                               // The bounds for the delegate view, which is an ImageButton in
                               // this example.
                               Rect delegateArea = new Rect();
                               ImageButton myButton = (ImageButton) findViewById(R.id.button);
                               myButton.setEnabled(true);
                               myButton.setOnClickListener(new View.OnClickListener() {
                                   @Override
                                   public void onClick(View view) {
                                       Toast.makeText(MainActivity.this,
                                               "Touch occurred within ImageButton touch region.",
                                               Toast.LENGTH_SHORT).show();
                                   }
                               });

                               // The hit rectangle for the ImageButton.
                               myButton.getHitRect(delegateArea);

                               // Extend the touch area of the ImageButton beyond its bounds on
                               // the right and bottom.
                               delegateArea.right += 100;
                               delegateArea.bottom += 100;

                               // Instantiate a TouchDelegate. "delegateArea" is the bounds in
                               // local coordinates of the containing view to be mapped to the
                               // delegate view. "myButton" is the child view that receives
                               // motion events.
                               TouchDelegate touchDelegate = new TouchDelegate(delegateArea,
                                       myButton);

                               // Set the TouchDelegate on the parent view so that touches
                               // within the touch delegate bounds are routed to the child.
                               if (View.class.isInstance(myButton.getParent())) {
                                   ((View) myButton.getParent()).setTouchDelegate(touchDelegate);
                               }
                           }
                       });
                   }
               }


Last updated 2024-02-22 UTC.


/About swipe-to-refresh
=======================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/swipe?hl=en

.. container:: devsite-article-body

   .. container:: attempt-right

      **Figure 1.** A swipe-to-refresh action updating a weather app.

   Even if your app automatically updates its content on a regular basis, you
   can also let users request manual updates. For example, a weather forecasting
   app can let users refresh the app to get the latest forecasts on demand. To
   provide a standard user experience for requesting updates, the Android
   platform includes the swipe-to-refresh design pattern, which lets users
   trigger an update with a vertical swipe.

   Download the sample apps:

   -  `SwipeRefreshLayoutBasic <https://github.com/android/views-widgets-samples/tree/main/SwipeRefreshLayoutBasic>`__
   -  `SwipeRefreshMultipleViews <https://github.com/android/views-widgets-samples/tree/main/SwipeRefreshMultipleViews/>`__

   .. rubric:: Lessons
      :name: lessons
      :class: hide-from-toc

   `Add swipe-to-refresh to your app <#>`__
      Learn how to provide swipe-to-refresh support in a
      `RecyclerView <#androidx.recyclerview.widget.RecyclerView>`__
      and how to provide a more accessible refresh option using the action bar.
   `Respond to a refresh request <#>`__
      Learn how to respond to the swipe-to-refresh gesture and how to perform
      the same update from an action bar refresh action.


Last updated 2024-02-22 UTC.


/Add swipe-to-refresh to your app
=================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/swipe/add-swipe-interface?hl=en

.. container:: devsite-article-body

   The swipe-to-refresh user interface pattern is implemented entirely within
   the
   `SwipeRefreshLayout <#androidx.swiperefreshlayout.widget.SwipeRefreshLayout>`__
   widget, which detects the vertical swipe, displays a distinctive progress
   bar, and triggers callback methods in your app. Enable this behavior by
   adding the widget to your layout file as the parent of a
   `ListView <#android.widget.ListView>`__ or
   `GridView <#android.widget.GridView>`__ and implementing the
   refresh behavior that is invoked when the user swipes.

   This page shows how to add the widget to an existing layout. It also shows
   how to add a refresh action to the action bar overflow area so that users who
   can't use the swipe gesture can trigger a manual update with an external
   device.

   .. rubric:: Add SwipeRefreshLayout dependency
      :name: setup

   To use ``SwipeRefreshLayout`` in your app, add the following dependency to
   your ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.swiperefreshlayout:swiperefreshlayout:1.2.0-alpha01"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.swiperefreshlayout:swiperefreshlayout:1.2.0-alpha01")
               }

   .. rubric:: Add the SwipeRefreshLayout Widget
      :name: AddSwipeWidget

   To add the swipe-to-refresh widget to an existing app, add
   ``SwipeRefreshLayout`` as the parent of a single ``ListView`` or
   ``GridView``. ``SwipeRefreshLayout`` only supports a single ``ListView`` or
   ``GridView`` child.

   The following example demonstrates how to add the ``SwipeRefreshLayout``
   widget to an existing layout file containing a ``ListView``:

   .. code:: prettyprint

      <androidx.swiperefreshlayout.widget.SwipeRefreshLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/swiperefresh"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <ListView
              android:id="@android:id/list"
              android:layout_width="match_parent"
              android:layout_height="match_parent" />

      </androidx.swiperefreshlayout.widget.SwipeRefreshLayout>

   You can also use the ``SwipeRefreshLayout`` widget with a
   `ListFragment <#androidx.fragment.app.ListFragment>`__. If the
   layout contains a ``ListView`` with the ID ``"@android:id/list"``, the
   swipe-to-refresh functionality is automatically supported. However,
   explicitly declaring the ``ListView`` this way supersedes the default
   ``ListFragment`` view structure. If you want to use the default view
   structure, override parts of the ``SwipeRefreshLayout`` and ``ListFragment``
   behavior.

   .. rubric:: Add a refresh action to the action bar
      :name: AddRefreshAction

   Add a refresh action to your app's action bar so users who can't perform
   swipe gestures can trigger a manual update. For example, users with
   accessibility needs can trigger action bar actions using external devices,
   such as keyboards and D-pads.

   Add the refresh action as a menu item, rather than as a button, by setting
   the attribute ``android:showAsAction=never``. If you display the action as a
   button, users might assume the refresh button action is different from the
   swipe-to-refresh action. Making the refresh action less conspicuous in the
   action bar encourages users to perform manual updates with swipe gestures
   while maintaining the accessible option where D-pad users look for it.

   The following code demonstrates how to add the swipe-to-refresh action to the
   overflow area:

   .. code:: prettyprint

      <menu xmlns:android="http://schemas.android.com/apk/res/android" >
          <item
              android:id="@+id/menu_refresh"
              android:showAsAction="never"
              android:title="@string/menu_refresh"/>
      </menu>


Last updated 2024-02-22 UTC.


/Respond to a refresh request
=============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/swipe/respond-refresh-request?hl=en

.. container:: devsite-article-body

   This document shows how to update your app when the user requests a manual
   refresh, whether they trigger it with a swipe gesture or use the action bar
   refresh action.

   .. rubric:: Respond to the refresh gesture
      :name: RespondRefresh

   When the user makes the swipe-to-refresh gesture, the system displays the
   progress indicator and calls your app's callback method. Your callback method
   is responsible for updating the app's data.

   To respond to the refresh gesture in your app, implement the
   `SwipeRefreshLayout.OnRefreshListener <#androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListener>`__
   interface and its
   `onRefresh() <#androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListener>`__
   method. The ``onRefresh()`` method is invoked when the user performs a swipe
   gesture.

   Put the code for the actual update operation in a separate method, preferably
   in a ``ViewModel``, and call that update method from your ``onRefresh()``
   implementation. That way, you can use the same update method to perform the
   update when the user triggers a refresh from the action bar.

   In your update method, call
   `setRefreshing(false) <#androidx.swiperefreshlayout.widget.SwipeRefreshLayout>`__
   when it finishes updating the data. Calling this method instructs the
   `SwipeRefreshLayout <#androidx.swiperefreshlayout.widget.SwipeRefreshLayout>`__
   to remove the progress indicator and update the view contents.

   For example, the following code implements ``onRefresh()`` and invokes the
   method ``myUpdateOperation()`` to update the data displayed by a
   `ListView <#android.widget.ListView>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Sets up a SwipeRefreshLayout.OnRefreshListener that invokes when
               // the user performs a swipe-to-refresh gesture.

               mySwipeRefreshLayout.setOnRefreshListener {
                   Log.i(LOG_TAG, "onRefresh called from SwipeRefreshLayout")

                   // This method performs the actual data-refresh operation and calls
                   // setRefreshing(false) when it finishes.
                   myUpdateOperation()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Sets up a SwipeRefreshLayout.OnRefreshListener that is invoked when
               // the user performs a swipe-to-refresh gesture.

               mySwipeRefreshLayout.setOnRefreshListener(() -> {
                   Log.i(LOG_TAG, "onRefresh called from SwipeRefreshLayout");

                   // This method performs the actual data-refresh operation and calls
                   // setRefreshing(false) when it finishes.
                   myUpdateOperation();
                 }
               );

   .. rubric:: Respond to the refresh action
      :name: RespondAction

   If the user requests a refresh by using the action bar, the system calls the
   `onOptionsItemSelected() <#androidx.fragment.app.Fragment>`__
   method. Your app responds to this call by displaying the progress indicator
   and refreshing the app's data.

   To respond to the refresh action, override ``onOptionsItemSelected()``. In
   your override method, trigger the ``SwipeRefreshLayout`` progress indicator
   by calling ``setRefreshing()`` with the value ``true``, then perform the
   update operation. Perform the actual update in a separate method, so the same
   method can be called whether the user triggers the update with a swipe or
   uses the action bar. When the update finishes, call ``setRefreshing(false)``
   to remove the refresh progress indicator.

   The following code shows how to respond to the request action:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Listen for option item selections to receive a notification when the user
               // requests a refresh by selecting the refresh action bar item.

               override fun onOptionsItemSelected(item: MenuItem): Boolean {
                   when (item.itemId) {

                       // Check whether the user triggers a refresh:
                       R.id.menu_refresh -> {
                           Log.i(LOG_TAG, "Refresh menu item selected")

                           // Signal SwipeRefreshLayout to start the progress indicator.
                           mySwipeRefreshLayout.isRefreshing = true

                           // Start the refresh background task. This method calls
                           // setRefreshing(false) when it finishes.
                           myUpdateOperation()

                           return true
                       }
                   }

                   // User doesn't trigger a refresh. Let the superclass handle this action.
                   return super.onOptionsItemSelected(item)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Listen for option item selections to receive a notification when the user
               // requests a refresh by selecting the refresh action bar item.

               @Override
               public boolean onOptionsItemSelected(MenuItem item) {
                   switch (item.getItemId()) {

                       // Check whether the user triggers a refresh:
                       case R.id.menu_refresh:
                           Log.i(LOG_TAG, "Refresh menu item selected");

                           // Signal SwipeRefreshLayout to start the progress indicator.
                           mySwipeRefreshLayout.setRefreshing(true);

                           // Start the refresh background task. This method calls
                           // setRefreshing(false) when it finishes.
                           myUpdateOperation();

                           return true;
                   }

                   // User doesn't trigger a refresh. Let the superclass handle this action.
                   return super.onOptionsItemSelected(item);
               }


Last updated 2024-02-22 UTC.


/About keyboards
================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input?hl=en

.. container:: devsite-article-body

   The Android system shows an on-screen keyboard—known as a *soft input
   method*—when a text field in your UI receives focus. To provide the best user
   experience, you can specify characteristics about the type of input you
   expect, such as a phone number or email address, and how the input method
   must behave, such as performing autocorrect for spelling mistakes.

   In addition to the on-screen input methods, Android supports hardware
   keyboards, so it's also important to optimize your app to support attached
   keyboards.

   These topics and more are discussed in the following documentation.

   .. rubric:: Lessons
      :name: lessons

   `Specify the input method type <#>`__
      Learn how to show certain soft input methods, such as those designed for
      phone numbers, web addresses, or other formats. Also, learn how to specify
      characteristics such as spelling suggestion behavior and action buttons
      such as **Done** or **Next**.
   `Handle input method visibility <#>`__
      Learn how to specify when to show the soft input method and how your
      layout must adjust to the reduced screen space.
   `Support keyboard navigation <#>`__
      Learn how to verify that users can navigate your app using a keyboard and
      how to make any necessary changes to the navigation order.
   `Handle keyboard actions <#>`__
      Learn how to respond directly to keyboard input for user actions.


Last updated 2024-02-22 UTC.


/Specify the input method type
==============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/style?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to use touch and input in Compose.

      `Text KeyboardOptions → <https://developer.android.google.cn/jetpack/compose/text#keyboard-options>`__

      |image-android-compose-ui-logo|

   Every text field expects a certain type of text input, such as an email
   address, phone number, or plain text. You must specify the input type for
   each text field in your app so the system displays the appropriate soft input
   method, such as an on-screen keyboard.

   Beyond the type of buttons available with an input method, you can specify
   behaviors such as whether the input method provides spelling suggestions,
   capitalizes new sentences, and replaces the carriage return button with an
   action button such as **Done** or **Next**. This page shows how to specify
   these characteristics.

   .. rubric:: Specify the keyboard type
      :name: Type

   Always declare the input method for your text fields by adding the
   `android:inputType <#android.widget.TextView>`__
   attribute to the `<EditText> <#android.widget.EditText>`__
   element.

   .. figure:: https://developer.android.google.cn/static/images/ui/edittext-phone.png
      :alt: phone input

      **Figure 1.** The ``phone`` input type.

   For example, if you want an input method for entering a phone number, use the
   ``"phone"`` value:

   .. code:: prettyprint

      <EditText
          android:id="@+id/phone"
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:hint="@string/phone_hint"
          android:inputType="phone" />

   .. figure:: https://developer.android.google.cn/static/images/training/input/ime_password.png
      :alt: textPassword input type

      **Figure 2.** The ``textPassword`` input type.

   If the text field is for a password, use the ``"textPassword"`` value so the
   text field conceals the user's input:

   .. code:: prettyprint

      <EditText
          android:id="@+id/password"
          android:hint="@string/password_hint"
          android:inputType="textPassword"
          ... />

   There are several possible values documented with the ``android:inputType``
   attribute, and you can combine some of the values to specify the input method
   appearance and additional behaviors.

   .. rubric:: Enable spelling suggestions and other behaviors
      :name: Spelling

   .. figure:: https://developer.android.google.cn/static/images/training/input/ime_autocorrect.png
      :alt: autocorrect

      **Figure 3.** Adding ``textAutoCorrect`` provides auto-correction for
      misspellings.

   The ``android:inputType`` attribute lets you specify various behaviors for
   the input method. Most importantly, if your text field is intended for basic
   text input—such as for a text message—enable auto spelling correction with
   the ``"textAutoCorrect"`` value.

   You can combine different behaviors and input method styles with the
   ``android:inputType`` attribute. For example, here's how to create a text
   field that capitalizes the first word of a sentence and also auto-corrects
   misspellings:

   .. code:: prettyprint

      <EditText
          android:id="@+id/message"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:inputType=
              "textCapSentences|textAutoCorrect"
          ... />

   .. rubric:: Specify the input method action
      :name: Action

   Most soft input methods provide a user action button in the bottom corner
   that's appropriate for the current text field. By default, the system uses
   this button for either a **Next** or **Done** action unless your text field
   supports multi-line text—such as with
   ``android:inputType="textMultiLine"``—in which case the action button is a
   carriage return. However, you can specify other actions that might be more
   appropriate for your text field, such as **Send** or **Go**.

   To specify the keyboard action button, use the
   `android:imeOptions <#android.widget.TextView>`__
   attribute with an action value such as ``"actionSend"`` or
   ``"actionSearch"``. For example:

   .. figure:: https://developer.android.google.cn/static/images/ui/edittext-actionsend.png
      :alt: send button

      **Figure 4.** The **Send** button appears when you declare
      ``android:imeOptions="actionSend"``.

   .. code:: prettyprint

      <EditText
          android:id="@+id/search"
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:hint="@string/search_hint"
          android:inputType="text"
          android:imeOptions="actionSend" />

   You can then listen for presses on the action button by defining a
   `TextView.OnEditorActionListener <#android.widget.TextView.OnEditorActionListener>`__
   for the `EditText <#android.widget.EditText>`__ element. In
   your listener, respond to the appropriate IME action ID defined in the
   `EditorInfo <#android.view.inputmethod.EditorInfo>`__ class,
   such as
   `IME_ACTION_SEND <#android.view.inputmethod.EditorInfo>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               findViewById<EditText>(R.id.search).setOnEditorActionListener { v, actionId, event ->
                   return@setOnEditorActionListener when (actionId) {
                       EditorInfo.IME_ACTION_SEND -> {
                           sendMessage()
                           true
                       }
                       else -> false
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               EditText editText = (EditText) findViewById(R.id.search);
               editText.setOnEditorActionListener(new OnEditorActionListener() {
                   @Override
                   public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
                       boolean handled = false;
                       if (actionId == EditorInfo.IME_ACTION_SEND) {
                           sendMessage();
                           handled = true;
                       }
                       return handled;
                   }
               });

   .. rubric:: Provide auto-complete suggestions
      :name: AutoComplete

   If you want to provide suggestions to users as they type, you can use a
   subclass of ``EditText`` called
   `AutoCompleteTextView <#android.widget.AutoCompleteTextView>`__.
   To implement auto-complete, you must specify an
   `Adapter <#android.widget.Adapter>`__ that provides the text
   suggestions. There are several adapters available, depending on where the
   data is coming from, such as from a database or an array.

   .. figure:: https://developer.android.google.cn/static/images/ui/edittext-autocomplete.png
      :alt: text suggestions

      **Figure 5.** Example of ``AutoCompleteTextView`` with text suggestions.

   The following procedure describes how to set up an ``AutoCompleteTextView``
   that provides suggestions from an array using
   `ArrayAdapter <#android.widget.ArrayAdapter>`__:

   #. Add the ``AutoCompleteTextView`` to your layout. Here's a layout with only
      the text field:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <AutoCompleteTextView xmlns:android="http://schemas.android.com/apk/res/android"
             android:id="@+id/autocomplete_country"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content" />

   #. Define the array that contains all text suggestions. For example, here's
      an array of country names:

      .. code:: prettyprint

         <?xml version="1.0" encoding="utf-8"?>
         <resources>
             <string-array name="countries_array">
                 <item>Afghanistan</item>
                 <item>Albania</item>
                 <item>Algeria</item>
                 <item>American Samoa</item>
                 <item>Andorra</item>
                 <item>Angola</item>
                 <item>Anguilla</item>
                 <item>Antarctica</item>
                 ...
             </string-array>
         </resources>

   #. In your `Activity <#android.app.Activity>`__ or
      `Fragment <#android.app.Fragment>`__, use the following code
      to specify the adapter that supplies the suggestions:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Get a reference to the AutoCompleteTextView in the layout.
                  val textView = findViewById(R.id.autocomplete_country) as AutoCompleteTextView
                  // Get the string array.
                  val countries: Array<out String> = resources.getStringArray(R.array.countries_array)
                  // Create the adapter and set it to the AutoCompleteTextView.
                  ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, countries).also { adapter ->
                      textView.setAdapter(adapter)
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Get a reference to the AutoCompleteTextView in the layout.
                  AutoCompleteTextView textView = (AutoCompleteTextView) findViewById(R.id.autocomplete_country);
                  // Get the string array.
                  String[] countries = getResources().getStringArray(R.array.countries_array);
                  // Create the adapter and set it to the AutoCompleteTextView.
                  ArrayAdapter<String> adapter =
                          new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, countries);
                  textView.setAdapter(adapter);

      In the preceding example, a new ``ArrayAdapter`` is initialized to bind
      each item in the ``countries_array`` string array to a
      `TextView <#android.widget.TextView>`__ that exists in the
      ``simple_list_item_1`` layout. This is a layout provided by Android that
      provides a standard appearance for text in a list.

   #. Assign the adapter to the ``AutoCompleteTextView`` by calling
      `setAdapter() <#android.widget.AutoCompleteTextView>`__.


Last updated 2024-04-15 UTC.



/Handle input method visibility
===============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/visibility?hl=en

.. container:: devsite-article-body

   When input focus moves in or out of an editable text field, Android shows or
   hides the input —such as the on-screen keyboard—as appropriate. The system
   also decides how your UI and the text field appear above the input method.
   For example, when the vertical space on the screen is constrained, the text
   field might fill all space above the input method.

   For most apps, these default behaviors are all that's needed. In some cases,
   though, you might want more control over the visibility of the input method
   and how it impacts the layout. This lesson explains how to control and
   respond to the input method visibility.

   **Note:**\  This page refers to the phrase *soft keyboard* throughout, which
   represents an on-screen keyboard and is the most common type of soft input
   method. Android supports other types of soft input methods, including image
   input and ink drawing.

   .. rubric:: Show the soft keyboard when the activity starts
      :name: ShowOnStart

   Although Android gives focus to the first text field in your layout when the
   activity starts, it doesn't show the soft keyboard. This behavior is
   appropriate because entering text might not be the primary task in the
   activity. However, if entering text is indeed the primary task, such as in a
   login screen, then you probably want the soft keyboard to appear by default.

   To show the input method when your activity starts, add the
   `android:windowSoftInputMode <#wsoft>`__
   attribute to the ``<activity>`` element with the ``"stateVisible"`` value.
   For example:

   .. code:: prettyprint

      <application ... >
          <activity
              android:windowSoftInputMode="stateVisible" ... >
              ...
          </activity>
         ...
      </application>

   **Note:**\  If the user's device has an attached hardware keyboard, the soft
   keyboard does not appear.

   .. rubric:: Specify how your UI should respond
      :name: Respond

   When the soft keyboard appears on the screen, it reduces the amount of space
   available for your app's UI. The system decides how to adjust the visible
   portion of your UI, but it might not get it right. To ensure the best
   behavior for your app, specify how you want the system to display your UI in
   the remaining space.

   To declare your preferred treatment in an activity, use the
   ``android:windowSoftInputMode`` attribute in your manifest's ``<activity>``
   element with one of the "adjust" values.

   For example, to ensure that the system resizes your layout to the available
   space—which keeps all of your layout content accessible, even if it requires
   scrolling—use ``"adjustResize"``:

   .. code:: prettyprint

      <application ... >
         <activity
             android:windowSoftInputMode="adjustResize" ... >
             ...
         </activity>
         ...
      </application>

   You can combine the adjustment specification with the `initial soft keyboard visibility <#ShowOnStart>`__ specification from the preceding section:

   .. code:: prettyprint

      <activity
          android:windowSoftInputMode="stateVisible|adjustResize" ... >
          ...
      </activity>

   Specifying ``"adjustResize"`` is important if your UI includes controls that
   the user might need to access immediately after or while performing text
   input. For example, if you use a relative layout to place a button bar at the
   bottom of the screen, using ``"adjustResize"`` resizes the layout so the
   button bar appears above the soft keyboard.

   .. rubric:: Show the soft keyboard on demand
      :name: ShowOnDemand

   If there is a method in your activity's lifecycle where you want to ensure
   the input method is visible, you can use the
   `InputMethodManager <#android.view.inputmethod.InputMethodManager>`__
   to show it.

   For example, the following method takes a
   `View <#android.view.View>`__ in which the user is expected to
   type something, calls
   `requestFocus() <#android.view.View>`__ to give
   it focus, then calls
   `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__
   to open the input method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               fun showSoftKeyboard(view: View) {
                  if (view.requestFocus()) {
                      val imm = getSystemService(InputMethodManager::class.java)
                      imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT)
                  }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void showSoftKeyboard(View view) {
                  if (view.requestFocus()) {
                      InputMethodManager imm = getSystemService(InputMethodManager.class);
                      imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);
                  }
               }

   **Note:**\  Once the soft keyboard is visible, don't programmatically hide
   it. The system hides the input method when the user finishes the task in the
   text field. Alternatively, the user can hide it with a system control, such
   as with the Back button.
   **Caution:**\  Don't use the
   `SHOW_FORCED <#android.view.inputmethod.InputMethodManager>`__
   flag in
   `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__
   to request the soft keyboard. Otherwise, the software keyboard can remain
   open even after the app has been closed.

   .. rubric:: Show the soft keyboard reliably
      :name: ShowReliably

   There are certain situations, such as when an activity is starting, in which
   using
   `InputMethodManager.showSoftInput() <#android.view.inputmethod.InputMethodManager>`__
   to display the soft keyboard may result in the software keyboard not being
   visible to the user.

   The visibility of the soft keyboard when using
   `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__
   is reliant on the following conditions:

   -  The view must already be connected to the software keyboard. (This, in
      turn, requires the `window to be focused <#android.view.View>`__
      and the editor view to request the view focus with
      `View.requestFocus() <#android.view.View>`__).

   -  The visibility can also be affected by the ``android:windowSoftInputMode``
      attribute and flags used by
      `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__.

   In certain use cases, such as when an activity is starting, some of these
   required conditions aren't met. The system doesn't consider the view as
   connected to the software keyboard, ignores the
   `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__
   call, and the soft keyboard isn't visible to the user.

   To make sure the software keyboard is reliably shown, you can use the
   following alternatives:

   -  **(Recommended) Use**
      `WindowInsetsControllerCompat <#androidx.core.view.WindowInsetsControllerCompat>`__.
      This object displays the soft keyboard during
      `Activity.onCreate() <#android.app.Activity>`__
      as shown in the following code snippet. The call is guaranteed to be
      scheduled after the window is focused.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               editText.requestFocus()
               WindowCompat.getInsetsController(window, editText)!!.show(WindowInsetsCompat.Type.ime())

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               editText.requestFocus();
               WindowCompat.getInsetsController(getWindow(), editText).show(WindowInsetsCompat.Type.ime());

   -  **Post a runnable.** This ensures that your app waits until receiving the
      window focus event from
      `View.onWindowFocusChanged() <#android.view.View>`__
      before calling
      `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyEditText : EditText() {
                 ...
                 override fun onWindowFocusChanged(hasWindowFocus: Boolean) {
                   if (hasWindowFocus) {
                     requestFocus()
                     post {
                       val imm: InputMethodManager = getSystemService(InputMethodManager::class.java)
                       imm.showSoftInput(this, 0)
                     }
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyEditText extends EditText {
                 ...
                 @Override
                 public void onWindowFocusChanged(boolean hasWindowFocus) {
                   if (hasWindowFocus) {
                     requestFocus();
                     post(() -> {
                       InputMethodManager imm = getSystemService(InputMethodManager.class);
                       imm.showSoftInput(this, 0);
                     });
                   }
                 }
               }

   .. rubric:: Handle runtime visibility flags carefully
      :name: showHideFlags

   When toggling soft keyboard visibility at runtime, take care not to pass
   certain flag values into these methods. For example, if the application
   expects the soft keyboard shows up when calling
   ``View.getWindowInsetsController().show(ime())`` in ``Activity.onCreate()``
   during the activity starts, the application developers should be careful to
   not set
   `SOFT_INPUT_STATE_HIDDEN <#android.view.WindowManager.LayoutParams>`__
   or
   `SOFT_INPUT_STATE_ALWAYS_HIDDEN <#android.view.WindowManager.LayoutParams>`__
   flags during the initial launch in case the soft keyboard is hidden
   unexpectedly.

   .. rubric:: System usually hides the soft keyboard automatically
      :name: showAutomatically

   In most situations, the system handles hiding the soft keyboard. This can be
   any of the following cases:

   -  The user finishes the task in the text field.
   -  The user presses the back key or swipe gestures with the back navigation.
   -  The user navigate to another app, and that other app has set
      `SOFT_INPUT_STATE_HIDDEN <#android.view.WindowManager.LayoutParams>`__
      or
      `SOFT_INPUT_STATE_ALWAYS_HIDDEN <#android.view.WindowManager.LayoutParams>`__
      flags when the view gains the focus.

   **Note:**\  Focusing a view other than a text field doesn't dismiss the soft
   keyboard on its own.

   .. rubric:: Hide the soft keyboard manually based on previous system behavior
      :name: hideManually

   Your app must hide the soft keyboard manually in some situations—for example,
   when the text field loses focus in
   `View.OnFocusChangeListener.onFocusChange <#android.view.View.OnFocusChangeListener>`__.
   Use this technique judiciously ; closing the soft keyboard unexpectedly
   impairs the user experience.

   If your app manually hides the soft keyboard, you need to know whether the
   soft keyboard was shown *explicitly* or *implicitly*:

   -  The soft keyboard is considered to have been *explicitly* shown after a
      call to
      `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__.

   -  Conversely, the soft keyboard is considered to have been implicitly shown
      in either of the following conditions:

      -  The system showed the soft keyboard while applying the
         ``android:windowSoftInputMode``.
      -  Your app passed
         `SHOW_IMPLICIT <#android.view.inputmethod.InputMethodManager>`__
         to
         `showSoftInput() <#android.view.inputmethod.InputMethodManager>`__.

   Normally,
   `hideSoftInputFromWindow() <#android.view.inputmethod.InputMethodManager>`__
   hides the soft keyboard regardless of how it was requested, but with
   `HIDE_IMPLICIT_ONLY <#android.view.inputmethod.InputMethodManager>`__
   it can be limited to only dismissing an implicitly requested soft keyboard.

   .. rubric:: Show a dialog or overlay view on top of the soft keyboard
      :name: showOnTopIme

   In some situations, the editor activity might need to create a non-editable
   dialog or overlay window on top of the soft keyboard.

   Your app has a few options, which the following sections describe.

   In summary, make sure to correctly handle the window flags of the soft
   keyboard targeting the window such that it satisfies the following
   expectations regarding vertical (z-layer) ordering:

   -  No flags (normal case): Behind the soft keyboard layer, and can receive
      text.
   -  `FLAG_NOT_FOCUSABLE <#android.view.WindowManager.LayoutParams>`__
      : On top of the soft keyboard layer, but can't receive text.
   -  `FLAG_ALT_FOCUSABLE_IM <#android.view.WindowManager.LayoutParams>`__
      : On top of the soft keyboard layer, can be focused but isn't connected to
      the soft keyboard. Also blocks all views underneath it from connecting to
      the soft keyboard. This is useful for showing an app dialog that doesn't
      use text input above the soft keyboard layer.
   -  `FLAG_NOT_FOCUSABLE <#android.view.WindowManager.LayoutParams>`__
      and
      `FLAG_ALT_FOCUSABLE_IM <#android.view.WindowManager.LayoutParams>`__
      : Behind the soft keyboard layer, but can't receive text.
   -  `FLAG_NOT_FOCUSABLE <#android.view.WindowManager.LayoutParams>`__
      and
      `FLAG_NOT_TOUCH_MODAL <#android.view.WindowManager.LayoutParams>`__
      : On top of the soft keyboard, and allow touch events to go "through" the
      window onto the soft keyboard.

   .. rubric:: Create a dialog
      :name: showOnTopIme_dialog

   Use the
   `FLAG_ALT_FOCUSABLE_IM <#android.view.WindowManager.LayoutParams>`__
   dialog window flag to keep the dialog on top of the soft keyboard, and to
   prevent the soft keyboard from gaining focus:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val content = TextView(this)
               content.text = "Non-editable dialog on top of soft keyboard"
               content.gravity = Gravity.CENTER
               val builder = AlertDialog.Builder(this)
                 .setTitle("Soft keyboard layering demo")
                 .setView(content)
               mDialog = builder.create()
               mDialog!!.window!!
                 .addFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM)
               mDialog!!.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TextView content = new TextView(this);
               content.setText("Non-editable dialog on top of soft keyboard");
               content.setGravity(Gravity.CENTER);
               final AlertDialog.Builder builder = new AlertDialog.Builder(this)
                   .setTitle("Soft keyboard layering demo")
                   .setView(content);
               mDialog = builder.create();
               mDialog.getWindow().addFlags(FLAG_ALT_FOCUSABLE_IM);
               mDialog.show();

   .. rubric:: Create an overlay view
      :name: showOnTopIme_view

   Create an overlay view specifying
   `TYPE_APPLICATION_OVERLAY <#android.view.WindowManager.LayoutParams>`__
   window type and
   `FLAG_ALT_FOCUSABLE_IM <#android.view.WindowManager.LayoutParams>`__
   window flag by the soft keyboard targeted activity.

   **Note:**\  This requires the user to grant the
   `SYSTEM_ALERT_WINDOW <#android.Manifest.permission>`__
   `special permission <#>`__ to your
   app.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val params = WindowManager.LayoutParams(
                 width,  /* Overlay window width */
                 height,  /* Overlay window height */
                 WindowManager.LayoutParams.TYPE_APPLICATION, /* Overlay window type */
                 WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM /* No need to allow for text input on top of the soft keyboard */
                   or WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,  /* Allow touch event send to soft keyboard behind the overlay */
                 PixelFormat.TRANSLUCENT
               )
               params.title = "Overlay window"
               mOverlayView!!.layoutParams = params
               windowManager.addView(mOverlayView, params)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WindowManager.LayoutParams params = new WindowManager.LayoutParams(
                   width, /* Overlay window width */
                   height, /* Overlay window height */
                   TYPE_APPLICATION, /* Overlay window type */
                   FLAG_ALT_FOCUSABLE_IM /* No need to allow for text input on top of the soft keyboard */
                       | FLAG_NOT_TOUCH_MODAL, /* Allow touch event send to soft keyboard behind the overlay */
                   PixelFormat.TRANSLUCENT);
               params.setTitle("Overlay window");
               mOverlayView.setLayoutParams(params);
               getWindowManager().addView(mOverlayView, params);

   .. rubric:: Show a dialog or view underneath the soft keyboard
      :name: showBehindIme

   Your app might need to create a dialog or a window that has the following
   properties:

   -  Appears underneath the soft keyboard requested by an editor activity such
      that it's not affected by text input.
   -  Remains aware of changes to the soft keyboard's inset size changes to
      adjust the dialog or window's layout.

   In this case, your app has several options. The following sections describe
   these options.

   .. rubric:: Create a dialog
      :name: showBehindIme_dialog

   Create a dialog by setting both the
   `FLAG_NOT_FOCUSABLE <#android.view.WindowManager.LayoutParams>`__
   window flag and the
   `FLAG_ALT_FOCUSABLE_IM <#android.view.WindowManager.LayoutParams>`__
   window flag:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val content = TextView(this)
               content.text = "Non-editable dialog behind soft keyboard"
               content.gravity = Gravity.CENTER
               val builder = AlertDialog.Builder(this)
                 .setTitle("Soft keyboard layering demo")
                 .setView(content)
               mDialog = builder.create()
               mDialog!!.window!!
                 .addFlags(FLAG_NOT_FOCUSABLE or FLAG_ALT_FOCUSABLE_IM)
               mDialog!!.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               TextView content = new TextView(this);
               content.setText("Non-editable dialog behind soft keyboard");
               content.setGravity(Gravity.CENTER);
               final AlertDialog.Builder builder = new AlertDialog.Builder(this)
                   .setTitle("Soft keyboard layering demo")
                   .setView(content);

               mDialog = builder.create();
               mDialog.getWindow()
                   .addFlags(FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM);
               mDialog.show();

   .. rubric:: Create an overlay view
      :name: showBehindIme_view

   Create an overlay view by setting both the
   `FLAG_NOT_FOCUSABLE <#android.view.WindowManager.LayoutParams>`__
   window flag and the
   `FLAG_ALT_FOCUSABLE_IM <#android.view.WindowManager.LayoutParams>`__
   window flag:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val params = WindowManager.LayoutParams(
                 width,  /* Overlay window width */
                 height,  /* Overlay window height */
                 WindowManager.LayoutParams.TYPE_APPLICATION,  /* Overlay window type */
                 WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                     or WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
                 PixelFormat.TRANSLUCENT
               )
               params.title = "Overlay window"
               mOverlayView!!.layoutParams = params
               windowManager.addView(mOverlayView, params)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               WindowManager.LayoutParams params = new WindowManager.LayoutParams(
                   width, /* Overlay window width */
                   height, /* Overlay window height */
                   TYPE_APPLICATION, /* Overlay window type */
                   FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM,
                   PixelFormat.TRANSLUCENT);
               params.setTitle("Overlay window");
               mOverlayView.setLayoutParams(params);
               getWindowManager().addView(mOverlayView, params);


Last updated 2024-02-22 UTC.


/Support keyboard navigation
============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/navigation?hl=en

.. container:: devsite-article-body

   In addition to soft input methods—such as on-screen keyboards—Android
   supports physical keyboards attached to the device. A keyboard offers a
   convenient mode for text input and a way for users to navigate and interact
   with your app. Although most hand-held devices such as phones use touch as
   the primary mode of interaction, tablets and similar devices are popular, and
   many users like to attach keyboard accessories to them.

   As more Android-powered devices offer this kind of experience, it's important
   that you optimize your app to support interaction through a keyboard. This
   document describes how you can improve navigation with a keyboard.

   **Note:** Supporting directional navigation in your app is also an important
   part of helping ensure your app is
   `accessible <#>`__ to users who don't
   navigate using visual cues. Fully supporting directional navigation in your
   app can also help you automate `user interface testing <#>`__ with tools like
   `UiAutomator <#>`__.

   .. rubric:: Test your app
      :name: Test

   Users might already be able to navigate your app using a keyboard, because
   the Android system enables most of the necessary behaviors by default.

   All interactive widgets provided by the Android framework—such as
   `Button <#android.widget.Button>`__ and
   `EditText <#android.widget.EditText>`__—are focusable. This
   means users can navigate with control devices such as a D-pad or keyboard,
   and each widget glows or otherwise changes its appearance when it gains input
   focus.

   To test your app, perform the following procedure:

   #. Install your app on a device that offers a hardware keyboard.

      If you don't have a hardware device with a keyboard, connect a Bluetooth
      keyboard or a USB keyboard.

      You can also use the Android emulator:

      #. In the AVD Manager, either click **New Device** or select an existing
         profile and click **Clone**.
      #. In the window that appears, ensure **Keyboard** and **DPad** are
         enabled.

   #. To test your app, use only the Tab key to navigate through your UI. Make
      sure each UI control gets focus as expected.

      Look for any instances in which the focus moves in an unexpected manner.

   #. Start again from the beginning of your app and navigate through your UI
      using direction controls like the arrow keys on the keyboard. From each
      focusable element in your UI, press Up, Down, Left, and Right.

      Look for any instances in which the focus moves in an unexpected manner.

   If you encounter any instances where navigating with the Tab key or direction
   controls doesn't do what you expect, specify where the focus must be in your
   layout, as discussed in the following sections.

   .. rubric:: Handle tab navigation
      :name: Tab

   When a user navigates your app using the keyboard Tab key, the system passes
   input focus between elements based on the order in which they appear in the
   layout. If you use a relative layout, for example, and the order of elements
   on the screen is different than the order in the file, then you might need to
   manually specify the focus order.

   For example, in the following layout, two buttons are aligned to the right
   side, and a text field is aligned to the left of the second button. To pass
   focus from the first button to the text field and then to the second button,
   the layout needs to explicitly define the focus order for each of the
   focusable elements with the
   `android:nextFocusForward <#android.view.View>`__
   attribute.

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout ...>
          <Button
              android:id="@+id/button1"
              android:nextFocusForward="@+id/editText1"
              app:layout_constraintRight_toRightOf="parent"
              app:layout_constraintTop_toTopOf="parent"
              ... />
          <Button
              android:id="@+id/button2"
              android:nextFocusForward="@+id/button1"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toBottomOf="@id/button1"
              ... />
          <EditText
              android:id="@id/editText1"
              android:nextFocusForward="@+id/button2"
              app:layout_constraintBottom_toBottomOf="@+id/button2"
              app:layout_constraintRight_toLeftOf="@id/button2
              ...  />
          ...
      </androidx.constraintlayout.widget.ConstraintLayout>

   Now, instead of the focus moving from ``button1`` to ``button2`` and then
   ``editText1``, it appropriately moves according to the appearance on the
   screen: from ``button1`` to ``editText1`` and then ``button2``.

   .. rubric:: Handle directional navigation
      :name: Direction

   Users can also navigate your app using the arrow keys on a keyboard, which
   behaves the same as when navigating with a D-pad or trackball. The system
   provides a "best guess" for which view to give focus to in a given direction
   based on the layout of the views on screen. However, sometimes the system
   guesses wrong.

   If the system doesn't pass focus to the appropriate view when navigating in a
   given direction, specify which view must receive focus with the following
   attributes:

   -  `android:nextFocusUp <#android.view.View>`__
   -  `android:nextFocusDown <#android.view.View>`__
   -  `android:nextFocusLeft <#android.view.View>`__
   -  `android:nextFocusRight <#android.view.View>`__

   Each attribute designates the next view to receive focus when the user
   navigates in that direction, as specified by the view ID. This is shown in
   the following example:

   .. code:: prettyprint

      <Button
          android:id="@+id/button1"
          android:nextFocusRight="@+id/button2"
          android:nextFocusDown="@+id/editText1"
          ... />
      <Button
          android:id="@id/button2"
          android:nextFocusLeft="@id/button1"
          android:nextFocusDown="@id/editText1"
          ... />
      <EditText
          android:id="@id/editText1"
          android:nextFocusUp="@id/button1"
          ...  />

   **Note:** Some Android views override the default navigation keys. For
   example, `EditText <#android.widget.EditText>`__ overrides the
   arrow keys to provide navigation within the inserted text.

   .. rubric:: Additional resources
      :name: additional-resources

   Refer to the following related resources:

   -  `Build accessible apps <#>`__


Last updated 2024-02-22 UTC.


/Handle keyboard actions
========================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/keyboard-input/commands?hl=en

.. container:: devsite-article-body

   When the user gives focus to an editable text view, such as an
   `EditText <#android.widget.EditText>`__ element, and the user
   has a hardware keyboard attached, all input is handled by the system.
   However, if you want to intercept or directly handle the keyboard input
   yourself, you can do so by implementing callback methods from the
   `KeyEvent.Callback <#android.view.KeyEvent.Callback>`__
   interface, such as
   `onKeyDown() <#android.view.KeyEvent.Callback>`__
   and
   `onKeyMultiple() <#android.view.KeyEvent.Callback>`__.

   Both the `Activity <#android.app.Activity>`__ and
   `View <#android.view.View>`__ classes implement the
   ``KeyEvent.Callback`` interface, so you generally override the callback
   methods in your extension of these classes, as appropriate.

   **Note:** When handling keyboard events with the
   `KeyEvent <#android.view.KeyEvent>`__ class and related APIs,
   expect that the keyboard events are coming only from a hardware keyboard.
   Never rely on receiving key events for any key on a soft input method (an
   on-screen keyboard).

   .. rubric:: Handle single key events
      :name: SingleKey

   To handle an individual key press, implement
   `onKeyDown() <#android.app.Activity>`__
   or
   `onKeyUp() <#android.app.Activity>`__,
   as appropriate. Usually, you use ``onKeyUp()`` if you want to ensure that you
   receive only one event. If the user presses and holds a key, then
   ``onKeyDown()`` is called multiple times.

   For example, this implementation responds to some keyboard keys to control a
   game:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onKeyUp(keyCode: Int, event: KeyEvent): Boolean {
                   return when (keyCode) {
                       KeyEvent.KEYCODE_D -> {
                           moveShip(MOVE_LEFT)
                           true
                       }
                       KeyEvent.KEYCODE_F -> {
                           moveShip(MOVE_RIGHT)
                           true
                       }
                       KeyEvent.KEYCODE_J -> {
                           fireMachineGun()
                           true
                       }
                       KeyEvent.KEYCODE_K -> {
                           fireMissile()
                           true
                       }
                       else -> super.onKeyUp(keyCode, event)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onKeyUp(int keyCode, KeyEvent event) {
                   switch (keyCode) {
                       case KeyEvent.KEYCODE_D:
                           moveShip(MOVE_LEFT);
                           return true;
                       case KeyEvent.KEYCODE_F:
                           moveShip(MOVE_RIGHT);
                           return true;
                       case KeyEvent.KEYCODE_J:
                           fireMachineGun();
                           return true;
                       case KeyEvent.KEYCODE_K:
                           fireMissile();
                           return true;
                       default:
                           return super.onKeyUp(keyCode, event);
                   }
               }

   .. rubric:: Handle modifier keys
      :name: ModifierKey

   To respond to modifier key events, such as when a key is combined with Shift
   or Control, you can query the ``KeyEvent`` that is passed to the callback
   method. Several methods provide information about modifier keys, such as
   `getModifiers() <#android.view.KeyEvent>`__ and
   `getMetaState() <#android.view.KeyEvent>`__.
   However, the simplest solution is to check whether the exact modifier key you
   care about is being pressed with methods such as
   `isShiftPressed() <#android.view.KeyEvent>`__
   and
   `isCtrlPressed() <#android.view.KeyEvent>`__.

   For example, here's the ``onKeyUp()`` implementation again, with extra
   handling for when the Shift key is held down with one of the keys:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onKeyUp(keyCode: Int, event: KeyEvent): Boolean {
                   return when (keyCode) {
                       ...
                       KeyEvent.KEYCODE_J -> {
                           if (event.isShiftPressed) {
                               fireLaser()
                           } else {
                               fireMachineGun()
                           }
                           true
                       }
                       KeyEvent.KEYCODE_K -> {
                           if (event.isShiftPressed) {
                               fireSeekingMissle()
                           } else {
                               fireMissile()
                           }
                           true
                       }
                       else -> super.onKeyUp(keyCode, event)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onKeyUp(int keyCode, KeyEvent event) {
                   switch (keyCode) {
                       ...
                       case KeyEvent.KEYCODE_J:
                           if (event.isShiftPressed()) {
                               fireLaser();
                           } else {
                               fireMachineGun();
                           }
                           return true;
                       case KeyEvent.KEYCODE_K:
                           if (event.isShiftPressed()) {
                               fireSeekingMissle();
                           } else {
                               fireMissile();
                           }
                           return true;
                       default:
                           return super.onKeyUp(keyCode, event);
                   }
               }

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Keyboard Shortcut Helper <#>`__
      : a system screen that enables users to search the keyboard shortcuts your
      app offers.


Last updated 2024-04-18 UTC.


/Handle stylus input
====================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/stylus?hl=en

.. container:: devsite-article-body

   .. container::

      .. figure::
         https://developer.android.google.cn/static/images/jetpack/compose/touchinput/stylus/hero.png

         .. rubric:: Stylus
            :name: stylus
            :class: hide-from-toc no-link

            Many phones and large screen devices include stylus
            support, and users expect seamless stylus experiences
            across all their apps. Your app can support stylus to
            provide improved navigation, drawing and handwriting
            capabilities, and advanced brushes with tilt and
            pressure detection.

   .. container::

      Visit our large screen gallery for design and UX
      guidance for creativity and productivity apps.

   .. container::

      .. container:: devsite-landing-row-header-text

         .. rubric:: Detecting stylus input
            :name: detecting-stylus-input

         .. container:: devsite-landing-row-group

            .. container:: Guide

               .. rubric:: `Get stylus data from MotionEvents <https://developer.android.google.cn/guide/topics/large-screens/input-compatibility-large-screens#stylus>`__
                  :name: get-stylus-data-from-motionevents
                  :class: hide-from-toc no-link

                  You can use motion events to detect whether the input
                  type is a stylus. The MotionEvent object contains data
                  on the tool type used, like a finger, stylus, or eraser.

            .. container:: Guide

               .. rubric:: `Check for historical points <https://developer.android.google.cn/reference/android/view/MotionEvent#batching>`__
                  :name: check-for-historical-points
                  :class: hide-from-toc no-link

                  A stylus pen can report events at much higher
                  frequencies than the display. For drawing apps, use the
                  getHistorical API to check for events in the recent
                  past.

   .. container::

         .. rubric:: Set your experience apart with advanced libraries
            :name: set-your-experience-apart-with-advanced-libraries

         .. container:: devsite-landing-row-description

            Use the advanced stylus libraries to reduce latency, detect
            pressure and tilt, ignore accidental marks, and recognize
            handwriting.

   .. container::

         .. rubric:: Low latency libraries
            :name: low-latency-libraries

         .. container:: devsite-landing-row-group

            .. container::

               |image-reduce|

               .. rubric:: `Reduce latency in the graphics rendering pipeline <https://developer.android.google.cn/guide/topics/large-screens/advanced-stylus#low_latency_graphics>`__
                  :name: reduce-latency-in-the-graphics-rendering-pipeline
                  :class: hide-from-toc no-link

                  Improve latency by reducing the processing time between
                  stylus input and screen rendering.

            .. container::

               |image-lightning|

               .. rubric:: `Reduce perceived latency <https://developer.android.google.cn/guide/topics/large-screens/advanced-stylus#motion_prediction>`__
                  :name: reduce-perceived-latency
                  :class: hide-from-toc no-link

                  Further reduce latency using prediction of future
                  MotionEvents, made easy with our Motion Prediction
                  Jetpack library.

   .. container::

         .. rubric:: Advanced libraries
            :name: advanced-libraries

         .. container:: devsite-landing-row-group

            .. container::

               |image-pencils|

               .. rubric:: `Build advanced brushes with pressure and tilt <https://developer.android.google.cn/guide/topics/large-screens/advanced-stylus#pressure>`__
                  :name: build-advanced-brushes-with-pressure-and-tilt
                  :class: hide-from-toc no-link

                  Use information about the pressure and tilt of the
                  stylus to render the stroke from the MotionEvent.

            .. container::

               |image-prohibited|

               .. rubric:: `Reject accidental stray marks <https://developer.android.google.cn/guide/topics/large-screens/advanced-stylus#palm_rejection_navigation_and_unwanted_inputs>`__
                  :name: reject-accidental-stray-marks
                  :class: hide-from-toc no-link

                  Avoid stray marks when the user accidentally touches the
                  screen while drawing or writing with a stylus.

            .. container::

               |image-engagement-2|

               .. rubric:: `Recognize handwriting <https://developers.google.cn/ml-kit/vision/digital-ink-recognition>`__
                  :name: recognize-handwriting
                  :class: hide-from-toc no-link

                  Recognize handwritten text and classify gestures on a
                  digital surface with ML Kit Digital Ink Recognition.

            .. container::

               |image-hardware|

               .. rubric:: `Build immersive experiences <https://developer.android.google.cn/guide/topics/large-screens/advanced-stylus#fullscreen_and_navigation_gestures>`__
                  :name: build-immersive-experiences
                  :class: hide-from-toc no-link

                  Empower users to work in full screen and use gesture
                  navigation without stray marks.

   .. container::

         |image-spanner|

      .. container:: devsite-landing-row-header-text

         .. rubric:: Build for all types of input
            :name: build-for-all-types-of-input

         .. container:: devsite-landing-row-description

            Empower your users to navigate your app with their stylus,
            just as they would with a keyboard or trackpad. Stylus
            optimizations also improve the experience for other types of
            input, like keyboard and mouse.

         .. container:: devsite-landing-row-group

            .. container:: Guide

               .. rubric:: `Show focus when hovering <https://developer.android.google.cn/guide/topics/large-screens/advanced-stylus#hover>`__
                  :name: show-focus-when-hovering
                  :class: hide-from-toc no-link

                  Help users easily identify where the focus is on the
                  screen for precise input. For example, add a focus
                  indicator like a thicker border when a user hovers over it.

            .. container:: Guide

               .. rubric:: `Customize your cursors <https://developer.android.google.cn/about/versions/nougat/android-7.0#custom_pointer_api>`__
                  :name: customize-your-cursors
                  :class: hide-from-toc no-link

                  While hovering, update the cursor to show a preview of
                  the brush type or current action.

            .. container:: Guide

               .. rubric:: `Drag and drop content <https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop>`__
                  :name: drag-and-drop-content
                  :class: hide-from-toc no-link

                  Drag and drop images, text, and other content so users
                  can quickly share from your app to another app.

            .. container:: Guide

               .. rubric:: `Make text selectable <https://developer.android.google.cn/jetpack/compose/text#select-text>`__
                  :name: make-text-selectable
                  :class: hide-from-toc no-link

                  Make the text in your app selectable so that users can
                  quickly select text and share with other apps with their stylus.

   .. container::

         .. rubric:: Other resources
            :name: other-resources

         .. container:: devsite-landing-row-group

            |image-ls-gallery|

               Gallery

            .. rubric:: `Large screen gallery <https://developer.android.google.cn/large-screens/gallery>`__
               :name: large-screen-gallery
               :class: hide-from-toc no-link

            |image-training-codelab|

               CodeLabs

            .. rubric:: `Android Training Codelab Advanced Stylus <https://developer.android.google.cn/codelabs/large-screens/advanced-stylus-support#0>`__
               :name: android-training-codelab-advanced-stylus
               :class: hide-from-toc no-link

            |image-low-latency|

               Guide

            .. rubric:: `Stylus Low Latency <https://medium.com/androiddevelopers/stylus-low-latency-d4a140a9c982>`__
               :name: stylus-low-latency
               :class: hide-from-toc no-link

            |image-concept-70|

               case study

            .. rubric:: `Concepts users spend 70% more time using the
               app on tablets than on phones <https://android-developers.googleblog.com/2023/03/concepts-users-spend-more-time-using-app-on-tablets-than-phones.html>`__
               :name: concepts-users-spend-70-more-time-using-the-app-on-tablets-than-on-phones
               :class: hide-from-toc no-link

            |image-stylus-youtube|

               YOUTUBE video

            .. rubric:: `Adding Stylus support to your Android app <https://www.youtube.com/watch?v=F8boaQsioH8>`__
               :name: adding-stylus-support-to-your-android-app
               :class: hide-from-toc no-link

            |image-optimizing-youtube|

               YOUTUBE video

            .. rubric:: `Optimizing keyboard and mouse support <https://www.youtube.com/watch?v=ucaSqyfpPas>`__
               :name: optimizing-keyboard-and-mouse-support
               :class: hide-from-toc no-link


Last updated 2024-04-15 UTC.

.. |image-reduce| image:: https://developer.android.google.cn/static/images/picto-icons/reduce.svg
.. |image-lightning| image:: https://developer.android.google.cn/static/images/picto-icons/lightning.svg
.. |image-pencils| image:: https://developer.android.google.cn/static/images/picto-icons/pencils.svg
.. |image-prohibited| image:: https://developer.android.google.cn/static/images/picto-icons/prohibited.svg
.. |image-engagement-2| image:: https://developer.android.google.cn/static/images/spot-icons/engagement-2.svg
.. |image-hardware| image:: https://developer.android.google.cn/static/images/picto-icons/hardware.svg
.. |image-spanner| image:: https://developer.android.google.cn/static/images/picto-icons/spanner.svg
   :class: devsite-landing-row-header-icon
.. |image-ls-gallery| image:: https://developer.android.google.cn/static/images/cards/distribute/engage/ls-gallery.png
   :target: https://developer.android.google.cn/large-screens/gallery
.. |image-training-codelab| image:: https://developer.android.google.cn/static/images/cards/distribute/engage/training-codelab.png
   :target: https://developer.android.google.cn/codelabs/large-screens/advanced-stylus-support#0
.. |image-low-latency| image:: https://developer.android.google.cn/static/images/cards/distribute/engage/low-latency.png
   :target: https://medium.com/androiddevelopers/stylus-low-latency-d4a140a9c982
.. |image-concept-70| image:: https://developer.android.google.cn/static/images/cards/distribute/engage/concept-70.png
   :target: https://android-developers.googleblog.com/2023/03/concepts-users-spend-more-time-using-app-on-tablets-than-phones.html
.. |image-stylus-youtube| image:: https://developer.android.google.cn/static/images/cards/distribute/engage/stylus-youtube.png
   :target: https://www.youtube.com/watch?v=F8boaQsioH8
.. |image-optimizing-youtube| image:: https://developer.android.google.cn/static/images/cards/distribute/engage/optimizing-youtube.png
   :target: https://www.youtube.com/watch?v=ucaSqyfpPas


/Use copy and paste across apps
===============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/copy-paste?hl=en

.. container:: devsite-article-body

   Android provides a powerful clipboard-based framework for copying and
   pasting. It supports simple and complex data types, including text strings,
   complex data structures, text and binary stream data, and application assets.
   Simple text data is stored directly in the clipboard, while complex data is
   stored as a reference that the pasting application resolves with a content
   provider. Copying and pasting works both within an application and between
   applications that implement the framework.

   Since part of the framework uses content providers, this document assumes
   some familiarity with the Android Content Provider API, which is described in
   `Content providers <#>`__.

   Users expect feedback when copying content to the clipboard, so in addition
   to the framework that powers copy and paste, Android shows a default UI to
   users when copying in Android 13 (API level 33) and higher. Due to this
   feature, there is a risk of duplicate notification. You can learn more about
   this edge case the in the `Avoid duplicate notifications <#duplicate-notifications>`__ section.

   .. figure:: https://developer.android.google.cn/static/images/about/versions/13/new-copy-paste-UI.gif
      name: android-13
      :alt: An animation showing Android 13 clipboard notification
      :width: 50.0%

      **Figure 1.** UI shown when content enters the clipboard in Android 13 and
      up.

   Manually provide feedback to users when copying in Android 12L (API level 32)
   and lower. See `recommendations for this <#Feedback>`__ in this document.

   .. rubric:: The clipboard framework
      :name: Clipboard

   When you use the clipboard framework, put data into a clip object, and then
   put the clip object on the system-wide clipboard. The clip object can take
   one of three forms:

   Text
      A text string. Put the string directly in the clip object, which you then
      put on the clipboard. To paste the string, get the clip object from the
      clipboard and copy the string into your application's storage.
   URI
      A `Uri <#android.net.Uri>`__ object representing any form of
      URI. This is primarily for copying complex data from a content provider.
      To copy data, put a ``Uri`` object into a clip object and put the clip
      object onto the clipboard. To paste the data, get the clip object, get the
      ``Uri`` object, resolve it to a data source, such as a content provider,
      and copy the data from the source into your application's storage.
   Intent
      An `Intent <#android.content.Intent>`__. This supports
      copying application shortcuts. To copy data, create an ``Intent``, put it
      in a clip object, and put the clip object on the clipboard. To paste the
      data, get the clip object and then copy the ``Intent`` object into your
      application's memory area.

   The clipboard holds only one clip object at a time. When an application puts
   a clip object on the clipboard, the previous clip object disappears.

   If you want to let users paste data into your application, you don't have to
   handle all types of data. You can examine the data on the clipboard before
   you give users the option to paste it. Besides having a certain data form,
   the clip object also contains metadata that tells you what MIME types are
   available. This metadata helps you decide whether your application can do
   something useful with the clipboard data. For example, if you have an
   application that primarily handles text, you might want to ignore clip
   objects that contain a URI or intent.

   You might also want to let users paste text regardless of the form of data on
   the clipboard. To do this, force the clipboard data into a text
   representation, and then paste this text. This is described in the `Coerce the clipboard to text <#CoerceToText>`__ section.

   .. rubric:: Clipboard classes
      :name: ClipboardClasses

   This section describes the classes used by the clipboard framework.

   .. rubric:: ClipboardManager
      :name: ClipboardManager

   The Android system clipboard is represented by the global
   `ClipboardManager <#android.content.ClipboardManager>`__ class.
   Don't instantiate this class directly. Instead, get a reference to it by
   invoking
   `getSystemService(CLIPBOARD_SERVICE) <#android.content.Context>`__.

   .. rubric:: ClipData, ClipData.Item, and ClipDescription
      :name: ClipClasses

   To add data to the clipboard, create a
   `ClipData <#android.content.ClipData>`__ object that contains a
   description of the data and the data itself. The clipboard holds one
   ``ClipData`` at a time. A ``ClipData`` contains a
   `ClipDescription <#android.content.ClipDescription>`__ object
   and one or more
   `ClipData.Item <#android.content.ClipData.Item>`__ objects.

   A ``ClipDescription`` object contains metadata about the clip. In particular,
   it contains an array of available MIME types for the clip's data.
   Additionally, on Android 12 (API level 31) and higher, the metadata includes
   information about whether the object contains `stylized text <#android.content.ClipDescription>`__ and about
   the `type of text in the object <#android.content.ClipDescription>`__.
   When you put a clip on the clipboard, this information is available to
   pasting applications, which can examine whether they can handle the clip
   data.

   A ``ClipData.Item`` object contains the text, URI, or intent data:

   Text
      A `CharSequence <#>`__.
   URI
      A ``Uri``. This usually contains a content provider URI, although any URI
      is allowed. The application that provides the data puts the URI on the
      clipboard. Applications that want to paste the data get the URI from the
      clipboard and use it to access the content provider or other data source
      and retrieve the data.
   Intent
      An ``Intent``. This data type lets you copy an application shortcut to the
      clipboard. Users can then paste the shortcut into their applications for
      later use.

   You can add more than one ``ClipData.Item`` object to a clip. This lets users
   copy and paste multiple selections as a single clip. For example, if you have
   a list widget that lets the user select more than one item at a time, you can
   copy all the items to the clipboard at once. To do this, create a separate
   ``ClipData.Item`` for each list item, and then add the ``ClipData.Item``
   objects to the ``ClipData`` object.

   .. rubric:: ClipData convenience methods
      :name: ClipDataMethods

   The ``ClipData`` class provides static convenience methods for creating a
   ``ClipData`` object with a single ``ClipData.Item`` object and a simple
   ``ClipDescription`` object:

   `newPlainText(label, text) <#android.content.ClipData>`__
      Returns a ``ClipData`` object whose single ``ClipData.Item`` object
      contains a text string. The ``ClipDescription`` object's label is set to
      ``label``. The single MIME type in ``ClipDescription`` is
      `MIMETYPE_TEXT_PLAIN <#android.content.ClipDescription>`__.

      Use ``newPlainText()`` to create a clip from a text string.

   `newUri(resolver, label, URI) <#android.content.ClipData>`__
      Returns a ``ClipData`` object whose single ``ClipData.Item`` object
      contains a URI. The ``ClipDescription`` object's label is set to
      ``label``. If the URI is a content URI—that is, if
      `Uri.getScheme() <#android.net.Uri>`__ returns
      ``content:``—the method uses the
      `ContentResolver <#android.content.ContentResolver>`__
      object provided in ``resolver`` to retrieve the available MIME types from
      the content provider. It then stores them in ``ClipDescription``. For a
      URI that isn't a ``content:`` URI, the method sets the MIME type to
      `MIMETYPE_TEXT_URILIST <#android.content.ClipDescription>`__.

      Use ``newUri()`` to create a clip from a URI—particularly a ``content:``
      URI.

   `newIntent(label, intent) <#android.content.ClipData>`__
      Returns a ``ClipData`` object whose single ``ClipData.Item`` object
      contains an ``Intent``. The ``ClipDescription`` object's label is set to
      ``label``. The MIME type is set to
      `MIMETYPE_TEXT_INTENT <#android.content.ClipDescription>`__.

      Use ``newIntent()`` to create a clip from an ``Intent`` object.

   .. rubric:: Coerce the clipboard data to text
      :name: CoerceToText

   Even if your application only handles text, you can copy non-text data from
   the clipboard by converting it with the
   `ClipData.Item.coerceToText() <#android.content.ClipData.Item>`__
   method.

   This method converts the data in ``ClipData.Item`` to text and returns a
   ``CharSequence``. The value that ``ClipData.Item.coerceToText()`` returns is
   based on the form of data in ``ClipData.Item``:

   Text
      If ``ClipData.Item`` is text—that is, if
      `getText() <#android.content.ClipData.Item>`__
      isn't null—coerceToText() returns the text.
   URI
      If ``ClipData.Item`` is a URI—that is, if
      `getUri() <#android.content.ClipData.Item>`__ isn't
      null—``coerceToText()`` tries to use it as a content URI.

      -  If the URI is a content URI and the provider can return a text stream,
         ``coerceToText()`` returns a text stream.
      -  If the URI is a content URI but the provider doesn't offer a text
         stream, ``coerceToText()`` returns a representation of the URI. The
         representation is the same as that returned by
         `Uri.toString() <#android.net.Uri>`__.
      -  If the URI isn't a content URI, ``coerceToText()`` returns a
         representation of the URI. The representation is the same as that
         returned by ``Uri.toString()``.
   Intent
      If ``ClipData.Item`` is an ``Intent``—that is, if
      `getIntent() <#android.content.ClipData.Item>`__
      isn't null—``coerceToText()`` converts it to an Intent URI and returns it.
      The representation is the same as that returned by
      `Intent.toUri(URI_INTENT_SCHEME) <#android.content.Intent>`__.

   The clipboard framework is summarized in figure 2. To copy data, an
   application puts a ``ClipData`` object on the ``ClipboardManager`` global
   clipboard. The ``ClipData`` contains one or more ``ClipData.Item`` objects
   and one ``ClipDescription`` object. To paste data, an application gets the
   ``ClipData``, gets its MIME type from the ``ClipDescription``, and gets the
   data from the ``ClipData.Item`` or from the content provider referred to by
   ``ClipData.Item``.

   .. figure:: https://developer.android.google.cn/static/images/ui/clipboard/copy_paste_framework.png
      name: framework
      :alt: An image showing a block diagram of the copy and paste framework
      :width: 100.0%

      **Figure 2.** The Android clipboard framework.

   .. rubric:: Copy to the clipboard
      :name: Copying

   To copy data to the clipboard, get a handle to the global
   ``ClipboardManager`` object, create a ``ClipData`` object, and add a
   ``ClipDescription`` and one or more ``ClipData.Item`` objects to it. Then,
   add the finished ``ClipData`` object to the ``ClipboardManager`` object. This
   is described further in the following procedure:

   #. If you are copying data using a content URI, set up a content provider.

   #. Get the system clipboard:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  when(menuItem.itemId) {
                      ...
                      R.id.menu_copy -> { // if the user selects copy
                          // Gets a handle to the clipboard service.
                          val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  ...
                  // If the user selects copy.
                  case R.id.menu_copy:

                  // Gets a handle to the clipboard service.
                  ClipboardManager clipboard = (ClipboardManager)
                          getSystemService(Context.CLIPBOARD_SERVICE);

   #. Copy the data to a new ``ClipData`` object:

      -  **For text**

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     // Creates a new text clip to put on the clipboard.
                     val clip: ClipData = ClipData.newPlainText("simple text", "Hello, World!")

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // Creates a new text clip to put on the clipboard.
                     ClipData clip = ClipData.newPlainText("simple text", "Hello, World!");

      -  **For a URI**

         This snippet constructs a URI by encoding a record ID onto the content
         URI for the provider. This technique is covered in more detail in the
         `Encoding an identifier on the URI <#Encoding>`__ section.

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     // Creates a Uri using a base Uri and a record ID based on the contact's last
                     // name. Declares the base URI string.
                     const val CONTACTS = "content://com.example.contacts"

                     // Declares a path string for URIs, used to copy data.
                     const val COPY_PATH = "/copy"

                     // Declares the Uri to paste to the clipboard.
                     val copyUri: Uri = Uri.parse("$CONTACTS$COPY_PATH/$lastName")
                     ...
                     // Creates a new URI clip object. The system uses the anonymous
                     // getContentResolver() object to get MIME types from provider. The clip object's
                     // label is "URI", and its data is the Uri previously created.
                     val clip: ClipData = ClipData.newUri(contentResolver, "URI", copyUri)

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // Creates a Uri using a base Uri and a record ID based on the contact's last
                     // name. Declares the base URI string.
                     private static final String CONTACTS = "content://com.example.contacts";

                     // Declares a path string for URIs, used to copy data.
                     private static final String COPY_PATH = "/copy";

                     // Declares the Uri to paste to the clipboard.
                     Uri copyUri = Uri.parse(CONTACTS + COPY_PATH + "/" + lastName);
                     ...
                     // Creates a new URI clip object. The system uses the anonymous
                     // getContentResolver() object to get MIME types from provider. The clip object's
                     // label is "URI", and its data is the Uri previously created.
                     ClipData clip = ClipData.newUri(getContentResolver(), "URI", copyUri);

      -  **For an intent**

         This snippet constructs an ``Intent`` for an application and then puts
         it in the clip object:

         .. container::

            .. container:: ds-selector-tabs

               .. container:: section

                  .. rubric:: Kotlin
                     :name: kotlin

                  .. code:: prettyprint

                     // Creates the Intent.
                     val appIntent = Intent(this, com.example.demo.myapplication::class.java)
                     ...
                     // Creates a clip object with the Intent in it. Its label is "Intent"
                     // and its data is the Intent object created previously.
                     val clip: ClipData = ClipData.newIntent("Intent", appIntent)

               .. container:: section

                  .. rubric:: Java
                     :name: java

                  .. code:: prettyprint

                     // Creates the Intent.
                     Intent appIntent = new Intent(this, com.example.demo.myapplication.class);
                     ...
                     // Creates a clip object with the Intent in it. Its label is "Intent"
                     // and its data is the Intent object created previously.
                     ClipData clip = ClipData.newIntent("Intent", appIntent);

   #. Put the new clip object on the clipboard:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Set the clipboard's primary clip.
                  clipboard.setPrimaryClip(clip)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Set the clipboard's primary clip.
                  clipboard.setPrimaryClip(clip);

   .. rubric:: Provide feedback when copying to the clipboard
      :name: Feedback

   Users expect visual feedback when an app copies content to the clipboard.
   This is done automatically for users in Android 13 and higher, but it must be
   manually implemented in prior versions.

   Starting in Android 13, the system displays a standard visual confirmation
   when content is added to the clipboard. The new confirmation does the
   following:

   -  Confirms the content was successfully copied.
   -  Provides a preview of the copied content.

   .. figure:: https://developer.android.google.cn/static/images/about/versions/13/new-copy-paste-UI.gif
      name: android-13
      :alt: An animation showing Android 13 clipboard notification
      :width: 50.0%

      **Figure 3.** UI shown when content enters the clipboard in Android 13 and
      up.

   In Android 12L (API level 32) and lower, users might be unsure whether they
   successfully copied content or what they copied. This feature standardizes
   the various notifications shown by apps after copying and offers users more
   control over the clipboard.

   .. rubric:: Avoid duplicate notifications
      :name: duplicate-notifications
      :class: clear

   In Android 12L (API level 32) and lower, we recommend alerting users when
   they successfully copy by issuing visual, in-app feedback, using a widget
   like a ``Toast`` or a ``Snackbar``, after copying.

   To avoid duplicate displays of information, we strongly recommend removing
   toasts or snackbars shown after an in-app copy for Android 13 and higher.

   .. figure:: https://developer.android.google.cn/static/images/about/versions/13/snackbar-overlap.png
      :alt: Post snackbar after an in-app copy.
      :figclass: screenshot

      **Figure 4.** If you show a copy confirmation snackbar in Android 13, the
      user sees duplicate messages.

   .. figure:: https://developer.android.google.cn/static/images/about/versions/13/toast-overlap.png
      :alt: Post toast after an in-app copy.
      :figclass: screenshot

      **Figure 5.** If you show a copy confirmation toast in Android 13, the
      user sees duplicate messages.

   Here's an example of how to implement this:

   .. code:: prettyprint

      fun textCopyThenPost(textCopied:String) {
          val clipboardManager = getSystemService(CLIPBOARD_SERVICE) as ClipboardManager
          // When setting the clipboard text.
          clipboardManager.setPrimaryClip(ClipData.newPlainText   ("", textCopied))
          // Only show a toast for Android 12 and lower.
          if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.S_V2)
              Toast.makeText(context, “Copied”, Toast.LENGTH_SHORT).show()
      }

   .. rubric:: Add sensitive content to the clipboard
      :name: SensitiveContent

   If your app lets users copy sensitive content to the clipboard, such as
   passwords or credit card information, you must add a flag to
   ``ClipDescription`` in ``ClipData`` before calling
   ``ClipboardManager.setPrimaryClip()``. Adding this flag prevents sensitive
   content from appearing in the visual confirmation of copied content in
   Android 13 and higher.

   .. figure:: https://developer.android.google.cn/static/images/about/versions/13/sensitive-content-before.png
      :alt: Copied text preview without flagging sensitive content
      :figclass: screenshot

      **Figure 6.** Copied text preview without a sensitive content flag.

   .. figure:: https://developer.android.google.cn/static/images/about/versions/13/sensitive-content-after.png
      :alt: Copied text preview flagging sensitive content.
      :figclass: screenshot

      **Figure 7.** Copied text preview with a sensitive content flag.

   To flag sensitive content, add a boolean extra to the ``ClipDescription``.
   All apps must do this, regardless of the targeted API level.

   .. code:: prettyprint

      // If your app is compiled with the API level 33 SDK or higher.
      clipData.apply {
          description.extras = PersistableBundle().apply {
              putBoolean(ClipDescription.EXTRA_IS_SENSITIVE, true)
          }
      }

      // If your app is compiled with a lower SDK.
      clipData.apply {
          description.extras = PersistableBundle().apply {
              putBoolean("android.content.extra.IS_SENSITIVE", true)
          }
      }

   .. rubric:: Paste from the clipboard
      :name: Paste

   As described previously, paste data from the clipboard by getting the global
   clipboard object, getting the clip object, looking at its data, and if
   possible copying the data from the clip object to your own storage. This
   section explains in detail how to paste the three forms of clipboard data.

   **Important:** For editable ``TextView`` objects, follow the `Receive rich content <#>`__ document to add support
   for pasting any type of content. The following section describes how to
   develop a custom UI for pasting content.

   .. rubric:: Paste plain text
      :name: PastePlainText

   To paste plain text, get the global clipboard and verify that it can return
   plain text. Then get the clip object and copy its text to your own storage
   using ``getText()``, as described in the following procedure:

   #. Get the global ``ClipboardManager`` object using
      ``getSystemService(CLIPBOARD_SERVICE)``. Also, declare a global variable
      to contain the pasted text:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  var clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                  var pasteData: String = ""

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
                  String pasteData = "";

   #. Determine whether you need to enable or disable the "paste" option in the
      current activity. Verify that the clipboard contains a clip and that you
      can handle the type of data represented by the clip:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Gets the ID of the "paste" menu item.
                  val pasteItem: MenuItem = menu.findItem(R.id.menu_paste)

                  // If the clipboard doesn't contain data, disable the paste menu item.
                  // If it does contain data, decide whether you can handle the data.
                  pasteItem.isEnabled = when {
                      !clipboard.hasPrimaryClip() -> {
                          false
                      }
                      !(clipboard.primaryClipDescription.hasMimeType(MIMETYPE_TEXT_PLAIN)) -> {
                          // Disables the paste menu item, since the clipboard has data but it
                          // isn't plain text.
                          false
                      }
                      else -> {
                          // Enables the paste menu item, since the clipboard contains plain text.
                          true
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Gets the ID of the "paste" menu item.
                  MenuItem pasteItem = menu.findItem(R.id.menu_paste);

                  // If the clipboard doesn't contain data, disable the paste menu item.
                  // If it does contain data, decide whether you can handle the data.
                  if (!(clipboard.hasPrimaryClip())) {

                      pasteItem.setEnabled(false);

                  } else if (!(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN))) {

                      // Disables the paste menu item, since the clipboard has data but
                      // it isn't plain text.
                      pasteItem.setEnabled(false);
                  } else {

                      // Enables the paste menu item, since the clipboard contains plain text.
                      pasteItem.setEnabled(true);
                  }

   #. Copy the data from the clipboard. This point in the code is only reachable
      if the "paste" menu item is enabled, so you can assume that the clipboard
      contains plain text. You don't yet know if it contains a text string or a
      URI that points to plain text. The following code snippet tests this, but
      it only shows the code for handling plain text:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  when (menuItem.itemId) {
                      ...
                      R.id.menu_paste -> {    // Responds to the user selecting "paste".
                          // Examines the item on the clipboard. If getText() doesn't return null,
                          // the clip item contains the text. Assumes that this application can only
                          // handle one item at a time.
                          val item = clipboard.primaryClip.getItemAt(0)

                          // Gets the clipboard as text.
                          pasteData = item.text

                          return if (pasteData != null) {
                              // If the string contains data, then the paste operation is done.
                              true
                          } else {
                              // The clipboard doesn't contain text. If it contains a URI,
                              // attempts to get data from it.
                              val pasteUri: Uri? = item.uri

                              if (pasteUri != null) {
                                  // If the URI contains something, try to get text from it.

                                  // Calls a routine to resolve the URI and get data from it.
                                  // This routine isn't presented here.
                                  pasteData = resolveUri(pasteUri)
                                  true
                              } else {

                                  // Something is wrong. The MIME type was plain text, but the
                                  // clipboard doesn't contain text or a Uri. Report an error.
                                  Log.e(TAG,"Clipboard contains an invalid data type")
                                  false
                              }
                          }
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Responds to the user selecting "paste".
                  case R.id.menu_paste:

                  // Examines the item on the clipboard. If getText() does not return null,
                  // the clip item contains the text. Assumes that this application can only
                  // handle one item at a time.
                   ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0);

                  // Gets the clipboard as text.
                  pasteData = item.getText();

                  // If the string contains data, then the paste operation is done.
                  if (pasteData != null) {
                      return true;

                  // The clipboard doesn't contain text. If it contains a URI, attempts to get
                  // data from it.
                  } else {
                      Uri pasteUri = item.getUri();

                      // If the URI contains something, try to get text from it.
                      if (pasteUri != null) {

                          // Calls a routine to resolve the URI and get data from it.
                          // This routine isn't presented here.
                          pasteData = resolveUri(Uri);
                          return true;
                      } else {

                          // Something is wrong. The MIME type is plain text, but the
                          // clipboard doesn't contain text or a Uri. Report an error.
                          Log.e(TAG, "Clipboard contains an invalid data type");
                          return false;
                      }
                  }

   .. rubric:: Paste data from a content URI
      :name: PasteContentUri

   If the ``ClipData.Item`` object contains a content URI and you determine that
   you can handle one of its MIME types, create a ``ContentResolver`` and call
   the appropriate content provider method to retrieve the data.

   The following procedure describes how to get data from a content provider
   based on a content URI on the clipboard. It checks whether a MIME type that
   the application can use is available from the provider.

   #. Declare a global variable to contain the MIME type:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Declares a MIME type constant to match against the MIME types offered
                  // by the provider.
                  const val MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact"

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Declares a MIME type constant to match against the MIME types offered by
                  // the provider.
                  public static final String MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact";

   #. Get the global clipboard. Also get a content resolver so you can access
      the content provider:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Gets a handle to the Clipboard Manager.
                  val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager

                  // Gets a content resolver instance.
                  val cr = contentResolver

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Gets a handle to the Clipboard Manager.
                  ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

                  // Gets a content resolver instance.
                  ContentResolver cr = getContentResolver();

   #. Get the primary clip from the clipboard and get its contents as a URI:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Gets the clipboard data from the clipboard.
                  val clip: ClipData? = clipboard.primaryClip

                  clip?.run {

                      // Gets the first item from the clipboard data.
                      val item: ClipData.Item = getItemAt(0)

                      // Tries to get the item's contents as a URI.
                      val pasteUri: Uri? = item.uri

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Gets the clipboard data from the clipboard.
                  ClipData clip = clipboard.getPrimaryClip();

                  if (clip != null) {

                      // Gets the first item from the clipboard data.
                      ClipData.Item item = clip.getItemAt(0);

                      // Tries to get the item's contents as a URI.
                      Uri pasteUri = item.getUri();

   #. Test whether the URI is a content URI by calling
      `getType(Uri) <#android.content.ContentResolver>`__.
      This method returns null if ``Uri`` doesn't point to a valid content
      provider.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                      // If the clipboard contains a URI reference...
                      pasteUri?.let {

                          // ...is this a content URI?
                          val uriMimeType: String? = cr.getType(it)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                      // If the clipboard contains a URI reference...
                      if (pasteUri != null) {

                          // ...is this a content URI?
                          String uriMimeType = cr.getType(pasteUri);

   #. Test whether the content provider supports a MIME type that the
      application understands. If it does, call
      `ContentResolver.query() <#android.content.ContentResolver>`__
      to get the data. The return value is a
      `Cursor <#android.database.Cursor>`__.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                          // If the return value isn't null, the Uri is a content Uri.
                          uriMimeType?.takeIf {

                              // Does the content provider offer a MIME type that the current
                              // application can use?
                              it == MIME_TYPE_CONTACT
                          }?.apply {

                              // Get the data from the content provider.
                              cr.query(pasteUri, null, null, null, null)?.use { pasteCursor ->

                                  // If the Cursor contains data, move to the first record.
                                  if (pasteCursor.moveToFirst()) {

                                      // Get the data from the Cursor here.
                                      // The code varies according to the format of the data model.
                                  }

                                  // Kotlin `use` automatically closes the Cursor.
                              }
                          }
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                          // If the return value isn't null, the Uri is a content Uri.
                          if (uriMimeType != null) {

                              // Does the content provider offer a MIME type that the current
                              // application can use?
                              if (uriMimeType.equals(MIME_TYPE_CONTACT)) {

                                  // Get the data from the content provider.
                                  Cursor pasteCursor = cr.query(uri, null, null, null, null);

                                  // If the Cursor contains data, move to the first record.
                                  if (pasteCursor != null) {
                                      if (pasteCursor.moveToFirst()) {

                                      // Get the data from the Cursor here.
                                      // The code varies according to the format of the data model.
                                      }
                                  }

                                  // Close the Cursor.
                                  pasteCursor.close();
                               }
                           }
                       }
                  }

   .. rubric:: Paste an Intent
      :name: PasteIntent

   To paste an intent, first get the global clipboard. Examine the
   ``ClipData.Item`` object to see whether it contains an ``Intent``. Then call
   ``getIntent()`` to copy the intent to your own storage. The following snippet
   demonstrates this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Gets a handle to the Clipboard Manager.
               val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager

               // Checks whether the clip item contains an Intent by testing whether
               // getIntent() returns null.
               val pasteIntent: Intent? = clipboard.primaryClip?.getItemAt(0)?.intent

               if (pasteIntent != null) {

                   // Handle the Intent.

               } else {

                   // Ignore the clipboard, or issue an error if
                   // you expect an Intent to be on the clipboard.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Gets a handle to the Clipboard Manager.
               ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

               // Checks whether the clip item contains an Intent, by testing whether
               // getIntent() returns null.
               Intent pasteIntent = clipboard.getPrimaryClip().getItemAt(0).getIntent();

               if (pasteIntent != null) {

                   // Handle the Intent.

               } else {

                   // Ignore the clipboard, or issue an error if
                   // you expect an Intent to be on the clipboard.
               }

   .. rubric:: System notification shown when your app accesses clipboard data
      :name: PastingSystemNotifications

   On Android 12 (API level 31) and higher, the system usually shows a toast
   message when your app calls
   `getPrimaryClip() <#android.content.ClipboardManager>`__.
   The text inside the message contains the following format:

   .. code:: none

      APP pasted from your clipboard

   The system doesn't show a toast message when your app does one of the
   following:

   -  Accesses `ClipData <#android.content.ClipData>`__ from your
      own app.
   -  Repeatedly accesses ``ClipData`` from a specific app. The toast appears
      only when your app accesses the data from that app for the first time.
   -  Retrieves metadata for the clip object, such as by calling
      `getPrimaryClipDescription() <#android.content.ClipboardManager>`__
      instead of ``getPrimaryClip()``.

   .. rubric:: Use content providers to copy complex data
      :name: Provider

   Content providers support copying complex data such as database records or
   file streams. To copy the data, put a content URI on the clipboard. Pasting
   applications then get this URI from the clipboard and use it to retrieve
   database data or file stream descriptors.

   Since the pasting application only has the content URI for your data, it
   needs to know which piece of data to retrieve. You can provide this
   information by encoding an identifier for the data on the URI itself, or you
   can provide a unique URI that returns the data you want to copy. Which
   technique you choose depends on the organization of your data.

   The following sections describe how to set up URIs, provide complex data, and
   provide file streams. The descriptions assume you are familiar with the
   general principles of content provider design.

   .. rubric:: Encode an identifier on the URI
      :name: Encoding

   A useful technique for copying data to the clipboard with a URI is to encode
   an identifier for the data on the URI itself. Your content provider can then
   get the identifier from the URI and use it to retrieve the data. The pasting
   application doesn't have to know that the identifier exists. It just has to
   get your "reference"—the URI plus the identifier—from the clipboard, give it
   your content provider, and get back the data.

   You usually encode an identifier onto a content URI by concatenating it to
   the end of the URI. For example, suppose you define your provider URI as the
   following string:

   .. code:: none

      "content://com.example.contacts"

   If you want to encode a name onto this URI, use the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val uriString = "content://com.example.contacts/Smith"

               // uriString now contains content://com.example.contacts/Smith.

               // Generates a uri object from the string representation.
               val copyUri = Uri.parse(uriString)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String uriString = "content://com.example.contacts" + "/" + "Smith";

               // uriString now contains content://com.example.contacts/Smith.

               // Generates a uri object from the string representation.
               Uri copyUri = Uri.parse(uriString);

   If you are already using a content provider, you might want to add a new URI
   path that indicates the URI is for copying. For example, suppose you already
   have the following URI paths:

   .. code:: none

      "content://com.example.contacts/people"
      "content://com.example.contacts/people/detail"
      "content://com.example.contacts/people/images"

   You can add another path that for copying URIs:

   .. code:: none

      "content://com.example.contacts/copying"

   You can then detect a "copy" URI by pattern-matching and handle it with code
   that is specific for copying and pasting.

   You normally use the encoding technique if you're already using a content
   provider, internal database, or internal table to organize your data. In
   these cases, you have multiple pieces of data you want to copy, and
   presumably a unique identifier for each piece. In response to a query from
   the pasting application, you can look up the data by its identifier and
   return it.

   If you don't have multiple pieces of data, then you probably don't need to
   encode an identifier. You can use a URI that is unique to your provider. In
   response to a query, your provider returns the data it currently contains.

   .. rubric:: Copy data structures
      :name: Records

   Set up a content provider for copying and pasting complex data as a subclass
   of the `ContentProvider <#android.content.ContentProvider>`__
   component. Encode the URI you put on the clipboard so that it points to the
   exact record you want to provide. In addition, consider the existing state of
   your application:

   -  If you already have a content provider, you can add to its functionality.
      You might only need to modify its ``query()`` method to handle URIs coming
      from applications that want to paste data. You probably want to modify the
      method to handle a "copy" URI pattern.
   -  If your application maintains an internal database, you might want to move
      this database into a content provider to facilitate copying from it.
   -  If you aren't using a database, you can implement a simple content
      provider whose sole purpose is to offer data to applications that are
      pasting from the clipboard.

   In the content provider, override at least the following methods:

   `query() <#android.content.ContentResolver>`__
      Pasting applications assume they can get your data by using this method
      with the URI you put on the clipboard. To support copying, have this
      method detect URIs containing a special "copy" path. Your application can
      then create a "copy" URI to put on the clipboard, containing the copy path
      and a pointer to the exact record you want to copy.
   `getType() <#android.content.ContentProvider>`__
      This method must return the MIME types for the data you intend to copy.
      The method
      `newUri() <#android.content.ClipData>`__
      calls ``getType()`` to put the MIME types into the new ``ClipData``
      object.

      MIME types for complex data are described in `Content providers <#>`__.

   You don't need to have any of the other content provider methods, such as
   `insert() <#android.content.ContentProvider>`__
   or
   `update() <#android.content.ContentProvider>`__.
   A pasting application only needs to get your supported MIME types and copy
   data from your provider. If you already have these methods, they won't
   interfere with copy operations.

   The following snippets demonstrate how to set up your application to copy
   complex data:

   #. In the global constants for your application, declare a base URI string
      and a path that identifies URI strings you are using to copy data. Also
      declare a MIME type for the copied data.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Declares the base URI string.
                  private const val CONTACTS = "content://com.example.contacts"

                  // Declares a path string for URIs that you use to copy data.
                  private const val COPY_PATH = "/copy"

                  // Declares a MIME type for the copied data.
                  const val MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact"

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Declares the base URI string.
                  private static final String CONTACTS = "content://com.example.contacts";

                  // Declares a path string for URIs that you use to copy data.
                  private static final String COPY_PATH = "/copy";

                  // Declares a MIME type for the copied data.
                  public static final String MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact";

   #. In the activity users copy data from, set up the code to copy data to the
      clipboard. In response to a copy request, put the URI on the clipboard.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  class MyCopyActivity : Activity() {
                      ...
                  when(item.itemId) {
                      R.id.menu_copy -> { // The user has selected a name and is requesting a copy.
                          // Appends the last name to the base URI.
                          // The name is stored in "lastName".
                          uriString = "$CONTACTS$COPY_PATH/$lastName"

                          // Parses the string into a URI.
                          val copyUri: Uri? = Uri.parse(uriString)

                          // Gets a handle to the clipboard service.
                          val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager

                          val clip: ClipData = ClipData.newUri(contentResolver, "URI", copyUri)

                          // Sets the clipboard's primary clip.
                          clipboard.setPrimaryClip(clip)
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public class MyCopyActivity extends Activity {
                      ...
                  // The user has selected a name and is requesting a copy.
                  case R.id.menu_copy:

                      // Appends the last name to the base URI.
                      // The name is stored in "lastName".
                      uriString = CONTACTS + COPY_PATH + "/" + lastName;

                      // Parses the string into a URI.
                      Uri copyUri = Uri.parse(uriString);

                      // Gets a handle to the clipboard service.
                      ClipboardManager clipboard = (ClipboardManager)
                          getSystemService(Context.CLIPBOARD_SERVICE);

                      ClipData clip = ClipData.newUri(getContentResolver(), "URI", copyUri);

                      // Sets the clipboard's primary clip.
                      clipboard.setPrimaryClip(clip);

   #. In the global scope of your content provider, create a URI matcher and add
      a URI pattern that matches URIs you put on the clipboard.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // A Uri Match object that simplifies matching content URIs to patterns.
                  private val sUriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {

                      // Adds a matcher for the content URI. It matches.
                      // "content://com.example.contacts/copy/*"
                      addURI(CONTACTS, "names/*", GET_SINGLE_CONTACT)
                  }

                  // An integer to use in switching based on the incoming URI pattern.
                  private const val GET_SINGLE_CONTACT = 0
                  ...
                  class MyCopyProvider : ContentProvider() {
                      ...
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public class MyCopyProvider extends ContentProvider {
                      ...
                  // A Uri Match object that simplifies matching content URIs to patterns.
                  private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

                  // An integer to use in switching based on the incoming URI pattern.
                  private static final int GET_SINGLE_CONTACT = 0;
                  ...
                  // Adds a matcher for the content URI. It matches
                  // "content://com.example.contacts/copy/*"
                  sUriMatcher.addURI(CONTACTS, "names/*", GET_SINGLE_CONTACT);

   #. Set up the
      `query() <#android.content.ContentProvider>`__
      method. This method can handle different URI patterns, depending on how
      you code it, but only the pattern for the clipboard copying operation
      shows.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Sets up your provider's query() method.
                  override fun query(
                          uri: Uri,
                          projection: Array<out String>?,
                          selection: String?,
                          selectionArgs: Array<out String>?,
                          sortOrder: String?
                  ): Cursor? {
                      ...
                      // When based on the incoming content URI:
                      when(sUriMatcher.match(uri)) {

                          GET_SINGLE_CONTACT -> {

                              // Queries and returns the contact for the requested name. Decodes
                              // the incoming URI, queries the data model based on the last name,
                              // and returns the result as a Cursor.
                          }
                      }
                      ...
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Sets up your provider's query() method.
                  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
                      String sortOrder) {
                      ...
                      // Switch based on the incoming content URI.
                      switch (sUriMatcher.match(uri)) {

                      case GET_SINGLE_CONTACT:

                          // Queries and returns the contact for the requested name. Decodes the
                          // incoming URI, queries the data model based on the last name, and
                          // returns the result as a Cursor.
                      ...
                  }

   #. Set up the ``getType()`` method to return an appropriate MIME type for
      copied data:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  // Sets up your provider's getType() method.
                  override fun getType(uri: Uri): String? {
                      ...
                      return when(sUriMatcher.match(uri)) {
                          GET_SINGLE_CONTACT -> MIME_TYPE_CONTACT
                          ...
                      }
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  // Sets up your provider's getType() method.
                  public String getType(Uri uri) {
                      ...
                      switch (sUriMatcher.match(uri)) {
                      case GET_SINGLE_CONTACT:
                          return (MIME_TYPE_CONTACT);
                      ...
                      }
                  }

   The `Paste data from a content URI <#PasteContentUri>`__ section describes
   how to get a content URI from the clipboard and use it to get and paste data.

   .. rubric:: Copy data streams
      :name: Streams

   You can copy and paste large amounts of text and binary data as streams. The
   data can have forms such as the following:

   -  Files stored on the actual device
   -  Streams from sockets
   -  Large amounts of data stored in a provider's underlying database system

   A content provider for data streams provides access to its data with a file
   descriptor object, such as
   `AssetFileDescriptor <#android.content.res.AssetFileDescriptor>`__,
   instead of a ``Cursor`` object. The pasting application reads the data stream
   using this file descriptor.

   To set up your application to copy a data stream with a provider, follow
   these steps:

   #. Set up a content URI for the data stream you are putting on the clipboard.
      Options for doing this include the following:

      -  Encode an identifier for the data stream onto the URI, as described in
         the `Encode an identifier on the URI <#Encoding>`__ section, and then
         maintain a table in your provider that contains identifiers and the
         corresponding stream name.
      -  Encode the stream name directly on the URI.
      -  Use a unique URI that always returns the current stream from the
         provider. If you use this option, remember to update your provider to
         point to a different stream whenever you copy the stream to the
         clipboard using the URI.

   #. Provide a MIME type for each type of data stream you plan to offer.
      Pasting applications need this information to determine whether they can
      paste the data on the clipboard.
   #. Implement one of the ``ContentProvider`` methods that returns a file
      descriptor for a stream. If you encode identifiers on the content URI, use
      this method to determine which stream to open.
   #. To copy the data stream to the clipboard, construct the content URI and
      place it on the clipboard.

   To paste a data stream, an application gets the clip from the clipboard, gets
   the URI, and uses it in a call to a ``ContentResolver`` file descriptor
   method that opens the stream. The ``ContentResolver`` method calls the
   corresponding ``ContentProvider`` method, passing it the content URI. Your
   provider returns the file descriptor to the ``ContentResolver`` method. The
   pasting application then has the responsibility to read the data from the
   stream.

   The following list shows the most important file descriptor methods for a
   content provider. Each of these has a corresponding ``ContentResolver``
   method with the string "Descriptor" appended to the method name. For example,
   the ``ContentResolver`` analog of
   `openAssetFile() <#android.content.ContentProvider>`__
   is
   `openAssetFileDescriptor() <#android.content.ContentResolver>`__.

   `openTypedAssetFile() <#android.content.ContentProvider>`__
      This method returns an asset file descriptor, but only if the provided
      MIME type is supported by the provider. The caller—the application doing
      the pasting—provides a MIME type pattern. The content provider of the
      application that copies a URI to the clipboard returns an
      ``AssetFileDescriptor`` file handle if it can provide that MIME type and
      throws an exception if it can't.

      This method handles subsections of files. You can use it to read assets
      that the content provider has copied to the clipboard.

   `openAssetFile() <#android.content.ContentProvider>`__
      This method is a more general form of ``openTypedAssetFile()``. It doesn't
      filter for allowed MIME types, but it can read subsections of files.
   `openFile() <#android.content.ContentProvider>`__
      This is a more general form of ``openAssetFile()``. It can't read
      subsections of files.

   You can optionally use the
   `openPipeHelper() <#android.content.ContentProvider>`__
   method with your file descriptor method. This lets the pasting application
   read the stream data in a background thread using a pipe. To use this method,
   implement the
   `ContentProvider.PipeDataWriter <#android.content.ContentProvider.PipeDataWriter>`__
   interface.

   .. rubric:: Design effective copy and paste functionality
      :name: DataDesign

   To design effective copy and paste functionality for your application,
   remember these points:

   -  At any time, there is only one clip on the clipboard. A new copy operation
      by any application in the system overwrites the previous clip. Since the
      user might navigate away from your application and copy before returning,
      you can't assume the clipboard contains the clip that the user previously
      copied in *your* application.
   -  The intended purpose of multiple ``ClipData.Item`` objects per clip is to
      support copying and pasting of multiple selections rather than different
      forms of reference to a single selection. You usually want all of the
      ``ClipData.Item`` objects in a clip to have the same form. That is, they
      must all be simple text, content URI, or ``Intent``, and not mixed.
   -  When you provide data, you can offer different MIME representations. Add
      the MIME types you support to the ``ClipDescription``, and then implement
      the MIME types in your content provider.
   -  When you get data from the clipboard, your application is responsible for
      checking the available MIME types and then deciding which one, if any, to
      use. Even if there is a clip on the clipboard and the user requests a
      paste, your application isn't required to do the paste. Do the paste if
      the MIME type is compatible. You might coerce the data on the clipboard to
      text using ``coerceToText()``. If your application supports more than one
      of the available MIME types, you can let the user pick which one to use.


Last updated 2024-05-03 UTC.


/Overview
=========

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop?hl=en

.. container:: devsite-article-body

   **Note:**\  See the improved method to implement drag-and-drop in `Receive rich content <#>`__. It provides a
   better UX and improves maintainability of your code.
   The Android drag-and-drop framework lets you add interactive drag-and-drop
   capabilities to your app. With drag-and-drop, users can copy or move text,
   images, objects, and any content that can be represented by a URI, from one
   `View <#android.view.View>`__ to another within an app, or
   between apps in `multi-window mode <#DragPermissionsMultiWindow>`__.

   +--------------------------------------+--------------------------------------+
   | |Text string and image being dragged | |Text string and image being dragged |
   | and dropped within an app.|          | and dropped between apps in          |
   |                                      | split-screen mode.|                  |
   +--------------------------------------+--------------------------------------+
   | **Figure 1.** Drag-and-drop within   | **Figure 2.** Drag-and-drop between  |
   | an app.                              | apps.                                |
   +--------------------------------------+--------------------------------------+

   The framework includes a drag event class, drag listeners, and helper classes
   and methods. Although primarily designed to enable the transfer of data, you
   can use the framework for other UI actions. For example, you can create an
   app that mixes colors when the user drags a color icon over another icon.
   However, the rest of document describes the drag-and-drop framework in the
   context of data transfer.

   .. rubric:: Overview
      :name: AboutDragging

   There are a few elements involved in the drag process.

   #. Drag source: The start point view of drag & drop process.

   #. Drop target: A view that can accept the drag data.

   #. `Drag shadow <#AboutDragShadowBuilder>`__:
      A *drag shadow* is a representation of the data being dragged, it's
      visible to users.

   #. `Drag events <#AboutDragEvent>`__:
      As the user moves the drag shadow over the app's layout, the system sends
      drag events to the drag event listeners and callback methods associated
      with the ``View`` objects in the layout.

   A drag-and-drop operation starts when the user makes a UI gesture that your
   app recognizes as a signal to start dragging data. In response, the app
   notifies the system that a drag-and-drop operation is starting. The system
   calls back to your app to get a *drag shadow*. and show it to users during
   drag-and-drop process.

   As the user moves the drag shadow over the app's layout, the system sends
   drag events to the `drag event listeners and callback methods <#AboutDragListeners>`__
   associated with the ``View`` objects in the layout. If the user releases the
   drag shadow over a drop target, the system sends the data to it. The
   drag-and-drop operation ends when the user releases the drag shadow, whether
   or not the drag shadow is over a drop target.

   .. rubric:: Topics
      :name: Topics

   `Key Concepts <#>`__
      Understand the drag-and-drop process.
   `DropHelper for simplified drag-and-drop <#>`__
      Learn how to implement drag-and-drop with ``DropHelper``.
   `Implement drag-and-drop with View <#>`__
      Alternatively, implement drag-and-drop with Android Views, this allows
      developers to have more control on the details.
   `Drag-and-drop in multi-window mode <#>`__
      Support drag-and-drop in multi-window mode, allow objects to move across
      different applications.


Last updated 2024-04-16 UTC.

.. |Text string and image being dragged and dropped within an app.| image:: https://developer.android.google.cn/static/images/guide/topics/ui/drag-and-drop-within-app.gif
.. |Text string and image being dragged and dropped between apps in split-screen mode.| image:: https://developer.android.google.cn/static/images/guide/topics/ui/drag-and-drop-between-apps.gif


/Key Concepts
=============

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/concepts?hl=en

.. container:: devsite-article-body

   The following sections explains a few key concepts for drag-and-drop process.

   .. rubric:: Drag-and-drop process
      :name: DragDropLifecycle

   There are four steps or states in the drag-and-drop process: started,
   continuing, dropped, and ended.

   Started
      In response to a user's drag gesture, your application calls
      ``startDragAndDrop()`` to tell the system to start a drag-and-drop
      operation. The method's arguments provide the following:

      -  The data to be dragged.
      -  A callback for drawing the drag shadow
      -  Metadata that describes the dragged data
      -  The system responds by calling back to your application to get a drag
         shadow. The system then displays the drag shadow on the device.
      -  Next, the system sends a drag event with action type
         `ACTION_DRAG_STARTED <#android.view.DragEvent>`__
         to the drag event listener of all ``View`` objects in the current
         layout. To continue to receive drag events—including a possible drop
         event—the drag event listener must return ``true``. This registers the
         listener with the system. Only registered listeners continue to receive
         drag events. At this point, listeners can also change the appearance of
         their drop target ``View`` object to show that the view can accept a
         drop event.
      -  If the drag event listener returns ``false``, it doesn't receive drag
         events for the current operation until the system sends a drag event
         with action type
         `ACTION_DRAG_ENDED <#android.view.DragEvent>`__.
         By returning ``false``, the listener tells the system that it isn't
         interested in the drag-and-drop operation and doesn't want to accept
         the dragged data.

   **Note:**\  A return value of ``false`` from a
   `View.OnDragListener <#android.view.View.OnDragListener>`__
   triggers the view's ``onDragEvent()`` handler.

   Continuing
      The user continues the drag. As the drag shadow intersects the bounding
      box of a drop target, the system sends one or more drag events to the
      target's drag event listener. The listener might alter the appearance of
      the drop target ``View`` in response to the event. For example, if the
      event indicates that the drag shadow enters the bounding box of the drop
      target—action type
      `ACTION_DRAG_ENTERED <#android.view.DragEvent>`__
      —the listener can react by highlighting the ``View``.
   Dropped
      The user releases the drag shadow within the bounding box of a drop
      target. The system sends the drop target's listener a drag event with
      action type
      `ACTION_DROP <#android.view.DragEvent>`__. The
      drag event object contains the data that passes to the system in the call
      to ``startDragAndDrop()`` that starts the operation. The listener is
      expected to return boolean ``true`` to the system if the listener
      successfully processes the dropped data. : This step only occurs if the
      user drops the drag shadow within the bounding box of a ``View`` whose
      listener is registered to receive drag events (a drop target). If the user
      releases the drag shadow in any other situation, no ``ACTION_DROP`` drag
      event is sent.
   Ended
      After the user releases the drag shadow, and after the system sends

      out a drag event with action type ``ACTION_DROP``, if necessary, the
      system sends a drag event with action type ``ACTION_DRAG_ENDED`` to
      indicate that the drag-and-drop operation is over. This is done regardless
      of where the user releases the drag shadow. The event is sent to every
      listener that is registered to receive drag events, even if the listener
      also receives the ``ACTION_DROP`` event.

   Each of these steps is described in more detail in the section called `A
   drag-and-drop operation <#DesignDragOperation>`__.

   **Note:**\  If apps are running in multi-window mode, users can drag data
   from one app to another. For more information, see `Drag and drop <#dnd>`__ in
   `Multi-window support <#>`__.

   .. rubric:: Drag events
      :name: AboutDragEvent

   The system sends out a drag event in the form of a ``DragEvent`` object,
   which contains an action type that describes what is happening in the
   drag-and-drop process. Depending on the action type, the object can also
   contain other data.

   Drag event listeners receive the ``DragEvent`` object. To get the action
   type, listeners call
   `DragEvent.getAction() <#android.view.DragEvent>`__.
   There are six possible values defined by constants in the ``DragEvent``
   class, which are described in table 1:

   **Table 1.** DragEvent action types

   +-----------------------+---+
   | Action type           | M |
   |                       | e |
   |                       | a |
   |                       | n |
   |                       | i |
   |                       | n |
   |                       | g |
   +=======================+===+
   | ```ACTION_DRAG_START  | T |
   | ED`` </reference/andr | h |
   | oid/view/DragEvent#AC | e |
   | TION_DRAG_STARTED>`__ | a |
   |                       | p |
   |                       | p |
   |                       | l |
   |                       | i |
   |                       | c |
   |                       | a |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | c |
   |                       | a |
   |                       | l |
   |                       | l |
   |                       | s |
   |                       | ` | |                       | ` |
   |                       | s |
   |                       | t |
   |                       | a |
   |                       | r |
   |                       | t |
   |                       | D |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | A |
   |                       | n |
   |                       | d |
   |                       | D |
   |                       | r |
   |                       | o |
   |                       | p |
   |                       | ( |
   |                       | ) | |                       | ` | |                       | ` |
   |                       | a |
   |                       | n |
   |                       | d |
   |                       | o |
   |                       | b |
   |                       | t |
   |                       | a |
   |                       | i |
   |                       | n |
   |                       | s |
   |                       | a |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | . |
   |                       | I |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | w |
   |                       | a |
   |                       | n |
   |                       | t |
   |                       | s |
   |                       | t |
   |                       | o |
   |                       | c |
   |                       | o |
   |                       | n |
   |                       | t |
   |                       | i |
   |                       | n |
   |                       | u |
   |                       | e |
   |                       | r |
   |                       | e |
   |                       | c |
   |                       | e |
   |                       | i |
   |                       | v |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | s |
   |                       | f |
   |                       | o |
   |                       | r |
   |                       | t |
   |                       | h |
   |                       | i |
   |                       | s |
   |                       | o |
   |                       | p |
   |                       | e |
   |                       | r |
   |                       | a |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | , |
   |                       | i |
   |                       | t |
   |                       | m |
   |                       | u |
   |                       | s |
   |                       | t |
   |                       | r |
   |                       | e |
   |                       | t |
   |                       | u |
   |                       | r |
   |                       | n |
   |                       | b |
   |                       | o |
   |                       | o |
   |                       | l |
   |                       | e |
   |                       | a |
   |                       | n | |                       | ` | |                       | ` |
   |                       | t |
   |                       | r |
   |                       | u |
   |                       | e | |                       | ` | |                       | ` |
   |                       | t |
   |                       | o |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | s |
   |                       | y |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | m |
   |                       | . |
   +-----------------------+---+ | ````\                 | T |
   |  ```ACTION_DRAG_ENTER | h |
   | ED`` </reference/andr | e |
   | oid/view/DragEvent#AC | d |
   | TION_DRAG_ENTERED>`__ | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | e |
   |                       | r |
   |                       | s |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | b |
   |                       | o |
   |                       | u |
   |                       | n |
   |                       | d |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | b |
   |                       | o |
   |                       | x |
   |                       | o |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | ' |
   |                       | s |
   |                       | ` | |                       | ` |
   |                       | V |
   |                       | i |
   |                       | e |
   |                       | w | |                       | ` | |                       | ` |
   |                       | . |
   |                       | T |
   |                       | h |
   |                       | i |
   |                       | s |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | f |
   |                       | i |
   |                       | r |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | a |
   |                       | c |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | t |
   |                       | y |
   |                       | p |
   |                       | e |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | r |
   |                       | e |
   |                       | c |
   |                       | e |
   |                       | i |
   |                       | v |
   |                       | e |
   |                       | s |
   |                       | w |
   |                       | h |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | e |
   |                       | r |
   |                       | s |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | b |
   |                       | o |
   |                       | u |
   |                       | n |
   |                       | d |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | b |
   |                       | o |
   |                       | x |
   |                       | . |
   +-----------------------+---+ | ````\ `               | S | | ``ACTION_DRAG_LOCATIO | u |
   | N`` </reference/andro | b |
   | id/view/DragEvent#ACT | s |
   | ION_DRAG_LOCATION>`__ | e |
   |                       | q |
   |                       | u |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | t |
   |                       | o |
   |                       | a |
   |                       | n |
   |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | A |
   |                       | G |
   |                       | _ |
   |                       | E |
   |                       | N |
   |                       | T |
   |                       | E |
   |                       | R |
   |                       | E |
   |                       | D | |                       | ` | |                       | ` |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | , |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | i |
   |                       | s |
   |                       | s |
   |                       | t |
   |                       | i |
   |                       | l |
   |                       | l |
   |                       | w |
   |                       | i |
   |                       | t |
   |                       | h |
   |                       | i |
   |                       | n |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | b |
   |                       | o |
   |                       | u |
   |                       | n |
   |                       | d |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | b |
   |                       | o |
   |                       | x |
   |                       | o |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | ' |
   |                       | s | |                       | ` | |                       | ` |
   |                       | V |
   |                       | i |
   |                       | e |
   |                       | w | |                       | ` | |                       | ` |
   |                       | . |
   +-----------------------+---+ | ```                   | F |
   | `\ ```ACTION_DRAG_EXI | o |
   | TED`` </reference/and | l |
   | roid/view/DragEvent#A | l |
   | CTION_DRAG_EXITED>`__ | o |
   |                       | w |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | a |
   |                       | n |
   |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | A |
   |                       | G |
   |                       | _ |
   |                       | E |
   |                       | N |
   |                       | T |
   |                       | E |
   |                       | R |
   |                       | E |
   |                       | D | |                       | ` | |                       | ` |
   |                       | a |
   |                       | n |
   |                       | d |
   |                       | a |
   |                       | t |
   |                       | l |
   |                       | e |
   |                       | a |
   |                       | s |
   |                       | t |
   |                       | o |
   |                       | n |
   |                       | e | |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | A |
   |                       | G |
   |                       | _ |
   |                       | L |
   |                       | O |
   |                       | C |
   |                       | A |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N | |                       | ` | |                       | ` |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | , |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | m |
   |                       | o |
   |                       | v |
   |                       | e |
   |                       | s |
   |                       | o |
   |                       | u |
   |                       | t |
   |                       | s |
   |                       | i |
   |                       | d |
   |                       | e |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | b |
   |                       | o |
   |                       | u |
   |                       | n |
   |                       | d |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | b |
   |                       | o |
   |                       | x |
   |                       | o |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | ' |
   |                       | s | |                       | ` | |                       | ` |
   |                       | V |
   |                       | i |
   |                       | e |
   |                       | w | |                       | ` | |                       | ` |
   |                       | . |
   +-----------------------+---+ | \ `A            | T | | CTION_DROP`` </refere | h |
   | nce/android/view/Drag | e |
   | Event#ACTION_DROP>`__ | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | r |
   |                       | e |
   |                       | l |
   |                       | e |
   |                       | a |
   |                       | s |
   |                       | e |
   |                       | s |
   |                       | o |
   |                       | v |
   |                       | e |
   |                       | r |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | ' |
   |                       | s |
   |                       | ` | |                       | ` |
   |                       | V |
   |                       | i |
   |                       | e |
   |                       | w | |                       | ` | |                       | ` |
   |                       | . |
   |                       | T |
   |                       | h |
   |                       | i |
   |                       | s |
   |                       | a |
   |                       | c |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | t |
   |                       | y |
   |                       | p |
   |                       | e |
   |                       | i |
   |                       | s |
   |                       | s |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | t |
   |                       | o |
   |                       | a | |                       | ` | |                       | ` |
   |                       | V |
   |                       | i |
   |                       | e |
   |                       | w | |                       | ` | |                       | ` |
   |                       | o |
   |                       | b |
   |                       | j |
   |                       | e |
   |                       | c |
   |                       | t |
   |                       | ' |
   |                       | s |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | o |
   |                       | n |
   |                       | l |
   |                       | y |
   |                       | i |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | r |
   |                       | e |
   |                       | t |
   |                       | u |
   |                       | r |
   |                       | n |
   |                       | s |
   |                       | b |
   |                       | o |
   |                       | o |
   |                       | l |
   |                       | e |
   |                       | a |
   |                       | n | |                       | ` | |                       | ` |
   |                       | t |
   |                       | r |
   |                       | u |
   |                       | e | |                       | ` | |                       | ` |
   |                       | i |
   |                       | n |
   |                       | r |
   |                       | e |
   |                       | s |
   |                       | p |
   |                       | o |
   |                       | n |
   |                       | s |
   |                       | e |
   |                       | t |
   |                       | o |
   |                       | t |
   |                       | h |
   |                       | e | |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | A |
   |                       | G |
   |                       | _ |
   |                       | S |
   |                       | T |
   |                       | A |
   |                       | R |
   |                       | T |
   |                       | E |
   |                       | D | |                       | ` | |                       | ` |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | . |
   |                       | T |
   |                       | h |
   |                       | i |
   |                       | s |
   |                       | a |
   |                       | c |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | t |
   |                       | y |
   |                       | p |
   |                       | e |
   |                       | i |
   |                       | s |
   |                       | n |
   |                       | ' |
   |                       | t |
   |                       | s |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | i |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | u |
   |                       | s |
   |                       | e |
   |                       | r |
   |                       | r |
   |                       | e |
   |                       | l |
   |                       | e |
   |                       | a |
   |                       | s |
   |                       | e |
   |                       | s |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | o |
   |                       | v |
   |                       | e |
   |                       | r |
   |                       | a | |                       | ` | |                       | ` |
   |                       | V |
   |                       | i |
   |                       | e |
   |                       | w | |                       | ` | |                       | ` |
   |                       | w |
   |                       | h |
   |                       | o |
   |                       | s |
   |                       | e |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | i |
   |                       | s |
   |                       | n |
   |                       | ' |
   |                       | t |
   |                       | r |
   |                       | e |
   |                       | g |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | r |
   |                       | e |
   |                       | d |
   |                       | o |
   |                       | r |
   |                       | i |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | u |
   |                       | s |
   |                       | e |
   |                       | r |
   |                       | r |
   |                       | e |
   |                       | l |
   |                       | e |
   |                       | a |
   |                       | s |
   |                       | e |
   |                       | s |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | s |
   |                       | h |
   |                       | a |
   |                       | d |
   |                       | o |
   |                       | w |
   |                       | o |
   |                       | v |
   |                       | e |
   |                       | r |
   |                       | a |
   |                       | n |
   |                       | y |
   |                       | t |
   |                       | h |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | t |
   |                       | h |
   |                       | a |
   |                       | t |
   |                       | i |
   |                       | s |
   |                       | n |
   |                       | ' |
   |                       | t |
   |                       | p |
   |                       | a |
   |                       | r |
   |                       | t |
   |                       | o |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | c |
   |                       | u |
   |                       | r |
   |                       | r |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | l |
   |                       | a |
   |                       | y |
   |                       | o |
   |                       | u |
   |                       | t |
   |                       | . |
   |                       | T |
   |                       | h |
   |                       | e |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | r |
   |                       | e |
   |                       | t |
   |                       | u |
   |                       | r |
   |                       | n |
   |                       | s |
   |                       | b |
   |                       | o |
   |                       | o |
   |                       | l |
   |                       | e |
   |                       | a |
   |                       | n | |                       | ` | |                       | ` |
   |                       | t |
   |                       | r |
   |                       | u |
   |                       | e | |                       | ` | |                       | ` |
   |                       | i |
   |                       | f |
   |                       | i |
   |                       | t |
   |                       | s |
   |                       | u |
   |                       | c |
   |                       | c |
   |                       | e |
   |                       | s |
   |                       | s |
   |                       | f |
   |                       | u |
   |                       | l |
   |                       | l |
   |                       | y |
   |                       | p |
   |                       | r |
   |                       | o |
   |                       | c |
   |                       | e |
   |                       | s |
   |                       | s |
   |                       | e |
   |                       | s |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | o |
   |                       | p |
   |                       | . |
   |                       | O |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | r |
   |                       | w |
   |                       | i |
   |                       | s |
   |                       | e |
   |                       | , |
   |                       | i |
   |                       | t |
   |                       | m |
   |                       | u |
   |                       | s |
   |                       | t |
   |                       | r |
   |                       | e |
   |                       | t |
   |                       | u |
   |                       | r |
   |                       | n | |                       | ` | |                       | ` |
   |                       | f |
   |                       | a |
   |                       | l |
   |                       | s |
   |                       | e | |                       | ` | |                       | ` |
   |                       | . |
   +-----------------------+---+ | `                     | T | | `\ `ACTION_DRAG_E | h | | NDED`` </reference/an | e |
   | droid/view/DragEvent# | s |
   | ACTION_DRAG_ENDED>`__ | y |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | m |
   |                       | i |
   |                       | s |
   |                       | e |
   |                       | n |
   |                       | d |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | - |
   |                       | a |
   |                       | n |
   |                       | d |
   |                       | - |
   |                       | d |
   |                       | r |
   |                       | o |
   |                       | p |
   |                       | o |
   |                       | p |
   |                       | e |
   |                       | r |
   |                       | a |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | . |
   |                       | T |
   |                       | h |
   |                       | i |
   |                       | s |
   |                       | a |
   |                       | c |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | t |
   |                       | y |
   |                       | p |
   |                       | e |
   |                       | i |
   |                       | s |
   |                       | n |
   |                       | ' |
   |                       | t |
   |                       | n |
   |                       | e |
   |                       | c |
   |                       | e |
   |                       | s |
   |                       | s |
   |                       | a |
   |                       | r |
   |                       | i |
   |                       | l |
   |                       | y |
   |                       | p |
   |                       | r |
   |                       | e |
   |                       | c |
   |                       | e |
   |                       | d |
   |                       | e |
   |                       | d |
   |                       | b |
   |                       | y |
   |                       | a |
   |                       | n |
   |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | O |
   |                       | P | |                       | ` | |                       | ` |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | . |
   |                       | I |
   |                       | f |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | s |
   |                       | y |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | m |
   |                       | s |
   |                       | e |
   |                       | n |
   |                       | d |
   |                       | s |
   |                       | a |
   |                       | n | |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | O |
   |                       | P | |                       | ` | |                       | ` |
   |                       | , |
   |                       | r |
   |                       | e |
   |                       | c |
   |                       | e |
   |                       | i |
   |                       | v |
   |                       | i |
   |                       | n |
   |                       | g |
   |                       | t |
   |                       | h |
   |                       | e | |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | A |
   |                       | G |
   |                       | _ |
   |                       | E |
   |                       | N |
   |                       | D |
   |                       | E |
   |                       | D | |                       | ` | |                       | ` |
   |                       | a |
   |                       | c |
   |                       | t |
   |                       | i |
   |                       | o |
   |                       | n |
   |                       | t |
   |                       | y |
   |                       | p |
   |                       | e |
   |                       | d |
   |                       | o |
   |                       | e |
   |                       | s |
   |                       | n |
   |                       | ' |
   |                       | t |
   |                       | i |
   |                       | m |
   |                       | p |
   |                       | l |
   |                       | y |
   |                       | t |
   |                       | h |
   |                       | a |
   |                       | t |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | d |
   |                       | r |
   |                       | o |
   |                       | p |
   |                       | s |
   |                       | u |
   |                       | c |
   |                       | c |
   |                       | e |
   |                       | e |
   |                       | d |
   |                       | e |
   |                       | d |
   |                       | . |
   |                       | T |
   |                       | h |
   |                       | e |
   |                       | l |
   |                       | i |
   |                       | s |
   |                       | t |
   |                       | e |
   |                       | n |
   |                       | e |
   |                       | r |
   |                       | m |
   |                       | u |
   |                       | s |
   |                       | t |
   |                       | c |
   |                       | a |
   |                       | l |
   |                       | l | |                       | ` | |                       | ` | |                       | ` |
   |                       | g |
   |                       | e |
   |                       | t |
   |                       | R |
   |                       | e |
   |                       | s |
   |                       | u |
   |                       | l |
   |                       | t |
   |                       | ( |
   |                       | ) | |                       | ` | |                       | ` |
   |                       |   |
   |                       | < |
   |                       | / |
   |                       | r |
   |                       | e |
   |                       | f |
   |                       | e |
   |                       | r |
   |                       | e |
   |                       | n |
   |                       | c |
   |                       | e |
   |                       | / |
   |                       | a |
   |                       | n |
   |                       | d |
   |                       | r |
   |                       | o |
   |                       | i |
   |                       | d |
   |                       | / |
   |                       | v |
   |                       | i |
   |                       | e |
   |                       | w |
   |                       | / |
   |                       | D |
   |                       | r |
   |                       | a |
   |                       | g |
   |                       | E |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | # |
   |                       | g |
   |                       | e |
   |                       | t |
   |                       | R |
   |                       | e |
   |                       | s |
   |                       | u |
   |                       | l |
   |                       | t |
   |                       | ( |
   |                       | ) |
   |                       | > | |                       | ` |
   |                       | _ |
   |                       | _ |
   |                       | , |
   |                       | a |
   |                       | s |
   |                       | s |
   |                       | h |
   |                       | o |
   |                       | w |
   |                       | n |
   |                       | i |
   |                       | n | |                       | ` |
   |                       | t |
   |                       | a |
   |                       | b |
   |                       | l |
   |                       | e |
   |                       | 2 |
   |                       |   |
   |                       | < |
   |                       | # |
   |                       | t |
   |                       | a |
   |                       | b |
   |                       | l |
   |                       | e |
   |                       | 2 |
   |                       | > | |                       | ` |
   |                       | _ |
   |                       | _ |
   |                       | , |
   |                       | t |
   |                       | o |
   |                       | g |
   |                       | e |
   |                       | t |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | v |
   |                       | a |
   |                       | l |
   |                       | u |
   |                       | e |
   |                       | t |
   |                       | h |
   |                       | a |
   |                       | t |
   |                       | i |
   |                       | s |
   |                       | r |
   |                       | e |
   |                       | t |
   |                       | u |
   |                       | r |
   |                       | n |
   |                       | e |
   |                       | d |
   |                       | i |
   |                       | n |
   |                       | r |
   |                       | e |
   |                       | s |
   |                       | p |
   |                       | o |
   |                       | n |
   |                       | s |
   |                       | e |
   |                       | t |
   |                       | o | |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | O |
   |                       | P | |                       | ` | |                       | ` |
   |                       | . |
   |                       | I |
   |                       | f |
   |                       | a |
   |                       | n | |                       | ` | |                       | ` |
   |                       | A |
   |                       | C |
   |                       | T |
   |                       | I |
   |                       | O |
   |                       | N |
   |                       | _ |
   |                       | D |
   |                       | R |
   |                       | O |
   |                       | P | |                       | ` | |                       | ` |
   |                       | e |
   |                       | v |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | i |
   |                       | s |
   |                       | n |
   |                       | ' |
   |                       | t |
   |                       | s |
   |                       | e |
   |                       | n |
   |                       | t |
   |                       | , |
   |                       | t |
   |                       | h |
   |                       | e |
   |                       | n | |                       | ` | |                       | ` |
   |                       | g |
   |                       | e |
   |                       | t |
   |                       | R |
   |                       | e |
   |                       | s |
   |                       | u |
   |                       | l |
   |                       | t |
   |                       | ( |
   |                       | ) | |                       | ` | |                       | ` |
   |                       | r |
   |                       | e |
   |                       | t |
   |                       | u |
   |                       | r |
   |                       | n |
   |                       | s | |                       | ` | |                       | ` |
   |                       | f |
   |                       | a |
   |                       | l |
   |                       | s |
   |                       | e | |                       | ` | |                       | ` |
   |                       | . |
   +-----------------------+---+
 The ``DragEvent`` object also contains the data and metadata that your
   application provides to the system in the call to ``startDragAndDrop()``.
   Some of the data is valid only for certain action types as summarized in
   table 2. For more information about events and their associated data, see the
   section called `A drag-and-drop operation <#DesignDragOperation>`__.

   **Table 2.** Valid DragEvent data by action type

   +----------+----------+----------+----------+----------+----------+----------+
   | `      | `ge    | `      | `        | `        | `getC  | ```      |
   | getActio | tClipDes | getLocal | ``getX() | ``getY() | lipData( | getResul |
   | n()`` </ | cription | State()` | `` </ref | `` </ref | )`` </re | t()`` </ |
   | referenc | ()`` </r | ` </refe | erence/a | erence/a | ference/ | referenc |
   | e/androi | eference | rence/an | ndroid/v | ndroid/v | android/ | e/androi |
   | d/view/D | /android | droid/vi | iew/Drag | iew/Drag | view/Dra | d/view/D |
   | ragEvent | /view/Dr | ew/DragE | Event#ge | Event#ge | gEvent#g | ragEvent | | #getActi | agEvent# | vent#get | tX()>`__ | tY()>`__ | etClipDa | #getResu |
   | on()>`__ | getClipD | LocalSta | value    | value    | ta()>`__ | lt()>`__ |
   | value    | escripti | te()>`__ |          |          | value    | value    |
   |          | on()>`__ | value    |          |          |          |          |
   |          | value    |          |          |          |          |          |
   +==========+==========+==========+==========+==========+==========+==========+
   | ```      | ✓        | ✓        |          |          |          |          |
   | ACTION_D |          |          |          |          |          |          |
   | RAG_STAR |          |          |          |          |          |          |
   | TED`` </ |          |          |          |          |          |          |
   | referenc |          |          |          |          |          |          |
   | e/androi |          |          |          |          |          |          |
   | d/view/D |          |          |          |          |          |          |
   | ragEvent |          |          |          |          |          |          |
   | #ACTION_ |          |          |          |          |          |          |
   | DRAG_STA |          |          |          |          |          |          |
   | RTED>`__ |          |          |          |          |          |          |
   +----------+----------+----------+----------+----------+----------+----------+
   | ```      | ✓        | ✓        |          |          |          |          |
   | ACTION_D |          |          |          |          |          |          |
   | RAG_ENTE |          |          |          |          |          |          |
   | RED`` </ |          |          |          |          |          |          |
   | referenc |          |          |          |          |          |          |
   | e/androi |          |          |          |          |          |          |
   | d/view/D |          |          |          |          |          |          |
   | ragEvent |          |          |          |          |          |          |
   | #ACTION_ |          |          |          |          |          |          |
   | DRAG_ENT |          |          |          |          |          |          |
   | ERED>`__ |          |          |          |          |          |          |
   +----------+----------+----------+----------+----------+----------+----------+
   | ```AC    | ✓        | ✓        | ✓        | ✓        |          |          |
   | TION_DRA |          |          |          |          |          |          |
   | G_LOCATI |          |          |          |          |          |          |
   | ON`` </r |          |          |          |          |          |          |
   | eference |          |          |          |          |          |          |
   | /android |          |          |          |          |          |          |
   | /view/Dr |          |          |          |          |          |          |
   | agEvent# |          |          |          |          |          |          |
   | ACTION_D |          |          |          |          |          |          |
   | RAG_LOCA |          |          |          |          |          |          |
   | TION>`__ |          |          |          |          |          |          |
   +----------+----------+----------+----------+----------+----------+----------+
   | `        | ✓        | ✓        |          |          |          |          | | ``ACTION |          |          |          |          |          |          |
   | _DRAG_EX |          |          |          |          |          |          |
   | ITED`` < |          |          |          |          |          |          |
   | /referen |          |          |          |          |          |          |
   | ce/andro |          |          |          |          |          |          |
   | id/view/ |          |          |          |          |          |          |
   | DragEven |          |          |          |          |          |          |
   | t#ACTION |          |          |          |          |          |          |
   | _DRAG_EX |          |          |          |          |          |          |
   | ITED>`__ |          |          |          |          |          |          |
   +----------+----------+----------+----------+----------+----------+----------+
   | ```      | ✓        | ✓        | ✓        | ✓        | ✓        |          |
   | ACTION_D |          |          |          |          |          |          |
   | ROP`` </ |          |          |          |          |          |          |
   | referenc |          |          |          |          |          |          |
   | e/androi |          |          |          |          |          |          |
   | d/view/D |          |          |          |          |          |          |
   | ragEvent |          |          |          |          |          |          |
   | #ACTION_ |          |          |          |          |          |          |
   | DROP>`__ |          |          |          |          |          |          |
   +----------+----------+----------+----------+----------+----------+----------+
   | ```ACTI  |          | ✓        |          |          |          | ✓        |
   | ON_DRAG_ |          |          |          |          |          |          |
   | ENDED``  |          |          |          |          |          |          |
   | </refere |          |          |          |          |          |          |
   | nce/andr |          |          |          |          |          |          |
   | oid/view |          |          |          |          |          |          |
   | /DragEve |          |          |          |          |          |          |
   | nt#ACTIO |          |          |          |          |          |          |
   | N_DRAG_E |          |          |          |          |          |          |
   | NDED>`__ |          |          |          |          |          |          |
   +----------+----------+----------+----------+----------+----------+----------+

   The ``DragEvent`` methods ``getAction()``,
   `describeContents() <#android.view.DragEvent>`__,
   `writeToParcel() <#android.view.DragEvent>`__,
   and `toString() <#android.view.DragEvent>`__ always
   return valid data.

   If a method doesn't contain valid data for a particular action type, it
   returns ``null`` or 0, depending on its result type.

   .. rubric:: Drag shadow
      :name: AboutDragShadowBuilder

   During a drag-and-drop operation, the system displays an image that the user
   drags. For data movement, this image represents the data being dragged. For
   other operations, the image represents some aspect of the drag operation.

   The image is called a *drag shadow*. You create it with methods you declare
   for a
   `View.DragShadowBuilder <#android.view.View.DragShadowBuilder>`__
   object. You pass the builder to the system when you start a drag-and-drop
   operation using ``startDragAndDrop()``. As part of its response to
   ``startDragAndDrop()``, the system invokes the callback methods you define in
   ``View.DragShadowBuilder`` to obtain a drag shadow.

   The ``View.DragShadowBuilder`` class has two constructors:

   `View.DragShadowBuilder(View) <#android.view.View.DragShadowBuilder>`__
      This constructor accepts any of your application's
      `View <#android.view.View>`__ objects. The constructor
      stores the ``View`` object in the ``View.DragShadowBuilder`` object, so
      the callbacks can access it to construct the drag shadow. The view doesn't
      have to be a ``View`` that the user selects to start the drag operation.

      If you use this constructor, you don't have to extend
      ``View.DragShadowBuilder`` or override its methods. By default, you get a
      drag shadow that has the same appearance as the ``View`` you pass as an
      argument, centered under the location where the user touches the screen.

   `View.DragShadowBuilder() <#android.view.View.DragShadowBuilder>`__
      If you use this constructor, no ``View`` object is available in the
      ``View.DragShadowBuilder`` object. The field is set to ``null``. You must
      extend ``View.DragShadowBuilder`` and override its methods, or else you
      get an invisible drag shadow. The system doesn't throw an error.

   The ``View.DragShadowBuilder`` class has two methods that together create the
   drag shadow:

   `onProvideShadowMetrics() <#android.view.View.DragShadowBuilder>`__
      The system calls this method immediately after you call
      ``startDragAndDrop()``. Use the method to send the dimensions and touch
      point of the drag shadow to the system. The method has two parameters:

      **``outShadowSize``:** a `Point <#android.graphics.Point>`__
      object. The drag shadow width goes in
      `x <#android.graphics.Point>`__, and its height goes in
      `y <#android.graphics.Point>`__.

      **``outShadowTouchPoint``:** a ``Point`` object. The touch point is the
      location within the drag shadow that must be under the user's finger
      during the drag. Its *X* position goes in ``x`` and its *Y* position goes
      in ``y``.

   `onDrawShadow() <#android.view.View.DragShadowBuilder>`__
      Immediately after the call to ``onProvideShadowMetrics()`` the system
      calls ``onDrawShadow()`` to create the drag shadow. The method has a
      single argument, a `Canvas <#android.graphics.Canvas>`__
      object that the system constructs from the parameters you provide in
      ``onProvideShadowMetrics()``. The method draws the drag shadow on the
      provided ``Canvas``.

   To improve performance, keep the size of the drag shadow small. For a single
   item, you might want to use an icon. For a multiple-item selection, you might
   want to use icons in a stack rather than full images spread out over the
   screen.

   .. rubric:: Drag event listeners and callback methods
      :name: AboutDragListeners

   A ``View`` receives drag events with a drag event listener that implements
   ``View.OnDragListener`` or with the view's ``onDragEvent()`` callback method.
   When the system calls the method or listener, it provides a
   `DragEvent <#android.view.DragEvent>`__ argument.

   In most cases, using a listener is preferable to using the callback method.
   When you design UIs, you usually don't subclass ``View`` classes, but using
   the callback method forces you to create subclasses to override the method.
   In comparison, you can implement one listener class and then use it with
   multiple different ``View`` objects. You can also implement it as an
   anonymous inline class or lambda expression. To set the listener for a
   ``View`` object, call ``setOnDragListener()``.

   As an alternative, you can alter the default implementation of
   ``onDragEvent()`` without overriding the method. Set an
   `OnReceiveContentListener <#android.view.OnReceiveContentListener>`__
   on a view; for more details, see
   `setOnReceiveContentListener() <#android.view.View>`__.
   The ``onDragEvent()`` method then does the following by default:

   -  Returns true in response to the call to ``startDragAndDrop()``.

   -  Calls
      `performReceiveContent() <#android.view.View>`__
      if the drag-and-drop data is dropped on the view. The data is passed to
      the method as a `ContentInfo <#android.view.ContentInfo>`__
      object. The method invokes the ``OnReceiveContentListener``.

   -  Returns true if the drag-and-drop data is dropped on the view and the
      ``OnReceiveContentListener`` consumes any of the content.

   Define the ``OnReceiveContentListener`` to handle the data specifically for
   your app. For backward compatibility down to API level 24, use the Jetpack
   version of
   `OnReceiveContentListener <#androidx.core.view.OnReceiveContentListener>`__.

   You can have a drag event listener and a callback method for a ``View``
   object, in which case the system first calls the listener. The system doesn't
   call the callback method unless the listener returns ``false``.

   The combination of the ``onDragEvent()`` method and ``View.OnDragListener``
   is analogous to the combination of the
   `onTouchEvent() <#android.view.View>`__
   and
   `View.OnTouchListener <#android.view.View.OnTouchListener>`__
   used with touch events.

   **Key Term:**\  The following sections refer to the method that receives drag
   events as the drag event *listener*. However, the method can be an
   ``onDragEvent()`` callback, a ``View.OnDragListener`` method, or both.


Last updated 2024-04-16 UTC.


/DropHelper for simplified drag and drop
========================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/drophelper?hl=en

.. container:: devsite-article-body

   The `DropHelper <#androidx.draganddrop.DropHelper>`__ class
   simplifies implementation of drag-and-drop capabilities. A member of the
   Jetpack `DragAndDrop <#>`__ library,
   ``DropHelper`` provides backward compatibility down to API level 24.

   Use ``DropHelper`` to specify drop targets, customize drop target
   highlighting, and define how dropped data is handled.

   .. rubric:: Set drag source
      :name: DragSource

   **Note:**\  See the `Drag-And-Drop sample app <https://github.com/android/user-interface-samples/tree/main/DragAndDrop>`__
   for a complete implementation sample.
   To get started, create
   `DragStartHelper <#androidx.core.view.DragStartHelper>`__ with
   drag source view and
   `OnDragStartListener <#androidx.core.view.DragStartHelper.OnDragStartListener>`__.

   In
   `OnDragStartListener <#androidx.core.view.DragStartHelper.OnDragStartListener>`__,
   override method
   `onDragStart() <#androidx.core.view.DragStartHelper.OnDragStartListener>`__.
   Create a ``ClipData`` object and ``ClipData.Item`` object for the data being
   moved. As part of the ``ClipData``, supply metadata that is stored in a
   ``ClipDescription`` object within the ``ClipData``. For a drag-and-drop
   operation that doesn't represent data movement, you might want to use
   ``null`` instead of an actual object.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               DragStartHelper(draggableView)
                   { view: View, _: DragStartHelper ->
                       val item = ClipData.Item(view.tag as? CharSequence)
                       val dragData = ClipData(
                           view.tag as? CharSequence,
                           arrayOf(ClipDescription.MIMETYPE_TEXT_PLAIN),
                           item
                       )
                       view.startDragAndDrop(
                           dragData,
                           View.DragShadowBuilder(view),
                           null,
                           0
                       )
                   }.attach()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               new DragStartHelper(draggableView, new DragStartHelper.OnDragStartListener() {
                   @Override
                   public void onDragStart(View view, DragStartHelper helper) {
                       CharSequence tag = (CharSequence) view.getTag();
                       ClipData.Item item = new ClipData.Item(tag);
                       ClipData dragData = new ClipData(
                         tag, new String[]{ClipDescription.MIMETYPE_TEXT_PLAIN}, item);
                       view.startDragAndDrop(
                         dragData, new View.DragShadowBuilder(view), null, 0);
                   }
               });

   .. rubric:: Specify drop targets
      :name: DropTargets

   When a user release a drop shadow over a view, the view needs to be
   configured properly to accept the data and respond correctly.

   `DropHelper.configureView() <#androidx.draganddrop.DropHelper>`__
   is a static, overloaded method that lets you specify drop targets. Its
   parameters include the following:

   -  The current `Activity <#android.app.Activity>`__—used for
      `URI permissions <#android.app.Activity>`__.

      -  A `View <#android.view.View>`__ that serves as the drop
         target.

         -  The `MIME types <https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types>`__
            the drop target can accept from the dropped data.

   -  Configuration options for the drop target—in particular, a list of
      `embedded ``EditText`` fields <#EditTextComponentsInDropTargets>`__.
   -  An
      `OnReceiveContentListener <#androidx.core.view.OnReceiveContentListener>`__
      to handle dropped data.

   For example, to create a drop target that accepts images, use either of the
   following method calls:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               configureView(
                   myActivity,
                   targetView,
                   arrayOf("image/*"),
                   options,
                   onReceiveContentListener)

               // or

               configureView(
                   myActivity,
                   targetView,
                   arrayOf("image/*"),
                   onReceiveContentListener)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               DropHelper.configureView(
                   myActivity,
                   targetView,
                   new String[] {"image/*"},
                   options,
                   onReceiveContentlistener);

               // or

               DropHelper.configureView(
                   myActivity,
                   targetView,
                   new String[] {"image/*"},
                   onReceiveContentlistener);

   The second call omits the drop target configuration options, in which case
   the drop target highlight color is set to the theme's secondary (or accent)
   color, the highlight corner radius is set to 16 dp, and the list of
   ``EditText`` components is empty. See the following section for details.

   .. rubric:: Configure drop targets
      :name: DropTargetConfiguration

   The
   `DropHelper.Options <#androidx.draganddrop.DropHelper.Options>`__
   inner class lets you configure drop targets. Provide an instance of the class
   to the
   `DropHelper.configureView(Activity, View, String[], Options, OnReceiveContentListener) <#androidx.draganddrop.DropHelperiew>`__
   method. See the previous section for more information.

   .. rubric:: Customize drop target highlighting
      :name: drop_target_highlighting

   ``DropHelper`` configures drop targets to display a highlight as users drag
   content over the targets. ``DropHelper`` provides default styling, and
   ``DropHelper.Options`` lets you set the color of the highlight and specify
   the corner radius of the highlight's rectangle.

   Use the
   `DropHelper.Options.Builder <#androidx.draganddrop.DropHelper.Options.Builder>`__
   class to create a ``DropHelper.Options`` instance and set configuration
   options, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val options: DropHelper.Options = DropHelper.Options.Builder()
                                                     .setHighlightColor(getColor(R.color.purple_300))
                                                     .setHighlightCornerRadiusPx(resources.getDimensionPixelSize(R.dimen.drop_target_corner_radius))
                                                     .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               DropHelper.Options options = new DropHelper.Options.Builder()
                                                    .setHighlightColor(getColor(R.color.purple_300))
                                                    .setHighlightCornerRadiusPx(getResources().getDimensionPixelSize(R.dimen.drop_target_corner_radius))
                                                    .build();

   .. rubric:: Handle EditText components in drop targets
      :name: EditTextComponentsInDropTargets

   ``DropHelper`` also controls focus within the drop target when the target
   contains editable text fields.

   Drop targets can be a single view or a view hierarchy. If the drop target
   view hierarchy contains one or more
   `EditText <#android.widget.EditText>`__ components, provide a
   list of the components to
   `DropHelper.Options.Builder.addInnerEditTexts(EditText...) <#androidx.draganddrop.DropHelper.Options.Builder>`__
   to ensure that drop target highlighting and text data handling work
   correctly.

   ``DropHelper`` prevents ``EditText`` components within the drop target view
   hierarchy from stealing focus from the containing view during drag
   interactions.

   Also, if the drag-and-drop
   `ClipData <#android.content.ClipData>`__ includes text and URI
   data, ``DropHelper`` selects one of the ``EditText`` components in the drop
   target to handle the text data. Selection is based on the following order of
   precedence:

   #. The ``EditText`` on which the ``ClipData`` is dropped.
   #. The ``EditText`` that contains the text cursor (caret).
   #. The first ``EditText`` provided to the call to
      ``DropHelper.Options.Builder.addInnerEditTexts(EditText...)``.

   To set an ``EditText`` as the default text data handler, pass the
   ``EditText`` as the first argument of the call to
   ``DropHelper.Options.Builder.addInnerEditTexts(EditText...)``. For example,
   if your drop target handles images but contains editable text fields ``T1``,
   ``T2``, and ``T3``, make ``T2`` the default as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val options: DropHelper.Options = DropHelper.Options.Builder()
                                                     .addInnerEditTexts(T2, T1, T3)
                                                     .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               DropHelper.Options options = new DropHelper.Options.Builder()
                                                    .addInnerEditTexts(T2, T1, T3)
                                                    .build();

   .. rubric:: Handle data in drop targets
      :name: drop_target_data_handling

   The ``DropHelper.configureView()`` method accepts an
   ``OnReceiveContentListener`` that you create to handle the drag-and-drop
   ``ClipData``. The drag-and-drop data is provided to the listener in a
   `ContentInfoCompat <#androidx.core.view.ContentInfoCompat>`__
   object. Text data is present in the object. Media, such as images, is
   represented by URIs.

   **Warning:**\  ``DropHelper`` configures the drop target to listen for
   drag-and-drop events and to handle the dropped data. Don't attach a
   `View.OnDragListener <#android.view.View.OnDragListener>`__ or
   ``OnReceiveContentListener`` to drop targets when using ``DropHelper``.
   The ``OnReceiveContentListener`` also handles data provided to the drop
   target by user interactions other than drag-and-drop—such as copy and
   paste—when ``DropHelper.configureView()`` is used to configure the following
   types of views:

   -  All views, if the user is running Android 12 or higher.
   -  `AppCompatEditText <#androidx.appcompat.widget.AppCompatEditText>`__,
      if the user is running a version of Android down to Android 7.0.

   **Note:**\  ``DropHelper`` supports the Jetpack
   `OnReceiveContentListener <#androidx.core.view.OnReceiveContentListener>`__
   interface, which is backward compatible down to API level 24. ``DropHelper``
   doesn't support the platform
   `OnReceiveContentListener <#android.view.OnReceiveContentListener>`__
   interface introduced in API level 31.

   .. rubric:: MIME types, permissions, and content validation
      :name: mime_types

   The MIME type checking by ``DropHelper`` is based on the drag-and-drop
   `ClipDescription <#android.content.ClipDescription>`__, which
   is created by the app providing the drag-and-drop data. Validate the
   ``ClipDescription`` to ensure the MIME types are set correctly.

   ``DropHelper`` requests all access permissions for content URIs contained in
   the drag-and-drop ``ClipData``. For more information, see
   `DragAndDropPermissions <#android.view.DragAndDropPermissions>`__.
   The permissions let you resolve the content URIs when processing the
   drag-and-drop data.

   ``DropHelper`` doesn't validate the data returned by content providers when
   resolving URIs in the dropped data. Check for null and verify the correctness
   of any resolved data.


Last updated 2024-04-22 UTC.


/Implement drag and drop with views
===================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/view?hl=en

.. container:: devsite-article-body

   You can implement your drag-and-drop process in views by responding to events
   that might trigger a drag start and responding and consuming drop events.

   .. rubric:: Start a drag
      :name: StartDrag

   The user starts a drag with a gesture, usually by touching or clicking and
   holding on an item they want to drag.

   To handle this in a ``View``, create a
   `ClipData <#android.content.ClipData>`__ object and
   `ClipData.Item <#android.content.ClipData.Item>`__ object for
   the data being moved. As part of the ``ClipData``, supply metadata that is
   stored in a
   `ClipDescription <#android.content.ClipDescription>`__ object
   within the ``ClipData``. For a drag-and-drop operation that doesn't represent
   data movement, you might want to use ``null`` instead of an actual object.

   For example, this code snippet shows how to respond to a touch & hold gesture
   on an ``ImageView`` by creating a ``ClipData`` object that contains the tag
   (or label) of an ``ImageView``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a string for the ImageView label.
               val IMAGEVIEW_TAG = "icon bitmap"
               ...
               val imageView = ImageView(context).apply {
                   // Set the bitmap for the ImageView from an icon bitmap defined elsewhere.
                   setImageBitmap(iconBitmap)
                   tag = IMAGEVIEW_TAG
                   setOnLongClickListener { v ->
                       // Create a new ClipData. This is done in two steps to provide
                       // clarity. The convenience method ClipData.newPlainText() can
                       // create a plain text ClipData in one step.

                       // Create a new ClipData.Item from the ImageView object's tag.
                       val item = ClipData.Item(v.tag as? CharSequence)

                       // Create a new ClipData using the tag as a label, the plain text
                       // MIME type, and the already-created item. This creates a new
                       // ClipDescription object within the ClipData and sets its MIME type
                       // to "text/plain".
                       val dragData = ClipData(
                           v.tag as? CharSequence,
                           arrayOf(ClipDescription.MIMETYPE_TEXT_PLAIN),
                           item)

                       // Instantiate the drag shadow builder. We use this imageView object
                       // to create the default builder.
                       val myShadow = View.DragShadowBuilder(view: this)

                       // Start the drag.
                       v.startDragAndDrop(dragData,  // The data to be dragged.
                                           myShadow,  // The drag shadow builder.
                                           null,      // No need to use local data.
                                           0          // Flags. Not currently used, set to 0.
                       )

                       // Indicate that the long-click is handled.
                       true
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a string for the ImageView label.
               private static final String IMAGEVIEW_TAG = "icon bitmap";
               ...
               // Create a new ImageView.
               ImageView imageView = new ImageView(context);

               // Set the bitmap for the ImageView from an icon bitmap defined elsewhere.
               imageView.setImageBitmap(iconBitmap);

               // Set the tag.
               imageView.setTag(IMAGEVIEW_TAG);

               // Set a long-click listener for the ImageView using an anonymous listener
               // object that implements the OnLongClickListener interface.
               imageView.setOnLongClickListener( v -> {

                   // Create a new ClipData. This is done in two steps to provide clarity. The
                   // convenience method ClipData.newPlainText() can create a plain text
                   // ClipData in one step.

                   // Create a new ClipData.Item from the ImageView object's tag.
                   ClipData.Item item = new ClipData.Item((CharSequence) v.getTag());

                   // Create a new ClipData using the tag as a label, the plain text MIME type,
                   // and the already-created item. This creates a new ClipDescription object
                   // within the ClipData and sets its MIME type to "text/plain".
                   ClipData dragData = new ClipData(
                           (CharSequence) v.getTag(),
                           new String[] { ClipDescription.MIMETYPE_TEXT_PLAIN },
                           item);

                   // Instantiate the drag shadow builder. We use this imageView object
                   // to create the default builder.
                   View.DragShadowBuilder myShadow = new View.DragShadowBuilder(imageView);

                   // Start the drag.
                   v.startDragAndDrop(dragData,  // The data to be dragged.
                                           myShadow,  // The drag shadow builder.
                                           null,      // No need to use local data.
                                           0          // Flags. Not currently used, set to 0.
                   );

                   // Indicate that the long-click is handled.
                   return true;
               });

   .. rubric:: Respond to a drag start
      :name: HandleStart

   During the drag operation, the system dispatches drag events to the drag
   event listeners of the ``View`` objects in the current layout. The listeners
   react by calling ``DragEvent.getAction()`` to get the action type. At the
   start of a drag, this method returns ``ACTION_DRAG_STARTED``.

   In response to an event with the action type ``ACTION_DRAG_STARTED``, a drag
   event listener must do the following:

   #. Call
      `DragEvent.getClipDescription() <#android.view.DragEvent>`__
      and use the MIME type methods in the returned ``ClipDescription`` to see
      whether the listener can accept the data being dragged.

      If the drag-and-drop operation doesn't represent data movement, this might
      be unnecessary.

   #. If the drag event listener can accept a drop, it must return ``true`` to
      tell the system to continue to send drag events to the listener. If the
      listener can't accept a drop, the listener must return ``false``, and the
      system stops sending drag events to the listener until the system sends
      ``ACTION_DRAG_ENDED`` to conclude the drag-and-drop operation.

   For an ``ACTION_DRAG_STARTED`` event, the following ``DragEvent`` methods
   aren't valid:
   `getClipData() <#android.view.DragEvent>`__,
   `getX() <#android.view.DragEvent>`__,
   `getY() <#android.view.DragEvent>`__, and
   `getResult() <#android.view.DragEvent>`__.

   .. rubric:: Handle events during the drag
      :name: HandleDuring

   During the drag action, drag event listeners that return ``true`` in response
   to the ``ACTION_DRAG_STARTED`` drag event continue to receive drag events.
   The types of drag events a listener receives during the drag depend on the
   location of the drag shadow and the visibility of the listener's ``View``.
   Listeners use the drag events primarily to decide if they must change the
   appearance of their ``View``.

   During the drag action, ``DragEvent.getAction()`` returns one of three
   values:

   -  `ACTION_DRAG_ENTERED <#android.view.DragEvent>`__:
      the listener receives this event action type when the touch point—the
      point on the screen underneath the user's finger or mouse—enters the
      bounding box of the listener's ``View``.
   -  `ACTION_DRAG_LOCATION <#android.view.DragEvent>`__:
      once the listener receives an ``ACTION_DRAG_ENTERED`` event, it receives a
      new ``ACTION_DRAG_LOCATION`` event every time the touch point moves until
      it receives an ``ACTION_DRAG_EXITED`` event. The ``getX()`` and ``getY()``
      methods return the X and Y coordinates of the touch point.
   -  `ACTION_DRAG_EXITED <#android.view.DragEvent>`__:
      this event action type is sent to a listener that previously receives
      ``ACTION_DRAG_ENTERED``. The event is sent when the drag shadow touch
      point moves from within the bounding box of the listener's ``View`` to
      outside the bounding box.

   The drag event listener doesn't need to react to any of these action types.
   If the listener returns a value to the system, it is ignored.

   Here are some guidelines for responding to each of these action types:

   -  In response to ``ACTION_DRAG_ENTERED`` or ``ACTION_DRAG_LOCATION``, the
      listener can change the appearance of the ``View`` to indicate that the
      view is a potential drop target.
   -  An event with the action type ``ACTION_DRAG_LOCATION`` contains valid data
      for ``getX()`` and ``getY()`` corresponding to the location of the touch
      point. The listener can use this information to alter the ``View``
      appearance at the touch point or to determine the exact position where the
      user can drop the content.
   -  In response to ``ACTION_DRAG_EXITED``, the listener must reset any
      appearance changes it applies in response to ``ACTION_DRAG_ENTERED`` or
      ``ACTION_DRAG_LOCATION``. This indicates to the user that the ``View`` is
      no longer an imminent drop target.

   .. rubric:: Respond to a drop
      :name: HandleDrop

   When the user releases the drag shadow over a ``View``, and the ``View``
   previously reports that it can accept the content being dragged, the system
   dispatches a drag event to the ``View`` with the action type ``ACTION_DROP``.

   The drag event listener must do the following:

   #. Call ``getClipData()`` to get the ``ClipData`` object that is originally
      supplied in the call to
      `startDragAndDrop() <#android.view.View>`__
      and process the data. If the drag-and-drop operation doesn't represent
      data movement, this is unnecessary.

   #. Return boolean ``true`` to indicate that the drop is processed
      successfully, or ``false`` if it isn't. The returned value becomes the
      value returned by ``getResult()`` for the eventual ``ACTION_DRAG_ENDED``
      event. If the system doesn't send out an ``ACTION_DROP`` event, the value
      returned by ``getResult()`` for an ``ACTION_DRAG_ENDED`` event is
      ``false``.

   For an ``ACTION_DROP`` event, ``getX()`` and ``getY()`` use the coordinate
   system of the ``View`` that receives the drop to return the *X* and *Y*
   position of the touch point at the moment of the drop.

   While the user is able to release the drag shadow over a ``View`` whose drag
   event listener isn't receiving drag events, empty regions of your app's UI or
   even over areas outside of your application, Android won't send an event with
   action type ``ACTION_DROP`` and will only send an ``ACTION_DRAG_ENDED``
   event.

   .. rubric:: Respond to a drag end
      :name: respond_to_a_drag_end

   Immediately after the user releases the drag shadow, the system sends a drag
   event with an action type of ``ACTION_DRAG_ENDED`` to all the drag event
   listeners in your application. This indicates that the drag operation is
   finished.

   Each drag event listener must do the following:

   #. If the listener changes its appearance during the operation, it should
      reset back to its default appearance as a visual indication to the user
      that the operation is finished.
   #. The listener can optionally call ``getResult()`` to find out more about
      the operation. If a listener returns ``true`` in response to an event of
      action type ``ACTION_DROP``, then ``getResult()`` returns boolean
      ``true``. In all other cases, ``getResult()`` returns boolean ``false``,
      including when the system doesn't send an ``ACTION_DROP`` event.
   #. To indicate the successful completion of the drop operation, the listener
      should return boolean ``true`` to the system. By not returning ``false``,
      a visual cue showing the drop shadow returning to its source may suggest
      to the user that the operation was unsuccessful.

   .. rubric:: Respond to drag events: An example
      :name: RespondEventSample

   All drag events are received by your drag event method or listener. The
   following code snippet is an example of responding to drag events:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val imageView = ImageView(this)

               // Set the drag event listener for the View.
               imageView.setOnDragListener { v, e ->

                   // Handle each of the expected events.
                   when (e.action) {
                       DragEvent.ACTION_DRAG_STARTED -> {
                           // Determine whether this View can accept the dragged data.
                           if (e.clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) {
                               // As an example, apply a blue color tint to the View to
                               // indicate that it can accept data.
                               (v as? ImageView)?.setColorFilter(Color.BLUE)

                               // Invalidate the view to force a redraw in the new tint.
                               v.invalidate()

                               // Return true to indicate that the View can accept the dragged
                               // data.
                               true
                           } else {
                               // Return false to indicate that, during the current drag and
                               // drop operation, this View doesn't receive events again until
                               // ACTION_DRAG_ENDED is sent.
                               false
                           }
                       }
                       DragEvent.ACTION_DRAG_ENTERED -> {
                           // Apply a green tint to the View.
                           (v as? ImageView)?.setColorFilter(Color.GREEN)

                           // Invalidate the view to force a redraw in the new tint.
                           v.invalidate()

                           // Return true. The value is ignored.
                           true
                       }

                       DragEvent.ACTION_DRAG_LOCATION ->
                           // Ignore the event.
                           true
                       DragEvent.ACTION_DRAG_EXITED -> {
                           // Reset the color tint to blue.
                           (v as? ImageView)?.setColorFilter(Color.BLUE)

                           // Invalidate the view to force a redraw in the new tint.
                           v.invalidate()

                           // Return true. The value is ignored.
                           true
                       }
                       DragEvent.ACTION_DROP -> {
                           // Get the item containing the dragged data.
                           val item: ClipData.Item = e.clipData.getItemAt(0)

                           // Get the text data from the item.
                           val dragData = item.text

                           // Display a message containing the dragged data.
                           Toast.makeText(this, "Dragged data is $dragData", Toast.LENGTH_LONG).show()

                           // Turn off color tints.
                           (v as? ImageView)?.clearColorFilter()

                           // Invalidate the view to force a redraw.
                           v.invalidate()

                           // Return true. DragEvent.getResult() returns true.
                           true
                       }

                       DragEvent.ACTION_DRAG_ENDED -> {
                           // Turn off color tinting.
                           (v as? ImageView)?.clearColorFilter()

                           // Invalidate the view to force a redraw.
                           v.invalidate()

                           // Do a getResult() and display what happens.
                           when(e.result) {
                               true ->
                                   Toast.makeText(this, "The drop was handled.", Toast.LENGTH_LONG)
                               else ->
                                   Toast.makeText(this, "The drop didn't work.", Toast.LENGTH_LONG)
                           }.show()

                           // Return true. The value is ignored.
                           true
                       }
                       else -> {
                           // An unknown action type is received.
                           Log.e("DragDrop Example", "Unknown action type received by View.OnDragListener.")
                           false
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               View imageView = new ImageView(this);

               // Set the drag event listener for the View.
               imageView.setOnDragListener( (v, e) -> {

                   // Handle each of the expected events.
                   switch(e.getAction()) {

                       case DragEvent.ACTION_DRAG_STARTED:

                           // Determine whether this View can accept the dragged data.
                           if (e.getClipDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) {

                               // As an example, apply a blue color tint to the View to
                               // indicate that it can accept data.
                               ((ImageView)v).setColorFilter(Color.BLUE);

                               // Invalidate the view to force a redraw in the new tint.
                               v.invalidate();

                               // Return true to indicate that the View can accept the dragged
                               // data.
                               return true;

                           }

                           // Return false to indicate that, during the current drag-and-drop
                           // operation, this View doesn't receive events again until
                           // ACTION_DRAG_ENDED is sent.
                           return false;

                       case DragEvent.ACTION_DRAG_ENTERED:

                           // Apply a green tint to the View.
                           ((ImageView)v).setColorFilter(Color.GREEN);

                           // Invalidate the view to force a redraw in the new tint.
                           v.invalidate();

                           // Return true. The value is ignored.
                           return true;

                       case DragEvent.ACTION_DRAG_LOCATION:

                           // Ignore the event.
                           return true;

                       case DragEvent.ACTION_DRAG_EXITED:

                           // Reset the color tint to blue.
                           ((ImageView)v).setColorFilter(Color.BLUE);

                           // Invalidate the view to force a redraw in the new tint.
                           v.invalidate();

                           // Return true. The value is ignored.
                           return true;

                       case DragEvent.ACTION_DROP:

                           // Get the item containing the dragged data.
                           ClipData.Item item = e.getClipData().getItemAt(0);

                           // Get the text data from the item.
                           CharSequence dragData = item.getText();

                           // Display a message containing the dragged data.
                           Toast.makeText(this, "Dragged data is " + dragData, Toast.LENGTH_LONG).show();

                           // Turn off color tints.
                           ((ImageView)v).clearColorFilter();

                           // Invalidate the view to force a redraw.
                           v.invalidate();

                           // Return true. DragEvent.getResult() returns true.
                           return true;

                       case DragEvent.ACTION_DRAG_ENDED:

                           // Turn off color tinting.
                           ((ImageView)v).clearColorFilter();

                           // Invalidate the view to force a redraw.
                           v.invalidate();

                           // Do a getResult() and displays what happens.
                           if (e.getResult()) {
                               Toast.makeText(this, "The drop was handled.", Toast.LENGTH_LONG).show();
                           } else {
                               Toast.makeText(this, "The drop didn't work.", Toast.LENGTH_LONG).show();
                           }

                           // Return true. The value is ignored.
                           return true;

                       // An unknown action type is received.
                       default:
                           Log.e("DragDrop Example","Unknown action type received by View.OnDragListener.");
                           break;
                   }

                   return false;

               });

   .. rubric:: Customize a drag shadow
      :name: CustomizeDragShadow

   You can define a customized ``myDragShadowBuilder`` by overriding the methods
   in ``View.DragShadowBuilder``. The following code snippet creates a small,
   rectangular, gray drag shadow for a ``TextView``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private class MyDragShadowBuilder(view: View) : View.DragShadowBuilder(view) {

                   private val shadow = ColorDrawable(Color.LTGRAY)

                   // Define a callback that sends the drag shadow dimensions and touch point
                   // back to the system.
                   override fun onProvideShadowMetrics(size: Point, touch: Point) {

                           // Set the width of the shadow to half the width of the original
                           // View.
                           val width: Int = view.width / 2

                           // Set the height of the shadow to half the height of the original
                           // View.
                           val height: Int = view.height / 2

                           // The drag shadow is a ColorDrawable. Set its dimensions to
                           // be the same as the Canvas that the system provides. As a result,
                           // the drag shadow fills the Canvas.
                           shadow.setBounds(0, 0, width, height)

                           // Set the size parameter's width and height values. These get back
                           // to the system through the size parameter.
                           size.set(width, height)

                           // Set the touch point's position to be in the middle of the drag
                           // shadow.
                           touch.set(width / 2, height / 2)
                   }

                   // Define a callback that draws the drag shadow in a Canvas that the system
                   // constructs from the dimensions passed to onProvideShadowMetrics().
                   override fun onDrawShadow(canvas: Canvas) {

                           // Draw the ColorDrawable on the Canvas passed in from the system.
                           shadow.draw(canvas)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static class MyDragShadowBuilder extends View.DragShadowBuilder {

                   // The drag shadow image, defined as a drawable object.
                   private static Drawable shadow;

                   // Constructor.
                   public MyDragShadowBuilder(View view) {

                           // Store the View parameter.
                           super(view);

                           // Create a draggable image that fills the Canvas provided by the
                           // system.
                           shadow = new ColorDrawable(Color.LTGRAY);
                   }

                   // Define a callback that sends the drag shadow dimensions and touch point
                   // back to the system.
                   @Override
                   public void onProvideShadowMetrics (Point size, Point touch) {

                           // Define local variables.
                           int width, height;

                           // Set the width of the shadow to half the width of the original
                           // View.
                           width = getView().getWidth() / 2;

                           // Set the height of the shadow to half the height of the original
                           // View.
                           height = getView().getHeight() / 2;

                           // The drag shadow is a ColorDrawable. Set its dimensions to
                           // be the same as the Canvas that the system provides. As a result,
                           // the drag shadow fills the Canvas.
                           shadow.setBounds(0, 0, width, height);

                           // Set the size parameter's width and height values. These get back
                           // to the system through the size parameter.
                           size.set(width, height);

                           // Set the touch point's position to be in the middle of the drag
                           // shadow.
                           touch.set(width / 2, height / 2);
                   }

                   // Define a callback that draws the drag shadow in a Canvas that the system
                   // constructs from the dimensions passed to onProvideShadowMetrics().
                   @Override
                   public void onDrawShadow(Canvas canvas) {

                           // Draw the ColorDrawable on the Canvas passed in from the system.
                           shadow.draw(canvas);
                   }
               }

   **Note:**\  You don't have to extend ``View.DragShadowBuilder``. The
   constructor
   `View.DragShadowBuilder(View) <#android.view.View.DragShadowBuilder>`__
   creates a default drag shadow that's the same size as the ``View`` argument
   passed to it. The constructor also centers the touch point in the drag
   shadow.


Last updated 2024-04-27 UTC.


/Drag and drop in multi-window mode
===================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/drag-drop/multi-window?hl=en

.. container:: devsite-article-body

   Devices that run Android 7.0 (API level 24) or higher support `multi-window mode <#>`__, which lets users
   move data from one app to another by dragging and dropping.

   The *source app*, where the operation starts, provides the data. The *target
   app*, where the operation ends, receives the data.

   When the user starts to drag content, the source app should set the
   `DRAG_FLAG_GLOBAL <#android.view.View>`__ flag
   to indicate that the user can drag data to another app.

   Because the data moves across app boundaries, the apps share access to the
   data using a content URI. This requires the following:

   -  The source app must set either or both of the
      `DRAG_FLAG_GLOBAL_URI_READ <#android.view.View>`__
      and
      `DRAG_FLAG_GLOBAL_URI_WRITE <#android.view.View>`__
      flags, depending on the read or write access to the data that the source
      app wants to grant to the target app.
   -  The target app must call
      `requestDragAndDropPermissions() <#android.app.Activity>`__
      immediately before handling the data that the user drags into the app. If
      the target app no longer needs access to the dragged data, the app can
      then call
      `release() <#android.view.DragAndDropPermissions>`__
      on the object that was returned from ``requestDragAndDropPermissions()``.
      Otherwise, the permissions are released when the containing activity is
      destroyed. If your implementation involves starting a new Activity to
      process the dropped URIs, you will need to grant the new Activity the same
      permissions. You must set the clip data and a flag:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  intent.setClipData(clipData)
                  intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  intent.setClipData(clipData);
                  intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

   The following code snippets demonstrate how to release read-only access to
   dragged data immediately after the user drop operation takes place. See the
   `Drag-And-Drop sample <https://github.com/android/user-interface-samples/tree/main/DragAndDrop>`__
   on GitHub for a more complete example.

   .. rubric:: Source activity
      :name: source_drag_and_drop_activity

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Drag a file stored in an images/ directory in internal storage.
               val internalImagesDir = File(context.filesDir, "images")
               val imageFile = File(internalImagesDir, imageFilename)
               val uri = FileProvider.getUriForFile(context, contentAuthority, imageFile)

               val listener = OnDragStartListener@{ view: View, _: DragStartHelper ->
                   val clipData = ClipData(ClipDescription("Image Description",
                                                           arrayOf("image/*")),
                                           ClipData.Item(uri))
                   // Must include DRAG_FLAG_GLOBAL to permit dragging data between apps.
                   // This example provides read-only access to the data.
                   val flags = View.DRAG_FLAG_GLOBAL or View.DRAG_FLAG_GLOBAL_URI_READ
                   return@OnDragStartListener view.startDragAndDrop(clipData,
                                                                    View.DragShadowBuilder(view),
                                                                    null,
                                                                    flags)
               }

               // Container where the image originally appears in the source app.
               val srcImageView = findViewById<ImageView>(R.id.imageView)

               // Detect and start the drag event.
               DragStartHelper(srcImageView, listener).apply {
                   attach()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Drag a file stored in an images/ directory in internal storage.
               File internalImagesDir = new File(context.getFilesDir(), "images");
               File imageFile = new File(internalImagesDir, imageFilename);
               final Uri uri = FileProvider.getUriForFile(context, contentAuthority, imageFile);

               // Container where the image originally appears in the source app.
               ImageView srcImageView = findViewById(R.id.imageView);

               // Enable the view to detect and start the drag event.
               new DragStartHelper(srcImageView, (view, helper) -> {
                   ClipData clipData = new ClipData(new ClipDescription("Image Description",
                                                                         new String[] {"image/*"}),
                                                    new ClipData.Item(uri));
                   // Must include DRAG_FLAG_GLOBAL to permit dragging data between apps.
                   // This example provides read-only access to the data.
                   int flags = View.DRAG_FLAG_GLOBAL | View.DRAG_FLAG_GLOBAL_URI_READ;
                   return view.startDragAndDrop(clipData,
                                                new View.DragShadowBuilder(view),
                                                null,
                                                flags);
               }).attach();

   .. rubric:: Target activity
      :name: target_drag_and_drop_activity

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Container where the image is to be dropped in the target app.
               val targetImageView = findViewById<ImageView>(R.id.imageView)

               targetImageView.setOnDragListener { view, event ->

                   when (event.action) {

                       ACTION_DROP -> {
                           val imageItem: ClipData.Item = event.clipData.getItemAt(0)
                           val uri = imageItem.uri

                           // Request permission to access the image data being dragged into
                           // the target activity's ImageView element.
                           val dropPermissions = requestDragAndDropPermissions(event)
                           (view as ImageView).setImageURI(uri)

                           // Release the permission immediately afterward because it's no
                           // longer needed.
                           dropPermissions.release()
                           return@setOnDragListener true
                       }

                       // Implement logic for other DragEvent cases here.

                       // An unknown action type is received.
                       else -> {
                           Log.e("DragDrop Example", "Unknown action type received by View.OnDragListener.")
                           return@setOnDragListener false
                       }

                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Container where the image is to be dropped in the target app.
               ImageView targetImageView = findViewById(R.id.imageView);

               targetImageView.setOnDragListener( (view, event) -> {

                   switch (event.getAction()) {

                       case ACTION_DROP:
                           ClipData.Item imageItem = event.getClipData().getItemAt(0);
                           Uri uri = imageItem.getUri();

                           // Request permission to access the image data being dragged into
                           // the target activity's ImageView element.
                           DragAndDropPermissions dropPermissions =
                               requestDragAndDropPermissions(event);

                           ((ImageView)view).setImageURI(uri);

                           // Release the permission immediately afterward because it's no
                           // longer needed.
                           dropPermissions.release();

                           return true;

                       // Implement logic for other DragEvent cases here.

                       // An unknown action type was received.
                       default:
                           Log.e("DragDrop Example","Unknown action type received by View.OnDragListener.");
                           break;
                   }

                   return false;
               });


Last updated 2024-04-16 UTC.


/Accept rich content from any source
====================================

.. https://developer.android.google.cn/develop/ui/views/receive-rich-content?hl=en

.. container:: devsite-article-body

   .. figure::
      https://developer.android.google.cn/static/images/develop/ui/views/copy-paste-drag-and-drop-in-split-screen.png
      :width: 260px

      **Figure 1.** The unified API provides a single place to handle incoming
      content regardless of the specific UI mechanism, such as pasting from the
      touch & hold menu or using drag-and-drop.

   Users love images, videos, and other expressive content, but inserting and
   moving this content in apps isn't always easy. To make it simpler for apps to
   receive rich content, Android 12 (API level 31) introduces a unified API that
   lets your app accept content from any source: clipboard, keyboard, or
   dragging.

   You can attach an interface, such as
   `OnReceiveContentListener <#android.view.OnReceiveContentListener>`__,
   to UI components and get a callback when content is inserted through any
   mechanism. The callback becomes the single place for your code to handle
   receiving all content, from plain and styled text to markup, images, videos,
   audio files, and others.

   For backward compatibility with previous Android versions, this API is also
   available in AndroidX, starting from `Core 1.7 <#1.7.0>`__ and `Appcompat 1.4 <#1.4.0>`__, which we recommend you
   use when implementing this functionality.

   .. rubric:: Overview
      :name: overview
      :class: clear

   With other existing APIs, each UI mechanism—such as the touch & hold menu or
   dragging—has its own corresponding API. This means that you have to integrate
   with each API separately, adding similar code for each mechanism that inserts
   content:

   .. figure:: https://developer.android.google.cn/static/images/develop/ui/views/required-apis-before.svg
      name: previous-app
      :alt: An image showing the different actions and the relative API to
      implement
      :width: 80.0%

      **Figure 2.** Previously, apps implemented a different API for each UI
      mechanism for inserting content.

   The ``OnReceiveContentListener`` API consolidates these different code paths
   by creating a single API to implement, so you can focus on your app-specific
   logic and let the platform handle the rest:

   .. figure:: https://developer.android.google.cn/static/images/develop/ui/views/required-apis-after.svg
      name: unified
      :alt: An image showing the simplified unified API
      :width: 100.0%

      **Figure 3.** The unified API lets you implement a single API that
      supports all UI mechanisms.

   This approach also means that when new ways of inserting content are added to
   the platform, you don't need to make additional code changes to enable
   support in your app. And if your app needs to implement full customization
   for a particular use case, you can still use the existing APIs, which
   continue to work the same way.

   .. rubric:: Implementation
      :name: implementation

   **Note:**\  See the `Drag and Drop sample <https://github.com/android/platform-samples/tree/main/samples/user-interface/draganddrop>`__
   for a complete implementation of
   `DropHelper <#>`__, which
   implements ``OnReceiveContentListener``. For more details, see the guide on
   `Enabling drag and drop <#>`__.
   The API is a listener interface with a single method,
   `OnReceiveContentListener <#android.view.OnReceiveContentListener>`__.
   To support older versions of the Android platform, we recommend using the
   matching
   `OnReceiveContentListener <#androidx.core.view.OnReceiveContentListener>`__
   interface in the AndroidX Core library.

   To use the API, implement the listener by specifying what types of content
   your app can handle:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               object MyReceiver : OnReceiveContentListener {
                   val MIME_TYPES = arrayOf("image/*", "video/*")
                   
                   // ...
                   
                   override fun onReceiveContent(view: View, payload: ContentInfoCompat): ContentInfoCompat? {
                       TODO("Not yet implemented")
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyReceiver implements OnReceiveContentListener {
                    public static final String[] MIME_TYPES = new String[] {"image/*", "video/*"};
                    // ...
               }

   After specifying all the content MIME types that your app supports, implement
   the rest of the listener:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyReceiver : OnReceiveContentListener {
                   override fun onReceiveContent(view: View, contentInfo: ContentInfoCompat): ContentInfoCompat {
                       val split = contentInfo.partition { item: ClipData.Item -> item.uri != null }
                       val uriContent = split.first
                       val remaining = split.second
                       if (uriContent != null) {
                           // App-specific logic to handle the URI(s) in uriContent.
                       }
                       // Return anything that your app didn't handle. This preserves the
                       // default platform behavior for text and anything else that you aren't
                       // implementing custom handling for.
                       return remaining
                   }

                   companion object {
                       val MIME_TYPES = arrayOf("image/*", "video/*")
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                public class MyReceiver implements OnReceiveContentListener {
                    public static final String[] MIME_TYPES = new String[] {"image/*", "video/*"};

                    @Override
                    public ContentInfoCompat onReceiveContent(View view, ContentInfoCompat contentInfo) {
                        Pair split = contentInfo.partition(
                                item -> item.getUri() != null);
                        ContentInfo uriContent = split.first;
                        ContentInfo remaining = split.second;
                        if (uriContent != null) {
                            // App-specific logic to handle the URI(s) in uriContent.
                        }
                        // Return anything that your app didn't handle. This preserves the
                        // default platform behavior for text and anything else that you aren't
                        // implementing custom handling for.
                        return remaining;
                    }
                }

   If your app already supports sharing with intents, you can reuse your
   app-specific logic for handling content URIs. Return any remaining data to
   delegate handling of that data to the platform.

   After implementing the listener, set it on the appropriate UI elements in
   your app:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyActivity : Activity() {
                   public override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       // ...
                       val myInput = findViewById(R.id.my_input)
                       ViewCompat.setOnReceiveContentListener(myInput, MyReceiver.MIME_TYPES, MyReceiver())
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyActivity extends Activity {
                    @Override
                    public void onCreate(Bundle savedInstanceState) {
                        // ...

                        AppCompatEditText myInput = findViewById(R.id.my_input);
                        ViewCompat.setOnReceiveContentListener(myInput, MyReceiver.MIME_TYPES, new MyReceiver());
                    }
               }

   .. rubric:: URI permissions
      :name: uri-permissions

   Read permissions are granted and released automatically by the platform for
   any `content URIs <#android.content.ContentResolver>`__ in the
   payload passed to the ``OnReceiveContentListener``.

   Normally, your app processes content URIs in a service or activity. For
   long-running processing, use
   `WorkManager <#>`__. When you
   implement this, extend permissions to the target service or activity by
   passing the content using
   `Intent.setClipData <#android.content.Intent>`__
   and `setting <#android.content.Intent>`__ the flag
   `FLAG_GRANT_READ_URI_PERMISSION <#android.content.Intent>`__.

   Alternatively, you can use a background thread within the current context to
   process the content. In this case, you must maintain a reference to the
   ``payload`` object received by the listener to help ensure that permissions
   aren't revoked prematurely by the platform.

   .. rubric:: Custom views
      :name: custom-views

   If your app uses a custom ``View`` subclass, take care to ensure that the
   ``OnReceiveContentListener`` isn't bypassed.

   If your ``View`` class overrides the
   `onCreateInputConnection <#android.widget.TextView>`__
   method, use the Jetpack API
   `InputConnectionCompat.createWrapper <#androidx.core.view.inputmethod.InputConnectionCompat>`__
   to configure the ``InputConnection``.

   If your ``View`` class overrides the
   `onTextContextMenuItem <#android.widget.TextView>`__
   method, delegate to super when the menu item is
   `R.id.paste <#android.R.id>`__ or
   `R.id.pasteAsPlainText <#android.R.id>`__.

   .. rubric:: Comparison with the keyboard image API
      :name: comparison

   You can think of the ``OnReceiveContentListener`` API as the next version of
   the existing `keyboard image API <#>`__. This
   unified API supports the functionality of the keyboard image API as well as
   some additional features. Device and feature compatibility varies depending
   on whether you use the Jetpack library or the native APIs from the Android
   SDK.

   .. table:: **Table 1.** Supported features and API levels for Jetpack.

      +-------------------------+-------------------------+-------------------------+
      | Action or feature       | Supported by keyboard   | Supported by unified    |
      |                         | image API               | API                     |
      +=========================+=========================+=========================+
      | Insert from the         | Yes (API level 13 and   | Yes (API level 13 and   |
      | keyboard                | higher)                 | higher)                 |
      +-------------------------+-------------------------+-------------------------+
      | Insert using paste from | No                      | Yes                     |
      | the touch & hold menu   |                         |                         |
      +-------------------------+-------------------------+-------------------------+
      | Insert using            | No                      | Yes (API level 24 and   |
      | drag-and-drop           |                         | higher)                 |
      +-------------------------+-------------------------+-------------------------+

   .. table:: **Table 2.** Supported features and API levels for native APIs.

      +-------------------------+-------------------------+-------------------------+
      | Action or feature       | Supported by keyboard   | Supported by unified    |
      |                         | image API               | API                     |
      +=========================+=========================+=========================+
      | Insert from the         | Yes (API level 25 and   | Yes (Android 12 and     |
      | keyboard                | higher)                 | higher)                 |
      +-------------------------+-------------------------+-------------------------+
      | Insert using paste from | No                      |                         |
      | the touch & hold menu   |                         |                         |
      +-------------------------+-------------------------+-------------------------+
      | Insert using drag and   | No                      |                         |
      | drop                    |                         |                         |
      +-------------------------+-------------------------+-------------------------+


Last updated 2024-05-03 UTC.


/About haptics
==============

.. https://developer.android.google.cn/develop/ui/views/haptics?hl=en

.. container:: devsite-article-body

   Haptics is everything you feel through the sense of touch. Modern Android
   devices often incorporate a vibration actuator to allow devices to stimulate
   the user's sense of touch. These motors have advanced significantly from the
   original loud buzzy vibration produced by early devices, and Android apps can
   now take advantage of capabilities to give users a richer experience with
   subtlety and depth.

   The following pages cover everything about vibration, from basic haptic
   feedback to increasingly more complex vibration waveforms and effect
   compositions.

   `Haptics design principles <#>`__
      The page describes the classifications supported by Android haptics and
      guidelines for designing them.
   `Add haptic feedback to events <#>`__
      The page presents code examples for different ways of providing haptic
      feedback to user interactions.
   `Vibration actuators primer <#>`__
      The page provides an overview of how vibration actuators work, which is
      important prerequisite knowledge for creating custom haptics.
   `Create custom haptic effects <#>`__
      This page provides several examples of using different haptics APIs to
      create custom effects in an Android application.
   `Add haptics APIs <#>`__
      The page is a reference for various haptics APIs available on Android, and
      also covers when and how to check for any device support necessary to
      ensure your Haptic effects play as intended.

   Also, be sure to read the `best practices for accessibility <#>`__.

   .. rubric:: Samples
      :name: samples

   The following samples are available in the `Haptic Sampler app <https://github.com/android/platform-samples/tree/main/samples/user-interface/haptics>`__
   on GitHub. You can also find documentation for each here.

   -  `Resist (with low ticks) <#resist>`__
   -  `Expand (with rise and fall) <#expand>`__
   -  `Wobble (with spins) <#wobble>`__
   -  `Bounce (with thuds) <#bounce>`__

   This documentation also includes code examples for the following custom
   vibration patterns:

   -  `Ramp-up pattern <#ramp_up_pattern>`__
   -  `Repeating pattern <#repeating_pattern>`__
   -  `Pattern with fallback <#pattern_with_fallback>`__

   .. rubric:: Video
      :name: video

   .. container:: wrap


Last updated 2024-02-22 UTC.


/Haptic design principles
=========================

.. https://developer.android.google.cn/develop/ui/views/haptics/haptics-principles?hl=en

.. container:: devsite-article-body

   When it comes to haptic feedback on mobile devices, less is more. Too much
   vibration can be annoying and even numbing to the hands, as the device is
   usually in-hand with the user's full attention. It can also be distracting
   from the user's intended task, which may lead the user to quickly turn off
   all haptics. However, well crafted haptics provide valuable sensory feedback
   that provide users with a richer engagement with their device.

   This page explains use cases for using haptics, introduces
   `classifications <#haptics_classifications>`__ for haptic effects, and also
   covers basic `guidelines <#haptics_design_guidelines>`__ for apps.

   .. rubric:: Use cases for adding haptics to your app
      :name: reasons_why

   Here are some reasons for incorporating haptics into your app.

   -  **To notify the user of an event that needs their attention.** Examples
      include an incoming phone call or text message, or an upcoming meeting on
      the calendar.

   -  **To confirm a state change in the device following a user action.**
      Examples include click feedback for a button press, unlocking a phone,
      fingerprint acceptance or rejection, or activating the camera.

   -  **To delight the user with effects.** Such effects could enhance an
      ongoing user action or emulate physical interaction. Examples include
      scroll feedback, a slider snapping into place, or haptic effects in sync
      with animations, sounds, videos, and games.

   .. rubric:: Haptics classifications
      :name: haptics_classifications

   The haptic principles presented here are designed around *clear haptics*,
   *rich haptics*, and *buzzy haptics*.

   .. rubric:: Clear haptics
      :name: clear_haptics

   Clear haptics refers to crisp and clean sensations associated with a discrete
   event, such as button presses. These effects often aim to imitate a
   corresponding real-world mechanical action, like those felt when pressing on
   a physical button.

   Android has predefined clear haptic effects in
   `VibrationEffect <#android.os.VibrationEffect>`__. However, in
   general apps should use action-oriented constants from
   `HapticFeedbackConstants <#android.view.HapticFeedbackConstants>`__
   to ensure consistency of effect and action across the device.

   The other advantage of action-oriented constants is that the platform can
   provide fallback behavior if a more complex effect isn't supported by the
   user's device.

   As you expand the use cases of haptic feedback, the available clear haptics
   can sometimes feel plain and monotone. In that case, aim for rich haptics
   that are more expressive.

   .. rubric:: Rich haptics
      :name: rich_haptics

   Rich haptics generally require haptic actuators that have a wider frequency
   bandwidth, enabling greater expressiveness and range. Rich haptics can also
   be produced by sequencing clear haptics
   `primitives <#primitives>`__
   in varied amplitudes and intervals.

   Examples of rich haptic effects are:

   -  A "fluttery" sensation, similar to a butterfly flapping its wings on your
      fingertip
   -  The texture of a surface felt by a finger dragging or swiping across it
   -  The sensations of wobbliness and instability, or heaviness and
      reverberation

   **Caution:**\  Rich haptics are supported by fewer devices, so it’s important
   to have a fallback strategy.

   .. rubric:: Buzzy haptics
      :name: buzzy_haptics

   Buzzy haptics can be characterized by noisy, sharp and penetrating vibrations
   that leave an after effect such as a tingling sensation even after the
   vibration is over. It also tends to have a ringing effect that feels like a
   reverberation before the vibration stops completely.

   Examples of buzzy haptic sensations are:

   -  Operating a jackhammer
   -  Riding a motorcycle
   -  In mobile devices, a long-winded, ringing vibration after a key press

   Dating back to pagers and feature phones, low-end mobile phones with
   low-performance haptic actuators or drivers tended to produce buzzy long
   vibrations for notification purposes.

   **Important:**\  Given the choice of buzzy haptics or no haptics for touch
   feedback, choose no haptics. Some situations where an event is always
   intended to grab the users attention, such as an incoming notification or
   call, may be appropriate for applying a buzzy fallback.

   .. rubric:: Haptics design guidelines
      :name: haptics_design_guidelines

   At a high level, the design guidelines can be summarized as:

   -  Favor rich and clear haptics over buzzy haptics.
   -  Be consistent, both with the system and the app design.
   -  Be mindful of frequency of use, and importance.

   .. rubric:: Prioritize predefined haptic constants and effects
      :name: pri_predefined

   If your action is covered by a predefined action present in
   `HapticFeedbackConstants <#android.view.HapticFeedbackConstants>`__,
   use that constant. This ensures a consistent user interaction experience,
   which is particularly valuable as an accessibility consideration.

   If you're creating your own effect, consider using the
   `VibrationEffect <#android.os.VibrationEffect>`__ predefined
   effects and the
   `VibrationEffect.Composition <#android.os.VibrationEffect.Composition>`__
   primitives. They are more likely to give a consistent quality experience
   across devices that support them.

   .. rubric:: Correlate event importance and frequency with strength
      :name: event_frequency

   Haptic effects shouldn't overwhelm the user or feel gratuitous.

   -  Haptic effects applied to very frequent events, like scrolling or moving a
      text handle, should be very subtle to provide a pleasant overall
      experience.

   -  More important events, like refreshing a page or submitting a form, should
      be stronger than changing a toggle or scrolling on a list, for example.

   -  Combine both concepts to create effects that become stronger as the
      interaction reaches a target, for example gradually increasing the
      amplitude of a sequence of ticks with dragging, dropping or snapping
      actions.

   .. rubric:: Be consistent
      :name: consistency

   Be consistent within your app with the application of haptics. If a
   particular interaction, like form submission or in-app navigation, has haptic
   feedback, make sure the same effect is applied to all similar interactions.
   This helps users to associate a meaning to a particular haptic feedback.

   Also be consistent with the Android system by using the same
   `HapticFeedbackConstants <#android.view.HapticFeedbackConstants>`__
   for well defined interactions, like time pickers or virtual keyboards.

   .. rubric:: Design visual and audio experience together with haptics
      :name: design_visual_audio

   Consider haptics as part of the total user experience.

   We strongly recommend co-design of visual, audio, and haptic effects. Make it
   harmonious or congruent with visual animations and sound patterns. Visual and
   auditory inputs can enhance the haptics perceived, and a well-designed haptic
   effect can provide a sense of *physicality* to visual and audio effects.

   Conversely, a haptic feedback that is played out of sync or that feels
   inconsistent with visual and audio effects can be a bit unsettling to the
   user. In some cases, the user may perceive the haptic actuator to be broken.

   .. rubric:: Avoid legacy one-shot vibrations for haptic feedback
      :name: legacy

   Avoid using the legacy `one-shot vibrations <#on_off_vibrations>`__,
   like the ones defined by
   `VibrationEffect.createOneShot <#android.os.VibrationEffect>`__
   or performed with the APIs
   `Vibrator.vibrate(long) <#android.os.Vibrator>`__
   and
   `Vibrator.vibrate(long[], int) <#android.os.Vibrator>`__.

   These vibrations might feel buzzy when they last for a long period after the
   input waveform has ended, especially on devices with a low-performance haptic
   actuator or driver.

   A good keyclick haptic feedback signal should last between 10 to 20
   milliseconds. However, the actuator may continue to ring for another 20 to 50
   milliseconds after a 20-millisecond input to the actuator has ended.
   Therefore, it's best to avoid single-shot vibrations for this type of
   feedback.


Last updated 2024-02-22 UTC.


/Add haptic feedback to events
==============================

.. https://developer.android.google.cn/develop/ui/views/haptics/haptic-feedback?hl=en

.. container:: devsite-article-body

   One of the most basic use cases for haptics is to provide feedback to user
   interactions. Time pickers, the key press on a virtual keyboard, and text
   selection are common examples of good use cases for haptic feedback. For more
   information about when and how to apply haptics, read `Haptics design principles <#>`__.

   This page describes three ways to provide haptic feedback.

   -  `Use a ``View`` <#view>`__ **(recommended)**. This approach is
      action-oriented, has the widest support, and doesn't require the
      ``VIBRATE`` permission.
   -  `Use a predefined ``VibrationEffect`` <#predefined_vibrationeffect>`__.
      This approach has more flexibility, but with some trade-offs.
   -  `Use advanced compositions with primitives <#advanced_composition>`__.
      This method is newer and even more flexible, but requires specific device
      support.

   These methods use primitives defined at the device level to provide high
   quality feedback tailored to the device in hand.

   **Caution:**\  We strongly discourage using older ``Vibrator`` methods
   employing ``createOneshot`` or ``createWaveform``, even if they appear to be
   supported on the device. These modes are often too loud for regular haptic
   feedback; use them only as a fallback if you need to highlight an extremely
   important action.
   All haptic feedback methods respect the user's touch feedback settings by
   default.

   .. rubric:: Use ``View`` components to generate haptic feedback
      :name: view

   Use the
   `View.performHapticFeedback <#android.view.View>`__
   method to generate haptic feedback. The haptic constants defined by the
   `HapticFeedbackConstants <#android.view.HapticFeedbackConstants>`__
   are focused on their functionality in an application, not the type of haptic
   effect performed.

   The underlying implementation might vary depending on the device and hardware
   capabilities, but the app only needs to consider the type of feedback to
   provide in a particular context. By focusing on the functionality, you can
   enable haptic feedback for similar interactions. Users learn to associate
   different meanings to different haptic sensations over time.

   .. rubric:: Prerequisites: Enable haptic feedback
      :name: use_view_prereq

   As long as the `View <#android.view.View>`__ is visible, haptic
   feedback can be used for its events. Some events, such as long press, have
   default haptics that are triggered if a listener on the view handles the
   event (returns ``true``).

   An Android ``View`` can disable haptic feedback by setting the
   `View.hapticFeedbackEnabled <#android.view.View>`__
   property to ``false``. Disabling this property results in default feedback.

   The
   `performHapticFeedback <#android.view.View>`__
   method also honors the system setting
   `HAPTIC_FEEDBACK_ENABLED <#android.provider.Settings.System>`__,
   which allows the user to potentially disable them for the entire system.

   Unlike other haptic APIs, using ``HapticFeedbackConstants`` with a ``View``
   doesn't require the ``VIBRATE`` permission.

   .. rubric:: Choose a ``HapticFeedbackConstant``
      :name: use_view_choose_haptic_feedback_constant

   When using ``View`` components with ``HapticFeedbackConstants``, there's no
   need to evaluate specific device support, as these constants will have
   fallback behavior if necessary. The only consideration is the SDK level of
   the desired constant.

   .. rubric:: Example 1: Keypress
      :name: use_view_example_1

   This is an example of how to add a haptic feedback to a touch input in
   ``View`` using touch listeners. The effects simulate the feeling of pressing
   down on a button and then releasing it.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class HapticTouchListener : View.OnTouchListener {
                 override fun onTouch(View view, MotionEvent event) : Boolean {
                   when (event.actionMasked) {
                     MotionEvent.ACTION_DOWN ->
                       view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                     MotionEvent.ACTION_UP ->
                       view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY_RELEASE)
                   }
                   return true
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class HapticTouchListener implements View.OnTouchListener {
                 @Override
                 public boolean onTouch(View view, MotionEvent event) {
                   switch (event.getAction()) {
                     case MotionEvent.ACTION_DOWN:
                       view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
                       break;
                     case MotionEvent.ACTION_UP:
                       view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY_RELEASE);
                       break;
                   }
                   return true;
                 }
               }

   .. rubric:: Example 2: Submit button
      :name: use_view_example_2

   Haptic feedback use cases go beyond simulating a physical interaction with
   the device. They might also be used to convey an abstract meaning. For
   example, the general expectation for a
   `CONFIRM <#android.view.HapticFeedbackConstants>`__
   effect is a short and light vibration while a
   `REJECT <#android.view.HapticFeedbackConstants>`__ might
   be a stronger feedback to signal failure. This is illustrated in the
   following example for a submit button feedback.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               submitButton.setOnClickListener { view ->
                 val successful = performSubmit()
                 if (successful) {
                   view.performHapticFeedback(HapticFeedbackConstants.CONFIRM)
                 } else {
                   view.performHapticFeedback(HapticFeedbackConstants.REJECT)
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               submitButton.setOnClickListener(view -> {
                 boolean successful = performSubmit();
                 if (successful) {
                   view.performHapticFeedback(HapticFeedbackConstants.CONFIRM);
                 } else {
                   view.performHapticFeedback(HapticFeedbackConstants.REJECT);
                 }
               });

   .. rubric:: Use a predefined ``VibrationEffect`` to generate haptic feedback
      :name: predefined_vibrationeffect

   Using the `View-based <#view>`__ approach focuses on the user
   interaction. It is preferred for consistency across the system. However,
   specific predefined
   `VibrationEffect <#android.os.VibrationEffect>`__ APIs can also
   be invoked for customized haptic feedback effects.

   Predefined effects are available as `VibrationEffect constants <#android.os.VibrationEffect>`__, and can be
   checked for support and played with the
   `Vibrator <#android.os.Vibrator>`__ service as shown in the
   following examples.

   .. rubric:: Understand device support of ``VibrationEffect`` APIs
      :name: predefined_vibrationeffect_device_support

   In basic usage, there should be no need to check for support of individual
   ``VibrationEffect`` APIs. The APIs such as
   `Vibrator.areEffectsSupported <#android.os.Vibrator>`__
   and
   `Vibrator.areAllEffectsSupported <#android.os.Vibrator>`__
   are used to determine if the device has a *customized* implementation of the
   constant. If a customized effect isn't present, your app can still play the
   effects and use a platform-defined fallback implementation.

   For more details, see `Predefined ``VibrationEffect`` <#predefined_vibration_effect>`__.

   .. rubric:: Prerequisites: Load the Vibrator and the ``VIBRATE`` permission
      :name: predefined_vibrationeffect_vibrator_setup

   Most vibrations can be played with the ``Vibrator`` service, which can be
   loaded as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               import android.os.Vibrator

               val vibrator = context.getSystemService(Vibrator::class.java)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               import android.os.Vibrator;

               Vibrator vibrator = context.getSystemService(Vibrator.class);

   The app needs to have the
   `VIBRATE <#android.Manifest.permission>`__ permission
   in order to vibrate the device using this service. The permission can be
   added to the application manifest file:

   .. code:: prettyprint

      <uses-permission android:name="android.permission.VIBRATE"/>

   .. rubric:: Play a predefined ``VibrationEffect``
      :name: predefined_vibrationeffect_play_predefined

   **Caution:**\  Following the
   `guidelines <#guidelines>`__,
   effects should be *clear* and their strengths should correspond with
   *importance*. If an effect isn't available, consider falling back to nothing
   rather than a discordant alternative.
   Predefined effects can be prepared using
   `VibrationEffect.createPredefined <#android.os.VibrationEffect>`__,
   then played using one of the ``vibrate`` methods on
   `Vibrator <#android.os.Vibrator>`__.

   This example plays a Click effect.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val vibrator = context.getSystemService(Vibrator::class.java)
               ...
               // Requires VIBRATE permission
               vibrator.vibrate(VibrationEffect.createPredefined(VibrationEffect.EFFECT_CLICK))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Vibrator vibrator = context.getSystemService(Vibrator.class);
               ...
               // Requires VIBRATE permission
               vibrator.vibrate(VibrationEffect.createPredefined(VibrationEffect.EFFECT_CLICK));

   .. rubric:: Use advanced compositions with primitives
      :name: advanced_composition

   The
   `VibrationEffect.Composition <#android.os.VibrationEffect.Composition>`__
   API offers additional possibilities for haptic feedback. However, unlike
   effects, these primitives don't have system-level fallbacks, which means that
   careful attention needs to be paid to the primitives and other capabilities
   supported by the device.

   Using these APIs is discussed in more detail in `Creating Custom Haptic Effects <#vibration_compositions>`__.


Last updated 2024-02-22 UTC.


/Vibration actuators primer
===========================

.. https://developer.android.google.cn/develop/ui/views/haptics/actuators?hl=en

.. container:: devsite-article-body

   Before `designing haptic effects <#>`__ on an Android
   device, it helps to get an overview of how vibration actuators work.

   |Illustration of the components of a Haptic LRA|

   The most common vibration actuators are Linear Resonant Actuators (LRAs).
   Each LRA consists of a voice coil pressed against a magnetic moving mass that
   is attached to a spring. An AC voltage applied to the voice coil creates an
   electromagnetic force that causes the mass to move. The spring provides the
   restoring force that causes the mass to return to its starting position. The
   back-and-forth movement of the mass causes the LRA to vibrate. They have a
   resonance frequency at which the output is maximum.

   **Note:**\  The word *resonant* in LRA means that the acceleration reaches a
   maximum value at the LRA's resonant frequency, and decreases at frequencies
   away from the resonant frequency. To understand the concept of resonance,
   imagine attaching one end of a bungee cord to a rubber ball and the other end
   to a hand. By moving the hand up and down at different rates, one can easily
   find a hand movement speed at which the rubber ball travels the maximum
   distance. That is resonance.
   **Note:**\  Some LRAs had resonant frequencies in the 200 to 300 Hz range,
   which coincided with the frequency at which human skin is most sensitive to
   vibration. The sensation of vibrations at this frequency range can be
   described as smooth, sharp and penetrating. Other models of LRAs have lower
   resonance frequencies at around 150 Hz. The sensation is qualitatively softer
   and fuller (in space).
   Given the same input voltage at two different frequencies, the vibration
   output amplitudes can be different. The further away the frequency is from
   the LRA’s resonant frequency, the lower its vibration amplitude is.

   One common function of LRAs in a device is to simulate the feeling of a
   button click on an unresponsive glass surface. It serves to make user
   interaction feel more natural. When applied to typing on a virtual keyboard,
   click feedback can increase typing speed and reduce errors. A clear and crisp
   click feedback signal is typically less than 10 to 20 milliseconds in
   duration. Achieving a good click requires some knowledge of the LRA used in a
   device. This is why relying on pre-fabricated waveforms provides the best
   feedback for a click. You can use them with the constants provided by the
   platform whenever a click feedback is needed.

   The haptic effects achievable in a device is determined by both the vibration
   actuator and its driver. Haptic drivers that include overdrive and active
   braking features can reduce the rise time and ringing of LRAs, leading to a
   more responsive and clear vibration. For illustration, let’s see how a custom
   waveform pattern behaves on a generic device.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val timings: LongArray = longArrayOf(50, 50, 50, 50, 50, 100, 350, 250)
               val amplitudes: IntArray = intArrayOf(77, 79, 84, 99, 143, 255, 0, 255)
               val repeatIndex = -1 // Do not repeat.

               vibrator.vibrate(VibrationEffect.createWaveform(timings, amplitudes, repeatIndex))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               long[] timings = new long[] { 50, 50, 50, 50, 50, 100, 350, 250 };
               int[] amplitudes = new int[] { 77, 79, 84, 99, 143, 255, 0, 255 };
               int repeatIndex = -1 // Do not repeat.

               vibrator.vibrate(VibrationEffect.createWaveform(timings, amplitudes, repeatIndex));

   The plot below shows the waveform corresponding to the code snippets shown
   above.

   |Plot of step function input waveform|

   The corresponding acceleration is shown below:

   |Plot of actual measured waveform, showing more organic transitions between
   levels|

   Note that the acceleration increases gradually, not suddenly, whenever there
   is a step change of amplitude in the pattern (e.g., at 0ms, 150ms, 200ms,
   250ms, 700ms). There is also an overshoot at each step change of amplitude,
   and there is visible ‘ringing’ that lasts at least 50ms when the input
   amplitude suddenly drops to 0.

   This haptic pattern can be improved by increasing and decreasing the
   amplitudes gradually to avoid overshoot and reduce ringing time. The
   following shows the waveform and acceleration plots of the revised version.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val timings: LongArray = longArrayOf(
                   25, 25, 50, 25, 25, 25, 25, 25, 25, 25, 75, 25, 25,
                   300, 25, 25, 150, 25, 25, 25
               )
               val amplitudes: IntArray = intArrayOf(
                   38, 77, 79, 84, 92, 99, 121, 143, 180, 217, 255, 170, 85,
                   0, 85, 170, 255, 170, 85, 0
               )
               val repeatIndex = -1 // Do not repeat.

               vibrator.vibrate(VibrationEffect.createWaveform(timings, amplitudes, repeatIndex))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               long[] timings = new long[] {
                       25, 25, 50, 25, 25, 25, 25, 25, 25, 25, 75, 25, 25,
                       300, 25, 25, 150, 25, 25, 25
                   };
               int[] amplitudes = new int[] {
                       38, 77, 79, 84, 92, 99, 121, 143, 180, 217, 255, 170, 85,
                       0, 85, 170, 255, 170, 85, 0
                   };
               int repeatIndex = -1; // Do not repeat.

               vibrator.vibrate(VibrationEffect.createWaveform(timings, amplitudes, repeatIndex));

   |Plot of input waveform with additional steps|

   |Plot of measured waveform, showing smoother transitions|

   It follows that creating a haptic effect on an Android device requires more
   than providing a frequency and amplitude value. It is not a trivial task to
   design a haptic effect from scratch without full access to the engineering
   specifications of the vibration actuator and the driver. Android APIs provide
   constants that let you do the following:

   -  Perform clear effects and
      `primitives <#primitives>`__.

   -  Concatenate them to compose new haptic effects.

   These pre-defined haptic constants and primitives can greatly speed up your
   work while ensuring high-quality haptic effects.


Last updated 2024-02-22 UTC.

.. |Illustration of the components of a Haptic LRA| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/lra-overview.svg
   :width: 100.0%
.. |Plot of step function input waveform| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/lra-input-waveform.svg
   :width: 100.0%
.. |Plot of actual measured waveform, showing more organic transitions between levels| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/lra-measured-waveform.svg
   :width: 100.0%
.. |Plot of input waveform with additional steps| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/lra-input-waveform-more-steps.svg
   :width: 100.0%
.. |Plot of measured waveform, showing smoother transitions| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/lra-measured-waveform-more-steps.svg
   :width: 100.0%


/Create custom haptic effects
=============================

.. https://developer.android.google.cn/develop/ui/views/haptics/custom-haptic-effects?hl=en

.. container:: devsite-article-body

   This page covers the examples of how to use different `haptics APIs <#>`__ to create custom effects in
   an Android application. As much of the information on this page relies on a
   good knowledge of the workings of a vibration actuator, we recommend reading
   the `Vibration actuator primer <#>`__.

   This page includes the following examples.

   -  `Custom vibration patterns <#custom_vibration_patterns>`__

      -  `Ramp up pattern <#ramp_up_pattern>`__: A pattern that begins smoothly.
      -  `Repeating pattern <#repeating_pattern>`__: A pattern with no end.
      -  `Pattern with fallback <#pattern_with_fallback>`__: A fallback
         demonstration.

   -  `Vibration compositions <#vibration_compositions>`__

      -  `Resist <#resist>`__: A drag effect with dynamic intensity.
      -  `Expand <#expand>`__: A rise then fall effect.
      -  `Wobble <#wobble>`__: A wobbly effect using the ``SPIN`` primitive.
      -  `Bounce <#bounce>`__: A bouncing effect using the ``THUD`` primitive.

   For additional examples, see `Add haptic feedback to events <#>`__, and always follow
   `haptics design principles <#>`__.

   .. rubric:: Use fallbacks to handle device compatibility
      :name: fallbacks

   When implementing any custom effect, consider the following:

   -  Which device capabilities are required for the effect
   -  What to do when the device is not capable of playing the effect

   The `Android haptics API reference <#>`__ provides details on how
   to check for support for components involved in your haptics, so that your
   app can provide a consistent overall experience.

   Depending on your use case, you might want to disable custom effects or to
   provide alternative custom effects based on different potential capabilities.

   Plan for the following high-level classes of device capability:

   -  If you're using haptic *primitives*: devices supporting those primitives
      needed by the custom effects. (See the next section for details on
      primitives.)

   -  Devices with *amplitude control*.

   -  Devices with *basic* vibration support (on/off)—in other words, those
      lacking amplitude control.

   If your app's haptic effect choice accounts for these categories, then its
   haptic user experience should remain predictable for any individual device.

   .. rubric:: Usage of haptic primitives
      :name: primitives

   Android includes several haptics *primitives* that vary in both amplitude and
   frequency. You may use one primitive alone or multiple primitives in
   combination to achieve rich haptic effects.

   -  Use delays of 50 ms or longer for discernible gaps between two primitives,
      also taking into account the `primitive duration <#android.os.Vibrator>`__
      if possible.

   -  Use scales that differ by a ratio of 1.4 or more so the difference in
      intensity is better perceived.

   -  Use scales of 0.5, 0.7 and 1.0 to create a low, medium and high intensity
      version of a primitive.

      **Note:**\  A 0.0 ``scale`` parameter indicates minimum perceivable
      vibration, not off.

   .. rubric:: Create custom vibration patterns
      :name: custom_vibration_patterns

   Vibration patterns are often used in attentional haptics, such as
   notifications and ringtones. The
   `Vibrator <#android.os.Vibrator>`__ service can play long
   vibration patterns that change the vibration amplitude over time. Such
   effects are named waveforms.

   Waveform effects can be easily perceivable, but sudden long vibrations can
   startle the user if played in a quiet environment. Ramping to a target
   amplitude too fast might also produce audible buzzing noises. The
   recommendation for designing waveform patterns is to smooth the amplitude
   transitions to create ramp up and down effects.

   **Important:**\  We recommended starting and ending a waveform at zero
   amplitude whenever possible. This avoids any sudden changes in the input
   voltage amplitude to the actuator which may cause the actuator to resonate;
   in other words, vibrate at its resonance frequency. Also, some drivers apply
   *active braking* if the waveform ends at 0, so the vibration stops more
   quickly. See `Vibration actuators primer <#>`__ for more details about this.

   .. rubric:: Sample: Ramp-up pattern
      :name: ramp_up_pattern

   Waveforms are represented as
   `VibrationEffect <#android.os.VibrationEffect>`__ with three
   parameters:

   #. **Timings:** an array of durations, in milliseconds, for each waveform
      segment.
   #. **Amplitudes:** the desired vibration amplitude for each duration
      specified in the first argument, represented by an integer value from 0 to
      255, with 0 representing the vibrator "off" and 255 being the device's
      maximum amplitude.
   #. **Repeat index:** the index in the array specified in the first argument
      to start repeating the waveform, or -1 if it should play the pattern only
      once.

   Here is an example waveform that pulses twice with a pause of 350 ms in
   between pulses. The first pulse is a smooth ramp up to the maximum amplitude,
   and the second is a quick ramp to hold maximum amplitude. Stopping at the end
   is defined by the negative repeat index value.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val timings: LongArray = longArrayOf(50, 50, 50, 50, 50, 100, 350, 25, 25, 25, 25, 200)
               val amplitudes: IntArray = intArrayOf(33, 51, 75, 113, 170, 255, 0, 38, 62, 100, 160, 255)
               val repeatIndex = -1 // Do not repeat.

               vibrator.vibrate(VibrationEffect.createWaveform(timings, amplitudes, repeatIndex))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               long[] timings = new long[] { 50, 50, 50, 50, 50, 100, 350, 25, 25, 25, 25, 200 };
               int[] amplitudes = new int[] { 33, 51, 75, 113, 170, 255, 0, 38, 62, 100, 160, 255 };
               int repeatIndex = -1; // Do not repeat.

               vibrator.vibrate(VibrationEffect.createWaveform(timings, amplitudes, repeatIndex));

   .. rubric:: Sample: Repeating pattern
      :name: repeating_pattern

   Waveforms can also be played repeatedly until cancelled. The way to create a
   repeating waveform is to set a non-negative ‘repeat’ parameter. When you play
   a repeating waveform, the vibration continues until it's explicitly cancelled
   in the service:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               void startVibrating() {
                 val timings: LongArray = longArrayOf(50, 50, 100, 50, 50)
                 val amplitudes: IntArray = intArrayOf(64, 128, 255, 128, 64)
                 val repeat = 1 // Repeat from the second entry, index = 1.
                 VibrationEffect repeatingEffect = VibrationEffect.createWaveform(timings, amplitudes, repeat)
                 // repeatingEffect can be used in multiple places.

                 vibrator.vibrate(repeatingEffect)
               }

               void stopVibrating() {
                 vibrator.cancel()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               void startVibrating() {
                 long[] timings = new long[] { 50, 50, 100, 50, 50 };
                 int[] amplitudes = new int[] { 64, 128, 255, 128, 64 };
                 int repeat = 1; // Repeat from the second entry, index = 1.
                 VibrationEffect repeatingEffect = VibrationEffect.createWaveform(timings, amplitudes, repeat);
                 // repeatingEffect can be used in multiple places.

                 vibrator.vibrate(repeatingEffect);
               }

               void stopVibrating() {
                 vibrator.cancel();
               }

   This is very useful for intermittent events that require user action to
   acknowledge it. Examples of such events include incoming phone calls and
   triggered alarms.

   .. rubric:: Sample: Pattern with fallback
      :name: pattern_with_fallback

   Controlling the amplitude of a vibration is a `hardware-dependent capability <#amplitude_control>`__.
   Playing a waveform on a low-end device without this capability causes it to
   vibrate at the maximum amplitude for each positive entry in the amplitude
   array. If your app needs to accommodate such devices then the recommendation
   is to make sure that your pattern doesn't generate a buzzing effect when
   played in that condition, or to design a simpler ON/OFF pattern that can be
   played as a fallback instead.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               if (vibrator.hasAmplitudeControl()) {
                 vibrator.vibrate(VibrationEffect.createWaveform(smoothTimings, amplitudes, smoothRepeatIdx))
               } else {
                 vibrator.vibrate(VibrationEffect.createWaveform(onOffTimings, onOffRepeatIdx))
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               if (vibrator.hasAmplitudeControl()) {
                 vibrator.vibrate(VibrationEffect.createWaveform(smoothTimings, amplitudes, smoothRepeatIdx));
               } else {
                 vibrator.vibrate(VibrationEffect.createWaveform(onOffTimings, onOffRepeatIdx));
               }

   **Note:**\  The ON/OFF pattern is actually specified in the API as a OFF/ON
   sequence of durations. See more details in the `API reference documentation <#android.os.VibrationEffect>`__.

   .. rubric:: Create vibration compositions
      :name: vibration_compositions

   This section presents ways to compose them into longer and more complex
   custom effects, and goes beyond that to explore rich haptics using more
   advanced hardware capabilities. You can use combinations of effects that vary
   amplitude and frequency to create more complex haptic effects on devices with
   haptic actuators that have a wider frequency bandwidth.

   **Note:**\  See `Add haptics feedback to events <#>`__ for predefined haptic
   effects and how to use them.
   The process for `creating custom vibration patterns <#custom_vibration_patterns>`__, described previously on this page,
   explains how to control the vibration amplitude to create smooth effects of
   ramping up and down. Rich haptics improves on this concept by exploring the
   wider frequency range of the device vibrator to make the effect even
   smoother. These waveforms are especially effective at creating a crescendo or
   diminuendo effect.

   The composition
   `primitives <#primitives>`__,
   described earlier on this page, are implemented by the device manufacturer.
   They provide a crisp, short and pleasant vibration that aligns with `Haptics principles <#>`__ for clear
   haptics. For more details about these capabilities and how they work, see
   `Vibration actuators primer <#>`__.

   Android doesn't provide fallbacks for compositions with unsupported
   primitives. We recommend that you perform the following steps:

   #. Before activating your advanced haptics, check that a given device
      supports all the primitives you're using.

   #. Disable the consistent set of experiences that are unsupported, not just
      the effects that are missing a primitive. More information on how to check
      the device’s support is shown as follows.

   You can create composed vibration effects with
   `VibrationEffect.Composition <#android.os.VibrationEffect.Composition>`__.
   Here is an example of a slowly rising effect followed by a sharp click
   effect:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               vibrator.vibrate(
                   VibrationEffect.startComposition().addPrimitive(
                     VibrationEffect.Composition.PRIMITIVE_SLOW_RISE
                   ).addPrimitive(
                     VibrationEffect.Composition.PRIMITIVE_CLICK
                   ).compose()
                 )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               vibrator.vibrate(
                   VibrationEffect.startComposition()
                       .addPrimitive(VibrationEffect.Composition.PRIMITIVE_SLOW_RISE)
                       .addPrimitive(VibrationEffect.Composition.PRIMITIVE_CLICK)
                       .compose());

   A composition is created by adding primitives to be played in sequence. Each
   primitive is also scalable, so you can control the amplitude of the vibration
   generated by each of them. The scale is defined as a value between 0 and 1,
   where 0 actually maps to a minimum amplitude at which this primitive can be
   (barely) felt by the user.

   If you’d like to create a weak and strong version of the same primitive, it
   is recommended that the scales differ by a ratio of 1.4 or more, so the
   difference in intensity can be easily perceived. Don't try to create more
   than three intensity levels of the same primitive, because they aren't
   perceptually distinct. For example, use scales of 0.5, 0.7, and 1.0 to create
   a low, medium, and high intensity version of a primitive.

   The composition can also specify delays to be added in between consecutive
   primitives. This delay is expressed in milliseconds since the end of the
   previous primitive. In general, a 5 to 10 ms gap between two primitives is
   too short to be detectable. Consider using a gap on the order of 50 ms or
   longer if you want to create a discernible gap between two primitives. Here
   is an example of a composition with delays:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val delayMs = 100
               vibrator.vibrate(
                   VibrationEffect.startComposition().addPrimitive(
                     VibrationEffect.Composition.PRIMITIVE_SPIN, 0.8f
                   ).addPrimitive(
                     VibrationEffect.Composition.PRIMITIVE_SPIN, 0.6f
                   ).addPrimitive(
                     VibrationEffect.Composition.PRIMITIVE_THUD, 1.0f, delayMs
                   ).compose()
                 )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               int delayMs = 100;
               vibrator.vibrate(
                   VibrationEffect.startComposition()
                       .addPrimitive(VibrationEffect.Composition.PRIMITIVE_SPIN, 0.8f)
                       .addPrimitive(VibrationEffect.Composition.PRIMITIVE_SPIN, 0.6f)
                       .addPrimitive(VibrationEffect.Composition.PRIMITIVE_THUD, 1.0f, delayMs)
                       .compose());

   The following APIs can be used to verify the device support for specific
   primitives:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val primitive = VibrationEffect.Composition.PRIMITIVE_LOW_TICK

               if (vibrator.areAllPrimitivesSupported(primitive)) {
                 vibrator.vibrate(VibrationEffect.startComposition().addPrimitive(primitive).compose())
               } else {
                 // Play a predefined effect or custom pattern as a fallback.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               int primitive = VibrationEffect.Composition.PRIMITIVE_LOW_TICK;

               if (vibrator.areAllPrimitivesSupported(primitive)) {
                 vibrator.vibrate(VibrationEffect.startComposition().addPrimitive(primitive).compose());
               } else {
                 // Play a predefined effect or custom pattern as a fallback.
               }

   It's also possible to check multiple primitives and then decide which ones to
   compose based on the device support level:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val effects: IntArray = intArrayOf(
                 VibrationEffect.Composition.PRIMITIVE_LOW_TICK,
                 VibrationEffect.Composition.PRIMITIVE_TICK,
                 VibrationEffect.Composition.PRIMITIVE_CLICK
               )
               val supported: BooleanArray = vibrator.arePrimitivesSupported(primitives);

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               int[] primitives = new int[] {
                 VibrationEffect.Composition.PRIMITIVE_LOW_TICK,
                 VibrationEffect.Composition.PRIMITIVE_TICK,
                 VibrationEffect.Composition.PRIMITIVE_CLICK
               };
               boolean[] supported = vibrator.arePrimitivesSupported(effects);

   .. rubric:: Sample: Resist (with low ticks)
      :name: resist

   You can control the amplitude of the primitive vibration to convey useful
   feedback to an action in progress. Closely-spaced scale values can be used to
   create a smooth crescendo effect of a primitive. The delay between
   consecutive
   `primitives <#primitives>`__
   can also be dynamically set based on the user interaction. This is
   illustrated in the following example of a view animation controlled by a drag
   gesture and augmented with haptics.

   **Note:**\  This sample app is available as part of the `Haptic Sampler app <https://github.com/android/platform-samples/tree/main/samples/user-interface/haptics>`__
   on GitHub.

   .. container:: demo-container

      .. container:: demo-with-frame

         |image-demo-portrait| |Animation of a circle being dragged down|

   .. container:: waveform-container

      |Plot of input vibration waveform|

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Composable
               fun ResistScreen() {
                 // Control variables for the dragging of the indicator.
                 var isDragging by remember { mutableStateOf(false) }
                 var dragOffset by remember { mutableStateOf(0f) }

                 // Only vibrates while the user is dragging
                 if (isDragging) {
                   LaunchedEffect(Unit) {
                     // Continuously run the effect for vibration to occur even when the view
                     // is not being drawn, when user stops dragging midway through gesture.
                     while (true) {
                       // Calculate the interval inversely proportional to the drag offset.
                       val vibrationInterval = calculateVibrationInterval(dragOffset)
                       // Calculate the scale directly proportional to the drag offset.
                       val vibrationScale = calculateVibrationScale(dragOffset)

                       delay(vibrationInterval)
                       vibrator.vibrate(
                         VibrationEffect.startComposition().addPrimitive(
                           VibrationEffect.Composition.PRIMITIVE_LOW_TICK,
                           vibrationScale
                         ).compose()
                       )
                     }
                   }
                 }

                 Screen() {
                   Column(
                     Modifier
                       .draggable(
                         orientation = Orientation.Vertical,
                         onDragStarted = {
                           isDragging = true
                         },
                         onDragStopped = {
                           isDragging = false
                         },
                         state = rememberDraggableState { delta ->
                           dragOffset += delta
                         }
                       )
                   ) {
                     // Build the indicator UI based on how much the user has dragged it.
                     ResistIndicator(dragOffset)
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class DragListener implements View.OnTouchListener {
                 // Control variables for the dragging of the indicator.
                 private int startY;
                 private int vibrationInterval;
                 private float vibrationScale;

                 @Override
                 public boolean onTouch(View view, MotionEvent event) {
                   switch (event.getAction()) {
                     case MotionEvent.ACTION_DOWN:
                       startY = event.getRawY();
                       vibrationInterval = calculateVibrationInterval(0);
                       vibrationScale = calculateVibrationScale(0);
                       startVibration();
                       break;
                     case MotionEvent.ACTION_MOVE:
                       float dragOffset = event.getRawY() - startY;
                       // Calculate the interval inversely proportional to the drag offset.
                       vibrationInterval = calculateVibrationInterval(dragOffset);
                       // Calculate the scale directly proportional to the drag offset.
                       vibrationScale = calculateVibrationScale(dragOffset);
                       // Build the indicator UI based on how much the user has dragged it.
                       updateIndicator(dragOffset);
                       break;
                     case MotionEvent.ACTION_CANCEL:
                     case MotionEvent.ACTION_UP:
                       // Only vibrates while the user is dragging
                       cancelVibration();
                       break;
                   }
                   return true;
                 }

                 private void startVibration() {
                   vibrator.vibrate(
                         VibrationEffect.startComposition()
                           .addPrimitive(VibrationEffect.Composition.PRIMITIVE_LOW_TICK, vibrationScale)
                           .compose());

                   // Continuously run the effect for vibration to occur even when the view
                   // is not being drawn, when user stops dragging midway through gesture.
                   handler.postDelayed(this::startVibration, vibrationInterval);
                 }

                 private void cancelVibration() {
                   handler.removeCallbacksAndMessages(null);
                 }
               }

   .. rubric:: Sample: Expand (with rise and fall)
      :name: expand

   There are two
   `primitives <#primitives>`__
   for ramping up the perceived vibration intensity: the
   `PRIMITIVE_QUICK_RISE <#android.os.VibrationEffect.Composition>`__
   and
   `PRIMITIVE_SLOW_RISE <#android.os.VibrationEffect.Composition>`__.
   They both reach the same target, but with different durations. There is only
   one primitive for ramping down, the
   `PRIMITIVE_QUICK_FALL <#android.os.VibrationEffect.Composition>`__.
   These primitives work better together to create a waveform segment that grows
   in intensity and then dies off. You can align scaled primitives to prevent
   sudden jumps in amplitude between them, which also works well for extending
   the overall effect duration. Perceptually, people always notice the rising
   portion more than the falling portion, so making the rising portion shorter
   than the falling can be used to shift the emphasis towards the falling
   portion.

   Here is an example of an application of this composition for expanding and
   collapsing a circle. The rise effect can enhance the feeling of expansion
   during the animation. The combination of rise and fall effects helps
   emphasize the collapsing at the end of the animation.

   **Note:**\  This sample app is available as part of the `Haptic Sampler app <https://github.com/android/platform-samples/tree/main/samples/user-interface/haptics>`__
   on GitHub.

   .. container:: demo-container

      .. container:: demo-with-frame

         |image-demo-portrait| |Animation of an expanding circle|

   .. container:: waveform-container

      |image-expand-waveform|

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               enum class ExpandShapeState {
                   Collapsed,
                   Expanded
               }

               @Composable
               fun ExpandScreen() {
                 // Control variable for the state of the indicator.
                 var currentState by remember { mutableStateOf(ExpandShapeState.Collapsed) }

                 // Animation between expanded and collapsed states.
                 val transitionData = updateTransitionData(currentState)

                 Screen() {
                   Column(
                     Modifier
                       .clickable(
                         {
                           if (currentState == ExpandShapeState.Collapsed) {
                             currentState = ExpandShapeState.Expanded
                             vibrator.vibrate(
                               VibrationEffect.startComposition().addPrimitive(
                                 VibrationEffect.Composition.PRIMITIVE_SLOW_RISE,
                                 0.3f
                               ).addPrimitive(
                                 VibrationEffect.Composition.PRIMITIVE_QUICK_FALL,
                                 0.3f
                               ).compose()
                             )
                           } else {
                             currentState = ExpandShapeState.Collapsed
                             vibrator.vibrate(
                               VibrationEffect.startComposition().addPrimitive(
                                 VibrationEffect.Composition.PRIMITIVE_SLOW_RISE
                               ).compose()
                             )
                         }
                       )
                   ) {
                     // Build the indicator UI based on the current state.
                     ExpandIndicator(transitionData)
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ClickListener implements View.OnClickListener {
                 private final Animation expandAnimation;
                 private final Animation collapseAnimation;
                 private boolean isExpanded;

                 ClickListener(Context context) {
                   expandAnimation = AnimationUtils.loadAnimation(context, R.anim.expand);
                   expandAnimation.setAnimationListener(new Animation.AnimationListener() {

                     @Override
                     public void onAnimationStart(Animation animation) {
                       vibrator.vibrate(
                         VibrationEffect.startComposition()
                           .addPrimitive(VibrationEffect.Composition.PRIMITIVE_SLOW_RISE, 0.3f)
                           .addPrimitive(VibrationEffect.Composition.PRIMITIVE_QUICK_FALL, 0.3f)
                           .compose());
                     }
                   });

                   collapseAnimation = AnimationUtils.loadAnimation(context, R.anim.collapse);
                   collapseAnimation.setAnimationListener(new Animation.AnimationListener() {

                     @Override
                     public void onAnimationStart(Animation animation) {
                       vibrator.vibrate(
                         VibrationEffect.startComposition()
                           .addPrimitive(VibrationEffect.Composition.PRIMITIVE_SLOW_RISE)
                           .compose());
                     }
                   });
                 }

                 @Override
                 public void onClick(View view) {
                   view.startAnimation(isExpanded ? collapseAnimation : expandAnimation);
                   isExpanded = !isExpanded;
                 }
               }

   .. rubric:: Sample: Wobble (with spins)
      :name: wobble

   One of the key `haptics principles <#>`__ is to delight
   users. A fun way to introduce a pleasant unexpected vibration effect is to
   use the
   `PRIMITIVE_SPIN <#android.os.VibrationEffect.Composition>`__.
   This primitive is most effective when it is called more than once. Multiple
   spins concatenated can create a wobbling and unstable effect, which can be
   further enhanced by applying a somewhat random scaling on each primitive. You
   can also experiment with the gap between successive spin
   `primitives <#primitives>`__.
   Two spins without any gap (0 ms in between) creates a tight spinning
   sensation. Increasing the inter-spin gap from 10 to 50 ms leads to a looser
   spinning sensation, and can be used to match the duration of a video or
   animation.

   We don't recommended using a gap that is longer than 100 ms, as the
   successive spins no longer integrate well and begin to feel like individual
   effects.

   Here is an example of a elastic shape that bounces back after being dragged
   down and then released. The animation is enhanced with a pair of spin
   effects, played with varying intensities that are proportional to the bounce
   displacement.

   **Note:**\  This sample app is available as part of the `Haptic Sampler app <https://github.com/android/platform-samples/tree/main/samples/user-interface/haptics>`__
   on GitHub.

   .. container:: demo-container

      .. container:: demo-with-frame

         |image-demo-portrait| |Animation of an elastic shape bouncing|

   .. container:: waveform-container

      |image-wobble-waveform|

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               @Composable
               fun WobbleScreen() {
                   // Control variables for the dragging and animating state of the elastic.
                   var dragDistance by remember { mutableStateOf(0f) }
                   var isWobbling by remember { mutableStateOf(false) }
                
                   // Use drag distance to create an animated float value behaving like a spring.
                   val dragDistanceAnimated by animateFloatAsState(
                       targetValue = if (dragDistance > 0f) dragDistance else 0f,
                       animationSpec = spring(
                           dampingRatio = Spring.DampingRatioHighBouncy,
                           stiffness = Spring.StiffnessMedium
                       ),
                   )
                
                   if (isWobbling) {
                       LaunchedEffect(Unit) {
                           while (true) {
                               val displacement = dragDistanceAnimated / MAX_DRAG_DISTANCE
                               // Use some sort of minimum displacement so the final few frames
                               // of animation don't generate a vibration.
                               if (displacement > SPIN_MIN_DISPLACEMENT) {
                                   vibrator.vibrate(
                                       VibrationEffect.startComposition().addPrimitive(
                                           VibrationEffect.Composition.PRIMITIVE_SPIN,
                                           nextSpinScale(displacement)
                                       ).addPrimitive(
                                         VibrationEffect.Composition.PRIMITIVE_SPIN,
                                         nextSpinScale(displacement)
                                       ).compose()
                                   )
                               }
                               // Delay the next check for a sufficient duration until the current
                               // composition finishes. Note that you can use
                               // Vibrator.getPrimitiveDurations API to calculcate the delay.
                               delay(VIBRATION_DURATION)
                           }
                       }
                   }
                
                   Box(
                       Modifier
                           .fillMaxSize()
                           .draggable(
                               onDragStopped = {
                                   isWobbling = true
                                   dragDistance = 0f
                               },
                               orientation = Orientation.Vertical,
                               state = rememberDraggableState { delta ->
                                   isWobbling = false
                                   dragDistance += delta
                               }
                           )
                   ) {
                       // Draw the wobbling shape using the animated spring-like value.
                       WobbleShape(dragDistanceAnimated)
                   }
               }

               // Calculate a random scale for each spin to vary the full effect.
               fun nextSpinScale(displacement: Float): Float {
                 // Generate a random offset in [-0.1,+0.1] to be added to the vibration
                 // scale so the spin effects have slightly different values.
                 val randomOffset: Float = Random.Default.nextFloat() * 0.2f - 0.1f
                 return (displacement + randomOffset).absoluteValue.coerceIn(0f, 1f)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class AnimationListener implements DynamicAnimation.OnAnimationUpdateListener {
                 private final Random vibrationRandom = new Random(seed);
                 private final long lastVibrationUptime;

                 @Override
                 public void onAnimationUpdate(DynamicAnimation animation, float value, float velocity) {
                   // Delay the next check for a sufficient duration until the current
                   // composition finishes. Note that you can use
                   // Vibrator.getPrimitiveDurations API to calculcate the delay.
                   if (SystemClock.uptimeMillis() - lastVibrationUptime < VIBRATION_DURATION) {
                     return;
                   }

                   float displacement = calculateRelativeDisplacement(value);

                   // Use some sort of minimum displacement so the final few frames
                   // of animation don't generate a vibration.
                   if (displacement < SPIN_MIN_DISPLACEMENT) {
                     return;
                   }

                   lastVibrationUptime = SystemClock.uptimeMillis();
                   vibrator.vibrate(
                     VibrationEffect.startComposition()
                       .addPrimitive(VibrationEffect.Composition.PRIMITIVE_SPIN, nextSpinScale(displacement))
                       .addPrimitive(VibrationEffect.Composition.PRIMITIVE_SPIN, nextSpinScale(displacement))
                       .compose());
                 }

                 // Calculate a random scale for each spin to vary the full effect.
                 float nextSpinScale(float displacement) {
                   // Generate a random offset in [-0.1,+0.1] to be added to the vibration
                   // scale so the spin effects have slightly different values.
                   float randomOffset = vibrationRandom.nextFloat() * 0.2f - 0.1f
                   return MathUtils.clamp(displacement + randomOffset, 0f, 1f)
                 }
               }

   .. rubric:: Sample: Bounce (with thuds)
      :name: bounce

   Another advanced application of vibration effects is to simulate physical
   interactions. The
   `PRIMITIVE_THUD <https://developer.android.google.cn/reference/android/os/VibrationEffect.Composition#PRIMITIVE_THUD>`__
   can create a strong and reverberating effect, which can be paired with the
   visualization of an impact, in a video or animation for example, to augment
   the overall experience.

   Here is an example of a simple ball drop animation enhanced with a thud
   effect played each time the ball bounces off the bottom of the screen:

   **Note:**\  This sample app is available as part of the `Haptic Sampler app <https://github.com/android/platform-samples/tree/main/samples/user-interface/haptics>`__
   on GitHub.

   .. container:: demo-container

      .. container:: demo-with-frame

         |image-demo-portrait| |Animation of a dropped ball bouncing off the bottom of the
         screen|

   .. container:: waveform-container

      |image-bounce-waveform|

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               enum class BallPosition {
                   Start,
                   End
               }

               @Composable
               fun BounceScreen() {
                 // Control variable for the state of the ball.
                 var ballPosition by remember { mutableStateOf(BallPosition.Start) }
                 var bounceCount by remember { mutableStateOf(0) }

                 // Animation for the bouncing ball.
                 var transitionData = updateTransitionData(ballPosition)
                 val collisionData = updateCollisionData(transitionData)

                 // Ball is about to contact floor, only vibrating once per collision.
                 var hasVibratedForBallContact by remember { mutableStateOf(false) }
                 if (collisionData.collisionWithFloor) {
                   if (!hasVibratedForBallContact) {
                     val vibrationScale = 0.7.pow(bounceCount++).toFloat()
                     vibrator.vibrate(
                       VibrationEffect.startComposition().addPrimitive(
                         VibrationEffect.Composition.PRIMITIVE_THUD,
                         vibrationScale
                       ).compose()
                     )
                     hasVibratedForBallContact = true
                   }
                 } else {
                   // Reset for next contact with floor.
                   hasVibratedForBallContact = false
                 }

                 Screen() {
                   Box(
                     Modifier
                       .fillMaxSize()
                       .clickable {
                         if (transitionData.isAtStart) {
                           ballPosition = BallPosition.End
                         } else {
                           ballPosition = BallPosition.Start
                           bounceCount = 0
                         }
                       },
                   ) {
                     // Build the ball UI based on the current state.
                     BouncingBall(transitionData)
                   }
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class ClickListener implements View.OnClickListener {
                 @Override
                 public void onClick(View view) {
                   view.animate()
                     .translationY(targetY)
                     .setDuration(3000)
                     .setInterpolator(new BounceInterpolator())
                     .setUpdateListener(new AnimatorUpdateListener() {

                       boolean hasVibratedForBallContact = false;
                       int bounceCount = 0;

                       @Override
                       public void onAnimationUpdate(ValueAnimator animator) {
                         boolean valueBeyondThreshold = (float) animator.getAnimatedValue() > 0.98;
                         if (valueBeyondThreshold) {
                           if (!hasVibratedForBallContact) {
                             float vibrationScale = (float) Math.pow(0.7, bounceCount++);
                             vibrator.vibrate(
                               VibrationEffect.startComposition()
                                 .addPrimitive(VibrationEffect.Composition.PRIMITIVE_THUD, vibrationScale)
                                 .compose());
                             hasVibratedForBallContact = true;
                           }
                         } else {
                           // Reset for next contact with floor.
                           hasVibratedForBallContact = false;
                         }
                       }
                     });
                 }
               }


Last updated 2024-02-22 UTC.

.. |image-demo-portrait| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/demo-portrait.svg
   :class: frame
.. |Animation of a circle being dragged down| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/resist-demo.gif
   :class: demo
.. |Plot of input vibration waveform| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/resist-waveform.svg
   :class: waveform
.. |image-demo-portrait| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/demo-portrait.svg
   :class: frame
.. |Animation of an expanding circle| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/expand-demo.gif
   :class: demo
.. |image-expand-waveform| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/expand-waveform.svg
   :class: waveform
.. |image-demo-portrait| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/demo-portrait.svg
   :class: frame
.. |Animation of an elastic shape bouncing| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/wobble-demo.gif
   :class: demo
.. |image-wobble-waveform| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/wobble-waveform.svg
   :class: waveform
.. |image-demo-portrait| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/demo-portrait.svg
   :class: frame
.. |Animation of a dropped ball bouncing off the bottom of the screen| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/bounce-demo.gif
   :class: demo
.. |image-bounce-waveform| image:: https://developer.android.google.cn/static/develop/ui/views/haptics/images/bounce-waveform.svg
   :class: waveform


/Haptics API reference
======================

.. https://developer.android.google.cn/develop/ui/views/haptics/haptics-apis?hl=en

.. container:: devsite-article-body

   This section gives an introduction to the various haptics APIs available in
   Android. It also covers when and how to check for any device support
   necessary to ensure your haptic effects play as you intend.

   There are several different ways to create haptic effects, and it's important
   to consider Android haptics `design principles <#>`__ when choosing
   among them. The following table summarizes these high level attributes of
   each approach:

   -  *Availability* is particularly important when planning behavior fallback,
      and needs to be combined with checking individual device support.
   -  `Clear haptics <#clear_haptics>`__
      are crisp and clean sensations that are less jarring for users.
   -  `Rich haptics <#rich_haptics>`__
      have greater expressiveness and often require more feature-rich hardware.

   +-------------------+-------------------+-------------------+-------------------+
   | API surface       | Availability      | Clear haptics     | Rich haptics      |
   +===================+===================+===================+===================+
   | `Hapt             | Android 1.5+      |                   |                   |
   | icFeedbackConstan | (per constant)    |                   |                   |
   | ts <#haptic_feedb |                   |                   |                   | | ack_constants>`__ |                   |                   |                   |
   +-------------------+-------------------+-------------------+-------------------+
   | `Predefined       | Android 10+       |                   |                   |
   | VibrationEffect   |                   |                   |                   |
   |  <#predefined_vib |                   |                   |                   | | ration_effect>`__ |                   |                   |                   |
   +-------------------+-------------------+-------------------+-------------------+
   | `VibrationEffect  | Android 11+ (per  |                   |                   |
   | Composition       | constant)         |                   |                   |
   | <#vibration_effec |                   |                   |                   | | t_composition>`__ |                   |                   |                   |
   +-------------------+-------------------+-------------------+-------------------+
   | `On/off, one-shot | Android 1         |                   |                   |
   | and waveform      |                   |                   |                   |
   | vibrations <#on_o |                   |                   |                   | | ff_vibrations>`__ |                   |                   |                   |
   +-------------------+-------------------+-------------------+-------------------+

   Additionally, `notification APIs <#notification_apis>`__, described on this
   page, allows you to customize the haptic effects that play for incoming
   notifications.

   Also described on this page are additional concepts that span the API
   surfaces:

   -  `Does the device have a vibrator? <#has_vibrator>`__
   -  `Amplitude control <#amplitude_control>`__ allows smoother, richer haptic
      effects, but is not supported by all devices.
   -  `VibrationAttributes() <#vibration_attributes>`__ helps you classify
      vibration based on its usage, ensuring the appropriate user settings will
      be applied to it and thus avoiding surprises to the user.

   .. rubric:: ``HapticFeedbackConstants``
      :name: haptic_feedback_constants

   The
   `HapticFeedbackConstants <#android.view.HapticFeedbackConstants>`__
   class provides action-based constants to allow apps to add haptic feedback
   that's consistent across the device experience, rather than each app having
   different effects for common actions.

   .. rubric:: Compatibility and requirements
      :name: haptic_feedback_constants_reqs

   Using the
   `View.performHapticFeedback <#android.view.View>`__
   method with these constants does not require any special permissions for the
   app. It is subject to the
   `View.hapticFeedbackEnabled <#android.view.View>`__
   property, which if set to ``false`` will disable all haptic feedback calls on
   the view, including default ones.The primary related setting the
   `View.hapticFeedbackEnabled <#android.view.View>`__
   property, which if set to ``false`` will disable all haptic feedback calls on
   the view, including default ones. The method also honours the user's system
   setting for enabling touch feedback.

   The only compatibility consideration is the SDK-level of the specific
   constant for the action.

   There is no need to provide fallback behavior when using
   `HapticFeedbackConstants <#android.view.HapticFeedbackConstants>`__.

   .. rubric:: Usage of ``HapticsFeedbackConstants``
      :name: hapticsfeedbackconstants

   For details on using ``HapticFeedbackConstants``, see `Add haptic feedback to events <#>`__.

   .. rubric:: Predefined ``VibrationEffect``
      :name: predefined_vibration_effect

   The `VibrationEffect <#android.os.VibrationEffect>`__
   class provides several predefined constants such as ``CLICK``, ``TICK`` and
   ``DOUBLE_CLICK``. These effects may be optimized for the device.

   .. rubric:: Compatibility and requirements
      :name: predefined_vibration_effect_reqs

   Playing any ``VibrationEffect`` requires the ``VIBRATE`` permission in the
   app manifest.

   There is no need to provide fallback behavior when using predefined
   ``VibrationEffect``, as constants that don't have a device-optimized
   implementation revert to a standard platform fallback.

   The
   `Vibrator.areEffectsSupported <#android.os.Vibrator>`__
   and
   `Vibrator.areAllEffectsSupported <#android.os.Vibrator>`__
   APIs are for determining if there is a *device-optimized implementation*.
   Predefined effects can still be used without an optimized implementation, and
   uses the standard platform fallback. Consequently, these
   ``areEffectsSupported`` APIs are only needed if an application wants to take
   into consideration whether the effect is optimized for the device or not.

   The effect-checking methods can return one of three values:

   -  `VIBRATION_EFFECT_SUPPORT_YES <#android.os.Vibrator>`__
      indicates that the device has optimized support for this effect.
   -  `VIBRATION_EFFECT_SUPPORT_NO <#android.os.Vibrator>`__
      indicates that the device does not have optimized support, but still uses
      the platform fallback.
   -  `VIBRATION_EFFECT_SUPPORT_UNKNOWN <#android.os.Vibrator>`__
      indicates the system doesn't know if the implementation is optimized or
      not.

   As the ``UNKNOWN`` value indicates the checking API is unavailable, it's
   typically returned for all effects or none of them. These devices fall back
   dynamically.

   .. rubric:: Usage of predefined ``VibrationEffect``
      :name: predefined_vibration_effect_usage

   For details on using a predefined ``VibrationEffect``, see `Use a predefined ``VibrationEffect`` to generate haptic
   feedback <#using_a_predefined_vibrationeffect>`__.

   .. rubric:: ``VibrationEffect`` composition
      :name: vibration_effect_composition

   A `VibrationEffect <#android.os.VibrationEffect>`__ composition
   is a vibration effect created using the
   `VibrationEffect.startComposition <#android.os.VibrationEffect>`__
   API. This API allows expressive `rich haptics <#rich_haptics>`__ by
   creating a sequence of primitives with customized delays and intensities.
   However, take special care to ensure that the device supports the features
   being combined to avoid an inconsistent overall experience.

   .. rubric:: Compatibility and requirements
      :name: vibration_effect_composition_reqs

   Playing any ``VibrationEffect`` requires the ``VIBRATE`` permission in the
   app manifest.

   Not all devices support all features of the composition API, and it is
   important to ensure that the *primitives* are available.

   .. rubric:: Check for vibration primitive support
      :name: vibration_effect_composition_check

   **Caution:**\  If a composition contains primitives that aren't supported by
   the device, the entire ``VibrationEffect.Composition`` won't play any
   vibration. Therefore, to ensure a predictable experience, the set of
   primitives used in your app should be checked for support when considering
   which haptic experiences to enable.
   Per-primitive support can be retrieved using the
   `Vibrator.arePrimitivesSupported <#android.os.Vibrator>`__
   method. Alternatively, a set of primitives may be checked together by using
   the
   `Vibrator.areAllPrimitivesSupported <#android.os.Vibrator>`__
   method - this is equivalent to ``AND``-ing the per-primitive support.

   **Note:**\  The support for checking individual primitives is fully available
   starting in Android 12 (SDK 31). In Android 11, the check relies only in the
   ability to compose primitives, returning ``TRUE`` for all requested primitive
   IDs.

   .. rubric:: Usage of ``VibrationEffect`` Compositions
      :name: vibration_effect_composition_usage

   For details on using ``VibrationEffect`` compositions, see `Create vibration compositions <#vibration_compositions>`__.

   .. rubric:: On-off, one-shot, and waveform vibrations
      :name: on_off_vibrations

   The oldest form of vibration supported on Android is simple vibrator on-off
   patterns with configurable durations. These APIs are typically not well
   aligned with `Haptics design principles <#>`__ because they can
   generate `buzzy haptics <#buzzy_haptics>`__;
   avoid them except as a last resort.

   The most common use case for on-off vibrations is notifications, where, no
   matter what, some vibration is desired. *Waveform vibrations* also uniquely
   allow a pattern to repeat indefinitely, as you might imagine for a ringtone.

   A *one-shot pattern* refers to vibrating once for N milliseconds.

   There are two types of *waveform* patterns:

   -  **Timings-only.** This type of waveform is a description of alternating
      durations spent off, and durations spent on. The timings start with the
      duration spent off. Consequently, waveform patterns often start with a
      zero value to indicate to immediately start vibrating.
   -  **Timings and amplitudes.** This type of waveform has an additional array
      of amplitudes to match with each timing figure, rather than the implicit
      on-off of the first form. However, it's important to check that the device
      supports amplitude control to ensure that the intended scaling can be
      achieved.

   .. rubric:: Compatibility and requirements
      :name: on_off_vibrations_reqs

   As on-off vibrations are the oldest form of vibrations, these are supported
   on virtually all devices `with a vibrator <#has_vibrator>`__, as described
   later on this page.

   Playing any ``VibrationEffect`` or the older style ``vibrate`` calls,
   requires the ``VIBRATE`` permission in the app manifest.

   When using different amplitude values in a waveform, we strongly recommend
   that you that the device supports *amplitude control*.

   .. rubric:: Check for amplitude control support
      :name: on_off_vibrations_checking

   Non-zero amplitude values are rounded up to 100% on devices without amplitude
   control, so it is important to check if the support is present using
   `Vibrator.hasAmplitudeControl <#android.os.Vibrator>`__.
   See the `amplitude control <#amplitude_control>`__ for
   more details.

   You should carefully consider whether your effect has sufficient quality
   without amplitude control. Falling back to an explicitly designed on-off
   vibration may be better.

   .. rubric:: Usage of on-off vibrations
      :name: on_off_vibrations_usage

   In newer SDK levels, all vibration modes were consolidated into a single
   expressive `VibrationEffect <#android.os.VibrationEffect>`__
   class, where these simple vibrations are created using
   `VibrationEffect.createOneshot <#android.os.VibrationEffect>`__
   or
   `VibrationEffect.createWaveform <#android.os.VibrationEffect>`__.

   .. rubric:: Notification APIs
      :name: notification_apis

   When customizing your app notifications, you can use one of the following
   APIs to associate a pattern with each notification channel:

   -  AndroidX

      -  `NotificationChannelCompat.Builder.setVibrationPattern <#androidx.core.app.NotificationChannelCompat.Builder>`__
      -  `NotificationCompat.setVibrate <#androidx.core.app.NotificationCompat.Builder>`__

   -  Android

      -  `NotificationChannel.setVibrationPattern <#android.app.NotificationChannel>`__
      -  (deprecated)
         `NotificationBuilder.setVibrate <#android.app.Notification.Builder>`__

   All of these forms take a basic `on-off waveform pattern <#on_off_vibrations>`__, as described earlier, where the first entry
   is the delay before turning the vibrator on.

   .. rubric:: General concepts
      :name: general_concepts

   Several concepts apply across the API surfaces detailed above.

   .. rubric:: Does the device have a vibrator?
      :name: has_vibrator

   You can obtain a non-null `Vibrator <#android.os.Vibrator>`__
   class from ``context.getSystemService(Vibrator.class)``. If the device
   doesn't have a vibrator, calls to the vibration APIs don't have any effect,
   so apps don't need to gate all of their haptics on a condition. However, if
   needed, an application can call
   `hasVibrator() <#android.os.Vibrator>`__ to
   determine if this is a real vibrator (``true``) or a stub (``false``).

   .. rubric:: Has the user disabled touch haptics?
      :name: user_disables_touch_haptics

   Some custom implementations may require manually checking whether the user
   has entirely disabled Android's `Touch feedback <https://support.google.com/accessibility/android/answer/9078946>`__
   setting, in which case touch feedback effects should be suppressed. This
   setting can be queried using the
   `HAPTIC_FEEDBACK_ENABLED <#android.provider.Settings.System>`__
   key, where a value of zero means disabled.

   .. rubric:: Vibration attributes
      :name: vibration_attributes

   Vibration attributes (currently in the form of
   `AudioAttributes <#android.media.AudioAttributes>`__) can be
   provided to help inform the system of the purpose of the vibration. This is
   required when initiating a vibration when your app is in the background, as
   only attentional haptics are supported for background usage.

   The creation of ``AudioAttributes`` is covered in its class documentation,
   and should be thought of as *vibration* rather than *sound*.

   As a guide, in most cases, the content type is ``CONTENT_TYPE_SONIFICATION``,
   and the usage might be values such as ``USAGE_ASSISTANCE_SONIFICATION`` for
   touch feedback in the foreground, or ``USAGE_ALARM`` for an alarm in the
   background. Audio flags have no effect on vibrations.

   .. rubric:: Amplitude control
      :name: amplitude_control

   If a vibrator has amplitude control, then it can play vibrations with varying
   intensities. This is an important capability for producing `rich haptics <#rich_haptics>`__, as
   well as potentially allowing user control of default haptic intensities.

   Amplitude control support can be checked by calling
   `Vibrator.hasAmplitudeControl <#android.os.Vibrator>`__.
   If a vibrator does not have amplitude support, *all amplitude values will map
   to off/on based on whether they are zero/non-zero*. Consequently,
   applications using rich haptics with varying amplitudes should consider
   disabling them if the device lacks amplitude control.


Last updated 2024-02-22 UTC.


/About game controllers
=======================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers?hl=en

.. container:: devsite-article-body

   You can enhance the user experience in your game by letting players use game
   controllers. The Android framework provides APIs for detecting and processing
   user input from game controllers.

   This guide shows how to make your game work consistently with game
   controllers across different Android API levels (API level 9 and up) and how
   to enhance the gaming experience for players by supporting multiple
   controllers simultaneously in your app.

   **Note:** If you are developing games or writing a C++ app, use the `Game Controller Library <#>`__ that is part of the
   `Android Game Development Kit (AGDK) <#>`__ instead.

   .. rubric:: Lessons
      :name: lessons

   `Handle controller actions <#>`__
      Learn how to handle user input from common input elements on game
      controllers, including directional pad (D-pad) buttons, gamepad buttons,
      and joysticks.
   `Support controllers across Android versions <#>`__
      Learn how to make game controllers behave the same across devices running
      different versions of Android.
   `Support multiple game controllers <#>`__
      Learn how to detect and use multiple game controllers that are
      simultaneously connected.
   `Additional game controller features <#>`__
      Learn how to use additional controller features.


Last updated 2024-05-03 UTC.


/Handle controller actions
==========================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/controller-input?hl=en

.. container:: devsite-article-body

   At the system level, Android reports input event codes from game controllers
   as Android key codes and axis values. In your game, you can receive these
   codes and values and convert them to specific in-game actions.

   When players physically connect or wirelessly pair a game controller to their
   Android-powered devices, the system auto-detects the controller as an input
   device and starts reporting its input events. Your game can receive these
   input events by implementing the following callback methods in your active
   `Activity <#android.app.Activity>`__ or focused
   `View <#android.view.View>`__ (you should implement the
   callbacks for either the `Activity <#android.app.Activity>`__
   or `View <#android.view.View>`__, but not both):

   -  From `Activity <#android.app.Activity>`__:

      -  `dispatchGenericMotionEvent(android.view. MotionEvent) <#android.app.Activity>`__

         Called to process generic motion events such as joystick movements.

      -  `dispatchKeyEvent(android.view.KeyEvent) <#android.app.Activity>`__

         Called to process key events such as a press or release of a gamepad or
         D-pad button.

   -  From `View <#android.view.View>`__:

      -  `onGenericMotionEvent(android.view.MotionEvent) <#android.view.View>`__

         Called to process generic motion events such as joystick movements.

      -  `onKeyDown(int, android.view.KeyEvent) <#android.view.View>`__

         Called to process a press of a physical key such as a gamepad or D-pad
         button.

      -  `onKeyUp(int, android.view.KeyEvent) <#android.view.View>`__

         Called to process a release of a physical key such as a gamepad or
         D-pad button.

   The recommended approach is to capture the events from the specific
   `View <#android.view.View>`__ object that the user interacts
   with. Inspect the following objects provided by the callbacks to get
   information about the type of input event received:

   `KeyEvent <#android.view.KeyEvent>`__
      An object that describes directional pad (D-pad) and gamepad button
      events. Key events are accompanied by a *key code* that indicates the
      specific button triggered, such as
      `DPAD_DOWN <#android.view.KeyEvent>`__ or
      `BUTTON_A <#android.view.KeyEvent>`__. You
      can obtain the key code by calling
      `getKeyCode() <#android.view.KeyEvent>`__ or
      from key event callbacks such as
      `onKeyDown() <#android.view.View>`__.
   `MotionEvent <#android.view.MotionEvent>`__
      An object that describes input from joystick and shoulder trigger
      movements. Motion events are accompanied by an action code and a set of
      *axis values*. The action code specifies the state change that occurred
      such as a joystick being moved. The axis values describe the position and
      other movement properties for a specific physical control, such as
      `AXIS_X <#android.view.MotionEvent>`__ or
      `AXIS_RTRIGGER <#android.view.MotionEvent>`__.
      You can obtain the action code by calling
      `getAction() <#android.view.MotionEvent>`__ and
      the axis value by calling
      `getAxisValue() <#android.view.MotionEvent>`__.

   This lesson focuses on how you can handle input from the most common types of
   physical controls (gamepad buttons, directional pads, and joysticks) in a
   game screen by implementing the above-mentioned
   `View <#android.view.View>`__ callback methods and processing
   `KeyEvent <#android.view.KeyEvent>`__ and
   `MotionEvent <#android.view.MotionEvent>`__ objects.

   .. rubric:: Verify a game controller is connected
      :name: input

   When reporting input events, Android does not distinguish between events that
   came from a non-game controller device and events that came from a game
   controller. For example, a touch screen action generates an
   `AXIS_X <#android.view.MotionEvent>`__ event that
   represents the X coordinate of the touch surface, but a joystick generates an
   `AXIS_X <#android.view.MotionEvent>`__ event that
   represents the X position of the joystick. If your game cares about handling
   game-controller input, you should first check that the input event comes from
   a relevant source type.

   To verify that a connected input device is a game controller, call
   `getSources() <#android.view.InputDevice>`__ to
   obtain a combined bit field of input source types supported on that device.
   You can then test to see if the following fields are set:

   -  A source type of
      `SOURCE_GAMEPAD <#android.view.InputDevice>`__
      indicates that the input device has gamepad buttons (for example,
      `BUTTON_A <#android.view.KeyEvent>`__).
      Note that this source type does not strictly indicate if the game
      controller has D-pad buttons, although most gamepads typically have
      directional controls.
   -  A source type of
      `SOURCE_DPAD <#android.view.InputDevice>`__
      indicates that the input device has D-pad buttons (for example,
      `DPAD_UP <#android.view.KeyEvent>`__).
   -  A source type of
      `SOURCE_JOYSTICK <#android.view.InputDevice>`__
      indicates that the input device has analog control sticks (for example, a
      joystick that records movements along
      `AXIS_X <#android.view.MotionEvent>`__ and
      `AXIS_Y <#android.view.MotionEvent>`__).

   The following code snippet shows a helper method that lets you check whether
   the connected input devices are game controllers. If so, the method retrieves
   the device IDs for the game controllers. You can then associate each device
   ID with a player in your game, and process game actions for each connected
   player separately. To learn more about supporting multiple game controllers
   that are simultaneously connected on the same Android device, see `Support
   multiple game controllers <#>`__.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            fun getGameControllerIds(): List<Int> {
                val gameControllerDeviceIds = mutableListOf<Int>()
                val deviceIds = InputDevice.getDeviceIds()
                deviceIds.forEach { deviceId ->
                    InputDevice.getDevice(deviceId).apply {

                        // Verify that the device has gamepad buttons, control sticks, or both.
                        if (sources and InputDevice.SOURCE_GAMEPAD == InputDevice.SOURCE_GAMEPAD
                                || sources and InputDevice.SOURCE_JOYSTICK == InputDevice.SOURCE_JOYSTICK) {
                            // This device is a game controller. Store its device ID.
                            gameControllerDeviceIds
                                    .takeIf { !it.contains(deviceId) }
                                    ?.add(deviceId)
                        }
                    }
                }
                return gameControllerDeviceIds
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public ArrayList<Integer> getGameControllerIds() {
                ArrayList<Integer> gameControllerDeviceIds = new ArrayList<Integer>();
                int[] deviceIds = InputDevice.getDeviceIds();
                for (int deviceId : deviceIds) {
                    InputDevice dev = InputDevice.getDevice(deviceId);
                    int sources = dev.getSources();

                    // Verify that the device has gamepad buttons, control sticks, or both.
                    if (((sources & InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD)
                            || ((sources & InputDevice.SOURCE_JOYSTICK)
                            == InputDevice.SOURCE_JOYSTICK)) {
                        // This device is a game controller. Store its device ID.
                        if (!gameControllerDeviceIds.contains(deviceId)) {
                            gameControllerDeviceIds.add(deviceId);
                        }
                    }
                }
                return gameControllerDeviceIds;
            }

   Additionally, you might want to check for individual input capabilities
   supported by a connected game controller. This might be useful, for example,
   if you want your game to use only input from the set of physical controls it
   understands.

   To detect if a specific key code or axis code is supported by a connected
   game controller, use these techniques:

   -  In Android 4.4 (API level 19) or higher, you can determine if a key code
      is supported on a connected game controller by calling
      `hasKeys(int...) <#android.view.InputDevice>`__.
   -  In Android 3.1 (API level 12) or higher, you can find all available axes
      supported on a connected game controller by first calling
      `getMotionRanges() <#android.view.InputDevice>`__.
      Then, on each
      `InputDevice.MotionRange <#android.view.InputDevice.MotionRange>`__
      object returned, call
      `getAxis() <#android.view.InputDevice.MotionRange>`__
      to get its axis ID.

   .. rubric:: Process gamepad button presses
      :name: button

   Figure 1 shows how Android maps key codes and axis values to the physical
   controls on most game controllers.

   |image-game-controller-profiles|
   **Figure 1.** Profile for a generic game controller.

   The callouts in the figure refer to the following:

   .. container::

      1.  `AXIS_HAT_X <#android.view.MotionEvent>`__,
          `AXIS_HAT_Y <#android.view.MotionEvent>`__,
          `DPAD_UP <#android.view.KeyEvent>`__,
          `DPAD_DOWN <#android.view.KeyEvent>`__,
          `DPAD_LEFT <#android.view.KeyEvent>`__,
          `DPAD_RIGHT <#android.view.KeyEvent>`__
      2.  `AXIS_X <#android.view.MotionEvent>`__,
          `AXIS_Y <#android.view.MotionEvent>`__,
          `BUTTON_THUMBL <#android.view.KeyEvent>`__
      3.  `AXIS_Z <#android.view.MotionEvent>`__,
          `AXIS_RZ <#android.view.MotionEvent>`__,
          `BUTTON_THUMBR <#android.view.KeyEvent>`__
      4.  `BUTTON_X <#android.view.KeyEvent>`__
      5.  `BUTTON_A <#android.view.KeyEvent>`__
      6.  `BUTTON_Y <#android.view.KeyEvent>`__
      7.  `BUTTON_B <#android.view.KeyEvent>`__
      8.  `BUTTON_R1 <#android.view.KeyEvent>`__
      9.  `AXIS_RTRIGGER <#android.view.MotionEvent>`__,
          `AXIS_THROTTLE <#android.view.MotionEvent>`__
      10. `AXIS_LTRIGGER <#android.view.MotionEvent>`__,
          `AXIS_BRAKE <#android.view.MotionEvent>`__
      11. `BUTTON_L1 <#android.view.KeyEvent>`__

   Common key codes generated by gamepad button presses include
   `BUTTON_A <#android.view.KeyEvent>`__,
   `BUTTON_B <#android.view.KeyEvent>`__,
   `BUTTON_SELECT <#android.view.KeyEvent>`__,
   and
   `BUTTON_START <#android.view.KeyEvent>`__.
   Some game controllers also trigger the
   `DPAD_CENTER <#android.view.KeyEvent>`__
   key code when the center of the D-pad crossbar is pressed. Your game can
   inspect the key code by calling
   `getKeyCode() <#android.view.KeyEvent>`__ or from
   key event callbacks such as
   `onKeyDown() <#android.view.View>`__,
   and if it represents an event that is relevant to your game, process it as a
   game action. Table 1 lists the recommended game actions for the most common
   gamepad buttons.

   **Table 1.** Recommended game actions for gamepad buttons.

   +--------------------------------------+--------------------------------------+
   | Game Action                          | Button Key Code                      |
   +======================================+======================================+
   | Start game in main menu, or          | ```BUTTON_START                      |
   | pause/unpause during game            | `` </reference/android/view/KeyEvent |
   |                                      | #KEYCODE_BUTTON_START>`__\ :sup:`\*` |
   +--------------------------------------+--------------------------------------+
   | Display menu                         | ```BUTTON_SELECT`                    |
   |                                      | ` </reference/android/view/KeyEvent# | |                                      | KEYCODE_BUTTON_SELECT>`__\ :sup:`\*` |
   |                                      | and                                  |
   |                                      | ```KEYC                              |
   |                                      | ODE_MENU`` </reference/android/view/ |
   |                                      | KeyEvent#KEYCODE_MENU>`__\ :sup:`\*` |
   +--------------------------------------+--------------------------------------+
   | Same as Android *Back* navigation    | `KEYCODE_BACK </reference/an     | | behavior described in the            | droid/view/KeyEvent#KEYCODE_BACK>`__ |
   | `Navigat                             |                                      | | ion <#>`__ |                                      |
   | design guide.                        |                                      |
   +--------------------------------------+--------------------------------------+
   | Navigate back to a previous item in  | `BUTTON_B </reference/androi     | | a menu                               | d/view/KeyEvent#KEYCODE_BUTTON_B>`__ |
   +--------------------------------------+--------------------------------------+
   | Confirm selection, or perform        | `BUTTON_A </reference/androi     | | primary game action                  | d/view/KeyEvent#KEYCODE_BUTTON_A>`__ |
   |                                      | and                                  |
   |                                      | ``                                   |
   |                                      | `DPAD_CENTER`` </reference/android/v |
   |                                      | iew/KeyEvent#KEYCODE_DPAD_CENTER>`__ |
   +--------------------------------------+--------------------------------------+

   *\* Your game should not rely on the presence of the Start, Select, or Menu
   buttons.*

   **Tip:** Consider providing a configuration screen in your game to allow
   users to personalize their own game controller mappings for game actions.

   The following snippet shows how you might override
   `onKeyDown() <#android.view.View>`__
   to associate the
   `BUTTON_A <#android.view.KeyEvent>`__ and
   `DPAD_CENTER <#android.view.KeyEvent>`__
   button presses with a game action.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class GameView(...) : View(...) {
                ...

                override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {
                    var handled = false
                    if (event.source and InputDevice.SOURCE_GAMEPAD == InputDevice.SOURCE_GAMEPAD) {
                        if (event.repeatCount == 0) {
                            when (keyCode) {
                                // Handle gamepad and D-pad button presses to navigate the ship
                                ...

                                else -> {
                                    keyCode.takeIf { isFireKey(it) }?.run {
                                        // Update the ship object to fire lasers
                                        ...
                                        handled = true
                                    }
                                }
                            }
                        }
                        if (handled) {
                            return true
                        }
                    }
                    return super.onKeyDown(keyCode, event)
                }

                // Here we treat Button_A and DPAD_CENTER as the primary action
                // keys for the game.
                private fun isFireKey(keyCode: Int): Boolean =
                        keyCode == KeyEvent.KEYCODE_DPAD_CENTER || keyCode == KeyEvent.KEYCODE_BUTTON_A
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class GameView extends View {
                ...

                @Override
                public boolean onKeyDown(int keyCode, KeyEvent event) {
                    boolean handled = false;
                    if ((event.getSource() & InputDevice.SOURCE_GAMEPAD)
                            == InputDevice.SOURCE_GAMEPAD) {
                        if (event.getRepeatCount() == 0) {
                            switch (keyCode) {
                                // Handle gamepad and D-pad button presses to
                                // navigate the ship
                                ...

                                default:
                                     if (isFireKey(keyCode)) {
                                         // Update the ship object to fire lasers
                                         ...
                                         handled = true;
                                     }
                                 break;
                            }
                        }
                        if (handled) {
                            return true;
                        }
                    }
                    return super.onKeyDown(keyCode, event);
                }

                private static boolean isFireKey(int keyCode) {
                    // Here we treat Button_A and DPAD_CENTER as the primary action
                    // keys for the game.
                    return keyCode == KeyEvent.KEYCODE_DPAD_CENTER
                            || keyCode == KeyEvent.KEYCODE_BUTTON_A;
                }
            }

   **Note:** On Android 4.2 (API level 17) and lower, the system treats
   `BUTTON_A <#android.view.KeyEvent>`__ as the
   Android *Back* key by default. If your app supports these Android versions,
   make sure to treat
   `BUTTON_A <#android.view.KeyEvent>`__ as the
   primary game action. To determine the current Android SDK version on the
   device, refer to the
   `Build.VERSION.SDK_INT <#android.os.Build.VERSION>`__
   value.

   .. rubric:: Process directional pad input
      :name: dpad

   The 4-way directional pad (D-pad) is a common physical control in many game
   controllers. Android reports D-pad UP and DOWN presses as
   `AXIS_HAT_Y <#android.view.MotionEvent>`__ events
   with a range from -1.0 (up) to 1.0 (down), and D-pad LEFT or RIGHT presses as
   `AXIS_HAT_X <#android.view.MotionEvent>`__ events
   with a range from -1.0 (left) to 1.0 (right).

   Some controllers instead report D-pad presses with a key code. If your game
   cares about D-pad presses, you should treat the hat axis events and the D-pad
   key codes as the same input events, as recommended in table 2.

   **Table 2.** Recommended default game actions for D-pad key codes and hat
   axis values.

   +-------------+-------------------------------+-------------------------------+
   | Game Action | D-pad Key Code                | Hat Axis Code                 |
   +=============+===============================+===============================+
   | Move Up     | `KEYCODE_DPAD_              | `AXIS_H                     | |             | UP`` </reference/android/view | AT_Y`` </reference/android/vi |
   |             | /KeyEvent#KEYCODE_DPAD_UP>`__ | ew/MotionEvent#AXIS_HAT_Y>`__ |
   |             |                               | (for values 0 to -1.0)        |
   +-------------+-------------------------------+-------------------------------+
   | Move Down   | `KEYCODE_DPAD_DOWN          | `AXIS_H                     | |             | `` </reference/android/view/K | AT_Y`` </reference/android/vi |
   |             | eyEvent#KEYCODE_DPAD_DOWN>`__ | ew/MotionEvent#AXIS_HAT_Y>`__ |
   |             |                               | (for values 0 to 1.0)         |
   +-------------+-------------------------------+-------------------------------+
   | Move Left   | `KEYCODE_DPAD_LEFT          | `AXIS_H                     | |             | `` </reference/android/view/K | AT_X`` </reference/android/vi |
   |             | eyEvent#KEYCODE_DPAD_LEFT>`__ | ew/MotionEvent#AXIS_HAT_X>`__ |
   |             |                               | (for values 0 to -1.0)        |
   +-------------+-------------------------------+-------------------------------+
   | Move Right  | `KEYCODE_DPAD_RIGHT`        | `AXIS_H                     | |             | ` </reference/android/view/Ke | AT_X`` </reference/android/vi |
   |             | yEvent#KEYCODE_DPAD_RIGHT>`__ | ew/MotionEvent#AXIS_HAT_X>`__ |
   |             |                               | (for values 0 to 1.0)         |
   +-------------+-------------------------------+-------------------------------+

   The following code snippet shows a helper class that lets you check the hat
   axis and key code values from an input event to determine the D-pad
   direction.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class Dpad {

                private var directionPressed = -1 // initialized to -1

                fun getDirectionPressed(event: InputEvent): Int {
                    if (!isDpadDevice(event)) {
                        return -1
                    }

                    // If the input event is a MotionEvent, check its hat axis values.
                    (event as? MotionEvent)?.apply {

                        // Use the hat axis value to find the D-pad direction
                        val xaxis: Float = event.getAxisValue(MotionEvent.AXIS_HAT_X)
                        val yaxis: Float = event.getAxisValue(MotionEvent.AXIS_HAT_Y)

                        directionPressed = when {
                            // Check if the AXIS_HAT_X value is -1 or 1, and set the D-pad
                            // LEFT and RIGHT direction accordingly.
                            xaxis.compareTo(-1.0f) == 0 -> Dpad.LEFT
                            xaxis.compareTo(1.0f) == 0 -> Dpad.RIGHT
                            // Check if the AXIS_HAT_Y value is -1 or 1, and set the D-pad
                            // UP and DOWN direction accordingly.
                            yaxis.compareTo(-1.0f) == 0 -> Dpad.UP
                            yaxis.compareTo(1.0f) == 0 -> Dpad.DOWN
                            else -> directionPressed
                        }
                    }
                    // If the input event is a KeyEvent, check its key code.
                    (event as? KeyEvent)?.apply {

                        // Use the key code to find the D-pad direction.
                        directionPressed = when(event.keyCode) {
                            KeyEvent.KEYCODE_DPAD_LEFT -> Dpad.LEFT
                            KeyEvent.KEYCODE_DPAD_RIGHT -> Dpad.RIGHT
                            KeyEvent.KEYCODE_DPAD_UP -> Dpad.UP
                            KeyEvent.KEYCODE_DPAD_DOWN -> Dpad.DOWN
                            KeyEvent.KEYCODE_DPAD_CENTER ->  Dpad.CENTER
                            else -> directionPressed
                        }
                    }
                    return directionPressed
                }

                companion object {
                    internal const val UP = 0
                    internal const val LEFT = 1
                    internal const val RIGHT = 2
                    internal const val DOWN = 3
                    internal const val CENTER = 4

                    fun isDpadDevice(event: InputEvent): Boolean =
                        // Check that input comes from a device with directional pads.
                        event.source and InputDevice.SOURCE_DPAD != InputDevice.SOURCE_DPAD
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class Dpad {
                final static int UP       = 0;
                final static int LEFT     = 1;
                final static int RIGHT    = 2;
                final static int DOWN     = 3;
                final static int CENTER   = 4;

                int directionPressed = -1; // initialized to -1

                public int getDirectionPressed(InputEvent event) {
                    if (!isDpadDevice(event)) {
                       return -1;
                    }

                    // If the input event is a MotionEvent, check its hat axis values.
                    if (event instanceof MotionEvent) {

                        // Use the hat axis value to find the D-pad direction
                        MotionEvent motionEvent = (MotionEvent) event;
                        float xaxis = motionEvent.getAxisValue(MotionEvent.AXIS_HAT_X);
                        float yaxis = motionEvent.getAxisValue(MotionEvent.AXIS_HAT_Y);

                        // Check if the AXIS_HAT_X value is -1 or 1, and set the D-pad
                        // LEFT and RIGHT direction accordingly.
                        if (Float.compare(xaxis, -1.0f) == 0) {
                            directionPressed =  Dpad.LEFT;
                        } else if (Float.compare(xaxis, 1.0f) == 0) {
                            directionPressed =  Dpad.RIGHT;
                        }
                        // Check if the AXIS_HAT_Y value is -1 or 1, and set the D-pad
                        // UP and DOWN direction accordingly.
                        else if (Float.compare(yaxis, -1.0f) == 0) {
                            directionPressed =  Dpad.UP;
                        } else if (Float.compare(yaxis, 1.0f) == 0) {
                            directionPressed =  Dpad.DOWN;
                        }
                    }

                    // If the input event is a KeyEvent, check its key code.
                    else if (event instanceof KeyEvent) {

                       // Use the key code to find the D-pad direction.
                        KeyEvent keyEvent = (KeyEvent) event;
                        if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_DPAD_LEFT) {
                            directionPressed = Dpad.LEFT;
                        } else if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_DPAD_RIGHT) {
                            directionPressed = Dpad.RIGHT;
                        } else if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_DPAD_UP) {
                            directionPressed = Dpad.UP;
                        } else if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_DPAD_DOWN) {
                            directionPressed = Dpad.DOWN;
                        } else if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_DPAD_CENTER) {
                            directionPressed = Dpad.CENTER;
                        }
                    }
                    return directionPressed;
                }

                public static boolean isDpadDevice(InputEvent event) {
                    // Check that input comes from a device with directional pads.
                    if ((event.getSource() & InputDevice.SOURCE_DPAD)
                         != InputDevice.SOURCE_DPAD) {
                         return true;
                     } else {
                         return false;
                     }
                 }
            }

   You can use this helper class in your game wherever you want to process D-pad
   input (for example, in the
   `onGenericMotionEvent() <#android.view.View>`__
   or
   `onKeyDown() <#android.view.View>`__
   callbacks).

   For example:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private val dpad = Dpad()
            ...
            override fun onGenericMotionEvent(event: MotionEvent): Boolean {
                if (Dpad.isDpadDevice(event)) {
                    when (dpad.getDirectionPressed(event)) {
                        Dpad.LEFT -> {
                            // Do something for LEFT direction press
                            ...
                            return true
                        }
                        Dpad.RIGHT -> {
                            // Do something for RIGHT direction press
                            ...
                            return true
                        }
                        Dpad.UP -> {
                            // Do something for UP direction press
                            ...
                            return true
                        }
                        ...
                    }
                }

                // Check if this event is from a joystick movement and process accordingly.
                ...
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            Dpad dpad = new Dpad();
            ...
            @Override
            public boolean onGenericMotionEvent(MotionEvent event) {

                // Check if this event if from a D-pad and process accordingly.
                if (Dpad.isDpadDevice(event)) {

                   int press = dpad.getDirectionPressed(event);
                   switch (press) {
                        case LEFT:
                            // Do something for LEFT direction press
                            ...
                            return true;
                        case RIGHT:
                            // Do something for RIGHT direction press
                            ...
                            return true;
                        case UP:
                            // Do something for UP direction press
                            ...
                            return true;
                        ...
                    }
                }

                // Check if this event is from a joystick movement and process accordingly.
                ...
            }

   .. rubric:: Process joystick movements
      :name: joystick

   When players move a joystick on their game controllers, Android reports a
   `MotionEvent <#android.view.MotionEvent>`__ that contains the
   `ACTION_MOVE <#android.view.MotionEvent>`__ action
   code and the updated positions of the joystick's axes. Your game can use the
   data provided by the
   `MotionEvent <#android.view.MotionEvent>`__ to determine if a
   joystick movement it cares about happened.

   Note that joystick motion events may batch multiple movement samples together
   within a single object. The
   `MotionEvent <#android.view.MotionEvent>`__ object contains the
   current position for each joystick axis as well as multiple historical
   positions for each axis. When reporting motion events with action code
   `ACTION_MOVE <#android.view.MotionEvent>`__ (such
   as joystick movements), Android batches up the axis values for efficiency.
   The historical values for an axis consists of the set of distinct values
   older than the current axis value, and more recent than values reported in
   any previous motion events. See the
   `MotionEvent <#android.view.MotionEvent>`__ reference for
   details.

   You can use the historical information to more accurately render a game
   object's movement based on the joystick input. To retrieve the current and
   historical values, call
   `getAxisValue() <#android.view.MotionEvent>`__
   or
   `getHistoricalAxisValue() <#android.view.MotionEvent>`__.
   You can also find the number of historical points in the joystick event by
   calling
   `getHistorySize() <#android.view.MotionEvent>`__.

   The following snippet shows how you might override the
   `onGenericMotionEvent() <#android.view.View>`__
   callback to process joystick input. You should first process the historical
   values for an axis, then process its current position.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            class GameView(...) : View(...) {

                override fun onGenericMotionEvent(event: MotionEvent): Boolean {

                    // Check that the event came from a game controller
                    return if (event.source and InputDevice.SOURCE_JOYSTICK == InputDevice.SOURCE_JOYSTICK
                            && event.action == MotionEvent.ACTION_MOVE) {

                        // Process the movements starting from the
                        // earliest historical position in the batch
                        (0 until event.historySize).forEach { i ->
                            // Process the event at historical position i
                            processJoystickInput(event, i)
                        }

                        // Process the current movement sample in the batch (position -1)
                        processJoystickInput(event, -1)
                        true
                    } else {
                        super.onGenericMotionEvent(event)
                    }
                }
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            public class GameView extends View {

                @Override
                public boolean onGenericMotionEvent(MotionEvent event) {

                    // Check that the event came from a game controller
                    if ((event.getSource() & InputDevice.SOURCE_JOYSTICK) ==
                            InputDevice.SOURCE_JOYSTICK &&
                            event.getAction() == MotionEvent.ACTION_MOVE) {

                        // Process all historical movement samples in the batch
                        final int historySize = event.getHistorySize();

                        // Process the movements starting from the
                        // earliest historical position in the batch
                        for (int i = 0; i < historySize; i++) {
                            // Process the event at historical position i
                            processJoystickInput(event, i);
                        }

                        // Process the current movement sample in the batch (position -1)
                        processJoystickInput(event, -1);
                        return true;
                    }
                    return super.onGenericMotionEvent(event);
                }
            }

   Before using joystick input, you need to determine if the joystick is
   centered, then calculate its axis movements accordingly. Joysticks typically
   have a *flat* area, that is, a range of values near the (0,0) coordinate at
   which the axis is considered to be centered. If the axis value reported by
   Android falls within the flat area, you should treat the controller to be at
   rest (that is, motionless along both axes).

   The snippet below shows a helper method that calculates the movement along
   each axis. You invoke this helper in the ``processJoystickInput()`` method
   described further below.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private fun getCenteredAxis(
                    event: MotionEvent,
                    device: InputDevice,
                    axis: Int,
                    historyPos: Int
            ): Float {
                val range: InputDevice.MotionRange? = device.getMotionRange(axis, event.source)

                // A joystick at rest does not always report an absolute position of
                // (0,0). Use the getFlat() method to determine the range of values
                // bounding the joystick axis center.
                range?.apply {
                    val value: Float = if (historyPos < 0) {
                        event.getAxisValue(axis)
                    } else {
                        event.getHistoricalAxisValue(axis, historyPos)
                    }

                    // Ignore axis values that are within the 'flat' region of the
                    // joystick axis center.
                    if (Math.abs(value) > flat) {
                        return value
                    }
                }
                return 0f
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private static float getCenteredAxis(MotionEvent event,
                    InputDevice device, int axis, int historyPos) {
                final InputDevice.MotionRange range =
                        device.getMotionRange(axis, event.getSource());

                // A joystick at rest does not always report an absolute position of
                // (0,0). Use the getFlat() method to determine the range of values
                // bounding the joystick axis center.
                if (range != null) {
                    final float flat = range.getFlat();
                    final float value =
                            historyPos < 0 ? event.getAxisValue(axis):
                            event.getHistoricalAxisValue(axis, historyPos);

                    // Ignore axis values that are within the 'flat' region of the
                    // joystick axis center.
                    if (Math.abs(value) > flat) {
                        return value;
                    }
                }
                return 0;
            }

   Putting it all together, here is how you might process joystick movements in
   your game:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            private fun processJoystickInput(event: MotionEvent, historyPos: Int) {

                val inputDevice = event.device

                // Calculate the horizontal distance to move by
                // using the input value from one of these physical controls:
                // the left control stick, hat axis, or the right control stick.
                var x: Float = getCenteredAxis(event, inputDevice, MotionEvent.AXIS_X, historyPos)
                if (x == 0f) {
                    x = getCenteredAxis(event, inputDevice, MotionEvent.AXIS_HAT_X, historyPos)
                }
                if (x == 0f) {
                    x = getCenteredAxis(event, inputDevice, MotionEvent.AXIS_Z, historyPos)
                }

                // Calculate the vertical distance to move by
                // using the input value from one of these physical controls:
                // the left control stick, hat switch, or the right control stick.
                var y: Float = getCenteredAxis(event, inputDevice, MotionEvent.AXIS_Y, historyPos)
                if (y == 0f) {
                    y = getCenteredAxis(event, inputDevice, MotionEvent.AXIS_HAT_Y, historyPos)
                }
                if (y == 0f) {
                    y = getCenteredAxis(event, inputDevice, MotionEvent.AXIS_RZ, historyPos)
                }

                // Update the ship object based on the new x and y values
            }

      .. container:: section

         .. rubric:: Java
            :name: java

         .. code:: prettyprint

            private void processJoystickInput(MotionEvent event,
                    int historyPos) {

                InputDevice inputDevice = event.getDevice();

                // Calculate the horizontal distance to move by
                // using the input value from one of these physical controls:
                // the left control stick, hat axis, or the right control stick.
                float x = getCenteredAxis(event, inputDevice,
                        MotionEvent.AXIS_X, historyPos);
                if (x == 0) {
                    x = getCenteredAxis(event, inputDevice,
                            MotionEvent.AXIS_HAT_X, historyPos);
                }
                if (x == 0) {
                    x = getCenteredAxis(event, inputDevice,
                            MotionEvent.AXIS_Z, historyPos);
                }

                // Calculate the vertical distance to move by
                // using the input value from one of these physical controls:
                // the left control stick, hat switch, or the right control stick.
                float y = getCenteredAxis(event, inputDevice,
                        MotionEvent.AXIS_Y, historyPos);
                if (y == 0) {
                    y = getCenteredAxis(event, inputDevice,
                            MotionEvent.AXIS_HAT_Y, historyPos);
                }
                if (y == 0) {
                    y = getCenteredAxis(event, inputDevice,
                            MotionEvent.AXIS_RZ, historyPos);
                }

                // Update the ship object based on the new x and y values
            }

   To support game controllers that have more sophisticated features beyond a
   single joystick, follow these best practices:

   -  **Handle dual controller sticks.** Many game controllers have both a left
      and right joystick. For the left stick, Android reports horizontal
      movements as `AXIS_X <#android.view.MotionEvent>`__
      events and vertical movements as
      `AXIS_Y <#android.view.MotionEvent>`__ events. For
      the right stick, Android reports horizontal movements as
      `AXIS_Z <#android.view.MotionEvent>`__ events and
      vertical movements as
      `AXIS_RZ <#android.view.MotionEvent>`__ events. Make
      sure to handle both controller sticks in your code.
   -  **Handle shoulder trigger presses (but provide alternative input
      methods).** Some controllers have left and right shoulder triggers. If
      these triggers are present, Android reports a left trigger press as an
      `AXIS_LTRIGGER <#android.view.MotionEvent>`__
      event and a right trigger press as an
      `AXIS_RTRIGGER <#android.view.MotionEvent>`__
      event. On Android 4.3 (API level 18), a controller that produces a
      `AXIS_LTRIGGER <#android.view.MotionEvent>`__
      also reports an identical value for the
      `AXIS_BRAKE <#android.view.MotionEvent>`__ axis.
      The same is true for
      `AXIS_RTRIGGER <#android.view.MotionEvent>`__
      and `AXIS_GAS <#android.view.MotionEvent>`__.
      Android reports all analog trigger presses with a normalized value from
      0.0 (released) to 1.0 (fully pressed). Not all controllers have triggers,
      so consider allowing players to perform those game actions with other
      buttons.


Last updated 2024-02-22 UTC.

.. |image-game-controller-profiles| image:: https://developer.android.google.cn/static/images/training/game-controller-profiles.png
   :name: figure1


/Add support across Android versions
====================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/compatibility?hl=en

.. container:: devsite-article-body

   If you are supporting game controllers in your game, it's your responsibility
   to make sure that your game responds to controllers consistently across
   devices running on different versions of Android. This lets your game reach a
   wider audience, and your players can enjoy a seamless gameplay experience
   with their controllers even when they switch or upgrade their Android
   devices.

   This lesson demonstrates how to use APIs available in Android 4.1 and higher
   in a backward compatible way, enabling your game to support the following
   features on devices running Android 3.1 and higher:

   -  The game can detect if a new game controller is added, changed, or
      removed.
   -  The game can query the capabilities of a game controller.
   -  The game can recognize incoming motion events from a game controller.

   The examples in this lesson are based on the reference implementation
   provided by the sample ``ControllerSample.zip`` available for download above.
   This sample shows how to implement the ``InputManagerCompat`` interface to
   support different versions of Android. To compile the sample, you must use
   Android 4.1 (API level 16) or higher. Once compiled, the sample app runs on
   any device running Android 3.1 (API level 12) or higher as the build target.

   .. rubric:: Prepare to abstract APIs for game controller support
      :name: prepare

   Suppose you want to be able to determine if a game controller's connection
   status has changed on devices running on Android 3.1 (API level 12). However,
   the APIs are only available in Android 4.1 (API level 16) and higher, so you
   need to provide an implementation that supports Android 4.1 and higher while
   providing a fallback mechanism that supports Android 3.1 up to Android 4.0.

   To help you determine which features require such a fallback mechanism for
   older versions, table 1 lists the differences in game controller support
   between Android 3.1 (API level 12) and 4.1 (API level 16).

   **Table 1.** APIs for game controller support across different Android
   versions.

   +----------------------+----------------------+--------------+--------------+
   | Controller           | Controller API       | API level 12 | API level 16 |
   | Information          |                      |              |              |
   +----------------------+----------------------+--------------+--------------+
   | Device               | ```getInputDevic     |              | •            |
   | Identification       | eIds()`` </reference |              |              |
   |                      | /android/hardware/in |              |              |
   |                      | put/InputManager#get |              |              |
   |                      | InputDeviceIds()>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | ```getInputDe        |              | •            |
   |                      | vice()`` </reference |              |              |
   |                      | /android/hardware/in |              |              |
   |                      | put/InputManager#get |              |              |
   |                      | InputDevice(int)>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | ```getVibrato        |              | •            |
   |                      | r()`` </reference/an |              |              |
   |                      | droid/view/InputDevi |              |              |
   |                      | ce#getVibrator()>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | ```SOURCE_JOYSTIC    | •            | •            |
   |                      | K`` </reference/andr |              |              |
   |                      | oid/view/InputDevice |              |              |
   |                      | #SOURCE_JOYSTICK>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | ```SOURCE_GAMEP      | •            | •            |
   |                      | AD`` </reference/and |              |              |
   |                      | roid/view/InputDevic |              |              |
   |                      | e#SOURCE_GAMEPAD>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   | Connection Status    | `                    |              | •            | |                      | ``onInputDeviceAdded |              |              |
   |                      | ()`` </reference/and |              |              |
   |                      | roid/hardware/input/ |              |              |
   |                      | InputManager.InputDe |              |              |
   |                      | viceListener#onInput |              |              |
   |                      | DeviceAdded(int)>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | ```on                |              | •            |
   |                      | InputDeviceChanged() |              |              |
   |                      | `` </reference/andro |              |              |
   |                      | id/hardware/input/In |              |              |
   |                      | putManager.InputDevi |              |              |
   |                      | ceListener#onInputDe |              |              |
   |                      | viceChanged(int)>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | ```on                |              | •            |
   |                      | InputDeviceRemoved() |              |              |
   |                      | `` </reference/andro |              |              |
   |                      | id/hardware/input/In |              |              |
   |                      | putManager.InputDevi |              |              |
   |                      | ceListener#onInputDe |              |              |
   |                      | viceRemoved(int)>`__ |              |              |
   +----------------------+----------------------+--------------+--------------+
   | Input Event          | D-pad press (        | •            | •            |
   | Identification       | ```KEYCODE_DPAD      |              |              |
   |                      | _UP`` </reference/an |              |              |
   |                      | droid/view/KeyEvent# |              |              |
   |                      | KEYCODE_DPAD_UP>`__, |              |              |
   |                      | ```KEYCODE_DPAD_DOW  |              |              |
   |                      | N`` </reference/andr |              |              |
   |                      | oid/view/KeyEvent#KE |              |              |
   |                      | YCODE_DPAD_DOWN>`__, |              |              |
   |                      | ```KEYCODE_DPAD_LEF  |              |              |
   |                      | T`` </reference/andr |              |              |
   |                      | oid/view/KeyEvent#KE |              |              |
   |                      | YCODE_DPAD_LEFT>`__, |              |              |
   |                      | `                    |              |              | |                      | ``KEYCODE_DPAD_RIGHT |              |              |
   |                      | `` </reference/andro |              |              |
   |                      | id/view/KeyEvent#KEY |              |              |
   |                      | CODE_DPAD_RIGHT>`__, |              |              |
   |                      | ```                  |              |              |
   |                      | KEYCODE_DPAD_CENTER` |              |              |
   |                      | ` </reference/androi |              |              |
   |                      | d/view/KeyEvent#KEYC |              |              | |                      | ODE_DPAD_CENTER>`__) |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | Gamepad button press | •            | •            |
   |                      | (                    |              |              |
   |                      | ```BUTTON            |              |              |
   |                      | _A`` </reference/and |              |              |
   |                      | roid/view/KeyEvent#K |              |              |
   |                      | EYCODE_BUTTON_A>`__, |              |              |
   |                      | ```BUTTON            |              |              |
   |                      | _B`` </reference/and |              |              |
   |                      | roid/view/KeyEvent#K |              |              |
   |                      | EYCODE_BUTTON_B>`__, |              |              |
   |                      | `BUTTON_THUMBL   |              |              |
   |                      | </reference/android/ |              |              |
   |                      | view/KeyEvent#KEYCOD |              |              | |                      | E_BUTTON_THUMBL>`__, |              |              |
   |                      | `BUTTON_THUMBR   |              |              |
   |                      | </reference/android/ |              |              |
   |                      | view/KeyEvent#KEYCOD |              |              | |                      | E_BUTTON_THUMBR>`__, |              |              |
   |                      | `BUTTON_SELECT   |              |              |
   |                      | </reference/android/ |              |              |
   |                      | view/KeyEvent#KEYCOD |              |              | |                      | E_BUTTON_SELECT>`__, |              |              |
   |                      | `BUTTON_START    |              |              |
   |                      |  </reference/android |              |              |
   |                      | /view/KeyEvent#KEYCO |              |              | |                      | DE_BUTTON_START>`__, |              |              |
   |                      | ```BUTTON_R          |              |              |
   |                      | 1`` </reference/andr |              |              |
   |                      | oid/view/KeyEvent#KE |              |              |
   |                      | YCODE_BUTTON_R1>`__, |              |              |
   |                      | ```BUTTON_L          |              |              |
   |                      | 1`` </reference/andr |              |              |
   |                      | oid/view/KeyEvent#KE |              |              |
   |                      | YCODE_BUTTON_L1>`__, |              |              |
   |                      | ```BUTTON_R          |              |              |
   |                      | 2`` </reference/andr |              |              |
   |                      | oid/view/KeyEvent#KE |              |              |
   |                      | YCODE_BUTTON_R2>`__, |              |              |
   |                      | ```BUTTON_L          |              |              |
   |                      | 2`` </reference/andr |              |              |
   |                      | oid/view/KeyEvent#KE |              |              |
   |                      | YCODE_BUTTON_L2>`__) |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | Joystick and hat     | •            | •            |
   |                      | switch movement (    |              |              |
   |                      | `AXIS_X </refere |              |              |
   |                      | nce/android/view/Mot |              |              | |                      | ionEvent#AXIS_X>`__, |              |              |
   |                      | `AXIS_Y </refere |              |              |
   |                      | nce/android/view/Mot |              |              | |                      | ionEvent#AXIS_Y>`__, |              |              |
   |                      | `AXIS_Z </refere |              |              |
   |                      | nce/android/view/Mot |              |              | |                      | ionEvent#AXIS_Z>`__, |              |              |
   |                      | ``                   |              |              |
   |                      | `AXIS_RZ`` </referen |              |              |
   |                      | ce/android/view/Moti |              |              |
   |                      | onEvent#AXIS_RZ>`__, |              |              |
   |                      | ```AXIS_             |              |              |
   |                      | HAT_X`` </reference/ |              |              |
   |                      | android/view/MotionE |              |              |
   |                      | vent#AXIS_HAT_X>`__, |              |              |
   |                      | ```AXIS_             |              |              |
   |                      | HAT_Y`` </reference/ |              |              |
   |                      | android/view/MotionE |              |              |
   |                      | vent#AXIS_HAT_Y>`__) |              |              |
   +----------------------+----------------------+--------------+--------------+
   |                      | Analog trigger press | •            | •            |
   |                      | (                    |              |              |
   |                      | ```AXIS_LTRIGG       |              |              |
   |                      | ER`` </reference/and |              |              |
   |                      | roid/view/MotionEven |              |              |
   |                      | t#AXIS_LTRIGGER>`__, |              |              |
   |                      | ```AXIS_RTRIGG       |              |              |
   |                      | ER`` </reference/and |              |              |
   |                      | roid/view/MotionEven |              |              |
   |                      | t#AXIS_RTRIGGER>`__) |              |              |
   +----------------------+----------------------+--------------+--------------+

   You can use abstraction to build version-aware game controller support that
   works across platforms. This approach involves the following steps:

   #. Define an intermediary Java interface that abstracts the implementation of
      the game controller features required by your game.
   #. Create a proxy implementation of your interface that uses APIs in Android
      4.1 and higher.
   #. Create a custom implementation of your interface that uses APIs available
      between Android 3.1 up to Android 4.0.
   #. Create the logic for switching between these implementations at runtime,
      and begin using the interface in your game.

   For an overview of how abstraction can be used to ensure that applications
   can work in a backward compatible way across different versions of Android,
   see `Creating Backward-Compatible UIs <#>`__.

   .. rubric:: Add an interface for backward compatibility
      :name: abstraction

   To provide backward compatibility, you can create a custom interface then add
   version-specific implementations. One advantage of this approach is that it
   lets you mirror the public interfaces on Android 4.1 (API level 16) that
   support game controllers.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The InputManagerCompat interface is a reference example.
               // The full code is provided in the ControllerSample.zip sample.
               interface InputManagerCompat {
                   val inputDeviceIds: IntArray
                   fun getInputDevice(id: Int): InputDevice

                   fun registerInputDeviceListener(
                           listener: InputManager.InputDeviceListener,
                           handler: Handler?
                   )

                   fun unregisterInputDeviceListener(listener:InputManager.InputDeviceListener)

                   fun onGenericMotionEvent(event: MotionEvent)

                   fun onPause()
                   fun onResume()

                   interface InputDeviceListener {
                       fun onInputDeviceAdded(deviceId: Int)
                       fun onInputDeviceChanged(deviceId: Int)
                       fun onInputDeviceRemoved(deviceId: Int)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The InputManagerCompat interface is a reference example.
               // The full code is provided in the ControllerSample.zip sample.
               public interface InputManagerCompat {
                   ...
                   public InputDevice getInputDevice(int id);
                   public int[] getInputDeviceIds();

                   public void registerInputDeviceListener(
                           InputManagerCompat.InputDeviceListener listener,
                           Handler handler);
                   public void unregisterInputDeviceListener(
                           InputManagerCompat.InputDeviceListener listener);

                   public void onGenericMotionEvent(MotionEvent event);

                   public void onPause();
                   public void onResume();

                   public interface InputDeviceListener {
                       void onInputDeviceAdded(int deviceId);
                       void onInputDeviceChanged(int deviceId);
                       void onInputDeviceRemoved(int deviceId);
                   }
                   ...
               }

   The ``InputManagerCompat`` interface provides the following methods:

   ``getInputDevice()``
      Mirrors
      `getInputDevice() <#android.hardware.input.InputManager>`__.
      Obtains the `InputDevice <#android.view.InputDevice>`__
      object that represents the capabilities of a game controller.
   ``getInputDeviceIds()``
      Mirrors
      `getInputDeviceIds() <#android.hardware.input.InputManager>`__.
      Returns an array of integers, each of which is an ID for a different input
      device. This is useful if you're building a game that supports multiple
      players and you want to detect how many controllers are connected.
   ``registerInputDeviceListener()``
      Mirrors
      `registerInputDeviceListener() <#android.hardware.input.InputManager>`__.
      Lets you register to be informed when a new device is added, changed, or
      removed.
   ``unregisterInputDeviceListener()``
      Mirrors
      `unregisterInputDeviceListener() <#android.hardware.input.InputManager>`__.
      Unregisters an input device listener.
   ``onGenericMotionEvent()``
      Mirrors
      `onGenericMotionEvent() <#android.view.View>`__.
      Lets your game intercept and handle
      `MotionEvent <#android.view.MotionEvent>`__ objects and axis
      values that represent events such as joystick movements and analog trigger
      presses.
   ``onPause()``
      Stops polling for game controller events when the main activity is paused,
      or when the game no longer has focus.
   ``onResume()``
      Starts polling for game controller events when the main activity is
      resumed, or when the game is started and runs in the foreground.
   ``InputDeviceListener``
      Mirrors the
      `InputManager.InputDeviceListener <#android.hardware.input.InputManager.InputDeviceListener>`__
      interface. Lets your game know when a game controller has been added,
      changed, or removed.

   Next, create implementations for ``InputManagerCompat`` that work across
   different platform versions. If your game is running on Android 4.1 or higher
   and calls an ``InputManagerCompat`` method, the proxy implementation calls
   the equivalent method in
   `InputManager <#android.hardware.input.InputManager>`__.
   However, if your game is running on Android 3.1 up to Android 4.0, the custom
   implementation processes calls to ``InputManagerCompat`` methods by using
   only APIs introduced no later than Android 3.1. Regardless of which
   version-specific implementation is used at runtime, the implementation passes
   the call results back transparently to the game.

   |image-backward-compatible-inputmanager|
   **Figure 1.** Class diagram of interface and version-specific
   implementations.

   .. rubric:: Implement the interface on Android 4.1 and higher
      :name: newer

   ``InputManagerCompatV16`` is an implementation of the ``InputManagerCompat``
   interface that proxies method calls to an actual
   `InputManager <#android.hardware.input.InputManager>`__ and
   `InputManager.InputDeviceListener <#android.hardware.input.InputManager.InputDeviceListener>`__.
   The `InputManager <#android.hardware.input.InputManager>`__ is
   obtained from the system
   `Context <#android.content.Context>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The InputManagerCompatV16 class is a reference implementation.
               // The full code is provided in the ControllerSample.zip sample.
               public class InputManagerV16(
                       context: Context,
                       private val inputManager: InputManager =
                           context.getSystemService(Context.INPUT_SERVICE) as InputManager,
                       private val listeners:
                           MutableMap<InputManager.InputDeviceListener, V16InputDeviceListener> = mutableMapOf()
               ) : InputManagerCompat {
                   override val inputDeviceIds: IntArray = inputManager.inputDeviceIds

                   override fun getInputDevice(id: Int): InputDevice = inputManager.getInputDevice(id)

                   override fun registerInputDeviceListener(
                           listener: InputManager.InputDeviceListener,
                           handler: Handler?
                   ) {
                       V16InputDeviceListener(listener).also { v16listener ->
                           inputManager.registerInputDeviceListener(v16listener, handler)
                           listeners += listener to v16listener
                       }
                   }

                   // Do the same for unregistering an input device listener
                   ...

                   override fun onGenericMotionEvent(event: MotionEvent) {
                       // unused in V16
                   }

                   override fun onPause() {
                       // unused in V16
                   }

                   override fun onResume() {
                       // unused in V16
                   }

               }

               class V16InputDeviceListener(
                       private val idl: InputManager.InputDeviceListener
               ) : InputManager.InputDeviceListener {

                   override fun onInputDeviceAdded(deviceId: Int) {
                       idl.onInputDeviceAdded(deviceId)
                   }
                   // Do the same for device change and removal
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The InputManagerCompatV16 class is a reference implementation.
               // The full code is provided in the ControllerSample.zip sample.
               public class InputManagerV16 implements InputManagerCompat {

                   private final InputManager inputManager;
                   private final Map<InputManagerCompat.InputDeviceListener,
                           V16InputDeviceListener> listeners;

                   public InputManagerV16(Context context) {
                       inputManager = (InputManager)
                               context.getSystemService(Context.INPUT_SERVICE);
                       listeners = new HashMap<InputManagerCompat.InputDeviceListener,
                               V16InputDeviceListener>();
                   }

                   @Override
                   public InputDevice getInputDevice(int id) {
                       return inputManager.getInputDevice(id);
                   }

                   @Override
                   public int[] getInputDeviceIds() {
                       return inputManager.getInputDeviceIds();
                   }

                   static class V16InputDeviceListener implements
                           InputManager.InputDeviceListener {
                       final InputManagerCompat.InputDeviceListener mIDL;

                       public V16InputDeviceListener(InputDeviceListener idl) {
                           mIDL = idl;
                       }

                       @Override
                       public void onInputDeviceAdded(int deviceId) {
                           mIDL.onInputDeviceAdded(deviceId);
                       }

                       // Do the same for device change and removal
                       ...
                   }

                   @Override
                   public void registerInputDeviceListener(InputDeviceListener listener,
                           Handler handler) {
                       V16InputDeviceListener v16Listener = new
                               V16InputDeviceListener(listener);
                       inputManager.registerInputDeviceListener(v16Listener, handler);
                       listeners.put(listener, v16Listener);
                   }

                   // Do the same for unregistering an input device listener
                   ...

                   @Override
                   public void onGenericMotionEvent(MotionEvent event) {
                       // unused in V16
                   }

                   @Override
                   public void onPause() {
                       // unused in V16
                   }

                   @Override
                   public void onResume() {
                       // unused in V16
                   }

               }

   .. rubric:: Implement the interface on Android 3.1 up to Android 4.0
      :name: older

   To create an implementation of ``InputManagerCompat`` that supports Android
   3.1 up to Android 4.0, you can use the following objects:

   -  A `SparseArray <#android.util.SparseArray>`__ of device IDs
      to track the game controllers that are connected to the device.
   -  A `Handler <#android.os.Handler>`__ to process device
      events. When an app is started or resumed, the
      `Handler <#android.os.Handler>`__ receives a message to
      start polling for game controller disconnection. The
      `Handler <#android.os.Handler>`__ will start a loop to check
      each known connected game controller and see if a device ID is returned. A
      ``null`` return value indicates that the game controller is disconnected.
      The `Handler <#android.os.Handler>`__ stops polling when the
      app is paused.
   -  A `Map <#>`__ of
      ``InputManagerCompat.InputDeviceListener`` objects. You will use the
      listeners to update the connection status of tracked game controllers.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The InputManagerCompatV9 class is a reference implementation.
               // The full code is provided in the ControllerSample.zip sample.
               class InputManagerV9(
                       val devices: SparseArray<Array<Long>> = SparseArray(),
                       private val listeners:
                       MutableMap<InputManager.InputDeviceListener, Handler> = mutableMapOf()
               ) : InputManagerCompat {
                   private val defaultHandler: Handler = PollingMessageHandler(this)
                   …
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The InputManagerCompatV9 class is a reference implementation.
               // The full code is provided in the ControllerSample.zip sample.
               public class InputManagerV9 implements InputManagerCompat {
                   private final SparseArray<long[]> devices;
                   private final Map<InputDeviceListener, Handler> listeners;
                   private final Handler defaultHandler;
                   …

                   public InputManagerV9() {
                       devices = new SparseArray<long[]>();
                       listeners = new HashMap<InputDeviceListener, Handler>();
                       defaultHandler = new PollingMessageHandler(this);
                   }
               }

   Implement a ``PollingMessageHandler`` object that extends
   `Handler <#android.os.Handler>`__, and override the
   `handleMessage() <#android.os.Handler>`__
   method. This method checks if an attached game controller has been
   disconnected and notifies registered listeners.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private class PollingMessageHandler(
                       inputManager: InputManagerV9,
                       private val mInputManager: WeakReference<InputManagerV9> = WeakReference(inputManager)
               ) : Handler() {

                   override fun handleMessage(msg: Message) {
                       super.handleMessage(msg)
                       when (msg.what) {
                           MESSAGE_TEST_FOR_DISCONNECT -> {
                               mInputManager.get()?.also { imv ->
                                   val time = SystemClock.elapsedRealtime()
                                   val size = imv.devices.size()
                                   for (i in 0 until size) {
                                       imv.devices.valueAt(i)?.also { lastContact ->
                                           if (time - lastContact[0] > CHECK_ELAPSED_TIME) {
                                               // check to see if the device has been
                                               // disconnected
                                               val id = imv.devices.keyAt(i)
                                               if (null == InputDevice.getDevice(id)) {
                                                   // Notify the registered listeners
                                                   // that the game controller is disconnected
                                                   imv.devices.remove(id)
                                               } else {
                                                   lastContact[0] = time
                                               }
                                           }
                                       }
                                   }
                                   sendEmptyMessageDelayed(MESSAGE_TEST_FOR_DISCONNECT, CHECK_ELAPSED_TIME)
                               }
                           }
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static class PollingMessageHandler extends Handler {
                   private final WeakReference<InputManagerV9> inputManager;

                   PollingMessageHandler(InputManagerV9 im) {
                       inputManager = new WeakReference<InputManagerV9>(im);
                   }

                   @Override
                   public void handleMessage(Message msg) {
                       super.handleMessage(msg);
                       switch (msg.what) {
                           case MESSAGE_TEST_FOR_DISCONNECT:
                               InputManagerV9 imv = inputManager.get();
                               if (null != imv) {
                                   long time = SystemClock.elapsedRealtime();
                                   int size = imv.devices.size();
                                   for (int i = 0; i < size; i++) {
                                       long[] lastContact = imv.devices.valueAt(i);
                                       if (null != lastContact) {
                                           if (time - lastContact[0] > CHECK_ELAPSED_TIME) {
                                               // check to see if the device has been
                                               // disconnected
                                               int id = imv.devices.keyAt(i);
                                               if (null == InputDevice.getDevice(id)) {
                                                   // Notify the registered listeners
                                                   // that the game controller is disconnected
                                                   imv.devices.remove(id);
                                               } else {
                                                   lastContact[0] = time;
                                               }
                                           }
                                       }
                                   }
                                   sendEmptyMessageDelayed(MESSAGE_TEST_FOR_DISCONNECT,
                                           CHECK_ELAPSED_TIME);
                               }
                               break;
                       }
                   }
               }

   To start and stop polling for game controller disconnection, override these
   methods:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val MESSAGE_TEST_FOR_DISCONNECT = 101
               private const val CHECK_ELAPSED_TIME = 3000L

               class InputManagerV9(
                       val devices: SparseArray<Array<Long>> = SparseArray(),
                       private val listeners:
                       MutableMap<InputManager.InputDeviceListener, Handler> = mutableMapOf()
               ) : InputManagerCompat {
                   ...
                   override fun onPause() {
                       defaultHandler.removeMessages(MESSAGE_TEST_FOR_DISCONNECT)
                   }

                   override fun onResume() {
                       defaultHandler.sendEmptyMessageDelayed(MESSAGE_TEST_FOR_DISCONNECT, CHECK_ELAPSED_TIME)
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private static final int MESSAGE_TEST_FOR_DISCONNECT = 101;
               private static final long CHECK_ELAPSED_TIME = 3000L;

               @Override
               public void onPause() {
                   defaultHandler.removeMessages(MESSAGE_TEST_FOR_DISCONNECT);
               }

               @Override
               public void onResume() {
                   defaultHandler.sendEmptyMessageDelayed(MESSAGE_TEST_FOR_DISCONNECT,
                           CHECK_ELAPSED_TIME);
               }

   To detect that an input device has been added, override the
   ``onGenericMotionEvent()`` method. When the system reports a motion event,
   check if this event came from a device ID that is already tracked, or from a
   new device ID. If the device ID is new, notify registered listeners.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onGenericMotionEvent(event: MotionEvent) {
                   // detect new devices
                   val id = event.deviceId
                   val timeArray: Array<Long> = mDevices.get(id) ?: run {
                       // Notify the registered listeners that a game controller is added
                       ...
                       arrayOf<Long>().also {
                           mDevices.put(id, it)
                       }
                   }
                   timeArray[0] = SystemClock.elapsedRealtime()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onGenericMotionEvent(MotionEvent event) {
                   // detect new devices
                   int id = event.getDeviceId();
                   long[] timeArray = mDevices.get(id);
                   if (null == timeArray) {
                       // Notify the registered listeners that a game controller is added
                       ...
                       timeArray = new long[1];
                       mDevices.put(id, timeArray);
                   }
                   long time = SystemClock.elapsedRealtime();
                   timeArray[0] = time;
               }

   Notification of listeners is implemented by using the
   `Handler <#android.os.Handler>`__ object to send a
   ``DeviceEvent`` `Runnable <#>`__ object to
   the message queue. The ``DeviceEvent`` contains a reference to an
   ``InputManagerCompat.InputDeviceListener``. When the ``DeviceEvent`` runs,
   the appropriate callback method of the listener is called to signal if the
   game controller was added, changed, or removed.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class InputManagerV9(
                       val devices: SparseArray<Array<Long>> = SparseArray(),
                       private val listeners:
                       MutableMap<InputManager.InputDeviceListener, Handler> = mutableMapOf()
               ) : InputManagerCompat {
                   ...
                   override fun registerInputDeviceListener(
                           listener: InputManager.InputDeviceListener,
                           handler: Handler?
                   ) {
                       listeners[listener] = handler ?: defaultHandler
                   }

                   override fun unregisterInputDeviceListener(listener: InputManager.InputDeviceListener) {
                       listeners.remove(listener)
                   }

                   private fun notifyListeners(why: Int, deviceId: Int) {
                       // the state of some device has changed
                       listeners.forEach { listener, handler ->
                           DeviceEvent.getDeviceEvent(why, deviceId, listener).also {
                               handler?.post(it)
                           }
                       }
                   }
                   ...
               }

               private val sObjectQueue: Queue<DeviceEvent> = ArrayDeque<DeviceEvent>()

               private class DeviceEvent(
                       private var mMessageType: Int,
                       private var mId: Int,
                       private var mListener: InputManager.InputDeviceListener
               ) : Runnable {

                   companion object {
                       fun getDeviceEvent(messageType: Int, id: Int, listener: InputManager.InputDeviceListener) =
                               sObjectQueue.poll()?.apply {
                                   mMessageType = messageType
                                   mId = id
                                   mListener = listener
                               } ?: DeviceEvent(messageType, id, listener)

                   }

                   override fun run() {
                       when(mMessageType) {
                           ON_DEVICE_ADDED -> mListener.onInputDeviceAdded(mId)
                           ON_DEVICE_CHANGED -> mListener.onInputDeviceChanged(mId)
                           ON_DEVICE_REMOVED -> mListener.onInputDeviceChanged(mId)
                           else -> {
                               // Handle unknown message type
                           }
                       }
                   }

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void registerInputDeviceListener(InputDeviceListener listener,
                       Handler handler) {
                   listeners.remove(listener);
                   if (handler == null) {
                       handler = defaultHandler;
                   }
                   listeners.put(listener, handler);
               }

               @Override
               public void unregisterInputDeviceListener(InputDeviceListener listener) {
                   listeners.remove(listener);
               }

               private void notifyListeners(int why, int deviceId) {
                   // the state of some device has changed
                   if (!listeners.isEmpty()) {
                       for (InputDeviceListener listener : listeners.keySet()) {
                           Handler handler = listeners.get(listener);
                           DeviceEvent odc = DeviceEvent.getDeviceEvent(why, deviceId,
                                   listener);
                           handler.post(odc);
                       }
                   }
               }

               private static class DeviceEvent implements Runnable {
                   private int mMessageType;
                   private int mId;
                   private InputDeviceListener mListener;
                   private static Queue<DeviceEvent> sObjectQueue =
                           new ArrayDeque<DeviceEvent>();
                   ...

                   static DeviceEvent getDeviceEvent(int messageType, int id,
                           InputDeviceListener listener) {
                       DeviceEvent curChanged = sObjectQueue.poll();
                       if (null == curChanged) {
                           curChanged = new DeviceEvent();
                       }
                       curChanged.mMessageType = messageType;
                       curChanged.mId = id;
                       curChanged.mListener = listener;
                       return curChanged;
                   }

                   @Override
                   public void run() {
                       switch (mMessageType) {
                           case ON_DEVICE_ADDED:
                               mListener.onInputDeviceAdded(mId);
                               break;
                           case ON_DEVICE_CHANGED:
                               mListener.onInputDeviceChanged(mId);
                               break;
                           case ON_DEVICE_REMOVED:
                               mListener.onInputDeviceRemoved(mId);
                               break;
                           default:
                               // Handle unknown message type
                               ...
                               break;
                       }
                       // Put this runnable back in the queue
                       sObjectQueue.offer(this);
                   }
               }

   You now have two implementations of ``InputManagerCompat``: one that works on
   devices running Android 4.1 and higher, and another that works on devices
   running Android 3.1 up to Android 4.0.

   .. rubric:: Use the version-specific implementation
      :name: using

   The version-specific switching logic is implemented in a class that acts as a
   `factory <https://en.wikipedia.org/wiki/Factory_(software_concept)>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               object Factory {
                   fun getInputManager(context: Context): InputManagerCompat =
                           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
                               InputManagerV16(context)
                           } else {
                               InputManagerV9()
                           }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public static class Factory {
                   public static InputManagerCompat getInputManager(Context context) {
                       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
                           return new InputManagerV16(context);
                       } else {
                           return new InputManagerV9();
                       }
                   }
               }

   Now you can simply instantiate an ``InputManagerCompat`` object and register
   an ``InputManagerCompat.InputDeviceListener`` in your main
   `View <#android.view.View>`__. Because of the version-switching
   logic you set up, your game automatically uses the implementation that's
   appropriate for the version of Android the device is running.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class GameView(context: Context) : View(context), InputManager.InputDeviceListener {
                   private val inputManager: InputManagerCompat = Factory.getInputManager(context).apply {
                       registerInputDeviceListener(this@GameView, null)
                       ...
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class GameView extends View implements InputDeviceListener {
                   private InputManagerCompat inputManager;
                   ...

                   public GameView(Context context, AttributeSet attrs) {
                       inputManager =
                               InputManagerCompat.Factory.getInputManager(this.getContext());
                       inputManager.registerInputDeviceListener(this, null);
                       ...
                   }
               }

   Next, override the
   `onGenericMotionEvent() <#android.view.View>`__
   method in your main view, as described in `Handle a MotionEvent from a Game Controller <#analog>`__.
   Your game should now be able to process game controller events consistently
   on devices running Android 3.1 (API level 12) and higher.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onGenericMotionEvent(event: MotionEvent): Boolean {
                   inputManager.onGenericMotionEvent(event)

                   // Handle analog input from the controller as normal
                   ...
                   return super.onGenericMotionEvent(event)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onGenericMotionEvent(MotionEvent event) {
                   inputManager.onGenericMotionEvent(event);

                   // Handle analog input from the controller as normal
                   ...
                   return super.onGenericMotionEvent(event);
               }

   You can find a complete implementation of this compatibility code in the
   ``GameView`` class provided in the sample ``ControllerSample.zip`` available
   for download above.


Last updated 2024-02-22 UTC.

.. |image-backward-compatible-inputmanager| image:: https://developer.android.google.cn/static/images/training/backward-compatible-inputmanager.png
   :name: figure1


/Add support for multiple controllers
=====================================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/multiple-controllers?hl=en

.. container:: devsite-article-body

   While most games are designed to support a single user per Android device,
   it's also possible to support multiple users with game controllers that are
   connected simultaneously on the same Android device.

   This lesson covers some basic techniques for handling input in your single
   device multiplayer game from multiple connected controllers. This includes
   maintaining a mapping between player avatars and each controller device and
   processing controller input events appropriately.

   .. rubric:: Map players to controller device IDs
      :name: map

   When a game controller is connected to an Android device, the system assigns
   it an integer device ID. You can obtain the device IDs for connected game
   controllers by calling
   `InputDevice.getDeviceIds() <#android.view.InputDevice>`__,
   as shown in `Verify a Game Controller is Connected <#input>`__.
   You can then associate each device ID with a player in your game, and process
   game actions for each player separately.

   **Note:** On devices running Android 4.1 (API level 16) and higher, you can
   obtain an input device’s descriptor using
   `getDescriptor() <#android.view.InputDevice>`__,
   which returns a unique persistent string value for the input device. Unlike a
   device ID, the descriptor value won't change even if the input device is
   disconnected, reconnected, or reconfigured.

   The code snippet below shows how to use a
   `SparseArray <#android.util.SparseArray>`__ to associate a
   player's avatar with a specific controller. In this example, the ``mShips``
   variable stores a collection of ``Ship`` objects. A new player avatar is
   created in-game when a new controller is attached by a user, and removed when
   its associated controller is removed.

   The ``onInputDeviceAdded()`` and ``onInputDeviceRemoved()`` callback methods
   are part of the abstraction layer introduced in `Supporting Controllers
   Across Android Versions <#status_callbacks%7D>`__.
   By implementing these listener callbacks, your game can identify the game
   controller's device ID when a controller is added or removed. This detection
   is compatible with Android 2.3 (API level 9) and higher.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private val ships = SparseArray<Ship>()

               override fun onInputDeviceAdded(deviceId: Int) {
                   getShipForID(deviceId)
               }

               override fun onInputDeviceRemoved(deviceId: Int) {
                   removeShipForID(deviceId)
               }

               private fun getShipForID(shipID: Int): Ship {
                   return ships.get(shipID) ?: Ship().also {
                       ships.append(shipID, it)
                   }
               }

               private fun removeShipForID(shipID: Int) {
                   ships.remove(shipID)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private final SparseArray<Ship> ships = new SparseArray<Ship>();

               @Override
               public void onInputDeviceAdded(int deviceId) {
                   getShipForID(deviceId);
               }

               @Override
               public void onInputDeviceRemoved(int deviceId) {
                   removeShipForID(deviceId);
               }

               private Ship getShipForID(int shipID) {
                   Ship currentShip = ships.get(shipID);
                   if ( null == currentShip ) {
                       currentShip = new Ship();
                       ships.append(shipID, currentShip);
                   }
                   return currentShip;
               }

               private void removeShipForID(int shipID) {
                   ships.remove(shipID);
               }

   .. rubric:: Process multiple controller input
      :name: detect

   Your game should execute the following loop to process input from multiple
   controllers:

   #. Detect whether an input event occurred.
   #. Identify the input source and its device ID.
   #. Based on the action indicated by the input event key code or axis value,
      update the player avatar associated with that device ID.
   #. Render and update the user interface.

   `KeyEvent <#android.view.KeyEvent>`__ and
   `MotionEvent <#android.view.MotionEvent>`__ input events have
   device IDs associated with them. Your game can take advantage of this to
   determine which controller the input event came from, and update the player
   avatar associated with that controller.

   The following code snippet shows how you might get a player avatar reference
   corresponding to a game controller device ID, and update the game based on
   the user's button press on that controller.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {
                   if (event.source and InputDevice.SOURCE_GAMEPAD == InputDevice.SOURCE_GAMEPAD) {
                       event.deviceId.takeIf { it != -1 }?.also { deviceId ->
                           val currentShip: Ship = getShipForID(deviceId)
                           // Based on which key was pressed, update the player avatar
                           // (e.g. set the ship headings or fire lasers)
                           return true
                       }
                   }
                   return super.onKeyDown(keyCode, event)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public boolean onKeyDown(int keyCode, KeyEvent event) {
                   if ((event.getSource() & InputDevice.SOURCE_GAMEPAD)
                               == InputDevice.SOURCE_GAMEPAD) {
                       int deviceId = event.getDeviceId();
                       if (deviceId != -1) {
                           Ship currentShip = getShipForId(deviceId);
                           // Based on which key was pressed, update the player avatar
                           // (e.g. set the ship headings or fire lasers)
                           ...
                           return true;
                       }
                   }
                   return super.onKeyDown(keyCode, event);
               }

   **Note:** As a best practice, when a user's game controller disconnects, you
   should pause the game and ask if the user wants to reconnect.


Last updated 2024-02-22 UTC.


/Additional controller features
===============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/game-controllers/controller-features?hl=en

.. container:: devsite-article-body

   Game controllers are equipped with additional features that significantly
   enhance player interaction and immersion. The haptics, motion sensors, and
   light functionalities of Android game controllers are particularly
   instrumental in deepening and enriching the gaming experience. Each feature
   uniquely stimulates the player's senses, fostering more meaningful and
   intuitive interactions within the game.

   .. rubric:: Haptics
      :name: haptics

   The haptics feature in Android game controllers is a crucial technology that
   provides realistic tactile feedback during gameplay.

   Haptics technology delivers physical sensations to the user through
   vibrations or movements. For example, when an explosion occurs in the game,
   the controller vibrates, allowing the player to feel the impact
   realistically. Additionally, subtle vibrations can be synchronized with the
   sound of a character walking or running, offering a more lifelike experience.
   This type of haptic feedback enables players to physically feel various
   events happening within the game.

   This technology maximizes player immersion, amplifies emotional responses,
   and enriches the dynamics of the game. Haptics settings in Android game
   controllers not only widen the creative possibilities for game developers but
   also provide players with a gaming experience more realistic than ever
   before.

   .. code:: prettyprint

      fun triggerVibrationMultiChannel(
        deviceId: Int, leftIntensity: Int, leftDuration: Int,
        rightIntensity: Int, rightDuration: Int) {
        val inputDevice = InputDevice.getDevice(deviceId)
        val vibratorManager = inputDevice!!.vibratorManager
        if (vibratorManager != null) {
          val vibratorIds = vibratorManager.vibratorIds
          val vibratorCount = vibratorIds.size
          if (vibratorCount > 0) {
            // We have an assumption that game controllers have two vibrators
            // corresponding to a left motor and a right motor, and the left
            // motor will be first.
            updateVibrator(vibratorManager.getVibrator(vibratorIds[0]), leftIntensity, leftDuration)
            if (vibratorCount > 1) {
              updateVibrator(vibratorManager.getVibrator(vibratorIds[1]), rightIntensity, rightDuration)
            }
          }
        }
      }

      fun updateVibrator(vibrator: Vibrator?, intensity: Int, duration: Int) {
        if (vibrator != null) {
          if (intensity == 0) {
            vibrator.cancel()
          } else if (duration > 0) {
            vibrator.vibrate(VibrationEffect.createOneShot(duration.toLong(), intensity))
          }
        }
      }

   To use vibrate, it sets a feature and permission.

   .. code:: prettyprint

      <application ...>
        ...
        <uses-feature android:name="android.hardware.gamepad" android:required="true"/>
        <uses-permission android:name="android.permission.VIBRATE"/>
        ...
      </application>

   **Note:**\  When specifying ``android:hardware:gamepad`` support, don't set
   the ``android:required`` attribute to ``true``. If you do this, users won't
   be able to install your app on the device.
   For more information about
   `VibratorManager <#android.os.VibratorManager>`__ and `App manifest <#>`__.

   .. rubric:: Motion sensors
      :name: motion_sensors

   One of the most innovative technologies enhancing gameplay experiences is the
   motion sensor-equipped Android game controller. This technology precisely
   detects the physical movements of users and translates that data into actions
   within the game, providing a more intuitive and immersive gaming experience.
   In this introduction, we will explore how the motion sensor features in
   Android game controllers works.

   Motion sensors typically incorporate gyroscopes and accelerometers to detect
   the movements and orientations of users.

   It needs to implement acceleration and gyroscope listener classes and
   register these listeners with the controller's sensor manager.

   .. code:: prettyprint

      fun setIntegratedAccelerometerActive(deviceId: Int) {
        val device = InputDevice.getDevice(deviceId)
        val sensorManager = device?.sensorManager
        val accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        if (accelerometer != null) {
          val accelerometerListener =
            GameControllerAccelerometerListener(accelerometer)
          sensorManager.registerListener(
            accelerometerListener, accelerometer,
            SensorManager.SENSOR_DELAY_GAME
          )
        }
      }

      fun setIntegratedGyroscopeActive(deviceId: Int) {
        val device = InputDevice.getDevice(deviceId)
        val sensorManager = device?.sensorManager
        val gyroscope = sensorManager?.getDefaultSensor(Sensor.TYPE_GYROSCOPE)
        if (gyroscope != null) {
          val gyroscopeListener = GameControllerGyroscopeListener(gyroscope)
          sensorManager.registerListener(
            gyroscopeListener, gyroscope,
            SensorManager.SENSOR_DELAY_GAME
          )
        }
      }

      class GameControllerAccelerometerListener(private val listenerAccelerometer: Sensor?) :
        SensorEventListener {
        override fun onSensorChanged(event: SensorEvent) {
          if (listenerAccelerometer != null) {
            synchronized(listenerAccelerometer) {
              if (event.sensor == listenerAccelerometer) {
                Log.d("Accelerometer",
                  "onSensorChanged " + event.values[0] + ", "
                  + event.values[1] + ", " + event.values[2])
              }
            }
          }
        }

        override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {
        }
      }

      class GameControllerGyroscopeListener(private val listenerGyroscope: Sensor?) :
        SensorEventListener {
        override fun onSensorChanged(event: SensorEvent) {
          if (listenerGyroscope != null) {
            synchronized(listenerGyroscope) {
              if (event.sensor == listenerGyroscope) {
                Log.d("Gyroscope",
                  "onSensorChanged " + event.values[0] + ", " +
                  event.values[1] + ", " + event.values[2])
              }
            }
          }
        }

        override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {
        }
      }

   For more information about `Motion sensors <#>`__ and
   `SensorEventListener <#android.hardware.SensorEventListener>`__.

   .. rubric:: Lights
      :name: lights

   The light color settings on Android game controllers add a new dimension of
   immersion to gameplay through visual elements.

   The light color feature utilizes built-in LED lights in the controller to
   display various colors, which respond dynamically to different gaming
   scenarios. For example, the lights might flash red when the player's health
   is critical or glow green upon the completion of a specific mission,
   providing visual feedback based on in-game events. These light color settings
   deepen user engagement, heighten the suspense and enjoyment of the game, and
   help players immerse more fully into the game world.

   The light color features in Android game controllers serves more than a mere
   decorative purpose—it plays a significant role in setting the mood of the
   game and improving the user experience.

   .. code:: prettyprint

      fun changeControllerLightColor(deviceId: Int, color: Int) {
        val device = InputDevice.getDevice(deviceId)
        device?.let {
          if (it.sources and InputDevice.SOURCE_JOYSTICK == InputDevice.SOURCE_JOYSTICK) {
            val lightsManager = device.lightsManager
            lightsManager?.let { manager ->
              manager.lights.forEach { light ->
                val stateBuilder = LightState.Builder()
                stateBuilder.setColor(color)
                val requestBuilder = LightsRequest.Builder()
                requestBuilder.addLight(light, stateBuilder.build())
                val lightsSession = lightsManager.openSession()
                lightsSession.requestLights(requestBuilder.build())
              }
            }
          }
        }
      }

   To use vibrate, it sets a feature and permission.

   .. code:: prettyprint

      <application ...>
        ...
        <uses-feature android:name="android.hardware.gamepad" android:required="true"/>
        <uses-permission android:name="android.permission.LIGHTS" />
        ...
      </application>

   **Note:**\  When specifying ``android:hardware:gamepad`` support, don't set
   the ``android:required`` attribute to ``"true"``. If you do this, users won't
   be able to install your app on the device.
   For more information about
   `LightsManager <#android.hardware.lights.LightsManager>`__ and
   `App manifest <#>`__.

   .. rubric:: Controller touchpad
      :name: controller_touchpad

   Some game controllers include a touchpad which can be used for a variety of
   in-game actions, such as navigating menus or controlling game characters in a
   more intuitive way.

   .. figure:: https://developer.android.google.cn/static/images/training/game-controller-touchpad.png
      :alt: Touchpad on the game controller.

      **Figure 1.** Touchpad on the game controller.

   Game controllers with integrated touchpads offer direct device control on
   Android. Touching the touchpad generates an on-screen mouse pointer, allowing
   for intuitive mouse-like navigation.


Last updated 2024-05-03 UTC.


/Create an input method
=======================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/creating-input-method?hl=en

.. container:: devsite-article-body

   An input method editor (IME) is a user control that lets users enter text.
   Android provides an extensible input-method framework that lets applications
   provide users alternative input methods, such as on-screen keyboards or
   speech input. After installing the IMEs, the user can select one from the
   system settings and use it across the entire system. Only one IME can be
   enabled at a time.

   To add an IME to the Android system, create an Android application containing
   a class that extends
   `InputMethodService <#android.inputmethodservice.InputMethodService>`__.
   In addition, you usually create a "settings" activity that passes options to
   the IME service. You can also define a settings UI that's displayed as part
   of the system settings.

   This page covers the following topics:

   -  `The IME lifecycle <#InputMethodLifecycle>`__
   -  `Declaring IME components in the application manifest <#DefiningIME>`__
   -  `The IME API <#IMEAPI>`__
   -  `Designing an IME UI <#IMEUI>`__
   -  `Sending text from an IME to an application <#SendText>`__
   -  `Working with IME subtypes <#IMESubTypes>`__
   -  `Other IME considerations <#GeneralDesign>`__

   If you haven't worked with IMEs, read the introductory article `On-screen
   Input Methods <http://android-developers.blogspot.com/2009/04/updating-applications-for-on-screen.html>`__
   first.

   **Note:** Beginning with Android 11, the platform lets IMEs display autofill
   suggestions inline, instead of using a pulldown menu. For more information
   about how autofill services can support this functionality, read about `how to integrate autofill with your IME <#>`__.

   .. rubric:: The IME lifecycle
      :name: InputMethodLifecycle

   The following diagram describes the lifecycle of an IME:

   .. figure:: https://developer.android.google.cn/static/resources/articles/images/inputmethod_lifecycle_image.png
      name: lifecycle
      :alt: An image showing the life cycle of an IME.
      :width: 60.0%

      **Figure 1.** The lifecycle of an IME.

   The following sections describe how to implement the UI and code associated
   with an IME that follows this lifecycle.

   .. rubric:: Declare IME components in the manifest
      :name: DefiningIME

   In the Android system, an IME is an Android application that contains a
   special IME service. The application's manifest file must declare the
   service, request the necessary permissions, provide an intent filter that
   matches the action ``action.view.InputMethod``, and provide metadata that
   defines characteristics of the IME. In addition, to provide a settings
   interface that lets the user modify the behavior of the IME, you can define a
   "settings" activity that can be launched from System Settings.

   The following snippet declares an IME service. It requests the permission
   `BIND_INPUT_METHOD <#android.Manifest.permission>`__
   to let the service connect the IME to the system, sets up an intent filter
   that matches the action ``android.view.InputMethod``, and defines metadata
   for the IME:

   .. code:: prettyprint

      <!-- Declares the input method service. -->
      <service android:name="FastInputIME"
          android:label="@string/fast_input_label"
          android:permission="android.permission.BIND_INPUT_METHOD">
          <intent-filter>
              <action android:name="android.view.InputMethod" />
          </intent-filter>
          <meta-data android:name="android.view.im"
                     android:resource="@xml/method" />
      </service>

   The next snippet declares the settings activity for the IME. It has an intent
   filter for
   `ACTION_MAIN <#android.content.Intent>`__ that
   indicates that this activity is the main entry point for the IME application:

   .. code:: prettyprint

      <!-- Optional: an activity for controlling the IME settings. -->
      <activity android:name="FastInputIMESettings"
          android:label="@string/fast_input_settings">
          <intent-filter>
              <action android:name="android.intent.action.MAIN"/>
          </intent-filter>
      </activity>

   You can also provide access to the IME's settings directly from its UI.

   .. rubric:: The input method API
      :name: IMEAPI

   Classes specific to IMEs are found in the
   `android.inputmethodservice <#android.inputmethodservice.package-summary>`__
   and
   `android.view.inputmethod <#android.view.inputmethod.package-summary>`__
   packages. The `KeyEvent <#android.view.KeyEvent>`__ class is
   important for handling keyboard characters.

   The central part of an IME is a service component—a class that extends
   ``InputMethodService``. In addition to implementing the normal service
   lifecycle, this class has callbacks for providing your IME's UI, handling
   user input, and delivering text to the field that has focus. By default, the
   ``InputMethodService`` class provides most of the implementation for managing
   the state and visibility of the IME and communicating with the current input
   field.

   The following classes are also important:

   `BaseInputConnection <#android.view.inputmethod.BaseInputConnection>`__
      Defines the communication channel from an
      `InputMethod <#android.view.inputmethod.InputMethod>`__ back
      to the application that is receiving its input. You use it to read text
      around the cursor, commit text to the text box, and send raw key events to
      the application. Applications must extend this class rather than
      implementing the base interface
      `InputConnection <#android.view.inputmethod.InputConnection>`__.
   `KeyboardView <#android.inputmethodservice.KeyboardView>`__
      An extension of `View <#android.view.View>`__ that renders a
      keyboard and responds to user input events. The keyboard layout is
      specified by an instance of
      `Keyboard <#android.inputmethodservice.Keyboard>`__, which
      you can define in an XML file.

   .. rubric:: Design the input method UI
      :name: IMEUI

   There are two main visual elements for an IME: the **input** view and the
   **candidates** view. You only have to implement the elements that are
   relevant to the input method you're designing.

   .. rubric:: Input view
      :name: InputView

   The input view is the UI where the user inputs text in the form of keyclicks,
   handwriting, or gestures. When the IME is displayed for the first time, the
   system calls the
   `onCreateInputView() <#android.inputmethodservice.InputMethodService>`__
   callback. In your implementation of this method, create the layout you want
   to display in the IME window and return the layout to the system. The
   following snippet shows an example of implementing the
   ``onCreateInputView()`` method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreateInputView(): View {
                   return layoutInflater.inflate(R.layout.input, null).apply {
                       if (this is MyKeyboardView) {
                           setOnKeyboardActionListener(this@MyInputMethod)
                           keyboard = latinKeyboard
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public View onCreateInputView() {
                   MyKeyboardView inputView =
                       (MyKeyboardView) getLayoutInflater().inflate(R.layout.input, null);

                   inputView.setOnKeyboardActionListener(this);
                   inputView.setKeyboard(latinKeyboard);

                   return inputView;
               }

   In this example, ``MyKeyboardView`` is an instance of a custom implementation
   of ``KeyboardView`` that renders a ``Keyboard``.

   .. rubric:: Candidates view
      :name: CandidateView

   The candidates view is the UI where the IME displays potential word
   corrections or suggestions for the user to select. In the IME lifecycle, the
   system calls
   `onCreateCandidatesView() <#android.inputmethodservice.InputMethodService>`__
   when it's ready to display the candidates view. In your implementation of
   this method, return a layout that shows word suggestions, or return null if
   you don't want to show anything. A null response is the default behavior, so
   you don't have to implement this if you don't provide suggestions.

   .. rubric:: UI design considerations
      :name: DesignConsiderations

   This section describes some UI design considerations for IMEs.

   .. rubric:: Handle multiple screen sizes
      :name: handle-multiple-screen-sizes

   The UI for your IME must be able to scale for different screen sizes and
   handle both landscape and portrait orientations. In non-fullscreen IME mode,
   leave sufficient space for the application to show the text field and any
   associated context, so that no more than half the screen is occupied by the
   IME. In fullscreen IME mode, this isn't an issue.

   .. rubric:: Handle different input types
      :name: handle-different-input-types

   Android text fields let you set a specific input type, such as free-form
   text, numbers, URLs, email addresses, and search strings. When you implement
   a new IME, detect the input type of each field and provide the appropriate
   interface for it. However, you don't have to set up your IME to check whether
   the user enters valid text for the input type. This is the responsibility of
   the application that owns the text field.

   For example, here is the interface that the Latin IME provides for the
   Android platform text input:

   .. figure:: https://developer.android.google.cn/static/images/ui/text_input.png
      name: text-input
      :alt: An image showing a text input on a Latin IME
      :width: 40.0%

      **Figure 2.** Latin IME text input.

   And here here is the interface that the Latin IME provides for the Android
   platform numeric input:

   .. figure:: https://developer.android.google.cn/static/images/ui/numeric_input.png
      name: text-input
      :alt: An image showing a numeric input on a Latin IME
      :width: 40.0%

      **Figure 3.** Latin IME numeric input.

   When an input field receives focus and your IME starts, the system calls
   `onStartInputView() <#android.inputmethodservice.InputMethodService>`__,
   passing in an
   `EditorInfo <#android.view.inputmethod.EditorInfo>`__ object
   that contains details about the input type and other attributes of the text
   field. In this object, the
   `inputType <#android.view.inputmethod.EditorInfo>`__
   field contains the text field's input type.

   The ``inputType`` field is an ``int`` that contains bit patterns for various
   input type settings. To test it for the text field's input type, mask it with
   the constant
   `TYPE_MASK_CLASS <#android.text.InputType>`__,
   like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               inputType and InputType.TYPE_MASK_CLASS

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               inputType & InputType.TYPE_MASK_CLASS

   The input type bit pattern can have one of several values, including:

   `TYPE_CLASS_NUMBER <#android.text.InputType>`__
      A text field for entering numbers. As illustrated in figure 3, the Latin
      IME displays a number pad for fields of this type.
   `TYPE_CLASS_DATETIME <#android.text.InputType>`__
      A text field for entering a date and time.
   `TYPE_CLASS_PHONE <#android.text.InputType>`__
      A text field for entering telephone numbers.
   `TYPE_CLASS_TEXT <#android.text.InputType>`__
      A text field for entering any supported characters.

   These constants are described in more detail in the reference documentation
   for `InputType <#android.text.InputType>`__.

   The ``inputType`` field can contain other bits that indicate a variant of the
   text field type, such as:

   `TYPE_TEXT_VARIATION_PASSWORD <#android.text.InputType>`__
      A variant of ``TYPE_CLASS_TEXT`` for entering passwords. The input method
      displays dingbats instead of the actual text.
   `TYPE_TEXT_VARIATION_URI <#android.text.InputType>`__
      A variant of ``TYPE_CLASS_TEXT`` for entering web URLs and other Uniform
      Resource Identifiers (URIs).
   `TYPE_TEXT_FLAG_AUTO_COMPLETE <#android.text.InputType>`__
      A variant of ``TYPE_CLASS_TEXT`` for entering text that the application
      auto-completes from a dictionary, search, or other facility.

   Mask ``inputType`` with the appropriate constant when you test for these
   variants. The available mask constants are listed in the reference
   documentation for ``InputType``.

   **Caution:** In your own IME, handle text correctly when you send it to a
   password field. Hide the password in your UI, both in the input view and in
   the candidates view. Don't store passwords on a device. To learn more, see
   `Security tips <#>`__.

   .. rubric:: Send text to the application
      :name: SendText

   As the user inputs text with your IME, you can send text to the application
   by sending individual key events or by editing the text around the cursor in
   the application's text field. In either case, use an instance of
   ``InputConnection`` to deliver the text. To get this instance, call
   `InputMethodService.getCurrentInputConnection() <#android.inputmethodservice.InputMethodService>`__.

   .. rubric:: Edit the text around the cursor
      :name: EditingCursor

   When you're handling the editing of existing text, some useful methods in
   ``BaseInputConnection`` are the following:

   `getTextBeforeCursor() <#android.view.inputmethod.BaseInputConnection>`__
      Returns a `CharSequence <#>`__
      containing the number of requested characters before the current cursor
      position.
   `getTextAfterCursor() <#android.view.inputmethod.BaseInputConnection>`__
      Returns a ``CharSequence`` containing the number of requested characters
      following the current cursor position.
   `deleteSurroundingText() <#android.view.inputmethod.BaseInputConnection>`__
      Deletes the specified number of characters before and following the
      current cursor position.
   `commitText() <#android.view.inputmethod.BaseInputConnection>`__
      Commits a ``CharSequence`` to the text field and sets a new cursor
      position.

   For example, the following snippet shows how to replace the four characters
   to the left of the cursor with the text "Hello!":

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               currentInputConnection.also { ic: InputConnection ->
                   ic.deleteSurroundingText(4, 0)
                   ic.commitText("Hello", 1)
                   ic.commitText("!", 1)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               InputConnection ic = getCurrentInputConnection();
               ic.deleteSurroundingText(4, 0);
               ic.commitText("Hello", 1);
               ic.commitText("!", 1);

   .. rubric:: Support composing text before committing
      :name: ComposeThenCommit

   If your IME predicts text or requires multiple steps to compose a glyph or
   word, you can show the progress in the text field until the user commits the
   word, and then you can replace the partial composition with the completed
   text. You can give special treatment to the text by adding a *span* to it
   when you pass it to
   `setComposingText() <#android.view.inputmethod.InputConnection>`__.

   The following snippet demonstrates how to show progress in a text field:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               currentInputConnection.also { ic: InputConnection ->
                   ic.setComposingText("Composi", 1)
                   ic.setComposingText("Composin", 1)
                   ic.commitText("Composing ", 1)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               InputConnection ic = getCurrentInputConnection();
               ic.setComposingText("Composi", 1);
               ic.setComposingText("Composin", 1);
               ic.commitText("Composing ", 1);

   .. rubric:: Intercept hardware key events
      :name: HardwareKeyEvents

   Even though the input method window doesn't have explicit focus, it receives
   hardware key events first and can consume them or forward them to the
   application. For example, you might want to consume the directional keys to
   navigate within your UI for candidate selection during composition. You might
   also want to trap the back key to dismiss any dialogs originating from the
   input method window.

   To intercept hardware keys, override
   `onKeyDown() <#android.inputmethodservice.InputMethodService>`__
   and
   `onKeyUp() <#android.inputmethodservice.InputMethodService>`__.

   Call the ``super()`` method for keys you don't want to handle yourself.

   .. rubric:: Create an IME subtype
      :name: IMESubTypes

   Subtypes let the IME expose multiple input modes and languages supported by
   an IME. A subtype can represent the following:

   -  A locale, such as en_US or fr_FR
   -  An input mode, such as voice, keyboard, or handwriting
   -  Other input styles, forms, or properties specific to the IME, such as
      10-key or QWERTY keyboard layouts

   The mode can be any text, such as "keyboard" or "voice". A subtype can also
   expose a combination of these.

   Subtype information is used for an IME switcher dialog that's available from
   the notification bar and for IME settings. The information also lets the
   framework bring up a specific subtype of an IME directly. When you build an
   IME, use the subtype facility, because it helps the user identify and switch
   between different IME languages and modes.

   Define subtypes in one of the input method's XML resource files, using the
   ``<subtype>`` element. The following code snippet defines an IME with two
   subtypes: a keyboard subtype for the US English locale and another keyboard
   subtype for the French language locale for France:

   .. code:: prettyprint

      <input-method xmlns:android="http://schemas.android.com/apk/res/android"
              android:settingsActivity="com.example.softkeyboard.Settings"
              android:icon="@drawable/ime_icon">
          <subtype android:name="@string/display_name_english_keyboard_ime"
                  android:icon="@drawable/subtype_icon_english_keyboard_ime"
                  android:languageTag="en-US"
                  android:imeSubtypeMode="keyboard"
                  android:imeSubtypeExtraValue="somePrivateOption=true" />
          <subtype android:name="@string/display_name_french_keyboard_ime"
                  android:icon="@drawable/subtype_icon_french_keyboard_ime"
                  android:languageTag="fr-FR"
                  android:imeSubtypeMode="keyboard"
                  android:imeSubtypeExtraValue="someVariable=30,someInternalOption=false" />
          <subtype android:name="@string/display_name_german_keyboard_ime" ... />
      </input-method>

   To make sure your subtypes are labeled correctly in the UI, use \`%s\` to get
   a subtype label that is the same as the subtype's locale label. This is
   demonstrated in the next two code snippets. The first snippet shows part of
   the input method's XML file:

   .. code:: prettyprint

      <subtype
          android:label="@string/label_subtype_generic"
          android:imeSubtypeLocale="en_US"
          android:icon="@drawable/icon_en_us"
          android:imeSubtypeMode="keyboard" />

   The next snippet is part of the IME's ``strings.xml`` file. The string
   resource ``label_subtype_generic``, which is used by the input method UI
   definition to set the subtype's label, is defined as the following:

   .. code:: prettyprint

      <string name="label_subtype_generic">%s</string>

   This setting causes the subtype's display name to match the locale setting.
   For example, in any English locale, the display name is “English (United
   States).”

   .. rubric:: Choose IME subtypes from the notification bar
      :name: SubtypeProcessing

   The Android system manages all subtypes exposed by all IMEs. IME subtypes are
   treated as modes of the IME they belong to. The user can navigate from the
   notification bar or the Settings app to a menu of available IME subtypes, as
   shown in the following figure:

   .. figure:: https://developer.android.google.cn/static/images/ui/languages_and_input.png
      name: text-input
      :alt: An image showing the Languages & input System menu
      :width: 40.0%

      **Figure 4.** The **Languages & input** system menu.

   .. rubric:: Choose IME subtypes from System Settings
      :name: SubtypeSettings

   The user can also control how subtypes are used in the **Language & input**
   settings panel in the system settings:

   .. figure:: https://developer.android.google.cn/static/images/ui/languages.png
      name: text-input
      :alt: An image showing the Languages selection menu
      :width: 40.0%

      **Figure 5.** The **Languages** system menu

   .. rubric:: Switch among IME subtypes
      :name: Switching

   You can let users easily switch among IME subtypes by providing a switching
   key, such as the globe-shaped language icon on the keyboard. This improves
   the keyboard's usability and is convenient for the user. To enable this
   switching, perform the following steps:

   #. Declare ``supportsSwitchingToNextInputMethod = "true"`` in the input
      method's XML resource files. Your declaration must look similar to the
      following code snippet:

      .. code:: prettyprint

         <input-method xmlns:android="http://schemas.android.com/apk/res/android"
                 android:settingsActivity="com.example.softkeyboard.Settings"
                 android:icon="@drawable/ime_icon"
                 android:supportsSwitchingToNextInputMethod="true">

   #. Call the
      `shouldOfferSwitchingToNextInputMethod() <#android.inputmethodservice.InputMethodService>`__
      method.

   #. If the method returns true, display a switching key.

   #. When the user taps the switching key, call
      `switchToNextInputMethod() <#android.inputmethodservice.InputMethodService>`__,
      passing false. A value of false tells the system to treat all subtypes
      equally, regardless of what IME they belong to. Specifying true requires
      the system to cycle through subtypes in the current IME.

   .. rubric:: General IME considerations
      :name: GeneralDesign

   Here are other things to consider as you implement your IME:

   -  Provide a way for users to set options directly from the IME's UI.
   -  Provide a way for users to switch to a different IME directly from the
      input method UI, because multiple IMEs might be installed on the device.
   -  Bring up the IME's UI quickly. Preload or load on demand any large
      resources so that users see the IME as soon as they tap a text field.
      Cache resources and views for subsequent invocations of the input method.
   -  Release large memory allocations immediately after the input method window
      is hidden, so that applications have sufficient memory to run. Use a
      delayed message to release resources if the IME is hidden for a few
      seconds.
   -  Make sure users can enter as many characters as possible for the language
      or locale associated with the IME. Users might use punctuation in
      passwords or user names, so your IME must provide many different
      characters to let users enter a password and access the device.


Last updated 2024-05-03 UTC.


/Add image keyboard support
===========================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/image-keyboard?hl=en

.. container:: devsite-article-body

   Users often want to communicate using emoji, stickers, and other kinds of
   rich content. In previous versions of Android, soft keyboards—also known as
   `input method editors <#>`__, or
   IMEs—could send only Unicode emoji to apps. For rich content, apps built
   app-specific APIs that couldn't be used in other apps or used workarounds
   like sending images through `simple share action <#>`__ or the clipboard.

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/text/image-keyboard-sample.png
      name: example
      :alt: An image showing a keyboard that support image search
      :width: 30.0%

      **Figure 1.** Example of image keyboard support.

   Starting with Android 7.1 (API level 25), the Android SDK includes the Commit
   Content API, which provides a universal way for IMEs to send images and other
   rich content directly to a text editor in an app. The API is also available
   in the v13 Support Library as of revision 25.0.0. We recommend using the
   Support Library because it contains helper methods that simplify
   implementation.

   With this API, you can build messaging apps that accept rich content from any
   keyboard as well as keyboards that can send rich content to any app. The
   `Google Keyboard <https://play.google.com/store/apps/details?id=com.google.android.inputmethod.latin>`__
   and apps like `Messages by Google <https://play.google.com/store/apps/details?id=com.google.android.apps.messaging>`__
   support the Commit Content API in Android 7.1, as shown in figure 1.

   This document shows how to implement the Commit Content API in both IMEs and
   apps.

   .. rubric:: How it works
      :name: how-it-works

   Keyboard image insertion requires participation from the IME and the app. The
   following sequence describes each step in the image insertion process:

   #. When the user taps an
      `EditText <#android.widget.EditText>`__, the editor sends a
      list of MIME content types that it accepts in
      `EditorInfo.contentMimeTypes <#android.view.inputmethod.EditorInfo>`__.

   #. The IME reads the list of supported types and displays content in the soft
      keyboard that the editor can accept.

   #. When the user selects an image, the IME calls
      `commitContent() <#android.view.inputmethod.InputConnection>`__
      and sends an
      `InputContentInfo <#android.view.inputmethod.InputContentInfo>`__
      to the editor. The ``commitContent()`` call is analogous to the
      `commitText() <#android.view.inputmethod.InputConnection>`__
      call, but for rich content. ``InputContentInfo`` contains an URI that
      identifies the content in a `content provider <#>`__.

   This process is depicted in figure 2:

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/text/image-keyboard-diagram.png
      name: diagram
      :alt: An image showing the sequence from Application to IME and back to
      Application
      :width: 60.0%

      **Figure 2.** Application to IME to application flow.

   .. rubric:: Add image support to apps
      :name: image-support

   **Important:**\  For editable ``TextView`` objects, follow the implementation
   steps in the `Receive rich content <#>`__ documentation to
   quickly add support for accepting rich content from IMEs in your app. This
   section describes how to accept rich content for ``View`` objects that don't
   yet support the
   `OnReceiveContentListener <#android.view.OnReceiveContentListener>`__.
   To accept rich content from IMEs, an app must tell IMEs what content types it
   accepts and specify a callback method that is executed when content is
   received. The following example demonstrates how to create an ``EditText``
   that accepts PNG images:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var editText: EditText = object : EditText(this) {
                   override fun onCreateInputConnection(outAttrs: EditorInfo): InputConnection {
                       var ic = super.onCreateInputConnection(outAttrs)
                       EditorInfoCompat.setContentMimeTypes(outAttrs, arrayOf("image/png"))
                       val mimeTypes = ViewCompat.getOnReceiveContentMimeTypes(this)
                       if (mimeTypes != null) {
                           EditorInfoCompat.setContentMimeTypes(outAttrs, mimeTypes)
                           ic = InputConnectionCompat.createWrapper(this, ic, outAttrs)
                       }
                       return ic
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               EditText editText = new EditText(this) {
                   @Override
                   public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
                       InputConnection ic = super.onCreateInputConnection(outAttrs);
                       EditorInfoCompat.setContentMimeTypes(outAttrs, new String[]{"image/png"});
                       String[] mimeTypes = ViewCompat.getOnReceiveContentMimeTypes(this);
                       if (mimeTypes != null) {
                           EditorInfoCompat.setContentMimeTypes(outAttrs, mimeTypes);
                           ic = InputConnectionCompat.createWrapper(this, ic, outAttrs);
                       }
                       return ic;
                   }
               };

   The following is further explanation:

   -  This example uses the Support Library, so there are some references to
      `android.support.v13.view.inputmethod <#android.support.v13.view.inputmethod.package-summary>`__
      instead of
      `android.view.inputmethod <#android.view.inputmethod.package-summary>`__.

   -  This example creates an ``EditText`` and overrides its
      `onCreateInputConnection(EditorInfo) <#android.widget.TextView>`__
      method to modify the
      `InputConnection <#android.view.inputmethod.InputConnection>`__.
      The ``InputConnection`` is the communication channel between an IME and
      the app that is receiving its input.

   -  The call
      `super.onCreateInputConnection() <#android.widget.TextView>`__
      preserves the built-in behavior—sending and receiving text—and gives you a
      reference to the ``InputConnection``.

   -  `setContentMimeTypes() <#androidx.core.view.inputmethod.EditorInfoCompat>`__
      adds a list of supported MIME types to the
      `EditorInfo <#android.view.inputmethod.EditorInfo>`__. Call
      ``super.onCreateInputConnection()`` before ``setContentMimeTypes()``.

   -  ``callback`` is executed whenever the IME commits content. The method
      `onCommitContent() <#androidx.core.view.inputmethod.InputConnectionCompat.OnCommitContentListener>`__
      has a reference to
      `InputContentInfoCompat <#androidx.core.view.inputmethod.InputContentInfoCompat>`__,
      which contains a content URI.

      -  Request and release permissions if your app is running on API level 25
         or higher and the
         `INPUT_CONTENT_GRANT_READ_URI_PERMISSION <#androidx.core.view.inputmethod.InputConnectionCompat>`__
         flag is set by the IME. Otherwise, you already have access to the
         content URI because it is granted by the IME or because the content
         provider doesn't restrict access. For more information, see `Add image support to IMEs <#imes>`__.

   -  `createWrapper() <#androidx.core.view.inputmethod.InputConnectionCompat>`__
      wraps the ``InputConnection``, the modified ``EditorInfo``, and the
      callback into a new ``InputConnection`` and returns it.

   The following are recommended practices:

   -  Editors that don't support rich content don't call
      `setContentMimeTypes() <#androidx.core.view.inputmethod.EditorInfoCompat>`__,
      and they leave their ``EditorInfo.contentMimeTypes`` set to ``null``.

   -  Editors ignore the content if the MIME type specified in
      ``InputContentInfo`` doesn't match any of the types they accept.

   -  Rich content doesn't affect and isn't affected by the position of the text
      cursor. Editors can ignore cursor position when working with content.

   -  In the editor's
      `OnCommitContentListener.onCommitContent() <#androidx.core.view.inputmethod.InputConnectionCompat.OnCommitContentListener>`__
      method, you can return ``true`` asynchronously, even before loading the
      content.

   -  Unlike text, which can be edited in the IME before being committed, rich
      content is committed immediately. If you want to let users edit or delete
      content, implement the logic yourself.

   To test your app, make sure your device or emulator has a keyboard that can
   send rich content. You can use the Google Keyboard in Android 7.1 or higher.

   .. rubric:: Add image support to IMEs
      :name: imes

   IMEs that want to send rich content to apps must implement the Commit Content
   API, as shown in the following example:

   -  Override
      `onStartInput() <#android.inputmethodservice.InputMethodService>`__
      or
      `onStartInputView() <#android.inputmethodservice.InputMethodService>`__
      and read the list of supported content types from the target editor. The
      following code snippet shows how to check whether the target editor
      accepts GIF images.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onStartInputView(editorInfo: EditorInfo, restarting: Boolean) {
                   val mimeTypes: Array<String> = EditorInfoCompat.getContentMimeTypes(editorInfo)

                   val gifSupported: Boolean = mimeTypes.any {
                       ClipDescription.compareMimeTypes(it, "image/gif")
                   }

                   if (gifSupported) {
                       // The target editor supports GIFs. Enable the corresponding content.
                   } else {
                       // The target editor doesn't support GIFs. Disable the corresponding
                       // content.
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onStartInputView(EditorInfo info, boolean restarting) {
                   String[] mimeTypes = EditorInfoCompat.getContentMimeTypes(editorInfo);

                   boolean gifSupported = false;
                   for (String mimeType : mimeTypes) {
                       if (ClipDescription.compareMimeTypes(mimeType, "image/gif")) {
                           gifSupported = true;
                       }
                   }

                   if (gifSupported) {
                       // The target editor supports GIFs. Enable the corresponding content.
                   } else {
                       // The target editor doesn't support GIFs. Disable the corresponding
                       // content.
                   }
               }

   -  Commit content to the app when the user selects an image. Avoid calling
      `commitContent() <#android.view.inputmethod.InputConnection>`__
      when there is any text being composed, because it might cause the editor
      to lose focus. The following code snippet shows how to commit a GIF image.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Commits a GIF image.

               // @param contentUri = Content URI of the GIF image to be sent.
               // @param imageDescription = Description of the GIF image to be sent.

               fun commitGifImage(contentUri: Uri, imageDescription: String) {
                   val inputContentInfo = InputContentInfoCompat(
                           contentUri,
                           ClipDescription(imageDescription, arrayOf("image/gif")),
                           null
                   )
                   val inputConnection = currentInputConnection
                   val editorInfo = currentInputEditorInfo
                   var flags = 0
                   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {
                       flags = flags or InputConnectionCompat.INPUT_CONTENT_GRANT_READ_URI_PERMISSION
                   }
                   InputConnectionCompat.commitContent(inputConnection, editorInfo, inputContentInfo, flags, null)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Commits a GIF image.

               // @param contentUri = Content URI of the GIF image to be sent.
               // @param imageDescription = Description of the GIF image to be sent.

               public static void commitGifImage(Uri contentUri, String imageDescription) {
                   InputContentInfoCompat inputContentInfo = new InputContentInfoCompat(
                           contentUri,
                           new ClipDescription(imageDescription, new String[]{"image/gif"}),
                           null
                   );
                   InputConnection inputConnection = getCurrentInputConnection();
                   EditorInfo editorInfo = getCurrentInputEditorInfo();
                   Int flags = 0;
                   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {
                       flags |= InputConnectionCompat.INPUT_CONTENT_GRANT_READ_URI_PERMISSION;
                   }
                   InputConnectionCompat.commitContent(
                           inputConnection, editorInfo, inputContentInfo, flags, null);
               }

   As an IME author, you most likely have to implement your own content provider
   to respond to content URI requests. The exception is if your IME supports
   content from existing content providers like
   `MediaStore <#android.provider.MediaStore>`__. For information
   on building content providers, see the `content provider <#>`__ and `file provider <#>`__ documentation.

   If you are building your own content provider, we recommend you don't export
   it by setting
   `android:exported <#exported>`__
   to ``false``. Instead, enable permission granting in the provider by setting
   `android:grantUriPermission <#gprmsn>`__
   to ``true``. Then, your IME can grant permissions to access the content URI
   when the content is committed. There are two ways to do this:

   -  On Android 7.1 (API level 25) and higher, when calling
      ``commitContent()``, set the flag parameter to
      `INPUT_CONTENT_GRANT_READ_URI_PERMISSION <#androidx.core.view.inputmethod.InputConnectionCompat>`__.
      Then, the ``InputContentInfo`` object that the app receives can request
      and release temporary read permissions by calling
      `requestPermission() <#android.view.inputmethod.InputContentInfo>`__
      and
      `releasePermission() <#android.view.inputmethod.InputContentInfo>`__.

   -  On Android 7.0 (API level 24) and lower,
      ``INPUT_CONTENT_GRANT_READ_URI_PERMISSION`` is ignored, so manually grant
      permission to the content. One way to do this is with
      `grantUriPermission() <#android.content.Context>`__,
      but you can implement your own mechanism that satisfies your own
      requirements.

   To test your IME, make sure your device or emulator has an app that can
   receive rich content. You can use the Google Messenger app in Android 7.1 or
   higher.


Last updated 2024-02-22 UTC.


/Implement a spelling checker
=============================

.. https://developer.android.google.cn/develop/ui/views/touch-and-input/spell-checker-framework?hl=en

.. container:: devsite-article-body

   The Android platform offers a spell checker framework that lets you implement
   and access spell checking in your app. The framework is one of the Text
   Service APIs.

   To use the framework in your app, you create an Android service that
   generates a spell checker *session* object. Based on text you provide, the
   session object returns spelling suggestions generated by the spell checker.

   .. rubric:: Spell checker lifecycle
      :name: SpellCheckLifeCycle

   The following diagram shows the lifecycle of the spell checker service:

   .. figure:: https://developer.android.google.cn/static/resources/articles/images/spellcheck_lifecycle.png
      name: speller-lifecycle
      :alt: An image showing the lifecycle for the spelling checker service
      :width: 70.0%

      **Figure 1.** The spell checker service lifecycle.

   To initiate spell checking, your app starts its implementation of the spell
   checker service. Clients in your app, such as activities or individual UI
   elements, request a spell checker session from the service, then use the
   session to get suggestions for text. As a client terminates its operation, it
   closes its spell checker session. If necessary, your app can shut down the
   spell checker service at any time.

   .. rubric:: Implement a spell checker service
      :name: SpellCheckImplementation

   To use the spell checker framework in your app, add a spell checker service
   component that includes the session object definition. You can also add an
   optional activity to your app that controls settings. Add an XML metadata
   file that describes the spell checker service, and add the appropriate
   elements to your manifest file.

   .. rubric:: Spell checker classes
      :name: SpellCheckCode

   Define the service and session object with the following classes:

   A subclass of `SpellCheckerService <#android.service.textservice.SpellCheckerService>`__
      The ``SpellCheckerService`` implements both the
      `Service <#android.app.Service>`__ class and the spell
      checker framework interface. Within your subclass, implement the following
      method:

      `createSession() <#android.service.textservice.SpellCheckerService>`__
         A factory method that returns a ``SpellCheckerService.Session`` object
         to a client that wants to check spelling.
   An implementation of `SpellCheckerService.Session <#android.service.textservice.SpellCheckerService.Session>`__
      An object that the spell checker service provides to clients to let them
      pass text to the spell checker and receive suggestions. Within this class,
      implement the following methods:

      `onCreate() <#android.service.textservice.SpellCheckerService.Session>`__
         Called by the system in response to ``createSession()``. In this
         method, you can initialize the ``SpellCheckerService.Session`` object
         based on the current locale and other details.
      `onGetSentenceSuggestionsMultiple() <#android.service.textservice.SpellCheckerService.Session>`__
         Performs the actual spell checking. This method returns an array of
         `SentenceSuggestionsInfo <#android.view.textservice.SentenceSuggestionsInfo>`__
         containing suggestions for the sentences passed to it.

      Optionally, you can implement
      `onCancel() <#android.service.textservice.SpellCheckerService.Session>`__,
      which handles requests to cancel spell checking;
      `onGetSuggestions() <#android.service.textservice.SpellCheckerService.Session>`__,
      which handles a word suggestion request; or
      `onGetSuggestionsMultiple() <#android.service.textservice.SpellCheckerService.Session>`__,
      which handles batches of word suggestion requests.

   **Note:** Implement all aspects of spell checking asynchronously and in a
   thread-safe manner. A spell checker might be called simultaneously by
   different threads running on different cores. The ``SpellCheckerService`` and
   ``SpellCheckerService.Session`` take care of this automatically.

   .. rubric:: Spell checker manifest and metadata
      :name: SpellCheckXML

   In addition to code, provide the appropriate manifest file and a metadata
   file for the spell checker.

   The manifest file defines the app, the service, and the activity for
   controlling settings, as shown in the following example:

   .. code:: prettyprint

      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.android.samplespellcheckerservice" >
          <application
              android:label="@string/app_name" >
              <service
                  android:label="@string/app_name"
                  android:name=".SampleSpellCheckerService"
                  android:permission="android.permission.BIND_TEXT_SERVICE" >
                  <intent-filter >
                      <action android:name="android.service.textservice.SpellCheckerService" />
                  </intent-filter>

                  <meta-data
                      android:name="android.view.textservice.scs"
                      android:resource="@xml/spellchecker" />
              </service>

              <activity
                  android:label="@string/sample_settings"
                  android:name="SpellCheckerSettingsActivity" >
                  <intent-filter >
                      <action android:name="android.intent.action.MAIN" />
                  </intent-filter>
              </activity>
          </application>
      </manifest>

   Components that want to use the service must request the permission
   `BIND_TEXT_SERVICE <#android.Manifest.permission>`__
   to ensure that only the system binds to the service. The service's definition
   also specifies the ``spellchecker.xml`` metadata file, which is described in
   the next section.

   The metadata file ``spellchecker.xml`` contains the following XML:

   .. code:: prettyprint

      <spell-checker xmlns:android="http://schemas.android.com/apk/res/android"
              android:label="@string/spellchecker_name"
              android:settingsActivity="com.example.SpellCheckerSettingsActivity">
          <subtype
                  android:label="@string/subtype_generic"
                  android:subtypeLocale="en”
          />
          <subtype
                  android:label="@string/subtype_generic"
                  android:subtypeLocale="fr”
          />
      </spell-checker>

   The metadata specifies the activity that the spell checker uses to control
   settings. It also defines subtypes for the spell checker. In this case, the
   subtypes define locales that the spell checker can handle.

   .. rubric:: Access the spell checker service from a client
      :name: SpellCheckClient

   apps that use `TextView <#android.widget.TextView>`__ and
   `EditText <#android.widget.EditText>`__ views automatically
   benefit from spell checking, because ``TextView`` automatically uses a spell
   checker:

   .. figure:: https://developer.android.google.cn/static/images/ui/spellchecker_edittext.png
      name: textview
      :alt: An image showing how the spell checker is automatically enabled in
      EditText
      :width: 50.0%

      **Figure 2.** Spell checking in an ``EditText``.

   However, you might want to interact directly with a spell checker service in
   other cases. The following diagram shows the flow of control for interacting
   with a spell checker service:

   .. figure:: https://developer.android.google.cn/static/resources/articles/images/spellcheck_client_flow.png
      name: interact
      :alt: An image showing the diagram of the interaction with a spell checker
      service
      :width: 35.0%

      **Figure 3.** Interaction with a spell checker service.

   The `LatinIME input method editor in the Android Open Source Project <https://android.googlesource.com/platform/packages/inputmethods/LatinIME/>`__
   contains an example of spell checking.


Last updated 2024-02-22 UTC.


/About notifications
====================

.. https://developer.android.google.cn/develop/ui/views/notifications?hl=en

.. container:: devsite-article-body

   A notification is a message that Android displays outside your app's UI to
   provide the user with reminders, communication from other people, or other
   timely information from your app. Users can tap the notification to open your
   app or take an action directly from the notification.

   This page provides an overview of where notifications appear and the
   available features. To start building notifications, read `Create a notification <#>`__.

   For more information about notification design and interaction patterns, see
   the `Notifications design guide <#>`__.

   .. rubric:: Appearances on a device
      :name: appearances

   Notifications automatically appear to users in different locations and
   formats. A notification appears as an icon in the status bar, a more detailed
   entry in the notification drawer, and a badge on the app's icon.
   Notifications also appear on paired wearables.

   .. rubric:: Status bar and notification drawer
      :name: bar-and-drawer

   When you issue a notification, it first appears as an icon in the status bar.

   |image-notification-area_2x|

   **Figure 1.** Notification icons appear on the left side of the status bar.

   Users can swipe down on the status bar to open the notification drawer, where
   they can view more details and take actions with the notification.

   |image-notification-drawer_2x|

   **Figure 2.** Notifications in the notification drawer.

   Users can drag down on a notification in the drawer to reveal the expanded
   view, which shows additional content and action buttons, if provided.
   Starting in Android 13, this expanded view includes a button that lets users
   `stop an app that has ongoing foreground services <#handle-user-initiated-stop>`__.

   A notification remains visible in the notification drawer until it's
   dismissed by the app or user.

   .. rubric:: Heads-up notification
      :name: Heads-up

   Beginning with Android 5.0, notifications can briefly appear in a floating
   window called a *heads-up notification*. This behavior is normally for
   important notifications that the user needs to know about immediately, and it
   only appears if the device is unlocked.

   |image-heads-up_2x|

   **Figure 3.** A heads-up notification appears in front of the foreground app.

   The heads-up notification appears when your app issues the notification. It
   disappears after a moment, but it remains visible in the notification drawer
   as usual.

   Conditions that might trigger heads-up notifications include the following:

   -  The user's activity is in fullscreen mode, such as when the app uses
      `fullScreenIntent <#android.app.Notification>`__.

   -  The notification has high priority and uses ringtones or vibrations on
      devices running Android 7.1 (API level 25) and lower.

   -  The `notification channel <#ManageChannels>`__ has high importance on
      devices running Android 8.0 (API level 26) and higher.

   .. rubric:: Lock screen
      :name: lockscreenNotification

   Beginning with Android 5.0, notifications can appear on the lock screen.

   You can programmatically set whether notifications posted by your app show on
   a secure lock screen and, if so, the level of detail visible.

   Users can use the system settings to choose the level of detail visible in
   lock screen notifications or to disable all lock screen notifications.
   Starting with Android 8.0, users can disable or enable lock screen
   notifications for each notification channel.

   |image-lock-screen_2x|

   **Figure 4.** Notifications on the lock screen with sensitive content hidden.

   To learn more, see `Set lock screen visibility <#lockscreenNotification>`__.

   .. rubric:: App icon badge
      :name: icon-badge

   In supported launchers on devices running Android 8.0 (API level 26) and
   higher, app icons indicate new notifications with a colored *badge* known as
   a *notification dot* on the corresponding app launcher icon.

   Users can touch & hold an app icon to see the notifications for that app.
   Users can dismiss or act on notifications from that menu, similar to the
   notification drawer.

   |image-badges-open_2x|

   **Figure 5.** Notification badges and the touch & hold menu.

   To learn more about how badges work, read `Modify a notification badge <#>`__.

   .. rubric:: Wear OS devices
      :name: wear

   If the user has a paired Wear OS device, all your notifications appear there
   automatically, including expandable detail and action buttons.

   You can enhance the experience by customizing the appearance of your
   notifications on wearables and by providing different actions, including
   suggested replies and voice input replies. For more information, see how to
   `add wearable-specific features to your notification <#add-wearable-features>`__.

   |image-wear_2x|

   **Figure 6.** Notifications automatically appear on a paired Wear OS device.

   .. rubric:: Notification anatomy
      :name: Templates

   The design of a notification is determined by system templates, and your app
   defines the contents for each portion of the template. Some details of the
   notification appear only in the expanded view.

   |image-notification-callouts_2x|

   **Figure 7.** A notification with basic details.

   The most common parts of a notification are indicated in figure 7, as
   follows:

   #. Small icon: required; set using
      `setSmallIcon() <#androidx.core.app.NotificationCompat.Builder>`__.
   #. App name: provided by the system.
   #. Time stamp: provided by the system, but you can override it using
      `setWhen() <#androidx.core.app.NotificationCompat.Builder>`__
      or hide it using
      `setShowWhen(false) <#androidx.core.app.NotificationCompat.Builder>`__.
   #. Large icon: optional; usually used only for contact photos. Don't use it
      for your app icon. Set using
      `setLargeIcon() <#androidx.core.app.NotificationCompat.Builder>`__.
   #. Title: optional; set using
      `setContentTitle() <#androidx.core.app.NotificationCompat.Builder>`__.
   #. Text: optional; set using
      `setContentText() <#androidx.core.app.NotificationCompat.Builder>`__.

   We strongly recommend using system templates for proper design compatibility
   on all devices. If necessary, you can `create a custom notification layout <#>`__.

   For more information about how to create a notification with these features
   and more, read `Create a notification <#>`__.

   .. rubric:: Notification actions
      :name: Actions

   Although it's not required, it's a good practice for every notification to
   open an appropriate app activity when it's tapped. In addition to this
   default notification action, you can add action buttons that complete an
   app-related task from the notification—often without opening an activity—as
   shown in figure 8.

   |image-notification-actions_2x|

   **Figure 8.** A notification with action buttons.

   Starting in Android 7.0 (API level 24), you can add an action to reply to
   messages or enter other text directly from the notification.

   Starting in Android 10 (API level 29), the platform can automatically
   generate action buttons with suggested intent-based actions.

   Adding action buttons is explained further in `Create a notification <#>`__.

   .. rubric:: Require an unlocked device
      :name: ActionsRequireUnlockedDevice

   Users might see notification actions on the device's lock screen. If a
   notification action causes an app to launch an activity or send a direct
   reply, users must unlock the device before the app can invoke that
   notification action.

   On Android 12 (API level 31) and higher, you can configure a notification
   action such that the device must be unlocked for your app to invoke that
   action, no matter what workflow the action launches. This option adds an
   extra layer of security to notifications on locked devices.

   To require a device to be unlocked before your app invokes a given
   notification action, pass ``true`` into
   `setAuthenticationRequired() <#android.app.Notification.Action.Builder>`__
   when creating your notification action, as shown in the following code
   snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val moreSecureNotification = Notification.Action.Builder(...)

                   // This notification always requests authentication when invoked
                   // from a lock screen.
                   .setAuthenticationRequired(true)
                   .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification moreSecureNotification = new Notification.Action.Builder(...)

                   // This notification always requests authentication when invoked
                   // from a lock screen.
                   .setAuthenticationRequired(true)
                   .build();

   .. rubric:: Expandable notification
      :name: expandable

   By default, the notification's text content is truncated to fit on one line.
   If you want your notification to be longer, you can enable a larger text area
   that's expandable by applying an additional template, as shown in figure 9.

   |image-notification-expanded_2x|

   **Figure 9.** An expandable notification for large text.

   You can also create an expandable notification with an image, in inbox style,
   with a chat conversation, or with media playback controls. For more
   information, read `Create an expandable notification <#>`__.

   .. rubric:: Notification updates and groups
      :name: bundle

   To avoid flooding your users with multiple or redundant notifications when
   you have additional updates, `update an existing notification <#Updating>`__ rather
   than issuing a new one or use the `inbox-style notification <#inbox-style>`__ to show
   conversation updates.

   However, if it's necessary to deliver multiple notifications, consider
   grouping the separate notifications into a group, available on Android 7.0
   and higher.

   A notification group lets you collapse multiple notifications into one post
   in the notification drawer with a summary. The user can progressively expand
   the notification group and each notification within it for more details, as
   shown in figure 10.

   |image-notification-group_2x|

   **Figure 10.** A collapsed and expanded notification group.

   To learn how to add notifications to a group, see `Create a group of notifications <#>`__.

   **Note:**\  If the same app sends four or more notifications and doesn't
   specify a grouping, the system automatically groups them together.

   .. rubric:: Notification channels
      :name: ManageChannels

   Starting in Android 8.0 (API level 26), all notifications must be assigned to
   a channel or they don't appear. This lets users disable specific notification
   channels for your app instead of disabling *all* your notifications. Users
   can control the visual and auditory options for each channel from the Android
   system settings, as shown in figure 11. Users can also touch & hold a
   notification to change behaviors for the associated channel.

   On devices running Android 7.1 (API level 25) and lower, users can manage
   notifications on a per-app basis only. Each app effectively has only one
   channel on Android 7.1 and lower.

   |image-channel-settings_2x|

   **Figure 11.** Notification settings for the Clock app and one of its
   channels.

   **Note:**\  The user interface refers to channels as "categories."
   An app can have separate channels for each type of notification the app
   issues. An app can also create notification channels in response to choices
   made by users. For example, you can set up separate notification channels for
   each conversation group created by a user in a messaging app.

   The channel is also where you specify the importance level for your
   notifications on Android 8.0 and higher, so all notifications posted to the
   same notification channel have the same behavior. This is described in the
   following section.

   For more information, see `Create and manage notification channels <#>`__.

   .. rubric:: Notification importance
      :name: importance

   Android uses the *importance* of a notification to determine how much the
   notification interrupts the user visually and audibly. The higher the
   importance of a notification, the more interruptive the notification is.

   On Android 7.1 (API level 25) and lower, the importance of a notification is
   determined by the notification's
   `priority <#androidx.core.app.NotificationCompat.Builder>`__.

   On Android 8.0 (API level 26) and higher, the importance of a notification is
   determined by the
   `importance <#android.app.NotificationChannel>`__
   of the channel the notification is posted to. Users can change the importance
   of a notification channel in the system settings, as shown in figure 12.

   |image-channel-alert-levels_2x|

   **Figure 12.** Users can change the importance of each channel on Android 8.0
   and higher.

   The possible importance levels and the associated notification behaviors are
   the following:

   -  Urgent: makes a sound and appears as a heads-up notification.

   -  High: makes a sound.

   -  Medium: makes no sound.

   -  Low: makes no sound and doesn't appear in the status bar.

   All notifications, regardless of importance, appear in non-interruptive
   system UI locations, such as in the notification drawer and as a badge on the
   launcher icon. However, you can `modify the appearance of the notification badge <#>`__.

   For more information, read about `how to set the importance <#Priority>`__.

   .. rubric:: Do Not Disturb mode
      :name: dnd-mode

   Starting in Android 5.0 (API level 21), users can enable *Do Not Disturb
   mode*, which silences sound and vibration for all notifications.
   Notifications still appear in the system UI as normal, unless the user
   specifies otherwise.

   There are three levels available in Do Not Disturb mode:

   -  Total silence: blocks all sounds and vibrations, including from alarms,
      music, videos, and games.
   -  Alarms only: blocks all sounds and vibrations, except from alarms.
   -  Priority only: users can configure which system-wide categories can
      interrupt them, such as only alarms, reminders, events, calls, or
      messages. For messages and calls, users can filter based on sender or
      caller, as shown in figure 13.

   |image-do-not-disturb-filter-settings_2x|

   **Figure 13.** Users can can allow notifications through based on system-wide
   categories (left) and sender or caller (right).

   On Android 8.0 (API level 26) and higher, users can additionally allow
   notifications through for app-specific categories—also known as channels—by
   overriding Do Not Disturb on a channel-by-channel basis. For example, a
   payment app might have channels for notifications related to withdrawals and
   deposits. The user can allow withdrawal notifications, deposit notifications,
   or both when in priority mode.

   On devices running Android 7.1 (API level 25) and lower, users can allow
   notifications through on an app-by-app basis, rather than on a
   channel-by-channel basis.

   To configure your notifications for these user settings, you must `set a
   system-wide category <#system-category>`__.

   .. rubric:: Notifications for foreground services
      :name: foreground-service

   A notification is required when your app is running a *foreground service*—a
   `Service <#android.app.Service>`__ running in the background
   that's long-living and noticeable to the user, such as a media player. This
   notification can't be dismissed like other notifications. To remove the
   notification, the service must be stopped or removed from the foreground
   state.

   For more information, read `Foreground services <#>`__. If you are building a
   media player, also read `Playing media in the background <#playing_media_in_the_background>`__.

   .. rubric:: Post limits
      :name: limits

   Beginning with Android 8.1 (API level 27), apps can't make a notification
   sound more than once per second. If your app posts multiple notifications in
   one second, they all appear as expected, but only the first notification per
   second makes a sound.

   However, Android also applies a rate limit when updating a notification. If
   you post updates to a single notification too frequently, such as many in
   less than one second, the system might drop updates.

   .. rubric:: Notification compatibility
      :name: compatibility

   The Android notification system UI and the notification-related APIs
   continually evolve. To use the latest notification API features while
   supporting older devices, use the Support Library notification API,
   `NotificationCompat <#androidx.core.app.NotificationCompat>`__,
   and its subclasses, as well as
   `NotificationManagerCompat <#androidx.core.app.NotificationManagerCompat>`__.
   This lets you avoid writing conditional code to check API levels, because
   these APIs handle it.

   ``NotificationCompat`` is updated as the platform evolves to include the
   latest methods. However, the availability of a method in
   ``NotificationCompat`` doesn't guarantee that the corresponding feature is
   provided on older devices. In some cases, calling a newly introduced API
   results in a no-op on older devices.

   The following is a summary of the most notable behavior changes by API level
   for Android notifications.

   .. rubric:: Android 5.0, API level 21
      :name: android_50_api_level_21
      :class: hide-from-toc

   -  Introduces lock screen and heads-up notifications.

   -  Lets the user set the phone to Do Not Disturb mode and configure which
      notifications are allowed to interrupt them when the device is in
      priority-only mode.

   -  Adds methods to set whether a notification is displayed on the lock
      screen, such as
      `setVisibility() <#androidx.core.app.NotificationCompat.Builder>`__),
      and for specifying a “public” version of the notification text.

   -  Adds ``setPriority()`` method, which tells the system how interruptive the
      notification is. For example, setting the priority to high makes the
      notification appear as a heads-up notification.

   -  Adds notification stacks support to Android Wear (now called Wear OS)
      devices. Put notifications into a stack using
      `setGroup() <#androidx.core.app.NotificationCompat.Builder>`__.
      Notification stacks, later known as a group or bundle, aren't supported on
      tablets or phones until Android 7.0 (API level 24).

   .. rubric:: Android 7.0, API level 24
      :name: android_70_api_level_24
      :class: hide-from-toc

   -  Restyles notification templates to put emphasis on the hero image and
      avatar.

   -  Adds three notification templates: one for messaging apps and the other
      two for decorating custom content views with the expandable affordance and
      other system decorations.

   -  Adds support to handheld devices, such as phones and tablets, for
      notification groups. Uses the same API as the Android Wear (now called
      Wear OS) notification stacks introduced in Android 5.0 (API level 21).

   -  Lets users reply inside a notification using inline reply. They can enter
      text, which is then routed to the notification's parent app.

   .. rubric:: Android 8.0, API level 26
      :name: android_80_api_level_26
      :class: hide-from-toc

   -  Makes individual notifications be put in a specific
      `channel <#ManageChannels>`__.

   -  Lets users turn off notifications per channel, instead of turning off all
      notifications from an app.

   -  Makes apps with active notifications display a notification badge on top
      of their app icon on the home or launcher screen.

   -  Lets users snooze a notification from the drawer. You can set an automatic
      timeout for a notification.

   -  Lets you set the notification's background color.

   -  Moves some APIs regarding notification behaviors from
      `Notification <#android.app.Notification>`__ to
      `NotificationChannel <#android.app.NotificationChannel>`__.
      For example, use
      `NotificationChannel.setImportance() <#android.app.NotificationChannel>`__
      instead of
      `NotificationCompat.Builder.setPriority() <#androidx.core.app.NotificationCompat.Builder>`__
      for Android 8.0 and higher.

   .. rubric:: Android 13.0, API level 33
      :name: android_130_api_level_33
      :class: hide-from-toc

   -  Adds `runtime permission <#>`__. For
      your app to send
      `non-exempt <#exemptions>`__
      notifications, the user must grant this permission to your app.

   .. rubric:: Android 14.0, API level 34
      :name: android_140_api_level_34
      :class: hide-from-toc

   -  Limits full-screen intent notifications to apps that provide calls and
      alarms. Use the
      `NotificationManager.canUseFullScreenIntent <#android.app.NotificationManager>`__
      API to check if your app has permission. If not, your app can use
      `ACTION_MANAGE_APP_USE_FULL_SCREEN_INTENT <#android.provider.Settings>`__
      to launch the settings page where users can grant the permission.

   -  Changes the way users experience non-dismissable notifications by allowing
      users to dismiss notifications action even when the
      `Notification.FLAG_ONGOING_EVENT <#android.app.Notification>`__
      flag is set. This doesn't apply to ``CallStyle`` notifications if the
      ``Notification.FLAG_ONGOING_EVENT`` flag is set or Device policy
      controller (DPC) and supporting packages for enterprise. This also does
      not apply when the phone is locked, or if the user selects **Clear all**.


Last updated 2024-05-03 UTC.

.. |image-notification-area_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-area_2x.png
   :width: 350px
.. |image-notification-drawer_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-drawer_2x.png
   :width: 350px
.. |image-heads-up_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/heads-up_2x.png
   :width: 350px
.. |image-lock-screen_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/lock-screen_2x.png
   :width: 350px
.. |image-badges-open_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/badges-open_2x.png
   :width: 350px
.. |image-wear_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/wear_2x.png
   :width: 600px
.. |image-notification-callouts_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-callouts_2x.png
   :width: 431px
.. |image-notification-actions_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-actions_2x.png
   :width: 384px
.. |image-notification-expanded_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-expanded_2x.png
   :width: 386px
.. |image-notification-group_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-group_2x.png
   :name: fig-bundles
   :width: 386px
.. |image-channel-settings_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/channel-settings_2x.png
   :width: 630px
.. |image-channel-alert-levels_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/channel-alert-levels_2x.png
   :name: figureChannelImportance
   :width: 300px
.. |image-do-not-disturb-filter-settings_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/do-not-disturb-filter-settings_2x.png
   :name: figureDoNotDisturbFilterSettings
   :width: 630px


/Request permission
===================

.. https://developer.android.google.cn/develop/ui/views/notifications/notification-permission?hl=en

.. container:: devsite-article-body

   Android 13 (API level 33) and higher supports a `runtime permission <#runtime>`__ for sending
   `non-exempt <#exemptions>`__ (including Foreground Services (FGS))
   notifications from an app:
   `POST_NOTIFICATIONS <#android.Manifest.permission>`__.
   This change helps users focus on the notifications that are most important to
   them.

   We highly recommend that you target Android 13 or higher as soon as possible
   to benefit from the additional control and flexibility of this feature. If
   you continue to target 12L (API level 32) or lower, you lose some flexibility
   with `requesting the permission in the context of your app's functionality <#request-in-context>`__.

   **Note:**\  Apps don't need to request the ``POST_NOTIFICATIONS`` permission
   in order to launch a foreground service. However, apps must include a
   notification when they start a foreground service, just as they do on
   previous versions of Android.

   .. rubric:: Declare the permission
      :name: declare

   To request the new notification permission from your app, update your app to
   target Android 13 and complete a similar process compared to `requesting other runtime permissions <#>`__, as shown in
   the following sections.

   The permission that you need to `declare in your app's manifest file <#>`__ appears in the following code
   snippet:

   .. code:: prettyprint

      <manifest ...>
          <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
          <application ...>
              ...
          </application>
      </manifest>

   .. rubric:: App capabilities depend on user choice in permissions dialog
      :name: user-choice

   In this dialog, users have the following actions available to them:

   -  `Select allow <#user-select-allow>`__
   -  `Select don't allow <#user-select-dont-allow>`__
   -  `Swipe away from the dialog <#user-swipe-away>`__, without pressing either
      button

   The following sections describe how your app behaves, based on which action
   the user takes.

   .. rubric:: User selects "Allow"
      :name: user-select-allow

   If the user selects the **allow** option, your app can do the following:

   -  Send notifications. All `notification channels <#>`__ are allowed.
   -  Post `notifications related to foreground services <#foreground-service>`__. These
      notifications appear in the `notification drawer <#bar-and-drawer>`__.

   .. rubric:: User selects "Don't allow"
      :name: user-select-dont-allow

   If the user selects the **don't allow** option, your app can't send
   notifications unless it qualifies for an `exemption <#exemptions>`__. All
   notification channels are blocked, except for a few specific roles. This is
   similar to the behavior that occurs when the user manually turns off all
   notifications for your app in system settings.

   .. caution::

      **Caution:** If your app targets 12L or lower and the user taps **Don't
      allow**, even just once, they aren't prompted again until one of the
      following occurs:

      -  The user uninstalls and reinstalls your app.
      -  You update your app to target Android 13 or higher.

   .. rubric:: User swipes away from dialog
      :name: user-swipe-away

   If the user swipes away from the dialog—that is, they don't select either
   **allow** or **don't allow**—the state of the notification permission doesn't
   change.

   .. rubric:: Effects on newly-installed apps
      :name: new-apps

   If a user installs your app on a device that runs Android 13 or higher, your
   app's **notifications are off by default**. Your app must wait to send
   notifications until after you request the new permission and the user grants
   that permission to your app.

   The time at which the permissions dialog appears is based on your app's
   target SDK version:

   -  If your app targets Android 13 or higher, your app has complete control
      over when the permission dialog is displayed. Use this opportunity to
      explain to users why the app needs this permission, encouraging them to
      grant it.
   -  If your app targets 12L (API level 32) or lower, the system shows the
      permission dialog the first time your app starts an activity after you
      create a `notification channel <#>`__, or
      when your app starts an activity and then creates its first notification
      channel. This is usually on app startup.

   .. rubric:: Effects on updates to existing apps
      :name: existing-apps

   To minimize disruptions associated with the notification permission, the
   system automatically pre-grants the permission to all `eligible apps <#eligibility>`__ when the user upgrades their device to Android 13 or
   higher. In other words, these apps can continue to send notifications to
   users, and users don't see a runtime permission prompt.

   **Note:**\  Consider the case where an eligible app was installed on a device
   running 12L or lower that the user is discarding, and the user allowed
   notifications on that old device. The user now has a new device that runs
   Android 13 or higher and restores the app using the `backup and restore <https://support.google.com/android/answer/2819582>`__ feature.
   In this situation, the system considers your app to be an "existing app," so
   the system automatically grants the permission to your app so that your app
   can continue to send notifications.

   .. rubric:: Eligibility for permission pre-grant
      :name: eligibility

   For your app to be *eligible* for an automatic pre-grant, it must have an
   existing notification channel and not have its notifications explicitly
   disabled by the user on a device that runs 12L or lower.

   If the user disabled notifications for your app on a device that runs 12L or
   lower, that denial persists when the device upgrades to Android 13 or higher.

   .. rubric:: Exemptions
      :name: exemptions

   This section contains the set of notifications and apps that are exempt from
   the notification permission behavior change. On Android 13 (API level 33) or
   higher, if the user denies the notification permission, they still see
   notices related to foreground services in the `Task Manager <#handle-user-initiated-stop>`__
   but don't see them in the `notification drawer <#bar-and-drawer>`__.

   .. rubric:: Media sessions
      :name: exemptions-media-sessions

   Notifications related to `media sessions <#>`__ are exempt from this
   behavior change.

   .. rubric:: Apps configured to self-manage phone calls
      :name: exemptions-self-manage-phone-calls

   If your app configures itself to self-manage phone calls, you don't need the
   ``POST_NOTIFICATIONS`` permission in order for your app to send notifications
   that use the
   `Notification.CallStyle <#android.app.Notification.CallStyle>`__
   notification style.

   The system considers your app to have configured itself for self-managing
   phone calls if it does each of the following:

   #. Declares the
      `MANAGE_OWN_CALLS <#android.Manifest.permission>`__
      permission.
   #. Implements the
      `ConnectionService <#android.telecom.ConnectionService>`__
      interface.
   #. Registers with the device's telecom provider by calling
      `registerPhoneAccount() <#android.telecom.TelecomManager>`__.

   .. rubric:: Test your app
      :name: test

   You can evaluate how the notification permission affects your app when it's
   first used on a device that runs Android 13 or higher. The following sets of
   `Android Debug Bridge (ADB) <#>`__ commands allow you
   to simulate the most common sequences of user choices and device upgrades
   without needing to reset your test device:

   -  App is newly installed on a device that runs Android 13 or higher:

      .. code:: none

         adb shell pm revoke PACKAGE_NAME android.permission.POST_NOTIFICATIONS
         adb shell pm clear-permission-flags PACKAGE_NAME \
           android.permission.POST_NOTIFICATIONS user-set
         adb shell pm clear-permission-flags PACKAGE_NAME \
           android.permission.POST_NOTIFICATIONS user-fixed

   -  The user keeps notifications enabled when the app is installed on a device
      that runs 12L or lower, then the device upgrades to Android 13 or higher:

      .. code:: none

         adb shell pm grant PACKAGE_NAME android.permission.POST_NOTIFICATIONS
         adb shell pm set-permission-flags PACKAGE_NAME \
           android.permission.POST_NOTIFICATIONS user-set
         adb shell pm clear-permission-flags PACKAGE_NAME \
           android.permission.POST_NOTIFICATIONS user-fixed

   -  The user manually disables notifications when the app is installed on a
      device that runs 12L or lower, then the device upgrades to Android 13 or
      higher:

      .. code:: none

         adb shell pm revoke PACKAGE_NAME android.permission.POST_NOTIFICATIONS
         adb shell pm set-permission-flags PACKAGE_NAME \
           android.permission.POST_NOTIFICATIONS user-set
         adb shell pm clear-permission-flags PACKAGE_NAME \
           android.permission.POST_NOTIFICATIONS user-fixed

   .. rubric:: Best practices
      :name: best-practices

   This section describes several ways that you can use the new notification
   permission most effectively in your app.

   .. rubric:: Update your app's target SDK version
      :name: update-target-sdk-version

   To give your app more flexibility over when the permission dialog appears,
   update your app so that it targets Android 13 or higher.

   .. rubric:: Wait to show notification permission prompt
      :name: wait-to-show-prompt

   Before you ask users to grant any permissions, let them familiarize
   themselves with your app.

   New users may want to explore the app and realize first-hand the benefits of
   each individual notification request. You can `trigger a permissions prompt <#request-permission>`__ from a user
   action. The following list shows several examples of when it's a good time to
   show the notification permission prompt:

   -  The user taps an "alert bell" button.
   -  The user chooses to follow someone's social media account.
   -  The user submits an order for food delivery.

   Figure 1 shows a recommended workflow for requesting the notification
   permission. Unless
   `shouldShowRequestPermissionRationale() <#androidx.core.app.ActivityCompat>`__
   returns ``true``, your app doesn't need to display the middle screen—the one
   that has the title text "Get notified!".

   Alternatively, you can set a request to appear after you give users a chance
   to familiarize themselves with your app. For example, you might wait until
   the third or fourth time the user launches your app.

   .. figure::
      https://developer.android.google.cn/static/images/permissions/notification-permission-a13-recommended-flow.svg
      :alt: After the user signs in, they're presented with an invitation to get
      notified of trip updates. After the user presses the I'm in button, the
      app requests the new permission, which causes the system dialog to appear
      :width: 100.0%

      **Figure 1.** A recommended user-driven workflow for requesting the
      notification permission. The middle screen is necessary only if
      ``shouldShowRequestPermissionRationale()`` returns ``true``.

   .. rubric:: Request the permission in context
      :name: request-in-context

   When you request notification permissions within your app, do so in the
   correct context, so that it's explicitly clear what the notifications are
   used for and why the user should opt in. For example, an email app might
   include options to send notifications for every new email, or only the emails
   where the user is the only recipient.

   Use this opportunity to give transparency to your intentions, and users are
   more likely to grant the notification permission to your app.

   .. rubric:: Check whether your app can send notifications
      :name: check-app-can-send

   Before your app sends a notification, confirm whether the user has enabled
   notifications for your app. To do so, call
   `areNotificationsEnabled() <#android.app.NotificationManager>`__.

   .. rubric:: Use the permission responsibly
      :name: use-responsibly

   After you receive approval to send notifications, remember to use the
   permission responsibly. Users can see the number of daily notifications that
   your app sends, and `they can revoke the permission <#handle-denial>`__ at any time.


Last updated 2024-05-03 UTC.


/Create and manage notification channels
========================================

.. https://developer.android.google.cn/develop/ui/views/notifications/channels?hl=en

.. container:: devsite-article-body

   Starting in Android 8.0 (API level 26), all notifications must be assigned to
   a channel. For each channel, you can set the visual and auditory behavior
   that is applied to all notifications in that channel. Users can change these
   settings and decide which notification channels from your app can be
   intrusive or visible.

   Check out the following video for an overview of channels and other
   notification features in Android 8.0.

   .. container:: video-wrapper-left

   The user settings for notification channels are available for each app in the
   system settings, as shown in figure 1.

   |image-channel-settings_2x|

   **Figure 1.** Notification settings for the Clock app and one of its
   channels.

   **Note:**\  The user interface refers to notification channels as
   "categories."
   After you create a notification channel, you can't change the notification
   behaviors. The user has complete control at that point. However, you can
   still change a channel's name and description.

   Create a channel for each type of notification you need to send. You can also
   create notification channels to reflect choices made by users. For example,
   you can set up separate notification channels for each conversation group
   created by a user in a messaging app.

   **Caution:**\  If you target Android 8.0 (API level 26) or higher and post a
   notification without specifying a notification channel, the notification
   doesn't appear and the system logs an error.
   When you target Android 8.0 (API level 26) or higher, you must implement one
   or more notification channels. If your ``targetSdkVersion`` is set to 25 or
   lower, when your app runs on Android 8.0 (API level 26) or higher, it behaves
   the same as on devices running Android 7.1 (API level 25) or lower.

   **Note:**\  As of Android 8.0 (API level 26), you can turn on a setting on
   your development device to display an on-screen warning that appears as a
   `toast <#>`__ when an app targeting Android
   8.0 (API level 26) or higher attempts to post without a notification channel.
   To turn on the setting for a development device running Android 8.0 (API
   level 26) or higher, navigate to **Settings** > **Developer options** and
   enable **Show notification channel warnings**.

   .. rubric:: Create a notification channel
      :name: CreateChannel

   To create a notification channel, follow these steps:

   #. Construct a
      `NotificationChannel <#android.app.NotificationChannel>`__
      object with a unique channel ID, user-visible name, and importance level.

   #. Optionally, specify the description that the user sees in the system
      settings with
      `setDescription() <#android.app.NotificationChannel>`__.

   #. Register the notification channel by passing it to
      `createNotificationChannel() <#android.app.NotificationManager>`__.

   **Caution:**\  Guard this code with a condition on the
   `SDK_INT <#android.os.Build.VERSION>`__ version to run
   only on Android 8.0 (API level 26) and higher, because the notification
   channels APIs aren't available in the Support Library.
   The following example shows how to create and register a notification
   channel:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                   // Create the NotificationChannel.
                   val name = getString(R.string.channel_name)
                   val descriptionText = getString(R.string.channel_description)
                   val importance = NotificationManager.IMPORTANCE_DEFAULT
                   val mChannel = NotificationChannel(CHANNEL_ID, name, importance)
                   mChannel.description = descriptionText
                   // Register the channel with the system. You can't change the importance
                   // or other notification behaviors after this.
                   val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
                   notificationManager.createNotificationChannel(mChannel)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private void createNotificationChannel() {
                   // Create the NotificationChannel, but only on API 26+ because
                   // the NotificationChannel class is not in the Support Library.
                   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                       CharSequence name = getString(R.string.channel_name);
                       String description = getString(R.string.channel_description);
                       int importance = NotificationManager.IMPORTANCE_DEFAULT;
                       NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);
                       channel.setDescription(description);
                       // Register the channel with the system. You can't change the importance
                       // or other notification behaviors after this.
                       NotificationManager notificationManager = getSystemService(NotificationManager.class);
                       notificationManager.createNotificationChannel(channel);
                   }
               }

   Recreating an existing notification channel with its original values performs
   no operation, so it's safe to call this code when starting an app.

   By default, all notifications posted to a given channel use the visual and
   auditory behaviors defined by the importance level from the
   `NotificationManagerCompat <#androidx.core.app.NotificationManagerCompat>`__
   class, such as
   `IMPORTANCE_DEFAULT <#androidx.core.app.NotificationManagerCompat>`__
   or
   `IMPORTANCE_HIGH <#androidx.core.app.NotificationManagerCompat>`__.
   See the next section for more information about `importance levels <#importance>`__.

   If you want to further customize your channel's default notification
   behaviors, you can call methods such as
   `enableLights() <#android.app.NotificationChannel>`__,
   `setLightColor() <#android.app.NotificationChannel>`__,
   and
   `setVibrationPattern() <#android.app.NotificationChannel>`__
   on the ``NotificationChannel``. Remember that once you create the channel,
   you can't change these settings, and the user has final control over whether
   these behaviors are active.

   You can also create multiple notification channels in a single operation by
   calling
   `createNotificationChannels() <#android.app.NotificationManager>`__.

   **Note:**\  In addition to adding each notification to your app-specific
   channels, consider adding each notification to one of the `system-wide categories <#system-category>`__,
   such as
   `CATEGORY_ALARM <#androidx.core.app.NotificationCompat>`__
   or
   `CATEGORY_REMINDER <#androidx.core.app.NotificationCompat>`__.

   .. rubric:: Set the importance level
      :name: importance

   Channel importance affects the interruption level of all notifications posted
   in the channel. Specify it in the ``NotificationChannel`` constructor, using
   one of five importance levels, ranging from
   `IMPORTANCE_NONE(0) <#android.app.NotificationManager>`__
   to
   `IMPORTANCE_HIGH(4) <#android.app.NotificationManager>`__.

   To support devices running Android 7.1 (API level 25) or lower, you must also
   call
   `setPriority() <#androidx.core.app.NotificationCompat.Builder>`__
   for each notification, using a priority constant from the
   `NotificationCompat <#androidx.core.app.NotificationCompat>`__
   class.

   The importance (``NotificationManager.IMPORTANCE_*``) and priority
   (``NotificationCompat.PRIORITY_*``) constants map to the user-visible
   importance options, as shown in the following table.

   .. list-table::
      :widths: 27 27 27
      :header-rows: 1

      - 

         - User-visible importance level
         - Importance (Android 8.0 and higher)
         - Priority (Android 7.1 and lower)
      - 

         - **Urgent**
            Makes a sound and appears as a heads-up notification.
         - `IMPORTANCE_HIGH <#android.app.NotificationManager>`__
         - `PRIORITY_HIGH <#androidx.core.app.NotificationCompat>`__
            or
            `PRIORITY_MAX <#androidx.core.app.NotificationCompat>`__
      - 

         - **High**
            Makes a sound.
         - `IMPORTANCE_DEFAULT <#android.app.NotificationManager>`__
         - `PRIORITY_DEFAULT <#androidx.core.app.NotificationCompat>`__
      - 

         - **Medium**
            Makes no sound.
         - `IMPORTANCE_LOW <#android.app.NotificationManager>`__
         - `PRIORITY_LOW <#androidx.core.app.NotificationCompat>`__
      - 

         - **Low**
            Makes no sound and doesn't appear in the status bar.
         - `IMPORTANCE_MIN <#android.app.NotificationManager>`__
         - `PRIORITY_MIN <#androidx.core.app.NotificationCompat>`__
      - 

         - **None**
            Makes no sound and doesn't appear in the status bar or shade.
         - `IMPORTANCE_NONE <#android.app.NotificationManager>`__
         - ``N/A``

   All notifications, regardless of importance, appear in non-interruptive
   system UI locations, such as in the notification drawer and as `a badge on the launcher icon <#icon-badge>`__, though you
   can `modify the appearance of the notification badge <#>`__.

   Once you submit the channel to the
   `NotificationManager <#android.app.NotificationManager>`__, you
   can't change the importance level. However, the user can change their
   preferences for your app's channels at any time.

   For information about choosing an appropriate priority level, see "Priority
   levels" in the `Notifications design guide <https://material.io/design/platform-guidance/android-notifications.html#settings>`__.

   .. rubric:: Read notification channel settings
      :name: ReadChannel

   Users can modify the settings for notification channels, including behaviors
   such as vibration and alert sound. If you want to know the settings a user
   applies to your notification channels, follow these steps:

   #. Get the ``NotificationChannel`` object by calling
      `getNotificationChannel() <#android.app.NotificationManager>`__
      or
      `getNotificationChannels() <#android.app.NotificationManager>`__.

   #. Query specific channel settings such as
      `getVibrationPattern() <#android.app.NotificationChannel>`__,
      `getSound() <#android.app.NotificationChannel>`__,
      and
      `getImportance() <#android.app.NotificationChannel>`__.

   If you detect a channel setting that you believe inhibits the intended
   behavior for your app, you can suggest that the user change it and provide an
   action to open the channel settings, as shown in the next section.

   .. rubric:: Open the notification channel settings
      :name: UpdateChannel

   After you create a notification channel, you can't change the notification
   channel's visual and auditory behaviors programmatically. Only the user can
   change the channel behaviors from the system settings. To provide your users
   easy access to these notification settings, add an item in your app's
   `settings UI <#>`__ that opens these system settings.

   You can open the system settings for notification channels with an
   `Intent <#android.content.Intent>`__ that uses the
   `ACTION_CHANNEL_NOTIFICATION_SETTINGS <#android.provider.Settings>`__
   action.

   For example, the following sample code shows how you can redirect a user to
   the settings for a notification channel:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS).apply {
                   putExtra(Settings.EXTRA_APP_PACKAGE, packageName)
                   putExtra(Settings.EXTRA_CHANNEL_ID, myNotificationChannel.getId())
               }
               startActivity(intent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);
               intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());
               intent.putExtra(Settings.EXTRA_CHANNEL_ID, myNotificationChannel.getId());
               startActivity(intent);

   Notice that the intent requires two extras that specify your app's package
   name (also known as the application ID) and the channel to edit.

   .. rubric:: Delete a notification channel
      :name: DeleteChannel

   You can delete notification channels by calling
   `deleteNotificationChannel() <#android.app.NotificationManager>`__.
   The following sample code demonstrates how to complete this process:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The id of the channel.
               val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
               val id: String = "my_channel_01"
               notificationManager.deleteNotificationChannel(id)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NotificationManager notificationManager =
                       (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
               // The id of the channel.
               String id = "my_channel_01";
               notificationManager.deleteNotificationChannel(id);

   **Note:**\  The notification settings screen displays the number of deleted
   channels, as a spam prevention mechanism. You can clear test channels on
   development devices by reinstalling the app or clearing the data associated
   with your copy of the app.

   .. rubric:: Create a notification channel group
      :name: CreateChannelGroup

   If want to further organize the appearance of your channels in the settings
   UI, you can create channel groups. This is a good idea when your app supports
   multiple user accounts, such as for `work profiles <#>`__, because it lets you create a
   notification channel group for each account. This way, users can easily
   identify and control multiple notification channels that have identical
   names.

   |image-channel-groups_2x|

   **Figure 2.** Notification channel settings with groups for personal and work
   accounts.

   For example, a social networking app might include support for personal and
   work accounts. In this scenario, each account might require multiple
   notification channels with identical functions and names, such as the
   following:

   -  A personal account with two channels:

      -  New comments

      -  Post recommendations

   -  A business account with two channels:

      -  New comments

      -  Post recommendations

   Organizing the notification channels into groups for each account lets users
   distinguish between them.

   Each notification channel group requires an ID, which must be unique within
   your package, as well as a user-visible name. The following snippet
   demonstrates how to create a notification channel group.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // The id of the group.
               val groupId = "my_group_01"
               // The user-visible name of the group.
               val groupName = getString(R.string.group_name)
               val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
               notificationManager.createNotificationChannelGroup(NotificationChannelGroup(groupId, groupName))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // The id of the group.
               String groupId = "my_group_01";
               // The user-visible name of the group.
               CharSequence groupName = getString(R.string.group_name);
               NotificationManager notificationManager =
                       (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
               notificationManager.createNotificationChannelGroup(new NotificationChannelGroup(groupId, groupName));

   After you create a new group, you can call
   `setGroup() <#android.app.NotificationChannel>`__
   to associate a new ``NotificationChannel`` object with the group.

   Once you submit the channel to the notification manager, you can't change the
   association between notification channel and group.


Last updated 2024-02-22 UTC.

.. |image-channel-settings_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/channel-settings_2x.png
   :width: 630px
.. |image-channel-groups_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/channel-groups_2x.png
   :width: 298px


/Basic notifications
====================

.. https://developer.android.google.cn/develop/ui/views/notifications/build-notification?hl=en

.. container:: devsite-article-body

   Notifications provide short, timely information about events in your app
   while it isn't in use. This document shows you how to create a notification
   with various features. For an introduction to how notifications appear on
   Android, see the `Notifications overview <#>`__. For sample code that
   uses notifications, see the `People sample <https://github.com/android/user-interface-samples/tree/main/People>`__
   on GitHub.

   The code in this page uses the
   `NotificationCompat <#androidx.core.app.NotificationCompat>`__
   APIs from the AndroidX Library. These APIs let you add features available
   only on newer versions of Android while still providing compatibility back to
   Android 9 (API level 28). However, some features, such as the inline reply
   action, result in a no-op on earlier versions.

   .. rubric:: Add the AndroidX Core Library
      :name: add-support-library

   Although most projects created with Android Studio include the necessary
   dependencies to use ``NotificationCompat``, verify that your module-level
   ``build.gradle`` file includes the following dependency:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.core:core:2.2.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.core:core-ktx:2.2.0")
               }

   **Note:**\  Other libraries in the ``androidx`` group also include ``core``
   as a transitive dependency. If you're already using other Jetpack APIs, you
   might have access to ``NotificationCompat`` without requiring this exact
   dependency.

   .. rubric:: Create a basic notification
      :name: simple-notification

   A notification in its most basic and compact form—also known as *collapsed
   form*—displays an icon, a title, and a small amount of text content. This
   section shows how to create a notification that the user can tap to launch an
   activity in your app.

   |image-notification-basic_2x|

   **Figure 1.** A notification with an icon, a title, and some text.

   For more details about each part of a notification, read about `notification anatomy <#Templates>`__.

   .. rubric:: Declare the runtime permission
      :name: permission

   Android 13 (API level 33) and higher supports a runtime permission for
   posting non-exempt (including Foreground Services (FGS)) notifications from
   an app.

   The permission that you need to declare in your app's manifest file appears
   in the following code snippet:

   .. code:: prettyprint

      <manifest ...>
          <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
          <application ...>
              ...
          </application>
      </manifest>

   For more details about runtime permissions, see `Notification runtime permission <#>`__.

   .. rubric:: Set the notification content
      :name: builder

   To get started, set the notification's content and channel using a
   `NotificationCompat.Builder <#androidx.core.app.NotificationCompat.Builder>`__
   object. The following example shows how to create a notification with the
   following:

   -  A small icon, set by
      `setSmallIcon() <#androidx.core.app.NotificationCompat.Builder>`__.
      This is the only user-visible content that's required.

   -  A title, set by
      `setContentTitle() <#androidx.core.app.NotificationCompat.Builder>`__.

   -  The body text, set by
      `setContentText() <#androidx.core.app.NotificationCompat.Builder>`__.

   -  The notification priority, set by
      `setPriority() <#androidx.core.app.NotificationCompat.Builder>`__.
      The priority determines how intrusive the notification is on Android 7.1
      and earlier. For Android 8.0 and later, instead set the channel importance
      as shown in the next section.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var builder = NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle(textTitle)
                       .setContentText(textContent)
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle(textTitle)
                       .setContentText(textContent)
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT);

   The ``NotificationCompat.Builder`` constructor requires you to provide a
   channel ID. This is required for compatibility with Android 8.0 (API level
   26) and later, but is ignored by earlier versions.

   By default, the notification's text content is truncated to fit one line. You
   can show additional information by creating an expandable notification.

   |image-notification-expanded_2x|

   **Figure 2.** An expandable notification in its collapsed and expanded forms.

   If you want your notification to be longer, you can enable an expandable
   notification by adding a style template with
   `setStyle() <#androidx.core.app.NotificationCompat.Builder>`__.
   For example, the following code creates a larger text area:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var builder = NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Much longer text that cannot fit one line...")
                       .setStyle(NotificationCompat.BigTextStyle()
                               .bigText("Much longer text that cannot fit one line..."))
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Much longer text that cannot fit one line...")
                       .setStyle(new NotificationCompat.BigTextStyle()
                               .bigText("Much longer text that cannot fit one line..."))
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT);

   For more information about other large notification styles, including how to
   add an image and media playback controls, see `Create an expandable notification <#>`__.

   .. rubric:: Create a channel and set the importance
      :name: Priority

   Before you can deliver the notification on Android 8.0 and later, register
   your app's `notification channel <#>`__ with the
   system by passing an instance of
   `NotificationChannel <#android.app.NotificationChannel>`__ to
   `createNotificationChannel() <#android.app.NotificationManager>`__.
   The following code is blocked by a condition on the
   `SDK_INT <#android.os.Build.VERSION>`__ version:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun createNotificationChannel() {
                   // Create the NotificationChannel, but only on API 26+ because
                   // the NotificationChannel class is not in the Support Library.
                   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                       val name = getString(R.string.channel_name)
                       val descriptionText = getString(R.string.channel_description)
                       val importance = NotificationManager.IMPORTANCE_DEFAULT
                       val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {
                           description = descriptionText
                       }
                       // Register the channel with the system.
                       val notificationManager: NotificationManager =
                           getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                       notificationManager.createNotificationChannel(channel)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private void createNotificationChannel() {
                   // Create the NotificationChannel, but only on API 26+ because
                   // the NotificationChannel class is not in the Support Library.
                   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                       CharSequence name = getString(R.string.channel_name);
                       String description = getString(R.string.channel_description);
                       int importance = NotificationManager.IMPORTANCE_DEFAULT;
                       NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);
                       channel.setDescription(description);
                       // Register the channel with the system; you can't change the importance
                       // or other notification behaviors after this.
                       NotificationManager notificationManager = getSystemService(NotificationManager.class);
                       notificationManager.createNotificationChannel(channel);
                   }
               }

   Because you must create the notification channel before posting any
   notifications on Android 8.0 and later, execute this code as soon as your app
   starts. It's safe to call this repeatedly, because creating an existing
   notification channel performs no operation.

   The ``NotificationChannel`` constructor requires an ``importance``, using one
   of the constants from the
   `NotificationManager <#android.app.NotificationManager>`__
   class. This parameter determines how to interrupt the user for any
   notification that belongs to this channel. Set the *priority* with
   ``setPriority()`` to support Android 7.1 and earlier, as shown in the
   preceding example.

   Although you must set the notification importance or priority as shown in the
   following example, the system doesn't guarantee the alert behavior you get.
   In some cases, the system might change the importance level based on other
   factors, and the user can always redefine what the importance level is for a
   given channel.

   For more information about what the different levels mean, read about
   `notification importance levels <#importance>`__.

   .. rubric:: Set the notification's tap action
      :name: tap

   Every notification must respond to a tap, usually to open an activity in your
   app that corresponds to the notification. To do so, specify a content intent
   defined with a `PendingIntent <#android.app.PendingIntent>`__
   object and pass it to
   `setContentIntent() <#androidx.core.app.NotificationCompat.Builder>`__.

   The following snippet shows how to create a basic intent to open an activity
   when the user taps the notification:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create an explicit intent for an Activity in your app.
               val intent = Intent(this, AlertDetails::class.java).apply {
                   flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
               }
               val pendingIntent: PendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE)

               val builder = NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       // Set the intent that fires when the user taps the notification.
                       .setContentIntent(pendingIntent)
                       .setAutoCancel(true)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create an explicit intent for an Activity in your app.
               Intent intent = new Intent(this, AlertDetails.class);
               intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
               PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE);

               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       // Set the intent that fires when the user taps the notification.
                       .setContentIntent(pendingIntent)
                       .setAutoCancel(true);

   This code calls
   `setAutoCancel() <#androidx.core.app.NotificationCompat.Builder>`__,
   which automatically `removes the notification <#Removing>`__ when the user
   taps it.

   The `setFlags() <#android.content.Intent>`__
   method shown in the preceding example preserves the user's expected
   navigation experience after they open your app using the notification. You
   might want to use it depending on the type of activity you're starting, which
   can be one of the following:

   -  An activity that exists exclusively for responses to the notification.
      There's no reason the user navigates to this activity during normal app
      use, so the activity starts a new task instead of being added to your
      app's existing `task and back stack <#>`__. This is the
      type of intent created in the preceding sample.

   -  An activity that exists in your app's regular app flow. In this case,
      starting the activity creates a back stack so that the user's expectations
      for the `Back and Up buttons <#>`__ are
      preserved.

   For more about the different ways to configure your notification's intent,
   see `Start an Activity from a Notification <#>`__.

   .. rubric:: Show the notification
      :name: notify

   To make the notification appear, call
   `NotificationManagerCompat.notify() <#androidx.core.app.NotificationManagerCompat>`__,
   passing it a unique ID for the notification and the result of
   `NotificationCompat.Builder.build() <#androidx.core.app.NotificationCompat.Builder>`__.
   This is shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               with(NotificationManagerCompat.from(this)) {
                   if (ActivityCompat.checkSelfPermission(
                           this@MainActivity,
                           Manifest.permission.POST_NOTIFICATIONS
                       ) != PackageManager.PERMISSION_GRANTED
                   ) {
                       // TODO: Consider calling
                       // ActivityCompat#requestPermissions
                       // here to request the missing permissions, and then overriding
                       // public fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>,
                       //                                        grantResults: IntArray)
                       // to handle the case where the user grants the permission. See the documentation
                       // for ActivityCompat#requestPermissions for more details.

                       return@with
                   }
                   // notificationId is a unique int for each notification that you must define.
                   notify(NOTIFICATION_ID, builder.build())
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               with(NotificationManagerCompat.from(this)) {
                  if (ActivityCompat.checkSelfPermission(
                          this@MainActivity,
                          Manifest.permission.POST_NOTIFICATIONS
                      ) != PackageManager.PERMISSION_GRANTED
                  ) {
                      // TODO: Consider calling
                      // ActivityCompat#requestPermissions
                      // here to request the missing permissions, and then overriding
                      // public void onRequestPermissionsResult(int requestCode, String[] permissions,
                      //                                        int[] grantResults)
                      // to handle the case where the user grants the permission. See the documentation
                      // for ActivityCompat#requestPermissions for more details.

                      return
                  }
                  // notificationId is a unique int for each notification that you must define.
                  notify(NOTIFICATION_ID, builder.build())
               }

   Save the notification ID that you pass to
   ``NotificationManagerCompat.notify()``, because you need it when you want to
   `update <#Updating>`__ or `remove the notification <#Removing>`__.

   Additionally, in order to test basic notifications on devices running on
   Android 13 and higher, turn on notifications manually or create a dialog to
   request notifications.

   **Note:**\  Beginning with Android 8.1 (API level 27), apps can't make a
   notification sound more than once per second. If your app posts multiple
   notifications in one second, they all appear as expected, but only the first
   notification per second makes a sound.

   .. rubric:: Add action buttons
      :name: Actions

   A notification can offer up to three action buttons that let the user respond
   quickly, such as to snooze a reminder or to reply to a text message. But
   these action buttons must not duplicate the action performed when the user
   `taps the notification <#tap>`__.

   |image-notification-basic-action_2x|

   **Figure 3.** A notification with one action button.

   To add an action button, pass a ``PendingIntent`` to the
   `addAction() <#androidx.core.app.NotificationCompat.Builder>`__
   method. This is like setting up the notification's default tap action, except
   instead of launching an activity, you can do other things such as start a
   `BroadcastReceiver <#android.content.BroadcastReceiver>`__ that
   performs a job in the background so that the action doesn't interrupt the app
   that's already open.

   For example, the following code shows how to send a broadcast to a specific
   receiver:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val ACTION_SNOOZE = "snooze"

               val snoozeIntent = Intent(this, MyBroadcastReceiver::class.java).apply {
                   action = ACTION_SNOOZE
                   putExtra(EXTRA_NOTIFICATION_ID, 0)
               }
               val snoozePendingIntent: PendingIntent =
                   PendingIntent.getBroadcast(this, 0, snoozeIntent, 0)
               val builder = NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       .setContentIntent(pendingIntent)
                       .addAction(R.drawable.ic_snooze, getString(R.string.snooze),
                               snoozePendingIntent)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               String ACTION_SNOOZE = "snooze"

               Intent snoozeIntent = new Intent(this, MyBroadcastReceiver.class);
               snoozeIntent.setAction(ACTION_SNOOZE);
               snoozeIntent.putExtra(EXTRA_NOTIFICATION_ID, 0);
               PendingIntent snoozePendingIntent =
                       PendingIntent.getBroadcast(this, 0, snoozeIntent, 0);

               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       .setContentIntent(pendingIntent)
                       .addAction(R.drawable.ic_snooze, getString(R.string.snooze),
                               snoozePendingIntent);

   For more information about building a ``BroadcastReceiver`` to run background
   work, see the `Broadcasts overview <#>`__.

   If you're instead trying to build a notification with media playback buttons,
   such as to pause and skip tracks, see how to `create a notification with media controls <#media-style>`__.

   **Note:**\  In Android 10 (API level 29) and later, the platform
   automatically generates notification action buttons if an app doesn't provide
   its own. If you don't want your app's notifications to display any suggested
   replies or actions, you can opt-out of system-generated replies and actions
   by using
   `setAllowGeneratedReplies() <#android.app.Notification.Action.Builder>`__
   and
   `setAllowSystemGeneratedContextualActions() <#android.app.Notification.Builder>`__.

   .. rubric:: Add a direct reply action
      :name: reply-action

   The direct reply action, introduced in Android 7.0 (API level 24), lets users
   enter text directly into the notification. The text is then delivered to your
   app without opening an activity. For example, you can use a direct reply
   action to let users reply to text messages or update task lists from within
   the notification.

   |image-reply-button_2x|

   **Figure 4.** Tapping the "Reply" button opens the text input.

   The direct reply action appears as an additional button in the notification
   that opens a text input. When the user finishes typing, the system attaches
   the text response to the intent you specify for the notification action and
   sends the intent to your app.

   .. rubric:: Add the reply button
      :name: add-reply-action

   To create a notification action that supports direct reply, follow these
   steps:

   #. Create an instance of
      `RemoteInput.Builder <#androidx.core.app.RemoteInput.Builder>`__
      that you can add to your notification action. This class's constructor
      accepts a string that the system uses as the key for the text input. Your
      app later uses that key to retrieve the text of the input.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                    // Key for the string that's delivered in the action's intent.
                    private val KEY_TEXT_REPLY = "key_text_reply"
                    var replyLabel: String = resources.getString(R.string.reply_label)
                    var remoteInput: RemoteInput = RemoteInput.Builder(KEY_TEXT_REPLY).run {
                        setLabel(replyLabel)
                        build()
                    }
                    

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                    // Key for the string that's delivered in the action's intent.
                    private static final String KEY_TEXT_REPLY = "key_text_reply";

                    String replyLabel = getResources().getString(R.string.reply_label);
                    RemoteInput remoteInput = new RemoteInput.Builder(KEY_TEXT_REPLY)
                            .setLabel(replyLabel)
                            .build();
                    

   #. Create a ``PendingIntent`` for the reply action.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                    // Build a PendingIntent for the reply action to trigger.
                    var replyPendingIntent: PendingIntent =
                        PendingIntent.getBroadcast(applicationContext,
                            conversation.getConversationId(),
                            getMessageReplyIntent(conversation.getConversationId()),
                            PendingIntent.FLAG_UPDATE_CURRENT)
                    

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                    // Build a PendingIntent for the reply action to trigger.
                    PendingIntent replyPendingIntent =
                            PendingIntent.getBroadcast(getApplicationContext(),
                                    conversation.getConversationId(),
                                    getMessageReplyIntent(conversation.getConversationId()),
                                    PendingIntent.FLAG_UPDATE_CURRENT);
                    

      **Caution:** If you reuse a ``PendingIntent``, a user might reply to a
      different conversation than the one they intend. You must provide a
      request code that is different for each conversation or provide an intent
      that doesn't return ``true`` when you call
      `equals() <#android.app.PendingIntent>`__
      on the reply intent of any other conversation. The conversation ID is
      frequently passed as part of the intent's extras bundle, but is ignored
      when you call ``equals()``.
   #. Attach the `RemoteInput <#androidx.core.app.RemoteInput>`__
      object to an action using
      `addRemoteInput() <#androidx.core.app.NotificationCompat.Action.Builder>`__.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                    // Create the reply action and add the remote input.
                    var action: NotificationCompat.Action =
                        NotificationCompat.Action.Builder(R.drawable.ic_reply_icon,
                            getString(R.string.label), replyPendingIntent)
                            .addRemoteInput(remoteInput)
                            .build()
                    

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                    // Create the reply action and add the remote input.
                    NotificationCompat.Action action =
                            new NotificationCompat.Action.Builder(R.drawable.ic_reply_icon,
                                    getString(R.string.label), replyPendingIntent)
                                    .addRemoteInput(remoteInput)
                                    .build();
                    

   #. Apply the action to a notification and issue the notification.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                    // Build the notification and add the action.
                    val newMessageNotification = Notification.Builder(context, CHANNEL_ID)
                            .setSmallIcon(R.drawable.ic_message)
                            .setContentTitle(getString(R.string.title))
                            .setContentText(getString(R.string.content))
                            .addAction(action)
                            .build()

                    // Issue the notification.
                    with(NotificationManagerCompat.from(this)) {
                        notificationManager.notify(notificationId, newMessageNotification)
                    }
                    

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                    // Build the notification and add the action.
                    Notification newMessageNotification = new Notification.Builder(context, CHANNEL_ID)
                            .setSmallIcon(R.drawable.ic_message)
                            .setContentTitle(getString(R.string.title))
                            .setContentText(getString(R.string.content))
                            .addAction(action)
                            .build();

                    // Issue the notification.
                    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
                    notificationManager.notify(notificationId, newMessageNotification);
                    

   The system prompts the user to input a response when they trigger the
   notification action, as shown in figure 4.

   .. rubric:: Retrieve user input from the reply
      :name: retrieve-user-reply

   To receive user input from the notification's reply UI, call
   `RemoteInput.getResultsFromIntent() <#androidx.core.app.RemoteInput>`__,
   passing it the ``Intent`` received by your ``BroadcastReceiver``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun getMessageText(intent: Intent): CharSequence? {
                   return RemoteInput.getResultsFromIntent(intent)?.getCharSequence(KEY_TEXT_REPLY)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               private CharSequence getMessageText(Intent intent) {
                   Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);
                   if (remoteInput != null) {
                       return remoteInput.getCharSequence(KEY_TEXT_REPLY);
                   }
                   return null;
                }

   After you process the text, update the notification by calling
   ``NotificationManagerCompat.notify()`` with the same ID and tag, if used.
   This is necessary to hide the direct reply UI and confirm to the user that
   their reply is received and processed correctly.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Build a new notification, which informs the user that the system
               // handled their interaction with the previous notification.
               val repliedNotification = Notification.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.ic_message)
                       .setContentText(getString(R.string.replied))
                       .build()

               // Issue the new notification.
               NotificationManagerCompat.from(this).apply {
                   notificationManager.notify(notificationId, repliedNotification)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Build a new notification, which informs the user that the system
               // handled their interaction with the previous notification.
               Notification repliedNotification = new Notification.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.ic_message)
                       .setContentText(getString(R.string.replied))
                       .build();

               // Issue the new notification.
               NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
               notificationManager.notify(notificationId, repliedNotification);

   When working with this new notification, use the context that's passed to the
   receiver's
   `onReceive() <#android.content.BroadcastReceiver>`__
   method.

   Append the reply to the bottom of the notification by calling
   `setRemoteInputHistory() <#android.app.Notification.Builder>`__.
   However, if you're building a messaging app, create a `messaging-style notification <#message-style>`__ and append the
   new message to the conversation.

   For more advice for notifications from a messaging apps, see the section
   about `best practices for messaging apps <#messaging-best-practices>`__.

   .. rubric:: Add a progress bar
      :name: progressbar

   Notifications can include an animated progress indicator that shows users the
   status of an ongoing operation.

   |image-notification-progressbar_2x|

   **Figure 5.** The progress bar during an operation.

   If you can estimate how much of the operation is complete at any time, use
   the "determinate" form of the indicator—as shown in figure 5—by calling
   `setProgress(max, progress, false) <#androidx.core.app.NotificationCompat.Builder>`__.
   The first parameter is what the "complete" value is, such as 100. The second
   is how much is complete. The last indicates that this is a determinate
   progress bar.

   As your operation proceeds, continuously call
   ``setProgress(max, progress, false)`` with an updated value for ``progress``
   and reissue the notification, as shown in the following example.

   **Note:**\  Because the progress bar requires that your app continuously
   update the notification, make this code run in a `background service <#>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val builder = NotificationCompat.Builder(this, CHANNEL_ID).apply {
                   setContentTitle("Picture Download")
                   setContentText("Download in progress")
                   setSmallIcon(R.drawable.ic_notification)
                   setPriority(NotificationCompat.PRIORITY_LOW)
               }
               val PROGRESS_MAX = 100
               val PROGRESS_CURRENT = 0
               NotificationManagerCompat.from(this).apply {
                   // Issue the initial notification with zero progress.
                   builder.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false)
                   notify(notificationId, builder.build())

                   // Do the job that tracks the progress here.
                   // Usually, this is in a worker thread.
                   // To show progress, update PROGRESS_CURRENT and update the notification with:
                   // builder.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false);
                   // notificationManager.notify(notificationId, builder.build());

                   // When done, update the notification once more to remove the progress bar.
                   builder.setContentText("Download complete")
                           .setProgress(0, 0, false)
                   notify(notificationId, builder.build())
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ...
               NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID);
               builder.setContentTitle("Picture Download")
                       .setContentText("Download in progress")
                       .setSmallIcon(R.drawable.ic_notification)
                       .setPriority(NotificationCompat.PRIORITY_LOW);

               // Issue the initial notification with zero progress.
               int PROGRESS_MAX = 100;
               int PROGRESS_CURRENT = 0;
               builder.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false);
               notificationManager.notify(notificationId, builder.build());

               // Do the job that tracks the progress here.
               // Usually, this is in a worker thread.
               // To show progress, update PROGRESS_CURRENT and update the notification with:
               // builder.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false);
               // notificationManager.notify(notificationId, builder.build());

               // When done, update the notification once more to remove the progress bar.
               builder.setContentText("Download complete")
                       .setProgress(0,0,false);
               notificationManager.notify(notificationId, builder.build());

   At the end of the operation, ``progress`` must equal ``max``. You can leave
   the progress bar to show that the operation is done or remove it. In either
   case, update the notification text to show that the operation is complete. To
   remove the progress bar, call ``setProgress(0, 0, false)``.

   To display an indeterminate progress bar (a bar that doesn't indicate
   completion percentage), call ``setProgress(0, 0, true)``. The result is an
   indicator that has the same style as the preceding progress bar except that
   it is a continuous animation that doesn't indicate completion. The progress
   animation runs until you call ``setProgress(0, 0, false)`` and then update
   the notification to remove the activity indicator.

   Remember to change the notification text to indicate that the operation is
   complete.

   **Note:**\  If you need to download a file, consider using
   `DownloadManager <#android.app.DownloadManager>`__, which
   provides its own notification to track your download progress.

   .. rubric:: Set a system-wide category
      :name: system-category

   Android uses predefined system-wide categories to determine whether to
   disturb the user with a given notification when the user enables `Do Not Disturb mode <#dnd-mode>`__.

   If your notification falls into one of the notification categories defined in
   ``NotificationCompat``—such as
   `CATEGORY_ALARM <#androidx.core.app.NotificationCompat>`__,
   `CATEGORY_REMINDER <#androidx.core.app.NotificationCompat>`__,
   `CATEGORY_EVENT <#androidx.core.app.NotificationCompat>`__,
   or
   `CATEGORY_CALL <#androidx.core.app.NotificationCompat>`__—declare
   it as such by passing the appropriate category to
   `setCategory() <#androidx.core.app.NotificationCompat.Builder>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var builder = NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       .setCategory(NotificationCompat.CATEGORY_MESSAGE)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       .setCategory(NotificationCompat.CATEGORY_MESSAGE);

   The system uses this information about your notification category to make
   decisions about displaying your notification when the device is in Do Not
   Disturb. However, you aren't required to set a system-wide category. Only do
   so if your notifications match one of the categories defined by in
   ``NotificationCompat``.

   .. rubric:: Show an urgent message
      :name: urgent-message

   Your app might need to display an urgent, time-sensitive message, such as an
   incoming phone call or a ringing alarm. In these situations, you can
   associate a full-screen intent with your notification.

   **Caution:**\  Notifications containing full-screen intents are substantially
   intrusive, so it's important to only use this type of notification for the
   most urgent, time-sensitive messages.
   When the notification is invoked, users see one of the following, depending
   on the device's lock status:

   -  If the user's device is locked, a full-screen activity appears, covering
      the lockscreen.
   -  If the user's device is unlocked, the notification appears in an expanded
      form that includes options for handling or dismissing the notification.

   **Note:**\  If your app targets Android 10 (API level 29) or later, you must
   request the
   `USE_FULL_SCREEN_INTENT <#android.Manifest.permission>`__
   permission in your app's manifest file for the system to launch the
   full-screen activity associated with the time-sensitive notification.
   The following code snippet demonstrates how to associate your notification
   with a full-screen intent:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val fullScreenIntent = Intent(this, ImportantActivity::class.java)
               val fullScreenPendingIntent = PendingIntent.getActivity(this, 0,
                   fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT)

               var builder = NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       .setFullScreenIntent(fullScreenPendingIntent, true)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent fullScreenIntent = new Intent(this, ImportantActivity.class);
               PendingIntent fullScreenPendingIntent = PendingIntent.getActivity(this, 0,
                       fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT);

               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setContentTitle("My notification")
                       .setContentText("Hello World!")
                       .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                       .setFullScreenIntent(fullScreenPendingIntent, true);

   .. rubric:: Set lock screen visibility
      :name: lockscreenNotification

   To control the level of detail visible in the notification from the lock
   screen, call
   `setVisibility() <#androidx.core.app.NotificationCompat.Builder>`__
   and specify one of the following values:

   -  `VISIBILITY_PUBLIC <#androidx.core.app.NotificationCompat>`__:
      the notification's full content shows on the lock screen.

   -  `VISIBILITY_SECRET <#androidx.core.app.NotificationCompat>`__:
      no part of the notification shows on the lock screen.

   -  `VISIBILITY_PRIVATE <#androidx.core.app.NotificationCompat>`__:
      only basic information, such as the notification's icon and the content
      title, shows on the lock screen. The notification's full content doesn't
      show.

   When you set ``VISIBILITY_PRIVATE``, you can also provide an alternate
   version of the notification content that hides certain details. For example,
   an SMS app might display a notification that shows "You have 3 new text
   messages," but hides the message contents and senders. To provide this
   alternative notification, first create the alternative notification with
   ``NotificationCompat.Builder`` as usual. Then, attach the alternative
   notification to the normal notification with
   `setPublicVersion() <#androidx.core.app.NotificationCompat.Builder>`__.

   Bear in mind that the user always has ultimate control over whether their
   notifications are visible on the lock screen and can control them based on
   your app's notification channels.

   .. rubric:: Update a notification
      :name: Updating

   To update a notification after you issue it, call
   ``NotificationManagerCompat.notify()`` again, passing it the same ID you used
   before. If the previous notification is dismissed, a new notification is
   created instead.

   You can optionally call
   `setOnlyAlertOnce() <#androidx.core.app.NotificationCompat.Builder>`__
   so your notification interrupts the user—with sound, vibration, or visual
   clues—only the first time the notification appears and not for later updates.

   **Caution:**\  Android applies a rate limit when updating a notification. If
   you post updates to a notification too frequently—many in less than one
   second—the system might drop updates.

   .. rubric:: Remove a notification
      :name: Removing

   Notifications remain visible until one of the following happens:

   -  The user dismisses the notification.
   -  The user taps the notification, if you call ``setAutoCancel()`` when you
      create the notification.
   -  You call
      `cancel() <#android.app.NotificationManager>`__
      for a specific notification ID. This method also deletes ongoing
      notifications.
   -  You call
      `cancelAll() <#android.app.NotificationManager>`__,
      which removes all notifications you previously issued.
   -  The specified duration elapses, if you set a timeout when creating the
      notification, using
      `setTimeoutAfter() <#androidx.core.app.NotificationCompat.Builder>`__.
      If required, you can cancel a notification before the specified timeout
      duration elapses.

   .. rubric:: Best practices for messaging apps
      :name: messaging-best-practices

   Consider the best practices listed here when creating notifications for your
   messaging and chat apps.

   .. rubric:: Use MessagingStyle
      :name: messaging-style

   Starting in Android 7.0 (API level 24), Android provides a notification style
   template specifically for messaging content. Using the
   `NotificationCompat.MessagingStyle <#androidx.core.app.NotificationCompat.MessagingStyle>`__
   class, you can change several of the labels displayed on the notification,
   including the conversation title, additional messages, and the content view
   for the notification.

   The following code snippet demonstrates how to customize a notification's
   style using the ``MessagingStyle`` class.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val user = Person.Builder()
                   .setIcon(userIcon)
                   .setName(userName)
                   .build()

               val notification = NotificationCompat.Builder(this, CHANNEL_ID)
                   .setContentTitle("2 new messages with $sender")
                   .setContentText(subject)
                   .setSmallIcon(R.drawable.new_message)
                   .setStyle(NotificationCompat.MessagingStyle(user)
                       .addMessage(messages[1].getText(), messages[1].getTime(), messages[1].getPerson())
                       .addMessage(messages[2].getText(), messages[2].getTime(), messages[2].getPerson())
                   )
                   .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Person user = new Person.Builder()
                   .setIcon(userIcon)
                   .setName(userName)
                   .build();

               Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID)
                   .setContentTitle("2 new messages with " + sender)
                   .setContentText(subject)
                   .setSmallIcon(R.drawable.new_message)
                   .setStyle(new NotificationCompat.MessagingStyle(user)
                       .addMessage(messages[1].getText(), messages[1].getTime(), messages[1].getPerson())
                       .addMessage(messages[2].getText(), messages[2].getTime(), messages[2].getPerson())
                   )
                   .build();

   Starting in Android 9.0 (API level 28), It is also required to use the
   `Person <#>`__ class in order to get
   an optimal rendering of the notification and its avatars.

   When using ``NotificationCompat.MessagingStyle``, do the following:

   -  Call
      `MessagingStyle.setConversationTitle() <#androidx.core.app.NotificationCompat.MessagingStyle>`__
      to set a title for group chats with more than two people. A good
      conversation title might be the name of the group chat or, if it doesn't
      have a name, a list of the participants in the conversation. Without this,
      the message might be mistaken as belonging to a one-to-one conversation
      with the sender of the most recent message in the conversation.
   -  Use the
      `MessagingStyle.setData() <#androidx.core.app.NotificationCompat.MessagingStyle.Message>`__
      method to include media messages such as images. MIME types of the pattern
      image/\* are supported.

   .. rubric:: Use Direct Reply
      :name: direct-reply

   Direct Reply lets a user reply inline to a message.

   -  After a user replies with the inline reply action, use
      `MessagingStyle.addMessage() <#androidx.core.app.NotificationCompat.MessagingStyle>`__
      to update the ``MessagingStyle`` notification, and don't retract or cancel
      the notification. Not cancelling the notification lets the user send
      multiple replies from the notification.
   -  To make the inline reply action compatible with Wear OS, call
      `Action.WearableExtender.setHintDisplayInlineAction(true) <#androidx.core.app.NotificationCompat.Action.WearableExtender>`__.
   -  Use the
      `addHistoricMessage() <#android.app.Notification.MessagingStyle>`__
      method to provide context to a direct reply conversation by adding
      historic messages to the notification.

   .. rubric:: Enable Smart Reply
      :name: smart-reply

   -  To enable Smart Reply, call
      `setAllowGeneratedResponses(true) <#androidx.core.app.NotificationCompat.Action.Builder>`__
      on the reply action. This causes Smart Reply responses to be available to
      users when the notification is bridged to a Wear OS device. Smart Reply
      responses are generated by an entirely on-watch machine learning model
      using the context provided by the ``NotificationCompat.MessagingStyle``
      notification, and no data is uploaded to the internet to generate the
      responses.

   .. rubric:: Add notification metadata
      :name: metadata

   -  Assign notification metadata to tell the system how to handle your app
      notifications when the device is in
      `Do Not Disturb mode <#dnd-mode>`__.
      For example, use the
      `addPerson() <#androidx.core.app.NotificationCompat.Builder>`__
      or
      `setCategory(Notification.CATEGORY_MESSAGE) <#androidx.core.app.NotificationCompat.Builder>`__
      method to override the Do Not Disturb.


Last updated 2024-05-03 UTC.

.. |image-notification-basic_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-basic_2x.png
   :width: 350px
.. |image-notification-expanded_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-expanded_2x.png
   :width: 350px
.. |image-notification-basic-action_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-basic-action_2x.png
   :width: 350px
.. |image-reply-button_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/reply-button_2x.png
   :name: fig-user-input
   :width: 750px
.. |image-notification-progressbar_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-progressbar_2x.png
   :width: 350px


/Expandable notifications
=========================

.. https://developer.android.google.cn/develop/ui/views/notifications/expanded?hl=en

.. container:: devsite-article-body

   A basic notification usually includes a title, a line of text, and actions
   the user can perform in response. To provide more information, you can create
   large, expandable notifications by applying one of several notification
   templates as described in this document.

   To start, build a notification with all the basic content as described in
   `Create a notification <#>`__. Then,
   call
   `setStyle() <#androidx.core.app.NotificationCompat.Builder>`__
   with a style object and supply information corresponding to each template, as
   shown in the following examples.

   .. rubric:: Add a large image
      :name: image-style

   To add an image in your notification, pass an instance of
   `NotificationCompat.BigPictureStyle <#androidx.core.app.NotificationCompat.BigPictureStyle>`__
   to ``setStyle()``.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val notification = NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_post)
                       .setContentTitle(imageTitle)
                       .setContentText(imageDescription)
                       .setStyle(NotificationCompat.BigPictureStyle()
                               .bigPicture(myBitmap))
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_post)
                       .setContentTitle(imageTitle)
                       .setContentText(imageDescription)
                       .setStyle(new NotificationCompat.BigPictureStyle()
                              .bigPicture(myBitmap))
                       .build();

   To make the image appear as a thumbnail only while the notification is
   collapsed, as shown in the following figure, call
   `setLargeIcon() <#androidx.core.app.NotificationCompat.Builder>`__
   and pass it the image. Then, call
   `BigPictureStyle.bigLargeIcon() <#androidx.core.app.NotificationCompat.BigPictureStyle>`__
   and pass it ``null`` so the large icon goes away when the notification is
   expanded:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val notification = NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_post)
                       .setContentTitle(imageTitle)
                       .setContentText(imageDescription)
                       .setLargeIcon(myBitmap)
                       .setStyle(NotificationCompat.BigPictureStyle()
                               .bigPicture(myBitmap)
                               .bigLargeIcon(null))
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_post)
                       .setContentTitle(imageTitle)
                       .setContentText(imageDescription)
                       .setLargeIcon(myBitmap)
                       .setStyle(new NotificationCompat.BigPictureStyle()
                               .bigPicture(myBitmap)
                               .bigLargeIcon(null))
                       .build();

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/template-image_2x.png
      name: bigpicture-style
      :alt: An image showing a collapsed notification and an expanded
      notification containing a blue image
      :width: 50.0%

      **Figure 1.** A notification using ``NotificationCompat.BigPictureStyle``.

   .. rubric:: Add a large block of text
      :name: large-style

   Apply
   `NotificationCompat.BigTextStyle <#androidx.core.app.NotificationCompat.BigTextStyle>`__
   to display text in the expanded content area of the notification:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val notification = NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_mail)
                       .setContentTitle(emailObject.getSenderName())
                       .setContentText(emailObject.getSubject())
                       .setLargeIcon(emailObject.getSenderAvatar())
                       .setStyle(NotificationCompat.BigTextStyle()
                               .bigText(emailObject.getSubjectAndSnippet()))
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_mail)
                       .setContentTitle(emailObject.getSenderName())
                       .setContentText(emailObject.getSubject())
                       .setLargeIcon(emailObject.getSenderAvatar())
                       .setStyle(new NotificationCompat.BigTextStyle()
                               .bigText(emailObject.getSubjectAndSnippet()))
                       .build();

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/template-large-text_2x.png
      name: bigtext-style
      :alt: An image showing a collapsed notification and an expanded
      notification using BigTextStyle
      :width: 50.0%

      **Figure 2.** A notification using ``NotificationCompat.BigTextStyle``.

   **Tip:**\  To add formatting in your text—such as bold, italic, line breaks,
   and so on—you can `add styling with HTML markup <#StylingWithHTML>`__.

   .. rubric:: Create an inbox-style notification
      :name: inbox-style

   Apply
   `NotificationCompat.InboxStyle <#androidx.core.app.NotificationCompat.InboxStyle>`__
   to a notification if you want to add multiple short summary lines, such as
   snippets from incoming emails. This lets you add multiple pieces of content
   text that are each truncated to one line, instead of the one continuous line
   of text provided by ``NotificationCompat.BigTextStyle``.

   To add a new line, call
   `addLine() <#androidx.core.app.NotificationCompat.InboxStyle>`__
   up to six times, as shown in the following example. If you add more than six
   lines, only the first six are visible.

   **Tip:**\  You can distinguish the message's subject and message in each line
   by `adding styling with HTML markup <#StylingWithHTML>`__, such as
   bolding the subject.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val notification = NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.baseline_email_24)
                       .setContentTitle("5 New mails from Frank")
                       .setContentText("Check them out")
                       .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.logo))
                       .setStyle(
                               NotificationCompat.InboxStyle()
                               .addLine("Re: Planning")
                               .addLine("Delivery on its way")
                               .addLine("Follow-up")
                       )
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification notification = NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.baseline_email_24)
                       .setContentTitle("5 New mails from Frank")
                       .setContentText("Check them out")
                       .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.logo))
                       .setStyle(
                               NotificationCompat.InboxStyle()
                               .addLine("Re: Planning")
                               .addLine("Delivery on its way")
                               .addLine("Follow-up")
                       )
                       .build();

   The result looks like the following figure:

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/expanded_inbox_style_2.png
      name: inbox-style
      :alt: An image showing an expanded inbox-style notification
      :width: 50.0%

      **Figure 3.** An expanded inbox-style notification.

   **Note:**\  For more information about how to group multiple notifications,
   see `Create a group of notifications <#>`__.

   .. rubric:: Show a conversation in a notification
      :name: message-style

   Apply
   `NotificationCompat.MessagingStyle <#androidx.core.app.NotificationCompat.MessagingStyle>`__
   to display sequential messages between any number of people. This is ideal
   for messaging apps, because it provides a consistent layout for each message
   by handling the sender name and message text separately, and each message can
   be multiple lines long.

   To add a new message, call
   `addMessage() <#androidx.core.app.NotificationCompat.MessagingStyle>`__,
   passing the message text, the time received, and the sender's name. You can
   also pass this information as a
   `NotificationCompat.MessagingStyle.Message <#androidx.core.app.NotificationCompat.MessagingStyle.Message>`__
   object, as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val message1 = NotificationCompat.MessagingStyle.Message(
                       messages[0].getText(),
                       messages[0].getTime(),
                       messages[0].getSender())
               val message2 = NotificationCompat.MessagingStyle.Message(
                       messages[1].getText(),
                       messages[1].getTime(),
                       messages[1].getSender())
               val notification = NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_message)
                       .setStyle(
                               NotificationCompat.MessagingStyle(resources.getString(R.string.reply_name))
                               .addMessage(message1)
                               .addMessage(message2))
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NotificationCompat.MessagingStyle.Message message1 =
                       new NotificationCompat.MessagingStyle.Message(messages[0].getText(),
                                                                     messages[0].getTime(),
                                                                     messages[0].getSender());
               NotificationCompat.MessagingStyle.Message message2 =
                       new NotificationCompat.MessagingStyle.Message(messages[1].getText(),
                                                                     messages[1].getTime(),
                                                                     messages[1].getSender());

               Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_message)
                       .setStyle(new NotificationCompat.MessagingStyle(resources.getString(R.string.reply_name))
                               .addMessage(message1)
                               .addMessage(message2))
                       .build();

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/template-messaging_2x.png
      name: message-style
      :alt: An image showing a notification in messaging style
      :width: 50.0%

      **Figure 4.** A notification using ``NotificationCompat.MessagingStyle``.

   When using ``NotificationCompat.MessagingStyle``, any values given to
   `setContentTitle() <#androidx.core.app.NotificationCompat.Builder>`__
   and
   `setContentText() <#androidx.core.app.NotificationCompat.Builder>`__
   are ignored.

   You can call
   `setConversationTitle() <#androidx.core.app.NotificationCompat.MessagingStyle>`__
   to add a title that appears above the conversation. This might be the
   user-created name of the group or, if it doesn't have a specific name, a list
   of the participants in the conversation. Don't set a conversation title for
   one-on-one chats, because the system uses the existence of this field as a
   hint that the conversation is a group.

   This style applies only on devices running Android 7.0 (API level 24) and
   later. When using the compatibility library
   (`NotificationCompat <#androidx.core.app.NotificationCompat>`__),
   as demonstrated earlier, notifications with ``MessagingStyle`` fall back
   automatically to a supported expanded notification style.

   When building a notification like this for a chat conversation, `add a direct reply action <#reply-action>`__.

   .. rubric:: Create a notification with media controls
      :name: media-style

   **Note:**\  When using AndroidX Media3, the `media notification is created automatically <#publishing_a_notification>`__.
   Apply
   `MediaStyleNotificationHelper.MediaStyle <#androidx.media3.session.MediaStyleNotificationHelper.MediaStyle>`__
   to display media playback controls and track information.

   Specify your associated
   `MediaSession <#androidx.media3.session.MediaSession>`__ in the
   constructor. This allows Android to display the right information about your
   media.

   Call
   `addAction() <#androidx.core.app.NotificationCompat.Builder>`__
   up to five times to display up to five icon buttons. Call ``setLargeIcon()``
   to set the album artwork.

   Unlike the other notification styles, ``MediaStyle`` also lets you modify the
   collapsed-size content view by specifying three action buttons that also
   appear in the collapsed view. To do so, provide the action button indices to
   `setShowActionsInCompactView() <#androidx.media3.session.MediaStyleNotificationHelper.MediaStyle>`__.

   The following example shows how to create a notification with media controls:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val notification = NotificationCompat.Builder(context, CHANNEL_ID)
                       // Show controls on lock screen even when user hides sensitive content.
                       .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                       .setSmallIcon(R.drawable.ic_stat_player)
                       // Add media control buttons that invoke intents in your media service
                       .addAction(R.drawable.ic_prev, "Previous", prevPendingIntent) // #0
                       .addAction(R.drawable.ic_pause, "Pause", pausePendingIntent) // #1
                       .addAction(R.drawable.ic_next, "Next", nextPendingIntent) // #2
                       // Apply the media style template.
                       .setStyle(MediaStyleNotificationHelper.MediaStyle(mediaSession)
                               .setShowActionsInCompactView(1 /* #1: pause button \*/))
                       .setContentTitle("Wonderful music")
                       .setContentText("My Awesome Band")
                       .setLargeIcon(albumArtBitmap)
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
                       // Show controls on lock screen even when user hides sensitive content.
                       .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                       .setSmallIcon(R.drawable.ic_stat_player)
                       // Add media control buttons that invoke intents in your media service
                       .addAction(R.drawable.ic_prev, "Previous", prevPendingIntent) // #0
                       .addAction(R.drawable.ic_pause, "Pause", pausePendingIntent)  // #1
                       .addAction(R.drawable.ic_next, "Next", nextPendingIntent)     // #2
                       // Apply the media style template.
                       .setStyle(new MediaStyleNotificationHelper.MediaStyle(mediaSession)
                               .setShowActionsInCompactView(1 /* #1: pause button */))
                       .setContentTitle("Wonderful music")
                       .setContentText("My Awesome Band")
                       .setLargeIcon(albumArtBitmap)
                       .build();

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/template-media_2x.png
      name: media-style
      :alt: An image showing a notification with media style
      :width: 50.0%

      **Figure 5.** A notification using
      ``MediaStyleNotificationHelper.MediaStyle``.

   **Note:**\  Notifications created with
   ``MediaStyleNotificationHelper.MediaStyle`` have their category set to
   `CATEGORY_TRANSPORT <#androidx.core.app.NotificationCompat>`__
   unless you set a different category using
   `setCategory() <#androidx.core.app.NotificationCompat.Builder>`__.

   .. rubric:: Additional resources
      :name: additional-resources

   See the following references for more information about ``MediaStyle`` and
   expandable notifications.

   -  `Using MediaStyle notifications with a foreground service <#implementing_a_mediasessionservice>`__
   -  `People sample app <https://github.com/android/user-interface-samples/tree/main/People>`__


Last updated 2024-02-22 UTC.


/Call style notifications
=========================

.. https://developer.android.google.cn/develop/ui/views/notifications/call-style?hl=en

.. container:: devsite-article-body

   On Android 12.0 (API level 31) and later, the system provides the
   `CallStyle <#android.app.Notification.CallStyle>`__
   notification template to distinguish call notifications from other types of
   notifications. Use this template to create incoming or ongoing call
   notifications. The template supports large-format notifications that include
   caller information and required actions such as answering or declining calls.

   Because incoming and ongoing calls are high priority events, these
   notifications receive top priority in the notification shade. This ranking
   also enables the system to forward these prioritized calls to other devices.

   The ``CallStyle`` notification template includes the following required
   actions:

   -  **Answer** or **Decline** for incoming calls.
   -  **Hang up** for ongoing calls.
   -  **Answer** or **Hang up** for call screening.

   Actions in this style appear as buttons, with the system automatically adding
   appropriate icons and text. Manual labeling of the buttons is not supported.
   For more information about notification design principles, see
   `Notifications <#>`__.

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/CallStyle.png
      name: call-style
      :alt: Call style notifications with labelled buttons
      :width: 100.0%

      **Figure 1.** CallStyle template for incoming and ongoing calls.

   The required actions are passed as intents, such as ``hangupIntent`` and
   ``answerIntent`` in the following sections. Each of these are a reference to
   a token maintained by the system. The token is a lightweight object that can
   be passed between different apps and processes. The system is responsible for
   managing the lifetime of the token and ensuring that the ``PendingIntent`` is
   usable even if the app that created it is no longer running. When you give
   another app a ``PendingIntent``, you are granting it the permission to
   perform the operation specified, such as decline or answer. This permission
   is granted even if the app that created the intent is not currently running.
   For more information, see the reference documentation for
   `PendingIntent <#android.app.PendingIntent>`__.

   Starting in Android 14 (API level 34), you can configure call notifications
   to be non-dismissible. To do so, use ``CallStyle`` notifications with the
   `Notification.FLAG_ONGOING_EVENT <#android.app.Notification>`__
   through
   `Notification.Builder#setOngoing(true) <#android.app.Notification.Builder>`__.

   The following are examples of using various methods with the ``CallStlye``
   notification.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a new call, setting the user as the caller.
               val incomingCaller = Person.Builder()
                   .setName("Jane Doe")
                   .setImportant(true)
                   .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a new call with the user as the caller.
               Person incomingCaller = new Person.Builder()
                   .setName("Jane Doe")
                   .setImportant(true)
                   .build();

   .. rubric:: Incoming call
      :name: incoming_call

   Use the ``forIncomingCall()`` method to create a call style notification for
   an incoming call.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a call style notification for an incoming call.
               val builder = Notification.Builder(context, CHANNEL_ID)
                   .setContentIntent(contentIntent)
                   .setSmallIcon(smallIcon)
                   .setStyle(
                        Notification.CallStyle.forIncomingCall(caller, declineIntent, answerIntent))
                   .addPerson(incomingCaller)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a call style notification for an incoming call.
               Notification.Builder builder = Notification.Builder(context, CHANNEL_ID)
                   .setContentIntent(contentIntent)
                   .setSmallIcon(smallIcon)
                   .setStyle(
                       Notification.CallStyle.forIncomingCall(caller, declineIntent, answerIntent))
                   .addPerson(incomingCaller);

   .. rubric:: Ongoing call
      :name: ongoing_call

   Use the ``forOngoingCall()`` method to create a call style notification for
   an ongoing call.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a call style notification for an ongoing call.
               val builder = Notification.Builder(context, CHANNEL_ID)
                   .setContentIntent(contentIntent)
                   .setSmallIcon(smallIcon)
                   .setStyle(
                        Notification.CallStyle.forOngoingCall(caller, hangupIntent))
                   .addPerson(second_caller)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a call style notification for an ongoing call.
               Notification.Builder builder = new Notification.Builder(context, CHANNEL_ID)
                   .setContentIntent(contentIntent)
                   .setSmallIcon(smallIcon)
                   .setStyle(
                       Notification.CallStyle.forOngoingCall(caller, hangupIntent))
                   .addPerson(second_caller);

   .. rubric:: Screen a call
      :name: screen_a_call

   Use the ``forScreeningCall()`` method to create a call style notification for
   screening a call.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a call style notification for screening a call.
               val builder = Notification.Builder(context, CHANNEL_ID)
                   .setContentIntent(contentIntent)
                   .setSmallIcon(smallIcon)
                   .setStyle(
                        Notification.CallStyle.forScreeningCall(caller, hangupIntent, answerIntent))
                   .addPerson(second_caller)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a call style notification for screening a call.
               Notification.Builder builder = new Notification.Builder(context, CHANNEL_ID)
                   .setContentIntent(contentIntent)
                   .setSmallIcon(smallIcon)
                   .setStyle(
                       Notification.CallStyle.forScreeningCall(caller, hangupIntent, answerIntent))
                   .addPerson(second_caller);

   .. rubric:: Provide compatibility across more Android versions
      :name: provide_compatibility_across_more_android_versions

   Associate ``CallStyle`` notifications on API versions 30 or earlier with a
   foreground service in order to assign them the high rank they are given in
   API level 31 or later. Additionally, ``CallStyle`` notifications on API
   version 30 or earlier can achieve a similar ranking by marking the
   notification as colorized, using the
   `setColorized() <#android.app.Notification.Builder>`__
   method.

   Use the Telecom APIs with ``CallStyle`` notifications. For more information,
   see `Telecom framework overview <#>`__.


Last updated 2024-02-22 UTC.


/Time-sensitive notifications
=============================

.. https://developer.android.google.cn/develop/ui/views/notifications/time-sensitive?hl=en

.. container:: devsite-article-body

   Your app might need to get the user's attention urgently in certain
   situations, such as an ongoing alarm or an incoming call. In apps targeting
   devices that run Android 9 (API level 28) or earlier, you might handle this
   by launching an activity while the app is in the background. This document
   shows how to achieve this behavior on devices running Android 10 (API level
   29) to Android 13 (API level 33).

   .. rubric:: Add the POST_NOTIFICATIONS permission
      :name: add-permission

   Starting in Android 13, add the following line to your
   ``AndroidManifest.xml`` file:

   .. code:: prettyprint

      <manifest ...>
          <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
          <application ...>
              ...
          </application>
      </manifest>

   Once you have this, you can create a notification channel.

   .. rubric:: Create a notification channel
      :name: create-notification-channel

   Create a notification channel to properly display your notifications and let
   the user manage notifications in the app settings. For more information about
   notification channels, see `Create and manage notification channels <#>`__.

   Create your notification channels in your ``Application`` class's
   `onCreate <#android.app.Application>`__ method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class DACapp : Application() {
                   override fun onCreate() {
                       super.onCreate()
                       val channel = NotificationChannel(
                           CHANNEL_ID,
                           "High priority notifications",
                           NotificationManager.IMPORTANCE_HIGH
                       )

                       val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                       notificationManager.createNotificationChannel(channel)
                   }
               }

   When the user runs your app for the first time, they see something like
   figure 1 in your app's **App info** system screen:

   .. figure::
      https://developer.android.google.cn/static/images/ui/notifications/time-sensitive_notification_channel_empty.png
      name: notification-channel
      :alt: An image showing the App Info, Notification screen of your app.
      :width: 40.0%

      **Figure 1.** Notifications section in the **App Info** screen of the
      app's system settings.

   .. rubric:: Manage notifications permissions
      :name: manage-notifications-permissions

   Starting in Android 13, request notification permissions before you show
   notifications to users.

   The minimum implementation looks like this:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val permissionLauncher = rememberLauncherForActivityResult(
                   contract = ActivityResultContracts.RequestPermission(),
                   onResult = { hasNotificationPermission = it }
               )
               ...
               Button(
                   onClick = {
                       if (!hasNotificationPermission) {
                           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                               permissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                           }
                       }
                   },
               ) {
                   Text(text = "Request permission")
               }

   If your device is running Android 13, tapping the ``Request permission``
   button triggers the dialog shown in figure 2:

   .. figure::
      https://developer.android.google.cn/static/images/ui/notifications/time-sensitive_notification_permission_request_dialog.png
      name: permission_dialog
      :alt: An image showing the permission request dialog
      :width: 40.0%

      **Figure 2.** System dialog for the notification permission request.

   If the user accepts the permission request, the app's **App info** section
   looks like figure 3:

   .. figure::
      https://developer.android.google.cn/static/images/ui/notifications/time-sensitive_notification_permission_granted.png
      name: permission_granted
      :alt: An image showing the App Info screen after granted notification
      permission request
      :width: 40.0%

      **Figure 3.** Notification permissions granted.

   **Experimental:**\  See the Accompanist `Jetpack Compose Permissions <https://google.github.io/accompanist/permissions/>`__ library
   for experimental permission management.

   .. rubric:: Create a high-priority notification
      :name: create-high-priority-notification

   When creating the notification, include a descriptive title and message.

   The following example contains a notification:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private fun showNotification() {
                   val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

                   val notificationBuilder =
                       NotificationCompat.Builder(this, CHANNEL_ID)
                           .setSmallIcon(R.drawable.baseline_auto_awesome_24)
                           .setContentTitle("HIGH PRIORITY")
                           .setContentText("Check this dog puppy video NOW!")
                           .setPriority(NotificationCompat.PRIORITY_HIGH)
                           .setCategory(NotificationCompat.CATEGORY_RECOMMENDATION)

                   notificationManager.notify(666, notificationBuilder.build())
               }

   .. rubric:: Display the notification to the user
      :name: display-notification-user

   Calling the ``showNotification()`` function triggers the notification as
   follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               Button(onClick = { showNotification() }) {
                   Text(text = "Show notification")
               }

   The notification in this example looks like figure 4:

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/time-sensitive_notification.png
      name: notification
      :alt: An image showing a high priority notification
      :width: 40.0%

      **Figure 4.** A high-priority notification.

   .. rubric:: Ongoing notification
      :name: ongoing

   When you display your notification to the user, they can acknowledge or
   dismiss your app's alert or reminder. For example, the user can accept or
   reject an incoming phone call.

   **Note:**\  While the user is using the device, the system UI might display a
   heads-up notification instead of launching your full-screen intent.
   If your notification is an ongoing one, such as an incoming phone call,
   associate the notification with a `foreground service <#Foreground>`__. The following code
   snippet shows how to display a notification associated with a foreground
   service:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Provide a unique integer for the "notificationId" of each notification.
               startForeground(notificationId, notification)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Provide a unique integer for the "notificationId" of each notification.
               startForeground(notificationId, notification);


Last updated 2024-05-03 UTC.


/Custom notifications
=====================

.. https://developer.android.google.cn/develop/ui/views/notifications/custom-notification?hl=en

.. container:: devsite-article-body

   To make your notifications look their best across different versions of
   Android, use the `standard notification template <#>`__ to build your
   notifications. If you want to provide more content in your notification,
   consider using one of the `expandable notification templates <#>`__.

   However, if the system templates don't meet your needs, you can use your own
   layout for the notification.

   **Caution:**\  When using a custom notification layout, take special care to
   ensure your custom layout works with different device orientations and
   resolutions. Although this advice applies to all UI layouts, it's especially
   important for notifications because the space in the notification drawer is
   restricted. The height available for a custom notification layout depends on
   the Android version. On some versions, collapsed view layouts are limited to
   as little as 48 dp, heads-up view layouts are limited to as little as 88 dp,
   and expanded view layouts are limited to as little as 252 dp.

   .. rubric:: Create custom layout for the content area
      :name: custom-content

   If you need a custom layout, you can apply
   `NotificationCompat.DecoratedCustomViewStyle <#androidx.core.app.NotificationCompat.DecoratedCustomViewStyle>`__
   to your notification. This API lets you provide a custom layout for the
   content area normally occupied by the title and text content, while still
   using system decorations for the notification icon, timestamp, sub-text, and
   action buttons.

   This API works similarly to the `expandable notification templates <#>`__ by building on the basic
   notification layout as follows:

   #. Build a `basic notification <#>`__
      with
      `NotificationCompat.Builder <#androidx.core.app.NotificationCompat.Builder>`__.
   #. Call
      `setStyle() <#androidx.core.app.NotificationCompat.Builder>`__,
      passing it an instance of
      `NotificationCompat.DecoratedCustomViewStyle <#androidx.core.app.NotificationCompat.DecoratedCustomViewStyle>`__.
   #. Inflate your custom layout as an instance of
      `RemoteViews <#android.widget.RemoteViews>`__.
   #. Call
      `setCustomContentView() <#androidx.core.app.NotificationCompat.Builder>`__
      to set the layout for the collapsed notification.
   #. Optionally, also call
      `setCustomBigContentView() <#androidx.core.app.NotificationCompat.Builder>`__
      to set a different layout for the expanded notification.

   **Note:**\  If you're creating a customized notification for media playback
   controls, follow the same recommendations but use the
   ``NotificationCompat.DecoratedMediaCustomViewStyle`` class instead.

   .. rubric:: Prepare the layouts
      :name: prepare-layouts

   You need a ``small`` and ``large`` layout. For this example, the ``small``
   layout might look like this:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:orientation="vertical">

          <TextView
              android:id="@+id/notification_title"
              style="@style/TextAppearance.Compat.Notification.Title"
              android:layout_width="wrap_content"
              android:layout_height="0dp"
              android:layout_weight="1"
              android:text="Small notification, showing only a title" />
      </LinearLayout>

   And the ``large`` layout might look like this:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="300dp"
          android:orientation="vertical">

          <TextView
              android:id="@+id/notification_title"
              style="@style/TextAppearance.Compat.Notification.Title"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_weight="1"
              android:text="Large notification, showing a title and a body." />

          <TextView
              android:id="@+id/notification_body"
              style="@style/TextAppearance.Compat.Notification.Line2"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_weight="1"
              android:text="This is the body. The height is manually forced to 300dp." />
      </LinearLayout>

   .. rubric:: Build and show the notification
      :name: build-and-show-notification

   After the layouts are ready, you can use them as shown in the following
   example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

               // Get the layouts to use in the custom notification.
               val notificationLayout = RemoteViews(packageName, R.layout.notification_small)
               val notificationLayoutExpanded = RemoteViews(packageName, R.layout.notification_large)

               // Apply the layouts to the notification.
               val customNotification = NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setStyle(NotificationCompat.DecoratedCustomViewStyle())
                       .setCustomContentView(notificationLayout)
                       .setCustomBigContentView(notificationLayoutExpanded)
                       .build()

               notificationManager.notify(666, customNotification)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);

               // Get the layouts to use in the custom notification
               RemoteViews notificationLayout = new RemoteViews(getPackageName(), R.layout.notification_small);
               RemoteViews notificationLayoutExpanded = new RemoteViews(getPackageName(), R.layout.notification_large);

               // Apply the layouts to the notification.
               Notification customNotification = new NotificationCompat.Builder(context, CHANNEL_ID)
                       .setSmallIcon(R.drawable.notification_icon)
                       .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
                       .setCustomContentView(notificationLayout)
                       .setCustomBigContentView(notificationLayoutExpanded)
                       .build();

               notificationManager.notify(666, customNotification);

   Be aware that the background color for the notification can vary across
   devices and versions. Apply Support Library styles such as
   ``TextAppearance_Compat_Notification`` for the text and
   ``TextAppearance_Compat_Notification_Title`` for the title in your custom
   layout, as shown in the following example. These styles adapt to the color
   variations so you don't end up with black-on-black or white-on-white text.

   .. code:: prettyprint

      <TextView
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:layout_weight="1"
          android:text="@string/notification_title"
          android:id="@+id/notification_title"
          style="@style/TextAppearance.Compat.Notification.Title" />

   Avoid setting a background image on your ``RemoteViews`` object, because your
   text might become unreadable.

   When you trigger a notification while the user is using an app, the result is
   similar to figure 1:

   .. figure::
      https://developer.android.google.cn/static/images/ui/notifications/custom_notification_small_inapp.png
      name: small-inapp
      :alt: An image showing a collapsed notification
      :width: 40.0%

      **Figure 1.** A small notification layout appears while using other apps.

   Tapping the expander arrow expands the notification, as shown in figure 2:

   .. figure::
      https://developer.android.google.cn/static/images/ui/notifications/custom_notification_large_inapp.png
      name: large-inapp
      :alt: An image showing an expanded notification in the system bar
      :width: 40.0%

      **Figure 2.** A large notification layout appears while using other apps.

   After the notification timeout runs out, the notification is visible only in
   the system bar, which looks like figure 3:

   .. figure::
      https://developer.android.google.cn/static/images/ui/notifications/custom_notification_small_system.png
      name: small-system
      :alt: An image showing a collapsed notification in the system bar
      :width: 40.0%

      **Figure 3.** How the small notification layout appears in the system bar.

   Tapping the expander arrow expands the notification, as shown in figure 4:

   .. figure::
      https://developer.android.google.cn/static/images/ui/notifications/custom_notification_large_system.png
      name: large-system
      :alt: An image showing an expanded notification in the system bar
      :width: 40.0%

      **Figure 4.** A large notification layout appears in the system bar.

   .. rubric:: Create a fully custom notification layout
      :name: fully-custom-notification

   **Note:**\  Apps targeting `Android 12 <#custom-notifications>`__ (API
   level 31) or later can't create fully custom notifications. Instead, the
   system applies a standard template nearly identical to the behavior of
   `Notification.DecoratedCustomViewStyle <#android.app.Notification.DecoratedCustomViewStyle>`__.
   If you don't want your notification decorated with the standard notification
   icon and header, follow the preceding steps but *don't* call ``setStyle()``.

   **Caution:**\  We don't recommend using an undecorated notification as this
   doesn't match other notifications and can cause significant layout
   compatibility issues on devices that apply different styling to the
   notification area.


Last updated 2024-02-22 UTC.


/Create a notification group
============================

.. https://developer.android.google.cn/develop/ui/views/notifications/group?hl=en

.. container:: devsite-article-body

   Starting in Android 7.0 (API level 24), you can display related notifications
   in a group. For example, if your app shows notifications for received emails,
   put all notifications for new email messages in the same group so they
   collapse together.

   To support older versions, add a summary notification that appears alone to
   summarize all the separate notifications. This is often best done with the
   `inbox-style notification <#inbox-style>`__.

   |image-notification-group_2x|

   **Figure 1.** A collapsed (top) and expanded (bottom) notification group.

   **Note:**\  Notification groups are not the same as `notification channel groups <#CreateChannelGroup>`__.
   Use notification groups if all of the following conditions are true for your
   use case:

   -  The child notifications are complete notifications and can be displayed
      individually without the need for a group summary.

   -  There is a benefit to surfacing the child notifications individually. For
      example:

      -  They are actionable, with actions specific to each notification.

      -  There is more information in each notification for the user to see.

   If your notifications don't meet the preceding criteria, instead consider
   `updating an existing notification <#>`__ with
   new information or creating a `message-style notification <#message-style>`__ to show
   multiple updates in the same conversation.

   **Note:**\  If your app sends four or more notifications and doesn't specify
   a group, the system `automatically groups <#automatic-grouping>`__ them on
   Android 7.0 and higher.

   .. rubric:: Create a group and add a notification to it
      :name: group-notification

   To create a notification group, define a unique identifier string for the
   group. Then, for each notification you want in the group, call
   `setGroup() <#androidx.core.app.NotificationCompat.Builder>`__,
   passing the group name. For example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val GROUP_KEY_WORK_EMAIL = "com.android.example.WORK_EMAIL"

               val newMessageNotification = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_mail)
                       .setContentTitle(emailObject.getSenderName())
                       .setContentText(emailObject.getSubject())
                       .setLargeIcon(emailObject.getSenderAvatar())
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String GROUP_KEY_WORK_EMAIL = "com.android.example.WORK_EMAIL";

               Notification newMessageNotification = new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.new_mail)
                       .setContentTitle(emailObject.getSenderName())
                       .setContentText(emailObject.getSubject())
                       .setLargeIcon(emailObject.getSenderAvatar())
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       .build();

   By default, notifications are sorted according to when they are posted, but
   you can change the order by calling
   `setSortKey() <#androidx.core.app.NotificationCompat.Builder>`__.

   If alerts for a notification's group must be handled by a different
   notification, call
   `setGroupAlertBehavior() <#androidx.core.app.NotificationCompat.Builder>`__
   For example, if you want only the summary of your group to make noise, all
   children in the group must have the group alert behavior
   `GROUP_ALERT_SUMMARY <#androidx.core.app.NotificationCompat>`__.
   The other options are
   `GROUP_ALERT_ALL <#androidx.core.app.NotificationCompat>`__
   and
   `GROUP_ALERT_CHILDREN <#androidx.core.app.NotificationCompat>`__.

   .. rubric:: Set a group summary
      :name: group-summary

   Grouped notifications must have an extra notification that acts as the group
   summary. To enable grouped notifications, you must set a group summary. This
   group summary must include some of the text from each of the other
   notifications in the group to help the user understand what is in the group.
   How the group summary is displayed depends on the Android version:

   -  On Android versions lower than 7.0 (API level 24), which can't show a
      nested group of notifications, the system only shows your group summary
      notification and hides all the others. The user can tap the group summary
      notification to open your app.

   -  On Android 7.0 and higher, the system shows your group summary
      notification as a nested group of notifications, labeled with snippets of
      text from each grouped notification. It doesn't display the text you set
      on the group summary notification. The user can expand the nested group of
      notifications to see the individual notifications in the group, as shown
      in figure 1.

   Even if newer versions of Android don't show the group summary text that you
   design, *you always need to manually set a summary to enable grouped
   notifications*. The behavior of the group summary might vary on some device
   types, such as wearables. Setting rich content on your group summary helps
   provide the best experience on all devices and versions.

   To add a group summary, proceed as follows:

   #. Create a new notification with a description of the group—often best done
      with the `inbox-style notification <#inbox-style>`__.

   #. Add the summary notification to the group by calling ``setGroup()``.

   #. Specify that it must be used as the group summary by calling
      `setGroupSummary(true) <#androidx.core.app.NotificationCompat.Builder>`__.

   The following code shows an example of creating a group summary:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Use constant ID for notifications used as group summary.
               val SUMMARY_ID = 0
               val GROUP_KEY_WORK_EMAIL = "com.android.example.WORK_EMAIL"

               val newMessageNotification1 = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
                       .setSmallIcon(R.drawable.ic_notify_email_status)
                       .setContentTitle(emailObject1.getSummary())
                       .setContentText("You will not believe...")
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       .build()

               val newMessageNotification2 = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
                       .setSmallIcon(R.drawable.ic_notify_email_status)
                       .setContentTitle(emailObject2.getSummary())
                       .setContentText("Please join us to celebrate the...")
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       .build()

               val summaryNotification = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
                       .setContentTitle(emailObject.getSummary())
                       // Set content text to support devices running API level < 24.
                       .setContentText("Two new messages")
                       .setSmallIcon(R.drawable.ic_notify_summary_status)
                       // Build summary info into InboxStyle template.
                       .setStyle(NotificationCompat.InboxStyle()
                               .addLine("Alex Faarborg Check this out")
                               .addLine("Jeff Chang Launch Party")
                               .setBigContentTitle("2 new messages")
                               .setSummaryText("janedoe@example.com"))
                       // Specify which group this notification belongs to.
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       // Set this notification as the summary for the group.
                       .setGroupSummary(true)
                       .build()

               NotificationManagerCompat.from(this).apply {
                   notify(emailNotificationId1, newMessageNotification1)
                   notify(emailNotificationId2, newMessageNotification2)
                   notify(SUMMARY_ID, summaryNotification)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Use constant ID for notifications used as group summary.
               int SUMMARY_ID = 0;
               String GROUP_KEY_WORK_EMAIL = "com.android.example.WORK_EMAIL";

               Notification newMessageNotification1 =
                   new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.ic_notify_email_status)
                       .setContentTitle(emailObject1.getSummary())
                       .setContentText("You will not believe...")
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       .build();

               Notification newMessageNotification2 =
                   new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                       .setSmallIcon(R.drawable.ic_notify_email_status)
                       .setContentTitle(emailObject2.getSummary())
                       .setContentText("Please join us to celebrate the...")
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       .build();

               Notification summaryNotification =
                   new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                       .setContentTitle(emailObject.getSummary())
                       // Set content text to support devices running API level < 24.
                       .setContentText("Two new messages")
                       .setSmallIcon(R.drawable.ic_notify_summary_status)
                       // Build summary info into InboxStyle template.
                       .setStyle(new NotificationCompat.InboxStyle()
                               .addLine("Alex Faarborg  Check this out")
                               .addLine("Jeff Chang    Launch Party")
                               .setBigContentTitle("2 new messages")
                               .setSummaryText("janedoe@example.com"))
                       // Specify which group this notification belongs to.
                       .setGroup(GROUP_KEY_WORK_EMAIL)
                       // Set this notification as the summary for the group.
                       .setGroupSummary(true)
                       .build();

               NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
               notificationManager.notify(emailNotificationId1, newMessageNotification1);
               notificationManager.notify(emailNotificationId2, newMessageNotification2);
               notificationManager.notify(SUMMARY_ID, summaryNotification);

   The summary notification ID must stay the same so that it's only posted once
   and so you can update it later if the summary information changes. Subsequent
   additions to the group must result in updating the existing summary.

   For sample code that uses notifications, see the `Android Notifications Sample <https://github.com/android/user-interface-samples/tree/main>`__ .

   .. rubric:: Automatic grouping
      :name: automatic-grouping

   On Android 7.0 (API level 24) and higher, if your app sends four or more
   notifications and doesn't specify a group key or group summary, the system
   might automatically group them together. Notifications grouped automatically
   appear with a group summary notification labeled with snippets of text from
   some of the grouped notifications. The user can expand this summary
   notification to see each individual notification, as with manually grouped
   notifications.

   Automatic grouping behavior might vary on some device types. To provide the
   best experience on all devices and versions, if you know notifications must
   be grouped, specify a group key and group summary to make sure they are
   grouped.


Last updated 2024-02-22 UTC.

.. |image-notification-group_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/notification-group_2x.png
   :width: 386px


/Start an activity from a notification
======================================

.. https://developer.android.google.cn/develop/ui/views/notifications/navigation?hl=en

.. container:: devsite-article-body

   When you start an activity from a notification, you must preserve the user's
   expected navigation experience. Tapping the Back button must take the user
   back through the app's normal work flow to the Home screen, and opening the
   Recents screen must show the activity as a separate task. To preserve this
   navigation experience, start the activity in a fresh task.

   The basic approach to set the tap behavior for your notification is described
   in `Create a basic notification <#SimpleNotification>`__.
   This page describes how to set up a
   `PendingIntent <#android.app.PendingIntent>`__ for your
   notification's action so it creates a fresh `task and back stack <#>`__. How you do this
   depends on which type of activity you're starting:

   Regular activity
      This is an activity that exists as a part of your app's normal UX flow.
      When the user arrives in the activity from the notification, the new task
      must include a complete back stack, letting the user tap the Back button
      to navigate up the app hierarchy.
   Special activity
      The user only sees this activity if it's started from a notification. In a
      sense, this activity extends the notification UI by providing information
      that is difficult to display in the notification itself. This activity
      doesn't need a back stack.

   .. rubric:: Set up a regular activity PendingIntent
      :name: DirectEntry

   To start a regular activity from your notification, set up the
   ``PendingIntent`` using
   `TaskStackBuilder <#androidx.core.app.TaskStackBuilder>`__ so
   that it creates a new back stack as follows.

   .. rubric:: Define your app's Activity hierarchy
      :name: activity-hierarchy

   Define the natural hierarchy for your activities by adding the
   `android:parentActivityName <#parent>`__
   attribute to each
   `<activity> <#>`__ element in your
   app manifest file. See the following example:

   .. code:: prettyprint

      <activity
          android:name=".MainActivity"
          android:label="@string/app_name" >
          <intent-filter>
              <action android:name="android.intent.action.MAIN" />
              <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
      </activity>
      <!-- MainActivity is the parent for ResultActivity. -->
      <activity
          android:name=".ResultActivity"
          android:parentActivityName=".MainActivity" />
          ...
      </activity>

   .. rubric:: Build a PendingIntent with a back stack
      :name: PendingIntent-back-stack

   To start an activity that includes a back stack of activities, create an
   instance of ``TaskStackBuilder`` and call
   `addNextIntentWithParentStack() <#androidx.core.app.TaskStackBuilder>`__,
   passing it the `Intent <#android.content.Intent>`__ for the
   activity you want to start.

   As long as you define the parent activity for each activity as described
   earlier, you can call
   `getPendingIntent() <#androidx.core.app.TaskStackBuilder>`__
   to receive a ``PendingIntent`` that includes the entire back stack.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create an Intent for the activity you want to start.
               val resultIntent = Intent(this, ResultActivity::class.java)
               // Create the TaskStackBuilder.
               val resultPendingIntent: PendingIntent? = TaskStackBuilder.create(this).run {
                   // Add the intent, which inflates the back stack.
                   addNextIntentWithParentStack(resultIntent)
                   // Get the PendingIntent containing the entire back stack.
                   getPendingIntent(0,
                           PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create an Intent for the activity you want to start.
               Intent resultIntent = new Intent(this, ResultActivity.class);
               // Create the TaskStackBuilder and add the intent, which inflates the back
               // stack.
               TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);
               stackBuilder.addNextIntentWithParentStack(resultIntent);
               // Get the PendingIntent containing the entire back stack.
               PendingIntent resultPendingIntent =
                       stackBuilder.getPendingIntent(0,
                           PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);

   If necessary, you can add arguments to ``Intent`` objects in the stack by
   calling
   `TaskStackBuilder.editIntentAt() <#androidx.core.app.TaskStackBuilder>`__.
   This is sometimes necessary to ensure that an activity in the back stack
   displays meaningful data when the user navigates to it.

   Then you can pass the ``PendingIntent`` to the notification as usual:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val builder = NotificationCompat.Builder(this, CHANNEL_ID).apply {
                   setContentIntent(resultPendingIntent)
                   ...
               }
               with(NotificationManagerCompat.from(this)) {
                   notify(NOTIFICATION_ID, builder.build())
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID);
               builder.setContentIntent(resultPendingIntent);
               ...
               NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
               notificationManager.notify(NOTIFICATION_ID, builder.build());

   .. rubric:: Set up a special activity PendingIntent
      :name: ExtendedNotification

   Because a special activity that starts from a notification doesn't need a
   back stack, you can create the ``PendingIntent`` by calling
   `getActivity() <#android.app.PendingIntent>`__.
   However, define the appropriate task options in the manifest.

   #. In your manifest, add the following attributes to the ``<activity>``
      element.

      `android:taskAffinity <#aff>`__\ ``=""``
         Combined with the
         `FLAG_ACTIVITY_NEW_TASK <#android.content.Intent>`__
         flag that you use in code, set this attribute blank to ensure this
         activity doesn't go into the app's default task. Any existing tasks
         that have the app's default affinity aren't affected.
      `android:excludeFromRecents <#exclude>`__\ ``="true"``
         Excludes the new task from the Recents screen so that the user can't
         accidentally navigate back to it.

      This is shown in the following example:

      .. code:: prettyprint

         <activity
             android:name=".ResultActivity"
             android:launchMode="singleTask"
             android:taskAffinity=""
             android:excludeFromRecents="true">
         </activity>

   #. Build and issue the notification:

      a. Create an ``Intent`` that starts the
         `Activity <#android.app.Activity>`__.
      b. Set the ``Activity`` to start in a new, empty task by calling
         `setFlags() <#android.content.Intent>`__
         with the flags ``FLAG_ACTIVITY_NEW_TASK`` and
         `FLAG_ACTIVITY_CLEAR_TASK <#android.content.Intent>`__.
      c. Create a ``PendingIntent`` by calling ``getActivity()``.

      This is shown in the following example:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val notifyIntent = Intent(this, ResultActivity::class.java).apply {
                      flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                  }
                  val notifyPendingIntent = PendingIntent.getActivity(
                          this, 0, notifyIntent,
                          PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                  )

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  Intent notifyIntent = new Intent(this, ResultActivity.class);
                  // Set the Activity to start in a new, empty task.
                  notifyIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                                      | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  // Create the PendingIntent.
                  PendingIntent notifyPendingIntent = PendingIntent.getActivity(
                          this, 0, notifyIntent,
                          PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
                  );

   #. Pass the ``PendingIntent`` to the notification as usual:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val builder = NotificationCompat.Builder(this, CHANNEL_ID).apply {
                      setContentIntent(notifyPendingIntent)
                      ...
                  }
                  with(NotificationManagerCompat.from(this)) {
                      notify(NOTIFICATION_ID, builder.build())
                  }

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID);
                  builder.setContentIntent(notifyPendingIntent);
                  ...
                  NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
                  notificationManager.notify(NOTIFICATION_ID, builder.build());

   For more information about the various task options and how the back stack
   works, see `Tasks and the back stack <#>`__.


Last updated 2024-02-22 UTC.


/About conversations
====================

.. https://developer.android.google.cn/develop/ui/views/notifications/conversations?hl=en

.. container:: devsite-article-body

   The people and conversations initiative is a multi-year Android initiative
   that aims to elevate people and conversations in the system surfaces of the
   phone. This priority is based on the fact that communication and interaction
   with other people is still the most valued and important functional area for
   the majority of our users across all demographics.

   A number of features were introduced in Android 11 to support the people and
   conversations initiative.

   .. rubric:: Conversation space
      :name: conversation-space

   | 

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/conversations-conv-space.png
      :alt: The conversation space is a dedicated notification area for
      real-time conversations between humans.
      :figclass: screenshot
      :width: 250px

      **Figure 1**: The conversations space.

   On handheld devices, there is a separate section on top of the notification
   shade containing only real-time conversations with people (such as calls and
   chat messages, including group chats). Notifications in this space look and
   act differently from non-conversation notifications on many phones:

   -  The design is different, with a strong emphasis on the avatar representing
      people combined with the app carrying the conversation.
   -  A tap on the notification opens the conversation in the app (or
      `bubble <#>`__, if the conversation was previously
      bubbled), and a tap on the caret expands the new messages in the shade to
      full length with the full list of options.
   -  Conversation-specific actions are offered (some by long-pressing):

      -  Mark this conversation as priority
      -  Promote this conversation to bubble (only shown if the app supports
         bubbles)
      -  Silence notifications for this conversation
      -  Set custom sounds or vibrations for this conversation

   .. rubric:: Conversations in Bubbles
      :name: bubbles

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/conversations-bubble.gif
      :alt: If a notification meets the conversation requirements, the platform
      launches it as a bubble from the notification drawer.
      :figclass: screenshot
      :width: 258px
      :height: 534px

      **Figure 2**: Notification being launched as a bubble from the
      notification drawer.

   Beginning in Android 11, `Bubbles <#>`__ can be
   started from notifications in the Conversations section. Only notifications
   with an associated shortcut are able to bubble. Conversations bubble
   automatically if they are marked as important or are triggered to bubble in
   the notification shade.

   .. rubric:: Conversation Shortcuts
      :name: shortcuts

   Shortcuts to conversations appear in the launcher and alongside
   `long-lived <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__,
   `sharing shortcuts <#>`__ in the
   sharesheet.

   .. rubric:: API guidelines
      :name: api-guidelines

   This section describes the APIs to add support in your app for the
   system-provided space that shows people and conversations.

   .. rubric:: Shortcuts for Conversations
      :name: api-shortcuts

   In order to participate in this conversation-centric initiative, apps need to
   provide the system with
   `long-lived <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
   shortcuts. We strongly recommend using long-lived `sharing shortcuts <#>`__. If necessary, you can
   use `dynamic shortcuts <#dynamic>`__ in
   Android 11, but we may remove this option in the future.

   To publish a
   `shortcut <#androidx.core.content.pm.ShortcutInfoCompat>`__ to the
   conversation, call the
   `ShortcutManagerCompat <#androidx.core.content.pm.ShortcutManagerCompat>`__
   methods
   `setDynamicShortcuts() <#androidx.core.content.pm.ShortcutManagerCompat>`__,
   `addDynamicShortcuts() <#androidx.core.content.pm.ShortcutManagerCompat>`__,
   or
   `pushDynamicShortcut() <#androidx.core.content.pm.ShortcutManagerCompat>`__
   (which automatically manages the shortcut limit for the developer). This
   shortcut must be
   `long-lived <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
   and have
   `Person <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
   data attached for one or more persons, identifying the other participants in
   the conversation. We also recommend that you set the
   `LocusIdCompat <#api-in-app>`__.

   If a conversation no longer exists, the app can delete the shortcut with
   `removeLongLivedShortcuts() <#androidx.core.content.pm.ShortcutManagerCompat>`__;
   doing so causes the system to delete all data associated with the
   conversation. Although shortcuts are removable, apps **shouldn't remove
   cached shortcuts** unless absolutely necessary; a shortcut is probably cached
   because the user interacted with it to change their experience, and removing
   the shortcut will undo those changes, leading to user frustration.

   **Note:**\  If removing a cached shortcut removes a person-specific
   conversation notification channel, the deleted category count in **Settings**
   is incremented.

   .. rubric:: Conversation Notifications
      :name: api-notifications

   A notification is considered as a conversation notification if the following
   are true:

   -  The notification uses
      `MessagingStyle <#androidx.core.app.NotificationCompat.MessagingStyle>`__.

   -  **(Only if the app targets Android 11 or higher)** The notification is
      associated with a valid
      `long-lived <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
      dynamic or cached sharing shortcut. The notification can set this
      association by calling
      `setShortcutId() <#androidx.core.app.NotificationCompat.Builder>`__
      or
      `setShortcutInfo() <#androidx.core.app.NotificationCompat.Builder>`__.
      If the app targets Android 10 or lower, the notification doesn't have to
      be associated with a shortcut, as discussed in the `fallback options <#non-11>`__ section.

   -  The user hasn't demoted the conversation from the conversation section via
      notification channel settings, at the time of posting.

   .. rubric:: Use LocusIdCompat
      :name: api-in-app

   On-device intelligence determines the conversations that the user is most
   likely to be interested in. Among the most important signals are *recency*
   and *frequency* of conversation sessions in each conversation. The system
   knows about interactions with a conversation from Launcher shortcuts or
   within a notification if they are properly tagged. However, the system
   doesn't know about conversations that happened fully in the app unless those
   interactions are also tagged. Thus, we strongly recommend that you `attach a ``LocusIdCompat`` to the
   shortcut <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
   and annotate the in-app activity or fragment with the associated
   `LocusIdCompat <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__.
   Use ``LocusIdCompat`` to enable the suggestion system to properly rank the
   conversation, and to enable the system to display the correct time of the
   user's last interaction (including in-app interactions) with a conversation.
   If you use
   `setShortcutInfo() <#androidx.core.app.NotificationCompat.Builder>`__
   to associate the conversation with a shortcut, the conversations system
   automatically attaches the appropriate ``LocusIdCompat``.

   .. rubric:: Conversation space requirements for apps that target Android 10
      or lower
      :name: non-11

   If an app doesn't target Android 11, its messages can still be surfaced in
   the conversation space. However, the app still must meet certain
   requirements. This section describes the requirements for those apps, and the
   fallback behavior if the app doesn't meet the requirements.

   **Note:**\  If the app targets Android 11 or higher, it must follow the
   requirements described in `API guidelines <#api-guidelines>`__ to have its
   messages appear in the conversation space.
   The core requirement for participation in the messaging space is, the app
   must implement
   `MessagingStyle <#androidx.core.app.NotificationCompat.MessagingStyle>`__
   notifications, and the notifications must reference a **long-lived shortcut**
   from the notification that is published at the time the notification is
   posted. Notifications that meet these requirements appear in the conversation
   space with this behavior:

   -  Notification is displayed in **conversation style**
   -  **Bubble** button is offered, if implemented
   -  **Conversation specific** **functions** are offered inline

   If the notification doesn't meet these requirements, the platform uses
   fallback options to format the notification. If a notification meets the
   requirements of either fallback case, the notification is displayed in the
   conversation space with special formatting. If the notification doesn't
   qualify for either fallback option, it isn't displayed in the conversation
   space.

   .. rubric:: Fallback: If MessagingStyle is used but no shortcut is provided
      :name: fallback-no-shortcut

   If the app targets Android 10 or lower and a notification uses
   `MessagingStyle <#androidx.core.app.NotificationCompat.MessagingStyle>`__
   but does *not* associate the message with a shortcut, the notification is
   shown in the conversation space with this behavior:

   -  Notification is displayed in **conversation style**
   -  **No bubble button** is offered
   -  **No conversation-specific functions** are offered inline

   .. rubric:: Fallback: If MessagingStyle isn't used, but the app is a
      recognized messaging app
      :name: fallack-msg-app

   If a notification doesn't use
   `MessagingStyle <#androidx.core.app.NotificationCompat.MessagingStyle>`__
   but the app is recognized by the platform as a messaging app, and the
   notification's
   `category <#androidx.core.app.NotificationCompat.Builder>`__
   parameter is set to
   `msg <#androidx.core.app.NotificationCompat>`__,
   the notification is shown in the conversation space with this behavior:

   -  Notification is displayed in **old, pre-Android 11 style**
   -  **No bubble button** is offered
   -  **No conversation-specific functions** are offered inline

   .. rubric:: Guidance, usage, and testing
      :name: guidance

   This section provides general guidance on how to use and test the
   conversation features.

   .. rubric:: When should I use conversations?
      :name: when

   Conversation Notifications and related shortcuts are intended to improve the
   user experience of **real-time conversations**. For example, SMS, text chats,
   and phone calls are real-time conversations where users expect to communicate
   quickly. Users don't have that expectation with emails and activities
   unrelated to conversations.

   We’ve given users the ability to remove a given conversation from the
   conversation section if they don’t feel it’s in the right space.

   .. rubric:: Best practices
      :name: best-practices

   To increase engagement and make it easier for your users to interact with
   people and conversations around your app, we recommend the following best
   practices.

   -  To ensure that missed calls are surfaced in the prioritized conversation
      shade and appear correctly in the `conversion widget <#conversation-widgets>`__, format missed call notifications as
      `conversations <#>`__ with a category set
      to
      `CATEGORY_MISSED_CALL <#android.app.Notification>`__.
   -  Provide high-quality avatars (104dp) for users; otherwise, the system uses
      the person's initials, which is a less engaging experience.
   -  Don’t
      `cancel <#android.app.NotificationManager>`__ a
      conversation notification before the user has not seen the message. One
      example of this is canceling a notification when opening the app in a view
      where the user can't see or address the message. If the user isn’t given
      the opportunity to read or address the message, a canceled notification
      and its associated bubble are removed, resulting in the loss of
      conversation context.
   -  Provide a
      `data <#android.app.Notification.MessagingStyle.Message>`__
      URI for MIME-related metadata associated with messages, which gives you
      the option of providing a richer experience in notifications.
   -  Use the
      `Android 12 status <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
      API to make `conversation widgets <#conversation-widgets>`__ more
      engaging.
   -  Adopt the following best practices for `conversation shortcuts <#shortcuts>`__.

      -  Publish shortcuts for incoming and outgoing in-app conversations that
         do not push notifications. Incoming and outgoing messages for the same
         conversation should have the same shortcut ID. Use
         `pushDynamicShortcut() <#androidx.core.content.pm.ShortcutManagerCompat>`__
         to publish your shortcuts and report usage.
      -  To avoid unintentional clipping of your shortcut avatar, provide an
         `AdaptiveIconDrawable <#android.graphics.drawable.AdaptiveIconDrawable>`__
         for the shortcut's icon. See `Providing shortcut imagery <#providing-shortcut-imagery>`__ for
         more details.
      -  To help the system promote your shortcut, follow `guidelines for
         getting the best ranking <#get-best-ranking>`__. Your shortcut
         is ranked in different system surfaces, including the Android
         sharesheet if it's a sharing shortcut.
      -  Ensure that conversation shortcuts
         `intents <#android.content.pm.ShortcutInfo.Builder>`__
         launch directly into the applicable conversation.
      -  Use the compat libs to conveniently set your shortcuts as
         `conversation <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
         related.

   .. rubric:: Testing Conversation Notifications and shortcuts
      :name: testing

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/conversations-testing.png
      :alt: Long-pressing on a conversation opens a menu of conversation-related
      actions.
      :figclass: screenshot

      **Figure 3**: You can verify that a conversation notification is properly
      configured by long-pressing on it and checking that the conversation menu
      appears.

   If you follow the conversation space `guidelines <#api-notifications>`__,
   conversations should automatically appear in the **conversation space**. You
   can verify that the shortcut is properly integrated by long-pressing on the
   notification. If the integration is done properly, the UI shows
   conversation-related actions. If the notification isn't linked to a shortcut,
   the UI shows text stating that the app doesn't support conversation features.

   `Added shortcuts <#api-shortcuts>`__ display on a long-press on the app
   launcher. Be sure to test that the shortcuts take you to the correct place
   within your app.

   `Added sharing shortcuts <#>`__ are
   shown in the sharesheet's direct share row when sharing content that your
   sharing shortcut can receive.

   .. rubric:: Conversation Widgets
      :name: conversation-widgets

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/conversation-widgets.png
      :alt: Conversations displayed in Conversation widgets
      :figclass: screenshot

      **Figure 1**: Conversations displayed in Conversation widgets.

   In Android 12, the Conversation Widget feature builds on the people and
   conversations feature `introduced in Android 11 <#>`__ by allowing apps to display
   conversation status in Conversation widgets.

   Conversation widgets promote user interaction by allowing them to easily open
   chats on the home screen. These widgets are enhanced shortcuts that allow
   users to efficiently get back to their conversations while showing snippets
   of their conversation status or other relevant information.

   .. rubric:: Validate that your app supports conversation widgets
      :name: validate-convo-widgets

   To validate that your app supports conversation widgets, you need to have at
   least two Android devices (both running Android 12) and two user accounts
   (one on each device) to exchange messages. For the purposes of this
   procedure, we’ll call the accounts “user A” and “user B.”

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/widget-picker-conversation.png
      :alt: Widget picker UI to add a new conversation widget
      :figclass: screenshot

      **Figure 2**: Widget picker UI to add a new conversation widget.

   Complete the following steps:

   #. On user A’s device, long-press on the launcher. In the widget picker, tap
      a new widget for a conversation as shown in figure 2.
   #. Drag the widget to the home screen. A list of active or recent
      conversations from user A’s app should be selectable.
   #. Now, on user B’s device, send a test message to user A.
   #. Back on user A’s device, verify that the widget is updated to reflect the
      notification of the message from user B.
   #. Optional: have both user A and user B set the conversation to different
      status values to ensure that their widgets properly reflect them. For a
      list of status values, see
      `ConversationStatus <#>`__.


Last updated 2024-05-03 UTC.


/Use bubbles for conversations
==============================

.. https://developer.android.google.cn/develop/ui/views/notifications/bubbles?hl=en

.. container:: devsite-article-body

   Bubbles make it easier for users to see and participate in conversations.

   .. container:: attempt-right

      **Figure 1.** A chat bubble.

   Bubbles are built into the notification system. They float on top of other
   app content and follow the user wherever they go. Users can expand bubbles to
   reveal app functionality and information, and they can collapse them when
   they're not using them.

   When the device is locked, or the always-on-display is active, bubbles appear
   as notifications normally do.

   Bubbles are an opt-out feature. When an app presents its first bubble, a
   permission dialog offers two choices:

   -  Block all bubbles from your app. Notifications aren't blocked, but they
      never appear as bubbles.
   -  Allow all bubbles from your app. All notifications sent with
      ``BubbleMetaData`` appear as bubbles.

   .. container::

   .. rubric:: The bubble API
      :name: bubble-api

   Bubbles are created via the notification API, so send your notification as
   normal. If you want your notification to display as a bubble, attach extra
   data to it.

   The expanded view of a bubble is created from an activity that you choose.
   Configure the activity to display properly as a bubble. The activity must be
   `resizeable <#resizeableActivity>`__
   and `embedded <#embedded>`__. If it
   lacks either of these requirements, it displays as a notification instead.

   The following code demonstrates how to implement a simple bubble:

   .. code:: prettyprint

      <activity
        android:name=".bubbles.BubbleActivity"
        android:theme="@style/AppTheme.NoActionBar"
        android:label="@string/title_activity_bubble"
        android:allowEmbedded="true"
        android:resizeableActivity="true"
      />

   If your app shows multiple bubbles of the same type, like multiple chat
   conversations with different contacts, the activity must be able to launch
   multiple instances. On devices running Android 10 and lower, notifications
   aren't shown as bubbles unless you explicitly set
   `documentLaunchMode <#dlmode>`__
   to ``"always"``. Beginning with Android 11, you don't need to explicitly set
   this value, as the system automatically sets all conversations'
   ``documentLaunchMode`` to ``"always"``.

   To send a bubble, follow these steps:

   #. `Create a notification <#>`__ as
      you normally do.
   #. Call
      `BubbleMetadata.Builder(PendingIntent, Icon) <#android.app.Notification.BubbleMetadata.Builder>`__
      or
      `BubbleMetadata.Builder(String) <#android.app.Notification.BubbleMetadata.Builder>`__
      to create a ``BubbleMetadata`` object.
   #. Use
      `setBubbleMetadata() <#android.app.Notification.Builder>`__
      to add the metadata to the notification.
   #. If targeting Android 11 or higher, make sure the bubble metadata or
      notification references a sharing shortcut.

   These steps are shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a bubble intent.
               val target = Intent(context, BubbleActivity::class.java)
               val bubbleIntent = PendingIntent.getActivity(context, 0, target, 0 /* flags */)
               val category = "com.example.category.IMG_SHARE_TARGET"

               val chatPartner = Person.Builder()
                   .setName("Chat partner")
                   .setImportant(true)
                   .build()

               // Create a sharing shortcut.
               val shortcutId = generateShortcutId()
               val shortcut =
                  ShortcutInfo.Builder(mContext, shortcutId)
                      .setCategories(setOf(category))
                      .setIntent(Intent(Intent.ACTION_DEFAULT))
                      .setLongLived(true)
                      .setShortLabel(chatPartner.name)
                      .build()

               // Create a bubble metadata.
               val bubbleData = Notification.BubbleMetadata.Builder(bubbleIntent,
                           Icon.createWithResource(context, R.drawable.icon))
                   .setDesiredHeight(600)
                   .build()

               // Create a notification, referencing the sharing shortcut.
               val builder = Notification.Builder(context, CHANNEL_ID)
                   .setContentIntent(contentIntent)
                   .setSmallIcon(smallIcon)
                   .setBubbleMetadata(bubbleData)
                   .setShortcutId(shortcutId)
                   .addPerson(chatPartner)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a bubble intent.
               Intent target = new Intent(mContext, BubbleActivity.class);
               PendingIntent bubbleIntent =
                   PendingIntent.getActivity(mContext, 0, target, 0 /* flags */);

               private val CATEGORY_TEXT_SHARE_TARGET =
                   "com.example.category.IMG_SHARE_TARGET"

               Person chatPartner = new Person.Builder()
                       .setName("Chat partner")
                       .setImportant(true)
                       .build();

               // Create a sharing shortcut.
               private String shortcutId = generateShortcutId();
               ShortcutInfo shortcut =
                  new ShortcutInfo.Builder(mContext, shortcutId)
                      .setCategories(Collections.singleton(CATEGORY_TEXT_SHARE_TARGET))
                      .setIntent(Intent(Intent.ACTION_DEFAULT))
                      .setLongLived(true)
                      .setShortLabel(chatPartner.getName())
                      .build();

               // Create a bubble metadata.
               Notification.BubbleMetadata bubbleData =
                   new Notification.BubbleMetadata.Builder(bubbleIntent,
                           Icon.createWithResource(context, R.drawable.icon))
                       .setDesiredHeight(600)
                       .build();

               // Create a notification, referencing the sharing shortcut.
               Notification.Builder builder =
                   new Notification.Builder(mContext, CHANNEL_ID)
                       .setContentIntent(contentIntent)
                       .setSmallIcon(smallIcon)
                       .setBubbleMetadata(bubbleData)
                       .setShortcutId(shortcutId)
                       .addPerson(chatPartner);

   **Note:**\  The first time you send the notification to display a bubble,
   make sure it's in a notification channel with
   `IMPORTANCE_MIN <#android.app.NotificationManager>`__
   or higher.
   If your app is in the foreground when a bubble is sent, importance is ignored
   and your bubble is always shown, unless the user blocks bubbles or
   notifications from your app.

   .. rubric:: Create an expanded bubble
      :name: expanded-bubble

   You can configure your bubble to present it in expanded state automatically.
   We recommend only using this functionality if the user performs an action
   that results in a bubble, like tapping a button to start a new chat. In this
   case, it also makes sense to suppress the initial notification sent when a
   bubble is created.

   There are methods you can use to set flags that enable these behaviors:
   `setAutoExpandBubble() <#android.app.Notification.BubbleMetadata.Builder>`__
   and
   `setSuppressNotification() <#android.app.Notification.BubbleMetadata.Builder>`__.

   The following example shows how to configure a bubble to automatically
   present in an expanded state:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val bubbleMetadata = Notification.BubbleMetadata.Builder()
                   .setDesiredHeight(600)
                   .setIntent(bubbleIntent)
                   .setAutoExpandBubble(true)
                   .setSuppressNotification(true)
                   .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification.BubbleMetadata bubbleData =
                   new Notification.BubbleMetadata.Builder()
                       .setDesiredHeight(600)
                       .setIntent(bubbleIntent)
                       .setAutoExpandBubble(true)
                       .setSuppressNotification(true)
                       .build();

   .. rubric:: Bubble content lifecycle
      :name: content-lifecycle

   When a bubble is expanded, the content activity goes through the normal
   `process lifecycle <#>`__,
   resulting in the application becoming a foreground process, if it isn't
   already.

   When the bubble is collapsed or dismissed, the activity is destroyed. This
   might result in the process being cached and later killed, depending on
   whether the app has other foreground components running.

   .. rubric:: When bubbles appear
      :name: bubbles-appear

   To reduce interruptions for the user, bubbles only appear under certain
   circumstances.

   If an app targets Android 11 or higher, a notification doesn't appear as a
   bubble unless it meets the `conversation requirements <#>`__. If an app targets
   Android 10 or lower, the notification appears as a bubble only if one or more
   of the following conditions are met:

   -  The notification uses
      `MessagingStyle <#android.app.Notification.MessagingStyle>`__
      and has a `Person <#android.app.Person>`__ added.
   -  The notification is from a call to
      `Service.startForeground <#android.app.Service>`__,
      has a
      `category <#android.app.Notification.Builder>`__
      of
      `CATEGORY_CALL <#android.app.Notification>`__,
      and has a ``Person`` added.
   -  The app is in the foreground when the notification is sent.

   If none of these conditions are met, the notification is shown instead of a
   bubble.

   .. rubric:: Best practices
      :name: best-practices

   -  Send a notification as a bubble only if it is important, such as when it
      is part of an ongoing communication or if the user explicitly requests a
      bubble for content. Bubbles use screen real estate and cover other app
      content.
   -  Make sure your bubble notification also works as a normal notification.
      When the user disables the bubble, a bubble notification is shown as a
      normal notification.
   -  Keep functionality as specific and lightweight as possible. Processes that
      launch from a bubble, such as activities and dialogs, appear within the
      bubble container. This means a bubble can have a task stack. Things can
      get complicated if there is a lot of functionality or navigation within
      your bubble.
   -  Call ``super.onBackPressed`` when overriding
      `onBackPressed <#android.app.Activity>`__ in
      the bubble activity. Otherwise, your bubble might not behave correctly.

   When a collapsed bubble receives an updated message, the bubble shows a badge
   icon to indicate an unread message. When the user opens the message in the
   associated app, follow these steps:

   -  `Update <https://developer.android.google.cn/training/notify-user/build-notification#Updating>`__
      the ``BubbleMetadata`` to suppress the notification. Call
      `BubbleMetadata.Builder.setSuppressNotification() <#android.app.Notification.BubbleMetadata.Builder>`__.
      This removes the badge icon to indicate that the user interacted with the
      message.
   -  Set
      `Notification.Builder.setOnlyAlertOnce() <#android.app.Notification.Builder>`__
      to ``true`` to suppress the sound or vibration that accompanies the
      ``BubbleMetadata`` update.

   .. rubric:: Sample app
      :name: sample

   The
   `People <https://github.com/android/user-interface-samples/tree/main/People>`__
   sample app is a simple conversation app that uses bubbles. For demonstration
   purposes, this app uses chatbots. In real-world applications, bubbles must
   only be used for messages by humans, not by bots.


Last updated 2024-05-03 UTC.


/Modify a badge
===============

.. https://developer.android.google.cn/develop/ui/views/notifications/badges?hl=en

.. container:: devsite-article-body

   Starting with Android 8.0 (API level 26), notification badges—also known as
   notification dots—appear on a launcher icon when the associated app has an
   active notification. Users can touch & hold the app icon to reveal the
   notifications, along with any `app shortcuts <#>`__,
   as shown in figure 1.

   These dots appear by default in launcher apps that support them, and there's
   nothing your app needs to do. However, there might be situations in which you
   don't want the to notification dot to appear or you want to control exactly
   which notifications appear there.

   |image-badges-open_2x|

   **Figure 1.** Notification badges and the touch & hold menu.

   .. rubric:: Disable badging
      :name: disable

   There are cases where badges don't make sense for your notifications, so you
   can disable them on a per-channel basis by calling
   `setShowBadge(false) <#android.app.NotificationChannel>`__
   on your
   `NotificationChannel <#android.app.NotificationChannel>`__
   object.

   For example, you might want to disable notification badges in the following
   situations:

   -  Ongoing notifications: most ongoing notifications, such as image
      processing, media playback controls, or current navigation instructions,
      don't make sense as a badge.
   -  Calendar reminders: avoid badging events occurring at the current time.
   -  Clock or alarm events: avoid badging notifications related to current
      alarms.

   The following sample code demonstrates how to hide badges for a notification
   channel:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val id = "my_channel_01"
               val name = getString(R.string.channel_name)
               val descriptionText = getString(R.string.channel_description)
               val importance = NotificationManager.IMPORTANCE_LOW
               val mChannel = NotificationChannel(id, name, importance).apply {
                   description = descriptionText
                   setShowBadge(false)
               }
               val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
               notificationManager.createNotificationChannel(mChannel)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               String id = "my_channel_01";
               CharSequence name = getString(R.string.channel_name);
               String description = getString(R.string.channel_description);
               int importance = NotificationManager.IMPORTANCE_LOW;
               NotificationChannel mChannel = new NotificationChannel(id, name, importance);
               mChannel.setDescription(description);
               mChannel.setShowBadge(false);

               NotificationManager notificationManager =
                       (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
               notificationManager.createNotificationChannel(mChannel);

   .. rubric:: Set custom notification count
      :name: set-custom-count

   By default, each notification increments a number displayed on the touch &
   hold menu, as shown in figure 1, but you can override this number for your
   app. For example, this might be useful if you're using just one notification
   to represent multiple new messages but want the count to represent the number
   of total new messages.

   To set a custom number, call
   `setNumber() <#androidx.core.app.NotificationCompat.Builder>`__
   on the notification, as shown here:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var notification = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
                       .setContentTitle("New Messages")
                       .setContentText("You've received 3 new messages.")
                       .setSmallIcon(R.drawable.ic_notify_status)
                       .setNumber(messageCount)
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification notification = new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                       .setContentTitle("New Messages")
                       .setContentText("You've received 3 new messages.")
                       .setSmallIcon(R.drawable.ic_notify_status)
                       .setNumber(messageCount)
                       .build();

   .. rubric:: Modify a notification's touch & hold menu icon
      :name: modify-icon

   The touch & hold menu displays the large or small icon associated with a
   notification if available. By default, the system displays the large icon,
   but you can call
   `Notification.Builder.setBadgeIconType() <#androidx.core.app.NotificationCompat.Builder>`__
   and pass in the
   `BADGE_ICON_SMALL <#androidx.core.app.NotificationCompat>`__
   constant to display the small icon.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var notification = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
                       .setContentTitle("New Messages")
                       .setContentText("You've received 3 new messages.")
                       .setSmallIcon(R.drawable.ic_notify_status)
                       .setBadgeIconType(NotificationCompat.BADGE_ICON_SMALL)
                       .build()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Notification notification = new NotificationCompat.Builder(MainActivity.this, CHANNEL_ID)
                       .setContentTitle("New Messages")
                       .setContentText("You've received 3 new messages.")
                       .setSmallIcon(R.drawable.ic_notify_status)
                       .setBadgeIconType(NotificationCompat.BADGE_ICON_SMALL)
                       .build();

   .. rubric:: Hide a duplicate shortcut
      :name: hide-duplicate-shortcut

   If your app creates a notification that duplicates an `app shortcut <#>`__, you can temporarily hide the
   shortcut while the notification is active by calling
   `setShortcutId() <#androidx.core.app.NotificationCompat.Builder>`__.

   For more sample code that uses notifications, see the `People sample <https://github.com/android/user-interface-samples/tree/main/People>`__.


Last updated 2024-02-22 UTC.

.. |image-badges-open_2x| image:: https://developer.android.google.cn/static/images/ui/notifications/badges-open_2x.png
   :width: 350px


/About pop-ups
==============

.. https://developer.android.google.cn/develop/ui/views/notifications/snackbar?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add notifications in Compose.

      `SnackBar → <https://developer.android.google.cn/jetpack/compose/layouts/material#snackbar>`__

      |image-android-compose-ui-logo|

   There are situations where you might want your app to show a quick message to
   the user, without necessarily waiting for the user to respond. For example,
   when a user performs an action like sending an email or deleting a file, your
   app shows a quick confirmation to the user. Often, the user doesn't need to
   respond to the message. The message needs to be prominent enough that the
   user can see it, but not so prominent that it prevents the user from working
   with your app.

   Android provides the
   `Snackbar <#>`__
   widget for this common use case. A ``Snackbar`` provides a quick pop-up
   message to the user. The current activity remains visible and interactive
   while the ``Snackbar`` is displayed. After a short time, the ``Snackbar``
   automatically dismisses itself.

   This documentation shows you how to use ``Snackbar`` to show pop-up messages.

   .. container:: attempt-right

      |image-snackbar_drive_2x|
      **Figure 1.** A ``Snackbar`` shows a message at the bottom of the
      activity, and the rest of the activity is still usable.

   **Note:** The ``Snackbar`` class supersedes
   `Toast <#android.widget.Toast>`__. While ``Toast`` is
   supported, ``Snackbar`` is the preferred way to display brief, transient
   messages to the user.

   .. rubric:: Additional resources
      :name: additional-resources

   `Build and display a pop-up message <#>`__
      Learn how to use a ``Snackbar`` to display a brief message to the user.
   `Add an action to a message <#>`__
      Learn how to add an action to a message, letting the user respond to the
      message.


Last updated 2024-04-15 UTC.

.. |image-snackbar_drive_2x| image:: https://developer.android.google.cn/static/images/training/snackbar/snackbar_drive_2x.png
   :width: 400px


/Build and display a pop-up message
===================================

.. https://developer.android.google.cn/develop/ui/views/notifications/snackbar/showing?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add notifications in Compose.

      `SnackBar → <https://developer.android.google.cn/jetpack/compose/layouts/material#snackbar>`__

      |image-android-compose-ui-logo|

   You can use a
   `Snackbar <#>`__
   to display a brief message to the user. Unlike
   `Notifications <#>`__, the message
   automatically goes away after a short period. A ``Snackbar`` is ideal for
   brief messages that the user doesn't need to act on. For example, an email
   app can use a ``Snackbar`` to tell the user that the app successfully sent an
   email.

   .. rubric:: Use a CoordinatorLayout
      :name: coordinator

   A ``Snackbar`` is attached to a view. The ``Snackbar`` provides basic
   functionality if it is attached to any object derived from the
   `View <#android.view.View>`__ class, such as any of the common
   layout objects. However, if the ``Snackbar`` is attached to a
   `CoordinatorLayout <#androidx.coordinatorlayout.widget.CoordinatorLayout>`__,
   the ``Snackbar`` gains additional features:

   -  The user can dismiss the ``Snackbar`` by swiping it away.
   -  The layout moves other UI elements when the ``Snackbar`` appears. For
      example, if the layout has a
      `FloatingActionButton <#>`__,
      the layout moves the button up when it shows a ``Snackbar``, instead of
      drawing the ``Snackbar`` on top of the button. You can see how this looks
      in figure 1.

   The ``CoordinatorLayout`` class provides a superset of the functionality of
   `FrameLayout <#android.widget.FrameLayout>`__. If your app
   already uses a ``FrameLayout``, you can replace that layout with a
   ``CoordinatorLayout`` to enable the full ``Snackbar`` functionality. If your
   app uses other layout objects, wrap your existing layout elements in a
   ``CoordinatorLayout``, as shown in the following example:

   .. code:: prettyprint

      <android.support.design.widget.CoordinatorLayout
          android:id="@+id/myCoordinatorLayout"
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <!-- Here are the existing layout elements, now wrapped in
               a CoordinatorLayout. -->
          <LinearLayout
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical">

              <!-- ...Toolbar, other layouts, other elements... -->

          </LinearLayout>

      </android.support.design.widget.CoordinatorLayout>

   Set an ``android:id`` tag for your ``CoordinatorLayout``. You need the
   layout's ID when you display the message.

   |image-snackbar_button_move_poster|
   **Figure 1.** The ``CoordinatorLayout`` moves the ``FloatingActionButton`` up
   when the ``Snackbar`` appears.

   .. rubric:: Display a message
      :name: display

   There are two steps to displaying a message. First, you create a ``Snackbar``
   object with the message text. Then, you call that object's
   `show() <#show()>`__
   method to display the message to the user.

   .. rubric:: Create a Snackbar object
      :name: create-snackbar

   Create a ``Snackbar`` object by calling the static
   `Snackbar.make() <#make(android.view.View,%20int,%20int)>`__
   method. When you create the ``Snackbar``, specify the message it displays and
   the length of time to show the message:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val mySnackbar = Snackbar.make(view, stringId, duration)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Snackbar mySnackbar = Snackbar.make(view, stringId, duration);

   view
      The view to attach the ``Snackbar`` to. The method searches up the view
      hierarchy from the passed view until it reaches a ``CoordinatorLayout`` or
      the window decor's content view. Ordinarily, it's simpler to pass the
      ``CoordinatorLayout`` enclosing your content.
   stringId
      The resource ID of the message you want to display. This can be formatted
      or unformatted text.
   duration
      The length of time to show the message. This can be
      `LENGTH_SHORT <#LENGTH_SHORT)>`__
      or
      `LENGTH_LONG <#LENGTH_LONG>`__.

   .. rubric:: Show the message to the user
      :name: show-snackbar

   After you create the ``Snackbar``, call its ``show()`` method to display the
   ``Snackbar`` to the user:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               mySnackbar.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               mySnackbar.show();

   The system doesn't show multiple ``Snackbar`` objects at the same time, so if
   the view is currently displaying another ``Snackbar``, the system queues your
   ``Snackbar`` and displays it after the current ``Snackbar`` expires or is
   dismissed.

   If you want to show a message to the user and don't need to call any of the
   ``Snackbar`` object's utility methods, you don't need to keep the reference
   to the ``Snackbar`` after you call ``show()``. For this reason, it's common
   to use method chaining to create and show a ``Snackbar`` in one statement:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               Snackbar.make(
                       findViewById(R.id.myCoordinatorLayout),
                       R.string.email_sent,
                       Snackbar.LENGTH_SHORT
               ).show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Snackbar.make(findViewById(R.id.myCoordinatorLayout), R.string.email_sent,
                                       Snackbar.LENGTH_SHORT)
                       .show();


Last updated 2024-04-29 UTC.

.. |image-snackbar_button_move_poster| image:: https://developer.android.google.cn/static/images/training/snackbar/snackbar_button_move_poster.png
   :width: 290px


/Add an action to a message
===========================

.. https://developer.android.google.cn/develop/ui/views/notifications/snackbar/action?hl=en

.. container:: devsite-article-body

   .. container:: android-page-banner

      Try the Compose way

      Jetpack Compose is the recommended UI toolkit for Android. Learn how
      to add notifications in Compose.

      `SnackBar → <https://developer.android.google.cn/jetpack/compose/layouts/material#snackbar>`__

      |image-android-compose-ui-logo|

   You can add an action to a
   `Snackbar <#>`__
   to let the user respond to your message. When you do this, the ``Snackbar``
   puts a button next to the message text, and the user can trigger your action
   by tapping the button. For example, an email app might put an *undo* button
   on its "email archived" message. If the user taps the *undo* button, the app
   takes the email back out of the archive.

   .. figure:: https://developer.android.google.cn/static/images/ui/notifications/action_snackbar_undo.png
      name: snackbar
      :alt: An image showing a snackbar with an UNDO action button
      :width: 50.0%

      **Figure 1.** A ``Snackbar`` with an undo action button that restores a
      removed item.

   To add an action to a ``Snackbar`` message, define a listener object that
   implements the
   `View.OnClickListener <#android.view.View.OnClickListener>`__
   interface. The system calls your listener's
   `onClick() <#android.view.View.OnClickListener>`__
   method if the user taps the message action. For example, this snippet shows a
   listener for an undo action:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyUndoListener : View.OnClickListener {

                 fun onClick(v: View) {
                   // Code to undo the user's last action.
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyUndoListener implements View.OnClickListener {

                   @Override
                   public void onClick(View v) {

                       // Code to undo the user's last action.
                   }
               }

   Use one of the
   `setAction() <#setAction(int,%20android.view.View.OnClickListener)>`__
   methods to attach the listener to your ``Snackbar``. Attach the listener
   before you call
   `show() <#show()>`__,
   as shown in this code sample:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val mySnackbar = Snackbar.make(findViewById(R.id.myCoordinatorLayout),
                                              R.string.email_archived, Snackbar.LENGTH_SHORT)
               mySnackbar.setAction(R.string.undo_string, MyUndoListener())
               mySnackbar.show()

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Snackbar mySnackbar = Snackbar.make(findViewById(R.id.myCoordinatorLayout),
                       R.string.email_archived, Snackbar.LENGTH_SHORT);
               mySnackbar.setAction(R.string.undo_string, new MyUndoListener());
               mySnackbar.show();

   If you are using `Jetpack Compose <#>`__, you can show a
   `SnackbarHost <#SnackbarHost(androidx.compose.material.SnackbarHostState,androidx.compose.ui.Modifier,kotlin.Function1)>`__,
   as shown in the following example:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   override fun onCreate(savedInstanceState: Bundle?) {

                     super.onCreate(savedInstanceState)

                     setContent {
                         DACPlaygroundTheme {
                             val snackbarHostState = remember { SnackbarHostState() }
                             val scope = rememberCoroutineScope()
                             Scaffold(
                                 snackbarHost = { SnackbarHost(snackbarHostState) },
                                 content = { padding ->
                                     Button(
                                         modifier = Modifier.padding(padding),
                                         onClick = {
                                             scope.launch {
                                                 snackbarHostState.showSnackbar(
                                                     message = "1 item removed",
                                                     actionLabel = "UNDO",
                                                     duration = SnackbarDuration.Short
                                                 ).run {
                                                     when (this) {
                                                         Dismissed -> Log.d("SNACKBAR", "Dismissed")
                                                         ActionPerformed -> Log.d("SNACKBAR", "UNDO CLICKED")
                                                     }
                                                 }
                                             }
                                         }
                                     ) { Text("Show snackbar") }
                                 }
                             )
                         }
                     }
                 }
                 

   **Note:** A ``Snackbar`` automatically goes away after a short time, so the
   user might not see the message or have a chance to tap the button. For this
   reason, offer other ways to perform ``Snackbar`` actions.


Last updated 2024-04-15 UTC.



/Use adaptive launcher icons
============================

.. https://developer.android.google.cn/develop/ui/views/launch/icon_design_adaptive?hl=en

.. container:: devsite-article-body

   |image-article_icons_header|

   An adaptive icon, or
   `AdaptiveIconDrawable <#android.graphics.drawable.AdaptiveIconDrawable>`__,
   can display differently depending on individual device capabilities and user
   theming. Adaptive icons are primarily used by the launcher on the home
   screen, but they can also be used in shortcuts, the Settings app, sharing
   dialogs, and the overview screen.

   An adaptive icon can adapt to different use cases:

   -  **Different shapes:** an adaptive icon can display a variety of shapes
      across different device models. For example, it can display a circular
      shape on one OEM device, and display a squircle (a shape between a square
      and a circle) on another device. Each device OEM must provide a mask,
      which the system uses to render all adaptive icons with the same shape.

      .. figure::
         https://developer.android.google.cn/static/guide/practices/ui_guidelines/images/article_icon_adaptive.gif
         name: different-shapes
         :alt: A gif showing a repeating animation of the same sample Android
         icon, showing different shapes depending on the mask used—a circle and
         then two different kinds of squircles
         :width: 40.0%

         **Figure 1.** Adaptive icons support a variety of masks, which vary
         from one device to another.

   -  **Visual effects:** an adaptive icon supports a variety of engaging visual
      effects, which display when users place or move the icon around the home
      screen.

      .. figure::
         https://developer.android.google.cn/static/guide/practices/ui_guidelines/images/article_icon_effect.gif
         name: visual-effects
         :alt: A gif showing examples of two circle-shaped Android sample icons,
         animated to show user response. The first icon shows the Android logo
         wobbling left then right, then up and down inside the circle. The
         second icon expands and then contracts again.
         :width: 40.0%

         **Figure 2.** Examples of visual effects displayed by an adaptive icon.

      **Note:**\  Animated visual effects are generated by supported launchers.
      Visual effects might vary from one launcher to another.

   -  **User theming:** starting with Android 13 (API level 33), users can theme
      their adaptive icons. If a user enables themed app icons, by turning on
      the **Themed icons** toggle in system settings, and the launcher supports
      this feature, the system uses the coloring of the user's chosen wallpaper
      and theme to determine the tint color.

      .. figure::
         https://developer.android.google.cn/static/guide/practices/ui_guidelines/images/adaptive-icon-themed-icons.png
         name: adaptive-icons
         :alt: An image showing examples of three Android devices, each one
         showing a different user theme with different tints: the first shows a
         wallpaper with dark tinting; the second shows a golden-tinted
         wallpaper; the third shows a wallpaper with light grey with bluish
         tints wallpaper. In each example, the icons have inherited the tinting
         of the wallpaper and blend in perfectly.
         :width: 100.0%

         **Figure 3.** Adaptive icons inheriting from the user's wallpaper and
         themes.

   In the following scenarios, the home screen doesn't display the themed app
   icon, and instead displays the adaptive or standard app icon:

   -  If the user doesn't enable themed app icons.
   -  If your app doesn't provide a monochromatic app icon.
   -  If the launcher doesn't support themed app icons.

   .. rubric:: Design adaptive icons
      :name: design-adaptive-icons

   To ensure that your adaptive icon supports different shapes, visual effects,
   and user theming, the design must meet the following requirements:

   -  You must provide two layers for the color version of the icon: one for the
      foreground, and one for the background.

      .. figure::
         https://developer.android.google.cn/static/guide/practices/ui_guidelines/images/adaptive-icon-foreground-background.png
         name: adaptive-icons-2
         :alt: An image showing an example of a foreground layer (left image)
         and a background layer (right image). The foreground shows the 16-sided
         icon of a sample Android logo centered within a 66x66 safe zone. The
         safe zone is centered inside of a 108x108 container. The background
         shows the same measured dimensions for the safe zone and the container,
         but only a blue background and no logo.
         :width: 100.0%

         **Figure 4.** Adaptive icons defined using foreground and background
         layers. The 66x66 *safe zone* depicted is the area that is never
         clipped by a shaped mask defined by an OEM.

      .. figure::
         https://developer.android.google.cn/static/guide/practices/ui_guidelines/images/adaptive-icon-mask-applied.png
         name: circular-mask
         :alt: An image showing the icon from the preceding image overlaid on a
         circular mask.
         :width: 40.0%

         **Figure 5.** An example of how foreground and background layers look
         together with a circular mask applied.

   -  If you want to support user theming of app icons, provide a single layer
      for the monochrome version of the icon.

      .. figure::
         https://developer.android.google.cn/static/guide/practices/ui_guidelines/images/adaptive-icon-monochrome.png
         name: monochrome
         :alt: An image showing an example of a monochromatic icon layer (left
         image) and color previews (right image). The monochromatic layer shows
         the 16-sided icon of a sample Android logo centered within a 66x66 safe
         zone. The safe zone is centered inside of a 108x108 container. The
         color previews show this layer display when applied to differently
         colored user themes (orange, pink, yellow, and green).
         :width: 100.0%

         **Figure 6.** A monochromatic icon layer (left) with examples of color
         previews (right).

   -  Size all layers to 108x108 dp.

   -  Use icons with clean edges. The layers must not have masks or background
      shadows around the outline of the icon.

   -  Use a logo that's at least 48x48 dp. It must not exceed 66x66 dp, because
      the inner 66x66 dp of the icon appears within the masked viewport.

   The outer 18 dp on each of the four sides of the layers is reserved for
   masking and to create visual effects such as parallax or pulsing.

   **Caution:**\  If you don't update your launcher icon with the necessary
   layers, the icon neither looks consistent with other icons displayed by the
   system nor supports visual effects.
   To learn how to create adaptive icons using Android Studio, see our `Android
   App icon Figma template <https://www.figma.com/community/file/1131374111452281708>`__ or
   `Android Studio documentation for creating launcher icons <#create-adaptive>`__. Also, check out
   the blog post `Designing Adaptive Icons <https://medium.com/google-design/designing-adaptive-icons-515af294c783>`__
   .

   .. rubric:: Add your adaptive icon to your app
      :name: add-to-your-app

   To add an adaptive icon to your app, update the ``android:icon`` attribute in
   your app manifest to specify a drawable resource. You can also define an icon
   drawable resource using the ``android:roundIcon`` attribute, but only if you
   require a different icon asset for circular masks—for example, if your
   branding relies on a circular shape.

   The following code snippet illustrates both of these attributes, but most
   apps only specify ``android:icon``:

   .. code:: prettyprint

      <application
          ...
          android:icon="@mipmap/ic_launcher"
          android:roundIcon="@mipmap/ic_launcher_round"
          ...>
      </application>

   Next, in ``res/mipmap-anydpi-v26/ic_launcher.xml``, create alternative
   drawable resources in your app for backward compatibility with Android 8.0
   (API level 26). Use the ``<adaptive-icon>`` element to define the foreground,
   background, and monochromatic layer drawables for your icons. The
   ``<foreground>``, ``<background>``, and ``<monochrome>`` inner elements
   support the ``android:drawable`` attribute.

   The following example shows how to define ``<foreground>``, ``<background>``,
   and ``<monochrome>`` elements inside ``<adaptive-icon>``:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      ...
      <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
          <background android:drawable="@drawable/ic_launcher_background" />
          <foreground android:drawable="@drawable/ic_launcher_foreground" />

          // Starting with Android 13 (API level 33), you can opt-in to providing a
          // <monochrome> drawable.
          <monochrome android:drawable="@drawable/ic_launcher_monochrome" />
      </adaptive-icon>
      ...

   You can also define drawables as elements by enclosing them in the
   ``<foreground>``, ``<background>``, and ``<monochrome>`` elements. The
   following snippet shows an example of doing this with the foreground
   drawable.

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      ...
      <foreground>
         <inset
             android:insetBottom="18dp"
             android:insetLeft="18dp"
             android:insetRight="18dp"
             android:insetTop="18dp">
             <shape android:shape="oval">
                 <solid android:color="#0000FF" />
             </shape>
         </inset>
      </foreground>
      ...

   If you want to apply the same mask and visual effect to your shortcuts as
   regular adaptive icons, use one of the following techniques:

   -  For static shortcuts, use the ``<adaptive-icon>`` element.
   -  For dynamic shortcuts, call the
      `createWithAdaptiveBitmap() <#android.graphics.drawable.Icon>`__
      method when you create them.

   For more information about implementing adaptive icons, see `Implementing
   Adaptive Icons <https://medium.com/google-developers/implementing-adaptive-icons-1e4d1795470e>`__.
   For more information about shortcuts, see `App shortcuts overview <#>`__.

   .. rubric:: Additional resources
      :name: additional_resources

   .. container:: video-wrapper

   See the following resources for additional information about designing and
   implementing adaptive icons.

   -  `Figma community page template <https://www.figma.com/community/file/1131374111452281708>`__
   -  `Understanding Android Adaptive Icons <https://medium.com/google-design/understanding-android-adaptive-icons-cee8a9de93e2>`__
   -  `Designing Adaptive Icons <https://medium.com/google-design/designing-adaptive-icons-515af294c783>`__
   -  `Implementing Adaptive Icons <https://medium.com/google-developers/implementing-adaptive-icons-1e4d1795470e>`__
   -  `Create app icons in Android Studio <#create-adaptive>`__
   -  `Google Play icon design specifications <#>`__


Last updated 2024-02-22 UTC.

.. |image-article_icons_header| image:: https://developer.android.google.cn/static/guide/practices/ui_guidelines/images/article_icons_header.png


/Add a splash screen to a new app
=================================

.. https://developer.android.google.cn/develop/ui/views/launch/splash-screen?hl=en

.. container:: devsite-article-body

   **Important:**\  If you implemented a custom splash screen in Android 11 or
   lower, migrate your app to the
   `SplashScreen <#android.window.SplashScreen>`__ API to ensure
   it displays correctly in Android 12 and higher. For instructions, see
   `Migrate your existing splash screen implementation to Android 12 <#>`__.
   Starting in Android 12, the
   `SplashScreen <#android.window.SplashScreen>`__ API lets apps
   launch with animation, including an into-app motion at launch, a splash
   screen showing your app icon, and a transition to your app itself. A
   ``SplashScreen`` is a `Window <#android.view.Window>`__ and
   therefore covers an `Activity <#android.app.Activity>`__.

   .. container:: float
      :name: example-1

   The splash screen experience brings standard design elements to every app
   launch, but it's also customizable so your app can maintain its unique
   branding.

   In addition to using the ``SplashScreen`` platform API, you can also use the
   `SplashScreen <#>`__
   compat library, which wraps the ``SplashScreen`` API.

   .. rubric:: How the splash screen works
      :name: how

   When a user launches an app while the app's process isn't running (a `cold start <#cold>`__) or the ``Activity``
   isn't created (a `warm start <#warm>`__), the following events
   occur:

   #. The system shows the splash screen using themes and any animations that
      you define.

   #. When the app is ready, the splash screen is dismissed and the app
      displays.

   The splash screen never shows during a `hot start <https://developer.android.google.cn/topic/performance/vitals/launch-time#hot>`__.

   .. rubric:: Elements and mechanics of the splash screen
      :name: elements

   The elements of the splash screen are defined by XML resource files in the
   Android manifest file. There are light and dark mode versions for each
   element.

   The customizable elements of a splash screen consist of the app icon, icon
   background, and window background:

   .. figure::
      https://developer.android.google.cn/static/images/guide/topics/ui/splash-screen/splash-screen-composition.png
      name: elements
      :alt: An image showing the elements contained in a splash screen
      :width: 100.0%

      **Figure 2.** Customizable elements of a splash screen.

   Consider the following elements, shown in figure 2:

   1 The **app icon** must be a vector drawable. It can be static or animated.
   Although animations can have an unlimited duration, we recommend not
   exceeding 1,000 milliseconds. The launcher icon is the default.

   2 The **icon background** is optional and useful if you need more contrast
   between the icon and the window background. If you use an `adaptive icon <#>`__, its background
   is displayed if there is enough contrast with the window background.

   3 As with adaptive icons, one-third of the foreground is masked.

   4 The **window background** consists of a single opaque color. If the window
   background is set and is a plain color, it is used by default if the
   attribute isn't set.

   .. rubric:: Splash screen dimensions
      :name: dimensions

   The splash screen icon uses the same specifications as `adaptive icons <https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive>`__,
   as follows:

   -  Branded image: this must be 200×80 dp.
   -  App icon with an icon background: this must be 240×240 dp and fit within a
      circle 160 dp in diameter.
   -  App icon without an icon background: this must be 288×288 dp and fit
      within a circle 192 dp in diameter.

   For example, if the full size of an image is 300×300 dp, the icon needs to
   fit within a circle with a diameter of 200 dp. Everything outside the circle
   turns invisible (masked).

   .. figure::
      https://developer.android.google.cn/static/images/guide/topics/ui/splash-screen/splash-screen-icon-dimensions.png
      name: dimensions
      :alt: An image showing different icon dimensions for solid and transparent
      background
      :width: 80.0%

      **Figure 3.** Splash screen icon dimensions for solid and transparent
      backgrounds, respectively.

   .. rubric:: Splash screen animations and the launch sequence
      :name: launch

   Additional latency is often associated with launching an app on a cold start.
   Adding an animated icon to your splash screen has obvious aesthetic appeal
   and provides a more premium experience. User research shows that perceived
   startup time is less when viewing an animation.

   A splash screen animation is embedded within the launch sequence components,
   as shown in figure 4.

   .. figure:: https://developer.android.google.cn/static/images/ui/splash-sequence.png
      name: launch-sequence
      :alt: An image showing the launch sequence in twelve consecutive frames,
      beginning with the launcher icon being tapped and filling the screen as it
      enlarges
      :width: 100.0%

      **Figure 4.** Launch sequence.

   #. Enter animation: this consists of the system view to the splash screen. It
      is controlled by the system and isn't customizable.

   #. Splash screen (shown during the "wait" portion of the sequence): the
      splash screen can be customized, letting you supply your own logo
      animation and branding. It must meet the
      `requirements <#splash-screen-animate-reqs>`__ described in this page to
      work properly.

   #. Exit animation: this consists of the animation that hides the splash
      screen. If you want to `customize it <#customize-animation>`__, use the
      `SplashScreenView <#android.window.SplashScreenView>`__ and
      its icon. You can run any animation on them, with settings for transform,
      opacity, and color. In this case, manually remove the splash screen when
      the animation is done.

   When running the icon animation, app launch gives you the option to skip the
   sequence in cases where the app is ready earlier. The app triggers
   ``onResume()`` or the splash screen times out automatically, so make sure the
   motion can be comfortably skipped. The splash screen must only be dismissed
   with ``onResume()`` when the app is stable from a visual standpoint, so no
   additional spinners are needed. Introducing an incomplete interface can be
   jarring for users and might give an impression of unpredictability or lack of
   polish.

   .. rubric:: Splash screen animation requirements
      :name: splash-screen-animate-reqs

   Your splash screen must adhere to the following specifications:

   -  Set a single window background color with no transparency. Day and Night
      mode are supported with the `SplashScreen compat library <#>`__.

   -  Make sure the animated icon meets the following specifications:

      -  **Format:** the icon must be an `AnimatedVectorDrawable (AVD) <#android.graphics.drawable.AnimatedVectorDrawable>`__
         XML.
      -  **Dimensions:** an AVD icon must be four times the size of an adaptive
         icon, as follows:

         -  The icon area must be 432 dp—in other words, four times the 108 dp
            area of an unmasked adaptive icon.
         -  The inner two-thirds of the image is visible on the launcher icon,
            and must be 288 dp—in other words, four times the 72 dp that makes
            up the inner masked area of an adaptive icon.

      -  **Duration:** we recommend not exceeding 1,000 ms on phones. You can
         use a delayed start, but this can't be longer than 166 ms. If the app
         startup time is longer than 1,000 ms, consider a looping animation.

   -  Establish an appropriate time to dismiss the splash screen, which happens
      as your app draws its first frame. You can further customize this as
      described in the section about `keeping the splash screen on-screen for longer periods <#suspend-drawing>`__.

   .. rubric:: Splash screen resources
      :name: splash-screen-resources

   .. container:: float
      :name: avd

   Download the
   ` <#>`__\ example starter
   kit, which demonstrates how to create, format, and export an animation into
   an AVD. It includes the following:

   -  Adobe After Effects project file of the animation.
   -  Final exported AVD XML file.
   -  Example GIF of the animation.

   By downloading these files, you agree to the `Google Terms of Service <https://policies.google.com/terms>`__.

   The `Google Privacy Policy <https://policies.google.com/privacy>`__ describes
   how data is handled in this service.

   .. rubric:: Customize the splash screen in your app
      :name: implement
      :class: hide-from-toc

   By default, ``SplashScreen`` uses the ``windowBackground`` of your theme if
   ``windowBackground`` is a single color. To customize the splash screen, add
   attributes to the app theme.

   You can customize your app's splash screen by doing any of the following:

   -  Set theme attributes to change its appearance.

   -  Keep it on-screen for a longer period.

   -  Customize the animation for dismissing the splash screen.

   .. rubric:: Get started
      :name: getting-started
      :class: hide-from-toc

   The core ``SplashScreen`` library brings the Android 12 splash screen to all
   devices from API 23. To add it to your project, add the following snippet to
   your ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.core:core-splashscreen:1.0.0"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.core:core-splashscreen:1.0.0")
               }

   .. rubric:: Set a theme for the splash screen to change its appearance
      :name: set-theme
      :class: hide-from-toc

   You can specify the following attributes in your ``Activity`` theme to
   customize the splash screen for your app. If you already have a legacy splash
   screen implementation that uses attributes like ``android:windowBackground``,
   consider providing an alternate resource file for Android 12 and higher.

   #. Use
      `windowSplashScreenBackground <#android.R.attr>`__
      to fill the background with a specific single color:

      .. code:: prettyprint

         <item name="android:windowSplashScreenBackground">@color/...</item>

   #. Use
      `windowSplashScreenAnimatedIcon <#android.R.attr>`__
      to replace the icon in the center of the starting window.

      For apps targeting Android 12 (API level 32) only, do the following:

      If the object is animatable and drawable through
      `AnimationDrawable <#android.graphics.drawable.AnimationDrawable>`__
      and ``AnimatedVectorDrawable``, set
      ``windowSplashScreenAnimationDuration`` to play the animation while
      showing the starting window. This isn't required for Android 13, because
      the duration is directly inferred from the ``AnimatedVectorDrawable``.

      .. code:: prettyprint

         <item name="android:windowSplashScreenAnimatedIcon">@drawable/...</item>

   #. Use
      `windowSplashScreenAnimationDuration <#android.R.attr>`__
      to indicate the duration of the splash screen icon animation. Setting this
      doesn't have any effect on the actual time during which the splash screen
      is shown, but you can retrieve it when customizing the splash screen exit
      animation using
      `SplashScreenView.getIconAnimationDuration <#android.window.SplashScreenView>`__.
      See the following section about `keeping the splash screen on-screen for longer periods <#suspend-drawing>`__ for more details.

      .. code:: prettyprint

         <item name="android:windowSplashScreenAnimationDuration">1000</item>

   #. Use
      `windowSplashScreenIconBackgroundColor <#android.R.attr>`__
      to set a background behind the splash screen icon. This is useful if there
      isn't enough contrast between the window background and the icon.

      .. code:: prettyprint

         <item name="android:windowSplashScreenIconBackgroundColor">@color/...</item>

   #. You can use
      `windowSplashScreenBrandingImage <#android.R.attr>`__
      to set an image to be shown at the bottom of the splash screen. However,
      the design guidelines recommend against using a branding image.

      .. code:: prettyprint

         <item name="android:windowSplashScreenBrandingImage">@drawable/...</item>

   #. You can use
      `windowSplashScreenBehavior <#android.R.attr>`__
      to specify whether your app always displays the icon on the splash screen
      in Android 13 and higher. The default value is 0, which displays the icon
      on the splash screen if the launching activity sets the
      ``splashScreenStyle`` to
      `SPLASH_SCREEN_STYLE_ICON <#android.window.SplashScreen>`__,
      or follows the system behavior if the launching activity doesn't specify a
      style. If you prefer to never display an empty splash screen and always
      want the animated icon to be displayed, set this to the value
      ``icon_preferred``.

      .. code:: prettyprint

         <item name="android:windowSplashScreenBehavior">icon_preferred</item>

   .. rubric:: Keep the splash screen on-screen for longer periods
      :name: suspend-drawing
      :class: hide-from-toc

   The splash screen is dismissed as soon as your app draws its first frame. If
   you need to load a small amount of data, such as loading in-app settings from
   a local disk asynchronously, you can use
   `ViewTreeObserver.OnPreDrawListener <#android.view.ViewTreeObserver.OnPreDrawListener>`__
   to suspend the app to draw its first frame.

   If your starting activity finishes before drawing—for example, by not setting
   the content view and finishing before ``onResume``—the pre-draw listener
   isn't needed.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Create a new event for the activity.
               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   // Set the layout for the content view.
                   setContentView(R.layout.main_activity)

                   // Set up an OnPreDrawListener to the root view.
                   val content: View = findViewById(android.R.id.content)
                   content.viewTreeObserver.addOnPreDrawListener(
                       object : ViewTreeObserver.OnPreDrawListener {
                           override fun onPreDraw(): Boolean {
                               // Check whether the initial data is ready.
                               return if (viewModel.isReady) {
                                   // The content is ready. Start drawing.
                                   content.viewTreeObserver.removeOnPreDrawListener(this)
                                   true
                               } else {
                                   // The content isn't ready. Suspend.
                                   false
                               }
                           }
                       }
                   )
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Create a new event for the activity.
               @Override
               protected void onCreate(@Nullable Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   // Set the layout for the content view.
                   setContentView(R.layout.main_activity);

                   // Set up an OnPreDrawListener to the root view.
                   final View content = findViewById(android.R.id.content);
                   content.getViewTreeObserver().addOnPreDrawListener(
                           new ViewTreeObserver.OnPreDrawListener() {
                               @Override
                               public boolean onPreDraw() {
                                   // Check whether the initial data is ready.
                                   if (mViewModel.isReady()) {
                                       // The content is ready. Start drawing.
                                       content.getViewTreeObserver().removeOnPreDrawListener(this);
                                       return true;
                                   } else {
                                       // The content isn't ready. Suspend.
                                       return false;
                                   }
                               }
                           });
               }

   .. rubric:: Customize the animation for dismissing the splash screen
      :name: customize-animation
      :class: hide-from-toc

   You can further customize the animation of the splash screen through
   `Activity.getSplashScreen() <#android.app.Activity>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   super.onCreate(savedInstanceState)
                   // ...

                   // Add a callback that's called when the splash screen is animating to the
                   // app content.
                   splashScreen.setOnExitAnimationListener { splashScreenView ->
                       // Create your custom animation.
                       val slideUp = ObjectAnimator.ofFloat(
                           splashScreenView,
                           View.TRANSLATION_Y,
                           0f,
                           -splashScreenView.height.toFloat()
                       )
                       slideUp.interpolator = AnticipateInterpolator()
                       slideUp.duration = 200L

                       // Call SplashScreenView.remove at the end of your custom animation.
                       slideUp.doOnEnd { splashScreenView.remove() }

                       // Run your animation.
                       slideUp.start()
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               protected void onCreate(@Nullable Bundle savedInstanceState) {
                   super.onCreate(savedInstanceState);
                   // ...

                   // Add a callback that's called when the splash screen is animating to the
                   // app content.
                   getSplashScreen().setOnExitAnimationListener(splashScreenView -> {
                       final ObjectAnimator slideUp = ObjectAnimator.ofFloat(
                               splashScreenView,
                               View.TRANSLATION_Y,
                               0f,
                               -splashScreenView.getHeight()
                       );
                       slideUp.setInterpolator(new AnticipateInterpolator());
                       slideUp.setDuration(200L);

                       // Call SplashScreenView.remove at the end of your custom animation.
                       slideUp.addListener(new AnimatorListenerAdapter() {
                           @Override
                           public void onAnimationEnd(Animator animation) {
                               splashScreenView.remove();
                           }
                       });

                       // Run your animation.
                       slideUp.start();
                   });
               }

   By the start of this callback, the `animated vector drawable <#android.graphics.drawable.AnimatedVectorDrawable>`__ on
   the splash screen starts. Depending on the duration of the app launch, the
   drawable might be in the middle of its animation. Use
   `SplashScreenView.getIconAnimationStart <#android.window.SplashScreenView>`__
   to know when the animation started. You can calculate the remaining duration
   of the icon animation as follows:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Get the duration of the animated vector drawable.
               val animationDuration = splashScreenView.iconAnimationDuration
               // Get the start time of the animation.
               val animationStart = splashScreenView.iconAnimationStart
               // Calculate the remaining duration of the animation.
               val remainingDuration = if (animationDuration != null && animationStart != null) {
                   (animationDuration - Duration.between(animationStart, Instant.now()))
                       .toMillis()
                       .coerceAtLeast(0L)
               } else {
                   0L
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Get the duration of the animated vector drawable.
               Duration animationDuration = splashScreenView.getIconAnimationDuration();
               // Get the start time of the animation.
               Instant animationStart = splashScreenView.getIconAnimationStart();
               // Calculate the remaining duration of the animation.
               long remainingDuration;
               if (animationDuration != null && animationStart != null) {
                   remainingDuration = animationDuration.minus(
                           Duration.between(animationStart, Instant.now())
                   ).toMillis();
                   remainingDuration = Math.max(remainingDuration, 0L);
               } else {
                   remainingDuration = 0L;
               }

   .. rubric:: Additional resources
      :name: additional-resources

   -  `Migrate your existing splash screen implementation to Android 12 and higher <#>`__
   -  `Now in Android <https://github.com/android/nowinandroid>`__ app, which
      shows a real-world implementation of a splash screen


Last updated 2024-05-03 UTC.


/Migrate an existing splash screen to the new API
=================================================

.. https://developer.android.google.cn/develop/ui/views/launch/splash-screen/migrate?hl=en

.. container:: devsite-article-body

   If you implement a custom splash screen in Android 11 or earlier, migrate
   your app to the `SplashScreen <#android.window.SplashScreen>`__
   API to help ensure it displays correctly in Android 12 and later.

   Starting in Android 12, the system applies the `Android system default splash screen <#>`__ on
   `cold <#cold>`__ and `warm starts <#warm>`__ for all apps. By
   default, this system splash screen is constructed using your app's launcher
   icon element and the
   `windowBackground <#android.R.attr>`__ of your
   theme, if it's a single color.

   If you don't migrate your app, your app launch experience on Android 12 and
   later might be degraded or have unintended results.

   -  If your existing splash screen is implemented using a `custom theme that
      overrides ``android:windowBackground`` <#set-theme>`__,
      the system replaces your custom splash screen with a default Android
      system splash screen on Android 12 and later. This might not be your app's
      intended experience.

   -  If your existing splash screen is implemented using a dedicated
      ``Activity``, launching your app on devices running Android 12 or later
      results in duplicate splash screens: `the system splash screen <#>`__ displays, followed
      by your existing splash screen activity.

   You can prevent these degraded or unintended experiences by completing the
   migration process described in this document. After you migrate, the API
   improves startup time, gives you full control over the splash screen
   experience, and creates a more consistent launch experience with other apps
   on the platform.

   .. rubric:: SplashScreen compat library
      :name: library

   You can use the ``SplashScreen`` API directly, but we strongly recommend
   using the `Androidx ``SplashScreen`` compat
   library <#>`__
   instead. The compat library uses the ``SplashScreen`` API, enables
   backward-compatibility, and creates a consistent look and feel for splash
   screen display across all Android versions. This document is written using
   the compat library.

   If you migrate using the ``SplashScreen`` API directly, on Android 11 and
   earlier your splash screen looks exactly the same as before the migration.
   Starting on Android 12, the splash screen has the Android 12 look and feel.

   If you migrate using the ``SplashScreen`` compat library, the system displays
   the same splash screen on all versions of Android.

   .. rubric:: Migrate your splash screen implementation
      :name: migrate

   Complete the following steps to migrate your existing splash screen
   implementation to Android 12 and later.

   This procedure applies to whichever type of implementation you are migrating
   from. If you're migrating from a dedicated ``Activity``, follow the `best practices <#best-practices>`__ described on this document for adapting your
   customized splash screen ``Activity``. The ``SplashScreen`` API also reduces
   startup latency that is introduced with a dedicated splash screen activity.

   To migrate your splash screen, do the following:

   #. In the ``build.gradle`` file, `change your ``compileSdkVersion`` <#>`__ and include the
      ``SplashScreen`` compat library in dependencies.

      .. code:: prettyprint

         build.gradle

         android {
            compileSdkVersion 31
            ...
         }
         dependencies {
            ...
            implementation 'androidx.core:core-splashscreen:1.0.0-beta02'
         }

   #. Create a theme with a parent of ``Theme.SplashScreen``. Set the value of
      ``postSplashScreenTheme`` to the theme that the ``Activity`` must use and
      the value of ``windowSplashScreenAnimatedIcon`` to a drawable or animated
      drawable. The other attributes are optional.

      .. code:: prettyprint

         <style name="Theme.App.Starting" parent="Theme.SplashScreen">
            <!-- Set the splash screen background, animated icon, and animation
            duration. -->
            <item name="windowSplashScreenBackground">@color/...</item>

            <!-- Use windowSplashScreenAnimatedIcon to add a drawable or an animated
                 drawable. One of these is required. -->
            <item name="windowSplashScreenAnimatedIcon">@drawable/...</item>
            <!-- Required for animated icons. -->
            <item name="windowSplashScreenAnimationDuration">200</item>

            <!-- Set the theme of the Activity that directly follows your splash
            screen. This is required. -->
            <item name="postSplashScreenTheme">@style/Theme.App</item>
         </style>

      If you want to add a background color underneath your icon, you can use
      the ``Theme.SplashScreen.IconBackground`` theme and set the
      ``windowSplashScreenIconBackground`` attribute.

   #. In the manifest, replace the theme of the starting activity to the theme
      you create in the previous step.

      .. code:: prettyprint

         <manifest>
            <application android:theme="@style/Theme.App.Starting">
             <!-- or -->
                 <activity android:theme="@style/Theme.App.Starting">
         ...

   #. Call ``installSplashScreen`` in the starting activity before calling
      ``super.onCreate()``.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  class MainActivity : Activity() {

                     override fun onCreate(savedInstanceState: Bundle?) {
                         // Handle the splash screen transition.
                         val splashScreen = installSplashScreen()

                         super.onCreate(savedInstanceState)
                         setContentView(R.layout.main_activity)
                  ...

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  public class MainActivity extends Activity {

                      @Override
                      protected void onCreate(Bundle savedInstanceState) {
                           // Handle the splash screen transition.
                           SplashScreen splashScreen = SplashScreen.installSplashScreen(this);

                           super.onCreate(savedInstanceState);
                           setContentView(R.layout.main_activity);
                      }
                  }

   ``installSplashScreen`` returns the splash screen object, which you can
   optionally use to customize animation or to keep the splash screen on screen
   for a longer duration. For more details on customizing the animation, see
   `Keep the splash screen on-screen for longer periods <#suspend-drawing>`__ and
   `Customize the animation for dismissing the splash screen <#customize-animation>`__.

   .. rubric:: Adapt your custom splash screen Activity to the splash screen
      :name: best-practices

   After you migrate to the splash screen for Android 12 and later, decide what
   to do with your previous custom splash screen ``Activity``. You have the
   following options:

   -  Keep the custom activity, but prevent it from displaying.
   -  Keep the custom activity for branding reasons.
   -  Remove the custom activity and adapt your app as needed.

   .. rubric:: Prevent the custom Activity from being displayed
      :name: prevent

   If your previous splash screen ``Activity`` is primarily used for routing,
   consider ways to remove it. For example, you might directly link to the
   actual activity or move to a singular activity with subcomponents. If this
   isn't feasible, you can use
   `SplashScreen.setKeepOnScreenCondition <#setkeeponscreencondition>`__
   to keep the routing activity in place but stop it from rendering. Doing so
   transfers the splash screen to the next activity and supports a smooth
   transition.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                 class RoutingActivity : Activity() {

                   override fun onCreate(savedInstanceState: Bundle?) {
                       val splashScreen = installSplashScreen()
                       super.onCreate(savedInstanceState)

                       // Keep the splash screen visible for this Activity.
                       splashScreen.setKeepOnScreenCondition { true }
                       startSomeNextActivity()
                       finish()
                    }
                  ...
                 

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                 public class RoutingActivity extends Activity {

                   @Override
                   protected void onCreate(Bundle savedInstanceState) {
                     SplashScreen splashScreen = SplashScreen.installSplashScreen(this);

                      super.onCreate(savedInstanceState);

                      // Keep the splash screen visible for this Activity.
                      splashScreen.setKeepOnScreenCondition(() -> true );
                      startSomeNextActivity();
                      finish();
                   }
                 ...
                 

   .. rubric:: Keep the custom activity for branding
      :name: branding

   If you want to use a previous splash screen ``Activity`` for branding
   reasons, you can transition from the system splash screen into your custom
   splash screen ``Activity`` by `customizing the animation for dismissing the
   splash screen <#customize-animation>`__.
   However, it's best to avoid this scenario if possible and use the
   ``SplashScreen`` API to brand your splash screen.

   If you need to display a `dialog <#>`__,
   we recommend displaying it over the subsequent custom splash screen activity
   or over the main activity after the system splash screen.

   .. rubric:: Remove the custom splash screen Activity
      :name: remove

   Generally, we recommend removing your previous custom splash screen
   ``Activity`` altogether to avoid the duplication of splash screens, to
   increase efficiency, and to reduce splash screen loading times. There are
   different techniques that you can use to avoid showing redundant splash
   screen activities.

   -  **Use lazy loading for your components, modules, or libraries.** Avoid
      loading or initializing components or libraries that aren't required for
      the app to work at launch. Load them later, when the app needs them.

      If your app truly needs a component to work properly, load it only when
      it's really needed and not at launch time, or use a background thread to
      load it after the app starts. Try to keep your ``Application.onCreate()``
      as light as possible.

      You can also benefit from using the `App Startup library <#>`__ to initialize components at
      application startup. When doing so, make sure to still load all the
      required modules for the starting activity and don't introduce janks where
      the lazily loaded modules become available.

   -  **Create a placeholder while loading a small amount of data locally.** Use
      the recommended theming approach and hold back the rendering until the app
      is ready. To implement a splash screen that is backward-compatible, follow
      the steps outlined in `Keep the splash screen on-screen for longer periods <#suspend-drawing>`__.

   -  **Show placeholders.** For network-based loads with indeterminate
      durations, dismiss the splash screen and show placeholders for
      asynchronous loading. Consider applying subtle animations to the content
      area that reflect the loading state. Make sure that the loaded content
      structure matches the `skeleton structure <https://m2.material.io/design/communication/launch-screen.html#placeholder-ui>`__
      as well as possible to support a smooth transition when the content is
      loaded.

   -  **Use caching**. When a user opens your app for the first time, you can
      show loading indicators for some UI elements, as shown in the following
      figure. The next time the user returns to your app, you can show this
      cached content while you load more recent content.

   .. container:: float
      :name: indicators


Last updated 2024-05-03 UTC.


/About shortcuts
================

.. https://developer.android.google.cn/develop/ui/views/launch/shortcuts?hl=en

.. container:: devsite-article-body

   As a developer, you can define *shortcuts* to perform specific actions in
   your app. You can display these shortcuts in a supported launcher or
   assistant—like Google Assistant—and help your users quickly start common or
   recommended tasks within your app.

   This documentation shows you how to
   `create <#>`__ and
   `manage <#>`__ app shortcuts. You
   can also learn some `best practices <#>`__ to improve your
   shortcuts.

   .. rubric:: Shortcut types
      :name: shortcut-types

   .. container:: attempt-right

      .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/shortcuts_2023.png
         name: fig-app-shortcuts
         :alt: app shortcuts
         :width: 250px

         **Figure 1.** Using app shortcuts, you can surface key actions and
         instantly take users deep into your app.

   Each shortcut references one or more
   `intents <#>`__, each of which launches a
   specific action in your app when users select the shortcut. The types of
   shortcuts you create for your app depend on the app's use case. Examples of
   actions you can express as shortcuts include the following:

   -  Composing a new email in an email app.
   -  Navigating users to a particular location in a mapping app.
   -  Sending messages to a user's contact in a communication app.
   -  Playing the next episode of a TV show in a media app.
   -  Loading the last save point in a gaming app.
   -  Letting the user order a drink in a delivery app using spoken commands.

   **Note:** Only main activities—activities that handle the
   `Intent.ACTION_MAIN <#android.content.Intent>`__
   action and the
   `Intent.CATEGORY_LAUNCHER <#android.content.Intent>`__
   category—can have shortcuts. If an app has multiple main activities, define
   the set of shortcuts for each activity.
   You can publish the following types of shortcuts for your app:

   -  *Static shortcuts* are defined in a resource file that is packaged into an
      APK or `app bundle <#>`__.
   -  *Dynamic shortcuts* can be pushed, updated, and removed by your app only
      at runtime.
   -  *Pinned shortcuts* can be added to supported launchers at runtime if the
      user grants permission.
      **Note:** Users can also create pinned shortcuts by copying your app's
      static and dynamic shortcuts onto the launcher.

   .. rubric:: Display shortcuts in assistants using capabilities
      :name: shortcut-capabilities

   *Capabilities* in ``shortcuts.xml`` let you declare the types of actions
   users can take to launch your app and jump directly to performing a specific
   task. For example, you can give users voice control of your app through
   Google Assistant by declaring ``capability`` elements that extend your in-app
   functionality to Assistant `App Actions <https://developer.android.google.cn/guide/app-actions/overview#app_actions>`__.
   For more details, see the documentation about `adding capabilities <#>`__.

   .. rubric:: Shortcut limitations
      :name: shortcut-limitations

   Most supported launchers display up to four shortcuts at a time, including
   both static and dynamic shortcuts. When pushing dynamic shortcuts for display
   on Google's surfaces, such as Google Assistant, use the `Google Shortcuts
   Integration Library <#gsi-library>`__ to
   avoid being subject to the shortcut limit.

   If you choose not to use the Google Shortcuts Integration Library, your app
   is subject to the device's limit for the number of shortcuts it supports at a
   time. Shortcuts published this way only appear within the Android launchers
   and aren't discoverable on Google surfaces such as Assistant.

   **Note:** The maximum number of shortcuts a device supports varies. Use the
   `getMaxShortcutCountPerActivity() <https://developer.android.com#androidx.core.content.pm.ShortcutManagerCompat>`__
   method to determine how many shortcuts a particular device supports.
   There is no limit to the number of pinned shortcuts users can create to your
   app. Your app can't remove pinned shortcuts, but it can
   `disable <#disable-shortcuts>`__
   them.

   **Note:** Although other apps can't access the metadata within your
   shortcuts, the launcher itself can access this data. Therefore, conceal
   sensitive user information in this metadata.
   To start creating shortcuts for your app, refer to the following
   documentation:

   -  `Create shortcuts <#>`__
   -  `Manage shortcuts <#>`__
   -  `Best practices for shortcuts <#>`__

   For more details about operations you can perform on shortcuts, see the
   `ShortcutManager <#android.content.pm.ShortcutManager>`__ API
   reference documentation.


Last updated 2024-04-29 UTC.


/Create shortcuts
=================

.. https://developer.android.google.cn/develop/ui/views/launch/shortcuts/creating-shortcuts?hl=en

.. container:: devsite-article-body

   Shortcuts deliver specific types of content to your users by helping them
   quickly access parts of your app.

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/shortcuts/pinned-shortcuts.png
      name: fig-pinned-shortcuts-example
      :alt: An image showing the contrast between app shortcuts and pinned
      shortcuts
      :width: 50.0%

      **Figure 1.** App shortcuts and pinned shortcuts.

   How you deliver content with shortcuts depends on your use case and whether
   the shortcut's context is app-driven or user-driven. Although a static
   shortcut's context doesn't change and a dynamic shortcut's context constantly
   changes, your app drives the context in both cases. In cases where a user
   chooses how your app delivers content to them, such as with a pinned
   shortcut, the context is defined by the user. The following scenarios
   describe a few use cases for each shortcut type:

   -  `Static shortcuts <#static>`__ **are
      best for apps that link to content using a consistent structure throughout
      the lifetime of a user's interaction with the app.** Because most
      launchers `only display four shortcuts <#>`__ at once, static
      shortcuts are useful for performing a routine task in a consistent way,
      such as if the user wants to view their calendar or email in a specific
      way .
   -  `Dynamic shortcuts <#dynamic>`__ **are
      used for actions in apps that are context-sensitive.** Context-sensitive
      shortcuts are tailored to the actions users perform in an app. For
      example, if you build a game that lets the user start from their current
      level on launch, you need to update the shortcut frequently. Using a
      dynamic shortcut lets you update the shortcut each time the user clears a
      level.
   -  `Pinned shortcuts <#pinned>`__ **are
      used for specific user-driven actions.** For example, a user might want to
      pin a specific website to the launcher. This is beneficial because it lets
      the user perform a custom action—like navigating to the website in one
      step, more quickly than using a default instance of a browser.

   .. rubric:: Create static shortcuts
      :name: static

   Static shortcuts provide links to generic actions within your app, and these
   actions must remain consistent over the lifetime of your app's current
   version. Good options for static shortcuts include viewing sent messages,
   setting an alarm, and displaying a user's exercise activity for the day.

   To create a static shortcut, do the following:

   #. In your app's ``AndroidManifest.xml`` file, find the activity whose intent
      filters are set to the
      `android.intent.action.MAIN <#android.content.Intent>`__
      action and the
      `android.intent.category.LAUNCHER <#android.content.Intent>`__
      category.

   #. Add a `<meta-data> <#>`__
      element to this activity that references the resource file where the app's
      shortcuts are defined:

      .. code:: prettyprint

           <manifest xmlns:android="http://schemas.android.com/apk/res/android"
                     package="com.example.myapplication">
             <application ... >
               <activity android:name="Main">
                 <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
                   <category android:name="android.intent.category.LAUNCHER" />
                 </intent-filter>
                 
                 <meta-data android:name="android.app.shortcuts"
                            android:resource="@xml/shortcuts" /> 
               </activity>
             </application>
           </manifest>
           

      **Note:** If using an
      `activity-alias <#>`__
      define the meta-data in the activity-alias rather than the activity it
      targets using the
      `targetActivity <#trgt>`__
      attribute.

   #. Create a new resource file called ``res/xml/shortcuts.xml``.

   #. In the new resource file, add a ``<shortcuts>`` root element that contains
      a list of ``<shortcut>`` elements. In each ``<shortcut>`` element, include
      information about a static shortcut including its icon, description
      labels, and the intents it launches within the app:

      .. code:: prettyprint

           <shortcuts xmlns:android="http://schemas.android.com/apk/res/android">
             <shortcut
               android:shortcutId="compose"
               android:enabled="true"
               android:icon="@drawable/compose_icon"
               android:shortcutShortLabel="@string/compose_shortcut_short_label1"
               android:shortcutLongLabel="@string/compose_shortcut_long_label1"
               android:shortcutDisabledMessage="@string/compose_disabled_message1">
               <intent
                 android:action="android.intent.action.VIEW"
                 android:targetPackage="com.example.myapplication"
                 android:targetClass="com.example.myapplication.ComposeActivity" />
               <!-- If your shortcut is associated with multiple intents, include them
                    here. The last intent in the list determines what the user sees when
                    they launch this shortcut. -->
               <categories android:name="android.shortcut.conversation" />
               <capability-binding android:key="actions.intent.CREATE_MESSAGE" />
             </shortcut>
             <!-- Specify more shortcuts here. -->
           </shortcuts>
           

   .. rubric:: Customize attribute values
      :name: attribute-values

   The following list includes descriptions for the different attributes within
   a static shortcut. Provide a value for ``android:shortcutId`` and
   ``android:shortcutShortLabel``. All other values are optional.

   ``android:shortcutId``
      A string literal that represents the shortcut when a
      `ShortcutManager <#android.content.pm.ShortcutManager>`__
      object performs operations on it.

      **Note:** You can't set this attribute's value to a resource string, such
      as ``@string/shortcut_id``.

   ``android:shortcutShortLabel``
      A concise phrase that describes the shortcut's purpose. When possible,
      limit this short description to 10 characters.

      For more information, see
      `setShortLabel() <#android.content.pm.ShortcutInfo.Builder>`__.

      **Note:** This attribute's value must be a resource string, such as
      ``@string/shortcut_short_label``.

   ``android:shortcutLongLabel``
      An extended phrase that describes the shortcut's purpose. If there's
      enough space, the launcher displays this value instead of
      ``android:shortcutShortLabel``. When possible, limit this long description
      to 25 characters.

      For more information, see
      `setLongLabel() <#android.content.pm.ShortcutInfo.Builder>`__.

      **Note:** This attribute's value must be a resource string, such as
      ``@string/shortcut_long_label``.

   ``android:shortcutDisabledMessage``
      The message that appears in a supported launcher when the user attempts to
      launch a disabled shortcut. The message must explain to the user why the
      shortcut is disabled. This attribute's value has no effect if
      ``android:enabled`` is ``true``.

      **Note:** This attribute's value must be a resource string, such as
      ``@string/shortcut_disabled_message``.

   ``android:enabled``
      Determines whether the user can interact with the shortcut from a
      supported launcher. The default value of ``android:enabled`` is ``true``.
      If you set it to ``false``, set an ``android:shortcutDisabledMessage``
      that explains why you're disabling the shortcut. If you don't think you
      need to provide such a message, remove the shortcut from the XML file
      entirely.

   ``android:icon``
      The `bitmap <#>`__ or `adaptive icon <#>`__ that the
      launcher uses when displaying the shortcut to the user. This value can be
      the path to an image or the resource file that contains the image. Use
      adaptive icons whenever possible to improve performance and consistency.

      **Note:** Shortcut icons can't include
      `tints <#DrawableTint>`__.

   .. rubric:: Configure inner elements
      :name: inner-elements

   The XML file that lists an app's static shortcuts supports the following
   elements inside each ``<shortcut>`` element. You **must** include an
   ``intent`` inner element for each static shortcut that you define.

   ``intent``
      The action that the system launches when the user selects the shortcut.
      This intent must provide a value for the ``android:action`` attribute.

      **Note:** This ``intent`` element can't include string resources.

      You can provide multiple intents for a single shortcut. See `Manage
      multiple intents and activities <#multiple-intents-activities>`__,
      `Set an intent <#set-an-intent>`__,
      and the `TaskStackBuilder <#android.app.TaskStackBuilder>`__
      class reference for details.

   ``categories``
      Provides a grouping for the types of actions that your app's shortcuts
      perform, such as creating new chat messages.

      For a list of supported shortcut categories, see the
      `ShortcutInfo <#android.content.pm.ShortcutInfo>`__ class
      reference.

   ``capability-binding``
      Declares the
      `capability <#>`__ linked
      with the shortcut.

      In the previous example, the shortcut is linked to a capability declared
      for
      `CREATE_MESSAGE <https://developers.google.com/assistant/app/reference/built-in-intents/communications/create-message>`__,
      which is an `App Actions <https://developers.google.com/assistant/app>`__
      built-in intent. This capability binding lets users use spoken commands
      with Google Assistant to invoke a shortcut.

   .. rubric:: Create dynamic shortcuts
      :name: dynamic

   Dynamic shortcuts provide links to specific, context-sensitive actions within
   your app. These actions can change between uses of your app and while your
   app is running. Good uses for dynamic shortcuts include calling a specific
   person, navigating to a specific location, and loading a game from the user's
   last save point. You can also use dynamic shortcuts to open a conversation.

   The
   `ShortcutManagerCompat <#androidx.core.content.pm.ShortcutManagerCompat>`__
   Jetpack library is a helper for the
   `ShortcutManager <#android.content.pm.ShortcutManager>`__ API,
   which lets you manage dynamic shortcuts in your app. Using the
   ``ShortcutManagerCompat`` library reduces boilerplate code and helps ensure
   that your shortcuts work consistently across Android versions. This library
   is also required for pushing dynamic shortcuts so that they are eligible to
   appear on Google surfaces—like Assistant—with the `Google Shortcuts Integration Library <#gsi-library>`__.

   The ``ShortcutManagerCompat`` API lets your app perform the following
   operations with dynamic shortcuts:

   -  **Push and update:** use
      `pushDynamicShortcut() <#androidx.core.content.pm.ShortcutManagerCompat>`__
      to publish and update your dynamic shortcuts. If there are already dynamic
      or pinned shortcuts with the same ID, each mutable shortcut updates.
   -  **Remove:** remove a set of dynamic shortcuts using
      `removeDynamicShortcuts() <#androidx.core.content.pm.ShortcutManagerCompat>`__.
      Remove all dynamic shortcuts using
      `removeAllDynamicShortcuts() <#androidx.core.content.pm.ShortcutManagerCompat>`__.

   For more information about performing operations on shortcuts, see `Manage shortcuts <#>`__ and the
   `ShortcutManagerCompat <#androidx.core.content.pm.ShortcutManagerCompat>`__
   reference.

   Here's an example of creating a dynamic shortcut and associating it with your
   app:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint


               val shortcut = ShortcutInfoCompat.Builder(context, "id1")
                       .setShortLabel("Website")
                       .setLongLabel("Open the website")
                       .setIcon(IconCompat.createWithResource(context, R.drawable.icon_website))
                       .setIntent(Intent(Intent.ACTION_VIEW,
                               Uri.parse("https://www.mysite.example.com/")))
                       .build()

               ShortcutManagerCompat.pushDynamicShortcut(context, shortcut)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint


               ShortcutInfoCompat shortcut = new ShortcutInfoCompat.Builder(context, "id1")
                   .setShortLabel("Website")
                   .setLongLabel("Open the website")
                   .setIcon(IconCompat.createWithResource(context, R.drawable.icon_website))
                   .setIntent(new Intent(Intent.ACTION_VIEW,
                                  Uri.parse("https://www.mysite.example.com/")))
                   .build();

               ShortcutManagerCompat.pushDynamicShortcut(context, shortcut);

   .. rubric:: Add the Google Shortcuts Integration Library
      :name: gsi-library

   The Google Shortcuts Integration Library is an optional Jetpack library. It
   lets you push dynamic shortcuts that can be displayed on Android surfaces,
   such as the launcher, and Google surfaces, such as Assistant. Using this
   library helps users discover your shortcuts to quickly access specific
   content or replay actions in your app.

   For example, a messaging app might push a dynamic shortcut for a contact
   named "Alex" after a user messages that person. After the dynamic shortcut is
   pushed, if the user asks Assistant, *"Hey Google, message Alex on
   ExampleApp,"* Assistant can launch ExampleApp and automatically configure it
   to send a message to Alex.

   Dynamic shortcuts pushed with this library aren't subject to the `shortcut limits <#shortcut-limitations>`__ enforced on a
   per-device basis. This lets your app push a shortcut every time a user
   completes an associated action in your app. Pushing frequent shortcuts this
   way lets Google understand your user's patterns of use and suggest
   contextually relevant shortcuts to them.

   For example, Assistant can learn from shortcuts pushed from your
   fitness-tracking app that a user typically runs each morning and proactively
   suggest a "start a run" shortcut when the user picks up their phone in the
   morning.

   The Google Shortcuts Integration Library doesn't offer any addressable
   functionality itself. Adding this library to your app lets Google surfaces
   take in the shortcuts your app pushes using ``ShortcutManagerCompat``.

   To use this library in your app, follow these steps:

   #. Update your ``gradle.properties`` file to support `AndroidX libraries <https://developer.android.google.cn/jetpack/androidx#using_androidx_libraries_in_your_project>`__:

      .. container::

         .. code:: prettyprint

                  
                  android.useAndroidX=true
                  # Automatically convert third-party libraries to use AndroidX
                  android.enableJetifier=true
                  
                  

   #. In ``app/build.gradle``, add dependencies for the Google Shortcuts
      Integration Library and ``ShortcutManagerCompat``:

      .. container::

         .. code:: prettyprint

                  
                  dependencies {
                    implementation "androidx.core:core:1.6.0"
                    implementation 'androidx.core:core-google-shortcuts:1.0.0'
                    ...
                  }
                  
                  

   With the library dependencies added to your Android project, your app can use
   the ``pushDynamicShortcut()`` method from ``ShortcutManagerCompat`` to push
   dynamic shortcuts that are eligible for display on the launcher and
   participating Google surfaces.

   **Note:** We recommend using ``pushDynamicShortcut`` to push dynamic
   shortcuts using the Google Shortcuts Integration Library. Your app can use
   other methods to publish shortcuts, but those might fail if they reach the
   maximum shortcut limit.

   .. rubric:: Create pinned shortcuts
      :name: pinned

   On Android 8.0 (API level 26) and higher, you can create pinned shortcuts.
   Unlike static and dynamic shortcuts, pinned shortcuts appear in supported
   launchers as separate icons. Figure 1 shows the distinction between these two
   types of shortcuts.

   **Note:** When you attempt to pin a shortcut onto a supported launcher, the
   user receives a confirmation dialog asking their permission to pin the
   shortcut. If the user doesn't let the shortcut be pinned, the launcher
   cancels the request.
   To pin a shortcut to a supported launcher using your app, complete the
   following steps:

   #. Use
      `isRequestPinShortcutSupported() <#android.content.pm.ShortcutManager>`__
      to verify that the device's default launcher supports in-app pinning of
      shortcuts.

   #. Create a ``ShortcutInfo`` object in one of two ways, depending on whether
      the shortcut exists:

      a. If the shortcut exists, create a ``ShortcutInfo`` object that contains
         only the existing shortcut's ID. The system finds and pins all other
         information related to the shortcut automatically.
      b. If you're pinning a new shortcut, create a ``ShortcutInfo`` object that
         contains an ID, an intent, and a short label for the new shortcut.

      **Note:** Because the system performs `backup and restore <#backup-restore>`__
      on pinned shortcuts automatically, these shortcuts' IDs must contain
      stable, constant strings or server-side identifiers, rather than
      identifiers generated locally that might not make sense on other devices.

   #. Pin the shortcut to the device's launcher by calling
      `requestPinShortcut() <#android.content.pm.ShortcutManager>`__.
      During this process, you can pass in a
      `PendingIntent <#android.app.PendingIntent>`__ object, which
      notifies your app only when the shortcut pins successfully.

      **Note:** If the user doesn't let the shortcut be pinned to the launcher,
      your app doesn't receive a callback.

      After a shortcut is pinned, your app can update its contents using the
      `updateShortcuts() <#android.content.pm.ShortcutManager>`__
      method. For more information, read `Update shortcuts <#update-shortcuts>`__.

   The following code snippet demonstrates how to create a pinned shortcut.

   **Note:** Instances of the ``ShortcutManager`` class must be obtained using
   `Context.getSystemService(Class) <#android.content.Context>`__
   with the argument ``ShortcutManager.class`` or
   `Context.getSystemService(String) <#android.content.Context>`__
   with the argument
   `Context.SHORTCUT_SERVICE <#android.content.Context>`__.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val shortcutManager = getSystemService(ShortcutManager::class.java)

               if (shortcutManager!!.isRequestPinShortcutSupported) {
                   // Enable the existing shortcut with the ID "my-shortcut".
                   val pinShortcutInfo = ShortcutInfo.Builder(context, "my-shortcut").build()

                   // Create the PendingIntent object only if your app needs to be notified
                   // that the user let the shortcut be pinned. If the pinning operation fails,
                   // your app isn't notified. Assume here that the app implements a method
                   // called createShortcutResultIntent() that returns a broadcast intent.
                   val pinnedShortcutCallbackIntent = shortcutManager.createShortcutResultIntent(pinShortcutInfo)

                   // Configure the intent so that your app's broadcast receiver gets the
                   // callback successfully. For details, see PendingIntent.getBroadcast().
                   val successCallback = PendingIntent.getBroadcast(context, /* request code */ 0,
                           pinnedShortcutCallbackIntent, /* flags */ 0)

                   shortcutManager.requestPinShortcut(pinShortcutInfo,
                           successCallback.intentSender)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               ShortcutManager shortcutManager =
                       context.getSystemService(ShortcutManager.class);

               if (shortcutManager.isRequestPinShortcutSupported()) {
                   // Enable the existing shortcut with the ID "my-shortcut".
                   ShortcutInfo pinShortcutInfo =
                           new ShortcutInfo.Builder(context, "my-shortcut").build();

                   // Create the PendingIntent object only if your app needs to be notified
                   // that the user let the shortcut be pinned. If the pinning operation fails,
                   // your app isn't notified. Assume here that the app implements a method
                   // called createShortcutResultIntent() that returns a broadcast intent.
                   Intent pinnedShortcutCallbackIntent =
                           shortcutManager.createShortcutResultIntent(pinShortcutInfo);

                   // Configure the intent so that your app's broadcast receiver gets the
                   // callback successfully. For details, see PendingIntent.getBroadcast().
                   PendingIntent successCallback = PendingIntent.getBroadcast(context, /* request code */ 0,
                           pinnedShortcutCallbackIntent, /* flags */ 0);

                   shortcutManager.requestPinShortcut(pinShortcutInfo,
                           successCallback.getIntentSender());
               }

   **Note:** See also the Support Library APIs
   `isRequestPinShortcutSupported() <#androidx.core.content.pm.ShortcutManagerCompat>`__
   and
   `requestPinShortcut() <#androidx.core.content.pm.ShortcutManagerCompat>`__,
   which work on Android 7.1 (API level 25) and lower. The Support Library falls
   back to the deprecated
   `EXTRA_SHORTCUT_INTENT <#android.content.Intent>`__
   extra to attempt the pinning process.

   .. rubric:: Create a custom shortcut activity
      :name: custom-pinned

   .. figure::
      https://developer.android.google.cn/static/images/guide/topics/ui/shortcuts/pinned-shortcuts-dialog.png
      name: fig-pinned-shortcuts-dialog
      :alt: An image showing the custom dialog activity that shows the prompt
      'Do you want to add the Gmail launcher icon to your home screen?' The
      custom options are 'No thanks' and 'Add icon'.
      :width: 40.0%

      **Figure 2.** Example of a custom app shortcut dialog activity.

   You can also create a specialized activity that helps users create shortcuts,
   complete with custom options and a confirmation button. Figure 2 shows an
   example of this type of activity in the Gmail app.

   In your app's manifest file, add
   `ACTION_CREATE_SHORTCUT <#android.content.Intent>`__
   to the activity's
   `<intent-filter> <#>`__
   element. This declaration sets up the following behavior when the user
   attempts to create a shortcut:

   #. The system starts your app's specialized activity.
   #. The user sets options for the shortcut.
   #. The user selects the confirmation button.
   #. Your app creates the shortcut using the
      `createShortcutResultIntent() <#android.content.pm.ShortcutManager>`__
      method. This method returns an
      `Intent <#android.content.Intent>`__, which your app relays
      back to the previously executing activity using
      `setResult() <#android.app.Activity>`__.
   #. Your app calls `finish() <#android.app.Activity>`__
      on the activity used to create the customized shortcut.

   Similarly, your app can prompt users to add pinned shortcuts to the home
   screen after installation or the first time the app is launched. This method
   is effective because it helps your users create a shortcut as part of their
   ordinary workflow.

   .. rubric:: Test shortcuts
      :name: testing

   To test your app's shortcuts, install your app on a device with a launcher
   that supports shortcuts. Then, perform the following actions:

   -  Touch & hold your app's launcher icon to view the shortcuts that you
      define for your app.
   -  Drag a shortcut to pin it to the device's launcher.


Last updated 2024-04-19 UTC.


/Add capabilities to shortcuts
==============================

.. https://developer.android.google.cn/develop/ui/views/launch/shortcuts/adding-capabilities?hl=en

.. container:: devsite-article-body

   Capabilities in ``shortcuts.xml`` let you declare the types of actions users
   can take to launch your app and directly perform a specific task.

   For example, Google Assistant App Actions use capabilities to let developers
   extend in-app features to `built-in intents <https://developers.google.com/assistant/app/intents>`__ (BIIs), letting
   users activate and control those features using spoken commands. A capability
   consists of the name of the action and an ``intent`` targeting the
   destination in your app that resolves the user intent.

   .. rubric:: Define capabilities in shortcuts.xml
      :name: definition

   You define ``capability`` elements in a ``shortcuts.xml`` resource file in
   your Android app development project. To define a ``capability`` element, do
   the following:

   #. Create a ``shortcuts.xml`` resource by following the instructions in
      `Create static shortcuts <https://develop/ui/views/launch/shortcuts/creating-shortcuts#static>`__.

   #. Include the following required information in your capability:

      -  **Capability name:** the action you want your app to support. Refer to
         the component documentation for the feature that requires capability
         definitions. App Actions voice-enabled commands use the BII
         ``Action ID`` for capability names, which you can find in `BII reference <https://developers.google.com/assistant/app/reference/built-in-intents>`__.
         For example, the
         `GET_THING <https://developers.google.com/assistant/app/reference/built-in-intents/common/get-thing>`__
         BII lists its ``Action ID`` as ``actions.intent.GET_THING``.

      -  **App destination:** the destination in your app the action launches to
         fulfill the user request. Define app destinations using ``intent``
         elements nested within the ``capability``.

      -  **Parameter mappings:** each ``intent`` might contain parameters to be
         passed as ``extra`` data of the intent. For example, each App Actions
         BII includes fields representing information users often provide in
         queries that trigger the BII.

   The following example demonstrates a capability definition in
   ``shortcuts.xml`` for
   `actions.intent.START_EXERCISE <https://developers.google.com/assistant/app/reference/built-in-intents/health-and-fitness/start-exercise>`__,
   a BII that lets users use spoken commands with Assistant to begin a workout
   in a fitness app:

   .. code:: prettyprint

      <shortcuts xmlns:android="http://schemas.android.com/apk/res/android">
        <capability android:name="actions.intent.START_EXERCISE">
          <intent
            android:action="android.intent.action.VIEW"
            android:targetPackage="com.example.sampleApp"
            android:targetClass="com.example.sampleApp.ExerciseActivity">
            <parameter
              android:name="exercise.name"
              android:key="exerciseType"/>
          </intent>
        </capability>
      </shortcuts>

   In the preceding example, the ``<capability>`` ``android:name`` attribute
   refers to the ``START_EXERCISE`` BII. If a user invokes this BII by asking
   Assistant, *"Hey Google, start a run in ExampleApp,"* Assistant fulfills the
   user request using information provided in the nested ``intent`` element. The
   ``intent`` in this sample defines the following details:

   -  The ``android:targetPackage`` sets the target application package for this
      intent.
   -  The ``android:targetClass`` field specifies the destination activity:
      ``com.example.sampleApp.ExerciseActivity``.
   -  The intent ``parameter`` declares support for a BII parameter
      `exercise.name <https://developers.google.com/assistant/app/reference/built-in-intents/health-and-fitness/start-exercise#recommended-fields>`__
      and how to pass the parameter value—collected from the user—as extra data
      in the ``intent``.

   .. rubric:: Associate shortcuts with a capability
      :name: associate

   Once you define a capability, you can extend its functionality by associating
   static or dynamic shortcuts with it. How shortcuts are linked to a
   ``capability`` depends on the feature being implemented and the actual words
   included in a user's request. For example, when a user begins a run in your
   fitness tracking app by asking Assistant, *"Hey Google, start a run in
   ExampleApp."* Assistant can use a shortcut to launch an instance of a
   ``capability`` that defines a valid exercise entity of "run" for the
   ``exercise.name`` parameter.

   For more information about associating shortcuts to App Actions, see `App Actions overview <https://developers.google.com/assistant/app>`__.


Last updated 2024-05-03 UTC.


/Manage shortcuts
=================

.. https://developer.android.google.cn/develop/ui/views/launch/shortcuts/managing-shortcuts?hl=en

.. container:: devsite-article-body

   After creating shortcuts, you might need to manage them over the lifetime of
   your app. For example, you might want to optimize your app by determining how
   often your users complete specific actions with your shortcuts. In another
   case, you might decide to disable a pinned shortcut to prevent your app from
   performing outdated or missing actions. For shortcuts referenced in
   conversations, you might want to track usage to provide signals that improve
   shortcut ranking.

   This page describes these and several other common ways to manage your
   shortcuts.

   .. rubric:: Shortcut behavior
      :name: shortcut-behavior

   The following sections contain general information about shortcut behavior,
   including visibility, display order, and ranks.

   .. rubric:: Shortcut visibility
      :name: shortcut-visibility

   **Important:**\  All shortcut information is stored in `credential encrypted storage <#>`__, so your app can't access a
   user's shortcuts until after they unlock the device.
   Static shortcuts and dynamic shortcuts appear in a supported launcher or
   assistant when the user performs a specific gesture or voice command. On
   supported launchers, the gesture is a touch & hold on the app's launcher
   icon, but the gesture might be different on other launcher apps. With Google
   Assistant, shortcuts can be displayed within Assistant or launched from a
   user voice command.

   The `LauncherApps <#android.content.pm.LauncherApps>`__ class
   provides APIs for launcher apps to access shortcuts.

   Because pinned shortcuts appear in the launcher itself, they're always
   visible. A pinned shortcut is removed from the launcher only in the following
   situations:

   -  The user removes it.
   -  The app associated with the shortcut is uninstalled.
   -  The user clears an app's data by going to **Settings > Apps &
      notifications**, selecting the app, then tapping **Storage > Clear
      storage**.

   `Share targets <#providing-direct-share-targets>`__
   are a subset of dynamic shortcuts that appear in the direct share row of the
   Android share sheet.

   .. figure:: https://developer.android.google.cn/static/images/guide/topics/ui/shortcuts/sharesheet.png
      name: indicators
      :alt: A screenshot of Android Sharesheet
      :width: 40.0%

      **Figure 1.** The Android Sharesheet. Direct share targets appear in the
      first row, followed by ranked apps and then the Apps lists.

   .. rubric:: Shortcut display order
      :name: shortcut-display

   When the launcher displays an app's shortcuts, they must appear in the
   following order:

   #. **Static shortcuts**: shortcuts whose
      `isDeclaredInManifest() <#androidx.core.content.pm.ShortcutInfoCompat>`__
      method returns ``true``.
   #. **Dynamic shortcuts**: shortcuts whose
      `ShortcutInfo.isDynamic() <#androidx.core.content.pm.ShortcutInfoCompat>`__
      method returns ``true``.

   Within each shortcut type—static and dynamic—shortcuts are sorted in order of
   increasing *rank* according to
   `ShortcutInfo.getRank <#androidx.core.content.pm.ShortcutInfoCompat>`__.
   Google Assistant also considers shortcut rank when determining contextual
   shortcuts to display to users.

   Ranks are non-negative, sequential integers. Static shortcuts are ranked from
   first-to-last in the order they appear in your ``shortcuts.xml`` file. For
   dynamic shortcuts, you can update ranks of existing shortcuts when you call
   `updateShortcuts(Context, List) <#androidx.core.content.pm.ShortcutManagerCompat>`__,
   `addDynamicShortcuts(Context, List) <#androidx.core.content.pm.ShortcutManagerCompat>`__,
   `pushDynamicShortcut(Context, ShortcutInfoCompat) <#androidx.core.content.pm.ShortcutManagerCompat>`__,
   or
   `setDynamicShortcuts(Context, List) <#androidx.core.content.pm.ShortcutManagerCompat>`__.

   The order of share targets is based on various factors including past user
   history, recency, frequency, `rank hint <#android.content.pm.ShortcutInfo.Builder>`__,
   app usage, and the priority set on the conversation that is associated with a
   sharing shortcut. Share targets created using the `Sharing Shortcuts API <#sharing-shortcuts-api>`__ are prioritized over
   the share targets produced by the
   `ChooserTargetService <#android.service.chooser.ChooserTargetService>`__
   which was deprecated in Android 11. In Android 12 and higher share targets
   generated by the deprecated ``ChooserTargetService`` will no longer appear in
   the share sheet.

   Most launchers display a maximum of four shortcuts. For any combination of
   static shortcuts and dynamic shortcuts that are defined, the launcher
   displays a maximum of two static shortcuts and two dynamic shortcuts. For
   example, if you define four static shortcuts and programmatically create
   three dynamic shortcuts, the launcher displays the first two static
   shortcuts, and the two most highly-ranked dynamic shortcuts.

   **Note:**\  Ranks are auto-adjusted so they're unique for each type of
   shortcut—static or dynamic. For example, if there are three dynamic shortcuts
   with ranks 0, 1, and 2, adding another dynamic shortcut with a rank of 1
   represents a request to place this shortcut in the second position. In
   response, the ranks of the shortcuts previously ranked 1 and 2 change to 2
   and 3, respectively.

   .. rubric:: Manage multiple intents and activities
      :name: manage-multiple

   If you want your app to perform multiple operations when your user activates
   a shortcut, you can configure it to trigger successive activities. You can
   accomplish this by assigning multiple intents, starting one activity from
   another, or setting intent flags, depending on the shortcut's type.

   .. rubric:: Assign multiple intents
      :name: assign-multiple

   When creating a shortcut with
   `ShortcutInfoCompat.Builder <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__,
   you can use
   `setIntents() <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
   instead of ``setIntent()``. By calling ``setIntents()``, you can launch
   multiple activities within your app when the user selects a shortcut, placing
   all but the last activity in the list on the back
   `stack <#>`__. If the user then taps the
   device's back button, they see another activity in your app instead of
   returning to the device's launcher.

   **Note:**\  When the user selects a shortcut and then taps the back button,
   your app launches the activity corresponding with the second-to-last intent
   listed in the shortcuts resource file. This behavior pattern continues as the
   user continues to tap the back button until the user clears the back stack
   that a shortcut creates. Then, if the user taps the back button again, the
   system navigates them back to the launcher.

   .. rubric:: Start one activity from another
      :name: start-one

   Static shortcuts can't have custom intent flags. The first intent of a static
   shortcut always has
   `Intent.FLAG_ACTIVITY_NEW_TASK <#android.content.Intent>`__
   and ``Intent.FLAG_ACTIVITY_CLEAR_TASK``
   `set <#android.content.Intent>`__. This
   means that when your app is running, all the existing activities in the app
   are destroyed when a static shortcut is launched. If you don't want this
   behavior, you can use a *trampoline activity* —an invisible activity that
   starts another activity—in ``Activity.onCreate(Bundle)``
   `that <#android.app.Activity>`__ calls
   ``Activity.finish()``:

   #. In the ``AndroidManifest.xml`` file, include the attribute assignment
      ``android:taskAffinity=``"" in the trampoline activity.
   #. In the shortcuts resource file, reference the trampoline activity in the
      intent within the static shortcut.

   For more information about trampoline activities, see `Starting one activity from another <#soafa>`__.

   .. rubric:: Set intent flags
      :name: set-intent

   You can publish dynamic shortcuts with any set of
   `Intent <#android.content.Intent>`__ flags.
   Preferably, specify ``Intent.FLAG_ACTIVITY_CLEAR_TASK`` along with your other
   flags. Otherwise, if you attempt to start another task while your app is
   running, the target activity might not appear.

   To learn more about tasks and intent flags, see `Tasks and the back stack <#>`__.

   .. rubric:: Update shortcuts
      :name: update-shortcuts

   Each app's launcher icon can contain, at most, a number of static and dynamic
   shortcuts combined that is equal to the value returned by
   `getMaxShortcutCountPerActivity <#androidx.core.content.pm.ShortcutManagerCompat>`__.
   There isn't a limit to the number of pinned shortcuts that an app can create.

   When a dynamic shortcut is pinned, even when the publisher removes it as a
   dynamic shortcut, the pinned shortcut is still visible and launchable. This
   lets an app have more than ``getMaxShortcutCountPerActivity()`` number of
   shortcuts.

   Consider the following example, which assumes that the value returned by
   ``getMaxShortcutCountPerActivity()`` is ``4``:

   #. A chat app publishes four dynamic shortcuts, representing the four most
      recent conversations: c1, c2, c3, and c4.
   #. The user pins all four of the shortcuts.
   #. Later, the user starts three additional conversations: c5, c6, and c7. The
      publisher app re-publishes its dynamic shortcuts. The new dynamic shortcut
      list is: c4, c5, c6, and c7.

   The app has to remove c1, c2, and c3, because it can't display more than four
   dynamic shortcuts. However, c1, c2, and c3 are still pinned shortcuts that
   the user can access and launch.

   The user can then access a total of seven shortcuts that link to activities
   in the publisher app. This is because the total includes the maximum number
   of shortcuts and the three pinned shortcuts.

   #. The app can use ``updateShortcuts(Context, List)`` to update any of the
      existing seven shortcuts. For example, you might update this set of
      shortcuts when the chat peers' icons change.
   #. You can use the
      `addDynamicShortcuts(Context, List) <#androidx.core.content.pm.ShortcutManagerCompat>`__
      and ``setDynamicShortcuts(Context, List)`` methods to update existing
      shortcuts with the same IDs. However, you can't use them for updating
      non-dynamic, pinned shortcuts, because these two methods try to convert
      the given lists of shortcuts to dynamic shortcuts.

   There isn't a limit to the number of shortcuts that can be pushed for display
   on assistant apps such as Google Assistant. Use the
   `pushDynamicShortcut() <#androidx.core.content.pm.ShortcutManagerCompat>`__
   method of the ``ShortcutManagerCompat`` Jetpack library to create and update
   shortcuts for use on assistant apps. Also, add the `Google Shortcuts
   Integration library <#gsi-library>`__ to
   your app to make dynamic links eligible to appear on Google Assistant.

   To learn more about guidelines for app shortcuts, including updating
   shortcuts, see `Best practices for shortcuts <#>`__.

   .. rubric:: Handle system locale changes
      :name: handle-system

   Apps must update dynamic and pinned shortcuts when they receive the
   `Intent.ACTION_LOCALE_CHANGED <#android.content.Intent>`__
   broadcast indicating a change to the system locale.

   .. rubric:: Track shortcut usage
      :name: track-shortcut

   To determine the situations during which static and dynamic shortcuts appear,
   the launcher examines the activation history of shortcuts. For static
   shortcuts, you can keep track of when users complete specific actions within
   your app by calling the
   `reportShortcutUsed() <#androidx.core.content.pm.ShortcutManagerCompat>`__
   method and passing it the ID of a shortcut when either of the following
   events occurs:

   -  The user selects the shortcut with the given ID.
   -  Within the app, the user manually completes the action corresponding to
      the same shortcut.

   Your app tracks usage for dynamic shortcuts by calling the
   ``pushDynamicShortcut()`` method and passing it the ID of the shortcut when a
   relevant event occurs. Pushing dynamic shortcut usage with this method lets
   assistant apps such as Google Assistant suggest relevant shortcuts to users.
   Because the ``pushDynamicShortcut()`` method reports usage when called, don't
   call the ``reportShortcutUsed()`` method for the same shortcuts.

   For conversation-related shortcuts, it is important to track usage for
   outgoing and incoming messages. For details, see the `best practices <#best-practices>`__
   for people and conversations.

   **Note:**\  The `Google Shortcuts Integration Library <#gsi-library>`__ is
   required to enable the dynamic links your app pushes to be eligible to appear
   on Google surfaces such as Google Assistant. By adding this library to your
   app, you let Assistant take in your dynamic links and suggest them to users
   from the Assistant app.

   .. rubric:: Disable shortcuts
      :name: disable-shortcuts

   Because your app and its users can pin shortcuts to the device's launcher,
   it's possible that these pinned shortcuts can direct users to actions within
   your app that are out of date or no longer exist. To manage this situation,
   you can disable the shortcuts that you don't want users to select by calling
   `disableShortcuts <#androidx.core.content.pm.ShortcutManagerCompat>`__,
   which removes the specified shortcuts from the static and dynamic shortcuts
   list and disables pinned copies of these shortcuts. You can also use an
   overloaded version of this method that accepts a
   `CharSequence <#>`__ as a custom error
   message. That error message then appears when users attempt to launch any
   disabled shortcut.

   **Note:**\  If you remove some of your app's static shortcuts when you update
   your app, the system disables these shortcuts automatically.

   .. rubric:: Rate limiting
      :name: rate-limiting

   When using the ``setDynamicShortcuts(), addDynamicShortcuts()``, or
   ``updateShortcuts()`` methods, you might only be able to call these methods a
   specific number of times in a *background app* —an app with no activities or
   services in the foreground. The limit on the specific number of times you can
   call these methods is called *rate limiting*. This feature prevents
   `ShortcutManagerCompat <#>`__
   from over-consuming device resources.

   When rate limiting is active,
   `isRateLimitingActive() <#isratelimitingactive>`__
   returns true. However, rate limiting is reset during certain events, so even
   background apps can call ``ShortcutManager`` methods until the rate limit is
   reached again. These events include the following:

   -  An app comes to the foreground.
   -  The system locale changes.
   -  The user performs the `inline reply <#>`__ action on a
      notification.

   If you encounter rate limiting during development or testing, you can select
   **Developer Options > Reset ShortcutManager rate-limiting** from the
   `device's settings <#>`__, or you can enter the
   following command in ``adb``:

   .. code:: none

      $ adb shell cmd shortcut reset-throttling [ --user your-user-id ]

   .. rubric:: Backup and restore
      :name: backup-and

   You can let users perform backup and restore operations on your app when
   changing devices by including the
   `android:allowBackup="true <#allowbackup>`__"
   attribute assignment in your app's manifest file. If you support backup and
   restore, keep the following points about app shortcuts in mind:

   -  Static shortcuts are re-published automatically, but only after the user
      re-installs your app on a new device.
   -  Dynamic shortcuts aren't backed up, so include logic in your app to
      re-publish them when a user opens your app on a new device.
   -  Pinned shortcuts are restored to the device's launcher automatically, but
      the system doesn't back up icons associated with pinned shortcuts.
      Therefore, save your pinned shortcuts' images in your app so that it's
      easy to restore them on a new device.

   The following code snippet shows how best to restore your app's dynamic
   shortcuts and how to check whether your app's pinned shortcuts were
   preserved:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyMainActivity : Activity() {
                   override fun onCreate(savedInstanceState: Bundle?) {
                       super.onCreate(savedInstanceState)
                       if (ShortcutManagerCompat.dynamicShortcuts.size == 0) {
                           // Application restored. Re-publish dynamic shortcuts.
                           if (ShortcutManagerCompat.pinnedShortcuts.size > 0) {
                               // Pinned shortcuts are restored. Use updateShortcuts() to make
                               // sure they contain up-to-date information.
                           }

                       }
                   }
                   // ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MainActivity extends Activity {
                   public void onCreate(Bundle savedInstanceState) {
                       super.onCreate(savedInstanceState);

                       if (ShortcutManagerCompat.getDynamicShortcuts().size() == 0) {
                           // Application restored. Re-publish dynamic shortcuts.
                           if (ShortcutManagerCompat.getPinnedShortcuts().size() > 0) {
                               // Pinned shortcuts are restored. Use pdateShortcuts() to make
                               // sure they contain up-to-date information.
                           }
                       }
                   }
                   // ...
               }


Last updated 2024-02-22 UTC.


/Implement best practices for shortcuts
=======================================

.. https://developer.android.google.cn/develop/ui/views/launch/shortcuts/best-practices?hl=en

.. container:: devsite-article-body

   When designing and creating your app's shortcuts, follow these guidelines:

   **Follow the design guidelines**
      To make your app's shortcuts visually consistent with the shortcuts used
      for system apps, follow the `App Shortcuts Icon Design Guidelines <#>`__.

   **Publish only four distinct shortcuts**
      Although the API supports a combination of up to 15 static and dynamic
      shortcuts for your app, we recommend that you publish only four distinct
      shortcuts, to improve their visual appearance in the launcher.

      In addition to displaying shortcuts on the launcher, use the `Google
      Shortcuts Integration Library <#gsi-library>`__
      to display shortcuts on Google surfaces such as Google Assistant. This
      library supports pushing an unlimited number of dynamic shortcuts. If you
      are using this library to push a large number of shortcuts, we recommend
      setting the ``rank`` of the shortcuts that must appear in supported
      launchers by calling the
      ` <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__\ ``setRank()``
      method.

   **Limit shortcut description length**
      The space in the menu that shows your app's shortcuts in the launcher is
      limited. When possible, limit the length of the "short description" of a
      shortcut to 10 characters and limit the length of the "long description"
      to 25 characters.

      For more information about labels for static shortcuts, read `Customize
      attribute values <#attribute-values>`__.
      For dynamic and pinned shortcuts, read the reference documentation on
      `setLongLabel() <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__
      and
      `setShortLabel() <#androidx.core.content.pm.ShortcutInfoCompat.Builder>`__.

   **Maintain shortcut and action usage history**
      For each shortcut you create, consider the different ways a user can
      accomplish the same task directly within your app. Call
      `reportShortcutUsed() <#androidx.core.content.pm.ShortcutManagerCompat>`__
      in each of these situations so that the launcher maintains an accurate
      history of how frequently a user performs the actions representing your
      shortcuts.

   **Update shortcuts only when their meaning is retained**
      When changing dynamic and pinned shortcuts, only call
      `updateShortcuts() <#androidx.core.content.pm.ShortcutManagerCompat>`__
      when changing the information of a shortcut that retains its meaning.
      Otherwise, use one of the following methods, depending on the type of
      shortcut you're recreating:

      -  Dynamic shortcuts:
         `pushDynamicShortcut() <#androidx.core.content.pm.ShortcutManagerCompat>`__.
      -  Pinned shortcuts:
         `requestPinShortcut() <#androidx.core.content.pm.ShortcutManagerCompat>`__.

      For example, if you create a shortcut for navigating to a supermarket, it
      is appropriate to update the shortcut if the name of the supermarket
      changes but its location stays the same. If the user begins shopping at a
      different supermarket location, however, it's better to create a new
      shortcut.

   **Check dynamic shortcuts whenever you launch your app**
      Dynamic shortcuts aren't preserved when the user restores their data onto
      a new device. For this reason, we recommend that you check the number of
      objects returned by
      `getDynamicShortcuts() <#androidx.core.content.pm.ShortcutManagerCompat>`__
      each time you launch your app and re-publish dynamic shortcuts as needed,
      as shown in the code snippet in `Backup and restore <#backup-restore>`__.


Last updated 2024-02-22 UTC.


/Create custom Quick Settings tiles
===================================

.. https://developer.android.google.cn/develop/ui/views/quicksettings-tiles?hl=en

.. container:: devsite-article-body

   Quick Settings are tiles displayed in the `Quick Settings panel <https://support.google.com/android/answer/9083864>`__, representing
   actions, that users can tap to quickly complete recurring tasks. Your app can
   provide a custom tile to users through the
   `TileService <#android.service.quicksettings.TileService>`__
   class, and use a `Tile <#android.service.quicksettings.Tile>`__
   object to track the state of the tile. For example, you could create a tile
   that lets users turn a VPN provided by your app on or off.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/images/quick-settings-vpn-on-off.png
      :alt: Quick Settings panel with the VPN tile turned on and off
      :width: 800px

      **Figure 1.** Quick Settings panel with the VPN tile turned on and off.

   **Note:**\  This guide only discusses non-Wear tiles — Quick Settings tiles
   have no relation to the tiles defined within Wear OS. For Wear OS tiles, see
   the `WearOS Tiles Guide <#>`__.

   .. rubric:: Decide when to create a tile
      :name: decide-when-to-create

   We recommend creating tiles for specific functionalities that you expect
   users to either access often or need fast access to (or both). The most
   effective tiles are the ones that match both of these qualities, providing
   quick access to frequently-performed actions.

   For example, you could create a tile for a fitness app that would allow users
   to quickly start a workout session. However, we wouldn’t recommend creating a
   tile for the same app that would allow users to review their entire workout
   history.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/images/use-cases-fitness-tiles.png
      :alt: Fitness app tile use cases
      :width: 500px

      **Figure 2.** Examples of recommended versus non-recommended tiles for a
      fitness app.

   To help improve your tile's discoverability and ease of use, we recommend
   avoiding certain practices:

   -  Avoid using tiles to launch an app. Use an `app shortcut <#>`__ or a standard launcher instead.

   -  Avoid using tiles for one-time user actions. Use an app shortcut or a
      `notification <#>`__ instead.

   -  Avoid creating too many tiles. We recommend a maximum of two per app. Use
      an app shortcut instead.

   -  Avoid using tiles that display information, but aren't interactive for
      users. Use a notification or a
      `widget <#>`__ instead.

   .. rubric:: Create your tile
      :name: create-tile

   To create a tile, you need to first create an appropriate tile icon, then
   create and declare your ``TileService`` in your app's manifest file.

   **Note:**\  Creating a ``TileService`` for your app does not add it to the
   user’s Quick Settings panel. Your ``TileService`` acts as an interface with
   the tile only after the user has added it.
   The `Quick Settings sample <https://github.com/android/user-interface-samples/tree/main/Quick-Settings>`__
   provides an example of how to create and manage a tile.

   .. rubric:: Create your custom icon
      :name: create-custom

   You’ll need to supply a custom icon, which displays on the tile in the Quick
   Settings panel. (You'll add this icon when declaring the ``TileService``,
   described in the next section.) The icon must be a solid white with a
   transparent background, measure 24 x 24dp, and be in the form of a
   `VectorDrawable <#android.graphics.drawable.VectorDrawable>`__.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/images/vector-drawable.png
      :alt: Example of a vector drawable
      :width: 250px

      **Figure 3.** Example of a vector drawable.

   Create an icon that visually hints at the purpose of your tile. This helps
   users easily identify if your tile fits their needs. For example, you might
   create an icon of a stopwatch for a tile for a fitness app that allows users
   to start a workout session.

   .. rubric:: Create and declare your TileService
      :name: create-declare-tileservice

   Create a service for your tile that extends the ``TileService`` class.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class MyQSTileService: TileService() {

                 // Called when the user adds your tile.
                 override fun onTileAdded() {
                   super.onTileAdded()
                 }
                 // Called when your app can update your tile.
                 override fun onStartListening() {
                   super.onStartListening()
                 }

                 // Called when your app can no longer update your tile.
                 override fun onStopListening() {
                   super.onStopListening()
                 }

                 // Called when the user taps on your tile in an active or inactive state.
                 override fun onClick() {
                   super.onClick()
                 }
                 // Called when the user removes your tile.
                 override fun onTileRemoved() {
                   super.onTileRemoved()
                 }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class MyQSTileService extends TileService {

                 // Called when the user adds your tile.
                 @Override
                 public void onTileAdded() {
                   super.onTileAdded();
                 }

                 // Called when your app can update your tile.
                 @Override
                 public void onStartListening() {
                   super.onStartListening();
                 }

                 // Called when your app can no longer update your tile.
                 @Override
                 public void onStopListening() {
                   super.onStopListening();
                 }

                 // Called when the user taps on your tile in an active or inactive state.
                 @Override
                 public void onClick() {
                   super.onClick();
                 }

                 // Called when the user removes your tile.
                 @Override
                 public void onTileRemoved() {
                   super.onTileRemoved();
                 }
               }

   Declare your ``TileService`` in your app's manifest file. Add the name and
   label of your ``TileService``, the custom icon you created in the preceding
   section, and the appropriate permission.

   .. code:: prettyprint

       <service
           android:name=".MyQSTileService"
           android:exported="true"
           android:label="@string/my_default_tile_label"  // 18-character limit.
           android:icon="@drawable/my_default_icon_label"
           android:permission="android.permission.BIND_QUICK_SETTINGS_TILE">
           <intent-filter>
               <action android:name="android.service.quicksettings.action.QS_TILE" />
           </intent-filter>
       </service>

   .. rubric:: Manage your TileService
      :name: manage-tileservice

   Once you’ve created and declared your ``TileService`` in your app manifest,
   you have to manage its state.

   ``TileService`` is a `bound service <#>`__.
   Your ``TileService`` is bound when requested by your app or if the system
   needs to communicate with it. A typical `bound-service lifecycle <#Lifecycle>`__ contains the
   following four callback methods:
   `onCreate() <#android.app.Service>`__,
   `onBind() <#android.app.Service>`__,
   `onUnbind() <#android.app.Service>`__,
   and `onDestroy() <#android.app.Service>`__. These
   methods are invoked by the system each time the service enters a new
   lifecycle phase.

   **Important:**\  Your ``TileService`` will still go through the typical
   ``Service`` lifecycle. However, ``TileService`` differs from most other bound
   services because it contains ``TileService``-specific lifecycle methods that
   your app must react to.

   .. rubric:: TileService lifecycle overview
      :name: tileservice-lifecycle

   In addition to the callbacks that control the bound-service lifecycle, you
   must implement other methods specific to the ``TileService`` lifecycle. These
   methods may be called outside of ``onCreate()`` and ``onDestroy()`` because
   the ``Service`` lifecycle methods and the ``TileService`` lifecycle methods
   are called in two separate asynchronous threads.

   The ``TileService`` lifecycle contains the following methods, which are
   invoked by the system each time your ``TileService`` enters a new lifecycle
   phase:

   -  `onTileAdded() <#android.service.quicksettings.TileService>`__:
      This method is called only when the user adds your tile for the first
      time, and if the user removes and adds your tile again. This is the best
      time to do any one-time initialization. However, this may not satisfy all
      the needed initialization.

      **Note:**\  ``onTileAdded()`` is not called whenever the tile is created.
      For example, ``onTileAdded()`` is not called when the device is rebooted
      or powered on if the tile had been added and not removed before the device
      was powered off.

   -  `onStartListening() <#android.service.quicksettings.TileService>`__
      and
      `onStopListening() <#android.service.quicksettings.TileService>`__:
      These methods are called whenever your app updates the tile, and are
      called often. The ``TileService`` remains bound between
      ``onStartListening()`` and ``onStopListening()``, allowing your app to
      modify the tile and push updates.

   -  `onTileRemoved() <#android.service.quicksettings.TileService>`__:
      This method is called only if the user removes your tile.

   **Caution:**\  These phases may not occur consecutively. ``onTileAdded()``
   may only be called once when your tile is added by a user to their Quick
   Settings panel. ``onStartListening()`` and ``onStopListening()`` may be
   called multiple times throughout the ``TileService`` lifecycle.
   ``onTileRemoved()`` will never be called if the user doesn’t remove your tile
   from their Quick Settings panel.

   .. rubric:: Select a listening mode
      :name: select-listening

   Your ``TileService`` listens in *active* mode or *non-active* mode. We
   recommend using active mode, which you’ll need to declare in the app
   manifest. Otherwise, the ``TileService`` is the standard mode and doesn’t
   need to be declared.

   Do not assume your ``TileService`` will live outside of
   ``onStartListening()`` and ``onStopListening()`` pair of methods.

   .. rubric:: Active mode (recommended)
      :name: active_mode_recommended

   Use active mode for a ``TileService`` that listens and monitors its state in
   its own process. A ``TileService`` in active mode is bound for
   ``onTileAdded()``, ``onTileRemoved()``, tap events, and when requested by the
   app process.

   We recommend active mode if your ``TileService`` is notified when your tile
   state should be updated by its own process. Active tiles limit the strain on
   the system because they do not have to be bound every time the Quick Settings
   panel becomes visible to the user.

   The static
   `TileService.requestListeningState() <#android.service.quicksettings.TileService.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blogate>`__
   method can be called to request the start of the listening state and receive
   a callback to ``onStartListening()``.

   You can declare active mode by adding the
   `META_DATA_ACTIVE_TILE <#android.service.quicksettings.TileService.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__
   to your app's manifest file.

   .. code:: prettyprint

      <service ...>
          <meta-data android:name="android.service.quicksettings.ACTIVE_TILE"
               android:value="true" />
          ...
      </service>

   .. rubric:: Non-active mode
      :name: non-active_mode

   Non-active mode is the standard mode. A ``TileService`` is in non-active mode
   if it is bound whenever your tile is visible to the user. This means that
   your ``TileService`` may be created and bound again at times beyond its
   control. It also may be unbound and destroyed when the user is not viewing
   the tile.

   Your app receives a callback to ``onStartListening()`` after the user opens
   their Quick Settings panel. You can update your ``Tile`` object as many times
   as you want between ``onStartListening()`` and ``onStopListening()``.

   **Caution:**\  If you use non-active mode instead of active mode, your
   ``TileService`` may be bound every time the user opens their Quick Settings
   panel.
   You do not need to declare non-active mode—simply do not add the
   ``META_DATA_ACTIVE_TILE`` to your app's manifest file.

   .. rubric:: Tile states overview
      :name: tile-states

   After a user adds your tile, it always exists in one of the following states.

   -  `STATE_ACTIVE <#android.service.quicksettings.Tile.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__:
      Indicates an on or enabled state. The user can interact with your tile
      while in this state.

      For example, for a fitness app tile that lets users initiate a timed
      workout session, ``STATE_ACTIVE`` would mean that the user has initiated a
      workout session and the timer is running.

   -  `STATE_INACTIVE <#android.service.quicksettings.Tile.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__:
      Indicates an off or paused state. The user can interact with your tile
      while in this state.

      To use the fitness app tile example again, a tile in ``STATE_INACTIVE``
      would mean that the user hasn't initiated a workout session, but could do
      so if they wanted to.

   -  `STATE_UNAVAILABLE <#android.service.quicksettings.Tile.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__:
      Indicates a temporarily unavailable state. The user cannot interact with
      your tile while in this state.

      For example, a tile in ``STATE_UNAVAILABLE`` means that the tile is not
      currently available to the user for some reason.

      **Caution:**\  Use ``STATE_UNAVAILABLE`` for tiles that are currently
      unavailable but could be put into an available state later. If the
      component will never be available for the user again, pass
      ``COMPONENT_ENABLED_STATE_DISABLED`` into
      `setComponentEnabledSetting() <#setcomponentenabledsetting>`__.

   The system only sets the initial state of your ``Tile`` object. You set the
   ``Tile`` object's state throughout the rest of its lifecycle.

   The system may tint the tile icon and background to reflect the state of your
   ``Tile`` object. ``Tile`` objects set to ``STATE_ACTIVE`` are the darkest,
   with ``STATE_INACTIVE`` and ``STATE_UNAVAILABLE`` increasingly lighter. The
   exact hue is specific to the manufacturer and version.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/images/state-hues.png
      :alt: VPN tile tinted to reflect object states
      :width: 500px

      **Figure 4.** Examples of a tile tinted to reflect the tile state (active,
      inactive, and unavailable states, respectively).

   .. rubric:: Update your tile
      :name: update-tile

   You can update your tile once you receive a callback to
   ``onStartListening()``. Depending on the tile's mode, your tile can be
   updated at least once until receiving a callback to ``onStopListening()``.

   In active mode, you can update your tile exactly once before receiving a
   callback to ``onStopListening()``. In non-active mode, you can update your
   tile as many times as you want between ``onStartListening()`` and
   ``onStopListening()``.

   **Note:**\  Active mode lets you update your tile regardless of whether your
   tile is visible to the user or not.
   You can retrieve your ``Tile`` object by calling
   `getQsTile() <#android.service.quicksettings.TileService.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__.
   To update specific fields of your ``Tile`` object, call the following
   methods:

   -  `setContentDescription() <#android.service.quicksettings.Tile>`__
   -  `setIcon() <#android.service.quicksettings.Tile>`__
   -  `setLabel() <#android.service.quicksettings.Tile>`__
   -  `setState() <#android.service.quicksettings.Tile>`__
   -  `setStateDescription() <#android.service.quicksettings.Tile>`__
   -  `setSubtitle() <#android.service.quicksettings.Tile>`__

   **Note:**\  The icon and label set in your app's manifest file are the
   default values displayed on the tile in the Quick Settings panel. However,
   you can call the ``setIcon()`` and ``setLabel()`` methods when updating your
   tile to set the fields to new values.
   You must call ``updateTile()`` to update your tile once you’re done setting
   the fields of the ``Tile`` object to the correct values. This will make the
   system parse the updated tile data and update the UI.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               data class StateModel(val enabled: Boolean, val label: String, val icon: Icon)

               override fun onStartListening() {
                 super.onStartListening()
                 val state = getStateFromService()
                 qsTile.label = state.label
                 qsTile.contentDescription = tile.label
                 qsTile.state = if (state.enabled) Tile.STATE_ACTIVE else Tile.STATE_INACTIVE
                 qsTile.icon = state.icon
                 qsTile.updateTile()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class StateModel {
                 final boolean enabled;
                 final String label;
                 final Icon icon;

                 public StateModel(boolean e, String l, Icon i) {
                   enabled = e;
                   label = l;
                   icon = i;
                 }
               }

               @Override
               public void onStartListening() {
                 super.onStartListening();
                 StateModel state = getStateFromService();
                 Tile tile = getQsTile();
                 tile.setLabel(state.label);
                 tile.setContentDescription(state.label);
                 tile.setState(state.enabled ? Tile.STATE_ACTIVE : Tile.STATE_INACTIVE);
                 tile.setIcon(state.icon);
                 tile.updateTile();
               }

   .. rubric:: Handle taps
      :name: handle-taps

   Users can tap on your tile to trigger an action if your tile is in
   ``STATE_ACTIVE`` or ``STATE_INACTIVE``. The system then invokes your app's
   `onClick() <#android.service.quicksettings.TileService>`__
   callback.

   Once your app receives a callback to ``onClick()``, it can launch a dialog or
   activity, trigger background work, or change the state of your tile.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               var clicks = 0
               override fun onClick() {
                 super.onClick()
                 counter++
                 qsTile.state = if (counter % 2 == 0) Tile.STATE_ACTIVE else Tile.STATE_INACTIVE
                 qsTile.label = "Clicked $counter times"
                 qsTile.contentDescription = qsTile.label
                 qsTile.updateTile()
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               int clicks = 0;

               @Override
               public void onClick() {
                 super.onClick();
                 counter++;
                 Tile tile = getQsTile();
                 tile.setState((counter % 2 == 0) ? Tile.STATE_ACTIVE : Tile.STATE_INACTIVE);
                 tile.setLabel("Clicked " + counter + " times");
                 tile.setContentDescription(tile.getLabel());
                 tile.updateTile();
               }

   .. rubric:: Launch a dialog
      :name: launch_a_dialog

   `showDialog() <#android.service.quicksettings.TileService>`__
   collapses the Quick Settings panel and shows a dialog. Use a dialog to add
   context to your action if it requires additional input or user consent.

   **Note:**\ 
   `isLocked() <#android.service.quicksettings.TileService>`__
   checks if the user’s lock screen is showing. When ``isLocked()`` returns
   true, ``showDialog()`` doesn't present a visible dialog because it loads
   under the lock screen.

   .. rubric:: Launch an activity
      :name: launch_an_activity

   `startActivityAndCollapse() <#android.service.quicksettings.TileService.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__
   starts an activity while collapsing the panel. Activities are useful if
   there’s more detailed information to display than within a dialog, or if your
   action is highly interactive.

   If your app requires significant user interaction, the app should launch an
   activity only as a last resort. Instead, consider using a dialog or a toggle.

   Long-tapping a tile prompts the **App Info** screen for the user. To override
   this behavior and instead launch an activity for setting preferences, add an
   ``<intent-filter>`` to one of your activities with
   `ACTION_QS_TILE_PREFERENCES <#android.service.quicksettings.TileService.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__.

   .. rubric:: Mark your tile as toggleable
      :name: mark-tile

   We recommend marking your tile as toggleable if it functions primarily as a
   two-state switch (which is the most common behavior of tiles). This helps
   provide information about the behavior of the tile to the operating system
   and improve overall accessibility.

   Set the ``TOGGLEABLE_TILE`` metadata to ``true`` to mark your tile as
   toggleable.

   .. code:: prettyprint

      <service ...>
        <meta-data android:name="android.service.quicksettings.TOGGLEABLE_TILE"
          android:value="true" />
      </service>

   .. rubric:: Perform only safe actions on securely-locked devices
      :name: perform-only

   Your tile may display on top of the lock screen on locked devices. If the
   tile contains sensitive information, check the value of
   `isSecure() <#android.service.quicksettings.TileService.html?utm_campaign=adp_series_quicksettingstiles_092916&utm_source=medium&utm_medium=blog>`__
   to determine whether the device is in a secure state, and your
   ``TileService`` should change its behavior accordingly.

   If the tile action is safe to perform while locked, use
   `startActivity() <#android.content.ContextWrapper>`__
   to launch an activity on top of the lock screen.

   If the tile action is unsafe, use
   `unlockAndRun() <#android.service.quicksettings.TileService>`__
   to prompt the user to unlock their device. If successful, the system executes
   the `Runnable <#>`__ object that you pass
   into this method.

   .. rubric:: Prompt the user to add your tile
      :name: prompt-user

   To manually add your tile, users must follow several steps:

   #. Swipe down to open the Quick Settings panel.
   #. Tap the edit button.
   #. Scroll through all tiles on their device until they locate your tile.
   #. Hold down your tile, and drag it to the list of active tiles.

   The user can also move or remove your tile at any point.

   Starting on Android 13, you can use the
   `requestAddTileService() <#android.app.StatusBarManagerice>`__
   method to make it much easier for users to add your tile to a device. This
   method prompts users with a request to quickly add your tile directly to
   their Quick Settings panel. The prompt includes the application name, the
   provided label, and icon.

   .. figure:: https://developer.android.google.cn/static/develop/ui/views/images/placement-api-user-prompt.png
      :alt: Quick Settings Placement API prompt
      :width: 300px

      **Figure 5.** Quick Settings Placement API prompt.

   .. code:: prettyprint

      public void requestAddTileService (
        ComponentName tileServiceComponentName,
        CharSequence tileLabel,
        Icon icon,
        Executor resultExecutor,
        Consumer<Integer> resultCallback
      )

   The callback contains information about whether or not the tile was added,
   not added, if it was already there, or if any error occurred.

   Use your discretion when deciding when and how often to prompt users. We
   recommend calling ``requestAddTileService()`` only in context – such as when
   the user first interacts with a feature that your tile facilitates.

   The system can choose to stop processing requests for a given
   `ComponentName <#android.content.ComponentName>`__ if it has
   been denied by the user enough times before. The user is determined from the
   `Context <#android.content.Context>`__ used to retrieve this
   service—it must match the current user.

   **Note:**\  We recommend calling ``requestAddTileService()`` to increase the
   discoverability of your tile and reduce the burden on the user to add your
   tile to their Quick Settings panel.


Last updated 2024-05-03 UTC.


/About app widgets
==================

.. https://developer.android.google.cn/develop/ui/views/appwidgets/overview?hl=en

.. container:: devsite-article-body

   Widgets are an essential aspect of home screen customization. You can think
   of them as "at-a-glance" views of an app's most important data and
   functionality that are accessible right on the user's home screen. Users can
   move widgets across their home screen panels, and, if supported, resize them
   to tailor the amount of information in the widget to their preference.

   This documentation introduces the different types of widgets you can create
   and the design principles to follow. To build an app widget using the Remove
   View APIs and XML layouts, see `Create a simple widget <#>`__. To build a widget using Kotlin and
   Compose style APIs, see `Jetpack Glance <#>`__.

   .. rubric:: Widget types
      :name: types

   As you plan your widget, think about what kind of widget you want to build.
   Widgets typically fall into one of the following categories:

   .. rubric:: Information widgets
      :name: info-widgets

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-5x2.png
      :alt: Example weather widget displaying Tokyo as mostly cloudy, 14
      degrees, and the projected temperature beginning at 4pm through 7pm
      :width: 300px

      **Figure 1.** An information widget from a weather app.

   Information widgets typically display crucial information elements and track
   how that information changes over time. Examples of information widgets are
   weather widgets, clock widgets, or sports score tracking widgets. Tapping
   information widgets typically launches the associated app and opens a
   detailed view of the widget information.

   .. rubric:: Collection widgets
      :name: collection-widgets

   Collection widgets specialize in displaying multiple elements of the same
   type, such as a collection of pictures from a gallery app, a collection of
   articles from a news app, or a collection of emails or messages from a
   communication app. Collection widgets can scroll vertically.

   Collection widgets typically focus on the following use cases:

   -  Browsing the collection.
   -  Opening an element of the collection to its detail view in the associated
      app.
   -  Interacting with elements, such as marking them done—with support for
      compound buttons in Android 12 (API level 31).

   .. rubric:: Control widgets
      :name: control-widgets

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/light-list.png
      :alt: A widget for an app called 'Light list,' displaying toggle switches
      labeled 'Bedroom,' 'Kitchen', and 'Living room,' with the first two toggle
      switches turned off
      :width: 300px

      **Figure 4.** Example of a control widget.

   The main purpose of a control widget is to display frequently used functions
   so that the user can trigger them from the home screen without having to open
   the app. You can think of them as remote controls for an app. An example of a
   control widget is a home control widget that lets users turn lights in the
   house on or off.

   Interacting with a control widget might open an associated detail view in the
   app. This depends on whether the control widget's function outputs any data,
   such as in the case of a search widget.

   .. rubric:: Hybrid widgets
      :name: hybrid-widgets

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/music.png
      :alt: A general music app showing buttons for 'thumbs down,' back,
      play/pause, forward, and 'thumbs up.' The artist and track are listed as
      'Artist' and 'Example music,' respectively.
      :width: 300px

      **Figure 5.** Example of a music app widget.

   While some widgets represent one of the types in the preceding
   sections—information, collection, or control—many widgets are hybrids that
   combine elements of different types. For example, a music player widget is
   primarily a control widget, but it also shows the user what track is
   currently playing, like an information widget.

   When planning your widget, design around one of the base types and add
   elements of other types as needed.

   .. rubric:: Integrate widgets with Google Assistant
      :name: voice

   Any type of widget can be displayed by Google Assistant in response to user
   voice commands. You can configure your widgets to fulfill `App Actions <https://developers.google.com/assistant/app>`__, enabling users to receive
   quick answers and interactive app experiences on Assistant surfaces like
   Android and `Android Auto <https://developers.google.cn/cars/design/android-auto/product-experience/system-ui/widgets>`__.
   For more details on widget fulfillment for Assistant, see `Integrate App
   Actions with Android widgets <https://developers.google.com/assistant/app/widgets>`__.

   .. rubric:: Widget limitations
      :name: limitations

   While widgets can be understood as "mini apps," there are certain limitations
   that are important to understand before you design your widget.

   .. rubric:: Gestures
      :name: gestures

   Because widgets live on the home screen, they have to co-exist with the
   navigation that is established there. This limits the gesture support that is
   available in a widget compared to a full-screen app. While apps might let
   users navigate between screens horizontally, that gesture is already taken on
   the home screen for the purpose of navigating between home screens.

   The only gestures available for widgets are **touch** and **vertical swipe**.

   .. rubric:: Elements
      :name: elements

   Given the limitations on gestures available for widgets, some UI building
   blocks that rely on restricted gestures are not available for widgets. For a
   complete list of supported building blocks and more information on layout
   restrictions, see `Create the widget layout <#layout>`__ and `Provide flexible widget layouts <#>`__.

   .. rubric:: Design guidelines
      :name: design

   .. rubric:: Widget content
      :name: content

   Widgets are a great way to attract a user to your app by "advertising" new
   and interesting content that is available in your app.

   Just like teasers on the front page of a newspaper, widgets consolidate and
   concentrate an app's information and provide a connection to richer detail
   within the app. You might say the widget is the information "snack" while the
   app is the "meal." Make sure your app shows more detail about an information
   item than what the widget displays.

   .. rubric:: Widget navigation
      :name: navigation

   In addition to the pure information content, consider making your widget
   provide navigation links to frequently used areas of your app. This lets
   users complete tasks more quickly and extends the functional reach of the app
   to the home screen.

   Good candidates for navigation links on widgets are:

   -  **Generative functions:** these are the functions that let the user create
      new content for an app, such as creating a new document or a new message.

   -  **Open the app at the top level:** tapping an information element usually
      navigates the user to a lower-level detail screen. Providing access to the
      top level of your application offers more navigation flexibility and can
      replace a dedicated app shortcut that users otherwise use to navigate to
      the app from the home screen. Using your application icon for this
      functionality can also provide your widget with a clear identity if the
      data you're displaying is ambiguous.

   .. rubric:: Widget resizing
      :name: resizing

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/clock.png
      :alt: Standard Google Clock widget
      :width: 300px

      **Figure 6.** Standard Google Clock widget.

   Touching & holding a resizable widget and then releasing it puts the widget
   into resize mode. Users can use the drag handles or the widget corners to set
   their preferred size.

   Resizing lets users adjust the height and width of a widget within the
   constraints of the home screen placement grid. You can decide whether your
   widget is freely resizable or constrained to horizontal or vertical size
   changes. You don't have to support resizing if your widget is inherently
   fixed-size.

   Letting users resize widgets has important benefits:

   -  They can fine-tune how much information they want to see on each widget.
   -  They can better influence the layout of widgets and shortcuts on their
      home panels.

   Plan a resize strategy for your widget according to the type of widget you're
   creating. List- or grid-based collection widgets are usually straightforward,
   because resizing the widget expands or contracts the vertical scrolling area.
   Regardless of the widget's size, the user can still scroll all information
   elements into view.

   Information widgets require more hands-on planning, because they aren't
   scrollable and all content has to fit within a given size. You must
   dynamically adjust your widget's content and layout to the size the user
   defines through the resize operation.

   In the example that follows, the user can resize a weather widget in three
   steps, exposing richer information about the weather at the current location
   as the widget grows.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-3x2.png
      :alt: Example weather widget in the smallest 3x2-grid size, and listing
      the location name (Tokyo), temperature (14°), and symbol indicating
      partially cloudy weather
      :width: 175px

      **Figure 7.** Example weather widget in a 3x2-grid 'small' size.

   | 

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-5x2.png
      :alt: Example weather widget in a 5x2 'medium' size, including all of the
      UI from the 3x2-grid size plus the label 'mostly cloudy' and forecast
      temperatures from 4pm through 7pm
      :width: 300px

      **Figure 8.** Example weather widget in a 5x2-grid 'medium' size.

   | 

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-5x4.png
      :alt: Example weather widget in a 5x4 'large' size, including all of the
      UI from the 3x2- and 5x2-grid sizes plus a forecast of the weather from
      Tuesday through Friday
      :width: 300px

      **Figure 9.** Example weather widget in the 5x4-grid 'large' size.

   For each widget size, determine how much of your app's information is
   displayed. For smaller sizes, concentrate on essential information, and then
   add contextual information as the widget grows horizontally and vertically.

   .. rubric:: Layout considerations
      :name: layout

   It's tempting to lay out your widgets according to the dimensions of the
   placement grid of a device that you develop with. This can be a useful
   initial approximation, but keep the following points in mind:

   -  Planning your widget resizing strategy across "size buckets" rather than
      variable grid dimensions gives you the most reliable results.
   -  The number, size, and spacing of cells can vary widely from device to
      device. Hence, it is very important that your widget is flexible and can
      accommodate more or less space than anticipated.
   -  As the user resizes a widget, the system responds with a dp size range in
      which your widget can redraw itself.
   -  Starting in Android 12, you can provide more refined size attributes and
      more flexible layouts. This includes:

      -  `Specifying widget size constraints <#specify-widget-size-constraints>`__.
         For example, you can specify the target size for your widget—in grid
         cells—as well as the maximum possible size.
      -  Providing `responsive layouts <#provide-responsive-layouts>`__,
         which change depending on the size of the widget.
      -  Providing `exact-size layouts <#provide-exact-layouts>`__,
         which let the launcher respond with size options for portrait and
         landscape mode, for phones, or with four sizes for foldables.
      -  Using `updated guidance and new APIs <#anatomy_determining_size>`__ to
         determine proper sizes for your widget.

   .. rubric:: Widget configuration by users
      :name: configuration

   Sometimes, the user needs to set up the widget before it can become useful.
   Think of an email widget where the user needs to select the mail folder
   before the inbox can be displayed or a static photo widget where the user has
   to assign a picture from the gallery to be displayed. Android widgets display
   their configuration choices right after the user drops the widget onto a home
   screen.

   **Note:**\  Android 12 adds new options to let you provide a more seamless
   configuration experience for users. See `Enable users to configure app widgets <#>`__ for details on letting
   users reconfigure already-placed widgets and skip the default configuration
   step.

   .. rubric:: Widget design checklist
      :name: checklist

   -  Focus on small portions of glanceable information on your widget. Expand
      on the information in your app.
   -  Choose the right widget type for your purpose.
   -  Plan how the content for your widget adapts to different sizes.
   -  Make your widget layout independent of orientation and device by making
      sure the layout can stretch and contract.
   -  Consider whether your widget needs any additional configuration.


Last updated 2024-05-03 UTC.


/Create a simple widget
=======================

.. https://developer.android.google.cn/develop/ui/views/appwidgets?hl=en

.. container:: devsite-article-body

   App widgets are miniature app views that you can be embed in other apps—such
   as the home screen—and receive periodic updates. These views are referred to
   as *widgets* in the user interface, and you can publish one with an app
   widget provider (or *widget provider*). An app component that holds other
   widgets is called an app widget host (or *widget host*). Figure 1 shows a
   sample music widget:

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/music.png
      :alt: Example of music widget
      :width: 300px

      **Figure 1.** Example of a music widget.

   This document describes how to publish a widget using a widget provider. For
   details about creating your own
   `AppWidgetHost <#android.appwidget.AppWidgetHost>`__ to host
   app widgets, see `Build a widget host <#>`__.

   For information about how to design your widget, see `App widgets overview <#>`__.

   .. rubric:: Widget components
      :name: components

   To create a widget, you need the following basic components:

   `AppWidgetProviderInfo <#android.appwidget.AppWidgetProviderInfo>`__ object
      Describes the metadata for a widget, such as the widget's layout, update
      frequency, and
      `AppWidgetProvider <#android.appwidget.AppWidgetProvider>`__
      class. ``AppWidgetProviderInfo`` is `defined in XML <#AppWidgetProviderInfo>`__, as described in this document.
   `AppWidgetProvider <#android.appwidget.AppWidgetProvider>`__ class
      Defines the basic methods that let you programmatically interface with the
      widget. Through it, you receive broadcasts when the widget is updated,
      enabled, disabled, or deleted. You `declare ``AppWidgetProvider`` in the
      manifest <#Manifest>`__ and then `implement <#AppWidgetProvider>`__ it, as
      described in this document.
   View layout
      Defines the initial layout for the widget. The layout is `defined in XML <#layout>`__, as described in this document.

   Figure 2 shows how these components fit into the overall app widget
   processing flow.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/flow-diagram.png
      :alt: App widget processing flow

      **Figure 2.** App widget processing flow.

   **Note:**\  Android Studio can automatically create a set of
   ``AppWidgetProviderInfo``, ``AppWidgetProvider``, and view layout files.
   Choose **New > Widget > App Widget**.
   If your widget needs user configuration, implement the app widget
   configuration activity. This activity lets users modify widget settings—for
   example, the time zone for a clock widget.

   -  Starting in Android 12 (API level 31), you can provide a default
      configuration and let users reconfigure the widget later. See `Use the
      widget's default configuration <#use-default>`__ and
      `Enable users to reconfigure placed widgets <#reconfigure-widgets>`__
      for more details.
   -  In Android 11 (API level 30) or lower, this activity is launched every
      time the user adds the widget to their home screen.

   We also recommend the following improvements: `flexible widget layouts <#>`__, `miscellaneous enhancements <#>`__, `advanced widgets <#>`__, `collection widgets <#>`__, and `building a widget host <#>`__.

   .. rubric:: Declare the AppWidgetProviderInfo XML
      :name: AppWidgetProviderInfo

   The ``AppWidgetProviderInfo`` object defines the essential qualities of a
   widget. Define the ``AppWidgetProviderInfo`` object in an XML resource file
   using a single ``<appwidget-provider>`` element and save it in the project's
   ``res/xml/`` folder.

   This is shown in the following example:

   .. code:: prettyprint

      <appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
          android:minWidth="40dp"
          android:minHeight="40dp"
          android:targetCellWidth="1"
          android:targetCellHeight="1"
          android:maxResizeWidth="250dp"
          android:maxResizeHeight="120dp"
          android:updatePeriodMillis="86400000"
          android:description="@string/example_appwidget_description"
          android:previewLayout="@layout/example_appwidget_preview"
          android:initialLayout="@layout/example_loading_appwidget"
          android:configure="com.example.android.ExampleAppWidgetConfigurationActivity"
          android:resizeMode="horizontal|vertical"
          android:widgetCategory="home_screen"
          android:widgetFeatures="reconfigurable|configuration_optional">
      </appwidget-provider>

   .. rubric:: Widget sizing attributes
      :name: widget-sizing-attributes

   The default home screen positions widgets in its window based on a grid of
   cells that have a defined height and width. Most home screens only let
   widgets take on sizes that are integer multiples of the grid cells—for
   example, two cells horizontally by three cells vertically.

   The widget sizing attributes let you specify a default size for your widget
   and provide lower and upper bounds on the size of the widget. In this
   context, the default size of a widget is the size that the widget takes on
   when it is first added to the home screen.

   The following table describes the ``<appwidget-provider>`` attributes
   pertaining to widget sizing:

   .. list-table::
      :widths: 40 40
      :header-rows: 1

      - 

         - Attributes and description
         - 
      - 

         - ``targetCellWidth`` and ``targetCellHeight`` (Android 12),
            ``minWidth`` and ``minHeight``
         - 

            -  Starting in Android 12, the ``targetCellWidth`` and
               ``targetCellHeight`` attributes specify the default size of the
               widget in terms of grid cells. These attributes *are* ignored in
               Android 11 and lower, and *can* be ignored if the home screen
               doesn't support a grid-based layout.
            -  The ``minWidth`` and ``minHeight`` attributes specify the default
               size of the widget in dp. If the values for a widget's minimum
               width or height don't match the dimensions of the cells, then the
               values are rounded up to the nearest cell size.

            We recommend specifying both sets of attributes—``targetCellWidth``
            and ``targetCellHeight``, and ``minWidth`` and ``minHeight``—so that
            your app can fall back to using ``minWidth`` and ``minHeight`` if
            the user's device doesn't support ``targetCellWidth`` and
            ``targetCellHeight``. If supported, the ``targetCellWidth`` and
            ``targetCellHeight`` attributes take precedence over the
            ``minWidth`` and ``minHeight`` attributes.
      - 

         - ``minResizeWidth`` and ``minResizeHeight``
         - Specify the widget's absolute minimum size. These values specify the
            size under which the widget is illegible or otherwise unusable.
            Using these attributes lets the user resize the widget to a size
            that is smaller than the default widget size. The ``minResizeWidth``
            attribute is ignored if it is greater than ``minWidth`` or if
            horizontal resizing isn't enabled. See
            `resizeMode <#resizemode>`__. Likewise, the ``minResizeHeight``
            attribute is ignored if it is greater than ``minHeight`` or if
            vertical resizing isn't enabled.
      - 

         - ``maxResizeWidth`` and ``maxResizeHeight``
         - Specify the widget's recommended maximum size. If the values aren't a
            multiple of the grid cell dimensions, they are rounded up to the
            nearest cell size. The ``maxResizeWidth`` attribute is ignored if it
            is smaller than ``minWidth`` or if horizontal resizing isn't
            enabled. See `resizeMode <#resizemode>`__. Likewise, the
            ``maxResizeHeight`` attribute is ignored if it is greater than
            ``minHeight`` or if vertical resizing isn't enabled. Introduced in
            Android 12.
      - 

         - ``resizeMode``
         - Specifies the rules by which a widget can be resized. You can use
            this attribute to make home screen widgets resizable horizontally,
            vertically, or on both axes. Users touch & hold a widget to show its
            resize handles, then drag the horizontal or vertical handles to
            change its size on the layout grid. Values for the ``resizeMode``
            attribute include ``horizontal``, ``vertical``, and ``none``. To
            declare a widget as resizable horizontally and vertically, use
            ``horizontal|vertical``.

   .. rubric:: Example
      :name: example

   To illustrate how the attributes in the preceding table affect widget sizing,
   assume the following specifications:

   -  A grid cell is 30 dp wide and 50 dp tall.
   -  The following attribute specification is provided:

   .. code:: prettyprint

      <appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
          android:minWidth="80dp"
          android:minHeight="80dp"
          android:targetCellWidth="2"
          android:targetCellHeight="2"
          android:minResizeWidth="40dp"
          android:minResizeHeight="40dp"
          android:maxResizeWidth="120dp"
          android:maxResizeHeight="120dp"
          android:resizeMode="horizontal|vertical" />

   **Starting with Android 12:**

   Use the ``targetCellWidth`` and ``targetCellHeight`` attributes as the
   default size of the widget.

   The widget's size is 2x2 by default. The widget can be resized down to 2x1 or
   up to 4x3.

   **Android 11 and lower:**

   Use the ``minWidth`` and ``minHeight`` attributes to compute the default size
   of the widget.

   The default width = ``Math.ceil(80 / 30)`` = 3

   The default height = ``Math.ceil(80 / 50)`` = 2

   The widget's size is 3x2 by default. The widget can be resized down to 2x1 or
   up to full screen.

   **Note:**\  The actual widget size computation is more complex than the
   preceding formula because it also includes widget margins and spacing between
   the grid cells.

   .. rubric:: Additional widget attributes
      :name: other-attributes

   The following table describes the ``<appwidget-provider>`` attributes
   pertaining to qualities other than widget sizing.

   .. list-table::
      :widths: 40 40
      :header-rows: 1

      - 

         - Attributes and description
         - 
      - 

         - ``updatePeriodMillis``
         - Defines how often the widget framework requests an update from the
            ``AppWidgetProvider`` by calling the ``onUpdate()`` callback method.
            The actual update isn't guaranteed to occur exactly on time with
            this value, and we recommend updating as infrequently as possible—no
            more than once an hour—to conserve the battery. For the full list of
            considerations to pick an appropriate update period, see
            `Optimizations for updating widget content <#update-widgets>`__.
      - 

         - ``initialLayout``
         - Points to the layout resource that defines the widget layout.
      - 

         - ``configure``
         - Defines the activity that launches when the user adds the widget,
            letting them configure widget properties. See `Enable users to configure widgets <#>`__.
            Starting in Android 12, your app can skip the initial configuration.
            See `Use the widget's default configuration <#use-default>`__
            for details.
      - 

         - ``description``
         - Specifies the description for the widget picker to display for your
            widget. Introduced in Android 12.
      - 

         - ``previewLayout`` (Android 12) and ``previewImage`` (Android 11 and
            lower)
         - 

            -  Starting in Android 12, the ``previewLayout`` attribute specifies
               a scalable preview, which you provide as an XML layout set to the
               widget's default size. Ideally, the layout XML specified as this
               attribute is the same layout XML as the actual widget with
               realistic default values.
            -  In Android 11 or lower, the ``previewImage`` attribute specifies
               a preview of what the widget looks like after it's configured,
               which the user sees when selecting the app widget. If not
               supplied, the user instead sees your app's launcher icon. This
               field corresponds to the ``android:previewImage`` attribute in
               the ``<receiver>`` element in the ``AndroidManifest.xml`` file.

            **Note:** We recommend specifying both the ``previewImage`` and
            ``previewLayout`` attributes so that your app can fall back to using
            ``previewImage`` if the user's device doesn't support
            ``previewLayout``. For more details, see `Backward compatibility
            with scalable widget previews <#bc-previews>`__.
      - 

         - ``autoAdvanceViewId``
         - Specifies the view ID of the widget subview that is auto-advanced by
            the widget's host.
      - 

         - ``widgetCategory``
         - Declares whether your widget can be displayed on the home screen
            (``home_screen``), the lock screen (``keyguard``), or both. For
            Android 5.0 and higher, only ``home_screen`` is valid.
      - 

         - ``widgetFeatures``
         - Declares features supported by the widget. For example, if you want
            your widget to use its default configuration when a user adds it,
            specify both the
            `configuration_optional <#android.appwidget.AppWidgetProviderInfo>`__
            and
            `reconfigurable <#android.appwidget.AppWidgetProviderInfo>`__
            flags. This bypasses launching the configuration activity after a
            user adds the widget. The user can still `reconfigure the widget <#reconfigure-widgets>`__
            afterward.

   .. rubric:: Use the AppWidgetProvider class to handle widget broadcasts
      :name: widget-broadcasts

   The ``AppWidgetProvider`` class handles widget broadcasts and updates the
   widget in response to widget lifecycle events. The following sections
   describe how to declare ``AppWidgetProvider`` in the manifest and then
   implement it.

   .. rubric:: Declare a widget in the manifest
      :name: Manifest

   First, declare the ``AppWidgetProvider`` class in your app's
   ``AndroidManifest.xml`` file, as shown in the following example:

   .. code:: prettyprint

      <receiver android:name="ExampleAppWidgetProvider"
                       android:exported="false">
          <intent-filter>
              <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
          </intent-filter>
          <meta-data android:name="android.appwidget.provider"
                     android:resource="@xml/example_appwidget_info" />
      </receiver>

   The ``<receiver>`` element requires the ``android:name`` attribute, which
   specifies the ``AppWidgetProvider`` used by the widget. The component must
   not be exported unless a separate process needs to broadcast to your
   ``AppWidgetProvider``, which usually isn't the case.

   The ``<intent-filter>`` element must include an ``<action>`` element with the
   ``android:name`` attribute. This attribute specifies that the
   ``AppWidgetProvider`` accepts the
   `ACTION_APPWIDGET_UPDATE <#android.appwidget.AppWidgetManager>`__
   broadcast. This is the only broadcast that you must explicitly declare. The
   `AppWidgetManager <#android.appwidget.AppWidgetManager>`__
   automatically sends all other widget broadcasts to the ``AppWidgetProvider``
   as necessary.

   The ``<meta-data>`` element specifies the ``AppWidgetProviderInfo`` resource
   and requires the following attributes:

   -  ``android:name``: specifies the metadata name. Use
      ``android.appwidget.provider`` to identify the data as the
      ``AppWidgetProviderInfo`` descriptor.
   -  ``android:resource``: specifies the ``AppWidgetProviderInfo`` resource
      location.

   .. rubric:: Implement the AppWidgetProvider class
      :name: AppWidgetProvider

   The ``AppWidgetProvider`` class extends
   `BroadcastReceiver <#android.content.BroadcastReceiver>`__ as a
   convenience class to handle widget broadcasts. It receives only the event
   broadcasts that are relevant to the widget, such as when the widget is
   updated, deleted, enabled, and disabled. When these broadcast events occur,
   the following ``AppWidgetProvider`` methods are called:

   `onUpdate() <#android.appwidget.AppWidgetProvider>`__
      This is called to update the widget at intervals defined by the
      ``updatePeriodMillis`` attribute in the ``AppWidgetProviderInfo``. See the
      `table describing additional widget attributes <#other-attributes>`__ in
      this page for more information.
      This method is also called when the user adds the widget, so it performs
      the essential setup such as defining event handlers for
      `View <#android.view.View>`__ objects or starting jobs to
      load data to display in the widget. However, if you declare a
      configuration activity without the ``configuration_optional`` flag, this
      method is *not* called when the user adds the widget, but it *is* called
      for the subsequent updates. It is the responsibility of the configuration
      activity to perform the first update when configuration is complete. See
      `Enable users to configure app widgets <#>`__ for more information.
      The most important callback is ``onUpdate()``. See `Handle events with the ``onUpdate()`` class <#handle-events>`__ in this page for more
      information.
   `onAppWidgetOptionsChanged() <#android.appwidget.AppWidgetProvider>`__
      This is called when the widget is first placed and any time the widget is
      resized. Use this callback to show or hide content based on the widget's
      size ranges. Get the size ranges—and, starting in Android 12, the list of
      possible sizes a widget instance can take—by calling
      `getAppWidgetOptions() <#android.appwidget.AppWidgetManager>`__,
      which returns a `Bundle <#android.os.Bundle>`__ that
      includes the following:

      -  `OPTION_APPWIDGET_MIN_WIDTH <#android.appwidget.AppWidgetManager>`__:
         contains the lower bound on the width, in dp units, of a widget
         instance.
      -  `OPTION_APPWIDGET_MIN_HEIGHT <#android.appwidget.AppWidgetManager>`__:
         contains the lower bound on the height, in dp units, of a widget
         instance.
      -  `OPTION_APPWIDGET_MAX_WIDTH <#android.appwidget.AppWidgetManager>`__:
         contains the upper bound on the width, in dp units, of a widget
         instance.
      -  `OPTION_APPWIDGET_MAX_HEIGHT <#android.appwidget.AppWidgetManager>`__:
         contains the upper bound on the height, in dp units, of a widget
         instance.
      -  `OPTION_APPWIDGET_SIZES <#android.appwidget.AppWidgetManager>`__:
         contains the list of possible sizes (``List<SizeF>``), in dp units,
         that a widget instance can take. Introduced in Android 12.

   `onDeleted(Context, int[]) <#android.appwidget.AppWidgetProvider>`__
      This is called every time a widget is deleted from the widget host.

   `onEnabled(Context) <#android.appwidget.AppWidgetProvider>`__
      This is called when an instance of the widget is created for the first
      time. For example, if the user adds two instances of your widget, this is
      only called the first time. If you need to open a new database or perform
      another setup that only needs to occur once for all widget instances, then
      this is a good place to do it.

   `onDisabled(Context) <#android.appwidget.AppWidgetProvider>`__
      This is called when the last instance of your widget is deleted from the
      widget host. This is where you clean up any work done in
      ``onEnabled(Context)``, such as deleting a temporary database.

   `onReceive(Context, Intent) <#android.appwidget.AppWidgetProvider>`__
      This is called for every broadcast and before each of the preceding
      callback methods. You normally don't need to implement this method,
      because the default ``AppWidgetProvider`` implementation filters all
      widget broadcasts and calls the preceding methods as appropriate.

   You must declare your ``AppWidgetProvider`` class implementation as a
   broadcast receiver using the ``<receiver>`` element in the
   ``AndroidManifest``. See `Declare a widget in the manifest <#Manifest>`__ in
   this page for more information.

   .. rubric:: Handle events with the onUpdate() class
      :name: handle-events

   The most important ``AppWidgetProvider`` callback is ``onUpdate()``, because
   it is called when each widget is added to a host, unless you use a
   configuration activity without the ``configuration_optional`` flag. If your
   widget accepts any user interaction events, then register the event handlers
   in this callback. If your widget doesn't create temporary files or databases,
   or perform other work that requires clean-up, then ``onUpdate()`` might be
   the only callback method you need to define.

   For example, if you want a widget with a button that launches an activity
   when tapped, you can use the following implementation of
   ``AppWidgetProvider``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class ExampleAppWidgetProvider : AppWidgetProvider() {

                   override fun onUpdate(
                           context: Context,
                           appWidgetManager: AppWidgetManager,
                           appWidgetIds: IntArray
                   ) {
                       // Perform this loop procedure for each widget that belongs to this
                       // provider.
                       appWidgetIds.forEach { appWidgetId ->
                           // Create an Intent to launch ExampleActivity.
                           val pendingIntent: PendingIntent = PendingIntent.getActivity(
                                   /* context = */ context,
                                   /* requestCode = */  0,
                                   /* intent = */ Intent(context, ExampleActivity::class.java),
                                   /* flags = */ PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                           )

                           // Get the layout for the widget and attach an onClick listener to
                           // the button.
                           val views: RemoteViews = RemoteViews(
                                   context.packageName,
                                   R.layout.appwidget_provider_layout
                           ).apply {
                               setOnClickPendingIntent(R.id.button, pendingIntent)
                           }

                           // Tell the AppWidgetManager to perform an update on the current
                           // widget.
                           appWidgetManager.updateAppWidget(appWidgetId, views)
                       }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class ExampleAppWidgetProvider extends AppWidgetProvider {

                   public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
                       // Perform this loop procedure for each widget that belongs to this
                       // provider.
                       for (int i=0; i < appWidgetIds.length; i++) {
                           int appWidgetId = appWidgetIds[i];
                           // Create an Intent to launch ExampleActivity
                           Intent intent = new Intent(context, ExampleActivity.class);
                           PendingIntent pendingIntent = PendingIntent.getActivity(
                               /* context = */ context,
                               /* requestCode = */ 0,
                               /* intent = */ intent,
                               /* flags = */ PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
                           );

                           // Get the layout for the widget and attach an onClick listener to
                           // the button.
                           RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.example_appwidget_layout);
                           views.setOnClickPendingIntent(R.id.button, pendingIntent);

                           // Tell the AppWidgetManager to perform an update on the current app
                           // widget.
                           appWidgetManager.updateAppWidget(appWidgetId, views);
                       }
                   }
               }

   This ``AppWidgetProvider`` defines only the ``onUpdate()`` method, using it
   to create a `PendingIntent <#android.app.PendingIntent>`__ that
   launches an `Activity <#android.app.Activity>`__ and attaches
   it to the widget's button using
   `setOnClickPendingIntent(int, PendingIntent) <#android.widget.RemoteViews>`__.
   It includes a loop that iterates through each entry in ``appWidgetIds``,
   which is an array of IDs that identify each widget created by this provider.
   If the user creates more than one instance of the widget, then they all
   update simultaneously. However, only one ``updatePeriodMillis`` schedule is
   managed for all instances of the widget. For example, if the update schedule
   is defined to be every two hours, and a second instance of the widget is
   added one hour after the first one, then they're both updated on the period
   defined by the first, and the second update period is ignored. They both
   update every two hours, not every hour.

   **Note:**\  Because ``AppWidgetProvider`` is an extension of
   ``BroadcastReceiver``, your process isn't guaranteed to keep running after
   the callback methods return. See
   `BroadcastReceiver <#android.content.BroadcastReceiver>`__ for
   information about the broadcast lifecycle. If your widget setup process can
   take several seconds—such as when performing web requests—and you require
   that your process continues, consider starting a ``Task`` using
   `WorkManager <#>`__ in the
   ``onUpdate()`` method. From within the task, you can perform your own updates
   to the widget without worrying about the ``AppWidgetProvider`` closing down
   due to an `Application Not Responding <#>`__
   (ANR) error.
   See the
   `ExampleAppWidgetProvider.java <https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/appwidget/ExampleAppWidgetProvider.java>`__
   sample class for more details.

   .. rubric:: Receive widget broadcast intents
      :name: receive-intents

   ``AppWidgetProvider`` is a convenience class. If you want to receive the
   widget broadcasts directly, you can implement your own ``BroadcastReceiver``
   or override the
   `onReceive(Context,Intent) <#android.appwidget.AppWidgetProvider>`__
   callback. The intents you need to care about are the following:

   -  `ACTION_APPWIDGET_UPDATE <#android.appwidget.AppWidgetManager>`__
   -  `ACTION_APPWIDGET_DELETED <#android.appwidget.AppWidgetManager>`__
   -  `ACTION_APPWIDGET_ENABLED <#android.appwidget.AppWidgetManager>`__
   -  `ACTION_APPWIDGET_DISABLED <#android.appwidget.AppWidgetManager>`__
   -  `ACTION_APPWIDGET_OPTIONS_CHANGED <#android.appwidget.AppWidgetManager>`__

   .. rubric:: Create the widget layout
      :name: layout

   You must define an initial layout for your widget in XML and save it in the
   project's ``res/layout/`` directory. Refer to `Design guidelines <#design>`__ for details.

   Creating the widget layout is straightforward if you're familiar with
   `layouts <#>`__. However, be aware that
   widget layouts are based on
   `RemoteViews <#android.widget.RemoteViews>`__, which doesn't
   support every kind of layout or view widget. You can't use custom views or
   subclasses of the views that are supported by ``RemoteViews``.

   ``RemoteViews`` also supports
   `ViewStub <#android.view.ViewStub>`__, which is an invisible,
   zero-sized ``View`` you can use to lazily inflate layout resources at
   runtime.

   .. rubric:: Support for stateful behavior
      :name: stateful-behavior

   Android 12 adds support for stateful behavior using the following existing
   components:

   -  `CheckBox <#>`__

   -  `Switch <#android.widget.Switch>`__

   -  `RadioButton <#android.widget.RadioButton>`__

   The widget is still stateless. Your app must store the state and register for
   state change events.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/home.png
      :alt: Example of shopping list widget showing stateful behavior
      :width: 300px

      **Figure 3.** Example of stateful behavior.

   **Note:**\  Always explicitly set the current checked state using
   ``RemoteViews.setCompoundButtonChecked``, or you might encounter unexpected
   results when your widget is dragged or resized.
   The following code example shows how to implement these components.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Check the view.
               remoteView.setCompoundButtonChecked(R.id.my_checkbox, true)

               // Check a radio group.
               remoteView.setRadioGroupChecked(R.id.my_radio_group, R.id.radio_button_2)

               // Listen for check changes. The intent has an extra with the key
               // EXTRA_CHECKED that specifies the current checked state of the view.
               remoteView.setOnCheckedChangeResponse(
                       R.id.my_checkbox,
                       RemoteViews.RemoteResponse.fromPendingIntent(onCheckedChangePendingIntent)
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Check the view.
               remoteView.setCompoundButtonChecked(R.id.my_checkbox, true);

               // Check a radio group.
               remoteView.setRadioGroupChecked(R.id.my_radio_group, R.id.radio_button_2);

               // Listen for check changes. The intent has an extra with the key
               // EXTRA_CHECKED that specifies the current checked state of the view.
               remoteView.setOnCheckedChangeResponse(
                   R.id.my_checkbox,
                   RemoteViews.RemoteResponse.fromPendingIntent(onCheckedChangePendingIntent));

   Provide two layouts: one targeting devices running Android 12 or higher in
   ``res/layout-v31``, and the other targeting previous Android 11 or lower in
   the default ``res/layout`` folder.

   .. rubric:: Implement rounded corners
      :name: rounded-corner

   Android 12 introduces the following system parameters to set the radii of
   your widget's rounded corners:

   -  `system_app_widget_background_radius <#android.R.dimen>`__:
      the corner radius of the widget background, which is never larger than
      28 dp.

   -  `system_app_widget_inner_radius <#android.R.dimen>`__:
      the corner radius of any view inside the widget. This is exactly 8 dp less
      than the background radius, to align nicely when using an 8 dp padding.

   The following example shows a widget that uses
   ``system_app_widget_background_radius`` for the corner of the widget and
   ``system_app_widget_inner_radius`` for views inside the widget.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/widget-weather.png
      :alt: Widget showing radii of the widget background and views inside the
      widget
      :width: 300px

      **Figure 4.** Rounded corners.

   1 Corner of the widget.

   2 Corner of a view inside the widget.

   **Important considerations for rounded corners**

   -  Third-party launchers and device manufacturers can override the
      ``system_app_widget_background_radius`` parameter to be smaller than
      28 dp. The ``system_app_widget_inner_radius`` parameter is always 8 dp
      less than the value of ``system_app_widget_background_radius``.
   -  If your widget doesn't use ``@android:id/background`` or define a
      background that clips its content based on the outline—with
      ``android:clipToOutline`` set to ``true``—the launcher automatically
      identifies the background and clips the widget using a rectangle with
      rounded corners of up to 16 dp. See `Ensure your widget is compatible with Android 12 <#ensure-compatibility>`__.

   For widget compatibility with previous versions of Android, we recommend
   defining custom attributes and using a custom theme to override them for
   Android 12, as shown in the following sample XML files:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: ``/values/attrs.xml``
            :name: valuesattrs.xml

         .. code:: prettyprint

            <resources>
              <attr name="backgroundRadius" format="dimension" />
            </resources>

      .. container:: section

         .. rubric:: ``/values/styles.xml``
            :name: valuesstyles.xml

         .. code:: prettyprint

            <resources>
              <style name="MyWidgetTheme">
                <item name="backgroundRadius">@dimen/my_background_radius_dimen</item>
              </style>
            </resources>

      .. container:: section

         .. rubric:: ``/values-31/styles.xml``
            :name: values-31styles.xml

         .. code:: prettyprint

            <resources>
              <style name="MyWidgetTheme" parent="@android:style/Theme.DeviceDefault.DayNight">
                <item name="backgroundRadius">@android:dimen/system_app_widget_background_radius</item>
              </style>
            </resources>

      .. container:: section

         .. rubric:: ``/drawable/my_widget_background.xml``
            :name: drawablemy_widget_background.xml

         .. code:: prettyprint

            <shape xmlns:android="http://schemas.android.com/apk/res/android"
              android:shape="rectangle">
              <corners android:radius="?attr/backgroundRadius" />
              ...
            </shape>

      .. container:: section

         .. rubric:: ``/layout/my_widget_layout.xml``
            :name: layoutmy_widget_layout.xml

         .. code:: prettyprint

            <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              ...
              android:background="@drawable/my_widget_background" />


Last updated 2024-05-03 UTC.


/Enhance your widget
====================

.. https://developer.android.google.cn/develop/ui/views/appwidgets/enhance?hl=en

.. container:: devsite-article-body

   This page includes details for optional widget enhancements that are
   available starting in Android 12 (API level 31). These features are optional,
   but they're straightforward to implement and improve your users' widget
   experience.

   .. rubric:: Use dynamic colors
      :name: dynamic-colors

   Starting in Android 12, a widget can use the device theme colors for buttons,
   backgrounds, and other components. This provides smoother transitions and
   consistency across different widgets.

   There are two ways to achieve dynamic colors:

   -  Use the system's default theme
      (``@android:style/Theme.DeviceDefault.DayNight``) in the root layout.

   -  Use the Material 3 theme (``Theme.Material3.DynamicColors.DayNight``) from
      the `Material Components for Android <https://github.com/material-components/material-components-android>`__
      library, available starting in `Material Components for Android v1.6.0 <https://github.com/material-components/material-components-android/releases/tag/1.6.0>`__.

   Once the theme is set in the root layout, you can use common color attributes
   in the root or any of its children to pick up the dynamic colors.

   Some examples of color attributes you can use are the following:

   -  ``?attr/primary``
   -  ``?attr/primaryContainer``
   -  ``?attr/onPrimary``
   -  ``?attr/onPrimaryContainer``

   In the following example using the Material 3 theme, the device's theme color
   is "purplish." The accent color and widget background adapt for light and
   dark modes, as shown in figures 1 and 2.

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="?attr/colorPrimaryContainer"
        android:theme="@style/Theme.Material3.DynamicColors.DayNight">

        <ImageView
          ...
          app:tint="?attr/colorPrimaryContainer"
          android:src="@drawable/ic_partly_cloudy" />

          <!-- Other widget content. -->

      </LinearLayout>

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/example-lightmode.png
      :alt: Widget in light mode theme
      :width: 300px

      **Figure 1.** Widget in light theme.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/example-darkmode.png
      :alt: Widgets in dark mode theme
      :width: 300px

      **Figure 2.** Widget in dark theme.

   **Tip:**\  We recommend using the `Material 3 <https://m3.material.io>`__
   theme to follow Material Design guidelines for consistency between devices
   and for backward compatibility.

   .. rubric:: Backward compatibility for dynamic colors
      :name: backward-compatibility

   Dynamic colors are only available in devices running Android 12 or higher. To
   provide a custom theme for lower versions, create a default theme with your
   custom colors and a new qualifier (``values-v31``) using the default theme
   attributes.

   Here is an example using the Material 3 theme:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: ``/values/styles.xml``
            :name: valuesstyles.xml

         .. code:: prettyprint

            <resources>
              <style name="MyWidgetTheme" parent="Theme.Material3.DynamicColors.DayNight">
                <!-- Override default colorBackground attribute with custom color. -->
                <item name="android:colorBackground">@color/my_background_color</item>

                <!-- Add other colors/attributes. -->

              </style>
            </resources>

      .. container:: section

         .. rubric:: ``/values-v31/styles.xml``
            :name: values-v31styles.xml

         .. code:: prettyprint

            <resources>
              <!-- Do not override any color attribute. -->
              <style name="MyWidgetTheme" parent="Theme.Material3.DynamicColors.DayNight" />
            </resources>

      .. container:: section

         .. rubric:: ``/layout/my_widget_layout.xml``
            :name: layoutmy_widget_layout.xml

         .. code:: prettyprint

            <resources>
              <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                ...
                android:background="?android:attr/colorBackground"
                android:theme="@style/MyWidgetTheme" />
            </resources>

   **Note:**\  See `Styles and Themes <#>`__
   for an in-depth guide to handling different styles, colors, attributes, and
   themes.

   .. rubric:: Enable voice support
      :name: voice

   `App Actions <https://developers.google.com/assistant/app>`__ let Google Assistant
   display widgets in response to relevant user voice commands. By configuring
   your widget to respond to `built-in intents (BIIs) <#>`__, your app can proactively display
   widgets on Assistant surfaces such as Android and Android Auto. Users have
   the option to `pin widgets <#pinning>`__ displayed
   by Assistant to their launcher, encouraging future engagement.

   For example, you can configure the workout summary widget for your exercise
   app to fulfill the user voice commands that trigger the
   `GET_EXERCISE_OBSERVATION <#>`__
   BII. Assistant proactively displays your widget when users trigger this BII
   by making requests like, *"Hey Google, how many miles did I run this week on
   ExampleApp?"*

   There are dozens of BIIs covering several categories of user interaction,
   letting almost any Android app enhance their widgets for voice. To get
   started, see `Integrate App Actions with Android widgets <#>`__.

   .. rubric:: Improve your app's widget picker experience
      :name: improve-widget-picker-experience

   Android 12 lets you improve the widget picker experience for your app by
   adding dynamic widget previews and widget descriptions.

   .. rubric:: Add scalable widget previews to the widget picker
      :name: add-scalable-widget-previews

   Starting in Android 12, the widget preview displayed in the widget picker is
   scalable. You provide it as an XML layout set to the widget's default size.
   Previously, the widget preview was a static drawable resource, in some cases
   leading to previews inaccurately reflecting how widgets appear when they are
   added to the home screen.

   To implement scalable widget previews, use the
   `previewLayout <#android.appwidget.AppWidgetProviderInfo>`__
   attribute of the ``appwidget-provider`` element to provide an XML layout
   instead:

   .. code:: prettyprint

      <appwidget-provider
          android:previewLayout="@layout/my_widget_preview">
      </appwidget-provider>

   We recommend using the same layout as the actual widget, with realistic
   default or test values. Most apps use the same ``previewLayout`` and
   ``initialLayout``. For guidance on creating accurate preview layouts, see the
   following section in this page.

   We recommend specifying both the ``previewLayout`` and ``previewImage``
   attributes, so that your app can fall back to using ``previewImage`` if the
   user's device doesn't support ``previewLayout``. The ``previewLayout``
   attribute takes precedence over the ``previewImage`` attribute.

   .. rubric:: Recommended approaches for building accurate previews
      :name: approaches-previews

   To implement scalable widget previews, use the ``previewLayout`` attribute of
   the ``appwidget-provider`` element to provide an XML layout:

   .. code:: prettyprint

      <appwidget-provider
          ...
          android:previewLayout="@layout/my_widget_preview">
      </appwidget-provider>

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/todo-list-groceries.png
      name: preview
      :alt: An image showing a widget preview
      :width: 30.0%

      **Figure 3.** A widget preview that by default appears in a 3x3 area but
      can fit in a 3x1 area because of its XML layout.

   To display an accurate preview, you can directly provide the actual widget
   layout with default values by completing the following steps:

   -  Setting ``android:text="@string/my_widget_item_fake_1"`` for ``TextView``
      elements.

      **Note:**\  Values set using the ``tools`` tag, such as
      ``tools:text="@string/my_wdiget_item_fake_1"``, aren't shown in the
      preview.

   -  Setting a default or placeholder image or icon, such as
      ``android:src="@drawable/my_widget_icon"``, for ``ImageView`` components.

   Without default values, the preview might show incorrect or empty values. An
   important benefit of this approach is that you can provide localized preview
   content.

   For recommended approaches for more complex previews that contain
   ``ListView``, ``GridView``, or ``StackView``, see `Build accurate previews
   that include dynamic items <#build-accurate-previews>`__ for
   details.

   .. rubric:: Backward compatibility with scalable widget previews
      :name: bc-previews

   To let widget pickers on Android 11 (API level 30) or lower show previews of
   your widget, specify the
   `previewImage <#preview>`__ attribute.

   If you change the widget's appearance, update the preview image.

   .. rubric:: Add a description for your widget
      :name: add-widget-description

   Starting in Android 12, provide a description for the widget picker to
   display for your widget.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/description.png
      name: picker
      :alt: An image showing a widget picker showing a widget and its
      description
      :width: 40.0%

      **Figure 4.** Sample widget picker showing a widget and its description.

   Provide a description for your widget using the ``description`` attribute of
   the ``&lt;appwidget-provider&gt;`` element:

   .. code:: prettyprint

      <appwidget-provider
          android:description="@string/my_widget_description">
      </appwidget-provider>

   **Note:**\  Be concise. There is no character limit, but the representation
   and available space for the description might differ depending on the device.
   You can use the
   `descriptionRes <#android.appwidget.AppWidgetProviderInfo>`__
   attribute on previous versions of Android, but it is ignored by the widget
   picker.

   .. rubric:: Enable smoother transitions
      :name: enable-smoother-transitions

   Starting in Android 12, launchers provide a smoother transition when a user
   launches your app from a widget.

   To enable this improved transition, use ``@android:id/background`` or
   ``android.R.id.background`` to identify your background element:

   .. code:: prettyprint

      // Top-level layout of the widget.
      <LinearLayout
          android:id="@android:id/background">
      </LinearLayout>

   **Warning:**\  Avoid using `broadcast trampolines <#notification-trampolines>`__.
   Starting in Android 12, an app can still launch an activity from a broadcast
   receiver or service if it's initiated from a widget click's
   `PendingIntent <#android.app.PendingIntent>`__. However, the
   new app animation isn't used for apps launched from a broadcast receiver or
   service, which leads to a poor user experience.
   Your app can use ``@android:id/background`` on previous versions of Android
   without breaking, but it is ignored.

   .. rubric:: Use runtime modification of RemoteViews
      :name: use-runtime-mod-of-remoteviews

   Starting in Android 12, you can take advantage of several ``RemoteViews``
   methods that provide for runtime modification of ``RemoteViews`` attributes.
   See the `RemoteViews <#android.widget.RemoteViews>`__ API
   reference for the full list of added methods.

   The following code example shows how to use a few of these methods.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               // Set the colors of a progress bar at runtime.
               remoteView.setColorStateList(R.id.progress, "setProgressTintList", createProgressColorStateList())

               // Specify exact sizes for margins.
               remoteView.setViewLayoutMargin(R.id.text, RemoteViews.MARGIN_END, 8f, TypedValue.COMPLEX_UNIT_DP)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               // Set the colors of a progress bar at runtime.
               remoteView.setColorStateList(R.id.progress, "setProgressTintList", createProgressColorStateList());

               // Specify exact sizes for margins.
               remoteView.setViewLayoutMargin(R.id.text, RemoteViews.MARGIN_END, 8f, TypedValue.COMPLEX_UNIT_DP);


Last updated 2024-05-03 UTC.


/Create an advanced widget
==========================

.. https://developer.android.google.cn/develop/ui/views/appwidgets/advanced?hl=en

.. container:: devsite-article-body

   This page explains recommended practices for creating a more advanced widget
   for a better user experience.

   .. rubric:: Optimizations for updating widget content
      :name: update-widgets

   Updating widget content can be computationally expensive. To save battery
   consumption, optimize the update type, frequency, and timing.

   .. rubric:: Types of widget updates
      :name: types

   There are three ways to update a widget: a full update, a partial update,
   and, in the case of a collection widget, a data refresh. Each has different
   computational costs and ramifications.

   The following describes each update type and provides code snippets for each.

   -  **Full update:** call
      `AppWidgetManager.updateAppWidget(int, android.widget.RemoteViews) <#android.appwidget.AppWidgetManager>`__
      to fully update the widget. This replaces the previously provided
      `RemoteViews <#android.widget.RemoteViews>`__ with a new
      ``RemoteViews``. This is the most computationally expensive update.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val appWidgetManager = AppWidgetManager.getInstance(context)
                  val remoteViews = RemoteViews(context.getPackageName(), R.layout.widgetlayout).also {
                  setTextViewText(R.id.textview_widget_layout1, "Updated text1")
                  setTextViewText(R.id.textview_widget_layout2, "Updated text2")
                  }
                  appWidgetManager.updateAppWidget(appWidgetId, remoteViews)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
                  RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widgetlayout);
                  remoteViews.setTextViewText(R.id.textview_widget_layout1, "Updated text1");
                  remoteViews.setTextViewText(R.id.textview_widget_layout2, "Updated text2");
                  appWidgetManager.updateAppWidget(appWidgetId, remoteViews);

   -  **Partial update:** call
      `AppWidgetManager.partiallyUpdateAppWidget <#android.appwidget.AppWidgetManager>`__
      to update parts of the widget. This merges the new ``RemoteViews`` with
      the previously provided ``RemoteViews``. This method is ignored if a
      widget doesn't receive at least one full update through
      `updateAppWidget(int[], RemoteViews) <#android.appwidget.AppWidgetManager>`__.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val appWidgetManager = AppWidgetManager.getInstance(context)
                  val remoteViews = RemoteViews(context.getPackageName(), R.layout.widgetlayout).also {
                  setTextViewText(R.id.textview_widget_layout, "Updated text")
                  }
                  appWidgetManager.partiallyUpdateAppWidget(appWidgetId, remoteViews)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
                  RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widgetlayout);
                  remoteViews.setTextViewText(R.id.textview_widget_layout, "Updated text");
                  appWidgetManager.partiallyUpdateAppWidget(appWidgetId, remoteViews);

   -  **Collection data refresh:** call
      `AppWidgetManager.notifyAppWidgetViewDataChanged <#android.appwidget.AppWidgetManager>`__
      to invalidate the data of a collection view in your widget. This triggers
      `RemoteViewsFactory.onDataSetChanged <#android.widget.RemoteViewsService.RemoteViewsFactory>`__.
      In the interim, the old data is displayed in the widget. You can safely
      perform expensive tasks synchronously with this method.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val appWidgetManager = AppWidgetManager.getInstance(context)
                  appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetId, R.id.widget_listview)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
                  appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetId, R.id.widget_listview);

   You can call these methods from anywhere in your app, as long as the app has
   the same UID as the corresponding
   `AppWidgetProvider <#android.appwidget.AppWidgetProvider>`__
   class.

   .. rubric:: Determine how often to update a widget
      :name: how-often

   Widgets are updated periodically depending on the value provided for the
   `updatePeriodMillis <#android.appwidget.AppWidgetProviderInfo>`__
   attribute. The widget can update in response to user interaction, broadcast
   updates, or both.

   .. rubric:: Update periodically
      :name: periodic

   You can control the frequency of the periodic update by specifying a value
   for ``AppWidgetProviderInfo.updatePeriodMillis`` in the
   ``appwidget-provider`` XML. Each update triggers the
   ``AppWidgetProvider.onUpdate()`` method, which is where you can place the
   code to update the widget. However, consider the `alternatives for broadcast receiver updates <#broadcastreceiver-duration>`__ described in a following
   section if your widget needs to load data asynchronously or takes more than
   10 seconds to update, because after 10 seconds, the system considers a
   ``BroadcastReceiver`` to be non-responsive.

   ``updatePeriodMillis`` doesn't support values of less than 30 minutes.
   However, if you want to disable periodic updates, you can specify 0.

   You can let users adjust the frequency of updates in a configuration. For
   example, they might want a stock ticker to update every 15 minutes or only
   four times a day. In this case, set the ``updatePeriodMillis`` to 0 and use
   `WorkManager <#>`__ instead.

   **Note:**\  Using repeating tasks with ``WorkManager`` is a good option, but
   similar power restrictions apply. See `App Standby Buckets <#buckets>`__ for more information.

   .. rubric:: Update in response to a user interaction
      :name: user-interaction

   Here are some recommended ways to update the widget based on user
   interaction:

   -  **From an activity of the app:** directly call
      ``AppWidgetManager.updateAppWidget`` in response to a user interaction,
      such as a user's tap.

   -  **From remote interactions, such as a notification or an app widget:**
      construct a ``PendingIntent``, then update the widget from the invoked
      ``Activity``, ``Broadcast``, or ``Service``. You can choose your own
      priority. For example, if you select a ``Broadcast`` for the
      ``PendingIntent``, you can choose a `foreground broadcast <#broadcastreceiver-priority>`__ to give the
      ``BroadcastReceiver`` priority.

   .. rubric:: Update in response to a broadcast event
      :name: broadcast-event

   An example of a broadcast event that requires a widget to update is when the
   user takes a photo. In this case, you want to update the widget when a new
   photo is detected.

   You can schedule a job with ``JobScheduler`` and specify a broadcast as the
   trigger using the
   `JobInfo.Builder.addTriggerContentUri <#android.app.job.JobInfo.Builder>`__
   method.

   You can also register a ``BroadcastReceiver`` for the broadcast—for example,
   listening for
   `ACTION_LOCALE_CHANGED <#android.content.Intent>`__.
   However, because this consumes device resources, use this with care and
   listen only to the specific broadcast. With the introduction of `broadcast limitations <#broadcasts>`__ in Android 7.0
   (API level 24) and Android 8.0 (API level 26), apps can't register implicit
   broadcasts in their manifests, with certain
   `exceptions <#>`__.

   .. rubric:: Considerations when updating a widget from a BroadcastReceiver
      :name: broadcastreceiver-considerations

   If the widget is updated from a ``BroadcastReceiver``, including
   ``AppWidgetProvider``, be aware of the following considerations regarding the
   duration and priority of a widget update.

   .. rubric:: Duration of the update
      :name: broadcastreceiver-duration

   As a rule, the system lets broadcast receivers, which usually run in the
   app’s main thread, run for up to 10 seconds before considering them
   non-responsive and triggering an `Application Not Responding <#>`__ (ANR) error. If it takes longer
   to update the widget, consider the following alternatives:

   -  Schedule a task using
      `WorkManager <#androidx.work.WorkManager>`__.

   -  Give the receiver more time with the
      `goAsync <#android.content.BroadcastReceiver>`__
      method. This lets receivers execute for 30 seconds.

      **Caution:**\  Any work you do here blocks further broadcasts until it
      completes, so it can slow the receiving of later events.

   See `Security considerations and best practices <#security-and-best-practices>`__ for
   more information.

   .. rubric:: Priority of the update
      :name: broadcastreceiver-priority

   By default, broadcasts—including those made using
   ``AppWidgetProvider.onUpdate``—run as background processes. This means
   overloaded system resources can cause a delay in the invocation of the
   broadcast receiver. To prioritize the broadcast, make it a foreground
   process.

   For example, add the
   `Intent.FLAG_RECEIVER_FOREGROUND <#android.content.Intent>`__
   flag to the ``Intent`` passed to the ``PendingIntent.getBroadcast`` when the
   user taps on a certain part of the widget.

   .. rubric:: Build accurate previews that include dynamic items
      :name: build-accurate-previews

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/missing-list.png
      :width: 250px

      **Figure 1:** A widget preview displaying no list items.

   This section explains the recommended approach for displaying multiple items
   in a widget preview for a widget with a `collection view <#>`__—that is, a widget that uses a
   ``ListView``, ``GridView``, or ``StackView``.

   If your widget uses one of these views, creating a scalable preview by
   `directly providing the actual widget layout <#approaches-previews>`__ degrades
   the experience when the widget preview displays no items. This occurs because
   collection view data is set dynamically at runtime, and it looks similar to
   the image shown in figure 1.

   To make previews of widgets with collection views display properly in the
   widget picker, we recommend maintaining a separate layout file designated for
   only the preview. This separate layout file includes the actual widget layout
   and a placeholder collection view with fake items. For example, you can mimic
   a ``ListView`` by providing a placeholder ``LinearLayout`` with several fake
   list items.

   To illustrate an example for a ``ListView``, start with a separate layout
   file:

   .. code:: prettyprint

      // res/layout/widget_preview.xml

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:background="@drawable/widget_background"
         android:orientation="vertical">

          // Include the actual widget layout that contains ListView.
          <include
              layout="@layout/widget_view"
              android:layout_width="match_parent"
              android:layout_height="wrap_content" />

          // The number of fake items you include depends on the values you provide
          // for minHeight or targetCellHeight in the AppWidgetProviderInfo
          // definition.

          <TextView android:text="@string/fake_item1"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_marginVertical="?attr/appWidgetInternalPadding" />

          <TextView android:text="@string/fake_item2"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_marginVertical="?attr/appWidgetInternalPadding" />

      </LinearLayout>

   Specify the preview layout file when providing the ``previewLayout``
   attribute of the ``AppWidgetProviderInfo`` metadata. You still specify the
   actual widget layout for the ``initialLayout`` attribute and use the actual
   widget layout when constructing a ``RemoteViews`` at runtime.

   .. code:: prettyprint

      <appwidget-provider
          previewLayout="@layout/widget_previe"
          initialLayout="@layout/widget_view" />

   .. rubric:: Complex list items
      :name: complex-list-items

   The example in the previous section provides fake list items, because the
   list items are `TextView <#android.widget.TextView>`__ objects.
   It can be more complex to provide fake items if the items are complex
   layouts.

   Consider a list item that is defined in ``widget_list_item.xml`` and consists
   of two ``TextView`` objects:

   .. code:: prettyprint

      <LinearLayout  xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="wrap_content">

          <TextView android:id="@id/title"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="@string/fake_title" />

          <TextView android:id="@id/content"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="@string/fake_content" />
      </LinearLayout>

   To provide fake list items, you can include the layout multiple times, but
   this causes each list item to be identical. To provide unique list items,
   follow these steps:

   #. Create a set of attributes for the text values:

      .. code:: prettyprint

         <resources>
             <attr name="widgetTitle" format="string" />
             <attr name="widgetContent" format="string" />
         </resources>

   #. Use these attributes to set the text:

      .. code:: prettyprint

         <LinearLayout  xmlns:android="http://schemas.android.com/apk/res/android"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content">

             <TextView android:id="@id/title"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
                 android:text="?widgetTitle" />

             <TextView android:id="@id/content"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
                 android:text="?widgetContent" />
         </LinearLayout>

   #. Create as many styles as required for the preview. Redefine the values in
      each style:

      .. code:: prettyprint

         <resources>

             <style name="Theme.Widget.ListItem">
                 <item name="widgetTitle"></item>
                 <item name="widgetContent"></item>
             </style>
             <style name="Theme.Widget.ListItem.Preview1">
                 <item name="widgetTitle">Fake Title 1</item>
                 <item name="widgetContent">Fake content 1</item>
             </style>
             <style name="Theme.Widget.ListItem.Preview2">
                 <item name="widgetTitle">Fake title 2</item>
                 <item name="widgetContent">Fake content 2</item>
             </style>

         </resources>

   #. Apply the styles on the fake items in the preview layout:

      .. code:: prettyprint

         <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" ...>

             <include layout="@layout/widget_view" ... />

             <include layout="@layout/widget_list_item"
                 android:theme="@style/Theme.Widget.ListItem.Preview1" />

             <include layout="@layout/widget_list_item"
                 android:theme="@style/Theme.Widget.ListItem.Preview2" />

         </LinearLayout>


Last updated 2024-05-03 UTC.


/Use widget collections
=======================

.. https://developer.android.google.cn/develop/ui/views/appwidgets/collections?hl=en

.. container:: devsite-article-body

   Collection widgets specialize in displaying many elements of the same type,
   such as collections of pictures from a gallery app, articles from a news app,
   or messages from a communication app. Collection widgets typically focus on
   two use cases: browsing the collection and opening an element of the
   collection to its detail view. Collection widgets can scroll vertically.

   These widgets use the
   `RemoteViewsService <#android.widget.RemoteViewsService>`__ to
   display collections that are backed by remote data, such as from a `content provider <#>`__. The widget presents
   the data using one of the following view types, which are known as
   *collection views*:

   `ListView <#android.widget.ListView>`__
      A view that shows items in a vertically scrolling list.
   `GridView <#android.widget.GridView>`__
      A view that shows items in a two-dimensional scrolling grid.
   `StackView <#android.widget.StackView>`__
      A stacked card view—kind of like a rolodex—where the user can flick the
      front card up or down to see the previous or next card, respectively.
   `AdapterViewFlipper <#android.widget.AdapterViewFlipper>`__
      An adapter-backed simple
      `ViewAnimator <#android.widget.ViewAnimator>`__ that
      animates between two or more views. Only one child is shown at a time.

   Because these collection views display collections backed by remote data,
   they use an `Adapter <#android.widget.Adapter>`__ to bind their
   user interface to their data. An ``Adapter`` binds individual items from a
   set of data to individual `View <#android.view.View>`__
   objects.

   And because these collection views are backed by adapters, the Android
   framework must include extra architecture to support their use in widgets. In
   the context of a widget, the ``Adapter`` is replaced by a
   `RemoteViewsFactory <#android.widget.RemoteViewsService.RemoteViewsFactory>`__,
   which is a thin wrapper around the ``Adapter`` interface. When requested for
   a specific item in the collection, the ``RemoteViewsFactory`` creates and
   returns the item for the collection as a
   `RemoteViews <#android.widget.RemoteViews>`__ object. To
   include a collection view in your widget, implement ``RemoteViewsService``
   and ``RemoteViewsFactory``.

   ``RemoteViewsService`` is a service that lets a remote adapter request
   ``RemoteViews`` objects. ``RemoteViewsFactory`` is an interface for an
   adapter between a collection view—such as ``ListView``, ``GridView``, and
   ``StackView``—and the underlying data for that view. From the
   `StackWidget sample <https://android.googlesource.com/platform/development/+/master/samples/StackWidget/src/com/example/android/stackwidget/StackWidgetService.java>`__,
   here is an example of the boilerplate code to implement this service and
   interface:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class StackWidgetService : RemoteViewsService() {

                   override fun onGetViewFactory(intent: Intent): RemoteViewsFactory {
                       return StackRemoteViewsFactory(this.applicationContext, intent)
                   }
               }

               class StackRemoteViewsFactory(
                       private val context: Context,
                       intent: Intent
               ) : RemoteViewsService.RemoteViewsFactory {

               // See the RemoteViewsFactory API reference for the full list of methods to
               // implement.

               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class StackWidgetService extends RemoteViewsService {
                   @Override
                   public RemoteViewsFactory onGetViewFactory(Intent intent) {
                       return new StackRemoteViewsFactory(this.getApplicationContext(), intent);
                   }
               }

               class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {

               // See the RemoteViewsFactory API reference for the full list of methods to
               // implement.

               }

   .. rubric:: Sample application
      :name: sample

   The code excerpts in this section are also drawn from the `StackWidget sample <https://android.googlesource.com/platform/development/+/master/samples/StackWidget>`__:

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/StackWidget.png

      **Figure 1.** A ``StackWidget``.

   This sample consists of a stack of ten views that display the values zero
   through nine. The sample widget has these primary behaviors:

   -  The user can vertically fling the top view in the widget to display the
      next or previous view. This is a built-in ``StackView`` behavior.

   -  Without any user interaction, the widget automatically advances through
      its views in sequence, like a slideshow. This is due to the setting
      ``android:autoAdvanceViewId="@id/stack_view"`` in the
      ``res/xml/stackwidgetinfo.xml`` file. This setting applies to the view ID,
      which in this case is the view ID of the stack view.

   -  If the user touches the top view, the widget displays the
      `Toast <#android.widget.Toast>`__ message "Touched view
      *n*," where *n* is the index (position) of the touched view. For more
      discussion on how to implement behaviors, see the `Add behavior to individual items <#behavior>`__ section.

   .. rubric:: Implement widgets with collections
      :name: implement-collections

   To implement a widget with collections, follow the procedure to `implement any widget <#>`__, followed by a few additional
   steps: modify the manifest, add a collection view to the widget layout, and
   modify your ``AppWidgetProvider`` subclass.

   .. rubric:: Manifest for widgets with collections
      :name: manifest-collections

   Beyond the requirements listed in `Declare a widget in the manifest <#Manifest>`__, you need to make it possible
   for widgets with collections to bind to your ``RemoteViewsService``. Do this
   by declaring the service in your manifest file with the permission
   `BIND_REMOTEVIEWS <#android.Manifest.permission>`__.
   This prevents other applications from freely accessing your widget's data.

   For example, when creating a widget that uses ``RemoteViewsService`` to
   populate a collection view, the manifest entry might look like this:

   .. code:: prettyprint

      <service android:name="MyWidgetService"
          android:permission="android.permission.BIND_REMOTEVIEWS" />

   In this example, ``android:name="MyWidgetService"`` refers to your subclass
   of ``RemoteViewsService``.

   .. rubric:: Layout for widgets with collections
      :name: layout-collections

   The main requirement for your widget layout XML file is that it include one
   of the collection views: ``ListView``, ``GridView``, ``StackView``, or
   ``AdapterViewFlipper``. Here is the ``widget_layout.xml`` file for the
   `StackWidget sample <https://android.googlesource.com/platform/development/+/master/samples/StackWidget/res/layout>`__:

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
          <StackView
              android:id="@+id/stack_view"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:gravity="center"
              android:loopViews="true" />
          <TextView
              android:id="@+id/empty_view"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:gravity="center"
              android:background="@drawable/widget_item_background"
              android:textColor="#ffffff"
              android:textStyle="bold"
              android:text="@string/empty_view_text"
              android:textSize="20sp" />
      </FrameLayout>

   Note that empty views must be siblings of the collection view for which the
   empty view represents empty state.

   In addition to the layout file for your entire widget, create another layout
   file that defines the layout for each item in the collection—for example, a
   layout for each book in a collection of books. The ``StackWidget`` sample has
   only one item layout file, ``widget_item.xml``, since all items use the same
   layout.

   .. rubric:: AppWidgetProvider class for widgets with collections
      :name: AppWidgetProvider-collections

   As with regular widgets, the bulk of the code in your
   `AppWidgetProvider <#android.appwidget.AppWidgetProvider>`__
   subclass typically goes in
   `onUpdate() <#android.appwidget.AppWidgetProvider>`__.
   The major difference in your implementation for ``onUpdate()`` when creating
   a widget with collections is that you must call
   `setRemoteAdapter() <#android.widget.RemoteViews>`__.
   This tells the collection view where to get its data. The
   ``RemoteViewsService`` can then return your implementation of
   ``RemoteViewsFactory``, and the widget can serve up the appropriate data.
   When you call this method, pass an intent that points to your implementation
   of ``RemoteViewsService`` and the widget ID that specifies the widget to
   update.

   For example, here's how the ``StackWidget`` sample implements the
   ``onUpdate()`` callback method to set the ``RemoteViewsService`` as the
   remote adapter for the widget collection:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onUpdate(
                       context: Context,
                       appWidgetManager: AppWidgetManager,
                       appWidgetIds: IntArray
               ) {
                   // Update each of the widgets with the remote adapter.
                   appWidgetIds.forEach { appWidgetId ->

                       // Set up the intent that starts the StackViewService, which
                       // provides the views for this collection.
                       val intent = Intent(context, StackWidgetService::class.java).apply {
                           // Add the widget ID to the intent extras.
                           putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                           data = Uri.parse(toUri(Intent.URI_INTENT_SCHEME))
                       }
                       // Instantiate the RemoteViews object for the widget layout.
                       val views = RemoteViews(context.packageName, R.layout.widget_layout).apply {
                           // Set up the RemoteViews object to use a RemoteViews adapter.
                           // This adapter connects to a RemoteViewsService through the
                           // specified intent.
                           // This is how you populate the data.
                           setRemoteAdapter(R.id.stack_view, intent)

                           // The empty view is displayed when the collection has no items.
                           // It must be in the same layout used to instantiate the
                           // RemoteViews object.
                           setEmptyView(R.id.stack_view, R.id.empty_view)
                       }

                       // Do additional processing specific to this widget.

                       appWidgetManager.updateAppWidget(appWidgetId, views)
                   }
                   super.onUpdate(context, appWidgetManager, appWidgetIds)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
                   // Update each of the widgets with the remote adapter.
                   for (int i = 0; i < appWidgetIds.length; ++i) {

                       // Set up the intent that starts the StackViewService, which
                       // provides the views for this collection.
                       Intent intent = new Intent(context, StackWidgetService.class);
                       // Add the widget ID to the intent extras.
                       intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);
                       intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
                       // Instantiate the RemoteViews object for the widget layout.
                       RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_layout);
                       // Set up the RemoteViews object to use a RemoteViews adapter.
                       // This adapter connects to a RemoteViewsService through the specified
                       // intent.
                       // This is how you populate the data.
                       views.setRemoteAdapter(R.id.stack_view, intent);

                       // The empty view is displayed when the collection has no items.
                       // It must be in the same layout used to instantiate the RemoteViews
                       // object.
                       views.setEmptyView(R.id.stack_view, R.id.empty_view);

                       // Do additional processing specific to this widget.

                       appWidgetManager.updateAppWidget(appWidgetIds[i], views);
                   }
                   super.onUpdate(context, appWidgetManager, appWidgetIds);
               }

   .. rubric:: Persist data
      :name: persistent-data

   As described on this page, the ``RemoteViewsService`` subclass provides the
   ``RemoteViewsFactory`` used to populate the remote collection view.

   Specifically, perform these steps:

   #. Subclass ``RemoteViewsService``. ``RemoteViewsService`` is the service
      through which a remote adapter can request ``RemoteViews``.

   #. In your ``RemoteViewsService`` subclass, include a class that implements
      the ``RemoteViewsFactory`` interface. ``RemoteViewsFactory`` is an
      interface for an adapter between a remote collection view—such as
      ``ListView``, ``GridView``, ``StackView``—and the underlying data for that
      view. Your implementation is responsible for making a ``RemoteViews``
      object for each item in the dataset. This interface is a thin wrapper
      around ``Adapter``.

   You can’t rely on a single instance of your service, or any data it contains,
   to persist. Don't store data in your ``RemoteViewsService`` unless it is
   static. If you want your widget’s data to persist, the best approach is to
   use a `ContentProvider <#android.content.ContentProvider>`__
   whose data persists beyond the process lifecycle. For example, a grocery
   store widget can store the state of each grocery list item in a persistent
   location, such as a SQL database.

   **Note:**\  See
   `WeatherDataProvider.java <https://android.googlesource.com/platform/development/+/master/samples/WeatherListWidget/src/com/example/android/weatherlistwidget/WeatherDataProvider.java>`__
   for a code sample demonstrating how to persist a widget’s underlying data
   using ``ContentProvider``.
   The primary contents of the ``RemoteViewsService`` implementation is its
   ``RemoteViewsFactory``, described in the following section.

   .. rubric:: RemoteViewsFactory interface
      :name: RemoteViewsFactory

   Your custom class that implements the ``RemoteViewsFactory`` interface
   provides the widget with the data for the items in its collection. To do
   this, it combines your widget item XML layout file with a source of data.
   This source of data can be anything from a database to a simple array. In the
   ``StackWidget`` sample, the data source is an array of ``WidgetItems``. The
   ``RemoteViewsFactory`` functions as an adapter to glue the data to the remote
   collection view.

   The two most important methods you need to implement for your
   ``RemoteViewsFactory`` subclass are
   `onCreate() <#android.widget.RemoteViewsService.RemoteViewsFactory>`__
   and
   `getViewAt() <#android.widget.RemoteViewsService.RemoteViewsFactory>`__.

   The system calls ``onCreate()`` when creating your factory for the first
   time. This is where you set up any connections or cursors to your data
   source. For example, the ``StackWidget`` sample uses ``onCreate()`` to
   initialize an array of ``WidgetItem`` objects. When your widget is active,
   the system accesses these objects using their index position in the array and
   displays the text they contain.

   Here is an excerpt from the ``StackWidget`` sample's ``RemoteViewsFactory``
   implementation that shows portions of the ``onCreate()`` method:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val REMOTE_VIEW_COUNT: Int = 10

               class StackRemoteViewsFactory(
                       private val context: Context
               ) : RemoteViewsService.RemoteViewsFactory {

                   private lateinit var widgetItems: List<WidgetItem>

                   override fun onCreate() {
                       // In onCreate(), set up any connections or cursors to your data
                       // source. Heavy lifting, such as downloading or creating content,
                       // must be deferred to onDataSetChanged() or getViewAt(). Taking
                       // more than 20 seconds on this call results in an ANR.
                       widgetItems = List(REMOTE_VIEW_COUNT) { index -> WidgetItem("$index!") }
                       ...
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
                   private static final int REMOTE_VIEW_COUNT = 10;
                   private List<WidgetItem> widgetItems = new ArrayList<WidgetItem>();

                   public void onCreate() {
                       // In onCreate(), setup any connections or cursors to your data
                       // source. Heavy lifting, such as downloading or creating content,
                       // must be deferred to onDataSetChanged() or getViewAt(). Taking
                       // more than 20 seconds on this call results in an ANR.
                       for (int i = 0; i < REMOTE_VIEW_COUNT; i++) {
                           widgetItems.add(new WidgetItem(i + "!"));
                       }
                       ...
                   }
               ...

   The ``RemoteViewsFactory`` method ``getViewAt()`` returns a ``RemoteViews``
   object corresponding to the data at the specified ``position`` in the data
   set. Here is an excerpt from the ``StackWidget`` sample's
   ``RemoteViewsFactory`` implementation:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun getViewAt(position: Int): RemoteViews {
                   // Construct a remote views item based on the widget item XML file
                   // and set the text based on the position.
                   return RemoteViews(context.packageName, R.layout.widget_item).apply {
                       setTextViewText(R.id.widget_item, widgetItems[position].text)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public RemoteViews getViewAt(int position) {
                   // Construct a remote views item based on the widget item XML file
                   // and set the text based on the position.
                   RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_item);
                   views.setTextViewText(R.id.widget_item, widgetItems.get(position).text);
                   return views;
               }

   .. rubric:: Add behavior to individual items
      :name: behavior

   The preceding sections show how to bind your data to your widget collection.
   But what if you want to add dynamic behavior to the individual items in your
   collection view?

   As described in `Handle events with the ``onUpdate()``
   class <#handle-events>`__, you normally use
   `setOnClickPendingIntent() <#android.widget.RemoteViews>`__
   to set an object's click behavior—such as to cause a button to launch an
   `Activity <#android.app.Activity>`__. But this approach is not
   allowed for child views in an individual collection item. For example, you
   can use ``setOnClickPendingIntent()`` to set up a global button in the Gmail
   widget that launches the app, for example, but not on the individual list
   items.

   Instead, to add click behavior to individual items in a collection, use
   `setOnClickFillInIntent() <#android.widget.RemoteViews>`__.
   This entails setting up a pending intent template for your collection view
   and then setting a fill-in intent on each item in the collection via your
   ``RemoteViewsFactory``.

   This section uses the ``StackWidget`` sample to describe how to add behavior
   to individual items. In the ``StackWidget`` sample, if the user touches the
   top view, the widget displays the ``Toast`` message "Touched view *n*," where
   *n* is the index (position) of the touched view. This is how it works:

   -  The ``StackWidgetProvider``—an
      `AppWidgetProvider <#android.appwidget.AppWidgetProvider>`__
      subclass—creates a pending intent with a custom action called
      ``TOAST_ACTION``.

   -  When the user touches a view, the intent fires and it broadcasts
      ``TOAST_ACTION``.

   -  This broadcast is intercepted by the ``StackWidgetProvider`` class's
      `onReceive() <#android.appwidget.AppWidgetProvider>`__
      method, and the widget displays the ``Toast`` message for the touched
      view. The data for the collection items is provided by the
      ``RemoteViewsFactory`` through the ``RemoteViewsService``.

   **Note:**\  The ``StackWidget`` sample uses a broadcast, but typically a
   widget launches an activity in a scenario like this.

   .. rubric:: Set up the pending intent template
      :name: setup-pending-intent

   The ``StackWidgetProvider`` (an
   `AppWidgetProvider <#android.appwidget.AppWidgetProvider>`__
   subclass) sets up a pending intent. Individual items of a collection can't
   set up their own pending intents. Instead, the collection as a whole sets up
   a pending intent template, and the individual items set a fill-in intent to
   create unique behavior on an item-by-item basis.

   This class also receives the broadcast that is sent when the user touches a
   view. It processes this event in its ``onReceive()`` method. If the intent's
   action is ``TOAST_ACTION``, the widget displays a ``Toast`` message for the
   current view.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               const val TOAST_ACTION = "com.example.android.stackwidget.TOAST_ACTION"
               const val EXTRA_ITEM = "com.example.android.stackwidget.EXTRA_ITEM"

               class StackWidgetProvider : AppWidgetProvider() {

                   ...

                   // Called when the BroadcastReceiver receives an Intent broadcast.
                   // Checks whether the intent's action is TOAST_ACTION. If it is, the
                   // widget displays a Toast message for the current item.
                   override fun onReceive(context: Context, intent: Intent) {
                       val mgr: AppWidgetManager = AppWidgetManager.getInstance(context)
                       if (intent.action == TOAST_ACTION) {
                           val appWidgetId: Int = intent.getIntExtra(
                                   AppWidgetManager.EXTRA_APPWIDGET_ID,
                                   AppWidgetManager.INVALID_APPWIDGET_ID
                           )
                           // EXTRA_ITEM represents a custom value provided by the Intent
                           // passed to the setOnClickFillInIntent() method to indicate the
                           // position of the clicked item. See StackRemoteViewsFactory in
                           // Set the fill-in Intent for details.
                           val viewIndex: Int = intent.getIntExtra(EXTRA_ITEM, 0)
                           Toast.makeText(context, "Touched view $viewIndex", Toast.LENGTH_SHORT).show()
                       }
                       super.onReceive(context, intent)
                   }

                   override fun onUpdate(
                           context: Context,
                           appWidgetManager: AppWidgetManager,
                           appWidgetIds: IntArray
                   ) {
                       // Update each of the widgets with the remote adapter.
                       appWidgetIds.forEach { appWidgetId ->

                           // Sets up the intent that points to the StackViewService that
                           // provides the views for this collection.
                           val intent = Intent(context, StackWidgetService::class.java).apply {
                               putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                               // When intents are compared, the extras are ignored, so embed
                               // the extra sinto the data so that the extras are not ignored.
                               data = Uri.parse(toUri(Intent.URI_INTENT_SCHEME))
                           }
                           val rv = RemoteViews(context.packageName, R.layout.widget_layout).apply {
                               setRemoteAdapter(R.id.stack_view, intent)

                               // The empty view is displayed when the collection has no items.
                               // It must be a sibling of the collection view.
                               setEmptyView(R.id.stack_view, R.id.empty_view)
                           }

                           // This section makes it possible for items to have individualized
                           // behavior. It does this by setting up a pending intent template.
                           // Individuals items of a collection can't set up their own pending
                           // intents. Instead, the collection as a whole sets up a pending
                           // intent template, and the individual items set a fillInIntent
                           // to create unique behavior on an item-by-item basis.
                           val toastPendingIntent: PendingIntent = Intent(
                                   context,
                                   StackWidgetProvider::class.java
                           ).run {
                               // Set the action for the intent.
                               // When the user touches a particular view, it has the effect of
                               // broadcasting TOAST_ACTION.
                               action = TOAST_ACTION
                               putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                               data = Uri.parse(toUri(Intent.URI_INTENT_SCHEME))

                               PendingIntent.getBroadcast(context, 0, this, PendingIntent.FLAG_UPDATE_CURRENT)
                           }
                           rv.setPendingIntentTemplate(R.id.stack_view, toastPendingIntent)

                           appWidgetManager.updateAppWidget(appWidgetId, rv)
                       }
                       super.onUpdate(context, appWidgetManager, appWidgetIds)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class StackWidgetProvider extends AppWidgetProvider {
                   public static final String TOAST_ACTION = "com.example.android.stackwidget.TOAST_ACTION";
                   public static final String EXTRA_ITEM = "com.example.android.stackwidget.EXTRA_ITEM";

                   ...

                   // Called when the BroadcastReceiver receives an Intent broadcast.
                   // Checks whether the intent's action is TOAST_ACTION. If it is, the
                   // widget displays a Toast message for the current item.
                   @Override
                   public void onReceive(Context context, Intent intent) {
                       AppWidgetManager mgr = AppWidgetManager.getInstance(context);
                       if (intent.getAction().equals(TOAST_ACTION)) {
                           int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,
                               AppWidgetManager.INVALID_APPWIDGET_ID);
                           // EXTRA_ITEM represents a custom value provided by the Intent
                           // passed to the setOnClickFillInIntent() method to indicate the
                           // position of the clicked item. See StackRemoteViewsFactory in
                           // Set the fill-in Intent for details.
                           int viewIndex = intent.getIntExtra(EXTRA_ITEM, 0);
                           Toast.makeText(context, "Touched view " + viewIndex, Toast.LENGTH_SHORT).show();
                       }
                       super.onReceive(context, intent);
                   }

                   @Override
                   public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
                       // Update each of the widgets with the remote adapter.
                       for (int i = 0; i < appWidgetIds.length; ++i) {

                           // Sets up the intent that points to the StackViewService that
                           // provides the views for this collection.
                           Intent intent = new Intent(context, StackWidgetService.class);
                           intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);
                           // When intents are compared, the extras are ignored, so embed
                           // the extras into the data so that the extras are not
                           // ignored.
                           intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
                           RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_layout);
                           rv.setRemoteAdapter(appWidgetIds[i], R.id.stack_view, intent);

                           // The empty view is displayed when the collection has no items. It
                           // must be a sibling of the collection view.
                           rv.setEmptyView(R.id.stack_view, R.id.empty_view);

                           // This section makes it possible for items to have individualized
                           // behavior. It does this by setting up a pending intent template.
                           // Individuals items of a collection can't set up their own pending
                           // intents. Instead, the collection as a whole sets up a pending
                           // intent template, and the individual items set a fillInIntent
                           // to create unique behavior on an item-by-item basis.
                           Intent toastIntent = new Intent(context, StackWidgetProvider.class);
                           // Set the action for the intent.
                           // When the user touches a particular view, it has the effect of
                           // broadcasting TOAST_ACTION.
                           toastIntent.setAction(StackWidgetProvider.TOAST_ACTION);
                           toastIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);
                           intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
                           PendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent,
                               PendingIntent.FLAG_UPDATE_CURRENT);
                           rv.setPendingIntentTemplate(R.id.stack_view, toastPendingIntent);

                           appWidgetManager.updateAppWidget(appWidgetIds[i], rv);
                       }
                       super.onUpdate(context, appWidgetManager, appWidgetIds);
                   }
               }

   .. rubric:: Set the fill-in intent
      :name: setup-fill-in-intent

   Your ``RemoteViewsFactory`` must set a fill-in intent on each item in the
   collection. This makes it possible to distinguish the individual on-click
   action of a given item. The fill-in intent is then combined with the
   `PendingIntent <#android.app.PendingIntent>`__ template to
   determine the final intent that is executed when the item is tapped.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               private const val REMOTE_VIEW_COUNT: Int = 10

               class StackRemoteViewsFactory(
                       private val context: Context,
                       intent: Intent
               ) : RemoteViewsService.RemoteViewsFactory {

                   private lateinit var widgetItems: List<WidgetItem>
                   private val appWidgetId: Int = intent.getIntExtra(
                           AppWidgetManager.EXTRA_APPWIDGET_ID,
                           AppWidgetManager.INVALID_APPWIDGET_ID
                   )

                   override fun onCreate() {
                       // In onCreate(), set up any connections or cursors to your data source.
                       // Heavy lifting, such as downloading or creating content, must be
                       // deferred to onDataSetChanged() or getViewAt(). Taking more than 20
                       // seconds on this call results in an ANR.
                       widgetItems = List(REMOTE_VIEW_COUNT) { index -> WidgetItem("$index!") }
                       ...
                   }
                   ...

                   override fun getViewAt(position: Int): RemoteViews {
                       // Construct a remote views item based on the widget item XML file
                       // and set the text based on the position.
                       return RemoteViews(context.packageName, R.layout.widget_item).apply {
                           setTextViewText(R.id.widget_item, widgetItems[position].text)

                           // Set a fill-intent to fill in the pending intent template.
                           // that is set on the collection view in StackWidgetProvider.
                           val fillInIntent = Intent().apply {
                               Bundle().also { extras ->
                                   extras.putInt(EXTRA_ITEM, position)
                                   putExtras(extras)
                               }
                           }
                           // Make it possible to distinguish the individual on-click
                           // action of a given item.
                           setOnClickFillInIntent(R.id.widget_item, fillInIntent)
                           ...
                       }
                   }
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class StackWidgetService extends RemoteViewsService {
                   @Override
                   public RemoteViewsFactory onGetViewFactory(Intent intent) {
                       return new StackRemoteViewsFactory(this.getApplicationContext(), intent);
                   }
               }

               class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
                   private static final int count = 10;
                   private List<WidgetItem> widgetItems = new ArrayList<WidgetItem>();
                   private Context context;
                   private int appWidgetId;

                   public StackRemoteViewsFactory(Context context, Intent intent) {
                       this.context = context;
                       appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,
                               AppWidgetManager.INVALID_APPWIDGET_ID);
                   }

                   // Initialize the data set.
                   public void onCreate() {
                       // In onCreate(), set up any connections or cursors to your data
                       // source. Heavy lifting, such as downloading or creating
                       // content, must be deferred to onDataSetChanged() or
                       // getViewAt(). Taking more than 20 seconds on this call results
                       // in an ANR.
                       for (int i = 0; i < count; i++) {
                           widgetItems.add(new WidgetItem(i + "!"));
                       }
                       ...
                   }

                   // Given the position (index) of a WidgetItem in the array, use the
                   // item's text value in combination with the widget item XML file to
                   // construct a RemoteViews object.
                   public RemoteViews getViewAt(int position) {
                       // Position always ranges from 0 to getCount() - 1.

                       // Construct a RemoteViews item based on the widget item XML
                       // file and set the text based on the position.
                       RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget_item);
                       rv.setTextViewText(R.id.widget_item, widgetItems.get(position).text);

                       // Set a fill-intent to fill in the pending
                       // intent template that is set on the collection view in
                       // StackWidgetProvider.
                       Bundle extras = new Bundle();
                       extras.putInt(StackWidgetProvider.EXTRA_ITEM, position);
                       Intent fillInIntent = new Intent();
                       fillInIntent.putExtras(extras);
                       // Make it possible to distinguish the individual on-click
                       // action of a given item.
                       rv.setOnClickFillInIntent(R.id.widget_item, fillInIntent);

                       // Return the RemoteViews object.
                       return rv;
                   }
                   ...
               }

   .. rubric:: Keep collection data fresh
      :name: keep-data-fresh

   Figure 2 illustrates the update flow in a widget that uses collections. It
   shows how the widget code interacts with the ``RemoteViewsFactory`` and how
   you can trigger updates:

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/appwidget_collections.png

      **Figure 2.** Interaction with ``RemoteViewsFactory`` during updates.

   Widgets that use collections can provide users with up-to-date content. For
   example, the Gmail widget gives users a snapshot of their inbox. To make this
   possible, trigger your ``RemoteViewsFactory`` and collection view to fetch
   and display new data.

   To do this, use the
   `AppWidgetManager <#android.appwidget.AppWidgetManager>`__ to
   call
   `notifyAppWidgetViewDataChanged() <#android.appwidget.AppWidgetManager>`__.
   This call results in a callback to your ``RemoteViewsFactory`` object’s
   `onDataSetChanged() <#android.widget.RemoteViewsService.RemoteViewsFactory>`__
   method, which lets you fetch any new data.

   You can perform processing-intensive operations synchronously within the
   ``onDataSetChanged()`` callback. You are guaranteed that this call is
   completed before the metadata or view data is fetched from the
   ``RemoteViewsFactory``. You can also perform processing-intensive operations
   within the ``getViewAt()`` method. If this call takes long, the loading
   view—specified by the ``RemoteViewsFactory`` object's
   `getLoadingView() <#android.widget.RemoteViewsService.RemoteViewsFactory>`__
   method—is displayed in the corresponding position of the collection view
   until it returns.

   .. rubric:: Use RemoteCollectionItems to pass along a collection directly
      :name: use-remote-collections

   Android 12 (API level 31) adds the
   `setRemoteAdapter(int viewId, RemoteViews.RemoteCollectionItems items) <#android.widget.RemoteViews>`__
   method, which lets your app pass along a collection directly when populating
   a collection view. If you set your adapter using this method, you don't need
   to implement a ``RemoteViewsFactory`` and you don't need to call
   ``notifyAppWidgetViewDataChanged()``.

   In addition to making it easier to populate your adapter, this approach also
   removes the latency for populating new itemswhen users scroll down the list
   to reveal a new item. This approach to setting the adapter is preferred as
   long as your set of collection items is relatively small. However, for
   example, this approach doesn't work well if your collection contains numerous
   ``Bitmaps`` being passed to ``setImageViewBitmap``.

   If the collection doesn’t use a constant set of layouts—that is, if some
   items are only sometimes present—use ``setViewTypeCount`` to specify the
   maximum number of unique layouts that the collection can contain. This lets
   the adapter be reused across updates to your app widget.

   Here’s an example of how to implement simplified ``RemoteViews`` collections.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val itemLayouts = listOf(
                       R.layout.item_type_1,
                       R.layout.item_type_2,
                       ...
               )

               remoteView.setRemoteAdapter(
                       R.id.list_view,
                       RemoteViews.RemoteCollectionItems.Builder()
                           .addItem(/* id= */ ID_1, RemoteViews(context.packageName, R.layout.item_type_1))
                           .addItem(/* id= */ ID_2, RemoteViews(context.packageName, R.layout.item_type_2))
                           ...
                           .setViewTypeCount(itemLayouts.count())
                           .build()
               )

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               List<Integer> itemLayouts = Arrays.asList(
                   R.layout.item_type_1,
                   R.layout.item_type_2,
                   ...
               );

               remoteView.setRemoteAdapter(
                   R.id.list_view,
                   new RemoteViews.RemoteCollectionItems.Builder()
                       .addItem(/* id= */ ID_1, new RemoteViews(context.getPackageName(), R.layout.item_type_1))
                       .addItem(/* id= */ ID_2, new RemoteViews(context.getPackageName(), R.layout.item_type_2))
                       ...
                       .setViewTypeCount(itemLayouts.size())
                       .build()
               );

   **Note:**\  When calling
   `setViewTypeCount() <#android.widget.RemoteViews.RemoteCollectionItems.Builder>`__,
   pass in the maximum number of different layout IDs that are used by
   ``RemoteViews`` in this collection. Otherwise, the view type count is
   inferred from the provided items, and the adapter is recreated when sending
   an update that uses additional layouts.


Last updated 2024-05-03 UTC.


/Size your widget
=================

.. https://developer.android.google.cn/develop/ui/views/appwidgets/layouts?hl=en

.. container:: devsite-article-body

   This page describes refinements for widget sizing and greater flexibility
   introduced in Android 12 (API level 31). It also details how to `determine a size for your widget <#anatomy_determining_size>`__.

   .. rubric:: Use improved APIs for widget sizes and layouts
      :name: refine-widget-sizes

   Starting with Android 12 (API level 31), you can provide more refined size
   attributes and flexible layouts by doing the following, as described in the
   sections that follow:

   #. `Specify additional widget sizing constraints. <#specify-widget-size-constraints>`__

   #. Providing `responsive layouts <#provide-responsive-layouts>`__ or `exact layouts. <#provide-exact-layouts>`__

   In previous versions of Android, it is possible to get the size ranges of a
   widget using the
   `OPTION_APPWIDGET_MIN_WIDTH <#android.appwidget.AppWidgetManager>`__,
   `OPTION_APPWIDGET_MIN_HEIGHT <#android.appwidget.AppWidgetManager>`__,
   `OPTION_APPWIDGET_MAX_WIDTH <#android.appwidget.AppWidgetManager>`__,
   and
   `OPTION_APPWIDGET_MAX_HEIGHT <#android.appwidget.AppWidgetManager>`__
   extras and then estimate the widget's size, but that logic doesn't work in
   all situations. For widgets targeting Android 12 or higher, we recommend
   providing `responsive <#provide-responsive-layouts>`__ or `exact layouts <#provide-exact-layouts>`__.

   .. rubric:: Specify additional widget sizing constraints
      :name: specify-widget-size-constraints

   Android 12 adds APIs letting you ensure your widget is sized more reliably
   across different devices with varying screen sizes.

   In addition to the existing
   `minWidth <#android.appwidget.AppWidgetProviderInfo>`__,
   `minHeight <#android.appwidget.AppWidgetProviderInfo>`__,
   `minResizeWidth <#android.appwidget.AppWidgetProviderInfo>`__,
   and
   `minResizeHeight <#android.appwidget.AppWidgetProviderInfo>`__
   attributes, use the following new ``appwidget-provider`` attributes:

   -  `targetCellWidth <#android.appwidget.AppWidgetProviderInfo>`__
      and
      `targetCellHeight <#android.appwidget.AppWidgetProviderInfo>`__:
      define the target size of the widget in terms of launcher grid cells. If
      defined, these attributes are used instead of ``minWidth`` or
      ``minHeight``.

   -  `maxResizeWidth <#android.appwidget.AppWidgetProviderInfo>`__
      and
      `maxResizeHeight <#android.appwidget.AppWidgetProviderInfo>`__:
      define the maximum size that the launcher allows the user to resize the
      widget to.

   The following XML shows how to use the sizing attributes.

   .. code:: prettyprint

      <appwidget-provider
        ...
        android:targetCellWidth="3"
        android:targetCellHeight="2"
        android:maxResizeWidth="250dp"
        android:maxResizeHeight="110dp">
      </appwidget-provider>

   .. rubric:: Provide responsive layouts
      :name: provide-responsive-layouts

   If the layout needs to change depending on the size of the widget, we
   recommend creating a small set of layouts, each valid for a range of sizes.
   If this isn’t possible, another option is to provide layouts based on the
   `exact widget size at runtime <#provide-exact-layouts>`__, as described in
   this page.

   This feature allows for smoother scaling and overall better system health,
   because the system doesn't have to wake up the app every time it displays the
   widget in a different size.

   The following code example shows how to provide a list of layouts.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onUpdate(...) {
                   val smallView = ...
                   val tallView = ...
                   val wideView = ...

                   val viewMapping: Map<SizeF, RemoteViews> = mapOf(
                           SizeF(150f, 100f) to smallView,
                           SizeF(150f, 200f) to tallView,
                           SizeF(215f, 100f) to wideView
                   )
                   val remoteViews = RemoteViews(viewMapping)

                   appWidgetManager.updateAppWidget(id, remoteViews)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onUpdate(...) {
                   RemoteViews smallView = ...;
                   RemoteViews tallView = ...;
                   RemoteViews wideView = ...;

                   Map<SizeF, RemoteViews> viewMapping = new ArrayMap<>();
                   viewMapping.put(new SizeF(150f, 100f), smallView);
                   viewMapping.put(new SizeF(150f, 200f), tallView);
                   viewMapping.put(new SizeF(215f, 100f), wideView);
                   RemoteViews remoteViews = new RemoteViews(viewMapping);

                   appWidgetManager.updateAppWidget(id, remoteViews);
               }

   Assume the widget has the following attributes:

   .. code:: prettyprint

      <appwidget-provider
          android:minResizeWidth="160dp"
          android:minResizeHeight="110dp"
          android:maxResizeWidth="250dp"
          android:maxResizeHeight="200dp">
      </appwidget-provider>

   The preceding code snippet means the following:

   -  ``smallView`` supports from 160dp (``minResizeWidth``) × 110dp
      (``minResizeHeight``) to 160dp × 199dp (next cutoff point - 1dp).

   -  ``tallView`` supports from 160dp × 200dp to 214dp (next cutoff point - 1)
      × 200dp.

   -  ``wideView`` supports from 215dp × 110dp (``minResizeHeight``) to 250dp
      (``maxResizeWidth``) × 200dp (``maxResizeHeight``).

      **Note:**\  It's possible for the widget's size to be larger than
      ``maxResizeWidth`` × ``maxResizeHeight``. See `Widget sizing attributes <#widget-sizing-attributes>`__ for more
      details.

   Your widget must support the size range from ``minResizeWidth`` ×
   ``minResizeHeight`` to ``maxResizeWidth`` × ``maxResizeHeight``. Within that
   range, you can decide the cutoff point to switch layouts.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/size-range.gif
      :alt: Example of responsive layout
      :width: 300px

      **Figure 1.** Example of a responsive layout.

   .. rubric:: Provide exact layouts
      :name: provide-exact-layouts

   If a small set of responsive layouts isn't feasible, you can instead provide
   different layouts tailored to the sizes at which the widget is shown. This is
   typically two sizes for phones (portrait and landscape mode) and four sizes
   for foldables.

   To implement this solution, your app needs to perform the following steps:

   #. Overload
      `AppWidgetProvider.onAppWidgetOptionsChanged() <#android.appwidget.AppWidgetProvider>`__,
      which is called when the set of sizes changes.

   #. Call
      `AppWidgetManager.getAppWidgetOptions() <#android.appwidget.AppWidgetManager>`__,
      which returns a `Bundle <#android.os.Bundle>`__ containing
      the sizes.

   #. Access the
      `AppWidgetManager.OPTION_APPWIDGET_SIZES <#android.appwidget.AppWidgetManager>`__
      key from the ``Bundle``.

   **Note:**\  Providing the list of sizes is the launcher’s responsibility. If
   the device has a launcher that doesn't support that field, the list of sizes
   might be empty or null.
   The following code example shows how to provide exact layouts.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onAppWidgetOptionsChanged(
                       context: Context,
                       appWidgetManager: AppWidgetManager,
                       id: Int,
                       newOptions: Bundle?
               ) {
                   super.onAppWidgetOptionsChanged(context, appWidgetManager, id, newOptions)
                   // Get the new sizes.
                   val sizes = newOptions?.getParcelableArrayList<SizeF>(
                           AppWidgetManager.OPTION_APPWIDGET_SIZES
                   )
                   // Check that the list of sizes is provided by the launcher.
                   if (sizes.isNullOrEmpty()) {
                       return
                   }
                   // Map the sizes to the RemoteViews that you want.
                   val remoteViews = RemoteViews(sizes.associateWith(::createRemoteViews))
                   appWidgetManager.updateAppWidget(id, remoteViews)
               }

               // Create the RemoteViews for the given size.
               private fun createRemoteViews(size: SizeF): RemoteViews { }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onAppWidgetOptionsChanged(
                   Context context, AppWidgetManager appWidgetManager, int appWidgetId, Bundle newOptions) {
                   super.onAppWidgetOptionsChanged(context, appWidgetManager, appWidgetId, newOptions);
                   // Get the new sizes.
                   ArrayList<SizeF> sizes =
                       newOptions.getParcelableArrayList(AppWidgetManager.OPTION_APPWIDGET_SIZES);
                   // Check that the list of sizes is provided by the launcher.
                   if (sizes == null || sizes.isEmpty()) {
                     return;
                   }
                   // Map the sizes to the RemoteViews that you want.
                   Map<SizeF, RemoteViews> viewMapping = new ArrayMap<>();
                   for (SizeF size : sizes) {
                       viewMapping.put(size, createRemoteViews(size));
                   }
                   RemoteViews remoteViews = new RemoteViews(viewMapping);
                   appWidgetManager.updateAppWidget(id, remoteViews);
               }

               // Create the RemoteViews for the given size.
               private RemoteViews createRemoteViews(SizeF size) { }

   .. rubric:: Determine a size for your widget
      :name: anatomy_determining_size

   Each widget must define a ``targetCellWidth`` and ``targetCellHeight`` for
   devices running Android 12 or higher—or ``minWidth`` and ``minHeight`` for
   all versions of Android—indicating the minimum amount of space it consumes by
   default. However, when users add a widget to their home screen, it generally
   occupies more than the minimum width and height you specify.

   Android home screens offer users a grid of available spaces onto which they
   can place widgets and icons. This grid can vary by device; for example, many
   handsets offer a 5x4 grid, and tablets can offer a larger grid. When your
   widget is added, it is stretched to occupy the minimum number of cells,
   horizontally and vertically, required to satisfy constraints for its
   ``targetCellWidth`` and ``targetCellHeight`` on devices running Android 12 or
   higher, or ``minWidth`` and ``minHeight`` constraints on devices running
   Android 11 (API level 30) or lower.

   Both the width and height of a cell and the size of the automatic margins
   applied to widgets can vary across devices. Use the following table to
   roughly estimate your widget's minimum dimensions in a typical 5x4 grid
   handset, given the number of occupied grid cells you want:

   +-------------------------+-------------------------+-------------------------+
   | Number of cells (width  | Available size in       | Available size in       |
   | x height)               | portrait mode (dp)      | landscape mode (dp)     |
   +-------------------------+-------------------------+-------------------------+
   | 1x1                     | 57x102dp                | 127x51dp                |
   +-------------------------+-------------------------+-------------------------+
   | 2x1                     | 130x102dp               | 269x51dp                |
   +-------------------------+-------------------------+-------------------------+
   | 3x1                     | 203x102dp               | 412x51dp                |
   +-------------------------+-------------------------+-------------------------+
   | 4x1                     | 276x102dp               | 554x51dp                |
   +-------------------------+-------------------------+-------------------------+
   | 5x1                     | 349x102dp               | 697x51dp                |
   +-------------------------+-------------------------+-------------------------+
   | 5x2                     | 349x220dp               | 697x117dp               |
   +-------------------------+-------------------------+-------------------------+
   | 5x3                     | 349x337dp               | 697x184dp               |
   +-------------------------+-------------------------+-------------------------+
   | 5x4                     | 349x455dp               | 697x250dp               |
   +-------------------------+-------------------------+-------------------------+
   | ...                     | ...                     | ...                     |
   +-------------------------+-------------------------+-------------------------+
   | n x m                   | (73n - 16) x (118m -    | (142n - 15) x (66m -    |
   |                         | 16)                     | 15)                     |
   +-------------------------+-------------------------+-------------------------+

   **Note:**\  The preceding table shows the available sizes on a Google Pixel 4
   to demonstrate the rough estimation of general available sizes in both
   portrait and landscape modes.
   Use the portrait mode cell sizes to inform the values you provide for the
   ``minWidth``, ``minResizeWidth``, and ``maxResizeWidth`` attributes.
   Similarly, use the landscape mode cell sizes to inform the values you provide
   for the ``minHeight``, ``minResizeHeight``, and ``maxResizeHeight``
   attributes.

   The reason for this is that the cell width is typically smaller in portrait
   mode than in landscape mode—and, similarly, the cell height is typically
   smaller in landscape mode than in portrait mode.

   For example, if you want your widget width to be resizable down to one cell
   on a Google Pixel 4, you need to set your ``minResizeWidth`` to at most 56dp
   to make sure the value for the ``minResizeWidth`` attribute is smaller than
   57dp—because a cell is at least 57dp wide in portrait. Similarly, if you want
   your widget height to be resizable in one cell on the same device, you need
   to set your ``minResizeHeight`` to at most 50dp to make sure the value for
   the ``minResizeHeight`` attribute is smaller than 51dp—because one cell is at
   least 51dp high in landscape mode.

   Each widget is resizable within the size ranges between the
   ``minResizeWidth``/``minResizeHeight`` and
   ``maxResizeWidth``/``maxResizeHeight`` attributes, which means it needs to
   adapt to any size ranges between them.

   **Note:**\  As mentioned previously, it's possible for the widget's size to
   be larger than ``maxResizeWidth`` x ``maxResizeHeight``. See `Widget sizing attributes <#widget-sizing-attributes>`__ for more
   details.
   For example, to set the default size of the widget on placement, you can set
   the following attributes:

   .. code:: prettyprint

      <appwidget-provider
          android:targetCellWidth="3"
          android:targetCellHeight="2"
          android:minWidth="180dp"
          android:minHeight="110dp">
      </appwidget-provider>

   This means the widget's default size is 3x2 cells, as specified by the
   ``targetCellWidth`` and ``targetCellHeight`` attributes—or 180×110dp, as
   specified by ``minWidth`` and ``minHeight`` for devices running Android 11 or
   lower. In the latter case, the size in cells can vary depending on the
   device.

   Also, to set the supported size ranges of your widget, you can set the
   following attributes:

   .. code:: prettyprint

      <appwidget-provider
          android:minResizeWidth="180dp"
          android:minResizeHeight="110dp"
          android:maxResizeWidth="530dp"
          android:maxResizeHeight="450dp">
      </appwidget-provider>

   As specified by the preceding attributes, the width of the widget is
   resizable from 180dp to 530dp, and its height is resizable from 110dp to
   450dp. The widget is then resizable from 3x2 to 5x2 cells, as long as the
   following conditions are present:

   -  The device has the 5x4 grid.
   -  The mapping between the number of cells and the available size in dps
      follows the `table showing estimation of minimum dimensions <#estimate-minimum-dimensions>`__ in this page.
   -  The widget adapts to that size range.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val smallView = RemoteViews(context.packageName, R.layout.widget_weather_forecast_small)
               val mediumView = RemoteViews(context.packageName, R.layout.widget_weather_forecast_medium)
               val largeView = RemoteViews(context.packageName, R.layout.widget_weather_forecast_large)

               val viewMapping: Map<SizeF, RemoteViews> = mapOf(
                       SizeF(180f, 110f) to smallView,
                       SizeF(270f, 110f) to mediumView,
                       SizeF(270f, 280f) to largeView
               )

               appWidgetManager.updateAppWidget(appWidgetId, RemoteViews(viewMapping))

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               RemoteViews smallView = 
                   new RemoteViews(context.getPackageName(), R.layout.widget_weather_forecast_small);
               RemoteViews mediumView = 
                   new RemoteViews(context.getPackageName(), R.layout.widget_weather_forecast_medium);
               RemoteViews largeView = 
                   new RemoteViews(context.getPackageName(), R.layout.widget_weather_forecast_large);

               Map<SizeF, RemoteViews> viewMapping = new ArrayMap<>();
               viewMapping.put(new SizeF(180f, 110f), smallView);
               viewMapping.put(new SizeF(270f, 110f), mediumView);
               viewMapping.put(new SizeF(270f, 280f), largeView);
               RemoteViews remoteViews = new RemoteViews(viewMapping);

               appWidgetManager.updateAppWidget(id, remoteViews);

   Assume the widget uses the responsive layouts defined in the preceding code
   snippets. This means the layout specified as
   ``R.layout.widget_weather_forecast_small`` is used from 180dp
   (``minResizeWidth``) x 110dp (``minResizeHeight``) to 269x279dp (next cutoff
   points - 1). Similarly, ``R.layout.widget_weather_forecast_medium`` is used
   from 270x110dp to 270x279dp, and ``R.layout.widget_weather_forecast_large``
   is used from 270x280dp to 530dp (``maxResizeWidth``) x 450dp
   (``maxResizeHeight``).

   As the user resizes the widget, its appearance changes to adapt to each size
   in cells, as shown in the following examples.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-3x2.png
      :alt: Example weather widget in the smallest 3x2-grid size. The UI shows
      the location name (Tokyo), temperature (14°), and symbol indicating
      partially cloudy weather.
      :width: 175px

      **Figure 2.** 3x2 ``R.layout.widget_weather_forecast_small``.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-4x2.png
      :alt: Example weather widget in a 4x2 'medium' size. Resizing the widget
      this way builds on all of the UI from the previous widget size, and adds
      the label 'Mostly cloudy' and a forecast of temperatures from 4pm through
      7pm.
      :width: 300px

      **Figure 3.** 4x2 ``R.layout.widget_weather_forecast_medium``.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-5x2.png
      :alt: Example weather widget in a 5x2 'medium' size. Resizing the widget
      this way results in the same UI as the previous size, except it is
      stretched by one cell length to take up more horizontal space.
      :width: 300px

      **Figure 4.** 5x2 ``R.layout.widget_weather_forecast_medium``.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-5x3.png
      :alt: Example weather widget in a 5x3 'large' size. Resizing the widget
      this way builds on all of the UI from the previous widget sizes, and adds
      a view inside the widget containing a forecast of the weather on Tuesday
      and Wednesday. Symbols indicating sunny or rainy weather and high and low
      temperatures for each day.
      :width: 300px

      **Figure 5.** 5x3 ``R.layout.widget_weather_forecast_large``.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/weather-size-5x4.png
      :alt: Example weather widget in a 5x4 'large' size. Resizing the widget
      this way builds on all of the UI from the previous widget sizes, and adds
      Thursday and Friday (and their corresponding symbols indicating the type
      of weather as well as high and low temperature for each day).
      :width: 300px

      **Figure 6.** 5x4 ``R.layout.widget_weather_forecast_large``.


Last updated 2024-05-03 UTC.


/Enable widget configuration
============================

.. https://developer.android.google.cn/develop/ui/views/appwidgets/configuration?hl=en

.. container:: devsite-article-body

   App widgets can be configurable. For example, a clock widget can let users
   configure which time zone to display.

   If you want to let users configure your widget’s settings, create a widget
   configuration `Activity <#android.app.Activity>`__. This
   activity is automatically launched by the app widget host either when the
   widget is created or later, depending on the `configuration options <#widget-config-options>`__ you specify.

   .. rubric:: Declare the configuration activity
      :name: declare

   Declare the configuration activity as a normal activity in the Android
   manifest file. The app widget host launches it with the
   `ACTION_APPWIDGET_CONFIGURE <#android.appwidget.AppWidgetManager>`__
   action, so the activity needs to accept this intent. For example:

   .. code:: prettyprint

      <activity android:name=".ExampleAppWidgetConfigurationActivity">
          <intent-filter>
              <action android:name="android.appwidget.action.APPWIDGET_CONFIGURE"/>
          </intent-filter>
      </activity>

   Declare the activity in the ``AppWidgetProviderInfo.xml`` file with the
   ``android:configure`` attribute. See more information about `declaring this file <#AppWidgetProviderInfo>`__. Here’s an example
   of how to declare the configuration activity:

   .. code:: prettyprint

      <appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
          ...
          android:configure="com.example.android.ExampleAppWidgetConfigurationActivity"
          ... >
      </appwidget-provider>

   The activity is declared with a fully qualified namespace, because the
   launcher references it from outside your package scope.

   That's all you need to start a configuration activity. Next, you need to
   implement the actual activity.

   .. rubric:: Implement the configuration activity
      :name: implement

   There are two important points to remember when you implement the activity:

   -  The app widget host calls the configuration activity, and the
      configuration activity must always return a result. The result must
      include the App Widget ID passed by the intent that launched the
      activity—saved in the intent extras as
      `EXTRA_APPWIDGET_ID <#android.appwidget.AppWidgetManager>`__.
   -  The system doesn't send the
      `ACTION_APPWIDGET_UPDATE <#android.appwidget.AppWidgetManager>`__
      broadcast when a configuration activity is launched, which means it
      doesn't call the
      `onUpdate() <#android.appwidget.AppWidgetProvider>`__
      method when the widget is created. It's the responsibility of the
      configuration activity to request an update from the ``AppWidgetManager``
      when creating the widget for the first time. However, ``onUpdate()`` is
      called for subsequent updates—it is only skipped the first time.

   See the code snippets in the following section for an example of how to
   return a result from the configuration and update the widget.

   .. rubric:: Update the widget from the configuration activity
      :name: update

   When a widget uses a configuration activity, it's the responsibility of the
   activity to update the widget when configuration is complete. You can do so
   by requesting an update directly from the
   `AppWidgetManager <#android.appwidget.AppWidgetManager>`__.

   Here's a summary of the procedure to properly update the widget and close the
   configuration activity:

   #. Get the App Widget ID from the intent that launched the activity:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val appWidgetId = intent?.extras?.getInt(
                          AppWidgetManager.EXTRA_APPWIDGET_ID,
                          AppWidgetManager.INVALID_APPWIDGET_ID
                  ) ?: AppWidgetManager.INVALID_APPWIDGET_ID

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  Intent intent = getIntent();
                  Bundle extras = intent.getExtras();
                  int appWidgetId = AppWidgetManager.INVALID_APPWIDGET_ID;
                  if (extras != null) {
                      appWidgetId = extras.getInt(
                              AppWidgetManager.EXTRA_APPWIDGET_ID,
                              AppWidgetManager.INVALID_APPWIDGET_ID);
                  }

   #. Set the activity result to ``RESULT_CANCELED``.

      This way, if the user backs out of the activity before reaching the end,
      the system notifies the app widget host that the configuration is canceled
      and the host doesn't add the widget:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val resultValue = Intent().putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                  setResult(Activity.RESULT_CANCELED, resultValue)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  int resultValue = new Intent().putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
                  setResult(Activity.RESULT_CANCELED, resultValue);

   #. Configure the widget according to the user’s preferences.

   #. When the configuration is complete, get an instance of the
      ``AppWidgetManager`` by calling
      `getInstance(Context) <#android.appwidget.AppWidgetManager>`__:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val appWidgetManager = AppWidgetManager.getInstance(context)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);

   #. Update the widget with a
      `RemoteViews <#android.widget.RemoteViews>`__ layout by
      calling
      `updateAppWidget(int,RemoteViews) <#android.appwidget.AppWidgetManager>`__:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val views = RemoteViews(context.packageName, R.layout.example_appwidget)
                  appWidgetManager.updateAppWidget(appWidgetId, views)

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.example_appwidget);
                  appWidgetManager.updateAppWidget(appWidgetId, views);

   #. Create the return intent, set it with the activity result, and finish the
      activity:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  val resultValue = Intent().putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                  setResult(Activity.RESULT_OK, resultValue)
                  finish()

            .. container:: section

               .. rubric:: Java
                  :name: java

               .. code:: prettyprint

                  Intent resultValue = new Intent().putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
                  setResult(RESULT_OK, resultValue);
                  finish();

   See the
   `ListWidgetConfigureActivity.kt <https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/java/com/example/android/appwidget/rv/list/ListWidgetConfigureActivity.kt>`__
   sample class on GitHub for an example.

   .. rubric:: Widget configuration options
      :name: widget-config-options

   By default, the app widget host only launches the configuration activity
   once, immediately after the user adds the widget to their home screen.
   However, you can specify options that let you enable users to reconfigure
   existing widgets or skip initial widget configuration by providing a default
   widget configuration.

   **Note:**\  These options are only available starting in Android 12 (API
   level 31). You can specify them for previous versions of Android, but the
   system ignores them and follows the default behavior.

   .. rubric:: Enable users to reconfigure placed widgets
      :name: reconfigure-widgets

   To let users reconfigure existing widgets, specify the
   `reconfigurable <#android.appwidget.AppWidgetProviderInfo>`__
   flag in the
   `widgetFeatures <#android.appwidget.AppWidgetProviderInfo>`__
   attribute of ``appwidget-provider``. See the guide to `declaring the ``AppWidgetProviderInfo.xml``
   file <#AppWidgetProviderInfo>`__ for more
   information. For example:

   .. code:: prettyprint

      <appwidget-provider
          android:configure="com.myapp.ExampleAppWidgetConfigurationActivity"
          android:widgetFeatures="reconfigurable">
      </appwidget-provider>

   Users can reconfigure their widget by touching & holding the widget and
   tapping the **Reconfigure** button, which is labeled 1 in figure 1.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/widget-reconfigure-button.png
      :alt: Button appears in bottom-right corner
      :width: 300px

      **Figure 1.** Widget **Reconfigure** button.

   **Note:**\  The ``reconfigurable`` flag was introduced in Android 9 (API
   level 28), but it was not widely supported until Android 12.

   .. rubric:: Use the widget's default configuration
      :name: use-default

   You can provide a more seamless widget experience by letting users skip the
   initial configuration step. To do this, specify both the
   `configuration_optional <#android.appwidget.AppWidgetProviderInfo>`__
   and ``reconfigurable`` flags in the ``widgetFeatures`` field. This bypasses
   launching the configuration activity after a user adds the widget. As
   mentioned previously, the user can still `reconfigure the widget <#reconfigure-widgets>`__ afterward. For example, a clock widget can
   bypass the initial configuration and show the device time zone by default.

   Here is an example of how to mark your configuration activity as both
   reconfigurable and optional:

   .. code:: prettyprint

      <appwidget-provider
          android:configure="com.myapp.ExampleAppWidgetConfigurationActivity"
          android:widgetFeatures="reconfigurable|configuration_optional">
      </appwidget-provider>

   .. rubric:: Let users pin a widget
      :name: pin

   On devices running Android 8.0 (API level 26) and higher, launchers that let
   users create `pinned shortcuts <#shortcut-types>`__
   also let them pin widgets onto their home screen. Similar to pinned
   shortcuts, these *pinned widgets* give users access to specific tasks in your
   app and can be added to the home screen directly from the app, as shown in
   the following video.

   .. figure:: https://developer.android.google.cn/static/images/appwidgets/widget_pinning.gif
      :alt: Example of responsive layout
      :width: 300px

      **Figure 2.** Example of pinning a widget.

   In your app, you can create a request for the system to pin a widget onto a
   supported launcher by completing the following steps:

   #. Make sure you `declare a widget in your app’s manifest file <#Manifest>`__.

   #. Call the
      `requestPinAppWidget() <#android.appwidget.AppWidgetManager>`__
      method, as shown in the following code snippet:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val appWidgetManager = AppWidgetManager.getInstance(context)
               val myProvider = ComponentName(context, ExampleAppWidgetProvider::class.java)

               if (appWidgetManager.isRequestPinAppWidgetSupported()) {
                   // Create the PendingIntent object only if your app needs to be notified
                   // when the user chooses to pin the widget. Note that if the pinning
                   // operation fails, your app isn't notified. This callback receives the ID
                   // of the newly pinned widget (EXTRA_APPWIDGET_ID).
                   val successCallback = PendingIntent.getBroadcast(
                           /* context = */ context,
                           /* requestCode = */ 0,
                           /* intent = */ Intent(...),
                           /* flags = */ PendingIntent.FLAG_UPDATE_CURRENT)

                   appWidgetManager.requestPinAppWidget(myProvider, null, successCallback)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
               ComponentName myProvider = new ComponentName(context, ExampleAppWidgetProvider.class);

               if (appWidgetManager.isRequestPinAppWidgetSupported()) {
                   // Create the PendingIntent object only if your app needs to be notified
                   // when the user chooses to pin the widget. Note that if the pinning
                   // operation fails, your app isn't notified. This callback receives the ID
                   // of the newly pinned widget (EXTRA_APPWIDGET_ID).
                   PendingIntent successCallback = PendingIntent.getBroadcast(
                           /* context = */ context,
                           /* requestCode = */ 0,
                           /* intent = */ new Intent(...),
                           /* flags = */ PendingIntent.FLAG_UPDATE_CURRENT);

                   appWidgetManager.requestPinAppWidget(myProvider, null, successCallback);
               }

   **Note:**\  If your app doesn't need to be notified of whether the system
   successfully pins a widget onto a supported launcher, you can pass in
   ``null`` as the third argument to ``requestPinAppWidget()``.


Last updated 2024-05-03 UTC.


/Build a widget host
====================

.. https://developer.android.google.cn/develop/ui/views/appwidgets/host?hl=en

.. container:: devsite-article-body

   The Android home screen, available on most Android-powered devices, lets the
   user embed `app widgets <#>`__ (or *widgets*)
   for quick access to content. If you're building a home screen replacement or
   a similar app, you can also let the user embed widgets by implementing
   `AppWidgetHost <#android.appwidget.AppWidgetHost>`__. This
   isn't something that most apps need to do, but if you are creating your own
   host, it's important to understand the contractual obligations a host
   implicitly agrees to.

   .. container:: video-wrapper

   This page focuses on the responsibilities involved in implementing a custom
   ``AppWidgetHost``. For a specific example of how to implement an
   ``AppWidgetHost``, look at the source code for the Android home screen
   `LauncherAppWidgetHost <https://cs.android.com/android/platform/superproject/+/master:packages/apps/Launcher3/src/com/android/launcher3/widget/LauncherAppWidgetHost.java;l=57?q=LauncherAppWidgetHost>`__.

   Here is an overview of key classes and concepts involved in implementing a
   custom ``AppWidgetHost``:

   -  **App widget host**: the ``AppWidgetHost`` provides the interaction with
      the AppWidget service for apps that embed widgets in their UI. An
      ``AppWidgetHost`` must have an ID that is unique within the host's own
      package. This ID persists across all uses of the host. The ID is typically
      a hardcoded value that you assign in your app.

   -  **App widget ID**: each widget instance is assigned a unique ID at the
      time of binding. See
      `bindAppWidgetIdIfAllowed() <#android.appwidget.AppWidgetManager>`__
      and, for more detail, the `Binding widgets <#bind>`__ section that
      follows. The host obtains the unique ID using
      `allocateAppWidgetId() <#android.appwidget.AppWidgetHost>`__.
      This ID persists across the lifetime of the widget until it is deleted
      from the host. Any host-specific state—such as the size and location of
      the widget—must be persisted by the hosting package and associated with
      the app widget ID.

   -  **App widget host view**: think of
      `AppWidgetHostView <#android.appwidget.AppWidgetHostView>`__
      as a frame that the widget is wrapped in whenever it needs to be
      displayed. A widget is associated with an ``AppWidgetHostView`` every time
      the widget is inflated by the host.

      -  By default, the system creates an ``AppWidgetHostView``, but the host
         can create its own subclass of ``AppWidgetHostView`` by extending it.
      -  Starting in Android 12 (API level 31), ``AppWidgetHostView`` introduces
         the the
         `setColorResources() <#android.appwidget.AppWidgetHostView>`__
         and
         `resetColorResources() <#android.appwidget.AppWidgetHostView>`__
         methods for handling dynamically overloaded colors. The host is
         responsible for providing the colors to these methods.

   -  **Options bundle**: the ``AppWidgetHost`` uses the options bundle to
      communicate information to the
      `AppWidgetProvider <#android.appwidget.AppWidgetProvider>`__
      about how the widget is displayed—for example, the `list of size ranges <#provide-exact-layouts>`__—and
      whether the widget is on a lockscreen or the home screen. This information
      lets the ``AppWidgetProvider`` tailor the widget's contents and appearance
      based on how and where it is displayed. You can use
      `updateAppWidgetOptions() <#android.appwidget.AppWidgetHostView>`__
      and
      `updateAppWidgetSize() <#android.appwidget.AppWidgetHostView>`__
      to modify a widget's bundle. Both of these methods trigger the
      `onAppWidgetOptionsChanged() <#android.appwidget.AppWidgetProvider>`__
      callback to the ``AppWidgetProvider``.

   .. rubric:: Binding widgets
      :name: bind

   When a user adds a widget to a host, a process called *binding* occurs.
   Binding refers to associating a particular app widget ID with a specific host
   and a specific ``AppWidgetProvider``.

   Binding APIs also make it possible for a host to provide a custom UI for
   binding. To use this process, your app must declare the
   `BIND_APPWIDGET <#android.Manifest.permission>`__
   permission in the host's manifest:

   .. code:: prettyprint

      <uses-permission android:name="android.permission.BIND_APPWIDGET" />

   But this is just the first step. At runtime, the user must explicitly grant
   permission to your app to let it add a widget to the host. To test whether
   your app has permission to add the widget, use the
   `bindAppWidgetIdIfAllowed() <#android.appwidget.AppWidgetManager>`__
   method. If ``bindAppWidgetIdIfAllowed()`` returns ``false``, your app must
   display a dialog prompting the user to grant permission: "allow" for the
   current widget addition, or "always allow" to cover all future widget
   additions.

   This snippet gives an example of how to display the dialog:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               val intent = Intent(AppWidgetManager.ACTION_APPWIDGET_BIND).apply {
                   putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                   putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName)
                   // This is the options bundle described in the preceding section.
                   putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options)
               }
               startActivityForResult(intent, REQUEST_BIND_APPWIDGET)

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
               intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
               intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);
               // This is the options bundle described in the preceding section.
               intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
               startActivityForResult(intent, REQUEST_BIND_APPWIDGET);

   The host must check whether the widget that a user adds needs configuration.
   For more information, see `Enable users to configure app widgets <#>`__.

   .. rubric:: Host responsibilities
      :name: responsibilities

   You can specify a number of configuration settings for widgets using the
   `AppWidgetProviderInfo metadata <#components>`__. You can retrieve these
   configuration options, covered in more detail in the following sections, from
   the
   `AppWidgetProviderInfo <#android.appwidget.AppWidgetProviderInfo>`__
   object associated with a widget provider.

   Regardless of the version of Android you are targeting, all hosts have the
   following responsibilities:

   -  When adding a widget, allocate the widget ID as described earlier. When a
      widget is removed from the host, call
      `deleteAppWidgetId() <#android.appwidget.AppWidgetHost>`__
      to deallocate the widget ID.

   -  When adding a widget, check whether the configuration activity needs to be
      launched. Typically, the host needs to launch the widget's configuration
      activity if it exists and isn't marked as optional by specifying both the
      ``configuration_optional`` and ``reconfigurable`` flags. See `Update the
      widget from the configuration activity <#update>`__ for details.
      This is a necessary step for many widgets before they can display.

      **Note:**\  Handle irregular cases where the configuration activity
      doesn't return or finishes with errors.

   -  Widgets specify a default width and height in the
      ``AppWidgetProviderInfo`` metadata. These values are defined in
      cells—starting in Android 12, if ``targetCellWidth`` and
      ``targetCellHeight`` are specified—or dps if only ``minWidth`` and
      ``minHeight`` are specified. See `Widget sizing attributes <#widget-sizing-attributes>`__.

      Make sure that the widget is laid out with at least this many dps. For
      example, many hosts align icons and widgets in a grid. In this scenario,
      by default the host adds the a widget using the minimum number of cells
      that satisfy the ``minWidth`` and ``minHeight`` constraints.

   In addition to the requirements listed in the preceding section, specific
   platform versions introduce features that place new responsibilities on the
   host.

   .. rubric:: Determine your approach based on the targeted Android version
      :name: determine-approach

   .. rubric:: Android 12
      :name: android-12

   Android 12 (API level 31) bundles an extra ``List<SizeF>`` that contains the
   list of possible sizes in dps that a widget instance can take in the options
   bundle. The number of sizes provided depends on the host implementation.
   Hosts typically provide two sizes for phones—portrait and landscape—and four
   sizes for foldables.

   There is a limit of ``MAX_INIT_VIEW_COUNT`` (16) on the number of different
   ``RemoteViews`` that an ``AppWidgetProvider`` can provide to
   `RemoteViews <#android.widget.RemoteViews>`__.
   Since ``AppWidgetProvider`` objects map a ``RemoteViews`` object to each size
   in the ``List<SizeF>``, don't provide more than ``MAX_INIT_VIEW_COUNT``
   sizes.

   Android 12 also introduces the
   `maxResizeWidth <#android.appwidget.AppWidgetProviderInfo>`__
   and
   `maxResizeHeight <#android.appwidget.AppWidgetProviderInfo>`__
   attributes in dps. We recommend that a widget that uses at least one of these
   attributes doesn't exceed the size specified by the attributes.

   .. rubric:: Additional resources
      :name: additional-resources

   -  See the `Glance <#>`__ reference
      documentation.


Last updated 2024-05-03 UTC.


/Control external devices
=========================

.. https://developer.android.google.cn/develop/ui/views/device-control?hl=en

.. container:: devsite-article-body

   In Android 11 and later, the Quick Access Device Controls feature lets the
   user quickly view and control external devices such as lights, thermostats,
   and cameras from a user affordance within three interactions from a default
   launcher. The device OEM chooses what launcher they use. Device
   aggregators—for example, Google Home—and third-party vendor apps can provide
   devices for display in this space. This page shows you how to surface device
   controls in this space and link them to your control app.

   **Note:**\  To leverage these features, your project's ``minSdk`` must be
   ``30`` or higher.

   .. container:: float
      :name: device-control

   To add this support, create and declare a ``ControlsProviderService``. Create
   the controls your app supports based on predefined control types, and then
   create publishers for these controls.

   .. rubric:: User interface
      :name: user-interface

   Devices are displayed under **Device controls** as templated widgets. Five
   device control widgets are available, as shown in the following figure:

   .. list-table::
      :widths: 27 27 27

      - 

         - .. figure:: https://developer.android.google.cn/static/images/device-control/device-control-toggle.png
               :alt: Toggle widget
               :width: 180px

            Toggle
         - .. figure::
               https://developer.android.google.cn/static/images/device-control/device-control-toggle-slider.png
               :alt: Toggle with slider widget
               :width: 180px

            Toggle with slider
         - .. figure:: https://developer.android.google.cn/static/images/device-control/device-control-range.png
               :alt: Range widget
               :width: 180px

            Range (can't be toggled on or off)
      - 

         - .. figure::
               https://developer.android.google.cn/static/images/device-control/device-control-toggle-stateless.png
               :alt: Stateless toggle widget
               :width: 180px

            Stateless toggle
         - .. figure:: https://developer.android.google.cn/static/images/device-control/device-control-panel1.png
               :alt: Temperature panel widget (closed)
               :width: 180px

            Temperature panel (closed)
         - 

   **Figure 2.** Collection of templated widgets.
   Touching & holding a widget takes you to the app for deeper control. You can
   customize the icon and color on each widget, but for the best user
   experience, use the default icon and color if the default set matches the
   device.

   .. figure:: https://developer.android.google.cn/static/images/device-control/device-control-panel2.png
      name: device-control-panel2
      :alt: An image showing the temperature panel widget (open)
      :width: 40.0%

      **Figure 3.** Open temperature panel widget open.

   .. rubric:: Create the service
      :name: create-service

   This section shows how to create the
   `ControlsProviderService <#android.service.controls.ControlsProviderService>`__.
   This service tells the Android system UI that your app contains device
   controls that must be surfaced in the **Device controls** area of the Android
   UI.

   The ``ControlsProviderService`` API assumes familiarity with reactive
   streams, as defined in the `Reactive Streams GitHub project <https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md>`__
   and implemented in the `Java 9 Flow interfaces <https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html>`__.
   The API is built around the following concepts:

   -  **Publisher:** your application is the publisher.
   -  **Subscriber:** the system UI is the subscriber and it can request a
      number of controls from the publisher.
   -  **Subscription:** the timeframe during which the publisher can send
      updates to the System UI. Either the publisher or the subscriber can close
      this window.

   .. rubric:: Declare the service
      :name: declare-service

   Your app must declare a service—such as ``MyCustomControlService``—in its app
   manifest.

   The service must include an intent filter for ``ControlsProviderService``.
   This filter lets applications contribute controls to the system UI.

   You also need a ``label`` that is displayed in the controls in the system UI.

   The following example shows how to declare a service:

   .. code:: prettyprint

      <service
          android:name="MyCustomControlService"
          android:label="My Custom Controls"
          android:permission="android.permission.BIND_CONTROLS"
          android:exported="true"
          >
          <intent-filter>
            <action android:name="android.service.controls.ControlsProviderService" />
          </intent-filter>
      </service>

   Next, create a new Kotlin file named ``MyCustomControlService.kt`` and make
   it extend ``ControlsProviderService()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   class MyCustomControlService : ControlsProviderService() {
                       ...
                   }
                   

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                   public class MyCustomJavaControlService extends ControlsProviderService {
                       ...
                   }
                   

   .. rubric:: Select the correct control type
      :name: select-control-type

   The API provides builder methods to create the controls. To populate the
   builder, determine the device you want to control and how the user interacts
   with it. Perform the following steps:

   #. Pick the type of device the control represents. The
      `DeviceTypes <#android.service.controls.DeviceTypes>`__
      class is an enumeration of all supported devices. The type is used to
      determine the icons and colors for the device in the UI.
   #. Determine the user-facing name, device location—for example, kitchen—and
      other UI textual elements associated with the control.
   #. Pick the best template to support user interaction. Controls are assigned
      a
      `ControlTemplate <#android.service.controls.templates.ControlTemplate>`__
      from the application. This template directly shows the control state to
      the user as well as the available input methods—that is, the
      `ControlAction <#android.service.controls.actions.ControlAction>`__.
      The following table outlines some of the available templates and the
      actions they support:

   .. list-table::

      - 

         - **Template**
         - **Action**
         - **Description**
      - 

         - `ControlTemplate.getNoTemplateObject() <#android.service.controls.templates.ControlTemplate>`__
         - ``None``
         - The application might use this to convey information about the
            control, but the user can't interact with it.
      - 

         - ``ToggleTemplate``
         - ``BooleanAction``
         - Represents a control that can be switched between enabled and
            disabled states. The ``BooleanAction`` object contains a field that
            changes to represent the requested new state when the user taps the
            control.
      - 

         - ``RangeTemplate``
         - ``FloatAction``
         - Represents a slider widget with specified min, max, and step values.
            When the user interacts with the slider, send a new ``FloatAction``
            object back to the application with the updated value.
      - 

         - ``ToggleRangeTemplate``
         - ``BooleanAction``, ``FloatAction`` 
         - This template is a combination of the ``ToggleTemplate`` and
            ``RangeTemplate``. It supports touch events as well as a slider,
            such as to control dimmable lights.
      - 

         - ``TemperatureControlTemplate``
         - ``ModeAction``, ``BooleanAction``, ``FloatAction``
         - In addition to encapsulating the preceding actions, this template
            lets the user set a mode, such as heat, cool, heat/cool, eco, or
            off.
      - 

         - ``StatelessTemplate``
         - ``CommandAction``
         - Used to indicate a control that provides touch capability but whose
            state can't be determined, such as an IR television remote. You can
            use this template to define a routine or macro, which is an
            aggregation of control and state changes.

   With this information, you can create the control:

   -  Use the
      `Control.StatelessBuilder <#android.service.controls.Control.StatelessBuilder>`__
      builder class when the state of the control is unknown.
   -  Use the
      `Control.StatefulBuilder <#android.service.controls.Control.StatefulBuilder>`__
      builder class when the state of the control is known.

   For example, to control a smart light bulb and a thermostat, add the
   following constants to your ``MyCustomControlService``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   private const val LIGHT_ID = 1234
                   private const val LIGHT_TITLE = "My fancy light"
                   private const val LIGHT_TYPE = DeviceTypes.TYPE_LIGHT
                   private const val THERMOSTAT_ID = 5678
                   private const val THERMOSTAT_TITLE = "My fancy thermostat"
                   private const val THERMOSTAT_TYPE = DeviceTypes.TYPE_THERMOSTAT
                
                   class MyCustomControlService : ControlsProviderService() {
                     ...
                   }
                   

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                   public class MyCustomJavaControlService extends ControlsProviderService {
                
                   private final int LIGHT_ID = 1337;
                   private final String LIGHT_TITLE = "My fancy light";
                   private final int LIGHT_TYPE = DeviceTypes.TYPE_LIGHT;
                   private final int THERMOSTAT_ID = 1338;
                   private final String THERMOSTAT_TITLE = "My fancy thermostat";
                   private final int THERMOSTAT_TYPE = DeviceTypes.TYPE_THERMOSTAT;
                
                   ...
                   }
                   

   .. rubric:: Create publishers for the controls
      :name: create-publishers-for-controls

   After you create the control, it needs a publisher. The publisher informs the
   system UI of the existence of the control. The ``ControlsProviderService``
   class has two publisher methods that you must override in your application
   code:

   -  ``createPublisherForAllAvailable()``: creates a
      `Publisher <https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/api/src/main/java/org/reactivestreams/Publisher.java>`__
      for all the controls available in your app. Use
      ``Control.StatelessBuilder()`` to build ``Control`` objects for this
      publisher.
   -  ``createPublisherFor()``: creates a ``Publisher`` for a list of given
      controls, as identified by their string identifiers. Use
      ``Control.StatefulBuilder`` to build these ``Control`` objects, since the
      publisher must assign a state to each control.

   .. rubric:: Create the publisher
      :name: create-publisher

   When your app first publishes controls to the system UI, the app doesn't know
   the state of each control. Getting the state can be a time-consuming
   operation involving many hops in the device-provider's network. Use the
   `createPublisherForAllAvailable() <#android.service.controls.ControlsProviderService>`__
   method to advertise the available controls to the system. This method uses
   the ``Control.StatelessBuilder`` builder class, since the state of each
   control is unknown.

   Once the controls appear in the Android UI , the user can select favorite
   controls.

   To use Kotlin coroutines to create a ``ControlsProviderService``, add a new
   dependency to your ``build.gradle``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "org.jetbrains.kotlinx:kotlinx-coroutines-jdk9:1.6.4"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("org.jetbrains.kotlinx:kotlinx-coroutines-jdk9:1.6.4")
               }

   Once you sync your Gradle files, add the following snippet to your
   ``Service`` to implement ``createPublisherForAllAvailable()``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   class MyCustomControlService : ControlsProviderService() {
                
                     override fun createPublisherForAllAvailable(): Flow.Publisher =
                         flowPublish {
                             send(createStatelessControl(LIGHT_ID, LIGHT_TITLE, LIGHT_TYPE))
                             send(createStatelessControl(THERMOSTAT_ID, THERMOSTAT_TITLE, THERMOSTAT_TYPE))
                         }
                
                     private fun createStatelessControl(id: Int, title: String, type: Int): Control {
                         val intent = Intent(this, MainActivity::class.java)
                             .putExtra(EXTRA_MESSAGE, title)
                             .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                         val action = PendingIntent.getActivity(
                             this,
                             id,
                             intent,
                             PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                         )
                
                         return Control.StatelessBuilder(id.toString(), action)
                             .setTitle(title)
                             .setDeviceType(type)
                             .build()
                     }
                
                         override fun createPublisherFor(controlIds: List): Flow.Publisher {
                          TODO()
                       }
                
                       override fun performControlAction(
                           controlId: String,
                           action: ControlAction,
                           consumer: Consumer
                       ) {
                           TODO()
                       }
                   }
                   

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                   public class MyCustomJavaControlService extends ControlsProviderService {
                
                       private final int LIGHT_ID = 1337;
                       private final String LIGHT_TITLE = "My fancy light";
                       private final int LIGHT_TYPE = DeviceTypes.TYPE_LIGHT;
                       private final int THERMOSTAT_ID = 1338;
                       private final String THERMOSTAT_TITLE = "My fancy thermostat";
                       private final int THERMOSTAT_TYPE = DeviceTypes.TYPE_THERMOSTAT;
                
                       private boolean toggleState = false;
                       private float rangeState = 18f;
                       private final Map> controlFlows = new HashMap<>();
                
                       @NonNull
                       @Override
                       public Flow.Publisher createPublisherForAllAvailable() {
                           List controls = new ArrayList<>();
                           controls.add(createStatelessControl(LIGHT_ID, LIGHT_TITLE, LIGHT_TYPE));
                           controls.add(createStatelessControl(THERMOSTAT_ID, THERMOSTAT_TITLE, THERMOSTAT_TYPE));
                           return FlowAdapters.toFlowPublisher(Flowable.fromIterable(controls));
                       }
                
                       @NonNull
                       @Override
                       public Flow.Publisher createPublisherFor(@NonNull List controlIds) {
                           ReplayProcessor updatePublisher = ReplayProcessor.create();
                
                           controlIds.forEach(control -> {
                               controlFlows.put(control, updatePublisher);
                               updatePublisher.onNext(createLight());
                               updatePublisher.onNext(createThermostat());
                           });
                
                           return FlowAdapters.toFlowPublisher(updatePublisher);
                       }
                   }
                   

   Swipe down the system menu and locate the **Device controls** button, shown
   in figure 4:

   .. figure:: https://developer.android.google.cn/static/images/ui/device_controls_ui.png
      name: system-ui
      :alt: An image showing the system ui for device controls
      :width: 50.0%

      **Figure 4.** Device controls in the system menu.

   Tapping **Device controls** navigates to a second screen where you can select
   your app. Once you select your app, you see how the previous snippet creates
   a custom system menu showing your new controls, as shown in figure 5:

   .. figure:: https://developer.android.google.cn/static/images/ui/device_controls_example_1.png
      name: controls_1
      :alt: An image showing the system menu containing a light and thermostat
      control
      :width: 50.0%

      **Figure 5.** Light and thermostat controls to add.

   Now, implement the ``createPublisherFor()`` method, adding the following to
   your ``Service``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   private val job = SupervisorJob()
                   private val scope = CoroutineScope(Dispatchers.IO + job)
                   private val controlFlows = mutableMapOf>()
                
                   private var toggleState = false
                   private var rangeState = 18f
                
                   override fun createPublisherFor(controlIds: List): Flow.Publisher {
                       val flow = MutableSharedFlow(replay = 2, extraBufferCapacity = 2)
                
                       controlIds.forEach { controlFlows[it] = flow }
                
                       scope.launch {
                           delay(1000) // Retrieving the toggle state.
                           flow.tryEmit(createLight())
                
                           delay(1000) // Retrieving the range state.
                           flow.tryEmit(createThermostat())
                
                       }
                       return flow.asPublisher()
                   }
                
                   private fun createLight() = createStatefulControl(
                       LIGHT_ID,
                       LIGHT_TITLE,
                       LIGHT_TYPE,
                       toggleState,
                       ToggleTemplate(
                           LIGHT_ID.toString(),
                           ControlButton(
                               toggleState,
                               toggleState.toString().uppercase(Locale.getDefault())
                           )
                       )
                   )
                
                   private fun createThermostat() = createStatefulControl(
                       THERMOSTAT_ID,
                       THERMOSTAT_TITLE,
                       THERMOSTAT_TYPE,
                       rangeState,
                       RangeTemplate(
                           THERMOSTAT_ID.toString(),
                           15f,
                           25f,
                           rangeState,
                           0.1f,
                           "%1.1f"
                       )
                   )
                
                   private fun  createStatefulControl(id: Int, title: String, type: Int, state: T, template: ControlTemplate): Control {
                       val intent = Intent(this, MainActivity::class.java)
                           .putExtra(EXTRA_MESSAGE, "$title $state")
                           .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                       val action = PendingIntent.getActivity(
                           this,
                           id,
                           intent,
                           PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                       )
                
                       return Control.StatefulBuilder(id.toString(), action)
                           .setTitle(title)
                           .setDeviceType(type)
                           .setStatus(Control.STATUS_OK)
                           .setControlTemplate(template)
                           .build()
                   }
                
                   override fun onDestroy() {
                       super.onDestroy()
                       job.cancel()
                   }
                
                   

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                   @NonNull
                   @Override
                   public Flow.Publisher createPublisherFor(@NonNull List controlIds) {
                       ReplayProcessor updatePublisher = ReplayProcessor.create();
                
                       controlIds.forEach(control -> {
                           controlFlows.put(control, updatePublisher);
                           updatePublisher.onNext(createLight());
                           updatePublisher.onNext(createThermostat());
                       });
                
                       return FlowAdapters.toFlowPublisher(updatePublisher);
                   }
                
                   private Control createStatelessControl(int id, String title, int type) {
                       Intent intent = new Intent(this, MainActivity.class)
                               .putExtra(EXTRA_MESSAGE, title)
                               .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                       PendingIntent action = PendingIntent.getActivity(
                               this,
                               id,
                               intent,
                               PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
                       );
                
                       return new Control.StatelessBuilder(id + "", action)
                               .setTitle(title)
                               .setDeviceType(type)
                               .build();
                   }
                
                   private Control createLight() {
                       return createStatefulControl(
                               LIGHT_ID,
                               LIGHT_TITLE,
                               LIGHT_TYPE,
                               toggleState,
                               new ToggleTemplate(
                                       LIGHT_ID + "",
                                       new ControlButton(
                                               toggleState,
                                               String.valueOf(toggleState).toUpperCase(Locale.getDefault())
                                       )
                               )
                       );
                   }
                
                   private Control createThermostat() {
                       return createStatefulControl(
                               THERMOSTAT_ID,
                               THERMOSTAT_TITLE,
                               THERMOSTAT_TYPE,
                               rangeState,
                               new RangeTemplate(
                                       THERMOSTAT_ID + "",
                                       15f,
                                       25f,
                                       rangeState,
                                       0.1f,
                                       "%1.1f"
                               )
                       );
                   }
                
                   private  Control createStatefulControl(int id, String title, int type, T state, ControlTemplate template) {
                       Intent intent = new Intent(this, MainActivity.class)
                               .putExtra(EXTRA_MESSAGE, "$title $state")
                               .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                       PendingIntent action = PendingIntent.getActivity(
                               this,
                               id,
                               intent,
                               PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
                       );
                
                       return new Control.StatefulBuilder(id + "", action)
                               .setTitle(title)
                               .setDeviceType(type)
                               .setStatus(Control.STATUS_OK)
                               .setControlTemplate(template)
                               .build();
                   }
                   

   In this example, the ``createPublisherFor()`` method contains a fake
   implementation of what your app must do: communicate with your device to
   retrieve its status, and emit that status to the system.

   The ``createPublisherFor()`` method uses Kotlin coroutines and flows to
   satisfy the required Reactive Streams API by doing the following:

   #. Creates a ``Flow``.
   #. Waits for one second.
   #. Creates and emits the state of the smart light.
   #. Waits for another second.
   #. Creates and emits the state of the thermostat.

   .. rubric:: Handle actions
      :name: handle-actions

   The ``performControlAction()`` method signals when the user interacts with a
   published control. The type of ``ControlAction`` sent determines the action.
   Perform the appropriate action for the given control and then update the
   state of the device in the Android UI.

   To complete the example, add the following to your ``Service``:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

                   override fun performControlAction(
                       controlId: String,
                       action: ControlAction,
                       consumer: Consumer
                   ) {
                       controlFlows[controlId]?.let { flow ->
                           when (controlId) {
                               LIGHT_ID.toString() -> {
                                   consumer.accept(ControlAction.RESPONSE_OK)
                                   if (action is BooleanAction) toggleState = action.newState
                                   flow.tryEmit(createLight())
                               }
                               THERMOSTAT_ID.toString() -> {
                                   consumer.accept(ControlAction.RESPONSE_OK)
                                   if (action is FloatAction) rangeState = action.newValue
                                   flow.tryEmit(createThermostat())
                               }
                               else -> consumer.accept(ControlAction.RESPONSE_FAIL)
                           }
                       } ?: consumer.accept(ControlAction.RESPONSE_FAIL)
                   }
                   

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

                   @Override
                   public void performControlAction(@NonNull String controlId, @NonNull ControlAction action, @NonNull Consumer consumer) {
                       ReplayProcessor processor = controlFlows.get(controlId);
                       if (processor == null) return;
                
                       if (controlId.equals(LIGHT_ID + "")) {
                           consumer.accept(ControlAction.RESPONSE_OK);
                           if (action instanceof BooleanAction) toggleState = ((BooleanAction) action).getNewState();
                           processor.onNext(createLight());
                       }
                       if (controlId.equals(THERMOSTAT_ID + "")) {
                           consumer.accept(ControlAction.RESPONSE_OK);
                           if (action instanceof FloatAction) rangeState = ((FloatAction) action).getNewValue()
                           processor.onNext(createThermostat());
                       }
                   }
                   

   Run the app, access the **Device controls** menu, and see your light and
   thermostat controls.

   .. figure:: https://developer.android.google.cn/static/images/ui/device_controls_example_2.png
      name: controls_2
      :alt: An image showing a light and thermostat control
      :width: 50.0%

      **Figure 6.** Light and thermostat controls.


Last updated 2024-05-03 UTC.


/About backward-compatible UIs
==============================

.. https://developer.android.google.cn/training/backward-compatible-ui?hl=en

.. container:: devsite-article-body

   This class demonstrates how to use UI components and APIs available in newer
   versions of Android in a backward-compatible way, ensuring that your
   application still runs on previous versions of the platform.

   Throughout this class, the new `Action Bar Tabs <#Tabs>`__ feature introduced in Android 3.0
   (API level 11) serves as the guiding example, but you can apply these
   techniques to other UI components and API features.

   .. rubric:: Lessons
      :name: lessons

   `Abstract the new APIs <#>`__
      Determine which features and APIs your application needs. Learn how to
      define application-specific, intermediary Java interfaces that abstract
      the implementation of the UI component to your application.
   `Proxy to the new APIs <#>`__
      Learn how to create an implementation of your interface that uses newer
      APIs.
   `Create an implementation with older APIs <#>`__
      Learn how to create a custom implementation of your interface that uses
      older APIs.
   `Use the version-aware component <#>`__
      Learn how to choose an implementation to use at runtime, and begin using
      the interface in your application.

   .. rubric:: You should also read
      :name: you-should-also-read

   -  `How to have your (Cup)cake and eat it too <http://android-developers.blogspot.com/2010/07/how-to-have-your-cupcake-and-eat-it-too.html>`__


Last updated 2024-02-22 UTC.


/Abstract newer APIs
====================

.. https://developer.android.google.cn/training/backward-compatible-ui/abstracting?hl=en

.. container:: devsite-article-body

   Suppose you want to use `action bar tabs <#Tabs>`__
   as the primary form of top-level navigation in your application.
   Unfortunately, the `ActionBar <#android.app.ActionBar>`__ APIs
   are only available in Android 3.0 or later (API level 11+). Thus, if you want
   to distribute your application to devices running earlier versions of the
   platform, you need to provide an implementation that supports the newer API
   while providing a fallback mechanism that uses older APIs.

   In this class, you build a tabbed user interface (UI) component that uses
   abstract classes with version-specific implementations to provide
   backward-compatibility. This lesson describes how to create an abstraction
   layer for the new tab APIs as the first step toward building the tab
   component.

   .. rubric:: Prepare for abstraction
      :name: prepare-abstraction

   `Abstraction <https://en.wikipedia.org/wiki/Abstraction_(computer_science)>`__
   in the Java programming language involves the creation of one or more
   interfaces or abstract classes to hide implementation details. In the case of
   newer Android APIs, you can use abstraction to build version-aware components
   that use the current APIs on newer devices, and fallback to older, more
   compatible APIs on older devices.

   When using this approach, you first determine what newer classes you want to
   be able to use in a backward compatible way, then create abstract classes,
   based on the public interfaces of the newer classes. In defining the
   abstraction interfaces, you should mirror the newer API as much as possible.
   This maximizes forward-compatibility and makes it easier to drop the
   abstraction layer in the future when it is no longer necessary.

   After creating abstract classes for these new APIs, any number of
   implementations can be created and chosen at runtime. For the purposes of
   backward-compatibility, these implementations can vary by required API level.
   Thus, one implementation may use recently released APIs, while others can use
   older APIs.

   .. rubric:: Create an abstract tab interface
      :name: create-abstract-tab

   In order to create a backward-compatible version of tabs, you should first
   determine which features and specific APIs your application requires. In the
   case of top-level section tabs, suppose you have the following functional
   requirements:

   #. Tab indicators should show text and an icon.
   #. Tabs can be associated with a fragment instance.
   #. The activity should be able to listen for tab changes.

   Preparing these requirements in advance allows you to control the scope of
   your abstraction layer. This means that you can spend less time creating
   multiple implementations of your abstraction layer and begin using your new
   backward-compatible implementation sooner.

   The key APIs for tabs are in
   `ActionBar <#android.app.ActionBar>`__ and
   `ActionBar.Tab <#android.app.ActionBar.Tab>`__. These are the
   APIs to abstract in order to make your tabs version-aware. The requirements
   for this example project call for compatibility back to Eclair (API level 5)
   while taking advantage of the new tab features in Honeycomb (API Level 11). A
   diagram of the class structure to support these two implementations and their
   abstract base classes (or interfaces) is shown below.

   |Class diagram of abstract base classes and version-specific
   implementations.|
   **Figure 1.** Class diagram of abstract base classes and version-specific
   implementations.

   .. rubric:: Abstract ActionBar.Tab
      :name: abstract-actionbar-tab

   Get started on building your tab abstraction layer by creating an abstract
   class representing a tab, that mirrors the
   `ActionBar.Tab <#android.app.ActionBar.Tab>`__ interface:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               sealed class CompatTab(val tag: String) {
                   ...
                   abstract fun getText(): CharSequence
                   abstract fun getIcon(): Drawable
                   abstract fun getCallback(): CompatTabListener
                   abstract fun getFragment(): Fragment

                   abstract fun setText(text: String): CompatTab
                   abstract fun setIcon(icon: Drawable): CompatTab
                   abstract fun setCallback(callback: CompatTabListener): CompatTab
                   abstract fun setFragment(fragment: Fragment): CompatTab
                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public abstract class CompatTab {
                   ...
                   public abstract CompatTab setText(int resId);
                   public abstract CompatTab setIcon(int resId);
                   public abstract CompatTab setTabListener(
                           CompatTabListener callback);
                   public abstract CompatTab setFragment(Fragment fragment);

                   public abstract CharSequence getText();
                   public abstract Drawable getIcon();
                   public abstract CompatTabListener getCallback();
                   public abstract Fragment getFragment();
                   ...
               }

   You can use an abstract class instead of an interface here to simplify the
   implementation of common features such as association of tab objects with
   activities (not shown in the code snippet).

   .. rubric:: Abstract ActionBar tab methods
      :name: abstract-actionbar-methods

   Next, define an abstract class that allows you to create and add tabs to an
   activity, like
   `ActionBar.newTab() <#android.app.ActionBar>`__ and
   `ActionBar.addTab() <#android.app.ActionBar>`__:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               sealed class TabHelper(protected val activity: FragmentActivity) {
                   ...

                   abstract fun setUp()

                   fun newTab(tag: String): CompatTab {
                       // This method is implemented in a later lesson.
                   }

                   abstract fun addTab(tab: CompatTab)

                   ...
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public abstract class TabHelper {
                   ...

                   public CompatTab newTab(String tag) {
                       // This method is implemented in a later lesson.
                   }

                   public abstract void addTab(CompatTab tab);

                   ...
               }

   In the next lessons, you create implementations for ``TabHelper`` and
   ``CompatTab`` that work across both older and newer platform versions.

   .. rubric:: You should also read
      :name: you-should-also-read

   -  `Action Bar <#>`__
   -  `Action Bar Tabs <#Tabs>`__

.. container:: devsite-steps

   .. container:: steps-next steps-direction

      ` <#>`__

      .. container:: steps-link-direction

         Next

      Proxy to newer APIs arrow_forward


Last updated 2024-02-22 UTC.

.. |Class diagram of abstract base classes and version-specific implementations.| image:: https://developer.android.google.cn/static/images/training/backward-compatible-ui-classes.png
   :name: figure-classes


/Proxy to newer APIs
====================

.. https://developer.android.google.cn/training/backward-compatible-ui/new-implementation?hl=en

.. container:: devsite-article-body

   This lesson shows you how to subclass the ``CompatTab`` and ``TabHelper``
   abstract classes and use new APIs. Your application can use this
   implementation on devices running a platform version that supports them.

   .. rubric:: Implement tabs using new APIs
      :name: new-tabs

   The concrete classes for ``CompatTab`` and ``TabHelper`` that use newer APIs
   are a *proxy* implementation. Since the abstract classes defined in the
   previous lesson mirror the new APIs (class structure, method signatures,
   etc.), the concrete classes that use these newer APIs simply proxy method
   calls and their results.

   You can directly use newer APIs in these concrete classes—and not crash on
   earlier devices—because of lazy class loading. Classes are loaded and
   initialized on first access—instantiating the class or accessing one of its
   static fields or methods for the first time. Thus, as long as you don't
   instantiate the Honeycomb-specific implementations on pre-Honeycomb devices,
   the Dalvik VM won't throw any
   `VerifyError <#>`__ exceptions.

   A good naming convention for this implementation is to append the API level
   or platform version code name corresponding to the APIs required by the
   concrete classes. For example, the native tab implementation can be provided
   by ``CompatTabHoneycomb`` and ``TabHelperHoneycomb`` classes, since they rely
   on APIs available in Android 3.0 (API level 11) or later.

   |Class diagram for the Honeycomb implementation of tabs.|
   **Figure 1.** Class diagram for the Honeycomb implementation of tabs.

   .. rubric:: Implement CompatTabHoneycomb
      :name: compattabhoneycomb

   ``CompatTabHoneycomb`` is the implementation of the ``CompatTab`` abstract
   class that ``TabHelperHoneycomb`` uses to reference individual tabs.
   ``CompatTabHoneycomb`` simply proxies all method calls to its contained
   `ActionBar.Tab <#android.app.ActionBar.Tab>`__ object.

   Begin implementing ``CompatTabHoneycomb`` using the new
   `ActionBar.Tab <#android.app.ActionBar.Tab>`__ APIs:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CompatTabHoneycomb internal constructor(val activity: Activity, tag: String) :
                       CompatTab(tag) {
                   ...
                   // The native tab object that this CompatTab acts as a proxy for.
                   private var mTab: ActionBar.Tab =
                           // Proxy to new ActionBar.newTab API
                           activity.actionBar.newTab()

                   override fun setText(@StringRes textId: Int): CompatTab {
                       // Proxy to new ActionBar.Tab.setText API
                       mTab.setText(textId)
                       return this
                   }

                   ...
                   // Do the same for other properties (icon, callback, etc.)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CompatTabHoneycomb extends CompatTab {
                   // The native tab object that this CompatTab acts as a proxy for.
                   ActionBar.Tab mTab;
                   ...

                   protected CompatTabHoneycomb(FragmentActivity activity, String tag) {
                       ...
                       // Proxy to new ActionBar.newTab API
                       mTab = activity.getActionBar().newTab();
                   }

                   public CompatTab setText(int resId) {
                       // Proxy to new ActionBar.Tab.setText API
                       mTab.setText(resId);
                       return this;
                   }

                   ...
                   // Do the same for other properties (icon, callback, etc.)
               }

   .. rubric:: Implement TabHelperHoneycomb
      :name: tabhelperhoneycomb

   ``TabHelperHoneycomb`` is the implementation of the ``TabHelper`` abstract
   class that proxies method calls to an actual
   `ActionBar <#android.app.ActionBar>`__, obtained from its
   contained `Activity <#android.app.Activity>`__.

   Implement ``TabHelperHoneycomb``, proxying method calls to the
   `ActionBar <#android.app.ActionBar>`__ API:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TabHelperHoneycomb internal constructor(activity: FragmentActivity) : TabHelper(activity) {

                   private var mActionBar: ActionBar? = null

                   override fun setUp() {
                       mActionBar = mActionBar ?: mActivity.actionBar.apply {
                           navigationMode = ActionBar.NAVIGATION_MODE_TABS
                       }
                   }

                   override fun addTab(tab: CompatTab) {
                       // Tab is a CompatTabHoneycomb instance, so its
                       // native tab object is an ActionBar.Tab.
                       mActionBar?.addTab(tab.getTab() as ActionBar.Tab)
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class TabHelperHoneycomb extends TabHelper {
                   ActionBar actionBar;
                   ...

                   protected void setUp() {
                       if (actionBar == null) {
                           actionBar = activity.getActionBar();
                           actionBar.setNavigationMode(
                                   ActionBar.NAVIGATION_MODE_TABS);
                       }
                   }

                   public void addTab(CompatTab tab) {
                       ...
                       // Tab is a CompatTabHoneycomb instance, so its
                       // native tab object is an ActionBar.Tab.
                       actionBar.addTab((ActionBar.Tab) tab.getTab());
                   }

                   // The other important method, newTab() is part of
                   // the base implementation.
               }

   .. rubric:: You should also read
      :name: you-should-also-read

   -  `Action Bar <#>`__
   -  `Action Bar Tabs <#Tabs>`__

.. container:: devsite-steps

   .. container:: steps-previous steps-direction

      ` <#>`__

      .. container:: steps-link-direction

         Previous

      arrow_back Abstract newer APIs

   .. container:: steps-next steps-direction

      ` <#>`__

      .. container:: steps-link-direction

         Next

      Create an implementation with older APIs arrow_forward


Last updated 2024-02-22 UTC.

.. |Class diagram for the Honeycomb implementation of tabs.| image:: https://developer.android.google.cn/static/images/training/backward-compatible-ui-classes-honeycomb.png
   :name: figure-classes


/Create an implementation with older APIs
=========================================

.. https://developer.android.google.cn/training/backward-compatible-ui/older-implementation?hl=en

.. container:: devsite-article-body

   This lesson discusses how to create an implementation that mirrors newer APIs
   yet supports older devices.

   .. rubric:: Decide on a substitute solution
      :name: decide-substitute

   The most challenging task in using newer UI features in a backward-compatible
   way is deciding on and implementing an older (fallback) solution for older
   platform versions. In many cases, it's possible to fulfill the purpose of
   these newer UI components using older UI framework features. For example:

   -  Action bars can be implemented using a horizontal
      `LinearLayout <#android.widget.LinearLayout>`__ containing
      image buttons, either as custom title bars or as views in your activity
      layout. Overflow actions can be presented under the device *Menu* button.

   -  Action bar tabs can be implemented using a horizontal
      `LinearLayout <#android.widget.LinearLayout>`__ containing
      buttons, or using the
      `TabWidget <#android.widget.TabWidget>`__ UI element.

   -  `NumberPicker <#android.widget.NumberPicker>`__ and
      `Switch <#android.widget.Switch>`__ widgets can be
      implemented using `Spinner <#android.widget.Spinner>`__ and
      `ToggleButton <#android.widget.ToggleButton>`__ widgets,
      respectively.

   -  `ListPopupWindow <#android.widget.ListPopupWindow>`__ and
      `PopupMenu <#android.widget.PopupMenu>`__ widgets can be
      implemented using
      `PopupWindow <#android.widget.PopupWindow>`__ widgets.

   There generally isn't a one-size-fits-all solution for backporting newer UI
   components to older devices. Be mindful of the user experience: on older
   devices, users may not be familiar with newer design patterns and UI
   components. Give some thought as to how the same functionality can be
   delivered using familiar elements. In many cases this is less of a concern—if
   newer UI components are prominent in the application ecosystem (such as the
   action bar), or where the interaction model is extremely simple and intuitive
   (such as swipe views using a
   `ViewPager <#androidx.viewpager.widget.ViewPager>`__).

   .. rubric:: Implement tabs using older APIs
      :name: older-tabs

   To create an older implementation of action bar tabs, you can use a
   `TabWidget <#android.widget.TabWidget>`__ and
   `TabHost <#android.widget.TabHost>`__ (although one can
   alternatively use horizontally laid-out
   `Button <#android.widget.Button>`__ widgets). Implement this in
   classes called ``TabHelperEclair`` and ``CompatTabEclair``, since this
   implementation uses APIs introduced no later than Android 2.0 (Eclair).

   |Class diagram for the Eclair implementation of tabs.|
   **Figure 1.** Class diagram for the Eclair implementation of tabs.

   The ``CompatTabEclair`` implementation stores tab properties such as the tab
   text and icon in instance variables, since there isn't an
   `ActionBar.Tab <#android.app.ActionBar.Tab>`__ object available
   to handle this storage:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class CompatTabEclair internal constructor(val activity: FragmentActivity, tag: String) :
                       CompatTab(tag) {

                   // Store these properties in the instance,
                   // as there is no ActionBar.Tab object.
                   private var text: CharSequence? = null
                   ...

                   override fun setText(resId: Int): CompatTab {
                       // Our older implementation simply stores this
                       // information in the object instance.
                       text = activity.resources.getText(resId)
                       return this
                   }

                   ...
                   // Do the same for other properties (icon, callback, etc.)
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class CompatTabEclair extends CompatTab {
                   // Store these properties in the instance,
                   // as there is no ActionBar.Tab object.
                   private CharSequence text;
                   ...

                   public CompatTab setText(int resId) {
                       // Our older implementation simply stores this
                       // information in the object instance.
                       text = activity.getResources().getText(resId);
                       return this;
                   }

                   ...
                   // Do the same for other properties (icon, callback, etc.)
               }

   The ``TabHelperEclair`` implementation makes use of methods on the
   `TabHost <#android.widget.TabHost>`__ widget for creating
   `TabHost.TabSpec <#android.widget.TabHost.TabSpec>`__ objects
   and tab indicators:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               class TabHelperEclair internal constructor(activity: FragmentActivity) : TabHelper(activity) {

                   private var tabHost: TabHost? = null
                   ...

                   override fun setUp() {
                       // Our activity layout for pre-Honeycomb devices
                       // must contain a TabHost.
                       tabHost = tabHost ?: mActivity.findViewById<TabHost>(android.R.id.tabhost).apply {
                           setup()
                       }
                   }

                   override fun addTab(tab: CompatTab) {
                       ...
                       tabHost?.newTabSpec(tab.tag)?.run {
                           setIndicator(tab.getText()) // And optional icon
                           ...
                           tabHost?.addTab(this)
                       }
                   }
                   // The other important method, newTab() is part of
                   // the base implementation.
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public class TabHelperEclair extends TabHelper {
                   private TabHost tabHost;
                   ...

                   protected void setUp() {
                       if (tabHost == null) {
                           // Our activity layout for pre-Honeycomb devices
                           // must contain a TabHost.
                           tabHost = (TabHost) mActivity.findViewById(
                                   android.R.id.tabhost);
                           tabHost.setup();
                       }
                   }

                   public void addTab(CompatTab tab) {
                       ...
                       TabSpec spec = tabHost
                               .newTabSpec(tag)
                               .setIndicator(tab.getText()); // And optional icon
                       ...
                       tabHost.addTab(spec);
                   }

                   // The other important method, newTab() is part of
                   // the base implementation.
               }

   You now have two implementations of ``CompatTab`` and ``TabHelper``: one that
   works on devices running Android 3.0 or later and uses new APIs, and another
   that works on devices running Android 2.0 or later and uses older APIs. The
   next lesson discusses using these implementations in your application.

.. container:: devsite-steps

   .. container:: steps-previous steps-direction

      ` <#>`__

      .. container:: steps-link-direction

         Previous

      arrow_back Proxy to newer APIs

   .. container:: steps-next steps-direction

      ` <#>`__

      .. container:: steps-link-direction

         Next

      Use the version-aware component arrow_forward


Last updated 2024-02-22 UTC.

.. |Class diagram for the Eclair implementation of tabs.| image:: https://developer.android.google.cn/static/images/training/backward-compatible-ui-classes-eclair.png
   :name: figure-classes


/Use the version-aware component
================================

.. https://developer.android.google.cn/training/backward-compatible-ui/using-component?hl=en

.. container:: devsite-article-body

   Now that you have two implementations of ``TabHelper`` and ``CompatTab``—one
   for Android 3.0 and later and one for earlier versions of the platform—it's
   time to do something with these implementations. This lesson discusses
   creating the logic for switching between these implementations, creating
   version-aware layouts, and finally using the backward-compatible UI
   component.

   .. rubric:: Add the switching logic
      :name: switching-logic

   The ``TabHelper`` abstract class acts as a
   `factory <https://en.wikipedia.org/wiki/Factory_(software_concept)>`__ for
   creating version-appropriate ``TabHelper`` and ``CompatTab`` instances, based
   on the current device's platform version:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               sealed class TabHelper(protected val mActivity: FragmentActivity, protected val tag: String) {

                   abstract fun setUp()

                   abstract fun addTab(tab: CompatTab)

                   // Usage is tabHelper.newTab("tag")
                   fun newTab(tag: String): CompatTab =
                           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                               CompatTabHoneycomb(mActivity, tag)
                           } else {
                               CompatTabEclair(mActivity, tag)
                           }

                   companion object {
                       // Usage is TabHelper.createInstance(activity)
                       fun createInstance(activity: FragmentActivity): TabHelper =
                               if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                                   TabHelperHoneycomb(activity)
                               } else {
                                   TabHelperEclair(activity)
                               }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               public abstract class TabHelper {
                   ...
                   // Usage is TabHelper.createInstance(activity)
                   public static TabHelper createInstance(FragmentActivity activity) {
                       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                           return new TabHelperHoneycomb(activity);
                       } else {
                           return new TabHelperEclair(activity);
                       }
                   }

                   // Usage is tabHelper.newTab("tag")
                   public CompatTab newTab(String tag) {
                       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                           return new CompatTabHoneycomb(mActivity, tag);
                       } else {
                           return new CompatTabEclair(mActivity, tag);
                       }
                   }
                   ...
               }

   .. rubric:: Create a version-aware activity layout
      :name: layout

   The next step is to provide layouts for your activity that can support the
   two tab implementations. For the older implementation (``TabHelperEclair``),
   you need to ensure that your activity layout contains a
   `TabWidget <#android.widget.TabWidget>`__ and
   `TabHost <#android.widget.TabHost>`__, along with a container
   for tab contents:

   **res/layout/main.xml:**

   .. code:: prettyprint

      <!-- This layout is for API level 5-10 only. -->
      <TabHost xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@android:id/tabhost"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <LinearLayout
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:padding="5dp">

              <TabWidget
                  android:id="@android:id/tabs"
                  android:layout_width="match_parent"
                  android:layout_height="wrap_content" />

              <FrameLayout
                  android:id="@android:id/tabcontent"
                  android:layout_width="match_parent"
                  android:layout_height="0dp"
                  android:layout_weight="1" />

          </LinearLayout>
      </TabHost>

   For the ``TabHelperHoneycomb`` implementation, all you need is a
   `FrameLayout <#android.widget.FrameLayout>`__ to contain the
   tab contents, since the tab indicators are provided by the
   `ActionBar <#android.app.ActionBar>`__:

   **res/layout-v11/main.xml:**

   .. code:: prettyprint

      <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@android:id/tabcontent"
          android:layout_width="match_parent"
          android:layout_height="match_parent" />

   At runtime, Android will decide which version of the ``main.xml`` layout to
   inflate depending on the platform version. This is the same logic shown in
   the previous section to determine which ``TabHelper`` implementation to use.

   .. rubric:: Use TabHelper in your activity
      :name: use-tabhelper

   In your activity's
   `onCreate() <#android.app.Activity>`__
   method, you can obtain a ``TabHelper`` object and add tabs with the following
   code:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kotlin

            .. code:: prettyprint

               override fun onCreate(savedInstanceState: Bundle?) {
                   ...
                   setContentView(R.layout.main)

                   TabHelper.createInstance(this).apply {
                       setUp()

                       newTab("photos")
                               .setText(R.string.tab_photos)
                               .also { photosTab ->
                                   addTab(photosTab)
                               }

                       newTab("videos")
                               .setText(R.string.tab_videos)
                               .also { videosTab ->
                                   addTab(videosTab)
                               }
                   }
               }

         .. container:: section

            .. rubric:: Java
               :name: java

            .. code:: prettyprint

               @Override
               public void onCreate(Bundle savedInstanceState) {
                   setContentView(R.layout.main);

                   TabHelper tabHelper = TabHelper.createInstance(this);
                   tabHelper.setUp();

                   CompatTab photosTab = tabHelper
                           .newTab("photos")
                           .setText(R.string.tab_photos);
                   tabHelper.addTab(photosTab);

                   CompatTab videosTab = tabHelper
                           .newTab("videos")
                           .setText(R.string.tab_videos);
                   tabHelper.addTab(videosTab);
               }

   When running the application, this code inflates the correct activity layout
   and instantiates either a ``TabHelperHoneycomb`` or ``TabHelperEclair``
   object. The concrete class that's actually used is opaque to the activity,
   since they share the common ``TabHelper`` interface.

   Below are two screenshots of this implementation running on an Android 2.3
   and Android 4.0 device.

   |Example screenshot of tabs running on an Android 2.3 device (using
   TabHelperEclair).| |Example screenshots of tabs running on an Android 4.0
   device (using TabHelperHoneycomb).|
   **Figure 1.** Example screenshots of backward-compatible tabs running on an
   Android 2.3 device (using ``TabHelperEclair``) and an Android 4.0 device
   (using ``TabHelperHoneycomb``).

.. container:: devsite-steps

   .. container:: steps-previous steps-direction

      ` <#>`__

      .. container:: steps-link-direction

         Previous

      arrow_back Create an implementation with older APIs


Last updated 2024-02-22 UTC.

.. |Example screenshot of tabs running on an Android 2.3 device (using TabHelperEclair).| image:: https://developer.android.google.cn/static/images/training/backward-compatible-ui-gb.png
   :width: 200px
.. |Example screenshots of tabs running on an Android 4.0 device (using TabHelperHoneycomb).| image:: https://developer.android.google.cn/static/images/training/backward-compatible-ui-ics.png
   :width: 200px
