
# /bash script to conbine mds

```sh
#!/usr/bin/env bash

list_spec()
{
    find . -name README.md
    spec=./reference/docs-conceptual/
    cat "$spec/toc.yml" | sed -n "s|.*href: \(.*\.md\)$|$spec\1|p"
}

list_huge()
{
    while read it; do
        array=($it)
        # don't quote regexp like that "[[:digit:]]M"
        [[ $array =~ [[:digit:]]M ]] && {
            printf "\n==>Huge doc\n"
            du -hd1 "${array[1]}"
        }
    done <<< $(du -hd1 "$1")
}

list_51()
{
    while read it; do
        echo $it | sed -n 's|\([^/]*\?\)$|\1/\1.md|p'
        find $it -name '*.md' | sed -n 's|\([/\][^/\]*\)\1|\0|; t skip; p; :skip'
    done <<<$(find ./reference/5.1/* -type 'd')
    # find ./reference/5.1/* -type 'd' | sed -n 's|\([^/]*\?\)$|\1/\1.md|p'
}

combines()
{
    while read md; do
        printf "\n# /$md\n"
        cat "$md"
    done <<EOF
    $(list_spec; list_51)
EOF
}
combines > /c/opendocs/PowerShell_Docs.md
# cat: ./reference/5.1/Microsoft.PowerShell.Security/About/About.md: No such file or directory
# cat: ./reference/5.1/Microsoft.WSMan.Management/About/About.md: No such file or directory
# cat: ./reference/5.1/PSReadLine/About/About.md: No such file or directory
# cat: ./reference/5.1/PSScheduledJob/About/About.md: No such file or directory
# cat: ./reference/5.1/PSWorkflow/About/About.md: No such file or directory

# list_huge "./reference/docs-conceptual"
# list_huge "./reference/docs-conceptual/media/overview"
# list_huge "./reference/docs-conceptual/learn/shell"
# tree -hfs "./reference/docs-conceptual/learn/shell/media"

# du -hd1 ./reference/5.1/Microsoft.PowerShell.Core
# a=./reference/7.2/Microsoft.PowerShell.Core/About/about_If.md
# a=./reference/5.1/Microsoft.PowerShell.Core/About/about_If.md
# b=./reference/7.5/Microsoft.PowerShell.Core/About/about_If.md
# diff $a $b

# /bash script to conbine mds
```

# /./README.md

    ---
    ms.date: 02/13/2024
    ---
# [PowerShell Documentation]

[PowerShell Documentation]: https://github.com/MicrosoftDocs/PowerShell-Docs

Welcome to the PowerShell-Docs repository, the home of the official PowerShell documentation.

## Microsoft Open Source Code of Conduct

This project has adopted the [Microsoft Open Source Code of Conduct][04]. For more information see
the [Code of Conduct FAQ][05] or contact [opencode@microsoft.com][06] with any additional questions
or comments.

[live-badge]: https://powershell.visualstudio.com/PowerShell-Docs/_apis/build/status/PowerShell-Docs-CI?branchName=live
[main-badge]: https://powershell.visualstudio.com/PowerShell-Docs/_apis/build/status/PowerShell-Docs-CI?branchName=main

## Build Status

|          live branch          |          main branch          |
| :---------------------------- | :---------------------------- |
| [![live-badge][]][live-badge] | [![main-badge][]][main-badge] |


## Repository Structure

The following list describes the main folders in this repository.

- `.github` - contains configuration settings used by GitHub for this repository
- `.vscode` - contains configuration settings and recommended extensions for Visual Studio Code (VS
  Code)
- `assets` - contains downloadable files linked in the documentation
- `reference` - contains the documentation published to
  [learn.microsoft.com][01]. This includes both
  reference and conceptual content.
  - `5.1` - contains the cmdlet reference and about topics for PowerShell 5.1
  - `7.2` - contains the cmdlet reference and about topics for PowerShell 7.2
  - `7.3` - contains the cmdlet reference and about topics for PowerShell 7.3
  - `7.4` - contains the cmdlet reference and about topics for PowerShell 7.4
  - `7.5` - contains the cmdlet reference and about topics for PowerShell 7.5
  - `bread` - contains the TOC used for breadcrumb navigation
  - `docs-conceptual` - contains the conceptual articles that are published to the Docs site. In
    general, the folder structure mirrors the Table of Contents (TOC).
  - `includes` - contains markdown include files
  - `mapping` - contains the version mapping configuration used by the build system
  - `media` - contains image files used in documentation. There are media folders throughout the
    `docs-conceptual` content. See the Contributor Guide for information on using images in
    documentation.
  - `module` - contains the markdown source for the Module Browser page
- `tests` - contains the Pester tests used by the build system
- `tools` - contains other tools used by the build system

> NOTE: The reference content (in the numbered folders) is used to create the webpages on the Docs
> site as well as the updateable help used by PowerShell. The articles in the `docs-conceptual`
> folder are only published to the Docs website.

## Contributing

We welcome public contributions into this repository via pull requests into the _main_ branch.
Please note that before we can accept your pull request you must sign our
[Contribution License Agreement][03]. This is a one-time requirement.

For more information on contributing, read our [contributor's guide][02]. The contributor's guide
contains detailed information about how to contribute documentation, suggested tools, and style and
formatting requirements. Please use the Issue and Pull Request templates to help keep documentation
consistent across versions.

## Licenses

There are two license files for this project. The MIT License applies to the code contained in this
repo. The Creative Commons license applies to the documentation.

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/scripting/
[02]: https://aka.ms/PSDocsContributor
[03]: https://cla.microsoft.com/
[04]: https://opensource.microsoft.com/codeofconduct/
[05]: https://opensource.microsoft.com/codeofconduct/faq/
[06]: mailto:opencode@microsoft.com

# /./reference/README.md

    ---
    locale: en-us
    ms.date: 05/18/2022
    schema: 2.0.0
    title: README
    ---
# PowerShell Reference

Reference material is organized into release versions. The content for each
version is organized by module name, and a distinct folder for the about
topics.

Over time, namespaces appeared as:

|         Module Name / PS Version          |  5.1  |  7.0  |  7.2  |  7.3  |
| ----------------------------------------- | :---: | :---: | :---: | :---: |
| CimCmdlets                                |   X   |   X   |   X   |   X   |
| ISE (introduced in 2.0)                   |   X   |       |       |       |
| Microsoft.PowerShell.Archive              |   X   |   X   |   X   |   X   |
| Microsoft.PowerShell.Core                 |   X   |   X   |   X   |   X   |
| Microsoft.PowerShell.Diagnostics          |   X   |   X   |   X   |   X   |
| Microsoft.PowerShell.Host                 |   X   |   X   |   X   |   X   |
| Microsoft.PowerShell.LocalAccounts        |   X   |       |       |       |
| Microsoft.PowerShell.Management           |   X   |   X   |   X   |   X   |
| Microsoft.PowerShell.ODataUtils           |   X   |       |       |       |
| Microsoft.PowerShell.Operation.Validation |   X   |       |       |       |
| Microsoft.PowerShell.Security             |   X   |   X   |   X   |   X   |
| Microsoft.PowerShell.Utility              |   X   |   X   |   X   |   X   |
| Microsoft.WsMan.Management                |   X   |   X   |   X   |   X   |
| PackageManagement                         |   X   |   X   |   X   |   X   |
| PowershellGet                             |   X   |   X   |   X   |   X   |
| PSDesiredStateConfiguration               |   X   |   X   |   X   |       |
| PSDiagnostics                             |   X   |   X   |   X   |   X   |
| PSReadLine                                |   X   |   X   |   X   |   X   |
| PSScheduledJob                            |   X   |       |       |       |
| PSWorkflow                                |   X   |       |       |       |
| PSWorkflowUtility                         |   X   |       |       |       |
| ThreadJob                                 |       |   X   |   X   |   X   |

# /./reference/how-to-use-docs.md

    ---
    description: This articles explains how to use the features of this site including search filtering and version selection.
    ms.date: 05/12/2023
    ms.topic: how-to
    title: How to use the PowerShell documentation
    ---
# How to use the PowerShell documentation

Welcome to the PowerShell online documentation. This site contains cmdlet reference for the
following versions of PowerShell:

- PowerShell 7.4 (LTS-current)
- PowerShell 7.3
- PowerShell 7.2 (LTS-current)
- PowerShell 5.1

## Navigating the documentation

![Screenshot showing the various elements of the web page.][02]

The web page contains multiple elements that help you navigate the documentation.

- **Site level navigation** - The site level navigation appears at the top of the page. It contains
  links to other content on the Microsoft Learn platform.
- **Related content navigation** - The related content bar is immediately below the site level
  navigation. It contains links to content related to the current documentation set, which is
  PowerShell in this case.
- **Version selector** - The version selector appears above the Table of Contents (TOC) and
  controls which version of the cmdlet reference appears in the TOC.
- **Table of Contents** - The TOC on the left side of the page is divided into two sections:
  conceptual and reference. Notice the line between the **Reference** node of the TOC. The
  conceptual documents appear above the line. Reference content is listed in **Reference** node
  below the line.
- **Action buttons** - The action buttons provide a way to add content to a collection, provide
  feedback, edit the content, or share the content with others.

## Selecting the version of PowerShell

Use the version selector located above the TOC to select the version of PowerShell you want. By
default, the page loads with the most current stable release version selected. The version selector
controls which version of the cmdlet reference appears in the TOC under the **Reference** node. Some
cmdlets work differently in different versions of PowerShell you are using. Be sure you are viewing
the documentation for the correct version of PowerShell.

The version selector doesn't affect conceptual documentation. The conceptual documents appear above
the **Reference** node in the TOC. The same conceptual articles appear for every version selected.
If there are version-specific differences, the documentation makes note of those differences.

![Animation showing how to use the version selector.][04]

You can verify the version of PowerShell you are using by inspecting the `$PSversionTable.PSVersion`
value. The following example shows the output for Windows PowerShell 5.1.

```powershell
$PSVersionTable.PSVersion
```

```Output
Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      22621  963
```

## Finding articles

There are two ways to search for content in Docs.

- The search box in the site-level navigation bar searches the entire site. It returns a list of
  matching articles from all documentation sets.
- The TOC filter box under the version selector allows filtering by words that appear in the title
  of an article. The filter displays a list of matching articles as you type. You can also select
  the option to search for the words in an article. When you search from here, the search is
  limited to the PowerShell documentation.

In the following example, the search in the site-level navigation bar returns 840 results for the
word `idempotent`. Entering the word `invoke` in the TOC filter box shows a list of articles that
contain the word `invoke` in the title. Entering the word `idempotent` in the TOC filter shows no
articles. Clicking the search link searches for `idempotent` in the PowerShell documentation. This
search only returns 9 results.

![Animation showing how to use the search features.][05]

## Downloading the documentation as a PDF

To download the documentation as a PDF, click the **Download PDF** button at the bottom of the TOC.

![Screenshot of the Download PDF button.][03]

- If you are viewing a conceptual article, the Learn platform creates a PDF containing all the
  conceptual content for the selected version.
- If you are viewing a reference article, the Learn platform creates a PDF containing all the
  reference content for the selected version.

## Finding articles for previous versions

Documentation for older versions of PowerShell is archived in our [Previous Versions][01] site. You
can choose **Previous Versions** from the version selector.

![Screenshot of the Previous Versions option.](https://learn.microsoft.com/en-us/powershell/docs-conceptual/media/how-to-use-docs/previous-versions.gif)

This site contains documentation for the following topics:

- PowerShell 3.0
- PowerShell 4.0
- PowerShell 5.0
- PowerShell 6
- PowerShell 7.0
- PowerShell 7.1
- PowerShell Workflows
- PowerShell Web Access

<!-- link references -->
[01]: https://aka.ms/PSLegacyDocs
[02]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/media/how-to-use-docs/how-to-use.gif
[03]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/media/how-to-use-docs/pdf-button.gif
[04]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/media/how-to-use-docs/version-search.gif
[05]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/media/how-to-use-docs/search-scope.gif

# /./reference/overview.md

    ---
    description: This article is an introduction to the PowerShell scripting environment and its features.
    ms.date: 06/28/2023
    ms.topic: overview
    title: What is PowerShell?
    ---

# What is PowerShell?

PowerShell is a cross-platform task automation solution made up of a command-line shell, a scripting
language, and a configuration management framework. PowerShell runs on Windows, Linux, and macOS.

## Command-line Shell

PowerShell is a modern command shell that includes the best features of other popular shells. Unlike
most shells that only accept and return text, PowerShell accepts and returns .NET objects. The shell
includes the following features:

- Robust command-line [history][01]
- Tab completion and command prediction (See [about_PSReadLine][02])
- Supports command and parameter [aliases][03]
- [Pipeline][04] for chaining commands
- In-console [help][05] system, similar to Unix `man` pages

## Scripting language

As a scripting language, PowerShell is commonly used for automating the management of systems. It's
also used to build, test, and deploy solutions, often in CI/CD environments. PowerShell is built on
the .NET Common Language Runtime (CLR). All inputs and outputs are .NET objects. No need to parse
text output to extract information from output. The PowerShell scripting language includes the
following features:

- Extensible through [functions][06], [classes][07], [scripts][08], and [modules][09]
- Extensible [formatting system][10] for easy output
- Extensible [type system][11] for creating dynamic types
- Built-in support for common data formats like [CSV][12], [JSON][13], and [XML][14]

## Automation platform

The extensible nature of PowerShell has enabled an ecosystem of PowerShell modules to deploy and
manage almost any technology you work with. For example:

Microsoft

- [Azure][15]
- [Windows][16]
- [Exchange][17]
- [SQL][18]

Third-party

- [AWS][19]
- [VMWare][20]
- [Google Cloud][21]

### Configuration management

PowerShell Desired State Configuration ([DSC][22]) is a management framework in PowerShell that
enables you to manage your enterprise infrastructure with configuration as code. With DSC, you can:

- Create declarative [configurations][23] and custom scripts for repeatable deployments
- Enforce configuration settings and report on configuration drift
- Deploy configuration using [push or pull][24] models

## Next steps

### Getting started

Are you new to PowerShell and don't know where to start? Take a look at these resources.

- [Installing PowerShell][25]
- [PowerShell Bits tutorials][26]
- [PowerShell 101][27]
- [Microsoft Virtual Academy videos][28]
- [PowerShell Learn modules][29]

### PowerShell in action

Take a look at how PowerShell is being used in different scenarios and on different platforms.

- [PowerShell remoting over SSH][30]
- [Getting started with Azure PowerShell][31]
- [Building a CI/CD pipeline with DSC][32]
- [Managing Microsoft Exchange][33]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_history
[02]: https://learn.microsoft.com/powershell/module/psreadline/about/about_psreadline
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_aliases
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pipelines
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-help
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced
[07]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_classes
[08]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_scripts
[09]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_modules
[10]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_format.ps1xml
[11]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_types.ps1xml
[12]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/convertfrom-csv
[13]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/convertfrom-json
[14]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/convertto-xml
[15]: https://learn.microsoft.com/powershell/azure
[16]: https://learn.microsoft.com/powershell/windows/get-started
[17]: https://learn.microsoft.com/powershell/exchange/exchange-management-shell
[18]: https://learn.microsoft.com/sql/powershell/sql-server-powershell
[19]: https://aws.amazon.com/powershell/
[20]: https://core.vmware.com/vmware-powercli
[21]: https://cloud.google.com/powershell/
[22]: https://learn.microsoft.com/powershell/scripting/dsc/overview/dscforengineers
[23]: https://learn.microsoft.com/powershell/scripting/dsc/configurations/configurations
[24]: https://learn.microsoft.com/powershell/scripting/dsc/pull-server/enactingconfigurations
[25]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell
[26]: https://learn.microsoft.com/powershell/scripting/learn/tutorials/00-introduction
[27]: https://learn.microsoft.com/powershell/scripting/learn/ps101/00-introduction
[28]: https://learn.microsoft.com/shows/browse?terms=powershell
[29]: https://learn.microsoft.com/training/browse/?terms=PowerShell
[30]: https://learn.microsoft.com/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core
[31]: https://learn.microsoft.com/powershell/azure/get-started-azureps
[32]: https://learn.microsoft.com/azure/devops/pipelines/release/dsc-cicd
[33]: https://learn.microsoft.com/powershell/exchange/exchange-management-shell

# /./reference/what-is-windows-powershell.md

    ---
    description: This article explains the difference between Windows PowerShell and PowerShell.
    ms.date: 03/07/2024
    ms.topic: overview
    title: What is Windows PowerShell?
    ---
# What is Windows PowerShell?

_**Windows PowerShell**_ and _**PowerShell**_ are two separate products.

- _**Windows PowerShell**_ is the version of PowerShell that ships in Windows. This version of
  PowerShell uses the full .NET Framework, which only runs on Windows. The latest version is Windows
  PowerShell 5.1. Microsoft is no longer updating Windows PowerShell with new features. Support for
  Windows PowerShell is tied to the version of Windows you are using.

- _**PowerShell**_ is built on the new versions of .NET instead of the .NET Framework and runs on
  Windows, Linux, and macOS. Support for PowerShell is based on the version of .NET that it was
  built on. For more information about the support lifecycle for PowerShell, see the
  [PowerShell support lifecycle][02] documentation.

## Further reading

- For a more detailed explanation of the differences between Windows PowerShell and PowerShell, see
  [Differences between Windows PowerShell 5.1 and PowerShell 7.x][03].
- For information about migrating from Windows PowerShell to PowerShell, see
  [Migrating from Windows PowerShell 5.1 to PowerShell 7][04].
- For more information about previous versions of Windows PowerShell, see
  [Previous versions of PowerShell][05].
- For more information about the terminology used in PowerShell documentation, see
  [Product terminology and branding guidelines][01].

<!-- link references -->
[01]: ./community/contributing/product-terminology.md
[02]: ./install/PowerShell-Support-Lifecycle.md
[03]: ./whats-new/differences-from-windows-powershell.md
[04]: ./whats-new/Migrating-from-Windows-PowerShell-51-to-PowerShell-7.md
[05]: https://learn.microsoft.com/previous-versions/powershell/scripting/overview

# /./reference/powershell-commands.md

    ---
    description: Commands for PowerShell are known as cmdlets (pronounced command-lets)
    ms.date: 11/16/2022
    ms.topic: overview
    title: What is a PowerShell command?
    ---
# What is a PowerShell command (cmdlet)?

Commands for PowerShell are known as cmdlets (pronounced command-lets). In addition to cmdlets,
PowerShell allows you to run any command available on your system.

## What is a cmdlet?

Cmdlets are native PowerShell commands, not stand-alone executables. Cmdlets are collected into
PowerShell modules that can be loaded on demand. Cmdlets can be written in any compiled .NET
language or in the PowerShell scripting language itself.

## Cmdlet names

PowerShell uses a _Verb-Noun_ name pair to name cmdlets. For example, the `Get-Command` cmdlet
included in PowerShell is used to get all the cmdlets that are registered in the command shell. The
verb identifies the action that the cmdlet performs, and the noun identifies the resource on which
the cmdlet performs its action.

## Next steps

To learn more about PowerShell and how to find other cmdlets, see the PowerShell Bits tutorial
[Discover PowerShell][01].

For more information about creating your own cmdlets, see the following resources:

Script-based cmdlets

- [about_Functions_Advanced][02]
- [about_Functions_CmdletBindingAttribute][03]
- [about_Functions_Advanced_Methods][04]

Compiled cmdlets (PowerShell SDK docs)

- [Cmdlet overview][05]

<!-- link references -->
[01]: learn/tutorials/01-discover-powershell.md
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods
[05]: developer/cmdlet/cmdlet-overview.md

# /./reference/discover-powershell.md

    ---
    description: Learn what PowerShell is and some essential commands used to discover more about PowerShell.
    ms.date: 01/31/2023
    ms.topic: overview
    title: Discover PowerShell
    ---

# Discover PowerShell

PowerShell is a command-line shell and a scripting language in one. PowerShell started out on
Windows to help automate administrative tasks. Now, it runs cross platform and can be used for
various tasks.

The thing that makes PowerShell unique is that it accepts and returns .NET objects, rather than
text. This feature makes it easier to connect different commands in a _pipeline_.

## What can PowerShell be used for?

Usage of PowerShell has grown since the days when it was Windows-only. It's still used for Windows
task automation, but today, you can use it for tasks like:

- **Cloud management**. PowerShell can be used to manage cloud resources. For example, you can
  retrieve information about cloud resources, as well as update or deploy new resources.
- **CI/CD**. It can also be used as part of a Continuous Integration/Continuous Deployment pipeline.
- **Automate tasks for Active Directory and Exchange**. You can use it to automate almost any task
  on Windows like creating users in Active Directory and mailboxes in Exchange.

There are many more areas of usage but the preceding list gives you a hint that PowerShell has come
a long way.

## Who uses PowerShell?

PowerShell is a powerful tool that can help people working in a multitude of roles. Traditionally,
PowerShell has been used by the System Administrator role but is now being used by people calling
themselves DevOps, Cloud Ops, and even Developers.

## PowerShell cmdlets

PowerShell comes with hundreds of preinstalled commands. PowerShell commands are called cmdlets
(pronounced _command-lets_).

The name of each cmdlet consists of a _Verb-Noun_ pair. For example, `Get-Process`. This naming
convention makes it easier to understand what the cmdlet does. It also makes it easier to find the
command you're looking for. When looking for a cmdlet to use, you can filter on the verb or noun.

### Using cmdlets to explore PowerShell

When you first pick up PowerShell, it might feel intimidating as there seems to be so much to learn.
PowerShell is designed to help you learn a little at a time, as you need it.

PowerShell includes cmdlets that help you discover PowerShell. Using these three cmdlets, you can
discover what commands are available, what they do, and what types they operate on.

- `Get-Verb`. Running this command returns a list of verbs that most commands adhere to. The
  response includes a description of what these verbs do. Since most commands follow this naming
  convention, it sets expectations on what a command does. This helps you select the appropriate
  command and what to name a command, should you be creating one.
- `Get-Command`. This command retrieves a list of all commands installed on your machine.
- `Get-Member`. It operates on object based output and is able to discover what object, properties
  and methods are available for a command.
- `Get-Help`. Invoking this command with the name of a command as an argument displays a help page
  describing various parts of a command.

Using these commands, you can discover almost anything you need to know about PowerShell.

### Verb

_Verb_ is an important concept in PowerShell. It's a naming standard that most cmdlets follow. It's
also a naming standard you're expected to follow when you write your own commands. The idea is that
the _Verb_ says what you're trying to do, like read or maybe change data. PowerShell has a
standardized list of verbs. To get a full list of all possible verbs, use the `Get-Verb` cmdlet:

```powershell
Get-Verb
```

The cmdlet returns a long list of verbs. The **Description** provides context for what the verb is
meant to do. Here's the first few rows of output:

```Output
Verb    AliasPrefix   Group     Description
----    -----------   -----     -----------
Add     a             Common    Adds a resource to a container, or attaches an item to another item
Clear   cl            Common    Removes all the resources from a container but does not delete the container
Close   cs            Common    Changes the state of a resource to make it inaccessible, unavailable, or unusab…
Copy    cp            Common    Copies a resource to another name or to another container
Enter   et            Common    Specifies an action that allows the user to move into a resource
Exit    ex            Common    Sets the current environment or context to the most recently used context
...
```

## Find commands with Get-Command

The `Get-Command` cmdlet returns a list of all available commands installed on your system. The list
you get back is quite large. You can limit the amount of information that comes back by filtering
the response using parameters or helper cmdlets.

### Filter on name

You can filter the output of `Get-Command` using different parameters. Filtering allows you to find
commands that have certain properties. The **Name** parameter allows you to find a specific command
by name.

```powershell
Get-Command -Name Get-Process
```

```Output
CommandType     Name              Version    Source
-----------     ----              -------    ------
Cmdlet          Get-Process       7.0.0.0    Microsoft.PowerShell.Management
```

What if you want to find all the commands that work with processes? You can use a wildcard `*`
to match other forms of the string. For example:

```powershell
Get-Command -Name *-Process
```

```Output
CommandType     Name              Version    Source
-----------     ----              -------    ------
Cmdlet          Debug-Process     7.0.0.0    Microsoft.PowerShell.Management
Cmdlet          Get-Process       7.0.0.0    Microsoft.PowerShell.Management
Cmdlet          Start-Process     7.0.0.0    Microsoft.PowerShell.Management
Cmdlet          Stop-Process      7.0.0.0    Microsoft.PowerShell.Management
Cmdlet          Wait-Process      7.0.0.0    Microsoft.PowerShell.Management
```

### Filtering on Noun and Verb

There are other parameters that filter on verb and noun values. The verb part of a command's name is
the leftmost part. The verb should be one of the values returned by the `Get-Verb` cmdlet. The
rightmost part of a command is the noun part. A noun can be anything.

- **Filter on verb**. In the command
  `Get-Process`, the verb part is `Get`. To filter on the verb part, use the **Verb** parameter.

   ```powershell
   Get-Command -Verb 'Get'
   ```

   This example lists all commands that use the verb `Get`.

- **Filter on noun**. In the command `Get-Process`, the noun part is `Process`. To filter on the
  noun, use the **Noun** parameter. The following example returns all cmdlets that have nouns
  starting with the letter `U`.

   ```powershell
   Get-Command -Noun U*
   ```

Also, you can combine parameters to narrow down your search, for example:

```powershell
Get-Command -Verb Get -Noun U*
```

```Output
CommandType     Name                         Version    Source
-----------     ----                         -------    ------
Cmdlet          Get-UICulture                7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Get-Unique                   7.0.0.0    Microsoft.PowerShell.Utility
Cmdlet          Get-Uptime                   7.0.0.0    Microsoft.PowerShell.Utility
```

### Use helper cmdlets to filter results

You can also use other cmdlets to filter results.

- `Select-Object`. This versatile command helps you pick out specific properties from one or more
  objects. You can also limit the number of items you get back. The following example returns the
  **Name** and **Source** property values for the first 5 commands available in the current session.

   ```powershell
   Get-Command | Select-Object -First 5 -Property Name, Source
   ```

   ```Output
   Name                      Source
   ----                      ------
   Add-AppPackage            Appx
   Add-AppPackageVolume      Appx
   Add-AppProvisionedPackage Dism
   Add-AssertionOperator     Pester
   Add-ProvisionedAppPackage Dism
   ```

   For more information, see [Select-Object][03].

- `Where-Object`. This cmdlet lets you filter the objects returned based on the values of
  properties. The command takes an expression that can test the value of a property. The following
  example returns all processes where the `ProcessName` starts with `p`.

  ```powershell
  Get-Process | Where-Object {$_.ProcessName -like "p*"}
  ```

  The `Get-Process` cmdlet returns a collection of process objects. To filter the response, _pipe_
  the output to `Where-Object`. Piping means that two or more commands are connected via a pipe `|`
  character. The output from one command is sent as the input for the next command. The filter
  expression for `Where-Object` uses the `-like` operator to match processes that start with the
  letter `p`.

## Explore objects with Get-Member

Once you've been able to locate the cmdlet you want, you want to know more about what output it
produces. The `Get-Member` cmdlet displays the type, properties, and methods of an object. Pipe the
output you want to inspect to `Get-Member`.

```powershell
Get-Process | Get-Member
```

The result displays the returned type as `TypeName` and all the properties and methods of the
object. Here's an excerpt of such a result:

```Output
TypeName: System.Diagnostics.Process

Name        MemberType     Definition
----        ----------     ----------
Handles     AliasProperty  Handles = Handlecount
Name        AliasProperty  Name = ProcessName
...
```

Using the **MemberType** parameter you can limit the information returned.

```powershell
Get-Process | Get-Member -MemberType Method
```

By default PowerShell only displays a few properties. The previous example displayed the `Name`,
`MemberType` and `Definition` members. You can use `Select-Object` to specify properties you want to
see. For example, you want to display only the `Name` and `Definition` properties:

```powershell
Get-Process | Get-Member | Select-Object Name, Definition
```

### Search by parameter type

`Get-Member` showed us that `Get-Process` returns **Process** type objects. The **ParameterType**
parameter of `Get-Command` can be used to find other commands that take **Process** objects as
input.

```powershell
Get-Command -ParameterType Process
```

```Output
CommandType     Name                         Version    Source
-----------     ----                         -------    ------
Cmdlet          Debug-Process                7.0.0.0    Microsoft.PowerShell.Managem…
Cmdlet          Enter-PSHostProcess          7.1.0.0    Microsoft.PowerShell.Core
Cmdlet          Get-Process                  7.0.0.0    Microsoft.PowerShell.Managem…
Cmdlet          Get-PSHostProcessInfo        7.1.0.0    Microsoft.PowerShell.Core
Cmdlet          Stop-Process                 7.0.0.0    Microsoft.PowerShell.Managem…
Cmdlet          Wait-Process                 7.0.0.0    Microsoft.PowerShell.Managem…
```

Knowing the output type of a command can help narrow down your search for related commands.

### Additional resources

- [Get-Command][01]
- [Get-Member][02]
- [Select-Object][03]

<!-- link references -->
[01]: xref:Microsoft.PowerShell.Core.Get-Command
[02]: xref:Microsoft.PowerShell.Utility.Get-Member
[03]: xref:Microsoft.PowerShell.Utility.Select-Object

# /./reference/install/installing-powershell-on-windows.md

    ---
    description: Information about installing PowerShell on Windows
    ms.date: 01/12/2024
    title: Installing PowerShell on Windows
    ---
# Installing PowerShell on Windows

There are multiple ways to install PowerShell in Windows. Each install method is designed to support
different scenarios and workflows. Choose the method that best suits your needs.

- [Winget][19] - Recommended way to install PowerShell on Windows clients
- [MSI package][16] - Best choice for Windows Servers and enterprise deployment scenarios
- [ZIP package][20] - Easiest way to "side load" or install multiple versions
  - Use this method for Windows Nano Server, Windows IoT, and Arm-based systems
- [.NET Global tool][15] - A good choice for .NET developers that install and use other global tools
- [Microsoft Store package][17] - An easy way to install for casual users of PowerShell but has
  limitations

> [!NOTE]
> The installation commands in this article are for the latest stable release of PowerShell. To
> install a different version of PowerShell, adjust the command to match the version you need. The
> following links direct you to the release page for each version in the PowerShell repository on
> GitHub.
>
> - Stable release: [https://aka.ms/powershell-release?tag=stable][23]
> - LTS release: [https://aka.ms/powershell-release?tag=lts][21]
> - Preview release: [https://aka.ms/powershell-release?tag=preview][22]
>
> Download links for every package are found in the **Assets** section of the Release page. The
> **Assets** section may be collapsed, so you may need to click to expand it.

## <a id="winget" />Install PowerShell using Winget (recommended)

Winget, the Windows Package Manager, is a command-line tool enables users to discover, install,
upgrade, remove, and configure applications on Windows client computers. This tool is the client
interface to the Windows Package Manager service. The `winget` command-line tool is bundled with
Windows 11 and modern versions of Windows 10 by default as the **App Installer**.

> [!NOTE]
> See the [winget documentation][14] for a list of system requirements and install instructions.
> `Winget` doesn't currently run on Windows servers.

The following commands can be used to install PowerShell using the published `winget` packages:

Search for the latest version of PowerShell

```powershell
winget search Microsoft.PowerShell
```

```Output
Name               Id                           Version   Source
-----------------------------------------------------------------
PowerShell         Microsoft.PowerShell         7.4.1.0   winget
PowerShell Preview Microsoft.PowerShell.Preview 7.4.0.101 winget
```

Install PowerShell or PowerShell Preview using the `id` parameter

```powershell
winget install --id Microsoft.Powershell --source winget
winget install --id Microsoft.Powershell.Preview --source winget
```

> [!NOTE]
> On Windows systems using X86 or X64 processor, `winget` installs the MSI package. On systems using
> the Arm64 processor, `winget` installs the Microsoft Store (MSIX) package. For more information,
> see [Installing from the Microsoft Store][17].

## <a id="msi" />Installing the MSI package

To install PowerShell on Windows, use the following links to download the install package from
GitHub.

- [PowerShell-7.4.1-win-x64.msi][28]
- [PowerShell-7.4.1-win-x86.msi][30]

Once downloaded, double-click the installer file and follow the prompts.

The installer creates a shortcut in the Windows Start Menu.

- By default the package is installed to `$env:ProgramFiles\PowerShell\<version>`
- You can launch PowerShell via the Start Menu or `$env:ProgramFiles\PowerShell\<version>\pwsh.exe`

> [!NOTE]
> PowerShell 7.4 installs to a new directory and runs side-by-side with Windows PowerShell 5.1.
> PowerShell 7.4 is an in-place upgrade that removes previous versions of PowerShell 7. Preview
> versions of PowerShell can be installed side-by-side with other versions of PowerShell.
>
> - PowerShell 7.4 is installed to `$env:ProgramFiles\PowerShell\7`
> - The `$env:ProgramFiles\PowerShell\7` folder is added to `$env:PATH`
>
> If you need to run PowerShell 7.4 side-by-side with other versions, use the [ZIP install][20]
> method to install the other version to a different folder.

### Support for Microsoft Update in PowerShell 7.2 and newer

PowerShell 7.2 and newer has support for Microsoft Update. When you enable this feature, you'll get
the latest PowerShell 7 updates in your traditional Microsoft Update (MU) management flow, whether
that's with Windows Update for Business, WSUS, Microsoft Endpoint Configuration Manager, or the
interactive MU dialog in Settings.

The PowerShell MSI package includes following command-line options:

- `USE_MU` - This property has two possible values:
  - `1` (default) - Opts into updating through Microsoft Update, WSUS, or Configuration Manager
  - `0` -  Don't opt into updating through Microsoft Update, WSUS, or Configuration Manager
- `ENABLE_MU`
  - `1` (default) - Opts into using Microsoft Update for Automatic Updates
  - `0` - Don't opt into using Microsoft Update

> [!NOTE]
> Enabling updates may have been set in a previous installation or manual configuration. Using
> `ENABLE_MU=0` doesn't remove the existing settings. Also, this setting can be overruled by Group
> Policy settings controlled by your administrator.

For more information, see the [PowerShell Microsoft Update FAQ][34].

### Install the MSI package from the command line

MSI packages can be installed from the command line allowing administrators to deploy packages
without user interaction. The MSI package includes the following properties to control the
installation options:

- `ADD_EXPLORER_CONTEXT_MENU_OPENPOWERSHELL` - This property controls the option for adding the
  `Open PowerShell` item to the context menu in Windows Explorer.
- `ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL` - This property controls the option for adding the
  `Run with PowerShell` item to the context menu in Windows Explorer.
- `ENABLE_PSREMOTING` - This property controls the option for enabling PowerShell remoting during
  installation.
- `REGISTER_MANIFEST` - This property controls the option for registering the Windows Event
  Logging manifest.
- `ADD_PATH` - This property controls the option for adding PowerShell to the Windows PATH
  environment variable.
- `DISABLE_TELEMETRY` - This property controls the option for disabling PowerShell's telemetry by
  setting the `POWERSHELL_TELEMETRY_OPTOUT` environment variable.
- `INSTALLFOLDER` - This property controls the installation directory. The default is
  `$env:ProgramFiles\PowerShell\`. This is the location where the installer creates the versioned
  subfolder. You can't change the name of the versioned subfolder.
  - For current releases, the versioned subfolder is `7`
  - For preview releases, the versioned subfolder is `7-preview`

The following example shows how to silently install PowerShell with all the install options enabled.

```powershell
msiexec.exe /package PowerShell-7.4.1-win-x64.msi /quiet ADD_EXPLORER_CONTEXT_MENU_OPENPOWERSHELL=1 ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL=1 ENABLE_PSREMOTING=1 REGISTER_MANIFEST=1 USE_MU=1 ENABLE_MU=1 ADD_PATH=1
```

For a full list of command-line options for `Msiexec.exe`, see
[Command line options][12].

## <a id="zip" />Installing the ZIP package

PowerShell binary ZIP archives are provided to enable advanced deployment scenarios. Download one of
the following ZIP archives from the [current release][23] page.

- [PowerShell-7.4.1-win-x64.zip][29]
- [PowerShell-7.4.1-win-x86.zip][31]
- [PowerShell-7.4.1-win-arm64.zip][27]

Depending on how you download the file you may need to unblock the file using the `Unblock-File`
cmdlet. Unzip the contents to the location of your choice and run `pwsh.exe` from there. Unlike
installing the MSI packages, installing the ZIP archive doesn't check for prerequisites. For
remoting over WSMan to work properly, ensure that you've met the [prerequisites][18].

Use this method to install the ARM-based version of PowerShell on computers like the Microsoft
Surface Pro X. For best results, install PowerShell to the to `$env:ProgramFiles\PowerShell\7`
folder.

## <a id="dotnet" />Install as a .NET Global tool

If you already have the [.NET Core SDK][05] installed, you can install PowerShell as a
[.NET Global tool][06].

```
dotnet tool install --global PowerShell
```

The dotnet tool installer adds `$HOME\.dotnet\tools` to your `$env:PATH` environment variable.
However, the currently running shell doesn't have the updated `$env:PATH`. You can start PowerShell
from a new shell by typing `pwsh`.

## <a id="msstore" />Installing from the Microsoft Store

PowerShell can be installed from the Microsoft Store. You can find the PowerShell release in the
[Microsoft Store][33] site or in the Store application in Windows.

Benefits of the Microsoft Store package:

- Automatic updates built right into Windows
- Integrates with other software distribution mechanisms like Intune and Configuration Manager
- Can install on Windows systems using x86, x64, or Arm64 processors

### Known limitations

By default, Windows Store packages run in an application sandbox that virtualizes access to some
filesystem and registry locations. Changes to virtualized file and registry locations don't persist
outside of the application sandbox.

This sandbox blocks all changes to the application's root folder. Any system-level configuration
settings stored in `$PSHOME` can't be modified. This includes the WSMAN configuration. This prevents
remote sessions from connecting to Store-based installs of PowerShell. User-level configurations and
SSH remoting are supported.

The following commands need write to `$PSHOME`. These commands aren't supported in a Microsoft Store
instance of PowerShell.

- `Register-PSSessionConfiguration`
- `Update-Help -Scope AllUsers`
- `Enable-ExperimentalFeature -Scope AllUsers`
- `Set-ExecutionPolicy -Scope LocalMachine`

For more information, see
[Understanding how packaged desktop apps run on Windows][13].

### Changes for PowerShell 7.2

Beginning in PowerShell 7.2, the PowerShell package is now exempt from file and registry
virtualization. Changes to virtualized file and registry locations now persist outside of the
application sandbox. However, changes to the application's root folder are still blocked.

> [!IMPORTANT]
> You must be running on Windows build 1903 or higher for this exemption to work.

## Installing a preview version

Preview releases of PowerShell 7 install to `$env:ProgramFiles\PowerShell\7-preview` so they can be
run side-by-side with non-preview releases of PowerShell. PowerShell 7.4 is the next preview
release.

## Upgrading an existing installation

For best results when upgrading, you should use the same install method you used when you first
installed PowerShell. If you aren't sure how PowerShell was installed, you can check the value of
the `$PSHOME` variable, which always points to the directory containing PowerShell that the current
session is running.

- If the value is `$HOME\.dotnet\tools`, PowerShell was installed with the [.NET Global tool][15].
- If the value is `$Env:ProgramFiles\PowerShell\7`, PowerShell was installed as an
  [MSI package][16] or with [Winget][19] on a computer with an X86 or x64 processor.
- If the value starts with `$Env:ProgramFiles\WindowsApps\`, PowerShell was installed as a
  [Microsoft Store package][17] or with [Winget][19] on computer with an ARM processor.
- If the value is anything else, it's likely that PowerShell was installed as a [ZIP package][20].

If you installed via the MSI package, that information also appears in the
**Programs and Features** Control Panel.

To determine whether PowerShell may be upgraded with Winget, run the following command:

```powershell
winget list --name PowerShell --upgrade-available
```

If there is an available upgrade, the output indicates the latest available version.

> [!NOTE]
> When upgrading, PowerShell won't upgrade from an LTS version to a non-LTS version. It only
> upgrades to the latest version of LTS, for example, from 7.2.3 to 7.2.18. To upgrade from an
> LTS release to a newer stable version or the next LTS, you need to install the new version with
> the MSI for that release.
>
> When the installed version isn't an LTS version, PowerShell upgrades to the latest stable
> version.

## Deploying on Windows 10 IoT Enterprise

Windows 10 IoT Enterprise comes with Windows PowerShell, which we can use to deploy PowerShell 7.

```powershell
# Replace the placeholder information for the following variables:
$deviceip = '<device ip address'
$zipfile = 'PowerShell-7.4.1-win-arm64.zip'
$downloadfolder = 'u:\users\administrator\Downloads'  # The download location is local to the device.
    # There should be enough  space for the zip file and the unzipped contents.

# Create PowerShell session to target device
Set-Item -Path WSMan:\localhost\Client\TrustedHosts $deviceip
$S = New-PSSession -ComputerName $deviceIp -Credential Administrator
# Copy the ZIP package to the device
Copy-Item $zipfile -Destination $downloadfolder -ToSession $S

#Connect to the device and expand the archive
Enter-PSSession $S
Set-Location u:\users\administrator\Downloads
Expand-Archive .\PowerShell-7.4.1-win-arm64.zip

# Set up remoting to PowerShell 7
Set-Location .\PowerShell-7.4.1-win-arm64
# Be sure to use the -PowerShellHome parameter otherwise it tries to create a new
# endpoint with Windows PowerShell 5.1
.\Install-PowerShellRemoting.ps1 -PowerShellHome .
```

When you set up PowerShell Remoting you get an error message and are disconnected from the device.
PowerShell has to restart WinRM. Now you can connect to PowerShell 7 endpoint on device.

```powershell

# Be sure to use the -Configuration parameter. If you omit it, you connect to Windows PowerShell 5.1
Enter-PSSession -ComputerName $deviceIp -Credential Administrator -Configuration PowerShell.7.4.1
```

## Deploying on Windows 10 IoT Core

Windows 10 IoT Core adds Windows PowerShell when you include _IOT_POWERSHELL_ feature, which we can
use to deploy PowerShell 7. The steps defined above for Windows 10 IoT Enterprise can be followed
for IoT Core as well.

For adding the latest PowerShell in the shipping image, use [Import-PSCoreRelease][24] command to
include the package in the workarea and add _OPENSRC_POWERSHELL_ feature to your image.

> [!NOTE]
> For ARM64 architecture, Windows PowerShell isn't added when you include _IOT_POWERSHELL_. So the
> zip based install doesn't work. You need to use `Import-PSCoreRelease` command to add it in
> the image.

## Deploying on Nano Server

These instructions assume that the Nano Server is a "headless" OS that has a version of PowerShell
already running on it. For more information, see the [Nano Server Image Builder][11]
documentation.

PowerShell binaries can be deployed using two different methods.

1. Offline - Mount the Nano Server VHD and unzip the contents of the zip file to your chosen
   location within the mounted image.
1. Online - Transfer the zip file over a PowerShell Session and unzip it in your chosen location.

In both cases, you need the [Windows x64 ZIP release package][29]. Run the commands within an
"Administrator" instance of PowerShell.

### Offline Deployment of PowerShell

1. Use your favorite zip utility to unzip the package to a directory within the mounted Nano Server
   image.
1. Unmount the image and boot it.
1. Connect to the built-in instance of Windows PowerShell.
1. Follow the instructions to create a remoting endpoint using the
   ["another instance technique"][04].

### Online Deployment of PowerShell

Deploy PowerShell to Nano Server using the following steps.

```powershell
# Replace the placeholder information for the following variables:
$ipaddr = '<Nano Server IP address>'
$credential = Get-Credential # <An Administrator account on the system>
$zipfile = 'PowerShell-7.4.1-win-x64.zip'
# Connect to the built-in instance of Windows PowerShell
$session = New-PSSession -ComputerName $ipaddr -Credential $credential
# Copy the file to the Nano Server instance
Copy-Item $zipfile c:\ -ToSession $session
# Enter the interactive remote session
Enter-PSSession $session
# Extract the ZIP file
Expand-Archive -Path C:\PowerShell-7.4.1-win-x64.zip -DestinationPath 'C:\Program Files\PowerShell 7'
```

If you want WSMan-based remoting, follow the instructions to create a remoting endpoint using the
["another instance technique"][04].

## PowerShell remoting

PowerShell supports the PowerShell Remoting Protocol (PSRP) over both WSMan and SSH. For more
information, see:

- [SSH Remoting in PowerShell][02]
- [WSMan Remoting in PowerShell][03]

The following prerequisites must be met to enable PowerShell remoting over WSMan on older versions
of Windows.

- Install the Windows Management Framework (WMF) 5.1 (as necessary). For more information about WMF,
  see [WMF Overview][10].
- Install the [Universal C Runtime][32] on Windows versions predating Windows 10. It's available via
  direct download or Windows Update. Fully patched systems already have this package installed.

## Supported versions of Windows

[!INCLUDE [Windows support](../../includes/windows-support.md)]

You can check the version that you are using by running `winver.exe`.

## Installation support

Microsoft supports the installation methods in this document. There may be other third-party methods
of installation available from other sources. While those tools and methods may work, Microsoft
can't support those methods.

<!-- link references -->
[02]: ../learn/remoting/SSH-Remoting-in-PowerShell-Core.md
[03]: ../learn/remoting/WSMan-Remoting-in-PowerShell-Core.md
[04]: ../learn/remoting/WSMan-Remoting-in-PowerShell-Core.md#executed-by-another-instance-of-powershell-on-behalf-of-the-instance-that-it-will-register
[05]: https://learn.microsoft.com/dotnet/core/sdk
[06]: https://learn.microsoft.com/dotnet/core/tools/global-tools
[10]: https://learn.microsoft.com/powershell/scripting/wmf/overview
[11]: https://learn.microsoft.com/windows-server/get-started/deploy-nano-server
[12]: https://learn.microsoft.com/windows/desktop/Msi/command-line-options
[13]: https://learn.microsoft.com/windows/msix/desktop/desktop-to-uwp-behind-the-scenes
[14]: https://learn.microsoft.com/windows/package-manager/winget
[15]: #dotnet
[16]: #msi
[17]: #msstore
[18]: #powershell-remoting
[19]: #winget
[20]: #zip
[21]: https://aka.ms/powershell-release?tag=lts
[22]: https://aka.ms/powershell-release?tag=preview
[23]: https://aka.ms/powershell-release?tag=stable
[24]: https://github.com/ms-iot/iot-adk-addonkit/blob/master/Tools/IoTCoreImaging/Docs/Import-PSCoreRelease.md#Import-PSCoreRelease
[27]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-arm64.zip
[28]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x64.msi
[29]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x64.zip
[30]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x86.msi
[31]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x86.zip
[32]: https://www.microsoft.com/download/details.aspx?id=50410
[33]: https://www.microsoft.com/store/apps/9MZ1SNWT0N5D
[34]: microsoft-update-faq.yml

# /./reference/install/installing-powershell-on-linux.md

    ---
    description: This article lists the Linux distributions and package managers that are supported for installing PowerShell.
    ms.date: 01/09/2023
    title: Install PowerShell on Linux
    ---
# Install PowerShell on Linux

PowerShell can be installed on several different Linux distributions. Most Linux platforms and
distributions have a major release each year, and provide a package manager that's used to install
PowerShell. PowerShell can be installed on some distributions of Linux that aren't supported by
Microsoft. In those cases, you may find support from the community for PowerShell on those
platforms.

For more information, see the [PowerShell Support Lifecycle][05] documentation.

This article lists the supported Linux distributions and package managers. All PowerShell releases
remain supported until either the version of PowerShell or the version of the Linux distribution
reaches end-of-support.

For the best compatibility, choose a long-term release (LTS) version.

## Alpine

[!INCLUDE [Alpine support](../../includes/alpine-support.md)]

For more information, see [Install PowerShell on Alpine][13].

## Debian

Debian uses APT (Advanced Package Tool) as a package manager.

[!INCLUDE [Debian support](../../includes/debian-support.md)]

For more information, see [Install PowerShell on Debian][14].

## Red Hat Enterprise Linux (RHEL)

RHEL 7 uses yum and RHEL 8 uses the dnf package manager.

[!INCLUDE [RHEL support](../../includes/rhel-support.md)]

For more information, see [Install PowerShell on RHEL][17].

## Ubuntu

Ubuntu uses APT (Advanced Package Tool) as a package manager.

[!INCLUDE [Ubuntu support](../../includes/ubuntu-support.md)]

For more information, see [Install PowerShell on Ubuntu][18].

## Community supported distributions

PowerShell can be installed on many distributions of Linux that aren't supported by Microsoft. In
those cases, you may find support from the community for PowerShell on those platforms

To be supported by Microsoft, the Linux distribution must meet the following criteria:

- The version and architecture of the distribution is supported by .NET Core.
- The version of the distribution is supported for at least one year.
- The version of the distribution isn't an interim release or equivalent.
- The PowerShell team has tested the version of the distribution.

For more information, see [Community support for PowerShell on Linux][06].

## Alternate installation methods

There are three other ways to install PowerShell on Linux, including Linux distributions that aren't
officially supported. You can try to install PowerShell using the PowerShell Snap Package. You can
also try deploying PowerShell binaries directly using the Linux `tar.gz` package. For more
information, see [Alternate ways to install PowerShell on Linux][15].

<!-- link references -->
[05]: ../PowerShell-Support-Lifecycle.md
[06]: community-support.md
[13]: install-alpine.md
[14]: install-debian.md
[15]: install-other-linux.md
[17]: install-rhel.md
[18]: install-ubuntu.md

# /./reference/install/install-alpine.md

    ---
    description: Information about installing PowerShell on Alpine Linux
    ms.date: 01/12/2024
    title: Installing PowerShell on Alpine Linux
    ---
# Installing PowerShell on Alpine Linux

All packages are available on our GitHub [releases][03] page. After the package is installed, run
`pwsh` from a terminal. Run `pwsh-preview` if you installed a preview release. Before installing,
check the list of [Supported versions][02] below.

> [!NOTE]
> PowerShell 7.4 is an in-place upgrade that removes previous versions of PowerShell 7. Preview
> versions of PowerShell can be installed side-by-side with other versions of PowerShell. If you
> need to run PowerShell 7.4 side-by-side with a previous version, reinstall the previous version
> using the [binary archive][05] method.

## Installation steps

Installation on Alpine is based on downloading tar.gz package from the [releases][03] page. The URL
to the package depends on the version of PowerShell you want to install.

- PowerShell 7.4.1 - `https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-linux-musl-x64.tar.gz`
- PowerShell 7.3.11 - `https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-linux-alpine-x64.tar.gz`
- PowerShell 7.2.18 - `https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell-7.2.18-linux-alpine-x64.tar.gz`

Then, in the terminal, execute the following shell commands to install PowerShell 7.3:

```sh
# install the requirements
sudo apk add --no-cache \
    ca-certificates \
    less \
    ncurses-terminfo-base \
    krb5-libs \
    libgcc \
    libintl \
    libssl1.1 \
    libstdc++ \
    tzdata \
    userspace-rcu \
    zlib \
    icu-libs \
    curl

sudo apk -X https://dl-cdn.alpinelinux.org/alpine/edge/main add --no-cache \
    lttng-ust

# Download the powershell '.tar.gz' archive
curl -L https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-linux-musl-x64.tar.gz -o /tmp/powershell.tar.gz

# Create the target folder where powershell will be placed
sudo mkdir -p /opt/microsoft/powershell/7

# Expand powershell to the target folder
sudo tar zxf /tmp/powershell.tar.gz -C /opt/microsoft/powershell/7

# Set execute permissions
sudo chmod +x /opt/microsoft/powershell/7/pwsh

# Create the symbolic link that points to pwsh
sudo ln -s /opt/microsoft/powershell/7/pwsh /usr/bin/pwsh

# Start PowerShell
pwsh
```

## Uninstall PowerShell

```sh
sudo rm -rf /usr/bin/pwsh /opt/microsoft/powershell
```

## PowerShell paths

- `$PSHOME` is `/opt/microsoft/powershell/7/`
- The profiles scripts are stored in the following locations:
  - AllUsersAllHosts - `$PSHOME/profile.ps1`
  - AllUsersCurrentHost - `$PSHOME/Microsoft.PowerShell_profile.ps1`
  - CurrentUserAllHosts - `~/.config/powershell/profile.ps1`
  - CurrentUserCurrentHost - `~/.config/powershell/Microsoft.PowerShell_profile.ps1`
- Modules are stored in the following locations:
  - User modules - `~/.local/share/powershell/Modules`
  - Shared modules - `/usr/local/share/powershell/Modules`
  - Default modules - `$PSHOME/Modules`
- PSReadLine history is recorded in `~/.local/share/powershell/PSReadLine/ConsoleHost_history.txt`

The profiles respect PowerShell's per-host configuration, so the default host-specific profiles
exists at `Microsoft.PowerShell_profile.ps1` in the same locations.

PowerShell respects the [XDG Base Directory Specification][04] on Linux.

## Supported versions

[!INCLUDE [Alpine support](../../includes/alpine-support.md)]

## Installation support

Microsoft supports the installation methods in this document. There may be other methods of
installation available from other third-party sources. While those tools and methods may work,
Microsoft can't support those methods.

<!-- link references -->
[02]: #supported-versions
[03]: https://aka.ms/PowerShell-Release?tag=stable
[04]: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
[05]: install-other-linux.md#binary-archives

# /./reference/install/install-debian.md

    ---
    description: Information about installing PowerShell on Debian Linux
    ms.date: 01/12/2024
    title: Installing PowerShell on Debian
    ---
# Installing PowerShell on Debian

All packages are available on our GitHub [releases][02] page. Before installing, check the list of
[Supported versions][01] below. After the package is installed, run `pwsh` from a terminal. Run
`pwsh-lts` if you installed a preview release.

> [!NOTE]
> PowerShell 7.4 is an in-place upgrade that removes previous versions of PowerShell 7. Preview
> versions of PowerShell can be installed side-by-side with other versions of PowerShell. If you
> need to run PowerShell 7.4 side-by-side with a previous version, reinstall the previous version
> using the [binary archive][05] method.

Debian uses APT (Advanced Package Tool) as a package manager.

## Installation on Debian 10 or 11 via the Package Repository

Microsoft builds and supports a variety of software products for Linux systems and makes them
available via Linux packaging clients (apt, dnf, yum, etc). These Linux software packages are hosted
on the _Linux package repository for Microsoft products_, [https://packages.microsoft.com][03], also
known as _PMC_.

Installing PowerShell from PMC is the preferred method of installation.

> [!NOTE]
> This script only works for supported versions of Debian.

```sh
###################################
# Prerequisites

# Update the list of packages
sudo apt-get update

# Install pre-requisite packages.
sudo apt-get install -y wget

# Get the version of Debian
source /etc/os-release

# Download the Microsoft repository GPG keys
wget -q https://packages.microsoft.com/config/debian/$VERSION_ID/packages-microsoft-prod.deb

# Register the Microsoft repository GPG keys
sudo dpkg -i packages-microsoft-prod.deb

# Delete the Microsoft repository GPG keys file
rm packages-microsoft-prod.deb

# Update the list of packages after we added packages.microsoft.com
sudo apt-get update

###################################
# Install PowerShell
sudo apt-get install -y powershell

# Start PowerShell
pwsh
```

## Installation via direct download

PowerShell 7.2 introduced a universal package that makes installation easier. Download the universal
package from the [releases][02] page onto your Debian machine.

The link to the current version is:

- PowerShell 7.4 (LTS) universal package for supported versions of Debian
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell_7.4.1-1.deb_amd64.deb`
- PowerShell 7.3 (stable) universal package for supported versions of Debian
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell_7.3.11-1.deb_amd64.deb`
- PowerShell 7.2 (LTS) universal package for supported versions of Debian
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell_7.2.18-1.deb_amd64.deb`

The following shell script downloads and installs the current preview release of PowerShell. You can
change the URL to download the version of PowerShell that you want to install.

```sh
###################################
# Prerequisites

# Update the list of packages
sudo apt-get update

# Install pre-requisite packages.
sudo apt-get install -y wget

# Download the PowerShell package file
wget https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell_7.4.1-1.deb_amd64.deb

###################################
# Install the PowerShell package
sudo dpkg -i powershell_7.4.1-1.deb_amd64.deb

# Resolve missing dependencies and finish the install (if necessary)
sudo apt-get install -f

# Delete the downloaded package file
rm powershell_7.4.1-1.deb_amd64.deb

# Start PowerShell
pwsh
```

## Uninstall PowerShell

```sh
sudo apt-get remove powershell
```

## PowerShell paths

- `$PSHOME` is `/opt/microsoft/powershell/7/`
- The profiles scripts are stored in the following locations:
  - AllUsersAllHosts - `$PSHOME/profile.ps1`
  - AllUsersCurrentHost - `$PSHOME/Microsoft.PowerShell_profile.ps1`
  - CurrentUserAllHosts - `~/.config/powershell/profile.ps1`
  - CurrentUserCurrentHost - `~/.config/powershell/Microsoft.PowerShell_profile.ps1`
- Modules are stored in the following locations:
  - User modules - `~/.local/share/powershell/Modules`
  - Shared modules - `/usr/local/share/powershell/Modules`
  - Default modules - `$PSHOME/Modules`
- PSReadLine history is recorded in `~/.local/share/powershell/PSReadLine/ConsoleHost_history.txt`

PowerShell respects the [XDG Base Directory Specification][04] on Linux.

## Supported versions

[!INCLUDE [Debian support](../../includes/debian-support.md)]

## Installation support

Microsoft supports the installation methods in this document. There may be other methods of
installation available from other third-party sources. While those tools and methods may work,
Microsoft can't support those methods.

<!-- link references -->
[01]: #supported-versions
[02]: https://aka.ms/PowerShell-Release?tag=stable
[03]: https://packages.microsoft.com
[04]: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
[05]: install-other-linux.md#binary-archives

# /./reference/install/install-rhel.md

    ---
    description: Information about installing PowerShell on Red Hat Enterprise Linux (RHEL)
    ms.date: 01/12/2024
    title: Installing PowerShell on Red Hat Enterprise Linux (RHEL)
    ---
# Installing PowerShell on Red Hat Enterprise Linux (RHEL)

All packages are available on our GitHub [releases][02] page. Before installing, check the list of
[Supported versions][01] below. After the package is installed, run `pwsh` from a terminal. Run
`pwsh-preview` if you installed a preview release.

> [!NOTE]
> PowerShell 7.4 is an in-place upgrade that removes previous versions of PowerShell 7. Preview
> versions of PowerShell can be installed side-by-side with other versions of PowerShell. If you
> need to run PowerShell 7.4 side-by-side with a previous version, reinstall the previous version
> using the [binary archive][05] method.

RHEL 7 uses `yum` and RHEL 8 and higher uses the `dnf` package manager.

## Installation via the Package Repository

Microsoft builds and supports a variety of software products for Linux systems and makes them
available via Linux packaging clients (apt, dnf, yum, etc). These Linux software packages are hosted
on the _Linux package repository for Microsoft products_, [https://packages.microsoft.com][03], also
known as _PMC_.

Installing PowerShell from PMC is the preferred method of installation.

> [!NOTE]
> This script only works for supported versions of RHEL.

```sh
###################################
# Prerequisites

# Get version of RHEL
source /etc/os-release
if [ $(bc<<<"$VERSION_ID < 8") = 1 ]
then majorver=7
elif [ $(bc<<<"$VERSION_ID < 9") = 1 ]
then majorver=8
else majorver=9
fi

# Register the Microsoft RedHat repository
curl -sSL -O https://packages.microsoft.com/config/rhel/$majorver/packages-microsoft-prod.rpm

# Register the Microsoft repository keys
sudo rpm -i packages-microsoft-prod.rpm

# Delete the repository keys after installing
rm packages-microsoft-prod.rpm

# RHEL 7.x uses yum and RHEL 8+ uses dnf
if [ $(bc<<<"$majorver < 8") ]
then
    # Update package index files
    sudo yum update
    # Install PowerShell
    sudo yum install powershell -y
else
    # Update package index files
    sudo dnf update
    # Install PowerShell
    sudo dnf install powershell -y
fi
```

## Installation via direct download

PowerShell 7.2 introduced a universal package that makes installation easier. Download the universal
package from the [releases][02] page onto your RHEL machine.

The link to the current version is:

- PowerShell 7.4 universal package for supported versions of RHEL
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-1.rh.x86_64.rpm`
- PowerShell 7.3.11 universal package for supported versions of RHEL
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-1.rh.x86_64.rpm`
- PowerShell 7.2.18 universal package for supported versions of RHEL
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell-7.2.18-1.rh.x86_64.rpm`

The following shell script downloads and installs the current preview release of PowerShell. You can
change the URL to download the version of PowerShell that you want to install.

On RHEL 8 or 9:

```sh
sudo dnf install https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-1.rh.x86_64.rpm
```

On RHEL 7:

```sh
sudo yum install https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-1.rh.x86_64.rpm
```

## Uninstall PowerShell

On RHEL 8 or 9:

```sh
sudo dnf remove powershell
```

On RHEL 7:

```sh
sudo yum remove powershell
```

## Support for Arm processors

PowerShell 7.2 and newer supports running on RHEL using a 64-bit Arm processor. Use the binary
archive installation method of installing PowerShell that's described in
[Alternate ways to install PowerShell on Linux][05].

## PowerShell paths

- `$PSHOME` is `/opt/microsoft/powershell/7/`
- The profiles scripts are stored in the following locations:
  - AllUsersAllHosts - `$PSHOME/profile.ps1`
  - AllUsersCurrentHost - `$PSHOME/Microsoft.PowerShell_profile.ps1`
  - CurrentUserAllHosts - `~/.config/powershell/profile.ps1`
  - CurrentUserCurrentHost - `~/.config/powershell/Microsoft.PowerShell_profile.ps1`
- Modules are stored in the following locations:
  - User modules - `~/.local/share/powershell/Modules`
  - Shared modules - `/usr/local/share/powershell/Modules`
  - Default modules - `$PSHOME/Modules`
- PSReadLine history is recorded in `~/.local/share/powershell/PSReadLine/ConsoleHost_history.txt`

PowerShell respects the [XDG Base Directory Specification][04] on Linux.

## Supported versions

[!INCLUDE [RHEL support](../../includes/rhel-support.md)]

## Installation support

Microsoft supports the installation methods in this document. There may be other methods of
installation available from other third-party sources. While those tools and methods may work,
Microsoft can't support those methods.

<!-- link references -->
[01]: #supported-versions
[02]: https://aka.ms/PowerShell-Release?tag=stable
[03]: https://packages.microsoft.com
[04]: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
[05]: install-other-linux.md#binary-archives

# /./reference/install/install-ubuntu.md

    ---
    description: Information about installing PowerShell on Ubuntu
    ms.date: 01/12/2024
    title: Installing PowerShell on Ubuntu
    ---
# Installing PowerShell on Ubuntu

All packages are available on our GitHub [releases][02] page. Before installing,
check the list of [Supported versions][01] below. After the package is installed, run
`pwsh` from a terminal. Run `pwsh-lts` if you installed a preview release.

> [!NOTE]
> PowerShell 7.4 is an in-place upgrade that removes previous versions of PowerShell 7. Preview
> versions of PowerShell can be installed side-by-side with other versions of PowerShell. If you
> need to run PowerShell 7.4 side-by-side with a previous version, reinstall the previous version
> using the [binary archive][05] method.

Ubuntu uses APT (Advanced Package Tool) as a package manager.

## Installation via Package Repository the Package Repository

Microsoft builds and supports a variety of software products for Linux systems and makes them
available via Linux packaging clients (apt, dnf, yum, etc). These Linux software packages are hosted
on the _Linux package repository for Microsoft products_, [https://packages.microsoft.com][03], also
known as _PMC_.

Installing PowerShell from PMC is the preferred method of installation.

> [!NOTE]
> This script only works for supported versions of Ubuntu.

```sh
###################################
# Prerequisites

# Update the list of packages
sudo apt-get update

# Install pre-requisite packages.
sudo apt-get install -y wget apt-transport-https software-properties-common

# Get the version of Ubuntu
source /etc/os-release

# Download the Microsoft repository keys
wget -q https://packages.microsoft.com/config/ubuntu/$VERSION_ID/packages-microsoft-prod.deb

# Register the Microsoft repository keys
sudo dpkg -i packages-microsoft-prod.deb

# Delete the Microsoft repository keys file
rm packages-microsoft-prod.deb

# Update the list of packages after we added packages.microsoft.com
sudo apt-get update

###################################
# Install PowerShell
sudo apt-get install -y powershell

# Start PowerShell
pwsh
```

> [!IMPORTANT]
> Ubuntu comes preconfigured with a package repository that includes .NET packages, but not
> PowerShell. Using these instructions to install PowerShell registers the Microsoft repository as a
> package source. You can install PowerShell and some versions of .NET from this repository.
> However, the Ubuntu package repository has different versions of the .NET packages. This can cause
> problems when installing .NET for other purposes. For more information about these problems, see
> [Troubleshoot .NET package mix ups on Linux][07].
>
> You must choose the feed you want to use to install .NET. You can set the priority of the package
> repositories to favor one over the other. For instructions on how to set the priorities, see
> [My Linux distribution provides .NET packages, and I want to use them][06].

## Installation via direct download

PowerShell 7.2 introduced a universal package that makes installation easier. Download the universal
package from the [releases][02] page onto your Ubuntu machine.

The link to the current version is:

- PowerShell 7.4 (LTS) universal package for supported versions of Ubuntu
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell_7.4.1-1.deb_amd64.deb`
- PowerShell 7.3.11 (stable) universal package for supported versions of Ubuntu
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell_7.3.11-1.deb_amd64.deb`
- PowerShell 7.2.18 (LTS) universal package for supported versions of Ubuntu
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell_7.2.18-1.deb_amd64.deb`

The following shell script downloads and installs the current preview release of PowerShell. You can
change the URL to download the version of PowerShell that you want to install.

```sh
###################################
# Prerequisites

# Update the list of packages
sudo apt-get update

# Install pre-requisite packages.
sudo apt-get install -y wget

# Download the PowerShell package file
wget https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell_7.4.1-1.deb_amd64.deb

###################################
# Install the PowerShell package
sudo dpkg -i powershell_7.4.1-1.deb_amd64.deb

# Resolve missing dependencies and finish the install (if necessary)
sudo apt-get install -f

# Delete the downloaded package file
rm powershell_7.4.1-1.deb_amd64.deb

# Start PowerShell Preview
pwsh-lts
```

## Uninstall PowerShell

```sh
sudo apt-get remove powershell
```

## Support for Arm processors

PowerShell 7.2 and newer supports running on Ubuntu using 32-bit Arm processors. Use the binary
archive installation method of installing PowerShell that's described in
[Alternate ways to install PowerShell on Linux][08].

## PowerShell paths

- `$PSHOME` is `/opt/microsoft/powershell/7/`
- The profiles scripts are stored in the following locations:
  - AllUsersAllHosts - `$PSHOME/profile.ps1`
  - AllUsersCurrentHost - `$PSHOME/Microsoft.PowerShell_profile.ps1`
  - CurrentUserAllHosts - `~/.config/powershell/profile.ps1`
  - CurrentUserCurrentHost - `~/.config/powershell/Microsoft.PowerShell_profile.ps1`
- Modules are stored in the following locations:
  - User modules - `~/.local/share/powershell/Modules`
  - Shared modules - `/usr/local/share/powershell/Modules`
  - Default modules - `$PSHOME/Modules`
- PSReadLine history is recorded in `~/.local/share/powershell/PSReadLine/ConsoleHost_history.txt`

PowerShell respects the [XDG Base Directory Specification][04] on Linux.

## Supported versions

[!INCLUDE [Ubuntu support](../../includes/ubuntu-support.md)]

## Installation support

Microsoft supports the installation methods in this document. There may be other methods of
installation available from other third-party sources. While those tools and methods may work,
Microsoft can't support those methods.

<!-- link references -->
[01]: #supported-versions
[02]: https://aka.ms/PowerShell-Release?tag=stable
[03]: https://packages.microsoft.com
[04]: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
[05]: install-other-linux.md#binary-archives
[06]: https://learn.microsoft.com/dotnet/core/install/linux-package-mixup?pivots=os-linux-ubuntu#my-linux-distribution-provides-net-packages-and-i-want-to-use-them
[07]: https://learn.microsoft.com/dotnet/core/install/linux-package-mixup?pivots=os-linux-ubuntu#whats-going-on
[08]: https://learn.microsoft.com/powershell/scripting/install/install-other-linux

# /./reference/install/community-support.md

    ---
    description: PowerShell may run on Linux distributions that aren't officially supported by Microsoft.
    ms.date: 01/12/2024
    title: Community support for PowerShell on Linux
    ---
# Community support for PowerShell on Linux

PowerShell can be installed on some distributions of Linux that aren't supported by Microsoft. In
those cases, you may find support from the community for PowerShell on those platforms.

To be supported by Microsoft, the Linux distribution must meet the following criteria:

- The version and architecture of the distribution is supported by .NET Core.
- The version of the distribution is supported for at least one year.
- The version of the distribution isn't an interim release or equivalent.
- The PowerShell team has tested the version of the distribution.

For more information, see the [PowerShell Support Lifecycle][10]
documentation.

The following distributions are supported by the community. Each distribution has its own community
support mechanisms. Consult the distribution's website to find their community resources. You may
also get help from these [PowerShell Community][01] resources.

## Ubuntu interim releases

The documented steps to install PowerShell on [Ubuntu][08] may work on Ubuntu interim releases.
However, PowerShell is only supported on the LTS releases of Ubuntu. Microsoft doesn't support
[interim releases][05] of Ubuntu.

## Arch Linux

> [!NOTE]
> Arch support isn't officially supported by Microsoft and is maintained by the community.

PowerShell is available from the [Arch Linux][07] User Repository (AUR).

- It can be compiled with the [latest tagged release][04]
- It can be compiled from the [latest commit to master][03]
- It can be installed using the [latest release binary][02]

Packages in the AUR are maintained by the community. For more information on installing packages
from the AUR, see the [Arch Linux wiki][06] or [Using PowerShell in Docker][09].

## Kali

> [!NOTE]
> Kali support isn't officially supported by Microsoft and is maintained by the community.

### Installation - Kali

```sh
# Install PowerShell package
apt update && apt -y install powershell

# Start PowerShell
pwsh
```

### Uninstallation - Kali

```sh
# Uninstall PowerShell package
apt -y remove powershell
```

## Raspberry Pi OS

[Raspberry Pi OS][13] (formerly Raspbian) is a free operating system based on Debian.

> [!IMPORTANT]
> .NET isn't supported on ARMv6 architecture devices, including Raspberry Pi Zero and Raspberry Pi
> devices prior to Raspberry Pi 2.

### Install on Raspberry Pi OS

Download the tar.gz package from the [releases][12] page onto your Raspberry Pi computer. The links
to the current versions are:

- PowerShell 7.4.1 - latest LTS release
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-linux-arm32.tar.gz`
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-linux-arm64.tar.gz`
- PowerShell 7.3.11 - latest stable release
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-linux-arm32.tar.gz`
  - `https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-linux-arm64.tar.gz`

Use the following shell commands to download and install the package. This script detects whether
you are running a 32 or 64-bit OS and installs the latest stable version of PowerShell for that
processor type.

```sh
###################################
# Prerequisites

# Update package lists
sudo apt-get update

# Install dependencies
sudo apt-get install jq libssl1.1 libunwind8 -y

###################################
# Download and extract PowerShell

# Grab the latest tar.gz
bits=$(getconf LONG_BIT)
release=$(curl -sL https://api.github.com/repos/PowerShell/PowerShell/releases/latest)
package=$(echo $release | jq -r ".assets[].browser_download_url" | grep "linux-arm${bits}.tar.gz")
wget $package

# Make folder to put powershell
mkdir ~/powershell

# Unpack the tar.gz file
tar -xvf "./${package##*/}" -C ~/powershell

# Start PowerShell
~/powershell/pwsh
```

Optionally, you can create a symbolic link to start PowerShell without specifying the path to the
`pwsh` binary.

```sh
# Start PowerShell from bash with sudo to create a symbolic link
sudo ~/powershell/pwsh -command 'New-Item -ItemType SymbolicLink -Path "/usr/bin/pwsh" -Target "$PSHOME/pwsh" -Force'

# alternatively you can run following to create a symbolic link
# sudo ln -s ~/powershell/pwsh /usr/bin/pwsh

# Now to start PowerShell you can just run "pwsh"
```

### Uninstallation - Raspberry Pi OS

```sh
rm -rf ~/powershell
```

<!-- link references -->
[01]: ../community/community-support.md
[02]: https://aur.archlinux.org/packages/powershell-bin/
[03]: https://aur.archlinux.org/packages/powershell-git/
[04]: https://aur.archlinux.org/packages/powershell/
[05]: https://ubuntu.com/about/release-cycle
[06]: https://wiki.archlinux.org/title/Arch_User_Repository#Installing_and_upgrading_packages
[07]: https://www.archlinux.org/download/
[08]: install-ubuntu.md
[09]: powershell-in-docker.md
[10]: powershell-support-lifecycle.md
[12]: install-other-linux.md#binary-archives
[13]: https://www.raspberrypi.org/documentation/installation/installing-images/README.md

# /./reference/install/install-other-linux.md

    ---
    description: Information about installing PowerShell on various Linux distributions
    ms.date: 01/12/2024
    title: Alternate ways to install PowerShell on Linux
    ---
# Alternate ways to install PowerShell on Linux

All packages are available on our GitHub [releases][14] page. After the package is installed, run
`pwsh` from a terminal. Run `pwsh-preview` if you installed a preview release.

There are three other ways to install PowerShell on a Linux distribution:

- Install using a [Snap Package][11]
- Install using the [binary archives][09]
- Install as a [.NET Global tool][10]

## Snap Package

Snaps are application packages that are easy to install, secure, cross‐platform and dependency‐free.
Snaps are discoverable and installable from the Snap Store. Snap packages are supported the same as
the distribution you're running the package on.

> [!IMPORTANT]
> The Snap Store contains PowerShell snap packages for many Linux distributions that are not
> officially supported by Microsoft. For support, see the list of available [Community Support][08]
> options.

### Getting snapd

`snapd` is required to run snaps. Use [these instructions][15] to make sure you have `snapd`
installed.

### Installation via Snap

PowerShell for Linux is published to the [Snap store][17] for easy installation and updates.

The preferred method is as follows:

```sh
# Install PowerShell
sudo snap install powershell --classic

# Start PowerShell
pwsh
```

To install the latest LTS version, use the following method:

```sh
# Install PowerShell
sudo snap install powershell --channel=lts/stable --classic

# Start PowerShell
pwsh
```

To install a preview version, use the following method:

```sh
# Install PowerShell
sudo snap install powershell-preview --classic

# Start PowerShell
pwsh-preview
```

After installation, Snap will automatically upgrade. You can trigger an upgrade using
`sudo snap refresh powershell` or `sudo snap refresh powershell-preview`.

### Uninstallation

```sh
sudo snap remove powershell
```

or

```sh
sudo snap remove powershell-preview
```

## Binary Archives

PowerShell binary `tar.gz` archives are provided for Linux platforms to enable advanced deployment
scenarios.

> [!NOTE]
> You can use this method to install any version of PowerShell including the latest:
>
> - Stable release: [https://aka.ms/powershell-release?tag=stable][00]
> - LTS release: [https://aka.ms/powershell-release?tag=lts][12]
> - Preview release: [https://aka.ms/powershell-release?tag=preview][13]

### Dependencies

PowerShell builds portable binaries for all Linux distributions. But, .NET Core runtime requires
different dependencies on different distributions, and PowerShell does too.

It's possible that when you install PowerShell, specific dependencies may not be installed, such as
when manually installing from the binary archives. The following list details Linux distributions
that are supported by Microsoft and have dependencies you may need to install. Check the
distribution page for more information:

- [Alpine][01]
- [Debian][02]
- [RHEL][03]
- [SLES][04]
- [Ubuntu][05]

To deploy PowerShell binaries on Linux distributions that aren't officially supported, you need to
install the necessary dependencies for the target OS in separate steps. For example, our
[Amazon Linux dockerfile][16] installs dependencies first, and then extracts the Linux `tar.gz`
archive.

### Installation using a binary archive file

> [!IMPORTANT]
> This method can be used to install PowerShell on any version of Linux, including distributions
> that are not officially supported by Microsoft. Be sure to install any necessary dependencies. For
> support, see the list of available [Community Support][08] options.

The following example shows the steps for installing the x64 binary archive. You must choose the
correct binary archive that matches the processor type for your platform.

- `powershell-7.3.11-linux-arm32.tar.gz`
- `powershell-7.3.11-linux-arm64.tar.gz`
- `powershell-7.3.11-linux-x64.tar.gz`

Use the following shell commands to download and install PowerShell from the `tar.gz` binary
archive. Change the URL to match the version of PowerShell you want to install.

```sh
# Download the powershell '.tar.gz' archive
curl -L -o /tmp/powershell.tar.gz https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-linux-x64.tar.gz

# Create the target folder where powershell will be placed
sudo mkdir -p /opt/microsoft/powershell/7

# Expand powershell to the target folder
sudo tar zxf /tmp/powershell.tar.gz -C /opt/microsoft/powershell/7

# Set execute permissions
sudo chmod +x /opt/microsoft/powershell/7/pwsh

# Create the symbolic link that points to pwsh
sudo ln -s /opt/microsoft/powershell/7/pwsh /usr/bin/pwsh
```

### Uninstalling binary archives

```sh
sudo rm -rf /usr/bin/pwsh /opt/microsoft/powershell
```

## Install as a .NET Global tool

If you already have the [.NET Core SDK][06] installed, it's easy to install PowerShell
as a [.NET Global tool][07].

```sh
dotnet tool install --global PowerShell
```

The dotnet tool installer adds `~/.dotnet/tools` to your `PATH` environment variable. However, the
currently running shell does not have the updated `PATH`. You should be able to start PowerShell
from a new shell by typing `pwsh`.

<!-- link references -->
[00]: https://aka.ms/powershell-release?tag=stable
[01]: https://learn.microsoft.com/dotnet/core/install/linux-alpine#dependencies
[02]: https://learn.microsoft.com/dotnet/core/install/linux-debian#dependencies
[03]: https://learn.microsoft.com/dotnet/core/install/linux-rhel#dependencies
[04]: https://learn.microsoft.com/dotnet/core/install/linux-sles#dependencies
[05]: https://learn.microsoft.com/dotnet/core/install/linux-ubuntu#dependencies
[06]: https://learn.microsoft.com/dotnet/core/sdk
[07]: https://learn.microsoft.com/dotnet/core/tools/global-tools
[08]: https://learn.microsoft.com/powershell/scripting/community/community-support
[09]: #binary-archives
[10]: #install-as-a-net-global-tool
[11]: #snap-package
[12]: https://aka.ms/powershell-release?tag=lts
[13]: https://aka.ms/powershell-release?tag=preview
[14]: https://aka.ms/PowerShell-Release?tag=stable
[15]: https://docs.snapcraft.io/core/install
[16]: https://github.com/PowerShell/PowerShell-Docker/blob/master/release/unstable/amazonlinux/docker/Dockerfile
[17]: https://snapcraft.io/store

# /./reference/install/installing-powershell-on-macos.md

    ---
    description: Information about installing PowerShell on macOS
    ms.date: 01/12/2024
    title: Installing PowerShell on macOS
    ---

# Installing PowerShell on macOS

PowerShell 7 or higher requires macOS 11 and higher. All packages are available on our GitHub
[releases][09] page. After the package is installed, run `pwsh` from a terminal. Before installing,
check the list of [Supported versions][06] below.

> [!NOTE]
> PowerShell 7.4 is an in-place upgrade that removes previous versions of PowerShell 7. Preview
> versions of PowerShell can be installed side-by-side with other versions of PowerShell. If you
> need to run PowerShell 7.4 side-by-side with a previous version, reinstall the previous version
> using the [binary archive][04] method.

## Install the latest stable release of PowerShell

There are several ways to install PowerShell on macOS. Choose one of the following methods:

- Install using [Homebrew][10]. Homebrew is the preferred package manager for macOS.
- Install PowerShell via [Direct Download][04]
- Install from [binary archives][03].

If the `brew` command isn't found, you need to install Homebrew following [their instructions][10].

```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

Once `brew` is installed you can install PowerShell.

The following command installs the latest stable release of PowerShell:

```sh
brew install powershell/tap/powershell
```

Finally, verify that your install is working properly:

```sh
pwsh
```

When new versions of PowerShell are released, update Homebrew's formulae and upgrade PowerShell:

```sh
brew update
brew upgrade powershell
```

> [!NOTE]
> The commands above can be called from within a PowerShell (pwsh) host, but then the PowerShell
> shell must be exited and restarted to complete the upgrade and refresh the values shown in
> `$PSVersionTable`.

[brew]: https://brew.sh/

## Install the latest preview release of PowerShell

After you've installed Homebrew, you can install PowerShell.

```sh
brew install powershell/tap/powershell-preview
```

Run the following command to start the preview version of PowerShell:

```sh
pwsh-preview
```

When new versions of PowerShell are released, update Homebrew's formulae and upgrade PowerShell:

```sh
brew update
brew upgrade powershell-preview
```

> [!NOTE]
> The commands above can be called from within a PowerShell (pwsh) host, but then the PowerShell
> shell must be exited and restarted to complete the upgrade. and refresh the values shown in
> `$PSVersionTable`.

## Install the latest LTS release of PowerShell

```sh
brew install powershell/tap/powershell-lts
```

You can now verify your install

```sh
pwsh
```

When new versions of PowerShell are released, run the following command.

```sh
brew upgrade powershell-lts
```

> [!NOTE]
> Whether you use the cask or the tap method, when updating to a newer version of PowerShell, use
> the same method you used to initially install PowerShell. If you use a different method, opening a
> new pwsh session will continue to use the older version of PowerShell.
>
> If you do decide to use different methods, there are ways to correct the issue using the
> [Homebrew link method][11].

## Installation via Direct Download

Starting with version 7.2, PowerShell supports the Apple M1 processor. Download the install package
from the [releases][09] page onto your computer. The links to the current versions are:

- PowerShell 7.4.1
  - x64 processors - [powershell-7.4.1-osx-x64.pkg][24]
  - M1 processors - [powershell-7.4.1-osx-arm64.pkg][22]
- PowerShell 7.3.11
  - x64 processors - [powershell-7.3.11-osx-x64.pkg][20]
  - M1 processors - [powershell-7.3.11-osx-arm64.pkg][18]
- PowerShell 7.2.18 (LTS)
  - x64 processors - [powershell-7.2.18-osx-x64.pkg][16]
  - M1 processors - [powershell-7.2.18-osx-arm64.pkg][14]

You can double-click the file and follow the prompts, or install it from the terminal using the
following commands. Change the name of the file to match the file you downloaded.

```sh
sudo installer -pkg ./Downloads/powershell-7.4.1-osx-x64.pkg -target /
```

If you are running on macOS Big Sur 11.5 or higher you may receive the following error message
when installing the package:

> "powershell-7.4.1-osx-x64.pkg" cannot be opened because Apple cannot check it for malicious
> software.

There are two ways to work around this issue:

Using the Finder

1. Find the package in Finder.
1. Control-click (click while pressing the <kbd>Ctrl</kbd> key) on the package.
1. Select **Open** from the context menu.

From the command line

1. Run `sudo xattr -rd com.apple.quarantine ./Downloads/powershell-7.4.1-osx-x64.pkg`. If you are using
   PowerShell 7 or higher, you can use the `Unblock-File` cmdlet. Include the full path to the
   `.pkg` file.
1. Install the package as you normally would.

> [!NOTE]
> This is a known issue related to package notarization that will be addressed in the future.

## Install as a .NET Global tool

If you already have the [.NET Core SDK][01] installed, it's easy to install PowerShell as a
[.NET Global tool][02].

```
dotnet tool install --global PowerShell
```

The dotnet tool installer adds `~/.dotnet/tools` to your `PATH` environment variable. However, the
currently running shell doesn't have the updated `PATH`. You should be able to start PowerShell from
a new shell by typing `pwsh`.

## Binary Archives

PowerShell binary `tar.gz` archives are provided for the macOS platform to enable advanced
deployment scenarios. When you install using this method you must also manually install any
dependencies.

> [!NOTE]
> You can use this method to install any version of PowerShell including the latest:
>
> - Stable release: [https://aka.ms/powershell-release?tag=stable][09]
> - LTS release: [https://aka.ms/powershell-release?tag=lts][07]
> - Preview release: [https://aka.ms/powershell-release?tag=preview][08]

### Installing binary archives on macOS

Download the install package from the [releases][09] page onto your computer. The links to the
current versions are:

- PowerShell 7.4 (LTS)
  - x64 processors - [powershell-7.4.1-osx-x64.tar.gz][25]
  - M1 processors - [powershell-7.4.1-osx-arm64.tar.gz][23]
- PowerShell 7.3 (stable)
  - x64 processors - [powershell-7.3.11-osx-x64.tar.gz][21]
  - M1 processors - [powershell-7.3.11-osx-arm64.tar.gz][19]
- PowerShell 7.2 (LTS)
  - x64 processors - [powershell-7.2.18-osx-x64.tar.gz][17]
  - M1 processors - [powershell-7.2.18-osx-arm64.tar.gz][15]

Use the following commands to install PowerShell from the binary archive. Change the download URL to
match the version you want to install.

```sh
# Download the powershell '.tar.gz' archive
curl -L -o /tmp/powershell.tar.gz https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-osx-x64.tar.gz

# Create the target folder where powershell is placed
sudo mkdir -p /usr/local/microsoft/powershell/7

# Expand powershell to the target folder
sudo tar zxf /tmp/powershell.tar.gz -C /usr/local/microsoft/powershell/7

# Set execute permissions
sudo chmod +x /usr/local/microsoft/powershell/7/pwsh

# Create the symbolic link that points to pwsh
sudo ln -s /usr/local/microsoft/powershell/7/pwsh /usr/local/bin/pwsh
```

## Uninstalling PowerShell

If you installed PowerShell with Homebrew, use the following command to uninstall:

```sh
brew uninstall --cask powershell
```

If you installed PowerShell via direct download, PowerShell must be removed manually:

```sh
sudo rm -rf /usr/local/bin/pwsh /usr/local/microsoft/powershell
```

To remove the additional PowerShell paths, refer to the [paths][05] section in this document and
remove the paths using `sudo rm`.

> [!NOTE]
> This isn't necessary if you installed with Homebrew.

## Paths

- `$PSHOME` is `/usr/local/microsoft/powershell/7`
  - The macOS install package creates a symbolic link, `/usr/local/bin/pwsh` that points to `pwsh`
    in the `$PSHOME` location.
- User profiles are read from `~/.config/powershell/profile.ps1`
- Default profiles are read from `$PSHOME/profile.ps1`
- User modules are read from `~/.local/share/powershell/Modules`
- Shared modules are read from `/usr/local/share/powershell/Modules`
- Default modules are read from `$PSHOME/Modules`
- PSReadLine history are recorded to `~/.local/share/powershell/PSReadLine/ConsoleHost_history.txt`

PowerShell respects the [XDG Base Directory Specification][26] on macOS.

## Supported versions

[!INCLUDE [macOS support](../../includes/macos-support.md)]

## Installation support

Microsoft supports the installation methods in this document. There may be other methods of
installation available from other sources. While those tools and methods may work, Microsoft can't
support those methods.

## Additional Resources

- [Homebrew Web][10]
- [Homebrew GitHub Repository][12]
- [Homebrew-Cask][13]

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/core/sdk
[02]: https://learn.microsoft.com/dotnet/core/tools/global-tools
[03]: #binary-archives
[04]: #installation-via-direct-download
[05]: #paths
[06]: #supported-versions
[07]: https://aka.ms/powershell-release?tag=lts
[08]: https://aka.ms/powershell-release?tag=preview
[09]: https://aka.ms/powershell-release?tag=stable
[10]: https://brew.sh/
[11]: https://docs.brew.sh/Manpage#link-ln-options-formula
[12]: https://github.com/Homebrew
[13]: https://github.com/Homebrew/homebrew-cask
[14]: https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell-7.2.18-osx-arm64.pkg
[15]: https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell-7.2.18-osx-arm64.tar.gz
[16]: https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell-7.2.18-osx-x64.pkg
[17]: https://github.com/PowerShell/PowerShell/releases/download/v7.2.18/powershell-7.2.18-osx-x64.tar.gz
[18]: https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-osx-arm64.pkg
[19]: https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-osx-arm64.tar.gz
[20]: https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-osx-x64.pkg
[21]: https://github.com/PowerShell/PowerShell/releases/download/v7.3.11/powershell-7.3.11-osx-x64.tar.gz
[22]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-osx-arm64.pkg
[23]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-osx-arm64.tar.gz
[24]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-osx-x64.pkg
[25]: https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/powershell-7.4.1-osx-x64.tar.gz
[26]: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html

# /./reference/install/powershell-on-arm.md

    ---
    description: PowerShell on Arm-based systems
    ms.date: 02/05/2024
    title: PowerShell on Arm-based systems
    ---

# PowerShell on Arm processors

Support for the Arm processor is based on the support policy of the version of .NET that PowerShell
uses. While .NET supports many more operating systems and versions, PowerShell support is limited to
the versions that have been tested.

It may be possible to use Arm-based versions of PowerShell on other Linux distributions and
versions, but we don't officially support it.

## PowerShell 7.4

Arm versions of PowerShell 7.4 can be installed on the following platforms:

|                OS                | Architectures |               Lifecycle                |
| -------------------------------- | ------------- | -------------------------------------- |
| Windows 11 Client Version 22000+ | Arm64         | [Windows][06]                          |
| Windows 10 Client Version 1607+  | Arm64         | [Windows][06]                          |
| macOS 10.15+                     | Arm64         | [macOS][05]                            |
| Raspberry Pi OS (Debian 10)      | Arm32         | [Raspberry Pi OS][09] and [Debian][07] |
| Ubuntu 22.04, 20.04, 18.04       | Arm32         | [Ubuntu][08]                           |

Support is based on the [.NET 8.0 Supported OS Lifecycle Policy][04].

## PowerShell 7.3

Arm versions of PowerShell 7.3 can be installed on the following platforms:

|                OS                | Architectures |               Lifecycle                |
| -------------------------------- | ------------- | -------------------------------------- |
| Windows 11 Client Version 22000+ | Arm64         | [Windows][06]                          |
| Windows 10 Client Version 1607+  | Arm64         | [Windows][06]                          |
| macOS 10.15+                     | Arm64         | [macOS][05]                            |
| Raspberry Pi OS (Debian 10)      | Arm32         | [Raspberry Pi OS][09] and [Debian][07] |
| Ubuntu 22.04, 20.04, 18.04       | Arm32         | [Ubuntu][08]                           |

Support is based on the [.NET 7.0 Supported OS Lifecycle Policy][03].

## PowerShell 7.2

Arm versions of PowerShell 7.2 can be installed on the following platforms:

|                OS                | Architectures |               Lifecycle                |
| -------------------------------- | ------------- | -------------------------------------- |
| Windows 11 Client Version 22000+ | Arm64         | [Windows][06]                          |
| Windows 10 Client Version 1607+  | Arm64         | [Windows][06]                          |
| macOS 10.14+                     | Arm64         | [macOS][05]                            |
| Raspberry Pi OS (Debian 10)      | Arm32         | [Raspberry Pi OS][09] and [Debian][07] |
| Ubuntu 22.04, 20.04, 18.04       | Arm32         | [Ubuntu][08]                           |

Support is based on the [.NET 6.0 Supported OS Lifecycle Policy][02].

## Installing PowerShell on Arm-based systems

For installation instructions, see the following articles:

Windows

- [Windows 10 on Arm][14]
- [Windows 10 IoT Enterprise][13]
- [Windows 10 IoT Core][12]

Linux - install from the binary archives

- [Alternate ways to install PowerShell on Linux][10]

macOS

- [Installing PowerShell on macOS][11]

Raspbery Pi

- [Raspberry Pi OS][01]

<!-- link references -->
[01]: community-support.md#raspberry-pi-os
[02]: https://github.com/dotnet/core/blob/main/release-notes/6.0/supported-os.md
[03]: https://github.com/dotnet/core/blob/main/release-notes/7.0/supported-os.md
[04]: https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md
[05]: https://support.apple.com/macos
[06]: https://support.microsoft.com/help/13853/windows-lifecycle-fact-sheet
[07]: https://wiki.debian.org/DebianReleases
[08]: https://wiki.ubuntu.com/Releases
[09]: https://www.raspberrypi.com/software/operating-systems/
[10]: install-other-linux.md#binary-archives
[11]: installing-powershell-on-macos.md
[12]: installing-powershell-on-windows.md#deploying-on-windows-10-iot-core
[13]: installing-powershell-on-windows.md#deploying-on-windows-10-iot-enterprise
[14]: installing-powershell-on-windows.md#installing-the-zip-package

# /./reference/install/PowerShell-in-Docker.md

    ---
    description: How to use PowerShell that's preinstalled in a Docker image.
    ms.date: 02/05/2024
    ms.devlang: powershell
    ms.topic: conceptual
    title: Using PowerShell in Docker
    ---

# Using PowerShell in Docker

We publish Docker images with PowerShell preinstalled. This article shows you how to get
started using PowerShell in the Docker container.

## Finding available images

The released images require Docker 17.05 or newer. It's also expected that you are able to run
Docker without `sudo` or local administrative rights. Please follow Docker's official
[instructions][01] to install `docker` correctly.

The release containers derive from the official distribution image, then install dependencies, and
finally install the PowerShell package.

These containers live at [Microsoft Artifact Registry][05].

For more information about these Docker images, visit the [PowerShell-Docker][02] repository on
GitHub.

## Using PowerShell in a container

The following steps show the Docker commands required to download the image containing the latest
available stable version of PowerShell and start an interactive PowerShell session.

```console
docker run -it mcr.microsoft.com/powershell
```

Use the following command to download and run the image containing the latest available preview
version of PowerShell.

```console
docker run -it mcr.microsoft.com/powershell:preview
```

### Remove the image when no longer needed

The following command is used to delete the Docker image when you no longer need it.

```console
docker rmi mcr.microsoft.com/powershell
```

## Legal and Licensing

PowerShell is licensed under the [MIT license][03].

### Windows Docker file and image licenses

By requesting and using the Container OS Image for Windows containers, you acknowledge, understand,
and consent to the Supplemental License Terms available on Docker hub:

- [Window Server Core][06]
- [Nano Server][04]

### Telemetry

By default, PowerShell collects limited telemetry without personally identifiable information to
help aid development of future versions of PowerShell. To opt-out of sending telemetry, create an
environment variable called `POWERSHELL_TELEMETRY_OPTOUT` set to a value of `1` before starting
PowerShell from the installed location. The telemetry we collect falls under the
[Microsoft Privacy Statement][07].

<!-- link references -->
[01]: https://docs.docker.com/engine/installation/
[02]: https://github.com/PowerShell/PowerShell-Docker
[03]: https://github.com/PowerShell/PowerShell/tree/master/LICENSE.txt
[04]: https://mcr.microsoft.com/product/windows/nanoserver
[05]: https://mcr.microsoft.com/product/powershell
[06]: https://mcr.microsoft.com/product/windows/servercore
[07]: https://privacy.microsoft.com/privacystatement/

# /./reference/learn/ps101/00-introduction.md

    ---
    description: This is the introduction of the book PowerShell 101 by Mike F. Robbins.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: Introduction
    ---
# Introduction

<table>
  <tr><td>
  <a href="https://leanpub.com/powershell101">
  <img src="https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/powershell101-150x194.png" alt="PowerShell 101 (the book)" />
  </a>
  </td>
  <td colspan=2>
  This content originally appeared in the book <em>PowerShell 101</em> by Mike F Robbins. We thank
  Mike for granting us permission to reuse his content here. The content has been edited from the
  original publication. You can still get the original book from Leanpub at
  <a href="https://leanpub.com/powershell101">PowerShell 101</a>.
  </td></tr>
</table>

## Who is this book for?

This is an entry-level book for anyone wanting to learn PowerShell.

This book focuses on PowerShell version 5.1 running on Windows 10 and Windows Server 2016 in a
Microsoft Active Directory domain environment. However, the basic concepts apply to all versions of
PowerShell running on any supported platform.

## About this book

This book is a collection of what I wish someone would have told me when I started learning
PowerShell, along with the tips, tricks, and best practices that I've learned while using PowerShell
during the past 10 years.

Instead of providing an enormous amount of information, this book attempts to provide a balance of
enough information to be successful for someone who is just getting started with PowerShell. Each
chapter contains links to specific help topics for those who want more information about the topics
covered in that chapter.

## About the author

Mike F Robbins is a former Microsoft MVP, co-author of _Windows PowerShell TFM 4th Edition_, and a
contributing author in the _PowerShell Deep Dives_ book. Mike has been a strong supporter of the
PowerShell community and is now the lead writer for [Azure PowerShell][Azure PowerShell] at Microsoft. He blogs at
[mikefrobbins.com][mikefrobbins.com] and can be found on twitter [@mikefrobbins][@mikefrobbins].

## Lab environment

The examples in this book were designed and tested on Windows 10 Anniversary Edition (build 1607)
and Windows Server 2016 using PowerShell version 5.1. If you're using a different version of
PowerShell or operating system, your results may differ from those shown here.

<!-- link references -->
[@mikefrobbins]: https://twitter.com/mikefrobbins
[mikefrobbins.com]: https://mikefrobbins.com/
[PowerShell 101]: https://leanpub.com/powershell101
[Azure PowerShell]: https://learn.microsoft.com/powershell/azure

# /./reference/learn/ps101/01-getting-started.md

    ---
    description: Where to find and how to launch PowerShell for new users.
    ms.custom: Contributor-mikefrobbins
    ms.date: 11/16/2022
    ms.reviewer: mirobb
    title: Getting Started with PowerShell
    ---
# Chapter 1 - Getting Started with PowerShell

I often find that presenters at conferences and user group meetings already have PowerShell running
when they start entry-level presentations. This book begins by answering the questions I've heard
attendees who haven't previously used PowerShell ask in those sessions.

Specifically, this chapter focuses on finding and launching PowerShell, and solving some of the
initial pain points that new users experience with PowerShell. Be sure to follow along and
walk through the examples shown in this chapter on your Windows 10 lab environment computer.

## What do I need to get started with PowerShell?

All modern versions of Windows operating systems ship with PowerShell installed. If you're running a version older than 5.1, you should install the latest version.

- To upgrade to Windows PowerShell 5.1, see [Upgrading existing Windows PowerShell][Upgrading existing Windows PowerShell]
- To install the latest version of PowerShell, see [Installing PowerShell][Installing PowerShell]

## Where do I find PowerShell?

The easiest way to find PowerShell on Windows 10 is to type **PowerShell** into the search bar as
shown in Figure 1-1.

![Figure 1-1 - Search for PowerShell in the Start Menu](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-1.png)

Notice that four different shortcuts for PowerShell are shown in Figure 1-1. The computer used for
demonstration purposes in this book is running the 64-bit version of Windows 10 so there's a 64-bit
version of the PowerShell console and the PowerShell ISE (Integrated Scripting Environment), and a
32-bit version of each one as denoted by the (x86) suffix on the shortcuts. If you happen to be
running a 32-bit version of Windows 10, you'll only have two shortcuts. Those items don't have the
(x86) suffix, but are 32-bit versions. If you have a 64-bit operating system, my recommendation is
to run the 64-bit version of PowerShell unless you have a specific reason for running the 32-bit
version.

For information about starting PowerShell on other versions of Windows, see
[Starting Windows PowerShell][Starting Windows PowerShell].

## How do I launch PowerShell?

In the production enterprise environments that I support, I use three different Active Directory
user accounts. I've mirrored those accounts in the lab environment used in this book. I log into the
Windows 10 computer as a domain user who is not a domain or local administrator.

I've launched the PowerShell console by clicking on the "Windows PowerShell" shortcut as shown in
Figure 1-1.

![Figure 1-4 - Title bar of the PowerShell window](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-4.png)

Notice that the title bar of the PowerShell console says "Windows PowerShell" as shown in Figure
1-4. Some commands run fine, but PowerShell can't participate in User Access Control (UAC). That
means it's unable to prompt for elevation for tasks that require the approval of an administrator.
The following error message is generated:

```powershell
Get-Service -Name W32Time | Stop-Service
```

```Output
Stop-Service : Service 'Windows Time (W32Time)' cannot be stopped due to the following
error: Cannot open W32Time service on computer '.'.
At line:1 char:29
+ Get-Service -Name W32Time | Stop-Service
+
    + CategoryInfo          : CloseError: (System.ServiceProcess.ServiceController:ServiceController)
     [Stop-Service], ServiceCommandException
    + FullyQualifiedErrorId : CouldNotStopService,Microsoft.PowerShell.Commands.StopServiceCommand
```

The solution to this problem is to run PowerShell as a domain user who is a local administrator.
This is how my second domain user account is configured. Using the principle of least privilege,
this account should NOT be a domain administrator, or have any elevated privileges in the domain.

Close PowerShell. Relaunch the PowerShell console, except this time right-click on the **Windows
PowerShell** shortcut and select **Run as administrator** as shown in Figure 1-5.

![Figure 1-5 - Context menu - Run as administrator](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-5.png)

If you're logged into Windows as a normal user, you'll be prompted for credentials. I'll enter the
credentials for my user account who is a domain user and local admin as shown in Figure 1-6.

![Figure 1-6](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-6.png)

Once PowerShell is relaunched as an administrator, the title bar should say "Administrator: Windows
PowerShell" as shown in Figure 1-7.

![Figure 1-7](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-7.png)

Now that PowerShell is being run elevated as a local administrator, UAC will no longer be a problem
when a command is run on the local computer that would normally require a prompt for elevation. Keep
in mind though that any command run from this elevated instance of the PowerShell console, also runs
elevated.

To simplify finding PowerShell and launching it as an administrator, I recommend pinning it to the
taskbar and setting it to automatically launch as an admin each time it's run.

Search for PowerShell again, except this time right-click on it and select "Pin to taskbar" as shown
in Figure 1-8.

![Figure 1-8](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-8.png)

Right-click on the PowerShell shortcut that's now pinned to the taskbar and select properties as
shown in Figure 1-9.

![Figure 1-9 - User account control - enter credentials](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-9.png)

Click on "Advanced" as denoted by #1 in Figure 1-10, then check the "Run as administrator" checkbox
as denoted by #2 in Figure 1-10, and then click OK twice to accept the changes and exit out of both
dialog boxes.

![Figure 1-10 - Title bar showing "Administrator"](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/ps101/media/figure1-10.png)

You'll never have to worry about finding PowerShell or whether or not it's running as an
administrator again.

Running PowerShell elevated as an administrator to prevent having problems with UAC only impacts
commands that are run against the local computer. It has no effect on commands that target remote
computers.

## What version of PowerShell am I running?

There are a number of automatic variables in PowerShell that store state information. One of these
variables is `$PSVersionTable`, which contains a hashtable that can be used to display the relevant
PowerShell version information:

```powershell
$PSVersionTable
```

```Output
Name                           Value
----                           -----
PSVersion                      5.1.19041.1
PSEdition                      Desktop
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}
BuildVersion                   10.0.19041.1
CLRVersion                     4.0.30319.42000
WSManStackVersion              3.0
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1
```

Newer versions of Windows PowerShell are distributed as part of the Windows Management Framework
(WMF). A specific version of the .NET Framework is required depending on the WMF version. To upgrade
to Windows PowerShell 5.1, see [Upgrading existing Windows PowerShell][Upgrading existing Windows PowerShell].

## Execution Policy

Contrary to popular belief, the execution policy in PowerShell is not a security boundary. It's
designed to prevent a user from unknowingly running a script. A determined user can easily bypass
the execution policy in PowerShell. Table 1-2 shows the default execution policy for current
Windows operating systems.

| Windows Operating System Version | Default Execution Policy |
| -------------------------------- | ------------------------ |
| Server 2019                      | Remote Signed            |
| Server 2016                      | Remote Signed            |
| Windows 10                       | Restricted               |

Regardless of the execution policy setting, any PowerShell command can be run interactively. The
execution policy only affects commands running in a script. The `Get-ExecutionPolicy` cmdlet is used
to determine what the current execution policy setting is and the `Set-ExecutionPolicy` cmdlet is
used to change the execution policy. My recommendation is to use the **RemoteSigned** policy, which
requires downloaded scripts to be signed by a trusted publisher in order to be run.

Check the current execution policy:

```powershell
Get-ExecutionPolicy
```

```Output
Restricted
```

PowerShell scripts can't be run at all when the execution policy is set to **Restricted**. This is
the default setting on all Windows client operating systems. To demonstrate the problem, save the
following code as a `.ps1` file named `Stop-TimeService.ps1`.

> [!TIP]
> A PowerShell script is a plaintext file with a `.ps1` extension that contains the commands you
> want to run. To create a PowerShell script, use a code editor like Visual Studio Code (VS Code) or
> any text editor such as Notepad.

```powershell
Get-Service -Name W32Time | Stop-Service -PassThru
```

That command runs interactively without error as long as PowerShell is run elevated as an
administrator. But as soon as it's saved as a script file and you try to execute the script, it
generates an error:

```powershell
.\Stop-TimeService.ps1
```

```Output
.\Stop-TimeService.ps1 : File C:\demo\Stop-TimeService.ps1 cannot be loaded because
running scripts is disabled on this system. For more information, see
about_Execution_Policies at http://go.microsoft.com/fwlink/?LinkID=135170.
At line:1 char:1
+ .\Stop-TimeService.ps1
+
    + CategoryInfo          : SecurityError: (:) [], PSSecurityException
    + FullyQualifiedErrorId : UnauthorizedAccess
```

Notice that the error shown in the previous set of results tells you exactly what the problem is
(running scripts is disabled on this system). When you run a command in PowerShell that generates an
error message, be sure to read the error message instead of just rerunning the command and hoping
that it runs successfully.

Change the PowerShell execution policy to remote signed.

```powershell
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
```

```Output
Execution Policy Change
The execution policy helps protect you from scripts that you do not trust. Changing the execution
policy might expose you to the security risks described in the about_Execution_Policies help topic
at http://go.microsoft.com/fwlink/?LinkID=135170. Do you want to change the execution policy?
[Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is "N"):y
```

Be sure to read the warning that's displayed when changing the execution policy. I also recommend
taking a look at the [about_Execution_Policies][about_Execution_Policies] help topic to make sure you understand the
security implications of changing the execution policy.

Now that the execution policy has been set to **RemoteSigned**, the `Stop-TimeService.ps1` script
runs error free.

```powershell
.\Stop-TimeService.ps1
```

```Output
Status   Name               DisplayName
------   ----               -----------
Stopped  W32Time            Windows Time
```

Be sure to start your Windows Time service before continuing otherwise you may run into unforeseen
problems.

```powershell
Start-Service -Name w32time
```

## Summary

In this chapter, you've learned how to find and launch PowerShell, and how to create a shortcut that
launches PowerShell as an administrator. You've also learned about the default execution policy and
how to change it.

## Review

1. How do you determine what PowerShell version a computer is running?
1. Why is it important to launch PowerShell elevated as an administrator?
1. How do you determine the current PowerShell execution policy?
1. What does the default PowerShell execution policy on Windows client computers prevent from
   occurring?
1. How do you change the PowerShell execution policy?

## Recommended Reading

For those who want to know more information about the topics covered in this chapter, I recommend
reading the following PowerShell help topics.

- [about_Automatic_Variables][about_Automatic_Variables]
- [about_Hash_Tables][about_Hash_Tables]
- [about_Execution_Policies][about_Execution_Policies]

In the next chapter, you'll learn about the discoverability of commands in PowerShell. One of the
things that will be covered is how to update PowerShell so those help topics can be viewed right
from within PowerShell instead of having to view them on the internet.

<!-- link references -->
[about_Automatic_Variables]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_automatic_variables
[about_Hash_Tables]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_hash_tables
[about_Execution_Policies]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_execution_policies
[Upgrading existing Windows PowerShell]: https://learn.microsoft.com/powershell/scripting/windows-powershell/install/installing-windows-powershell#upgrading-existing-windows-powershell
[Installing PowerShell]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell
[Starting Windows PowerShell]: https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell

# /./reference/learn/ps101/02-help-system.md

    ---
    description: Mastering the help system is the key to being successful with PowerShell.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: The Help System
    ---
# Chapter 2 - The Help System

Two groups of IT pros were given a written test without access to a computer to determine their
skill level with PowerShell. PowerShell beginners were placed in one group and experts in another.
Based on the results of the test, there didn't seem to be much difference in the skill level between
the two groups. Both groups were given a second test similar to the first one. This time they were
given access to a computer with PowerShell that didn't have access to the internet. The results of
the second test showed a huge difference in the skill level between the two groups. Experts don't
always know the answers, but they know how to figure out the answers.

What was the difference in the results of the first and second test between these two groups?

The differences observed in these two tests were because experts don't memorize how to use thousands
of commands in PowerShell. They learn how to use the help system within PowerShell extremely well.
This allows them to find the necessary commands when needed and how to use those commands once
they've found them.

I've heard Jeffrey Snover, the inventor of PowerShell, tell a similar story a number of times.

Mastering the help system is the key to being successful with PowerShell.

## Discoverability

Compiled commands in PowerShell are called cmdlets. Cmdlet is pronounced "command-let" (not
CMD-let). Cmdlets names have the form of singular "Verb-Noun" commands to make them easily
discoverable. For example, the cmdlet for determining what processes are running is `Get-Process`
and the cmdlet for retrieving a list of services and their statuses is `Get-Service`. There are
other types of commands in PowerShell such as aliases and functions that will be covered later in
this book. The term PowerShell command is a generic term that's often used to refer to any type of
command in PowerShell, regardless of whether or not it's a cmdlet, function, or alias.

## The Three Core Cmdlets in PowerShell

- `Get-Command`
- `Get-Help`
- `Get-Member` (covered in chapter 3)

One question I'm often asked is how do you figure out what the commands are in PowerShell? Both
`Get-Command` and `Get-Help` can be used to determine the commands.

## Get-Help

`Get-Help` is a multipurpose command. `Get-Help` helps you learn how to use commands once you find
them. `Get-Help` can also be used to help locate commands, but in a different and more indirect way
when compared to `Get-Command`.

When `Get-Help` is used to locate commands, it first searches for wildcard matches of command names
based on the provided input. If it doesn't find a match, it searches through the help topics
themselves, and if no match is found an error is returned. Contrary to popular belief, `Get-Help`
can be used to find commands that don't have help topics.

The first thing you need to know about the help system in PowerShell is how to use the `Get-Help`
cmdlet. The following command is used to display the help topic for `Get-Help`.

```powershell
Get-Help -Name Get-Help
```

```Output
Do you want to run Update-Help?
The Update-Help cmdlet downloads the most current Help files for Windows PowerShell
modules, and installs them on your computer. For more information about the Update-Help
cmdlet, see http://go.microsoft.com/fwlink/?LinkId=210614.
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"):
```

Beginning with PowerShell version 3, PowerShell help doesn't ship with the operating system. The
first time `Get-Help` is run for a command, the previous message is displayed. If the `help`
function or `man` alias is used instead of the `Get-Help` cmdlet, you don't receive this prompt.

Answering yes by pressing <kbd>Y</kbd> runs the `Update-Help` cmdlet, which requires internet access
by default. `Y` can be specified in either upper or lower case.

Once the help is downloaded and the update is complete, the help topic is returned for the specified
command:

```powershell
Get-Help -Name Get-Help
```

Take a moment to run that example on your computer, review the output, and take note of how the
information is grouped:

- NAME
- SYNOPSIS
- SYNTAX
- DESCRIPTION
- RELATED LINKS
- REMARKS

As you can see, help topics can contain an enormous amount of information and this isn't even the
entire help topic.

While not specific to PowerShell, a parameter is a way to provide input to a command. `Get-Help` has
many parameters that can be specified in order to return the entire help topic or a subset of
it.

The syntax section of the help topic shown in the previous set of results lists all of the
parameters for `Get-Help`. At first glance, it appears the same parameters are listed six different
times. Each of those different blocks in the syntax section is a parameter set. This means the
`Get-Help` cmdlet has six different parameter sets. If you take a closer look, you'll notice that at
least one parameter is different in each of the parameter sets.

Parameter sets are mutually exclusive. Once a unique parameter that only exists in one of the
parameter sets is used, only parameters contained within that parameter set can be used. For
example, both the **Full** and **Detailed** parameters couldn't be specified at the same time
because they are in different parameter sets.

Each of the following parameters are in different parameter sets:

- Full
- Detailed
- Examples
- Online
- Parameter
- ShowWindow

All of the cryptic syntax such as square and angle brackets in the syntax section means something
but will be covered in Appendix A of this book. While important, learning the cryptic syntax is
often difficult to retain for someone who is new to PowerShell and may not use it everyday.

For more information to better understand the cryptic syntax, see [Appendix A][Appendix A].

For beginners, there's an easier way to figure out the same information except in plain language.

When the **Full** parameter of `Get-Help` is specified, the entire help topic is returned.

```powershell
Get-Help -Name Get-Help -Full
```

Take a moment to run that example on your computer, review the output, and take note of how the
information is grouped:

- NAME
- SYNOPSIS
- SYNTAX
- DESCRIPTION
- PARAMETERS
- INPUTS
- OUTPUTS
- NOTES
- EXAMPLES
- RELATED LINKS

Notice that using the **Full** parameter returned several additional sections, one of which is the
PARAMETERS section that provides more information than the cryptic SYNTAX section.

The **Full** parameter is a switch parameter. A parameter that doesn't require a value is called a
switch parameter. When a switch parameter is specified, its value is true and when it's not, its
value is false.

If you've been working through this chapter in the PowerShell console, you noticed that the previous
command to display the full help topic for `Get-Help` flew by on the screen without giving you a
chance to read it. There's a better way.

`Help` is a function that pipes `Get-Help` to a function named `more`, which is a wrapper for the
`more.com` executable file in Windows. In the PowerShell console, `help` provides one page of help
at a time. In the ISE, it works the same way as `Get-Help`. My recommendation is to use the `help`
function instead of the `Get-Help` cmdlet since it provides a better experience and it's less to
type.

Less typing isn't always a good thing, however. If you're going to save your commands as a script or
share them with someone else, be sure to use full cmdlet and parameter names. The full names are
self-documenting, which makes them easier to understand. Think about the next person that has to
read and understand your commands. It could be you. Your coworkers and future self will thank you.

Try running the following commands in the PowerShell console on your Windows 10 lab environment
computer.

```powershell
Get-Help -Name Get-Help -Full
help -Name Get-Help -Full
help Get-Help -Full
```

Did you notice any differences in the output from the previously listed commands when you ran them
on your Windows 10 lab environment computer?

There aren't any differences other than the last two options return the results one page at a time.
The <kbd>spacebar</kbd> is used to display the next page of content when using the `Help` function
and <kbd>Ctrl</kbd>+<kbd>C</kbd> cancels commands that are running in the PowerShell console.

The first example uses the `Get-Help` cmdlet, the second uses the `Help` function, and the third
omits the **Name** parameter when using the `Help` function. **Name** is a positional parameter and
it's being used positionally in that example. This means the value can be specified without
specifying the parameter name, as long as the value itself is specified in the correct position. How
did I know what position to specify the value in? By reading the help as shown in the following
example.

```powershell
help Get-Help -Parameter Name
```

```Output
-Name <String>
    Gets help about the specified command or concept. Enter the name of a cmdlet, function,
    provider, script, or workflow, such as Get-Member, a conceptual article name, such as
    about_Objects, or an alias, such as ls. Wildcard characters are permitted in cmdlet and
    provider names, but you can't use wildcard characters to find the names of function help and
    script help articles.

    To get help for a script that isn't located in a path that's listed in the $env:Path
    environment variable, type the script's path and file name.

    If you enter the exact name of a help article, Get-Help displays the article contents.

    If you enter a word or word pattern that appears in several help article titles, Get-Help
    displays a list of the matching titles.

    If you enter a word that doesn't match any help article titles, Get-Help displays a list of
    articles that include that word in their contents.

    The names of conceptual articles, such as about_Objects, must be entered in English, even in
    non-English versions of PowerShell.

    Required?                    false
    Position?                    0
    Default value                None
    Accept pipeline input?       True (ByPropertyName)
    Accept wildcard characters?  true
```

Notice that in the previous example, the **Parameter** parameter was used with the Help function to
only return information from the help topic for the **Name** parameter. This is much more concise
than trying to manually sift through what sometimes seems like a hundred page help topic.

Based on those results, you can see that the **Name** parameter is positional and must be specified
in position zero (the first position) when used positionally. The order that parameters are
specified in doesn't matter if the parameter name is specified.

One other important piece of information is that the **Name** parameter expects the datatype for its
value to be a single string, which is denoted by `<String>`. If it accepted multiple strings, the
datatype would be listed as `<String[]>`.

Sometimes you simply don't want to display the entire help topic for a command. There are a number
of other parameters besides **Full** that can be specified with `Get-Help` or `Help`. Try running
the following commands on your Windows 10 lab environment computer:

```powershell
Get-Help -Name Get-Command -Full
Get-Help -Name Get-Command -Detailed
Get-Help -Name Get-Command -Examples
Get-Help -Name Get-Command -Online
Get-Help -Name Get-Command -Parameter Noun
Get-Help -Name Get-Command -ShowWindow
```

I typically use `help <command name>` with the **Full** or **Online** parameter. If I'm only
interested in the examples, I'll use the **Examples** parameter and if I'm only interested in a
specific parameter, I'll use the **Parameter** parameter. The **ShowWindow** parameter opens the
help topic in a separate searchable window that can be placed on a different monitor if you have
multiple monitors. I've avoided the **ShowWindow** parameter because there's a known bug where it
doesn't display the entire help topic.

If you want help in a separate window, my recommendation is to either use the **Online** parameter
or use the **Full** parameter and pipe the results to `Out-GridView`, as shown in the following
example.

```powershell
help Get-Command -Full | Out-GridView
```

Both the `Out-GridView` cmdlet and the **ShowWindow** parameter of the `Get-Help` cmdlet require an
operating system with a GUI (Graphical User Interface). They will generate an error message if you
attempt to use either of them on Windows Server that's been installed using the server core (no-GUI)
installation option.

To use `Get-Help` to find commands, use the asterisk (`*`) wildcard character with the **Name**
parameter. Specify a term that you're searching for commands on as the value for the **Name**
parameter as shown in the following example.

```powershell
help *process*
```

```Output
Name                              Category  Module                    Synopsis
----                              --------  ------                    --------
Enter-PSHostProcess               Cmdlet    Microsoft.PowerShell.Core Connects to and ...
Exit-PSHostProcess                Cmdlet    Microsoft.PowerShell.Core Closes an intera...
Get-PSHostProcessInfo             Cmdlet    Microsoft.PowerShell.Core
Debug-Process                     Cmdlet    Microsoft.PowerShell.M... Debugs one or mo...
Get-Process                       Cmdlet    Microsoft.PowerShell.M... Gets the process...
Start-Process                     Cmdlet    Microsoft.PowerShell.M... Starts one or mo...
Stop-Process                      Cmdlet    Microsoft.PowerShell.M... Stops one or mor...
Wait-Process                      Cmdlet    Microsoft.PowerShell.M... Waits for the pr...
Get-AppvVirtualProcess            Function  AppvClient                ...
Start-AppvVirtualProcess          Function  AppvClient                ...
```

In the previous example, the `*` wildcard characters are not required and omitting them produces the
same result. `Get-Help` automatically adds the wildcard characters behind the scenes.

```powershell
help process
```

The previous command produces the same results as specifying the `*` wildcard character on each end
of process.

I prefer to add them since that's the option that always works consistently. Otherwise, they are
required in certain scenarios and not others. As soon as you add a wildcard character in the middle
of the value, they're no longer automatically added behind the scenes to the value you specified.

```powershell
help pr*cess
```

No results are returned by that command unless the `*` wildcard character is added to the beginning,
end, or both the beginning and end of `pr*cess`.

If the value you specified begins with a dash, then an error is generated because PowerShell
interprets it as a parameter name and no such parameter name exists for the `Get-Help` cmdlet.

```powershell
help -process
```

If what you're attempting to look for are commands that end with `-process`, you only need to add
the `*` wildcard character to the beginning of the value.

```powershell
help *-process
```

When searching for PowerShell commands with `Get-Help`, you want to be a little more vague instead
of being too specific with what you're searching for.

Searching for `process` earlier found only commands that contained `process` in the name of the
command and returned only those results. When `Get-Help` is used to search for `processes`, it
doesn't find any matches for command names, so it performs a search of every help topic in
PowerShell on your system and returns any matches it finds. This causes it to return an enormous
number of results.

```powershell
Get-Help processes
```

```Output
Name                              Category  Module                    Synopsis
----                              --------  ------                    --------
Disconnect-PSSession              Cmdlet    Microsoft.PowerShell.Core Disconnects from...
Enter-PSHostProcess               Cmdlet    Microsoft.PowerShell.Core Connects to and ...
ForEach-Object                    Cmdlet    Microsoft.PowerShell.Core Performs an oper...
Get-PSSessionConfiguration        Cmdlet    Microsoft.PowerShell.Core Gets the registe...
New-PSTransportOption             Cmdlet    Microsoft.PowerShell.Core Creates an objec...
Out-Host                          Cmdlet    Microsoft.PowerShell.Core Sends output to ...
Where-Object                      Cmdlet    Microsoft.PowerShell.Core Selects objects ...
Clear-Variable                    Cmdlet    Microsoft.PowerShell.U... Deletes the valu...
Compare-Object                    Cmdlet    Microsoft.PowerShell.U... Compares two set...
Convert-String                    Cmdlet    Microsoft.PowerShell.U... Formats a string...
ConvertFrom-Csv                   Cmdlet    Microsoft.PowerShell.U... Converts object ...
ConvertTo-Html                    Cmdlet    Microsoft.PowerShell.U... Converts Microso...
ConvertTo-Xml                     Cmdlet    Microsoft.PowerShell.U... Creates an XML-b...
Debug-Runspace                    Cmdlet    Microsoft.PowerShell.U... Starts an intera...
Export-Csv                        Cmdlet    Microsoft.PowerShell.U... Converts objects...
Export-FormatData                 Cmdlet    Microsoft.PowerShell.U... Saves formatting...
Format-List                       Cmdlet    Microsoft.PowerShell.U... Formats the outp...
Format-Table                      Cmdlet    Microsoft.PowerShell.U... Formats the outp...
Get-Random                        Cmdlet    Microsoft.PowerShell.U... Gets a random nu...
Get-Unique                        Cmdlet    Microsoft.PowerShell.U... Returns unique i...
Group-Object                      Cmdlet    Microsoft.PowerShell.U... Groups objects t...
Import-Clixml                     Cmdlet    Microsoft.PowerShell.U... Imports a CLIXML...
Import-Csv                        Cmdlet    Microsoft.PowerShell.U... Creates table-li...
Measure-Object                    Cmdlet    Microsoft.PowerShell.U... Calculates the n...
Out-File                          Cmdlet    Microsoft.PowerShell.U... Sends output to ...
Out-GridView                      Cmdlet    Microsoft.PowerShell.U... Sends output to ...
Select-Object                     Cmdlet    Microsoft.PowerShell.U... Selects objects ...
Set-Variable                      Cmdlet    Microsoft.PowerShell.U... Sets the value o...
Sort-Object                       Cmdlet    Microsoft.PowerShell.U... Sorts objects by...
Tee-Object                        Cmdlet    Microsoft.PowerShell.U... Saves command ou...
Trace-Command                     Cmdlet    Microsoft.PowerShell.U... Configures and s...
Write-Output                      Cmdlet    Microsoft.PowerShell.U... Sends the specif...
Debug-Process                     Cmdlet    Microsoft.PowerShell.M... Debugs one or mo...
Get-Process                       Cmdlet    Microsoft.PowerShell.M... Gets the process...
Get-WmiObject                     Cmdlet    Microsoft.PowerShell.M... Gets instances o...
Start-Process                     Cmdlet    Microsoft.PowerShell.M... Starts one or mo...
Stop-Process                      Cmdlet    Microsoft.PowerShell.M... Stops one or mor...
Wait-Process                      Cmdlet    Microsoft.PowerShell.M... Waits for the pr...
Get-Counter                       Cmdlet    Microsoft.PowerShell.D... Gets performance...
Invoke-WSManAction                Cmdlet    Microsoft.WSMan.Manage... Invokes an actio...
Remove-WSManInstance              Cmdlet    Microsoft.WSMan.Manage... Deletes a manage...
Get-WSManInstance                 Cmdlet    Microsoft.WSMan.Manage... Displays managem...
New-WSManInstance                 Cmdlet    Microsoft.WSMan.Manage... Creates a new in...
Set-WSManInstance                 Cmdlet    Microsoft.WSMan.Manage... Modifies the man...
about_Arithmetic_Operators        HelpFile                            Describes the op...
about_Arrays                      HelpFile                            Describes arrays...
about_Debuggers                   HelpFile                            Describes the Wi...
about_Execution_Policies          HelpFile                            Describes the Wi...
about_ForEach-Parallel            HelpFile                            Describes the Fo...
about_Foreach                     HelpFile                            Describes a lang...
about_Functions                   HelpFile                            Describes how to...
about_Language_Keywords           HelpFile                            Describes the ke...
about_Methods                     HelpFile                            Describes how to...
about_Objects                     HelpFile                            Provides essenti...
about_Parallel                    HelpFile                            Describes the Pa...
about_Pipelines                   HelpFile                            Combining comman...
about_Preference_Variables        HelpFile                            Variables that c...
about_Remote                      HelpFile                            Describes how to...
about_Remote_Output               HelpFile                            Describes how to...
about_Sequence                    HelpFile                            Describes the Se...
about_Session_Configuration_Files HelpFile                            Describes sessio...
about_Variables                   HelpFile                            Describes how va...
about_Windows_PowerShell_5.0      HelpFile                            Describes new fe...
about_WQL                         HelpFile                            Describes WMI Qu...
about_WS-Management_Cmdlets       HelpFile                            Provides an over...
about_ForEach-Parallel            HelpFile                            Describes the Fo...
about_Parallel                    HelpFile                            Describes the Pa...
about_Sequence                    HelpFile                            Describes the Se...
```

Using `Help` to search for `process` returned 10 results and using it to search for `processes`
returned 68 results. If only one result is found, the help topic itself will be displayed instead of
a list of commands.

```powershell
get-help *hotfix*
```

```Output
NAME
    Get-HotFix

SYNOPSIS
    Gets the hotfixes that have been applied to the local and remote computers.


SYNTAX
    Get-HotFix [-ComputerName <String[]>] [-Credential <PSCredential>] [-Description
    <String[]>] [<CommonParameters>]

    Get-HotFix [[-Id] <String[]>] [-ComputerName <String[]>] [-Credential
    <PSCredential>] [<CommonParameters>]


DESCRIPTION
    The Get-Hotfix cmdlet gets hotfixes (also called updates) that have been installed
    on either the local computer (or on specified remote computers) by Windows Update,
    Microsoft Update, or Windows Server Update Services; the cmdlet also gets hotfixes
    or updates that have been installed manually by users.


RELATED LINKS
    Online Version: http://go.microsoft.com/fwlink/?LinkId=821586
    Win32_QuickFixEngineering http://go.microsoft.com/fwlink/?LinkID=145071
    Get-ComputerRestorePoint
    Add-Content

REMARKS
    To see the examples, type: "get-help Get-HotFix -examples".
    For more information, type: "get-help Get-HotFix -detailed".
    For technical information, type: "get-help Get-HotFix -full".
    For online help, type: "get-help Get-HotFix -online"
```

Now to debunk the myth that `Help` in PowerShell can only find commands that have help topics.

```powershell
help *more*
```

```Output
NAME
    more

SYNTAX
    more [[-paths] <string[]>]


ALIASES
    None


REMARKS
    None
```

Notice in the previous example that `more` doesn't have a help topic, yet the `Help` system in
PowerShell was able to find it. It only found one match and returned the basic syntax information
that you'll see when a command doesn't have a help topic.

PowerShell contains numerous conceptual (About) help topics. The following command can be used to
return a list of all **About** help topics on your system.

```powershell
help About_*
```

Limiting the results to one single About help topic displays the actual help topic instead of
returning a list.

```powershell
help about_Updatable_Help
```

The help system in PowerShell has to be updated in order for the **About** help topics to be
present. If for some reason the initial update of the help system failed on your computer, the files
will not be available until the `Update-Help` cmdlet has been run successfully.

## Get-Command

`Get-Command` is designed to help you locate commands. Running `Get-Command` without any parameters
returns a list of all the commands on your system. The following example demonstrates using the
`Get-Command` cmdlet to determine what commands exist for working with processes:

```powershell
Get-Command -Noun Process
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Debug-Process                                      3.1.0.0    Microsof...
Cmdlet          Get-Process                                        3.1.0.0    Microsof...
Cmdlet          Start-Process                                      3.1.0.0    Microsof...
Cmdlet          Stop-Process                                       3.1.0.0    Microsof...
Cmdlet          Wait-Process                                       3.1.0.0    Microsof...
```

Notice in the previous example where `Get-Command` was run, the **Noun** parameter is used and
`Process` is specified as the value for the **Noun** parameter. What if you didn't know how to use
the `Get-Command` cmdlet? You could use `Get-Help` to display the help topic for `Get-Command`.

The **Name**, **Noun**, and **Verb** parameters accept wildcards. The following example shows
wildcards being used with the **Name** parameter:

```powershell
Get-Command -Name *service*
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Function        Get-NetFirewallServiceFilter                       2.0.0.0    NetSecurity
Function        Set-NetFirewallServiceFilter                       2.0.0.0    NetSecurity
Cmdlet          Get-Service                                        3.1.0.0    Microsof...
Cmdlet          New-Service                                        3.1.0.0    Microsof...
Cmdlet          New-WebServiceProxy                                3.1.0.0    Microsof...
Cmdlet          Restart-Service                                    3.1.0.0    Microsof...
Cmdlet          Resume-Service                                     3.1.0.0    Microsof...
Cmdlet          Set-Service                                        3.1.0.0    Microsof...
Cmdlet          Start-Service                                      3.1.0.0    Microsof...
Cmdlet          Stop-Service                                       3.1.0.0    Microsof...
Cmdlet          Suspend-Service                                    3.1.0.0    Microsof...
Application     AgentService.exe                                   10.0.14... C:\Windo...
Application     SensorDataService.exe                              10.0.14... C:\Windo...
Application     services.exe                                       10.0.14... C:\Windo...
Application     services.msc                                       0.0.0.0    C:\Windo...
Application     TieringEngineService.exe                           10.0.14... C:\Windo...
```

I'm not a fan of using wildcards with the **Name** parameter of `Get-Command` since it also returns
executable files that are not native PowerShell commands.

If you are going to use wildcard characters with the **Name** parameter, I recommend limiting the
results with the **CommandType** parameter.

```powershell
Get-Command -Name *service* -CommandType Cmdlet, Function, Alias
```

A better option is to use either the **Verb** or **Noun** parameter or both of them since only
PowerShell commands have both verbs and nouns.

Found something wrong with a help topic? The good news is the help topics for PowerShell have been
open-sourced and available in the [PowerShell-Docs][PowerShell-Docs] repository on GitHub. Pay it forward by not
only fixing the incorrect information for yourself, but everyone else as well. Simply fork the
PowerShell documentation repository on GitHub, update the help topic, and submit a pull request.
Once the pull request is accepted, the corrected documentation is available for everyone.

## Updating Help

The local copy of the PowerShell help topics was previously updated the first-time help on a command
was requested. It's recommended to periodically update the help system because there can be updates
to the help content from time to time. The `Update-Help` cmdlet is used to update the help topics.
It requires internet access by default and for you to be running PowerShell elevated as an
administrator.

```powershell
Update-Help
```

```Output
Update-Help : Failed to update Help for the module(s) 'BitsTransfer' with UI culture(s)
{en-US} : Unable to retrieve the HelpInfo XML file for UI culture en-US. Make sure the HelpInfoUri
property in the module manifest is valid or check your network connection and then try the command again.
At line:1 char:1
+ Update-Help
+
    + CategoryInfo          : InvalidOperation: (:) [Update-Help], Exception
    + FullyQualifiedErrorId : InvalidHelpInfoUri,Microsoft.PowerShell.Commands.UpdateHel
   pCommand

Update-Help : Failed to update Help for the module(s) 'NetworkControllerDiagnostics,
StorageReplica' with UI culture(s) {en-US} : Unable to retrieve the HelpInfo XML file
for UI culture en-US. Make sure the HelpInfoUri property in the module manifest is valid
or check your network connection and then try the command again.
At line:1 char:1
+ Update-Help
+
    + CategoryInfo          : ResourceUnavailable: (:) [Update-Help], Exception
    + FullyQualifiedErrorId : UnableToRetrieveHelpInfoXml,Microsoft.PowerShell.Commands.
   UpdateHelpCommand
```

A couple of the modules returned errors, which is not uncommon. If the machine didn't have internet
access, you could use the `Save-Help` cmdlet on another machine that does have internet access to
first save the updated help information to a file share on your network and then use the
**SourcePath** parameter of `Update-Help` to specify this network location for the help topics.

Consider setting up a scheduled task or adding some logic to your profile script in PowerShell to
periodically update the help content on your computer. Profile scripts will be discussed in an
upcoming chapter.

## Summary

In this chapter you've learned how to find commands with both `Get-Help` and `Get-Command`. You've
learned how to use the help system to figure out how to use commands once you find them. You've also
learned how to update the content of the help topics when updates are available.

My challenge to you is to learn a PowerShell command a day.

```powershell
Get-Command | Get-Random | Get-Help -Full
```

## Review

1. Is the **DisplayName** parameter of `Get-Service` positional?
1. How many parameter sets does the `Get-Process` cmdlet have?
1. What PowerShell commands exist for working with event logs?
1. What is the PowerShell command for returning a list of PowerShell processes running on your
   computer?
1. How do you update the PowerShell help content that's stored on your computer?

## Recommended Reading

If you want to know more information about the topics covered in this chapter, I recommend
reading the following PowerShell help topics.

- [Get-Help][Get-Help]
- [Get-Command][Get-Command]
- [Update-Help][Update-Help]
- [Save-Help][Save-Help]
- [about_Updatable_Help][about_Updatable_Help]
- [about_Command_Syntax][about_Command_Syntax]

In the next chapter, you'll learn about the `Get-Member` cmdlet as well as objects, properties, and
methods.

<!-- link references -->
[Get-Help]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-help
[Get-Command]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command
[Update-Help]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/update-help
[Save-Help]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/save-help
[about_Updatable_Help]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_updatable_help
[about_Command_Syntax]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_command_syntax
[PowerShell-Docs]: https://github.com/MicrosoftDocs/PowerShell-Docs
[Appendix A]: appendix-a.md

# /./reference/learn/ps101/03-discovering-objects.md

    ---
    description: You don't have to be a developer to understand and use objects, properties, and methods.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: Discovering objects, properties, and methods
    ---
# Chapter 3 - Discovering objects, properties, and methods

My first introduction to computers was a Commodore 64, but my first modern computer was a 286 12-Mhz
IBM clone with 1 megabyte of memory, a 40-megabyte hard drive, and one 5-1/4 inch floppy disk drive
with a CGA monitor running Microsoft DOS 3.3.

Many IT Pros, like myself, are no stranger to the command line, but when the subject of objects,
properties, and methods comes up, they get the deer in the headlights look and say, "I'm not a
developer." Guess what? You don't have to be a developer to be successful with PowerShell. Don't get
bogged down in the terminology. Not everything may make sense initially, but after a little hands-on
experience you'll start to have those "light bulb" moments. "Aha! So that's what the book was
talking about."

Be sure to try the examples on your computer to gain some of that hands-on experience.

## Requirements

The Active Directory PowerShell module is required by some of the examples shown in this chapter.
The module is part of the Remote Server Administration Tools (RSAT) for Windows. For the 1809 (or
higher) build of Windows, the RSAT tools are installed as a Windows feature. Support for Active Directory
is not available on Windows Home.

- For information about installing the RSAT tools, see [Windows Management modules][Windows Management modules].
- For older versions of Windows, see [RSAT for Windows][RSAT for Windows].

## Get-Member

`Get-Member` helps you discover what objects, properties, and methods are available for commands.
Any command that produces object-based output can be piped to `Get-Member`. A property is a
characteristic about an item. Your drivers license has a property called eye color and the most
common values for that property are blue and brown. A method is an action that can be taken on an
item. In staying with the drivers license example, one of the methods is "Revoke" because the
department of motor vehicles can revoke your drivers license.

### Properties

In the following example, I'll retrieve information about the Windows Time service running on my
computer.

```powershell
Get-Service -Name w32time
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  w32time            Windows Time
```

**Status**, **Name**, and **DisplayName** are examples of properties as shown in the previous set of
results. The value for the **Status** property is `Running`, the value for the **Name** property is
`w32time`, and the value for **DisplayName** is `Windows Time`.

Now I'll pipe that same command to `Get-Member`:

```powershell
Get-Service -Name w32time | Get-Member
```

```Output
   TypeName: System.ServiceProcess.ServiceController

Name                      MemberType    Definition
----                      ----------    ----------
Name                      AliasProperty Name = ServiceName
RequiredServices          AliasProperty RequiredServices = ServicesDependedOn
Disposed                  Event         System.EventHandler Disposed(System.Object, Sy...
Close                     Method        void Close()
Continue                  Method        void Continue()
CreateObjRef              Method        System.Runtime.Remoting.ObjRef CreateObjRef(ty...
Dispose                   Method        void Dispose(), void IDisposable.Dispose()
Equals                    Method        bool Equals(System.Object obj)
ExecuteCommand            Method        void ExecuteCommand(int command)
GetHashCode               Method        int GetHashCode()
GetLifetimeService        Method        System.Object GetLifetimeService()
GetType                   Method        type GetType()
InitializeLifetimeService Method        System.Object InitializeLifetimeService()
Pause                     Method        void Pause()
Refresh                   Method        void Refresh()
Start                     Method        void Start(), void Start(string[] args)
Stop                      Method        void Stop()
WaitForStatus             Method        void WaitForStatus(System.ServiceProcess.Servi...
CanPauseAndContinue       Property      bool CanPauseAndContinue {get;}
CanShutdown               Property      bool CanShutdown {get;}
CanStop                   Property      bool CanStop {get;}
Container                 Property      System.ComponentModel.IContainer Container {get;}
DependentServices         Property      System.ServiceProcess.ServiceController[] Depe...
DisplayName               Property      string DisplayName {get;set;}
MachineName               Property      string MachineName {get;set;}
ServiceHandle             Property      System.Runtime.InteropServices.SafeHandle Serv...
ServiceName               Property      string ServiceName {get;set;}
ServicesDependedOn        Property      System.ServiceProcess.ServiceController[] Serv...
ServiceType               Property      System.ServiceProcess.ServiceType ServiceType ...
Site                      Property      System.ComponentModel.ISite Site {get;set;}
StartType                 Property      System.ServiceProcess.ServiceStartMode StartTy...
Status                    Property      System.ServiceProcess.ServiceControllerStatus ...
ToString                  ScriptMethod  System.Object ToString();
```

The first line of the results in the previous example contains one piece of very important
information. **TypeName** tells you what type of object was returned. In this example, a
**System.ServiceProcess.ServiceController** object was returned. This is often abbreviated as the
portion of the **TypeName** just after the last period; **ServiceController** in this example.

Once you know what type of object a command produces, you can use this information to find commands
that accept that type of object as input.

```powershell
Get-Command -ParameterType ServiceController
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-Service                                        3.1.0.0    Microsof...
Cmdlet          Restart-Service                                    3.1.0.0    Microsof...
Cmdlet          Resume-Service                                     3.1.0.0    Microsof...
Cmdlet          Set-Service                                        3.1.0.0    Microsof...
Cmdlet          Start-Service                                      3.1.0.0    Microsof...
Cmdlet          Stop-Service                                       3.1.0.0    Microsof...
Cmdlet          Suspend-Service                                    3.1.0.0    Microsof...
```

All of those commands have a parameter that accepts a **ServiceController** object type by
pipeline, parameter input, or both.

Notice that there are more properties than are displayed by default. Although these additional
properties aren't displayed by default, they can be selected from the pipeline by piping the command
to the `Select-Object` cmdlet and using the **Property** parameter. The following example selects
all of the properties by piping the results of `Get-Service` to `Select-Object` and specifying the
`*` wildcard character as the value for the **Property** parameter.

```powershell
Get-Service -Name w32time | Select-Object -Property *
```

```Output
Name                : w32time
RequiredServices    : {}
CanPauseAndContinue : False
CanShutdown         : True
CanStop             : True
DisplayName         : Windows Time
DependentServices   : {}
MachineName         : .
ServiceName         : w32time
ServicesDependedOn  : {}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :
```

Specific properties can also be selected using a comma-separated list for the value of the
**Property** parameter.

```powershell
Get-Service -Name w32time | Select-Object -Property Status, Name, DisplayName, ServiceType
```

```Output
 Status Name    DisplayName        ServiceType
 ------ ----    -----------        -----------
Running w32time Windows Time Win32ShareProcess
```

By default, four properties are returned in a table and five or more are returned in a list. Some
commands use custom formatting to override how many properties are displayed by default in a table.
There are several `Format-*` cmdlets that can be used to manually override these defaults. The most
common ones are `Format-Table` and `Format-List`, both of which will be covered in an upcoming
chapter.

Wildcard characters can be used when specifying the property names with `Select-Object`.

```powershell
Get-Service -Name w32time | Select-Object -Property Status, DisplayName, Can*
```

```Output
Status              : Running
DisplayName         : Windows Time
CanPauseAndContinue : False
CanShutdown         : True
CanStop             : True
```

In the previous example, `Can*` was used as one of the values for the **Property** parameter to
return all the properties that start with `Can`. These include **CanPauseAndContinue**,
**CanShutdown**, and **CanStop**.

### Methods

Methods are an action that can be taken. Use the **MemberType** parameter to narrow down the results
of `Get-Member` to only show the methods for `Get-Service`.

```powershell
Get-Service -Name w32time | Get-Member -MemberType Method
```

```Output
   TypeName: System.ServiceProcess.ServiceController

Name                      MemberType Definition
----                      ---------- ----------
Close                     Method     void Close()
Continue                  Method     void Continue()
CreateObjRef              Method     System.Runtime.Remoting.ObjRef CreateObjRef(type ...
Dispose                   Method     void Dispose(), void IDisposable.Dispose()
Equals                    Method     bool Equals(System.Object obj)
ExecuteCommand            Method     void ExecuteCommand(int command)
GetHashCode               Method     int GetHashCode()
GetLifetimeService        Method     System.Object GetLifetimeService()
GetType                   Method     type GetType()
InitializeLifetimeService Method     System.Object InitializeLifetimeService()
Pause                     Method     void Pause()
Refresh                   Method     void Refresh()
Start                     Method     void Start(), void Start(string[] args)
Stop                      Method     void Stop()
WaitForStatus             Method     void WaitForStatus(System.ServiceProcess.ServiceC...
```

As you can see, there are many methods. The **Stop** method can be used to stop a Windows service.

```powershell
(Get-Service -Name w32time).Stop()
```

Now to verify the Windows time service has indeed been stopped.

```powershell
Get-Service -Name w32time
```

```Output
Status   Name               DisplayName
------   ----               -----------
Stopped  w32time            Windows Time
```

I rarely find myself using methods, but they're something you need to be aware of. There are times
that you'll come across a `Get-*` command without a corresponding command to modify that item.
Often, a method can be used to perform an action that modifies it. The `Get-SqlAgentJob` cmdlet in
the SqlServer PowerShell module is a good example of this. The module installs as part of
[SQL Server Management Studio (SMSS)][SMSS]. No corresponding `Set-*` cmdlet exists, but a
method can be used to complete the same task.

Another reason to be aware of methods is that many beginners assume destructive changes can't be
made with `Get-*` commands. But they indeed can cause serious problems if used inappropriately.

A better option is to use a cmdlet to perform the action if one exists. Go ahead and start the
Windows Time service, except this time use the cmdlet for starting services.

```powershell
Get-Service -Name w32time | Start-Service -PassThru
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  w32time            Windows Time
```

By default, `Start-Service` doesn't return any results just like the start method of `Get-Service`.
But one of the benefits of using a cmdlet is that many times the cmdlet offers additional
functionality that isn't available with a method. In the previous example, the **PassThru**
parameter was used. This causes a cmdlet that doesn't normally produce output, to produce output.

Be careful with assumptions about the output of a cmdlet. We all know what happens when you assume
things. I'll retrieve information about the PowerShell process running on my Windows 10 lab
environment computer.

```powershell
Get-Process -Name PowerShell
```

```Output
Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    922      48   107984     140552       2.84   9020   1 powershell

```

Now I'll pipe that same command to Get-Member:

```powershell
Get-Process -Name PowerShell | Get-Member
```

```Output
   TypeName: System.Diagnostics.Process

Name                       MemberType     Definition
----                       ----------     ----------
Handles                    AliasProperty  Handles = Handlecount
Name                       AliasProperty  Name = ProcessName
NPM                        AliasProperty  NPM = NonpagedSystemMemorySize64
PM                         AliasProperty  PM = PagedMemorySize64
SI                         AliasProperty  SI = SessionId
VM                         AliasProperty  VM = VirtualMemorySize64
WS                         AliasProperty  WS = WorkingSet64
Disposed                   Event          System.EventHandler Disposed(System.Object, ...
ErrorDataReceived          Event          System.Diagnostics.DataReceivedEventHandler ...
Exited                     Event          System.EventHandler Exited(System.Object, Sy...
OutputDataReceived         Event          System.Diagnostics.DataReceivedEventHandler ...
BeginErrorReadLine         Method         void BeginErrorReadLine()
BeginOutputReadLine        Method         void BeginOutputReadLine()
CancelErrorRead            Method         void CancelErrorRead()
CancelOutputRead           Method         void CancelOutputRead()
Close                      Method         void Close()
CloseMainWindow            Method         bool CloseMainWindow()
CreateObjRef               Method         System.Runtime.Remoting.ObjRef CreateObjRef(...
Dispose                    Method         void Dispose(), void IDisposable.Dispose()
Equals                     Method         bool Equals(System.Object obj)
GetHashCode                Method         int GetHashCode()
GetLifetimeService         Method         System.Object GetLifetimeService()
GetType                    Method         type GetType()
InitializeLifetimeService  Method         System.Object InitializeLifetimeService()
Kill                       Method         void Kill()
Refresh                    Method         void Refresh()
Start                      Method         bool Start()
ToString                   Method         string ToString()
WaitForExit                Method         bool WaitForExit(int milliseconds), void Wai...
WaitForInputIdle           Method         bool WaitForInputIdle(int milliseconds), boo...
__NounName                 NoteProperty   string __NounName=Process
BasePriority               Property       int BasePriority {get;}
Container                  Property       System.ComponentModel.IContainer Container {...
EnableRaisingEvents        Property       bool EnableRaisingEvents {get;set;}
ExitCode                   Property       int ExitCode {get;}
ExitTime                   Property       datetime ExitTime {get;}
Handle                     Property       System.IntPtr Handle {get;}
HandleCount                Property       int HandleCount {get;}
HasExited                  Property       bool HasExited {get;}
Id                         Property       int Id {get;}
MachineName                Property       string MachineName {get;}
MainModule                 Property       System.Diagnostics.ProcessModule MainModule ...
MainWindowHandle           Property       System.IntPtr MainWindowHandle {get;}
MainWindowTitle            Property       string MainWindowTitle {get;}
MaxWorkingSet              Property       System.IntPtr MaxWorkingSet {get;set;}
MinWorkingSet              Property       System.IntPtr MinWorkingSet {get;set;}
Modules                    Property       System.Diagnostics.ProcessModuleCollection M...
NonpagedSystemMemorySize   Property       int NonpagedSystemMemorySize {get;}
NonpagedSystemMemorySize64 Property       long NonpagedSystemMemorySize64 {get;}
PagedMemorySize            Property       int PagedMemorySize {get;}
PagedMemorySize64          Property       long PagedMemorySize64 {get;}
PagedSystemMemorySize      Property       int PagedSystemMemorySize {get;}
PagedSystemMemorySize64    Property       long PagedSystemMemorySize64 {get;}
PeakPagedMemorySize        Property       int PeakPagedMemorySize {get;}
PeakPagedMemorySize64      Property       long PeakPagedMemorySize64 {get;}
PeakVirtualMemorySize      Property       int PeakVirtualMemorySize {get;}
PeakVirtualMemorySize64    Property       long PeakVirtualMemorySize64 {get;}
PeakWorkingSet             Property       int PeakWorkingSet {get;}
PeakWorkingSet64           Property       long PeakWorkingSet64 {get;}
PriorityBoostEnabled       Property       bool PriorityBoostEnabled {get;set;}
PriorityClass              Property       System.Diagnostics.ProcessPriorityClass Prio...
PrivateMemorySize          Property       int PrivateMemorySize {get;}
PrivateMemorySize64        Property       long PrivateMemorySize64 {get;}
PrivilegedProcessorTime    Property       timespan PrivilegedProcessorTime {get;}
ProcessName                Property       string ProcessName {get;}
ProcessorAffinity          Property       System.IntPtr ProcessorAffinity {get;set;}
Responding                 Property       bool Responding {get;}
SafeHandle                 Property       Microsoft.Win32.SafeHandles.SafeProcessHandl...
SessionId                  Property       int SessionId {get;}
Site                       Property       System.ComponentModel.ISite Site {get;set;}
StandardError              Property       System.IO.StreamReader StandardError {get;}
StandardInput              Property       System.IO.StreamWriter StandardInput {get;}
StandardOutput             Property       System.IO.StreamReader StandardOutput {get;}
StartInfo                  Property       System.Diagnostics.ProcessStartInfo StartInf...
StartTime                  Property       datetime StartTime {get;}
SynchronizingObject        Property       System.ComponentModel.ISynchronizeInvoke Syn...
Threads                    Property       System.Diagnostics.ProcessThreadCollection T...
TotalProcessorTime         Property       timespan TotalProcessorTime {get;}
UserProcessorTime          Property       timespan UserProcessorTime {get;}
VirtualMemorySize          Property       int VirtualMemorySize {get;}
VirtualMemorySize64        Property       long VirtualMemorySize64 {get;}
WorkingSet                 Property       int WorkingSet {get;}
WorkingSet64               Property       long WorkingSet64 {get;}
PSConfiguration            PropertySet    PSConfiguration {Name, Id, PriorityClass, Fi...
PSResources                PropertySet    PSResources {Name, Id, Handlecount, WorkingS...
Company                    ScriptProperty System.Object Company {get=$this.Mainmodule....
CPU                        ScriptProperty System.Object CPU {get=$this.TotalProcessorT...
Description                ScriptProperty System.Object Description {get=$this.Mainmod...
FileVersion                ScriptProperty System.Object FileVersion {get=$this.Mainmod...
Path                       ScriptProperty System.Object Path {get=$this.Mainmodule.Fil...
Product                    ScriptProperty System.Object Product {get=$this.Mainmodule....
ProductVersion             ScriptProperty System.Object ProductVersion {get=$this.Main...
```

Notice that there are more properties listed than are displayed by default. A number of the default
properties displayed don't show up as properties when viewing the results of `Get-Member`. This is
because many of the displayed values, such as `NPM(K)`, `PM(K)`, `WS(K)`, and `CPU(s)`, are
calculated properties. To determine the actual property names, the command must be piped to
`Get-Member`.

If a command does not produce output, it can't be piped to `Get-Member`. Since `Start-Service`
doesn't produce any output by default, it generates an error when you try to pipe it to
`Get-Member`.

```powershell
Start-Service -Name w32time | Get-Member
```

```Output
Get-Member : You must specify an object for the Get-Member cmdlet.
At line:1 char:31
+ Start-Service -Name w32time | Get-Member
+
    + CategoryInfo          : CloseError: (:) [Get-Member], InvalidOperationException
    + FullyQualifiedErrorId : NoObjectInGetMember,Microsoft.PowerShell.Commands.GetMembe
   rCommand
```

The **PassThru** parameter can be specified with the `Start-Service` cmdlet make it produce output,
which is then piped to `Get-Member` without error.

```powershell
Start-Service -Name w32time -PassThru | Get-Member
```

```Output
   TypeName: System.ServiceProcess.ServiceController

Name                      MemberType    Definition
----                      ----------    ----------
Name                      AliasProperty Name = ServiceName
RequiredServices          AliasProperty RequiredServices = ServicesDependedOn
Disposed                  Event         System.EventHandler Disposed(System.Object, Sy...
Close                     Method        void Close()
Continue                  Method        void Continue()
CreateObjRef              Method        System.Runtime.Remoting.ObjRef CreateObjRef(ty...
Dispose                   Method        void Dispose(), void IDisposable.Dispose()
Equals                    Method        bool Equals(System.Object obj)
ExecuteCommand            Method        void ExecuteCommand(int command)
GetHashCode               Method        int GetHashCode()
GetLifetimeService        Method        System.Object GetLifetimeService()
GetType                   Method        type GetType()
InitializeLifetimeService Method        System.Object InitializeLifetimeService()
Pause                     Method        void Pause()
Refresh                   Method        void Refresh()
Start                     Method        void Start(), void Start(string[] args)
Stop                      Method        void Stop()
WaitForStatus             Method        void WaitForStatus(System.ServiceProcess.Servi...
CanPauseAndContinue       Property      bool CanPauseAndContinue {get;}
CanShutdown               Property      bool CanShutdown {get;}
CanStop                   Property      bool CanStop {get;}
Container                 Property      System.ComponentModel.IContainer Container {get;}
DependentServices         Property      System.ServiceProcess.ServiceController[] Depe...
DisplayName               Property      string DisplayName {get;set;}
MachineName               Property      string MachineName {get;set;}
ServiceHandle             Property      System.Runtime.InteropServices.SafeHandle Serv...
ServiceName               Property      string ServiceName {get;set;}
ServicesDependedOn        Property      System.ServiceProcess.ServiceController[] Serv...
ServiceType               Property      System.ServiceProcess.ServiceType ServiceType ...
Site                      Property      System.ComponentModel.ISite Site {get;set;}
StartType                 Property      System.ServiceProcess.ServiceStartMode StartTy...
Status                    Property      System.ServiceProcess.ServiceControllerStatus ...
ToString                  ScriptMethod  System.Object ToString();
```

To be piped to `Get-Member`, a command must produce object-based output.

```powershell
Get-Service -Name w32time | Out-Host | Get-Member
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  w32time            Windows Time

Get-Member : You must specify an object for the Get-Member cmdlet.
At line:1 char:40
+ Get-Service -Name w32time | Out-Host | Get-Member
+
    + CategoryInfo          : CloseError: (:) [Get-Member], InvalidOperationException
    + FullyQualifiedErrorId : NoObjectInGetMember,Microsoft.PowerShell.Commands.GetMemberCommand
```

`Out-Host` writes directly to the PowerShell host, but it doesn't produce object-based output for
the pipeline. So it can't be piped to `Get-Member`.

## Active Directory

> [!NOTE]
> The Remote Server Administration Tools listed in the requirements section of this chapter are
> required to complete this section. Also, as mentioned in the introduction to this book, your
> Windows 10 lab environment computer must be a member of the lab environment domain.

Use `Get-Command` with the **Module** parameter to determine what commands were added as part of the
ActiveDirectory PowerShell module when the remote server administration tools were installed.

```powershell
Get-Command -Module ActiveDirectory
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Add-ADCentralAccessPolicyMember                    1.0.0.0    ActiveDi...
Cmdlet          Add-ADComputerServiceAccount                       1.0.0.0    ActiveDi...
Cmdlet          Add-ADDomainControllerPasswordReplicationPolicy    1.0.0.0    ActiveDi...
Cmdlet          Add-ADFineGrainedPasswordPolicySubject             1.0.0.0    ActiveDi...
Cmdlet          Add-ADGroupMember                                  1.0.0.0    ActiveDi...
Cmdlet          Add-ADPrincipalGroupMembership                     1.0.0.0    ActiveDi...
Cmdlet          Add-ADResourcePropertyListMember                   1.0.0.0    ActiveDi...
Cmdlet          Clear-ADAccountExpiration                          1.0.0.0    ActiveDi...
Cmdlet          Clear-ADClaimTransformLink                         1.0.0.0    ActiveDi...
Cmdlet          Disable-ADAccount                                  1.0.0.0    ActiveDi...
...
```

A total of 147 commands were added as part of the ActiveDirectory PowerShell module. Some commands
of these commands only return a portion of the available properties by default.

Did you notice anything different about the names of the commands in this module? The noun portion
of the commands has an AD prefix. This is common to see on the commands of most modules. The prefix
is designed to help prevent naming conflicts.

```powershell
Get-ADUser -Identity mike | Get-Member
```

```Output
   TypeName: Microsoft.ActiveDirectory.Management.ADUser

Name              MemberType            Definition
----              ----------            ----------
Contains          Method                bool Contains(string propertyName)
Equals            Method                bool Equals(System.Object obj)
GetEnumerator     Method                System.Collections.IDictionaryEnumerator GetEn...
GetHashCode       Method                int GetHashCode()
GetType           Method                type GetType()
ToString          Method                string ToString()
Item              ParameterizedProperty Microsoft.ActiveDirectory.Management.ADPropert...
DistinguishedName Property              System.String DistinguishedName {get;set;}
Enabled           Property              System.Boolean Enabled {get;set;}
GivenName         Property              System.String GivenName {get;set;}
Name              Property              System.String Name {get;}
ObjectClass       Property              System.String ObjectClass {get;set;}
ObjectGUID        Property              System.Nullable`1[[System.Guid, mscorlib, Vers...
SamAccountName    Property              System.String SamAccountName {get;set;}
SID               Property              System.Security.Principal.SecurityIdentifier S...
Surname           Property              System.String Surname {get;set;}
UserPrincipalName Property              System.String UserPrincipalName {get;set;}
```

Even if you're only vaguely familiar with Active Directory, you're probably aware that a user
account has more properties than are shown in this example.

The `Get-ADUser` cmdlet has a **Properties** parameter that is used to specify the additional
(non-default) properties you want to return. Specifying the `*` wildcard character returns all of
them.

```powershell
Get-ADUser -Identity mike -Properties * | Get-Member
```

```Output
   TypeName: Microsoft.ActiveDirectory.Management.ADUser

Name                                 MemberType            Definition
----                                 ----------            ----------
Contains                             Method                bool Contains(string proper...
Equals                               Method                bool Equals(System.Object obj)
GetEnumerator                        Method                System.Collections.IDiction...
GetHashCode                          Method                int GetHashCode()
GetType                              Method                type GetType()
ToString                             Method                string ToString()
Item                                 ParameterizedProperty Microsoft.ActiveDirectory.M...
AccountExpirationDate                Property              System.DateTime AccountExpi...
accountExpires                       Property              System.Int64 accountExpires...
AccountLockoutTime                   Property              System.DateTime AccountLock...
AccountNotDelegated                  Property              System.Boolean AccountNotDe...
AllowReversiblePasswordEncryption    Property              System.Boolean AllowReversi...
AuthenticationPolicy                 Property              Microsoft.ActiveDirectory.M...
AuthenticationPolicySilo             Property              Microsoft.ActiveDirectory.M...
BadLogonCount                        Property              System.Int32 BadLogonCount ...
badPasswordTime                      Property              System.Int64 badPasswordTim...
badPwdCount                          Property              System.Int32 badPwdCount {g...
CannotChangePassword                 Property              System.Boolean CannotChange...
CanonicalName                        Property              System.String CanonicalName...
Certificates                         Property              Microsoft.ActiveDirectory.M...
City                                 Property              System.String City {get;set;}
CN                                   Property              System.String CN {get;}
codePage                             Property              System.Int32 codePage {get;...
Company                              Property              System.String Company {get;...
CompoundIdentitySupported            Property              Microsoft.ActiveDirectory.M...
Country                              Property              System.String Country {get;...
countryCode                          Property              System.Int32 countryCode {g...
Created                              Property              System.DateTime Created {get;}
createTimeStamp                      Property              System.DateTime createTimeS...
Deleted                              Property              System.Boolean Deleted {get;}
Department                           Property              System.String Department {g...
Description                          Property              System.String Description {...
DisplayName                          Property              System.String DisplayName {...
DistinguishedName                    Property              System.String Distinguished...
Division                             Property              System.String Division {get...
DoesNotRequirePreAuth                Property              System.Boolean DoesNotRequi...
dSCorePropagationData                Property              Microsoft.ActiveDirectory.M...
EmailAddress                         Property              System.String EmailAddress ...
EmployeeID                           Property              System.String EmployeeID {g...
EmployeeNumber                       Property              System.String EmployeeNumbe...
Enabled                              Property              System.Boolean Enabled {get...
Fax                                  Property              System.String Fax {get;set;}
GivenName                            Property              System.String GivenName {ge...
HomeDirectory                        Property              System.String HomeDirectory...
HomedirRequired                      Property              System.Boolean HomedirRequi...
HomeDrive                            Property              System.String HomeDrive {ge...
HomePage                             Property              System.String HomePage {get...
HomePhone                            Property              System.String HomePhone {ge...
Initials                             Property              System.String Initials {get...
instanceType                         Property              System.Int32 instanceType {...
isDeleted                            Property              System.Boolean isDeleted {g...
KerberosEncryptionType               Property              Microsoft.ActiveDirectory.M...
LastBadPasswordAttempt               Property              System.DateTime LastBadPass...
LastKnownParent                      Property              System.String LastKnownPare...
lastLogoff                           Property              System.Int64 lastLogoff {ge...
lastLogon                            Property              System.Int64 lastLogon {get...
LastLogonDate                        Property              System.DateTime LastLogonDa...
lastLogonTimestamp                   Property              System.Int64 lastLogonTimes...
LockedOut                            Property              System.Boolean LockedOut {g...
logonCount                           Property              System.Int32 logonCount {ge...
LogonWorkstations                    Property              System.String LogonWorkstat...
Manager                              Property              System.String Manager {get;...
MemberOf                             Property              Microsoft.ActiveDirectory.M...
MNSLogonAccount                      Property              System.Boolean MNSLogonAcco...
MobilePhone                          Property              System.String MobilePhone {...
Modified                             Property              System.DateTime Modified {g...
modifyTimeStamp                      Property              System.DateTime modifyTimeS...
msDS-User-Account-Control-Computed   Property              System.Int32 msDS-User-Acco...
Name                                 Property              System.String Name {get;}
nTSecurityDescriptor                 Property              System.DirectoryServices.Ac...
ObjectCategory                       Property              System.String ObjectCategor...
ObjectClass                          Property              System.String ObjectClass {...
ObjectGUID                           Property              System.Nullable`1[[System.G...
objectSid                            Property              System.Security.Principal.S...
Office                               Property              System.String Office {get;s...
OfficePhone                          Property              System.String OfficePhone {...
Organization                         Property              System.String Organization ...
OtherName                            Property              System.String OtherName {ge...
PasswordExpired                      Property              System.Boolean PasswordExpi...
PasswordLastSet                      Property              System.DateTime PasswordLas...
PasswordNeverExpires                 Property              System.Boolean PasswordNeve...
PasswordNotRequired                  Property              System.Boolean PasswordNotR...
POBox                                Property              System.String POBox {get;set;}
PostalCode                           Property              System.String PostalCode {g...
PrimaryGroup                         Property              System.String PrimaryGroup ...
primaryGroupID                       Property              System.Int32 primaryGroupID...
PrincipalsAllowedToDelegateToAccount Property              Microsoft.ActiveDirectory.M...
ProfilePath                          Property              System.String ProfilePath {...
ProtectedFromAccidentalDeletion      Property              System.Boolean ProtectedFro...
pwdAnswer                            Property              System.String pwdAnswer {ge...
pwdLastSet                           Property              System.Int64 pwdLastSet {ge...
pwdQuestion                          Property              System.String pwdQuestion {...
SamAccountName                       Property              System.String SamAccountNam...
sAMAccountType                       Property              System.Int32 sAMAccountType...
ScriptPath                           Property              System.String ScriptPath {g...
sDRightsEffective                    Property              System.Int32 sDRightsEffect...
ServicePrincipalNames                Property              Microsoft.ActiveDirectory.M...
SID                                  Property              System.Security.Principal.S...
SIDHistory                           Property              Microsoft.ActiveDirectory.M...
SmartcardLogonRequired               Property              System.Boolean SmartcardLog...
sn                                   Property              System.String sn {get;set;}
State                                Property              System.String State {get;set;}
StreetAddress                        Property              System.String StreetAddress...
Surname                              Property              System.String Surname {get;...
Title                                Property              System.String Title {get;set;}
TrustedForDelegation                 Property              System.Boolean TrustedForDe...
TrustedToAuthForDelegation           Property              System.Boolean TrustedToAut...
UseDESKeyOnly                        Property              System.Boolean UseDESKeyOnl...
userAccountControl                   Property              System.Int32 userAccountCon...
userCertificate                      Property              Microsoft.ActiveDirectory.M...
UserPrincipalName                    Property              System.String UserPrincipal...
uSNChanged                           Property              System.Int64 uSNChanged {get;}
uSNCreated                           Property              System.Int64 uSNCreated {get;}
whenChanged                          Property              System.DateTime whenChanged...
whenCreated                          Property              System.DateTime whenCreated...
```

Now that looks more like it.

Can you think of a reason why the properties of an Active Directory user account would be so limited
by default? Imagine if you returned every property for every user account in your production Active
Directory environment. Think of the performance degradation that you could cause, not only to the
domain controllers themselves, but also to your network. It's doubtful that you'll actually need
every property anyway. Returning all of the properties for a single user account is perfectly
acceptable when you're trying to determine what properties exist.

It's not uncommon to run a command many times when prototyping it. If you're going to perform
some huge query, query it once and store the results in a variable. Then work with the contents of
the variable instead of repeatedly using some expensive query.

```powershell
$Users = Get-ADUser -Identity mike -Properties *
```

Use the contents of the `$Users` variable instead of running the previous command numerous times.
Keep in mind that the contents of the variable aren't updated when changes are made to that user in
Active Directory.

You could pipe the `$Users` variable to `Get-Member` to discover the available properties.

```powershell
$Users | Get-Member
```

Then select the individual properties by piping `$Users` to `Select-Object`, all without ever having
to query Active Directory more than one time.

```powershell
$Users | Select-Object -Property Name, LastLogonDate, LastBadPasswordAttempt
```

If you are going to query Active Directory more than once, use the **Properties** parameter to
specify any non-default properties you want.

```powershell
Get-ADUser -Identity mike -Properties LastLogonDate, LastBadPasswordAttempt
```

```Output
DistinguishedName      : CN=Mike F. Robbins,OU=Sales,DC=mikefrobbins,DC=com
Enabled                : True
GivenName              : Mike
LastBadPasswordAttempt : 2/4/2017 10:46:15 AM
LastLogonDate          : 2/18/2017 12:45:14 AM
Name                   : Mike F. Robbins
ObjectClass            : user
ObjectGUID             : a82a8c58-1332-4a57-a6e2-68e0c750ea56
SamAccountName         : mike
SID                    : S-1-5-21-2989741381-570885089-3319121794-1108
Surname                : Robbins
UserPrincipalName      : miker@mikefrobbins.com
```

## Summary

In this chapter, you've learned how to determine what type of object a command produces, how to
determine what properties and methods are available for a command, and how to work with commands
that limit the properties that are returned by default.

## Review

1. What type of object does the `Get-Process` cmdlet produce?
1. How do you determine what the available properties are for a command?
1. If a command exists for getting something but not for setting the same thing, what should you
   check for?
1. How can certain commands that don't produce output by default be made to produce output?
1. If you're going to be working with the results of a command that produces an enormous amount of
   output, what should you consider doing?

## Recommended Reading

- [Get-Member][Get-Member]
- [Viewing Object Structure (Get-Member)][Viewing Object Structure (Get-Member)]
- [about_Objects][about_Objects]
- [about_Properties][about_Properties]
- [about_Methods][about_Methods]
- [No PowerShell Cmdlet to Start or Stop Something? Don't Forget to Check for Methods on the Get Cmdlets][use-methods]

<!-- link references -->
[RSAT for Windows]: https://support.microsoft.com/help/2693643
[Windows Management modules]: https://learn.microsoft.com/powershell/scripting/whats-new/module-compatibility#windows-management-modules
[Get-Member]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/get-member
[Viewing Object Structure (Get-Member)]: https://learn.microsoft.com/powershell/scripting/samples/viewing-object-structure--get-member-
[about_Objects]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_objects
[about_Properties]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_properties
[about_Methods]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_methods
[use-methods]: https://mikefrobbins.com/2016/12/15/no-powershell-cmdlet-to-start-or-stop-something-dont-forget-to-check-for-methods-on-the-get-cmdlets/
[SMSS]: https://learn.microsoft.com/sql/ssms/download-sql-server-management-studio-ssms

# /./reference/learn/ps101/04-pipelines.md

    ---
    description: A PowerShell one-liner is one continuous pipeline, containing multiple commands, to accomplish a single task.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: One-liners and the pipeline
    ---
# Chapter 4 - One-liners and the pipeline

When I first started learning PowerShell, if I couldn't accomplish a task with a PowerShell
one-liner, I went back to the GUI. Over time, I built my skills up to writing scripts, functions,
and modules. Don't allow yourself to become overwhelmed by some of the more advanced examples you
may see on the internet. No one is a natural expert with PowerShell. We were all beginners at
one time.

I have a bit of advice to offer those of you who are still using the GUI for administration:
install the management tools on your admin workstation and manage your servers remotely. This way it
won't matter if the server is running a GUI or Server Core installation of the operating system.
It's going to help prepare you for managing servers remotely with PowerShell.

As with previous chapters, be sure to follow along on your Windows 10 lab environment computer.

## One-Liners

A PowerShell one-liner is one continuous pipeline and not necessarily a command that's on one
physical line. Not all commands that are on one physical line are one-liners.

Even though the following command is on multiple physical lines, it's a PowerShell one-liner because
it's one continuous pipeline. It could be written on one physical line, but I've chosen to line
break at the pipe symbol. The pipe symbol is one of the characters where a natural line break is
allowed in PowerShell.

```powershell
Get-Service |
  Where-Object CanPauseAndContinue -eq $true |
    Select-Object -Property *
```

```Output
Name                : LanmanWorkstation
RequiredServices    : {NSI, MRxSmb20, Bowser}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Workstation
DependentServices   : {SessionEnv, Netlogon, Browser}
MachineName         : .
ServiceName         : LanmanWorkstation
ServicesDependedOn  : {NSI, MRxSmb20, Bowser}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Automatic
Site                :
Container           :

Name                : Netlogon
RequiredServices    : {LanmanWorkstation}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Netlogon
DependentServices   : {}
MachineName         : .
ServiceName         : Netlogon
ServicesDependedOn  : {LanmanWorkstation}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Automatic
Site                :
Container           :

Name                : vmicheartbeat
RequiredServices    : {}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Hyper-V Heartbeat Service
DependentServices   : {}
MachineName         : .
ServiceName         : vmicheartbeat
ServicesDependedOn  : {}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :

Name                : vmickvpexchange
RequiredServices    : {}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Hyper-V Data Exchange Service
DependentServices   : {}
MachineName         : .
ServiceName         : vmickvpexchange
ServicesDependedOn  : {}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :

Name                : vmicrdv
RequiredServices    : {}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Hyper-V Remote Desktop Virtualization Service
DependentServices   : {}
MachineName         : .
ServiceName         : vmicrdv
ServicesDependedOn  : {}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :

Name                : vmicshutdown
RequiredServices    : {}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Hyper-V Guest Shutdown Service
DependentServices   : {}
MachineName         : .
ServiceName         : vmicshutdown
ServicesDependedOn  : {}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :

Name                : vmictimesync
RequiredServices    : {VmGid}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Hyper-V Time Synchronization Service
DependentServices   : {}
MachineName         : .
ServiceName         : vmictimesync
ServicesDependedOn  : {VmGid}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :

Name                : vmicvss
RequiredServices    : {}
CanPauseAndContinue : True
CanShutdown         : False
CanStop             : True
DisplayName         : Hyper-V Volume Shadow Copy Requestor
DependentServices   : {}
MachineName         : .
ServiceName         : vmicvss
ServicesDependedOn  : {}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :

Name                : Winmgmt
RequiredServices    : {RPCSS}
CanPauseAndContinue : True
CanShutdown         : True
CanStop             : True
DisplayName         : Windows Management Instrumentation
DependentServices   : {wscsvc, NcaSvc, iphlpsvc}
MachineName         : .
ServiceName         : Winmgmt
ServicesDependedOn  : {RPCSS}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Automatic
Site                :
Container           :
```

Natural line breaks can occur at commonly used characters including comma (`,`) and opening brackets
(`[`), braces (`{`), and parenthesis (`(`). Others that aren't so common include the semicolon
(`;`), equals sign (`=`), and both opening single and double quotes (`'`,`"`).

Using the backtick (`` ` ``) or grave accent character as a line continuation character is a
controversial topic. My recommendation is to try to avoid it if at all possible. I often see
PowerShell commands written using a backtick immediately after a natural line break character.
There's no reason for it to be there.

```powershell
Get-Service -Name w32time |
>> Select-Object -Property *
```

```Output
Name                : w32time
RequiredServices    : {}
CanPauseAndContinue : False
CanShutdown         : True
CanStop             : True
DisplayName         : Windows Time
DependentServices   : {}
MachineName         : .
ServiceName         : w32time
ServicesDependedOn  : {}
ServiceHandle       : SafeServiceHandle
Status              : Running
ServiceType         : Win32ShareProcess
StartType           : Manual
Site                :
Container           :
```

The commands shown in the previous two examples work fine in the PowerShell console. But if you try
to run them in the console pane of the PowerShell ISE, they'll generate an error. The console pane
of the PowerShell ISE doesn't wait for the rest of the command to be entered on the next line like
the PowerShell console does. To avoid this problem in the console pane of the PowerShell ISE, use
<kbd>Shift</kbd>+<kbd>Enter</kbd> instead of just pressing <kbd>Enter</kbd> when continuing a
command on another line.

This next example isn't a PowerShell one-liner because it's not one continuous pipeline. It's two
separate commands on one line, separated by a semicolon.

```powershell
$Service = 'w32time'; Get-Service -Name $Service
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  w32time            Windows Time
```

Many programming and scripting languages require a semicolon at the end of each line. While they can
be used that way in PowerShell, it's not recommended because they're not needed.

## Filtering Left

The results of the commands shown in this chapter have been filtered down to a subset. For example,
`Get-Service` was used with the **Name** parameter to filter the list of services that were returned
to only the Windows Time service.

In the pipeline, you always want to filter the results down to what you're looking for as early as
possible. This is accomplished using parameters on the first command or, the one to the far left.
This is sometimes called _filtering left_.

The following example uses the **Name** parameter of `Get-Service` to immediately filter the results
to the Windows Time service only.

```powershell
Get-Service -Name w32time
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  w32time            Windows Time
```

It's not uncommon to see examples where the command is piped to `Where-Object` to perform the
filtering.

```powershell
Get-Service | Where-Object Name -eq w32time
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  W32Time            Windows Time
```

The first example filters at the source and only returns the results for the Windows Time service.
The second example returns all the services then pipes them to another command to perform the
filtering. While this may not seem like a big deal in this example, imagine if you were querying a
list of Active Directory users. Do you really want to return the information for many thousands of
user accounts from Active Directory only to pipe them to another command that filters them down to a
tiny subset? My recommendation is to always filter left even when it doesn't seem to matter. You'll
be so use to it that you'll automatically filter left when it really does matter.

I once had someone tell me that the order you specify the commands in doesn't matter. That couldn't
be further from the truth. The order that the commands are specified in does indeed matter when
performing filtering. For example, consider the scenario where you are using `Select-Object` to
select only a few properties and `Where-Object` to filter on properties that won't be in the
selection. In that scenario, the filtering must occur first, otherwise the property won't exist
in the pipeline when try to perform the filtering.

```powershell
Get-Service |
Select-Object -Property DisplayName, Running, Status |
Where-Object CanPauseAndContinue
```

The command in the previous example doesn't return any results because the **CanStopAndContinue**
property doesn't exist when the results of `Select-Object` are piped to `Where-Object`. That
particular property wasn't "selected". In essence, it was filtered out. Reversing the order of
`Select-Object` and `Where-Object` produces the desired results.

```powershell
Get-Service |
Where-Object CanPauseAndContinue |
Select-Object -Property DisplayName, Status
```

```Output
DisplayName                                    Status
-----------                                    ------
Workstation                                    Running
Netlogon                                       Running
Hyper-V Heartbeat Service                      Running
Hyper-V Data Exchange Service                  Running
Hyper-V Remote Desktop Virtualization Service  Running
Hyper-V Guest Shutdown Service                 Running
Hyper-V Time Synchronization Service           Running
Hyper-V Volume Shadow Copy Requestor           Running
Windows Management Instrumentation             Running
```

## The Pipeline

As you've seen in many of the examples shown so far throughout this book, many times the output of
one command can be used as input for another command. In Chapter 3, `Get-Member` was used to
determine what type of object a command produces. Chapter 3 also showed using the **ParameterType**
parameter of `Get-Command` to determine what commands accepted that type of input, although not
necessarily by pipeline input.

Depending on how thorough a commands help is, it may include an **INPUTS** and **OUTPUTS** section.

```powershell
help Stop-Service -Full
```

```Output
...
INPUTS
    System.ServiceProcess.ServiceController, System.String
        You can pipe a service object or a string that contains the name of a service
        to this cmdlet.

OUTPUTS
    None, System.ServiceProcess.ServiceController
        This cmdlet generates a System.ServiceProcess.ServiceController object that
        represents the service, if you use the PassThru parameter. Otherwise, this
        cmdlet does not generate any output.
...
```

Only the relevant section of the help is shown in the previous results. As you can see, the
**INPUTS** section states that a **ServiceController** or a **String** object can be piped to the
`Stop-Service` cmdlet. It doesn't tell you which parameters accept that type of input. One of the
easiest ways to determine that information is to look through the different parameters in the full
version of the help for the `Stop-Service` cmdlet.

```powershell
help Stop-Service -Full
```

```Output
...
-DisplayName <String[]>
    Specifies the display names of the services to stop. Wildcard characters are
    permitted.

    Required?                    true
    Position?                    named
    Default value                None
    Accept pipeline input?       False
    Accept wildcard characters?  false

-InputObject <ServiceController[]>
    Specifies ServiceController objects that represent the services to stop. Enter a
    variable that contains the objects, or type a command or expression that gets the
    objects.

    Required?                    true
    Position?                    0
    Default value                None
    Accept pipeline input?       True (ByValue)
    Accept wildcard characters?  false

-Name <String[]>
    Specifies the service names of the services to stop. Wildcard characters are
    permitted.

    Required?                    true
    Position?                    0
    Default value                None
    Accept pipeline input?       True (ByPropertyName, ByValue)
    Accept wildcard characters?  false
...
```

Once again, I've only shown the relevant portion of the help in the previous set of results. Notice
that the **DisplayName** parameter doesn't accept pipeline input, the **InputObject** parameter
accepts pipeline input **by value** for **ServiceController** objects, and the **Name** parameter
accepts pipeline input **by value** for **string** objects. It also accepts pipeline input **by
property name**.

When a parameter accepts pipeline input by both property name and by value, it always tries **by
value** first. If **by value** fails, then it tries **by property name**. **By value** is a little
misleading. I prefer to call it **by type**. This means if you pipe the results of a command that
produces a **ServiceController** object type to `Stop-Service`, it binds that input to the
**InputObject** parameter. But if you pipe the results of a command that produces **String** output
to `Stop-Service`, it binds it to the **Name** parameter. If you pipe the results of a command that
doesn't produce a **ServiceController** or **String** object to `Stop-Service`, but it does produce
output containing a property called **Name**, then it binds the **Name** property from the output to
the **Name** parameter of `Stop-Service`.

Determine what type of output the `Get-Service` command produces.

```powershell
Get-Service -Name w32time | Get-Member
```

```Output
   TypeName: System.ServiceProcess.ServiceController
```

`Get-Service` produces a ServiceController object type.

As you previously saw in the help, the **InputObject** parameter of `Stop-Service` accepts
**ServiceController** objects via the pipeline **by value** (by type). This means that when the
results of the `Get-Service` cmdlet are piped to `Stop-Service`, they bind to the **InputObject**
parameter of `Stop-Service`.

```powershell
Get-Service -Name w32time | Stop-Service
```

Now to try string input. Pipe `w32time` to `Get-Member` just to confirm that it's a string.

```powershell
'w32time' | Get-Member
```

```Output
   TypeName: System.String
```

As previously shown in the help, piping a string to `Stop-Service` binds it **by value** to the
**Name** parameter of `Stop-Service`. Test this by piping `w32time` to `Stop-Service`.

```powershell
'w32time' | Stop-Service
```

Notice that in the previous example, I used single quotes around the string `w32time`. In
PowerShell, you should always use single quotes instead of double quotes unless the contents of the
quoted string contains a variable that needs to be expanded to its actual value. By using single
quotes, PowerShell doesn't have to parse the contents contained within the quotes so your code runs
a little faster.

Create a custom object to test pipeline input by property name for the **Name** parameter of
`Stop-Service`.

```powershell
$CustomObject = [pscustomobject]@{
 Name = 'w32time'
 }
```

The contents of the **CustomObject** variable is a **PSCustomObject** object type and it contains a
property named **Name**.

```powershell
$CustomObject | Get-Member
```

```Output
   TypeName: System.Management.Automation.PSCustomObject

Name        MemberType   Definition
----        ----------   ----------
Equals      Method       bool Equals(System.Object obj)
GetHashCode Method       int GetHashCode()
GetType     Method       type GetType()
ToString    Method       string ToString()
Name        NoteProperty string Name=w32time
```

If you were to surround the `$CustomObject` variable with quotes, you want to use double quotes.
Otherwise, using single quotes, the literal string `$CustomObject` is piped to `Get-Member` instead
of the value contained by the variable.

Although piping the contents of `$CustomObject` to `Stop-Service` cmdlet binds to the **Name**
parameter, this time it binds **by property name** instead of **by value** because the contents of
`$CustomObject` is an object that has a property named **Name**.

In this example, I create another custom object using a different property name, such as
**Service**.

```powershell
$CustomObject = [pscustomobject]@{
  Service = 'w32time'
}
```

An error is generated when trying to pipe `$CustomObject` to `Stop-Service` because it doesn't
produce a **ServiceController** or **String** object, and it doesn't have a property named **Name**.

```powershell
$CustomObject | Stop-Service
```

```Output
Stop-Service : Cannot find any service with service name '@{Service=w32time}'.
At line:1 char:17
+ $CustomObject | Stop-Service
+
    + CategoryInfo          : ObjectNotFound: (@{Service=w32time}:String) [Stop-Service]
   , ServiceCommandException
    + FullyQualifiedErrorId : NoServiceFoundForGivenName,Microsoft.PowerShell.Commands.S
   topServiceCommand
```

If the output of one command doesn't line up with the pipeline input options for another command,
`Select-Object` can be used to rename the property so that the properties lineup correctly.

```powershell
$CustomObject |
  Select-Object -Property @{name='Name';expression={$_.Service}} |
    Stop-Service
```

In this example, `Select-Object` was used to rename the **Service** property to a property named
**Name**.

The syntax this example may seem a little complicated at first. What I have learned is that you'll
never learn the syntax by copy and pasting code. Take the time to type the code in. After a few
times, it becomes second nature. Having multiple monitors is a huge benefit because you can display
the example code on one screen and type it in on another one.

Occasionally, you may want to use a parameter that doesn't accept pipeline input. The following
example demonstrates using the output of one command as input for another. First save the display
name for a couple of Windows services into a text file.

```powershell
'Background Intelligent Transfer Service', 'Windows Time' |
Out-File -FilePath $env:TEMP\services.txt
```

You can run the command that provides the needed output within parentheses as the value for the
parameter of the command requiring the input.

```powershell
Stop-Service -DisplayName (Get-Content -Path $env:TEMP\services.txt)
```

This is just like order of operations in Algebra for those of you who remember how it works. The
command within parentheses always runs prior to the outer portion of the command.

## PowerShellGet

PowerShellGet is a PowerShell module that contains commands for discovering, installing, publishing,
and updating PowerShell modules (and other artifacts) to or from a NuGet repository. PowerShellGet
ships with PowerShell version 5.0 and higher. It is available as a separate download for PowerShell
version 3.0 and higher.

Microsoft hosts an online NuGet repository called the [PowerShell Gallery][PowerShell Gallery].
Although this repository is hosted by Microsoft, the majority of the modules contained within the
repository aren't written by Microsoft. Any code obtain from the PowerShell Gallery should be
thoroughly reviewed in an isolated test environment before being considered suitable for use in a
production environment.

Most companies will want to host their own internal private NuGet repository where they can post
their internal use only modules as well as modules that they've downloaded from other sources once
they've validated them as being non-malicious.

Use the `Find-Module` cmdlet that's part of the PowerShellGet module to find a module in the
PowerShell Gallery that I wrote named MrToolkit.

```powershell
Find-Module -Name MrToolkit
```

```Output
NuGet provider is required to continue
PowerShellGet requires NuGet provider version '2.8.5.201' or newer to interact with
NuGet-based repositories. The NuGet provider must be available in 'C:\Program
Files\PackageManagement\ProviderAssemblies' or
'C:\Users\MrAdmin\AppData\Local\PackageManagement\ProviderAssemblies'. You can also
install the NuGet provider by running 'Install-PackageProvider -Name NuGet
-MinimumVersion 2.8.5.201 -Force'. Do you want PowerShellGet to install and import the
NuGet provider now?
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"):

Version    Name                                Repository           Description
-------    ----                                ----------           -----------
1.1        MrToolkit                           PSGallery            Misc PowerShell Tools
```

The first time you use one of the commands from the PowerShellGet module, you'll be prompted to
install the NuGet provider.

To install the MrToolkit module, pipe the previous command to `Install-Module`.

```powershell
Find-Module -Name MrToolkit | Install-Module
```

```Output
Untrusted repository
You are installing the modules from an untrusted repository. If you trust this
repository, change its InstallationPolicy value by running the Set-PSRepository cmdlet.
Are you sure you want to install the modules from
'https://www.powershellgallery.com/api/v2/'?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"): y
```

Since the PowerShell Gallery is an untrusted repository, it prompts you to approve the installation
of the module.

## Finding pipeline input the easy way

The MrToolkit module contains a function named `Get-MrPipelineInput`. This cmdlet can be used to
easily determine which parameters of a command accept pipeline input, what type of object they
accept, and if they accept pipeline input **by value** or **by property name**.

```powershell
Get-MrPipelineInput -Name Stop-Service
```

```Output
ParameterName ParameterType                             ValueFromPipeline ValueFromPipelineByPropertyName
------------- -------------                             ----------------- ---------------
InputObject   System.ServiceProcess.ServiceController[]              True           False
Name          System.String[]                                        True            True
```

As you can see, the same information we previously determined by sifting through the help can easily
be determined with this function.

## Summary

In this chapter, you've learned about PowerShell one-liners. You've learned that the number of
physical lines that a command is on has nothing to do with whether or not it's a PowerShell
one-liner. You've also learned about filtering left, the pipeline, and PowerShellGet.

## Review

1. What is a PowerShell one-liner?
1. What are some of the characters where natural line breaks can occur in PowerShell?
1. Why should you filter left?
1. What are the two ways that a PowerShell command can accept pipeline input?
1. Why shouldn't you trust commands found in the PowerShell Gallery?

## Recommended Reading

- [about_Pipelines][about_Pipelines]
- [about_Command_Syntax][about_Command_Syntax]
- [about_Parameters][about_Parameters]
- [PowerShellGet: The BIG EASY way to discover, install, and update PowerShell modules][psget]

<!-- link references-->
[about_Pipelines]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pipelines
[about_Command_Syntax]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_command_syntax
[about_Parameters]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parameters
[psget]: https://mikefrobbins.com/2015/04/23/powershellget-the-big-easy-way-to-discover-install-and-update-powershell-modules/
[PowerShell Gallery]: https://www.powershellgallery.com/

# /./reference/learn/ps101/05-formatting-aliases-providers-comparison.md

    ---
    description: This chapter introduces the concepts of output formatting, command aliases, providers, and comparison operations.
    ms.custom: Contributor-mikefrobbins
    ms.date: 11/16/2022
    ms.reviewer: mirobb
    title: Formatting, aliases, providers, comparison
    ---
# Chapter 5 - Formatting, aliases, providers, comparison

## Requirements

The SQL Server PowerShell module is required by some of the examples shown in this chapter. The
module installs as part of [SQL Server Management Studio (SSMS)][SSMS]. It's also used in
subsequent chapters. Download and install it on your Windows 10 lab environment computer.

## Format Right

In Chapter 4, you learned to filter as far to the left as possible. The rule for manually formatting
a command's output is similar to that rule except it needs to occur as far to the right as possible.

The most common format commands are `Format-Table` and `Format-List`. `Format-Wide` and
`Format-Custom` can also be used, but are less common.

As mentioned in Chapter 3, a command that returns more than four properties defaults to a list
unless custom formatting is used.

```powershell
Get-Service -Name w32time | Select-Object -Property Status, DisplayName, Can*
```

```Output
Status              : Running
DisplayName         : Windows Time
CanPauseAndContinue : False
CanShutdown         : True
CanStop             : True
```

Use the `Format-Table` cmdlet to manually override the formatting and show the output in a table
instead of a list.

```powershell
Get-Service -Name w32time | Select-Object -Property Status, DisplayName, Can* |
Format-Table
```

```Output
 Status DisplayName  CanPauseAndContinue CanShutdown CanStop
 ------ -----------  ------------------- ----------- -------
Running Windows Time               False        True    True
```

The default output for `Get-Service` is three properties in a table.

```powershell
Get-Service -Name w32time
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  w32time            Windows Time
```

Use the `Format-List` cmdlet to override the default formatting and return the results in a list.

```powershell
Get-Service -Name w32time | Format-List
```

```Output
Name                : w32time
DisplayName         : Windows Time
Status              : Running
DependentServices   : {}
ServicesDependedOn  : {}
CanPauseAndContinue : False
CanShutdown         : True
CanStop             : True
ServiceType         : Win32ShareProcess
```

Notice that simply piping `Get-Service` to `Format-List` made it return additional properties. This
doesn't occur with every command because of the way the formatting for that particular command is
set up behind the scenes.

The number one thing to be aware of with the format cmdlets is they produce format objects that are
different than normal objects in PowerShell.

```powershell
Get-Service -Name w32time | Format-List | Get-Member
```

```Output
   TypeName: Microsoft.PowerShell.Commands.Internal.Format.FormatStartData

Name                                    MemberType Definition
----                                    ---------- ----------
Equals                                  Method     bool Equals(System.Object obj)
GetHashCode                             Method     int GetHashCode()
GetType                                 Method     type GetType()
ToString                                Method     string ToString()
autosizeInfo                            Property   Microsoft.PowerShell.Commands.Inter...
ClassId2e4f51ef21dd47e99d3c952918aff9cd Property   string ClassId2e4f51ef21dd47e99d3c9...
groupingEntry                           Property   Microsoft.PowerShell.Commands.Inter...
pageFooterEntry                         Property   Microsoft.PowerShell.Commands.Inter...
pageHeaderEntry                         Property   Microsoft.PowerShell.Commands.Inter...
shapeInfo                               Property   Microsoft.PowerShell.Commands.Inter...

   TypeName: Microsoft.PowerShell.Commands.Internal.Format.GroupStartData

Name                                    MemberType Definition
----                                    ---------- ----------
Equals                                  Method     bool Equals(System.Object obj)
GetHashCode                             Method     int GetHashCode()
GetType                                 Method     type GetType()
ToString                                Method     string ToString()
ClassId2e4f51ef21dd47e99d3c952918aff9cd Property   string ClassId2e4f51ef21dd47e99d3c9...
groupingEntry                           Property   Microsoft.PowerShell.Commands.Inter...
shapeInfo                               Property   Microsoft.PowerShell.Commands.Inter...

   TypeName: Microsoft.PowerShell.Commands.Internal.Format.FormatEntryData

Name                                    MemberType Definition
----                                    ---------- ----------
Equals                                  Method     bool Equals(System.Object obj)
GetHashCode                             Method     int GetHashCode()
GetType                                 Method     type GetType()
ToString                                Method     string ToString()
ClassId2e4f51ef21dd47e99d3c952918aff9cd Property   string ClassId2e4f51ef21dd47e99d3c9...
formatEntryInfo                         Property   Microsoft.PowerShell.Commands.Inter...
outOfBand                               Property   bool outOfBand {get;set;}
writeStream                             Property   Microsoft.PowerShell.Commands.Inter...

   TypeName: Microsoft.PowerShell.Commands.Internal.Format.GroupEndData

Name                                    MemberType Definition
----                                    ---------- ----------
Equals                                  Method     bool Equals(System.Object obj)
GetHashCode                             Method     int GetHashCode()
GetType                                 Method     type GetType()
ToString                                Method     string ToString()
ClassId2e4f51ef21dd47e99d3c952918aff9cd Property   string ClassId2e4f51ef21dd47e99d3c9...
groupingEntry                           Property   Microsoft.PowerShell.Commands.Inter...

   TypeName: Microsoft.PowerShell.Commands.Internal.Format.FormatEndData

Name                                    MemberType Definition
----                                    ---------- ----------
Equals                                  Method     bool Equals(System.Object obj)
GetHashCode                             Method     int GetHashCode()
GetType                                 Method     type GetType()
ToString                                Method     string ToString()
ClassId2e4f51ef21dd47e99d3c952918aff9cd Property   string ClassId2e4f51ef21dd47e99d3c9...
groupingEntry                           Property   Microsoft.PowerShell.Commands.Inter...
```

What this means is format commands can't be piped to most other commands. They can be piped to some
of the `Out-*` commands, but that's about it. This is why you want to perform any formatting at the
very end of the line (format right).

## Aliases

An alias in PowerShell is a shorter name for a command. PowerShell includes a set of built-in
aliases and you can also define your own aliases.

The `Get-Alias` cmdlet is used to find aliases. If you already know the alias for a command, the
**Name** parameter is used to determine what command the alias is associated with.

```powershell
Get-Alias -Name gcm
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           gcm -> Get-Command
```

Multiple aliases can be specified for the value of the **Name** parameter.

```powershell
Get-Alias -Name gcm, gm
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           gcm -> Get-Command
Alias           gm -> Get-Member
```

You'll often see the **Name** parameter omitted since it's a positional parameter.

```powershell
Get-Alias gm
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           gm -> Get-Member
```

If you want to find aliases for a command, you'll need to use the **Definition** parameter.

```powershell
Get-Alias -Definition Get-Command, Get-Member
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           gcm -> Get-Command
Alias           gm -> Get-Member
```

The **Definition** parameter can't be used positionally so it must be specified.

Aliases can save you a few keystrokes and they're fine when you're typing commands into the console.
They shouldn't be used in scripts or any code that you're saving or sharing with others. As
mentioned earlier in this book, using full cmdlet and parameter names is self-documenting and easier
to understand.

Use caution when creating your own aliases because they'll only exist in your current PowerShell
session on your computer.

## Providers

A provider in PowerShell is an interface that allows file system like access to a datastore. There
are a number of built-in providers in PowerShell.

```powershell
Get-PSProvider
```

```Output
Name                 Capabilities                       Drives
----                 ------------                       ------
Registry             ShouldProcess, Transactions        {HKLM, HKCU}
Alias                ShouldProcess                      {Alias}
Environment          ShouldProcess                      {Env}
FileSystem           Filter, ShouldProcess, Credentials {C, A, D}
Function             ShouldProcess                      {Function}
Variable             ShouldProcess                      {Variable}
Certificate          ShouldProcess                      {Cert}
WSMan                Credentials                        {WSMan}
```

As you can see in the previous results, there are built-in providers for the registry, aliases,
environment variables, the file system, functions, variables, certificates, and WSMan.

The actual drives that these providers use to expose their datastore can be determined with the
`Get-PSDrive` cmdlet. The `Get-PSDrive` cmdlet not only displays drives exposed by providers, but it
also displays Windows logical drives including drives mapped to network shares.

```powershell
Get-PSDrive
```

```Output
Name           Used (GB)     Free (GB) Provider      Root
----           ---------     --------- --------      ----
A                                      FileSystem    A:\
Alias                                  Alias
C                  14.41        112.10 FileSystem    C:\
Cert                                   Certificate   \
D                                      FileSystem    D:\
Env                                    Environment
Function                               Function
HKCU                                   Registry      HKEY_CURRENT_USER
HKLM                                   Registry      HKEY_LOCAL_MACHINE
Variable                               Variable
WSMan                                  WSMan
```

Third-party modules such as the Active Directory PowerShell module and the SQLServer PowerShell
module both add their own PowerShell provider and PSDrive.

Import the Active Directory and SQL Server PowerShell modules.

```powershell
Import-Module -Name ActiveDirectory, SQLServer
```

Check to see if any additional PowerShell providers were added.

```powershell
Get-PSProvider
```

```Output
Name                 Capabilities                       Drives
----                 ------------                       ------
Registry             ShouldProcess, Transactions        {HKLM, HKCU}
Alias                ShouldProcess                      {Alias}
Environment          ShouldProcess                      {Env}
FileSystem           Filter, ShouldProcess, Credentials {C, A, D}
Function             ShouldProcess                      {Function}
Variable             ShouldProcess                      {Variable}
ActiveDirectory      Include, Exclude, Filter, Shoul... {AD}
SqlServer            Credentials                        {SQLSERVER}
```

Notice that in the previous set of results, two new PowerShell providers now exist, one for Active
Directory and another one for SQL Server.

A PSDrive for each of those modules was also added.

```powershell
Get-PSDrive
```

```Output
Name           Used (GB)     Free (GB) Provider      Root
----           ---------     --------- --------      ----
A                                      FileSystem    A:\
AD                                     ActiveDire... //RootDSE/
Alias                                  Alias
C                  19.38        107.13 FileSystem    C:\
Cert                                   Certificate   \
D                                      FileSystem    D:\
Env                                    Environment
Function                               Function
HKCU                                   Registry      HKEY_CURRENT_USER
HKLM                                   Registry      HKEY_LOCAL_MACHINE
SQLSERVER                              SqlServer     SQLSERVER:\
Variable                               Variable
WSMan                                  WSMan
```

PSDrives can be accessed just like a traditional file system.

```powershell
Get-ChildItem -Path Cert:\LocalMachine\CA
```

```Output
   PSParentPath: Microsoft.PowerShell.Security\Certificate::LocalMachine\CA

Thumbprint                                Subject
----------                                -------
FEE449EE0E3965A5246F000E87FDE2A065FD89D4  CN=Root Agency
D559A586669B08F46A30A133F8A9ED3D038E2EA8  OU=www.verisign.com/CPS Incorporated LIABI...
109F1CAED645BB78B3EA2B94C0697C740733031C  CN=Microsoft Windows Hardware Compatibility,...
```

## Comparison Operators

PowerShell contains a number of comparison operators that are used to compare values or find values
that match certain patterns. Table 5-1 contains a list of comparison operators in PowerShell.

|    Operator    |                          Definition                          |
| -------------- | ------------------------------------------------------------ |
| `-eq`          | Equal to                                                     |
| `-ne`          | Not equal to                                                 |
| `-gt`          | Greater than                                                 |
| `-ge`          | Greater than or equal to                                     |
| `-lt`          | Less than                                                    |
| `-le`          | Less than or equal to                                        |
| `-Like`        | Match using the `*` wildcard character                       |
| `-NotLike`     | Does not match using the `*` wildcard character              |
| `-Match`       | Matches the specified regular expression                     |
| `-NotMatch`    | Does not match the specified regular expression              |
| `-Contains`    | Determines if a collection contains a specified value        |
| `-NotContains` | Determines if a collection does not contain a specific value |
| `-In`          | Determines if a specified value is in a collection           |
| `-NotIn`       | Determines if a specified value is not in a collection       |
| `-Replace`     | Replaces the specified value                                 |

All of the operators listed in Table 5-1 are case-insensitive. Place a `c` in front of the operator
listed in Table 5-1 to make it case-sensitive. For example, `-ceq` is the case-sensitive version of
the `-eq` comparison operator.

Proper case "PowerShell" is equal to lower case "powershell" using the equals comparison operator.

```powershell
'PowerShell' -eq 'powershell'
```

```Output
True
```

It's not equal using the case-sensitive version of the equals comparison operator.

```powershell
'PowerShell' -ceq 'powershell'
```

```Output
False
```

The not equal comparison operator reverses the condition.

```powershell
'PowerShell' -ne 'powershell'
```

```Output
False
```

Greater than, greater than or equal to, less than, and less than or equal all work with string or
numeric values.

```powershell
5 -gt 5
```

```Output
False
```

Using greater than or equal to instead of greater than with the previous example returns the
**Boolean** true since five is equal to five.

```powershell
5 -ge 5
```

```Output
True
```

Based on the results from the previous two examples, you can probably guess how both less than and
less than or equal to work.

```powershell
5 -lt 10
```

```Output
True
```

The `-Like` and `-Match` operators can be confusing, even for experienced PowerShell users. `-Like`
is used with wildcard the characters `*` and `?` to perform "like" matches.

```powershell
'PowerShell' -like '*shell'
```

```Output
True
```

`-Match` uses a regular expression to perform the matching.

```powershell
'PowerShell' -match '^*.shell$'
```

```Output
True
```

Use the range operator to store the numbers 1 through 10 in a variable.

```powershell
$Numbers = 1..10
```

```Output
```

Determine if the `$Numbers` variable includes 15.

```powershell
$Numbers -contains 15
```

```Output
False
```

Determine if it includes the number 10.

```powershell
$Numbers -contains 10
```

```Output
True
```

`-NotContains` reverses the logic to see if the `$Numbers` variable doesn't contain a value.

```powershell
$Numbers -notcontains 15
```

```Output
True
```

The previous example returns the **Boolean** true because it's true that the `$Numbers` variable
doesn't contain 15. It does however contain the number 10 so it's false when it's tested.

```powershell
$Numbers -notcontains 10
```

```Output
False
```

The "in" comparison operator was first introduced in PowerShell version 3.0. It's used to determine
if a value is "in" an array. The `$Numbers` variable is an array since it contains multiple values.

```powershell
15 -in $Numbers
```

```Output
False
```

In other words, `-in` performs the same test as the contains comparison operator except from the
opposite direction.

```powershell
10 -in $Numbers
```

```Output
True
```

15 isn't in the `$Numbers` array so false is returned in the following example.

```powershell
15 -in $Numbers
```

```Output
False
```

Just like the `-contains` operator, `not` reverses the logic for the `-in` operator.

```powershell
10 -notin $Numbers
```

```Output
False
```

The previous example returns false because the `$Numbers` array does include 10 and the condition
was testing to determine if it didn't contain 10.

15 is "not in" the `$Numbers` array so it returns the **Boolean** true.

```powershell
15 -notin $Numbers
```

```Output
True
```

The `-replace` operator does just want you would think. It's used to replace something. Specifying
one value replaces that value with nothing. In the following example, I replace "Shell" with nothing.

```powershell
'PowerShell' -replace 'Shell'
```

```Output
Power
```

If you want to replace a value with a different value, specify the new value after the pattern you
want to replace. SQL Saturday in Baton Rouge is an event that I try to speak at every year. In the
following example, I replace the word "Saturday" with the abbreviation "Sat".

```powershell
'SQL Saturday - Baton Rouge' -Replace 'saturday','Sat'
```

```Output
SQL Sat - Baton Rouge
```

There are also methods like **Replace()** that can be used to replace things similar to the way the
replace operator works. However, the `-Replace` operator is case-insensitive by default, and the
**Replace()** method is case-sensitive.

```powershell
'SQL Saturday - Baton Rouge'.Replace('saturday','Sat')
```

```Output
SQL Saturday - Baton Rouge
```

Notice that the word "Saturday" wasn't replaced in the previous example. This is because it was
specified in a different case than the original. When the word "Saturday" is specified in the same
case as the original, the **Replace()** method does replace it as expected.

```powershell
'SQL Saturday - Baton Rouge'.Replace('Saturday','Sat')
```

```Output
SQL Sat - Baton Rouge
```

Be careful when using methods to transform data because you can run into unforeseen problems, such
as failing the _Turkey Test_. For an example, see the blog article titled
[Using Pester to Test PowerShell Code with Other Cultures][Using Pester to Test PowerShell Code with Other Cultures]. My recommendation is to use an
operator instead of a method whenever possible to avoid these types of problems.

While the comparison operators can be used as shown in the previous examples, I normally find myself
using them with the `Where-Object` cmdlet to perform some type of filtering.

## Summary

In this chapter, you've learned a number of different topics to include Formatting Right, Aliases,
Providers, and Comparison Operators.

## Review

1. Why is it necessary to perform Formatting as far to the right as possible?
1. How do you determine what the actual cmdlet is for the `%` alias?
1. Why shouldn't you use aliases in scripts you save or code you share with others?
1. Perform a directory listing on the drives that are associated with one of the registry providers.
1. What's one of the main benefits of using the replace operator instead of the replace method?

## Recommended Reading

- [Format-Table][Format-Table]
- [Format-List][Format-List]
- [Format-Wide][Format-Wide]
- [about_Aliases][about_Aliases]
- [about_Providers][about_Providers]
- [about_Comparison_Operators][about_Comparison_Operators]
- [about_Arrays][about_Arrays]

<!-- link references -->
[SSMS]: https://learn.microsoft.com/sql/ssms/download-sql-server-management-studio-ssms
[Format-Table]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/format-table
[Format-List]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/format-list
[Format-Wide]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/format-wide
[about_Aliases]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_aliases
[about_Providers]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_providers
[about_Comparison_Operators]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_comparison_operators
[about_Arrays]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arrays
[Using Pester to Test PowerShell Code with Other Cultures]: https://mikefrobbins.com/2015/10/22/using-pester-to-test-powershell-code-with-other-cultures/

# /./reference/learn/ps101/06-flow-control.md

    ---
    description: PowerShell provides methods to create loops, make decisions, and logically control the flow of code in scripts.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: Flow control
    ---
# Chapter 6 - Flow control

## Scripting

When you move from writing PowerShell one-liners to writing scripts, it sounds a lot more
complicated than it really is. A script is nothing more than the same or similar commands that you
would run interactively in the PowerShell console, except they're saved as a `.PS1` file. There are
some scripting constructs that you may use such as a `foreach` loop instead of the `ForEach-Object`
cmdlet. To beginners, the differences can be confusing especially when you consider that `foreach`
is both a scripting construct and an alias for the `ForEach-Object` cmdlet.

## Looping

One of the great things about PowerShell is, once you figure out how to do something for one item,
it's almost as easy to do the same task for hundreds of items. Simply loop through the items using
one of the many different types of loops in PowerShell.

### ForEach-Object

`ForEach-Object` is a cmdlet for iterating through items in a pipeline such as with PowerShell
one-liners. `ForEach-Object` streams the objects through the pipeline.

Although the **Module** parameter of `Get-Command` accepts multiple values that are strings, it only
accepts them via pipeline input by property name or via parameter input. In the following scenario,
if I want to pipe two strings by value to `Get-Command` for use with the **Module** parameter, I
would need to use the `ForEach-Object` cmdlet.

```powershell
'ActiveDirectory', 'SQLServer' |
   ForEach-Object {Get-Command -Module $_} |
     Group-Object -Property ModuleName -NoElement |
         Sort-Object -Property Count -Descending
```

```Output
Count Name
----- ----
  147 ActiveDirectory
   82 SqlServer
```

In the previous example, `$_` is the current object. Beginning with PowerShell version 3.0,
`$PSItem` can be used instead of `$_`. But I find that most experienced PowerShell users still
prefer using `$_` since it's backward compatible and less to type.

When using the `foreach` keyword, you must store all of the items in memory before iterating through
them, which could be difficult if you don't know how many items you're working with.

```powershell
$ComputerName = 'DC01', 'WEB01'
foreach ($Computer in $ComputerName) {
  Get-ADComputer -Identity $Computer
}
```

```Output
DistinguishedName : CN=DC01,OU=Domain Controllers,DC=mikefrobbins,DC=com
DNSHostName       : dc01.mikefrobbins.com
Enabled           : True
Name              : DC01
ObjectClass       : computer
ObjectGUID        : c38da20c-a484-469d-ba4c-bab3fb71ae8e
SamAccountName    : DC01$
SID               : S-1-5-21-2989741381-570885089-3319121794-1001
UserPrincipalName :

DistinguishedName : CN=WEB01,CN=Computers,DC=mikefrobbins,DC=com
DNSHostName       : web01.mikefrobbins.com
Enabled           : True
Name              : WEB01
ObjectClass       : computer
ObjectGUID        : 33aa530e-1e31-40d8-8c78-76a18b673c33
SamAccountName    : WEB01$
SID               : S-1-5-21-2989741381-570885089-3319121794-1107
UserPrincipalName :
```

Many times a loop such as `foreach` or `ForEach-Object` is necessary. Otherwise you'll receive an
error message.

```powershell
Get-ADComputer -Identity 'DC01', 'WEB01'
```

```Output
Get-ADComputer : Cannot convert 'System.Object[]' to the type
'Microsoft.ActiveDirectory.Management.ADComputer' required by parameter 'Identity'.
Specified method is not supported.
At line:1 char:26
+ Get-ADComputer -Identity 'DC01', 'WEB01'
+                          ~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (:) [Get-ADComputer], ParameterBindingExc
   eption
    + FullyQualifiedErrorId : CannotConvertArgument,Microsoft.ActiveDirectory.Management
   .Commands.GetADComputer
```

Other times, you can get the same results while eliminating the loop altogether. Consult the cmdlet
help to understand your options.

```powershell
'DC01', 'WEB01' | Get-ADComputer
```

```Output
DistinguishedName : CN=DC01,OU=Domain Controllers,DC=mikefrobbins,DC=com
DNSHostName       : dc01.mikefrobbins.com
Enabled           : True
Name              : DC01
ObjectClass       : computer
ObjectGUID        : c38da20c-a484-469d-ba4c-bab3fb71ae8e
SamAccountName    : DC01$
SID               : S-1-5-21-2989741381-570885089-3319121794-1001
UserPrincipalName :

DistinguishedName : CN=WEB01,CN=Computers,DC=mikefrobbins,DC=com
DNSHostName       : web01.mikefrobbins.com
Enabled           : True
Name              : WEB01
ObjectClass       : computer
ObjectGUID        : 33aa530e-1e31-40d8-8c78-76a18b673c33
SamAccountName    : WEB01$
SID               : S-1-5-21-2989741381-570885089-3319121794-1107
UserPrincipalName :
```

As you can see in the previous examples, the **Identity** parameter for `Get-ADComputer` only accepts a
single value when provided via parameter input, but it allows for multiple items when the input is
provided via pipeline input.

### For

A `for` loop iterates while a specified condition is true. The `for` loop is not something that I
use often, but it does have its uses.

```powershell
for ($i = 1; $i -lt 5; $i++) {
  Write-Output "Sleeping for $i seconds"
  Start-Sleep -Seconds $i
}
```

```Output
Sleeping for 1 seconds
Sleeping for 2 seconds
Sleeping for 3 seconds
Sleeping for 4 seconds
```

In the previous example, the loop will iterate four times by starting off with the number one and
continue as long as the counter variable `$i` is less than 5. It will sleep for a total of 10
seconds.

### Do

There are two different `do` loops in PowerShell. `Do Until` runs while the specified condition is
false.

```powershell
$number = Get-Random -Minimum 1 -Maximum 10
do {
  $guess = Read-Host -Prompt "What's your guess?"
  if ($guess -lt $number) {
    Write-Output 'Too low!'
  }
  elseif ($guess -gt $number) {
    Write-Output 'Too high!'
  }
}
until ($guess -eq $number)
```

```Output
What's your guess?: 1
Too low!
What's your guess?: 2
Too low!
What's your guess?: 3
```

The previous example is a numbers game that continues until the value you guess equals the same
number that the `Get-Random` cmdlet generated.

`Do While` is just the opposite. It runs as long as the specified condition evaluates to true.

```powershell
$number = Get-Random -Minimum 1 -Maximum 10
do {
  $guess = Read-Host -Prompt "What's your guess?"
  if ($guess -lt $number) {
    Write-Output 'Too low!'
  } elseif ($guess -gt $number) {
    Write-Output 'Too high!'
  }
}
while ($guess -ne $number)
```

```Output
What's your guess?: 1
Too low!
What's your guess?: 2
Too low!
What's your guess?: 3
Too low!
What's your guess?: 4
```

The same results are achieved with a `Do While` loop by reversing the test condition to not equals.

`Do` loops always run at least once because the condition is evaluated at the end of the loop.

### While

Similar to the `Do While` loop, a `While` loop runs as long as the specified condition is true. The
difference however, is that a `While` loop evaluates the condition at the top of the loop before any
code is run. So it doesn't run if the condition evaluates to false.

```powershell
$date = Get-Date -Date 'November 22'
while ($date.DayOfWeek -ne 'Thursday') {
  $date = $date.AddDays(1)
}
Write-Output $date
```

```Output
Thursday, November 23, 2017 12:00:00 AM
```

The previous example calculates what day Thanksgiving Day is on in the United States. It's always on
the fourth Thursday of November. So the loop starts with the 22nd day of November and adds a day
while the day of the week isn't equal to Thursday. If the 22nd is a Thursday, the loop doesn't run
at all.

## Break, Continue, and Return

`Break` is designed to break out of a loop. It's also commonly used with the `switch` statement.

```powershell
for ($i = 1; $i -lt 5; $i++) {
  Write-Output "Sleeping for $i seconds"
  Start-Sleep -Seconds $i
  break
}
```

```Output
Sleeping for 1 seconds
```

The `break` statement shown in the previous example causes the loop to exit on the first iteration.

Continue is designed to skip to the next iteration of a loop.

```powershell
while ($i -lt 5) {
  $i += 1
  if ($i -eq 3) {
    continue
  }
  Write-Output $i
}
```

```Output
1
2
4
5
```

The previous example will output the numbers 1, 2, 4, and 5. It skips number 3 and continues with
the next iteration of the loop. Similar to `break`, `continue` breaks out of the loop except only
for the current iteration. Execution continues with the next iteration instead of breaking out of
the loop and stopping.

Return is designed to exit out of the existing scope.

```powershell
$number = 1..10
foreach ($n in $number) {
  if ($n -ge 4) {
    Return $n
  }
}
```

```Output
4
```

Notice that in the previous example, return outputs the first result and then exits out of the
loop. A more thorough explanation of the result statement can be found in one of my blog articles:
["The PowerShell return keyword"]["The PowerShell return keyword"].

## Summary

In this chapter, you've learned about the different types of loops that exist in PowerShell.

## Review

1. What is the difference in the `ForEach-Object` cmdlet and the foreach scripting construct?
1. What is the primary advantage of using a While loop instead of a Do While or Do Until loop.
1. How do the break and continue statements differ?

## Recommended Reading

- [ForEach-Object][ForEach-Object]
- [about_ForEach][about_ForEach]
- [about_For][about_For]
- [about_Do][about_Do]
- [about_While][about_While]
- [about_Break][about_Break]
- [about_Continue][about_Continue]
- [about_Return][about_Return]

<!-- link references -->
[ForEach-Object]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/foreach-object
[about_ForEach]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_foreach
[about_For]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_for
[about_Do]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_do
[about_While]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_while
[about_Break]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_break
[about_Continue]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_continue
[about_Return]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_return
["The PowerShell return keyword"]: https://mikefrobbins.com/2015/07/23/the-powershell-return-keyword/

# /./reference/learn/ps101/07-working-with-wmi.md

    ---
    description: PowerShell has had cmdlets for working with WMI since the beginning.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: Working with WMI
    ---
# Chapter 7 - Working with WMI

## WMI and CIM

Windows PowerShell ships by default with cmdlets for working with other technologies such as Windows Management Instrumentation (WMI). The WMI cmdlets are deprecated and are not available in PowerShell 6+, but are covered here as you may encounter them in older scripts running on Windows PowerShell. For new development, use the CIM cmdlets instead.

There are several native WMI cmdlets that exist in PowerShell without having to install any additional software or modules.  `Get-Command` can be used to
determine what WMI cmdlets exist in Windows PowerShell. The following results are from my Windows 10 lab environment computer that is running PowerShell version 5.1. Your results may differ depending on what PowerShell version you're running. 

```powershell
Get-Command -Noun WMI*
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Get-WmiObject                                      3.1.0.0    Microsof...
Cmdlet          Invoke-WmiMethod                                   3.1.0.0    Microsof...
Cmdlet          Register-WmiEvent                                  3.1.0.0    Microsof...
Cmdlet          Remove-WmiObject                                   3.1.0.0    Microsof...
Cmdlet          Set-WmiInstance                                    3.1.0.0    Microsof...
```

Common Information Model (CIM) cmdlets were introduced in PowerShell version 3.0. The CIM cmdlets
are designed so they can be used on both Windows and non-Windows machines. 

The CIM cmdlets are all contained within a module. To obtain a list of the CIM cmdlets, use
`Get-Command` with the **Module** parameter as shown in the following example.

```powershell
Get-Command -Module CimCmdlets
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Export-BinaryMiLog                                 1.0.0.0    CimCmdlets
Cmdlet          Get-CimAssociatedInstance                          1.0.0.0    CimCmdlets
Cmdlet          Get-CimClass                                       1.0.0.0    CimCmdlets
Cmdlet          Get-CimInstance                                    1.0.0.0    CimCmdlets
Cmdlet          Get-CimSession                                     1.0.0.0    CimCmdlets
Cmdlet          Import-BinaryMiLog                                 1.0.0.0    CimCmdlets
Cmdlet          Invoke-CimMethod                                   1.0.0.0    CimCmdlets
Cmdlet          New-CimInstance                                    1.0.0.0    CimCmdlets
Cmdlet          New-CimSession                                     1.0.0.0    CimCmdlets
Cmdlet          New-CimSessionOption                               1.0.0.0    CimCmdlets
Cmdlet          Register-CimIndicationEvent                        1.0.0.0    CimCmdlets
Cmdlet          Remove-CimInstance                                 1.0.0.0    CimCmdlets
Cmdlet          Remove-CimSession                                  1.0.0.0    CimCmdlets
Cmdlet          Set-CimInstance                                    1.0.0.0    CimCmdlets
```

The CIM cmdlets still allow you to work with WMI so don't be confused when someone makes the
statement "When I query WMI with the PowerShell CIM cmdlets..."

As I previously mentioned, WMI is a separate technology from PowerShell and you're just using the
CIM cmdlets for accessing WMI. You may find an old VBScript that uses WMI Query Language (WQL) to
query WMI such as in the following example.

```vb
strComputer = "."
Set objWMIService = GetObject("winmgmts:" _
    & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")

Set colBIOS = objWMIService.ExecQuery _
    ("Select * from Win32_BIOS")

For each objBIOS in colBIOS
    Wscript.Echo "Manufacturer: " & objBIOS.Manufacturer
    Wscript.Echo "Name: " & objBIOS.Name
    Wscript.Echo "Serial Number: " & objBIOS.SerialNumber
    Wscript.Echo "SMBIOS Version: " & objBIOS.SMBIOSBIOSVersion
    Wscript.Echo "Version: " & objBIOS.Version
Next
```

You can take the WQL query from that VBScript and use it with the `Get-CimInstance` cmdlet without
any modifications.

```powershell
Get-CimInstance -Query 'Select * from Win32_BIOS'
```

```Output
SMBIOSBIOSVersion : 090006
Manufacturer      : American Megatrends Inc.
Name              : Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz
SerialNumber      : 3810-1995-1654-4615-2295-2755-89
Version           : VRTUAL - 4001628
```

That's not how I typically query WMI with PowerShell. But it does work and allows you to easily
migrate existing VBScripts to PowerShell. When I start out writing a one-liner to query WMI, I use
the following syntax.

```powershell
Get-CimInstance -ClassName Win32_BIOS
```

```Output
SMBIOSBIOSVersion : 090006
Manufacturer      : American Megatrends Inc.
Name              : Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz
SerialNumber      : 3810-1995-1654-4615-2295-2755-89
Version           : VRTUAL - 4001628
```

If I only want the serial number, I can pipe the output to `Select-Object` and specify only the
**SerialNumber** property.

```powershell
Get-CimInstance -ClassName Win32_BIOS | Select-Object -Property SerialNumber
```

```Output
SerialNumber
------------
3810-1995-1654-4615-2295-2755-89
```

By default, there are several properties that are retrieved behind the scenes that are never used.
It may not matter much when querying WMI on the local computer. But once you start querying remote
computers, it's not only additional processing time to return that information, but also additional
unnecessary information to have to pull across the network. `Get-CimInstance` has a **Property**
parameter that limits the information that's retrieved. This makes the query to WMI more efficient.

```powershell
Get-CimInstance -ClassName Win32_BIOS -Property SerialNumber |
Select-Object -Property SerialNumber
```

```Output
SerialNumber
------------
3810-1995-1654-4615-2295-2755-89
```

The previous results returned an object. To return a simple string, use the **ExpandProperty**
parameter.

```powershell
Get-CimInstance -ClassName Win32_BIOS -Property SerialNumber |
Select-Object -ExpandProperty SerialNumber
```

```Output
3810-1995-1654-4615-2295-2755-89
```

You could also use the dotted style of syntax to return a simple string. This eliminates the need to
pipe to `Select-Object`.

```powershell
(Get-CimInstance -ClassName Win32_BIOS -Property SerialNumber).SerialNumber
```

```Output
3810-1995-1654-4615-2295-2755-89
```

## Query Remote Computers with the CIM cmdlets

I'm still running PowerShell as a local admin who is a domain user. When I try to query information
from a remote computer using the `Get-CimInstance` cmdlet, I receive an access denied error message.

```powershell
Get-CimInstance -ComputerName dc01 -ClassName Win32_BIOS
```

```Output
Get-CimInstance : Access is denied.
At line:1 char:1
+ Get-CimInstance -ComputerName dc01 -ClassName Win32_BIOS
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : PermissionDenied: (root\cimv2:Win32_BIOS:String) [Get-CimI
   nstance], CimException
    + FullyQualifiedErrorId : HRESULT 0x80070005,Microsoft.Management.Infrastructure.Cim
   Cmdlets.GetCimInstanceCommand
    + PSComputerName        : dc01
```

Many people have security concerns when it comes to PowerShell, but the truth is you have exactly
the same permissions in PowerShell as you do in the GUI. No more and no less. The problem in the
previous example is that the user running PowerShell doesn't have rights to query WMI information
from the DC01 server. I could relaunch PowerShell as a domain administrator since `Get-CimInstance`
doesn't have a **Credential** parameter. But, trust me, that isn't a good idea because then anything
that I run from PowerShell would be running as a domain admin. That could be dangerous from a
security standpoint depending on the situation.

Using the principle of least privilege, I elevate to my domain admin account on a per command basis
using the **Credential** parameter, if a command has one. `Get-CimInstance` doesn't have a
**Credential** parameter so the solution in this scenario is to create a **CimSession** first. Then
I use the **CimSession** instead of a computer name to query WMI on the remote computer.

```powershell
$CimSession = New-CimSession -ComputerName dc01 -Credential (Get-Credential)
```

```Output
cmdlet Get-Credential at command pipeline position 1
Supply values for the following parameters:
Credential
```

The CIM session was stored in a variable named `$CimSession`. Notice that I also specified the
`Get-Credential` cmdlet in parentheses so that it executes first, prompting me for alternate
credentials, before creating the new session. I'll show you another more efficient way to specify
alternate credentials later in this chapter, but it's important to understand this basic concept
before making it more complicated.

The CIM session created in the previous example can now be used with the `Get-CimInstance` cmdlet to
query the BIOS information from WMI on the remote computer.

```powershell
Get-CimInstance -CimSession $CimSession -ClassName Win32_BIOS
```

```Output
SMBIOSBIOSVersion : 090006
Manufacturer      : American Megatrends Inc.
Name              : Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz
SerialNumber      : 0986-6980-3916-0512-6608-8243-13
Version           : VRTUAL - 4001628
PSComputerName    : dc01
```

There are several additional benefits to using CIM sessions instead of just specifying a computer
name. When running multiple queries to the same computer, using a CIM session is more efficient than
using the computer name for each query. Creating a CIM session only sets up the connection once.
Then, multiple queries use that same session to retrieve information. Using the computer name
requires the cmdlets to set up and tear down the connection with each individual query.

The `Get-CimInstance` cmdlet uses the WSMan protocol by default, which means the remote computer
needs PowerShell version 3.0 or higher to connect. It's actually not the PowerShell version that
matters, it's the stack version. The stack version can be determined using the `Test-WSMan` cmdlet.
It needs to be version 3.0. That's the version you'll find with PowerShell version 3.0 and higher.

```powershell
Test-WSMan -ComputerName dc01
```

```Output
wsmid           : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd
ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd
ProductVendor   : Microsoft Corporation
ProductVersion  : OS: 0.0.0 SP: 0.0 Stack: 3.0
```

The older WMI cmdlets use the DCOM protocol, which is compatible with older versions of Windows. But
DCOM is typically blocked by the firewall on newer versions of Windows. The `New-CimSessionOption`
cmdlet allows you to create a DCOM protocol connection for use with `New-CimSession`. This allows
the `Get-CimInstance` cmdlet to be used to communicate with versions of Windows as old as Windows
Server 2000. This also means that PowerShell is not required on the remote computer when using the
`Get-CimInstance` cmdlet with a CimSession that's configured to use the DCOM protocol.

Create the DCOM protocol option using the `New-CimSessionOption` cmdlet and store it in a variable.

```powershell
$DCOM = New-CimSessionOption -Protocol Dcom
```

For efficiency, you can store your domain administrator or elevated credentials in a variable so you
don't have to constantly enter them for each command.

```powershell
$Cred = Get-Credential
```

```Output
cmdlet Get-Credential at command pipeline position 1
Supply values for the following parameters:
Credential
```

I have a server named SQL03 that runs Windows Server 2008 (non-R2). It's the newest Windows Server
operating system that doesn't have PowerShell installed by default.

Create a **CimSession** to SQL03 using the DCOM protocol.

```powershell
$CimSession = New-CimSession -ComputerName sql03 -SessionOption $DCOM -Credential $Cred
```

Notice in the previous command, this time I specified the variable named `$Cred` as the value for
the **Credential** parameter instead of having to enter them manually again.

The output of the query is the same regardless of the underlying protocol being used.

```powershell
Get-CimInstance -CimSession $CimSession -ClassName Win32_BIOS
```

```Output
SMBIOSBIOSVersion : 090006
Manufacturer      : American Megatrends Inc.
Name              : Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz
SerialNumber      : 7237-7483-8873-8926-7271-5004-86
Version           : VRTUAL - 4001628
PSComputerName    : sql03
```

The `Get-CimSession` cmdlet is used to see what **CimSessions** are currently connected and what
protocols they're using.

```powershell
Get-CimSession
```

```Output
Id           : 1
Name         : CimSession1
InstanceId   : 80742787-e38e-41b1-a7d7-fa1369cf1402
ComputerName : dc01
Protocol     : WSMAN

Id           : 2
Name         : CimSession2
InstanceId   : 8fcabd81-43cf-4682-bd53-ccce1e24aecb
ComputerName : sql03
Protocol     : DCOM
```

Retrieve and store both of the previously created **CimSessions** in a variable named `$CimSession`.

```powershell
$CimSession = Get-CimSession
```

Query both of the computers with one command, one using the WSMan protocol and the other one with
DCOM.

```powershell
Get-CimInstance -CimSession $CimSession -ClassName Win32_BIOS
```

```Output
SMBIOSBIOSVersion : 090006
Manufacturer      : American Megatrends Inc.
Name              : Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz
SerialNumber      : 0986-6980-3916-0512-6608-8243-13
Version           : VRTUAL - 4001628
PSComputerName    : dc01

SMBIOSBIOSVersion : 090006
Manufacturer      : American Megatrends Inc.
Name              : Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz
SerialNumber      : 7237-7483-8873-8926-7271-5004-86
Version           : VRTUAL - 4001628
PSComputerName    : sql03
```

I've written numerous blog articles about the WMI and CIM cmdlets. One of the most useful ones is
about a function that I created to automatically determine if WSMan or DCOM should be used and set
up the CIM session automatically without having to figure out which one manually. That blog article
is titled [PowerShell Function to Create CimSessions to Remote Computers with Fallback to Dcom].

When you're finished with the CIM sessions, you should remove them with the `Remove-CimSession`
cmdlet. To remove all CIM sessions, simply pipe `Get-CimSession` to `Remove-CimSession`.

```powershell
Get-CimSession | Remove-CimSession
```

## Summary

In this chapter, you've learned about using PowerShell to work with WMI on both local and remote
computers. You've also learned how to use the CIM cmdlets to work with remote computers with both
the WSMan or DCOM protocol.

## Review

1. What is the difference in the WMI and CIM cmdlets?
1. By default, what protocol does the `Get-CimInstance` cmdlet use?
1. What are some of the benefits of using a CIM session instead of specifying a computer name with
   `Get-CimInstance`?
1. How do you specify an alternate protocol other than the default one for use with
   `Get-CimInstance`?
1. How do you close or remove CIM sessions?

## Recommended Reading

- [about_WMI][about_WMI]
- [about_WMI_Cmdlets][about_WMI_Cmdlets]
- [about_WQL][about_WQL]
- [CimCmdlets Module][CimCmdlets Module]
- [Video: Using CIM Cmdlets and CIM Sessions][Video: Using CIM Cmdlets and CIM Sessions]

<!-- link references -->
[about_WMI]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_wmi
[about_WMI_Cmdlets]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_wmi_cmdlets
[about_WQL]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_wql
[CimCmdlets Module]: https://learn.microsoft.com/powershell/module/cimcmdlets/
[Video: Using CIM Cmdlets and CIM Sessions]: https://mikefrobbins.com/2013/09/12/phillyposh-user-group-meeting-presentation-follow-up-powershell-second-hop-problem-with-cimsessions/
[PowerShell Function to Create CimSessions to Remote Computers with Fallback to Dcom]: https://mikefrobbins.com/2014/08/28/powershell-function-to-create-cimsessions-to-remote-computers-with-fallback-to-dcom/

# /./reference/learn/ps101/08-powershell-remoting.md

    ---
    description: There are many different ways to run commands against remote computers in PowerShell.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: PowerShell remoting
    ---
# Chapter 8 - PowerShell remoting

PowerShell has many different ways to run commands against remote computers. In the last chapter,
you saw how to remotely query WMI using the CIM cmdlets. PowerShell also includes several cmdlets
that have a built-in **ComputerName** parameter.

As shown in the following example, `Get-Command` can be used with the **ParameterName** parameter to
determine what commands have a **ComputerName** parameter.

```powershell
Get-Command -ParameterName ComputerName
```

```Output
CommandType     Name                           Version    Source
-----------     ----                           -------    ------
Cmdlet          Add-Computer                   3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Clear-EventLog                 3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Connect-PSSession              3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Enter-PSSession                3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Get-EventLog                   3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Get-HotFix                     3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Get-Process                    3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Get-PSSession                  3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Get-Service                    3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Get-WmiObject                  3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Invoke-Command                 3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Invoke-WmiMethod               3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Limit-EventLog                 3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          New-EventLog                   3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          New-PSSession                  3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Receive-Job                    3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Receive-PSSession              3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Register-WmiEvent              3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Remove-Computer                3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Remove-EventLog                3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Remove-PSSession               3.0.0.0    Microsoft.PowerShell.Core
Cmdlet          Remove-WmiObject               3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Rename-Computer                3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Restart-Computer               3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Send-MailMessage               3.1.0.0    Microsoft.PowerShell.Utility
Cmdlet          Set-Service                    3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Set-WmiInstance                3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Show-EventLog                  3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Stop-Computer                  3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Test-Connection                3.1.0.0    Microsoft.PowerShell.Management
Cmdlet          Write-EventLog                 3.1.0.0    Microsoft.PowerShell.Management
```

Commands such as `Get-Process` and `Get-Hotfix` have a **ComputerName** parameter. This isn't the
long-term direction that Microsoft is heading for running commands against remote computers. Even if
you find a command that has a **ComputerName** parameter, chances are that you'll need to specify
alternate credentials and it won't have a **Credential** parameter. And if you decided to run
PowerShell from an elevated account, a firewall between you and the remote computer can block the
request.

To use the PowerShell remoting commands that are demonstrated in this chapter, PowerShell remoting
must be enabled on the remote computer. Use the `Enable-PSRemoting` cmdlet to enable PowerShell
remoting.

```powershell
Enable-PSRemoting
```

```Output
WinRM has been updated to receive requests.
WinRM service type changed successfully.
WinRM service started.

WinRM has been updated for remote management.
WinRM firewall exception enabled.
```

## One-To-One Remoting

If you want your remote session to be interactive, then one-to-one remoting is what you want.
This type of remoting is provided via the `Enter-PSSession` cmdlet.

In the last chapter, I stored my domain admin credentials in a variable named `$Cred`. If you
haven't already done so, go ahead and store your domain admin credentials in the `$Cred` variable.

This allows you to enter the credentials once and use them on a per command basis as long as your
current PowerShell session is active.

```powershell
$Cred = Get-Credential
```

Create a one-to-one PowerShell remoting session to the domain controller named dc01.

```powershell
Enter-PSSession -ComputerName dc01 -Credential $Cred
```

```Output
[dc01]: PS C:\Users\Administrator\Documents>
```

Notice that in the previous example that the PowerShell prompt is preceded by `[dc01]`. This means
you're in an interactive PowerShell session to the remote computer named dc01. Any commands you
execute run on dc01, not on your local computer. Also, keep in mind that you only have access to the
PowerShell commands that exist on the remote computer and not the ones on your local computer. In
other words, if you've installed additional modules on your computer, they aren't accessible on the
remote computer.

When you're connected to a remote computer via a one-to-one interactive PowerShell remoting session,
you're effectively sitting at the remote computer. The objects are normal objects just like the ones
you've been working with throughout this entire book.

```powershell
[dc01]:  Get-Process | Get-Member
```

```Output
   TypeName: System.Diagnostics.Process

Name                       MemberType     Definition
----                       ----------     ----------
Handles                    AliasProperty  Handles = Handlecount
Name                       AliasProperty  Name = ProcessName
NPM                        AliasProperty  NPM = NonpagedSystemMemorySize64
PM                         AliasProperty  PM = PagedMemorySize64
SI                         AliasProperty  SI = SessionId
VM                         AliasProperty  VM = VirtualMemorySize64
WS                         AliasProperty  WS = WorkingSet64
Disposed                   Event          System.EventHandler Disposed(System.Object, ...
ErrorDataReceived          Event          System.Diagnostics.DataReceivedEventHandler ...
Exited                     Event          System.EventHandler Exited(System.Object, Sy...
OutputDataReceived         Event          System.Diagnostics.DataReceivedEventHandler ...
BeginErrorReadLine         Method         void BeginErrorReadLine()
BeginOutputReadLine        Method         void BeginOutputReadLine()
CancelErrorRead            Method         void CancelErrorRead()
CancelOutputRead           Method         void CancelOutputRead()
Close                      Method         void Close()
CloseMainWindow            Method         bool CloseMainWindow()
CreateObjRef               Method         System.Runtime.Remoting.ObjRef CreateObjRef(...
Dispose                    Method         void Dispose(), void IDisposable.Dispose()
Equals                     Method         bool Equals(System.Object obj)
GetHashCode                Method         int GetHashCode()
GetLifetimeService         Method         System.Object GetLifetimeService()
GetType                    Method         type GetType()
InitializeLifetimeService  Method         System.Object InitializeLifetimeService()
Kill                       Method         void Kill()
Refresh                    Method         void Refresh()
Start                      Method         bool Start()
ToString                   Method         string ToString()
WaitForExit                Method         bool WaitForExit(int milliseconds), void Wai...
WaitForInputIdle           Method         bool WaitForInputIdle(int milliseconds), boo...
__NounName                 NoteProperty   string __NounName=Process
BasePriority               Property       int BasePriority {get;}
Container                  Property       System.ComponentModel.IContainer Container {...
EnableRaisingEvents        Property       bool EnableRaisingEvents {get;set;}
ExitCode                   Property       int ExitCode {get;}
ExitTime                   Property       datetime ExitTime {get;}
Handle                     Property       System.IntPtr Handle {get;}
HandleCount                Property       int HandleCount {get;}
HasExited                  Property       bool HasExited {get;}
Id                         Property       int Id {get;}
MachineName                Property       string MachineName {get;}
MainModule                 Property       System.Diagnostics.ProcessModule MainModule ...
MainWindowHandle           Property       System.IntPtr MainWindowHandle {get;}
MainWindowTitle            Property       string MainWindowTitle {get;}
MaxWorkingSet              Property       System.IntPtr MaxWorkingSet {get;set;}
MinWorkingSet              Property       System.IntPtr MinWorkingSet {get;set;}
Modules                    Property       System.Diagnostics.ProcessModuleCollection M...
NonpagedSystemMemorySize   Property       int NonpagedSystemMemorySize {get;}
NonpagedSystemMemorySize64 Property       long NonpagedSystemMemorySize64 {get;}
PagedMemorySize            Property       int PagedMemorySize {get;}
PagedMemorySize64          Property       long PagedMemorySize64 {get;}
PagedSystemMemorySize      Property       int PagedSystemMemorySize {get;}
PagedSystemMemorySize64    Property       long PagedSystemMemorySize64 {get;}
PeakPagedMemorySize        Property       int PeakPagedMemorySize {get;}
PeakPagedMemorySize64      Property       long PeakPagedMemorySize64 {get;}
PeakVirtualMemorySize      Property       int PeakVirtualMemorySize {get;}
PeakVirtualMemorySize64    Property       long PeakVirtualMemorySize64 {get;}
PeakWorkingSet             Property       int PeakWorkingSet {get;}
PeakWorkingSet64           Property       long PeakWorkingSet64 {get;}
PriorityBoostEnabled       Property       bool PriorityBoostEnabled {get;set;}
PriorityClass              Property       System.Diagnostics.ProcessPriorityClass Prio...
PrivateMemorySize          Property       int PrivateMemorySize {get;}
PrivateMemorySize64        Property       long PrivateMemorySize64 {get;}
PrivilegedProcessorTime    Property       timespan PrivilegedProcessorTime {get;}
ProcessName                Property       string ProcessName {get;}
ProcessorAffinity          Property       System.IntPtr ProcessorAffinity {get;set;}
Responding                 Property       bool Responding {get;}
SafeHandle                 Property       Microsoft.Win32.SafeHandles.SafeProcessHandl...
SessionId                  Property       int SessionId {get;}
Site                       Property       System.ComponentModel.ISite Site {get;set;}
StandardError              Property       System.IO.StreamReader StandardError {get;}
StandardInput              Property       System.IO.StreamWriter StandardInput {get;}
StandardOutput             Property       System.IO.StreamReader StandardOutput {get;}
StartInfo                  Property       System.Diagnostics.ProcessStartInfo StartInf...
StartTime                  Property       datetime StartTime {get;}
SynchronizingObject        Property       System.ComponentModel.ISynchronizeInvoke Syn...
Threads                    Property       System.Diagnostics.ProcessThreadCollection T...
TotalProcessorTime         Property       timespan TotalProcessorTime {get;}
UserProcessorTime          Property       timespan UserProcessorTime {get;}
VirtualMemorySize          Property       int VirtualMemorySize {get;}
VirtualMemorySize64        Property       long VirtualMemorySize64 {get;}
WorkingSet                 Property       int WorkingSet {get;}
WorkingSet64               Property       long WorkingSet64 {get;}
PSConfiguration            PropertySet    PSConfiguration {Name, Id, PriorityClass, Fi...
PSResources                PropertySet    PSResources {Name, Id, Handlecount, WorkingS...
Company                    ScriptProperty System.Object Company {get=$this.Mainmodule....
CPU                        ScriptProperty System.Object CPU {get=$this.TotalProcessorT...
Description                ScriptProperty System.Object Description {get=$this.Mainmod...
FileVersion                ScriptProperty System.Object FileVersion {get=$this.Mainmod...
Path                       ScriptProperty System.Object Path {get=$this.Mainmodule.Fil...
Product                    ScriptProperty System.Object Product {get=$this.Mainmodule....
ProductVersion             ScriptProperty System.Object ProductVersion {get=$this.Main...
[dc01]:
```

When you're done working with the remote computer, exit the one-to-one remoting session by using the
`Exit-PSSession` cmdlet.

```powershell
[dc01]:  Exit-PSSession
```

## One-To-Many Remoting

Sometimes you may need to perform a task interactively on a remote computer. But remoting is much
more powerful when performing a task on multiple remote computers at the same time. Use the
`Invoke-Command` cmdlet to run a command against one or more remote computers at the same time.

```powershell
Invoke-Command -ComputerName dc01, sql02, web01 {Get-Service -Name W32time} -Credential $Cred
```

```Output
Status   Name        DisplayName       PSComputerName
------   ----        -----------       --------------
Running  W32time     Windows Time      web01
Start... W32time     Windows Time      dc01
Running  W32time     Windows Time      sql02
```

In the previous example, three servers were queried for the status of the Windows Time service. The
`Get-Service` cmdlet was placed inside the script block of `Invoke-Command`. `Get-Service` actually
runs on the remote computer and the results are returned to your local computer as deserialized
objects.

Piping the previous command to `Get-Member` shows that the results are indeed deserialized objects.

```powershell
Invoke-Command -ComputerName dc01, sql02, web01 {Get-Service -Name W32time} -Credential $Cred | Get-Member
```

```Output
   TypeName: Deserialized.System.ServiceProcess.ServiceController

Name                MemberType   Definition
----                ----------   ----------
GetType             Method       type GetType()
ToString            Method       string ToString(), string ToString(string format, Sys...
Name                NoteProperty string Name=W32time
PSComputerName      NoteProperty string PSComputerName=sql02
PSShowComputerName  NoteProperty bool PSShowComputerName=True
RequiredServices    NoteProperty Deserialized.System.ServiceProcess.ServiceController[...
RunspaceId          NoteProperty guid RunspaceId=570313c4-ac84-4109-bf67-c6b33236af0a
CanPauseAndContinue Property     System.Boolean {get;set;}
CanShutdown         Property     System.Boolean {get;set;}
CanStop             Property     System.Boolean {get;set;}
Container           Property      {get;set;}
DependentServices   Property     Deserialized.System.ServiceProcess.ServiceController[...
DisplayName         Property     System.String {get;set;}
MachineName         Property     System.String {get;set;}
ServiceHandle       Property     System.String {get;set;}
ServiceName         Property     System.String {get;set;}
ServicesDependedOn  Property     Deserialized.System.ServiceProcess.ServiceController[...
ServiceType         Property     System.String {get;set;}
Site                Property      {get;set;}
StartType           Property     System.String {get;set;}
Status              Property     System.String {get;set;}
```

Notice that the majority of the methods are missing on deserialized objects. This means they're not
live objects; they're inert. You can't start or stop a service using a deserialized object because
it's a snapshot of the state of that object the point when the command ran on the remote computer.

That doesn't mean you can't start or stop a service using a method with `Invoke-Command` though. It
just means that the method has to be called in the remote session.

I'll stop the Windows Time service on all three of those remote servers using the **Stop()** method
to prove this point.

```powershell
Invoke-Command -ComputerName dc01, sql02, web01 {(Get-Service -Name W32time).Stop()} -Credential $Cred
Invoke-Command -ComputerName dc01, sql02, web01 {Get-Service -Name W32time} -Credential $Cred
```

```Output
Status   Name        DisplayName       PSComputerName
------   ----        -----------       --------------
Stopped  W32time     Windows Time      web01
Stopped  W32time     Windows Time      dc01
Stopped  W32time     Windows Time      sql02
```

As mentioned in a previous chapter, if a cmdlet exists for accomplishing a task, I recommend using
it instead of using a method. In the previous scenario, I recommend using the `Stop-Service` cmdlet
instead of the stop method. I chose to use the **Stop()** method to prove a point since many people
are under the misconception that methods can't be called when using PowerShell remoting. They can't
be called on the object that's returned because it's deserialized, but they can be called in the
remote session itself.

## PowerShell Sessions

In the last example in the previous section, I ran two commands using the `Invoke-Command` cmdlet.
That means two separate sessions had to be set up and torn down to run those two commands.

Similar to the CIM sessions discussed in Chapter 7, a PowerShell session to a remote computer can be
used to run multiple commands against the remote computer without the overhead of a new session for
each individual command.

Create a PowerShell session to each of the three computers we've been working with in this chapter,
DC01, SQL02, and WEB01.

```powershell
$Session = New-PSSession -ComputerName dc01, sql02, web01 -Credential $Cred
```

Now use the variable named `$Session` to start the Windows Time service using a method and check the
status of the service.

```powershell
Invoke-Command -Session $Session {(Get-Service -Name W32time).Start()}
Invoke-Command -Session $Session {Get-Service -Name W32time}
```

```Output
Status   Name        DisplayName       PSComputerName
------   ----        -----------       --------------
Running  W32time     Windows Time      web01
Start... W32time     Windows Time      dc01
Running  W32time     Windows Time      sql02
```

Once the session is created using alternate credentials, it's no longer necessary to specify the
credentials each time a command is run.

When you're finished using the sessions, be sure to remove them.

```powershell
Get-PSSession | Remove-PSSession
```

## Summary

In this chapter you've learned about PowerShell remoting, how to run commands in an interactive
session with one remote computer, and how to run commands against multiple computers using
one-to-many remoting. You've also learned the benefits of using a PowerShell session when running
multiple commands against the same remote computer.

## Review

1. How do you enable PowerShell remoting?
1. What is the PowerShell command for starting an interactive session with a remote computer?
1. What is a benefit of using a PowerShell remoting session versus just specifying the computer name
   with each command?
1. Can a PowerShell remoting session be used with a one-to-one remoting session?
1. What is the difference in the type of objects that are returned by cmdlets versus those returned
   when running those same cmdlets against remote computers with `Invoke-Command`?

## Recommended Reading

- [about_Remote][about_Remote]
- [about_Remote_Output][about_Remote_Output]
- [about_Remote_Requirements][about_Remote_Requirements]
- [about_Remote_Troubleshooting][about_Remote_Troubleshooting]
- [about_Remote_Variables][about_Remote_Variables]
- [PowerShell Remoting FAQ][PowerShell Remoting FAQ]

<!-- link references -->
[PowerShell Remoting FAQ]: ../../security/remoting/powershell-remoting-faq.yml
[about_Remote]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote
[about_Remote_Output]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote_output
[about_Remote_Requirements]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote_requirements
[about_Remote_Troubleshooting]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote_troubleshooting
[about_Remote_Variables]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote_variables

# /./reference/learn/ps101/09-functions.md

    ---
    description: PowerShell functions allow you to create tools that can be reused in scripts.
    ms.custom: Contributor-mikefrobbins
    ms.date: 11/16/2022
    ms.reviewer: mirobb
    title: Functions
    ---
# Chapter 9 - Functions

If you're writing PowerShell one-liners or scripts and find yourself often having to modify them for
different scenarios, there's a good chance that it's a good candidate to be turned into a function
that can be reused.

Whenever possible, I prefer to write functions because they are more tool oriented. I can put the
functions in a script module, put that module in the `$env:PSModulePath`, and call the functions
without needing to physically locate where they're saved. Using the PowerShellGet module, it's easy
to share those modules in a NuGet repository. PowerShellGet ships with PowerShell version 5.0 and
higher. It is available as a separate download for PowerShell version 3.0 and higher.

Don't over complicate things. Keep it simple and use the most straight forward way to accomplish a
task. Avoid aliases and positional parameters in any code that you reuse. Format your code for
readability. Don't hardcode values; use parameters and variables. Don't write unnecessary code even
if it doesn't hurt anything. It adds unnecessary complexity. Attention to detail goes a long
way when writing any PowerShell code.

## Naming

When naming your functions in PowerShell, use a [Pascal case][Pascal case] name with an approved verb and a
singular noun. I also recommend prefixing the noun. For example:
`<ApprovedVerb>-<Prefix><SingularNoun>`.

In PowerShell, there's a specific list of approved verbs that can be obtained by running `Get-Verb`.

```powershell
Get-Verb | Sort-Object -Property Verb
```

```Output
Verb        Group
----        -----
Add         Common
Approve     Lifecycle
Assert      Lifecycle
Backup      Data
Block       Security
Checkpoint  Data
Clear       Common
Close       Common
Compare     Data
Complete    Lifecycle
Compress    Data
Confirm     Lifecycle
Connect     Communications
Convert     Data
ConvertFrom Data
ConvertTo   Data
Copy        Common
Debug       Diagnostic
Deny        Lifecycle
Disable     Lifecycle
Disconnect  Communications
Dismount    Data
Edit        Data
Enable      Lifecycle
Enter       Common
Exit        Common
Expand      Data
Export      Data
Find        Common
Format      Common
Get         Common
Grant       Security
Group       Data
Hide        Common
Import      Data
Initialize  Data
Install     Lifecycle
Invoke      Lifecycle
Join        Common
Limit       Data
Lock        Common
Measure     Diagnostic
Merge       Data
Mount       Data
Move        Common
New         Common
Open        Common
Optimize    Common
Out         Data
Ping        Diagnostic
Pop         Common
Protect     Security
Publish     Data
Push        Common
Read        Communications
Receive     Communications
Redo        Common
Register    Lifecycle
Remove      Common
Rename      Common
Repair      Diagnostic
Request     Lifecycle
Reset       Common
Resize      Common
Resolve     Diagnostic
Restart     Lifecycle
Restore     Data
Resume      Lifecycle
Revoke      Security
Save        Data
Search      Common
Select      Common
Send        Communications
Set         Common
Show        Common
Skip        Common
Split       Common
Start       Lifecycle
Step        Common
Stop        Lifecycle
Submit      Lifecycle
Suspend     Lifecycle
Switch      Common
Sync        Data
Test        Diagnostic
Trace       Diagnostic
Unblock     Security
Undo        Common
Uninstall   Lifecycle
Unlock      Common
Unprotect   Security
Unpublish   Data
Unregister  Lifecycle
Update      Data
Use         Other
Wait        Lifecycle
Watch       Common
Write       Communications
```

In the previous example, I've sorted the results by the **Verb** column. The **Group** column gives
you an idea of how these verbs are used. It's important to choose an approved verb in PowerShell
when functions are added to a module. The module generates a warning message at load time if you
choose an unapproved verb. That warning message makes your functions look unprofessional. Unapproved
verbs also limit the discoverability of your functions.

## A simple function

A function in PowerShell is declared with the function keyword followed by the function name and
then an open and closing curly brace. The code that the function will execute is contained within
those curly braces.

```powershell
function Get-Version {
    $PSVersionTable.PSVersion
}
```

The function shown is a simple example that returns the version of PowerShell.

```powershell
Get-Version
```

```Output
Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      14393  693
```

There's a good chance of name conflict with functions named something like `Get-Version` and default
commands in PowerShell or commands that others may write. This is why I recommend prefixing the noun
portion of your functions to help prevent naming conflicts. In the following example, I'll use the
prefix "PS".

```powershell
function Get-PSVersion {
    $PSVersionTable.PSVersion
}
```

Other than the name, this function is identical to the previous one.

```powershell
Get-PSVersion
```

```Output
Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      14393  693
```

Even when prefixing the noun with something like PS, there's still a good chance of having a name
conflict. I typically prefix my function nouns with my initials. Develop a standard and stick to it.

```powershell
function Get-MrPSVersion {
    $PSVersionTable.PSVersion
}
```

This function is no different than the previous two other than using a more sensible name to try to
prevent naming conflicts with other PowerShell commands.

```powershell
Get-MrPSVersion
```

```Output
Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      14393  693
```

Once loaded into memory, you can see functions on the **Function** PSDrive.

```powershell
Get-ChildItem -Path Function:\Get-*Version
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Function        Get-Version
Function        Get-PSVersion
Function        Get-MrPSVersion
```

If you want to remove these functions from your current session, you'll have to remove them from the
**Function** PSDrive or close and reopen PowerShell.

```powershell
Get-ChildItem -Path Function:\Get-*Version | Remove-Item
```

Verify that the functions were indeed removed.

```powershell
Get-ChildItem -Path Function:\Get-*Version
```

If the functions were loaded as part of a module, the module can be unloaded to remove them.

```powershell
Remove-Module -Name <ModuleName>
```

The `Remove-Module` cmdlet removes modules from memory in your current PowerShell session, it
doesn't remove them from your system or from disk.

## Parameters

Don't statically assign values! Use parameters and variables. When it comes to naming your
parameters, use the same name as the default cmdlets for your parameter names whenever possible.

```powershell
function Test-MrParameter {

    param (
        $ComputerName
    )

    Write-Output $ComputerName

}
```

Why did I use **ComputerName** and not **Computer**, **ServerName**, or **Host** for my parameter
name? It's because I wanted my function standardized like the default cmdlets.

I'll create a function to query all of the commands on a system and return the number of them that
have specific parameter names.

```powershell
function Get-MrParameterCount {
    param (
        [string[]]$ParameterName
    )

    foreach ($Parameter in $ParameterName) {
        $Results = Get-Command -ParameterName $Parameter -ErrorAction SilentlyContinue

        [pscustomobject]@{
            ParameterName = $Parameter
            NumberOfCmdlets = $Results.Count
        }
    }
}
```

As you can see in the results shown below, 39 commands that have a **ComputerName** parameter. There
aren't any cmdlets that have parameters such as **Computer**, **ServerName**, **Host**, or
**Machine**.

```powershell
Get-MrParameterCount -ParameterName ComputerName, Computer, ServerName, Host, Machine
```

```Output
ParameterName NumberOfCmdlets
------------- ---------------
ComputerName               39
Computer                    0
ServerName                  0
Host                        0
Machine                     0
```

I also recommend using the same case for your parameter names as the default cmdlets. Use
`ComputerName`, not `computername`. This makes your functions look and feel like the default
cmdlets. People who are already familiar with PowerShell will feel right at home.

The `param` statement allows you to define one or more parameters. The parameter definitions are
separated by a comma (`,`). For more information, see [about_Functions_Advanced_Parameters][about_Functions_Advanced_Parameters].

## Advanced Functions

Turning a function in PowerShell into an advanced function is really simple. One of the differences
between a function and an advanced function is that advanced functions have a number of common
parameters that are added to the function automatically. These common parameters include parameters
such as **Verbose** and **Debug**.

I'll start out with the `Test-MrParameter` function that was used in the previous section.

```powershell
function Test-MrParameter {

    param (
        $ComputerName
    )

    Write-Output $ComputerName

}
```

What I want you to notice is that the `Test-MrParameter` function doesn't have any common
parameters. There are a couple of different ways to see the common parameters. One is by viewing the
syntax using `Get-Command`.

```powershell
Get-Command -Name Test-MrParameter -Syntax
```

```Output
Test-MrParameter [[-ComputerName] <Object>]
```

Another is to drill down into the parameters with `Get-Command`.

```powershell
(Get-Command -Name Test-MrParameter).Parameters.Keys
```

```Output
ComputerName
```

Add `CmdletBinding` to turn the function into an advanced function.

```powershell
function Test-MrCmdletBinding {

    [CmdletBinding()] #<<-- This turns a regular function into an advanced function
    param (
        $ComputerName
    )

    Write-Output $ComputerName

}
```

Adding `CmdletBinding` adds the common parameters automatically. `CmdletBinding` requires a `param`
block, but the `param` block can be empty.

```powershell
Get-Command -Name Test-MrCmdletBinding -Syntax
```

```Output
Test-MrCmdletBinding [[-ComputerName] <Object>] [<CommonParameters>]
```

Drilling down into the parameters with `Get-Command` shows the actual parameter names including the
common ones.

```powershell
(Get-Command -Name Test-MrCmdletBinding).Parameters.Keys
```

```Output
ComputerName
Verbose
Debug
ErrorAction
WarningAction
InformationAction
ErrorVariable
WarningVariable
InformationVariable
OutVariable
OutBuffer
PipelineVariable
```

## SupportsShouldProcess

`SupportsShouldProcess` adds **WhatIf** and **Confirm** parameters. These are only needed for
commands that make changes.

```powershell
function Test-MrSupportsShouldProcess {

    [CmdletBinding(SupportsShouldProcess)]
    param (
        $ComputerName
    )

    Write-Output $ComputerName

}
```

Notice that there are now **WhatIf** and **Confirm** parameters.

```powershell
Get-Command -Name Test-MrSupportsShouldProcess -Syntax
```

```Output
Test-MrSupportsShouldProcess [[-ComputerName] <Object>] [-WhatIf] [-Confirm] [<CommonParameters>]
```

Once again, you can also use `Get-Command` to return a list of the actual parameter names including
the common ones along with WhatIf and Confirm.

```powershell
(Get-Command -Name Test-MrSupportsShouldProcess).Parameters.Keys
```

```Output
ComputerName
Verbose
Debug
ErrorAction
WarningAction
InformationAction
ErrorVariable
WarningVariable
InformationVariable
OutVariable
OutBuffer
PipelineVariable
WhatIf
Confirm
```

## Parameter Validation

Validate input early on. Why allow your code to continue on a path when it's not possible to
run without valid input?

Always type the variables that are being used for your parameters (specify a datatype).

```powershell
function Test-MrParameterValidation {

    [CmdletBinding()]
    param (
        [string]$ComputerName
    )

    Write-Output $ComputerName

}
```

In the previous example, I've specified **String** as the datatype for the **ComputerName**
parameter. This causes it to allow only a single computer name to be specified. If more than one
computer name is specified via a comma-separated list, an error is generated.

```powershell
Test-MrParameterValidation -ComputerName Server01, Server02
```

```Output
Test-MrParameterValidation : Cannot process argument transformation on parameter
'ComputerName'. Cannot convert value to type System.String.
At line:1 char:42
+ Test-MrParameterValidation -ComputerName Server01, Server02
+
    + CategoryInfo          : InvalidData: (:) [Test-MrParameterValidation], ParameterBindingArg
     umentTransformationException
    + FullyQualifiedErrorId : ParameterArgumentTransformationError,Test-MrParameterValidation
```

The problem with the current definition is that it's valid to omit the value of the **ComputerName**
parameter, but a value is required for the function to complete successfully. This is where the
`Mandatory` parameter attribute comes in handy.

```powershell
function Test-MrParameterValidation {

    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$ComputerName
    )

    Write-Output $ComputerName

}
```

The syntax used in the previous example is PowerShell version 3.0 and higher compatible.
`[Parameter(Mandatory=$true)]` could be specified instead to make the function compatible with
PowerShell version 2.0 and higher. Now that the **ComputerName** is required, if one isn't
specified, the function will prompt for one.

```powershell
Test-MrParameterValidation
```

```Output
cmdlet Test-MrParameterValidation at command pipeline position 1
Supply values for the following parameters:
ComputerName:
```

If you want to allow for more than one value for the **ComputerName** parameter, use the **String**
datatype but add open and closed square brackets to the datatype to allow for an array of strings.

```powershell
function Test-MrParameterValidation {

    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string[]]$ComputerName
    )

    Write-Output $ComputerName

}
```

Maybe you want to specify a default value for the **ComputerName** parameter if one isn't specified.
The problem is that default values can't be used with mandatory parameters. Instead, you'll need to
use the `ValidateNotNullOrEmpty` parameter validation attribute with a default value.

```powershell
function Test-MrParameterValidation {

    [CmdletBinding()]
    param (
        [ValidateNotNullOrEmpty()]
        [string[]]$ComputerName = $env:COMPUTERNAME
    )

    Write-Output $ComputerName

}
```

Even when setting a default value, try not to use static values. In the previous example,
`$env:COMPUTERNAME` is used as the default value, which is automatically translated into the local
computer name if a value is not provided.

## Verbose Output

While inline comments are useful, especially if you're writing some complex code, they never get
seen by users unless they look into the code itself.

The function shown in the following example has an inline comment in the `foreach` loop. While this
particular comment may not be that difficult to locate, imagine if the function included hundreds of
lines of code.

```powershell
function Test-MrVerboseOutput {

    [CmdletBinding()]
    param (
        [ValidateNotNullOrEmpty()]
        [string[]]$ComputerName = $env:COMPUTERNAME
    )

    foreach ($Computer in $ComputerName) {
        #Attempting to perform some action on $Computer <<-- Don't use
        #inline comments like this, use write verbose instead.
        Write-Output $Computer
    }

}
```

A better option is to use `Write-Verbose` instead of inline comments.

```powershell
function Test-MrVerboseOutput {

    [CmdletBinding()]
    param (
        [ValidateNotNullOrEmpty()]
        [string[]]$ComputerName = $env:COMPUTERNAME
    )

    foreach ($Computer in $ComputerName) {
        Write-Verbose -Message "Attempting to perform some action on $Computer"
        Write-Output $Computer
    }

}
```

When the function is called without the **Verbose** parameter, the verbose output won't be
displayed.

```powershell
Test-MrVerboseOutput -ComputerName Server01, Server02
```

When it's called with the **Verbose** parameter, the verbose output will be displayed.

```powershell
Test-MrVerboseOutput -ComputerName Server01, Server02 -Verbose
```

## Pipeline Input

When you want your function to accept pipeline input, some additional coding is necessary. As
mentioned earlier in this book, commands can accept pipeline input **by value** (by type) or **by
property name**. You can write your functions just like the native commands so that they accept
either one or both of these types of input.

To accept pipeline input **by value**, specified the `ValueFromPipeline` parameter attribute for
that particular parameter. Keep in mind that you can only accept pipeline input **by value** from
one of each datatype. For example, if you have two parameters that accept string input, only one of
those can accept pipeline input **by value** because if you specified it for both of the string
parameters, the pipeline input wouldn't know which one to bind to. This is another reason I call
this type of pipeline input _by type_ instead of **by value**.

Pipeline input comes in one item at a time similar to the way items are handled in a `foreach` loop.
At a minimum, a `process` block is required to process each of these items if you're accepting an
array as input. If you're only accepting a single value as input, a `process` block isn't necessary,
but I still recommend specifying it for consistency.

```powershell
function Test-MrPipelineInput {

    [CmdletBinding()]
    param (
        [Parameter(Mandatory,
                   ValueFromPipeline)]
        [string[]]$ComputerName
    )

    PROCESS {
        Write-Output $ComputerName
    }

}
```

Accepting pipeline input **by property name** is similar except it's specified with the
`ValueFromPipelineByPropertyName` parameter attribute and it can be specified for any number of
parameters regardless of datatype. The key is that the output of the command that's being piped in
has to have a property name that matches the name of the parameter or a parameter alias of your
function.

```powershell
function Test-MrPipelineInput {

    [CmdletBinding()]
    param (
        [Parameter(Mandatory,
                   ValueFromPipelineByPropertyName)]
        [string[]]$ComputerName
    )

    PROCESS {
            Write-Output $ComputerName
    }

}
```

`BEGIN` and `END` blocks are optional. `BEGIN` would be specified before the `PROCESS` block and is
used to perform any initial work prior to the items being received from the pipeline. This is
important to understand. Values that are piped in are not accessible in the `BEGIN` block. The `END`
block would be specified after the `PROCESS` block and is used for cleanup once all of the items
that are piped in have been processed.

## Error Handling

The function shown in the following example generates an unhandled exception when a computer can't
be contacted.

```powershell
function Test-MrErrorHandling {

    [CmdletBinding()]
    param (
        [Parameter(Mandatory,
                   ValueFromPipeline,
                   ValueFromPipelineByPropertyName)]
        [string[]]$ComputerName
    )

    PROCESS {
        foreach ($Computer in $ComputerName) {
            Test-WSMan -ComputerName $Computer
        }
    }

}
```

There are a couple of different ways to handle errors in PowerShell. `Try/Catch` is the more modern
way to handle errors.

```powershell
function Test-MrErrorHandling {

    [CmdletBinding()]
    param (
        [Parameter(Mandatory,
                   ValueFromPipeline,
                   ValueFromPipelineByPropertyName)]
        [string[]]$ComputerName
    )

    PROCESS {
        foreach ($Computer in $ComputerName) {
            try {
                Test-WSMan -ComputerName $Computer
            }
            catch {
                Write-Warning -Message "Unable to connect to Computer: $Computer"
            }
        }
    }

}
```

Although the function shown in the previous example uses error handling, it also generates an
unhandled exception because the command doesn't generate a terminating error. This is also important
to understand. Only terminating errors are caught. Specify the **ErrorAction** parameter with
**Stop** as the value to turn a non-terminating error into a terminating one.

```powershell
function Test-MrErrorHandling {

    [CmdletBinding()]
    param (
        [Parameter(Mandatory,
                   ValueFromPipeline,
                   ValueFromPipelineByPropertyName)]
        [string[]]$ComputerName
    )

    PROCESS {
        foreach ($Computer in $ComputerName) {
            try {
                Test-WSMan -ComputerName $Computer -ErrorAction Stop
            }
            catch {
                Write-Warning -Message "Unable to connect to Computer: $Computer"
            }
        }
    }

}
```

Don't modify the global `$ErrorActionPreference` variable unless absolutely necessary. If you're
using something like .NET directly from within your PowerShell function, you can't specify the
**ErrorAction** on the command itself. In that scenario, you might need to change the global
`$ErrorActionPreference` variable, but if you do change it, change it back immediately after trying
the command.

## Comment-Based Help

It's considered to be a best practice to add comment based help to your functions so the people
you're sharing them with will know how to use them.

```powershell
function Get-MrAutoStoppedService {

<#
.SYNOPSIS
    Returns a list of services that are set to start automatically, are not
    currently running, excluding the services that are set to delayed start.

.DESCRIPTION
    Get-MrAutoStoppedService is a function that returns a list of services from
    the specified remote computer(s) that are set to start automatically, are not
    currently running, and it excludes the services that are set to start automatically
    with a delayed startup.

.PARAMETER ComputerName
    The remote computer(s) to check the status of the services on.

.PARAMETER Credential
    Specifies a user account that has permission to perform this action. The default
    is the current user.

.EXAMPLE
     Get-MrAutoStoppedService -ComputerName 'Server1', 'Server2'

.EXAMPLE
     'Server1', 'Server2' | Get-MrAutoStoppedService

.EXAMPLE
     Get-MrAutoStoppedService -ComputerName 'Server1' -Credential (Get-Credential)

.INPUTS
    String

.OUTPUTS
    PSCustomObject

.NOTES
    Author:  Mike F Robbins
    Website: http://mikefrobbins.com
    Twitter: @mikefrobbins
#>

    [CmdletBinding()]
    param (

    )

    #Function Body

}
```

When you add comment based help to your functions, help can be retrieved for them just like the
default built-in commands.

All of the syntax for writing a function in PowerShell can seem overwhelming especially for someone
who is just getting started. Often times if I can't remember the syntax for something, I'll open a
second copy of the ISE on a separate monitor and view the "Cmdlet (advanced function) - Complete"
snippet while typing in the code for my function. Snippets can be accessed in the PowerShell ISE
using the <kbd>Ctrl</kbd>+<kbd>J</kbd> key combination.

## Summary

In this chapter you've learned the basics of writing functions in PowerShell to include how to turn
a function into an advanced function and some of the more important elements that you should
consider when writing PowerShell functions such as parameter validation, verbose output, pipeline
input, error handling, and comment based help.

## Review

1. How do you obtain a list of approved verbs in PowerShell?
1. How do you turn a PowerShell function into an advanced function?
1. When should **WhatIf** and **Confirm** parameters be added to your PowerShell functions?
1. How do you turn a non-terminating error into a terminating one?
1. Why should you add comment based help to your functions?

## Recommended Reading

- [about_Functions][about_Functions]
- [about_Functions_Advanced_Parameters][about_Functions_Advanced_Parameters]
- [about_CommonParameters][about_CommonParameters]
- [about_Functions_CmdletBindingAttribute][about_Functions_CmdletBindingAttribute]
- [about_Functions_Advanced][about_Functions_Advanced]
- [about_Try_Catch_Finally][about_Try_Catch_Finally]
- [about_Comment_Based_Help][about_Comment_Based_Help]
- [Video: PowerShell Toolmaking with Advanced Functions and Script Modules][Video: PowerShell Toolmaking with Advanced Functions and Script Modules]

<!-- link references -->
[about_Functions]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions
[about_Functions_Advanced_Parameters]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters
[about_CommonParameters]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_commonparameters
[about_Functions_CmdletBindingAttribute]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute
[about_Functions_Advanced]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced
[about_Try_Catch_Finally]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_try_catch_finally
[about_Comment_Based_Help]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_comment_based_help
[Video: PowerShell Toolmaking with Advanced Functions and Script Modules]: https://mikefrobbins.com/2016/05/26/video-powershell-toolmaking-with-advanced-functions-and-script-modules/
[Pascal case]: https://learn.microsoft.com/dotnet/standard/design-guidelines/capitalization-conventions

# /./reference/learn/ps101/10-script-modules.md

    ---
    description: Script modules are an easy way to package scripts and functions into a reusable tool.
    ms.custom: Contributor-mikefrobbins
    ms.date: 12/08/2022
    ms.reviewer: mirobb
    title: Script modules
    ---
# Chapter 10 - Script modules

Turning your one-liners and scripts in PowerShell into reusable tools becomes even more important if
it's something that you're going to use frequently. Packaging your functions in a script module
makes them look and feel more professional and makes them easier to share.

## Dot-Sourcing Functions

Something that we didn't talk about in the previous chapter is dot-sourcing functions. When a
function in a script isn't part of a module, the only way to load it into memory is to dot-source
the `.PS1` file that it's saved in.

The following function has been saved as `Get-MrPSVersion.ps1`.

```powershell
function Get-MrPSVersion {
    $PSVersionTable
}
```

When you run the script, nothing happens.

```powershell
.\Get-MrPSVersion.ps1
```

If you try to call the function, it generates an error message.

```powershell
Get-MrPSVersion
```

```Output
Get-MrPSVersion : The term 'Get-MrPSVersion' is not recognized as the name of a cmdlet,
function, script file, or operable program. Check the spelling of the name, or if a path
was included, verify that the path is correct and try again.
At line:1 char:1
+ Get-MrPSVersion
    + CategoryInfo          : ObjectNotFound: (Get-MrPSVersion:String) [], CommandNotFou
   ndException
    + FullyQualifiedErrorId : CommandNotFoundException

```

You can determine if functions are loaded into memory by checking to see if they exist on the
**Function** PSDrive.

```powershell
Get-ChildItem -Path Function:\Get-MrPSVersion
```

```Output
Get-ChildItem : Cannot find path 'Get-MrPSVersion' because it does not exist.
At line:1 char:1
+ Get-ChildItem -Path Function:\Get-MrPSVersion
    + CategoryInfo          : ObjectNotFound: (Get-MrPSVersion:String) [Get-ChildItem],
   ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetChildItemCommand
```

The problem with calling the script that contains the function is that the functions are loaded in
the _Script_ scope. When the script completes, that scope is removed and the function is removed
with it.

The function needs to be loaded into the _Global_ scope. That can be accomplished by dot-sourcing
the script that contains the function. The relative path can be used.

```powershell
. .\Get-MrPSVersion.ps1
```

The fully qualified path can also be used.

```powershell
. C:\Demo\Get-MrPSVersion.ps1
```

If a portion of the path is stored in a variable, it can be combined with the remainder of the path.
There's no reason to use string concatenation to combine the variable together with the remainder of
the path.

```powershell
$Path = 'C:\'
. $Path\Get-MrPSVersion.ps1
```

Now when I check the **Function** PSDrive, the `Get-MrPSVersion` function exists.

```powershell
Get-ChildItem -Path Function:\Get-MrPSVersion
```

```Output
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Function        Get-MrPSVersion
```

## Script Modules

A script module in PowerShell is simply a file containing one or more functions that's saved as a
`.PSM1` file instead of a `.PS1` file.

How do you create a script module? You're probably guessing with a command named something like
`New-Module`. Your assumption would be wrong. While there is a command in PowerShell named
`New-Module`, that command creates a dynamic module, not a script module. Always be sure to read the
help for a command even when you think you've found the command you need.

```powershell
help New-Module
```

```Output
NAME
    New-Module

SYNOPSIS
    Creates a new dynamic module that exists only in memory.

SYNTAX
    New-Module [-Name] <String> [-ScriptBlock] <ScriptBlock> [-ArgumentList <Object[]>]
    [-AsCustomObject] [-Cmdlet <String[]>] [-Function <String[]>] [-ReturnResult]
    [<CommonParameters>]

DESCRIPTION
    The New-Module cmdlet creates a dynamic module from a script block. The members of
    the dynamic module, such as functions and variables, are immediately available in
    the session and remain available until you close the session.

    Like static modules, by default, the cmdlets and functions in a dynamic module are
    exported and the variables and aliases are not. However, you can use the
    Export-ModuleMember cmdlet and the parameters of New-Module to override the defaults.

    You can also use the AsCustomObject parameter of New-Module to return the dynamic
    module as a custom object. The members of the modules, such as functions, are
    implemented as script methods of the custom object instead of being imported into
    the session.

    Dynamic modules exist only in memory, not on disk. Like all modules, the members of
    dynamic modules run in a private module scope that is a child of the global scope.
    Get-Module cannot get a dynamic module, but Get-Command can get the exported members.

    To make a dynamic module available to Get-Module , pipe a New-Module command to
    Import-Module, or pipe the module object that New-Module returns to Import-Module .
    This action adds the dynamic module to the Get-Module list, but it does not save the
    module to disk or make it persistent.

RELATED LINKS
    Online Version: http://go.microsoft.com/fwlink/?LinkId=821495
    Export-ModuleMember
    Get-Module
    Import-Module
    Remove-Module

REMARKS
    To see the examples, type: "get-help New-Module -examples".
    For more information, type: "get-help New-Module -detailed".
    For technical information, type: "get-help New-Module -full".
    For online help, type: "get-help New-Module -online"
```

In the previous chapter, I mentioned that functions should use approved verbs otherwise they'll
generate a warning message when the module is imported. The following code uses the `New-Module`
cmdlet to create a dynamic module in memory. This module demonstrates the unapproved verb warning.

```powershell
New-Module -Name MyModule -ScriptBlock {

    function Return-MrOsVersion {
        Get-CimInstance -ClassName Win32_OperatingSystem |
        Select-Object -Property @{label='OperatingSystem';expression={$_.Caption}}
    }

    Export-ModuleMember -Function Return-MrOsVersion

} | Import-Module
```

```Output
WARNING: The names of some imported commands from the module 'MyModule' include
unapproved verbs that might make them less discoverable. To find the commands with
unapproved verbs, run the Import-Module command again with the Verbose parameter. For a
list of approved verbs, type Get-Verb.
```

Just to reiterate, although the `New-Module` cmdlet was used in the previous example, that's not the
command for creating script modules in PowerShell.

Save the following two functions in a file named `MyScriptModule.psm1`.

```powershell
function Get-MrPSVersion {
    $PSVersionTable
}

function Get-MrComputerName {
    $env:COMPUTERNAME
}
```

Try to call one of the functions.

```powershell
Get-MrComputerName
```

```Output
Get-MrComputerName : The term 'Get-MrComputerName' is not recognized as the name of a
cmdlet, function, script file, or operable program. Check the spelling of the name, or
if a path was included, verify that the path is correct and try again.
At line:1 char:1
+ Get-MrComputerName
    + CategoryInfo          : ObjectNotFound: (Get-MrComputerName:String) [], CommandNot
   FoundException
    + FullyQualifiedErrorId : CommandNotFoundException
```

An error message is generated saying the function can't be found. You could also check the
**Function** PSDrive just like before and you'll find that it doesn't exist there either.

You could manually import the file with the `Import-Module` cmdlet.

```powershell
Import-Module C:\MyScriptModule.psm1
```

The module autoloading feature was introduced in PowerShell version 3. To take advantage of module
autoloading, a script module needs to be saved in a folder with the same base name as the `.PSM1` file
and in a location specified in `$env:PSModulePath`.

```powershell
$env:PSModulePath
```

```Output
C:\Users\mike-ladm\Documents\WindowsPowerShell\Modules;C:\Program Files\WindowsPowerShell\
Modules;C:\Windows\system32\WindowsPowerShell\v1.0\Modules;C:\Program Files (x86)\Microsof
t SQL Server\130\Tools\PowerShell\Modules\
```

The results are difficult to read. Since the paths are separated by a semicolon, you can split the
results to return each path on a separate line. This makes them easier to read.

```powershell
$env:PSModulePath -split ';'
```

```Output
C:\Users\mike-ladm\Documents\WindowsPowerShell\Modules
C:\Program Files\WindowsPowerShell\Modules
C:\Windows\system32\WindowsPowerShell\v1.0\Modules
C:\Program Files (x86)\Microsoft SQL Server\130\Tools\PowerShell\Modules\
```

The first three paths in the list are the default. When SQL Server Management Studio was installed,
it added the last path. For module autoloading to work, the `MyScriptModule.psm1` file needs to be
located in a folder named `MyScriptModule` directly inside one of those paths.

Not so fast. For me, my current user path isn't the first one in the list. I almost never use that
path since I log into Windows with a different user than the one I use to run PowerShell. That means
it's not located in my normal Documents folder.

The second path is the **AllUsers** path. This is the location where I store all of my modules.

The third path is underneath `C:\Windows\System32`. Only Microsoft should be storing modules in that
location since it resides within the operating systems folder.

Once the `.PSM1` file is located in the correct path, the module will load automatically when one of
its commands is called.

## Module Manifests

All modules should have a module manifest. A module manifest contains metadata about your module.
The file extension for a module manifest file is `.PSD1`. Not all files with a `.PSD1` extension are
module manifests. They can also be used for things such as storing the environmental portion of a
DSC configuration. `New-ModuleManifest` is used to create a module manifest. **Path** is the only
value that's required. However, the module won't work if **RootModule** isn't specified. It's a good
idea to specify **Author** and **Description** in case you decide to upload your module to a NuGet
repository with PowerShellGet since those values are required in that scenario.

The version of a module without a manifest is 0.0. This is a dead giveaway that the module doesn't
have a manifest.

```powershell
Get-Module -Name MyScriptModule
```

```Output
ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Script     0.0        myscriptmodule                      {Get-MrComputerName, Get-MrP...
```

The module manifest can be created with all of the recommended information.

```powershell
New-ModuleManifest -Path $env:ProgramFiles\WindowsPowerShell\Modules\MyScriptModule\MyScriptModule.psd1 -RootModule MyScriptModule -Author 'Mike F Robbins' -Description 'MyScriptModule' -CompanyName 'mikefrobbins.com'
```

If any of this information is missed during the initial creation of the module manifest, it can be
added or updated later using `Update-ModuleManifest`. Don't recreate the manifest using
`New-ModuleManifest` once it's already created because the GUID will change.

## Defining Public and Private Functions

You may have helper functions that you may want to be private and only accessible by other functions
within the module. They are not intended to be accessible to users of your module. There are a
couple of different ways to accomplish this.

If you're not following the best practices and only have a `.PSM1` file, then your only option is to
use the `Export-ModuleMember` cmdlet.

```powershell
function Get-MrPSVersion {
    $PSVersionTable
}

function Get-MrComputerName {
    $env:COMPUTERNAME
}

Export-ModuleMember -Function Get-MrPSVersion
```

In the previous example, only the `Get-MrPSVersion` function is available to the users of your
module, but the `Get-MrComputerName` function is available to other functions within the module
itself.

```powershell
Get-Command -Module MyScriptModule
```

```Output
CommandType     Name                                            Version    Source
-----------     ----                                            -------    ------
Function        Get-MrPSVersion                                 1.0        MyScriptModule
```

If you've added a module manifest to your module (and you should), then I recommend specifying the
individual functions you want to export in the **FunctionsToExport** section of the module manifest.

```powershell
FunctionsToExport = 'Get-MrPSVersion'
```

It's not necessary to use both `Export-ModuleMember` in the `.PSM1` file and the
**FunctionsToExport** section of the module manifest. One or the other is sufficient.

## Summary

In this chapter you've learned how to turn your functions into a script module in PowerShell. You've
also learned some of the best practices for creating script modules such as creating a module
manifest for your script module.

## Review

1. How do you create a script module in PowerShell?
1. Why is it important for your functions to use an approved verb?
1. How do you create a module manifest in PowerShell?
1. What are the two options for exporting only certain functions from your module?
1. What is required for your modules to load automatically when a command is called?

## Recommended Reading

- [How to Create PowerShell Script Modules and Module Manifests][How to Create PowerShell Script Modules and Module Manifests]
- [about_Modules][about_Modules]
- [New-ModuleManifest][New-ModuleManifest]
- [Export-ModuleMember][Export-ModuleMember]

<!-- link references -->
[How to Create PowerShell Script Modules and Module Manifests]: https://mikefrobbins.com/2013/07/04/how-to-create-powershell-script-modules-and-module-manifests/
[about_Modules]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_modules
[New-ModuleManifest]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/new-modulemanifest
[Export-ModuleMember]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/export-modulemember

# /./reference/learn/ps101/appendix-a.md

    ---
    description: This article explains how to read and understand the syntax of a cmdlet as presented by Get-Help.
    ms.custom: Contributor-mikefrobbins
    ms.date: 11/16/2022
    ms.reviewer: mirobb
    title: Appendix A - Help Syntax
    ---
# Appendix A - Help Syntax

The following example shows the **SYNTAX** section of the help for the `Get-EventLog` cmdlet.

```powershell
help Get-EventLog
```

```Output
NAME
    Get-EventLog

SYNOPSIS
    Gets the events in an event log, or a list of the event logs, on the local or remote
    computers.


SYNTAX
    Get-EventLog [-LogName] <String> [[-InstanceId] <Int64[]>] [-After <DateTime>]
    [-AsBaseObject] [-Before <DateTime>] [-ComputerName <String[]>] [-EntryType {Error |
    Information | FailureAudit | SuccessAudit | Warning}] [-Index <Int32[]>] [-Message
    <String>] [-Newest <Int32>] [-Source <String[]>] [-UserName <String[]>]
    [<CommonParameters>]

    Get-EventLog [-AsString] [-ComputerName <String[]>] [-List] [<CommonParameters>]
```

Only the relevant portion of the help is shown in this example.

The syntax is primarily made up of several sets of opening and closing brackets (`[]`). These have
two different meanings depending on how they're used. Anything contained within square brackets is
optional unless they're a set of empty square brackets `[]`. Empty square brackets only appear
after a datatype such as `<string[]>`. This means that particular parameter can accept more than
one value of that type.

The first parameter in the first parameter set of `Get-EventLog` is **LogName**. LogName is
surrounded by square brackets which means that it's a positional parameter. In other words,
specifying the name of the parameter itself is optional as long as it's specified in the correct
position. The information in the angle brackets (`<>`) after the parameter name indicates that it
needs a single **string** value. The entire parameter name and datatype are not surrounded by square
brackets so the **LogName** parameter is required when using this parameter set.

```powershell
Get-EventLog [-LogName] <String>
```

The second parameter is **InstanceId**. Notice that the parameter name and the datatype are both
completely surrounded by square brackets. This means that the **InstanceId** parameter is optional,
not mandatory. Also notice that **InstanceId** is surrounded by its own set of square brackets. As
with the **LogName** parameter, this means the parameter is positional. There's one last set of
square brackets after the datatype. This means that it can accept more than one value in the form of
an array or a comma-separated list.

```
[[-InstanceId] <Int64[]>]
```

The second parameter set has a **List** parameter. It's a switch parameter because there's no
datatype following the parameter name. When the **List** parameter is specified, the value is
**True**. When it's not specified, the value is **False**.

```
[-List]
```

The syntax information for a command can also be retrieved using `Get-Command` using the **Syntax**
parameter. This is a handy shortcut that I use all the time. It allows me to quickly learn how to
use a command without having to sift through multiple pages of help information. If I end up needing
more information, then I'll revert to using the actual help content.

```powershell
Get-Command -Name Get-EventLog -Syntax
```

```Output
Get-EventLog [-LogName] <string> [[-InstanceId] <long[]>] [-ComputerName <string[]>] [-Newest <int>]
 [-After <datetime>] [-Before <datetime>] [-UserName <string[]>] [-Index <int[]> ]
 [-EntryType <string[]>] [-Source <string[]>] [-Message <string>] [-AsBaseObject]
 [<CommonParameters>]

Get-EventLog [-ComputerName <string[]>] [-List] [-AsString] [<CommonParameters>]
```

The more you use the help system in PowerShell, the easier remembering all of the different nuances
becomes. Before you know it, using it becomes second nature.

# /./reference/learn/shell/optimize-shell.md

    ---
    description: >
      This article provides an overview of the shell features that help users improve
      their user experience.
    title: Optimizing your shell experience
    ms.date: 7/14/2022
    ---
# Optimizing your shell experience

PowerShell is a command-line shell and a scripting language used for automation.

[Wikipedia][wiki] includes the following description of a shell:

> A shell manages the user-system interaction by prompting users for input, interpreting their
> input, and then handling output from the underlying operating system (much like a read-eval-print
> loop or [REPL][REPL]).

Similar to other shells like `bash` or `cmd.exe`, PowerShell allows you to run any command available
on your system, not just PowerShell commands.

PowerShell commands are known as _cmdlets_ (pronounced command-lets). Cmdlets are PowerShell
commands, not stand-alone executables. PowerShell commands can't be run in other shells without
running PowerShell first.

## Features of the PowerShell command-line interface

PowerShell is a modern command shell that includes the best features of other popular shells. Unlike
most shells that only accept and return text, PowerShell accepts and returns .NET objects. The shell
has several features that you can use to optimize your interactive user experience.

- Robust command-line [history][history]
- [Tab completion][tab] and [command prediction][prediction]
- Supports command and parameter [aliases][aliases]
- [Pipeline][Pipeline] for chaining commands
- In-console [help][help] system, similar to Unix `man` pages

<!-- link reference -->
[aliases]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_aliases
[help]: dynamic-help.md
[history]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_history
[Pipeline]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pipelines
[prediction]: using-predictors.md
[REPL]: https://wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop
[tab]: tab-completion.md
[wiki]: https://wikipedia.org/wiki/Shell_(computing)#Overview

# /./reference/learn/shell/running-commands.md

    ---
    description: >
      This article shows how to run commands in PowerShell.
    title: Running commands in the shell
    ms.date: 08/22/2022
    ---
# Running commands in the shell

PowerShell is a command-line shell and a scripting language used for automation. Similar to other
shells, like `bash` on Linux or the Windows Command Shell (`cmd.exe`), PowerShell lets you to run
any command available on your system, not just PowerShell commands.

## Types of commands

For any shell in any operating system there are three types of commands:

- **Shell language keywords** are part of the shell's scripting language.

  - Examples of `bash` keywords include: `if`, `then`, `else`, `elif`, and `fi`.
  - Examples of `cmd.exe` keywords include: `dir`, `copy`, `move`, `if`, and `echo`.
  - Examples of PowerShell keywords include: `for`, `foreach`, `try`, `catch`, and `trap`.

  Shell language keywords can only be used within the runtime environment of the shell. There is no
  executable file, external to the shell, that provides the keyword's functionality.

- **OS-native commands** are executable files installed in the operating system. The executables can
  be run from any command-line shell, like PowerShell. This includes script files that may require
  other shells to work properly. For example, if you run a Windows batch script (`.cmd` file) in
  PowerShell, PowerShell runs `cmd.exe` and passes in the batch file for execution.

- **Shell environment-specific commands** are commands defined in external files that can only be
  used within the runtime environment of the shell. These include scripts and functions, or they can
  be specially compiled modules that add commands to the shell runtime. In PowerShell, these
  commands are known as _cmdlets_ (pronounced "command-lets").

## Running native commands

Any native command can be run from the PowerShell command line. Usually you run the command exactly
as you would in `bash` or `cmd.exe`. The following example shows running the `grep` command in
`bash` on Ubuntu Linux.

```bash
sdwheeler@circumflex:~$ grep sdwheeler /etc/passwd
sdwheeler:x:1000:1000:,,,:/home/sdwheeler:/bin/bash
sdwheeler@circumflex:~$ pwsh
PowerShell 7.2.6
Copyright (c) Microsoft Corporation.

https://aka.ms/powershell
Type 'help' to get help.
```

After starting PowerShell on Ubuntu, you can run the same command from the PowerShell command line:

```powershell
PS /home/sdwheeler> grep sdwheeler /etc/passwd
sdwheeler:x:1000:1000:,,,:/home/sdwheeler:/bin/bash
```

### Passing arguments to native commands

Most shells include features for using variables, evaluating expressions, and handling strings. But
each shell does these things differently. In PowerShell, all parameters start with a hyphen (`-`)
character. In `cmd.exe`, most parameters use a slash (`/`) character. Other command-line tools may
not have a special character for parameters.

Each shell has its own way of handling and evaluating strings on the command line. When running
native commands in PowerShell that expect strings to be quoted in a specific way, you may need
adjust how you pass those strings.

For more information, see the following articles:

- [about_Parsing][1]
- [about_Quoting_Rules][2]

PowerShell 7.2 introduced a new experimental feature `PSnativeCommandArgumentPassing` that improved
native command handling. For more information, see [PSnativeCommandArgumentPassing][3].

### Handling output and errors

PowerShell also has several more output streams than other shells. The `bash` and `cmd.exe` shells
have **stdout** and **stderr**. PowerShell has six output streams. For more information, see
[about_Redirection][4] and [about_Output_Streams][5].

In general, the output sent to **stdout** by a native command is sent to the **Success** stream in
PowerShell. Output sent to **stderr** by a native command is sent to the **Error** stream in
PowerShell.

When a native command has a non-zero exit code, `$?` is set to `$false`. If the exit code is zero,
`$?` is set to `$true`.

However, this changed in PowerShell 7.2. Error records redirected from native commands, like when
using redirection operators (`2>&1`), aren't written to PowerShell's `$Error` variable and the
preference variable `$ErrorActionPreference` doesn't affect the redirected output.

Many native commands write to **stderr** as an alternative stream for additional information. This
behavior can cause confusion in PowerShell when looking through errors and the additional output
information can be lost if `$ErrorActionPreference` is set to a state that mutes the output.

PowerShell 7.3 added a new experimental feature `PSnativeCommandErrorActionPreference` that allows
you to control whether output to `stderr` is treated as an error. For more information, see
[PSnativeCommandErrorActionPreference][6].

## Running PowerShell commands

As previously noted, PowerShell commands are known as cmdlets. Cmdlets are collected into PowerShell
modules that can be loaded on demand. Cmdlets can be written in any compiled .NET language or using
the PowerShell scripting language itself.

### PowerShell commands that run other commands

The PowerShell **call operator** (`&`) lets you run commands that are stored in variables and
represented by strings or script blocks. You can use this to run any native command or PowerShell
command. This is useful in a script when you need to dynamically construct the command-line
parameters for a native command. For more information, see the [call operator][7].

The `Start-Process` cmdlet can be used to run native commands, but should only be used when you need
to control how the command is executed. The cmdlet has parameters to support the following
scenarios:

- Run a command using different credentials
- Hide the console window created by the new process
- Redirect **stdin**, **stdout**, and **stderr** streams
- Use a different working directory for the command

The following example runs the native command `sort.exe` with redirected input and output streams.

```powershell
$processOptions = @{
    FilePath = "sort.exe"
    RedirectStandardInput = "TestSort.txt"
    RedirectStandardOutput = "Sorted.txt"
    RedirectStandardError = "SortError.txt"
    UseNewEnvironment = $true
}
Start-Process @processOptions
```

For more information, see [Start-Process][8].

On Windows, the `Invoke-Item` cmdlet performs the default action for the specified item. For
example, it runs an executable file or opens a document file using the application associated with
the document file type. The default action depends on the type of item and is resolved by the
PowerShell provider that provides access to the item.

The following example opens the PowerShell source code repository in your default web browser.

```powershell
Invoke-Item https://github.com/PowerShell/PowerShell
```

For more information, see [Invoke-Item][9].

<!-- link references -->
[1]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing#passing-arguments-to-native
[2]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_quoting_rules
[3]: ../experimental-features.md#psnativecommandargumentpassing
[4]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_redirection
[5]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_output_streams
[6]: ../experimental-features.md#psnativecommanderroractionpreference
[7]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_operators#call-operator-
[8]: https://learn.microsoft.com/powershell/module/microsoft.powershell.management/start-process
[9]: https://learn.microsoft.com/powershell/module/microsoft.powershell.management/invoke-item

# /./reference/learn/shell/tab-completion.md

    ---
    description: >
        This article explains the tab-completion feature of the shell, how to configure it, and how to
        extend its capabilities.
    no-loc: [<kbd>Tab</kbd>, <kbd>Ctrl</kbd>, <kbd>Space</kbd>]
    title: Using tab-completion in the shell
    ms.date: 7/14/2022
    ---
# Using tab-completion in the shell

PowerShell provides completions on input to provide hints, enable discovery, and speed up input
entry. Command names, parameter names, argument values and file paths can all be completed by
pressing the <kbd>Tab</kbd> key.

The <kbd>Tab</kbd> key is the default key binding on Windows. **PSReadLine** also provides a
`MenuComplete` function that's bound to <kbd>Ctrl</kbd>+<kbd>Space</kbd>. The `MenuComplete`
function displays a list of matching completions below the command line.

These keybindings can be changed using **PSReadLine** cmdlets or the application that's hosting
PowerShell. Keybindings can be different on non-Windows platforms. For more information, see
[about_PSReadLine_Functions][PSRFunctions].

## Built-in tab completion features

PowerShell has enabled tab completion for many aspects of the command line experience.

### Filename completion

To fill in a filename or path from the available choices automatically, type part of the name and
press the <kbd>Tab</kbd> key. PowerShell automatically expands the name to the first match that it
finds. Pressing the <kbd>Tab</kbd> key again cycles through all the available choices with each key
press.

### Command and parameter name completion

The tab expansion of cmdlet names is slightly different. To use tab expansion on a cmdlet name, type
the entire first part of the name (the verb) and the hyphen that follows it. You can fill in more of
the name for a partial match. For example, if you type `get-co` and then press the <kbd>Tab</kbd>
key, PowerShell automatically expands this to the `Get-Command` cmdlet (notice that it also changes
the case of letters to their standard form). If you press <kbd>Tab</kbd> key again, PowerShell
replaces this with the only other matching cmdlet name, `Get-Content`. Tab completion also works to
resolve PowerShell aliases and native executables.

The following graphic shows examples of tab and menu completion.

![Tab and menu completion examples](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/tab-completion/tab-menu-complete.gif)

### Other tab completion enhancements

Each new version of PowerShell includes improvements to tab completion that fix bugs and improve
usability.

PowerShell 7.0

- Tab completion resolves variable assignments that are enums or are type constrained
- Tab completion expands abbreviated cmdlets and functions. For example, `i-psdf<tab>` returns
  `Import-PowerShellDataFile`

PowerShell 7.2

- Fix tab completion for unlocalized `about*` topics
- Fix splatting being treated as positional parameter in completions
- Add completions for Comment-based Help keywords
- Add completion for `#requires` statements
- Add tab completion for **View** parameter of `Format-*` cmdlets
- Add support for class-based argument completers

PowerShell 7.3

- Fix tab completion within the script block specified for the `ValidateScriptAttribute`
- Added tab completion for loop labels after `break` and `continue`
- Improve Hashtable completion in multiple scenarios
  - Parameter splatting
  - **Arguments** parameter for `Invoke-CimMethod`
  - **FilterHashtable** parameter for `Get-WinEvent`
  - **Property** parameter for the CIM cmdlets
  - Removes duplicates from member completion scenarios
- Support forward slashes in network share (UNC path) completion
- Improve member auto completion
- Prioritize `ValidateSet` completions over enums for parameters
- Add type inference support for generic methods with type parameters
- Improve type inference and completions
  - Allows methods to be shown in completion results for `ForEach-Object -MemberName`
  - Prevents completion on expressions that return **void** like (`[void]("")`)
  - Allows non-default Class constructors to show up when class completion is based on the AST

## Other ways to enhance tab completion of command parameters

Built-in tab expansion is controlled by the internal function **TabExpansion** or **TabExpansion2**.
It's possible to create functions or modules that replace the default behavior of these functions.
You can find examples in the PowerShell Gallery by searching for the [TabExpansion][TabExpansion]
keyword.

### Using the `ValidateSet` or `ArgumentCompletions` attributes with parameters

The `ArgumentCompletions` attribute allows you to add tab completion values to a specific parameter.
The `ArgumentCompletions` attribute is similar to `ValidateSet`. Both attributes takes a list of
values to be presented when the user presses <kbd>Tab</kbd> after the parameter name. However,
unlike `ValidateSet`, the values aren't validated.

For more information, see:

- [ArgumentCompletions][ArgumentCompletions]
- [ValidateSet][ValidateSet]

### Using the `ArgumentCompleter` attribute or `Register-ArgumentCompleter` with parameters

An argument completer is a script block or function that provides dynamic tab completion for
parameter values.

The `ArgumentCompleter` attribute allows you to register a function that provides tab completion
values to for the parameter. The argument completer function must be available to the function
containing the parameter with the `ArgumentCompleter` attribute. Usually, the function is defined in
the same script or module.

For more information, see [ArgumentCompleter][ArgumentCompleter].

The `Register-ArgumentCompleter` cmdlet registers a script block as an argument completer function
at run time for any command you specify. This allows you to define argument completers outside of
the script or module or for native commands. For more information, see
[Register-ArgumentCompleter][Register-ArgumentCompleter].

## Predictive IntelliSense in PSReadLine

PSReadLine 2.1.0 introduced the **Predictive IntelliSense** feature. Predictive IntelliSense
provides suggestions for full commands based on items from your **PSReadLine** history.

PSReadLine 2.2.2 extends the power of Predictive IntelliSense by adding support for plug-in modules
that use advanced logic to provide suggestions for full commands. The **Az.Tools.Predictor** module
was the first plug-in for Predictive IntelliSense. It uses Machine Learning to predict what Azure
PowerShell command you want to run and the parameters you want to use.

For more information, see [Using predictors](using-predictors.md).

<!-- link references -->
[ArgumentCompleter]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion#argumentcompleter-attribute
[ArgumentCompletions]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters#argumentcompletions-attribute
[PSRFunctions]: https://learn.microsoft.com/powershell/module/psreadline/about/about_psreadline_functions#completion-functions
[Register-ArgumentCompleter]: xref:Microsoft.PowerShell.Core.Register-ArgumentCompleter
[TabExpansion]: https://www.powershellgallery.com/packages?q=tabexpansion
[ValidateSet]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters#validateset-attribute

# /./reference/learn/shell/using-predictors.md

    ---
    description: This article describes the features and usage of Predictive IntelliSense in PSReadLine.
    title: Using predictors in PSReadLine
    ms.date: 7/14/2022
    ---
# Using predictors in PSReadLine

**PSReadLine** 2.1.0 introduced the **Predictive IntelliSense** feature. Predictive IntelliSense
provides suggestions for full commands based on items from your **PSReadLine** history.
**PSReadLine** 2.2.2 extends the power of Predictive IntelliSense by adding support for plug-in
modules that use advanced logic to provide suggestions for full commands. The latest version,
**PSReadLine** 2.2.6, enables predictions by default.

## Using Predictive IntelliSense

When Predictive IntelliSense is enabled, the prediction suggestion appears as colored text following
the user's cursor. The suggestions from Predictive IntelliSense help new and experienced users of
PowerShell discover, edit, and execute full commands based on matching predictions. Suggestions can
come from the user's history and additional domain specific plugins.

![Inline view of a prediction](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/using-predictors/predictor-inline-1.png)

The previous images shows the default `InlineView` of the suggestion. Pressing <kbd>RightArrow</kbd>
key accepts an inline suggestion. After accepting the suggestion, you can edit the command line
before hitting <kbd>Enter</kbd> to run the command.

**PSReadLine** also offers a `ListView` presentation of the suggestions.

![List view of predictions](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/using-predictors/predictor-listview-1.png)

When in the list view, you can use the arrow keys to scroll through the available suggestions. List
view also shows the source of the prediction.

**PSReadLine** defaults to `InlineView`. You can switch between `InlineView` and `ListView` by
pressing the <kbd>F2</kbd> key. You can also use the **PredictionViewStyle** parameter of
`Set-PSReadLineOption` to change the view.

## Managing Predictive IntelliSense

To use Predictive IntelliSense you must have a newer version of **PSReadLine** installed. For best
results, install the latest version of the module.

To install **PSReadLine** using **PowerShellGet**:

```powershell
Install-Module -Name PSReadLine
```

Or install using the new [PowerShellGet v3][PSGetv3] module:

```powershell
Install-PSResource -Name PSReadLine
```

**PSReadLine** can be installed in Windows PowerShell 5.1 or in PowerShell 7 or higher. To use
predictor plug-ins you must be running in PowerShell 7.2 or higher. Windows PowerShell 5.1 can use
the history-based predictor.

In **PSReadLine** 2.2.6, Predictive IntelliSense is enabled by default depending on the following
conditions:

- If Virtual Terminal (VT) is supported and **PSReadLine** running in PowerShell 7.2 or higher,
  **PredictionSource** is set to `HistoryAndPlugin`
- If VT is supported and **PSReadLine** running in PowerShell older than 7.2, **PredictionSource**
  is set to `History`
- If VT isn't supported, **PredictionSource** is set to `None`.

Use the following command to see the current setting:

```powershell
Get-PSReadLineOption | Select-Object -Property PredictionSource
```

You can change the prediction source using the `Set-PSReadLineOption` cmdlet with the
**PredictionSource** parameter. The **PredictionSource** can be set to:

- `None`
- `History`
- `Plugin`
- `HistoryAndPlugin`

> [!NOTE]
> History-based predictions come from the history maintained by **PSReadLine**. That history is more
> comprehensive than the session-based history you can see using `Get-History`. For more
> information, see **Command history** section of [about_PSReadLine][psr-history].

### Setting the prediction color

By default, predictions appear in light grey text on the same line the user is typing. To support
accessibility needs, you can customize the prediction color. Colors are defined using ANSI escape
sequences. You can use `$PSStyle` to compose ANSI escape sequences.

```powershell
Set-PSReadLineOption -Colors @{ InlinePrediction = $PSStyle.Background.Blue }
```

Or you can create your own. The default light-grey prediction text color can be restored using the
following ANSI escape sequence.

```powershell
Set-PSReadLineOption -Colors @{ InlinePrediction = "`e[38;5;238m" }
```

For more information about setting prediction color and other PSReadLine settings, see
[Set-PSReadLineOption][Set-PSReadLineOption].

### Changing keybindings

PSReadLine contains functions to navigate and accept predictions. For example:

- `AcceptSuggestion` - Accept the current inline suggestion
- `AcceptNextSuggestionWord` - Accept the next word of the inline suggestion
- `AcceptSuggestion` is built within `ForwardChar`, which is bound to
  <kbd>RightArrow</kbd> by default
- `AcceptNextSuggestionWord` is built within the function `ForwardWord`, which can be bound to
  <kbd>Ctrl</kbd>+<kbd>f</kbd>

You can use the `Set-PSReadLineKeyHandler` cmdlet to change key bindings.

```powershell
Set-PSReadLineKeyHandler -Chord "Ctrl+f" -Function ForwardWord
```

With this binding, pressing <kbd>Ctrl</kbd>+<kbd>f</kbd> accepts the next word of an inline
suggestion when the cursor is at the end of current editing line. You can bind other keys to
`AcceptSuggestion` and `AcceptNextSuggestionWord` for similar functionalities. For example, you may
want to make <kbd>RightArrow</kbd> accept the next word of the inline suggestion, instead of the
whole suggestion line.

```powershell
Set-PSReadLineKeyHandler -Chord "RightArrow" -Function ForwardWord
```

## Using other predictor plug-ins

The **Az.Tools.Predictor** module was the first plug-in for Predictive IntelliSense. It uses Machine
Learning to predict what Azure PowerShell command you want to run and the parameters you want to
use. For more information and installation instructions, see
[Announcing General Availability of Az.Tools.Predictor][azpredictor].

The **CompletionPredictor** module adds an IntelliSense experience for anything that can be
tab-completed in PowerShell. With **PSReadLine** set to `InlineView`, you get the normal tab
completion experience. When you switch to `ListView`, you get the IntelliSense experience. You can
install the [CompletionPredictor][CompletionPredictor] module from the PowerShell Gallery.

![PowerShell IntelliSense using the CompletionPredictor](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/using-predictors/completion-predictor.gif)

As previously noted, `ListView` shows you the source of the prediction. If you have multiple
plug-ins installed the predictions are grouped by source with **History** listed first followed by
each plug-in in the order that they were loaded.

## Creating your own predictor module

You can write your own predictor using C# to create a compiled PowerShell module. The module must
implement the **System.Management.Automation.Subsystem.Prediction.ICommandPredictor** interface.
This interface declares the methods used to query for prediction results and provide feedback.

For more information, see [How to create a command-line predictor][custom-predictor].

<!-- link references -->
[azpredictor]: https://techcommunity.microsoft.com/t5/azure-tools-blog/announcing-general-availability-of-az-tools-predictor/ba-p/3297956
[Set-PSReadLineOption]: xref:PSReadLine.Set-PSReadLineOption
[PSGetv3]: https://www.powershellgallery.com/packages/PowerShellGet/3.0.14-beta14
[CompletionPredictor]: https://www.powershellgallery.com/packages/CompletionPredictor
[psr-history]: https://learn.microsoft.com/powershell/module/psreadline/about/about_psreadline#command-history
[custom-predictor]: https://learn.microsoft.com/powershell/scripting/dev-cross-plat/create-cmdline-predictor

# /./reference/learn/shell/dynamic-help.md

    ---
    description: This article explains how to use the dynamic help feature of PSReadLine.
    title: Using dynamic help
    ms.date: 03/24/2023
    ---
# Using dynamic help

Dynamic Help provides just-in-time help that allows you to stay focused on your work without losing
your place typing on the command line.

## Getting cmdlet help

Dynamic Help provides a view of full cmdlet help shown in an alternative screen buffer.
**PSReadLine** maps the function `ShowCommandHelp` to the <kbd>F1</kbd>key.

- When the cursor is at the end of a fully expanded cmdlet name, pressing <kbd>F1</kbd>displays the
  help for that cmdlet.
- When the cursor is at the end of a fully expanded parameter name, pressing <kbd>F1</kbd>displays
  the help for the cmdlet beginning at the parameter.

![Full screen Dynamic help][01]

The pager in **PSReadLine** allows you to scroll the displayed help using the up and down arrow
keys. Pressing <kbd>Q</kbd> exits the alternative screen buffer and returns to the current cursor
position on the command line on the primary screen.

## Getting focused parameter help

Pressing <kbd>Alt</kbd>+<kbd>h</kbd> provides dynamic help for parameters. The help is shown below
the current command line similar to [MenuComplete][05]. The cursor must be at the end of
the fully expanded parameter name when you press the <kbd>Alt</kbd>+<kbd>h</kbd> key.

![Focused help for a parameter using Alt-h][02]

## Selecting arguments on the command line

To quickly select and edit the arguments of a cmdlet without disturbing your syntax using
<kbd>Alt</kbd>+<kbd>a</kbd>. Based on the cursor position, it searches from the current cursor
position and stops when it finds any arguments on the command line.

![Argument selection using Alt-A][03]

## Choosing keybindings

Not all keybindings work for all operating systems and terminal applications. For example,
keybindings for the <kbd>Alt</kbd> key don't work on macOS by default. On Linux,
<kbd>Ctrl</kbd>+<kbd>[</kbd> is the same as <kbd>Escape</kbd>. And
<kbd>Ctrl</kbd>+<kbd>Spacebar</kbd> generates a <kbd>Control</kbd>+<kbd>2</kbd> key sequence instead
of the <kbd>Control</kbd>+<kbd>Spacebar</kbd> sequence expected.

To work around these quirks, map the PSReadLine function to an available key combination. For
example:

```powershell
Set-PSReadLineKeyHandler -chord 'Ctrl+l' -Function ShowParameterHelp
Set-PSReadLineKeyHandler -Chord 'Ctrl+k' -Function SelectCommandArgument
```

For more information about keybindings and workarounds, see [Using PSReadLine key handlers][04].

<!-- link references -->
[01]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/dynamic-help/dynamic-help.gif
[02]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/dynamic-help/dynamic-help-alt-h.png
[03]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/dynamic-help/dynamic-help-alt-a.gif
[04]: using-keyhandlers.md
[05]: tab-completion.md#command-and-parameter-name-completion

# /./reference/learn/shell/using-aliases.md

    ---
    description: This article describe how to use aliases in PowerShell.
    ms.date: 11/16/2022
    title: Using aliases
    ---
# Using aliases

An alias is an alternate name or shorthand name for a cmdlet or for a command element, such as a
function, script, file, or executable file. You can run the command using the alias instead of the
executable name.

## Managing command aliases

PowerShell provides cmdlets for managing command aliases.

```powershell
Get-Command -Noun Alias
```

```Output
CommandType Name         Version Source
----------- ----         ------- ------
Cmdlet      Export-Alias 7.0.0.0 Microsoft.PowerShell.Utility
Cmdlet      Get-Alias    7.0.0.0 Microsoft.PowerShell.Utility
Cmdlet      Import-Alias 7.0.0.0 Microsoft.PowerShell.Utility
Cmdlet      New-Alias    7.0.0.0 Microsoft.PowerShell.Utility
Cmdlet      Remove-Alias 7.0.0.0 Microsoft.PowerShell.Utility
Cmdlet      Set-Alias    7.0.0.0 Microsoft.PowerShell.Utility
```

For more information, see [about_Aliases][01].

Use the [Get-Alias][04] cmdlet to list the aliases available in your environment. To list the
aliases for a single cmdlet, use the **Definition** parameter and specify the executable name.

```powershell
Get-Alias -Definition Get-ChildItem
```

```Output
CommandType     Name
-----------     ----
Alias           dir -> Get-ChildItem
Alias           gci -> Get-ChildItem
Alias           ls -> Get-ChildItem
```

To get the definition of a single alias, use the **Name** parameter.

```powershell
Get-Alias -Name gci
```

```Output
CommandType     Name
-----------     ----
Alias           gci -> Get-ChildItem
```

## Compatibility aliases in Windows

PowerShell has several aliases that allow **UNIX** and **cmd.exe** users to use familiar commands in
Windows. The following table show common commands, the related PowerShell cmdlet, and the PowerShell
alias:

|            cmd.exe command            | UNIX command | PowerShell cmdlet |             PowerShell alias              |
| ------------------------------------- | ------------ | ----------------- | ----------------------------------------- |
| **cd**, **chdir**                     | **cd**       | `Set-Location`    | `sl`, `cd`, `chdir`                       |
| **cls**                               | **clear**    | `Clear-Host`      | `cls` `clear`                             |
| **copy**                              | **cp**       | `Copy-Item`       | `cpi`, `cp`, `copy`                       |
| **del**, **erase**, **rd**, **rmdir** | **rm**       | `Remove-Item`     | `ri`, `del`, `erase`, `rd`, `rm`, `rmdir` |
| **dir**                               | **ls**       | `Get-ChildItem`   | `gci`, `dir`, `ls`                        |
| **echo**                              | **echo**     | `Write-Output`    | `write` `echo`                            |
| **md**                                | **mkdir**    | `New-Item`        | `ni`                                      |
| **move**                              | **mv**       | `Move-Item`       | `mi`, `move`, `mi`                        |
| **popd**                              | **popd**     | `Pop-Location`    | `popd`                                    |
|                                       | **pwd**      | `Get-Location`    | `gl`, `pwd`                               |
| **pushd**                             | **pushd**    | `Push-Location`   | `pushd`                                   |
| **ren**                               | **mv**       | `Rename-Item`     | `rni`, `ren`                              |
| **type**                              | **cat**      | `Get-Content`     | `gc`, `cat`, `type`                       |

> [!NOTE]
> The aliases in this table are Windows-specific. Some aliases aren't available on other platforms.
> This is to allow the native command to work in a PowerShell session. For example, `ls` isn't
> defined as a PowerShell alias on macOS or Linux so that the native command is run instead of
> `Get-ChildItem`.

## Creating alternate names for commands with parameters

You can assign an alias to a cmdlet, script, function, or executable file. Unlike some Unix shells,
you cannot assign an alias to a command with parameters. For example, you can assign an alias to the
`Get-Eventlog` cmdlet, but you cannot assign an alias to the `Get-Eventlog -LogName System` command.
You must create a function that contains the command with parameters.

For more information, see [about_Aliases][02].

## Parameter aliases and shorthand names

PowerShell also provides ways to create shorthand names for parameters. Parameter aliases are
defined using the `Alias` attribute when you declare the parameter. These can't be defined using the
`*-Alias` cmdlets.

For more information, see the [Alias attribute][03] documentation.

In addition to parameter aliases, PowerShell lets you specify the parameter name using the fewest
characters needed to uniquely identify the parameter. For example, the `Get-ChildItem` cmdlet has
the **Recurse** and **ReadOnly** parameters. To uniquely identify the **Recurse** parameter you only
need to provide `-rec`. If you combine that with the command alias, `Get-ChildItem -Recurse` can be
shortened to `dir -rec`.

## Don't use aliases in scripts

Aliases are a convenience feature to be used interactively in the shell. You should always use the
full command and parameter names in your scripts.

- Aliases can be deleted or redefined in a profile script
- Any aliases you define may not be available to the user of your scripts
- Aliases make your code harder to read and maintain

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_aliases
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_aliases#alternate-names-for-commands-with-parameters
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters#alias-attribute
[04]: xref:Microsoft.PowerShell.Utility.Get-Alias

# /./reference/learn/shell/creating-profiles.md

    ---
    description: >
      This article explains how to use your profile to save preferred PowerShell settings and optimize
      your shell experience.
    ms.date: 12/01/2022
    title: Customizing your shell environment
    ---
# Customizing your shell environment

A PowerShell profile is a script that runs when PowerShell starts. You can use the profile to
customize the environment. You can:

- add aliases, functions, and variables
- load modules
- create PowerShell drives
- run arbitrary commands
- and change preference settings

Putting these settings in your profile ensures that they're available whenever you start PowerShell
on your system.

> [!NOTE]
> To run scripts in Windows, the PowerShell execution policy needs to be set to `RemoteSigned` at a
> minimum. Execution policies don't apply to macOS and Linux. For more information, see
> [about_Execution_Policy][1].

## The $PROFILE variable

The `$PROFILE` automatic variable stores the paths to the PowerShell profiles that are available in
the current session.

There are four possible profiles available to support different user scopes and different PowerShell
hosts. The fully qualified paths for each profile script are stored in the following member
properties of `$PROFILE`.

- **AllUsersAllHosts**
- **AllUsersCurrentHost**
- **CurrentUserAllHosts**
- **CurrentUserCurrentHost**

You can create profile scripts that run for all users or just one user, the **CurrentUser**.
**CurrentUser** profiles are stored in the user's home directory.

There are also profiles that run for all PowerShell hosts or specific hosts. The profile script
for each PowerShell host has a name unique for that host. For example, the filename for the standard
Console Host on Windows or the default terminal application on other platforms is
`Microsoft.PowerShell_profile.ps1`. For Visual Studio Code (VS Code), the filename is
`Microsoft.VSCode_profile.ps1`.

For more information, see [about_Profiles][2].

By default, referencing the `$PROFILE` variable returns the path to the "Current User, Current Host"
profile. The other profiles path can be accessed through the properties of the `$PROFILE` variable.
For example:

```powershell
PS> $PROFILE
C:\Users\user1\Documents\PowerShell\Microsoft.PowerShell_profile.ps1
PS> $PROFILE.AllUsersAllHosts
C:\Program Files\PowerShell\7\profile.ps1
```

## How to create your personal profile

When you first install PowerShell on a system, the profile script files and the directories they
belong to don't exist. The following command creates the "Current User, Current Current Host"
profile script file if it doesn't exist.

```powershell
if (!(Test-Path -Path $PROFILE)) {
  New-Item -ItemType File -Path $PROFILE -Force
}
```

The **Force** parameter of `New-Item` cmdlet creates the necessary folders when they don't exist.
Once you have created the script file, you can use your favorite editor to customize your shell
environment.

## Adding customizations to your profile

The previous articles talked about using [tab completion][3], [command predictors][4], and
[aliases][5]. These articles showed the commands used to load the required modules, create custom
completers, define keybindings, and other settings. These are the kinds of customizations that you
want to have available in every PowerShell interactive session. The profile script is the place for
these settings.

The simplest way to edit your profile script is to open the file in your favorite code editor. For
example, the following command opens the profile in [VS Code][6].

```powershell
code $PROFILE
```

You could also use `notepad.exe` on Windows, `vi` on Linux, or any other text editor.

The following profile script has examples for many of the customizations mentioned in the
previous articles. You can use any of these settings in your own profile.

```powershell
## Map PSDrives to other registry hives
if (!(Test-Path HKCR:)) {
    $null = New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT
    $null = New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS
}

## Customize the prompt
function prompt {
    $identity = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = [Security.Principal.WindowsPrincipal] $identity
    $adminRole = [Security.Principal.WindowsBuiltInRole]::Administrator

    $prefix = $(if (Test-Path variable:/PSDebugContext) { '[DBG]: ' }
                elseif ($principal.IsInRole($adminRole)) { "[ADMIN]: " }
                else { '' })
    $body = 'PS ' + $(Get-Location)
    $suffix = $(if ($NestedPromptLevel -ge 1) { '>>' }) + '> '
    $prefix + $body + $suffix
}

## Create $PSStyle if running on a version older than 7.2
## - Add other ANSI color definitions as needed

if ($PSVersionTable.PSVersion.ToString() -lt '7.2.0') {
    # define escape char since "`e" may not be supported
    $esc = [char]0x1b
    $PSStyle = [pscustomobject]@{
        Foreground = @{
            Magenta = "${esc}[35m"
            BrightYellow = "${esc}[93m"
        }
        Background = @{
            BrightBlack = "${esc}[100m"
        }
    }
}

## Set PSReadLine options and keybindings
$PSROptions = @{
    ContinuationPrompt = '  '
    Colors             = @{
        Operator         = $PSStyle.Foreground.Magenta
        Parameter        = $PSStyle.Foreground.Magenta
        Selection        = $PSStyle.Background.BrightBlack
        InLinePrediction = $PSStyle.Foreground.BrightYellow + $PSStyle.Background.BrightBlack
    }
}
Set-PSReadLineOption @PSROptions
Set-PSReadLineKeyHandler -Chord 'Ctrl+f' -Function ForwardWord
Set-PSReadLineKeyHandler -Chord 'Enter' -Function ValidateAndAcceptLine

## Add argument completer for the dotnet CLI tool
$scriptblock = {
    param($wordToComplete, $commandAst, $cursorPosition)
    dotnet complete --position $cursorPosition $commandAst.ToString() |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
}
Register-ArgumentCompleter -Native -CommandName dotnet -ScriptBlock $scriptblock
```

This profile script provides examples for the following customization:

- Adds two new [PSDrives][7] for the other root registry hives.
- Creates a [customized prompt][8] that changes if you are running in an elevated session.
- Configures **PSReadLine** and adds keybinding. The color settings use the [$PSStyle][9] feature to
  define the ANSI color settings.
- Adds tab completion for the [dotnet CLI][10] tool. The tool provides parameters to help resolve the
  command-line arguments. The script block for [Register-ArgumentCompleter][11] uses that
  feature to provide the tab completion.

<!-- link references -->

[1]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_execution_policies
[2]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_profiles
[3]: tab-completion.md
[4]: using-predictors.md
[5]: using-aliases.md
[6]: https://code.visualstudio.com/
[7]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_filesystem_provider
[8]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_prompts
[9]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_ansi_terminals
[10]: https://learn.microsoft.com/dotnet/core/tools/
[11]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/register-argumentcompleter

# /./reference/learn/shell/using-keyhandlers.md

    ---
    description: This article explains how to use PSReadLine keybindings for various platforms and terminals applications.
    title: Using PSReadLine key handlers
    ms.date: 03/27/2023
    ---
# Using PSReadLine key handlers

The **PSReadLine** module provides key handlers that map **PSReadLine** functions to keyboard
chords. Keyboard chords are a sequence of one or more keystrokes that are pressed at the same time.
For example, the chord <kbd>Ctrl</kbd>+<kbd>Spacebar</kbd> is the combination of the <kbd>Ctrl</kbd>
and <kbd>Spacebar</kbd> keys pressed at the same time. A **PSReadLine** function is a predefined
action that can be performed on a command line. For example, the `MenuComplete` function allows you
to choose from a list of options from a menu complete the input on the command line.

**PSReadLine** has several predefined key handlers that are bound by default. You can also define
your own custom key handlers. Run the following command to list the key handlers that are currently
defined.

```powershell
Get-PSReadLineKeyHandler
```

You can also get a list of all unbound **PSReadLine** functions that are available to be bound to a key chord.

```powershell
Get-PSReadLineKeyHandler -Unbound
```

You can use the `Set-PSReadLineKeyHandler` cmdlet to bind a function to a key handler. The following
command binds the `MenuComplete` function to the chord <kbd>Ctrl</kbd>+<kbd>Spacebar</kbd>.

```powershell
Set-PSReadLineKeyHandler -Chord 'Ctrl+Spacebar' -Function MenuComplete
```

## Finding key names and chord bindings

The names of the keys in the chord are defined by the `[System.ConsoleKey]` enumeration. For more
information, see [System.ConsoleKey][05] documentation. For example, the name of the <kbd>2</kbd>
key in `[System.ConsoleKey]` is `D2`, whereas the name of the <kbd>2</kbd> key on the numeric keypad
is `NumPad2`. You can use the `[System.Console]::ReadKey()` method to find the name of the key you
pressed.

```powershell
[System.Console]::ReadKey()
```

The following output shows the information returned by the `ReadKey()` method for the
<kbd>Ctrl</kbd>+<kbd>2</kbd> key chord.

```Output
KeyChar Key Modifiers
------- --- ---------
        D2   Control
```

For the **PSReadLine** key handler cmdlets, this chord is represented as `Ctrl+D2`. The following
example binds this chord to a function.

```powershell
Set-PSReadLineKeyHandler -Chord 'Ctrl+D2' -Function MenuComplete
```

You can bind multiple cords to a single function. By default, the `BackwardDeleteChar` function is
bound to two chords.

```powershell
Get-PSReadLineKeyHandler -Chord Backspace, Ctrl+h
```

```Output
Key       Function           Description
---       --------           -----------
Backspace BackwardDeleteChar Delete the character before the cursor
Ctrl+h    BackwardDeleteChar Delete the character before the cursor
```

> [!NOTE]
> The **Chord** parameter is **case-sensitive**. Meaning, you can create different bindings for
> <kbd>Ctrl</kbd>+<kbd>X</kbd> and <kbd>Ctrl</kbd>+<kbd>x</kbd>.

On Windows, you can also use the <kbd>Alt</kbd>+<kbd>?</kbd> key chord to show the function bound to
the next key chord you enter. When you type <kbd>Alt</kbd>+<kbd>?</kbd> you see the following
prompt:

```Output
what-is-key:
```

When you hit the <kbd>Backspace</kbd> key you get the following response:

```Output
Backspace: BackwardDeleteChar - Delete the character before the cursor
```

## Key handlers on non-Windows computers

The key codes generated by your keyboard can be different depending on the operating system and
terminal application you are using.

### macOS

The Macintosh keyboard doesn't have an <kbd>Alt</kbd> key like Windows and Linux systems. Instead,
it has the <kbd>&#x2325; Option</kbd> key. macOS uses this key differently than the <kbd>Alt</kbd>
key on other systems. However, you can configure the terminal and iTerm2 applications on macOS to
treat it as an <kbd>Alt</kbd> key.

#### Configuring the Terminal application

Open the **Settings** window from the App bar in Terminal.app. Select **Profiles** and choose the
profile you want to configure. Select the **Keyboard** tab of the configuration options. Below the
list of keys, select the **Use Option as Meta Key** setting. This setting allows the <kbd>&#x2325;
Option</kbd> key to act as <kbd>Alt</kbd> in the Terminal application.

![Screenshot of Terminal.app settings.][02]

#### Configuring the iTerm2 application

Open the **Settings** window from the App Bar in iTerm.app. Select **Profiles** and choose the
profile you want to configure. Select the **Keys** tab of the configuration options. Select the
**Esc+** option for both the **Left Option Key** and **Right Option Key** settings. This setting
allows the <kbd>&#x2325; Option</kbd> key to act as <kbd>Alt</kbd> in the iTerm application.

![Screenshot of iTerm.app settings.][01]

> [!NOTE]
> The exact steps may vary depending on the versions of macOS and the terminal applications. These
> examples were captured on macOS Ventura 13.2.1 and iTerm2 v3.4.16.

### Linux

On Linux platforms, the key code generated can be different than other systems. For example:

- <kbd>Ctrl</kbd>+<kbd>[</kbd> is the same as <kbd>Escape</kbd>
- <kbd>Ctrl</kbd>+<kbd>Spacebar</kbd> generates the key codes for <kbd>Ctrl</kbd>+<kbd>D2</kbd>. If
  you want to map a function <kbd>Ctrl</kbd>+<kbd>Spacebar</kbd> you must use the chord `Ctrl+D2`.

  ```powershell
  Set-PSReadLineKeyHandler -Chord 'Ctrl+D2' -Function MenuComplete
  ```

Use the `ReadKey()` method to verify the key codes generated by your keyboard.

## Commonly used key handlers

Here are a few commonly used key handlers that are bound by default on Windows. Note that the key
binding may be different on non-Windows platforms.

### MenuComplete

Complete the input by selecting from a menu of possible completion values.

Default chord: `Ctrl+Spacebar`

The following example shows the menu of possible completions for commands beginning with `select`.

```Output
PS C:\> select<Ctrl+Spacebar>
select                   Select-Object            Select-PSFPropertyValue  Select-Xml
Select-AzContext         Select-PSFConfig         Select-PSMDBuildProject
Select-AzSubscription    Select-PSFObject         Select-String

Select-Object
```

Use the arrow keys to select the completion you want. Press the <kbd>Enter</kbd> key to complete the
input. As you move through the selections, help for the selected command is displayed below the
menu.

### ClearScreen

This function clears the screen similar to the `cls` or `clear` commands.

Default chord: `Ctrl+l`

### SelectCommandArgument

Selects the next argument on the command line.

Default chord: `Alt+a`

You may have command in your history that you want to run again with different parameter values. You
can use the chord to cycle through each parameter and change the value as needed.

`New-AzVM -ResourceGroupName myRGName -Location eastus -Name myVM`

Pressing <kbd>Alt</kbd>+<kbd>a</kbd> selects the next parameter argument in turn: `myRGName`,
`eastus`, `myVM`.

### GotoBrace

Moves the cursor to the matching brace.

Default chord: `Ctrl+]`

This functions moves your cursor to the closing brace that matches the brace at the current cursor
position on the command line. The function works for brackets (`[]`), braces (`{}`), and
parentheses, (`()`).

### DigitArgument

Start or accumulate a numeric argument use to repeat a keystroke the specified number of times.

Default chord: `Alt+0` through `Alt+9`

For example, typing <kbd>Alt</kbd>+<kbd>4</kbd>+<kbd>#</kbd> enters `####` on the command line.

## See also

- [Get-PSReadLineKeyHandler][03]
- [Set-PSReadLineKeyHandler][04]

<!-- link references -->
[01]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/using-keyhandlers/macos-iterm2-settings.png
[02]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/shell/media/using-keyhandlers/macos-terminal-settings.png
[03]: xref:PSReadLine.Get-PSReadLineKeyHandler
[04]: xref:PSReadLine.Set-PSReadLineKeyHandler
[05]: xref:System.ConsoleKey

# /./reference/learn/shell/using-light-theme.md

    ---
    description: >
      This article shows how to configure PSReadLine color settings for a light themed terminal.
    ms.date: 12/17/2022
    title: Configuring a light colored theme
    ---
# Configuring a light colored theme

The default colors for both PowerShell and **PSReadLine** are selected for a dark background
terminal. However, some users may choose to use a light background with dark text. Since most of the
default colors don't set the background, using light foreground colors on a light background
produces unreadable text.

**PSReadLine** allows you to define colors for 18 different syntax elements. You can view the
current settings using the `Get-PSReadLineOption` cmdlet.

```Output
EditMode                               : Windows
AddToHistoryHandler                    : System.Func`2[System.String,System.Object]
HistoryNoDuplicates                    : True
HistorySavePath                        : C:\Users\user1\AppData\Roaming\Microsoft\Wind...
HistorySaveStyle                       : SaveIncrementally
HistorySearchCaseSensitive             : False
HistorySearchCursorMovesToEnd          : False
MaximumHistoryCount                    : 4096
ContinuationPrompt                     : >>
ExtraPromptLineCount                   : 0
PromptText                             : {> }
BellStyle                              : Audible
DingDuration                           : 50
DingTone                               : 1221
CommandsToValidateScriptBlockArguments : {ForEach-Object, %, Invoke-Command, icm...}
CommandValidationHandler               :
CompletionQueryItems                   : 100
MaximumKillRingCount                   : 10
ShowToolTips                           : True
ViModeIndicator                        : None
WordDelimiters                         : ;:,.[]{}()/\|^&*-=+'"-—―
AnsiEscapeTimeout                      : 100
PredictionSource                       : HistoryAndPlugin
PredictionViewStyle                    : InlineView
CommandColor                           : "`e[93m"
CommentColor                           : "`e[32m"
ContinuationPromptColor                : "`e[37m"
DefaultTokenColor                      : "`e[37m"
EmphasisColor                          : "`e[96m"
ErrorColor                             : "`e[91m"
InlinePredictionColor                  : "`e[38;5;238m"
KeywordColor                           : "`e[92m"
ListPredictionColor                    : "`e[33m"
ListPredictionSelectedColor            : "`e[48;5;238m"
MemberColor                            : "`e[97m"
NumberColor                            : "`e[97m"
OperatorColor                          : "`e[90m"
ParameterColor                         : "`e[90m"
SelectionColor                         : "`e[30;47m"
StringColor                            : "`e[36m"
TypeColor                              : "`e[37m"
VariableColor                          : "`e[92m"
```

The color settings are stored as strings containing ANSI escape sequences that change the color in
your terminal. Using the `Set-PSReadLineOption` cmdlet you can change the colors to values that work
better for a light-colored background.

## Defining colors for a light theme

The PowerShell ISE can be configured to use a light theme for both the editor and console panes. You
can also view and change the colors that the ISE uses for various syntax and output types. You can
use these color choices to define a similar theme for **PSReadLine**.

The following hashtable defines colors for **PSReadLine** that mimic the colors in the PowerShell
ISE.

```powershell
$ISETheme = @{
    Command                  = $PSStyle.Foreground.FromRGB(0x0000FF)
    Comment                  = $PSStyle.Foreground.FromRGB(0x006400)
    ContinuationPrompt       = $PSStyle.Foreground.FromRGB(0x0000FF)
    Default                  = $PSStyle.Foreground.FromRGB(0x0000FF)
    Emphasis                 = $PSStyle.Foreground.FromRGB(0x287BF0)
    Error                    = $PSStyle.Foreground.FromRGB(0xE50000)
    InlinePrediction         = $PSStyle.Foreground.FromRGB(0x93A1A1)
    Keyword                  = $PSStyle.Foreground.FromRGB(0x00008b)
    ListPrediction           = $PSStyle.Foreground.FromRGB(0x06DE00)
    Member                   = $PSStyle.Foreground.FromRGB(0x000000)
    Number                   = $PSStyle.Foreground.FromRGB(0x800080)
    Operator                 = $PSStyle.Foreground.FromRGB(0x757575)
    Parameter                = $PSStyle.Foreground.FromRGB(0x000080)
    String                   = $PSStyle.Foreground.FromRGB(0x8b0000)
    Type                     = $PSStyle.Foreground.FromRGB(0x008080)
    Variable                 = $PSStyle.Foreground.FromRGB(0xff4500)
    ListPredictionSelected   = $PSStyle.Background.FromRGB(0x93A1A1)
    Selection                = $PSStyle.Background.FromRGB(0x00BFFF)
}
```

> [!NOTE]
> In PowerShell 7.2 and higher you can use the `FromRGB()` method of `$PSStyle` to create the ANSI
> escape sequences for the colors you want.
>
> For more information about `$PSStyle`, see [about_ANSI_Terminals][01].
>
> For more information about ANSI escape sequences, see the [ANSI escape code][04] article in
> Wikipedia.

## Setting the color theme in your profile

To have the color settings you want in every PowerShell session, you must add the configuration
settings to your PowerShell profile script. For an example, see
[Customizing your shell environment][02]

Add the `$ISETheme` variable and the following `Set-PSReadLineOption` command to your profile.

```powershell
Set-PSReadLineOption -Colors $ISETheme
```

Beginning in PowerShell 7.2, PowerShell adds colorized output to the default console experience. The
colors used are defined in the `$PSStyle` variable and are designed for a dark background. The
following settings work better for a light background terminal.

```powershell
$PSStyle.Formatting.FormatAccent       = "`e[32m"
$PSStyle.Formatting.TableHeader        = "`e[32m"
$PSStyle.Formatting.ErrorAccent        = "`e[36m"
$PSStyle.Formatting.Error              = "`e[31m"
$PSStyle.Formatting.Warning            = "`e[33m"
$PSStyle.Formatting.Verbose            = "`e[33m"
$PSStyle.Formatting.Debug              = "`e[33m"
$PSStyle.Progress.Style                = "`e[33m"
$PSStyle.FileInfo.Directory            = $PSStyle.Background.FromRgb(0x2f6aff) +
                                         $PSStyle.Foreground.BrightWhite
$PSStyle.FileInfo.SymbolicLink         = "`e[36m"
$PSStyle.FileInfo.Executable           = "`e[95m"
$PSStyle.FileInfo.Extension['.ps1']    = "`e[36m"
$PSStyle.FileInfo.Extension['.ps1xml'] = "`e[36m"
$PSStyle.FileInfo.Extension['.psd1']   = "`e[36m"
$PSStyle.FileInfo.Extension['.psm1']   = "`e[36m"
```

## Choosing colors for accessibility

The ISE color theme may not work for users with color-blindness or other conditions that limit their
ability to see colors.

The [World Wide Web Consortium (W3C)][05] has recommendations for using colors for accessibility.
The Web Content Accessibility Guidelines (WCAG) 2.1 recommends that "visual presentation of text and
images of text has a contrast ratio of at least 4.5:1." For more information, see
[Success Criterion 1.4.3 Contrast (Minimum)][06].

The [Contrast Ratio][03] website provides a tool that lets you pick foreground and background
colors and measure the contrast. You can use this tool to find color combinations that work best for
you.

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/About/about_ANSI_Terminals
[02]: creating-profiles.md
[03]: https://contrast-ratio.com/
[04]: https://en.wikipedia.org/wiki/ANSI_escape_code
[05]: https://www.w3.org/
[06]: https://www.w3.org/TR/WCAG/#contrast-minimum

# /./reference/learn/deep-dives/overview.md

    ---
    description: The Deep Dives section of the documentation contains articles the provide more details and examples than the cmdlet reference.
    ms.date: 11/16/2022
    title: Deep dives
    ---
# Deep dive articles

The articles in this section are designed to be an in-depth look into PowerShell topics. These
articles don't replace the reference articles, but provide diverse examples, illustrate edge
cases, and warn about pitfalls and common mistakes.

This collection is also a showcase for community contributions. The inaugural set of articles come
from [@KevinMarquette][@KevinMarquette] and were originally published at [PowerShellExplained.com][PowerShellExplained.com].

## How to contribute content

If you're interested in contributing content to this collection, please read the [Contributor Guide][Contributor Guide].
When you are ready to propose a contribution, submit an issue in the GitHub repository using the
[Document Idea template][Document Idea template] and include a link to the existing content you want
to share.

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Contributor Guide]: https://aka.ms/PSDocsContributor
[Document Idea template]: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/new?assignees=&labels=doc-idea&template=New_Document_Request.md&title=Community+contribution

# /./reference/learn/deep-dives/everything-about-arrays.md

    ---
    description: Arrays are a fundamental language feature of most programming languages.
    ms.custom: contributor-KevinMarquette
    ms.date: 11/16/2022
    title: Everything you wanted to know about arrays
    ---
# Everything you wanted to know about arrays

[Arrays][02] are a fundamental language feature of most programming languages. They're a collection
of values or objects that are difficult to avoid. Let's take a close look at arrays and everything
they have to offer.

> [!NOTE]
> The [original version][12] of this article appeared on the blog written by [@KevinMarquette][13].
> The PowerShell team thanks Kevin for sharing this content with us. Please check out his blog at
> [PowerShellExplained.com][09].

## What is an array?

I'm going to start with a basic technical description of what arrays are and how they are used by
most programming languages before I shift into the other ways PowerShell makes use of them.

An array is a data structure that serves as a collection of multiple items. You can iterate over the
array or access individual items using an index. The array is created as a sequential chunk of
memory where each value is stored right next to the other.

I'll touch on each of those details as we go.

## Basic usage

Because arrays are such a basic feature of PowerShell, there is a simple syntax for working with
them in PowerShell.

### Create an array

An empty array can be created by using `@()`

```powershell
PS> $data = @()
PS> $data.count
0
```

We can create an array and seed it with values just by placing them in the `@()` parentheses.

```powershell
PS> $data = @('Zero','One','Two','Three')
PS> $data.count
4

PS> $data
Zero
One
Two
Three
```

This array has 4 items. When we call the `$data` variable, we see the list of our items. If it's an
array of strings, then we get one line per string.

We can declare an array on multiple lines. The comma is optional in this case and generally left
out.

```powershell
$data = @(
    'Zero'
    'One'
    'Two'
    'Three'
)
```

I prefer to declare my arrays on multiple lines like that. Not only does it get easier to read when
you have multiple items, it also makes it easier to compare to previous versions when using source
control.

#### Other syntax

It's commonly understood that `@()` is the syntax for creating an array, but comma-separated lists
work most of the time.

```powershell
$data = 'Zero','One','Two','Three'
```

#### Write-Output to create arrays

One cool little trick worth mentioning is that you can use `Write-Output` to quickly create strings
at the console.

```powershell
$data = Write-Output Zero One Two Three
```

This is handy because you don't have to put quotes around the strings when the parameter accepts
strings. I would never do this in a script but it's fair game in the console.

### Accessing items

Now that you have an array with items in it, you may want to access and update those items.

#### Offset

To access individual items, we use the brackets `[]` with an offset value starting at 0. This is
how we get the first item in our array:

```powershell
PS> $data = 'Zero','One','Two','Three'
PS> $data[0]
Zero
```

The reason why we use zero here is because the first item is at the beginning of the list so we use
an offset of 0 items to get to it. To get to the second item, we would need to use an offset of 1 to
skip the first item.

```powershell
PS> $data[1]
One
```

This would mean that the last item is at offset 3.

```powershell
PS> $data[3]
Three
```

#### Index

Now you can see why I picked the values that I did for this example. I introduced this as an offset
because that is what it really is, but this offset is more commonly referred to as an index. An
index that starts at `0`. For the rest of this article I will call the offset an index.

#### Special index tricks

In most languages, you can only specify a single number as the index and you get a single item back.
PowerShell is much more flexible. You can use multiple indexes at once. By providing a list of
indexes, we can select several items.

```powershell
PS> $data[0,2,3]
Zero
Two
Three
```

The items are returned based on the order of the indexes provided. If you duplicate an index,
you get that item both times.

```powershell
PS> $data[3,0,3]
Three
Zero
Three
```

We can specify a sequence of numbers with the built-in `..` operator.

```powershell
PS> $data[1..3]
One
Two
Three
```

This works in reverse too.

```powershell
PS> $data[3..1]
Three
Two
One
```

You can use negative index values to offset from the end. So if you need the last item in the list,
you can use `-1`.

```powershell
PS> $data[-1]
Three
```

One word of caution here with the `..` operator. The sequence `0..-1` and `-1..0` evaluate to the
values `0,-1` and `-1,0`. It's easy to see `$data[0..-1]` and think it would enumerate all items if
you forget this detail. `$data[0..-1]` gives you the same value as `$data[0,-1]` by giving you the
first and last item in the array (and none of the other values). Here is a larger example:

```powershell
PS> $a = 1,2,3,4,5,6,7,8
PS> $a[2..-1]
3
2
1
8
```

This is the same as:

```powershell
PS> $a[2,1,0,-1]
3
2
1
8
```

#### Out of bounds

In most languages, if you try to access an index of an item that is past the end of the array, you
would get some type of error or an exception. PowerShell silently returns nothing.

```powershell
PS> $null -eq $data[9000]
True
```

#### Cannot index into a null array

If your variable is `$null` and you try to index it like an array, you get a
`System.Management.Automation.RuntimeException` exception with the message
`Cannot index into a null array`.

```powershell
PS> $empty = $null
PS> $empty[0]
Error: Cannot index into a null array.
```

So make sure your arrays are not `$null` before you try to access elements inside them.

#### Count

Arrays and other collections have a count property that tells you how many items are in the array.

```powershell
PS> $data.count
4
```

PowerShell 3.0 added a count property to most objects. you can have a single object and it should
give you a count of `1`.

```powershell
PS> $date = Get-Date
PS> $date.count
1
```

Even `$null` has a count property except it returns `0`.

```powershell
PS> $null.count
0
```

There are some traps here that I will revisit when I cover checking for `$null` or empty arrays
later on in this article.

#### Off-by-one errors

A common programming error is created because arrays start at index 0. Off-by-one errors can be
introduced in two ways.

The first is by mentally thinking you want the second item and using an index of `2` and really getting
the third item. Or by thinking that you have four items and you want last item, so you use the count
to access the last item.

```powershell
$data[ $data.count ]
```

PowerShell is perfectly happy to let you do that and give you exactly what item exists at index 4:
`$null`. You should be using `$data.count - 1` or the `-1` that we learned about above.

```powershell
PS> $data[ $data.count - 1 ]
Three
```

This is where you can use the `-1` index to get the last element.

```powershell
PS> $data[ -1 ]
Three
```

Lee Dailey also pointed out to me that we can use `$data.GetUpperBound(0)` to get the max index
number.

```powershell
PS> $data.GetUpperBound(0)
3
PS> $data[ $data.GetUpperBound(0) ]
Three
```

The second most common way is when iterating the list and not stopping at the right time. I'll
revisit this when we talk about using the `for` loop.

### Updating items

We can use the same index to update existing items in the array. This gives us direct access to
update individual items.

```powershell
$data[2] = 'dos'
$data[3] = 'tres'
```

If we try to update an item that is past the last element, then we get an
`Index was outside the bounds of the array.` error.

```powershell
PS> $data[4] = 'four'
Index was outside the bounds of the array.
At line:1 char:1
+ $data[4] = 'four'
+ ~~~~~~~~~~~~~
+ CategoryInfo          : OperationStopped: (:) [], IndexOutOfRangeException
+ FullyQualifiedErrorId : System.IndexOutOfRangeException
```

I'll revisit this later when I talk about how to make an array larger.

### Iteration

At some point, you might need to walk or iterate the entire list and perform some action for each
item in the array.

#### Pipeline

Arrays and the PowerShell pipeline are meant for each other. This is one of the simplest ways to
process over those values. When you pass an array to a pipeline, each item inside the array is
processed individually.

```powershell
PS> $data = 'Zero','One','Two','Three'
PS> $data | ForEach-Object {"Item: [$PSItem]"}
Item: [Zero]
Item: [One]
Item: [Two]
Item: [Three]
```

If you have not seen `$PSItem` before, just know that it's the same thing as `$_`. You can use either
one because they both represent the current object in the pipeline.

#### ForEach loop

The `ForEach` loop works well with collections. Using the syntax:
`foreach ( <variable> in <collection> )`

```powershell
foreach ( $node in $data )
{
    "Item: [$node]"
}
```

#### ForEach method

I tend to forget about this one but it works well for simple operations. PowerShell allows you to
call `.ForEach()` on a collection.

```powershell
PS> $data.foreach({"Item [$PSItem]"})
Item [Zero]
Item [One]
Item [Two]
Item [Three]
```

The `.foreach()` takes a parameter that is a script block. You can drop the parentheses and just
provide the script block.

```powershell
$data.foreach{"Item [$PSItem]"}
```

This is a lesser known syntax but it works just the same. This `foreach` method was added in
PowerShell 4.0.

#### For loop

The `for` loop is used heavily in most other languages but you don't see it much in PowerShell. When
you do see it, it's often in the context of walking an array.

```powershell
for ( $index = 0; $index -lt $data.count; $index++)
{
    "Item: [{0}]" -f $data[$index]
}
```

The first thing we do is initialize an `$index` to `0`. Then we add the condition that `$index` must
be less than `$data.count`. Finally, we specify that every time we loop that we must increase the
index by `1`. In this case `$index++` is short for `$index = $index + 1`. The [format operator][03]
(`-f`) is used to insert the value of `$data[$index]` in the output string.

Whenever you're using a `for` loop, pay special attention to the condition. I used
`$index -lt $data.count` here. It's easy to get the condition slightly wrong to get an off-by-one
error in your logic. Using `$index -le $data.count` or `$index -lt ($data.count - 1)` are ever so
slightly wrong. That would cause your result to process too many or too few items. This is the
classic off-by-one error.

#### Switch loop

This is one that is easy to overlook. If you provide an array to a [switch statement][06], it checks
each item in the array.

```powershell
$data = 'Zero','One','Two','Three'
switch( $data )
{
    'One'
    {
        'Tock'
    }
    'Three'
    {
        'Tock'
    }
    Default
    {
        'Tick'
    }
}
```

```Output
Tick
Tock
Tick
Tock
```

There are a lot of cool things that we can do with the switch statement. I have another article
dedicated to this.

- [Everything you ever wanted to know about the switch statement][06]

#### Updating values

When your array is a collection of string or integers (value types), sometimes you may want to
update the values in the array as you loop over them. Most of the loops above use a variable in the
loop that holds a copy of the value. If you update that variable, the original value in the array is
not updated.

The exception to that statement is the `for` loop. If you want to walk an array and update values
inside it, then the `for` loop is what you're looking for.

```powershell
for ( $index = 0; $index -lt $data.count; $index++ )
{
    $data[$index] = "Item: [{0}]" -f $data[$index]
}
```

This example takes a value by index, makes a few changes, and then uses that same index to assign
it back.

## Arrays of Objects

So far, the only thing we've placed in an array is a value type, but arrays can also contain
objects.

```powershell
$data = @(
    [pscustomobject]@{FirstName='Kevin';LastName='Marquette'}
    [pscustomobject]@{FirstName='John'; LastName='Doe'}
)
```

Many cmdlets return collections of objects as arrays when you assign them to a variable.

```powershell
$processList = Get-Process
```

All of the basic features we already talked about still apply to arrays of objects with a few
details worth pointing out.

### Accessing properties

We can use an index to access an individual item in a collection just like with value types.

```powershell
PS> $data[0]

FirstName LastName
-----     ----
Kevin     Marquette
```

We can access and update properties directly.

```powershell
PS> $data[0].FirstName

Kevin

PS> $data[0].FirstName = 'Jay'
PS> $data[0]

FirstName LastName
-----     ----
Jay       Marquette
```

#### Array properties

Normally you would have to enumerate the whole list like this to access all the properties:

```powershell
PS> $data | ForEach-Object {$_.LastName}

Marquette
Doe
```

Or by using the `Select-Object -ExpandProperty` cmdlet.

```powershell
PS> $data | Select-Object -ExpandProperty LastName

Marquette
Doe
```

But PowerShell offers us the ability to request `LastName` directly. PowerShell enumerates them
all for us and returns a clean list.

```powershell
PS> $data.LastName

Marquette
Doe
```

The enumeration still happens but we don't see the complexity behind it.

### Where-Object filtering

This is where `Where-Object` comes in so we can filter and select what we want out of the array
based on the properties of the object.

```powershell
PS> $data | Where-Object {$_.FirstName -eq 'Kevin'}

FirstName LastName
-----     ----
Kevin     Marquette
```

We can write that same query to get the `FirstName` we are looking for.

```powershell
$data | Where FirstName -eq Kevin
```

#### Where()

Arrays have a `Where()` method on them that allows you to specify a `scriptblock` for the filter.

```powershell
$data.Where({$_.FirstName -eq 'Kevin'})
```

This feature was added in PowerShell 4.0.

### Updating objects in loops

With value types, the only way to update the array is to use a for loop because we need to know the
index to replace the value. We have more options with objects because they are reference types. Here
is a quick example:

```powershell
foreach($person in $data)
{
    $person.FirstName = 'Kevin'
}
```

This loop is walking every object in the `$data` array. Because objects are reference types, the
`$person` variable references the exact same object that is in the array. So updates to its
properties do update the original.

You still can't replace the whole object this way. If you try to assign a new object to the
`$person` variable, you're updating the variable reference to something else that no longer points
to the original object in the array. This doesn't work like you would expect:

```powershell
foreach($person in $data)
{
    $person = [pscustomobject]@{
        FirstName='Kevin'
        LastName='Marquette'
    }
}
```

## Operators

The operators in PowerShell also work on arrays. Some of them work slightly differently.

### -join

The `-join` operator is the most obvious one so let's look at it first. I like the `-join`
operator and use it often. It joins all elements in the array with the character or string that
you specify.

```powershell
PS> $data = @(1,2,3,4)
PS> $data -join '-'
1-2-3-4
PS> $data -join ','
1,2,3,4
```

One of the features that I like about the `-join` operator is that it handles single items.

```powershell
PS> 1 -join '-'
1
```

I use this inside logging and verbose messages.

```powershell
PS> $data = @(1,2,3,4)
PS> "Data is $($data -join ',')."
Data is 1,2,3,4.
```

#### -join $array

Here is a clever trick that Lee Dailey pointed out to me. If you ever want to join everything
without a delimiter, instead of doing this:

```powershell
PS> $data = @(1,2,3,4)
PS> $data -join $null
1234
```

You can use `-join` with the array as the parameter with no prefix. Take a look at this example to
see that I'm talking about.

```powershell
PS> $data = @(1,2,3,4)
PS> -join $data
1234
```

### -replace and -split

The other operators like `-replace` and `-split` execute on each item in the array. I can't say
that I have ever used them this way but here is an example.

```powershell
PS> $data = @('ATX-SQL-01','ATX-SQL-02','ATX-SQL-03')
PS> $data -replace 'ATX','LAX'
LAX-SQL-01
LAX-SQL-02
LAX-SQL-03
```

### -contains

The `-contains` operator allows you to check an array of values to see if it contains a specified
value.

```powershell
PS> $data = @('red','green','blue')
PS> $data -contains 'green'
True
```

### -in

When you have a single value that you would like to verify matches one of several values, you can
use the `-in` operator. The value would be on the left and the array on the right-hand side of the
operator.

```powershell
PS> $data = @('red','green','blue')
PS> 'green' -in $data
True
```

This can get expensive if the list is large. I often use a regex pattern if I'm checking more than
a few values.

```powershell
PS> $data = @('red','green','blue')
PS> $pattern = "^({0})$" -f ($data -join '|')
PS> $pattern
^(red|green|blue)$

PS> 'green' -match $pattern
True
```

### -eq and -ne

Equality and arrays can get complicated. When the array is on the left side, every item gets
compared. Instead of returning `True`, it returns the object that matches.

```powershell
PS> $data = @('red','green','blue')
PS> $data -eq 'green'
green
```

When you use the `-ne` operator, we get all the values that are not equal to our value.

```powershell
PS> $data = @('red','green','blue')
PS> $data -ne 'green'
red
blue
```

When you use this in an `if()` statement, a value that is returned is a `True` value. If no value is
returned, then it's a `False` value. Both of these next statements evaluate to `True`.

```powershell
$data = @('red','green','blue')
if ( $data -eq 'green' )
{
    'Green was found'
}
if ( $data -ne 'green' )
{
    'And green was not found'
}
```

I'll revisit this in a moment when we talk about testing for `$null`.

### -match

The `-match` operator tries to match each item in the collection.

```powershell
PS> $servers = @(
    'LAX-SQL-01'
    'LAX-API-01'
    'ATX-SQL-01'
    'ATX-API-01'
)
PS> $servers -match 'SQL'
LAX-SQL-01
ATX-SQL-01
```

When you use `-match` with a single value, a special variable `$Matches` gets populated with match
info. This isn't the case when an array is processed this way.

We can take the same approach with `Select-String`.

```powershell
$servers | Select-String SQL
```

I take a closer look at `Select-String`,`-match` and the `$matches` variable in another post called
[The many ways to use regex][10].

### $null or empty

Testing for `$null` or empty arrays can be tricky. Here are the common traps with arrays.

At a glance, this statement looks like it should work.

```powershell
if ( $array -eq $null)
{
    'Array is $null'
}
```

But I just went over how `-eq` checks each item in the array. So we can have an array of several
items with a single $null value and it would evaluate to `$true`

```powershell
$array = @('one',$null,'three')
if ( $array -eq $null)
{
    'I think Array is $null, but I would be wrong'
}
```

This is why it's a best practice to place the `$null` on the left side of the operator. This makes
this scenario a non-issue.

```powershell
if ( $null -eq $array )
{
    'Array actually is $null'
}
```

A `$null` array isn't the same thing as an empty array. If you know you have an array, check the
count of objects in it. If the array is `$null`, the count is `0`.

```powershell
if ( $array.count -gt 0 )
{
    "Array isn't empty"
}
```

There is one more trap to watch out for here. You can use the `count` even if you have a single
object, unless that object is a `PSCustomObject`. This is a bug that is fixed in PowerShell 6.1.
That's good news, but a lot of people are still on 5.1 and need to watch out for it.

```powershell
PS> $object = [PSCustomObject]@{Name='TestObject'}
PS> $object.count
$null
```

If you're still on PowerShell 5.1, you can wrap the object in an array before checking the count to
get an accurate count.

```powershell
if ( @($array).count -gt 0 )
{
    "Array isn't empty"
}
```

To fully play it safe, check for `$null`, then check the count.

```powershell
if ( $null -ne $array -and @($array).count -gt 0 )
{
    "Array isn't empty"
}
```

### All -eq

I recently saw someone ask [how to verify that every value in an array matches a given value][14].
Reddit user **/u/bis** had this clever [solution][15] that checks for any incorrect values and then
flips the result.

```powershell
$results = Test-Something
if ( -not ( $results -ne 'Passed') )
{
    'All results a Passed'
}
```

## Adding to arrays

At this point, you're starting to wonder how to add items to an array. The quick answer is that you
can't. An array is a fixed size in memory. If you need to grow it or add a single item to it, then
you need to create a new array and copy all the values over from the old array. This sounds like a
lot of work, however, PowerShell hides the complexity of creating the new array. PowerShell
implements the addition operator (`+`) for arrays.

> [!NOTE]
> PowerShell does not implement a subtraction operation. If you want a flexible alternative to an
> array, you need to use a [generic `List`][04] object.

### Array addition

We can use the addition operator with arrays to create a new array. So given these two arrays:

```powershell
$first = @(
    'Zero'
    'One'
)
$second = @(
    'Two'
    'Three'
)
```

We can add them together to get a new array.

```powershell
PS> $first + $second

Zero
One
Two
Three
```

### Plus equals +=

We can create a new array in place and add an item to it like this:

```powershell
$data = @(
    'Zero'
    'One'
    'Two'
    'Three'
)
$data += 'four'
```

Just remember that every time you use `+=` that you're duplicating and creating a new array. This
is a not an issue for small datasets but it scales extremely poorly.

### Pipeline assignment

You can assign the results of any pipeline into a variable. It's an array if it contains multiple
items.

```powershell
$array = 1..5 | ForEach-Object {
    "ATX-SQL-$PSItem"
}
```

Normally when we think of using the pipeline, we think of the typical PowerShell one-liners. We can
leverage the pipeline with `foreach()` statements and other loops. So instead of adding items to an
array in a loop, we can drop items onto the pipeline.

```powershell
$array = foreach ( $node in (1..5))
{
    "ATX-SQL-$node"
}
```

## Array Types

By default, an array in PowerShell is created as a `[PSObject[]]` type. This allows it to contain
any type of object or value. This works because everything is inherited from the `PSObject` type.

### Strongly typed arrays

You can create an array of any type using a similar syntax. When you create a strongly typed array,
it can only contain values or objects the specified type.

```powershell
PS> [int[]] $numbers = 1,2,3
PS> [int[]] $numbers2 = 'one','two','three'
ERROR: Cannot convert value "one" to type "System.Int32". Input string was not in a correct format."

PS> [string[]] $strings = 'one','two','three'
```

### ArrayList

Adding items to an array is one of its biggest limitations, but there are a few other collections
that we can turn to that solve this problem.

The `ArrayList` is commonly one of the first things that we think of when we need an array that is
faster to work with. It acts like an object array every place that we need it, but it handles adding
items quickly.

Here is how we create an `ArrayList` and add items to it.

```powershell
$myarray = [System.Collections.ArrayList]::new()
[void]$myArray.Add('Value')
```

We are calling into .NET to get this type. In this case, we are using the default constructor to
create it. Then we call the `Add` method to add an item to it.

The reason I'm using `[void]` at the beginning of the line is to suppress the return code. Some .NET
calls do this and can create unexpected output.

If the only data that you have in your array is strings, then also take a look at using
[StringBuilder][11]. It's almost the same thing but has some methods that are just for dealing with
strings. The `StringBuilder` is specially designed for performance.

It's common to see people move to `ArrayList` from arrays. But it comes from a time where C# didn't
have generic support. The `ArrayList` is deprecated in support for the generic `List[]`

### Generic List

A generic type is a special type in C# that defines a generalized class and the user specifies the
data types it uses when created. So if you want a list of numbers or strings, you would define that
you want list of `int` or `string` types.

Here is how you create a List for strings.

```powershell
$mylist = [System.Collections.Generic.List[string]]::new()
```

Or a list for numbers.

```powershell
$mylist = [System.Collections.Generic.List[int]]::new()
```

We can cast an existing array to a list like this without creating the object first:

```powershell
$mylist = [System.Collections.Generic.List[int]]@(1,2,3)
```

We can shorten the syntax with the `using namespace` statement in PowerShell 5 and newer. The
`using` statement needs to be the first line of your script. By declaring a namespace, PowerShell
lets you leave it off of the data types when you reference them.

```powershell
using namespace System.Collections.Generic
$myList = [List[int]]@(1,2,3)
```

This makes the `List` much more usable.

You have a similar `Add` method available to you. Unlike the ArrayList, there is no return value on
the `Add` method so we don't have to `void` it.

```powershell
$myList.Add(10)
```

And we can still access the elements like other arrays.

```powershell
PS> $myList[-1]
10
```

#### List[PSObject]

You can have a list of any type, but when you don't know the type of objects, you can use
`[List[PSObject]]` to contain them.

```powershell
$list = [List[PSObject]]::new()
```

#### Remove()

The `ArrayList` and the generic `List[]` both support removing items from the collection.

```powershell
using namespace System.Collections.Generic
$myList = [List[string]]@('Zero','One','Two','Three')
[void]$myList.Remove("Two")
Zero
One
Three
```

When working with value types, it removes the first one from the list. You can call it over and over
again to keep removing that value. If you have reference types, you have to provide the object that
you want removed.

```powershell
[list[System.Management.Automation.PSDriveInfo]]$drives = Get-PSDrive
$drives.remove($drives[2])
```

```powershell
$delete = $drives[2]
$drives.remove($delete)
```

The remove method returns `true` if it was able to find and remove the item from the collection.

### More collections

There are many other collections that can be used but these are the good generic array replacements.
If you're interested in learning about more of these options, take a look at this [Gist][08] that
[Mark Kraus][07] put together.

## Other nuances

Now that I have covered all the major functionality, here are a few more things that I wanted to
mention before I wrap this up.

### Pre-sized arrays

I mentioned that you can't change the size of an array once it's created. We can create an array of
a pre-determined size by calling it with the `new($size)` constructor.

```powershell
$data = [Object[]]::new(4)
$data.count
4
```

### Multiplying arrays

An interesting little trick is that you can multiply an array by an integer.

```powershell
PS> $data = @('red','green','blue')
PS> $data * 3
red
green
blue
red
green
blue
red
green
blue
```

### Initialize with 0

A common scenario is that you want to create an array with all zeros. If you're only going to have
integers, a strongly typed array of integers defaults to all zeros.

```powershell
PS> [int[]]::new(4)
0
0
0
0
```

We can use the multiplying trick to do this too.

```powershell
PS> $data = @(0) * 4
PS> $data
0
0
0
0
```

The nice thing about the multiplying trick is that you can use any value. So if you would rather
have `255` as your default value, this would be a good way to do it.

```powershell
PS> $data = @(255) * 4
PS> $data
255
255
255
255
```

### Nested arrays

An array inside an array is called a nested array. I don't use these much in PowerShell but I have
used them more in other languages. Consider using an array of arrays when your data fits in a grid
like pattern.

Here are two ways we can create a two-dimensional array.

```powershell
$data = @(@(1,2,3),@(4,5,6),@(7,8,9))

$data2 = @(
    @(1,2,3),
    @(4,5,6),
    @(7,8,9)
)
```

The comma is very important in those examples. I gave an earlier example of a normal array on
multiple lines where the comma was optional. That isn't the case with a multi-dimensional array.

The way we use the index notation changes slightly now that we've a nested array. Using the
`$data` above, this is how we would access the value 3.

```powershell
PS> $outside = 0
PS> $inside = 2
PS> $data[$outside][$inside]
3
```

Add a set of bracket for each level of array nesting. The first set of brackets is for the outer
most array and then you work your way in from there.

### Write-Output -NoEnumerate

PowerShell likes to unwrap or enumerate arrays. This is a core aspect of the way PowerShell uses the
pipeline but there are times that you don't want that to happen.

I commonly pipe objects to `Get-Member` to learn more about them. When I pipe an array to it, it
gets unwrapped and Get-Member sees the members of the array and not the actual array.

```powershell
PS> $data = @('red','green','blue')
PS> $data | Get-Member
TypeName: System.String
...
```

To prevent that unwrap of the array, you can use `Write-Output -NoEnumerate`.

```powershell
PS> Write-Output -NoEnumerate $data | Get-Member
TypeName: System.Object[]
...
```

I have a second way that's more of a hack (and I try to avoid hacks like this). You can place a
comma in front of the array before you pipe it. This wraps `$data` into another array where it is
the only element, so after the unwrapping the outer array we get back `$data` unwrapped.

```powershell
PS> ,$data | Get-Member
TypeName: System.Object[]
...
```

### Return an array

This unwrapping of arrays also happens when you output or return values from a function. You can
still get an array if you assign the output to a variable so this isn't commonly an issue.

The catch is that you have a new array. If that is ever a problem, you can use
`Write-Output -NoEnumerate $array` or `return ,$array` to work around it.

## Anything else?

I know this is all a lot to take in. My hope is that you learn something from this article every
time you read it and that it turns out to be a good reference for you for a long time to come. If
you found this to be helpful, please share it with others you think may get value out of it.

From here, I would recommend you check out a similar post that I wrote about [hashtables][05].

<!-- link references -->
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arrays
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_operators#format-operator--f
[04]: #generic-list
[05]: everything-about-hashtable.md
[06]: everything-about-switch.md
[07]: https://get-powershellblog.blogspot.com/2016/11/about-mark-kraus.html
[08]: https://gist.github.com/kevinblumenfeld/4a698dbc90272a336ed9367b11d91f1c
[09]: https://powershellexplained.com/
[10]: https://powershellexplained.com/2017-07-31-Powershell-regex-regular-expression/
[11]: https://powershellexplained.com/2017-11-20-Powershell-StringBuilder/
[12]: https://powershellexplained.com/2018-10-15-Powershell-arrays-Everything-you-wanted-to-know/
[13]: https://twitter.com/KevinMarquette
[14]: https://www.reddit.com/r/PowerShell/comments/9mzo09/if_statement_multiple_variables_but_1_condition
[15]: https://www.reddit.com/r/PowerShell/comments/9mzo09/if_statement_multiple_variables_but_1_condition/e7iizca

# /./reference/learn/deep-dives/everything-about-hashtable.md

    ---
    description: Hashtables are really important in PowerShell so it's good to have a solid understanding of them.
    ms.custom: contributor-KevinMarquette
    ms.date: 06/25/2023
    title: Everything you wanted to know about hashtables
    ---
# Everything you wanted to know about hashtables

I want to take a step back and talk about [hashtables][hashtables]. I use them all the time now. I
was teaching someone about them after our user group meeting last night and I realized I had the
same confusion about them as he had. Hashtables are really important in PowerShell so it's good to
have a solid understanding of them.

> [!NOTE]
> The [original version][original version] of this article appeared on the blog written by
> [@KevinMarquette][@KevinMarquette]. The PowerShell team thanks Kevin for sharing this content with
> us. Please check out his blog at [PowerShellExplained.com][PowerShellExplained.com].

## Hashtable as a collection of things

I want you to first see a **Hashtable** as a collection in the traditional definition of a
hashtable. This definition gives you a fundamental understanding of how they work when they get used
for more advanced stuff later. Skipping this understanding is often a source of confusion.

## What is an array?

Before I jump into what a **Hashtable** is, I need to mention [arrays][arrays] first. For the
purpose of this discussion, an array is a list or collection of values or objects.

```powershell
$array = @(1,2,3,5,7,11)
```

Once you have your items into an array, you can either use `foreach` to iterate over the list or use
an index to access individual elements in the array.

```powershell
foreach($item in $array)
{
    Write-Output $item
}

Write-Output $array[3]
```

You can also update values using an index in the same way.

```powershell
$array[2] = 13
```

I just scratched the surface on arrays but that should put them into the right context as I move
onto hashtables.

## What is a hashtable?

I'm going to start with a basic technical description of what hashtables are, in the general sense,
before I shift into the other ways PowerShell uses them.

A hashtable is a data structure, much like an array, except you store each value (object) using a
key. It's a basic key/value store. First, we create an empty hashtable.

```powershell
$ageList = @{}
```

Notice that braces, instead of parentheses, are used to define a hashtable. Then we add an item
using a key like this:

```powershell
$key = 'Kevin'
$value = 36
$ageList.add( $key, $value )

$ageList.add( 'Alex', 9 )
```

The person's name is the key and their age is the value that I want to save.

## Using the brackets for access

Once you add your values to the hashtable, you can pull them back out using that same key (instead
of using a numeric index like you would have for an array).

```powershell
$ageList['Kevin']
$ageList['Alex']
```

When I want Kevin's age, I use his name to access it. We can use this approach to add or update
values into the hashtable too. This is just like using the `add()` function above.

```powershell
$ageList = @{}

$key = 'Kevin'
$value = 36
$ageList[$key] = $value

$ageList['Alex'] = 9
```

There's another syntax you can use for accessing and updating values that I'll cover in a later
section. If you're coming to PowerShell from another language, these examples should fit in with
how you may have used hashtables before.

### Creating hashtables with values

So far I've created an empty hashtable for these examples. You can pre-populate the keys and
values when you create them.

```powershell
$ageList = @{
    Kevin = 36
    Alex  = 9
}
```

### As a lookup table

The real value of this type of a hashtable is that you can use them as a lookup table. Here is a
simple example.

```powershell
$environments = @{
    Prod = 'SrvProd05'
    QA   = 'SrvQA02'
    Dev  = 'SrvDev12'
}

$server = $environments[$env]
```

In this example, you specify an environment for the `$env` variable and it will pick the correct
server. You could use a `switch($env){...}` for a selection like this but a hashtable is a nice
option.

This gets even better when you dynamically build the lookup table to use it later. So think about
using this approach when you need to cross reference something. I think we would see this even more
if PowerShell wasn't so good at filtering on the pipe with `Where-Object`. If you're ever in a
situation where performance matters, this approach needs to be considered.

I won't say that it's faster, but it does fit into the rule of [If performance matters, test it][If performance matters, test it].

#### Multiselection

Generally, you think of a hashtable as a key/value pair, where you provide one key and get one
value. PowerShell allows you to provide an array of keys to get multiple values.

```powershell
$environments[@('QA','DEV')]
$environments[('QA','DEV')]
$environments['QA','DEV']
```

In this example, I use the same lookup hashtable from above and provide three different array styles
to get the matches. This is a hidden gem in PowerShell that most people aren't aware of.

## Iterating hashtables

Because a hashtable is a collection of key/value pairs, you iterate over it differently than you do
for an array or a normal list of items.

The first thing to notice is that if you pipe your hashtable, the pipe treats it like one object.

```powershell
PS> $ageList | Measure-Object
count : 1
```

Even though the `.count` property tells you how many values it contains.

```powershell
PS> $ageList.count
2
```

You get around this issue by using the `.values` property if all you need is just the values.

```powershell
PS> $ageList.values | Measure-Object -Average
Count   : 2
Average : 22.5
```

It's often more useful to enumerate the keys and use them to access the values.

```powershell
PS> $ageList.keys | ForEach-Object{
    $message = '{0} is {1} years old!' -f $_, $ageList[$_]
    Write-Output $message
}
Kevin is 36 years old
Alex is 9 years old
```

Here is the same example with a `foreach(){...}` loop.

```powershell
foreach($key in $ageList.keys)
{
    $message = '{0} is {1} years old' -f $key, $ageList[$key]
    Write-Output $message
}
```

We are walking each key in the hashtable and then using it to access the value. This is a common
pattern when working with hashtables as a collection.

### GetEnumerator()

That brings us to `GetEnumerator()` for iterating over our hashtable.

```powershell
$ageList.GetEnumerator() | ForEach-Object{
    $message = '{0} is {1} years old!' -f $_.key, $_.value
    Write-Output $message
}
```

The enumerator gives you each key/value pair one after another. It was designed specifically for
this use case. Thank you to [Mark Kraus](https://get-PowerShellblog.blogspot.com) for reminding me
of this one.

### BadEnumeration

One important detail is that you can't modify a hashtable while it's being enumerated. If we start
with our basic `$environments` example:

```powershell
$environments = @{
    Prod = 'SrvProd05'
    QA   = 'SrvQA02'
    Dev  = 'SrvDev12'
}
```

And trying to set every key to the same server value fails.

```powershell
$environments.Keys | ForEach-Object {
    $environments[$_] = 'SrvDev03'
}

An error occurred while enumerating through a collection: Collection was modified;
enumeration operation may not execute.
+ CategoryInfo          : InvalidOperation: tableEnumerator:HashtableEnumerator) [],
 RuntimeException
+ FullyQualifiedErrorId : BadEnumeration
```

This will also fail even though it looks like it should also be fine:

```powershell
foreach($key in $environments.keys) {
    $environments[$key] = 'SrvDev03'
}

Collection was modified; enumeration operation may not execute.
    + CategoryInfo          : OperationStopped: (:) [], InvalidOperationException
    + FullyQualifiedErrorId : System.InvalidOperationException
```

The trick to this situation is to clone the keys before doing the enumeration.

```powershell
$environments.Keys.Clone() | ForEach-Object {
    $environments[$_] = 'SrvDev03'
}
```

## Hashtable as a collection of properties

So far the type of objects we placed in our hashtable were all the same type of object. I used ages
in all those examples and the key was the person's name. This is a great way to look at it when your
collection of objects each have a name. Another common way to use hashtables in PowerShell is to
hold a collection of properties where the key is the name of the property. I'll step into that idea
in this next example.

### Property-based access

The use of property-based access changes the dynamics of hashtables and how you can use them in
PowerShell. Here is our usual example from above treating the keys as properties.

```powershell
$ageList = @{}
$ageList.Kevin = 35
$ageList.Alex = 9
```

Just like the examples above, this example adds those keys if they don't exist in the hashtable
already. Depending on how you defined your keys and what your values are, this is either a
little strange or a perfect fit. The age list example has worked great up until this point. We need
a new example for this to feel right going forward.

```powershell
$person = @{
    name = 'Kevin'
    age  = 36
}
```

And we can add and access attributes on the `$person` like this.

```powershell
$person.city = 'Austin'
$person.state = 'TX'
```

All of a sudden this hashtable starts to feel and act like an object. It's still a collection of
things, so all the examples above still apply. We just approach it from a different point of view.

### Checking for keys and values

In most cases, you can just test for the value with something like this:

```powershell
if( $person.age ){...}
```

It's simple but has been the source of many bugs for me because I was overlooking one important
detail in my logic. I started to use it to test if a key was present. When the value was `$false` or
zero, that statement would return `$false` unexpectedly.

```powershell
if( $person.age -ne $null ){...}
```

This works around that issue for zero values but not $null vs non-existent keys. Most of the time
you don't need to make that distinction but there are functions for when you do.

```powershell
if( $person.ContainsKey('age') ){...}
```

We also have a `ContainsValue()` for the situation where you need to test for a value without
knowing the key or iterating the whole collection.

### Removing and clearing keys

You can remove keys with the `.Remove()` function.

```powershell
$person.remove('age')
```

Assigning them a `$null` value just leaves you with a key that has a `$null` value.

A common way to clear a hashtable is to just initialize it to an empty hashtable.

```powershell
$person = @{}
```

While that does work, try to use the `clear()` function instead.

```powershell
$person.clear()
```

This is one of those instances where using the function creates self-documenting code and it makes
the intentions of the code very clean.

## All the fun stuff

### Ordered hashtables

By default, hashtables aren't ordered (or sorted). In the traditional context, the order doesn't
matter when you always use a key to access values. You may find that you want the properties to stay
in the order that you define them. Thankfully, there's a way to do that with the `ordered` keyword.

```powershell
$person = [ordered]@{
    name = 'Kevin'
    age  = 36
}
```

Now when you enumerate the keys and values, they stay in that order.

### Inline hashtables

When you're defining a hashtable on one line, you can separate the key/value pairs with a
semicolon.

```powershell
$person = @{ name = 'kevin'; age = 36; }
```

This will come in handy if you're creating them on the pipe.

### Custom expressions in common pipeline commands

There are a few cmdlets that support the use of hashtables to create custom or calculated
properties. You commonly see this with `Select-Object` and `Format-Table`. The hashtables have a
special syntax that looks like this when fully expanded.

```powershell
$property = @{
    name = 'totalSpaceGB'
    expression = { ($_.used + $_.free) / 1GB }
}
```

The `name` is what the cmdlet would label that column. The `expression` is a script block that is
executed where `$_` is the value of the object on the pipe. Here is that script in action:

```powershell
$drives = Get-PSDrive | Where Used
$drives | Select-Object -Property name, $property

Name     totalSpaceGB
----     ------------
C    238.472652435303
```

I placed that in a variable but it could easily be defined inline and you can shorten `name` to `n`
and `expression` to `e` while you're at it.

```powershell
$drives | Select-Object -property name, @{n='totalSpaceGB';e={($_.used + $_.free) / 1GB}}
```

I personally don't like how long that makes commands and it often promotes some bad behaviors that I
won't get into. I'm more likely to create a new hashtable or `pscustomobject` with all the fields
and properties that I want instead of using this approach in scripts. But there's a lot of code out
there that does this so I wanted you to be aware of it. I talk about creating a `pscustomobject`
later on.

### Custom sort expression

It's easy to sort a collection if the objects have the data that you want to sort on. You can
either add the data to the object before you sort it or create a custom expression for
`Sort-Object`.

```powershell
Get-ADUser | Sort-Object -Property @{ e={ Get-TotalSales $_.Name } }
```

In this example I'm taking a list of users and using some custom cmdlet to get additional
information just for the sort.

#### Sort a list of Hashtables

If you have a list of hashtables that you want to sort, you'll find that the `Sort-Object` doesn't
treat your keys as properties. We can get a round that by using a custom sort expression.

```powershell
$data = @(
    @{name='a'}
    @{name='c'}
    @{name='e'}
    @{name='f'}
    @{name='d'}
    @{name='b'}
)

$data | Sort-Object -Property @{e={$_.name}}
```

## Splatting hashtables at cmdlets

This is one of my favorite things about hashtables that many people don't discover early on. The
idea is that instead of providing all the properties to a cmdlet on one line, you can instead pack
them into a hashtable first. Then you can give the hashtable to the function in a special way. Here
is an example of creating a DHCP scope the normal way.

```powershell
Add-DhcpServerV4Scope -Name 'TestNetwork' -StartRange '10.0.0.2' -EndRange '10.0.0.254' -SubnetMask '255.255.255.0' -Description 'Network for testlab A' -LeaseDuration (New-TimeSpan -Days 8) -Type "Both"
```

Without using [splatting][splatting], all those things need to be defined on a single line. It
either scrolls off the screen or will wrap where ever it feels like. Now compare that to a command
that uses splatting.

```powershell
$DHCPScope = @{
    Name          = 'TestNetwork'
    StartRange    = '10.0.0.2'
    EndRange      = '10.0.0.254'
    SubnetMask    = '255.255.255.0'
    Description   = 'Network for testlab A'
    LeaseDuration = (New-TimeSpan -Days 8)
    Type          = "Both"
}
Add-DhcpServerV4Scope @DHCPScope
```

The use of the `@` sign instead of the `$` is what invokes the splat operation.

Just take a moment to appreciate how easy that example is to read. They are the exact same command
with all the same values. The second one is easier to understand and maintain going forward.

I use splatting anytime the command gets too long. I define too long as causing my window to scroll
right. If I hit three properties for a function, odds are that I'll rewrite it using a splatted
hashtable.

### Splatting for optional parameters

One of the most common ways I use splatting is to deal with optional parameters that come from
some place else in my script. Let's say I have a function that wraps a `Get-CIMInstance` call that
has an optional `$Credential` argument.

```powershell
$CIMParams = @{
    ClassName = 'Win32_Bios'
    ComputerName = $ComputerName
}

if($Credential)
{
    $CIMParams.Credential = $Credential
}

Get-CIMInstance @CIMParams
```

I start by creating my hashtable with common parameters. Then I add the `$Credential` if it exists.
Because I'm using splatting here, I only need to have the call to `Get-CIMInstance` in my code
once. This design pattern is very clean and can handle lots of optional parameters easily.

To be fair, you could write your commands to allow `$null` values for parameters. You just don't
always have control over the other commands you're calling.

### Multiple splats

You can splat multiple hashtables to the same cmdlet. If we revisit our original splatting example:

```powershell
$Common = @{
    SubnetMask  = '255.255.255.0'
    LeaseDuration = (New-TimeSpan -Days 8)
    Type = "Both"
}

$DHCPScope = @{
    Name        = 'TestNetwork'
    StartRange  = '10.0.0.2'
    EndRange    = '10.0.0.254'
    Description = 'Network for testlab A'
}

Add-DhcpServerv4Scope @DHCPScope @Common
```

I'll use this method when I have a common set of parameters that I'm passing to lots of commands.

### Splatting for clean code

There's nothing wrong with splatting a single parameter if makes you code cleaner.

```powershell
$log = @{Path = '.\logfile.log'}
Add-Content "logging this command" @log
```

### Splatting executables

Splatting also works on some executables that use a `/param:value` syntax. `Robocopy.exe`, for
example, has some parameters like this.

```powershell
$robo = @{R=1;W=1;MT=8}
robocopy source destination @robo
```

I don't know that this is all that useful, but I found it interesting.

## Adding hashtables

Hashtables support the addition operator to combine two hashtables.

```powershell
$person += @{Zip = '78701'}
```

This only works if the two hashtables don't share a key.

## Nested hashtables

We can use hashtables as values inside a hashtable.

```powershell
$person = @{
    name = 'Kevin'
    age  = 36
}
$person.location = @{}
$person.location.city = 'Austin'
$person.location.state = 'TX'
```

I started with a basic hashtable containing two keys. I added a key called `location` with an empty
hashtable. Then I added the last two items to that `location` hashtable. We can do this all inline
too.

```powershell
$person = @{
    name = 'Kevin'
    age  = 36
    location = @{
        city  = 'Austin'
        state = 'TX'
    }
}
```

This creates the same hashtable that we saw above and can access the properties the same way.

```powershell
$person.location.city
Austin
```

There are many ways to approach the structure of your objects. Here is a second way to look at a
nested hashtable.

```powershell
$people = @{
    Kevin = @{
        age  = 36
        city = 'Austin'
    }
    Alex = @{
        age  = 9
        city = 'Austin'
    }
}
```

This mixes the concept of using hashtables as a collection of objects and a collection of
properties. The values are still easy to access even when they're nested using whatever approach
you prefer.

```powershell
PS> $people.kevin.age
36
PS> $people.kevin['city']
Austin
PS> $people['Alex'].age
9
PS> $people['Alex']['City']
Austin
```

I tend to use the dot property when I'm treating it like a property. Those are generally things I've
defined statically in my code and I know them off the top of my head. If I need to walk the list or
programmatically access the keys, I use the brackets to provide the key name.

```powershell
foreach($name in $people.keys)
{
    $person = $people[$name]
    '{0}, age {1}, is in {2}' -f $name, $person.age, $person.city
}
```

Having the ability to nest hashtables gives you a lot of flexibility and options.

### Looking at nested hashtables

As soon as you start nesting hashtables, you're going to need an easy way to look at them from the
console. If I take that last hashtable, I get an output that looks like this and it only goes so
deep:

```powershell
PS> $people
Name                           Value
----                           -----
Kevin                          {age, city}
Alex                           {age, city}
```

My go to command for looking at these things is `ConvertTo-JSON` because it's very clean and I
frequently use JSON on other things.

```powershell
PS> $people | ConvertTo-Json
{
    "Kevin":  {
                "age":  36,
                "city":  "Austin"
            },
    "Alex":  {
                "age":  9,
                "city":  "Austin"
            }
}
```

Even if you don't know JSON, you should be able to see what you're looking for. There's a
`Format-Custom` command for structured data like this but I still like the JSON view better.

## Creating objects

Sometimes you just need to have an object and using a hashtable to hold properties just isn't
getting the job done. Most commonly you want to see the keys as column names. A `pscustomobject`
makes that easy.

```powershell
$person = [pscustomobject]@{
    name = 'Kevin'
    age  = 36
}

$person

name  age
----  ---
Kevin  36
```

Even if you don't create it as a `pscustomobject` initially, you can always cast it later when
needed.

```powershell
$person = @{
    name = 'Kevin'
    age  = 36
}

[pscustomobject]$person

name  age
----  ---
Kevin  36
```

I already have detailed write-up for [pscustomobject][pscustomobject] that you should go read after this one. It
builds on a lot of the things learned here.

## Reading and writing hashtables to file

### Saving to CSV

Struggling with getting a hashtable to save to a CSV is one of the difficulties that I was referring
to above. Convert your hashtable to a `pscustomobject` and it will save correctly to CSV. It helps
if you start with a `pscustomobject` so the column order is preserved. But you can cast it to a
`pscustomobject` inline if needed.

```powershell
$person | ForEach-Object{ [pscustomobject]$_ } | Export-CSV -Path $path
```

Again, check out my write-up on using a [pscustomobject][pscustomobject].

### Saving a nested hashtable to file

If I need to save a nested hashtable to a file and then read it back in again, I use the JSON
cmdlets to do it.

```powershell
$people | ConvertTo-JSON | Set-Content -Path $path
$people = Get-Content -Path $path -Raw | ConvertFrom-JSON
```

There are two important points about this method. First is that the JSON is written out multiline so
I need to use the `-Raw` option to read it back into a single string. The Second is that the
imported object is no longer a `[hashtable]`. It's now a `[pscustomobject]` and that can cause
issues if you don't expect it.

Watch for deeply-nested hashtables. When you convert it to JSON you might not get the results you
expect.

```powershell
@{ a = @{ b = @{ c = @{ d = "e" }}}} | ConvertTo-Json

{
  "a": {
    "b": {
      "c": "System.Collections.Hashtable"
    }
  }
}
```

Use **Depth** parameter to ensure that you have expanded all the nested hashtables.

```powershell
@{ a = @{ b = @{ c = @{ d = "e" }}}} | ConvertTo-Json -Depth 3

{
  "a": {
    "b": {
      "c": {
        "d": "e"
      }
    }
  }
}
```

If you need it to be a `[hashtable]` on import, then you need to use the `Export-CliXml` and
`Import-CliXml` commands.

### Converting JSON to Hashtable

If you need to convert JSON to a `[hashtable]`, there's one way that I know of to do it with the
[JavaScriptSerializer][JavaScriptSerializer] in .NET.

```powershell
[Reflection.Assembly]::LoadWithPartialName("System.Web.Script.Serialization")
$JSSerializer = [System.Web.Script.Serialization.JavaScriptSerializer]::new()
$JSSerializer.Deserialize($json,'Hashtable')
```

Beginning in PowerShell v6, JSON support uses the NewtonSoft JSON.NET and adds hashtable support.

```powershell
'{ "a": "b" }' | ConvertFrom-Json -AsHashtable

Name      Value
----      -----
a         b
```

PowerShell 6.2 added the **Depth** parameter to `ConvertFrom-Json`. The default **Depth** is 1024.

### Reading directly from a file

If you have a file that contains a hashtable using PowerShell syntax, there's a way to import it
directly.

```powershell
$content = Get-Content -Path $Path -Raw -ErrorAction Stop
$scriptBlock = [scriptblock]::Create( $content )
$scriptBlock.CheckRestrictedLanguage( $allowedCommands, $allowedVariables, $true )
$hashtable = ( & $scriptBlock )
```

It imports the contents of the file into a `scriptblock`, then checks to make sure it doesn't have
any other PowerShell commands in it before it executes it.

On that note, did you know that a module manifest (the psd1 file) is just a hashtable?

## Keys can be any object

Most of the time, the keys are just strings. So we can put quotes around anything and make it a key.

```powershell
$person = @{
    'full name' = 'Kevin Marquette'
    '#' = 3978
}
$person['full name']
```

You can do some odd things that you may not have realized you could do.

```powershell
$person.'full name'

$key = 'full name'
$person.$key
```

Just because you can do something, it doesn't mean that you should. That last one just looks like a
bug waiting to happen and would be easily misunderstood by anyone reading your code.

Technically your key doesn't have to be a string but they're easier to think about if you only use
strings. However, indexing doesn't work well with the complex keys.

```powershell
$ht = @{ @(1,2,3) = "a" }
$ht

Name                           Value
----                           -----
{1, 2, 3}                      a
```

Accessing a value in the hashtable by its key doesn't always work. For example:

```powershell
$key = $ht.keys[0]
$ht.$($key)
a
$ht[$key]
a
```

When the key is an array, you must wrap the `$key` variable in a subexpression so that it can be
used with member access (`.`) notation. Or, you can use array index (`[]`) notation.

## Use in automatic variables

### $PSBoundParameters

[$PSBoundParameters][PSBoundParameters] is an automatic variable that only exists inside the context of a function.
It contains all the parameters that the function was called with. This isn't exactly a hashtable but
close enough that you can treat it like one.

That includes removing keys and splatting it to other functions. If you find yourself writing proxy
functions, take a closer look at this one.

See [about_Automatic_Variables][about_Automatic_Variables] for more details.

### PSBoundParameters gotcha

One important thing to remember is that this only includes the values that are passed in as
parameters. If you also have parameters with default values but aren't passed in by the caller,
`$PSBoundParameters` doesn't contain those values. This is commonly overlooked.

### $PSDefaultParameterValues

This automatic variable lets you assign default values to any cmdlet without changing the cmdlet.
Take a look at this example.

```powershell
$PSDefaultParameterValues["Out-File:Encoding"] = "UTF8"
```

This adds an entry to the `$PSDefaultParameterValues` hashtable that sets `UTF8` as the default
value for the `Out-File -Encoding` parameter. This is session-specific so you should place it in
your `$profile`.

I use this often to pre-assign values that I type quite often.

```powershell
$PSDefaultParameterValues[ "Connect-VIServer:Server" ] = 'VCENTER01.contoso.local'
```

This also accepts wildcards so you can set values in bulk. Here are some ways you can use that:

```powershell
$PSDefaultParameterValues[ "Get-*:Verbose" ] = $true
$PSDefaultParameterValues[ "*:Credential" ] = Get-Credential
```

For a more in-depth breakdown, see this great article on [Automatic Defaults][Automatic Defaults] by
[Michael Sorens][Michael Sorens].

## Regex $Matches

When you use the `-match` operator, an automatic variable called `$matches` is created with the
results of the match. If you have any sub expressions in your regex, those sub matches are also
listed.

```powershell
$message = 'My SSN is 123-45-6789.'

$message -match 'My SSN is (.+)\.'
$Matches[0]
$Matches[1]
```

### Named matches

This is one of my favorite features that most people don't know about. If you use a named regex
match, then you can access that match by name on the matches.

```powershell
$message = 'My Name is Kevin and my SSN is 123-45-6789.'

if($message -match 'My Name is (?<Name>.+) and my SSN is (?<SSN>.+)\.')
{
    $Matches.Name
    $Matches.SSN
}
```

In the example above, the `(?<Name>.*)` is a named sub expression. This value is then placed in the
`$Matches.Name` property.

## Group-Object -AsHashtable

One little known feature of `Group-Object` is that it can turn some datasets into a hashtable for
you.

```powershell
Import-CSV $Path | Group-Object -AsHashtable -Property email
```

This will add each row into a hashtable and use the specified property as the key to access it.

## Copying Hashtables

One important thing to know is that hashtables are objects. And each variable is just a reference to
an object. This means that it takes more work to make a valid copy of a hashtable.

### Assigning reference types

When you have one hashtable and assign it to a second variable, both variables point to the same
hashtable.

```powershell
PS> $orig = @{name='orig'}
PS> $copy = $orig
PS> $copy.name = 'copy'
PS> 'Copy: [{0}]' -f $copy.name
PS> 'Orig: [{0}]' -f $orig.name

Copy: [copy]
Orig: [copy]
```

This highlights that they're the same because altering the values in one will also alter the values
in the other. This also applies when passing hashtables into other functions. If those functions
make changes to that hashtable, your original is also altered.

### Shallow copies, single level

If we have a simple hashtable like our example above, we can use `.Clone()` to make a shallow copy.

```powershell
PS> $orig = @{name='orig'}
PS> $copy = $orig.Clone()
PS> $copy.name = 'copy'
PS> 'Copy: [{0}]' -f $copy.name
PS> 'Orig: [{0}]' -f $orig.name

Copy: [copy]
Orig: [orig]
```

This will allow us to make some basic changes to one that don't impact the other.

### Shallow copies, nested

The reason why it's called a shallow copy is because it only copies the base level properties. If
one of those properties is a reference type (like another hashtable), then those nested objects will
still point to each other.

```powershell
PS> $orig = @{
        person=@{
            name='orig'
        }
    }
PS> $copy = $orig.Clone()
PS> $copy.person.name = 'copy'
PS> 'Copy: [{0}]' -f $copy.person.name
PS> 'Orig: [{0}]' -f $orig.person.name

Copy: [copy]
Orig: [copy]
```

So you can see that even though I cloned the hashtable, the reference to `person` wasn't cloned. We
need to make a deep copy to truly have a second hashtable that isn't linked to the first.

### Deep copies

There are a couple of ways to make a deep copy of a hashtable (and keep it as a hashtable). Here's a
function using PowerShell to recursively create a deep copy:

```powershell
function Get-DeepClone
{
    [CmdletBinding()]
    param(
        $InputObject
    )
    process
    {
        if($InputObject -is [hashtable]) {
            $clone = @{}
            foreach($key in $InputObject.keys)
            {
                $clone[$key] = Get-DeepClone $InputObject[$key]
            }
            return $clone
        } else {
            return $InputObject
        }
    }
}
```

It doesn't handle any other reference types or arrays, but it's a good starting point.

Another way is to use .Net to deserialize it using **CliXml** like in this function:

```powershell
function Get-DeepClone
{
    param(
        $InputObject
    )
    $TempCliXmlString = [System.Management.Automation.PSSerializer]::Serialize($obj, [int32]::MaxValue)
    return [System.Management.Automation.PSSerializer]::Deserialize($TempCliXmlString)
}
```

For extremely large hashtables, the deserializing function is faster as it scales out. However,
there are some things to consider when using this method. Since it uses **CliXml**, it's memory
intensive and if you are cloning huge hashtables, that might be a problem. Another limitation of the
**CliXml** is there is a depth limitation of 48. Meaning, if you have a hashtable with 48 layers of
nested hashtables, the cloning will fail and no hashtable will be output at all.

## Anything else?

I covered a lot of ground quickly. My hope is that you walk away leaning something new or
understanding it better every time you read this. Because I covered the full spectrum of this
feature, there are aspects that just may not apply to you right now. That is perfectly OK and is
kind of expected depending on how much you work with PowerShell.

<!-- link references -->
[original version]: https://powershellexplained.com/2016-11-06-powershell-hashtable-everything-you-wanted-to-know-about/
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[hashtables]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_hash_tables
[arrays]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arrays
[If performance matters, test it]: https://github.com/PoshCode/PowerShellPracticeAndStyle/blob/master/Best-Practices/Performance.md
[splatting]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_splatting
[pscustomobject]: everything-about-pscustomobject.md
[JavaScriptSerializer]: https://learn.microsoft.com/dotnet/api/system.web.script.serialization.javascriptserializer?view=netframework-4.8&preserve-view=true
[PSBoundParameters]: https://tommymaynard.com/the-psboundparameters-automatic-variable-2016/
[about_Automatic_Variables]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_automatic_variables
[Automatic Defaults]: https://www.simple-talk.com/sysadmin/PowerShell/PowerShell-time-saver-automatic-defaults/
[Michael Sorens]: http://cleancode.sourceforge.net/wwwdoc/about.html

# /./reference/learn/deep-dives/everything-about-pscustomobject.md

    ---
    description: PSCustomObject is a simple way to create structured data.
    ms.custom: contributor-KevinMarquette
    ms.date: 10/11/2023
    title: Everything you wanted to know about PSCustomObject
    ---
# Everything you wanted to know about PSCustomObject

`PSCustomObject` is a great tool to add into your PowerShell tool belt. Let's start with the basics
and work our way into the more advanced features. The idea behind using a `PSCustomObject` is to
have a simple way to create structured data. Take a look at the first example and you'll have a
better idea of what that means.

> [!NOTE]
> The [original version][original version] of this article appeared on the blog written by
> [@KevinMarquette][@KevinMarquette]. The PowerShell team thanks Kevin for sharing this content with
> us. Please check out his blog at [PowerShellExplained.com][PowerShellExplained.com].

## Creating a PSCustomObject

I love using `[PSCustomObject]` in PowerShell. Creating a usable object has never been easier.
Because of that, I'm going to skip over all the other ways you can create an object but I need
to mention that most of these examples are PowerShell v3.0 and newer.

```powershell
$myObject = [PSCustomObject]@{
    Name     = 'Kevin'
    Language = 'PowerShell'
    State    = 'Texas'
}
```

This method works well for me because I use hashtables for just about everything. But there are
times when I would like PowerShell to treat hashtables more like an object. The first place you
notice the difference is when you want to use `Format-Table` or `Export-CSV` and you realize that a
hashtable is just a collection of key/value pairs.

You can then access and use the values like you would a normal object.

```powershell
$myObject.Name
```

### Converting a hashtable

While I am on the topic, did you know you could do this:

```powershell
$myHashtable = @{
    Name     = 'Kevin'
    Language = 'PowerShell'
    State    = 'Texas'
}
$myObject = [pscustomobject]$myHashtable
```

I do prefer to create the object from the start but there are times you have to work with a
hashtable first. This example works because the constructor takes a hashtable for the object
properties. One important note is that while this method works, it isn't an exact equivalent. The
biggest difference is that the order of the properties isn't preserved.

If you want to preserve the order, see
[Ordered hashtables](everything-about-hashtable.md#ordered-hashtables).

### Legacy approach

You may have seen people use `New-Object` to create custom objects.

```powershell
$myHashtable = @{
    Name     = 'Kevin'
    Language = 'PowerShell'
    State    = 'Texas'
}

$myObject = New-Object -TypeName PSObject -Property $myHashtable
```

This way is quite a bit slower but it may be your best option on early versions of PowerShell.

### Saving to a file

I find the best way to save a hashtable to a file is to save it as JSON. You can import it back into
a `[PSCustomObject]`

```powershell
$myObject | ConvertTo-Json -depth 1 | Set-Content -Path $Path
$myObject = Get-Content -Path $Path | ConvertFrom-Json
```

I cover more ways to save objects to a file in my article on
[The many ways to read and write to files][The many ways to read and write to files].

## Working with properties

### Adding properties

You can still add new properties to your `PSCustomObject` with `Add-Member`.

```powershell
$myObject | Add-Member -MemberType NoteProperty -Name 'ID' -Value 'KevinMarquette'

$myObject.ID
```

### Remove properties

You can also remove properties off of an object.

```powershell
$myObject.psobject.properties.remove('ID')
```

The `.psobject` is an intrinsic member that gives you access to base object metadata. For more
information about intrinsic members, see
[about_Intrinsic_Members](/powershell/module/microsoft.powershell.core/about/about_intrinsic_members).

### Enumerating property names

Sometimes you need a list of all the property names on an object.

```powershell
$myObject | Get-Member -MemberType NoteProperty | Select -ExpandProperty Name
```

We can get this same list off of the `psobject` property too.

```powershell
$myobject.psobject.properties.name
```

> [!NOTE]
> `Get-Member` returns the properties in alphabetical order. Using the member-access operator to
> enumerate the property names returns the properties in the order they were defined on the object.

### Dynamically accessing properties

I already mentioned that you can access property values directly.

```powershell
$myObject.Name
```

You can use a string for the property name and it will still work.

```powershell
$myObject.'Name'
```

We can take this one more step and use a variable for the property name.

```powershell
$property = 'Name'
$myObject.$property
```

I know that looks strange, but it works.

### Convert PSCustomObject into a hashtable

To continue on from the last section, you can dynamically walk the properties and create a hashtable
from them.

```powershell
$hashtable = @{}
foreach( $property in $myobject.psobject.properties.name )
{
    $hashtable[$property] = $myObject.$property
}
```

### Testing for properties

If you need to know if a property exists, you could just check for that property to have a value.

```powershell
if( $null -ne $myObject.ID )
```

But if the value could be `$null` you can check to see if it exists by checking the
`psobject.properties` for it.

```powershell
if( $myobject.psobject.properties.match('ID').Count )
```

## Adding object methods

If you need to add a script method to an object, you can do it with `Add-Member` and a
`ScriptBlock`. You have to use the `this` automatic variable reference the current object. Here is a
`scriptblock` to turn an object into a hashtable. (same code form the last example)

```powershell
$ScriptBlock = {
    $hashtable = @{}
    foreach( $property in $this.psobject.properties.name )
    {
        $hashtable[$property] = $this.$property
    }
    return $hashtable
}
```

Then we add it to our object as a script property.

```powershell
$memberParam = @{
    MemberType = "ScriptMethod"
    InputObject = $myobject
    Name = "ToHashtable"
    Value = $scriptBlock
}
Add-Member @memberParam
```

Then we can call our function like this:

```powershell
$myObject.ToHashtable()
```

### Objects vs Value types

Objects and value types don't handle variable assignments the same way. If you assign value types to
each other, only the value get copied to the new variable.

```powershell
$first = 1
$second = $first
$second = 2
```

In this case, `$first` is 1 and `$second` is 2.

Object variables hold a reference to the actual object. When you assign one object to a new
variable, they still reference the same object.

```powershell
$third = [PSCustomObject]@{Key=3}
$fourth = $third
$fourth.Key = 4
```

Because `$third` and `$fourth` reference the same instance of an object, both `$third.key` and
`$fourth.Key` are 4.

### psobject.copy()

If you need a true copy of an object, you can clone it.

```powershell
$third = [PSCustomObject]@{Key=3}
$fourth = $third.psobject.copy()
$fourth.Key = 4
```

Clone creates a shallow copy of the object. They have different instances now and `$third.key` is 3
and `$fourth.Key` is 4 in this example.

I call this a shallow copy because if you have nested objects (objects with properties contain other
objects), only the top-level values are copied. The child objects will reference each other.

### PSTypeName for custom object types

Now that we have an object, there are a few more things we can do with it that may not be nearly as
obvious. First thing we need to do is give it a `PSTypeName`. This is the most common way I see
people do it:

```powershell
$myObject.PSObject.TypeNames.Insert(0,"My.Object")
```

I recently discovered another way to do this from this
[post by /u/markekraus][post by /u/markekraus]. I did a little digging and more posts about the idea
from [Adam Bertram][Adam Bertram] and [Mike Shepard][Mike Shepard] where they talk about this
approach that allows you to define it inline.

```powershell
$myObject = [PSCustomObject]@{
    PSTypeName = 'My.Object'
    Name       = 'Kevin'
    Language   = 'PowerShell'
    State      = 'Texas'
}
```

I love how nicely this just fits into the language. Now that we have an object with a proper type
name, we can do some more things.

> [!NOTE]
> You can also create custom PowerShell types using PowerShell classes. For more information, see
> [PowerShell Class Overview](/powershell/module/Microsoft.PowerShell.Core/About/about_Classes).

## Using DefaultPropertySet (the long way)

PowerShell decides for us what properties to display by default. A lot of the native commands have a
`.ps1xml` [formatting file][formatting file] that does all the heavy lifting. From this
[post by Boe Prox][post by Boe Prox], there's another way for us to do this on our custom object
using just PowerShell. We can give it a `MemberSet` for it to use.

```powershell
$defaultDisplaySet = 'Name','Language'
$defaultDisplayPropertySet = New-Object System.Management.Automation.PSPropertySet('DefaultDisplayPropertySet',[string[]]$defaultDisplaySet)
$PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]@($defaultDisplayPropertySet)
$MyObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers
```

Now when my object just falls to the shell, it will only show those properties by default.

### Update-TypeData with DefaultPropertySet

This is nice but I recently saw a better way using [Update-TypeData][Update-TypeData] to specify
the default properties.

```powershell
$TypeData = @{
    TypeName = 'My.Object'
    DefaultDisplayPropertySet = 'Name','Language'
}
Update-TypeData @TypeData
```

That is simple enough that I could almost remember it if I didn't have this post as a quick
reference. Now I can easily create objects with lots of properties and still give it a nice clean
view when looking at it from the shell. If I need to access or see those other properties, they're
still there.

```powershell
$myObject | Format-List *
```

### Update-TypeData with ScriptProperty

Something else I got out of that video was creating script properties for your objects. This
would be a good time to point out that this works for existing objects too.

```powershell
$TypeData = @{
    TypeName = 'My.Object'
    MemberType = 'ScriptProperty'
    MemberName = 'UpperCaseName'
    Value = {$this.Name.toUpper()}
}
Update-TypeData @TypeData
```

You can do this before your object is created or after and it will still work. This is what makes
this different than using `Add-Member` with a script property. When you use `Add-Member` the way I
referenced earlier, it only exists on that specific instance of the object. This one applies to all
objects with this `TypeName`.

## Function parameters

You can now use these custom types for parameters in your functions and scripts. You can have one
function create these custom objects and then pass them into other functions.

```powershell
param( [PSTypeName('My.Object')]$Data )
```

PowerShell requires that the object is the type you specified. It throws a validation error if
the type doesn't match automatically to save you the step of testing for it in your code. A great
example of letting PowerShell do what it does best.

### Function OutputType

You can also define an `OutputType` for your advanced functions.

```powershell
function Get-MyObject
{
    [OutputType('My.Object')]
    [CmdletBinding()]
        param
        (
            ...
```

The **OutputType** attribute value is only a documentation note. It isn't derived from the function
code or compared to the actual function output.

The main reason you would use an output type is so that meta information about your function
reflects your intentions. Things like `Get-Command` and `Get-Help` that your development environment
can take advantage of. If you want more information, then take a look at the help for it:
[about_Functions_OutputTypeAttribute][about_Functions_OutputTypeAttribute].

With that said, if you're using Pester to unit test your functions then it would be a good idea
to validate the output objects match your **OutputType**. This could catch variables that just fall
to the pipe when they shouldn't.

## Closing thoughts

The context of this was all about `[PSCustomObject]`, but a lot of this information applies to
objects in general.

I have seen most of these features in passing before but never saw them presented as a collection of
information on `PSCustomObject`. Just this last week I stumbled upon another one and was surprised
that I had not seen it before. I wanted to pull all these ideas together so you can hopefully see
the bigger picture and be aware of them when you have an opportunity to use them. I hope you learned
something and can find a way to work this into your scripts.

<!-- link references -->
[original version]: https://powershellexplained.com/2016-10-28-powershell-everything-you-wanted-to-know-about-pscustomobject/
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[post by Boe Prox]: https://learn-PowerShell.net/2013/08/03/quick-hits-set-the-default-property-display-in-PowerShell-on-custom-objects/
[formatting file]: https://mcpmag.com/articles/2014/05/13/PowerShell-properties-part-3.aspx
[about_Functions_OutputTypeAttribute]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute
[The many ways to read and write to files]: https://powershellexplained.com/2017-03-18-Powershell-reading-and-saving-data-to-files
[post by /u/markekraus]: https://www.reddit.com/r/PowerShell/comments/590awc/is_it_possible_to_initialize_a_pscustoobject_with/
[Adam Bertram]: http://www.adamtheautomator.com/
[Mike Shepard]: https://powershellstation.com/2016/05/22/custom-objects-and-pstypename/
[Update-TypeData]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/update-typedata

# /./reference/learn/deep-dives/everything-about-string-substitutions.md

    ---
    description: There are many ways to use variables in strings to create formatted text.
    ms.custom: contributor-KevinMarquette
    ms.date: 11/16/2022
    title: Everything you wanted to know about variable substitution in strings
    ---
# Everything you wanted to know about variable substitution in strings

There are many ways to use variables in strings. I'm calling this variable substitution but I'm
referring to any time you want to format a string to include values from variables. This is
something that I often find myself explaining to new scripters.

> [!NOTE]
> The [original version][14] of this article appeared on the blog written by
> [@KevinMarquette][16]. The PowerShell team thanks Kevin for sharing this content with us. Please
> check out his blog at [PowerShellExplained.com][13].

## Concatenation

The first class of methods can be referred to as concatenation. It's basically taking several
strings and joining them together. There's a long history of using concatenation to build formatted
strings.

```powershell
$name = 'Kevin Marquette'
$message = 'Hello, ' + $name
```

Concatenation works out OK when there are only a few values to add. But this can get complicated
quickly.

```powershell
$first = 'Kevin'
$last = 'Marquette'
```

```powershell
$message = 'Hello, ' + $first + ' ' + $last + '.'
```

This simple example is already getting harder to read.

## Variable substitution

PowerShell has another option that is easier. You can specify your variables directly in the
strings.

```powershell
$message = "Hello, $first $last."
```

The type of quotes you use around the string makes a difference. A double quoted string allows the
substitution but a single quoted string doesn't. There are times you want one or the other so you
have an option.

## Command substitution

Things get a little tricky when you start trying to get the values of properties into a string. This
is where many new people get tripped up. First let me show you what they think should work (and at
face value almost looks like it should).

```powershell
$directory = Get-Item 'c:\windows'
$message = "Time: $directory.CreationTime"
```

You would be expecting to get the `CreationTime` off of the `$directory`, but instead you get this
`Time: c:\windows.CreationTime` as your value. The reason is that this type of substitution only
sees the base variable. It considers the period as part of the string so it stops resolving the
value any deeper.

It just so happens that this object gives a string as a default value when placed into a string.
Some objects give you the type name instead like `System.Collections.Hashtable`. Just something
to watch for.

PowerShell allows you to do command execution inside the string with a special syntax. This allows
us to get the properties of these objects and run any other command to get a value.

```powershell
$message = "Time: $($directory.CreationTime)"
```

This works great for some situations but it can get just as crazy as concatenation if you have just
a few variables.

### Command execution

You can run commands inside a string. Even though I have this option, I don't like it. It gets
cluttered quickly and hard to debug. I either run the command and save to a variable or use a format
string.

```powershell
$message = "Date: $(Get-Date)"
```

## Format string

.NET has a way to format strings that I find fairly easy to work with. First let me show you the
static method for it before I show you the PowerShell shortcut to do the same thing.

```powershell
# .NET string format string
[string]::Format('Hello, {0} {1}.',$first,$last)

# PowerShell format string
'Hello, {0} {1}.' -f $first, $last
```

What is happening here is that the string is parsed for the tokens `{0}` and `{1}`, then it uses
that number to pick from the values provided. If you want to repeat one value some place in the
string, you can reuse that values number.

The more complicated the string gets, the more value you get out of this approach.

### Format values as arrays

If your format line gets too long, you can place your values into an array first.

```powershell
$values = @(
    "Kevin"
    "Marquette"
)
'Hello, {0} {1}.' -f $values
```

This is not splatting because I'm passing the whole array in, but the idea is similar.

## Advanced formatting

I intentionally called these out as coming from .NET because there are lots of formatting options
already well [documented][01] on it. There are built-in ways to format various data types.

```powershell
"{0:yyyyMMdd}" -f (Get-Date)
"Population {0:N0}" -f  8175133
```

```Output
20211110
Population 8,175,133
```

I'm not going to go into them but I just wanted to let you know that this is a very powerful
formatting engine if you need it.

## Joining strings

Sometimes you actually do want to concatenate a list of values together. There's a `-join` operator
that can do that for you. It even lets you specify a character to join between the strings.

```powershell
$servers = @(
    'server1'
    'server2'
    'server3'
)

$servers  -join ','
```

If you want to `-join` some strings without a separator, you need to specify an empty string `''`.
But if that is all you need, there's a faster option.

```powershell
[string]::Concat('server1','server2','server3')
[string]::Concat($servers)
```

It's also worth pointing out that you can also `-split` strings too.

## Join-Path

This is often overlooked but a great cmdlet for building a file path.

```powershell
$folder = 'Temp'
Join-Path -Path 'c:\windows' -ChildPath $folder
```

The great thing about this is it works out the backslashes correctly when it puts the values
together. This is especially important if you are taking values from users or config files.

This also goes well with `Split-Path` and `Test-Path`. I also cover these in my post about
[reading and saving to files][15].

## Strings are arrays

I do need to mention adding strings here before I go on. Remember that a string is just an array of
characters. When you add multiple strings together, a new array is created each time.

Look at this example:

```powershell
$message = "Numbers: "
foreach($number in 1..10000)
{
    $message += " $number"
}
```

It looks very basic but what you don't see is that each time a string is added to `$message` that a
whole new string is created. Memory gets allocated, data gets copied and the old one is discarded.
Not a big deal when it's only done a few times, but a loop like this would really expose the issue.

### StringBuilder

StringBuilder is also very popular for building large strings from lots of smaller strings. The
reason why is because it just collects all the strings you add to it and only concatenates all of
them at the end when you retrieve the value.

```powershell
$stringBuilder = New-Object -TypeName "System.Text.StringBuilder"

[void]$stringBuilder.Append("Numbers: ")
foreach($number in 1..10000)
{
    [void]$stringBuilder.Append(" $number")
}
$message = $stringBuilder.ToString()
```

Again, this is something that I'm reaching out to .NET for. I don't use it often anymore but it's
good to know it's there.

## Delineation with braces

This is used for suffix concatenation within the string. Sometimes your variable doesn't have a
clean word boundary.

```powershell
$test = "Bet"
$tester = "Better"
Write-Host "$test $tester ${test}ter"
```

Thank you [/u/real_parbold][18] for that one.

Here is an alternate to this approach:

```powershell
Write-Host "$test $tester $($test)ter"
Write-Host "{0} {1} {0}ter" -f $test, $tester
```

I personally use format string for this, but this is good to know incase you see it in the wild.

## Find and replace tokens

While most of these features limit your need to roll your own solution, there are times where you
may have large template files where you want to replace strings inside.

Let us assume you pulled in a template from a file that has a lot of text.

```powershell
$letter = Get-Content -Path TemplateLetter.txt -RAW
$letter = $letter -replace '#FULL_NAME#', 'Kevin Marquette'
```

You may have lots of tokens to replace. The trick is to use a very distinct token that is easy to
find and replace. I tend to use a special character at both ends to help distinguish it.

I recently found a new way to approach this. I decided to leave this section in here because this is
a pattern that is commonly used.

### Replace multiple tokens

When I have a list of tokens that I need to replace, I take a more generic approach. I would place
them in a hashtable and iterate over them to do the replace.

```powershell
$tokenList = @{
    Full_Name = 'Kevin Marquette'
    Location = 'Orange County'
    State = 'CA'
}

$letter = Get-Content -Path TemplateLetter.txt -RAW
foreach( $token in $tokenList.GetEnumerator() )
{
    $pattern = '#{0}#' -f $token.key
    $letter = $letter -replace $pattern, $token.Value
}
```

Those tokens could be loaded from JSON or CSV if needed.

### ExecutionContext ExpandString

There's a clever way to define a substitution string with single quotes and expand the variables
later. Look at this example:

```powershell
$message = 'Hello, $Name!'
$name = 'Kevin Marquette'
$string = $ExecutionContext.InvokeCommand.ExpandString($message)
```

The call to `.InvokeCommand.ExpandString` on the current execution context uses the variables in
the current scope for substitution. The key thing here is that the `$message` can be defined very
early before the variables even exist.

If we expand on that just a little bit, we can perform this substitution over and over wih different
values.

```powershell
$message = 'Hello, $Name!'
$nameList = 'Mark Kraus','Kevin Marquette','Lee Dailey'
foreach($name in $nameList){
    $ExecutionContext.InvokeCommand.ExpandString($message)
}
```

To keep going on this idea; you could be importing a large email template from a text file to do
this. I have to thank [Mark Kraus][02] for this [suggestion][17].

## Whatever works the best for you

I'm a fan of the format string approach. I definitely do this with the more complicated strings or
if there are multiple variables. On anything that is very short, I may use any one of these.

## Anything else?

I covered a lot of ground on this one. My hope is that you walk away learning something new.

## Links

If you'd like to learn more about the methods and features that make string interpolation possible,
see the following list for the reference documentation.

- Concatenation uses the [addition operator][05]
- Variable and command substitution follow the [quoting rules][10]
- Formatting uses the [format operator][09]
- Joining strings uses the [join operator][08] and references [`Join-Path`][11], but you could also
  read about [`Join-String`][12]
- Arrays are documented in [About arrays][06]
- StringBuilder is a .NET class, with its [own documentation][04]
- Braces in strings is also covered in the [quoting rules][10]
- Token replacement uses the [replace operator][07]
- The `$ExecutionContext.InvokeCommand.ExpandString()` method has
  [.NET API reference documentation][03]

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.string.format#overloads
[02]: https://get-powershellblog.blogspot.com/
[03]: https://learn.microsoft.com/dotnet/api/system.management.automation.commandinvocationintrinsics.expandstring
[04]: https://learn.microsoft.com/dotnet/api/system.text.stringbuilder
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arithmetic_operators#adding-and-multiplying-non-numeric-types
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arrays
[07]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_comparison_operators#replacement-operator
[08]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_join
[09]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_operators#format-operator--f
[10]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_quoting_rules
[11]: https://learn.microsoft.com/powershell/module/microsoft.powershell.management/join-path
[12]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/join-string
[13]: https://powershellexplained.com/
[14]: https://powershellexplained.com/2017-01-13-powershell-variable-substitution-in-strings/
[15]: https://powershellexplained.com/2017-03-18-Powershell-reading-and-saving-data-to-files/
[16]: https://twitter.com/KevinMarquette
[17]: https://www.reddit.com/r/PowerShell/comments/5npf8h/kevmar_everything_you_wanted_to_know_about/dcdfia5/
[18]: https://www.reddit.com/r/PowerShell/comments/5npf8h/kevmar_everything_you_wanted_to_know_about/dcdfm6p/

# /./reference/learn/deep-dives/everything-about-if.md

    ---
    description: Like many other languages, PowerShell has statements for conditionally executing code in your scripts.
    ms.custom: contributor-KevinMarquette
    ms.date: 11/16/2022
    title: Everything you wanted to know about the if statement
    ---
# Everything you wanted to know about the `if` statement

Like many other languages, PowerShell has statements for conditionally executing code in your
scripts. One of those statements is the [If][If] statement. Today we will take a deep dive into one of
the most fundamental commands in PowerShell.

> [!NOTE]
> The [original version][original version] of this article appeared on the blog written by [@KevinMarquette][@KevinMarquette]. The
> PowerShell team thanks Kevin for sharing this content with us. Please check out his blog at
> [PowerShellExplained.com][PowerShellExplained.com].

## Conditional execution

Your scripts often need to make decisions and perform different logic based on those decisions.
This is what I mean by conditional execution. You have one statement or value to evaluate, then
execute a different section of code based on that evaluation. This is exactly what the `if`
statement does.

## The `if` statement

Here is a basic example of the `if` statement:

```powershell
$condition = $true
if ( $condition )
{
    Write-Output "The condition was true"
}
```

The first thing the `if` statement does is evaluate the expression in parentheses. If it evaluates
to `$true`, then it executes the `scriptblock` in the braces. If the value was `$false`, then it
would skip over that scriptblock.

In the previous example, the `if` statement was just evaluating the `$condition` variable. It was
`$true` and would have executed the `Write-Output` command inside the scriptblock.

In some languages, you can place a single line of code after the `if` statement and it gets
executed. That isn't the case in PowerShell. You must provide a full `scriptblock` with braces for
it to work correctly.

## Comparison operators

The most common use of the `if` statement for is comparing two items with each other. PowerShell has
special operators for different comparison scenarios. When you use a comparison operator, the value
on the left-hand side is compared to the value on the right-hand side.

### -eq for equality

The `-eq` does an equality check between two values to make sure they're equal to each other.

```powershell
$value = Get-MysteryValue
if ( 5 -eq $value )
{
    # do something
}
```

In this example, I'm taking a known value of `5` and comparing it to my `$value` to see if they
match.

One possible use case is to check the status of a value before you take an action on it. You could
get a service and check that the status was running before you called `Restart-Service` on it.

It's common in other languages like C# to use `==` for equality (ex: `5 == $value`) but that doesn't
work with PowerShell. Another common mistake that people make is to use the equals sign (ex:
`5 = $value`) that is reserved for assigning values to variables. By placing your known value on the
left, it makes that mistake more awkward to make.

This operator (and others) has a few variations.

- `-eq` case-insensitive equality
- `-ieq` case-insensitive equality
- `-ceq` case-sensitive equality

### -ne not equal

Many operators have a related operator that is checking for the opposite result. `-ne` verifies that
the values don't equal each other.

```powershell
if ( 5 -ne $value )
{
    # do something
}
```

Use this to make sure that the action only executes if the value isn't `5`. A good use-cases where
would be to check if a service was in the running state before you try to start it.

**Variations:**

- `-ne` case-insensitive not equal
- `-ine` case-insensitive not equal
- `-cne` case-sensitive not equal

These are inverse variations of `-eq`. I'll group these types together when I list variations
for other operators.

### -gt -ge -lt -le for greater than or less than

These operators are used when checking to see if a value is larger or smaller than another value.
The `-gt -ge -lt -le` stand for GreaterThan, GreaterThanOrEqual, LessThan, and LessThanOrEqual.

```powershell
if ( $value -gt 5 )
{
    # do something
}
```

**Variations:**

- `-gt` greater than
- `-igt` greater than, case-insensitive
- `-cgt` greater than, case-sensitive
- `-ge` greater than or equal
- `-ige` greater than or equal, case-insensitive
- `-cge` greater than or equal, case-sensitive
- `-lt` less than
- `-ilt` less than, case-insensitive
- `-clt` less than, case-sensitive
- `-le` less than or equal
- `-ile` less than or equal, case-insensitive
- `-cle` less than or equal, case-sensitive

I don't know why you would use case-sensitive and insensitive options for these operators.

### -like wildcard matches

PowerShell has its own wildcard-based pattern matching syntax and you can use it with the `-like`
operator. These wildcard patterns are fairly basic.

- `?` matches any single character
- `*` matches any number of characters

```powershell
$value = 'S-ATX-SQL01'
if ( $value -like 'S-*-SQL??')
{
    # do something
}
```

It's important to point out that the pattern matches the whole string. If you need to match
something in the middle of the string, you need to place the `*` on both ends of the
string.

```powershell
$value = 'S-ATX-SQL02'
if ( $value -like '*SQL*')
{
    # do something
}
```

**Variations:**

- `-like` case-insensitive wildcard
- `-ilike` case-insensitive wildcard
- `-clike` case-sensitive wildcard
- `-notlike` case-insensitive wildcard not matched
- `-inotlike` case-insensitive wildcard not matched
- `-cnotlike` case-sensitive wildcard not matched

### -match regular expression

The `-match` operator allows you to check a string for a regular-expression-based match. Use this
when the wildcard patterns aren't flexible enough for you.

```powershell
$value = 'S-ATX-SQL01'
if ( $value -match 'S-\w\w\w-SQL\d\d')
{
    # do something
}
```

A regex pattern matches anywhere in the string by default. So you can specify a substring that
you want matched like this:

```powershell
$value = 'S-ATX-SQL01'
if ( $value -match 'SQL')
{
    # do something
}
```

Regex is a complex language of its own and worth looking into. I talk more about `-match` and
[the many ways to use regex][the many ways to use regex] in another article.

**Variations:**

- `-match` case-insensitive regex
- `-imatch` case-insensitive regex
- `-cmatch` case-sensitive regex
- `-notmatch` case-insensitive regex not matched
- `-inotmatch` case-insensitive regex not matched
- `-cnotmatch` case-sensitive regex not matched

### -is of type

You can check a value's type with the `-is` operator.

```powershell
if ( $value -is [string] )
{
    # do something
}
```

You may use this if you're working with classes or accepting various objects over the pipeline. You
could have either a service or a service name as your input. Then check to see if you have a service
and fetch the service if you only have the name.

```powershell
if ( $Service -isnot [System.ServiceProcess.ServiceController] )
{
    $Service = Get-Service -Name $Service
}
```

**Variations:**

- `-is` of type
- `-isnot` not of type

## Collection operators

When you use the previous operators with a single value, the result is `$true` or `$false`. This is
handled slightly differently when working with a collection. Each item in the collection gets
evaluated and the operator returns every value that evaluates to `$true`.

```powershell
PS> 1,2,3,4 -eq 3
3
```

This still works correctly in an `if` statement. So a value is returned by your operator, then the
whole statement is `$true`.

```powershell
$array = 1..6
if ( $array -gt 3 )
{
    # do something
}
```

There's one small trap hiding in the details here that I need to point out. When using the `-ne`
operator this way, it's easy to mistakenly look at the logic backwards. Using `-ne` with a
collection returns `$true` if any item in the collection doesn't match your value.

```powershell
PS> 1,2,3 -ne 4
1
2
3
```

This may look like a clever trick, but we have operators `-contains` and `-in` that handle this more
efficiently. And `-notcontains` does what you expect.

### -contains

The `-contains` operator checks the collection for your value. As soon as it finds a match, it
returns `$true`.

```powershell
$array = 1..6
if ( $array -contains 3 )
{
    # do something
}
```

This is the preferred way to see if a collection contains your value. Using `Where-Object` (or
`-eq`) walks the entire list every time and is significantly slower.

**Variations:**

- `-contains` case-insensitive match
- `-icontains` case-insensitive match
- `-ccontains` case-sensitive match
- `-notcontains` case-insensitive not matched
- `-inotcontains` case-insensitive not matched
- `-cnotcontains` case-sensitive not matched

### -in

The `-in` operator is just like the `-contains` operator except the collection is on the right-hand
side.

```powershell
$array = 1..6
if ( 3 -in $array )
{
    # do something
}
```

**Variations:**

- `-in` case-insensitive match
- `-iin` case-insensitive match
- `-cin` case-sensitive match
- `-notin` case-insensitive not matched
- `-inotin` case-insensitive not matched
- `-cnotin` case-sensitive not matched

## Logical operators

Logical operators are used to invert or combine other expressions.

### -not

The `-not` operator flips an expression from `$false` to `$true` or from `$true` to `$false`. Here
is an example where we want to perform an action when `Test-Path` is `$false`.

```powershell
if ( -not ( Test-Path -Path $path ) )
```

Most of the operators we talked about do have a variation where you do not need to use the `-not`
operator. But there are still times it is useful.

### ! operator

You can use `!` as an alias for `-not`.

```powershell
if ( -not $value ){}
if ( !$value ){}
```

You may see `!` used more by people that come from another languages like C#. I prefer to type it
out because I find it hard to see when quickly looking at my scripts.

### -and

You can combine expressions with the `-and` operator. When you do that, both sides need to be
`$true` for the whole expression to be `$true`.

```powershell
if ( ($age -gt 13) -and ($age -lt 55) )
```

In that example, `$age` must be 13 or older for the left side and less than 55 for the right side. I
added extra parentheses to make it clearer in that example but they're optional as long as the
expression is simple. Here is the same example without them.

```powershell
if ( $age -gt 13 -and $age -lt 55 )
```

Evaluation happens from left to right. If the first item evaluates to `$false`, it exits early and
doesn't perform the right comparison. This is handy when you need to make sure a value exists before
you use it. For example, `Test-Path` throws an error if you give it a `$null` path.

```powershell
if ( $null -ne $path -and (Test-Path -Path $path) )
```

### -or

The `-or` allows for you to specify two expressions and returns `$true` if either one of them is
`$true`.

```powershell
if ( $age -le 13 -or $age -ge 55 )
```

Just like with the `-and` operator, the evaluation happens from left to right. Except that if the
first part is `$true`, then the whole statement is `$true` and it doesn't process the rest of the
expression.

Also make note of how the syntax works for these operators. You need two separate expressions. I
have seen users try to do something like this `$value -eq 5 -or 6` without realizing their mistake.

### -xor exclusive or

This one is a little unusual. `-xor` allows only one expression to evaluate to `$true`. So if both
items are `$false` or both items are `$true`, then the whole expression is `$false`. Another way to
look at this is the expression is only `$true` when the results of the expression are different.

It's rare that anyone would ever use this logical operator and I can't think up a good example as to
why I would ever use it.

## Bitwise operators

Bitwise operators perform calculations on the bits within the values and produce a new value as the
result. Teaching [bitwise operators][bitwise operators] is beyond the scope of this article, but here is the list of them.

- `-band` binary AND
- `-bor` binary OR
- `-bxor` binary exclusive OR
- `-bnot` binary NOT
- `-shl` shift left
- `-shr` shift right

## PowerShell expressions

We can use normal PowerShell inside the condition statement.

```powershell
if ( Test-Path -Path $Path )
```

`Test-Path` returns `$true` or `$false` when it executes. This also applies to commands that return
other values.

```powershell
if ( Get-Process Notepad* )
```

It evaluates to `$true` if there's a returned process and `$false` if there isn't. It's
perfectly valid to use pipeline expressions or other PowerShell statements like this:

```powershell
if ( Get-Process | Where Name -eq Notepad )
```

These expressions can be combined with each other with the `-and` and `-or` operators, but you may
have to use parenthesis to break them into subexpressions.

```powershell
if ( (Get-Process) -and (Get-Service) )
```

### Checking for $null

Having a no result or a `$null` value evaluates to `$false` in the `if` statement. When checking
specifically for `$null`, it's a best practice to place the `$null` on the left-hand side.

```powershell
if ( $null -eq $value )
```

There are quite a few nuances when dealing with `$null` values in PowerShell. If you're interested
in diving deeper, I have an article about [everything you wanted to know about $null][everything you wanted to know about $null].

### Variable assignment within the condition

I almost forgot to add this one until [Prasoon Karunan V][Prasoon Karunan V] reminded me of it.

```powershell
if ($process=Get-Process notepad -ErrorAction ignore) {$process} else {$false}
```

Normally when you assign a value to a variable, the value isn't passed onto the pipeline or
console. When you do a variable assignment in a sub expression, it does get passed on to the
pipeline.

```powershell
PS> $first = 1
PS> ($second = 2)
2
```

See how the `$first` assignment has no output and the `$second` assignment does? When an assignment
is done in an `if` statement, it executes just like the `$second` assignment above. Here is a clean
example on how you could use it:

```powershell
if ( $process = Get-Process Notepad* )
{
    $process | Stop-Process
}
```

If `$process` gets assigned a value, then the statement is `$true` and `$process` gets stopped.

Make sure you don't confuse this with `-eq` because this isn't an equality check. This is a more
obscure feature that most people don't realize works this way.

## Variable assignment from the scriptblock

You can also use the `if` statement scriptblock to assign a value to a variable.

```powershell
$discount = if ( $age -ge 55 )
{
    Get-SeniorDiscount
}
elseif ( $age -le 13 )
{
    Get-ChildDiscount
}
else
{
    0.00
}
```

Each script block is writing the results of the commands, or the value, as output. We can assign the
result of the `if` statement to the `$discount` variable. That example could have just as easily
assigned those values to the `$discount` variable directly in each scriptblock. I can't say that I
use this with the `if` statement often, but I do have an example where I used this recently.

## Alternate execution path

The `if` statement allows you to specify an action for not only when the statement is `$true`, but
also for when it's `$false`. This is where the `else` statement comes into play.

### else

The `else` statement is always the last part of the `if` statement when used.

```powershell
if ( Test-Path -Path $Path -PathType Leaf )
{
    Move-Item -Path $Path -Destination $archivePath
}
else
{
    Write-Warning "$path doesn't exist or isn't a file."
}
```

In this example, we check the `$path` to make sure it's a file. If we find the file, we move it. If
not, we write a warning. This type of branching logic is very common.

### Nested if

The `if` and `else` statements take a script block, so we can place any PowerShell command inside
them, including another `if` statement. This allows you to make use of much more complicated logic.

```powershell
if ( Test-Path -Path $Path -PathType Leaf )
{
    Move-Item -Path $Path -Destination $archivePath
}
else
{
    if ( Test-Path -Path $Path )
    {
        Write-Warning "A file was required but a directory was found instead."
    }
    else
    {
        Write-Warning "$path could not be found."
    }
}
```

In this example, we test the happy path first and then take action on it. If that fails, we do
another check and to provide more detailed information to the user.

### elseif

We aren't limited to just a single conditional check. We can chain `if` and `else` statements
together instead of nesting them by using the `elseif` statement.

```powershell
if ( Test-Path -Path $Path -PathType Leaf )
{
    Move-Item -Path $Path -Destination $archivePath
}
elseif ( Test-Path -Path $Path )
{
    Write-Warning "A file was required but a directory was found instead."
}
else
{
    Write-Warning "$path could not be found."
}
```

The execution happens from the top to the bottom. The top `if` statement is evaluated first. If that
is `$false`, then it moves down to the next `elseif` or `else` in the list. That last `else` is the
default action to take if none of the others return `$true`.

### switch

At this point, I need to mention the `switch` statement. It provides an alternate syntax for doing
multiple comparisons with a value. With the `switch`, you specify an expression and that result gets
compared with several different values. If one of those values match, the matching code block is
executed. Take a look at this example:

```powershell
$itemType = 'Role'
switch ( $itemType )
{
    'Component'
    {
        'is a component'
    }
    'Role'
    {
        'is a role'
    }
    'Location'
    {
        'is a location'
    }
}
```

There three possible values that can match the `$itemType`. In this case, it matches with `Role`. I
used a simple example just to give you some exposure to the `switch` operator. I talk more
about [everything you ever wanted to know about the switch statement][everything you ever wanted to know about the switch statement] in another article.

### Array inline

I have a function called [Invoke-SnowSql][Invoke-SnowSql] that launches an executable with several command-line
arguments. Here is a clip from that function where I build the array of arguments.

```powershell
$snowSqlParam = @(
    '--accountname', $Endpoint
    '--username', $Credential.UserName
    '--option', 'exit_on_error=true'
    '--option', 'output_format=csv'
    '--option', 'friendly=false'
    '--option', 'timing=false'
    if ($Debug)
    {
        '--option', 'log_level=DEBUG'
    }
    if ($Path)
    {
        '--filename', $Path
    }
    else
    {
        '--query', $singleLineQuery
    }
)
```

The `$Debug` and `$Path` variables are parameters on the function that are provided by the end user.
I evaluate them inline inside the initialization of my array. If `$Debug` is true, then those values
fall into the `$snowSqlParam` in the correct place. Same holds true for the `$Path` variable.

## Simplify complex operations

It's inevitable that you run into a situation that has way too many comparisons to check and your
`If` statement scrolls way off the right side of the screen.

```powershell
$user = Get-ADUser -Identity $UserName
if ( $null -ne $user -and $user.Department -eq 'Finance' -and $user.Title -match 'Senior' -and $user.HomeDrive -notlike '\\server\*' )
{
    # Do Something
}
```

They can be hard to read and that make you more prone to make mistakes. There are a few things we
can do about that.

### Line continuation

There some operators in PowerShell that let you wrap you command to the next line. The logical
operators `-and` and `-or` are good operators to use if you want to break your expression into
multiple lines.

```powershell
if ($null -ne $user -and
    $user.Department -eq 'Finance' -and
    $user.Title -match 'Senior' -and
    $user.HomeDrive -notlike '\\server\*'
)
{
    # Do Something
}
```

There's still a lot going on there, but placing each piece on its own line makes a big difference.
I generally use this when I get more than two comparisons or if I have to scroll to the right to
read any of the logic.

### Pre-calculating results

We can take that statement out of the `if` statement and only check the result.

```powershell
$needsSecureHomeDrive = $null -ne $user -and
    $user.Department -eq 'Finance' -and
    $user.Title -match 'Senior' -and
    $user.HomeDrive -notlike '\\server\*'

if ( $needsSecureHomeDrive )
{
    # Do Something
}
```

This just feels much cleaner than the previous example. You also are given an opportunity to use a
variable name that explains what it's that you're really checking. This is also and example of
self-documenting code that saves unnecessary comments.

### Multiple if statements

We can break this up into multiple statements and check them one at a time. In this case, we use a
flag or a tracking variable to combine the results.

```powershell

$skipUser = $false

if( $null -eq $user )
{
    $skipUser = $true
}

if( $user.Department -ne 'Finance' )
{
    Write-Verbose "isn't in Finance department"
    $skipUser = $true
}

if( $user.Title -match 'Senior' )
{
    Write-Verbose "Doesn't have Senior title"
    $skipUser = $true
}

if( $user.HomeDrive -like '\\server\*' )
{
    Write-Verbose "Home drive already configured"
    $skipUser = $true
}

if ( -not $skipUser )
{
    # do something
}
```

I did have to invert the logic to make the flag logic work correctly. Each evaluation is an
individual `if` statement. The advantage of this is that when you're debugging, you can tell
exactly what the logic is doing. I was able to add much better verbosity at the same time.

The obvious downside is that it's so much more code to write. The code is more complex to look at
as it takes a single line of logic and explodes it into 25 or more lines.

### Using functions

We can also move all that validation logic into a function. Look at how clean this looks at a
glance.

```powershell
if ( Test-SecureDriveConfiguration -ADUser $user )
{
    # do something
}
```

You still have to create the function to do the validation, but it makes this code much easier to
work with. It makes this code easier to test. In your tests, you can mock the call to
`Test-ADDriveConfiguration` and you only need two tests for this function. One where it returns
`$true` and one where it returns `$false`. Testing the other function is simpler because it's
so small.

The body of that function could still be that one-liner we started with or the exploded logic that
we used in the last section. This works well for both scenarios and allows you to easily change that
implementation later.

## Error handling

One important use of the `if` statement is to check for error conditions before you run into
errors. A good example is to check if a folder already exists before you try to create it.

```powershell
if ( -not (Test-Path -Path $folder) )
{
    New-Item -Type Directory -Path $folder
}
```

I like to say that if you expect an exception to happen, then it's not really an exception. So check
your values and validate your conditions where you can.

If you want to dive a little more into actual exception handling, I have an article on
[everything you ever wanted to know about exceptions][everything you ever wanted to know about exceptions].

## Final words

The `if` statement is such a simple statement but is a fundamental piece of PowerShell. You will
find yourself using this multiple times in almost every script you write. I hope you have a better
understanding than you had before.

<!-- link references -->
[original version]: https://powershellexplained.com/2019-08-11-Powershell-if-then-else-equals-operator/
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[if]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_if
[bitwise operators]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arithmetic_operators#bitwise-operators
[the many ways to use regex]: https://powershellexplained.com/2017-07-31-Powershell-regex-regular-expression/
[everything you ever wanted to know about exceptions]: everything-about-exceptions.md
[everything you wanted to know about $null]: everything-about-null.md
[Prasoon Karunan V]: https://twitter.com/prasoonkarunan
[everything you ever wanted to know about the switch statement]: everything-about-switch.md
[Invoke-SnowSql]: https://github.com/loanDepot/SnowSQL/blob/a3731b52e4ab4ecb503fb81e2d8cb131e8f90410/SnowSQL/public/Invoke-SnowSql.ps1#L90

# /./reference/learn/deep-dives/everything-about-switch.md

    ---
    description: The switch statement in PowerShell offers features that aren't found in other languages.
    ms.custom: contributor-KevinMarquette
    ms.date: 11/16/2022
    title: Everything you ever wanted to know about the switch statement
    ---
# Everything you ever wanted to know about the switch statement

Like many other languages, PowerShell has commands for controlling the flow of execution within your
scripts. One of those statements is the [switch][switch] statement and in PowerShell, it offers
features that aren't found in other languages. Today, we take a deep dive into working with the
PowerShell `switch`.

> [!NOTE]
> The [original version][original version] of this article appeared on the blog written by
> [@KevinMarquette][@KevinMarquette]. The PowerShell team thanks Kevin for sharing this content with
> us. Please check out his blog at [PowerShellExplained.com][PowerShellExplained.com].

## The `if` statement

One of the first statements that you learn is the `if` statement. It lets you execute a script block
if a statement is `$true`.

``` powershell
if ( Test-Path $Path )
{
    Remove-Item $Path
}
```

You can have much more complicated logic using `elseif` and `else` statements. Here is an example
where I have a numeric value for day of the week and I want to get the name as a string.

``` powershell
$day = 3

if ( $day -eq 0 ) { $result = 'Sunday'        }
elseif ( $day -eq 1 ) { $result = 'Monday'    }
elseif ( $day -eq 2 ) { $result = 'Tuesday'   }
elseif ( $day -eq 3 ) { $result = 'Wednesday' }
elseif ( $day -eq 4 ) { $result = 'Thursday'  }
elseif ( $day -eq 5 ) { $result = 'Friday'    }
elseif ( $day -eq 6 ) { $result = 'Saturday'  }

$result
```

```Output
Wednesday
```

It turns out that this is a common pattern and there are many ways to deal with this. One
of them is with a `switch`.

## Switch statement

The `switch` statement allows you to provide a variable and a list of possible values. If the value
matches the variable, then its scriptblock is executed.

``` powershell
$day = 3

switch ( $day )
{
    0 { $result = 'Sunday'    }
    1 { $result = 'Monday'    }
    2 { $result = 'Tuesday'   }
    3 { $result = 'Wednesday' }
    4 { $result = 'Thursday'  }
    5 { $result = 'Friday'    }
    6 { $result = 'Saturday'  }
}

$result
```

```Output
'Wednesday'
```

For this example, the value of `$day` matches one of the numeric values, then the correct name is
assigned to `$result`. We're only doing a variable assignment in this example, but any PowerShell
can be executed in those script blocks.

### Assign to a variable

We can write that last example in another way.

``` powershell
$result = switch ( $day )
{
    0 { 'Sunday'    }
    1 { 'Monday'    }
    2 { 'Tuesday'   }
    3 { 'Wednesday' }
    4 { 'Thursday'  }
    5 { 'Friday'    }
    6 { 'Saturday'  }
}
```

We're placing the value on the PowerShell pipeline and assigning it to the `$result`. You can do
this same thing with the `if` and `foreach` statements.

### Default

We can use the `default` keyword to identify the what should happen if there is no match.

``` powershell
$result = switch ( $day )
{
    0 { 'Sunday' }
    # ...
    6 { 'Saturday' }
    default { 'Unknown' }
}
```

Here we return the value `Unknown` in the default case.

### Strings

I was matching numbers in those last examples, but you can also match strings.

``` powershell
$item = 'Role'

switch ( $item )
{
    Component
    {
        'is a component'
    }
    Role
    {
        'is a role'
    }
    Location
    {
        'is a location'
    }
}
```

```Output
is a role
```

I decided not to wrap the `Component`,`Role` and `Location` matches in quotes here to highlight that
they're optional. The `switch` treats those as a string in most cases.

## Arrays

One of the cool features of the PowerShell `switch` is the way it handles arrays. If you give a
`switch` an array, it processes each element in that collection.

``` powershell
$roles = @('WEB','Database')

switch ( $roles ) {
    'Database'   { 'Configure SQL' }
    'WEB'        { 'Configure IIS' }
    'FileServer' { 'Configure Share' }
}
```

```Output
Configure IIS
Configure SQL
```

If you have repeated items in your array, then they're matched multiple times by the appropriate
section.

### PSItem

You can use the `$PSItem` or `$_` to reference the current item that was processed. When we do a
simple match, `$PSItem` is the value that we're matching. I'll be performing some advanced matches
in the next section where this variable is used.

## Parameters

A unique feature of the PowerShell `switch` is that it has a number of switch parameters that
change how it performs.

### -CaseSensitive

The matches aren't case-sensitive by default. If you need to be case-sensitive, you can use
`-CaseSensitive`. This can be used in combination with the other switch parameters.

### -Wildcard

We can enable wildcard support with the `-wildcard` switch. This uses the same wildcard logic as the
`-like` operator to do each match.

``` powershell
$Message = 'Warning, out of disk space'

switch -Wildcard ( $message )
{
    'Error*'
    {
        Write-Error -Message $Message
    }
    'Warning*'
    {
        Write-Warning -Message $Message
    }
    default
    {
        Write-Information $message
    }
}
```

```Output
WARNING: Warning, out of disk space
```

Here we're processing a message and then outputting it on different streams based on the contents.

### -Regex

The switch statement supports regex matches just like it does wildcards.

``` powershell
switch -Regex ( $message )
{
    '^Error'
    {
        Write-Error -Message $Message
    }
    '^Warning'
    {
        Write-Warning -Message $Message
    }
    default
    {
        Write-Information $message
    }
}
```

I have more examples of using regex in another article I wrote:
[The many ways to use regex][The many ways to use regex].

### -File

A little known feature of the switch statement is that it can process a file with the `-File`
parameter. You use `-file` with a path to a file instead of giving it a variable expression.

``` powershell
switch -Wildcard -File $path
{
    'Error*'
    {
        Write-Error -Message $PSItem
    }
    'Warning*'
    {
        Write-Warning -Message $PSItem
    }
    default
    {
        Write-Output $PSItem
    }
}
```

It works just like processing an array. In this example, I combine it with wildcard matching and
make use of the `$PSItem`. This would process a log file and convert it to warning and error
messages depending on the regex matches.

## Advanced details

Now that you're aware of all these documented features, we can use them in the context of more
advanced processing.

### Expressions

The `switch` can be on an expression instead of a variable.

``` powershell
switch ( ( Get-Service | Where status -eq 'running' ).name ) {...}
```

Whatever the expression evaluates to is the value used for the match.

### Multiple matches

You may have already picked up on this, but a `switch` can match to multiple conditions. This is
especially true when using `-wildcard` or `-regex` matches. You can add the same condition multiple
times and all are triggered.

``` powershell
switch ( 'Word' )
{
    'word' { 'lower case word match' }
    'Word' { 'mixed case word match' }
    'WORD' { 'upper case word match' }
}
```

```Output
lower case word match
mixed case word match
upper case word match
```

All three of these statements are fired. This shows that every condition is checked (in order). This
holds true for processing arrays where each item checks each condition.

### Continue

Normally, this is where I would introduce the `break` statement, but it's better that we learn how
to use `continue` first. Just like with a `foreach` loop, `continue` continues onto the next item in
the collection or exits the `switch` if there are no more items. We can rewrite that last example
with continue statements so that only one statement executes.

``` powershell
switch ( 'Word' )
{
    'word'
    {
        'lower case word match'
        continue
    }
    'Word'
    {
        'mixed case word match'
        continue
    }
    'WORD'
    {
        'upper case word match'
        continue
    }
}
```

```Output
lower case word match
```

Instead of matching all three items, the first one is matched and the switch continues to the next
value. Because there are no values left to process, the switch exits. This next example is showing
how a wildcard could match multiple items.

``` powershell
switch -Wildcard -File $path
{
    '*Error*'
    {
        Write-Error -Message $PSItem
        continue
    }
    '*Warning*'
    {
        Write-Warning -Message $PSItem
        continue
    }
    default
    {
        Write-Output $PSItem
    }
}
```

Because a line in the input file could contain both the word `Error` and `Warning`, we only want the
first one to execute and then continue processing the file.

### Break

A `break` statement exits the switch. This is the same behavior that `continue` presents for single
values. The difference is shown when processing an array. `break` stops all processing in the switch
and `continue` moves onto the next item.

``` powershell
$Messages = @(
    'Downloading update'
    'Ran into errors downloading file'
    'Error: out of disk space'
    'Sending email'
    '...'
)

switch -Wildcard ($Messages)
{
    'Error*'
    {
        Write-Error -Message $PSItem
        break
    }
    '*Error*'
    {
        Write-Warning -Message $PSItem
        continue
    }
    '*Warning*'
    {
        Write-Warning -Message $PSItem
        continue
    }
    default
    {
        Write-Output $PSItem
    }
}
```

```Output
Downloading update
WARNING: Ran into errors downloading file
write-error -message $PSItem : Error: out of disk space
+ CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
+ FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException
```

In this case, if we hit any lines that start with `Error` then we get an error and the switch stops.
This is what that `break` statement is doing for us. If we find `Error` inside the string and not
just at the beginning, we write it as a warning. We do the same thing for `Warning`. It's possible
that a line could have both the word `Error` and `Warning`, but we only need one to process. This is
what the `continue` statement is doing for us.

### Break labels

The `switch` statement supports `break/continue` labels just like `foreach`.

``` powershell
:filelist foreach($path in $logs)
{
    :logFile switch -Wildcard -File $path
    {
        'Error*'
        {
            Write-Error -Message $PSItem
            break filelist
        }
        'Warning*'
        {
            Write-Error -Message $PSItem
            break logFile
        }
        default
        {
            Write-Output $PSItem
        }
    }
}
```

I personally don't like the use of break labels but I wanted to point them out because they're
confusing if you've never seen them before. When you have multiple `switch` or `foreach` statements
that are nested, you may want to break out of more than the inner most item. You can place a label
on a `switch` that can be the target of your `break`.

### Enum

PowerShell 5.0 gave us enums and we can use them in a switch.

``` powershell
enum Context {
    Component
    Role
    Location
}

$item = [Context]::Role

switch ( $item )
{
    Component
    {
        'is a component'
    }
    Role
    {
        'is a role'
    }
    Location
    {
        'is a location'
    }
}
```

```Output
is a role
```

If you want to keep everything as strongly typed enums, then you can place them in parentheses.

``` powershell
switch ($item )
{
    ([Context]::Component)
    {
        'is a component'
    }
    ([Context]::Role)
    {
        'is a role'
    }
    ([Context]::Location)
    {
        'is a location'
    }
}
```

The parentheses are needed here so that the switch doesn't treat the value `[Context]::Location` as
a literal string.

### ScriptBlock

We can use a scriptblock to perform the evaluation for a match if needed.

``` powershell
$age = 37

switch ( $age )
{
    {$PSItem -le 18}
    {
        'child'
    }
    {$PSItem -gt 18}
    {
        'adult'
    }
}
```

```Output
'adult'
```

This adds complexity and can make your `switch` hard to read. In most cases where you would use
something like this it would be better to use `if` and `elseif` statements. I would consider using
this if I already had a large switch in place and I needed two items to hit the same evaluation
block.

One thing that I think helps with legibility is to place the scriptblock in parentheses.

``` powershell
switch ( $age )
{
    ({$PSItem -le 18})
    {
        'child'
    }
    ({$PSItem -gt 18})
    {
        'adult'
    }
}
```

It still executes the same way and gives a better visual break when quickly looking at it.

### Regex $matches

We need to revisit regex to touch on something that isn't immediately obvious. The use of regex
populates the `$matches` variable. I do go into the use of `$matches` more when I talk about
[The many ways to use regex][The many ways to use regex]. Here is a quick sample to show it in
action with named matches.

``` powershell
$message = 'my ssn is 123-23-3456 and credit card: 1234-5678-1234-5678'

switch -regex ($message)
{
    '(?<SSN>\d\d\d-\d\d-\d\d\d\d)'
    {
        Write-Warning "message contains a SSN: $($matches.SSN)"
    }
    '(?<CC>\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d)'
    {
        Write-Warning "message contains a credit card number: $($matches.CC)"
    }
    '(?<Phone>\d\d\d-\d\d\d-\d\d\d\d)'
    {
        Write-Warning "message contains a phone number: $($matches.Phone)"
    }
}
```

```Output
WARNING: message may contain a SSN: 123-23-3456
WARNING: message may contain a credit card number: 1234-5678-1234-5678
```

### $null

You can match a `$null` value that doesn't have to be the default.

```powershell
$values = '', 5, $null
switch ( $values )
{
    $null          { "Value '$_' is `$null" }
    { '' -eq $_ }  { "Value '$_' is an empty string" }
    default        { "Value [$_] isn't an empty string or `$null" }
}
```

```Output
Value '' is an empty string
Value [5] isn't an empty string or $null
Value '' is $null
```

When testing for an empty string in a `switch` statement, it's important to use the comparison
statement as shown in this example instead of the raw value `''`. In a `switch` statement, the raw
value `''` also matches `$null`. For example:

```powershell
$values = '', 5, $null
switch ( $values )
{
    $null          { "Value '$_' is `$null" }
    ''             { "Value '$_' is an empty string" }
    default        { "Value [$_] isn't an empty string or `$null" }
}
```

```Output
Value '' is an empty string
Value [5] isn't an empty string or $null
Value '' is $null
Value '' is an empty string
```

Also, be careful with empty returns from cmdlets. Cmdlets or pipelines that have no output are
treated as an empty array that doesn't match anything, including the `default` case.

```powershell
$file = Get-ChildItem NonExistantFile*
switch ( $file )
{
    $null   { '$file is $null' }
    default { "`$file is type $($file.GetType().Name)" }
}
# No matches
```

### Constant expression

Lee Dailey pointed out that we can use a constant `$true` expression to evaluate `[bool]` items.
Imagine if we have several boolean checks that need to happen.

``` powershell
$isVisible = $false
$isEnabled = $true
$isSecure = $true

switch ( $true )
{
    $isEnabled
    {
        'Do-Action'
    }
    $isVisible
    {
        'Show-Animation'
    }
    $isSecure
    {
        'Enable-AdminMenu'
    }
}
```

```Output
Do-Action
Enabled-AdminMenu
```

This is a clean way to evaluate and take action on the status of several boolean fields. The cool
thing about this is that you can have one match flip the status of a value that hasn't been
evaluated yet.

``` powershell
$isVisible = $false
$isEnabled = $true
$isAdmin = $false

switch ( $true )
{
    $isEnabled
    {
        'Do-Action'
        $isVisible = $true
    }
    $isVisible
    {
        'Show-Animation'
    }
    $isAdmin
    {
        'Enable-AdminMenu'
    }
}
```

```Output
Do-Action
Show-Animation
```

Setting `$isEnabled` to `$true` in this example makes sure that `$isVisible` is also set to `$true`.
Then when `$isVisible` gets evaluated, its scriptblock is invoked. This is a bit counter-intuitive
but is a clever use of the mechanics.

### $switch automatic variable

When the `switch` is processing its values, it creates an enumerator and calls it `$switch`. This is
an automatic variable created by PowerShell and you can manipulate it directly.

```powershell
$a = 1, 2, 3, 4

switch($a) {
    1 { [void]$switch.MoveNext(); $switch.Current }
    3 { [void]$switch.MoveNext(); $switch.Current }
}
```

This gives you the results of:

```Output
2
4
```

By moving the enumerator forward, the next item doesn't get processed by the `switch` but you can
access that value directly. I would call it madness.

## Other patterns

### Hashtables

One of my most popular posts is the one I did on [hashtables][hashtables]. One of the use cases for
a `hashtable` is to be a lookup table. That's an alternate approach to a common pattern that a
`switch` statement is often addressing.

``` powershell
$day = 3

$lookup = @{
    0 = 'Sunday'
    1 = 'Monday'
    2 = 'Tuesday'
    3 = 'Wednesday'
    4 = 'Thursday'
    5 = 'Friday'
    6 = 'Saturday'
}

$lookup[$day]
```

```Output
Wednesday
```

If I'm only using a `switch` as a lookup, I often use a `hashtable` instead.

### Enum

PowerShell 5.0 introduced the `Enum` and it's also an option in this case.

``` powershell
$day = 3

enum DayOfTheWeek {
    Sunday
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
}

[DayOfTheWeek]$day
```

```Output
Wednesday
```

We could go all day looking at different ways to solve this problem. I just wanted to make sure you
knew you had options.

## Final words

The switch statement is simple on the surface but it offers some advanced features that most people
don't realize are available. Stringing those features together makes this a powerful feature. I hope
you learned something that you had not realized before.

<!-- link references -->
[original version]: https://powershellexplained.com/2018-01-12-Powershell-switch-statement/
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[switch]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_switch
[The many ways to use regex]: https://powershellexplained.com/2017-07-31-Powershell-regex-regular-expression
[hashtables]: everything-about-hashtable.md


# /./reference/learn/deep-dives/everything-about-exceptions.md

    ---
    description: Error handling is just part of life when it comes to writing code.
    ms.custom: contributor-KevinMarquette
    ms.date: 08/15/2023
    title: Everything you wanted to know about exceptions
    ---
# Everything you wanted to know about exceptions

Error handling is just part of life when it comes to writing code. We can often check and validate
conditions for expected behavior. When the unexpected happens, we turn to exception handling. You
can easily handle exceptions generated by other people's code or you can generate your own
exceptions for others to handle.

> [!NOTE]
> The [original version][07] of this article appeared on the blog written by [@KevinMarquette][08].
> The PowerShell team thanks Kevin for sharing this content with us. Please check out his blog at
> [PowerShellExplained.com][05].

## Basic terminology

We need to cover some basic terms before we jump into this one.

### Exception

An Exception is like an event that is created when normal error handling can't deal with the issue.
Trying to divide a number by zero or running out of memory are examples of something that creates an
exception. Sometimes the author of the code you're using creates exceptions for certain issues
when they happen.

### Throw and Catch

When an exception happens, we say that an exception is thrown. To handle a thrown exception, you
need to catch it. If an exception is thrown and it isn't caught by something, the script stops
executing.

### The call stack

The call stack is the list of functions that have called each other. When a function is called, it
gets added to the stack or the top of the list. When the function exits or returns, it is removed
from the stack.

When an exception is thrown, that call stack is checked in order for an exception handler to catch
it.

### Terminating and non-terminating errors

An exception is generally a terminating error. A thrown exception is either be caught or it
terminates the current execution. By default, a non-terminating error is generated by `Write-Error`
and it adds an error to the output stream without throwing an exception.

I point this out because `Write-Error` and other non-terminating errors do not trigger the
`catch`.

### Swallowing an exception

This is when you catch an error just to suppress it. Do this with caution because it can make
troubleshooting issues very difficult.

## Basic command syntax

Here is a quick overview of the basic exception handling syntax used in PowerShell.

### Throw

To create our own exception event, we throw an exception with the `throw` keyword.

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

This creates a runtime exception that is a terminating error. It's handled by a `catch` in a
calling function or exits the script with a message like this.

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### Write-Error -ErrorAction Stop

I mentioned that `Write-Error` doesn't throw a terminating error by default. If you specify
`-ErrorAction Stop`, `Write-Error` generates a terminating error that can be handled with a
`catch`.

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.

#### Cmdlet -ErrorAction Stop

If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error`
statements into terminating errors that stop execution or that can be handled by a `catch`.

```powershell
Start-Something -ErrorAction Stop
```

For more information about the **ErrorAction** parameter, see [about_CommonParameters][03]. For more
information about the `$ErrorActionPreference` variable, see [about_Preference_Variables][04].

### Try/Catch

The way exception handling works in PowerShell (and many other languages) is that you first `try` a
section of code and if it throws an error, you can `catch` it. Here is a quick sample.

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
    Write-Output $_
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
    Write-Output $_
}
```

The `catch` script only runs if there's a terminating error. If the `try` executes correctly, then
it skips over the `catch`. You can access the exception information in the `catch` block using the
`$_` variable.

### Try/Finally

Sometimes you don't need to handle an error but still need some code to execute if an exception
happens or not. A `finally` script does exactly that.

Take a look at this example:

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

Anytime you open or connect to a resource, you should close it. If the `ExecuteNonQuery()` throws an
exception, the connection isn't closed. Here is the same code inside a `try/finally` block.

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

In this example, the connection is closed if there's an error. It also is closed if there's no
error. The `finally` script runs every time.

Because you're not catching the exception, it still gets propagated up the call stack.

### Try/Catch/Finally

It's perfectly valid to use `catch` and `finally` together. Most of the time you'll use one or
the other, but you may find scenarios where you use both.

## $PSItem

Now that we got the basics out of the way, we can dig a little deeper.

Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord`
that contains the details about the exception. Here is a quick overview of some of the key
properties.

For these examples, I used an invalid path in `ReadAllText` to generate this exception.

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### PSItem.ToString()

This gives you the cleanest message to use in logging and general output. `ToString()` is
automatically called if `$PSItem` is placed inside a string.

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### $PSItem.InvocationInfo

This property contains additional information collected by PowerShell about the function or script
where the exception was thrown. Here is the `InvocationInfo` from the sample exception that I
created.

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber`
where the invocation started.

### $PSItem.ScriptStackTrace

This property shows the order of function calls that got you to the code where the exception was
generated.

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

I'm only making calls to functions in the same script but this would track the calls if multiple
scripts were involved.

### $PSItem.Exception

This is the actual exception that was thrown.

#### $PSItem.Exception.Message

This is the general message that describes the exception and is a good starting point when
troubleshooting. Most exceptions have a default message but can also be set to something custom when
the exception is thrown.

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the
`ErrorRecord`.

#### $PSItem.Exception.InnerException

Exceptions can contain inner exceptions. This is often the case when the code you're calling
catches an exception and throws a different exception. The original exception is placed inside
the new exception.

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

I will revisit this later when I talk about re-throwing exceptions.

#### $PSItem.Exception.StackTrace

This is the `StackTrace` for the exception. I showed a `ScriptStackTrace` above, but this one is for
the calls to managed code.

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

You only get this stack trace when the event is thrown from managed code. I'm calling a .NET
framework function directly so that is all we can see in this example. Generally when you're looking
at a stack trace, you're looking for where your code stops and the system calls begin.

## Working with exceptions

There is more to exceptions than the basic syntax and exception properties.

### Catching typed exceptions

You can be selective with the exceptions that you catch. Exceptions have a type and you can specify
the type of exception you want to catch.

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

The exception type is checked for each `catch` block until one is found that matches your exception.
It's important to realize that exceptions can inherit from other exceptions. In the example above,
`FileNotFoundException` inherits from `IOException`. So if the `IOException` was first, then it
would get called instead. Only one catch block is invoked even if there are multiple matches.

If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had an
`InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.

### Catch multiple types at once

It's possible to catch multiple exception types with the same `catch` statement.

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

Thank you `/u/Sheppard_Ra` for suggesting this addition.

### Throwing typed exceptions

You can throw typed exceptions in PowerShell. Instead of calling `throw` with a string:

```powershell
throw "Could not find: $path"
```

Use an exception accelerator like this:

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

But you have to specify a message when you do it that way.

You can also create a new instance of an exception to be thrown. The message is optional when you do
this because the system has default messages for all built-in exceptions.

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

By using a typed exception, you (or others) can catch the exception by the type as mentioned in the
previous section.

#### Write-Error -Exception

We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception
type. Use `Write-Error` like in these examples:

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception (New-Object -TypeName System.IO.FileNotFoundException) -ErrorAction Stop
```

Then we can catch it like this:

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### The big list of .NET exceptions

I compiled a master list with the help of the [Reddit/r/PowerShell community][09] that contains
hundreds of .NET exceptions to complement this post.

- [The big list of .NET exceptions][06]

I start by searching that list for exceptions that feel like they would be a good fit for my
situation. You should try to use exceptions in the base `System` namespace.

### Exceptions are objects

If you start using a lot of typed exceptions, remember that they are objects. Different exceptions
have different constructors and properties. If we look at the [FileNotFoundException][02]
documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file
path.

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

And it has a `FileName` property that exposes that file path.

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

You should consult the [.NET documentation][01] for other constructors and object properties.

### Re-throwing an exception

If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch`
it. You should only `catch` an exception that you plan to handle or perform some action when it
happens.

There are times where you want to perform an action on an exception but re-throw the exception so
something downstream can deal with it. We could write a message or log the problem close to where we
discover it but handle the issue further up the stack.

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current
exception.

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

We want to re-throw the exception to preserve the original execution information like source script
and line number. If we throw a new exception at this point, it hides where the exception started.

#### Re-throwing a new exception

If you catch an exception but you want to throw a different one, then you should nest the original
exception inside the new one. This allows someone down the stack to access it as the
`$PSItem.Exception.InnerException`.

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### $PSCmdlet.ThrowTerminatingError()

The one thing that I don't like about using `throw` for raw exceptions is that the error message
points at the `throw` statement and indicates that line is where the problem is.

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

Having the error message tell me that my script is broken because I called `throw` on line 31 is a
bad message for users of your script to see. It doesn't tell them anything useful.

Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then
this is the error that we would see.

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

Do you see how it points to the `Get-Resource` function as the source of the problem? That tells the
user something useful.

Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

This changes the source of the error to the Cmdlet and hide the internals of your function from
the users of your Cmdlet.

## Try can create terminating errors

Kirk Munro points out that some exceptions are only terminating errors when executed inside a
`try/catch` block. Here is the example he gave me that generates a divide by zero runtime exception.

```powershell
function Start-Something { 1/(1-1) }
```

Then invoke it like this to see it generate the error and still output the message.

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

But by placing that same code inside a `try/catch`, we see something else happen.

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

We see the error become a terminating error and not output the first message. What I don't like
about this one is that you can have this code in a function and it acts differently if someone is
using a `try/catch`.

I have not ran into issues with this myself but it is corner case to be aware of.

### $PSCmdlet.ThrowTerminatingError() inside try/catch

One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your
Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet. This leaves the burden
on the caller of your function to decide how to handle the error. They can turn it back into a
terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.

### Public function templates

One last take a way I had with my conversation with Kirk Munro was that he places a
`try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced
functions. In those generic catch blocks, he has a single line using
`$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

Because everything is in a `try` statement within his functions, everything acts consistently. This
also gives clean errors to the end user that hides the internal code from the generated error.

## Trap

I focused on the `try/catch` aspect of exceptions. But there's one legacy feature I need to mention
before we wrap this up.

A `trap` is placed in a script or function to catch all exceptions that happen in that scope. When
an exception happens, the code in the `trap` is executed and then the normal code continues. If
multiple exceptions happen, then the trap is called over and over.

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

I personally never adopted this approach but I can see the value in admin or controller scripts that
log any and all exceptions, then still continue to execute.

## Closing remarks

Adding proper exception handling to your scripts not only make them more stable, but also makes it
easier for you to troubleshoot those exceptions.

I spent a lot of time talking `throw` because it is a core concept when talking about exception
handling. PowerShell also gave us `Write-Error` that handles all the situations where you would use
`throw`. So don't think that you need to be using `throw` after reading this.

Now that I have taken the time to write about exception handling in this detail, I'm going to switch
over to using `Write-Error -Stop` to generate errors in my code. I'm also going to take Kirk's
advice and make `ThrowTerminatingError` my goto exception handler for every function.

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api
[02]: https://learn.microsoft.com/dotnet/api/System.IO.FileNotFoundException
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_commonparameters
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_preference_variables
[05]: https://powershellexplained.com/
[06]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[07]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[08]: https://twitter.com/KevinMarquette
[09]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/

# /./reference/learn/deep-dives/everything-about-null.md

    ---
    description: The PowerShell $null often appears to be simple but it has a lot of nuances. Let's take a close look at $null so you know what happens when you unexpectedly run into a null value.
    ms.custom: contributor-KevinMarquette
    ms.date: 11/16/2022
    title: Everything you wanted to know about $null
    ---
# Everything you wanted to know about $null

The PowerShell `$null` often appears to be simple but it has a lot of nuances. Let's take a close
look at `$null` so you know what happens when you unexpectedly run into a `$null` value.

> [!NOTE]
> The [original version][original version] of this article appeared on the blog written by [@KevinMarquette][@KevinMarquette]. The
> PowerShell team thanks Kevin for sharing this content with us. Please check out his blog at
> [PowerShellExplained.com][PowerShellExplained.com].

## What is NULL?

You can think of NULL as an unknown or empty value. A variable is NULL until you assign a value or
an object to it. This can be important because there are some commands that require a value and
generate errors if the value is NULL.

### PowerShell $null

`$null` is an automatic variable in PowerShell used to represent NULL. You can assign it to
variables, use it in comparisons and use it as a place holder for NULL in a collection.

PowerShell treats `$null` as an object with a value of NULL. This is different than what you may
expect if you come from another language.

## Examples of $null

Anytime you try to use a variable that you have not initialized, the value is `$null`. This is one
of the most common ways that `$null` values sneak into your code.

```powershell
PS> $null -eq $undefinedVariable
True
```

If you happen to mistype a variable name then PowerShell sees it as a different variable and the
value is `$null`.

The other way you find `$null` values is when they come from other commands that don't give you
any results.

```powershell
PS> function Get-Nothing {}
PS> $value = Get-Nothing
PS> $null -eq $value
True
```

## Impact of $null

`$null` values impact your code differently depending on where they show up.

### In strings

If you use `$null` in a string, then it's a blank value (or empty string).

```powershell
PS> $value = $null
PS> Write-Output "The value is $value"
The value is
```

This is one of the reasons that I like to place brackets around variables when using them in log
messages. It's even more important to identify the edges of your variable values when the value is
at the end of the string.

```powershell
PS> $value = $null
PS> Write-Output "The value is [$value]"
The value is []
```

This makes empty strings and `$null` values easy to spot.

### In numeric equation

When a `$null` value is used in a numeric equation then your results are invalid if they don't give
an error. Sometimes the `$null` evaluates to `0` and other times it makes the whole result `$null`.
Here is an example with multiplication that gives 0 or `$null` depending on the order of the values.

```powershell
PS> $null * 5
PS> $null -eq ( $null * 5 )
True

PS> 5 * $null
0
PS> $null -eq ( 5 * $null )
False
```

### In place of a collection

A collection allows you use an index to access values. If you try to index into a collection that is
actually `null`, you get this error: `Cannot index into a null array`.

```powershell
PS> $value = $null
PS> $value[10]
Cannot index into a null array.
At line:1 char:1
+ $value[10]
+ ~~~~~~~~~~
    + CategoryInfo          : InvalidOperation: (:) [], RuntimeException
    + FullyQualifiedErrorId : NullArray
```

If you have a collection but try to access an element that is not in the collection, you get a
`$null` result.

```powershell
$array = @( 'one','two','three' )
$null -eq $array[100]
True
```

### In place of an object

If you try to access a property or sub property of an object that doesn't have the specified
property, you get a `$null` value like you would for an undefined variable. It doesn't matter if the
variable is `$null` or an actual object in this case.

```powershell
PS> $null -eq $undefined.some.fake.property
True

PS> $date = Get-Date
PS> $null -eq $date.some.fake.property
True
```

### Method on a null-valued expression

Calling a method on a `$null` object throws a `RuntimeException`.

```powershell
PS> $value = $null
PS> $value.toString()
You cannot call a method on a null-valued expression.
At line:1 char:1
+ $value.tostring()
+ ~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidOperation: (:) [], RuntimeException
    + FullyQualifiedErrorId : InvokeMethodOnNull
```

Whenever I see the phrase `You cannot call a method on a null-valued expression` then the first
thing I look for are places where I am calling a method on a variable without first checking it
for `$null`.

## Checking for $null

You may have noticed that I always place the `$null` on the left when checking for `$null` in my
examples. This is intentional and accepted as a PowerShell best practice. There are some scenarios
where placing it on the right doesn't give you the expected result.

Look at this next example and try to predict the results:

```powershell
if ( $value -eq $null )
{
    'The array is $null'
}
if ( $value -ne $null )
{
    'The array is not $null'
}
```

If I do not define `$value`, the first one evaluates to `$true` and our message is
`The array is $null`. The trap here is that it's possible to create a `$value` that allows both of
them to be `$false`

```powershell
$value = @( $null )
```

In this case, the `$value` is an array that contains a `$null`. The `-eq` checks every value in the
array and returns the `$null` that is matched. This evaluates to `$false`. The `-ne` returns
everything that doesn't match `$null` and in this case there are no results (This also evaluates to
`$false`). Neither one is `$true` even though it looks like one of them should be.

Not only can we create a value that makes both of them evaluate to `$false`, it's possible to
create a value where they both evaluate to `$true`. Mathias Jessen (@IISResetMe) has a
[good post][good post] that dives into that scenario.

### PSScriptAnalyzer and VSCode

The [PSScriptAnalyzer][PSScriptAnalyzer] module has a rule that checks for this issue called
`PSPossibleIncorrectComparisonWithNull`.

```powershell
PS> Invoke-ScriptAnalyzer ./myscript.ps1

RuleName                              Message
--------                              -------
PSPossibleIncorrectComparisonWithNull $null should be on the left side of equality comparisons.
```

Because VS Code uses the PSScriptAnalyser rules too, it also highlights or identifies this as a
problem in your script.

### Simple if check

A common way that people check for a non-$null value is to use a simple `if()` statement without
the comparison.

```powershell
if ( $value )
{
    Do-Something
}
```

If the value is `$null`, this evaluates to `$false`. This is easy to read, but be careful that it's
looking for exactly what you're expecting it to look for. I read that line of code as:

> If `$value` has a value.

But that's not the whole story. That line is actually saying:

> If `$value` is not `$null` or `0` or `$false` or an empty string or an empty array.

Here is a more complete sample of that statement.

```powershell
if ( $null -ne $value -and
        $value -ne 0 -and
        $value -ne '' -and
        ($value -isnot [array] -or $value.Length -ne 0) -and
        $value -ne $false )
{
    Do-Something
}
```

It's perfectly OK to use a basic `if` check as long as you remember those other values count as
`$false` and not just that a variable has a value.

I ran into this issue when refactoring some code a few days ago. It had a basic property check like
this.

```powershell
if ( $object.property )
{
    $object.property = $value
}
```

I wanted to assign a value to the object property only if it existed. In most cases, the original
object had a value that would evaluate to `$true` in the `if` statement. But I ran into an issue
where the value was occasionally not getting set. I debugged the code and found that the object had
the property but it was a blank string value. This prevented it from ever getting updated with the
previous logic. So I added a proper `$null` check and everything worked.

```powershell
if ( $null -ne $object.property )
{
    $object.property = $value
}
```

It's little bugs like these that are hard to spot and make me aggressively check values for `$null`.

## $null.Count

If you try to access a property on a `$null` value, that the property is also `$null`. The `count`
property is the exception to this rule.

```powershell
PS> $value = $null
PS> $value.count
0
```

When you have a `$null` value, then the `count` is `0`. This special property is added by
PowerShell.

### [PSCustomObject] Count

Almost all objects in PowerShell have that count property. One important exception is the
`[PSCustomObject]` in Windows PowerShell 5.1 (This is fixed in PowerShell 6.0). It doesn't have a
count property so you get a `$null` value if you try to use it. I call this out here so that you
don't try to use `.Count` instead of a `$null` check.

Running this example on Windows PowerShell 5.1 and PowerShell 6.0 gives you different results.

```powershell
$value = [PSCustomObject]@{Name='MyObject'}
if ( $value.count -eq 1 )
{
    "We have a value"
}
```

## Empty null

There is one special type of `$null` that acts differently than the others. I am going to call it
the empty `$null` but it's really a [System.Management.Automation.Internal.AutomationNull][System.Management.Automation.Internal.AutomationNull]. This
empty `$null` is the one you get as the result of a function or script block that returns nothing (a
void result).

```powershell
PS> function Get-Nothing {}
PS> $nothing = Get-Nothing
PS> $null -eq $nothing
True
```

If you compare it with `$null`, you get a `$null` value. When used in an evaluation where a value is
required, the value is always `$null`. But if you place it inside an array, it's treated the same as
an empty array.

```powershell
PS> $containempty = @( @() )
PS> $containnothing = @($nothing)
PS> $containnull = @($null)

PS> $containempty.count
0
PS> $containnothing.count
0
PS> $containnull.count
1
```

You can have an array that contains one `$null` value and its `count` is `1`. But if you place
an empty result inside an array then it's not counted as an item. The count is `0`.

If you treat the empty `$null` like a collection, then it's empty.

If you pass in an empty value to a function parameter that isn't strongly typed, PowerShell coerces
the nothing value into a `$null` value by default. This means inside the function, the value will be
treated as `$null` instead of the **System.Management.Automation.Internal.AutomationNull** type.

### Pipeline

The primary place you see the difference is when using the pipeline. You can pipe a `$null`
value but not an empty `$null` value.

```powershell
PS> $null | ForEach-Object{ Write-Output 'NULL Value' }
'NULL Value'
PS> $nothing | ForEach-Object{ Write-Output 'No Value' }
```

Depending on your code, you should account for the `$null` in your logic.

Either check for `$null` first

- Filter out null on the pipeline (`... | Where {$null -ne $_} | ...`)
- Handle it in the pipeline function

## foreach

One of my favorite features of `foreach` is that it doesn't enumerate over a `$null` collection.

```powershell
foreach ( $node in $null )
{
    #skipped
}
```

This saves me from having to `$null` check the collection before I enumerate it. If you have a
collection of `$null` values, the `$node` can still be `$null`.

The foreach started working this way with PowerShell 3.0. If you happen to be on an older version,
then this is not the case. This is one of the important changes to be aware of when back-porting
code for 2.0 compatibility.

## Value types

Technically, only reference types can be `$null`. But PowerShell is very generous and allows for
variables to be any type. If you decide to strongly type a value type, it cannot be `$null`.
PowerShell converts `$null` to a default value for many types.

```powershell
PS> [int]$number = $null
PS> $number
0

PS> [bool]$boolean = $null
PS> $boolean
False

PS> [string]$string = $null
PS> $string -eq ''
True
```

There are some types that do not have a valid conversion from `$null`. These types generate a
`Cannot convert null to type` error.

```powershell
PS> [datetime]$date = $null
Cannot convert null to type "System.DateTime".
At line:1 char:1
+ [datetime]$date = $null
+ ~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException
    + FullyQualifiedErrorId : RuntimeException
```

### Function parameters

Using a strongly typed values in function parameters is very common. We generally learn to define
the types of our parameters even if we tend not to define the types of other variables in our
scripts. You may already have some strongly typed variables in your functions and not even realize
it.

```powershell
function Do-Something
{
    param(
        [String] $Value
    )
}
```

As soon as you set the type of the parameter as a `string`, the value can never be `$null`. It's
common to check if a value is `$null` to see if the user provided a value or not.

```powershell
if ( $null -ne $Value ){...}
```

`$Value` is an empty string `''` when no value is provided. Use the automatic variable
`$PSBoundParameters.Value` instead.

```powershell
if ( $null -ne $PSBoundParameters.Value ){...}
```

`$PSBoundParameters` only contains the parameters that were specified when the function was called.
You can also use the `ContainsKey` method to check for the property.

```powershell
if ( $PSBoundParameters.ContainsKey('Value') ){...}
```

### IsNotNullOrEmpty

If the value is a string, you can use a static string function to check if the value is `$null` or
an empty string at the same time.

```powershell
if ( -not [string]::IsNullOrEmpty( $value ) ){...}
```

I find myself using this often when I know the value type should be a string.

## When I $null check

I am a defensive scripter. Anytime I call a function and assign it to a variable, I check it for
`$null`.

```powershell
$userList = Get-ADUser kevmar
if ($null -ne $userList){...}
```

I much prefer using `if` or `foreach` over using `try/catch`. Don't get me wrong, I still use
`try/catch` a lot. But if I can test for an error condition or an empty set of results, I can allow
my exception handling be for true exceptions.

I also tend to check for `$null` before I index into a value or call methods on an object. These two
actions fail for a `$null` object so I find it important to validate them first. I already covered
those scenarios earlier in this post.

### No results scenario

It's important to know that different functions and commands handle the no results scenario
differently. Many PowerShell commands return the empty `$null` and an error in the error stream. But
others throw exceptions or give you a status object. It's still up to you to know how the commands
you use deal with the no results and error scenarios.

## Initializing to $null

One habit that I have picked up is initializing all my variables before I use them. You are required
to do this in other languages. At the top of my function or as I enter a foreach loop, I define all
the values that I'm using.

Here is a scenario that I want you to take a close look at. It's an example of a bug I had to chase
down before.

```powershell
function Do-Something
{
    foreach ( $node in 1..6 )
    {
        try
        {
            $result = Get-Something -ID $node
        }
        catch
        {
            Write-Verbose "[$result] not valid"
        }

        if ( $null -ne $result )
        {
            Update-Something $result
        }
    }
}
```

The expectation here is that `Get-Something` returns either a result or an empty `$null`. If there
is an error, we log it. Then we check to make sure we got a valid result before processing it.

The bug hiding in this code is when `Get-Something` throws an exception and doesn't assign a value
to `$result`. It fails before the assignment so we don't even assign `$null` to the `$result`
variable. `$result` still contains the previous valid `$result` from other iterations.
`Update-Something` to execute multiple times on the same object in this example.

I set `$result` to `$null` right inside the foreach loop before I use it to mitigate this issue.

```powershell
foreach ( $node in 1..6 )
{
    $result = $null
    try
    {
        ...
```

### Scope issues

This also helps mitigate scoping issues. In that example, we assign values to `$result` over and
over in a loop. But because PowerShell allows variable values from outside the function to bleed
into the scope of the current function, initializing them inside your function mitigates bugs
that can be introduced that way.

An uninitialized variable in your function is not `$null` if it's set to a value in a parent scope.
The parent scope could be another function that calls your function and uses the same variable
names.

If I take that same `Do-something` example and remove the loop, I would end up with something that
looks like this example:

```powershell
function Invoke-Something
{
    $result = 'ParentScope'
    Do-Something
}

function Do-Something
{
    try
    {
        $result = Get-Something -ID $node
    }
    catch
    {
        Write-Verbose "[$result] not valid"
    }

    if ( $null -ne $result )
    {
        Update-Something $result
    }
}
```

If the call to `Get-Something` throws an exception, then my `$null` check finds the `$result` from
`Invoke-Something`. Initializing the value inside your function mitigates this issue.

Naming variables is hard and it's common for an author to use the same variable names in multiple
functions. I know I use `$node`,`$result`,`$data` all the time. So it would be very easy for values
from different scopes to show up in places where they should not be.

## Redirect output to $null

I have been talking about `$null` values for this entire article but the topic is not complete if I
didn't mention redirecting output to `$null`. There are times when you have commands that output
information or objects that you want to suppress. Redirecting output to `$null` does that.

### Out-Null

The Out-Null command is the built-in way to redirect pipeline data to `$null`.

```powershell
New-Item -Type Directory -Path $path | Out-Null
```

### Assign to $null

You can assign the results of a command to `$null` for the same effect as using `Out-Null`.

```powershell
$null = New-Item -Type Directory -Path $path
```

Because `$null` is a constant value, you can never overwrite it. I don't like the way it looks in my
code but it often performs faster than `Out-Null`.

### Redirect to $null

You can also use the redirection operator to send output to `$null`.

```powershell
New-Item -Type Directory -Path $path > $null
```

If you're dealing with command-line executables that output on the different streams. You can
redirect all output streams to `$null` like this:

```powershell
git status *> $null
```

## Summary

I covered a lot of ground on this one and I know this article is more fragmented than most of my
deep dives. That is because `$null` values can pop up in many different places in PowerShell and all
the nuances are specific to where you find it. I hope you walk away from this with a better
understanding of `$null` and an awareness of the more obscure scenarios you may run into.

<!-- link references -->
[original version]: https://powershellexplained.com/2018-12-23-Powershell-null-everything-you-wanted-to-know/
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[good post]: https://blog.iisreset.me/schrodingers-argumentlist
[PSScriptAnalyzer]: https://www.powershellgallery.com/packages/PSScriptAnalyzer
[System.Management.Automation.Internal.AutomationNull]: https://learn.microsoft.com/dotnet/api/system.management.automation.internal.automationnull

# /./reference/learn/deep-dives/everything-about-shouldprocess.md

    ---
    description: ShouldProcess is an important feature that is often overlooked is. The WhatIf and Confirm parameters make it easy to add to your functions.
    ms.custom: contributor-KevinMarquette
    ms.date: 11/16/2022
    title: Everything you wanted to know about ShouldProcess
    ---
# Everything you wanted to know about ShouldProcess

PowerShell functions have several features that greatly improve the way users interact with them.
One important feature that is often overlooked is `-WhatIf` and `-Confirm` support and it's easy to
add to your functions. In this article, we dive deep into how to implement this feature.

> [!NOTE]
> The [original version][original version] of this article appeared on the blog written by [@KevinMarquette][@KevinMarquette]. The
> PowerShell team thanks Kevin for sharing this content with us. Please check out his blog at
> [PowerShellExplained.com][PowerShellExplained.com].

This is a simple feature you can enable in your functions to provide a safety net for the users that
need it. There's nothing scarier than running a command that you know can be dangerous for the
first time. The option to run it with `-WhatIf` can make a big difference.

## CommonParameters

Before we look at implementing these [common parameters][common parameters], I want to take a quick look at how
they're used.

## Using -WhatIf

When a command supports the `-WhatIf` parameter, it allows you to see what the command would have
done instead of making changes. it's a good way to test out the impact of a command, especially
before you do something destructive.

```powershell
PS C:\temp> Get-ChildItem
    Directory: C:\temp
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         4/19/2021   8:59 AM              0 importantfile.txt
-a----         4/19/2021   8:58 AM              0 myfile1.txt
-a----         4/19/2021   8:59 AM              0 myfile2.txt

PS C:\temp> Remove-Item -Path .\myfile1.txt -WhatIf
What if: Performing the operation "Remove File" on target "C:\Temp\myfile1.txt".
```

If the command correctly implements `ShouldProcess`, it should show you all the changes that it
would have made. Here is an example using a wildcard to delete multiple files.

```powershell
PS C:\temp> Remove-Item -Path * -WhatIf
What if: Performing the operation "Remove File" on target "C:\Temp\myfile1.txt".
What if: Performing the operation "Remove File" on target "C:\Temp\myfile2.txt".
What if: Performing the operation "Remove File" on target "C:\Temp\importantfile.txt".
```

## Using -Confirm

Commands that support `-WhatIf` also support `-Confirm`. This gives you a chance confirm an action
before performing it.

```powershell
PS C:\temp> Remove-Item .\myfile1.txt -Confirm

Confirm
Are you sure you want to perform this action?
Performing the operation "Remove File" on target "C:\Temp\myfile1.txt".
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "Y"):
```

In this case, you have multiple options that allow you to continue, skip a change, or stop the
script. The help prompt describes each of those options like this.

```Output
Y - Continue with only the next step of the operation.
A - Continue with all the steps of the operation.
N - Skip this operation and proceed with the next operation.
L - Skip this operation and all subsequent operations.
S - Pause the current pipeline and return to the command prompt. Type "exit" to resume the pipeline.
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "Y"):
```

### Localization

This prompt is localized in PowerShell so the language changes based on the language of your
operating system. This is one more thing that PowerShell manages for you.

### Switch parameters

Let's take quick moment to look at ways to pass a value to a switch parameter. The main reason I
call this out is that you often want to pass parameter values to functions you call.

The first approach is a specific parameter syntax that can be used for all parameters but you mostly
see it used for switch parameters. You specify a colon to attach a value to the parameter.

```powershell
Remove-Item -Path:* -WhatIf:$true
```

You can do the same with a variable.

```powershell
$DoWhatIf = $true
Remove-Item -Path * -WhatIf:$DoWhatIf
```

The second approach is to use a hashtable to splat the value.

```powershell
$RemoveSplat = @{
    Path = '*'
    WhatIf = $true
}
Remove-Item @RemoveSplat
```

If you're new to hashtables or splatting, I have another article on that covers
[everything you wanted to know about hashtables][everything you wanted to know about hashtables].

## SupportsShouldProcess

The first step to enable `-WhatIf` and `-Confirm` support is to specify `SupportsShouldProcess` in
the `CmdletBinding` of your function.

```powershell
function Test-ShouldProcess {
    [CmdletBinding(SupportsShouldProcess)]
    param()
    Remove-Item .\myfile1.txt
}
```

By specifying `SupportsShouldProcess` in this way, we can now call our function with `-WhatIf` (or
`-Confirm`).

```powershell
PS> Test-ShouldProcess -WhatIf
What if: Performing the operation "Remove File" on target "C:\Temp\myfile1.txt".
```

Notice that I did not create a parameter called `-WhatIf`. Specifying `SupportsShouldProcess`
automatically creates it for us. When we specify the `-WhatIf` parameter on `Test-ShouldProcess`,
some things we call also perform `-WhatIf` processing.

### Trust but verify

There's some danger here trusting that everything you call inherits `-WhatIf` values. For the rest
of the examples, I'm going to assume that it doesn't work and be very explicit when making calls
to other commands. I recommend that you do the same.

```powershell
function Test-ShouldProcess {
    [CmdletBinding(SupportsShouldProcess)]
    param()
    Remove-Item .\myfile1.txt -WhatIf:$WhatIfPreference
}
```

I will revisit the nuances much later once you have a better understanding of all the pieces in
play.

## $PSCmdlet.ShouldProcess

The method that allows you to implement `SupportsShouldProcess` is `$PSCmdlet.ShouldProcess`. You
call `$PSCmdlet.ShouldProcess(...)` to see if you should process some logic and PowerShell takes
care of the rest. Let's start with an example:

```powershell
function Test-ShouldProcess {
    [CmdletBinding(SupportsShouldProcess)]
    param()

    $file = Get-ChildItem './myfile1.txt'
    if($PSCmdlet.ShouldProcess($file.Name)){
        $file.Delete()
    }
}
```

The call to `$PSCmdlet.ShouldProcess($file.name)` checks for the `-WhatIf` (and `-Confirm`
parameter) then handles it accordingly. The `-WhatIf` causes `ShouldProcess` to output a
description of the change and return `$false`:

```powershell
PS> Test-ShouldProcess -WhatIf
What if: Performing the operation "Test-ShouldProcess" on target "myfile1.txt".
```

A call using `-Confirm` pauses the script and prompts the user with the option to continue. It
returns `$true` if the user selected `Y`.

```powershell
PS> Test-ShouldProcess -Confirm
Confirm
Are you sure you want to perform this action?
Performing the operation "Test-ShouldProcess" on target "myfile1.txt".
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "Y"):
```

An awesome feature of `$PSCmdlet.ShouldProcess` is that it doubles as verbose output. I depend on
this often when implementing `ShouldProcess`.

```powershell
PS> Test-ShouldProcess -Verbose
VERBOSE: Performing the operation "Test-ShouldProcess" on target "myfile1.txt".
```

### Overloads

There are a few different overloads for `$PSCmdlet.ShouldProcess` with different parameters for
customizing the messaging. We already saw the first one in the example above. Let's take a closer
look at it.

```powershell
function Test-ShouldProcess {
    [CmdletBinding(SupportsShouldProcess)]
    param()

    if($PSCmdlet.ShouldProcess('TARGET')){
        # ...
    }
}
```

This produces output that includes both the function name and the target (value of the parameter).

```powershell
What if: Performing the operation "Test-ShouldProcess" on target "TARGET".
```

Specifying a second parameter as the operation uses the operation value instead of the function
name in the message.

```powershell
## $PSCmdlet.ShouldProcess('TARGET','OPERATION')
What if: Performing the operation "OPERATION" on target "TARGET".
```

The next option is to specify three parameters to fully customize the message. When three parameters
are used, the first one is the entire message. The second two parameters are still used in the
`-Confirm` message output.

```powershell
## $PSCmdlet.ShouldProcess('MESSAGE','TARGET','OPERATION')
What if: MESSAGE
```

### Quick parameter reference

Just in case you came here only to figure out what parameters you should use, here is a quick
reference showing how the parameters change the message in the different `-WhatIf` scenarios.

```powershell
## $PSCmdlet.ShouldProcess('TARGET')
What if: Performing the operation "FUNCTION_NAME" on target "TARGET".

## $PSCmdlet.ShouldProcess('TARGET','OPERATION')
What if: Performing the operation "OPERATION" on target "TARGET".

## $PSCmdlet.ShouldProcess('MESSAGE','TARGET','OPERATION')
What if: MESSAGE
```

I tend to use the one with two parameters.

### ShouldProcessReason

We have a fourth overload that's more advanced than the others. It allows you to get the reason
`ShouldProcess` was executed. I'm only adding this here for completeness because we can just check
if `$WhatIfPreference` is `$true` instead.

```powershell
$reason = ''
if($PSCmdlet.ShouldProcess('MESSAGE','TARGET','OPERATION',[ref]$reason)){
    Write-Output "Some Action"
}
$reason
```

We have to pass the `$reason` variable into the fourth parameter as a reference variable with
`[ref]`. `ShouldProcess` populates `$reason` with the value `None` or `WhatIf`. I didn't say this
was useful and I have had no reason to ever use it.

### Where to place it

You use `ShouldProcess` to make your scripts safer. So you use it when your scripts are making
changes. I like to place the `$PSCmdlet.ShouldProcess` call as close to the change as possible.

```powershell
## general logic and variable work
if ($PSCmdlet.ShouldProcess('TARGET','OPERATION')){
    # Change goes here
}
```

If I'm processing a collection of items, I call it for each item. So the call gets placed inside
the foreach loop.

```powershell
foreach ($node in $collection){
    # general logic and variable work
    if ($PSCmdlet.ShouldProcess($node,'OPERATION')){
        # Change goes here
    }
}
```

The reason why I place `ShouldProcess` tightly around the change, is that I want as much code to
execute as possible when `-WhatIf` is specified. I want the setup and validation to run if possible
so the user gets to see those errors.

I also like to use this in my Pester tests that validate my projects. If I have a piece of logic
that is hard to mock in pester, I can often wrap it in `ShouldProcess` and call it with `-WhatIf` in
my tests. It's better to test some of your code than none of it.

### $WhatIfPreference

The first preference variable we have is `$WhatIfPreference`. This is `$false` by default. If you
set it to `$true` then your function executes as if you specified `-WhatIf`. If you set this in
your session, all commands perform `-WhatIf` execution.

When you call a function with `-WhatIf`, the value of `$WhatIfPreference` gets set to `$true` inside
the scope of your function.

## ConfirmImpact

Most of my examples are for `-WhatIf` but everything so far also works with `-Confirm` to prompt the
user. You can set the `ConfirmImpact` of the function to high and it prompts the user as if it was
called with `-Confirm`.

```powershell
function Test-ShouldProcess {
    [CmdletBinding(
        SupportsShouldProcess,
        ConfirmImpact = 'High'
    )]
    param()

    if ($PSCmdlet.ShouldProcess('TARGET')){
        Write-Output "Some Action"
    }
}
```

This call to `Test-ShouldProcess` is performing the `-Confirm` action because of the `High` impact.

```powershell
PS> Test-ShouldProcess

Confirm
Are you sure you want to perform this action?
Performing the operation "Test-ShouldProcess" on target "TARGET".
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "Y"): y
Some Action
```

The obvious issue is that now it's harder to use in other scripts without prompting the user. In
this case, we can pass a `$false` to `-Confirm` to suppress the prompt.

```powershell
PS> Test-ShouldProcess -Confirm:$false
Some Action
```

I'll cover how to add `-Force` support in a later section.

### $ConfirmPreference

`$ConfirmPreference` is an automatic variable that controls when `ConfirmImpact` asks you to
confirm execution. Here are the possible values for both `$ConfirmPreference` and `ConfirmImpact`.

- `High`
- `Medium`
- `Low`
- `None`

With these values, you can specify different levels of impact for each function. If you have
`$ConfirmPreference` set to a value higher than `ConfirmImpact`, then you aren't prompted to
confirm execution.

By default, `$ConfirmPreference` is set to `High` and `ConfirmImpact` is `Medium`. If you want your
function to automatically prompt the user, set your `ConfirmImpact` to `High`. Otherwise set it to
`Medium` if its destructive and use `Low` if the command is always safe run in production. If you
set it to `none`, it doesn't prompt even if `-Confirm` was specified (but it still gives you
`-WhatIf` support).

When calling a function with `-Confirm`, the value of `$ConfirmPreference` gets set to `Low` inside
the scope of your function.

### Suppressing nested confirm prompts

The `$ConfirmPreference` can get picked up by functions that you call. This can create scenarios
where you add a confirm prompt and the function you call also prompts the user.

What I tend to do is specify `-Confirm:$false` on the commands that I call when I have already
handled the prompting.

```powershell
function Test-ShouldProcess {
    [CmdletBinding(SupportsShouldProcess)]
    param()

    $file = Get-ChildItem './myfile1.txt'
    if($PSCmdlet.ShouldProcess($file.Name)){
        Remove-Item -Path $file.FullName -Confirm:$false
    }
}
```

This brings us back to an earlier warning: There are nuances as to when `-WhatIf` is not passed to a
function and when `-Confirm` passes to a function. I promise I'll get back to this later.

## $PSCmdlet.ShouldContinue

If you need more control than `ShouldProcess` provides, you can trigger the prompt directly with
`ShouldContinue`. `ShouldContinue` ignores `$ConfirmPreference`, `ConfirmImpact`, `-Confirm`,
`$WhatIfPreference`, and `-WhatIf` because it prompts every time it's executed.

At a quick glance, it's easy to confuse `ShouldProcess` and `ShouldContinue`. I tend to remember to
use `ShouldProcess` because the parameter is called `SupportsShouldProcess` in the `CmdletBinding`.
You should use `ShouldProcess` in almost every scenario. That is why I covered that method first.

Let's take a look at `ShouldContinue` in action.

```powershell
function Test-ShouldContinue {
    [CmdletBinding()]
    param()

    if($PSCmdlet.ShouldContinue('TARGET','OPERATION')){
        Write-Output "Some Action"
    }
}
```

This provides us a simpler prompt with fewer options.

```powershell
Test-ShouldContinue

Second
TARGET
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"):
```

The biggest issue with `ShouldContinue` is that it requires the user to run it interactively because
it always prompts the user. You should always be building tools that can be used by other
scripts. The way you do this is by implementing `-Force`. I'll revisit this idea later.

### Yes to all

This is automatically handled with `ShouldProcess` but we have to do a little more work for
`ShouldContinue`. There's a second method overload where we have to pass in a few values by
reference to control the logic.

```powershell
function Test-ShouldContinue {
    [CmdletBinding()]
    param()

    $collection = 1..5
    $yesToAll = $false
    $noToAll = $false

    foreach($target in $collection) {

        $continue = $PSCmdlet.ShouldContinue(
                "TARGET_$target",
                'OPERATION',
                [ref]$yesToAll,
                [ref]$noToAll
            )

        if ($continue){
            Write-Output "Some Action [$target]"
        }
    }
}
```

I added a `foreach` loop and a collection to show it in action. I pulled the `ShouldContinue` call
out of the `if` statement to make it easier to read. Calling a method with four parameters starts to
get a little ugly, but I tried to make it look as clean as I could.

## Implementing -Force

`ShouldProcess` and `ShouldContinue` need to implement `-Force` in different ways. The trick to
these implementations is that `ShouldProcess` should always get executed, but `ShouldContinue`
should not get executed if `-Force` is specified.

### ShouldProcess -Force

If you set your `ConfirmImpact` to `high`, the first thing your users are going to try is to
suppress it with `-Force`. That's the first thing I do anyway.

```powershell
Test-ShouldProcess -Force
Error: Test-ShouldProcess: A parameter cannot be found that matches parameter name 'force'.
```

If you recall from the `ConfirmImpact` section, they actually need to call it like this:

```powershell
Test-ShouldProcess -Confirm:$false
```

Not everyone realizes they need to do that and `-Force` doesn't suppress `ShouldContinue`.
So we should implement `-Force` for the sanity of our users. Take a look at this full example here:

```powershell
function Test-ShouldProcess {
    [CmdletBinding(
        SupportsShouldProcess,
        ConfirmImpact = 'High'
    )]
    param(
        [Switch]$Force
    )

    if ($Force -and -not $Confirm){
        $ConfirmPreference = 'None'
    }

    if ($PSCmdlet.ShouldProcess('TARGET')){
        Write-Output "Some Action"
    }
}
```

We add our own `-Force` switch as a parameter. The `-Confirm` parameter is automatically added
when using `SupportsShouldProcess` in the `CmdletBinding`.

```powershell
[CmdletBinding(
    SupportsShouldProcess,
    ConfirmImpact = 'High'
)]
param(
    [Switch]$Force
)
```

Focusing in on the `-Force` logic here:

```powershell
if ($Force -and -not $Confirm){
    $ConfirmPreference = 'None'
}
```

If the user specifies `-Force`, we want to suppress the confirm prompt unless they also specify
`-Confirm`. This allows a user to force a change but still confirm the change. Then we set
`$ConfirmPreference` in the local scope. Now, using the `-Force` parameter temporarily sets the
`$ConfirmPreference` to none, disabling prompt for confirmation.

```powershell
if ($PSCmdlet.ShouldProcess('TARGET')){
        Write-Output "Some Action"
    }
```

If someone specifies both `-Force` and `-WhatIf`, then `-WhatIf` needs to take priority. This
approach preserves `-WhatIf` processing because `ShouldProcess` always gets executed.

Do not add a check for the `$Force` value inside the `if` statement with the `ShouldProcess`. That is
an anti-pattern for this specific scenario even though that's what I show you in the next section
for `ShouldContinue`.

### ShouldContinue -Force

This is the correct way to implement `-Force` with `ShouldContinue`.

```powershell
function Test-ShouldContinue {
    [CmdletBinding()]
    param(
        [Switch]$Force
    )

    if($Force -or $PSCmdlet.ShouldContinue('TARGET','OPERATION')){
        Write-Output "Some Action"
    }
}
```

By placing the `$Force` to the left of the `-or` operator, it gets evaluated first. Writing it
this way short circuits the execution of the `if` statement. If `$force` is `$true`, then the
`ShouldContinue` is not executed.

```powershell
PS> Test-ShouldContinue -Force
Some Action
```

We don't have to worry about `-Confirm` or `-WhatIf` in this scenario because they're not supported
by `ShouldContinue`. This is why it needs to be handled differently than `ShouldProcess`.

## Scope issues

Using `-WhatIf` and `-Confirm` are supposed to apply to everything inside your functions and
everything they call. They do this by setting `$WhatIfPreference` to `$true` or setting
`$ConfirmPreference` to `Low` in the local scope of the function. When you call another function,
calls to `ShouldProcess` use those values.

This actually works correctly most of the time. Anytime you call built-in cmdlet or a function in
your same scope, it works. It also works when you call a script or a function in a script module
from the console.

The one specific place where it doesn't work is when a script or a script module calls a function in
another script module. This may not sound like a big problem, but most of the modules you create or
pull from the PSGallery are script modules.

The core issue is that script modules do not inherit the values for `$WhatIfPreference` or
`$ConfirmPreference` (and several others) when called from functions in other script modules.

The best way to summarize this as a general rule is that this works correctly for binary modules and
never trust it to work for script modules. If you aren't sure, either test it or just assume it
doesn't work correctly.

I personally feel this is very dangerous because it creates scenarios where you add `-WhatIf`
support to multiple modules that work correctly in isolation, but fail to work correctly when they
call each other.

We do have a GitHub RFC working to get this issue fixed. See
[Propagate execution preferences beyond script module scope][RFC] for more details.

## In closing

I have to look up how to use `ShouldProcess` every time I need to use it. It took me a long time to
distinguish `ShouldProcess` from `ShouldContinue`. I almost always need to look up what parameters
to use. So don't worry if you still get confused from time to time. This article will be here when
you need it. I'm sure I will reference it often myself.

If you liked this post, please share your thoughts with me on Twitter using the link below. I always
like hearing from people that get value from my content.

<!-- link references -->
[original version]: https://powershellexplained.com/2020-03-15-Powershell-shouldprocess-whatif-confirm-shouldcontinue-everything/
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[common parameters]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_commonparameters
[everything you wanted to know about hashtables]: everything-about-hashtable.md
[RFC]: https://github.com/PowerShell/PowerShell-RFC/pull/221#issuecomment-592954839

# /./reference/learn/deep-dives/write-progress-across-multiple-threads.md

    ---
    description: How to use Write-Progress across multiple threads with Foreach-Object -Parallel
    ms.date: 11/16/2022
    title: Displaying progress while multi-threading
    ---

# Writing Progress across multiple threads with Foreach Parallel

Starting in PowerShell 7.0, the ability to work in multiple threads simultaneously is possible using
the **Parallel** parameter in the
[Foreach-Object](/powershell/module/Microsoft.PowerShell.Core/Foreach-Object) cmdlet. Monitoring the
progress of these threads can be a challenge though. Normally, you can monitor the progress of a
process using [Write-Progress](/powershell/module/Microsoft.PowerShell.Utility/Write-Progress).
However, since PowerShell uses a separate runspace for each thread when using **Parallel**,
reporting the progress back to the host isn't as straight forward as normal use of `Write-Progress`.

## Using a synced hashtable to track progress

When writing the progress from multiple threads, tracking becomes difficult because when running
parallel processes in PowerShell, each process has it's own runspace. To get around this, you can
use a [synchronized hashtable](/dotnet/api/system.collections.hashtable.synchronized). A synced
hashtable is a thread safe data structure that can be modified by multiple threads simultaneously
without throwing an error.

### Set up

One of the downsides to this approach is it takes a, somewhat, complex set up to ensure everything
runs without error.

```powershell
$dataset = @(
    @{
        Id   = 1
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 2
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 3
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 4
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 5
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
)

# Create a hashtable for process.
# Keys should be ID's of the processes
$origin = @{}
$dataset | Foreach-Object {$origin.($_.id) = @{}}

# Create synced hashtable
$sync = [System.Collections.Hashtable]::Synchronized($origin)
```

This section creates three different data structures, for three different purposes.

The `$dataSet` variable stores an array of hashtables that is used to coordinate the next steps
without the risk of being modified. If an object collection is modified while iterating through the
collection, PowerShell throws an error. You must keep the object collection in the loop separate
from the objects being modified. The `Id` key in each hashtable is the identifier for a mock
process. The `Wait` key simulates the workload of each mock process being tracked.

The `$origin` variable stores a nested hashtable with each key being one of the mock process id's.
Then, it is used to hydrate the synchronized hashtable stored in the `$sync` variable. The `$sync`
variable is responsible for reporting the progress back to the parent runspace, which displays the
progress.

### Running the processes

This section runs the multi-threaded processes and creates some of the output used to display
progress.

```powershell
$job = $dataset | Foreach-Object -ThrottleLimit 3 -AsJob -Parallel {
    $syncCopy = $using:sync
    $process = $syncCopy.$($PSItem.Id)

    $process.Id = $PSItem.Id
    $process.Activity = "Id $($PSItem.Id) starting"
    $process.Status = "Processing"

    # Fake workload start up that takes x amount of time to complete
    start-sleep -Milliseconds ($PSItem.wait*5)

    # Process. update activity
    $process.Activity = "Id $($PSItem.id) processing"
    foreach ($percent in 1..100)
    {
        # Update process on status
        $process.Status = "Handling $percent/100"
        $process.PercentComplete = (($percent / 100) * 100)

        # Fake workload that takes x amount of time to complete
        Start-Sleep -Milliseconds $PSItem.Wait
    }

    # Mark process as completed
    $process.Completed = $true
}
```

The mock processes are sent to `Foreach-Object` and started as jobs. The **ThrottleLimit** is set to
**3** to highlight running multiple processes in a queue. The jobs are stored in the `$job` variable
and allows us to know when all the processes have finished later on.

When using the `using:` statement to reference a parent scope variable in PowerShell, you can't use
expressions to make it dynamic. For example, if you tried to create the `$process` variable like
this, `$process = $using:sync.$($PSItem.id)`, you would get an error stating you can't use
expressions there. So, we create the `$syncCopy` variable to be able to reference and modify the
`$sync` variable without the risk of it failing.

Next, we build out a hashtable to represent the progress of the process currently in the loop using
the `$process` variable by referencing the synchronized hashtable keys. The **Activity** and the
**Status** keys are used as parameter values for `Write-Progress` to display the status of a given
mock process in the next section.

The `foreach` loop is just a way to simulate the process working and is randomized based on the
`$dataSet` **Wait** attribute to set `Start-Sleep` using milliseconds. How you calculate the
progress of your process may vary.

### Displaying the progress of multiple processes

Now that the mock processes are running as jobs, we can start to write the processes progress to the
PowerShell window.

```powershell
while($job.State -eq 'Running')
{
    $sync.Keys | Foreach-Object {
        # If key is not defined, ignore
        if(![string]::IsNullOrEmpty($sync.$_.keys))
        {
            # Create parameter hashtable to splat
            $param = $sync.$_

            # Execute Write-Progress
            Write-Progress @param
        }
    }

    # Wait to refresh to not overload gui
    Start-Sleep -Seconds 0.1
}
```

The `$job` variable contains the parent **job** and has a child **job** for each of the mock
processes. While any of the child jobs are still running, the parent job **State** will remain
"Running". This allows us to use the `while` loop to continually update the progress of
every process until all processes are finished.

Within the while loop, we loop through each of the keys in the `$sync` variable. Since this is
a synchronized hashtable, it is constantly updated but can still be accessed without throwing any
errors.

There is a check to ensure that the process being reported is actually running using the
`IsNullOrEmpty()` method. If the process hasn't been started, the loop won't report on it and move
on to the next until it gets to a process that has been started. If the process is started, the
hashtable from the current key is used to splat the parameters to `Write-Progress`.

### Full example

```powershell
# Example workload
$dataset = @(
    @{
        Id   = 1
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 2
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 3
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 4
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
    @{
        Id   = 5
        Wait = 3..10 | get-random | Foreach-Object {$_*100}
    }
)

# Create a hashtable for process.
# Keys should be ID's of the processes
$origin = @{}
$dataset | Foreach-Object {$origin.($_.id) = @{}}

# Create synced hashtable
$sync = [System.Collections.Hashtable]::Synchronized($origin)

$job = $dataset | Foreach-Object -ThrottleLimit 3 -AsJob -Parallel {
    $syncCopy = $using:sync
    $process = $syncCopy.$($PSItem.Id)

    $process.Id = $PSItem.Id
    $process.Activity = "Id $($PSItem.Id) starting"
    $process.Status = "Processing"

    # Fake workload start up that takes x amount of time to complete
    start-sleep -Milliseconds ($PSItem.wait*5)

    # Process. update activity
    $process.Activity = "Id $($PSItem.id) processing"
    foreach ($percent in 1..100)
    {
        # Update process on status
        $process.Status = "Handling $percent/100"
        $process.PercentComplete = (($percent / 100) * 100)

        # Fake workload that takes x amount of time to complete
        Start-Sleep -Milliseconds $PSItem.Wait
    }

    # Mark process as completed
    $process.Completed = $true
}

while($job.State -eq 'Running')
{
    $sync.Keys | Foreach-Object {
        # If key is not defined, ignore
        if(![string]::IsNullOrEmpty($sync.$_.keys))
        {
            # Create parameter hashtable to splat
            $param = $sync.$_

            # Execute Write-Progress
            Write-Progress @param
        }
    }

    # Wait to refresh to not overload gui
    Start-Sleep -Seconds 0.1
}
```

## Related Links

- [about_Jobs](/powershell/module/Microsoft.PowerShell.Core/About/about_Jobs)
- [about_Scopes](/powershell/module/Microsoft.PowerShell.Core/About/about_Scopes)
- [about_Splatting](/powershell/module/Microsoft.PowerShell.Core/About/about_Splatting)

# /./reference/learn/deep-dives/add-credentials-to-powershell-functions.md

    ---
    description: How to add credential parameters to your PowerShell scripts, functions, and cmdlets.
    ms.custom: contributor-JoshDuffney
    ms.date: 11/16/2022
    title: Add Credential support to PowerShell functions
    ---
# Add Credential support to PowerShell functions

> [!NOTE]
> The [original version][original version] of this article appeared on the blog written by [@joshduffney][@joshduffney]. This
> article has been edited for inclusion on this site. The PowerShell team thanks Josh for sharing
> this content with us. Please check out his blog at [duffney.io][duffney.io].

This article shows you how to add credential parameters to PowerShell functions and why you'd want
to. A credential parameter is to allow you to run the function or cmdlet as a different user. The
most common use is to run the function or cmdlet as an elevated user account.

For example, the cmdlet `New-ADUser` has a **Credential** parameter, which you could provide domain
admin credentials to create an account in a domain. Assuming your normal account running the
PowerShell session doesn't have that access already.

## Creating credential object

The [PSCredential][PSCredential] object represents a set of security credentials such as a user name and
password. The object can be passed as a parameter to a function that runs as the user account in
that credential object. There are a few ways that you can create a credential object. The first way
to create a credential object is to use the PowerShell cmdlet `Get-Credential`. When you run without
parameters, it prompts you for a username and password. Or you can call the cmdlet with some
optional parameters.

To specify the domain name and username ahead of time you can use either the **Credential** or
**UserName** parameters. When you use the **UserName** parameter, you're also required to provide a
**Message** value. The code below demonstrates using the cmdlet. You can also store the credential
object in a variable so that you can use the credential multiple times. In the example below, the
credential object is stored in the variable `$Cred`.

```powershell
$Cred = Get-Credential
$Cred = Get-Credential -Credential domain\user
$Cred = Get-Credential -UserName domain\user -Message 'Enter Password'
```

Sometimes, you can't use the interactive method of creating credential objects shown in the previous
example. Most automation tools require a non-interactive method. To create a credential without user
interaction, create a secure string containing the password. Then pass the secure string and user
name to the `System.Management.Automation.PSCredential()` method.

Use the following command to create a secure string containing the password:

```powershell
ConvertTo-SecureString "MyPlainTextPassword" -AsPlainText -Force
```

Both the **AsPlainText** and **Force** parameters are required. Without those parameters, you
receive a message warning that you shouldn't pass plain text into a secure string. PowerShell
returns this warning because the plain text password gets recorded in various logs. Once you have a
secure string created, you need to pass it to the `PSCredential()` method to create the credential
object. In the following example, the variable `$password` contains the secure string `$Cred`
contains the credential object.

```powershell
$password = ConvertTo-SecureString "MyPlainTextPassword" -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential ("username", $password)
```

Now that you know how to create credential objects, you can add credential parameters to your
PowerShell functions.

## Adding a Credential Parameter

Just like any other parameter, you start off by adding it in the `param` block of your function.
It's recommended that you name the parameter `$Credential` because that's what existing PowerShell
cmdlets use. The type of the parameter should be `[System.Management.Automation.PSCredential]`.

The following example shows the parameter block for a function called `Get-Something`. It has two
parameters: `$Name` and `$Credential`.

```powershell
function Get-Something {
    param(
        $Name,
        [System.Management.Automation.PSCredential]$Credential
    )
```

The code in this example is enough to have a working credential parameter, however there are a few
things you can add to make it more robust.

- Add the `[ValidateNotNull()]` validation attribute to check that the value being passed to
  **Credential**. If the parameter value is null, this attribute prevents the function from
  executing with invalid credentials.

- Add `[System.Management.Automation.Credential()]`. This allows you to pass in a username as a
  string and have an interactive prompt for the password.

- Set a default value for the `$Credential` parameter to
  `[System.Management.Automation.PSCredential]::Empty`. Your function you might be passing this
  `$Credential` object to existing PowerShell cmdlets. Providing a null value to the cmdlet called
  inside your function causes an error. Providing an empty credential object avoids this error.

> [!TIP]
> Some cmdlets that accept a credential parameter do not support
> `[System.Management.Automation.PSCredential]::Empty` as they should. See the
> [Dealing with Legacy Cmdlets](#dealing-with-legacy-cmdlets) section for a workaround.

## Using credential parameters

The following example demonstrates how to use credential parameters. This example shows a function
called `Set-RemoteRegistryValue`, which is out of [The Pester Book][The Pester Book]. This function defines the
credential parameter using the techniques describe in the previous section. The function calls
`Invoke-Command` using the `$Credential` variable created by the function. This allows you to change
the user who's running `Invoke-Command`. Because the default value of `$Credential` is an empty
credential, the function can run without providing credentials.

```powershell
function Set-RemoteRegistryValue {
    param(
        $ComputerName,
        $Path,
        $Name,
        $Value,
        [ValidateNotNull()]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty
    )
        $null = Invoke-Command -ComputerName $ComputerName -ScriptBlock {
            Set-ItemProperty -Path $using:Path -Name $using:Name -Value $using:Value
        } -Credential $Credential
}
```

The following sections show different methods of providing credentials to `Set-RemoteRegistryValue`.

### Prompting for credentials

Using `Get-Credential` in parentheses `()` at run time causes the `Get-credential` to run first. You
are prompted for a username and password. You could use the **Credential** or **UserName**
parameters of `Get-credential` to pre-populate the username and domain. The following example uses a
technique called splatting to pass parameters to the `Set-RemoteRegistryValue` function. For more
information about splatting, check out the [about_Splatting][about_Splatting] article.

```powershell
$remoteKeyParams = @{
    ComputerName = $env:COMPUTERNAME
    Path = 'HKLM:\SOFTWARE\Microsoft\WebManagement\Server'
    Name = 'EnableRemoteManagement'
    Value = '1'
}

Set-RemoteRegistryValue @remoteKeyParams -Credential (Get-Credential)
```

![Get a credential at runtime](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/deep-dives/media/add-credentials-to-powershell-functions/GetCredAtRunTime.gif)

Using `(Get-Credential)` seems cumbersome. Normally, when you use the **Credential** parameter with
only a username, the cmdlet automatically prompts for the password. The
`[System.Management.Automation.Credential()]` attribute enables this behavior.

```powershell
$remoteKeyParams = @{
    ComputerName = $env:COMPUTERNAME
    Path = 'HKLM:\SOFTWARE\Microsoft\WebManagement\Server'
    Name = 'EnableRemoteManagement'
    Value = '1'
}

Set-RemoteRegistryValue @remoteKeyParams -Credential duffney
```

![Prompt for credentials](https://learn.microsoft.com/en-us/powershell/docs-conceptual/learn/deep-dives/media/add-credentials-to-powershell-functions/GetCredsPrompt.gif)

> [!NOTE]
> To set the registry value shown, these examples assume you have the **Web Server** features of
> Windows installed. Run `Install-WindowsFeature Web-Server` and
> `Install-WindowsFeature web-mgmt-tools` if required.

### Provide credentials in a variable

You can also populate a credential variable ahead of time and pass it to the **Credential**
parameter of `Set-RemoteRegistryValue` function. Use this method with Continuous Integration /
Continuous Deployment (CI/CD) tools such as Jenkins, TeamCity, and Octopus Deploy. For an example
using Jenkins, check out Hodge's blog post
[Automating with Jenkins and PowerShell on Windows - Part 2][Automating with Jenkins and PowerShell on Windows - Part 2].

This example uses the .NET method to create the credential object and a secure string to pass in the
password.

```powershell
$password = ConvertTo-SecureString "P@ssw0rd" -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential ("duffney", $password)

$remoteKeyParams = @{
    ComputerName = $env:COMPUTERNAME
    Path = 'HKLM:\SOFTWARE\Microsoft\WebManagement\Server'
    Name = 'EnableRemoteManagement'
    Value = '1'
}

Set-RemoteRegistryValue @remoteKeyParams -Credential $Cred
```

For this example, the secure string is created using a clear text password. All of the
previously mentioned CI/CD have a secure method of providing that password at run time. When using
those tools, replace the plain text password with the variable defined within the CI/CD tool you
use.

### Run without credentials

Since `$Credential` defaults to an empty credential object, you can run the command without
credentials, as shown in this example:

```powershell
$remoteKeyParams = @{
    ComputerName = $env:COMPUTERNAME
    Path = 'HKLM:\SOFTWARE\Microsoft\WebManagement\Server'
    Name = 'EnableRemoteManagement'
    Value = '1'
}

Set-RemoteRegistryValue @remoteKeyParams
```

## Dealing with legacy cmdlets

Not all cmdlets support credential objects or allow empty credentials. Instead, the cmdlet wants
username and password parameters as strings. There are a few ways to work around this limitation.

### Using if-else to handle empty credentials

In this scenario, the cmdlet you want to run doesn't accept an empty credential object. This example
adds the **Credential** parameter to `Invoke-Command` only if it's not empty. Otherwise, it runs the
`Invoke-Command` without the **Credential** parameter.

```powershell
function Set-RemoteRegistryValue {
    param(
        $ComputerName,
        $Path,
        $Name,
        $Value,
        [ValidateNotNull()]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty
    )

    if($Credential -ne [System.Management.Automation.PSCredential]::Empty) {
        Invoke-Command -ComputerName:$ComputerName -Credential:$Credential  {
            Set-ItemProperty -Path $using:Path -Name $using:Name -Value $using:Value
        }
    } else {
        Invoke-Command -ComputerName:$ComputerName {
            Set-ItemProperty -Path $using:Path -Name $using:Name -Value $using:Value
        }
    }
}
```

### Using splatting to handle empty credentials

This example uses parameter splatting to call the legacy cmdlet. The `$Credential` object is
conditionally added to the hash table for splatting and avoids the need to repeat the
`Invoke-Command` script block. To learn more about splatting inside functions, see the
[Splatting Parameters Inside Advanced Functions][Splatting Parameters Inside Advanced Functions] blog post.

```powershell
function Set-RemoteRegistryValue {
    param(
        $ComputerName,
        $Path,
        $Name,
        $Value,
        [ValidateNotNull()]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty
    )

        $Splat = @{
            ComputerName = $ComputerName
        }

        if ($Credential -ne [System.Management.Automation.PSCredential]::Empty) {
            $Splat['Credential'] = $Credential
        }

        $null = Invoke-Command -ScriptBlock {
            Set-ItemProperty -Path $using:Path -Name $using:Name -Value $using:Value
        } @splat
}
```

### Working with string passwords

The `Invoke-Sqlcmd` cmdlet is an example of a cmdlet that accepts a string as a password.
`Invoke-Sqlcmd` allows you to run simple SQL insert, update, and delete statements. `Invoke-Sqlcmd`
requires a clear-text username and password rather than a more secure credential object. This
example shows how to extract the username and password from a credential object.

The `Get-AllSQLDatabases` function in this example calls the `Invoke-Sqlcmd` cmdlet to query a SQL
server for all its databases. The function defines a **Credential** parameter with the same
attribute used in the previous examples. Since the username and password exist within the
`$Credential` variable, you can extract those values for use with `Invoke-Sqlcmd`.

The user name is available from the **UserName** property of the `$Credential` variable. To obtain
the password, you have to use the `GetNetworkCredential()` method of the `$Credential` object. The
values are extracted into variables that are added to a hash table used for splatting parameters to
`Invoke-Sqlcmd`.

```powershell
function Get-AllSQLDatabases {
    param(
        $SQLServer,
        [ValidateNotNull()]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty
    )

        $UserName = $Credential.UserName
        $Password = $Credential.GetNetworkCredential().Password

        $splat = @{
            UserName = $UserName
            Password = $Password
            ServerInstance = 'SQLServer'
            Query = "Select * from Sys.Databases"
        }

        Invoke-Sqlcmd @splat
}

$credSplat = @{
    TypeName = 'System.Management.Automation.PSCredential'
    ArgumentList = 'duffney',('P@ssw0rd' | ConvertTo-SecureString -AsPlainText -Force)
}
$Credential = New-Object @credSplat

Get-AllSQLDatabases -SQLServer SQL01 -Credential $Credential
```

## Continued learning credential management

Creating and storing credential objects securely can be difficult. The following resources can help
you maintain PowerShell credentials.

- [BetterCredentials][BetterCredentials]
- [Azure Key Vault][Azure Key Vault]
- [Vault Project][Vault Project]
- [SecretManagement module][SecretManagement module]

<!-- link references -->
[original version]: https://duffney.io/addcredentialstopowershellfunctions/
[@joshduffney]: https://twitter.com/joshduffney
[duffney.io]: https://duffney.io/posts/
[BetterCredentials]: https://www.powershellgallery.com/packages/BetterCredentials/
[Azure Key Vault]: https://azure.microsoft.com/services/key-vault/
[Vault Project]: https://www.vaultproject.io/
[Splatting Parameters Inside Advanced Functions]: https://duffney.io/Splatting-Parameters-Within-AdvancedFunctions
[Automating with Jenkins and PowerShell on Windows - Part 2]: https://hodgkins.io/automating-with-jenkins-and-powershell-on-windows-part-2
[PSCredential]: https://learn.microsoft.com/dotnet/api/system.management.automation.pscredential
[The Pester Book]: https://leanpub.com/the-pester-book
[about_Splatting]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_splatting
[SecretManagement module]: https://devblogs.microsoft.com/powershell/secretmanagement-and-secretstore-updates/

# /./reference/learn/deep-dives/avoid-assigning-variables-in-expressions.md

    ---
    description: This article covers the limitations of assigning variables in expressions.
    ms.custom: wiki-migration
    ms.date: 11/16/2022
    title: Avoid assigning variables in expressions
    ---
# Avoid assigning variables in expressions

PowerShell allows you to use assignments within expressions by enclosing the assignment in
parentheses `()`. PowerShell passes the assigned value through. For example:

```powershell
# In an `if` conditional
if ($foo = Get-Item $PROFILE) { "$foo exists" }

# Property access
($profileFile = Get-Item $PROFILE).LastWriteTime

# You can even *assign* to such expressions.
($profileFile = Get-Item $PROFILE).LastWriteTime = Get-Date
```

> [!NOTE]
> While this syntax is allowed, its use is discouraged. There are cases where this does not work and
> the intent of the code author can be confusing to other code reviewers.

## Limitations

The assignment case doesn't always work. When it doesn't work, the assignment is discarded. If you
create an instance of a _mutable_ value type and attempt to both save the instance in a variable and
modify one of its properties in the same expression, the property assignment is discarded.

```powershell
# create mutable value type
PS> Add-Type 'public struct Foo { public int x; }'

# Create an instance, store it in a variable, and try to modify its property.
# This assignment is effectively IGNORED.
PS> ($var = [Foo]::new()).x = 1
PS> $var.x
0
```

The difference is that you can't return a reference to the value. Essentially,
`($var = [Foo]::new())` is equivalent to `$($var = [Foo]::new(); $var)`. You're no longer performing
a member access on the variable you're performing a member access on the variable's output, which is
a copy.

The workaround is to create the instance and save it in a variable first, and then assign to the
property via the variable:

```powershell
# create mutable value type
PS> Add-Type 'public struct Foo { public int x; }'

# Create an instance and store it in a variable first
# and then modify its property via the variable.
PS> $var = [Foo]::new()
PS> $var.x = 1
PS> $var.x
1
```

# /./reference/learn/deep-dives/avoid-using-invoke-expression.md

    ---
    description: This article explains why Invoke-Expression should only be used as a last resort.
    ms.custom: wiki-migration
    ms.date: 11/16/2022
    title: Avoid using Invoke-Expression
    ---
# Avoid using Invoke-Expression

The `Invoke-Expression` cmdlet should only be used as a _last resort_. In most scenarios, safer and
more robust alternatives are available. Forums like Stack Overflow are filled with examples of
`Invoke-Expression` misuse. Also note that **PSScriptAnalyzer** has a rule for this. For more
information, see
[AvoidUsingInvokeExpression](/powershell/utility-modules/psscriptanalyzer/rules/avoidusinginvokeexpression).

Carefully consider the security implications. When a string from an untrusted source such as user
input is passed directly to `Invoke-Expression`, arbitrary commands can be executed. Always consider
a different, more robust and secure solution first.

## Common scenarios

Consider the following usage scenarios:

- **It's simpler to redirect PowerShell to execute something naturally.** For example:

  ```powershell
  Get-Content ./file.ps1 | Invoke-Expression
  ```

  These cases are trivially avoidable. The script or code already exists in file or AST form, so you
  should write a script with parameters and invoke it directly instead of using `Invoke-Expression`
  on a string.

- **Running a script from a trusted source.** For example, running the install script from the
  PowerShell repository:

  ```powershell
  Invoke-WebRequest https://aka.ms/install-powershell.ps1 | Invoke-Expression
  ```

  You should only use this interactively. And, while this does make life simpler, this practice
  should be discouraged.

- **Testing for parsing errors.** The PowerShell team tests for parse errors in the source code
  using `Invoke-Expression` because that's the only way to turn a parse-time error into a runtime
  one.

## Conclusion

Most other scripting languages have a way to evaluate a string as code, and as an interpreted
language, PowerShell must have a way to dynamically run itself. But there's no good reason to use
`Invoke-Expression` in a production environment.

## References

- Stack Overflow discussion -
  [In what scenario was Invoke-Expression designed to be used?](https://stackoverflow.com/a/51252636/45375)
- PowerShell Blog post -
  [Invoke-Expression Considered Harmful](https://devblogs.microsoft.com/powershell/invoke-expression-considered-harmful/)

# /./reference/learn/deep-dives/output-missing-from-transcript.md

    ---
    description: This articles explains the limitations of PowerShell transcripts and the cases than can cause data to be logged out of order or be missing from the transcript.
    ms.custom: wiki-migration
    ms.date: 11/16/2022
    title: Limitations of PowerShell transcripts
    ---
# Limitations of PowerShell transcripts

Mixing `Write-Host` output with the output objects, strings, and PowerShell transcription is
complicated. There is a subtle interaction between the script and how transcription works with
PowerShell pipelines that can have unexpected results.

When you emit objects from your script the formatting of those objects is handled by `Out-Default`.
But the formatting can occur after the script has completed and transcription has stopped. This
means that the output doesn't get transcribed. Strings are handled differently. Sometimes string
output is passed through formatting, but not always. `Write-Host` makes an immediate write to the
host process. `Write-Object` is sent through the formatting system. Combining the output of complex
objects with writes to the host makes it difficult to predict what gets logged in the transcript.

## Scenario 1 - Output of a structured object at the end of all of the other operations

Consider the following script and its output:

```powershell
PS> Get-Content scenario1.ps1
Start-Transcript scenario1.log -UseMinimalHeader
Write-Host '1'
Write-Output '2'
Get-Location
Write-Host '4'
Write-Output '5'
Stop-Transcript

PS> ./scenario1.ps1
Transcript started, output file is scenario1.log
1
2

4
Path
----
/Users/user1/src/projects/transcript
5
Transcript stopped, output file is /Users/user1/src/projects/transcript/scenario1.log
```

The output to the console shows the output you expect, but not in the order you expect it.
`Write-Host 4` is visible before `Get-Location` because `Write-Host` is optimized to write directly
to the host. There's code in transcription that copies the output to the transcript file and the
console. Then we have the regular output of `Get-Location` and `Write-Output 5` sent as output of
the script.

```powershell
PS> Get-Content scenario1.log
**********************
PowerShell transcript start
Start time: 20191106114858
**********************
Transcript started, output file is s2
1
2

4
**********************
PowerShell transcript end
End time: 20191106114858
**********************
```

Since transcription is turned off before the script exits, it's not rendered in the transcript. The
objects were sent to the next consumer in the pipeline. In this case, it's `Out-Default`, which
PowerShell inserted automatically. To complicate things further, the output of strings is also
optimized in the formatting system. The first `Write-Output 2` gets emitted and captured by the
transcript. But the insertion of the `Get-Location` object causes its output to be pushed into the
stack of things that need actual formatting, which sets a bit of state for any remaining objects
that also may need formatting. This is why the second `Write-Output 5` doesn't get added to the
transcript.

## Scenario 2 - Move the object emission to the beginning

Consider the following script and its output:

```powershell
PS> Get-Content scenario2.ps1
Start-Transcript scenario2.log -UseMinimalHeader
Get-Location
Write-Host '1'
Write-Output '2'
Get-Location
Write-Host '4'
Write-Output '5'
Stop-Transcript

PS> ./scenario2.ps1
Transcript started, output file is scenario2.log

1
4
Path
----
/Users/user1/src/projects/transcript
2
5
Transcript stopped, output file is /Users/user1/src/projects/transcript/scenario2.log
```

We can see that the `Write-Host` commands happen before anything, and then the objects start to come
out. The `Write-Output` of a string forces the object to be rendered to the screen, but notice that
the transcript contains only the output of `Write-Host`. That's because those string objects are
piped to `Out-Default` for formatting after the script turned off transcription.

```powershell
PS> Get-Content scenario2.log
**********************
PowerShell transcript start
Start time: 20220606094609
**********************
Transcript started, output file is s3

1
4
**********************
PowerShell transcript end
End time: 20220606094609
**********************
```

## Scenario 3 - Object emitted at the end of the script

For this scenario, the output of the complex object is at the end of the script.

```powershell
PS> Get-Content scenario3.ps1
Start-Transcript scenario3.log -UseMinimalHeader
Write-Host '1'
Write-Output '2'
Write-Host '4'
Write-Output '5'
Get-Location
Stop-Transcript

PS> ./scenario3.ps1
Transcript started, output file is scenario3.log
1
2
4
5

Path
----
/Users/user1/src/projects/transcript
Transcript stopped, output file is /Users/user1/src/projects/transcript/scenario3.log
```

The string output from both `Write-Host` and `Write-Object` makes it into the transcript. However,
the output from `Get-Location` occurs after transcription has stopped.

```
**********************
PowerShell transcript start
Start time: 20220606100342
**********************
Transcript started, output file is scenario3.log
1
2
4
5

**********************
PowerShell transcript end
End time: 20220606100342
**********************
```

## A way to ensure full transcription

This example is a slight variation on the original scenario, but now everything is logged to the
transcript. The original code is wrapped in a script block and the formatter explicitly invoked via
`Out-Default`.

```powershell
PS> Get-Content scenario4.ps1
Start-Transcript scenario4.log -UseMinimalHeader
. {
    Write-Host '1'
    Write-Output '2'
    Get-Location
    Write-Host '4'
    Write-Output '5'
} | Out-Default
Stop-Transcript

PS> ./scenario4.ps1
Transcript started, output file is scenario4.log
1
2

4
Path
----
/Users/user1/src/projects/transcript
5

Transcript stopped, output file is /Users/user1/src/projects/transcript/scenario4.log
```

Notice that the last `Write-Host` call is still out of order, that's because of the
optimization in `Write-Host` that doesn't go into the output stream.

```powershell
PS> Get-Content scenario4.log
**********************
PowerShell transcript start
Start time: 20220606101038
**********************
Transcript started, output file is s5
1
2

4
Path
----
/Users/user1/src/projects/transcript
5

**********************
PowerShell transcript end
End time: 20220606101038
**********************
```

# /./reference/samples/viewing-object-structure--get-member-.md

    ---
    description: Get-Member is a powerful tool that allows to see the type and structure of objects in PowerShell.
    ms.date: 12/08/2022
    title: Viewing object structure
    ---
# Viewing object structure

Because objects play such a central role in PowerShell, there are several native commands designed
to work with arbitrary object types. The most important one is the `Get-Member` command.

The simplest technique for analyzing the objects that a command returns is to pipe the output of
that command to the `Get-Member` cmdlet. The `Get-Member` cmdlet shows you the formal name of the
object type and a complete listing of its members. The number of elements that are returned can
sometimes be overwhelming. For example, a process object can have over 100 members.

The following command allows you to see all the members of a **Process** object and page through the
output.

```powershell
Get-Process | Get-Member | Out-Host -Paging
```

```Output
TypeName: System.Diagnostics.Process

Name                           MemberType     Definition
----                           ----------     ----------
Handles                        AliasProperty  Handles = Handlecount
Name                           AliasProperty  Name = ProcessName
NPM                            AliasProperty  NPM = NonpagedSystemMemorySize
PM                             AliasProperty  PM = PagedMemorySize
VM                             AliasProperty  VM = VirtualMemorySize
WS                             AliasProperty  WS = WorkingSet
add_Disposed                   Method         System.Void add_Disposed(Event...
...
```

We can make this long list of information more usable by filtering for elements we want to see. The
`Get-Member` command lets you list only members that are properties. There are several forms of
properties. The cmdlet displays properties of a type using the **MemberType** parameter with the
value `Properties`. The resulting list is still very long, but a more manageable:

```powershell
Get-Process | Get-Member -MemberType Properties
```

```Output
   TypeName: System.Diagnostics.Process

Name                       MemberType     Definition
----                       ----------     ----------
Handles                    AliasProperty  Handles = Handlecount
Name                       AliasProperty  Name = ProcessName
...
ExitCode                   Property       System.Int32 ExitCode {get;}
...
Handle                     Property       System.IntPtr Handle {get;}
...
CPU                        ScriptProperty System.Object CPU {get=$this.Total...
...
Path                       ScriptProperty System.Object Path {get=$this.Main...
...
```

> [!NOTE]
> The allowed values of MemberType are AliasProperty, CodeProperty, Property, NoteProperty,
> ScriptProperty, Properties, PropertySet, Method, CodeMethod, ScriptMethod, Methods,
> ParameterizedProperty, MemberSet, and All.

There are more than 60 properties for a process. By default, PowerShell determines how to display an
object type using information stored in XML files that have names ending in `.format.ps1xml`. The
formatting definition for process objects is stored in `DotNetTypes.format.ps1xml`.

If you need to look at properties other than those that PowerShell displays by default, you can
format the output using the `Format-*` cmdlets.

# /./reference/samples/selecting-parts-of-objects--select-object-.md

    ---
    description: You can use the `Select-Object` cmdlet to create new, custom PowerShell objects that contain properties selected from the objects on the pipeline.
    ms.date: 12/08/2022
    title: Selecting parts of objects
    ---
# Selecting parts of objects

You can use the `Select-Object` cmdlet to create new, custom PowerShell objects that contain
properties selected from the objects you use to create them. Type the following command to create a
new object that includes only the **Name** and **FreeSpace** properties of the **Win32_LogicalDisk**
WMI class:

```powershell
Get-CimInstance -Class Win32_LogicalDisk |
    Select-Object -Property Name, FreeSpace
```

```Output
Name      FreeSpace
----      ---------
C:      50664845312
```

With `Select-Object` you can create calculated properties to display **FreeSpace** in gigabytes
rather than bytes.

```powershell
Get-CimInstance -Class Win32_LogicalDisk |
    Select-Object -Property Name, @{
        label='FreeSpace'
        expression={($_.FreeSpace/1GB).ToString('F2')}
    }
```

```Output
Name    FreeSpace
----    ---------
C:      47.18
```

# /./reference/samples/removing-objects-from-the-pipeline--where-object-.md

    ---
    description: The Where-Object cmdlet allows you to filter objects that are passed on the pipeline.
    ms.date: 12/08/2022
    title: Removing objects from the pipeline
    ---
# Removing objects from the pipeline

In PowerShell, you often generate and pass along more objects to a pipeline than you want. You can
specify the properties of particular objects to display using the `Format-*` cmdlets, but this
doesn't help with the problem of removing entire objects from the display. You may want to filter
objects before the end of a pipeline, so you can perform actions on only a subset of the initially
generated objects.

PowerShell includes a `Where-Object` cmdlet that allows you to test each object in the pipeline and
only pass it along the pipeline if it meets a particular test condition. Objects that don't pass the
test are removed from the pipeline. You supply the test condition as the value of the
**FilterScript** parameter.

## Performing simple tests with Where-Object

The value of **FilterScript** is a _script block_ - one or more PowerShell commands surrounded by
braces (`{}`) - that evaluates to true or false. These script blocks can be simple, but creating
them requires knowing about another PowerShell concept, comparison operators. A comparison operator
compares the items that appear on each side of it. Comparison operators begin with a hyphen
character (`-`) and are followed by a name. Basic comparison operators work on almost any kind of
object. The more advanced comparison operators might only work on text or arrays.

> [!NOTE]
> By default, PowerShell comparison operators are case-insensitive.

Due to parsing considerations, symbols such as `<`,`>`, and `=` aren't used as comparison
operators. Instead, comparison operators are comprised of letters. The basic comparison operators
are listed in the following table.

| Comparison Operator |                  Meaning                  |    Example (returns true)    |
| ------------------- | ----------------------------------------- | ---------------------------- |
| -eq                 | is equal to                               | 1 -eq 1                      |
| -ne                 | isn't equal to                            | 1 -ne 2                      |
| -lt                 | Is less than                              | 1 -lt 2                      |
| -le                 | Is less than or equal to                  | 1 -le 2                      |
| -gt                 | Is greater than                           | 2 -gt 1                      |
| -ge                 | Is greater than or equal to               | 2 -ge 1                      |
| -like               | Is like (wildcard comparison for text)    | "file.doc" -like "f*.do?"    |
| -notlike            | isn't like (wildcard comparison for text) | "file.doc" -notlike "p*.doc" |
| -contains           | Contains                                  | 1,2,3 -contains 1            |
| -notcontains        | doesn't contain                           | 1,2,3 -notcontains 4         |

`Where-Object` script blocks use the special variable `$_` to refer to the current object in the
pipeline. Here is an example of how it works. If you have a list of numbers, and only want to return
the ones that are less than 3, you can use `Where-Object` to filter the numbers by typing:

```
1,2,3,4 | Where-Object {$_ -lt 3}
1
2
```

## Filtering based on object properties

Since `$_` refers to the current pipeline object, we can access its properties for our tests.

As an example, we can look at the **Win32_SystemDriver** class in WMI. There might be hundreds of
system drivers on a particular system, but you might only be interested in a particular set of the
system drivers, such as those that are running. For the **Win32_SystemDriver** class the relevant
property is **State**. You can filter the system drivers, selecting only the running ones by typing:

```powershell
Get-CimInstance -Class Win32_SystemDriver |
    Where-Object {$_.State -eq 'Running'}
```

This still produces a long list. You may want to filter to only select the drivers set to start
automatically by testing the **StartMode** value as well:

```powershell
Get-CimInstance -Class Win32_SystemDriver |
    Where-Object {$_.State -eq "Running"} |
    Where-Object {$_.StartMode -eq "Auto"}
```

```Output
DisplayName : RAS Asynchronous Media Driver
Name        : AsyncMac
State       : Running
Status      : OK
Started     : True

DisplayName : Audio Stub Driver
Name        : audstub
State       : Running
Status      : OK
Started     : True
...
```

This gives us a lot of information we no longer need because we know that the drivers are running.
In fact, the only information we probably need at this point are the name and the display name. The
following command includes only those two properties, resulting in much simpler output:

```powershell
Get-CimInstance -Class Win32_SystemDriver |
    Where-Object {$_.State -eq "Running"} |
    Where-Object {$_.StartMode -eq "Manual"} |
    Format-Table -Property Name,DisplayName
```

```Output
Name              DisplayName
----              -----------
AsyncMac               RAS Asynchronous Media Driver
bindflt                Windows Bind Filter Driver
bowser                 Browser
CompositeBus           Composite Bus Enumerator Driver
condrv                 Console Driver
HdAudAddService        Microsoft 1.1 UAA Function Driver for High Definition Audio Service
HDAudBus               Microsoft UAA Bus Driver for High Definition Audio
HidUsb                 Microsoft HID Class Driver
HTTP                   HTTP Service
igfx                   igfx
IntcDAud               Intel(R) Display Audio
intelppm               Intel Processor Driver
...
```

There are two `Where-Object` elements in the above command, but they can be expressed in a single
`Where-Object` element using the `-and` logical operator, like this:

```powershell
Get-CimInstance -Class Win32_SystemDriver |
    Where-Object {($_.State -eq 'Running') -and ($_.StartMode -eq 'Manual')} |
    Format-Table -Property Name,DisplayName
```

The standard logical operators are listed in the following table.

| Logical Operator |                 Meaning                  |   Example (returns true)   |
| ---------------- | ---------------------------------------- | -------------------------- |
| `-and`           | Logical and; true if both sides are true | `(1 -eq 1) -and (2 -eq 2)` |
| `-or`            | Logical or; true if either side is true  | `(1 -eq 1) -or (1 -eq 2)`  |
| `-not`           | Logical not; reverses true and false     | `-not (1 -eq 2)`           |
| `!`              | Logical not; reverses true and false     | `!(1 -eq 2)`               |

# /./reference/samples/sorting-objects.md

    ---
    description: The Sort-Object cmdlet allows you to sort a collection of objects on one or more properties.
    ms.date: 12/08/2022
    title: Sorting objects
    ---
# Sorting objects

We can organize displayed data to make it easier to scan using the `Sort-Object` cmdlet.
`Sort-Object` takes the name of one or more properties to sort on, and returns data sorted by the
values of those properties.

## Basic sorting

Consider the problem of listing subdirectories and files in the current directory. If we want to
sort by **LastWriteTime** and then by **Name**, we can do it by typing:

```powershell
Get-ChildItem |
    Sort-Object -Property LastWriteTime, Name |
    Format-Table -Property LastWriteTime, Name
```

```output
LastWriteTime          Name
-------------          ----
11/6/2017 10:10:11 AM  .localization-config
11/6/2017 10:10:11 AM  .openpublishing.build.ps1
11/6/2017 10:10:11 AM  appveyor.yml
11/6/2017 10:10:11 AM  LICENSE
11/6/2017 10:10:11 AM  LICENSE-CODE
11/6/2017 10:10:11 AM  ThirdPartyNotices
11/6/2017 10:10:15 AM  tests
6/6/2018 7:58:59 PM    CONTRIBUTING.md
6/6/2018 7:58:59 PM    README.md
...
```

You can also sort the objects in reverse order by specifying the **Descending** switch parameter.

```powershell
Get-ChildItem |
  Sort-Object -Property LastWriteTime, Name -Descending |
  Format-Table -Property LastWriteTime, Name
```

```output
LastWriteTime          Name
-------------          ----
12/1/2018 10:13:50 PM  reference
12/1/2018 10:13:50 PM  dsc
...
6/6/2018 7:58:59 PM    README.md
6/6/2018 7:58:59 PM    CONTRIBUTING.md
11/6/2017 10:10:15 AM  tests
11/6/2017 10:10:11 AM  ThirdPartyNotices
11/6/2017 10:10:11 AM  LICENSE-CODE
11/6/2017 10:10:11 AM  LICENSE
11/6/2017 10:10:11 AM  appveyor.yml
11/6/2017 10:10:11 AM  .openpublishing.build.ps1
11/6/2017 10:10:11 AM  .localization-config
```

## Using hash tables

You can sort different properties in different orders using hash tables in an array. Each hash table
uses an **Expression** key to specify the property name as string and an **Ascending** or
**Descending** key to specify the sort order by `$true` or `$false`. The **Expression** key is
mandatory. The **Ascending** or **Descending** key is optional.

The following example sorts objects in descending **LastWriteTime** order and ascending **Name**
order.

```powershell
Get-ChildItem |
  Sort-Object -Property @{ Expression = 'LastWriteTime'; Descending = $true },
                        @{ Expression = 'Name'; Ascending = $true } |
  Format-Table -Property LastWriteTime, Name
```

```output
LastWriteTime          Name
-------------          ----
12/1/2018 10:13:50 PM  dsc
12/1/2018 10:13:50 PM  reference
11/29/2018 6:56:01 PM  .openpublishing.redirection.json
11/29/2018 6:56:01 PM  gallery
11/24/2018 10:33:22 AM developer
11/20/2018 7:22:19 PM  .markdownlint.json
...
```

You can also set a scriptblock to the **Expression** key. When running the `Sort-Object` cmdlet, the
scriptblock is executed and the result is used for sorting.

The following example sorts objects in descending order by the time span between **CreationTime**
and **LastWriteTime**.

```powershell
Get-ChildItem |
    Sort-Object -Property @{ Exp = { $_.LastWriteTime - $_.CreationTime }; Desc = $true } |
    Format-Table -Property LastWriteTime, CreationTime
```

```output
LastWriteTime          CreationTime
-------------          ------------
12/1/2018 10:13:50 PM  11/6/2017 10:10:11 AM
12/1/2018 10:13:50 PM  11/6/2017 10:10:11 AM
11/7/2018 6:52:24 PM   11/6/2017 10:10:11 AM
11/7/2018 6:52:24 PM   11/6/2017 10:10:15 AM
11/3/2018 9:58:17 AM   11/6/2017 10:10:11 AM
10/26/2018 4:50:21 PM  11/6/2017 10:10:11 AM
11/17/2018 1:10:57 PM  11/29/2017 5:48:30 PM
11/12/2018 6:29:53 PM  12/7/2017 7:57:07 PM
...
```

## Tips

You can omit the **Property** parameter name as following:

```powershell
Sort-Object LastWriteTime, Name
```

Besides, you can refer to `Sort-Object` by its built-in alias, `sort`:

```powershell
sort LastWriteTime, Name
```

The keys in the hash tables for sorting can be abbreviated as following:

```powershell
Sort-Object @{ e = 'LastWriteTime'; d = $true }, @{ e = 'Name'; a = $true }
```

In this example, the **e** stands for **Expression**, the **d** stands for **Descending**, and the
**a** stands for **Ascending**.

To improve readability, you can place the hash tables into a separate variable:

```powershell
$order = @(
  @{ Expression = 'LastWriteTime'; Descending = $true }
  @{ Expression = 'Name'; Ascending = $true }
)

Get-ChildItem |
    Sort-Object $order |
    Format-Table LastWriteTime, Name
```

# /./reference/samples/creating-.net-and-com-objects--new-object-.md

    ---
    description: As an object-oriented scripting language, PowerShell supports both .NET and COM-based objects. This article shows you how to create and interact with these objects.
    ms.date: 12/08/2022
    title: Creating .NET and COM objects
    ---
# Creating .NET and COM objects

> This sample only runs on Windows platforms.

There are software components with .NET Framework and COM interfaces that enable you to perform many
system administration tasks. PowerShell lets you use these components, so you aren't limited
to the tasks that can be performed by using cmdlets. Many of the cmdlets in the initial release of
PowerShell don't work against remote computers. We will demonstrate how to get around this
limitation when managing event logs by using the .NET Framework **System.Diagnostics.EventLog**
class directly from PowerShell.

## Using New-Object for event log access

The .NET Framework Class Library includes a class named **System.Diagnostics.EventLog** that can be
used to manage event logs. You can create a new instance of a .NET Framework class by using the
`New-Object` cmdlet with the **TypeName** parameter. For example, the following command creates an
event log reference:

```powershell
New-Object -TypeName System.Diagnostics.EventLog
```

```Output
  Max(K) Retain OverflowAction        Entries Name
  ------ ------ --------------        ------- ----
```

Although the command has created an instance of the **EventLog** class, the instance doesn't include any
data. that's because we didn't specify a particular event log. How do you get a real event log?

### Using constructors with New-Object

To refer to a specific event log, you need to specify the name of the log. `New-Object` has an
**ArgumentList** parameter. The arguments you pass as values to this parameter are used by a special
startup method of the object. The method is called a **constructor** because it's used to construct
the object. For example, to get a reference to the Application log, you specify the string
'Application' as an argument:

```powershell
New-Object -TypeName System.Diagnostics.EventLog -ArgumentList Application
```

```Output
Max(K) Retain OverflowAction        Entries Name
------ ------ --------------        ------- ----
16,384      7 OverwriteOlder          2,160 Application
```

> [!NOTE]
> Since most of the .NET classes are contained in the **System** namespace, PowerShell automatically
> attempts to find classes you specify in the **System** namespace if it can't find a match for the
> typename you specify. This means that you can specify `Diagnostics.EventLog` instead of
> `System.Diagnostics.EventLog`.

### Storing Objects in Variables

You might want to store a reference to an object, so you can use it in the current shell. Although
PowerShell lets you do a lot of work with pipelines, lessening the need for variables,
sometimes storing references to objects in variables makes it more convenient to manipulate those
objects.

The output from any valid PowerShell command can be stored in a variable. Variable names always
begin with `$`. If you want to store the Application log reference in a variable named `$AppLog`,
type the name of the variable, followed by an equal sign and then type the command used to create
the Application log object:

```powershell
$AppLog = New-Object -TypeName System.Diagnostics.EventLog -ArgumentList Application
```

If you then type `$AppLog`, you can see that it contains the Application log:

```powershell
$AppLog
```

```Output
  Max(K) Retain OverflowAction        Entries Name
  ------ ------ --------------        ------- ----
  16,384      7 OverwriteOlder          2,160 Application
```

### Accessing a remote event log with New-Object

The commands used in the preceding section target the local computer; the `Get-EventLog` cmdlet can
do that. To access the Application log on a remote computer, you must supply both the log name and a
computer name (or IP address) as arguments.

```powershell
$RemoteAppLog = New-Object -TypeName System.Diagnostics.EventLog Application, 192.168.1.81
$RemoteAppLog
```

```Output
  Max(K) Retain OverflowAction        Entries Name
  ------ ------ --------------        ------- ----
     512      7 OverwriteOlder            262 Application
```

Now that we have a reference to an event log stored in the `$RemoteAppLog` variable, what tasks can
we perform on it?

### Clearing an event log with object methods

Objects often have methods that can be called to perform tasks. You can use `Get-Member` to display
the methods associated with an object. The following command and selected output show some the
methods of the **EventLog** class:

```powershell
$RemoteAppLog | Get-Member -MemberType Method
```

```Output
   TypeName: System.Diagnostics.EventLog

Name                      MemberType Definition
----                      ---------- ----------
...
Clear                     Method     System.Void Clear()
Close                     Method     System.Void Close()
...
GetType                   Method     System.Type GetType()
...
ModifyOverflowPolicy      Method     System.Void ModifyOverflowPolicy(Overfl...
RegisterDisplayName       Method     System.Void RegisterDisplayName(String ...
...
ToString                  Method     System.String ToString()
WriteEntry                Method     System.Void WriteEntry(String message),...
WriteEvent                Method     System.Void WriteEvent(EventInstance in...
```

The `Clear()` method can be used to clear the event log. When calling a method, you must always
follow the method name by parentheses, even if the method doesn't require arguments. This lets
PowerShell distinguish between the method and a potential property with the same name. Type
the following to call the **Clear** method:

```powershell
$RemoteAppLog.Clear()
$RemoteAppLog
```

```Output
  Max(K) Retain OverflowAction        Entries Name
  ------ ------ --------------        ------- ----
     512      7 OverwriteOlder              0 Application
```

Notice that the event log was cleared and now has 0 entries instead of 262.

## Creating COM objects with New-Object

You can use `New-Object` to work with Component Object Model (COM) components. Components range from
the various libraries included with Windows Script Host (WSH) to ActiveX applications such as
Internet Explorer that are installed on most systems.

`New-Object` uses .NET Framework Runtime-Callable Wrappers to create COM objects, so it has the same
limitations that .NET Framework does when calling COM objects. To create a COM object, you need to
specify the **ComObject** parameter with the Programmatic Identifier or **ProgId** of the COM class
you want to use. A complete discussion of the limitations of COM use and determining what ProgIds
are available on a system is beyond the scope of this user's guide, but most well-known objects from
environments such as WSH can be used within PowerShell.

You can create the WSH objects by specifying these progids: **WScript.Shell**, **WScript.Network**,
**Scripting.Dictionary**, and **Scripting.FileSystemObject**. The following commands create these
objects:

```powershell
New-Object -ComObject WScript.Shell
New-Object -ComObject WScript.Network
New-Object -ComObject Scripting.Dictionary
New-Object -ComObject Scripting.FileSystemObject
```

Although most of the functionality of these classes is made available in other ways in Windows
PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.

## Creating a desktop shortcut with WScript.Shell

One task that can be performed quickly with a COM object is creating a shortcut. Suppose you want to
create a shortcut on your desktop that links to the home folder for PowerShell. You first
need to create a reference to **WScript.Shell**, which we will store in a variable named
`$WshShell`:

```powershell
$WshShell = New-Object -ComObject WScript.Shell
```

`Get-Member` works with COM objects, so you can explore the members of the object by typing:

```powershell
$WshShell | Get-Member
```

```Output
   TypeName: System.__ComObject#{41904400-be18-11d3-a28b-00104bd35090}

Name                     MemberType            Definition
----                     ----------            ----------
AppActivate              Method                bool AppActivate (Variant, Va...
CreateShortcut           Method                IDispatch CreateShortcut (str...
...
```

`Get-Member` has an optional **InputObject** parameter you can use instead of piping to provide
input to `Get-Member`. You would get the same output as shown above if you instead used the command
**Get-Member -InputObject $WshShell**. If you use **InputObject**, it treats its argument as a
single item. This means that if you have several objects in a variable, `Get-Member` treats them as
an array of objects. For example:

```powershell
$a = 1,2,"three"
Get-Member -InputObject $a
```

```Output
TypeName: System.Object[]
Name               MemberType    Definition
----               ----------    ----------
Count              AliasProperty Count = Length
...
```

The **WScript.Shell CreateShortcut** method accepts a single argument, the path to the shortcut file
to create. We could type in the full path to the desktop, but there is an easier way. The desktop is
normally represented by a folder named Desktop inside the home folder of the current user. Windows
PowerShell has a variable `$HOME` that contains the path to this folder. We can specify the path to
the home folder by using this variable, and then add the name of the Desktop folder and the name for
the shortcut to create by typing:

```powershell
$lnk = $WshShell.CreateShortcut("$HOME\Desktop\PSHome.lnk")
```

When you use something that looks like a variable name inside double-quotes, PowerShell tries to
substitute a matching value. If you use single-quotes, PowerShell doesn't try to substitute the
variable value. For example, try typing the following commands:

```powershell
"$HOME\Desktop\PSHome.lnk"
```

```Output
C:\Documents and Settings\aka\Desktop\PSHome.lnk
```

```powershell
'$HOME\Desktop\PSHome.lnk'
```

```Output
$HOME\Desktop\PSHome.lnk
```

We now have a variable named `$lnk` that contains a new shortcut reference. If you want to see its
members, you can pipe it to `Get-Member`. The output below shows the members we need to use to
finish creating our shortcut:

```powershell
$lnk | Get-Member
```

```Output
TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b}
Name             MemberType   Definition
----             ----------   ----------
...
Save             Method       void Save ()
...
TargetPath       Property     string TargetPath () {get} {set}
```

We need to specify the **TargetPath**, which is the application folder for PowerShell, and then save
the shortcut by calling the `Save` method. The PowerShell application folder path is stored in the
variable `$PSHome`, so we can do this by typing:

```powershell
$lnk.TargetPath = $PSHome
$lnk.Save()
```

## Using Internet Explorer from PowerShell

Many applications, including the Microsoft Office family of applications and Internet Explorer, can
be automated by using COM. The following examples illustrate some of the typical techniques and
issues involved in working with COM-based applications.

You create an Internet Explorer instance by specifying the Internet Explorer ProgId,
**InternetExplorer.Application**:

```powershell
$ie = New-Object -ComObject InternetExplorer.Application
```

This command starts Internet Explorer, but doesn't make it visible. If you type `Get-Process`, you can
see that a process named `iexplore` is running. In fact, if you exit PowerShell, the process will
continue to run. You must reboot the computer or use a tool like Task Manager to end the `iexplore`
process.

> [!NOTE]
> COM objects that start as separate processes, commonly called _ActiveX executables_, may or may
> not display a user interface window when they start up. If they create a window but don't make it
> visible, like Internet Explorer, the focus usually moves to the Windows desktop. You must make the
> window visible to interact with it.

By typing `$ie | Get-Member`, you can view properties and methods for Internet Explorer. To see the
Internet Explorer window, set the **Visible** property to `$true` by typing:

```powershell
$ie.Visible = $true
```

You can then navigate to a specific Web address using the `Navigate` method:

```powershell
$ie.Navigate("https://devblogs.microsoft.com/scripting/")
```

Using other members of the Internet Explorer object model, it's possible to retrieve text content
from the Web page. The following command displays the HTML text in the body of the current Web
page:

```powershell
$ie.Document.Body.InnerText
```

To close Internet Explorer from within PowerShell, call its `Quit()` method:

```powershell
$ie.Quit()
```

The `$ie` variable no longer contains a valid reference even though it still appears to be a COM
object. If you attempt to use it, PowerShell returns an automation error:

```powershell
$ie | Get-Member
```

```Output
Get-Member : Exception retrieving the string representation for property "Appli
cation" : "The object invoked has disconnected from its clients. (Exception fro
m HRESULT: 0x80010108 (RPC_E_DISCONNECTED))"
At line:1 char:16
+ $ie | Get-Member <<<<
```

You can either remove the remaining reference with a command like `$ie = $null`, or completely
remove the variable by typing:

```powershell
Remove-Variable ie
```

> [!NOTE]
> There is no common standard for whether ActiveX executables exit or continue to run when you
> remove a reference to one. Depending on circumstances, such as whether the application is visible,
> whether an edited document is running in it, and even whether PowerShell is still running,
> the application may or may not exit. For this reason, you should test termination behavior for
> each ActiveX executable you want to use in PowerShell.

## Getting warnings about .NET Framework-wrapped COM objects

In some cases, a COM object might have an associated .NET Framework **Runtime-Callable Wrapper**
(RCW) that's used by `New-Object`. Since the behavior of the RCW may be different from the behavior
of the normal COM object, `New-Object` has a **Strict** parameter to warn you about RCW access. If
you specify the **Strict** parameter and then create a COM object that uses an RCW, you get a
warning message:

```powershell
$xl = New-Object -ComObject Excel.Application -Strict
```

```Output
New-Object : The object written to the pipeline is an instance of the type "Mic
rosoft.Office.Interop.Excel.ApplicationClass" from the component's primary interop assembly. If
this type exposes different members than the IDispatch members , scripts written to work with this
object might not work if the primary interop assembly isn't installed. At line:1 char:17 + $xl =
New-Object <<<< -ComObject Excel.Application -Strict
```

Although the object is still created, you are warned that it isn't a standard COM object.

# /./reference/samples/using-static-classes-and-methods.md

    ---
    description: This article explains how to identify and use the properties and methods of .NET static classes.
    ms.date: 12/08/2022
    title: Using Static Classes and Methods
    ---
# Using static classes and methods

Not all .NET Framework classes can be created using `New-Object`. For example, if you try to
create a **System.Environment** or a **System.Math** object with `New-Object`, you will get the
following error messages:

```powershell
New-Object System.Environment
```

```Output
New-Object : Constructor not found. Cannot find an appropriate constructor for
type System.Environment.
At line:1 char:11
+ New-Object  <<<< System.Environment
```

```powershell
New-Object System.Math
```

```Output
New-Object : Constructor not found. Cannot find an appropriate constructor for
type System.Math.
At line:1 char:11
+ New-Object  <<<< System.Math
```

These errors occur because there is no way to create a new object from these classes. These classes
are reference libraries of methods and properties that don't change state. You don't need to create
them, you simply use them. Classes and methods such as these are called _static classes_ because
they're not created, destroyed, or changed. To make this clear we will provide examples that use
static classes.

## Getting environment data with System.Environment

Usually, the first step in working with an object in Windows PowerShell is to use Get-Member to find
out what members it contains. With static classes, the process is a little different because the
actual class isn't an object.

### Referring to the static System.Environment class

You can refer to a static class by surrounding the class name with square brackets. For example, you
can refer to **System.Environment** by typing the name within brackets. Doing so displays some
generic type information:

```powershell
[System.Environment]
```

```Output
IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     False    Environment                              System.Object
```

> [!NOTE]
> As we mentioned previously, Windows PowerShell automatically prepends '**System.**' to type names
> when you use `New-Object`. The same thing happens when using a bracketed type name, so you can
> specify **\[System.Environment]** as **\[Environment]**.

The **System.Environment** class contains general information about the working environment for the
current process, which is `powershell.exe` when working within Windows PowerShell.

If you try to view details of this class by typing **\[System.Environment] | Get-Member**, the
object type is reported as being **System.RuntimeType** , not **System.Environment**:

```powershell
[System.Environment] | Get-Member
```

```Output
   TypeName: System.RuntimeType
```

To view static members with Get-Member, specify the **Static** parameter:

```powershell
[System.Environment] | Get-Member -Static
```

```Output
   TypeName: System.Environment

Name                       MemberType Definition
----                       ---------- ----------
Equals                     Method     static System.Boolean Equals(Object ob...
Exit                       Method     static System.Void Exit(Int32 exitCode)
...
CommandLine                Property   static System.String CommandLine {get;}
CurrentDirectory           Property   static System.String CurrentDirectory ...
ExitCode                   Property   static System.Int32 ExitCode {get;set;}
HasShutdownStarted         Property   static System.Boolean HasShutdownStart...
MachineName                Property   static System.String MachineName {get;}
NewLine                    Property   static System.String NewLine {get;}
OSVersion                  Property   static System.OperatingSystem OSVersio...
ProcessorCount             Property   static System.Int32 ProcessorCount {get;}
StackTrace                 Property   static System.String StackTrace {get;}
SystemDirectory            Property   static System.String SystemDirectory {...
TickCount                  Property   static System.Int32 TickCount {get;}
UserDomainName             Property   static System.String UserDomainName {g...
UserInteractive            Property   static System.Boolean UserInteractive ...
UserName                   Property   static System.String UserName {get;}
Version                    Property   static System.Version Version {get;}
WorkingSet                 Property   static System.Int64 WorkingSet {get;}
TickCount                               ExitCode
```

We can now select properties to view from System.Environment.

### Displaying static properties of System.Environment

The properties of System.Environment are also static, and must be specified in a different way than
normal properties. We use `::` to indicate to Windows PowerShell that we want to work with a static
method or property. To see the command that was used to launch Windows PowerShell, we check the
**CommandLine** property by typing:

```powershell
[System.Environment]::Commandline
```

```Output
"C:\Program Files\Windows PowerShell\v1.0\powershell.exe"
```

To check the operating system version, display the OSVersion property by typing:

```powershell
[System.Environment]::OSVersion
```

```Output
           Platform ServicePack         Version             VersionString
           -------- -----------         -------             -------------
            Win32NT Service Pack 2      5.1.2600.131072     Microsoft Windows...
```

We can check whether the computer is in the process of shutting down by displaying the
**HasShutdownStarted** property:

```powershell
[System.Environment]::HasShutdownStarted
```

```Output
False
```

## Doing math with System.Math

The **System.Math** static class is useful for performing some mathematical operations. The class
includes several useful methods, which we can display using `Get-Member`.

> [!NOTE]
> **System.Math** has several methods with the same name, but they're distinguished by the type of
> their parameters.

Type the following command to list the methods of the **System.Math** class.

```powershell
[System.Math] | Get-Member -Static -MemberType Methods
```

```Output
   TypeName: System.Math

Name            MemberType Definition
----            ---------- ----------
Abs             Method     static System.Single Abs(Single value), static Sy...
Acos            Method     static System.Double Acos(Double d)
Asin            Method     static System.Double Asin(Double d)
Atan            Method     static System.Double Atan(Double d)
Atan2           Method     static System.Double Atan2(Double y, Double x)
BigMul          Method     static System.Int64 BigMul(Int32 a, Int32 b)
Ceiling         Method     static System.Double Ceiling(Double a), static Sy...
Cos             Method     static System.Double Cos(Double d)
Cosh            Method     static System.Double Cosh(Double value)
DivRem          Method     static System.Int32 DivRem(Int32 a, Int32 b, Int3...
Equals          Method     static System.Boolean Equals(Object objA, Object ...
Exp             Method     static System.Double Exp(Double d)
Floor           Method     static System.Double Floor(Double d), static Syst...
IEEERemainder   Method     static System.Double IEEERemainder(Double x, Doub...
Log             Method     static System.Double Log(Double d), static System...
Log10           Method     static System.Double Log10(Double d)
Max             Method     static System.SByte Max(SByte val1, SByte val2), ...
Min             Method     static System.SByte Min(SByte val1, SByte val2), ...
Pow             Method     static System.Double Pow(Double x, Double y)
ReferenceEquals Method     static System.Boolean ReferenceEquals(Object objA...
Round           Method     static System.Double Round(Double a), static Syst...
Sign            Method     static System.Int32 Sign(SByte value), static Sys...
Sin             Method     static System.Double Sin(Double a)
Sinh            Method     static System.Double Sinh(Double value)
Sqrt            Method     static System.Double Sqrt(Double d)
Tan             Method     static System.Double Tan(Double a)
Tanh            Method     static System.Double Tanh(Double value)
Truncate        Method     static System.Decimal Truncate(Decimal d), static...
```

This displays several mathematical methods. Here is a list of commands that demonstrate how some of
the common methods work:

```powershell
[System.Math]::Sqrt(9)
3
[System.Math]::Pow(2,3)
8
[System.Math]::Floor(3.3)
3
[System.Math]::Floor(-3.3)
-4
[System.Math]::Ceiling(3.3)
4
[System.Math]::Ceiling(-3.3)
-3
[System.Math]::Max(2,7)
7
[System.Math]::Min(2,7)
2
[System.Math]::Truncate(9.3)
9
[System.Math]::Truncate(-9.3)
-9
```

# /./reference/samples/getting-wmi-objects--get-ciminstance-.md

    ---
    description: This article shows several examples of how to get instances of WMI objects from a computer system.
    ms.date: 12/08/2022
    title: Getting WMI objects with Get-CimInstance
    ---
# Getting WMI objects with Get-CimInstance

> This sample only applies to Windows platforms.

Windows Management Instrumentation (WMI) is a core technology for Windows system administration
because it exposes a wide range of information in a uniform manner. Because of how much WMI makes
possible, the PowerShell cmdlet for accessing WMI objects, `Get-CimInstance`, is one of the most
useful for doing real work. We're going to discuss how to use the CIM cmdlets to access WMI objects
and then how to use WMI objects to do specific things.

## Listing WMI classes

The first problem most WMI users face is trying to find out what can be done with WMI. WMI classes
describe the resources that can be managed. There are hundreds of WMI classes, some of which contain
dozens of properties.

`Get-CimClass` addresses this problem by making WMI discoverable. You can get a list of the WMI
classes available on the local computer by typing:

```powershell
Get-CimClass -Namespace root/CIMV2 | 
    Where-Object CimClassName -like Win32* | 
    Select-Object CimClassName
```

```Output
CimClassName
------------
Win32_DeviceChangeEvent
Win32_SystemConfigurationChangeEvent
Win32_VolumeChangeEvent
Win32_SystemTrace
Win32_ProcessTrace
Win32_ProcessStartTrace
Win32_ProcessStopTrace
Win32_ThreadTrace
Win32_ThreadStartTrace
Win32_ThreadStopTrace
...
```

You can retrieve the same information from a remote computer using the **ComputerName** parameter,
specifying a computer name or IP address:

```powershell
Get-CimClass -Namespace root/CIMV2 -ComputerName 192.168.1.29
```

The class listing returned by remote computers may vary due to the specific operating system the
computer is running and the particular WMI extensions are added by installed applications.

> [!NOTE]
> When using CIM cmdlets to connect to a remote computer, the remote computer must be running WMI
> and the account you are using must be in the local **Administrators** group on the remote
> computer. The remote system doesn't need to have PowerShell installed. This allows you to
> administer operating systems that aren't running PowerShell, but do have WMI available.

## Displaying WMI class details

If you already know the name of a WMI class, you can use it to get information immediately. For
example, one of the WMI classes commonly used for retrieving information about a computer is
**Win32_OperatingSystem**.

```powershell
Get-CimInstance -Class Win32_OperatingSystem
```

```Output
SystemDirectory     Organization BuildNumber RegisteredUser SerialNumber            Version
---------------     ------------ ----------- -------------- ------------            -------
C:\WINDOWS\system32 Microsoft    22621       USER1          00330-80000-00000-AA175 10.0.22621
```

Although we're showing all of the parameters, the command can be expressed in a more succinct way.
The **ComputerName** parameter isn't necessary when connecting to the local system. We show it to
demonstrate the most general case and remind you about the parameter. The **Namespace** defaults to
`root/CIMV2`, and can be omitted as well. Finally, most cmdlets allow you to omit the name of common
parameters. With `Get-CimInstance`, if no name is specified for the first parameter, PowerShell
treats it as the **Class** parameter. This means the last command could have been issued by typing:

```powershell
Get-CimInstance Win32_OperatingSystem
```

The **Win32_OperatingSystem** class has many more properties than those displayed here. You can use
Get-Member to see all the properties. The properties of a WMI class are automatically available like
other object properties:

```powershell
Get-CimInstance -Class Win32_OperatingSystem | Get-Member -MemberType Property
```

```Output
   TypeName: Microsoft.Management.Infrastructure.CimInstance#root/cimv2/Win32_OperatingSystem
Name                                      MemberType Definition
----                                      ---------- ----------
BootDevice                                Property   string BootDevice {get;}
BuildNumber                               Property   string BuildNumber {get;}
BuildType                                 Property   string BuildType {get;}
Caption                                   Property   string Caption {get;}
CodeSet                                   Property   string CodeSet {get;}
CountryCode                               Property   string CountryCode {get;}
CreationClassName                         Property   string CreationClassName {get;}
CSCreationClassName                       Property   string CSCreationClassName {get;}
CSDVersion                                Property   string CSDVersion {get;}
CSName                                    Property   string CSName {get;}
CurrentTimeZone                           Property   int16 CurrentTimeZone {get;}
DataExecutionPrevention_32BitApplications Property   bool DataExecutionPrevention_32BitApplications {get;}
DataExecutionPrevention_Available         Property   bool DataExecutionPrevention_Available {get;}
...
```

## Displaying non-default properties with Format cmdlets

If you want the information contained in the **Win32_OperatingSystem** class that isn't displayed by
default, you can display it by using the **Format** cmdlets. For example, if you want to display
available memory data, type:

```powershell
Get-CimInstance -Class Win32_OperatingSystem | Format-Table -Property TotalVirtualMemorySize, TotalVisibleMemorySize, FreePhysicalMemory, FreeVirtualMemory, FreeSpaceInPagingFiles
```

```Output
TotalVirtualMemorySize TotalVisibleMemorySize FreePhysicalMemory FreeVirtualMemory FreeSpaceInPagingFiles
---------------------- ---------------------- ------------------ ----------------- ----------------------
              41787920               16622096            9537952          33071884               25056628
```

> [!NOTE]
> Wildcards work with property names in `Format-Table`, so the final pipeline element can be
> reduced to `Format-Table -Property Total*Memory*, Free*`

The memory data might be more readable if you format it as a list by typing:

```powershell
Get-CimInstance -Class Win32_OperatingSystem | Format-List Total*Memory*, Free*
```

```Output
TotalVirtualMemorySize : 41787920
TotalVisibleMemorySize : 16622096
FreePhysicalMemory     : 9365296
FreeSpaceInPagingFiles : 25042952
FreeVirtualMemory      : 33013484
Name                   : Microsoft Windows 11 Pro|C:\Windows|\Device\Harddisk0\Partition2
```

# /./reference/samples/manipulating-items-directly.md

    ---
    description: PowerShell provides several cmdlets that help manage items on local and remote computers. Items are objects exposed by PowerShell providers like the filesystem, registry, certificates, and others.
    ms.date: 12/08/2022
    title: Manipulating Items Directly
    ---
# Manipulating items directly

The elements that you see in PowerShell drives, such as the files and folders or registry keys, are
called _Items_ in PowerShell. The cmdlets for working with them item have the noun **Item** in
their names.

The output of the `Get-Command -Noun Item` command shows that there are nine PowerShell item
cmdlets.

```powershell
Get-Command -Noun Item
```

```Output
CommandType     Name                            Definition
-----------     ----                            ----------
Cmdlet          Clear-Item                      Clear-Item [-Path] <String[]...
Cmdlet          Copy-Item                       Copy-Item [-Path] <String[]>...
Cmdlet          Get-Item                        Get-Item [-Path] <String[]> ...
Cmdlet          Invoke-Item                     Invoke-Item [-Path] <String[...
Cmdlet          Move-Item                       Move-Item [-Path] <String[]>...
Cmdlet          New-Item                        New-Item [-Path] <String[]> ...
Cmdlet          Remove-Item                     Remove-Item [-Path] <String[...
Cmdlet          Rename-Item                     Rename-Item [-Path] <String>...
Cmdlet          Set-Item                        Set-Item [-Path] <String[]> ...
```

## Creating new items

To create a new item in the filesystem, use the `New-Item` cmdlet. Include the **Path** parameter
with path to the item, and the **ItemType** parameter with a value of `file` or `directory`.

For example, to create a new directory named `New.Directory` in the `C:\Temp` directory, type:

```powershell
New-Item -Path c:\temp\New.Directory -ItemType Directory
```

```Output
    Directory: Microsoft.PowerShell.Core\FileSystem::C:\temp

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
d----        2006-05-18  11:29 AM            New.Directory
```

To create a file, change the value of the **ItemType** parameter to `file`. For example, to create a
file named `file1.txt` in the `New.Directory` directory, type:

```powershell
New-Item -Path C:\temp\New.Directory\file1.txt -ItemType file
```

```Output
    Directory: Microsoft.PowerShell.Core\FileSystem::C:\temp\New.Directory

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a---        2006-05-18  11:44 AM          0 file1
```

You can use the same technique to create a new registry key. In fact, a registry key is easier to
create because the only item type in the Windows registry is a key. (Registry entries are item
_properties_.) For example, to create a key named `_Test` in the `CurrentVersion` subkey, type:

```powershell
New-Item -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\_Test
```

```Output
   Hive: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion

SKC  VC Name                           Property
---  -- ----                           --------
  0   0 _Test                          {}
```

When typing a registry path, be sure to include the colon (`:`) in the PowerShell drive names,
`HKLM:` and `HKCU:`. Without the colon, PowerShell doesn't recognize the drive name in the path.

## Why registry values aren't items

When you use the `Get-ChildItem` cmdlet to find the items in a registry key, you will never see
actual registry entries or their values.

For example, the registry key `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`
usually contains several registry entries that represent applications that run when the system
starts.

However, when you use `Get-ChildItem` to look for child items in the key, all you will see is the
`OptionalComponents` subkey of the key:

```powershell
Get-ChildItem HKLM:\Software\Microsoft\Windows\CurrentVersion\Run
```

```Output
   Hive: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
SKC  VC Name                           Property
---  -- ----                           --------
  3   0 OptionalComponents             {}
```

Although it would be convenient to treat registry entries as items, you can't specify a path to a
registry entry in a way that ensures that it's unique. The path notation doesn't distinguish between
the registry subkey named **Run** and the **(Default)** registry entry in the **Run** subkey.
Furthermore, because registry entry names can contain the backslash character (`\`), if registry
entries were items, then you couldn't use the path notation to distinguish a registry entry named
`Windows\CurrentVersion\Run` from the subkey that's located in that path.

## Renaming existing items

To change the name of a file or folder, use the `Rename-Item` cmdlet. The following command changes
the name of the `file1.txt` file to `fileOne.txt`.

```powershell
Rename-Item -Path C:\temp\New.Directory\file1.txt fileOne.txt
```

The `Rename-Item` cmdlet can change the name of a file or a folder, but it can't move an item. The
following command fails because it attempts to move the file from the `New.Directory` directory to
the Temp directory.

```powershell
Rename-Item -Path C:\temp\New.Directory\fileOne.txt c:\temp\fileOne.txt
```

```Output
Rename-Item : can't rename because the target specified isn't a path.
At line:1 char:12
+ Rename-Item  <<<< -Path C:\temp\New.Directory\fileOne c:\temp\fileOne.txt
```

## Moving items

To move a file or folder, use the `Move-Item` cmdlet.

For example, the following command moves the New.Directory directory from the `C:\temp` directory to
the root of the `C:` drive. To verify that the item was moved, include the **PassThru** parameter of
the `Move-Item` cmdlet. Without **PassThru**, the `Move-Item` cmdlet doesn't display any results.

```powershell
Move-Item -Path C:\temp\New.Directory -Destination C:\ -PassThru
```

```Output
    Directory: Microsoft.PowerShell.Core\FileSystem::C:\

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
d----        2006-05-18  12:14 PM            New.Directory
```

## Copying items

If you are familiar with the copy operations in other shells, you might find the behavior of the
`Copy-Item` cmdlet in PowerShell to be unusual. When you copy an item from one location to another,
`Copy-Item` doesn't copy its contents by default.

For example, if you copy the `New.Directory` directory from the C: drive to the `C:\temp` directory,
the command succeeds, but the files in the New.Directory directory aren't copied.

```powershell
Copy-Item -Path C:\New.Directory -Destination C:\temp
```

If you display the contents of `C:\temp\New.Directory`, you will find that it contains no files:

```
PS> Get-ChildItem -Path C:\temp\New.Directory
PS>
```

Why doesn't the `Copy-Item` cmdlet copy the contents to the new location?

The `Copy-Item` cmdlet was designed to be generic; it isn't just for copying files and folders.
Also, even when copying files and folders, you might want to copy only the container and not the
items within it.

To copy all of the contents of a folder, include the **Recurse** parameter of the `Copy-Item` cmdlet
in the command. If you have already copied the directory without its contents, add the **Force**
parameter, which allows you to overwrite the empty folder.

```powershell
Copy-Item -Path C:\New.Directory -Destination C:\temp -Recurse -Force -Passthru
```

```Output
    Directory: Microsoft.PowerShell.Core\FileSystem::C:\temp

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
d----        2006-05-18   1:53 PM            New.Directory

    Directory: Microsoft.PowerShell.Core\FileSystem::C:\temp\New.Directory

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a---        2006-05-18  11:44 AM          0 file1
```

## Deleting items

To delete files and folders, use the `Remove-Item` cmdlet. PowerShell cmdlets, such as
`Remove-Item`, that can make significant, irreversible changes will often prompt for confirmation
when you enter its commands. For example, if you try to remove the `New.Directory` folder, you will
be prompted to confirm the command, because the folder contains files:

```powershell
Remove-Item C:\temp\New.Directory
```

```Output
Confirm
The item at C:\temp\New.Directory has children and the -recurse parameter was not
specified. If you continue, all children will be removed with the item. Are you
 sure you want to continue?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help
(default is "Y"):
```

Because `Yes` is the default response, to delete the folder and its files, press the
<kbd>Enter</kbd> key. To remove the folder without confirming, use the **Recurse** parameter.

```powershell
Remove-Item C:\temp\New.Directory -Recurse
```

## Executing items

PowerShell uses the `Invoke-Item` cmdlet to perform a default action for a file or folder. This
default action is determined by the default application handler in the registry; the effect is the
same as if you double-click the item in File Explorer.

For example, suppose you run the following command:

```powershell
Invoke-Item C:\WINDOWS
```

An Explorer window that's located in `C:\Windows` appears, just as if you had double-clicked the
`C:\Windows` folder.

If you invoke the `Boot.ini` file on a system prior to Windows Vista:

```powershell
Invoke-Item C:\boot.ini
```

If the `.ini` file type is associated with Notepad, the `boot.ini` file opens in Notepad.

# /./reference/samples/changing-computer-state.md

    ---
    description: This example shows how you can use external commands from PowerShell to manage the configuration of a computer.
    ms.date: 12/08/2022
    title: Changing computer state
    ---
# Changing computer state

> This sample only applies to Windows platforms.

To reset a computer in PowerShell, use either a standard command-line tool, WMI, or a CIM class.
Although you are using PowerShell only to run the tool, learning how to change a computer's power
state in PowerShell illustrates some of the important details about working with external tools in
PowerShell.

## Locking a computer

The only way to lock a computer directly with the standard available tools is to call the
**LockWorkstation()** function in **user32.dll**:

```powershell
rundll32.exe user32.dll,LockWorkStation
```

This command immediately locks the workstation. It uses `rundll32.exe` to call the
`LockWorkStation` function in `user32.dll`.

When you lock a workstation while Fast User Switching is enabled, such as on Windows XP, the
computer displays the user logon screen rather than starting the current user's screensaver.

To shut down particular sessions on a Terminal Server, use the **tsshutdn.exe** command-line tool.

## Logging off the current session

You can use several different techniques to log off of a session on the local system. The simplest
way is to use the Remote Desktop/Terminal Services command-line tool, **logoff.exe** (For details,
at the PowerShell prompt, type `logoff /?`). To log off the current active session, type `logoff`
with no arguments.

You can also use the **shutdown.exe** tool with its logoff option:

```powershell
shutdown.exe -l
```

Another option is to use WMI. The **Win32_OperatingSystem** class has a **Shutdown** method.
Invoking the method with the 0 flag initiates logoff:

For more information, see the [Shutdown method][01] of the **Win32_OperatingSystem** class.

```powershell
Get-CimInstance -ClassName Win32_OperatingSystem | Invoke-CimMethod -MethodName Shutdown
```

## Shutting down or restarting a computer

Shutting down and restarting computers are similar tasks. Most command-line tools support both
actions. Windows includes two command-line tools for restarting a computer. Use either
`tsshutdn.exe` or `shutdown.exe` with appropriate arguments. You can get detailed usage information
from `tsshutdn.exe /?` or `shutdown.exe /?`.

You can also perform shutdown and restart operations directly from PowerShell.

To shut down the computer, use the `Stop-Computer` command

```powershell
Stop-Computer
```

To restart the operating system, use the Restart-Computer command

```powershell
Restart-Computer
```

To force an immediate restart of the computer, use the -Force parameter.

```powershell
Restart-Computer -Force
```

<!-- link references -->
[01]: https://learn.microsoft.com/windows/win32/cimwin32prov/shutdown-method-in-class-win32-operatingsystem

# /./reference/samples/collecting-information-about-computers.md

    ---
    description: This article shows how to collection information about computer configuration use WMI and CIM cmdlets.
    ms.date: 12/08/2022
    title: Collecting information about computers
    ---
# Collecting information about computers

> This sample only applies to Windows platforms.

Cmdlets from **CimCmdlets** module are the most important cmdlets for general system management
tasks. All critical subsystem settings are exposed through WMI. Furthermore, WMI treats data as
objects that are in collections of one or more items. Because PowerShell also works with objects and
has a pipeline that allows you to treat single or multiple objects in the same way, generic WMI
access allows you to perform some advanced tasks with very little work.

## Listing desktop settings

We'll begin with a command that collects information about the desktops on the local computer.

```powershell
Get-CimInstance -ClassName Win32_Desktop
```

This returns information for all desktops, whether they're in use or not.

> [!NOTE]
> Information returned by some WMI classes can be very detailed, and often include metadata about
> the WMI class.

Because most of these metadata properties have names that begin with **Cim**, you can filter the
properties using `Select-Object`. Specify the **-ExcludeProperty** parameter with "Cim*" as the
value. For example:

```powershell
Get-CimInstance -ClassName Win32_Desktop | Select-Object -ExcludeProperty "CIM*"
```

To filter out the metadata, use a pipeline operator (|) to send the results of the `Get-CimInstance`
command to `Select-Object -ExcludeProperty "CIM*"`.

## Listing BIOS Information

The WMI **Win32_BIOS** class returns fairly compact and complete information about the system BIOS
on the local computer:

```powershell
Get-CimInstance -ClassName Win32_BIOS
```

## Listing Processor Information

You can retrieve general processor information by using WMI's **Win32_Processor** class, although
you will likely want to filter the information:

```powershell
Get-CimInstance -ClassName Win32_Processor | Select-Object -ExcludeProperty "CIM*"
```

For a generic description string of the processor family, you can just return the **SystemType**
property:

```powershell
Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -Property SystemType

SystemType
----------
X86-based PC
```

## Listing computer manufacturer and model

Computer model information is also available from **Win32_ComputerSystem**. The standard displayed
output will not need any filtering to provide OEM data:

```powershell
Get-CimInstance -ClassName Win32_ComputerSystem
```

```Output
Name PrimaryOwnerName Domain    TotalPhysicalMemory Model                   Manufacturer
---- ---------------- ------    ------------------- -----                   ------------
MyPC Jane Doe         WORKGROUP 804765696           DA243A-ABA 6415cl NA910 Compaq Presario 06
```

Your output from commands such as this, which return information directly from some hardware, is
only as good as the data you have. Some information isn't correctly configured by hardware
manufacturers and may therefore be unavailable.

## Listing installed hotfixes

You can list all installed hotfixes by using **Win32_QuickFixEngineering**:

```powershell
Get-CimInstance -ClassName Win32_QuickFixEngineering
```

This class returns a list of hotfixes that looks like this:

```Output
Source Description     HotFixID  InstalledBy   InstalledOn PSComputerName
------ -----------     --------  -----------   ----------- --------------
       Security Update KB4048951 Administrator 12/16/2017  .
```

For more succinct output, you may want to exclude some properties. Although you can use the
`Get-CimInstance`'s **Property** parameter to choose only the **HotFixID**, doing so will actually
return more information, because all the metadata is displayed by default:

```powershell
Get-CimInstance -ClassName Win32_QuickFixEngineering -Property HotFixID
```

```Output
InstalledOn           :
Caption               :
Description           :
InstallDate           :
Name                  :
Status                :
CSName                :
FixComments           :
HotFixID              : KB4533002
InstalledBy           :
ServicePackInEffect   :
PSComputerName        :
CimClass              : root/cimv2:Win32_QuickFixEngineering
CimInstanceProperties : {Caption, Description, InstallDate, Name…}
CimSystemProperties   : Microsoft.Management.Infrastructure.CimSystemProperties
...
```

The additional data is returned, because the **Property** parameter in `Get-CimInstance` restricts
the properties returned from WMI class instances, not the object returned to PowerShell. To reduce
the output, use `Select-Object`:

```powershell
Get-CimInstance -ClassName Win32_QuickFixEngineering -Property HotFixId |
    Select-Object -Property HotFixId
```

```Output
HotFixId
--------
KB4048951
```

## Listing operating system version information

The **Win32_OperatingSystem** class properties include version and service pack information. You can
explicitly select only these properties to get a version information summary from
**Win32_OperatingSystem**:

```powershell
Get-CimInstance -ClassName Win32_OperatingSystem |
  Select-Object -Property BuildNumber,BuildType,OSType,ServicePackMajorVersion,ServicePackMinorVersion
```

You can also use wildcards with the **Property** parameter. Because all the properties beginning
with either **Build** or **ServicePack** are important to use here, we can shorten this to the
following form:

```powershell
Get-CimInstance -ClassName Win32_OperatingSystem |
    Select-Object -Property Build*,OSType,ServicePack*
```

```Output
BuildNumber             : 18362
BuildType               : Multiprocessor Free
OSType                  : 18
ServicePackMajorVersion : 0
ServicePackMinorVersion : 0
```

## Listing local users and owner

General information about local users can be found with a selection of **Win32_OperatingSystem**
class properties. You can explicitly select the properties to display like this:

```powershell
Get-CimInstance -ClassName Win32_OperatingSystem |
    Select-Object -Property NumberOfLicensedUsers, NumberOfUsers, RegisteredUser
```

A more succinct version using wildcards is:

```powershell
Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property *user*
```

## Getting available disk space

To see the disk space and free space for local drives, you can use the **Win32_LogicalDisk** class.
You need to see only instances with a **DriveType** of 3, the value WMI uses for fixed hard disks.

```powershell
Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3"
```

```Output
DeviceID DriveType ProviderName VolumeName Size         FreeSpace   PSComputerName
-------- --------- ------------ ---------- ----         ---------   --------------
C:       3                      Local Disk 203912880128 65541357568 .
Q:       3                      New Volume 122934034432 44298250240 .
```

```powershell
Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3" |
    Measure-Object -Property FreeSpace,Size -Sum |
    Select-Object -Property Property,Sum
```

```Output
Property           Sum
--------           ---
FreeSpace 109839607808
Size      326846914560
```

## Getting logon session information

You can get general information about logon sessions associated with users through the
**Win32_LogonSession** WMI class:

```powershell
Get-CimInstance -ClassName Win32_LogonSession
```

## Getting the user logged on to a computer

You can display the user logged on to a particular computer system using **Win32_ComputerSystem**.
This command returns only the user logged on to the system desktop:

```powershell
Get-CimInstance -ClassName Win32_ComputerSystem -Property UserName
```

## Getting local time from a computer

You can retrieve the current local time on a specific computer using the **Win32_LocalTime** WMI
class.

```powershell
Get-CimInstance -ClassName Win32_LocalTime
```

```Output
Day            : 23
DayOfWeek      : 1
Hour           : 8
Milliseconds   :
Minute         : 52
Month          : 12
Quarter        : 4
Second         : 55
WeekInMonth    : 4
Year           : 2019
PSComputerName :
```

## Displaying service status

To view the status of all services on a specific computer, you can locally use the `Get-Service`
cmdlet. For remote systems, you can use the **Win32_Service** WMI class. If you also use
`Select-Object` to filter the results to **Status**, **Name**, and **DisplayName**, the output
format is almost identical to that from `Get-Service`:

```powershell
Get-CimInstance -ClassName Win32_Service |
    Select-Object -Property Status,Name,DisplayName
```

To allow the complete display of names for services with long names, use the **AutoSize** and
**Wrap** parameters of `Format-Table`. These parameters optimize column width and allow long names
to wrap instead of being truncated:

```powershell
Get-CimInstance -ClassName Win32_Service |
    Format-Table -Property Status, Name, DisplayName -AutoSize -Wrap
```

# /./reference/samples/creating-get-winEvent-queries-with-filterhashtable.md

    ---
    description: This article how to use the FilterHashtable of Get-WinEvent to query the Windows Event logs.
    ms.date: 06/28/2023
    title: Creating Get-WinEvent queries with FilterHashtable
    ---

# Creating Get-WinEvent queries with FilterHashtable

> This sample only applies to Windows platforms.

To read the original June 3, 2014 **Scripting Guy** blog post, see
[Use FilterHashTable to Filter Event Log with PowerShell][09].

This article is an excerpt of the original blog post and explains how to use the `Get-WinEvent`
cmdlet's **FilterHashtable** parameter to filter event logs. PowerShell's `Get-WinEvent` cmdlet is a
powerful method to filter Windows event and diagnostic logs. Performance improves when a
`Get-WinEvent` query uses the **FilterHashtable** parameter.

When you work with large event logs, it's not efficient to send objects down the pipeline to a
`Where-Object` command. Prior to PowerShell 6, the `Get-EventLog` cmdlet was another option to get
log data. For example, the following commands are inefficient to filter the
**Microsoft-Windows-Defrag** logs:

```powershell
Get-EventLog -LogName Application | Where-Object Source -Match defrag

Get-WinEvent -LogName Application | Where-Object { $_.ProviderName -Match 'defrag' }
```

The following command uses a hash table that improves the performance:

```powershell
Get-WinEvent -FilterHashtable @{
   LogName='Application'
   ProviderName='*defrag'
}
```

## Blog posts about enumeration

This article presents information about how to use enumerated values in a hash table. For more
information about enumeration, read these **Scripting Guy** blog posts. To create a function that
returns the enumerated values, see [Enumerations and Values][08]. For more information, see the
[Scripting Guy series of blog posts about enumeration][07].

## Hash table key-value pairs

To build efficient queries, use the `Get-WinEvent` cmdlet with the **FilterHashtable** parameter.
**FilterHashtable** accepts a hash table as a filter to get specific information from Windows event
logs. A hash table uses **key-value** pairs. For more information about hash tables, see
[about_Hash_Tables][05].

If the **key-value** pairs are on the same line, they must be separated by a semicolon. If each
**key-value** pair is on a separate line, the semicolon isn't needed. For example, this article
places **key-value** pairs on separate lines and doesn't use semicolons.

This sample uses several of the **FilterHashtable** parameter's **key-value** pairs. The completed
query includes **LogName**, **ProviderName**, **Keywords**, **ID**, and **Level**.

The accepted **key-value** pairs are shown in the following table and are included in the
documentation for the [Get-WinEvent][06] **FilterHashtable** parameter.

The following table displays the key names, data types, and whether wildcard characters are accepted
for a data value.

|    Key name    | Value data type | Accepts wildcard characters? |
| -------------- | --------------- | ---------------------------- |
| LogName        | `<String[]>`    | Yes                          |
| ProviderName   | `<String[]>`    | Yes                          |
| Path           | `<String[]>`    | No                           |
| Keywords       | `<Long[]>`      | No                           |
| ID             | `<Int32[]>`     | No                           |
| Level          | `<Int32[]>`     | No                           |
| StartTime      | `<DateTime>`    | No                           |
| EndTime        | `<DateTime>`    | No                           |
| UserID         | `<SID>`         | No                           |
| Data           | `<String[]>`    | No                           |
| `<named-data>` | `<String[]>`    | No                           |

The `<named-data>` key represents a named event data field. For example, the Perflib event 1008
can contain the following event data:

```xml
<EventData>
  <Data Name="Service">BITS</Data>
  <Data Name="Library">C:\Windows\System32\bitsperf.dll</Data>
  <Data Name="Win32Error">2</Data>
</EventData>
```

You can query for these events using the following command:

```powershell
Get-WinEvent -FilterHashtable @{LogName='Application'; 'Service'='Bits'}
```

> [!NOTE]
> The ability to query for `<named-data>` was added in PowerShell 6.

## Building a query with a hash table

To verify results and troubleshoot problems, it helps to build the hash table one **key-value** pair
at a time. The query gets data from the **Application** log. The hash table is equivalent to
`Get-WinEvent -LogName Application`.

To begin, create the `Get-WinEvent` query. Use the **FilterHashtable** parameter's **key-value**
pair with the key, **LogName**, and the value, **Application**.

```powershell
Get-WinEvent -FilterHashtable @{
   LogName='Application'
}
```

Continue to build the hash table with the **ProviderName** key. Usually, the **ProviderName** is the
name that appears in the **Source** field in the **Windows Event Viewer**. For example,
`.NET Runtime` in the following screenshot:

[Image of Windows Event Viewer sources][02]

Update the hash table and include the **key-value** pair with the key, **ProviderName**, and the
value, `.NET Runtime`.

```powershell
Get-WinEvent -FilterHashtable @{
   LogName='Application'
   ProviderName='.NET Runtime'
}
```

> [!NOTE]
> For some event providers, the correct **ProviderName** can be obtained by looking on the
> **Details** tab in **Event Properties**. For example, events where the **Source** field shows
> `Defrag`, the correct **ProviderName** is `Microsoft-Windows-Defrag`.

If your query needs to get data from archived event logs, use the **Path** key. The **Path** value
specifies the full path to the log file. For more information, see the **Scripting Guy** blog post,
[Use PowerShell to Parse Saved Event Logs for Errors][10].

## Using enumerated values in a hash table

**Keywords** is the next key in the hash table. The **Keywords** data type is an array of the
`[long]` value type that holds a large number. Use the following command to find the maximum value
of `[long]`:

```powershell
[long]::MaxValue
```

```Output
9223372036854775807
```

For the **Keywords** key, PowerShell uses a number, not a string such as **Security**. **Windows
Event Viewer** displays the **Keywords** as strings, but they're enumerated values. In the hash
table, if you use the **Keywords** key with a string value, an error message is displayed.

Open the **Windows Event Viewer** and from the **Actions** pane, click on **Filter current log**.
The **Keywords** drop-down menu displays the available keywords, as shown in the following
screenshot:

[Image of Windows Event Viewer keywords][01]

Use the following command to display the `StandardEventKeywords` property names.

```powershell
[System.Diagnostics.Eventing.Reader.StandardEventKeywords] |
    Get-Member -Static -MemberType Property
```

```Output
   TypeName: System.Diagnostics.Eventing.Reader.StandardEventKeywords
Name             MemberType Definition
—-             ———- ———-
AuditFailure     Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
AuditSuccess     Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
CorrelationHint  Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
CorrelationHint2 Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
EventLogClassic  Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
None             Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
ResponseTime     Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
Sqm              Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
WdiContext       Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
WdiDiagnostic    Property   static System.Diagnostics.Eventing.Reader.StandardEventKey…
```

The enumerated values are documented in the **.NET Framework**. For more information, see
[StandardEventKeywords Enumeration][03].

The **Keywords** names and enumerated values are as follows:

| Name             |  Value            |
| ---------------- | ------------------|
| AuditFailure     | 4503599627370496  |
| AuditSuccess     | 9007199254740992  |
| CorrelationHint2 | 18014398509481984 |
| EventLogClassic  | 36028797018963968 |
| Sqm              | 2251799813685248  |
| WdiDiagnostic    | 1125899906842624  |
| WdiContext       | 562949953421312   |
| ResponseTime     | 281474976710656   |
| None             | 0                 |

Update the hash table and include the **key-value** pair with the key, **Keywords**, and the
**EventLogClassic** enumeration value, **36028797018963968**.

```powershell
Get-WinEvent -FilterHashtable @{
   LogName='Application'
   ProviderName='.NET Runtime'
   Keywords=36028797018963968
}
```

### Keywords static property value (optional)

The **Keywords** key is enumerated, but you can use a static property name in the hash table query.
Rather than using the returned string, the property name must be converted to a value with the
**Value__** property.

For example, the following script uses the **Value__** property.

```powershell
$C = [System.Diagnostics.Eventing.Reader.StandardEventKeywords]::EventLogClassic
Get-WinEvent -FilterHashtable @{
   LogName='Application'
   ProviderName='.NET Runtime'
   Keywords=$C.Value__
}
```

## Filtering by Event Id

To get more specific data, the query's results are filtered by **Event Id**. The **Event Id** is
referenced in the hash table as the key **ID** and the value is a specific **Event Id**. The
**Windows Event Viewer** displays the **Event Id**. This example uses **Event Id 1023**.

Update the hash table and include the **key-value** pair with the key, **ID** and the value,
**1023**.

```powershell
Get-WinEvent -FilterHashtable @{
   LogName='Application'
   ProviderName='.NET Runtime'
   Keywords=36028797018963968
   ID=1023
}
```

## Filtering by Level

To further refine the results and include only events that are errors, use the **Level** key.
**Windows Event Viewer** displays the **Level** as string values, but they're enumerated values. In
the hash table, if you use the **Level** key with a string value, an error message is displayed.

**Level** has values such as **Error**, **Warning**, or **Informational**. Use the following command
to display the `StandardEventLevel` property names.

```powershell
[System.Diagnostics.Eventing.Reader.StandardEventLevel] |
    Get-Member -Static -MemberType Property
```

```Output
   TypeName: System.Diagnostics.Eventing.Reader.StandardEventLevel

Name          MemberType Definition
----          ---------- ----------
Critical      Property   static System.Diagnostics.Eventing.Reader.StandardEventLevel Critical {get;}
Error         Property   static System.Diagnostics.Eventing.Reader.StandardEventLevel Error {get;}
Informational Property   static System.Diagnostics.Eventing.Reader.StandardEventLevel Informational {get;}
LogAlways     Property   static System.Diagnostics.Eventing.Reader.StandardEventLevel LogAlways {get;}
Verbose       Property   static System.Diagnostics.Eventing.Reader.StandardEventLevel Verbose {get;}
Warning       Property   static System.Diagnostics.Eventing.Reader.StandardEventLevel Warning {get;}
```

The enumerated values are documented in the **.NET Framework**. For more information, see
[StandardEventLevel Enumeration][04].

The **Level** key's names and enumerated values are as follows:

| Name           | Value |
| -------------- | ----- |
| Verbose        |   5   |
| Informational  |   4   |
| Warning        |   3   |
| Error          |   2   |
| Critical       |   1   |
| LogAlways      |   0   |

The hash table for the completed query includes the key, **Level**, and the value, **2**.

```powershell
Get-WinEvent -FilterHashtable @{
   LogName='Application'
   ProviderName='.NET Runtime'
   Keywords=36028797018963968
   ID=1023
   Level=2
}
```

### Level static property in enumeration (optional)

The **Level** key is enumerated, but you can use a static property name in the hash table query.
Rather than using the returned string, the property name must be converted to a value with the
**Value__** property.

For example, the following script uses the **Value__** property.

```powershell
$C = [System.Diagnostics.Eventing.Reader.StandardEventLevel]::Informational
Get-WinEvent -FilterHashtable @{
   LogName='Application'
   ProviderName='.NET Runtime'
   Keywords=36028797018963968
   ID=1023
   Level=$C.Value__
}
```

<!-- link references -->
[01]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/samples/media/creating-get-winEvent-queries-with-filterhashtable/keywords.png
[02]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/samples/media/creating-get-winEvent-queries-with-filterhashtable/providername.png
[03]: https://learn.microsoft.com/dotnet/api/system.diagnostics.eventing.reader.standardeventkeywords
[04]: https://learn.microsoft.com/dotnet/api/system.diagnostics.eventing.reader.standardeventlevel
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_hash_tables
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.diagnostics/Get-WinEvent
[07]: https://devblogs.microsoft.com/scripting/tag/enum/
[08]: https://devblogs.microsoft.com/scripting/hey-scripting-guy-weekend-scripter-enumerations-and-values
[09]: https://devblogs.microsoft.com/scripting/use-filterhashtable-to-filter-event-log-with-powershell/
[10]: https://devblogs.microsoft.com/scripting/use-powershell-to-parse-saved-event-logs-for-errors

# /./reference/samples/managing-processes-with-process-cmdlets.md

    ---
    description: PowerShell provides several cmdlets that help manage processes on local and remote computers.
    ms.date: 12/08/2022
    title: Managing processes with Process cmdlets
    ---
# Managing processes with Process cmdlets

> This sample only applies to Windows PowerShell 5.1.

You can use the Process cmdlets in PowerShell to manage local and remote processes in
PowerShell.

## Getting processes

To get the processes running on the local computer, run a `Get-Process` with no parameters.

You can get particular processes by specifying their process names or process IDs. The following
command gets the Idle process:

```powershell
Get-Process -id 0
```

```Output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
      0       0        0         16     0               0 Idle
```

Although it's normal for cmdlets to return no data in some situations, when you specify a process by
its **ProcessId**, `Get-Process` generates an error if it finds no matches, because the usual intent
is to retrieve a known running process. If there is no process with that ID, it's likely that the ID
is incorrect or that the process of interest has already exited:

```powershell
Get-Process -Id 99
```

```Output
Get-Process : No process with process ID 99 was found.
At line:1 char:12
+ Get-Process  <<<< -Id 99
```

You can use the Name parameter of the `Get-Process` cmdlet to specify a subset of processes based on
the process name. The Name parameter can take multiple names in a comma-separated list and it
supports the use of wildcards, so you can type name patterns.

For example, the following command gets process whose names begin with "ex."

```powershell
Get-Process -Name ex*
```

```Output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    234       7     5572      12484   134     2.98   1684 EXCEL
    555      15    34500      12384   134   105.25    728 explorer
```

Because the .NET **System.Diagnostics.Process** class is the foundation for PowerShell processes, it
follows some of the conventions used by **System.Diagnostics.Process**. One of those conventions is
that the process name for an executable never includes the `.exe` at the end of the executable name.

`Get-Process` also accepts multiple values for the Name parameter.

```powershell
Get-Process -Name exp*,power*
```

```Output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    540      15    35172      48148   141    88.44    408 explorer
    605       9    30668      29800   155     7.11   3052 powershell
```

You can use the ComputerName parameter of `Get-Process` to get processes on remote computers. For
example, the following command gets the PowerShell processes on the local computer (represented by
"localhost") and on two remote computers.

```powershell
Get-Process -Name PowerShell -ComputerName localhost, Server01, Server02
```

```Output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    258       8    29772      38636   130            3700 powershell
    398      24    75988      76800   572            5816 powershell
    605       9    30668      29800   155     7.11   3052 powershell
```

The computer names aren't evident in this display, but they're stored in the **MachineName** property of
the process objects that `Get-Process` returns. The following command uses the `Format-Table` cmdlet
to display the process **ID**, **ProcessName** and **MachineName** (ComputerName) properties of the
process objects.

```powershell
Get-Process -Name PowerShell -ComputerName localhost, Server01, Server01 |
    Format-Table -Property ID, ProcessName, MachineName
```

```Output
  Id ProcessName MachineName
  -- ----------- -----------
3700 powershell  Server01
3052 powershell  Server02
5816 powershell  localhost
```

This more complex command adds the **MachineName** property to the standard `Get-Process` display.

```powershell
Get-Process powershell -ComputerName localhost, Server01, Server02 |
    Format-Table -Property Handles,
        @{Label="NPM(K)";Expression={[int]($_.NPM/1024)}},
        @{Label="PM(K)";Expression={[int]($_.PM/1024)}},
        @{Label="WS(K)";Expression={[int]($_.WS/1024)}},
        @{Label="VM(M)";Expression={[int]($_.VM/1MB)}},
        @{Label="CPU(s)";Expression={if ($_.CPU -ne $()){$_.CPU.ToString("N")}}},
        Id, ProcessName, MachineName -auto
```

```Output
Handles  NPM(K)  PM(K) WS(K) VM(M) CPU(s)  Id ProcessName  MachineName
-------  ------  ----- ----- ----- ------  -- -----------  -----------
    258       8  29772 38636   130         3700 powershell Server01
    398      24  75988 76800   572         5816 powershell localhost
    605       9  30668 29800   155 7.11    3052 powershell Server02
```

## Stopping processes

PowerShell gives you flexibility for listing processes, but what about stopping a process?

The `Stop-Process` cmdlet takes a **Name** or **Id** to specify a process you want to stop. Your ability to
stop processes depends on your permissions. Some processes can't be stopped. For example, if you try
to stop the idle process, you get an error:

```powershell
Stop-Process -Name Idle
```

```Output
Stop-Process : Process 'Idle (0)' cannot be stopped due to the following error:
 Access is denied
At line:1 char:13
+ Stop-Process  <<<< -Name Idle
```

You can also force prompting with the **Confirm** parameter. This parameter is particularly useful
if you use a wildcard when specifying the process name, because you may accidentally match some
processes you don't want to stop:

```powershell
Stop-Process -Name t*,e* -Confirm
```

```Output
Confirm
Are you sure you want to perform this action?
Performing operation "Stop-Process" on Target "explorer (408)".
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help
(default is "Y"):n
Confirm
Are you sure you want to perform this action?
Performing operation "Stop-Process" on Target "taskmgr (4072)".
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help
(default is "Y"):n
```

Complex process manipulation is possible by using some of the object filtering cmdlets. Because a
Process object has a **Responding** property that's true when it's no longer responding, you can
stop all nonresponsive applications with the following command:

```powershell
Get-Process | Where-Object -FilterScript {$_.Responding -eq $false} | Stop-Process
```

You can use the same approach in other situations. For example, suppose a secondary notification
area application automatically runs when users start another application. You may find that this
doesn't work correctly in Terminal Services sessions, but you still want to keep it in sessions that
run on the physical computer console. Sessions connected to the physical computer desktop always
have a session ID of 0, so you can stop all instances of the process that are in other sessions by
using `Where-Object` and the process, **SessionId**:

```powershell
Get-Process -Name BadApp | Where-Object -FilterScript {$_.SessionId -neq 0} | Stop-Process
```

The `Stop-Process` cmdlet doesn't have a **ComputerName** parameter. Therefore, to run a stop process
command on a remote computer, you need to use the `Invoke-Command` cmdlet. For example, to stop the
PowerShell process on the Server01 remote computer, type:

```powershell
Invoke-Command -ComputerName Server01 {Stop-Process Powershell}
```

## Stopping All Other PowerShell Sessions

It may occasionally be useful to be able to stop all running PowerShell sessions other than the
current session. If a session is using too many resources or is inaccessible (it may be running
remotely or in another desktop session), you may not be able to directly stop it. If you try to stop
all running sessions, however, the current session may be terminated instead.

Each PowerShell session has an environment variable PID that contains the **Id** of the Windows
PowerShell process. You can check the $PID against the Id of each session and terminate only Windows
PowerShell sessions that have a different Id. The following pipeline command does this and returns
the list of terminated sessions (because of the use of the **PassThru** parameter):

```powershell
Get-Process -Name powershell | Where-Object -FilterScript {$_.Id -ne $PID} |
    Stop-Process -PassThru
```

```Output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    334       9    23348      29136   143     1.03    388 powershell
    304       9    23152      29040   143     1.03    632 powershell
    302       9    20916      26804   143     1.03   1116 powershell
    335       9    25656      31412   143     1.09   3452 powershell
    303       9    23156      29044   143     1.05   3608 powershell
    287       9    21044      26928   143     1.02   3672 powershell
```

## Starting, debugging, and waiting for processes

PowerShell also comes with cmdlets to start (or restart), debug a process, and wait for a process to
complete before running a command. For information about these cmdlets, see the cmdlet help topic
for each cmdlet.

## See also

- [Get-Process][03]
- [Stop-Process][05]
- [Start-Process][04]
- [Wait-Process][06]
- [Debug-Process][02]
- [Invoke-Command][01]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/Invoke-Command
[02]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/Debug-Process
[03]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/Get-Process
[04]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/Start-Process
[05]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/Stop-Process
[06]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/Wait-Process

# /./reference/samples/managing-services.md

    ---
    description: PowerShell provides several cmdlets that help manage services on local and remote computers.
    ms.date: 12/08/2022
    title: Managing services
    ---
# Managing services

> This sample only applies to Windows PowerShell 5.1.

There are eight core **Service** cmdlets, designed for a wide range of service tasks . This article
only looks at listing and changing running state for services. You can get a list of service cmdlets
using `Get-Command *-Service`. You can find information about each cmdlet by using
`Get-Help <Cmdlet-Name>`, such as `Get-Help New-Service`.

## Getting services

You can get the services on a local or remote computer by using the `Get-Service` cmdlet. As with
`Get-Process`, using the `Get-Service` command without parameters returns all services. You can
filter by name, even using an asterisk as a wildcard:

```powershell
PS> Get-Service -Name se*

Status   Name               DisplayName
------   ----               -----------
Running  seclogon           Secondary Logon
Running  SENS               System Event Notification
Stopped  ServiceLayer       ServiceLayer
```

Because it isn't always apparent what the real name for the service is, you may find you need to
find services by display name. You can search by specific name, use wildcards, or provide a list of
display names:

```powershell
PS> Get-Service -DisplayName se*

Status   Name               DisplayName
------   ----               -----------
Running  lanmanserver       Server
Running  SamSs              Security Accounts Manager
Running  seclogon           Secondary Logon
Stopped  ServiceLayer       ServiceLayer
Running  wscsvc             Security Center

PS> Get-Service -DisplayName ServiceLayer, Server

Status   Name               DisplayName
------   ----               -----------
Running  lanmanserver       Server
Stopped  ServiceLayer       ServiceLayer
```

## Getting remote services

With Windows PowerShell, you can use the **ComputerName** parameter of the `Get-Service` cmdlet to
get the services on remote computers. The **ComputerName** parameter accepts multiple values and
wildcard characters, so you can get the services on multiple computers with a single command. For
example, the following command gets the services on the Server01 remote computer.

```powershell
Get-Service -ComputerName Server01
```

Starting in PowerShell 6.0, the `*-Service` cmdlets don't have the **ComputerName** parameter. You
can still get services on remote computers with PowerShell remoting. For example, the following
command gets the services on the Server02 remote computer.

```powershell
Invoke-Command -ComputerName Server02 -ScriptBlock { Get-Service }
```

You can also manage services with the other `*-Service` cmdlets. For more information on PowerShell
remoting, see [about_Remote][01].

## Getting required and dependent services

The Get-Service cmdlet has two parameters that are very useful in service administration. The
DependentServices parameter gets services that depend on the service.

The **RequiredServices** parameter gets services upon which the LanmanWorkstation service depends.

```powershell
PS> Get-Service -Name LanmanWorkstation -RequiredServices

Status   Name               DisplayName
------   ----               -----------
Running  MRxSmb20           SMB 2.0 MiniRedirector
Running  bowser             Bowser
Running  MRxSmb10           SMB 1.x MiniRedirector
Running  NSI                Network Store Interface Service
```

The **DependentServices** parameter gets that require the LanmanWorkstation service.

```powershell
PS> Get-Service -Name LanmanWorkstation -DependentServices

Status   Name               DisplayName
------   ----               -----------
Running  SessionEnv         Terminal Services Configuration
Running  Netlogon           Netlogon
Stopped  Browser            Computer Browser
Running  BITS               Background Intelligent Transfer Ser...
```

The following command gets all services that have dependencies. The `Format-Table` cmdlet to display
the **Status**, **Name**, **RequiredServices**, and **DependentServices** properties of the
services.

```powershell
Get-Service -Name * | Where-Object {$_.RequiredServices -or $_.DependentServices} |
  Format-Table -Property Status, Name, RequiredServices, DependentServices -auto
```

## Stopping, starting, suspending, and restarting services

The Service cmdlets all have the same general form. Services can be specified by common name or
display name, and take lists and wildcards as values. To stop the print spooler, use:

```powershell
Stop-Service -Name spooler
```

To start the print spooler after it's stopped, use:

```powershell
Start-Service -Name spooler
```

To suspend the print spooler, use:

```powershell
Suspend-Service -Name spooler
```

The `Restart-Service` cmdlet works in the same manner as the other Service cmdlets:

```powershell
PS> Restart-Service -Name spooler

WARNING: Waiting for service 'Print Spooler (Spooler)' to finish starting...
WARNING: Waiting for service 'Print Spooler (Spooler)' to finish starting...
PS>
```

Notice that you get a repeated warning message about the Print Spooler starting up. When you perform
a service operation that takes some time, PowerShell notifies you that it's still attempting to
perform the task.

If you want to restart multiple services, you can get a list of services, filter them, and then
perform the restart:

```powershell
PS> Get-Service | Where-Object -FilterScript {$_.CanStop} | Restart-Service

WARNING: Waiting for service 'Computer Browser (Browser)' to finish stopping...
WARNING: Waiting for service 'Computer Browser (Browser)' to finish stopping...
Restart-Service : can't stop service 'Logical Disk Manager (dmserver)' because
 it has dependent services. It can only be stopped if the Force flag is set.
At line:1 char:57
+ Get-Service | Where-Object -FilterScript {$_.CanStop} | Restart-Service <<<<
WARNING: Waiting for service 'Print Spooler (Spooler)' to finish starting...
WARNING: Waiting for service 'Print Spooler (Spooler)' to finish starting...
```

These Service cmdlets don't have a **ComputerName** parameter, but you can run them on a remote
computer by using the `Invoke-Command` cmdlet. For example, the following command restarts the
Spooler service on the Server01 remote computer.

```powershell
Invoke-Command -ComputerName Server01 {Restart-Service Spooler}
```

## Setting service properties

The `Set-Service` cmdlet changes the properties of a service on a local or remote computer. Because
the service status is a property, you can use this cmdlet to start, stop, and suspend a service.
The Set-Service cmdlet also has a StartupType parameter that lets you change the service startup
type.

To use `Set-Service` on Windows Vista and later versions of Windows, open PowerShell with the **Run
as administrator** option.

For more information, see [Set-Service][04]

## See also

- [about_Remote][01]
- [Get-Service][02]
- [Set-Service][04]
- [Restart-Service][03]
- [Suspend-Service][05]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/about/about_Remote
[02]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/get-service
[03]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/restart-service
[04]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/set-service
[05]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/suspend-service

# /./reference/samples/working-with-printers.md

    ---
    description: This articles shows how to manage printers in Windows using WMI objects and COM interfaces.
    ms.date: 12/08/2022
    title: Working with printers
    ---
# Working with printers in Windows

> This sample only applies to Windows platforms.

You can use PowerShell to manage printers using WMI and the **WScript.Network** COM object from WSH.

## Listing printer connections

The simplest way to list the printers installed on a computer is to use the WMI **Win32_Printer**
class:

```powershell
Get-CimInstance -Class Win32_Printer
```

You can also list the printers using the **WScript.Network** COM object that's typically used in WSH
scripts:

```powershell
(New-Object -ComObject WScript.Network).EnumPrinterConnections()
```

Because this command returns a simple string collection of port names and printer device names
without any distinguishing labels, it isn't easy to interpret.

## Adding a network printer

To add a new network printer, use **WScript.Network**:

```powershell
(New-Object -ComObject WScript.Network).AddWindowsPrinterConnection("\\Printserver01\Xerox5")
```

## Setting a default printer

To use WMI to set the default printer, find the printer in the **Win32_Printer** collection and then
invoke the **SetDefaultPrinter** method:

```powershell
$printer = Get-CimInstance -Class Win32_Printer -Filter "Name='HP LaserJet 5Si'"
Invoke-CimMethod -InputObject $printer -MethodName SetDefaultPrinter
```

**WScript.Network** is a little simpler to use, because it has a **SetDefaultPrinter** method that
takes only the printer name as an argument:

```powershell
(New-Object -ComObject WScript.Network).SetDefaultPrinter('HP LaserJet 5Si')
```

## Removing a printer connection

To remove a printer connection, use the **WScript.Network RemovePrinterConnection** method:

```powershell
(New-Object -ComObject WScript.Network).RemovePrinterConnection("\\Printserver01\Xerox5")
```

# /./reference/samples/performing-networking-tasks.md

    ---
    description: This article shows how to use WMI classes in PowerShell to manage network configuration setting in Windows.
    ms.date: 12/08/2022
    title: Performing networking tasks
    ---
# Performing networking tasks

> This sample only applies to Windows platforms.

Because TCP/IP is the most commonly used network protocol, most low-level network protocol
administration tasks involve TCP/IP. In this section, we use PowerShell and WMI to do these tasks.

## Listing IP addresses for a computer

To get all IP addresses in use on the local computer, use the following command:

```powershell
Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter IPEnabled=$true |
    Select-Object -ExpandProperty IPAddress
```

Since the **IPAddress** property of a **Win32_NetworkAdapterConfiguration** object is an array, you
must use the **ExpandProperty** parameter of `Select-Object` to see the entire list of addresses.

```Output
10.0.0.1
fe80::60ea:29a7:a233:7cb7
2601:600:a27f:a470:f532:6451:5630:ec8b
2601:600:a27f:a470:e167:477d:6c5c:342d
2601:600:a27f:a470:b021:7f0d:eab9:6299
2601:600:a27f:a470:a40e:ebce:1a8c:a2f3
2601:600:a27f:a470:613c:12a2:e0e0:bd89
2601:600:a27f:a470:444f:17ec:b463:7edd
2601:600:a27f:a470:10fd:7063:28e9:c9f3
2601:600:a27f:a470:60ea:29a7:a233:7cb7
2601:600:a27f:a470::2ec1
```

Using the `Get-Member` cmdlet, you can see that the **IPAddress** property is an array:

```powershell
Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter IPEnabled=$true |
    Get-Member -Name IPAddress
```

```Output
   TypeName: Microsoft.Management.Infrastructure.CimInstance#root/cimv2/Win32_NetworkAdapterConfiguration

Name      MemberType Definition
----      ---------- ----------
IPAddress Property   string[] IPAddress {get;}
```

The IPAddress property for each network adapter is actually an array. The braces in the definition
indicate that **IPAddress** isn't a **System.String** value, but an array of **System.String**
values.

## Listing IP configuration data

To display detailed IP configuration data for each network adapter, use the following command:

```powershell
Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter IPEnabled=$true
```

The default display for the network adapter configuration object is a very reduced set of the
available information. For in-depth inspection and troubleshooting, use `Select-Object` or a
formatting cmdlet, such as `Format-List`, to specify the properties to be displayed.

In modern TCP/IP networks you are probably not interested in IPX or WINS properties. You can use the
**ExcludeProperty** parameter of `Select-Object` to hide properties with names that begin with
"WINS" or "IPX".

```powershell
Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter IPEnabled=$true |
    Select-Object -ExcludeProperty IPX*,WINS*
```

This command returns detailed information about DHCP, DNS, routing, and other minor IP configuration
properties.

## Pinging computers

You can perform a simple ping against a computer using by **Win32_PingStatus**. The following
command performs the ping, but returns lengthy output:

```powershell
Get-CimInstance -Class Win32_PingStatus -Filter "Address='127.0.0.1'"
```

A more useful form for summary information a display of the Address, ResponseTime, and StatusCode
properties, as generated by the following command. The **Autosize** parameter of `Format-Table`
resizes the table columns so that they display properly in PowerShell.

```powershell
Get-CimInstance -Class Win32_PingStatus -Filter "Address='127.0.0.1'" |
    Format-Table -Property Address,ResponseTime,StatusCode -Autosize
```

```Output
Address   ResponseTime StatusCode
-------   ------------ ----------
127.0.0.1            0          0
```

A StatusCode of 0 indicates a successful ping.

You can use an array to ping multiple computers with a single command. Because there is more than
one address, use the `ForEach-Object` to ping each address separately:

```powershell
'127.0.0.1','localhost','bing.com' |
  ForEach-Object -Process {
    Get-CimInstance -Class Win32_PingStatus -Filter ("Address='$_'") |
      Select-Object -Property Address,ResponseTime,StatusCode
  }
```

You can use the same command format to ping all the addresses on a subnet, such as a private network
that uses network number 192.168.1.0 and a standard Class C subnet mask (255.255.255.0)., Only
addresses in the range of 192.168.1.1 through 192.168.1.254 are legitimate local addresses (0 is
always reserved for the network number and 255 is a subnet broadcast address).

To represent an array of the numbers from 1 through 254 in PowerShell, use the expression `1..254`.
A complete subnet ping can be performed by adding each value in the range to a partial address in
the ping statement:

```powershell
1..254| ForEach-Object -Process {
  Get-CimInstance -Class Win32_PingStatus -Filter ("Address='192.168.1.$_'") } |
    Select-Object -Property Address,ResponseTime,StatusCode
```

Note that this technique for generating a range of addresses can be used elsewhere as well. You can
generate a complete set of addresses in this way:

```powershell
$ips = 1..254 | ForEach-Object -Process {'192.168.1.' + $_}
```

## Retrieving network adapter properties

Earlier, we mentioned that you could retrieve general configuration properties using the
**Win32_NetworkAdapterConfiguration** class. Although not strictly TCP/IP information, network
adapter information such as MAC addresses and adapter types can be useful for understanding what's
going on with a computer. To get a summary of this information, use the following command:

```powershell
Get-CimInstance -Class Win32_NetworkAdapter -ComputerName .
```

## Assigning the DNS domain for a network adapter

To assign the DNS domain for automatic name resolution, use the **SetDNSDomain** method of the
**Win32_NetworkAdapterConfiguration**. The **Query** parameter of `Invoke-CimMethod` takes a WQL
query string. The cmdlet calls the method specified on each instance returned by the query.

```powershell
$wql = 'SELECT * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled=True'
$args = @{ DnsDomain = 'fabrikam.com'}
Invoke-CimMethod -MethodName SetDNSDomain -Arguments $args -Query $wql
```

Filtering on `IPEnabled=True` is necessary, because even on a network that uses only TCP/IP, several
of the network adapter configurations on a computer aren't true TCP/IP adapters. they're general
software elements supporting RAS, VPN, QoS, and other services for all adapters and thus don't have
an address of their own.

## Performing DHCP configuration tasks

Modifying DHCP details involves working with a set of network adapters, just as the DNS
configuration does. There are several distinct actions you can perform using WMI.

### Finding DHCP-enabled adapters

To find the DHCP-enabled adapters on a computer, use the following command:

```powershell
Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter "DHCPEnabled=$true"
```

To exclude adapters with IP configuration problems, you can retrieve only IP-enabled adapters:

```powershell
Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter "IPEnabled=$true and DHCPEnabled=$true"
```

### Retrieving DHCP properties

Because DHCP-related properties for an adapter generally begin with `DHCP`, you can use the Property
parameter of `Format-Table` to display only those properties:

```powershell
Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter  "IPEnabled=$true and DHCPEnabled=$true" |
  Format-Table -Property DHCP*
```

### Enabling DHCP on each adapter

To enable DHCP on all adapters, use the following command:

```powershell
$wql = 'SELECT * from Win32_NetworkAdapterConfiguration WHERE IPEnabled=True and DHCPEnabled=False'
Invoke-CimMethod -MethodName ReleaseDHCPLease -Query $wql
```

Using the filter statement `IPEnabled=True and DHCPEnabled=False` avoids enabling DHCP where it's
already enabled.

### Releasing and renewing DHCP leases on specific adapters

Instances of the **Win32_NetworkAdapterConfiguration** class has `ReleaseDHCPLease` and
`RenewDHCPLease` methods. Both are used in the same way. In general, use these methods if you only
need to release or renew addresses for an adapter on a specific subnet. The easiest way to filter
adapters on a subnet is to choose only the adapter configurations that use the gateway for that
subnet. For example, the following command releases all DHCP leases on adapters on the local
computer that are obtaining DHCP leases from 192.168.1.254:

```powershell
$wql = 'SELECT * from Win32_NetworkAdapterConfiguration WHERE DHCPServer="192.168.1.1"'
Invoke-CimMethod -MethodName ReleaseDHCPLease -Query $wql
```

The only change for renewing a DHCP lease is to use the `RenewDHCPLease` method instead of the
`ReleaseDHCPLease` method:

```powershell
$wql = 'SELECT * from Win32_NetworkAdapterConfiguration WHERE DHCPServer="192.168.1.1"'
Invoke-CimMethod -MethodName RenewDHCPLease -Query $wql
```

> [!NOTE]
> When using these methods on a remote computer, be aware that you can lose access to the remote
> system if you are connected to it through the adapter with the released or renewed lease.

### Releasing and renewing DHCP leases on all adapters

You can perform global DHCP address releases or renewals on all adapters by using the
**Win32_NetworkAdapterConfiguration** methods, `ReleaseDHCPLeaseAll` and `RenewDHCPLeaseAll`.
However, the command must apply to the WMI class, rather than a particular adapter, because
releasing and renewing leases globally is performed on the class, not on a specific adapter. The
`Invoke-CimMethod` cmdlet can call the methods of a class.

```powershell
Invoke-CimMethod -ClassName Win32_NetworkAdapterConfiguration -MethodName ReleaseDHCPLeaseAll
```

You can use the same command format to invoke the **RenewDHCPLeaseAll** method:

```powershell
Invoke-CimMethod -ClassName Win32_NetworkAdapterConfiguration -MethodName RenewDHCPLeaseAll
```

## Creating a network share

To create a network share, use the `Create` method of **Win32_Share**:

```powershell
Invoke-CimMethod -ClassName Win32_Share -MethodName Create -Arguments @{
    Path = 'C:\temp'
    Name = 'TempShare'
    Type = [uint32]0 #Disk Drive
    MaximumAllowed = [uint32]25
    Description = 'test share of the temp folder'
}
```

This is equivalent to the following `net share` command on Windows:

```powershell
net share tempshare=c:\temp /users:25 /remark:"test share of the temp folder"
```

To call a method of a WMI class that takes parameters you must know what parameters are available
and the types of those parameters. For example, you can list the methods of the **Win32_Class** with
the following commands:

```powershell
(Get-CimClass -ClassName Win32_Share).CimClassMethods
```

```Output
Name          ReturnType Parameters                                   Qualifiers
----          ---------- ----------                                   ----------
Create            UInt32 {Access, Description, MaximumAllowed, Name…} {Constructor, Implemented, MappingStrings, Stati…
SetShareInfo      UInt32 {Access, Description, MaximumAllowed}        {Implemented, MappingStrings}
GetAccessMask     UInt32 {}                                           {Implemented, MappingStrings}
Delete            UInt32 {}                                           {Destructor, Implemented, MappingStrings}
```

Use the following command to list the parameters of the `Create` method.

```powershell
(Get-CimClass -ClassName Win32_Share).CimClassMethods['Create'].Parameters
```

```Output
Name            CimType Qualifiers                                  ReferenceClassName
----            ------- ----------                                  ------------------
Access         Instance {EmbeddedInstance, ID, In, MappingStrings…}
Description      String {ID, In, MappingStrings, Optional}
MaximumAllowed   UInt32 {ID, In, MappingStrings, Optional}
Name             String {ID, In, MappingStrings}
Password         String {ID, In, MappingStrings, Optional}
Path             String {ID, In, MappingStrings}
Type             UInt32 {ID, In, MappingStrings}
```

You can also read the documentation for
[Create][02] method of the
**Win32_Share** class.

## Removing a network share

You can remove a network share with **Win32_Share**, but the process is slightly different from
creating a share, because you need to retrieve the specific instance to be removed, rather than the
**Win32_Share** class. The following example deletes the share **TempShare**:

```powershell
$wql = 'SELECT * from Win32_Share WHERE Name="TempShare"'
Invoke-CimMethod -MethodName Delete -Query $wql
```

## Connecting a Windows-accessible network drive

The `New-PSDrive` cmdlet can create a PowerShell drive that's mapped to a network share.

```powershell
New-PSDrive -Name "X" -PSProvider "FileSystem" -Root "\\Server01\Public"
```

However, drives created this way are only available to PowerShell session where they're created. To
map a drive that's available outside of PowerShell (or to other PowerShell sessions), you must use
the **Persist** parameter.

```powershell
New-PSDrive -Persist -Name "X" -PSProvider "FileSystem" -Root "\\Server01\Public"
```

> [!NOTE]
> Persistently mapped drives may not be available when running in an elevated context. This is the
> default behavior of Windows UAC. For more information, see the following article:
>
> - [Mapped drives aren't available from an elevated prompt when UAC is configured to Prompt for credentials][01]

<!-- link references -->
[01]: https://learn.microsoft.com/troubleshoot/windows-client/networking/mapped-drives-not-available-from-elevated-command
[02]: https://learn.microsoft.com/windows/win32/cimwin32prov/create-method-in-class-win32-share

# /./reference/samples/working-with-software-installations.md

    ---
    description: This article shows how to use WMI to manage software installed in Windows.
    ms.date: 03/17/2023
    title: Working with software installations
    ---
# Working with software installations

Applications installed with the Windows Installer can be found through WMI's queries, but not all
applications use the Windows Installer. The specific techniques for find applications installed
with other tools depends on the installer software.

For example, applications installed by copying the files to a folder on the computer usually can't
be managed using techniques discussed here. You can manage these applications as files and folders
using the techniques discussed in [Working With Files and Folders][02].

For software installed using an installer package, the Windows Installer can be found using the
**Win32Reg_AddRemovePrograms** or the **Win32_Product** classes. However, both of these have
problems. The **Win32Reg_AddRemovePrograms** is only available if you are using System Center
Configuration Manager (SCCM). And the **Win32_Product** class can be slow and has side effects.

> [!CAUTION]
> The **Win32_Product** class isn't query optimized. Queries that use wildcard filters cause WMI to
> use the MSI provider to enumerate all installed products then parse the full list sequentially to
> handle the filter. This also initiates a consistency check of packages installed, verifying and
> repairing the install. The validation is a slow process and may result in errors in the event
> logs. For more information seek [KB article 974524][01].

This article provides an alternative method for finding installed software.

## Querying the Uninstall registry key to find installed software

Because most standard applications register an uninstaller with Windows, we can work with those
locally by finding them in the Windows registry. There is no guaranteed way to find every
application on a system. However, it's possible to find all programs with listings displayed in
**Add or Remove Programs** in the following registry key:

`HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall`.

We can find the number of installed applications by counting the number
of registry keys:

```powershell
$UninstallPath = 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall'
(Get-ChildItem -Path $UninstallPath).Count
```

```Output
459
```

We can search this list of applications further using a variety of techniques. To display the values
of the registry values in the registry keys under `Uninstall`, use the `GetValue()` method of the
registry keys. The value of the method is the name of the registry entry. For example, to find the
display names of applications in the `Uninstall` key, use the following command:

```powershell
Get-ChildItem -Path $UninstallPath |
    ForEach-Object -Process { $_.GetValue('DisplayName') } |
    Sort-Object
```

> [!NOTE]
> There is no guarantee that the **DisplayName** values are unique.

The following example produces output similar to the **Win32Reg_AddRemovePrograms** class:

```powershell
Get-ChildItem $UninstallPath |
    ForEach-Object {
        $ProdID = ($_.Name -split '\\')[-1]
        Get-ItemProperty -Path "$UninstallPath\$ProdID" -ea SilentlyContinue |
        Select-Object -Property DisplayName, InstallDate, @{n='ProdID'; e={$ProdID}}, Publisher, DisplayVersion
} | Select-Object -First 3
```

For the sake of brevity, this example uses `Select-Object` to limit the number of items returned to
three.

```Output
DisplayName    : 7-Zip 22.01 (x64)
InstallDate    :
ProdID         : 7-Zip
Publisher      : Igor Pavlov
DisplayVersion : 22.01

DisplayName    : AutoHotkey 1.1.33.10
InstallDate    :
ProdID         : AutoHotkey
Publisher      : Lexikos
DisplayVersion : 1.1.33.10

DisplayName    : Beyond Compare 4.4.6
InstallDate    : 20230310
ProdID         : BeyondCompare4_is1
Publisher      : Scooter Software
DisplayVersion : 4.4.6.27483
```

<!-- link references -->
[01]: https://support.microsoft.com/help/974524
[02]: Working-with-Files-and-Folders.md

# /./reference/samples/decode-powershell-command-from-a-running-process.md

    ---
    author: randomnote1
    description: This article shows how to decode a script block that a PowerShell process is currently running.
    ms.date: 12/08/2022
    title: Decode a PowerShell command from a running process
    ---

# Decode a PowerShell command from a running process

> This sample only runs on Windows platforms.

At times, you may have a PowerShell process running that's taking up a large amount of resources.
This process could be running in the context of a [Task Scheduler][03] job or a
[SQL Server Agent][01] job. Where there are multiple PowerShell processes running, it can be
difficult to know which process represents the problem. This article shows how to decode a script
block that a PowerShell process is currently running.

## Create a long running process

To demonstrate this scenario, open a new PowerShell window and run the following code. It executes a
PowerShell command that outputs a number every minute for 10 minutes.

```powershell
powershell.exe -Command {
    $i = 1
    while ( $i -le 10 )
    {
        Write-Output -InputObject $i
        Start-Sleep -Seconds 60
        $i++
    }
}
```

## View the process

The body of the command that PowerShell is executing is stored in the **CommandLine** property of
the [Win32_Process][02] class. If the command is an encoded command, the **CommandLine**
property contains the string "EncodedCommand". Using this information, the encoded command can be
de-obfuscated via the following process.

Start PowerShell as Administrator. It's vital that PowerShell is running as administrator, otherwise
no results are returned when querying the running processes.

Execute the following command to get all the PowerShell processes that have an encoded command:

```powershell
$powerShellProcesses = Get-CimInstance -ClassName Win32_Process -Filter 'CommandLine LIKE "%EncodedCommand%"'
```

The following command creates a custom PowerShell object that contains the process ID and the
encoded command.

```powershell
$commandDetails = $powerShellProcesses | Select-Object -Property ProcessId,
@{
    name       = 'EncodedCommand'
    expression = {
        if ( $_.CommandLine -match 'encodedCommand (.*) -inputFormat' )
        {
            return $matches[1]
        }
    }
}
```

Now the encoded command can be decoded. The following snippet iterates over the command details
object, decodes the encoded command, and adds the decoded command back to the object for further
investigation.

```powershell
$commandDetails | ForEach-Object -Process {
    # Get the current process
    $currentProcess = $_

    # Convert the Base 64 string to a Byte Array
    $commandBytes = [System.Convert]::FromBase64String($currentProcess.EncodedCommand)

    # Convert the Byte Array to a string
    $decodedCommand = [System.Text.Encoding]::Unicode.GetString($commandBytes)

    # Add the decoded command back to the object
    $commandDetails |
        Where-Object -FilterScript { $_.ProcessId -eq $currentProcess.processId } |
        Add-Member -MemberType NoteProperty -Name DecodedCommand -Value $decodedCommand
}
$commandDetails[0] | Format-List -Property *
```

The decoded command can now be reviewed by selecting the decoded command property.

```Output
ProcessId      : 8752
EncodedCommand : IAAKAAoACgAgAAoAIAAgACAAIAAkAGkAIAA9ACAAMQAgAAoACgAKACAACgAgACAAIAAgAHcAaABpAGwAZQAgACgAIAAkAGkAIAAtAG
                 wAZQAgADEAMAAgACkAIAAKAAoACgAgAAoAIAAgACAAIAB7ACAACgAKAAoAIAAKACAAIAAgACAAIAAgACAAIABXAHIAaQB0AGUALQBP
                 AHUAdABwAHUAdAAgAC0ASQBuAHAAdQB0AE8AYgBqAGUAYwB0ACAAJABpACAACgAKAAoAIAAKACAAIAAgACAAIAAgACAAIABTAHQAYQ
                 ByAHQALQBTAGwAZQBlAHAAIAAtAFMAZQBjAG8AbgBkAHMAIAA2ADAAIAAKAAoACgAgAAoAIAAgACAAIAAgACAAIAAgACQAaQArACsA
                 IAAKAAoACgAgAAoAIAAgACAAIAB9ACAACgAKAAoAIAAKAA==
DecodedCommand :
                     $i = 1
                     while ( $i -le 10 )
                     {
                         Write-Output -InputObject $i
                         Start-Sleep -Seconds 60
                         $i++
                     }
```

[task]: https://learn.microsoft.com/windows/desktop/TaskSchd/task-scheduler-start-page
[sqlagent]: https://learn.microsoft.com/sql/ssms/agent/sql-server-agent
[Win32_Process]: https://learn.microsoft.com/windows/desktop/CIMWin32Prov/win32-process

<!-- link references -->
[01]: https://learn.microsoft.com/sql/ssms/agent/sql-server-agent
[02]: https://learn.microsoft.com/windows/desktop/CIMWin32Prov/win32-process
[03]: https://learn.microsoft.com/windows/desktop/TaskSchd/task-scheduler-start-page

# /./reference/samples/redirecting-data-with-out---cmdlets.md

    ---
    description: This article shows how to use the cmdlets that manage output in PowerShell.
    ms.date: 12/08/2022
    title: Redirecting output
    ---
# Redirecting output

PowerShell provides several cmdlets that let you control data output directly. These cmdlets share
two important characteristics.

First, they generally transform data to some form of text. They do this because they output the data
to system components that require text input. This means they need to represent the objects as text.
Therefore, the text is formatted as you see it in the PowerShell console window.

Second, these cmdlets use the PowerShell verb **Out** because they send information out from
PowerShell to somewhere else.

## Console output

By default, PowerShell sends data to the host window, which is exactly what the `Out-Host`
cmdlet does. The primary use for the `Out-Host` cmdlet is paging. For example, the following command
uses `Out-Host` to page the output of the `Get-Command` cmdlet:

```powershell
Get-Command | Out-Host -Paging
```

The host window display is outside of PowerShell. This is important because when data is sent out of
PowerShell, it's actually removed. You can see this if you try to create a pipeline that pages data
to the host window, and then attempt to format it as a list, as shown here:

```powershell
Get-Process | Out-Host -Paging | Format-List
```

You might expect the command to display pages of process information in list format. Instead, it
displays the default tabular list:

```output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    101       5     1076       3316    32     0.05   2888 alg
...
    618      18    39348      51108   143   211.20    740 explorer
    257       8     9752      16828    79     3.02   2560 explorer
...
<SPACE> next page; <CR> next line; Q quit
...
```

The `Out-Host` cmdlet sends the data directly to the console, so the `Format-List` command never
receives anything to format.

The correct way to structure this command is to put the `Out-Host` cmdlet at the end of the pipeline
as shown below. This causes the process data to be formatted in a list before being paged and
displayed.

```powershell
Get-Process | Format-List | Out-Host -Paging
```

```Output
Id      : 2888
Handles : 101
CPU     : 0.046875
Name    : alg
...

Id      : 740
Handles : 612
CPU     : 211.703125
Name    : explorer

Id      : 2560
Handles : 257
CPU     : 3.015625
Name    : explorer
...
<SPACE> next page; <CR> next line; Q quit
...
```

This applies to all of the **Out** cmdlets. An **Out** cmdlet should always appear at the end of the
pipeline.

> [!NOTE]
> All the **Out** cmdlets render output as text, using the formatting in effect for the console
> window, including line length limits.

## Discarding output

The `Out-Null` cmdlet is designed to immediately discard any input it receives. This is useful for
discarding unnecessary data that you get as a side-effect of running a command. When type the
following command, you don't get anything back from the command:

```powershell
Get-Command | Out-Null
```

The `Out-Null` cmdlet doesn't discard error output. For example, if you enter the following command,
a message is displayed informing you that PowerShell doesn't recognize `Is-NotACommand`:

```
PS> Get-Command Is-NotACommand | Out-Null
Get-Command : 'Is-NotACommand' isn't recognized as a cmdlet, function, operable program, or script file.
At line:1 char:12
+ Get-Command  <<<< Is-NotACommand | Out-Null
```

## Printing data

> `Out-Printer` is only available on Windows platforms.

You can print data using the `Out-Printer` cmdlet. The `Out-Printer` cmdlet uses your default
printer if you don't provide a printer name. You can use any Windows-based printer by specifying its
display name. There is no need for any kind of printer port mapping or even a real physical printer.
For example, if you have the Microsoft Office document imaging tools installed, you can send the
data to an image file by typing:

```powershell
Get-Command Get-Command | Out-Printer -Name 'Microsoft Office Document Image Writer'
```

## Saving data

You can send output to a file instead of the console window using the `Out-File` cmdlet. The
following command line sends a list of processes to the file `C:\temp\processlist.txt`:

```powershell
Get-Process | Out-File -FilePath C:\temp\processlist.txt
```

The results of using the `Out-File` cmdlet may not be what you expect if you are used to traditional
output redirection. To understand its behavior, you must be aware of the context in which the
`Out-File` cmdlet operates.

On Window PowerShell 5.1, the `Out-File` cmdlet creates a Unicode file. Some tools, that expect
ASCII files, don't work correctly with the default output format. You can change the default output
format to ASCII using the **Encoding** parameter:

```powershell
Get-Process | Out-File -FilePath C:\temp\processlist.txt -Encoding ASCII
```

`Out-file` formats file contents to look like console output. This causes the output to be truncated
just as it's in a console window in most circumstances. For example, if you run the following
command:

```powershell
Get-Command | Out-File -FilePath c:\temp\output.txt
```

The output will look like this:

```output
CommandType     Name                            Definition
-----------     ----                            ----------
Cmdlet          Add-Content                     Add-Content [-Path] <String[...
Cmdlet          Add-History                     Add-History [[-InputObject] ...
...
```

To get output that doesn't force line wraps to match the screen width, you can use the **Width**
parameter to specify line width. Because **Width** is a 32-bit integer parameter, the maximum value
it can have is 2147483647. Type the following to set the line width to this maximum value:

```powershell
Get-Command | Out-File -FilePath c:\temp\output.txt -Width 2147483647
```

The `Out-File` cmdlet is most useful when you want to save output as it would have displayed on the
console.

# /./reference/samples/using-format-commands-to-change-output-view.md

    ---
    description: PowerShell has a extensible formatting system that allows you to present output in lists, tables, or custom layouts.
    ms.date: 12/08/2022
    title: Using Format commands to change output view
    ---
# Using Format commands to change output view

PowerShell has a set of cmdlets that allow you to control how properties are displayed for
particular objects. The names of all the cmdlets begin with the verb `Format`. They let you select
which properties you want to show.

```powershell
Get-Command -Verb Format -Module Microsoft.PowerShell.Utility
```

```Output
CommandType     Name               Version    Source
-----------     ----               -------    ------
Cmdlet          Format-Custom      6.1.0.0    Microsoft.PowerShell.Utility
Cmdlet          Format-Hex         6.1.0.0    Microsoft.PowerShell.Utility
Cmdlet          Format-List        6.1.0.0    Microsoft.PowerShell.Utility
Cmdlet          Format-Table       6.1.0.0    Microsoft.PowerShell.Utility
Cmdlet          Format-Wide        6.1.0.0    Microsoft.PowerShell.Utility
```

This article describes the `Format-Wide`, `Format-List`, and `Format-Table` cmdlets.

Each object type in PowerShell has default properties that are used when you don't select the
properties to display. Each cmdlet uses the same **Property** parameter to specify which properties
you want displayed. Because `Format-Wide` only shows a single property, its **Property** parameter
only takes a single value, but the property parameters of `Format-List` and `Format-Table` accept a
list of property names.

In this example, the default output of `Get-Process` cmdlet shows that we've two instances of
Internet Explorer running.

```powershell
Get-Process -Name iexplore
```

The default format for **Process** objects displays the properties shown here:

```Output
 NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName
 ------    -----      -----     ------      --  -- -----------
     32    25.52      10.25      13.11   12808   1 iexplore
     52    11.46      26.46       3.55   21748   1 iexplore
```

## Using Format-Wide for single-item output

The `Format-Wide` cmdlet, by default, displays only the default property of an object. The
information associated with each object is displayed in a single column:

```powershell
Get-Command -Verb Format | Format-Wide
```

```Output
Format-Custom          Format-Hex
Format-List            Format-Table
Format-Wide
```

You can also specify a non-default property:

```powershell
Get-Command -Verb Format | Format-Wide -Property Noun
```

```Output
Custom                 Hex
List                   Table
Wide
```

### Controlling Format-Wide display with column

With the `Format-Wide` cmdlet, you can only display a single property at a time. This makes it
useful for displaying large lists in multiple columns.

```powershell
Get-Command -Verb Format | Format-Wide -Property Noun -Column 3
```

```Output
Custom                 Hex                  List
Table                  Wide

```

## Using Format-List for a list view

The `Format-List` cmdlet displays an object in the form of a listing, with each property labeled and
displayed on a separate line:

```powershell
Get-Process -Name iexplore | Format-List
```

```Output
Id      : 12808
Handles : 578
CPU     : 13.140625
SI      : 1
Name    : iexplore

Id      : 21748
Handles : 641
CPU     : 3.59375
SI      : 1
Name    : iexplore
```

You can specify as many properties as you want:

```powershell
Get-Process -Name iexplore | Format-List -Property ProcessName,FileVersion,StartTime,Id
```

```Output
ProcessName : iexplore
FileVersion : 11.00.18362.1 (WinBuild.160101.0800)
StartTime   : 10/22/2019 11:23:58 AM
Id          : 12808

ProcessName : iexplore
FileVersion : 11.00.18362.1 (WinBuild.160101.0800)
StartTime   : 10/22/2019 11:23:57 AM
Id          : 21748
```

### Getting detailed information using Format-List with wildcards

The `Format-List` cmdlet lets you use a wildcard as the value of its **Property** parameter. This
lets you display detailed information. Often, objects include more information than you need, which
is why PowerShell doesn't show all property values by default. To show all properties of an object,
use the `Format-List -Property *` command. The following command generates more than 60 lines of
output for a single process:

```powershell
Get-Process -Name iexplore | Format-List -Property *
```

Although the `Format-List` command is useful for showing detail, if you want an overview of output
that includes many items, a simpler tabular view is often more useful.

## Using Format-Table for tabular output

If you use the `Format-Table` cmdlet with no property names specified to format the output of the
`Get-Process` command, you get exactly the same output as you do without a `Format` cmdlet. By
default, PowerShell displays **Process** objects in a tabular format.

```powershell
Get-Service -Name win* | Format-Table
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  WinDefend          Windows Defender Antivirus Service
Running  WinHttpAutoProx... WinHTTP Web Proxy Auto-Discovery Se...
Running  Winmgmt            Windows Management Instrumentation
Running  WinRM              Windows Remote Management (WS-Manag...
```

> [!NOTE]
> `Get-Service` is only available on Windows platforms.

### Improving Format-Table output

Although a tabular view is useful for displaying lots of information, it may be difficult to
interpret if the display is too narrow for the data. In the previous example, the output is
truncated. If you specify the **AutoSize** parameter when you run the `Format-Table` command,
PowerShell calculates column widths based on the actual data displayed. This makes the columns
readable.

```powershell
Get-Service -Name win* | Format-Table -AutoSize
```

```Output
Status  Name                DisplayName
------  ----                -----------
Running WinDefend           Windows Defender Antivirus Service
Running WinHttpAutoProxySvc WinHTTP Web Proxy Auto-Discovery Service
Running Winmgmt             Windows Management Instrumentation
Running WinRM               Windows Remote Management (WS-Management)
```

The `Format-Table` cmdlet might still truncate data, but it only truncates at the end of the screen.
Properties, other than the last one displayed, are given as much size as they need for their longest
data element to display correctly.

```powershell
Get-Service -Name win* |
    Format-Table -Property Name, Status, StartType, DisplayName, DependentServices -AutoSize
```

```Output
Name                 Status StartType DisplayName                               DependentServi
                                                                                ces
----                 ------ --------- -----------                               --------------
WinDefend           Running Automatic Windows Defender Antivirus Service        {}
WinHttpAutoProxySvc Running    Manual WinHTTP Web Proxy Auto-Discovery Service  {NcaSvc, iphl…
Winmgmt             Running Automatic Windows Management Instrumentation        {vmms, TPHKLO…
WinRM               Running Automatic Windows Remote Management (WS-Management) {}
```

The `Format-Table` command assumes that properties are listed in order of importance. The cmdlet
attempts to fully display the properties nearest the beginning. If the `Format-Table` command can't
display all the properties, it removes some columns from the display. You can see this behavior in
the **DependentServices** property previous example.

### Wrapping Format-Table output in columns

You can force lengthy `Format-Table` data to wrap within its display column using the **Wrap**
parameter. Using the **Wrap** parameter may not do what you expect, since it uses default settings
if you don't also specify **AutoSize**:

```powershell
Get-Service -Name win* |
    Format-Table -Property Name, Status, StartType, DisplayName, DependentServices -Wrap
```

```Output
Name                 Status StartType DisplayName                               DependentServi
                                                                                ces
----                 ------ --------- -----------                               --------------
WinDefend           Running Automatic Windows Defender Antivirus Service        {}
WinHttpAutoProxySvc Running    Manual WinHTTP Web Proxy Auto-Discovery Service  {NcaSvc,
                                                                                iphlpsvc}
Winmgmt             Running Automatic Windows Management Instrumentation        {vmms,
                                                                                TPHKLOAD,
                                                                                SUService,
                                                                                smstsmgr…}
WinRM               Running Automatic Windows Remote Management (WS-Management) {}
```

Using the **Wrap** parameter by itself doesn't slow down processing very much. However, using
**AutoSize** to format a recursive file listing of a large directory structure can take a long time
and use lots of memory before displaying the first output items.

If you aren't concerned about system load, then **AutoSize** works well with the **Wrap** parameter.
The initial columns still use as much width as needed to display items on one line, but the final
column is wrapped, if necessary.

> [!NOTE]
> Some columns may not be displayed when you specify the widest columns first. For best results,
> specify the smallest data elements first.

In the following example, we specify the widest properties first.

```powershell
Get-Process -Name iexplore |
    Format-Table -Wrap -AutoSize -Property FileVersion, Path, Name, Id
```

Even with wrapping, the final **Id** column is omitted:

```Output
FileVersion                          Path                                                  Nam
                                                                                           e
-----------                          ----                                                  ---
11.00.18362.1 (WinBuild.160101.0800) C:\Program Files (x86)\Internet Explorer\IEXPLORE.EXE iex
                                                                                           plo
                                                                                           re
11.00.18362.1 (WinBuild.160101.0800) C:\Program Files\Internet Explorer\iexplore.exe       iex
                                                                                           plo
                                                                                           re
```

### Organizing table output

Another useful parameter for tabular output control is **GroupBy**. Longer tabular listings in
particular may be hard to compare. The **GroupBy** parameter groups output based on a property
value. For example, we can group services by **StartType** for easier inspection, omitting the
**StartType** value from the property listing:

```powershell
Get-Service -Name win* | Sort-Object StartType | Format-Table -GroupBy StartType
```

```Output
   StartType: Automatic
Status   Name               DisplayName
------   ----               -----------
Running  WinDefend          Windows Defender Antivirus Service
Running  Winmgmt            Windows Management Instrumentation
Running  WinRM              Windows Remote Management (WS-Managem…

   StartType: Manual
Status   Name               DisplayName
------   ----               -----------
Running  WinHttpAutoProxyS… WinHTTP Web Proxy Auto-Discovery Serv…
```

# /./reference/samples/managing-current-location.md

    ---
    description: PowerShell uses the noun Location to refer to the working directory, and implements a family of cmdlets to examine and manipulate your location.
    ms.date: 12/08/2022
    title: Managing current location
    ---
# Managing current location

When navigating folder systems in File Explorer, you usually have a specific working location -
namely, the current open folder. Items in the current folder can be manipulated easily by clicking
them. For command-line interfaces such as Cmd.exe, when you are in the same folder as a particular
file, you can access it by specifying a relatively short name, rather than needing to specify the
entire path to the file. The current directory is called the working directory.

PowerShell uses the noun **Location** to refer to the working directory, and implements a family of
cmdlets to examine and manipulate your location.

## Getting your current location (Get-Location)

To determine the path of your current directory location, enter the `Get-Location` command:

```powershell
Get-Location
```

```Output
Path
----
C:\Documents and Settings\PowerUser
```

> [!NOTE]
> The `Get-Location` cmdlet is similar to the **pwd** command in the BASH shell. The `Set-Location`
> cmdlet is similar to the **cd** command in Cmd.exe.

## Setting your current location (Set-Location)

The `Get-Location` command is used with the `Set-Location` command. The `Set-Location` command
allows you to specify your current directory location.

```powershell
Set-Location -Path C:\Windows
```

After you enter the command, notice that you don't receive any direct feedback about the effect of
the command. Most PowerShell commands that perform an action produce little or no output because the
output isn't always useful. To verify that a successful directory change has occurred when you enter
the `Set-Location` command, include the **PassThru** parameter when you enter the `Set-Location`
command:

```powershell
Set-Location -Path C:\Windows -PassThru
```

```Output
Path
----
C:\WINDOWS
```

The **PassThru** parameter can be used with many Set commands in PowerShell to return information
about the result for cases in which there is no default output.

You can specify paths relative to your current location in the same way as you would in most UNIX
and Windows command shells. In standard notation for relative paths, a period (`.`) represents your
current folder, and a doubled period (`..`) represents the parent directory of your current
location.

For example, if you are in the `C:\Windows` folder, a period (`.`) represents `C:\Windows` and
double periods (`..`) represent `C:`. You can change from your current location to the root of the
`C:` drive by typing:

```powershell
Set-Location -Path .. -PassThru
```

```Output
Path
----
C:\
```

The same technique works on PowerShell drives that aren't file system drives, such as `HKLM:`. You
can set your location to the `HKLM\Software` key in the registry by typing:

```powershell
Set-Location -Path HKLM:\SOFTWARE -PassThru
```

```Output
Path
----
HKLM:\SOFTWARE
```

You can then change the directory location to the parent directory, using a relative path:

```powershell
Set-Location -Path .. -PassThru
```

```Output
Path
----
HKLM:\
```

You can type `Set-Location` or use any of the built-in PowerShell aliases for `Set-Location` (`cd`,
`chdir`, `sl`). For example:

```powershell
cd -Path C:\Windows
```

```powershell
chdir -Path .. -PassThru
```

```powershell
sl -Path HKLM:\SOFTWARE -PassThru
```

## Saving and recalling recent locations (Push-Location and Pop-Location)

When changing locations, it's helpful to keep track of where you have been and to be able to return
to your previous location. The `Push-Location` cmdlet in PowerShell creates an ordered history (a
"stack") of directory paths where you have been, and you can step back through the history of
directory paths using the `Pop-Location` cmdlet.

For example, PowerShell typically starts in the user's home directory.

```powershell
Get-Location

Path
----
C:\Documents and Settings\PowerUser
```

> [!NOTE]
> The word **stack** has a special meaning in many programming settings, including .NET Framework.
> Like a physical stack of items, the last item you put onto the stack is the first item that you
> can pull off the stack. Adding an item to a stack is colloquially known as "pushing" the item onto
> the stack. Pulling an item off the stack is colloquially known as "popping" the item off the
> stack.

To push the current location onto the stack, and then move to the Local Settings folder, type:

```powershell
Push-Location -Path "Local Settings"
```

You can then push the Local Settings location onto the stack and move to the Temp folder by typing:

```powershell
Push-Location -Path Temp
```

You can verify that you changed directories by entering the `Get-Location` command:

```powershell
Get-Location
```

```Output
Path
----
C:\Documents and Settings\PowerUser\Local Settings\Temp
```

You can then pop back into the most recently visited directory by entering the `Pop-Location`
command, and verify the change by entering the `Get-Location` command:

```powershell
Pop-Location
Get-Location
```

```Output
Path
----
C:\Documents and Settings\me\Local Settings
```

Just as with the `Set-Location` cmdlet, you can include the **PassThru** parameter when you enter
the `Pop-Location` cmdlet to display the directory that you entered:

```powershell
Pop-Location -PassThru
```

```Output
Path
----
C:\Documents and Settings\PowerUser
```

You can also use the Location cmdlets with network paths. If you have a server named FS01 with a
share named Public, you can change your location by typing

```powershell
Set-Location \\FS01\Public
```

or

```powershell
Push-Location \\FS01\Public
```

You can use the `Push-Location` and `Set-Location` commands to change the location to any available
drive. For example, if you have a local CD-ROM drive with drive letter D that contains a data CD,
you can change the location to the CD drive by entering the `Set-Location D:` command.

If the drive is empty, you get the following error message:

```powershell
Set-Location D:
```

```Output
Set-Location : Cannot find path 'D:\' because it does not exist.
```

When you are using a command-line interface, it's not convenient to use File Explorer to examine the
available physical drives. Also, File Explorer would not show you the all the PowerShell drives.
PowerShell provides a set of commands for manipulating PowerShell drives.

# /./reference/samples/managing-windows-powershell-drives.md

    ---
    description: A PowerShell drive is a data store location that you can access like a filesystem drive in PowerShell. By default, PowerShell includes providers that support the filesystem, the registry, certificate stores, and others.
    ms.date: 12/08/2022
    title: Managing PowerShell drives
    ---
# Managing PowerShell drives

> This sample only applies to Windows platforms.

A _PowerShell drive_ is a data store location that you can access like a filesystem drive in
PowerShell. The PowerShell providers create some drives for you, such as the file
system drives (including `C:` and `D:`), the registry drives (`HKCU:` and `HKLM:`), and the
certificate drive (`Cert:`), and you can create your own PowerShell drives. These drives are
useful, but they're available only within PowerShell. You can't access them using other Windows
tools, such as File Explorer or `Cmd.exe`.

PowerShell uses the noun, **PSDrive**, for commands that work with PowerShell
drives. For a list of the PowerShell drives in your PowerShell session, use the
`Get-PSDrive` cmdlet.

```powershell
Get-PSDrive
```

```Output
Name       Provider      Root                                   CurrentLocation
----       --------      ----                                   ---------------
A          FileSystem    A:\
Alias      Alias
C          FileSystem    C:\                                 ...And Settings\me
cert       Certificate   \
D          FileSystem    D:\
Env        Environment
Function   Function
HKCU       Registry      HKEY_CURRENT_USER
HKLM       Registry      HKEY_LOCAL_MACHINE
Variable   Variable
```

Although the drives in the display vary with the drives on your system, yours should look similar to
the output of the `Get-PSDrive` command shown above.

filesystem drives are a subset of the PowerShell drives. You can identify the filesystem drives by
the FileSystem entry in the Provider column. The filesystem drives in PowerShell are supported by
the PowerShell FileSystem provider.

To see the syntax of the `Get-PSDrive` cmdlet, type a `Get-Command` command with the **Syntax**
parameter:

```powershell
Get-Command -Name Get-PSDrive -Syntax
```

```Output
Get-PSDrive [[-Name] <String[]>] [-Scope <String>] [-PSProvider <String[]>] [-V
erbose] [-Debug] [-ErrorAction <ActionPreference>] [-ErrorVariable <String>] [-
OutVariable <String>] [-OutBuffer <Int32>]
```

The **PSProvider** parameter lets you display only the PowerShell drives that are supported by a
particular provider. For example, to display only the PowerShell drives that are supported by the
PowerShell FileSystem provider, type a `Get-PSDrive` command with the **PSProvider** parameter and
the **FileSystem** value:

```powershell
Get-PSDrive -PSProvider FileSystem
```

```Output
Name       Provider      Root                                   CurrentLocation
----       --------      ----                                   ---------------
A          FileSystem    A:\
C          FileSystem    C:\                           ...nd Settings\PowerUser
D          FileSystem    D:\
```

To view the PowerShell drives that represent registry hives, use the **PSProvider** parameter to
display only the PowerShell drives that are supported by the PowerShell Registry provider:

```powershell
Get-PSDrive -PSProvider Registry
```

```Output
Name       Provider      Root                                   CurrentLocation
----       --------      ----                                   ---------------
HKCU       Registry      HKEY_CURRENT_USER
HKLM       Registry      HKEY_LOCAL_MACHINE
```

You can also use the standard Location cmdlets with the PowerShell drives:

```powershell
Set-Location HKLM:\SOFTWARE
Push-Location .\Microsoft
Get-Location
```

```Output
Path
----
HKLM:\SOFTWARE\Microsoft
```

## Adding new PowerShell drives

You can add your own PowerShell drives by using the `New-PSDrive` command. To get the syntax for the
`New-PSDrive` command, enter the `Get-Command` command with the **Syntax** parameter:

```powershell
Get-Command -Name New-PSDrive -Syntax
```

```Output
New-[-Description <String>] [-Scope <String>] [-Credential <PSCredential>] [-Verbose] [-Debug ]
[-ErrorAction <ActionPreference>] [-ErrorVariable <String>] [-OutVariable <St ring>]
[-OutBuffer <Int32>] [-WhatIf] [-Confirm]
```

To create a new PowerShell drive, you must supply three parameters:

- A name for the drive (you can use any valid PowerShell name)
- The PSProvider - use `FileSystem` for filesystem locations and `Registry` for registry locations
- The root, that is, the path to the root of the new drive

For example, you can create a drive named `Office` that's mapped to the folder that contains the
Microsoft Office applications on your computer, such as `C:\Program Files\MicrosoftOffice\OFFICE11`.
To create the drive, type the following command:

```powershell
New-PSDrive -Name Office -PSProvider FileSystem -Root "C:\Program Files\Microsoft Office\OFFICE11"
```

```Output
Name       Provider      Root                                   CurrentLocation
----       --------      ----                                   ---------------
Office     FileSystem    C:\Program Files\Microsoft Offic...
```

> [!NOTE]
> In general, paths aren't case-sensitive.

A PowerShell drive is accessed using its name followed by a colon (`:`).

A PowerShell drive can make many tasks much simpler. For example, some of the most important keys in
the Windows registry have extremely long paths, making them cumbersome to access and difficult to
remember. Critical configuration information resides under
`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion`. To view and change items in the
CurrentVersion registry key, you can create a PowerShell drive that's rooted in that key by typing:

```powershell
New-PSDrive -Name cvkey -PSProvider Registry -Root HKLM\Software\Microsoft\Windows\CurrentVersion
```

```Output
Name       Provider      Root                                   CurrentLocation
----       --------      ----                                   ---------------
cvkey      Registry      HKLM\Software\Microsoft\Windows\...
```

You can then change location to the **cvkey:** drive as you would any other drive:

```powershell
cd cvkey:
```

or:

```powershell
Set-Location cvkey: -PassThru
```

```Output
Path
----
cvkey:\
```

The `New-PSDrive` cmdlet adds the new drive only to the current PowerShell session. If you close the
PowerShell window, the new drive is lost. To save a PowerShell drive, use the `Export-Console` cmdlet
to export the current PowerShell session, and then use the `PowerShell.exe` **PSConsoleFile**
parameter to import it. Or, add the new drive to your Windows PowerShell profile.

## Deleting PowerShell drives

You can delete drives from PowerShell using the `Remove-PSDrive` cmdlet. For example, if you added
the `Office:` PowerShell drive, as shown in the `New-PSDrive` topic, you can delete it by typing:

```powershell
Remove-PSDrive -Name Office
```

To delete the `cvkey:` PowerShell drive, use the following command:

```powershell
Remove-PSDrive -Name cvkey
```

However, you can't delete it while you are in the drive. For example:

```powershell
cd office:
Remove-PSDrive -Name office
```

```Output
Remove-PSDrive : Cannot remove drive 'Office' because it is in use.
At line:1 char:15
+ remove-psdrive  <<<< -name office
```

## Adding and removing drives outside PowerShell

PowerShell detects filesystem drives that are added or removed in Windows, including:

- network drives that are mapped
- USB drives that are attached
- Drives that are deleted using the `net use` command or from a Windows Script Host (WSH) script

# /./reference/samples/working-with-files-and-folders.md

    ---
    description: This article discusses how to deal with specific file and folder manipulation tasks using PowerShell.
    ms.date: 10/18/2023
    title: Working with files and folders
    ---
# Working with files and folders

Navigating through PowerShell drives and manipulating the items on them is similar to manipulating
files and folders on Windows disk drives. This article discusses how to deal with specific file and
folder manipulation tasks using PowerShell.

## Listing all files and folders within a folder

You can get all items directly within a folder using `Get-ChildItem`. Add the optional **Force**
parameter to display hidden or system items. For example, this command displays the direct contents
of PowerShell Drive `C:`.

```powershell
Get-ChildItem -Path C:\ -Force
```

The command lists only the directly contained items, much like using the `dir` command in `cmd.exe`
or `ls` in a UNIX shell. To show items in subfolder, you need to specify the **Recurse** parameter.
The following command lists everything on the `C:` drive:

```powershell
Get-ChildItem -Path C:\ -Force -Recurse
```

`Get-ChildItem` can filter items with its **Path**, **Filter**, **Include**, and **Exclude**
parameters, but those are typically based only on name. You can perform complex filtering based on
other properties of items using `Where-Object`.

The following command finds all executables within the Program Files folder that were last modified
after October 1, 2005 and that are neither smaller than 1 megabyte nor larger than 10 megabytes:

```powershell
Get-ChildItem -Path $env:ProgramFiles -Recurse -Include *.exe |
    Where-Object -FilterScript {
        ($_.LastWriteTime -gt '2005-10-01') -and ($_.Length -ge 1mb) -and ($_.Length -le 10mb)
    }
```

## Copying files and folders

Copying is done with `Copy-Item`. The following command backs up your PowerShell profile script:

```powershell
if (Test-Path -Path $PROFILE) {
    Copy-Item -Path $PROFILE -Destination $($PROFILE -replace 'ps1$', 'bak')
}
```

The `Test-Path` command checks whether the profile script exists.

If the destination file already exists, the copy attempt fails. To overwrite a pre-existing
destination, use the **Force** parameter:

```powershell
if (Test-Path -Path $PROFILE) {
    Copy-Item -Path $PROFILE -Destination $($PROFILE -replace 'ps1$', 'bak') -Force
}
```

This command works even when the destination is read-only.

Folder copying works the same way. This command copies the folder `C:\temp\test1` to the new folder
`C:\temp\DeleteMe` recursively:

```powershell
Copy-Item C:\temp\test1 -Recurse C:\temp\DeleteMe
```

You can also copy a selection of items. The following command copies all `.txt` files contained
anywhere in `C:\data` to `C:\temp\text`:

```powershell
Copy-Item -Filter *.txt -Path c:\data -Recurse -Destination C:\temp\text
```

You can still run native commands like `xcopy.exe` and `robocopy.exe` to copy files.

## Creating files and folders

Creating new items works the same on all PowerShell providers. If a PowerShell provider has more
than one type of item—for example, the FileSystem PowerShell provider distinguishes between
directories and files—you need to specify the item type.

This command creates a new folder `C:\temp\New Folder`:

```powershell
New-Item -Path 'C:\temp\New Folder' -ItemType Directory
```

This command creates a new empty file `C:\temp\New Folder\file.txt`

```powershell
New-Item -Path 'C:\temp\New Folder\file.txt' -ItemType File
```

> [!IMPORTANT]
> When using the **Force** switch with the `New-Item` command to create a folder, and the folder
> already exists, it _won't_ overwrite or replace the folder. It will simply return the existing
> folder object. However, if you use `New-Item -Force` on a file that already exists, the file
> is overwritten.

## Removing all files and folders within a folder

You can remove contained items using `Remove-Item`, but you will be prompted to confirm the
removal if the item contains anything else. For example, if you attempt to delete the folder
`C:\temp\DeleteMe` that contains other items, PowerShell prompts you for confirmation before
deleting the folder:

```powershell
Remove-Item -Path C:\temp\DeleteMe
```

```Output
Confirm
The item at C:\temp\DeleteMe has children and the Recurse parameter wasn't
specified. If you continue, all children will be removed with the item. Are you
sure you want to continue?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help
(default is "Y"):
```

If you don't want to be prompted for each contained item, specify the **Recurse** parameter:

```powershell
Remove-Item -Path C:\temp\DeleteMe -Recurse
```

## Mapping a local folder as a drive

You can also map a local folder, using the `New-PSDrive` command. The following command creates a
local drive `P:` rooted in the local Program Files directory, visible only from the PowerShell
session:

```powershell
New-PSDrive -Name P -Root $env:ProgramFiles -PSProvider FileSystem
```

Just as with network drives, drives mapped within PowerShell are immediately visible to the
PowerShell shell. To create a mapped drive visible from File Explorer, use the **Persist**
parameter. However, only remote paths can be used with **Persist**.

## Reading a text file into an array

One of the more common storage formats for text data is in a file with separate lines treated as
distinct data elements. The `Get-Content` cmdlet can be used to read an entire file in one step,
as shown here:

```powershell
Get-Content -Path $PROFILE
# Load modules and change to the PowerShell-Docs repository folder
Import-Module posh-git
Set-Location C:\Git\PowerShell-Docs
```

`Get-Content` treats the data read from the file as an array, with one element per line of file
content. You can confirm this by checking the **Length** of the returned content:

```powershell
PS> (Get-Content -Path $PROFILE).Length
3
```

This command is most useful for getting lists of information into PowerShell. For example, you might
store a list of computer names or IP addresses in the file `C:\temp\domainMembers.txt`, with one
name on each line of the file. You can use `Get-Content` to retrieve the file contents and put them
in the variable `$Computers`:

```powershell
$Computers = Get-Content -Path C:\temp\DomainMembers.txt
```

`$Computers` is now an array containing a computer name in each element.

# /./reference/samples/working-with-files-folders-and-registry-keys.md

    ---
    description: This article discusses how to deal with registry key manipulation tasks using PowerShell.
    ms.date: 12/08/2022
    title: Working with files folders and registry keys
    ---
# Working with files, folders and registry keys

> This sample only applies to Windows platforms.

PowerShell uses the noun **Item** to refer to items found on a PowerShell drive. When dealing with
the PowerShell FileSystem provider, an **Item** might be a file, a folder, or the PowerShell drive.
Listing and working with these items is a critical basic task in most administrative settings, so we
want to discuss these tasks in detail.

## Enumerating files, folders, and registry keys

Since getting a collection of items from a particular location is such a common task, the
`Get-ChildItem` cmdlet is designed specifically to return all items found within a container such as
a folder.

If you want to return all files and folders that are contained directly within the folder
`C:\Windows`, type:

```
PS> Get-ChildItem -Path C:\Windows
    Directory: Microsoft.PowerShell.Core\FileSystem::C:\Windows

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a---        2006-05-16   8:10 AM          0 0.log
-a---        2005-11-29   3:16 PM         97 acc1.txt
-a---        2005-10-23  11:21 PM       3848 actsetup.log
...
```

The listing looks similar to what you would see when you enter the `dir` command in `cmd.exe`, or
the `ls` command in a UNIX command shell.

You can perform complex listings using parameters of the `Get-ChildItem` cmdlet. You can see the
syntax the `Get-ChildItem` cmdlet by typing:

```powershell
Get-Command -Name Get-ChildItem -Syntax
```

These parameters can be mixed and matched to get highly customized output.

### Listing all contained items

To see both the items inside a Windows folder and any items that are contained within the
subfolders, use the **Recurse** parameter of `Get-ChildItem`. The listing displays everything within
the Windows folder and the items in its subfolders. For example:

```
PS> Get-ChildItem -Path C:\WINDOWS -Recurse

    Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS
    Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\AppPatch
Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a---        2004-08-04   8:00 AM    1852416 AcGenral.dll
...
```

### Filtering items by name

To display only the names of items, use the **Name** parameter of `Get-Childitem`:

```
PS> Get-ChildItem -Path C:\WINDOWS -Name
addins
AppPatch
assembly
...
```

### Forcibly listing hidden items

Items that are hidden in File Explorer or `cmd.exe` aren't displayed in the output of a
`Get-ChildItem` command. To display hidden items, use the **Force** parameter of `Get-ChildItem`.
For example:

```powershell
Get-ChildItem -Path C:\Windows -Force
```

This parameter is named **Force** because you can forcibly override the normal behavior of the
`Get-ChildItem` command. **Force** is a widely used parameter that forces an action that a cmdlet
wouldn't normally perform, although it can't perform any action that compromises the security of the
system.

### Matching item names with wildcards

The `Get-ChildItem` command accepts wildcards in the path of the items to list.

Because wildcard matching is handled by the PowerShell engine, all cmdlets that accepts wildcards
use the same notation and have the same matching behavior. The PowerShell wildcard notation
includes:

- Asterisk (`*`) matches zero or more occurrences of any character.
- Question mark (`?`) matches exactly one character.
- Left bracket (`[`) character and right bracket (`]`) character surround a set of characters to be
  matched.

Here are some examples of how wildcard specification works.

To find all files in the Windows directory with the suffix `.log` and exactly five characters in the
base name, enter the following command:

```
PS> Get-ChildItem -Path C:\Windows\?????.log

    Directory: Microsoft.PowerShell.Core\FileSystem::C:\Windows
Mode                LastWriteTime     Length Name
----                -------------     ------ ----
...
-a---        2006-05-11   6:31 PM     204276 ocgen.log
-a---        2006-05-11   6:31 PM      22365 ocmsn.log
...
-a---        2005-11-11   4:55 AM         64 setup.log
-a---        2005-12-15   2:24 PM      17719 VxSDM.log
...
```

To find all files that begin with the letter `x` in the Windows directory, type:

```powershell
Get-ChildItem -Path C:\Windows\x*
```

To find all files whose names begin with "x" or "z", type:

```powershell
Get-ChildItem -Path C:\Windows\[xz]*
```

For more information about wildcards, see [about_Wildcards][01].

### Excluding items

You can exclude specific items using the **Exclude** parameter of `Get-ChildItem`. This lets you
perform complex filtering in a single statement.

For example, suppose you are trying to find the Windows Time Service DLL in the **System32** folder,
and all you can remember about the DLL name is that it begins with "W" and has "32" in it.

An expression like `w*32*.dll` will find all DLLs that satisfy the conditions, but you may want to
further filter out the files and omit any win32 files. You can omit these files using the
**Exclude** parameter with the pattern `win*`:

```
PS> Get-ChildItem -Path C:\WINDOWS\System32\w*32*.dll -Exclude win*

    Directory: C:\WINDOWS\System32

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---           3/18/2019  9:43 PM         495616 w32time.dll
-a---           3/18/2019  9:44 PM          35328 w32topl.dll
-a---           1/24/2020  5:44 PM         401920 Wldap32.dll
-a---          10/10/2019  5:40 PM         442704 ws2_32.dll
-a---           3/18/2019  9:44 PM          66048 wsnmp32.dll
-a---           3/18/2019  9:44 PM          18944 wsock32.dll
-a---           3/18/2019  9:44 PM          64792 wtsapi32.dll
```

### Mixing Get-ChildItem parameters

You can use several of the parameters of the `Get-ChildItem` cmdlet in the same command. Before you
mix parameters, be sure that you understand wildcard matching. For example, the following command
returns no results:

```powershell
Get-ChildItem -Path C:\Windows\*.dll -Recurse -Exclude [a-y]*.dll
```

There are no results, even though there are two DLLs that begin with the letter "z" in the Windows
folder.

No results were returned because we specified the wildcard as part of the path. Even though the
command was recursive, the `Get-ChildItem` cmdlet restricted the items to those that are in the
Windows folder with names ending with `.dll`.

To specify a recursive search for files whose names match a special pattern, use the **Include**
parameter.

```
PS> Get-ChildItem -Path C:\Windows -Include *.dll -Recurse -Exclude [a-y]*.dll

    Directory: Microsoft.PowerShell.Core\FileSystem::C:\Windows\System32\Setup

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a---        2004-08-04   8:00 AM       8261 zoneoc.dll

    Directory: Microsoft.PowerShell.Core\FileSystem::C:\Windows\System32

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a---        2004-08-04   8:00 AM     337920 zipfldr.dll
```

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_wildcards

# /./reference/samples/working-with-registry-entries.md

    ---
    description: This article discusses how to deal with registry entries using PowerShell.
    ms.date: 12/08/2022
    title: Working with registry entries
    ---
# Working with registry entries

> This sample only applies to Windows platforms.

Because registry entries are properties of keys and, as such, can't be directly browsed, we need to
take a slightly different approach when working with them.

## Listing registry entries

There are many different ways to examine registry entries. The simplest way is to get the property
names associated with a key. For example, to see the names of the entries in the registry key
`HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion`, use `Get-Item`. Registry keys have a
property with the generic name of "Property" that's a list of registry entries in the key. The
following command selects the Property property and expands the items so that they're displayed in a
list:

```powershell
Get-Item -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion |
    Select-Object -ExpandProperty Property
```

```Output
DevicePath
MediaPathUnexpanded
ProgramFilesDir
CommonFilesDir
ProductId
```

To view the registry entries in a more readable form, use `Get-ItemProperty`:

```powershell
Get-ItemProperty -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion
```

```Output
ProgramFilesDir          : C:\Program Files
CommonFilesDir           : C:\Program Files\Common Files
ProgramFilesDir (x86)    : C:\Program Files (x86)
CommonFilesDir (x86)     : C:\Program Files (x86)\Common Files
CommonW6432Dir           : C:\Program Files\Common Files
DevicePath               : C:\WINDOWS\inf
MediaPathUnexpanded      : C:\WINDOWS\Media
ProgramFilesPath         : C:\Program Files
ProgramW6432Dir          : C:\Program Files
SM_ConfigureProgramsName : Set Program Access and Defaults
SM_GamesName             : Games
PSPath                   : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SOFTWA
                           RE\Microsoft\Windows\CurrentVersion
PSParentPath             : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SOFTWA
                           RE\Microsoft\Windows
PSChildName              : CurrentVersion
PSDrive                  : HKLM
PSProvider               : Microsoft.PowerShell.Core\Registry
```

The Windows PowerShell-related properties for the key are all prefixed with "PS", such as
**PSPath**, **PSParentPath**, **PSChildName**, and **PSProvider**.

You can use the `*.*` notation for referring to the current location. You can use `Set-Location` to
change to the **CurrentVersion** registry container first:

```powershell
Set-Location -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion
```

Alternatively, you can use the built-in `HKLM:` PSDrive with `Set-Location`:

```powershell
Set-Location -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion
```

You can then use the `.` notation for the current location to list the properties without
specifying a full path:

```powershell
Get-ItemProperty -Path .
```

```Output
...
DevicePath          : C:\WINDOWS\inf
MediaPathUnexpanded : C:\WINDOWS\Media
ProgramFilesDir     : C:\Program Files
...
```

Path expansion works the same as it does within the filesystem, so from this location you can get
the **ItemProperty** listing for `HKLM:\SOFTWARE\Microsoft\Windows\Help` using
`Get-ItemProperty -Path ..\Help`.

## Getting a single registry entry

If you want to retrieve a specific entry in a registry key, you can use one of several possible
approaches. This example finds the value of **DevicePath** in
`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion`.

Using `Get-ItemProperty`, use the **Path** parameter to specify the name of the key, and the
**Name** parameter to specify the name of the **DevicePath** entry.

```powershell
Get-ItemProperty -Path HKLM:\Software\Microsoft\Windows\CurrentVersion -Name DevicePath
```

```Output
DevicePath   : C:\WINDOWS\inf
PSPath       : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion
PSParentPath : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\Software\Microsoft\Windows
PSChildName  : CurrentVersion
PSDrive      : HKLM
PSProvider   : Microsoft.PowerShell.Core\Registry
```

This command returns the standard Windows PowerShell properties as well as the **DevicePath**
property.

> [!NOTE]
> Although `Get-ItemProperty` has **Filter**, **Include**, and **Exclude** parameters, they can't
> be used to filter by property name. These parameters refer to registry keys, which are item
> paths and not registry entries, which are item properties.

Another option is to use the `reg.exe` command line tool. For help with `reg.exe`, type `reg.exe /?`
at a command prompt. To find the **DevicePath** entry, use `reg.exe` as shown in the following
command:

```powershell
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion /v DevicePath
```

```Output
! REG.EXE VERSION 3.0

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion
    DevicePath  REG_EXPAND_SZ   %SystemRoot%\inf
```

You can also use the **WshShell** COM object to find some registry entries, although this method
doesn't work with large binary data or with registry entry names that include characters such as
backslash (`\`). Append the property name to the item path with a `\` separator:

```powershell
(New-Object -ComObject WScript.Shell).RegRead("HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\DevicePath")
```

```Output
%SystemRoot%\inf
```

## Setting a single registry entry

If you want to change a specific entry in a registry key, you can use one of several possible
approaches. This example modifies the **Path** entry under `HKEY_CURRENT_USER\Environment`. The
**Path** entry specifies where to find executable files.

1. Retrieve the current value of the **Path** entry using `Get-ItemProperty`.
1. Add the new value, separating it with a `;`.
1. Use `Set-ItemProperty` with the specified key, entry name, and value to modify the registry
   entry.

```powershell
$value = Get-ItemProperty -Path HKCU:\Environment -Name Path
$newpath = $value.Path += ";C:\src\bin\"
Set-ItemProperty -Path HKCU:\Environment -Name Path -Value $newpath
```

> [!NOTE]
> Although `Set-ItemProperty` has **Filter**, **Include**, and **Exclude** parameters, they
> can't be used to filter by property name. These parameters refer to registry keys—which are item
> paths—and not registry entries—which are item properties.

Another option is to use the Reg.exe command line tool. For help with reg.exe, type `reg.exe /?` at
a command prompt.

The following example changes the **Path** entry by removing the path added in the example above.
`Get-ItemProperty` is still used to retrieve the current value to avoid having to parse the string
returned from `reg query`. The **SubString** and **LastIndexOf** methods are used to retrieve the
last path added to the **Path** entry.

```powershell
$value = Get-ItemProperty -Path HKCU:\Environment -Name Path
$newpath = $value.Path.SubString(0, $value.Path.LastIndexOf(';'))
reg add HKCU\Environment /v Path /d $newpath /f
```

```Output
The operation completed successfully.
```

## Creating new registry entries

To add a new entry named "PowerShellPath" to the **CurrentVersion** key, use `New-ItemProperty` with
the path to the key, the entry name, and the value of the entry. For this example, we will take the
value of the Windows PowerShell variable `$PSHome`, which stores the path to the installation
directory for Windows PowerShell.

You can add the new entry to the key using the following command, and the command also returns
information about the new entry:

```powershell
New-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion -Name PowerShellPath -PropertyType String -Value $PSHome
```

```Output
PSPath         : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion
PSParentPath   : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
PSChildName    : CurrentVersion
PSDrive        : HKLM
PSProvider     : Microsoft.PowerShell.Core\Registry
PowerShellPath : C:\Program Files\Windows PowerShell\v1.0
```

The **PropertyType** must be the name of a **Microsoft.Win32.RegistryValueKind** enumeration member
from the following table:

| PropertyType Value |                                    Meaning                                    |
| ------------------ | ----------------------------------------------------------------------------- |
| Binary             | Binary data                                                                   |
| DWord              | A number that's a valid **UInt32**                                            |
| ExpandString       | A string that can contain environment variables that are dynamically expanded |
| MultiString        | A multiline string                                                            |
| String             | Any string value                                                              |
| QWord              | 8 bytes of binary data                                                        |

You can add a registry entry to multiple locations by specifying an array of values for the **Path**
parameter:

```powershell
New-ItemProperty -Name PowerShellPath -PropertyType String -Value $PSHome `
  -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion, HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion
```

You can also overwrite a pre-existing registry entry value by adding the **Force** parameter to any
`New-ItemProperty` command.

## Renaming registry entries

To rename the **PowerShellPath** entry to "PSHome," use `Rename-ItemProperty`:

```powershell
Rename-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion -Name PowerShellPath -NewName PSHome
```

To display the renamed value, add the **PassThru** parameter to the command.

```powershell
Rename-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion -Name PowerShellPath -NewName PSHome -passthru
```

## Deleting registry entries

To delete both the PSHome and PowerShellPath registry entries, use `Remove-ItemProperty`:

```powershell
Remove-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion -Name PSHome
Remove-ItemProperty -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion -Name PowerShellPath
```

# /./reference/samples/working-with-registry-keys.md

    ---
    description: This article discusses how to deal with registry keys using PowerShell.
    ms.date: 12/08/2022
    title: Working with registry keys
    ---
# Working with registry keys

> This sample only applies to Windows platforms.

Because registry keys are items on PowerShell drives, working with them is very similar to working
with files and folders. One critical difference is that every item on a registry-based PowerShell
drive is a container, just like a folder on a file system drive. However, registry entries and their
associated values are properties of the items, not distinct items.

## Listing all subkeys of a registry key

You can show all items directly within a registry key using `Get-ChildItem`. Add the optional
**Force** parameter to display hidden or system items. For example, this command displays the items
directly within PowerShell drive `HKCU:`, which corresponds to the `HKEY_CURRENT_USER` registry
hive:

```powershell
Get-ChildItem -Path HKCU:\ | Select-Object Name
```

```Output
   Hive: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER

Name
----
HKEY_CURRENT_USER\AppEvents
HKEY_CURRENT_USER\Console
HKEY_CURRENT_USER\Control Panel
HKEY_CURRENT_USER\DirectShow
HKEY_CURRENT_USER\dummy
HKEY_CURRENT_USER\Environment
HKEY_CURRENT_USER\EUDC
HKEY_CURRENT_USER\Keyboard Layout
HKEY_CURRENT_USER\MediaFoundation
HKEY_CURRENT_USER\Microsoft
HKEY_CURRENT_USER\Network
HKEY_CURRENT_USER\Printers
HKEY_CURRENT_USER\Software
HKEY_CURRENT_USER\System
HKEY_CURRENT_USER\Uninstall
HKEY_CURRENT_USER\WXP
HKEY_CURRENT_USER\Volatile Environment
```

These are the top-level keys visible under `HKEY_CURRENT_USER` in the Registry Editor
(`regedit.exe`).

You can also specify this registry path by specifying the registry provider's name, followed by
`::`. The registry provider's full name is `Microsoft.PowerShell.Core\Registry`, but this can be
shortened to just `Registry`. Any of the following commands will list the contents directly under
`HKCU:`.

```powershell
Get-ChildItem -Path Registry::HKEY_CURRENT_USER
Get-ChildItem -Path Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER
Get-ChildItem -Path Registry::HKCU
Get-ChildItem -Path Microsoft.PowerShell.Core\Registry::HKCU
Get-ChildItem HKCU:
```

These commands list only the directly contained items, much like using `DIR` in `cmd.exe` or `ls`
in a UNIX shell. To show contained items, you need to specify the **Recurse** parameter. To list all
registry keys in `HKCU:`, use the following command.

```powershell
Get-ChildItem -Path HKCU:\ -Recurse
```

`Get-ChildItem` can perform complex filtering capabilities through its **Path**, **Filter**,
**Include**, and **Exclude** parameters, but those parameters are typically based only on name. You
can perform complex filtering based on other properties of items using the `Where-Object` cmdlet.
The following command finds all keys within `HKCU:\Software` that have no more than one subkey and
also have exactly four values:

```powershell
Get-ChildItem -Path HKCU:\Software -Recurse |
    Where-Object {($_.SubKeyCount -le 1) -and ($_.ValueCount -eq 4) }
```

## Copying keys

Copying is done with `Copy-Item`. The following example copies the `CurrentVersion` subkey of
`HKLM:\SOFTWARE\Microsoft\Windows\` and all of its properties to `HKCU:\`.

```powershell
Copy-Item -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion' -Destination HKCU:
```

If you examine this new key in the registry editor or using `Get-ChildItem`, you notice that you
don't have copies of the contained subkeys in the new location. In order to copy all of the contents
of a container, you need to specify the **Recurse** parameter. To make the preceding copy command
recursive, you would use this command:

```powershell
Copy-Item -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion' -Destination HKCU: -Recurse
```

You can still use other tools you already have available to perform filesystem copies. Any registry
editing tools—including `reg.exe`, `regini.exe`, `regedit.exe`, and COM objects that support
registry editing, such as **WScript.Shell** and WMI's **StdRegProv** class can be used from within
PowerShell.

## Creating keys

Creating new keys in the registry is simpler than creating a new item in a file system. Because all
registry keys are containers, you don't need to specify the item type. Just provide an explicit
path, such as:

```powershell
New-Item -Path HKCU:\Software_DeleteMe
```

You can also use a provider-based path to specify a key:

```powershell
New-Item -Path Registry::HKCU\Software_DeleteMe
```

## Deleting keys

Deleting items is essentially the same for all providers. The following commands silently remove
items:

```powershell
Remove-Item -Path HKCU:\Software_DeleteMe
Remove-Item -Path 'HKCU:\key with spaces in the name'
```

## Removing all keys under a specific key

You can remove contained items using `Remove-Item`, but you will be prompted to confirm the removal
if the item contains anything else. For example, if we attempt to delete the `HKCU:\CurrentVersion`
subkey we created, we see this:

```powershell
Remove-Item -Path HKCU:\CurrentVersion
```

```Output
Confirm
The item at HKCU:\CurrentVersion\AdminDebug has children and the -recurse
parameter was not specified. If you continue, all children will be removed with
the item. Are you sure you want to continue?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "Y"):
```

To delete contained items without prompting, specify the **Recurse** parameter:

```powershell
Remove-Item -Path HKCU:\CurrentVersion -Recurse
```

If you wanted to remove all items within `HKCU:\CurrentVersion` but not `HKCU:\CurrentVersion`
itself, you could instead use:

```powershell
Remove-Item -Path HKCU:\CurrentVersion\* -Recurse
```

# /./reference/samples/creating-a-custom-input-box.md

    ---
    description: This article shows how to create a custom input box by using the .NET Framework form-building features in Windows PowerShell.
    ms.date: 12/08/2022
    title: Creating a custom input box
    ---
# Creating a custom input box

> This sample only applies to Windows platforms.

Script a graphical custom input box using Microsoft .NET Framework form-building features in Windows
PowerShell 3.0 and later releases.

## Create a custom, graphical input box

Copy and then paste the following into Windows PowerShell ISE, and then save it as a PowerShell
script (`.ps1`) file.

```powershell
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$form = New-Object System.Windows.Forms.Form
$form.Text = 'Data Entry Form'
$form.Size = New-Object System.Drawing.Size(300,200)
$form.StartPosition = 'CenterScreen'

$okButton = New-Object System.Windows.Forms.Button
$okButton.Location = New-Object System.Drawing.Point(75,120)
$okButton.Size = New-Object System.Drawing.Size(75,23)
$okButton.Text = 'OK'
$okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
$form.AcceptButton = $okButton
$form.Controls.Add($okButton)

$cancelButton = New-Object System.Windows.Forms.Button
$cancelButton.Location = New-Object System.Drawing.Point(150,120)
$cancelButton.Size = New-Object System.Drawing.Size(75,23)
$cancelButton.Text = 'Cancel'
$cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
$form.CancelButton = $cancelButton
$form.Controls.Add($cancelButton)

$label = New-Object System.Windows.Forms.Label
$label.Location = New-Object System.Drawing.Point(10,20)
$label.Size = New-Object System.Drawing.Size(280,20)
$label.Text = 'Please enter the information in the space below:'
$form.Controls.Add($label)

$textBox = New-Object System.Windows.Forms.TextBox
$textBox.Location = New-Object System.Drawing.Point(10,40)
$textBox.Size = New-Object System.Drawing.Size(260,20)
$form.Controls.Add($textBox)

$form.Topmost = $true

$form.Add_Shown({$textBox.Select()})
$result = $form.ShowDialog()

if ($result -eq [System.Windows.Forms.DialogResult]::OK)
{
    $x = $textBox.Text
    $x
}
```

The script begins by loading two .NET Framework classes: **System.Drawing** and
**System.Windows.Forms**. You then start a new instance of the .NET Framework class
**System.Windows.Forms.Form**. That provides a blank form or window to which you can start adding
controls.

```powershell
$form = New-Object System.Windows.Forms.Form
```

After you create an instance of the Form class, assign values to three properties of this class.

- **Text.** This becomes the title of the window.
- **Size.** This is the size of the form, in pixels. The preceding script creates a form that's 300
  pixels wide by 200 pixels tall.
- **StartingPosition.** This optional property is set to **CenterScreen** in the preceding script.
  If you don't add this property, Windows selects a location when the form is opened. By setting the
  **StartingPosition** to **CenterScreen**, you're automatically displaying the form in the middle
  of the screen each time it loads.

```powershell
$form.Text = 'Data Entry Form'
$form.Size = New-Object System.Drawing.Size(300,200)
$form.StartPosition = 'CenterScreen'
```

Next, create an **OK** button for your form. Specify the size and behavior of the **OK** button. In
this example, the button position is 120 pixels from the form's top edge, and 75 pixels from the
left edge. The button height is 23 pixels, while the button length is 75 pixels. The script uses
predefined Windows Forms types to determine the button behaviors.

```powershell
$okButton = New-Object System.Windows.Forms.Button
$okButton.Location = New-Object System.Drawing.Point(75,120)
$okButton.Size = New-Object System.Drawing.Size(75,23)
$okButton.Text = 'OK'
$okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
$form.AcceptButton = $OKButton
$form.Controls.Add($OKButton)
```

Similarly, you create a **Cancel** button. The **Cancel** button is 120 pixels from the top, but 150
pixels from the left edge of the window.

```powershell
$cancelButton = New-Object System.Windows.Forms.Button
$cancelButton.Location = New-Object System.Drawing.Point(150,120)
$cancelButton.Size = New-Object System.Drawing.Size(75,23)
$cancelButton.Text = 'Cancel'
$cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
$form.CancelButton = $cancelButton
$form.Controls.Add($cancelButton)
```

Next, provide label text on your window that describes the information you want users to provide.

```powershell
$label = New-Object System.Windows.Forms.Label
$label.Location = New-Object System.Drawing.Point(10,20)
$label.Size = New-Object System.Drawing.Size(280,20)
$label.Text = 'Please enter the information in the space below:'
$form.Controls.Add($label)
```

Add the control (in this case, a text box) that lets users provide the information you've described
in your label text. There are many other controls you can apply besides text boxes. For more
controls, see [System.Windows.Forms Namespace][01].

```powershell
$textBox = New-Object System.Windows.Forms.TextBox
$textBox.Location = New-Object System.Drawing.Point(10,40)
$textBox.Size = New-Object System.Drawing.Size(260,20)
$form.Controls.Add($textBox)
```

Set the **Topmost** property to **$true** to force the window to open atop other open windows and
dialog boxes.

```powershell
$form.Topmost = $true
```

Next, add this line of code to activate the form, and set the focus to the text box that you
created.

```powershell
$form.Add_Shown({$textBox.Select()})
```

Add the following line of code to display the form in Windows.

```powershell
$result = $form.ShowDialog()
```

Finally, the code inside the **If** block instructs Windows what to do with the form after users
provide text in the text box, and then click the **OK** button or press the **Enter** key.

```powershell
if ($result -eq [System.Windows.Forms.DialogResult]::OK) {
    $x = $textBox.Text
    $x
}
```

## See also

- [GitHub: Dave Wyatt's WinFormsExampleUpdates][02])
- [Windows PowerShell Tip of the Week:  Creating a Custom Input Box][03]

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.windows.forms
[02]: https://github.com/dlwyatt/WinFormsExampleUpdates
[03]: https://learn.microsoft.com/previous-versions/windows/it-pro/windows-powershell-1.0/ff730941(v=technet.10)

# /./reference/samples/creating-a-graphical-date-picker.md

    ---
    description: This article shows how to create a custom calendar-style control by using the .NET Framework form-building features in Windows PowerShell.
    ms.date: 12/08/2022
    title: Creating a graphical date picker
    ---
# Creating a graphical date picker

> This sample only applies to Windows platforms.

Use Windows PowerShell 3.0 and later releases to create a form with a graphical, calendar-style
control that lets users select a day of the month.

## Create a graphical date-picker control

Copy and then paste the following into Windows PowerShell ISE, and then save it as a PowerShell
script (`.ps1`) file.

```powershell
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$form = New-Object Windows.Forms.Form -Property @{
    StartPosition = [Windows.Forms.FormStartPosition]::CenterScreen
    Size          = New-Object Drawing.Size 243, 230
    Text          = 'Select a Date'
    Topmost       = $true
}

$calendar = New-Object Windows.Forms.MonthCalendar -Property @{
    ShowTodayCircle   = $false
    MaxSelectionCount = 1
}
$form.Controls.Add($calendar)

$okButton = New-Object Windows.Forms.Button -Property @{
    Location     = New-Object Drawing.Point 38, 165
    Size         = New-Object Drawing.Size 75, 23
    Text         = 'OK'
    DialogResult = [Windows.Forms.DialogResult]::OK
}
$form.AcceptButton = $okButton
$form.Controls.Add($okButton)

$cancelButton = New-Object Windows.Forms.Button -Property @{
    Location     = New-Object Drawing.Point 113, 165
    Size         = New-Object Drawing.Size 75, 23
    Text         = 'Cancel'
    DialogResult = [Windows.Forms.DialogResult]::Cancel
}
$form.CancelButton = $cancelButton
$form.Controls.Add($cancelButton)

$result = $form.ShowDialog()

if ($result -eq [Windows.Forms.DialogResult]::OK) {
    $date = $calendar.SelectionStart
    Write-Host "Date selected: $($date.ToShortDateString())"
}
```

The script begins by loading two .NET Framework classes: **System.Drawing** and
**System.Windows.Forms**. You then start a new instance of the .NET Framework class
**Windows.Forms.Form**. That provides a blank form or window to which you can start adding controls.

```powershell
$form = New-Object Windows.Forms.Form -Property @{
    StartPosition = [Windows.Forms.FormStartPosition]::CenterScreen
    Size          = New-Object Drawing.Size 243, 230
    Text          = 'Select a Date'
    Topmost       = $true
}
```

This example assigns values to four properties of this class by using the **Property** property and
hashtable.

1. **StartPosition**: If you don't add this property, Windows selects a location when the form is
   opened. By setting this property to **CenterScreen**, you're automatically displaying the form in
   the middle of the screen each time it loads.

1. **Size**:
   This is the size of the form, in pixels.
   The preceding script creates a form that's 243 pixels wide by 230 pixels tall.

1. **Text**:
   This becomes the title of the window.

1. **Topmost**: By setting this property to `$true`, you can force the window to open atop other
   open windows and dialog boxes.

Next, create and then add a calendar control in your form. In this example, the current day isn't
highlighted or circled. Users can select only one day on the calendar at one time.

```powershell
$calendar = New-Object Windows.Forms.MonthCalendar -Property @{
    ShowTodayCircle   = $false
    MaxSelectionCount = 1
}
$form.Controls.Add($calendar)
```

Next, create an **OK** button for your form. Specify the size and behavior of the **OK** button. In
this example, the button position is 165 pixels from the form's top edge, and 38 pixels from the
left edge. The button height is 23 pixels, while the button length is 75 pixels. The script uses
predefined Windows Forms types to determine the button behaviors.

```powershell
$okButton = New-Object Windows.Forms.Button -Property @{
    Location     = New-Object Drawing.Point 38, 165
    Size         = New-Object Drawing.Size 75, 23
    Text         = 'OK'
    DialogResult = [Windows.Forms.DialogResult]::OK
}
$form.AcceptButton = $okButton
$form.Controls.Add($okButton)
```

Similarly, you create a **Cancel** button. The **Cancel** button is 165 pixels from the top, but 113
pixels from the left edge of the window.

```powershell
$cancelButton = New-Object Windows.Forms.Button -Property @{
    Location     = New-Object Drawing.Point 113, 165
    Size         = New-Object Drawing.Size 75, 23
    Text         = 'Cancel'
    DialogResult = [Windows.Forms.DialogResult]::Cancel
}
$form.CancelButton = $cancelButton
$form.Controls.Add($cancelButton)
```

Add the following line of code to display the form in Windows.

```powershell
$result = $form.ShowDialog()
```

Finally, the code inside the `if` block instructs Windows what to do with the form after users
select a day on the calendar, and then click the **OK** button or press the **Enter** key. Windows
PowerShell displays the selected date to users.

```powershell
if ($result -eq [Windows.Forms.DialogResult]::OK) {
    $date = $calendar.SelectionStart
    Write-Host "Date selected: $($date.ToShortDateString())"
}
```

## See also

- [GitHub: Dave Wyatt's WinFormsExampleUpdates][02]
- [Windows PowerShell Tip of the Week: Creating a Graphical Date Picker][01])

<!-- link references -->
[01]: https://learn.microsoft.com/previous-versions/windows/it-pro/windows-powershell-1.0/ff730942(v=technet.10)
[02]: https://github.com/dlwyatt/WinFormsExampleUpdates

# /./reference/samples/multiple-selection-list-boxes.md

    ---
    description: This article shows how to create a multiple-selection list box control using the .NET Framework form-building features in Windows PowerShell.
    ms.date: 12/08/2022
    title: Multiple selection list boxes
    ---
# Multiple-selection list boxes

> This sample only applies to Windows platforms.

Use Windows PowerShell 3.0 and later releases to create a multiple-selection list box control in a
custom Windows Form.

## Create list box controls that allow multiple selections

Copy and then paste the following into Windows PowerShell ISE, and then save it as a PowerShell
script (`.ps1`) file.

```powershell
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$form = New-Object System.Windows.Forms.Form
$form.Text = 'Data Entry Form'
$form.Size = New-Object System.Drawing.Size(300,200)
$form.StartPosition = 'CenterScreen'

$OKButton = New-Object System.Windows.Forms.Button
$OKButton.Location = New-Object System.Drawing.Point(75,120)
$OKButton.Size = New-Object System.Drawing.Size(75,23)
$OKButton.Text = 'OK'
$OKButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
$form.AcceptButton = $OKButton
$form.Controls.Add($OKButton)

$CancelButton = New-Object System.Windows.Forms.Button
$CancelButton.Location = New-Object System.Drawing.Point(150,120)
$CancelButton.Size = New-Object System.Drawing.Size(75,23)
$CancelButton.Text = 'Cancel'
$CancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
$form.CancelButton = $CancelButton
$form.Controls.Add($CancelButton)

$label = New-Object System.Windows.Forms.Label
$label.Location = New-Object System.Drawing.Point(10,20)
$label.Size = New-Object System.Drawing.Size(280,20)
$label.Text = 'Please make a selection from the list below:'
$form.Controls.Add($label)

$listBox = New-Object System.Windows.Forms.Listbox
$listBox.Location = New-Object System.Drawing.Point(10,40)
$listBox.Size = New-Object System.Drawing.Size(260,20)

$listBox.SelectionMode = 'MultiExtended'

[void] $listBox.Items.Add('Item 1')
[void] $listBox.Items.Add('Item 2')
[void] $listBox.Items.Add('Item 3')
[void] $listBox.Items.Add('Item 4')
[void] $listBox.Items.Add('Item 5')

$listBox.Height = 70
$form.Controls.Add($listBox)
$form.Topmost = $true

$result = $form.ShowDialog()

if ($result -eq [System.Windows.Forms.DialogResult]::OK)
{
    $x = $listBox.SelectedItems
    $x
}
```

The script begins by loading two .NET Framework classes: **System.Drawing** and
**System.Windows.Forms**. You then start a new instance of the .NET Framework class
**System.Windows.Forms.Form**. That provides a blank form or window to which you can start adding
controls.

```powershell
$form = New-Object System.Windows.Forms.Form
```

After you create an instance of the Form class, assign values to three properties of this class.

- **Text.** This becomes the title of the window.
- **Size.** This is the size of the form, in pixels. The preceding script creates a form that's 300
  pixels wide by 200 pixels tall.
- **StartingPosition.** This optional property is set to **CenterScreen** in the preceding script.
  If you don't add this property, Windows selects a location when the form is opened. By setting the
  **StartingPosition** to **CenterScreen**, you're automatically displaying the form in the middle
  of the screen each time it loads.

```powershell
$form.Text = 'Data Entry Form'
$form.Size = New-Object System.Drawing.Size(300,200)
$form.StartPosition = 'CenterScreen'
```

Next, create an **OK** button for your form. Specify the size and behavior of the **OK** button. In
this example, the button position is 120 pixels from the form's top edge, and 75 pixels from the
left edge. The button height is 23 pixels, while the button length is 75 pixels. The script uses
predefined Windows Forms types to determine the button behaviors.

```powershell
$OKButton = New-Object System.Windows.Forms.Button
$OKButton.Location = New-Object System.Drawing.Size(75,120)
$OKButton.Size = New-Object System.Drawing.Size(75,23)
$OKButton.Text = 'OK'
$OKButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
$form.AcceptButton = $OKButton
$form.Controls.Add($OKButton)
```

Similarly, you create a **Cancel** button. The **Cancel** button is 120 pixels from the top, but 150
pixels from the left edge of the window.

```powershell
$CancelButton = New-Object System.Windows.Forms.Button
$CancelButton.Location = New-Object System.Drawing.Point(150,120)
$CancelButton.Size = New-Object System.Drawing.Size(75,23)
$CancelButton.Text = 'Cancel'
$CancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
$form.CancelButton = $CancelButton
$form.Controls.Add($CancelButton)
```

Next, provide label text on your window that describes the information you want users to provide.

```powershell
$label = New-Object System.Windows.Forms.Label
$label.Location = New-Object System.Drawing.Point(10,20)
$label.Size = New-Object System.Drawing.Size(280,20)
$label.Text = 'Please make a selection from the list below:'
$form.Controls.Add($label)
```

Add the control (in this case, a list box) that lets users provide the information you've described
in your label text. There are many other controls you can apply besides text boxes; for more
controls, see [System.Windows.Forms Namespace][01].

```powershell
$listBox = New-Object System.Windows.Forms.Listbox
$listBox.Location = New-Object System.Drawing.Point(10,40)
$listBox.Size = New-Object System.Drawing.Size(260,20)
```

Here's how you specify that you want to allow users to select multiple values from the list.

```powershell
$listBox.SelectionMode = 'MultiExtended'
```

In the next section, you specify the values you want the list box to display to users.

```powershell
[void] $listBox.Items.Add('Item 1')
[void] $listBox.Items.Add('Item 2')
[void] $listBox.Items.Add('Item 3')
[void] $listBox.Items.Add('Item 4')
[void] $listBox.Items.Add('Item 5')
```

Specify the maximum height of the list box control.

```powershell
$listBox.Height = 70
```

Add the list box control to your form, and instruct Windows to open the form atop other windows and
dialog boxes when it's opened.

```powershell
$form.Controls.Add($listBox)
$form.Topmost = $true
```

Add the following line of code to display the form in Windows.

```powershell
$result = $form.ShowDialog()
```

Finally, the code inside the `if` block instructs Windows what to do with the form after users
select one or more options from the list box, and then click the **OK** button or press the
**Enter** key.

```powershell
if ($result -eq [System.Windows.Forms.DialogResult]::OK)
{
    $x = $listBox.SelectedItems
    $x
}
```

## See also

- [Weekend Scripter: Fixing PowerShell GUI Examples][03]
- [GitHub: Dave Wyatt's WinFormsExampleUpdates][04]
- [Windows PowerShell Tip of the Week: Multi-Select List Boxes - And More!][02])

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.windows.forms
[02]: https://learn.microsoft.com/previous-versions/windows/it-pro/windows-powershell-1.0/ff730950(v=technet.10)
[03]: https://devblogs.microsoft.com/scripting/weekend-scripter-fixing-powershell-gui-examples/
[04]: https://github.com/dlwyatt/WinFormsExampleUpdates

# /./reference/samples/selecting-items-from-a-list-box.md

    ---
    description: This article shows how to create a list box control using the .NET Framework form-building features in Windows PowerShell.
    ms.date: 12/08/2022
    title: Selecting items from a list box
    ---
# Selecting items from a list box

> This sample only applies to Windows platforms.

Use Windows PowerShell 3.0 and later releases to create a dialog box that lets users select items
from a list box control.

## Create a list box control, and select items from it

Copy and then paste the following into Windows PowerShell ISE, and then save it as a PowerShell
script (`.ps1`) file.

```powershell
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

$form = New-Object System.Windows.Forms.Form
$form.Text = 'Select a Computer'
$form.Size = New-Object System.Drawing.Size(300,200)
$form.StartPosition = 'CenterScreen'

$okButton = New-Object System.Windows.Forms.Button
$okButton.Location = New-Object System.Drawing.Point(75,120)
$okButton.Size = New-Object System.Drawing.Size(75,23)
$okButton.Text = 'OK'
$okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
$form.AcceptButton = $okButton
$form.Controls.Add($okButton)

$cancelButton = New-Object System.Windows.Forms.Button
$cancelButton.Location = New-Object System.Drawing.Point(150,120)
$cancelButton.Size = New-Object System.Drawing.Size(75,23)
$cancelButton.Text = 'Cancel'
$cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
$form.CancelButton = $cancelButton
$form.Controls.Add($cancelButton)

$label = New-Object System.Windows.Forms.Label
$label.Location = New-Object System.Drawing.Point(10,20)
$label.Size = New-Object System.Drawing.Size(280,20)
$label.Text = 'Please select a computer:'
$form.Controls.Add($label)

$listBox = New-Object System.Windows.Forms.ListBox
$listBox.Location = New-Object System.Drawing.Point(10,40)
$listBox.Size = New-Object System.Drawing.Size(260,20)
$listBox.Height = 80

[void] $listBox.Items.Add('atl-dc-001')
[void] $listBox.Items.Add('atl-dc-002')
[void] $listBox.Items.Add('atl-dc-003')
[void] $listBox.Items.Add('atl-dc-004')
[void] $listBox.Items.Add('atl-dc-005')
[void] $listBox.Items.Add('atl-dc-006')
[void] $listBox.Items.Add('atl-dc-007')

$form.Controls.Add($listBox)

$form.Topmost = $true

$result = $form.ShowDialog()

if ($result -eq [System.Windows.Forms.DialogResult]::OK)
{
    $x = $listBox.SelectedItem
    $x
}
```

The script begins by loading two .NET Framework classes: **System.Drawing** and
**System.Windows.Forms**. You then start a new instance of the .NET Framework class
**System.Windows.Forms.Form**. That provides a blank form or window to which you can start adding
controls.

```powershell
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
```

After you create an instance of the **Form** class, assign values to three properties of this class.

- **Text.** This becomes the title of the window.
- **Size.** This is the size of the form, in pixels. The preceding script creates a form that's 300
  pixels wide by 200 pixels tall.
- **StartingPosition.** This optional property is set to **CenterScreen** in the preceding script.
  If you don't add this property, Windows selects a location when the form is opened. By setting the
  **StartingPosition** to **CenterScreen**, you're automatically displaying the form in the middle
  of the screen each time it loads.

```powershell
$form.Text = 'Select a Computer'
$form.Size = New-Object System.Drawing.Size(300,200)
$form.StartPosition = 'CenterScreen'
```

Next, create an **OK** button for your form. Specify the size and behavior of the **OK** button. In
this example, the button position is 120 pixels from the form's top edge, and 75 pixels from the
left edge. The button height is 23 pixels, while the button length is 75 pixels. The script uses
predefined Windows Forms types to determine the button behaviors.

```powershell
$okButton = New-Object System.Windows.Forms.Button
$okButton.Location = New-Object System.Drawing.Point(75,120)
$okButton.Size = New-Object System.Drawing.Size(75,23)
$okButton.Text = 'OK'
$okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
$form.AcceptButton = $okButton
$form.Controls.Add($okButton)
```

Similarly, you create a **Cancel** button. The **Cancel** button is 120 pixels from the top, but 150
pixels from the left edge of the window.

```powershell
$cancelButton = New-Object System.Windows.Forms.Button
$cancelButton.Location = New-Object System.Drawing.Point(150,120)
$cancelButton.Size = New-Object System.Drawing.Size(75,23)
$cancelButton.Text = 'Cancel'
$cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
$form.CancelButton = $cancelButton
$form.Controls.Add($cancelButton)
```

Next, provide label text on your window that describes the information you want users to provide. In
this case, you want users to select a computer.

```powershell
$label = New-Object System.Windows.Forms.Label
$label.Location = New-Object System.Drawing.Point(10,20)
$label.Size = New-Object System.Drawing.Size(280,20)
$label.Text = 'Please select a computer:'
$form.Controls.Add($label)
```

Add the control (in this case, a list box) that lets users provide the information you've described
in your label text. There are many other controls you can apply besides list boxes; for more
controls, see [System.Windows.Forms Namespace][01].

```powershell
$listBox = New-Object System.Windows.Forms.ListBox
$listBox.Location = New-Object System.Drawing.Point(10,40)
$listBox.Size = New-Object System.Drawing.Size(260,20)
$listBox.Height = 80
```

In the next section, you specify the values you want the list box to display to users.

> [!NOTE]
> The list box created by this script allows only one selection. To create a list box
> control that allows multiple selections, specify a value for the **SelectionMode** property,
> similarly to the following: `$listBox.SelectionMode = 'MultiExtended'`. For more information, see
> [Multiple-selection List Boxes][04].

```powershell
[void] $listBox.Items.Add('atl-dc-001')
[void] $listBox.Items.Add('atl-dc-002')
[void] $listBox.Items.Add('atl-dc-003')
[void] $listBox.Items.Add('atl-dc-004')
[void] $listBox.Items.Add('atl-dc-005')
[void] $listBox.Items.Add('atl-dc-006')
[void] $listBox.Items.Add('atl-dc-007')
```

Add the list box control to your form, and instruct Windows to open the form atop other windows and
dialog boxes when it's opened.

```powershell
$form.Controls.Add($listBox)
$form.Topmost = $true
```

Add the following line of code to display the form in Windows.

```powershell
$result = $form.ShowDialog()
```

Finally, the code inside the **If** block instructs Windows what to do with the form after users
select an option from the list box, and then click the **OK** button or press the **Enter** key.

```powershell
if ($result -eq [System.Windows.Forms.DialogResult]::OK) {
    $x = $listBox.SelectedItem
    $x
}
```

## See also

- [GitHub: Dave Wyatt's WinFormsExampleUpdates][03]
- [Windows PowerShell Tip of the Week: Selecting Items from a List Box][02]

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.windows.forms
[02]: https://learn.microsoft.com/previous-versions/windows/it-pro/windows-powershell-1.0/ff730949(v=technet.10)
[03]: https://github.com/dlwyatt/WinFormsExampleUpdates
[04]: Multiple-selection-List-Boxes.md

# /./reference/learn/experimental-features.md

    ---
    description: Lists the currently available experimental features and how to use them.
    ms.date: 02/23/2024
    title: Using Experimental Features in PowerShell
    ---
# Using Experimental Features in PowerShell

The Experimental Features support in PowerShell provides a mechanism for experimental features to
coexist with existing stable features in PowerShell or PowerShell modules.

An experimental feature is one where the design isn't finalized. The feature is available for users
to test and provide feedback. Once an experimental feature is finalized, the design changes become
breaking changes.

> [!CAUTION]
> Experimental features aren't intended to be used in production since the changes are allowed to be
> breaking. Experimental features aren't officially supported. However, we appreciate any feedback
> and bug reports. You can file issues in the [GitHub source repository][25].

For more information about enabling or disabling these features, see
[about_Experimental_Features][06].

## Experimental feature lifecycle

The [Get-ExperimentalFeature][29] cmdlet returns all experimental features available to PowerShell.
Experimental features can come from modules or the PowerShell engine. Module-based experimental
features are only available after you import the module. In the following example, the
**PSDesiredStateConfiguration** isn't loaded, so the `PSDesiredStateConfiguration.InvokeDscResource`
feature isn't available.

```powershell
Get-ExperimentalFeature
```

```Output
Name                             Enabled Source   Description
----                             ------- ------   -----------
PSCommandNotFoundSuggestion        False PSEngine Recommend potential commands based on fuzzy searc…
PSCommandWithArgs                  False PSEngine Enable `-CommandWithArgs` parameter for pwsh
PSFeedbackProvider                  True PSEngine Replace the hard-coded suggestion framework with …
PSLoadAssemblyFromNativeCode       False PSEngine Expose an API to allow assembly loading from nati…
PSModuleAutoLoadSkipOfflineFiles    True PSEngine Module discovery will skip over files that are ma…
PSSubsystemPluginModel              True PSEngine A plugin model for registering and un-registering…
```

Use the [Enable-ExperimentalFeature][28] and [Disable-ExperimentalFeature][27] cmdlets to enable or
disable a feature. You must start a new PowerShell session for this change to be in effect. Run the
following command to enable the `PSCommandNotFoundSuggestion` feature:

```powershell
Enable-ExperimentalFeature PSCommandNotFoundSuggestion
```

```Output
WARNING: Enabling and disabling experimental features do not take effect until next start
of PowerShell.
```

When an experimental feature becomes _mainstream_, it's no longer available as an experimental
feature because the functionality is now part of the PowerShell engine or module. For example, the
`PSAnsiRenderingFileInfo` feature became mainstream in PowerShell 7.3. You get the functionality of
the feature automatically.

> [!NOTE]
> Some features have configuration requirements, such as preference variables, that must be set to
> get the desired results from the feature.

When an experimental feature is _discontinued_, that feature is no longer available in the
PowerShell. For example, the `PSNativePSPathResolution` feature was discontinued in PowerShell 7.3.

## Available features

This article describes the experimental features that are available and how to use the feature.

Legend

- The ![Experimental][02] icon indicates that the experimental feature is available in the version
  of PowerShell
- The ![Mainstream][01] icon indicates the version of PowerShell where the experimental feature
  became mainstream
- The ![Discontinued][03] icon indicates the version of PowerShell where the experimental feature
  was removed

|                        Name                         |         7.2         |         7.3         |         7.4         |    7.5 (preview)    |
| --------------------------------------------------- | :-----------------: | :-----------------: | :-----------------: | :-----------------: |
| [PSCommandNotFoundSuggestion][10]                   | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] |
| [PSDesiredStateConfiguration.InvokeDscResource][14] | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] |
| [PSNativePSPathResolution][21]                      | ![Experimental][02] | ![Discontinued][03] |                     |                     |
| [PSSubsystemPluginModel][23]                        | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] |
| [PSNativeCommandArgumentPassing][18]                | ![Experimental][02] |  ![Mainstream][01]  |                     |                     |
| [PSAnsiRenderingFileInfo][09]                       | ![Experimental][02] |  ![Mainstream][01]  |                     |                     |
| [PSLoadAssemblyFromNativeCode][16]                  | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] | ![Experimental][02] |
| [PSNativeCommandErrorActionPreference][19]          |                     | ![Experimental][02] |  ![Mainstream][01]  |                     |
| [PSFeedbackProvider][15]                            |                     |                     | ![Experimental][02] | ![Experimental][02] |
| [PSModuleAutoLoadSkipOfflineFiles][17]              |                     |                     | ![Experimental][02] | ![Experimental][02] |
| [PSCommandWithArgs][11]                             |                     |                     | ![Experimental][02] | ![Experimental][02] |
| [PSNativeWindowsTildeExpansion][22]                 |                     |                     |                     | ![Experimental][02] |

### PSAnsiRenderingFileInfo

> [!NOTE]
> This feature became mainstream in PowerShell 7.3.

The ANSI formatting features were added in PowerShell 7.2. This feature adds the `$PSStyle.FileInfo`
member and enables coloring of specific file types.

- `$PSStyle.FileInfo.Directory` - Built-in member to specify the color for directories
- `$PSStyle.FileInfo.SymbolicLink` - Built-in member to specify the color for symbolic links
- `$PSStyle.FileInfo.Executable` - Built-in member to specify the color for executables.
- `$PSStyle.FileInfo.Extension` - Use this member to define the colors for different file
  extensions. The **Extension** member pre-includes extensions for archive and PowerShell files.

For more information, see [about_Automatic_Variables][05].

### PSCommandNotFoundSuggestion

Recommends potential commands based on fuzzy matching search after a **CommandNotFoundException**.

```powershell
PS> get
```

```Output
get: The term 'get' isn't recognized as the name of a cmdlet, function, script file,
or operable program. Check the spelling of the name, or if a path was included, verify
that the path is correct and try again.

Suggestion [4,General]: The most similar commands are: set, del, ft, gal, gbp, gc, gci,
gcm, gdr, gcs.
```

### PSCommandWithArgs

This feature enables the `-CommandWithArgs` parameter for `pwsh`. This parameter allows you to
execute a PowerShell command with arguments. Unlike `-Command`, this parameter populates the `$args`
built-in variable that can be used by the command.

The first string is the command and subsequent strings delimited by whitespace are the arguments.

For example:

```powershell
pwsh -CommandWithArgs '$args | % { "arg: $_" }' arg1 arg2
```

This example produces the following output:

```Output
arg: arg1
arg: arg2
```

This feature was added in PowerShell 7.4-preview.2.

### PSDesiredStateConfiguration.InvokeDscResource

Enables compilation to MOF on non-Windows systems and enables the use of `Invoke-DSCResource`
without an LCM.

Beginning with PowerShell 7.2, the **PSDesiredStateConfiguration** module was removed and this
feature is disabled by default. To enable this feature you must install the
**PSDesiredStateConfiguration** v2.0.5 module from the PowerShell Gallery and enable the feature.

DSC v3 doesn't have this experimental feature. DSC v3 only supports `Invoke-DSCResource` and doesn't
use or support MOF compilation. For more information, see
[PowerShell Desired State Configuration v3][04].

### PSFeedbackProvider

When you enable this feature, PowerShell uses a new feedback provider to give you feedback when a
command can't be found. The feedback provider is extensible, and can be implemented by third-party
modules. The feedback provider can be used by other subsystems, such as the predictor subsystem, to
provide predictive IntelliSense results.

This feature includes two built-in feedback providers:

- **GeneralCommandErrorFeedback** serves the same suggestion functionality existing today
- **UnixCommandNotFound**, available on Linux, provides feedback similar to bash.

  The **UnixCommandNotFound** serves as both a feedback provider and a predictor. The suggestion
  from command-not-found command is used both for providing the feedback when command can't be found
  in an interactive run, and for providing predictive IntelliSense results for the next command
  line.

This feature was added in PowerShell 7.4-preview.3.

### PSLoadAssemblyFromNativeCode

Exposes an API to allow assembly loading from native code.

### PSModuleAutoLoadSkipOfflineFiles

With this feature enabled, if a user's **PSModulePath** contains a folder from a cloud provider,
such as OneDrive, PowerShell no longer triggers the download of all files contained within that
folder. Any file marked as not downloaded are skipped. Users who use cloud providers to sync their
modules between machines should mark the module folder as **Pinned** or the equivalent status for
providers other than OneDrive. Marking the module folder as **Pinned** ensures that the files are
always kept on disk.

This feature was added in PowerShell 7.4-preview.1.

### PSNativeCommandArgumentPassing

> [!NOTE]
> This feature became mainstream in PowerShell 7.3.

When this experimental feature is enabled PowerShell uses the `ArgumentList` property of the
`StartProcessInfo` object rather than our current mechanism of reconstructing a string when invoking
a native executable.

> [!CAUTION]
> The new behavior is a **breaking change** from current behavior. This may break scripts and
> automation that work around the various issues when invoking native applications. Historically,
> quotes must be escaped and it isn't possible to provide empty arguments to a native application.
> Use the [stop-parsing token][08] (`--%`) or the [`Start-Process`][31] cmdlet to sidestep native
> argument passing when needed.

This feature adds a new `$PSNativeCommandArgumentPassing` preference variable that controls this
behavior. This variable allows you to select the behavior at runtime. The valid values are `Legacy`,
`Standard`, and `Windows`. The default behavior is platform specific. On Windows platforms, the
default setting is `Windows` and non-Windows platforms default to `Standard`.

`Legacy` is the historic behavior. The behavior of `Windows` and `Standard` mode are the same
except, in `Windows` mode, invocations of the following files automatically use the `Legacy` style
argument passing.


- `cmd.exe`
- `find.exe`
- `cscript.exe`
- `wscript.exe`
- `sqlcmd.exe` - Added in PowerShell 7.3.1
- ending with `.bat`
- ending with `.cmd`
- ending with `.js`
- ending with `.vbs`
- ending with `.wsf`

If the `$PSNativeCommandArgumentPassing` is set to either `Legacy` or `Standard`, the parser doesn't
check for these files.

The default behavior is platform specific. On Windows platforms, the default setting is `Windows`
and non-Windows platforms is `Standard`.

> [!NOTE]
> The following examples use the `TestExe.exe` tool. You can build `TestExe` from the source code.
> See [TestExe][26] in the PowerShell source repository.

New behaviors made available by this change:

- Literal or expandable strings with embedded quotes the quotes are preserved:

  ```powershell
  PS> $a = 'a" "b'
  PS> TestExe -echoargs $a 'c" "d' e" "f
  Arg 0 is <a" "b>
  Arg 1 is <c" "d>
  Arg 2 is <e f>
  ```

- Empty strings as arguments are preserved:

  ```powershell
  PS> TestExe -echoargs '' a b ''
  Arg 0 is <>
  Arg 1 is <a>
  Arg 2 is <b>
  Arg 3 is <>
  ```

For more examples of the new behavior, see [about_Parsing][07].

PowerShell 7.3 also added the ability to trace parameter binding for native commands. For more
information, see [Trace-Command][32].

### PSNativeCommandErrorActionPreference

<!-- Keep this until 7.4.1 then remove since it's already in the mainstream docs -->

> [!NOTE]
> This feature became mainstream in PowerShell 7.4.

Native commands usually return an exit code to the calling application that's zero for success or
non-zero for failure. However, native commands currently don't participate in the PowerShell error
stream. Redirected **stderr** output isn't interpreted the same as the PowerShell error stream. Many
native commands use stderr as an information or verbose stream, thus only the exit code matters.
Users working with native commands in their scripts need to check the exit status after each call
using similar to the following example:

```powershell
if ($LASTEXITCODE -ne 0) {
    throw "Command failed. See above errors for details"
}
```

However, this example doesn't support all cases where `$?` can be false from a cmdlet or function
error, making `$LASTEXITCODE` stale.

This feature implements the `$PSNativeCommandUseErrorActionPreference` preference variable that
controls how native commands errors are handled in PowerShell. This allows native command failures
to produce error objects that are added to the PowerShell error stream and may terminate execution
of the script without extra handling.

`$PSNativeCommandUseErrorActionPreference` is set to `$true` by default. With the preference set to
`$true` you get the following behavior:

- When `$ErrorActionPreference = 'Stop'`, scripts will break when a native command returns a
  non-zero exit code.
- When `$ErrorActionPreference = 'Continue'` (the default), you will see PowerShell error messages
  for native command errors, but scripts won't break.

### PSNativePSPathResolution

> [!NOTE]
> This experimental feature was removed in PowerShell 7.3 and is no longer supported.

If a PSDrive path that uses the FileSystem provider is passed to a native command, the resolved file
path is passed to the native command. This means a command like `code temp:/test.txt` now works as
expected.

Also, on Windows, if the path starts with `~`, that's resolved to the full path and passed to the
native command. In both cases, the path is normalized to the directory separators for the relevant
operating system.

- If the path isn't a PSDrive or `~` (on Windows), then path normalization doesn't occur
- If the path is in single quotes, then it's not resolved and treated as literal

### PSSubsystemPluginModel

This feature enables the subsystem plugin model in PowerShell. The feature makes it possible to
separate components of `System.Management.Automation.dll` into individual subsystems that reside in
their own assembly. This separation reduces the disk footprint of the core PowerShell engine and
allows these components to become optional features for a minimal PowerShell installation.

Currently, only the **CommandPredictor** subsystem is supported. This subsystem is used along with
the PSReadLine module to provide custom prediction plugins. In future, **Job**,
**CommandCompleter**, **Remoting** and other components could be separated into subsystem assemblies
outside of `System.Management.Automation.dll`.

The experimental feature includes a new cmdlet, [Get-PSSubsystem][30]. This cmdlet is only available
when the feature is enabled. This cmdlet returns information about the subsystems that are available
on the system.

### PSNativeWindowsTildeExpansion

When this feature is enabled, PowerShell expands unquoted tilde (`~`) to the user's current home
folder before invoking native commands. The following examples show how the feature works.

With the feature disabled, the tilde is passed to the native command as a literal string.

```powershell
PS> cmd.exe /c echo ~
~
```

With the feature enabled, PowerShell expands the tilde before it's passed to the native command.

```powershell
PS> cmd.exe /c echo ~
C:\Users\username
```

This feature only applies to Windows. On non-Windows platforms, tilde expansion is handled natively.

This feature was added in PowerShell 7.5-preview.2.

<!-- link references -->
[01]: https://learn.microsoft.com/en-us/powershell/media/shared/check-mark-button-2705.svg
[02]: https://learn.microsoft.com/en-us/powershell/media/shared/construction-sign-1f6a7.svg
[03]: https://learn.microsoft.com/en-us/powershell/media/shared/cross-mark-274c.svg
[04]: https://learn.microsoft.com/powershell/dsc/overview?view=dsc-3.0&preserve-view=true
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_automatic_variables
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_experimental_features
[07]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing
[08]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing#the-stop-parsing-token
[09]: #psansirenderingfileinfo
[10]: #pscommandnotfoundsuggestion
[11]: #pscommandwithargs
[14]: #psdesiredstateconfigurationinvokedscresource
[15]: #psfeedbackprovider
[16]: #psloadassemblyfromnativecode
[17]: #psmoduleautoloadskipofflinefiles
[18]: #psnativecommandargumentpassing
[19]: #psnativecommanderroractionpreference
[21]: #psnativepspathresolution
[22]: #psnativewindowstildeexpansion
[23]: #pssubsystempluginmodel
[25]: https://github.com/PowerShell/PowerShell/issues/new/choose
[26]: https://github.com/PowerShell/PowerShell/tree/master/test/tools/TestExe
[27]: xref:Microsoft.PowerShell.Core.Disable-ExperimentalFeature
[28]: xref:Microsoft.PowerShell.Core.Enable-ExperimentalFeature
[29]: xref:Microsoft.PowerShell.Core.Get-ExperimentalFeature
[30]: xref:Microsoft.PowerShell.Core.Get-PSSubsystem
[31]: xref:Microsoft.PowerShell.Management.Start-Process
[32]: xref:Microsoft.PowerShell.Utility.Trace-Command


# /./reference/learn/more-powershell-learning.md

    ---
    description: A list of resources for learning PowerShell and connecting with other PowerShell users.
    ms.date: 08/18/2022
    title: PowerShell learning resources
    ---
# PowerShell learning resources

Additional resources for learning about PowerShell.

## Learn modules

Microsoft Learn is a free, online training platform that provides interactive learning for Microsoft
products and more. Our goal is to help you become proficient on our technologies and learn more
skills with fun, guided, hands-on, interactive content that's specific to your role and goals.

- [PowerShell modules][1]

## Blogs and community

In addition to the Help available at the command line, the following resources provide more
information for users who want to run PowerShell.

- [PowerShell Team Blog][2]. The best resource for learning directly from the PowerShell product
  team.
- [PowerShell Community Blog][3] articles are scenario-driven. Written by the community, for the
  community.
- Have questions about using PowerShell? Connect with hundreds of other people who have similar
  interests in one of the many community forums listed on the [PowerShell Community][4] page.

### Microsoft Virtual Academy

The Microsoft Virtual Academy videos have been moved to Channel 9.

- [Getting Started with Microsoft PowerShell][5]
- [Advanced Tools & Scripting with PowerShell 3.0 Jump Start][6]
- [Testing PowerShell with Pester][7]
- [Getting Started with PowerShell Desired State Configuration (DSC)][8]
- [Advanced PowerShell DSC and Custom Resources][9]
- [SharePoint Automation with DSC][10]

## Resources for PowerShell Developers

The following resources provide resources to help developers create their own PowerShell modules,
functions, cmdlets, providers, and hosting applications.

- [PowerShell SDK][11]
- [PowerShell SDK API Browser][12]

<!-- link references -->
[1]: https://learn.microsoft.com/training/browse/?terms=PowerShell
[2]: https://devblogs.microsoft.com/powershell/
[3]: https://devblogs.microsoft.com/powershell-community/
[4]: https://learn.microsoft.com/powershell/scripting/community/community-support
[5]: https://learn.microsoft.com/shows/getting-started-with-microsoft-powershell/
[6]: https://learn.microsoft.com/shows/advanced-tools-and-scripting-with-powershell-3.0-jump-start/
[7]: https://learn.microsoft.com/shows/testing-powershell-with-pester/
[8]: https://learn.microsoft.com/shows/getting-started-with-powershell-dsc/
[9]: https://learn.microsoft.com/shows/advanced-powershell-dsc-and-custom-resources/
[10]: https://learn.microsoft.com/shows/sharepoint-automation-with-dsc/
[11]: https://learn.microsoft.com/powershell/scripting/developer/windows-powershell
[12]: https://learn.microsoft.com/dotnet/api/system.management.automation

# /./reference/learn/glossary.md

    ---
    description: A glossary of PowerShell-related terminology.
    ms.date: 01/19/2024
    title: PowerShell Glossary
    ms.custom: template-glossary-pattern
    ---
# PowerShell Glossary

This article lists common terms used to talk about PowerShell.

## B

### binary module

A PowerShell module whose root module is a binary (`.dll`) file. A binary module may or may not
include a module manifest.

## C

### CommonParameter

A parameter that's added to all cmdlets, advanced functions, and workflows by the PowerShell engine.

## D

### dot source

In PowerShell, to start a command by typing a dot and a space before the command. Commands that are
dot sourced run in the current scope instead of in a new scope. Any variables, aliases, functions,
or drives that command creates are created in the current scope and are available to users when the
command is completed.

### dynamic module

A module that exists only in memory. The `New-Module` and `Import-PSSession` cmdlets create dynamic
modules.

### dynamic parameter

A parameter that's added to a PowerShell cmdlet, function, or script under certain conditions.
Cmdlets, functions, providers, and scripts can add dynamic parameters.

## F

### format file

A PowerShell XML file that has the `.format.ps1xml` extension and that defines how PowerShell
displays an object based on its .NET Framework type.

## G

### global session state

The session state that contains the data that's accessible to the user of a PowerShell session.

## H

### Host

The interface that the PowerShell engine uses to communicate with the user. For example, the host
specifies how prompts are handled between PowerShell and the user.

### host application

A program that loads the PowerShell engine into its process and uses it to perform operations.

## I

### input processing method

A method that a cmdlet can use to process the records it receives as input. The input processing
methods include the `BeginProcessing` method, the `ProcessRecord` method, the `EndProcessing`
method, and the `StopProcessing` method.

## M

### manifest module

A PowerShell module that has a manifest and whose **RootModule** key is empty.

### member-access enumeration

A PowerShell convenience feature to automatically enumerate items in a collection when using the
member-access operator (`.`).

### module

A self-contained reusable unit that allows you to partition, organize, and abstract your PowerShell
code. A module can contain cmdlets, providers, functions, variables, and other types of resources
that can be imported as a single unit.

### module manifest

A PowerShell data file (`.psd1`) that describes the contents of a module and that controls how a
module is processed.

### module session state

The session state that contains the public and private data of a PowerShell module. The private data
in this session state isn't available to the user of a PowerShell session.

## N

### non-terminating error

An error that doesn't stop PowerShell from continuing to process the command. See also,
[terminating error][03].

### noun

The word that follows the hyphen in a PowerShell cmdlet name. The noun describes the resources upon
which the cmdlet acts.

## P

### parameter set

A group of parameters that can be used in the same command to perform a specific action.

### pipe

In PowerShell, to send the results of the preceding command as input to the next command in the
pipeline.

### pipeline

A series of commands connected by pipeline operators (`|`). Each pipeline operator sends the results
of the preceding command as input to the next command.

### PowerShell cmdlet

A single command that participates in the pipeline semantics of PowerShell. This includes binary
(C#) cmdlets, advanced script functions, CDXML, and Workflows.

### PowerShell command

The elements in a pipeline that cause an action to be carried out. PowerShell commands are either
typed at the keyboard or invoked programmatically.

### PowerShell data file

A text file that has the `.psd1` file extension. PowerShell uses data files for various purposes
such as storing module manifest data and storing translated strings for script internationalization.

### PowerShell drive

A virtual drive that provides direct access to a data store. It can be defined by a PowerShell
provider or created at the command line. Drives created at the command line are session-specific
drives and are lost when the session is closed.

### provider

A Microsoft .NET Framework-based program that makes the data in a specialized data store available
in PowerShell so that you can view and manage it.

### PSSession

A type of PowerShell session that's created, managed, and closed by the user.

## R

### root module

The module specified in the **RootModule** key in a module manifest.

### runspace

In PowerShell, the operating environment in which each command in a pipeline is executed.

## S

### scalar value

In PowerShell, a scalar value is any value type that is not enumerable. This includes the .NET
primitive types, such as boolens and numbers, and other value types such as **String**, **DateTime**
and **Guid**.

For a list of .NET primitive types, see the _Remarks_ section of
[System.Type.IsPrimitive Property][01].

### script block

In the PowerShell programming language, a collection of statements or expressions that can be used
as a single unit. A script block can accept arguments and return values.

### script file

A file that has the `.ps1` extension and contains a script written in the PowerShell language.

### script module

A PowerShell module whose root module is a script module (`.psm1`) file. A script module may include
a module manifest. The script defines the members that the script module exports.

### shell

The command interpreter that's used to pass commands to the operating system.

### switch parameter

A parameter that doesn't take an argument. The value of a switch parameter defaults to `$false`.
When a switch parameter is used, its value becomes `$true`.

## T

### terminating error

An error that stops PowerShell from processing the command. See also, [non-terminating error][02].

### transaction

An atomic unit of work. The work in a transaction must be completed as a whole. If any part of the
transaction fails, the entire transaction fails.

### type file

A PowerShell XML file that has the `.types.ps1xml` extension and that extends the properties of Microsoft
.NET Framework types in PowerShell.

## V

### verb

The word that precedes the hyphen in a PowerShell cmdlet name. The verb describes the action that
the cmdlet performs.

## W

### Windows PowerShell ISE

The Integrated Scripting Environment (ISE) - A Windows PowerShell host application that enables you
to run commands and to write, test, and debug scripts in a friendly, syntax-colored,
Unicode-compliant environment.

### Windows PowerShell snap-in

A resource that defines a set of cmdlets, providers, and Microsoft .NET Framework types that can be
added to the Windows PowerShell environment. PowerShell snap-ins have been replaced by modules.

### Windows PowerShell Workflow

A workflow is a sequence of programmed, connected steps that perform long-running tasks or require
the coordination of multiple steps across multiple devices or managed nodes. Windows PowerShell
Workflow lets IT pros and developers author sequences of multi-device management activities, or
single tasks within a workflow, as workflows. Windows PowerShell Workflow lets you adapt and run
both PowerShell scripts and XAML files as workflows. Windows PowerShell Workflow is built on the
Windows Workflow Foundation, which has been deprecated.

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.type.isprimitive#remarks
[02]: #non-terminating-error
[03]: #terminating-error

# /./reference/whats-new/what-s-new-in-powershell-75.md

    ---
    title: What's New in PowerShell 7.5
    description: New features and changes released in PowerShell 7.5
    ms.date: 02/23/2024
    ---

# What's New in PowerShell 7.5

PowerShell 7.5-preview.2 includes the following features, updates, and breaking changes. PowerShell
7.5 is built on .NET 9.0.0-preview.1.

For a complete list of changes, see the [CHANGELOG][chg] in the GitHub repository.

## Breaking Changes

- Fix `-OlderThan` and `-NewerThan` parameters for `Test-Path` when using `PathType` and date range
  ([#20942][20942]) (Thanks @ArmaanMcleod!)
  - Previously `-OlderThan` would be ignored if specified together
- Change `New-FileCatalog -CatalogVersion` default to 2 ([#20428][20428]) (Thanks @ThomasNieto!)
- Block getting help from network locations in restricted remoting sessions ([#20593][20593])

## Tab completion improvements

Many thanks to **@ArmaanMcleod** and others for all their work to improve tab completion.

- Prevent fallback to file completion when tab completing type names ([#20084][20084]) (Thanks
  @MartinGC94)
- Add argument completer to `-Version` for `Set-StrictMode` ([#20554][20554]) (Thanks
  @ArmaanMcleod!)
- Add `-Verb` argument completer for `Get-Verb`/ `Get-Command` and refactor `Get-Verb`
  ([#20286][20286]) (Thanks @ArmaanMcleod)
- Add `-Verb` argument completer for `Start-Process` ([#20415][20415]) (Thanks @ArmaanMcleod)
- Add `-Scope` argument completer for `*-Variable`, `*-Alias` & `*-PSDrive` commands
  ([#20451][20451]) (Thanks @ArmaanMcleod)
- Add `-Module` completion for `Save-Help`/`Update-Help` commands ([#20678][20678]) (Thanks
  @ArmaanMcleod)

## Web Cmdlets improvements

- Fix `Invoke-WebRequest` to report correct size when `-Resume` is specified ([#20207][20207])
  (Thanks @LNKLEO!)
- Fix Web Cmdlets to allow `WinForm` apps to work correctly ([#20606][20606])

## Other cmdlet improvements

- Fix `Test-Connection` due to .NET 8 changes ([#20369][20369])
- Fix `Get-Service` non-terminating error message to include category ([#20276][20276])
- Add `-Empty` and `-InputObject` parameters to `New-Guid` ([#20014][20014]) (Thanks @CarloToso!)
- Add the alias `r` to the parameter `-Recurse` for the `Get-ChildItem` command ([#20100][20100])
  (Thanks @kilasuit!)
- Add `LP` to `LiteralPath` aliases for functions still missing it ([#20820][20820])
- Add implicit localization fallback to `Import-LocalizedData` ([#19896][19896]) (Thanks
  @chrisdent-de!)
- Add `Aliases` to the properties shown up when formatting the help content of the parameter
  returned by `Get-Help` ([#20994][20994])
- Add `HelpUri` to `Remove-Service` ([#20476][20476])
- Fix completion crash for the SCCM provider (#20815, #20919, #20915) (Thanks @MartinGC94!)
- Fix regression in `Get-Content` when `-Tail 0` and `-Wait` are used together ([#20734][20734])
  (Thanks @CarloToso!)
- Fix `Start-Process -PassThru` to make sure the `ExitCode` property is accessible for the returned
  `Process` object ([#20749][20749]) (Thanks @CodeCyclone!)
- Fix `Group-Object` to use current culture for its output ([#20608][20608])
- Fix `Group-Object` output using interpolated strings ([#20745][20745]) (Thanks @mawosoft!)
- Fix rendering of `DisplayRoot` for network `PSDrive` ([#20793][20793])
- Fix `Copy-Item` progress to only show completed when all files are copied ([#20517][20517])
- Fix UNC path completion regression ([#20419][20419]) (Thanks @MartinGC94!)
- Report error if invalid `-ExecutionPolicy` is passed to `pwsh` ([#20460][20460])
- Add **WinGetCommandNotFound** and **CompletionPredictor** modules to track usage ([#21040][21040])
- Add **DateKind** parameter to `ConvertFrom-Json` ([#20925][20925]) (Thanks @jborean93!)
- Add **DirectoryInfo** to the OutputType for New-Item ([#21126][21126]) (Thanks @MartinGC94!)
- Fix 1 serialization of array values ([#21085][21085]) (Thanks @jborean93!)

## Engine improvements

- Add telemetry to check for specific tags when importing a module ([#20371][20371])
- Add `PSAdapter` and `ConsoleGuiTools` to module load telemetry allowlist ([#20641][20641])
- Add Winget module to track usage ([#21040][21040])
- Ensure the filename is not null when logging WDAC ETW events ([#20910][20910]) (Thanks
  @jborean93!)
- Fix four regressions introduced by the WDAC logging feature ([#20913][20913])
- Leave the input, output, and error handles unset when they are not redirected ([#20853][20853])
- Fix implicit remoting proxy cmdlets to act on common parameters ([#20367][20367])
- Include the module version in error messages when module is not found ([#20144][20144]) (Thanks
  @ArmaanMcleod!)
- Fix `unixmode` to handle `setuid` and `sticky` when file is not an executable ([#20366][20366])
- Fix using assembly to use Path.Combine when constructing assembly paths ([#21169][21169])
- Validate the value for using namespace during semantic checks to prevent declaring invalid
  namespaces ([#21162][21162])

## Experimental features

- Add tilde expansion for windows native executables ([#20402][20402]) (Thanks @domsleee!)
  For more information, see [PSNativeWindowsTildeExpansion][01]

<!-- end of content -->
<!-- reference links -->
[chg]: https://github.com/PowerShell/PowerShell/blob/master/CHANGELOG/preview.md

[01]: ../learn/experimental-features.md#psnativewindowstildeexpansion

[19896]: https://github.com/PowerShell/PowerShell/pull/19896
[20014]: https://github.com/PowerShell/PowerShell/pull/20014
[20084]: https://github.com/PowerShell/PowerShell/pull/20084
[20100]: https://github.com/PowerShell/PowerShell/pull/20100
[20144]: https://github.com/PowerShell/PowerShell/pull/20144
[20207]: https://github.com/PowerShell/PowerShell/pull/20207
[20276]: https://github.com/PowerShell/PowerShell/pull/20276
[20286]: https://github.com/PowerShell/PowerShell/pull/20286
[20366]: https://github.com/PowerShell/PowerShell/pull/20366
[20367]: https://github.com/PowerShell/PowerShell/pull/20367
[20369]: https://github.com/PowerShell/PowerShell/pull/20369
[20371]: https://github.com/PowerShell/PowerShell/pull/20371
[20415]: https://github.com/PowerShell/PowerShell/pull/20415
[20419]: https://github.com/PowerShell/PowerShell/pull/20419
[20428]: https://github.com/PowerShell/PowerShell/pull/20428
[20451]: https://github.com/PowerShell/PowerShell/pull/20451
[20460]: https://github.com/PowerShell/PowerShell/pull/20460
[20476]: https://github.com/PowerShell/PowerShell/pull/20476
[20517]: https://github.com/PowerShell/PowerShell/pull/20517
[20554]: https://github.com/PowerShell/PowerShell/pull/20554
[20593]: https://github.com/PowerShell/PowerShell/pull/20593
[20606]: https://github.com/PowerShell/PowerShell/pull/20606
[20608]: https://github.com/PowerShell/PowerShell/pull/20608
[20641]: https://github.com/PowerShell/PowerShell/pull/20641
[20678]: https://github.com/PowerShell/PowerShell/pull/20678
[20734]: https://github.com/PowerShell/PowerShell/pull/20734
[20745]: https://github.com/PowerShell/PowerShell/pull/20745
[20749]: https://github.com/PowerShell/PowerShell/pull/20749
[20793]: https://github.com/PowerShell/PowerShell/pull/20793
[20820]: https://github.com/PowerShell/PowerShell/pull/20820
[20853]: https://github.com/PowerShell/PowerShell/pull/20853
[20910]: https://github.com/PowerShell/PowerShell/pull/20910
[20913]: https://github.com/PowerShell/PowerShell/pull/20913
[20942]: https://github.com/PowerShell/PowerShell/pull/20942
[20994]: https://github.com/PowerShell/PowerShell/pull/20994
[20402]: https://github.com/PowerShell/PowerShell/pull/20402
[20925]: https://github.com/PowerShell/PowerShell/pull/20925
[21040]: https://github.com/PowerShell/PowerShell/pull/21040
[21085]: https://github.com/PowerShell/PowerShell/pull/21085
[21126]: https://github.com/PowerShell/PowerShell/pull/21126
[21162]: https://github.com/PowerShell/PowerShell/pull/21162
[21169]: https://github.com/PowerShell/PowerShell/pull/21169

# /./reference/whats-new/what-s-new-in-powershell-74.md

    ---
    title: What's New in PowerShell 7.4
    description: New features and changes released in PowerShell 7.4
    ms.date: 02/07/2024
    ---

# What's New in PowerShell 7.4

PowerShell 7.4 includes the following features, updates, and breaking changes. PowerShell 7.4 is
built on .NET 8.0.0.

For a complete list of changes, see the [CHANGELOG][chg] in the GitHub repository.

## Breaking changes

- Nano server docker images aren't available for this release
- Added the **ProgressAction** parameter to the Common Parameters
- Update some PowerShell APIs to throw **ArgumentException** instead of **ArgumentNullException**
  when the argument is an empty string ([#19215][19215]) (Thanks @xtqqczze!)
- Remove code related to `#requires -pssnapin` ([#19320][19320])
- `Test-Json` now uses JsonSchema.Net instead of Newtonsoft.Json.Schema. With this change,
  `Test-Json` no longer supports the older Draft 4 schemas. ([#18141][18141]) (Thanks @gregsdennis!)
  For more information about JSON schemas, see [JSON Schema][14] documentation.
- Output from `Test-Connection` now includes more detailed information about TCP connection tests
- .NET introduced changes that affected `Test-Connection`. The cmdlet now returns an error about
  the need to use `sudo` on Linux platforms when using a custom buffer size ([#20369][20369])
- Experimental feature [PSNativeCommandPreserveBytePipe][10] is now mainstream. PowerShell now
  preserves the byte-stream data when redirecting the **stdout** stream of a native command to a
  file or when piping byte-stream data to the stdin stream of a native command.
- Change how relative paths in `Resolve-Path` are handled when using the **RelativeBasePath**
  parameter ([#19755][19755]) (Thanks @MartinGC94!)
- Remove unused PSv2 code - removes TabExpansion function ([#18337][18337])

## Installer updates

The Windows MSI package now provides an option to disable PowerShell telemetry during installation.
For more information, see [Install the msi package from the command line][01].

## Updated versions of PSResourceGet and PSReadLine

PowerShell 7.4 includes **Microsoft.PowerShell.PSResourceGet** v1.0.1. This module is installed
side-by-side with **PowerShellGet** v2.2.5 and **PackageManagement** v1.4.8.1. For more information,
see the documentation for [Microsoft.PowerShell.PSResourceGet][12].

PowerShell 7.4 now includes **PSReadLine** v2.3.4. For more information, see the documentation for
[PSReadLine][13].

## Tab completion improvements

Many thanks to **@MartinGC94** and others for all their work to improve tab completion.

- Fix issue when completing the first command in a script with an empty array expression
  ([#18355][18355])
- Fix positional argument completion ([#17796][17796])
- Prioritize the default parameter set when completing positional arguments ([#18755][18755])
- Improve pseudo binding for dynamic parameters ([#18030][18030])
- Improve type inference of hashtable keys ([#17907][17907])
- Fix type inference error for empty return statements ([#18351][18351])
- Improve type inference for Get-Random ([#18972][18972])
- Fix type inference for all scope variables ([#18758][18758])
- Improve enumeration of inferred types in pipeline ([#17799][17799])
- Add completion for values in comparisons when comparing Enums ([#17654][17654])
- Add property assignment completion for enums ([#19178][19178])
- Fix completion for PSCustomObject variable properties ([#18682][18682])
- Fix member completion in attribute argument ([#17902][17902])
- Exclude redundant parameter aliases from completion results ([#19382][19382])
- Fix class member completion for classes with base types ([#19179][19179])
- Add completion for Using keywords ([#16514][18758])
- Fix TabExpansion2 variable leak when completing variables ([#18763][18763])
- Enable completion of variables across ScriptBlock scopes ([#19819][19819])
- Fix completion of the foreach statement variable ([#19814][19814])
- Fix variable type inference precedence ([#18691][18691])
- Fix member completion for PowerShell Enum class ([#19740][19740])
- Fix parsing for array literals in index expressions in method calls ([#19224][19224])
- Improve path completion ([#19489][19489])
- Fix an indexing out of bound error in CompleteInput for empty script input ([#19501][19501])
- Improve variable completion performance ([#19595][19595])
- Improve Hashtable key completion for type constrained variable assignments, nested Hashtables and
  more ([#17660][17660])
- Infer external application output as strings ([#19193][19193])
- Update parameter completion for enums to exclude values not allowed by `ValidateRange` attributes
  ([#17750][17750]) (Thanks @fflaten!).
- Fix dynamic parameter completion ([#19510][19510])
- Add completion for variables assigned by the Data statement ([#19831][19831])

## Web cmdlet improvements

Many thanks to **@CarloToso** and others for all the work on improving web cmdlets.

- Fix decompression in web cmdlets to include Brotli ([#17955][17955]) (Thanks @iSazonov!)
- Webcmdlets add 308 to redirect codes and small cleanup ([#18536][18536])
- Complete the progress bar rendering in Invoke-WebRequest when downloading is complete or cancelled
  ([#18130][18130])
- Web cmdlets get **Retry-After** interval from response headers if the status code is 429
  ([#18717][18717])
- Web cmdlets set default charset encoding to UTF8 ([#18219][18219])
- Preserve WebSession.MaximumRedirection from changes ([#19190][19190])
- WebCmdlets parse XML declaration to get encoding value, if present. ([#18748][18748])
- Fix using xml -Body in webcmdlets without an encoding ([#19281][19281])
- Adjust PUT method behavior to POST one for default content type in WebCmdlets ([#19152][19152])
- Take into account ContentType from Headers in WebCmdlets ([#19227][19227])
- Allow to preserve the original HTTP method by adding **-PreserveHttpMethodOnRedirect** to Web
  cmdlets ([#18894][18894])
- Webcmdlets display an error on https to http redirect ([#18595][18595])
- Add **AllowInsecureRedirect** switch to Web cmdlets ([#18546][18546])
- Improve verbose message in web cmdlets when content length is unknown ([#19252][19252])
- Build the relative URI for links from the response in `Invoke-WebRequest` ([#19092][19092])
- Fix redirection for `-CustomMethod POST` in WebCmdlets ([#19111][19111])
- Dispose previous response in Webcmdlets ([#19117][19117])
- Improve `Invoke-WebRequest` xml and json errors format ([#18837][18837])
- Add ValidateNotNullOrEmpty to **OutFile** and **InFile** parameters of WebCmdlets
  ([#19044][19044])
- HttpKnownHeaderNames update headers list ([#18947][18947])
- `Invoke-RestMethod -FollowRelLink` fix links containing commas ([#18829][18829])
- Fix bug with managing redirection and KeepAuthorization in Web cmdlets ([#18902][18902])
- Add **StatusCode** to **HttpResponseException** ([#18842][18842])
- Support HTTP persistent connections in Web Cmdlets ([#19249][19249]) (Thanks @stevenebutler!)
- Small cleanup `Invoke-RestMethod` ([#19490][19490])
- Improve the verbose message of WebCmdlets to show correct HTTP version ([#19616][19616])
- Add **FileNameStar** to **MultipartFileContent** in WebCmdlets ([#19467][19467])
- Fix HTTP status from 409 to 429 for WebCmdlets to get retry interval from Retry-After header.
  ([#19622][19622]) (Thanks @mkht!)
- Change `-TimeoutSec` to `-ConnectionTimeoutSeconds` and add `-OperationTimeoutSeconds` to web
  cmdlets ([#19558][19558]) (Thanks @stevenebutler!) Other cmdlets
- Support Ctrl+c when connection hangs while reading data in WebCmdlets ([#19330][19330]) (Thanks
  @stevenebutler!)
- Support Unix domain socket in WebCmdlets ([#19343][19343])

## Other cmdlet improvements

- `Test-Connection` now returns error about the need to use `sudo` on Linux platforms when using a
  custom buffer size ([#20369][20369])
- Add output types to Format commands ([#18746][18746]) (Thanks @MartinGC94!)
- Add output type attributes for `Get-WinEvent` ([#17948][17948]) (Thanks @MartinGC94!)
- Add **Path** and **LiteralPath** parameters to `Test-Json` cmdlet ([#19042][19042]) (Thanks
  @ArmaanMcleod!)
- Add **NoHeader** parameter to `ConvertTo-Csv` and `Export-Csv` cmdlets ([#19108][19108]) (Thanks
  @ArmaanMcleod!)
- Add **Confirm** and **WhatIf** parameters to `Stop-Transcript`([#18731][18731]) (Thanks
  @JohnLBevan!)
- Add **FuzzyMinimumDistance** parameter to `Get-Command` ([#18261][18261])
- Make **Encoding** parameter able to take `ANSI` encoding in PowerShell ([#19298][19298]) (Thanks
  @CarloToso!)
- Add progress to `Copy-Item` ([#18735][18735])
- `Update-Help` now reports an error when using implicit culture on non-US systems.
  ([#17780][17780]) (Thanks @dkaszews!)
- Don't require activity when creating a completed progress record ([#18474][18474]) (Thanks
  @MartinGC94!)
- Disallow negative values for `Get-Content` cmdlet parameters `-Head` and `-Tail`
  ([#19715][19715]) (Thanks @CarloToso!)
- Make `Update-Help` throw proper error when current culture isn't associated with a language
  ([#19765][19765]) (Thanks @josea!)
- Allow combining of `-Skip` and `-SkipLast` parameters in `Select-Object` cmdlet.
  ([#18849][18849]) (Thanks @ArmaanMcleod!)
- Add `Get-SecureRandom` cmdlet ([#19587][19587])
- `Set-Clipboard -AsOSC52` for remote usage ([#18222][18222]) (Thanks @dkaszews!)
- Speed up `Resolve-Path` relative path resolution ([#19171][19171]) (Thanks @MartinGC94!)
- Added the switch parameter `-CaseInsensitive` to `Select-Object` and `Get-Unique` cmdlets
  ([#19683][19683]) (Thanks @ArmaanMcleod!)
- `Restart-Computer` and `Stop-Computer` should fail with error when not running via sudo on Unix
  ([#19824][19824])

## Engine improvements

Updates to `$PSStyle`

- Adds **Dim** and **DimOff** properties ([#18653][18653])
- Added static methods to the **PSStyle** class that map foreground and background **ConsoleColor**
  values to ANSI escape sequences ([#17938][17938])
- Table headers for calculated fields are formatted in italics by default
- Add support of respecting `$PSStyle.OutputRendering` on the remote host ([#19601][19601])
- Updated telemetry data to include use of `CrescendoBuilt` modules ([#20371][20371])

Other Engine updates

- Make PowerShell class not affiliate with Runspace when declaring the `NoRunspaceAffinity`
  attribute ([#18138][18138])
- Add the `ValidateNotNullOrWhiteSpace` attribute ([#17191][17191]) (Thanks @wmentha!)
- Add `sqlcmd` to the list for legacy argument passing ([#18559][18559])
- Add the function `cd~` ([#18308][18308]) (Thanks @GigaScratch!)
- Fix array type parsing in generic types ([#19205][19205]) (Thanks @MartinGC94!)
- Fix wildcard globbing in root of device paths ([#19442][19442]) (Thanks @MartinGC94!)
- Add a public API for getting locations of PSModulePath elements ([#19422][19422])
- Fix incorrect string to type conversion ([#19560][19560]) (Thanks @MartinGC94!)
- Fix slow execution when many breakpoints are used ([#14953][14953]) (Thanks @nohwnd!)
- Remove code related to `#requires -pssnapin` ([#19320][19320])

## Experimental Features

PowerShell 7.4 introduces the following experimental features:

- [PSFeedbackProvider][06] - Replaces the hard-coded suggestion framework with an extensible
  feedback provider.
  - This feature also adds the **FeedbackName**, **FeedbackText**, and **FeedbackAction** properties
    to `$PSStyle.Formatting` that allow you to change the formatting of feedback messages.
- [PSModuleAutoLoadSkipOfflineFiles][07] - Module discovery now skips over files that are marked by
  cloud providers as not fully on disk.
- [PSCommandWithArgs][05] - Add support for passing arguments to commands as a single string

The following experimental features became mainstream:

- [PSConstrainedAuditLogging][02]
- [PSCustomTableHeaderLabelDecoration][08]
- [PSNativeCommandErrorActionPreference][10]
- [PSNativeCommandPreserveBytePipe][11]
- [PSWindowsNativeCommandArgPassing][09]

PowerShell 7.4 changed the following experimental features:

- [PSCommandNotFoundSuggestion][04] - This feature now uses an extensible feedback provider rather
  than hard-coded suggestions ([#18726][18726])

For more information about the Experimental Features, see [Using Experimental Features][03].

<!-- end of content -->
<!-- reference links -->
[01]: ../install/installing-powershell-on-windows.md
[02]: ../security/application-control.md#wdac-policy-auditing
[03]: ../learn/experimental-features.md
[04]: ../learn/experimental-features.md#pscommandnotfoundsuggestion
[05]: ../learn/experimental-features.md#pscommandwithargs
[06]: ../learn/experimental-features.md#psfeedbackprovider
[07]: ../learn/experimental-features.md#psmoduleautoloadskipofflinefiles
[08]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_ansi_terminals
[09]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_preference_variables#psnativecommandargumentpassing
[10]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_preference_variables#psnativecommanduseerroractionpreference
[11]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_redirection?view=powershell-7.4&preserve-view=true#redirecting-output-from-native-commands
[12]: https://learn.microsoft.com/powershell/module/microsoft.powershell.psresourceget
[13]: https://learn.microsoft.com/powershell/module/psreadline
[14]: https://json-schema.org/understanding-json-schema/reference/schema

[chg]: https://github.com/PowerShell/PowerShell/blob/master/CHANGELOG/7.4.md
[14953]: https://github.com/PowerShell/PowerShell/pull/14953
[17191]: https://github.com/PowerShell/PowerShell/pull/17191
[17654]: https://github.com/PowerShell/PowerShell/pull/17654
[17660]: https://github.com/PowerShell/PowerShell/pull/17660
[17750]: https://github.com/PowerShell/PowerShell/pull/17750
[17780]: https://github.com/PowerShell/PowerShell/pull/17780
[17796]: https://github.com/PowerShell/PowerShell/pull/17796
[17799]: https://github.com/PowerShell/PowerShell/pull/17799
[17902]: https://github.com/PowerShell/PowerShell/pull/17902
[17907]: https://github.com/PowerShell/PowerShell/pull/17907
[17938]: https://github.com/PowerShell/PowerShell/pull/17938
[17948]: https://github.com/PowerShell/PowerShell/pull/17948
[17955]: https://github.com/PowerShell/PowerShell/pull/17955
[18030]: https://github.com/PowerShell/PowerShell/pull/18030
[18130]: https://github.com/PowerShell/PowerShell/pull/18130
[18138]: https://github.com/PowerShell/PowerShell/pull/18138
[18141]: https://github.com/PowerShell/PowerShell/pull/18141
[18219]: https://github.com/PowerShell/PowerShell/pull/18219
[18222]: https://github.com/PowerShell/PowerShell/pull/18222
[18261]: https://github.com/PowerShell/PowerShell/pull/18261
[18308]: https://github.com/PowerShell/PowerShell/pull/18308
[18337]: https://github.com/PowerShell/PowerShell/pull/18337
[18351]: https://github.com/PowerShell/PowerShell/pull/18351
[18355]: https://github.com/PowerShell/PowerShell/pull/18355
[18474]: https://github.com/PowerShell/PowerShell/pull/18474
[18536]: https://github.com/PowerShell/PowerShell/pull/18536
[18546]: https://github.com/PowerShell/PowerShell/pull/18546
[18559]: https://github.com/PowerShell/PowerShell/pull/18559
[18595]: https://github.com/PowerShell/PowerShell/pull/18595
[18653]: https://github.com/PowerShell/PowerShell/pull/18653
[18682]: https://github.com/PowerShell/PowerShell/pull/18682
[18691]: https://github.com/PowerShell/PowerShell/pull/18691
[18695]: https://github.com/PowerShell/PowerShell/pull/18695
[18717]: https://github.com/PowerShell/PowerShell/pull/18717
[18726]: https://github.com/PowerShell/PowerShell/pull/18726
[18731]: https://github.com/PowerShell/PowerShell/pull/18731
[18735]: https://github.com/PowerShell/PowerShell/pull/18735
[18746]: https://github.com/PowerShell/PowerShell/pull/18746
[18748]: https://github.com/PowerShell/PowerShell/pull/18748
[18755]: https://github.com/PowerShell/PowerShell/pull/18755
[18758]: https://github.com/PowerShell/PowerShell/pull/18758
[18763]: https://github.com/PowerShell/PowerShell/pull/18763
[18829]: https://github.com/PowerShell/PowerShell/pull/18829
[18837]: https://github.com/PowerShell/PowerShell/pull/18837
[18842]: https://github.com/PowerShell/PowerShell/pull/18842
[18849]: https://github.com/PowerShell/PowerShell/pull/18849
[18894]: https://github.com/PowerShell/PowerShell/pull/18894
[18902]: https://github.com/PowerShell/PowerShell/pull/18902
[18947]: https://github.com/PowerShell/PowerShell/pull/18947
[18972]: https://github.com/PowerShell/PowerShell/pull/18972
[19042]: https://github.com/PowerShell/PowerShell/pull/19042
[19044]: https://github.com/PowerShell/PowerShell/pull/19044
[19092]: https://github.com/PowerShell/PowerShell/pull/19092
[19108]: https://github.com/PowerShell/PowerShell/pull/19108
[19111]: https://github.com/PowerShell/PowerShell/pull/19111
[19117]: https://github.com/PowerShell/PowerShell/pull/19117
[19152]: https://github.com/PowerShell/PowerShell/pull/19152
[19171]: https://github.com/PowerShell/PowerShell/pull/19171
[19178]: https://github.com/PowerShell/PowerShell/pull/19178
[19179]: https://github.com/PowerShell/PowerShell/pull/19179
[19190]: https://github.com/PowerShell/PowerShell/pull/19190
[19193]: https://github.com/PowerShell/PowerShell/pull/19193
[19205]: https://github.com/PowerShell/PowerShell/pull/19205
[19215]: https://github.com/PowerShell/PowerShell/pull/19215
[19224]: https://github.com/PowerShell/PowerShell/pull/19224
[19227]: https://github.com/PowerShell/PowerShell/pull/19227
[19249]: https://github.com/PowerShell/PowerShell/pull/19249
[19252]: https://github.com/PowerShell/PowerShell/pull/19252
[19281]: https://github.com/PowerShell/PowerShell/pull/19281
[19298]: https://github.com/PowerShell/PowerShell/pull/19298
[19320]: https://github.com/PowerShell/PowerShell/pull/19320
[19330]: https://github.com/PowerShell/PowerShell/pull/19330
[19343]: https://github.com/PowerShell/PowerShell/pull/19343
[19382]: https://github.com/PowerShell/PowerShell/pull/19382
[19422]: https://github.com/PowerShell/PowerShell/pull/19422
[19442]: https://github.com/PowerShell/PowerShell/pull/19442
[19467]: https://github.com/PowerShell/PowerShell/pull/19467
[19489]: https://github.com/PowerShell/PowerShell/pull/19489
[19490]: https://github.com/PowerShell/PowerShell/pull/19490
[19501]: https://github.com/PowerShell/PowerShell/pull/19501
[19510]: https://github.com/PowerShell/PowerShell/pull/19510
[19558]: https://github.com/PowerShell/PowerShell/pull/19558
[19560]: https://github.com/PowerShell/PowerShell/pull/19560
[19587]: https://github.com/PowerShell/PowerShell/pull/19587
[19595]: https://github.com/PowerShell/PowerShell/pull/19595
[19601]: https://github.com/PowerShell/PowerShell/pull/19601
[19616]: https://github.com/PowerShell/PowerShell/pull/19616
[19622]: https://github.com/PowerShell/PowerShell/pull/19622
[19683]: https://github.com/PowerShell/PowerShell/pull/19683
[19715]: https://github.com/PowerShell/PowerShell/pull/19715
[19740]: https://github.com/PowerShell/PowerShell/pull/19740
[19755]: https://github.com/PowerShell/PowerShell/pull/19755
[19765]: https://github.com/PowerShell/PowerShell/pull/19765
[19814]: https://github.com/PowerShell/PowerShell/pull/19814
[19819]: https://github.com/PowerShell/PowerShell/pull/19819
[19824]: https://github.com/PowerShell/PowerShell/pull/19824
[19831]: https://github.com/PowerShell/PowerShell/pull/19831
[20369]: https://github.com/PowerShell/PowerShell/pull/20369
[20371]: https://github.com/PowerShell/PowerShell/pull/20371

# /./reference/whats-new/what-s-new-in-powershell-73.md

    ---
    title: What's New in PowerShell 7.3
    description: New features and changes released in PowerShell 7.3
    ms.date: 02/27/2023
    ---

# What's New in PowerShell 7.3

PowerShell 7.3 is the next stable release, built on .NET 7.0.

PowerShell 7.3 includes the following features, updates, and breaking changes.

## Breaking Changes and Improvements

- In this release, Windows APIs were updated or removed for compliance, which means that PowerShell
  7.3 doesn't run on Windows 7. While Windows 7 is no longer supported, previous builds could run on
  Windows 7.
- PowerShell Direct for Hyper-V is only supported on Windows 10, version 1809 and higher.
- `Test-Connection` is broken due to an intentional [breaking change][09] in .NET 7. It's tracked by
  [#17018][10]
- Add `clean` block to script block as a peer to `begin`, `process`, and `end` to allow easy
  resource cleanup ([#15177][15177])
- Change default for `$PSStyle.OutputRendering` to **Host**
- Make `Out-String` and `Out-File` keep string input unchanged ([#17455][17455])
- Move the type data definition of System.Security.AccessControl.ObjectSecurity to the
  Microsoft.PowerShell.Security module ([#16355][16355]) (Thanks @iSazonov!)
  - Before this change, a user doesn't need to explicitly import the
    **Microsoft.PowerShell.Security** module to use the code properties defined for an instance of
    **System.Security.AccessControl.ObjectSecurity**.
  - After this change, a user needs to explicitly import **Microsoft.PowerShell.Security** module in
    order to use those code properties and code methods.

## Tab completion improvements

- PowerShell 7.3 includes PSReadline 2.2.6, which enables Predictive IntelliSense by default. For
  more information, see [about_PSReadLine][12].
- Fix tab completion within the script block specified for the `ValidateScriptAttribute`.
  ([#14550][14550]) (Thanks @MartinGC94!)
- Added tab completion for loop labels after `break`/`continue` ([#16438][16438]) (Thanks
  @MartinGC94!)
- Improve Hashtable completion in multiple scenarios ([#16498][16498]) (Thanks @MartinGC94!)
  - Parameter splatting
  - **Arguments** parameter for `Invoke-CimMethod`
  - **FilterHashtable** parameter for `Get-WinEvent`
  - **Property** parameter for the CIM cmdlets
  - Removes duplicates from member completion scenarios
- Support forward slashes in network share (UNC path) completion ([#17111][17111]) (Thanks @sba923!)
- Improve member autocompletion ([#16504][16504]) (Thanks @MartinGC94!)
- Prioritize ValidateSet completions over Enums for parameters ([#15257][15257]) (Thanks
  @MartinGC94!)
- Add type inference support for generic methods with type parameters ([#16951][16951]) (Thanks
  @MartinGC94!)
- Improve type inference and completions ([#16963][16963]) (Thanks @MartinGC94!)
  - Allows methods to be shown in completion results for `ForEach-Object -MemberName`
  - Prevents completion on expressions that return void like `([void](""))`
  - Allows non-default Class constructors to show up when class completion is based on the AST
- Improve type inference for `$_` ([#17716][17716]) (Thanks @MartinGC94!)
- Fix type inference for **ICollection** ([#17752][17752]) (Thanks @MartinGC94!)
- Prevent braces from being removed when completing variables ([#17751][17751]) (Thanks
  @MartinGC94!)
- Add completion for index expressions for dictionaries ([#17619][17619]) (Thanks @MartinGC94!)
- Fix type completion for attribute tokens ([#17484][17484]) (Thanks @MartinGC94!)
- Improve dynamic parameter tab completion ([#17661][17661]) (Thanks @MartinGC94!)
- Avoid binding positional parameters when completing parameter in front of value ([#17693][17693])
  (Thanks @MartinGC94!)

## Improved error handling

- Set `$?` correctly for command expression with redirections ([#16046][16046])
- Fix a casting error when using `$PSNativeCommandUseErrorActionPreference` ([#15993][15993])
- Make the native command error handling optionally honor `ErrorActionPreference` ([#15897][15897])
- Specify the executable path as `TargetObject` for non-zero exit code ErrorRecord
  ([#16108][16108]) (Thanks @rkeithhill!)

## Session and remoting improvements

- Add `-Options` to the PSRP over SSH commands to allow passing OpenSSH options directly
  ([#12802][12802]) (Thanks @BrannenGH!)
- Add `-ConfigurationFile` parameter to `pwsh` to allow starting a new process with the session
  configuration defined in a `.pssc` file ([#17447][17447])
- Add support for using `New-PSSessionConfigurationFile` on non-Windows platforms ([#17447][17447])

## Updated cmdlets

- Add `-HttpVersion` parameter to web cmdlets ([#15853][15853]) (Thanks @hayhay27!)
- Add support to web cmdlets for open-ended input tags ([#16193][16193]) (Thanks @farmerau!)
- Fix `ConvertTo-Json -Depth` to allow 100 at maximum ([#16197][16197]) (Thanks @KevRitchie!)
  @rkeithhill!)
- Improve variable handling when calling `Invoke-Command` with the `$using:` expression
  ([#16113][16113]) (Thanks @dwtaber!)
- Add `-StrictMode` to `Invoke-Command` to allow specifying strict mode when invoking command
  locally ([#16545][16545]) (Thanks @Thomas-Yu!)
- Add `clean` block to script block as a peer to `begin`, `process`, and `end` to allow easy
  resource cleanup ([#15177][15177])
- Add `-Amended` switch to `Get-CimClass` cmdlet ([#17477][17477]) (Thanks @iSazonov)
- Changed `ConvertFrom-Json -AsHashtable` to use ordered hashtable ([#17405][17405])
- Removed ANSI escape sequences in strings before sending to `Out-GridView` ([#17664][17664])
- Added the **Milliseconds** parameter to `New-TimeSpan` ([#17621][17621]) (Thanks @NoMoreFood!)
- Show optional parameters when displaying method definitions and overloads ([#13799][13799])
  (Thanks @eugenesmlv!)
- Allow commands to still be executed even if the current working directory no longer exists
  ([#17579][17579])
- Add support for HTTPS with `Set-AuthenticodeSignature -TimeStampServer` ([#16134][16134]) (Thanks
  @Ryan-Hutchison-USAF!)
- Render decimal numbers in a table using current culture ([#17650][17650])
- Add type accelerator ordered for **OrderedDictionary** ([#17804][17804]) (Thanks @fflaten!)
- Add `find.exe` to legacy argument binding behavior for Windows ([#17715][17715])
- Add `-noprofileloadtime` switch to pwsh ([#17535][17535]) (Thanks @rkeithhill!)

For a complete list of changes, see the [Change Log][11] in the GitHub repository.

## Experimental Features

In PowerShell 7.3, following experimental features became mainstream:

- `PSAnsiRenderingFileInfo` - This feature adds the `$PSStyle.FileInfo` member and enables
  coloring of specific file types.
- `PSCleanBlock` - Adds `clean` block to script block as a peer to `begin`, `process`, and `end`
  to allow easy resource cleanup.
- `PSAMSIMethodInvocationLogging` - Extends the data sent to AMSI for inspection to include all
  invocations of .NET method members.
- [PSNativeCommandArgumentPassing][08] - PowerShell now uses the **ArgumentList** property of the
  **StartProcessInfo** object rather than the old mechanism of reconstructing a string when invoking
  a native executable.

  PowerShell 7.3.1 adds `sqlcmd.exe` to the list of native commands in Windows that use the `Legacy`
  style of argument passing.
- `PSExec` - Adds the new `Switch-Process` cmdlet (alias `exec`) to provide `exec` compatibility for
  non-Windows systems.

  PowerShell 7.3.1 changed the `exec` alias to a function that wraps `Switch-Process`. The function
  allows you to pass parameters to the native command that might have erroneously bound to the
  **WithCommand** parameter.

PowerShell 7.3 introduces the following experimental features:

- [PSNativeCommandErrorActionPreference][06] - Adds the
  `$PSNativeCommandUseErrorActionPreference` variable to enable errors produced by native commands
  to be PowerShell errors.

PowerShell 7.3 removed the following experimental features:

- `PSNativePSPathResolution` experimental feature is no longer supported.
- `PSStrictModeAssignment` experimental feature is no longer supported.

For more information about the Experimental Features, see [Using Experimental Features][01].

<!-- end of content -->
<!-- reference links -->
[01]: ../learn/experimental-features.md
[06]: ../learn/experimental-features.md#psnativecommanderroractionpreference
[08]: ../learn/experimental-features.md#psnativecommandargumentpassing
[09]: https://github.com/dotnet/runtime/issues/66746
[10]: https://github.com/PowerShell/PowerShell/issues/17018
[11]: https://github.com/PowerShell/PowerShell/releases/tag/v7.3.0
[12]: https://learn.microsoft.com/powershell/module/psreadline/about/about_psreadline#psreadline-release-history
[12802]: https://github.com/PowerShell/PowerShell/pull/12802
[13799]: https://github.com/PowerShell/PowerShell/pull/13799
[14550]: https://github.com/PowerShell/PowerShell/pull/14550
[15177]: https://github.com/PowerShell/PowerShell/pull/15177
[15257]: https://github.com/PowerShell/PowerShell/pull/15257
[15853]: https://github.com/PowerShell/PowerShell/pull/15853
[15897]: https://github.com/PowerShell/PowerShell/pull/15897
[15993]: https://github.com/PowerShell/PowerShell/pull/15993
[16046]: https://github.com/PowerShell/PowerShell/pull/16046
[16108]: https://github.com/PowerShell/PowerShell/pull/16108
[16113]: https://github.com/PowerShell/PowerShell/pull/16113
[16134]: https://github.com/PowerShell/PowerShell/pull/16134
[16193]: https://github.com/PowerShell/PowerShell/pull/16193
[16197]: https://github.com/PowerShell/PowerShell/pull/16197
[16355]: https://github.com/PowerShell/PowerShell/pull/16355
[16438]: https://github.com/PowerShell/PowerShell/pull/16438
[16498]: https://github.com/PowerShell/PowerShell/pull/16498
[16504]: https://github.com/PowerShell/PowerShell/pull/16504
[16545]: https://github.com/PowerShell/PowerShell/pull/16545
[16951]: https://github.com/PowerShell/PowerShell/pull/16951
[16963]: https://github.com/PowerShell/PowerShell/pull/16963
[17111]: https://github.com/PowerShell/PowerShell/pull/17111
[17405]: https://github.com/PowerShell/PowerShell/pull/17405
[17447]: https://github.com/PowerShell/PowerShell/pull/17447
[17455]: https://github.com/PowerShell/PowerShell/pull/17455
[17477]: https://github.com/PowerShell/PowerShell/pull/17477
[17484]: https://github.com/PowerShell/PowerShell/pull/17484
[17535]: https://github.com/PowerShell/PowerShell/pull/17535
[17579]: https://github.com/PowerShell/PowerShell/pull/17579
[17619]: https://github.com/PowerShell/PowerShell/pull/17619
[17621]: https://github.com/PowerShell/PowerShell/pull/17621
[17650]: https://github.com/PowerShell/PowerShell/pull/17650
[17661]: https://github.com/PowerShell/PowerShell/pull/17661
[17664]: https://github.com/PowerShell/PowerShell/pull/17664
[17693]: https://github.com/PowerShell/PowerShell/pull/17693
[17715]: https://github.com/PowerShell/PowerShell/pull/17715
[17716]: https://github.com/PowerShell/PowerShell/pull/17716
[17751]: https://github.com/PowerShell/PowerShell/pull/17751
[17752]: https://github.com/PowerShell/PowerShell/pull/17752
[17804]: https://github.com/PowerShell/PowerShell/pull/17804

# /./reference/whats-new/what-s-new-in-powershell-72.md

    ---
    title: What's New in PowerShell 7.2
    description: New features and changes released in PowerShell 7.2
    ms.date: 01/20/2023
    ---

# What's New in PowerShell 7.2

PowerShell 7.2 is the next Long Term Servicing (LTS) release is built on .NET 6.0.

PowerShell 7.2 includes the following features, updates, and breaking changes.

- New universal installer packages for most supported Linux distributions
- Microsoft Update support on Windows
- 2 new experimental features
  - Improved native command argument passing support
  - ANSI FileInfo color support
- Improved Tab Completions
- PSReadLine 2.1 with Predictive IntelliSense
- 7 experimental features promoted to mainstream and 1 removed
- Separating DSC from PowerShell 7 to enable future improvements
- Several breaking changes to improve usability

For a complete list of changes, see the [Change Log][11] in the GitHub repository.

## Installation updates

Check the installation instructions for your preferred operating system:

- [Windows][09]
- [macOS][08]
- [Linux][07]

Additionally, PowerShell 7.2 supports ARM64 versions of Windows and macOS and ARM32 and ARM64
versions of Debian and Ubuntu.

For up-to-date information about supported operating systems and support lifecycle, see the
[PowerShell Support Lifecycle][10].

### New universal install packages for Linux distributions

Previously, we created separate installer packages for each supported version of CentOS, RHEL,
Debian, and Ubuntu. The universal installer package combines eight different packages into one,
making installation on Linux simpler. The universal package installs the necessary dependencies for
the target distribution and creates the platform-specific changes to make PowerShell work.

### Microsoft Update support for Windows

PowerShell 7.2 add support for Microsoft Update. When you enable this feature, you'll get the latest
PowerShell 7 updates in your traditional Windows Update (WU) management flow, whether that's with
Windows Update for Business, WSUS, SCCM, or the interactive WU dialog in Settings.

The PowerShell 7.2 MSI package includes following command-line options:

- `USE_MU` - This property has two possible values:
  - `1` (default) - Opts into updating through Microsoft Update or WSUS
  - `0` -  don't opt into updating through Microsoft Update or WSUS
- `ENABLE_MU`
  - `1` (default) - Opts into using Microsoft Update the Automatic Updates or Windows Update
  - `0` - don't opt into using Microsoft Update the Automatic Updates or Windows Update

## Experimental Features

The following experimental features are now mainstream features in this release:

- `Microsoft.PowerShell.Utility.PSImportPSDataFileSkipLimitCheck` - see
  [Import-PowerShellDataFile][06]
- `Microsoft.PowerShell.Utility.PSManageBreakpointsInRunspace`
- `PSAnsiRendering` - see [about_ANSI_Terminals][05]
- `PSAnsiProgress` - see [about_ANSI_Terminals][05]
- `PSCultureInvariantReplaceOperator`
- `PSNotApplyErrorActionToStderr`
- `PSUnixFileStat`

The following experimental feature was added in this release:

- [PSNativeCommandArgumentPassing][04] - When this experimental feature is enabled PowerShell uses
  the **ArgumentList** property of the **StartProcessInfo** object rather than our current mechanism
  of reconstructing a string when invoking a native executable. This feature adds a new automatic
  variable `$PSNativeCommandArgumentPassing` that allows you to select the behavior at runtime.

- [PSAnsiRenderingFileInfo][02] - Allow ANSI color customization of file information.
- [PSLoadAssemblyFromNativeCode][03] - Exposes an API to allow assembly loading from native code.

For more information about the Experimental Features, see [Using Experimental Features][01].

## Improved Tab Completions

PowerShell 7.2 includes several improvements to Tab Completion. These changes include bugfixes and
improve usability.

- Fix tab completion for unlocalized about* topics (#15265) (Thanks @MartinGC94)
- Fix splatting being treated as positional parameter in completions (#14623) (Thanks @MartinGC94)
- Add completions for comment-based help keywords (#15337) (Thanks @MartinGC94)
- Add completion for Requires statements (#14596) (Thanks @MartinGC94)
- Added tab completion for View parameter of Format-* cmdlets (#14513) (Thanks @iSazonov)

## PSReadLine 2.1 Predictive IntelliSense

PSReadLine 2.1 introduced `CommandPrediction` APIs that establish a framework for providing
predictions for command-line completion. The API enables users to discover, edit, and execute full
commands based on matching predictions from the user's history.

Predictive IntelliSense is disabled by default. To enable predictions, run the following command:

```powershell
Set-PSReadLineOption -PredictionSource History
```

## Separating DSC from PowerShell 7 to enable future improvements

The PSDesiredStateConfiguration module was removed from the PowerShell 7.2 package and is now
published to the PowerShell Gallery. This allows the PSDesiredStateConfiguration module to be
developed independently of PowerShell and users can mix and match versions of PowerShell and
PSDesiredStateConfiguration for their environment. To install PSDesiredStateConfiguration 2.0.5 from
the PowerShell Gallery:

```powershell
Install-Module -Name PSDesiredStateConfiguration -Repository PSGallery -MaximumVersion 2.99
```

> [!IMPORTANT]
> Be sure to include the parameter MaximumVersion or you could install version 3 (or higher) of
> PSDesireStateConfiguration that contains significant differences.

## Engine updates

- Add `LoadAssemblyFromNativeMemory` function to load assemblies in memory from a native PowerShell
  host by awakecoding · Pull Request #14652

## Breaking Changes and Improvements

- The PSDesiredStateConfiguration was removed from the PowerShell 7.2 package
- Make PowerShell Linux deb and RPM packages universal (#15109)
- Experimental feature `PSNativeCommandArgumentPassing`: Use ArgumentList for native executable
  invocation (#14692)
- Ensure `-PipelineVariable` is set for all output from script cmdlets (#12766)
- Emit warning if `ConvertTo-Json` exceeds -Depth value (#13692)
- Remove alias D of -Directory switch CL-General #15171
- Improve detection of mutable value types (#12495)
- Restrict `New-Object` in **NoLanguage** mode under lock down (#14140)
- Enforce AppLocker Deny configuration before Execution Policy Bypass configuration (#15035)
- Change `FileSystemInfo.Target` from a **CodeProperty** to an **AliasProperty** that points to
  `FileSystemInfo.LinkTarget` (#16165)

<!-- end of content -->
<!-- link references -->
[01]: ../learn/experimental-features.md
[02]: ../learn/experimental-features.md#psansirenderingfileinfo
[03]: ../learn/experimental-features.md#psloadassemblyfromnativecode
[04]: ../learn/experimental-features.md#psnativecommandargumentpassing
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_ansi_terminals
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/import-powershelldatafile
[07]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell-core-on-linux
[08]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell-core-on-macos
[09]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell-core-on-windows
[10]: https://learn.microsoft.com/powershell/scripting/powershell-support-lifecycle
[11]: https://github.com/PowerShell/PowerShell/blob/master/CHANGELOG/7.2.md

# /./reference/whats-new/Migrating-from-Windows-PowerShell-51-to-PowerShell-7.md

    ---
    description: Update from PowerShell 5.1 to PowerShell 7 for your Windows platforms.
    ms.date: 04/02/2024
    title: Migrating from Windows PowerShell 5.1 to PowerShell 7
    ---

# Migrating from Windows PowerShell 5.1 to PowerShell 7

Designed for cloud, on-premises, and hybrid environments, PowerShell 7 is packed with enhancements
and [new features][09].

- Installs and runs side-by-side with Windows PowerShell
- Improved compatibility with existing Windows PowerShell modules
- New language features, like ternary operators and `ForEach-Object -Parallel`
- Improved performance
- SSH-based remoting
- Cross-platform interoperability
- Support for Docker containers

PowerShell 7 works side-by-side with Windows PowerShell letting you easily test and compare between
editions before deployment. Migration is simple, quick, and safe.

PowerShell 7 is supported on the following Windows operating systems:

- Windows 10, and 11
- Windows Server 2016, 2019, and 2022

PowerShell 7 also runs on macOS and several Linux distributions. For a list of supported operating
systems and information about the support lifecycle, see the [PowerShell Support Lifecycle][06].

## Installing PowerShell 7

For flexibility and to support the needs of IT, DevOps engineers, and developers, there are several
options available to install PowerShell 7. In most cases, the installation options can be reduced to
the following methods:

- Deploy PowerShell using the [MSI package][03]
- Deploy PowerShell using the [ZIP package][05]

> [!NOTE]
> The MSI package can be deployed and updated with management products such as
> [Microsoft Configuration Manager][12]. Download the packages from
> [GitHub Release page][24].

Deploying the MSI package requires Administrator permission. The ZIP package can be deployed by any
user. The ZIP package is the easiest way to install PowerShell 7 for testing, before committing to a
full installation.

You may also install PowerShell 7 via the Windows Store or `winget`. For more information about both
of these methods, see the detailed instructions in [Installing PowerShell on Windows][04].

## Using PowerShell 7 side-by-side with Windows PowerShell 5.1

PowerShell 7 is designed to coexist with Windows PowerShell 5.1. The following features ensure that
your investment in PowerShell is protected and your migration to PowerShell 7 is simple.

- Separate installation path and executable name
- Separate PSModulePath
- Separate profiles for each version
- Improved module compatibility
- New remoting endpoints
- Group policy support
- Separate Event logs

### Differences in .NET versions

PowerShell 7.2 is built on .NET 6.0. Windows PowerShell 5.1 is built on .NET Framework 4.x. The
differences between the .NET versions might affect the behavior of your scripts, especially if you
are calling .NET method directly. For more information,
[Differences between Windows PowerShell 5.1 and PowerShell 7.x][10].

### Separate installation path and executable name

PowerShell 7 installs to a new directory, enabling side-by-side execution with Windows PowerShell
5.1.

Install locations by version:

- Windows PowerShell 5.1: `$env:WINDIR\System32\WindowsPowerShell\v1.0`
- PowerShell 6.x: `$env:ProgramFiles\PowerShell\6`
- PowerShell 7: `$env:ProgramFiles\PowerShell\7`

The new location is added to your PATH allowing you to run both Windows PowerShell 5.1 and
PowerShell 7. If you're migrating from PowerShell 6.x to PowerShell 7, PowerShell 6 is removed and
the PATH replaced.

In Windows PowerShell, the PowerShell executable is named `powershell.exe`. In version 6 and above,
the executable is named `pwsh.exe`. The new name makes it easy to support side-by-side execution of
both versions.

### Separate PSModulePath

By default, Windows PowerShell and PowerShell 7 store modules in different locations. PowerShell 7
combines those locations in the `$Env:PSModulePath` environment variable. When importing a module by
name, PowerShell checks the location specified by `$Env:PSModulePath`. This allows PowerShell 7 to
load both Core and Desktop modules.

|            Install Scope            |                Windows PowerShell 5.1                 |              PowerShell 7.0              |
| ----------------------------------- | ----------------------------------------------------- | ---------------------------------------- |
| PowerShell modules                  | `$env:WINDIR\system32\WindowsPowerShell\v1.0\Modules` | `$env:ProgramFiles\PowerShell\7\Modules` |
| User installed<br>AllUsers scope    | `$env:ProgramFiles\WindowsPowerShell\Modules`         | `$env:ProgramFiles\PowerShell\Modules`   |
| User installed<br>CurrentUser scope | `$HOME\Documents\WindowsPowerShell\Modules`           | `$HOME\Documents\PowerShell\Modules`     |

The following examples show the default values of `$Env:PSModulePath` for each version.

- For Windows PowerShell 5.1:

  ```powershell
  $Env:PSModulePath -split (';')
  ```

  ```Output
  C:\Users\<user>\Documents\WindowsPowerShell\Modules
  C:\Program Files\WindowsPowerShell\Modules
  C:\WINDOWS\System32\WindowsPowerShell\v1.0\Modules
  ```

- For PowerShell 7:

  ```powershell
  $Env:PSModulePath -split (';')
  ```

  ```Output
  C:\Users\<user>\Documents\PowerShell\Modules
  C:\Program Files\PowerShell\Modules
  C:\Program Files\PowerShell\7\Modules
  C:\Program Files\WindowsPowerShell\Modules
  C:\WINDOWS\System32\WindowsPowerShell\v1.0\Modules
  ```

Notice that PowerShell 7 includes the Windows PowerShell paths and the PowerShell 7 paths to provide
autoloading of modules.

> [!NOTE]
> Additional paths may exist if you have changed the PSModulePath environment variable or installed
> custom modules or applications.

For more information, see [about_PSModulePath][17].

For more information about Modules, see [about_Modules][15].

### Separate profiles

A PowerShell profile is a script that executes when PowerShell starts. This script customizes your
environment by adding commands, aliases, functions, variables, modules, and PowerShell drives. The
profile script makes these customizations available in every session without having to manually
recreate them.

The path to the location of the profile has changed in PowerShell 7.

- In Windows PowerShell 5.1, the location of the profile is `$HOME\Documents\WindowsPowerShell`.
- In PowerShell 7, the location of the profile is `$HOME\Documents\PowerShell`.

The profile filenames have also changed:

   ```powershell
   $PROFILE | Select-Object *Host* | Format-List
  ```

  ```Output
   AllUsersAllHosts       : C:\Program Files\PowerShell\7\profile.ps1
   AllUsersCurrentHost    : C:\Program Files\PowerShell\7\Microsoft.PowerShell_profile.ps1
   CurrentUserAllHosts    : C:\Users\<user>\Documents\PowerShell\profile.ps1
   CurrentUserCurrentHost : C:\Users\<user>\Documents\PowerShell\Microsoft.PowerShell_profile.ps1
   ```

For more information
[about_Profiles][16].

### PowerShell 7 compatibility with Windows PowerShell 5.1 modules

Most of the modules you use in Windows PowerShell 5.1 already work with PowerShell 7, including
Azure PowerShell and Active Directory. We're continuing to work with other teams to add native
PowerShell 7 support for more modules including Microsoft Graph, Office 365, and others. For the
current list of supported modules, see [PowerShell 7 module compatibility][11].

> [!NOTE]
> On Windows, we've also added a **UseWindowsPowerShell** switch to `Import-Module` to ease the
> transition to PowerShell 7 for those using incompatible modules. For more information on this
> functionality, see [about_Windows_PowerShell_Compatibility][20].

## PowerShell Remoting

PowerShell remoting lets you run any PowerShell command on one or more remote computers. You can
establish persistent connections, start interactive sessions, and run scripts on remote computers.

### WS-Management remoting

Windows PowerShell 5.1 and below use the WS-Management (WSMAN) protocol for connection negotiation
and data transport. Windows Remote Management (WinRM) uses the WSMAN protocol. If WinRM has been
enabled, PowerShell 7 uses the existing Windows PowerShell 5.1 endpoint named `Microsoft.PowerShell`
for remoting connections. To update PowerShell 7 to include its own endpoint, run the
`Enable-PSRemoting` cmdlet. For information about connecting to specific endpoints, see
[WS-Management Remoting in PowerShell][08]

To use Windows PowerShell remoting, the remote computer must be configured for remote management.
For more information, including instructions, see [About Remote Requirements][19].

For more information about working with remoting, see [About Remote][18]

### SSH-based remoting

SSH-based remoting was added in PowerShell 6.x to support other operating systems that can't use
Windows native components like **WinRM**. SSH remoting creates a PowerShell host process on the
target computer as an SSH subsystem. For details and examples on setting up SSH-based remoting on
Windows or Linux, see: [PowerShell remoting over SSH][07].

> [!NOTE]
> The PowerShell Gallery (PSGallery) contains a module and cmdlet that automatically configures
> SSH-based remoting. Install the `Microsoft.PowerShell.RemotingTools` module from the
> [PSGallery][25] and run the `Enable-SSH` cmdlet.

The `New-PSSession`, `Enter-PSSession`, and `Invoke-Command` cmdlets have new parameter sets to
support SSH connections.

```powershell
[-HostName <string>]  [-UserName <string>]  [-KeyFilePath <string>]
```

To create a remote session, specify the target computer with the **HostName** parameter and provide
the user name with **UserName**. When running the cmdlets interactively, you're prompted for a
password.

```powershell
Enter-PSSession -HostName <Computer> -UserName <Username>
```

Alternatively, when using the **HostName** parameter, provide the username information followed by
the at sign (`@`), followed by the computer name.

```powershell
Enter-PSSession -HostName <Username>@<Computer>
```

You may set up SSH key authentication using a private key file with the **KeyFilePath** parameter.
For more information, see [OpenSSH Key Management][21].

## Group Policy supported

PowerShell includes Group Policy settings to help you define consistent option values for servers in
an enterprise environment. These settings include:

- Console session configuration: Sets a configuration endpoint in which PowerShell is run.
- Turn on Module Logging: Sets the LogPipelineExecutionDetails property of modules.
- Turn on PowerShell Script Block Logging: Enables detailed logging of all PowerShell scripts.
- Turn on Script Execution: Sets the PowerShell execution policy.
- Turn on PowerShell Transcription: enables capturing of input and output of PowerShell commands
  into text-based transcripts.
- Set the default source path for Update-Help: Sets the source for Updatable Help to a directory,
  not the Internet.

For more information, see [about_Group_Policy_Settings][13].

PowerShell 7 includes Group Policy templates and an installation script in `$PSHOME`.

Group Policy tools use administrative template files (`.admx`, `.adml`) to populate policy settings
in the user interface. This allows administrators to manage registry-based policy settings. The
`InstallPSCorePolicyDefinitions.ps1` script installs PowerShell Administrative Templates on the
local machine.

```powershell
Get-ChildItem -Path $PSHOME -Filter *Core*Policy*
```

```Output
    Directory: C:\Program Files\PowerShell\7

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---           2/27/2020 12:38 AM          15861 InstallPSCorePolicyDefinitions.ps1
-a---           2/27/2020 12:28 AM           9675 PowerShellCoreExecutionPolicy.adml
-a---           2/27/2020 12:28 AM           6201 PowerShellCoreExecutionPolicy.admx
```

## Separate Event Logs

Windows PowerShell and PowerShell 7 log events to separate event logs. Use the following command to
get a list of the PowerShell logs.

```powershell
Get-WinEvent -ListLog *PowerShell*
```

For more information, see [about_Logging_Windows][14].

## Improved editing experience with Visual Studio Code

[Visual Studio Code (VSCode)][22] with the [PowerShell Extension][23] is the supported scripting
environment for PowerShell 7. The Windows PowerShell Integrated Scripting Environment (ISE) only
supports Windows PowerShell.

The updated PowerShell extension includes:

- New ISE compatibility mode
- PSReadLine in the Integrated Console, including syntax highlighting, multi-line editing, and back
  search
- Stability and performance improvements
- New CodeLens integration
- Improved path autocompletion

To make the transition to Visual Studio Code easier, use the **Enable ISE Mode** function available
in the **Command Palette**. This function switches VSCode into an ISE-style layout. The ISE-style
layout gives you all the new features and capabilities of PowerShell in a familiar user experience.

To switch to the new ISE layout, press <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> to open the
**Command Palette**, type `PowerShell` and select **PowerShell: Enable ISE Mode**.

To set the layout to the original layout, open the **Command Palette**, select
**PowerShell: Disable ISE Mode (restore to defaults)**.

For details about customizing the VSCode layout to ISE, see
[How to Replicate the ISE Experience in Visual Studio Code][01]

> [!NOTE]
> There are no plans to update the ISE with new features. In the latest versions of Windows 10 or
> Windows Server 2019 and higher, the ISE is now a user-uninstallable feature. There are no plans to
> permanently remove the ISE. The PowerShell Team and its partners are focused on improving the
> scripting experience in the PowerShell extension for Visual Studio Code.

## Next Steps

Armed with the knowledge to effectively migrate, [install PowerShell 7][02] now!

<!-- link references -->
[01]: ../dev-cross-plat/vscode/how-to-replicate-the-ise-experience-in-vscode.md
[02]: ../install/installing-powershell-on-windows.md
[03]: ../install/installing-powershell-on-windows.md#msi
[04]: ../install/installing-powershell-on-windows.md#winget
[05]: ../install/installing-powershell-on-windows.md#zip
[06]: ../install/powershell-support-lifecycle.md
[07]: ../security/remoting/ssh-remoting-in-powershell.md
[08]: ../security/remoting/wsman-remoting-in-powershell.md
[09]: ../whats-new/What-s-New-in-PowerShell-70.md
[10]: ./differences-from-windows-powershell.md
[11]: ./module-compatibility.md
[12]: https://learn.microsoft.com/configmgr/apps/
[13]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_group_policy_settings
[14]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_logging_windows
[15]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/About/about_Modules
[16]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_profiles
[17]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_psmodulepath
[18]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote
[19]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote_requirements
[20]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/About/about_windows_powershell_compatibility
[21]: https://learn.microsoft.com/windows-server/administration/openssh/openssh_keymanagement
[22]: https://code.visualstudio.com/
[23]: https://code.visualstudio.com/docs/languages/powershell
[24]: https://github.com/PowerShell/PowerShell/releases
[25]: https://www.powershellgallery.com/packages/Microsoft.PowerShell.RemotingTools

# /./reference/whats-new/differences-from-windows-powershell.md

    ---
    ms.date: 04/02/2024
    title: Differences between Windows PowerShell 5.1 and PowerShell 7.x
    description: This article summarizes the differences and breaking changes from Windows PowerShell 5.1 and the current version of PowerShell that is based on .NET Core.
    ---
# Differences between Windows PowerShell 5.1 and PowerShell 7.x

Windows PowerShell 5.1 is built on top of the .NET Framework v4.5. With the release of PowerShell
6.0, PowerShell became an open source project built on .NET Core 2.0. Moving from the .NET Framework
to .NET Core allowed PowerShell to become a cross-platform solution. PowerShell runs on Windows,
macOS, and Linux.

There are few differences in the PowerShell language between Windows PowerShell and PowerShell. The
most notable differences are in the availability and behavior of PowerShell cmdlets between Windows
and non-Windows platforms and the changes that stem from the differences between the .NET Framework
and .NET Core.

This article summarizes the significant differences and breaking changes between Windows PowerShell
and the current version of PowerShell. This summary does not include new features or cmdlets that
have been added. Nor does this article discuss what changed between versions. The goal of this
article is to present the current state of PowerShell and how that is different from Windows
PowerShell. For a detailed discussion of changes between versions and the addition of new features,
see the **What's New** articles for each version.

- [What's new in PowerShell 7.5][36]
- [What's new in PowerShell 7.4][35]
- [What's new in PowerShell 7.3][34]
- [What's new in PowerShell 7.2][33]
- [What's new in PowerShell 7.1][27]
- [What's new in PowerShell 7.0][32]
- [What's new in PowerShell 6.x][28]

## .NET Framework vs .NET Core

PowerShell on Linux and macOS uses .NET core, which is a subset of the full .NET Framework on
Microsoft Windows. This is significant because PowerShell provides direct access to the underlying
framework types and methods. As a result, scripts that run on Windows may not run on non-Windows
platforms because of the differences in the frameworks. For more information about changes in .NET
Core, see [Breaking changes for migration from .NET Framework to .NET Core][03].

Each new release of PowerShell is built on a newer version of .NET. There can be breaking changes in
.NET that affect PowerShell.

- PowerShell 7.5 - Built on .NET 9.0
- PowerShell 7.4 - Built on .NET 8.0
- PowerShell 7.3 - Built on .NET 7.0
- PowerShell 7.2 (LTS-current) - Built on .NET 6.0 (LTS-current)
- PowerShell 7.1 - Built on .NET 5.0
- PowerShell 7.0 (LTS) - Built on .NET Core 3.1 (LTS)
- PowerShell 6.2 - Built on .NET Core 2.1
- PowerShell 6.1 - Built on .NET Core 2.1
- PowerShell 6.0 - Built on .NET Core 2.0

With the advent of [.NET Standard 2.0][30], PowerShell can load many traditional Windows
PowerShell modules without modification. Additionally, PowerShell 7 includes a Windows PowerShell
Compatibility feature that allows you to use Windows PowerShell modules that still require the full
framework.

For more information see:

- [about_Windows_PowerShell_Compatibility][09]
- [PowerShell 7 module compatibility][29]

### Be aware of .NET method changes

While .NET method changes are not specific to PowerShell, they can affect your scripts, especially
if you are calling .NET methods directly. Also, there might be new overloads for constructors. This
can have an impact on how you create objects using `New-Object` or the `[type]::new()` method.

For example, .NET added overloads to the `[System.String]::Split()` method that aren't available in
.NET Framework 4.5. The following list shows the overloads for the `Split()` method available in
Windows PowerShell 5.1:

```powershell
PS> "".Split

OverloadDefinitions
-------------------
string[] Split(Params char[] separator)
string[] Split(char[] separator, int count)
string[] Split(char[] separator, System.StringSplitOptions options)
string[] Split(char[] separator, int count, System.StringSplitOptions options)
string[] Split(string[] separator, System.StringSplitOptions options)
string[] Split(string[] separator, int count, System.StringSplitOptions options)
```

The following list shows the overloads for the `Split()` method available in PowerShell 7:

```powershell
"".Split

OverloadDefinitions
-------------------
string[] Split(char separator, System.StringSplitOptions options)
string[] Split(char separator, int count, System.StringSplitOptions options)
string[] Split(Params char[] separator)
string[] Split(char[] separator, int count)
string[] Split(char[] separator, System.StringSplitOptions options)
string[] Split(char[] separator, int count, System.StringSplitOptions options)
string[] Split(string separator, System.StringSplitOptions options)
string[] Split(string separator, int count, System.StringSplitOptions options)
string[] Split(string[] separator, System.StringSplitOptions options)
string[] Split(string[] separator, int count, System.StringSplitOptions options)
```

In Windows PowerShell 5.1, you could pass a character array (`char[]`) to the `Split()` method as a
`string`. The method splits the target string at any occurrence of a character in the array. The
following command splits the target string in Windows PowerShell 5.1, but not in PowerShell 7:

```powershell
# PowerShell 7 example
"1111p2222q3333".Split('pq')
```

```Output
1111p2222q3333
```

To bind to the correct overload, you must typecast the string to a character array:

```powershell
# PowerShell 7 example
"1111p2222q3333".Split([char[]]'pq')
```

```Output
1111
2222
3333
```

## Modules no longer shipped with PowerShell

For various compatibility reasons, the following modules are no longer included in PowerShell.

- ISE
- Microsoft.PowerShell.LocalAccounts
- Microsoft.PowerShell.ODataUtils
- Microsoft.PowerShell.Operation.Validation
- PSScheduledJob
- PSWorkflow
- PSWorkflowUtility

### PowerShell Workflow

[PowerShell Workflow][26] is a feature in Windows PowerShell that builds on top of
[Windows Workflow Foundation (WF)][04] that enables the creation of robust runbooks
for long-running or parallelized tasks.

Due to the lack of support for Windows Workflow Foundation in .NET Core, we removed PowerShell
Workflow from PowerShell.

In the future, we would like to enable native parallelism/concurrency in the PowerShell language
without the need for PowerShell Workflow.

If there is a need to use checkpoints to resume a script after the OS restarts, we recommend
using Task Scheduler to run a script on OS startup, but the script would need to maintain
its own state (like persisting it to a file).

## Cmdlets removed from PowerShell

For the modules that are included in PowerShell, the following cmdlets were removed from PowerShell
for various compatibility reasons or the use of unsupported APIs.

CimCmdlets

- `Export-BinaryMiLog`

Microsoft.PowerShell.Core

- `Add-PSSnapin`
- `Export-Console`
- `Get-PSSnapin`
- `Remove-PSSnapin`
- `Resume-Job`
- `Suspend-Job`

Microsoft.PowerShell.Diagnostics

- `Export-Counter`
- `Import-Counter`

Microsoft.PowerShell.Management

- `Add-Computer`
- `Checkpoint-Computer`
- `Clear-EventLog`
- `Complete-Transaction`
- `Disable-ComputerRestore`
- `Enable-ComputerRestore`
- `Get-ComputerRestorePoint`
- `Get-ControlPanelItem`
- `Get-EventLog`
- `Get-Transaction`
- `Get-WmiObject`
- `Invoke-WmiMethod`
- `Limit-EventLog`
- `New-EventLog`
- `New-WebServiceProxy`
- `Register-WmiEvent`
- `Remove-Computer`
- `Remove-EventLog`
- `Remove-WmiObject`
- `Reset-ComputerMachinePassword`
- `Restore-Computer`
- `Set-WmiInstance`
- `Show-ControlPanelItem`
- `Show-EventLog`
- `Start-Transaction`
- `Test-ComputerSecureChannel`
- `Undo-Transaction`
- `Use-Transaction`
- `Write-EventLog`

Microsoft.PowerShell.Utility

- `Convert-String`
- `ConvertFrom-String`

PSDesiredStateConfiguration

- `Disable-DscDebug`
- `Enable-DscDebug`
- `Get-DscConfiguration`
- `Get-DscConfigurationStatus`
- `Get-DscLocalConfigurationManager`
- `Publish-DscConfiguration`
- `Remove-DscConfigurationDocument`
- `Restore-DscConfiguration`
- `Set-DscLocalConfigurationManager`
- `Start-DscConfiguration`
- `Stop-DscConfiguration`
- `Test-DscConfiguration`
- `Update-DscConfiguration`

### WMI v1 cmdlets

The following WMI v1 cmdlets were removed from PowerShell:

- `Register-WmiEvent`
- `Set-WmiInstance`
- `Invoke-WmiMethod`
- `Get-WmiObject`
- `Remove-WmiObject`

The CimCmdlets module (aka WMI v2) cmdlets perform the same function and provide new functionality
and a redesigned syntax.

### `New-WebServiceProxy` cmdlet removed

.NET Core does not support the Windows Communication Framework, which provide services for using the
SOAP protocol. This cmdlet was removed because it requires SOAP.

### `*-Transaction` cmdlets removed

These cmdlets had very limited usage. The decision was made to discontinue support for them.

- `Complete-Transaction`
- `Get-Transaction`
- `Start-Transaction`
- `Undo-Transaction`
- `Use-Transaction`

### `*-EventLog` cmdlets

Due to the use of unsupported APIs, the `*-EventLog` cmdlets have been removed from PowerShell.
`Get-WinEvent` and `New-WinEvent` are available to get and create events on Windows.

### Cmdlets that use the Windows Presentation Framework (WPF)

.NET Core 3.1 added support for WPF, so the release of PowerShell 7.0 restored the following
Windows-specific features:

- The `Show-Command` cmdlet
- The `Out-GridView` cmdlet
- The **ShowWindow** parameter of `Get-Help`

### PowerShell Desired State Configuration (DSC) changes

`Invoke-DscResource` was restored as an experimental feature in PowerShell 7.0.

Beginning with PowerShell 7.2, the PSDesiredStateConfiguration module has been removed from
PowerShell and has been published to the PowerShell Gallery. For more information, see the
[announcement][31] in the PowerShell Team blog.

## PowerShell executable changes

### Renamed `powershell.exe` to `pwsh.exe`

The binary name for PowerShell has been changed from `powershell(.exe)` to `pwsh(.exe)`. This
change provides a deterministic way for users to run PowerShell on machines and support
side-by-side installations of Windows PowerShell and PowerShell.

Additional changes to `pwsh(.exe)` from `powershell.exe`:

- Changed the first positional parameter from `-Command` to `-File`. This change fixes the usage of
  `#!` (aka as a shebang) in PowerShell scripts that are being executed from non-PowerShell shells
  on non-Windows platforms. It also means that you can run commands like `pwsh foo.ps1` or
  `pwsh fooScript` without specifying `-File`. However, this change requires that you explicitly
  specify `-c` or `-Command` when trying to run commands like `pwsh.exe -Command Get-Command`.
- `pwsh` accepts the `-i` (or `-Interactive`) switch to indicate an interactive shell.
  This allows PowerShell to be used as a default shell on Unix platforms.
- Removed parameters `-ImportSystemModules` and `-PSConsoleFile` from `pwsh.exe`.
- Changed `pwsh -version` and built-in help for `pwsh.exe` to align with other native tools.
- Invalid argument error messages for `-File` and `-Command` and exit codes consistent with Unix
  standards
- Added `-WindowStyle` parameter on Windows. Similarly, package-based installations updates on
  non-Windows platforms are in-place updates.

The shortened name is also consistent with naming of shells on non-Windows platforms.

### Support running a PowerShell script with bool parameter

Previously, using `pwsh.exe` to execute a PowerShell script using `-File` provided no way to pass
`$true`/`$false` as parameter values. Support for `$true`/`$false` as parsed values to parameters
was added. Switch values are also supported.

## Improved backwards compatibility with Windows PowerShell

For Windows, a new switch parameter **UseWindowsPowerShell** is added to `Import-Module`. This
switch creates a proxy module in PowerShell 7 that uses a local Windows PowerShell process to
implicitly run any cmdlets contained in that module. For more information, see [Import-Module][14].

For more information on which Microsoft modules work with PowerShell 7.0, see the
[Module Compatibility Table][29].

### Microsoft Update support for Windows

PowerShell 7.2 added support for Microsoft Update. When you enable this feature, you'll get the latest
PowerShell 7 updates in your traditional Windows Update (WU) management flow, whether that's with
Windows Update for Business, WSUS, SCCM, or the interactive WU dialog in Settings.

The PowerShell 7.2 MSI package includes following command-line options:

- `USE_MU` - This property has two possible values:
  - `1` (default) - Opts into updating through Microsoft Update or WSUS
  - `0` -  Do not opt into updating through Microsoft Update or WSUS
- `ENABLE_MU`
  - `1` (default) - Opts into using Microsoft Update the Automatic Updates or Windows Update
  - `0` - Do not opt into using Microsoft Update the Automatic Updates or Windows Update

## Engine changes

### Support PowerShell as a default Unix shell

On Unix, it is a convention for shells to accept `-i` for an interactive shell and many tools
expect this behavior (`script` for example, and when setting PowerShell as the default shell) and
calls the shell with the `-i` switch. This change is breaking in that `-i` previously could be used
as short hand to match `-inputformat`, which now needs to be `-in`.

### Custom snap-ins

[PowerShell snap-ins][07] are a predecessor to PowerShell modules that do not have widespread
adoption in the PowerShell community.

Due to the complexity of supporting snap-ins and their lack of usage in the community, we no longer
support custom snap-ins in PowerShell.

### Experimental feature flags

PowerShell 6.2 enabled support for [Experimental Features][06]. This allows PowerShell developers to
deliver new features and get feedback before the design is complete. This way we avoid making
breaking changes as the design evolves.

Use `Get-ExperimentalFeature` to get a list of available experimental features. You can enable or
disable these features with `Enable-ExperimentalFeature` and `Disable-ExperimentalFeature`.

### Load assembly from module base path before trying to load from the GAC

Previously, when a binary module has the module assembly in GAC, we loaded the assembly from GAC
before trying to load it from module base path.

### Skip null-element check for collections with a value-type element type

For the `Mandatory` parameter and `ValidateNotNull` and `ValidateNotNullOrEmpty` attributes, skip
the null-element check if the collection's element type is value type.

### Preserve `$?` for **ParenExpression**, **SubExpression** and **ArrayExpression**

This PR alters the way we compile subpipelines `(...)`, subexpressions `$(...)` and array
expressions `@()` so that `$?` is not automatically **true**. Instead the value of `$?` depends on
the result of the pipeline or statements executed.

### Fix `$?` to not be `$false` when native command writes to `stderr`

`$?` is not set to `$false` when native command writes to `stderr`. It is common for native commands
to write to `stderr` without intending to indicate a failure. `$?` is set to `$false` only when the
native command has a non-zero exit code.

### Make `$ErrorActionPreference` not affect `stderr` output of native commands

It is common for native commands to write to `stderr` without intending to indicate a failure. With
this change, `stderr` output is still captured in **ErrorRecord** objects, but the runtime no longer
applies `$ErrorActionPreference` if the **ErrorRecord** comes from a native command.

### Change `$OutputEncoding` to use `UTF-8 NoBOM` encoding rather than ASCII

The previous encoding, ASCII (7-bit), would result in incorrect alteration of the output in some
cases. Making `UTF-8 NoBOM` the default preserves Unicode output with an encoding supported by most
tools and operating systems.

### Unify cmdlets with parameter `-Encoding` to be of type `System.Text.Encoding`

The `-Encoding` value `Byte` has been removed from the filesystem provider cmdlets. A new parameter,
`-AsByteStream`, is now used to specify that a byte stream is required as input or that the output
is a stream of bytes.

### Change `New-ModuleManifest` encoding to `UTF8NoBOM` on non-Windows platforms

Previously, `New-ModuleManifest` creates `psd1` manifests in UTF-16 with BOM, creating a problem for
Linux tools. This breaking change changes the encoding of `New-ModuleManifest` to be UTF (no BOM) in
non-Windows platforms.

### Remove `AllScope` from most default aliases

To speed up scope creation, `AllScope` was removed from most default aliases. `AllScope` was left
for a few frequently used aliases where the lookup was faster.

### `-Verbose` and `-Debug` no longer overrides `$ErrorActionPreference`

Previously, if `-Verbose` or `-Debug` were specified, it overrode the behavior of
`$ErrorActionPreference`. With this change, `-Verbose` and `-Debug` no longer affect the behavior of
`$ErrorActionPreference`.

Also, the `-Debug` parameter sets `$DebugPreference` to **Continue** instead of **Inquire**.

### Make `$PSCulture` consistently reflect in-session culture changes

In Windows PowerShell, the current culture value is cached, which can allow the value to get out of
sync with the culture is change after session-startup. This caching behavior is fixed in PowerShell
core.

### Allow explicitly specified named parameter to supersede the same one from hashtable splatting

With this change, the named parameters from splatting are moved to the end of the parameter list so
that they are bound after all explicitly specified named parameters are bound. Parameter binding for
simple functions doesn't throw an error when a specified named parameter cannot be found. Unknown
named parameters are bound to the `$args` parameter of the simple function. Moving splatting to the
end of the argument list changes the order the parameters appears in `$args`.

For example:

```powershell
function SimpleTest {
    param(
        $Name,
        $Path
    )
    "Name: $Name; Path: $Path; Args: $args"
}
```

In the previous behavior, **MyPath** is not bound to `-Path` because it's the third argument in the
argument list. ## So it ends up being stuffed into '$args' along with `Blah = "World"`

```powershell
PS> $hash = @{ Name = "Hello"; Blah = "World" }
PS> SimpleTest @hash "MyPath"
Name: Hello; Path: ; Args: -Blah: World MyPath
```

With this change, the arguments from `@hash` are moved to the end of the argument list. **MyPath**
becomes the first argument in the list, so it is bound to `-Path`.

```powershell
PS> SimpleTest @hash "MyPath"
Name: Hello; Path: MyPath; Args: -Blah: World
```

## Language changes

### Null-coalescing operator `??`

The null-coalescing operator `??` returns the value of its left-hand operand if it isn't null.
Otherwise, it evaluates the right-hand operand and returns its result. The `??` operator doesn't
evaluate its right-hand operand if the left-hand operand evaluates to non-null.

```powershell
$x = $null
$x ?? 100
```

```Output
100
```

In the following example, the right-hand operand won't be evaluated.

```powershell
[string] $todaysDate = '1/10/2020'
$todaysDate ?? (Get-Date).ToShortDateString()
```

```Output
1/10/2020
```

### Null-coalescing assignment operator `??=`

The null-coalescing assignment operator `??=` assigns the value of its right-hand operand to its
left-hand operand only if the left-hand operand evaluates to null. The `??=` operator doesn't
evaluate its right-hand operand if the left-hand operand evaluates to non-null.

```powershell
$x = $null
$x ??= 100
$x
```

```Output
100
```

In the following example, the right-hand operand won't be evaluated.

```powershell
[string] $todaysDate = '1/10/2020'
$todaysDate ??= (Get-Date).ToShortDateString()
```

```Output
1/10/2020
```

### Null-conditional operators

> [!NOTE]
> This feature was moved from experimental to mainstream in PowerShell 7.1.

A null-conditional operator applies a member access, `?.`, or element access, `?[]`, operation to
its operand only if that operand evaluates to non-null; otherwise, it returns null.

Since PowerShell allows `?` to be part of the variable name, formal specification of the variable
name is required for using these operators. So it is required to use `{}` around the variable names
like `${a}` or when `?` is part of the variable name `${a?}`.

In the following example, the value of **PropName** is returned.

```powershell
$a = @{ PropName = 100 }
${a}?.PropName
```

```Output
100
```

The following example will return null, without trying to access the member
name **PropName**.

```powershell
$a = $null
${a}?.PropName
```

Similarly, the value of the element will be returned.

```powershell
$a = 1..10
${a}?[0]
```

```Output
1
```

And when the operand is null, the element isn't accessed and null is returned.

```PowerShell
$a = $null
${a}?[0]
```

> [!NOTE]
> The variable name syntax of `${<name>}` should not be confused with the `$()` subexpression
> operator. For more information, see Variable name section of [about_Variables][08].

### Added `&` operator for job control

Putting `&` at the end of a pipeline causes the pipeline to be run as a PowerShell job. When a
pipeline is backgrounded, a job object is returned. Once the pipeline is running as a job, all of
the standard `*-Job` cmdlets can be used to manage the job. Variables (ignoring process-specific
variables) used in the pipeline are automatically copied to the job so `Copy-Item $foo $bar &` just
works. The job is also run in the current directory instead of the user's home directory.

### New methods/properties on `PSCustomObject`

We've added new methods and properties to `PSCustomObject`. `PSCustomObject` now includes a
`Count`/`Length` property like other objects.

```powershell
$PSCustomObject = [pscustomobject]@{foo = 1}

$PSCustomObject.Length
```

```Output
1
```

```powershell
$PSCustomObject.Count
```

```Output
1
```

This work also includes `ForEach` and `Where` methods that allow you to operate and filter on
`PSCustomObject` items:

```powershell
$PSCustomObject.ForEach({$_.foo + 1})
```

```Output
2
```

```powershell
$PSCustomObject.Where({$_.foo -gt 0})
```

```Output
foo
---
  1
```

### Conversions from PSMethod to Delegate

You can convert a `PSMethod` into a delegate. This allows you to do things like passing `PSMethod`
`[M]::DoubleStrLen` as a delegate value into `[M]::AggregateString`:

```powershell
class M {
    static [int] DoubleStrLen([string] $value) { return 2 * $value.Length }

    static [long] AggregateString([string[]] $values, [func[string, int]] $selector) {
        [long] $res = 0
        foreach($s in $values){
            $res += $selector.Invoke($s)
        }
        return $res
    }
}

[M]::AggregateString((gci).Name, [M]::DoubleStrLen)
```

### String comparison behavior changed in PowerShell 7.1

PowerShell 7.1 is built on .NET 5.0, which introduced the following breaking change:

- [Behavior changes when comparing strings on .NET 5+][05]

As of .NET 5.0, culture invariant string comparisons ignore non-printing control characters.

For example, the following two strings are considered to be identical:

```powershell
# Escape sequence "`a" is Ctrl-G or [char]7
'Food' -eq "Foo`ad"
```

```Output
True
```

## New cmdlets

### New Get-Uptime cmdlet

The [Get-Uptime][19] cmdlet returns the time elapsed since the last boot of the operating system.
The cmdlet was introduced in PowerShell 6.0.

### New Remove-Alias cmdlet

The [Remove-Alias][21] cmdlet removes an alias from the current PowerShell session. The cmdlet was
introduced in PowerShell 6.0.

### New cmdlet Remove-Service

The [Remove-Service][15] cmdlet removes a Windows service in the registry and in the service
database. The `Remove-Service` cmdlet was introduced in PowerShell 6.0.

### New Markdown cmdlets

Markdown is a standard for creating readable plaintext documents with basic formatting that can be
rendered into HTML.

The following cmdlets were added in PowerShell 6.1:

- [ConvertFrom-Markdown][16] - Convert the contents of a string or a file to a **MarkdownInfo**
  object.
- [Get-MarkdownOption][18] - Returns the current colors and styles used for rendering Markdown
  content in the console.
- [Set-MarkdownOption][22] - Sets the colors and styles used for rendering Markdown content in the
  console.
- [Show-Markdown][23] - Displays Markdown content in the console or as HTML

### New Test-Json cmdlet

The [Test-Json][24] cmdlet tests whether a string is a valid JavaScript Object Notation (JSON)
document and can optionally verify that JSON document against a provided schema.

This cmdlet was introduced in PowerShell 6.1

### New cmdlets to support Experimental Features

The following cmdlets were added in PowerShell 6.2 to support Experimental Features.

- [Disable-ExperimentalFeature][10]
- [Enable-ExperimentalFeature][11]
- [Get-ExperimentalFeature][13]

### New Join-String cmdlet

The [Join-String][20] cmdlet combines objects from the pipeline into a single string. This cmdlet
was added in PowerShell 6.2.

### New view ConciseView and cmdlet Get-Error

PowerShell 7.0 enhances the display of error messages to improve the readability of interactive and
script errors with a new default view, **ConciseView**. The views are user-selectable through the
preference variable `$ErrorView`.

With **ConciseView**, if an error is not from a script or parser error, then it's a single line
error message:

```powershell
Get-Childitem -Path c:\NotReal
```

```Output
Get-ChildItem: Cannot find path 'C:\NotReal' because it does not exist
```

If the error occurs during script execution or is a parsing error, PowerShell returns a multiline
error message that contains the error, a pointer, and an error message showing where the error is in
that line. If the terminal doesn't support ANSI color escape sequences (VT100), then colors are not
displayed.

The default view in PowerShell 7 is **ConciseView**. The previous default view was **NormalView**
and you can select this by setting the preference variable `$ErrorView`.

```powershell
$ErrorView = 'NormalView' # Sets the error view to NormalView
$ErrorView = 'ConciseView' # Sets the error view to ConciseView
```

> [!NOTE]
> A new property **ErrorAccentColor** is added to `$Host.PrivateData` to support changing the accent
> color of the error message.

The new `Get-Error`cmdlet provides a complete detailed view of the fully qualified error when
desired. By default the cmdlet displays the full details, including inner exceptions, of the last
error that occurred.

The `Get-Error` cmdlet supports input from the pipeline using the built-in variable `$Error`.
`Get-Error` displays all piped errors.

```powershell
$Error | Get-Error
```

The `Get-Error` cmdlet supports the **Newest** parameter, allowing you to specify how many errors
from the current session you wish displayed.

```powershell
Get-Error -Newest 3 # Displays the lst three errors that occurred in the session
```

For more information, see [Get-Error][17].

## Cmdlet changes

### Parallel execution added to ForEach-Object

Beginning in PowerShell 7.0, the `ForEach-Object` cmdlet, which iterates items in a collection, now
has built-in parallelism with the new **Parallel** parameter.

By default, parallel script blocks use the current working directory of the caller that started the
parallel tasks.

This example retrieves 50,000 log entries from 5 system logs on a local Windows machine:

```powershell
$logNames = 'Security','Application','System','Windows PowerShell','Microsoft-Windows-Store/Operational'

$logEntries = $logNames | ForEach-Object -Parallel {
    Get-WinEvent -LogName $_ -MaxEvents 10000
} -ThrottleLimit 5

$logEntries.Count

50000
```

The **Parallel** parameter specifies the script block that is run in parallel for each input log
name.

The new **ThrottleLimit** parameter limits the number of script blocks running in parallel at a
given time. The default is 5.

Use the `$_` variable to represent the current input object in the script block. Use the `$using:`
scope to pass variable references to the running script block.

For more information, see [ForEach-Object][12].

### Check `system32` for compatible built-in modules on Windows

In the Windows 10 1809 update and Windows Server 2019, we updated a number of built-in PowerShell
modules to mark them as compatible with PowerShell.

When PowerShell starts up, it automatically includes `$windir\System32` as part of the
`PSModulePath` environment variable. However, it only exposes modules to `Get-Module` and
`Import-Module` if its `CompatiblePSEdition` is marked as compatible with `Core`.

You can override this behavior to show all modules using the `-SkipEditionCheck` switch parameter.
We've also added a `PSEdition` property to the table output.

### `-lp` alias for all `-LiteralPath` parameters

We created a standard parameter alias `-lp` for all the built-in PowerShell cmdlets that have a
`-LiteralPath` parameter.

### Fix `Get-Item -LiteralPath a*b` if `a*b` doesn't actually exist to return error

Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard
found no files, it would silently exit. Correct behavior should be that `-LiteralPath` is literal so
if the file doesn't exist, it should error. Change is to treat wildcards used with `-Literal` as
literal.

### Set working directory to current directory in `Start-Job`

The `Start-Job` cmdlet now uses the current directory as the working directory for the new job.

### Remove `-Protocol` from `*-Computer` cmdlets

Due to issues with RPC remoting in CoreFX (particularly on non-Windows platforms) and ensuring a
consistent remoting experience in PowerShell, the `-Protocol` parameter was removed from the
`\*-Computer` cmdlets. DCOM is no longer supported for remoting. The following cmdlets only support
WSMAN remoting:

- `Rename-Computer`
- `Restart-Computer`
- `Stop-Computer`

### Remove `-ComputerName` from `*-Service` cmdlets

In order to encourage the consistent use of PSRP, the `-ComputerName` parameter was removed from
`*-Service` cmdlets.

### Fix `Get-Content -Delimiter` to not include the delimiter in the returned lines

Previously, the output while using `Get-Content -Delimiter` was inconsistent and inconvenient as it
required further processing of the data to remove the delimiter. This change removes the delimiter
in returned lines.

### Changes to `Format-Hex`

The `-Raw` parameter is now a "no-op" (in that it does nothing). Going forward all output is
displayed with a true representation of numbers that includes all of the bytes for its type. This is
what the `-Raw` parameter was doing prior to this change.

### Typo fix in Get-ComputerInfo property name

`BiosSerialNumber` was misspelled as `BiosSeralNumber` and has been changed to the correct spelling.

### Add `Get-StringHash` and `Get-FileHash` cmdlets

This change is that some hash algorithms are not supported by CoreFX, therefore they are no longer
available:

- `MACTripleDES`
- `RIPEMD160`

### Add validation on `Get-*` cmdlets where passing $null returns all objects instead of error

Passing `$null` to any of the following now throws an error:

- `Get-Credential -UserName`
- `Get-Event -SourceIdentifier`
- `Get-EventSubscriber -SourceIdentifier`
- `Get-Help -Name`
- `Get-PSBreakpoint -Script`
- `Get-PSProvider -PSProvider`
- `Get-PSSessionConfiguration -Name`
- `Get-Runspace -Name`
- `Get-RunspaceDebug -RunspaceName`
- `Get-Service -Name`
- `Get-TraceSource -Name`
- `Get-Variable -Name`

### Add support for the W3C Extended Log File Format in `Import-Csv`

Previously, the `Import-Csv` cmdlet cannot be used to directly import the log files in W3C extended
log format and additional action would be required. With this change, W3C extended log format is
supported.

### `Import-Csv` applies `PSTypeNames` upon import when type information is present in the CSV

Previously, objects exported using `Export-CSV` with `TypeInformation` imported with
`ConvertFrom-Csv` were not retaining the type information. This change adds the type information to
`PSTypeNames` member if available from the CSV file.

### `-NoTypeInformation` is the default on `Export-Csv`

Previously, the `Export-CSV` cmdlet would output a comment as the first line containing the type
name of the object. The change excludes the type information by default because it's not understood
by most CSV tools. This change was made to address customer feedback.

Use `-IncludeTypeInformation` to retain the previous behavior.

### Allow `*` to be used in registry path for `Remove-Item`

Previously, `-LiteralPath` given a wildcard would treat it the same as `-Path` and if the wildcard
found no files, it would silently exit. Correct behavior should be that `-LiteralPath` is literal so
if the file doesn't exist, it should error. Change is to treat wildcards used with `-Literal` as
literal.

### Group-Object now sorts the groups

As part of the performance improvement, `Group-Object` now returns a sorted listing of the groups.
Although you should not rely on the order, you could be broken by this change if you wanted the
first group. We decided that this performance improvement was worth the change since the impact of
being dependent on previous behavior is low.

### Standard deviation in `Measure-Object`

The output from `Measure-Object` now includes a `StandardDeviation` property.

```powershell
Get-Process | Measure-Object -Property CPU -AllStats
```

```Output
Count             : 308
Average           : 31.3720576298701
Sum               : 9662.59375
Maximum           : 4416.046875
Minimum           :
StandardDeviation : 264.389544720926
Property          : CPU
```

### `Get-PfxCertificate -Password`

`Get-PfxCertificate` now has the `Password` parameter, which takes a `SecureString`. This allows you
to use it non-interactively:

```powershell
$certFile = '\\server\share\pwd-protected.pfx'
$certPass = Read-Host -AsSecureString -Prompt 'Enter the password for certificate: '

$certThumbPrint = (Get-PfxCertificate -FilePath $certFile -Password $certPass ).ThumbPrint
```

### Removal of the `more` function

In the past, PowerShell shipped a function on Windows called `more` that wrapped `more.com`. That
function has now been removed.

Also, the `help` function changed to use `more.com` on Windows, or the system's default pager
specified by `$env:PAGER` on non-Windows platforms.

### `cd DriveName:` now returns users to the current working directory in that drive

Previously, using `Set-Location` or `cd` to return to a PSDrive sent users to the default location
for that drive. Users are now sent to the last known current working directory for that session.

### `cd -` returns to previous directory

```powershell
C:\Windows\System32> cd C:\
C:\> cd -
C:\Windows\System32>
```

Or on Linux:

```ShellSession
PS /etc> cd /usr/bin
PS /usr/bin> cd -
PS /etc>
```

Also, `cd` and `cd --` change to `$HOME`.

### `Update-Help` as non-admin

By popular demand, `Update-Help` no longer needs to be run as an administrator. `Update-Help` now
defaults to saving help to a user-scoped folder.

### `Where-Object -Not`

With the addition of `-Not` parameter to `Where-Object`, can filter an object at the pipeline for
the non-existence of a property, or a null/empty property value.

For example, this command returns all services that don't have any dependent services defined:

```powershell
Get-Service | Where-Object -Not DependentServices
```

## Changes to Web Cmdlets

The underlying .NET API of the Web Cmdlets has been changed to `System.Net.Http.HttpClient`. This
change provides many benefits. However, this change along with a lack of interoperability with
Internet Explorer have resulted in several breaking changes within `Invoke-WebRequest` and
`Invoke-RestMethod`.

- `Invoke-WebRequest` now supports basic HTML Parsing only. `Invoke-WebRequest` always returns a
  `BasicHtmlWebResponseObject` object. The `ParsedHtml` and `Forms` properties have been removed.
- `BasicHtmlWebResponseObject.Headers` values are now `String[]` instead of `String`.
- `BasicHtmlWebResponseObject.BaseResponse` is now a `System.Net.Http.HttpResponseMessage` object.
- The `Response` property on Web Cmdlet exceptions is now a `System.Net.Http.HttpResponseMessage`
  object.
- Strict RFC header parsing is now default for the `-Headers` and `-UserAgent` parameter. This can
  be bypassed with `-SkipHeaderValidation`.
- `file://` and `ftp://` URI schemes are no longer supported.
- `System.Net.ServicePointManager` settings are no longer honored.
- There is currently no certificate based authentication available on macOS.
- Use of `-Credential` over an `http://` URI will result in an error. Use an `https://` URI or
  supply the `-AllowUnencryptedAuthentication` parameter to suppress the error.
- `-MaximumRedirection` now produces a terminating error when redirection attempts exceed the
  provided limit instead of returning the results of the last redirection.
- In PowerShell 6.2, a change was made to default to UTF-8 encoding for JSON responses. When a
  charset is not supplied for a JSON response, the default encoding should be UTF-8 per RFC 8259.
- Default encoding set to UTF-8 for `application-json` responses
- Added `-SkipHeaderValidation` parameter to allow `Content-Type` headers that aren't
  standards-compliant
- Added `-Form` parameter to support simplified `multipart/form-data` support
- Compliant, case-insensitive handling of relation keys
- Added `-Resume` parameter for web cmdlets

### Invoke-RestMethod returns useful info when no data is returned

When an API returns just `null`, `Invoke-RestMethod` was serializing this as the string `"null"`
instead of `$null`. This change fixes the logic in `Invoke-RestMethod` to properly serialize a valid
single value JSON `null` literal as `$null`.

### Web Cmdlets warn when `-Credential` is sent over unencrypted connections

When using HTTP, content including passwords are sent as clear-text. This change is to not allow
this by default and return an error if credentials are being passed insecurely. Users can bypass
this by using the `-AllowUnencryptedAuthentication` switch.

### Make `-OutFile` parameter in web cmdlets to work like `-LiteralPath`

Beginning in PowerShell 7.1, the **OutFile** parameter of the web cmdlets works like **LiteralPath**
and does not process wildcards.

## API changes

### Remove `AddTypeCommandBase` class

The `AddTypeCommandBase` class was removed from `Add-Type` to improve performance. This class is
only used by the `Add-Type` cmdlet and should not impact users.

### Removed `VisualBasic` as a supported language in Add-Type

In the past, you could compile Visual Basic code using the `Add-Type` cmdlet. Visual Basic was
rarely used with `Add-Type`. We removed this feature to reduce the size of PowerShell.

### Removed `RunspaceConfiguration` support

Previously, when creating a PowerShell runspace programmatically using the API, you could use the
legacy [`RunspaceConfiguration`][02] or the newer [`InitialSessionState`][01] classes. This change
removed support for `RunspaceConfiguration` and only supports `InitialSessionState`.

### `CommandInvocationIntrinsics.InvokeScript` bind arguments to `$input` instead of `$args`

An incorrect position of a parameter resulted in the args passed as input instead of as args.

### Remove `ClrVersion` and `BuildVersion` properties from `$PSVersionTable`

The `ClrVersion` property of `$PSVersionTable` is not useful with CoreCLR. End users should not be
using that value to determine compatibility.

The `BuildVersion` property was tied to the Windows build version, which is not available on
non-Windows platforms. Use the `GitCommitId` property to retrieve the exact build version of
PowerShell.

### Implement Unicode escape parsing

`` `u####`` or `` `u{####}`` is converted to the corresponding Unicode character. To output a
literal `` `u``, escape the backtick: ``` ``u```.

### Parameter binding problem with `ValueFromRemainingArguments` in PS functions

`ValueFromRemainingArguments` now returns the values as an array instead of a single value which
itself is an array.

### Cleaned up uses of `CommandTypes.Workflow` and `WorkflowInfoCleaned`

Clean up code related to the uses of `CommandTypes.Workflow` and `WorkflowInfo` in
**System.Management.Automation**.

These minor breaking changes mainly affect help provider code.

- Change the public constructors of `WorkflowInfo` to internal. We don't support workflow anymore,
  so it makes sense to not allow people to create `Workflow` instances.
- Remove the type **System.Management.Automation.DebugSource** since it's only used for workflow
  debugging.
- Remove the overload of `SetParent` from the abstract class **Debugger** that is only used for
  workflow debugging.
- Remove the same overload of `SetParent` from the derived class **RemotingJobDebugger**.

### Do not wrap return result in `PSObject` when converting a `ScriptBlock` to a delegate

When a `ScriptBlock` is converted to a delegate type to be used in C# context, wrapping the result
in a `PSObject` brings unneeded troubles:

- When the value is converted to the delegate return type, the `PSObject` essentially gets
  unwrapped. So the `PSObject` is unneeded.
- When the delegate return type is `object`, it gets wrapped in a `PSObject` making it hard to work
  with in C# code.

After this change, the returned object is the underlying object.

## Remoting Support

PowerShell Remoting (PSRP) using WinRM on Unix platforms requires NTLM/Negotiate or Basic Auth over
HTTPS. PSRP on macOS only supports Basic Auth over HTTPS. Kerberos-based authentication is not
supported for non-Windows platforms.

PowerShell also supports PowerShell Remoting (PSRP) over SSH on all platforms (Windows, macOS, and
Linux). For more information, see [SSH remoting in PowerShell][25].

### PowerShell Direct for Containers tries to use `pwsh` first

[PowerShell Direct][31] is a feature of PowerShell and Hyper-V that allows you to connect to a
Hyper-V VM or Container without network connectivity or other remote management services.

In the past, PowerShell Direct connected using the built-in Windows PowerShell instance on the
Container. Now, PowerShell Direct first attempts to connect using any available `pwsh.exe` on the
`PATH` environment variable. If `pwsh.exe` isn't available, PowerShell Direct falls back to use
`powershell.exe`.

### `Enable-PSRemoting` now creates separate remoting endpoints for preview versions

`Enable-PSRemoting` now creates two remoting session configurations:

- One for the major version of PowerShell. For example, `PowerShell.6`. This endpoint that can be
  relied upon across minor version updates as the "system-wide" PowerShell 6 session configuration
- One version-specific session configuration, for example: `PowerShell.6.1.0`

This behavior is useful if you want to have multiple PowerShell 6 versions installed and accessible
on the same machine.

Additionally, preview versions of PowerShell now get their own remoting session configurations after
running the `Enable-PSRemoting` cmdlet:

```powershell
C:\WINDOWS\system32> Enable-PSRemoting
```

Your output may be different if you haven't set up WinRM before.

```Output
WinRM is already set up to receive requests on this computer.
WinRM is already set up for remote management on this computer.
```

Then you can see separate PowerShell session configurations for the preview and stable builds of
PowerShell 6, and for each specific version.

```powershell
Get-PSSessionConfiguration
```

```Output
Name          : PowerShell.6.2-preview.1
PSVersion     : 6.2
StartupScript :
RunAsUser     :
Permission    : NT AUTHORITY\INTERACTIVE AccessAllowed, BUILTIN\Administrators AccessAllowed, BUILTIN\Remote Management Users AccessAllowed

Name          : PowerShell.6-preview
PSVersion     : 6.2
StartupScript :
RunAsUser     :
Permission    : NT AUTHORITY\INTERACTIVE AccessAllowed, BUILTIN\Administrators AccessAllowed, BUILTIN\Remote Management Users AccessAllowed

Name          : powershell.6
PSVersion     : 6.1
StartupScript :
RunAsUser     :
Permission    : NT AUTHORITY\INTERACTIVE AccessAllowed, BUILTIN\Administrators AccessAllowed, BUILTIN\Remote Management Users AccessAllowed

Name          : powershell.6.1.0
PSVersion     : 6.1
StartupScript :
RunAsUser     :
Permission    : NT AUTHORITY\INTERACTIVE AccessAllowed, BUILTIN\Administrators AccessAllowed, BUILTIN\Remote Management Users AccessAllowed
```

### `user@host:port` syntax supported for SSH

SSH clients typically support a connection string in the format `user@host:port`. With the addition
of SSH as a protocol for PowerShell Remoting, we've added support for this format of connection
string:

`Enter-PSSession -HostName fooUser@ssh.contoso.com:2222`

## Telemetry can only be disabled with an environment variable

PowerShell sends basic telemetry data to Microsoft when it is launched. The data includes the OS
name, OS version, and PowerShell version. This data allows us to better understand the environments
where PowerShell is used and enables us to prioritize new features and fixes.

To opt-out of this telemetry, set the environment variable `POWERSHELL_TELEMETRY_OPTOUT` to `true`,
`yes`, or `1`. We no longer support deletion of the file
`DELETE_ME_TO_DISABLE_CONSOLEHOST_TELEMETRY` to disable telemetry.

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.initialsessionstate
[02]: https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspaceconfiguration
[03]: https://learn.microsoft.com/dotnet/core/compatibility/fx-core
[04]: https://learn.microsoft.com/dotnet/framework/windows-workflow-foundation/
[05]: https://learn.microsoft.com/dotnet/standard/base-types/string-comparison-net-5-plus
[06]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/About/about_Experimental_Features
[07]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pssnapins
[08]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_Variables#variable-names-that-include-special-characters
[09]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility
[10]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/Disable-ExperimentalFeature
[11]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/Enable-ExperimentalFeature
[12]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/foreach-object
[13]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/Get-ExperimentalFeature
[14]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/import-module
[15]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Management/Remove-Service
[16]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/ConvertFrom-Markdown
[17]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/get-error
[18]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Get-MarkdownOption
[19]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Get-Uptime
[20]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Join-String
[21]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Remove-Alias
[22]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Set-MarkdownOption
[23]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Show-Markdown
[24]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Test-Json
[25]: https://learn.microsoft.com/powershell/scripting/learn/remoting/SSH-Remoting-in-PowerShell-Core
[26]: https://learn.microsoft.com/previous-versions/powershell/scripting/components/workflows-guide
[27]: https://learn.microsoft.com/previous-versions/powershell/scripting/whats-new/what-s-new-in-powershell-71
[28]: https://learn.microsoft.com/previous-versions/powershell/scripting/whats-new/what-s-new-in-powershell-core-62?view=powershell-6&preserve-view=true
[29]: https://aka.ms/PSModuleCompat
[30]: https://devblogs.microsoft.com/dotnet/introducing-net-standard/
[31]: https://devblogs.microsoft.com/powershell/announcing-psdesiredstateconfiguration-on-powershell-gallery/
[32]: What-s-New-in-PowerShell-70.md
[33]: What-s-New-in-PowerShell-72.md
[34]: What-s-New-in-PowerShell-73.md
[35]: What-s-New-in-PowerShell-74.md
[36]: What-s-New-in-PowerShell-75.md

# /./reference/whats-new/unix-support.md

    ---
    description: This article summarizes the differences between PowerShell on Windows and PowerShell on non-Windows platforms.
    ms.date: 11/01/2022
    title: PowerShell differences on non-Windows platforms
    ---
# PowerShell differences on non-Windows platforms

PowerShell strives to provide feature parity across all supported platforms. But, due to differences
in .NET Core and platform-specific differences, some features behave differently or aren't
available. Additional changes have been made to improve interoperability of PowerShell on
non-Windows platforms.

## .NET Framework vs .NET Core

PowerShell on Linux and macOS uses .NET Core, which is a subset of the full .NET Framework on
Microsoft Windows. As a result, scripts that run on Windows may not run on non-Windows platforms
because of the differences in the frameworks.

For more information about changes in .NET Core, see
[Breaking changes for migration from .NET Framework to .NET Core][01].

## General Unix interoperability changes

- Added support for native command globbing on Unix platforms. This means you can
  use wildcards with native commands like `ls *.txt`.
- The `more` functionality respects the Linux `$PAGER` and defaults to `less`.
- Trailing backslash is automatically escaped when dealing with native command arguments.
- Fixed ConsoleHost to honor `NoEcho` on Unix platforms.
- don't add `PATHEXT` environment variable on Unix
- A `powershell` man-page is included in the package

## Execution policy

The `-ExecutionPolicy` parameter is ignored when running PowerShell on non-Windows platforms.
`Get-ExecutionPolicy` returns **Unrestricted** on Linux and macOS. `Set-ExecutionPolicy` does
nothing on Linux and macOS.

## Case-sensitivity in PowerShell

Historically, PowerShell has been uniformly case-insensitive, with few exceptions. On UNIX-like
operating systems, the file system is predominantly case-sensitive and PowerShell adheres to the
standard of the file system.

- When specifying a file in PowerShell, the correct case must be used.
- If a script tries to load a module and the module name isn't cased correctly, then the module load
  fails. This may cause a problem with existing scripts if the name by which the module is
  referenced doesn't match the proper case of the actual filename.
- While names in the filesystem are case-sensitive, tab-completion of filenames isn't
  case-sensitive. Tab-completion cycles through the list of names using case-insensitive matching.
- `Get-Help` supports case-insensitive pattern matching on Unix platforms.
- `Import-Module` is case insensitive when it's using a filename to determine the module's name.

## Filesystem support for Linux and macOS

- Paths given to cmdlets are now slash-agnostic (both / and \ work as directory separator)
- XDG Base Directory Specification is now respected and used by default:
  - The Linux/macOS profile path is located at `~/.config/powershell/profile.ps1`
  - The history save path is located at `~/.local/share/powershell/PSReadline/ConsoleHost_history.txt`
  - The user module path is located at `~/.local/share/powershell/Modules`
- Support for file and folder names containing the colon character on Unix.
- Support for script names or full paths that have commas.
- Detect when `-LiteralPath` is used to suppress wildcard expansion for navigation cmdlets.
- Updated `Get-ChildItem` to work more like the *nix `ls -R` and the Windows `DIR /S` native
  commands. `Get-ChildItem` now returns the symbolic links encountered during a recursive search and
  doesn't search the directories that those links target.

## .PS1 File Extensions

PowerShell scripts must end in `.ps1` for the interpreter to understand how to load and run them in
the current process. Running scripts in the current process is the expected usual behavior for
PowerShell. The `#!` magic number may be added to a script that doesn't have a `.ps1` extension, but
this causes the script to be run in a new PowerShell instance preventing the script from working
properly when interchanging objects. This may be the desirable behavior when executing a PowerShell
script from `bash` or another shell.

## Convenience aliases removed

On Windows, PowerShell provides a set of aliases that map to Linux command names for user
convenience. On Linux and macOS, the "convenience aliases" for the basic commands `ls`, `cp`, `mv`,
`rm`, `cat`, `man`, `mount`, `ps` have been removed to allow the native executable to run without
specifying a path.

## Logging

On macOS, PowerShell uses the native `os_log` APIs to log to Apple's [unified logging system][08].
On Linux, PowerShell uses [Syslog][09], a ubiquitous logging solution.

## Job Control

There is no Unix-style job-control support in PowerShell on Linux or macOS. The `fg` and `bg`
commands aren't available. You can use [PowerShell jobs][02] that do work across all platforms.

Putting `&` at the end of a pipeline causes the pipeline to be run as a PowerShell job. When a
pipeline is backgrounded, a job object is returned. Once the pipeline is running as a job, all
`*-Job` cmdlets can be used to manage the job. Variables (ignoring process-specific variables) used
in the pipeline are automatically copied to the job so `Copy-Item $foo $bar &` just works. The job
is also run in the current directory instead of the user's home directory.

## Remoting Support

PowerShell Remoting (PSRP) using WinRM on Unix platforms requires NTLM/Negotiate or Basic Auth over
HTTPS. PSRP on macOS only supports Basic Auth over HTTPS. Kerberos-based authentication isn't
supported.

PowerShell supports PowerShell Remoting (PSRP) over SSH on all platforms (Windows, macOS, and
Linux). For more information, see [SSH remoting in PowerShell][04].

## Just-Enough-Administration (JEA) Support

The ability to create constrained administration (JEA) remoting endpoints isn't available in
PowerShell on Linux or macOS.

## `sudo`, `exec`, and PowerShell

Because PowerShell runs most commands in memory (like Python or Ruby), you can't use sudo directly
with PowerShell built-ins. You can run `pwsh` from sudo. If it's necessary to run a PowerShell
cmdlet from within PowerShell with sudo, for example, `sudo Set-Date 8/18/2016`, then you would do
`sudo pwsh Set-Date 8/18/2016`.

## Missing Cmdlets

A large number of the commands (cmdlets) normally available in PowerShell aren't available on Linux
or macOS. In many cases, these commands make no sense on these platforms (e.g. Windows-specific
features like the registry). Other commands like the service control commands are present, but not
functional. Future releases may correct these problems by fixing the broken cmdlets and adding new
ones over time.

For a comprehensive list of modules and cmdlets and the platforms they support, see
[Release history of modules and cmdlets][05].

## Modules no longer shipped with PowerShell

For various compatibility reasons, the following modules are no longer included in PowerShell.

- ISE
- Microsoft.PowerShell.LocalAccounts
- Microsoft.PowerShell.ODataUtils
- Microsoft.PowerShell.Operation.Validation
- PSScheduledJob
- PSWorkflow
- PSWorkflowUtility

The following Windows-specific modules aren't included in PowerShell for Linux or macOS.

- CimCmdlets
- Microsoft.PowerShell.Diagnostics
- Microsoft.WSMan.Management
- PSDiagnostics

## Cmdlets not available on non-Windows platforms

For non-Windows platforms, PowerShell includes the following modules:

- Microsoft.PowerShell.Archive
- Microsoft.PowerShell.Core
- Microsoft.PowerShell.Host
- Microsoft.PowerShell.Management
- Microsoft.PowerShell.Security
- Microsoft.PowerShell.Utility
- PackageManagement
- PowerShellGet
- PSDesiredStateConfiguration
- PSReadLine
- ThreadJob

However, some cmdlets have been removed from PowerShell, and others aren't available or may work
differently on non-Windows platforms. For a comprehensive list of cmdlets removed from PowerShell,
see [Cmdlets removed from PowerShell][06].

### Microsoft.PowerShell.Core

The **ShowWindow** parameter of `Get-Help` isn't available for non-Windows platforms.

### Microsoft.PowerShell.Security cmdlets

The following cmdlets aren't available on Linux or macOS:

- `Get-Acl`
- `Set-Acl`
- `Get-AuthenticodeSignature`
- `Set-AuthenticodeSignature`
- `New-FileCatalog`
- `Test-FileCatalog`

These cmdlets are only available beginning in PowerShell 7.1.

- `Get-CmsMessage`
- `Protect-CmsMessage`
- `Unprotect-CmsMessage`

### Microsoft.PowerShell.Management cmdlets

The following cmdlets aren't available on Linux and macOS:

- `Clear-RecycleBin`
- `Get-HotFix`

The following cmdlets are available with limitations:

`Get-Clipboard` - available on Linux but not supported on macOS
`Set-Clipboard` - available in PowerShell 7.0+
`Restart-Computer` - available for Linux and macOS in PowerShell 7.1+
`Stop-Computer` - available for Linux and macOS in PowerShell 7.1+

### Microsoft.PowerShell.Utility cmdlets

The following cmdlets aren't available on Linux and macOS:

- `Convert-String`
- `ConvertFrom-String`
- `Out-GridView`
- `Out-Printer`
- `Show-Command`

## Aliases not available on Linux or macOS

The following table lists the aliases available for Windows that aren't available on non-Windows
platforms. These aliases aren't available because the target cmdlet isn't available or the alias
conflicts with a native command on those platforms.

|   Alias   |         Cmdlet         |
| --------- | ---------------------- |
| `ac`      | `Add-Content`          |
| `cat`     | `Get-Content`          |
| `clear`   | `Clear-Host`           |
| `cnsn`    | `Connect-PSSession`    |
| `compare` | `Compare-Object`       |
| `cp`      | `Copy-Item`            |
| `cpp`     | `Copy-ItemProperty`    |
| `diff`    | `Compare-Object`       |
| `dnsn`    | `Disconnect-PSSession` |
| `gsv`     | `Get-Service`          |
| `kill`    | `Stop-Process`         |
| `ls`      | `Get-ChildItem`        |
| `man`     | `help`                 |
| `mount`   | `New-PSDrive`          |
| `mv`      | `Move-Item`            |
| `ogv`     | `Out-GridView`         |
| `ps`      | `Get-Process`          |
| `rm`      | `Remove-Item`          |
| `rmdir`   | `Remove-Item`          |
| `sasv`    | `Start-Service`        |
| `shcm`    | `Show-Command`         |
| `sleep`   | `Start-Sleep`          |
| `sort`    | `Sort-Object`          |
| `spsv`    | `Stop-Service`         |
| `start`   | `Start-Process`        |
| `tee`     | `Tee-Object`           |
| `write`   | `Write-Output`         |

## PowerShell Desired State Configuration (DSC)

Many cmdlets were removed from the PSDesiredStateConfiguration module beginning in PowerShell 6.0.
Support for DSC on non-Windows platforms is limited and mostly experimental. The
`Invoke-DscResource` cmdlet was restored as an experimental feature in PowerShell 7.0.

DSC isn't supported on macOS.

For more information about using DSC on Linux, see [Get started with DSC for Linux][03].

Beginning with PowerShell 7.2, the **PSDesiredStateConfiguration** module has been removed from
PowerShell and is published to the PowerShell Gallery. For more information, see the
[announcement][07] in the PowerShell Team blog.

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/core/compatibility/fx-core
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_jobs
[03]: https://learn.microsoft.com/powershell/scripting/dsc/getting-started/lnxgettingstarted
[04]: https://learn.microsoft.com/powershell/scripting/learn/remoting/SSH-Remoting-in-PowerShell-Core
[05]: cmdlet-versions.md
[06]: differences-from-windows-powershell.md#cmdlets-removed-from-powershell
[07]: https://devblogs.microsoft.com/powershell/announcing-psdesiredstateconfiguration-on-powershell-gallery/
[08]: https://developer.apple.com/documentation/os/logging
[09]: https://en.wikipedia.org/wiki/Syslog

# /./reference/whats-new/cmdlet-versions.md

    ---
    description: This article lists the modules and cmdlets that are included in various versions of PowerShell.
    ms.date: 01/18/2024
    title: Release history of modules and cmdlets
    ---
# Release history of modules and cmdlets

This article lists the modules and cmdlets that are included in various versions of PowerShell. This
is a summary of information found in the release notes. More detailed information can be found in
the release notes:

- [What's new in PowerShell 7.5][32]
- [What's new in PowerShell 7.4][31]
- [What's new in PowerShell 7.3][30]
- [What's new in PowerShell 7.2][29]
- [What's new in PowerShell 7.1][04]
- [What's new in PowerShell 7.0][03]

This is a work in progress. Please help us keep this information fresh.

## Module release history

|             ModuleName / PSVersion              |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |                    Note                     |
| ----------------------------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ------------------------------------------- |
| [CimCmdlets][05]                                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                                |
| [ISE (introduced in 2.0)][06]                   | ![Included][01] |                 |                 |                 |                 | Windows only                                |
| [Microsoft.PowerShell.Archive][07]              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                             |
| [Microsoft.PowerShell.Core][08]                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                             |
| [Microsoft.PowerShell.Diagnostics][09]          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                                |
| [Microsoft.PowerShell.Host][10]                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                             |
| [Microsoft.PowerShell.LocalAccounts][11]        | ![Included][01] |                 |                 |                 |                 | Windows only (64-bit only)                  |
| [Microsoft.PowerShell.Management][12]           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                             |
| [Microsoft.PowerShell.ODataUtils][13]           | ![Included][01] |                 |                 |                 |                 | Windows only                                |
| [Microsoft.PowerShell.Operation.Validation][14] | ![Included][01] |                 |                 |                 |                 | Windows only                                |
| [Microsoft.PowerShell.PSResourceGet][15]        |                 |                 |                 | ![Included][01] | ![Included][01] | New versions available from the Gallery     |
| [Microsoft.PowerShell.Security][16]             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                             |
| [Microsoft.PowerShell.Utility][17]              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                             |
| [Microsoft.WsMan.Management][18]                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                                |
| [PackageManagement][19]                         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                             |
| [PowershellGet 1.1][20]                         | ![Included][01] |                 |                 |                 |                 | Must upgrade to v2.x                        |
| [PowershellGet 2.x][20]                         |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | New versions available from the Gallery     |
| [PSDesiredStateConfiguration 1.1][21]           | ![Included][01] |                 |                 |                 |                 | Removed in 7.2 - available from the Gallery |
| [PSDesiredStateConfiguration 2.x][22]           |                 | ![Removed][02]  |                 |                 |                 | Removed in 7.2 - available from the Gallery |
| [PSDesiredStateConfiguration 3.x][23]           |                 |                 |                 |                 |                 | Preview available from the Gallery          |
| [PSDiagnostics][24]                             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                                |
| [PSReadLine][25]                                | v1.x            | v2.1            | v2.2.6          | v2.3.4          | v2.3.4          | New versions available from the Gallery     |
| [PSScheduledJob][26]                            | ![Included][01] |                 |                 |                 |                 | Windows only                                |
| [PSWorkflow][27]                                | ![Included][01] |                 |                 |                 |                 | Windows only                                |
| [PSWorkflowUtility][27]                         | ![Included][01] |                 |                 |                 |                 | Windows only                                |
| [ThreadJob][28]                                 |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Can be installed in PowerShell 5.1          |

## Cmdlet release history

### CimCmdlets

|         Cmdlet name         |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |     Note     |
| --------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ------------ |
| Export-BinaryMiLog          | ![Included][01] |                 |                 |                 |                 | Windows only |
| Get-CimAssociatedInstance   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Get-CimClass                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Get-CimInstance             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Get-CimSession              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Import-BinaryMiLog          | ![Included][01] |                 |                 |                 |                 | Windows only |
| Invoke-CimMethod            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| New-CimInstance             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| New-CimSession              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| New-CimSessionOption        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Register-CimIndicationEvent | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Remove-CimInstance          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Remove-CimSession           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Set-CimInstance             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |

### ISE (introduced in 2.0)

This modules is only available in Windows PowerShell.

|    Cmdlet name    |       5.1       | Note |
| ----------------- | --------------- | ---- |
| Get-IseSnippet    | ![Included][01] |      |
| Import-IseSnippet | ![Included][01] |      |
| New-IseSnippet    | ![Included][01] |      |

### Microsoft.PowerShell.Archive

|   Cmdlet name    |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       | Note |
| ---------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ---- |
| Compress-Archive | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Expand-Archive   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |

### Microsoft.PowerShell.Core

|            Cmdlet name            |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |                    Note                    |
| --------------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ------------------------------------------ |
| Add-History                       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Add-PSSnapin                      | ![Included][01] |                 |                 |                 |                 | Windows only                               |
| Clear-History                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Clear-Host                        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Connect-PSSession                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Debug-Job                         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Disable-ExperimentalFeature       |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added in 6.2                               |
| Disable-PSRemoting                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Disable-PSSessionConfiguration    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Disconnect-PSSession              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Enable-ExperimentalFeature        |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added in 6.2                               |
| Enable-PSRemoting                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Enable-PSSessionConfiguration     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Enter-PSHostProcess               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added Linux support in 6.2                 |
| Enter-PSSession                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Exit-PSHostProcess                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added Linux support in 6.2                 |
| Exit-PSSession                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Export-Console                    | ![Included][01] |                 |                 |                 |                 | Windows only                               |
| Export-ModuleMember               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| ForEach-Object                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-Command                       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-ExperimentalFeature           |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added in 6.2                               |
| Get-Help                          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-History                       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-Job                           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-Module                        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-PSHostProcessInfo             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added Linux support in 6.2                 |
| Get-PSSession                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-PSSessionCapability           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-PSSessionConfiguration        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Get-PSSnapin                      | ![Included][01] |                 |                 |                 |                 | Windows only                               |
| Get-Verb                          | ![Included][01] |                 |                 |                 |                 | Moved to Microsoft.PowerShell.Utility 6.0+ |
| Import-Module                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Invoke-Command                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Invoke-History                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| New-Module                        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| New-ModuleManifest                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| New-PSRoleCapabilityFile          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| New-PSSession                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| New-PSSessionConfigurationFile    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added Linux support in 7.3                 |
| New-PSSessionOption               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| New-PSTransportOption             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Out-Default                       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Out-Host                          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Out-Null                          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Receive-Job                       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Receive-PSSession                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Register-ArgumentCompleter        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Register-PSSessionConfiguration   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Remove-Job                        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Remove-Module                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Remove-PSSession                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Remove-PSSnapin                   | ![Included][01] |                 |                 |                 |                 | Windows only                               |
| Resume-Job                        | ![Included][01] |                 |                 |                 |                 |                                            |
| Save-Help                         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Set-PSDebug                       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Set-PSSessionConfiguration        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Set-StrictMode                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Start-Job                         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Stop-Job                          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Switch-Process                    |                 |                 | ![Included][01] | ![Included][01] | ![Included][01] | Linux and macOS only                       |
| Suspend-Job                       | ![Included][01] |                 |                 |                 |                 | Windows only                               |
| Test-ModuleManifest               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Test-PSSessionConfigurationFile   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Unregister-PSSessionConfiguration | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                               |
| Update-Help                       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Wait-Job                          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |
| Where-Object                      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                            |

### Microsoft.PowerShell.Diagnostics

|  Cmdlet name   |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |     Note     |
| -------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ------------ |
| Export-Counter | ![Included][01] |                 |                 |                 |                 | Windows only |
| Get-Counter    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Get-WinEvent   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Import-Counter | ![Included][01] |                 |                 |                 |                 | Windows only |
| New-WinEvent   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |

### Microsoft.PowerShell.Host

|   Cmdlet name    |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       | Note |
| ---------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ---- |
| Start-Transcript | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Stop-Transcript  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |

### Microsoft.PowerShell.LocalAccounts (64-bit only)

This modules is only available in Windows PowerShell.

|       Cmdlet name       |       5.1       | Note |
| ----------------------- | --------------- | ---- |
| Add-LocalGroupMember    | ![Included][01] |      |
| Disable-LocalUser       | ![Included][01] |      |
| Enable-LocalUser        | ![Included][01] |      |
| Get-LocalGroup          | ![Included][01] |      |
| Get-LocalGroupMember    | ![Included][01] |      |
| Get-LocalUser           | ![Included][01] |      |
| New-LocalGroup          | ![Included][01] |      |
| New-LocalUser           | ![Included][01] |      |
| Remove-LocalGroup       | ![Included][01] |      |
| Remove-LocalGroupMember | ![Included][01] |      |
| Remove-LocalUser        | ![Included][01] |      |
| Rename-LocalGroup       | ![Included][01] |      |
| Rename-LocalUser        | ![Included][01] |      |
| Set-LocalGroup          | ![Included][01] |      |
| Set-LocalUser           | ![Included][01] |      |

### Microsoft.PowerShell.Management

|          Cmdlet name          |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |               Note               |
| ----------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | -------------------------------- |
| Add-Computer                  | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Add-Content                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Checkpoint-Computer           | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Clear-Content                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Clear-EventLog                | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Clear-Item                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Clear-ItemProperty            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Clear-RecycleBin              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Complete-Transaction          | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Convert-Path                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Copy-Item                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Copy-ItemProperty             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Debug-Process                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Disable-ComputerRestore       | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Enable-ComputerRestore        | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Get-ChildItem                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-Clipboard                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | NotsupportedonmacOS              |
| Get-ComputerInfo              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Get-ComputerRestorePoint      | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Get-Content                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-ControlPanelItem          | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Get-EventLog                  | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Get-HotFix                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Get-Item                      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-ItemProperty              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-ItemPropertyValue         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-Location                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-Process                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-PSDrive                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-PSProvider                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Get-Service                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Get-TimeZone                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Get-Transaction               | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Get-WmiObject                 | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Invoke-Item                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Invoke-WmiMethod              | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Join-Path                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Limit-EventLog                | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Move-Item                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Move-ItemProperty             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| New-EventLog                  | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| New-Item                      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| New-ItemProperty              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| New-PSDrive                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| New-Service                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| New-WebServiceProxy           | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Pop-Location                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Push-Location                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Register-WmiEvent             | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Remove-Computer               | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Remove-EventLog               | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Remove-Item                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Remove-ItemProperty           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Remove-PSDrive                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Remove-Service                |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Remove-WmiObject              | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Rename-Computer               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Rename-Item                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Rename-ItemProperty           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Reset-ComputerMachinePassword | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Resolve-Path                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Restart-Computer              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added Linux/macOS support in 7.1 |
| Restart-Service               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Restore-Computer              | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Resume-Service                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Set-Clipboard                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Set-Content                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Set-Item                      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Set-ItemProperty              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Set-Location                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Set-Service                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Set-TimeZone                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Set-WmiInstance               | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Show-ControlPanelItem         | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Show-EventLog                 | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Split-Path                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Start-Process                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Start-Service                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Start-Transaction             | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Stop-Computer                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added Linux/macOS support in 7.1 |
| Stop-Process                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Stop-Service                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Suspend-Service               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                     |
| Test-ComputerSecureChannel    | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Test-Connection               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Test-Path                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Undo-Transaction              | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Use-Transaction               | ![Included][01] |                 |                 |                 |                 | Windows only                     |
| Wait-Process                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                  |
| Write-EventLog                | ![Included][01] |                 |                 |                 |                 | Windows only                     |

### Microsoft.PowerShell.ODataUtils


This modules is only available in Windows PowerShell.

|        Cmdlet name        |       5.1       | Note |
| ------------------------- | --------------- | ---- |
| Export-ODataEndpointProxy | ![Included][01] |      |

### Microsoft.PowerShell.Operation.Validation

This modules is only available in Windows PowerShell.

|        Cmdlet name         |       5.1       | Note |
| -------------------------- | --------------- | ---- |
| Get-OperationValidation    | ![Included][01] |      |
| Invoke-OperationValidation | ![Included][01] |      |

### Microsoft.PowerShell.PSResourceGet

|           Cmdlet name           |       7.4       |       7.5       | Note |
| ------------------------------- | --------------- | --------------- | ---- |
| Get-PSResource                  | ![Included][01] | ![Included][01] |      |
| Import-PSGetRepository          | ![Included][01] | ![Included][01] |      |
| Find-PSResource                 | ![Included][01] | ![Included][01] |      |
| Get-InstalledPSResource         | ![Included][01] | ![Included][01] |      |
| Get-PSResourceRepository        | ![Included][01] | ![Included][01] |      |
| Get-PSScriptFileInfo            | ![Included][01] | ![Included][01] |      |
| Install-PSResource              | ![Included][01] | ![Included][01] |      |
| New-PSScriptFileInfo            | ![Included][01] | ![Included][01] |      |
| Publish-PSResource              | ![Included][01] | ![Included][01] |      |
| Register-PSResourceRepository   | ![Included][01] | ![Included][01] |      |
| Save-PSResource                 | ![Included][01] | ![Included][01] |      |
| Set-PSResourceRepository        | ![Included][01] | ![Included][01] |      |
| Test-PSScriptFileInfo           | ![Included][01] | ![Included][01] |      |
| Uninstall-PSResource            | ![Included][01] | ![Included][01] |      |
| Unregister-PSResourceRepository | ![Included][01] | ![Included][01] |      |
| Update-PSModuleManifest         | ![Included][01] | ![Included][01] |      |
| Update-PSResource               | ![Included][01] | ![Included][01] |      |
| Update-PSScriptFileInfo         | ![Included][01] | ![Included][01] |      |

### Microsoft.PowerShell.Security

|        Cmdlet name        |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |                  Note                   |
| ------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | --------------------------------------- |
| ConvertFrom-SecureString  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                         |
| ConvertTo-SecureString    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                         |
| Get-Acl                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                            |
| Get-AuthenticodeSignature | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                            |
| Get-CmsMessage            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Support for Linux/macOS added in 7.1    |
| Get-Credential            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                         |
| Get-ExecutionPolicy       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Returns **Unrestricted** on Linux/macOS |
| Get-PfxCertificate        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                         |
| New-FileCatalog           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                            |
| Protect-CmsMessage        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Support for Linux/macOS added in 7.1    |
| Set-Acl                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                            |
| Set-AuthenticodeSignature | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                            |
| Set-ExecutionPolicy       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Does nothing on Linux/macOS             |
| Test-FileCatalog          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                            |
| Unprotect-CmsMessage      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Support for Linux/macOS added in 7.1    |

### Microsoft.PowerShell.Utility

|        Cmdlet name        |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |                   Note                    |
| ------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ----------------------------------------- |
| Add-Member                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Add-Type                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Clear-Variable            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Compare-Object            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| ConvertFrom-Csv           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| ConvertFrom-Json          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| ConvertFrom-Markdown      |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added in 6.1                              |
| ConvertFrom-SddlString    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                              |
| ConvertFrom-String        | ![Included][01] |                 |                 |                 |                 |                                           |
| ConvertFrom-StringData    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Convert-String            | ![Included][01] |                 |                 |                 |                 |                                           |
| ConvertTo-Csv             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| ConvertTo-Html            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| ConvertTo-Json            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| ConvertTo-Xml             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Debug-Runspace            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Disable-PSBreakpoint      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Disable-RunspaceDebug     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Enable-PSBreakpoint       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Enable-RunspaceDebug      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Export-Alias              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Export-Clixml             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Export-Csv                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Export-FormatData         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Export-PSSession          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Format-Custom             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Format-Hex                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Format-List               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Format-Table              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Format-Wide               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Alias                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Culture               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Date                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Error                 |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Event                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | No event sources available on Linux/macOS |
| Get-EventSubscriber       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-FileHash              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-FormatData            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Host                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-MarkdownOption        |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added in 6.1                              |
| Get-Member                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-PSBreakpoint          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-PSCallStack           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Random                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Runspace              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-RunspaceDebug         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-SecureRandom          |                 |                 |                 | ![Included][01] | ![Included][01] | Added in 7.4                              |
| Get-TraceSource           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-TypeData              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-UICulture             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Unique                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Uptime                |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Variable              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Get-Verb                  |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Moved from Microsoft.PowerShell.Core      |
| Group-Object              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Import-Alias              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Import-Clixml             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Import-Csv                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Import-LocalizedData      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Import-PowerShellDataFile | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Import-PSSession          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Invoke-Expression         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Invoke-RestMethod         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Invoke-WebRequest         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Join-String               |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Measure-Command           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Measure-Object            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| New-Alias                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| New-Event                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | No event sources available on Linux/macOS |
| New-Guid                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| New-Object                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| New-TemporaryFile         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| New-TimeSpan              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| New-Variable              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Out-File                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Out-GridView              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                              |
| Out-Printer               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                              |
| Out-String                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Read-Host                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Register-EngineEvent      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | No event sources available on Linux/macOS |
| Register-ObjectEvent      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Remove-Alias              |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Remove-Event              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | No event sources available on Linux/macOS |
| Remove-PSBreakpoint       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Remove-TypeData           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Remove-Variable           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Select-Object             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Select-String             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Select-Xml                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Send-MailMessage          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Set-Alias                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Set-Date                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Set-MarkdownOption        |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added in 6.1                              |
| Set-PSBreakpoint          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Set-TraceSource           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Set-Variable              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Show-Command              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only                              |
| Show-Markdown             |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added in 6.1                              |
| Sort-Object               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Start-Sleep               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Tee-Object                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Test-Json                 |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Trace-Command             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Unblock-File              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Added support for macOS in 7.0            |
| Unregister-Event          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | No event sources available on Linux/macOS |
| Update-FormatData         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Update-List               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Update-TypeData           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Wait-Debugger             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Wait-Event                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Debug               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Error               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Host                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Information         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Output              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Progress            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Verbose             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |
| Write-Warning             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |                                           |

### Microsoft.WsMan.Management

|      Cmdlet name       |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |     Note     |
| ---------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ------------ |
| Connect-WSMan          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Disable-WSManCredSSP   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Disconnect-WSMan       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Enable-WSManCredSSP    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Get-WSManCredSSP       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Get-WSManInstance      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Invoke-WSManAction     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| New-WSManInstance      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| New-WSManSessionOption | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Remove-WSManInstance   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Set-WSManInstance      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Set-WSManQuickConfig   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Test-WSMan             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |

### PackageManagement

|       Cmdlet name        |       5.1       |       7.2       |       7.3       |       7.4       |       7.4       |       7.5       | Note |
| ------------------------ | --------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ---- |
| Find-Package             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Find-PackageProvider     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-Package              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-PackageProvider      | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-PackageSource        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Import-PackageProvider   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Install-Package          | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Install-PackageProvider  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Register-PackageSource   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Save-Package             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Set-PackageSource        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Uninstall-Package        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Unregister-PackageSource | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |

### PowershellGet 2.x

|           Cmdlet name           |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       | Note |
| ------------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ---- |
| Find-Command                    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Find-DscResource                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Find-Module                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Find-RoleCapability             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Find-Script                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-CredsFromCredentialProvider |                 | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-InstalledModule             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-InstalledScript             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-PSRepository                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Install-Module                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Install-Script                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| New-ScriptFileInfo              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Publish-Module                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Publish-Script                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Register-PSRepository           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Save-Module                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Save-Script                     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Set-PSRepository                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Test-ScriptFileInfo             | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Uninstall-Module                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Uninstall-Script                | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Unregister-PSRepository         | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Update-Module                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Update-ModuleManifest           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Update-Script                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Update-ScriptFileInfo           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |

### PSDesiredStateConfiguration v1.1

This modules is only available from in Windows PowerShell.

|           Cmdlet name            |       5.1       | Note |
| -------------------------------- | --------------- | ---- |
| Configuration                    | ![Included][01] |      |
| Disable-DscDebug                 | ![Included][01] |      |
| Enable-DscDebug                  | ![Included][01] |      |
| Get-DscConfiguration             | ![Included][01] |      |
| Get-DscConfigurationStatus       | ![Included][01] |      |
| Get-DscLocalConfigurationManager | ![Included][01] |      |
| Get-DscResource                  | ![Included][01] |      |
| Invoke-DscResource               | ![Included][01] |      |
| New-DSCCheckSum                  | ![Included][01] |      |
| Publish-DscConfiguration         | ![Included][01] |      |
| Remove-DscConfigurationDocument  | ![Included][01] |      |
| Restore-DscConfiguration         | ![Included][01] |      |
| Set-DscLocalConfigurationManager | ![Included][01] |      |
| Start-DscConfiguration           | ![Included][01] |      |
| Stop-DscConfiguration            | ![Included][01] |      |
| Test-DscConfiguration            | ![Included][01] |      |
| Update-DscConfiguration          | ![Included][01] |      |

### PSDesiredStateConfiguration v2.0.5

This modules is only available from the PowerShell Gallery.

|    Cmdlet name     |      2.0.5      |     Note     |
| ------------------ | --------------- | ------------ |
| Configuration      | ![Included][01] |              |
| Get-DscResource    | ![Included][01] |              |
| Invoke-DscResource | ![Included][01] | Experimental |
| New-DSCCheckSum    | ![Included][01] |              |

### PSDesiredStateConfiguration v3.x - Preview

This modules is only available from the PowerShell Gallery.

|       Cmdlet name       |  3.0 (preview)  |     Note     |
| ----------------------- | --------------- | ------------ |
| Configuration           | ![Included][01] |              |
| ConvertTo-DscJsonSchema | ![Included][01] |              |
| Get-DscResource         | ![Included][01] |              |
| Invoke-DscResource      | ![Included][01] |              |
| New-DscChecksum         | ![Included][01] |              |

### PSDiagnostics

|         Cmdlet name          |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       |     Note     |
| ---------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ------------ |
| Disable-PSTrace              | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Disable-PSWSManCombinedTrace | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Disable-WSManTrace           | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Enable-PSTrace               | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Enable-PSWSManCombinedTrace  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Enable-WSManTrace            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Get-LogProperties            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Set-LogProperties            | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Start-Trace                  | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |
| Stop-Trace                   | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Windows only |

### PSReadLine

|         Cmdlet name         |       5.1       |       7.2       |       7.3       |       7.4       |       7.5       | Note |
| --------------------------- | --------------- | --------------- | --------------- | --------------- | --------------- | ---- |
| Get-PSReadLineKeyHandler    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Get-PSReadLineOption        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| PSConsoleHostReadLine       | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Remove-PSReadLineKeyHandler | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Set-PSReadLineKeyHandler    | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |
| Set-PSReadLineOption        | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] |      |

### PSScheduledJob

This modules is only available in Windows PowerShell.

|       Cmdlet name       |       5.1       | Note |
| ----------------------- | --------------- | ---- |
| Add-JobTrigger          | ![Included][01] |      |
| Disable-JobTrigger      | ![Included][01] |      |
| Disable-ScheduledJob    | ![Included][01] |      |
| Enable-JobTrigger       | ![Included][01] |      |
| Enable-ScheduledJob     | ![Included][01] |      |
| Get-JobTrigger          | ![Included][01] |      |
| Get-ScheduledJob        | ![Included][01] |      |
| Get-ScheduledJobOption  | ![Included][01] |      |
| New-JobTrigger          | ![Included][01] |      |
| New-ScheduledJobOption  | ![Included][01] |      |
| Register-ScheduledJob   | ![Included][01] |      |
| Remove-JobTrigger       | ![Included][01] |      |
| Set-JobTrigger          | ![Included][01] |      |
| Set-ScheduledJob        | ![Included][01] |      |
| Set-ScheduledJobOption  | ![Included][01] |      |
| Unregister-ScheduledJob | ![Included][01] |      |

### PSWorkflow & PSWorkflowUtility

This modules is only available in Windows PowerShell.

|          Cmdlet name          |       5.1       | Note |
| ----------------------------- | --------------- | ---- |
| New-PSWorkflowExecutionOption | ![Included][01] |      |
| New-PSWorkflowSession         | ![Included][01] |      |
| Invoke-AsWorkflow             | ![Included][01] |      |

### ThreadJob

|   Cmdlet name   | 5.1 |       7.2       |       7.3       |       7.4       |       7.5       |                Note                |
| --------------- | --- | --------------- | --------------- | --------------- | --------------- | ---------------------------------- |
| Start-ThreadJob |     | ![Included][01] | ![Included][01] | ![Included][01] | ![Included][01] | Can be installed in PowerShell 5.1 |

<!-- link references -->
[01]: https://learn.microsoft.com/en-us/powershell/media/shared/check-mark-button-2705.svg
[02]: https://learn.microsoft.com/en-us/powershell/media/shared/cross-mark-274c.svg
[03]: https://learn.microsoft.com/previous-versions/powershell/scripting/whats-new/what-s-new-in-powershell-70
[04]: https://learn.microsoft.com/previous-versions/powershell/scripting/whats-new/what-s-new-in-powershell-71
[05]: #cimcmdlets
[06]: #ise-introduced-in-20
[07]: #microsoftpowershellarchive
[08]: #microsoftpowershellcore
[09]: #microsoftpowershelldiagnostics
[10]: #microsoftpowershellhost
[11]: #microsoftpowershelllocalaccounts-64-bit-only
[12]: #microsoftpowershellmanagement
[13]: #microsoftpowershellodatautils
[14]: #microsoftpowershelloperationvalidation
[15]: #microsoftpowershellpsresourceget
[16]: #microsoftpowershellsecurity
[17]: #microsoftpowershellutility
[18]: #microsoftwsmanmanagement
[19]: #packagemanagement
[20]: #powershellget-2x
[21]: #psdesiredstateconfiguration-v11
[22]: #psdesiredstateconfiguration-v205
[23]: #psdesiredstateconfiguration-v3x---preview
[24]: #psdiagnostics
[25]: #psreadline
[26]: #psscheduledjob
[27]: #psworkflow--psworkflowutility
[28]: #threadjob
[29]: what-s-new-in-powershell-72.md
[30]: what-s-new-in-powershell-73.md
[31]: what-s-new-in-powershell-74.md
[32]: what-s-new-in-powershell-75.md

# /./reference/whats-new/module-compatibility.md

    ---
    description: This article lists the compatibility status of modules published for other Microsoft products with PowerShell 7.
    ms.date: 06/28/2023
    title: PowerShell 7 module compatibility
    ---
# PowerShell 7 module compatibility

This article contains a partial list of PowerShell modules published by Microsoft.

The PowerShell team is working with the various feature teams that create PowerShell modules to help
them produce modules that work in PowerShell 7. These modules are not owned by the PowerShell team.

The following modules are known to support PowerShell 7.

## Azure PowerShell

The Az PowerShell module is a set of cmdlets for managing Azure resources directly from PowerShell.
PowerShell 7.0.6 LTS or higher is the recommended version of PowerShell for use with the Azure Az
PowerShell module on all platforms.

For more information, see [Introducing the Azure Az PowerShell module][02].

## MSGraph PowerShell SDK

The Microsoft Graph SDKs are designed to simplify building high-quality, efficient, and resilient
applications that access Microsoft Graph. PowerShell 7 and later is the recommended PowerShell
version for use with the Microsoft Graph PowerShell SDK.

For more information, see [Install the Microsoft Graph PowerShell SDK][01].

## Windows management modules

The Windows management modules provide management and support for various Windows features and
services. Most of these modules have been updated to work natively with PowerShell 7, or tested for
compatibility with PowerShell 7.

These modules are installed in different ways depending on the Edition of Windows, and how the
module is packaged for that Edition.

For more information about installation and compatibility, see
[PowerShell 7 module compatibility][05] in the Windows documentation.

## Exchange Online Management 2.0

The Exchange Online PowerShell V2 module (EXO V2) connects to all Exchange-related PowerShell
environments in Microsoft 365: Exchange Online PowerShell, Security & Compliance PowerShell, and
standalone Exchange Online Protection (EOP) PowerShell.

EXO v2.0.4 or later is supported in PowerShell 7.0.3 or later.

For more information, see [About the Exchange Online PowerShell V2 module][03].

## PowerShell modules for SQL Server

There are two SQL Server PowerShell modules:

- **SqlServer**: This module includes new cmdlets to support the latest SQL features, including
  updated versions of the cmdlets in SQLPS.
- **SQLPS**: The SQLPS is the module used by SQL Agent to run agent jobs in agent job steps using
  the PowerShell subsystem.

The SqlServer modules require PowerShell version 5.0 or greater.

For more information, see [Install the SQL Server PowerShell module][06].

## Finding the status of other modules

You can find a complete list of modules using the [PowerShell Module Browser][04]. Using the Module
Browser, you can find documentation for other PowerShell modules to determine their PowerShell
version requirements.

<!-- link references -->
[01]: https://learn.microsoft.com/graph/powershell/installation#supported-powershell-versions
[02]: https://learn.microsoft.com/powershell/azure/new-azureps-module-az
[03]: https://learn.microsoft.com/powershell/exchange/exchange-online-powershell-v2
[04]: https://learn.microsoft.com/powershell/module
[05]: https://learn.microsoft.com/powershell/windows/module-compatibility
[06]: https://learn.microsoft.com/sql/powershell/download-sql-server-ps-module

# /./reference/windows-powershell/ise/introducing-the-windows-powershell-ise.md

    ---
    description: The PowerShell ISE is a host application for Windows PowerShell that allows you to run commands and write, test, and debug scripts in a single Windows-based graphic user interface.
    ms.date: 10/07/2021
    ms.topic: overview
    title: Introducing the Windows PowerShell ISE
    ---

# The Windows PowerShell ISE

The Windows PowerShell Integrated Scripting Environment (ISE) is a host application for Windows
PowerShell. In the ISE, you can run commands and write, test, and debug scripts in a single
Windows-based graphic user interface. The ISE provides multiline editing, tab completion, syntax
coloring, selective execution, context-sensitive help, and support for right-to-left languages. Menu
items and keyboard shortcuts are mapped to many of the same tasks that you would do in the Windows
PowerShell console. For example, when you debug a script in the ISE, you can right-click on a line
of code in the edit pane to set a breakpoint.

## Support

The ISE was first introduced with Windows PowerShell V2 and was re-designed with PowerShell V3. The
ISE is supported in all supported versions of Windows PowerShell up to and including Windows
PowerShell V5.1.

> [!NOTE]
> The PowerShell ISE is no longer in active feature development. As a shipping component of
> Windows, it continues to be officially supported for security and high-priority servicing fixes.
> We currently have no plans to remove the ISE from Windows.
>
> There is no support for the ISE in PowerShell v6 and beyond. Users looking for replacement for the
> ISE should use [Visual Studio Code](https://code.visualstudio.com/) with the
> [PowerShell Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell).

## Key Features

Key features in Windows PowerShell ISE include:

- Multiline editing: To insert a blank line under the current line in the Command pane, press
  <kbd>SHIFT</kbd>+<kbd>ENTER</kbd>.
- Selective execution: To run part of a script, select the text you want to run, and then click the
  **Run Script** button. Or, press <kbd>F5</kbd>.
- Context-sensitive help: Type `Invoke-Item`, and then press <kbd>F1</kbd>. The Help file opens to
  the article for the `Invoke-Item` cmdlet.

The Windows PowerShell ISE lets you customize some aspects of its appearance. It also has its own
Windows PowerShell profile script.

## To start the Windows PowerShell ISE

Click **Start**, select **Windows PowerShell**, and then click **Windows PowerShell ISE**.
Alternately, you can type `powershell_ise.exe` in any command shell or in the Run box.

## To get Help in the Windows PowerShell ISE

On the **Help** menu, click **Windows PowerShell Help**. Or, press <kbd>F1</kbd>. The file that
opens describes Windows PowerShell ISE and Windows PowerShell, including all the help available from
the `Get-Help` cmdlet.

# /./reference/windows-powershell/ise/exploring-the-windows-powershell-ise.md

    ---
    description: This article is an overview of the features of the Windows PowerShell ISE
    ms.custom: ISE-F1-page
    ms.date: 05/04/2023
    ms.topic: ui-reference
    title: Exploring the Windows PowerShell ISE
    ---

# Exploring the Windows PowerShell ISE

You can use the Windows PowerShell Integrated Scripting Environment (ISE) to create, run, and debug
commands and scripts.

![Screenshot of the full ISE window.](https://learn.microsoft.com/en-us/powershell/docs-conceptual/windows-powershell/ise/media/exploring-the-windows-powershell-ise/full-ise-window.png)

The Windows PowerShell ISE consists of the menu bar, Windows PowerShell tabs,
the toolbar, script tabs, a Script Pane, a Console Pane, a status bar, a text-size slider and
context-sensitive Help.

## Menu Bar

The menu bar contains the **File**, **Edit**, **View**, **Tools**, **Debug**, **Add-ons**, and
**Help** menus.

![Screenshot of the menu bar.](https://learn.microsoft.com/en-us/powershell/docs-conceptual/windows-powershell/ise/media/exploring-the-windows-powershell-ise/ise-menu-bar.png)

The buttons on the menus allow you to perform tasks related to writing and running scripts and
running commands in the Windows PowerShell ISE. Additionally, an [add-on tool][11] may be placed on
the menu bar by running scripts that use the [The ISE Object Model Hierarchy][10].

## Toolbar

![Screenshot of the tool bar.](https://learn.microsoft.com/en-us/powershell/docs-conceptual/windows-powershell/ise/media/exploring-the-windows-powershell-ise/ise-tool-bar.png)

The following buttons are located on the toolbar.

|             Button             |                                                                                     Function                                                                                     |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **New**                        | Opens a new script.                                                                                                                                                              |
| **Open**                       | Opens an existing script or file.                                                                                                                                                |
| **Save**                       | Saves a script or file.                                                                                                                                                          |
| **Cut**                        | Cuts the selected text and copies it to the clipboard.                                                                                                                           |
| **Copy**                       | Copies the selected text to the clipboard.                                                                                                                                       |
| **Paste**                      | Pastes the contents of the clipboard at the cursor location.                                                                                                                     |
| **Clear Console Pane**         | Clears all content in the Console Pane.                                                                                                                                          |
| **Undo**                       | Reverses the action that was just performed.                                                                                                                                     |
| **Redo**                       | Performs the action that was just undone.                                                                                                                                        |
| **Run Script**                 | Runs a script.                                                                                                                                                                   |
| **Run Selection**              | Runs a selected portion of a script.                                                                                                                                             |
| **Stop Operation**             | Stops a script that's running.                                                                                                                                                   |
| **New Remote PowerShell Tab**  | Creates a new PowerShell Tab that establishes a session on a remote computer. A dialog box appears and prompts you to enter details required to establish the remote connection. |
| **Start PowerShell.exe**       | Opens a PowerShell Console.                                                                                                                                                      |
| **Show Script Pane Top**       | Moves the Script Pane to the top in the display.                                                                                                                                 |
| **Show Script Pane Right**     | Moves the Script Pane to the right in the display.                                                                                                                               |
| **Show Script Pane Maximized** | Maximizes the Script Pane.                                                                                                                                                       |
| **Show Command Window**        | Shows the Commands Pane for installed Modules, as a separate Window.                                                                                                             |
| **Show Command Add-on**        | Shows the Commands Pane for installed Modules, as a sidebar Add-on.                                                                                                              |

## Windows PowerShell Tabs

![Screenshot of the Windows PowerShell tabs.](https://learn.microsoft.com/en-us/powershell/docs-conceptual/windows-powershell/ise/media/exploring-the-windows-powershell-ise/ise-powershell-tabs.png)

A Windows PowerShell tab is the environment in which a Windows PowerShell script runs. You can open
new Windows PowerShell tabs in the Windows PowerShell ISE to create separate environments on your
local computer or on remote computers. You may have a maximum of eight PowerShell tabs
simultaneously open.

For more information, see [How to Create a PowerShell Tab in Windows PowerShell ISE][02].

## Script Tab

![Screenshot of the script tabs.](https://learn.microsoft.com/en-us/powershell/docs-conceptual/windows-powershell/ise/media/exploring-the-windows-powershell-ise/ise-script-tabs.png)

Displays the name of the script you are editing. You can click a script tab to select the script you
want to edit.

When you point to the script tab, the fully qualified path to the script file appears in a tooltip.

## Script Pane

![Screenshot of the panes and status bar.](https://learn.microsoft.com/en-us/powershell/docs-conceptual/windows-powershell/ise/media/exploring-the-windows-powershell-ise/ise-panes.png)

Allows you to create and run scripts. You can open, edit and run existing scripts in the Script
Pane. For more information, see [How to Write and Run Scripts in the Windows PowerShell ISE][07].

## Console Pane

Displays the results of the commands and scripts you have run. You can run commands in the Console
pane. You can also copy and clear the contents in the Console Pane.

For more information, see the following articles:

- [How to Use the Console Pane in the Windows PowerShell ISE][06]
- [How to Debug Scripts in Windows PowerShell ISE][03]
- [How to Use Tab Completion in the Script Pane and Console Pane][05]

## Status Bar

Allows you to see whether the commands and scripts that you run are complete. The status bar is at
the bottom of the window. Selected portions of error messages are displayed on the status bar.

## Text-Size Slider

Increases or decreases the size of the text on the screen.

## Help

Help for Windows PowerShell ISE is available on Microsoft Learn. You can open the Help by clicking
**Windows PowerShell ISE Help** on the **Help** menu or by pressing the <kbd>F1</kbd> key anywhere
except when the cursor is on a cmdlet name in either the Script Pane or the Console Pane. From the
**Help** menu you can also run the `Update-Help` cmdlet, and display the Command Window which
assists you in constructing commands by showing you all the parameters for a cmdlet and enabling you
to fill in the parameters in an easy-to-use form.

## See Also

- [Introducing the Windows PowerShell ISE][08]
- [How to Use Profiles in Windows PowerShell ISE][04]
- [Accessibility in Windows PowerShell ISE][01]
- [Keyboard Shortcuts for the Windows PowerShell ISE][09]

<!-- link references -->
[01]: Accessibility-in-Windows-PowerShell-ISE.md
[02]: How-to-Create-a-PowerShell-Tab-in-Windows-PowerShell-ISE.md
[03]: How-to-Debug-Scripts-in-Windows-PowerShell-ISE.md
[04]: How-to-Use-Profiles-in-Windows-PowerShell-ISE.md
[05]: How-to-Use-Tab-Completion-in-the-Script-Pane-and-Console-Pane.md
[06]: How-to-Use-the-Console-Pane-in-the-Windows-PowerShell-ISE.md
[07]: How-to-Write-and-Run-Scripts-in-the-Windows-PowerShell-ISE.md
[08]: Introducing-the-Windows-PowerShell-ISE.md
[09]: Keyboard-Shortcuts-for-the-Windows-PowerShell-ISE.md
[10]: object-model/The-ISE-Object-Model-Hierarchy.md
[11]: object-model/The-ISEAddOnTool-Object.md

# /./reference/windows-powershell/ise/how-to-create-a-powershell-tab-in-windows-powershell-ise.md

    ---
    description: Tabs in the Windows PowerShell Integrated Scripting Environment (ISE) allow you to simultaneously create and use several execution environments within the same application. Each PowerShell tab corresponds to a separate execution environment or session.
    ms.date: 10/07/2021
    ms.topic: ui-reference
    title: How to Create a PowerShell Tab in Windows PowerShell ISE
    ---

# How to Create a PowerShell Tab in Windows PowerShell ISE

Tabs in the Windows PowerShell Integrated Scripting Environment (ISE) allow you to simultaneously
create and use several execution environments within the same application. Each PowerShell tab
corresponds to a separate execution environment or session.

> [!NOTE]
> Variables, functions, and aliases that you create in one tab do not carry over to another. They
> are different Windows PowerShell sessions.

Use the following steps to open or close a tab in Windows PowerShell. To rename a tab, set the
[DisplayName](object-model/The-PowerShellTab-Object.md#displayname) property on the Windows
PowerShell Tab scripting object.

## To create and use a new PowerShell Tab

On the **File** menu, click **New PowerShell Tab**. The new PowerShell tab always opens as the
active window. PowerShell tabs are incrementally numbered in the order that they are opened. Each
tab is associated with its own Windows PowerShell console window. You can have up to 32 PowerShell
tabs with their own session open at a time (this is limited to 8 on Windows PowerShell ISE 2.0.)

Note that clicking the **New** or **Open** icons on the toolbar does not create a new tab with a
separate session. Instead, those buttons open a new or existing script file on the currently active
tab with a session. You can have multiple script files open with each tab and session. The script
tabs for a session only appear below the session tabs when the associated session is active.

To make a PowerShell tab active, click the tab. To select from all PowerShell tabs that are open, on
the **View** menu, click the PowerShell tab you want to use.

## To create and use a new Remote PowerShell tab

On the **File** menu, click **New Remote PowerShell Tab** to establish a session on a remote
computer. A dialog box appears and prompts you to enter details required to establish the remote
connection. The remote tab functions just like a local PowerShell tab, but the commands and scripts
are run on the remote computer.

## To close a PowerShell Tab

To close a tab, you can use any of the following techniques:

- Click the tab that you want to close.

- On the **File** menu, click **Close PowerShell Tab**, or click the Close button (**X**) on an
  active tab to close the tab.

If you have unsaved files open in the PowerShell tab that you are closing, you are prompted to save
or discard them. For more information about how to save a script, see
[How to Save a Script](How-to-Write-and-Run-Scripts-in-the-Windows-PowerShell-ISE.md#how-to-save-a-script).

## See Also

- [Introducing the Windows PowerShell ISE](Introducing-the-Windows-PowerShell-ISE.md)
- [How to Use the Console Pane in the Windows PowerShell ISE](How-to-Use-the-Console-Pane-in-the-Windows-PowerShell-ISE.md)

# /./reference/windows-powershell/ise/how-to-debug-scripts-in-windows-powershell-ise.md

    ---
    description: This article describes how to debug scripts on a local computer by using the Windows PowerShell ISE visual debugging features.
    ms.date: 10/07/2021
    ms.topic: ui-reference
    title: How to Debug Scripts in Windows PowerShell ISE
    ---

# How to Debug Scripts in Windows PowerShell ISE

This article describes how to debug scripts on a local computer by using the Windows PowerShell
Integrated Scripting Environment (ISE) visual debugging features.

## How to manage breakpoints

A breakpoint is a designated spot in a script where you would like operation to pause so that you
can examine the current state of the variables and the environment in which your script is running.
Once your script is paused by a breakpoint, you can run commands in the Console Pane to examine the
state of your script. You can output variables or run other commands. You can even modify the value
of any variables that are visible to the context of the currently running script. After you have
examined what you want to see, you can resume operation of the script.

You can set three types of breakpoints in the Windows PowerShell debugging environment:

1. **Line breakpoint**. The script pauses when the designated line is reached during the operation
   of the script

1. **Variable breakpoint.** The script pauses whenever the designated variable's value changes.

1. **Command breakpoint.** The script pauses whenever the designated command is about to be run
   during the operation of the script. It can include parameters to further filter the breakpoint to
   only the operation you want. The command can also be a function you created.

Of these, in the Windows PowerShell ISE debugging environment, only line breakpoints can be set by
using the menu or the keyboard shortcuts. The other two types of breakpoints can be set, but they
are set from the Console Pane by using the
[Set-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Set-PSBreakpoint) cmdlet. This
section describes how you can perform debugging tasks in Windows PowerShell ISE by using the menus
where available, and perform a wider range of commands from the Console Pane by using scripting.

### To set a breakpoint

A breakpoint can be set in a script only after it has been saved. Right-click the line where you
want to set a line breakpoint, and then click **Toggle Breakpoint**. Or, click the line where you
want to set a line breakpoint, and press <kbd>F9</kbd> or, on the **Debug** menu, click **Toggle
Breakpoint**.

The following script is an example of how you can set a variable breakpoint from the Console Pane by
using the [Set-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Set-PSBreakpoint)
cmdlet.

```powershell
# This command sets a breakpoint on the Server variable in the Sample.ps1 script.
Set-PSBreakpoint -Script sample.ps1 -Variable Server
```

### List all breakpoints

Displays all breakpoints in the current Windows PowerShell session.

On the **Debug** menu, click **List Breakpoints**. The following script is an example of how you can
list all breakpoints from the Console Pane by using the
[Get-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Get-PSBreakpoint) cmdlet.

```powershell
# This command lists all breakpoints in the current session.
Get-PSBreakpoint
```

### Remove a breakpoint

Removing a breakpoint deletes it.

If you think you might want to use it again later, consider
[Disable a Breakpoint](#disable-a-breakpoint) it instead. Right-click the line where you want to
remove a breakpoint, and then click **ToggleBreakpoint**. Or, click the line where you want to
remove a breakpoint, and on the **Debug** menu, click **Toggle Breakpoint**. The following script is
an example of how to remove a breakpoint with a specified ID from the Console Pane by using the
[Remove-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Remove-PSBreakpoint) cmdlet.

```powershell
# This command deletes the breakpoint with breakpoint ID 2.
Remove-PSBreakpoint -Id 2
```

### Remove All Breakpoints

To remove all breakpoints defined in the current session, on the **Debug** menu, click **Remove All
Breakpoints**.

The following script is an example of how to remove all breakpoints from the Console Pane by using
the [Remove-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Remove-PSBreakpoint)
cmdlet.

```powershell
# This command deletes all of the breakpoints in the current session.
Get-PSBreakpoint | Remove-PSBreakpoint
```

### Disable a Breakpoint

Disabling a breakpoint does not remove it. It turns it off until it is enabled. To disable a
specific line breakpoint, right-click the line where you want to disable a breakpoint, and then
click **Disable Breakpoint**.

Or, click the line where you want to disable a breakpoint, and press <kbd>F9</kbd> or, on the
**Debug** menu, click **Disable Breakpoint**. The following script is an example of how you can
remove a breakpoint with a specified ID from the Console Pane using the
[Disable-PSBreakpoint](/powershell/module/microsoft.powershell.utility/disable-psbreakpoint) cmdlet.

```powershell
# This command disables the breakpoint with breakpoint ID 0.
Disable-PSBreakpoint -Id 0
```

### Disable All Breakpoints

Disabling a breakpoint does not remove it; it turns it off until it is enabled. To disable all
breakpoints in the current session, on the **Debug** menu, click **Disable all Breakpoints**. The
following script is an example of how you can disable all breakpoints from the Console Pane by using
the [Disable-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Disable-PSBreakpoint)
cmdlet.

```powershell
# This command disables all breakpoints in the current session.
# You can abbreviate this command as: "gbp | dbp".
Get-PSBreakpoint | Disable-PSBreakpoint
```

### Enable a Breakpoint

To enable a specific breakpoint, right-click the line where you want to enable a breakpoint, and
then click **Enable Breakpoint**. Or, click the line where you want to enable a breakpoint, and then
press <kbd>F9</kbd> or, on the **Debug** menu, click **Enable Breakpoint**. The following script is
an example of how you can enable specific breakpoints from the Console Pane by using the
[Enable-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Enable-PSBreakpoint) cmdlet.

```powershell
# This command enables breakpoints with breakpoint IDs 0, 1, and 5.
Enable-PSBreakpoint -Id 0, 1, 5
```

### Enable All Breakpoints

To enable all breakpoints defined in the current session, on the **Debug** menu, click **Enable all
Breakpoints**. The following script is an example of how you can enable all breakpoints from the
Console Pane by using the
[Enable-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Enable-PSBreakpoint) cmdlet.

```powershell
# This command enables all breakpoints in the current session.
# You can abbreviate the command by using their aliases: "gbp | ebp".
Get-PSBreakpoint | Enable-PSBreakpoint
```

## How to manage a debugging session

Before you start debugging, you must set one or more breakpoints. You cannot set a breakpoint unless
the script that you want to debug is saved. For directions on of how to set a breakpoint, see
[How to manage breakpoints](#how-to-manage-breakpoints) or
[Set-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Set-PSBreakpoint). After you
start debugging, you cannot edit a script until you stop debugging. A script that has one or more
breakpoints set is automatically saved before it is run.

### To start debugging

Press <kbd>F5</kbd> or, on the toolbar, click the **Run Script** icon, or on the **Debug** menu
click **Run/Continue**. The script runs until it encounters the first breakpoint. It pauses
operation there and highlights the line on which it paused.

### To continue debugging

Press <kbd>F5</kbd> or, on the toolbar, click the **Run Script** icon, or on the **Debug** menu,
click **Run/Continue** or, in the Console Pane, type `C` and then press <kbd>ENTER</kbd>. This
causes the script to continue running to the next breakpoint or to the end of the script if no
further breakpoints are encountered.

### To view the call stack

The call stack displays the current run location in the script. If the script is running in a
function that was called by a different function, then that is represented in the display by
additional rows in the output. The bottom-most row displays the original script and the line in it
in which a function was called. The next line up shows that function and the line in it in which
another function might have been called. The top-most row shows the current context of the current
line on which the breakpoint is set.

While paused, to see the current call stack, press <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>D</kbd> or,
on the **Debug** menu, click **Display Call Stack** or, in the Console Pane, type `K` and then press
<kbd>ENTER</kbd>.

### To stop debugging

Press <kbd>SHIFT</kbd>+<kbd>F5</kbd> or, on the **Debug** menu, click **Stop Debugger**, or, in the
Console Pane, type `Q` and then press <kbd>ENTER</kbd>.

## How to step over, step into, and step out while debugging

Stepping is the process of running one statement at a time. You can stop on a line of code, and
examine the values of variables and the state of the system. The following table describes common
debugging tasks such as stepping over, stepping into, and stepping out.

| Debugging Task |                                                                                                                   Description                                                                                                                    |                                                      How to accomplish it in PowerShell ISE                                                       |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Step Into**  | Executes the current statement and then stops at the next statement. If the current statement is a function or script call, then the debugger steps into that function or script, otherwise it stops at the next statement.                      | Press <kbd>F11</kbd> or, on the **Debug** menu, click **Step Into**, or in the Console Pane, type `S` and press <kbd>ENTER</kbd>.                 |
| **Step Over**  | Executes the current statement and then stops at the next statement. If the current statement is a function or script call, then the debugger executes the whole function or script, and it stops at the next statement after the function call. | Press <kbd>F10</kbd> or, on the **Debug** menu, click **Step Over**, or in the Console Pane, type `V` and press <kbd>ENTER</kbd>.                 |
| **Step Out**   | Steps out of the current function and up one level if the function is nested. If in the main body, the script is executed to the end, or to the next breakpoint. The skipped statements are executed, but not stepped through.                   | Press <kbd>SHIFT</kbd>+<kbd>F11</kbd>, or on the **Debug** menu, click **Step Out**, or in the Console Pane, type `O` and press <kbd>ENTER</kbd>. |
| **Continue**   | Continues execution to the end, or to the next breakpoint. The skipped functions and invocations are executed, but not stepped through.                                                                                                          | Press <kbd>F5</kbd> or, on the **Debug** menu, click **Run/Continue**, or in the Console Pane, type `C` and press <kbd>ENTER</kbd>.               |

## How to display the values of variables while debugging

You can display the current values of variables in the script as you step through the code.

### To display the values of standard variables

Use one of the following methods:

- In the Script Pane, hover over the variable to display its value as a tool tip.

- In the Console Pane, type the variable name and press <kbd>ENTER</kbd>.

All panes in ISE are always in the same scope. Therefore, while you are debugging a script, the
commands that you type in the Console Pane run in script scope. This allows you to use the Console
Pane to find the values of variables and call functions that are defined only in the script.

### To display the values of automatic variables

You can use the preceding method to display the value of almost all variables while you are
debugging a script. However, these methods do not work for the following automatic variables.

- `$_`

- `$Input`

- `$MyInvocation`

- `$PSBoundParameters`

- `$Args`

If you try to display the value of any of these variables, you get the value of that variable for in
an internal pipeline the debugger uses, not the value of the variable in the script. You can work
around this for a few variables (`$_`, `$Input`, `$MyInvocation`, `$PSBoundParameters`, and `$Args`)
by using the following method:

1. In the script, assign the value of the automatic variable to a new variable.

1. Display the value of the new variable, either by hovering over the new variable in the Script
   Pane, or by typing the new variable in the Console Pane.

For example, to display the value of the `$MyInvocation` variable, in the script, assign the value
to a new variable, such as `$scriptName`, and then hover over or type the `$scriptName` variable to
display its value.

```powershell
# In C:\ps-test\MyScript.ps1
$scriptName = $MyInvocation.PSCommandPath
```

```PowerShell
# In the Console Pane:
.\MyScript.ps1
$scriptName
```

```Output
C:\ps-test\MyScript.ps1
```

## See Also

[Exploring the Windows PowerShell ISE](exploring-the-windows-powershell-ise.md)

# /./reference/windows-powershell/ise/how-to-use-profiles-in-windows-powershell-ise.md

    ---
    description: This article explains how to use Profiles in Windows PowerShell ISE.
    ms.date: 10/07/2021
    title: How to Use Profiles in Windows PowerShell ISE
    ---

# How to Use Profiles in Windows PowerShell ISE

This article explains how to use Profiles in Windows PowerShell&reg; Integrated Scripting Environment
(ISE). We recommend that before performing the tasks in this section, you review
[about_Profiles](/powershell/module/microsoft.powershell.core/about/about_profiles), or in the
Console Pane, type, `Get-Help about_Profiles` and press <kbd>ENTER</kbd>.

A profile is a Windows PowerShell ISE script that runs automatically when you start a new session.
You can create one or more Windows PowerShell profiles for Windows PowerShell ISE and use them to
add the configure the Windows PowerShell or Windows PowerShell ISE environment, preparing it for
your use, with variables, aliases, functions, and color and font preferences that you want
available. A profile affects every Windows PowerShell ISE session that you start.

> [!NOTE]
> The Windows PowerShell execution policy determines whether you can run scripts and load a profile.
> The default execution policy, "Restricted," prevents all scripts from running, including profiles.
> If you use the "Restricted" policy, the profile cannot load. For more information about execution
> policy, see [about_Execution_Policies](/powershell/module/microsoft.powershell.core/about/about_execution_policies).

## Selecting a profile to use in the Windows PowerShell ISE

Windows PowerShell ISE supports profiles for the current user and all users. It also supports the
Windows PowerShell profiles that apply to all hosts.

The profile that you use is determined by how you use Windows PowerShell and Windows PowerShell ISE.

- If you use only Windows PowerShell ISE to run Windows PowerShell, then save all your items in one
  of the ISE-specific profiles, such as the **CurrentUserCurrentHost** profile for Windows PowerShell
  ISE or the **AllUsersCurrentHost** profile for Windows PowerShell ISE.

- If you use multiple host programs to run Windows PowerShell, save your functions, aliases,
  variables, and commands in a profile that affects all host programs, such as the
  CurrentUserAllHosts or the **AllUsersAllHosts** profile, and save ISE-specific features, like color
  and font customization in the **CurrentUserCurrentHost** profile for Windows PowerShell ISE profile or
  the **AllUsersCurrentHost** profile for Windows PowerShell ISE.

The following are profiles that can be created and used in Windows PowerShell ISE. Each profile is
saved to its own specific path.

|           Profile Type           |                   Profile Path                   |
| -------------------------------- | ------------------------------------------------ |
| **Current user, PowerShell ISE** | `$PROFILE.CurrentUserCurrentHost`, or `$PROFILE` |
| **All users, PowerShell ISE**    | `$PROFILE.AllUsersCurrentHost`                   |
| **Current user, All hosts**      | `$PROFILE.CurrentUserAllHosts`                   |
| **All users, All hosts**         | `$PROFILE.AllUsersAllHosts`                      |

## To create a new profile

To create a new "Current user, Windows PowerShell ISE" profile, run this command:

```powershell
if (!(Test-Path -Path $PROFILE ))
{ New-Item -Type File -Path $PROFILE -Force }
```

To create a new "All users, Windows PowerShell ISE" profile, run this command:

```powershell
if (!(Test-Path -Path $PROFILE.AllUsersCurrentHost))
{ New-Item -Type File -Path $PROFILE.AllUsersCurrentHost -Force }
```

To create a new "Current user, All Hosts" profile, run this command:

```powershell
if (!(Test-Path -Path $PROFILE.CurrentUserAllHosts))
{ New-Item -Type File -Path $PROFILE.CurrentUserAllHosts -Force }
```

To create a new "All users, All Hosts" profile, type:

```powershell
if (!(Test-Path -Path $PROFILE.AllUsersAllHosts))
{ New-Item -Type File -Path $PROFILE.AllUsersAllHosts -Force }
```

## To edit a profile

1. To open the profile, run the command `psEdit` with the variable that specifies the profile you want
   to edit. For example, to open the "Current user, Windows PowerShell ISE" profile, type:
   `psEdit $PROFILE`

1. Add some items to your profile. The following are a few examples to get you started:

   - To change the default background color of the Console Pane to blue, in the profile file type:
     `$psISE.Options.OutputPaneBackground = 'blue'` . For more information about the `$psISE`
     variable, see [Windows PowerShell ISE Object Model Reference](object-model/The-ISE-Object-Model-Hierarchy.md).

   - To change font size to 20, in the profile file type: `$psISE.Options.FontSize =20`

1. To save your profile file, on the **File** menu, click **Save**. Next time you open the Windows
   PowerShell ISE, your customizations are applied.

## See Also

- [about_Profiles](/powershell/module/microsoft.powershell.core/about/about_profiles)
- [Introducing the Windows PowerShell ISE](Introducing-the-Windows-PowerShell-ISE.md)

# /./reference/windows-powershell/ise/how-to-use-tab-completion-in-the-script-pane-and-console-pane.md

    ---
    description: How to Use Tab Completion in the Script Pane and Console Pane
    ms.date: 01/02/2020
    title: How to Use Tab Completion in the Script Pane and Console Pane
    ---

# How to Use Tab Completion in the Script Pane and Console Pane

Tab completion provides automatic help when you are typing in the Script Pane or in the Command
Pane. Use the following steps to take advantage of this feature:

## To automatically complete a command entry

In the Command Pane or Script Pane, type a few characters of a command and then press <kbd>TAB</kbd> to select
the desired completion text. If multiple items begin with the text that you initially typed, then
continue pressing <kbd>TAB</kbd> until the item you want appears. Tab completion can help with typing a cmdlet
name, parameter name, variable name, object property name, or a file path.

> [!NOTE]
> In the Script Pane, pressing <kbd>TAB</kbd> will automatically complete a command only when you are editing
> `.ps1`, `.psd1`, or `.psm1` files. Tab completion works any time when you are typing in the Command Pane.

## To automatically complete a cmdlet parameter entry

In the Command Pane or Script pane, type a cmdlet followed by a dash and then press <kbd>TAB</kbd>.

For example, type `Get-Process -` and then press <kbd>TAB</kbd> multiple times to display each of
the parameters for the cmdlet in turn.

## See Also

- [Introducing the Windows PowerShell ISE](Introducing-the-Windows-PowerShell-ISE.md)
- [How to Create a PowerShell Tab](How-to-Create-a-PowerShell-Tab-in-Windows-PowerShell-ISE.md)

# /./reference/windows-powershell/ise/how-to-use-the-console-pane-in-the-windows-powershell-ise.md

    ---
    description: How to Use the Console Pane in the Windows PowerShell ISE
    ms.date: 01/02/2020
    ms.topic: ui-reference
    title: How to Use the Console Pane in the Windows PowerShell ISE
    ---

# How to Use the Console Pane in the Windows PowerShell ISE

The Console pane in the Windows PowerShell Integrated Scripting Environment (ISE) operates exactly
like the stand-alone Windows PowerShell ISE console window.

To run a command in the Console Pane, type a command, and then press <kbd>ENTER</kbd>. To enter
multiple commands that you want to execute in sequence, type <kbd>SHIFT</kbd>+<kbd>ENTER</kbd>
between commands. See
[How to Use Tab Completion in the Script Pane and Console Pane](How-to-Use-Tab-Completion-in-the-Script-Pane-and-Console-Pane.md)
for help in typing commands.

To stop a command, on the toolbar, click **Stop Operation**, or press
<kbd>CTRL</kbd>+<kbd>BREAK</kbd>. You can also use <kbd>CTRL</kbd>+<kbd>C</kbd> to stop a command if
the context is unambiguous. For example, if some text has been selected in the current Pane, then
<kbd>CTRL</kbd>+<kbd>C</kbd> maps to the copy operation.

Beginning in Windows PowerShell v3, the Output pane was combined with the Console pane. This has the
benefit of behaving like the stand-alone Windows PowerShell console and eliminates the differences
in procedures that were needed when they were separate. You can:

- Select and copy text from the Console pane to the Clipboard for pasting in any other window. To
  select text, click and hold the mouse in the output pane while dragging the mouse over the text
  you want to capture. You can also use the cursor arrow keys while holding <kbd>SHIFT</kbd> to
  select text. Then press <kbd>CTRL</kbd>+<kbd>C</kbd> or click the **Copy** icon in the toolbar.

- Paste the selected text at a current cursor position. Click the **Paste** icon on the toolbar.

- Clear all the text in the Console pane. To clear the Console pane, you can click the **Clear
  Console Pane** icon on the toolbar, or run the command `Clear-Host` or its alias, `cls`.

## See Also

- [Introducing the Windows PowerShell ISE](Introducing-the-Windows-PowerShell-ISE.md)

# /./reference/windows-powershell/ise/how-to-write-and-run-scripts-in-the-windows-powershell-ise.md

    ---
    description: This article describes how to create, edit, run, and save scripts in the Script Pane.
    ms.date: 10/07/2021
    title: How to Write and Run Scripts in the Windows PowerShell ISE
    ---

# How to Write and Run Scripts in the Windows PowerShell ISE

This article describes how to create, edit, run, and save scripts in the Script Pane.

## How to create and run scripts

You can open and edit Windows PowerShell files in the Script Pane. Specific file types of interest
in Windows PowerShell are script files (`.ps1`), script data files (`.psd1`), and script module
files (`.psm1`). These file types are syntax colored in the Script Pane editor. Other common file
types you may open in the Script Pane are configuration files (`.ps1xml`), XML files, and text
files.

> [!NOTE]
> The Windows PowerShell execution policy determines whether you can run scripts and load Windows
> PowerShell profiles and configuration files. The default execution policy, Restricted, prevents
> all scripts from running, and prevents loading profiles. To change the execution policy to allow
> profiles to load and be used, see
> [Set-ExecutionPolicy](/powershell/module/microsoft.powershell.security/set-executionpolicy) and
> [about_Signing](/powershell/module/microsoft.powershell.core/about/about_signing).

### To create a new script file

On the toolbar, click **New**, or on the **File** menu, click **New**. The created file appears in
a new file tab under the current PowerShell tab. Remember that the PowerShell tabs are only visible
when there are more than one. By default a file of type script (`.ps1`) is created, but it can be
saved with a new name and extension. Multiple script files can be created in the same PowerShell
tab.

### To open an existing script

On the toolbar, click **Open**, or on the **File** menu, click **Open**. In the **Open** dialog
box, select the file you want to open. The opened file appears in a new tab.

### To close a script tab

Click the **Close** icon (**X**) of the file tab you want to close or select the **File** menu and
click **Close**.

If the file has been altered since it was last saved, you're prompted to save or discard it.

### To display the file path

On the file tab, point to the file name. The fully qualified path to the script file appears in a
tooltip.

### To run a script

On the toolbar, click **Run Script**, or on the **File** menu, click **Run**.

### To run a portion of a script

1. In the Script Pane, select a portion of a script.
2. On the **File** menu, click **Run Selection**, or on the toolbar, click **Run Selection**.

### To stop a running script

There are several ways to stop a running script.

- Click **Stop Operation** on the toolbar
- Press <kbd>CTRL</kbd>+<kbd>BREAK</kbd>
- Select the **File** menu and click **Stop Operation**.

Pressing <kbd>CTRL</kbd>+<kbd>C</kbd> also works unless some text is currently selected, in which
case <kbd>CTRL</kbd>+<kbd>C</kbd> maps to the copy function for the selected text.

## How to write and edit text in the Script Pane

You can copy, cut, paste, find, and replace text in the Script Pane. You can also undo and redo the
last action you just performed. The keyboard shortcuts for these actions are the same shortcuts
used for all Windows applications.

### To enter text in the Script Pane

1. Move the cursor to the Script Pane by clicking anywhere in the Script Pane, or by clicking **Go
   to Script Pane** in the **View** menu.
1. Create a script. Syntax coloring and tab completion provide a richer editing experience in
   Windows PowerShell ISE.
1. See [How to Use Tab Completion in the Script Pane and Console Pane](How-to-Use-Tab-Completion-in-the-Script-Pane-and-Console-Pane.md)
   for details about using the tab completion feature to help in typing.

### To find text in the Script Pane

1. To find text anywhere, press <kbd>CTRL</kbd>+<kbd>F</kbd> or, on the **Edit** menu, click **Find
   in Script**.
1. To find text after the cursor, press <kbd>F3</kbd> or, on the **Edit** menu, click **Find Next in
   Script**.
1. To find text before the cursor, press <kbd>SHIFT</kbd>+<kbd>F3</kbd> or, on the **Edit** menu,
   click **Find Previous in Script**.

### To find and replace text in the Script Pane

Press <kbd>CTRL</kbd>+<kbd>H</kbd> or, on the **Edit** menu, click **Replace in Script**. Enter the
text you want to find and the replacement text, then press <kbd>ENTER</kbd>.

### To go to a particular line of text in the Script Pane

1. In the Script Pane, press <kbd>CTRL</kbd>+<kbd>G</kbd> or, on the **Edit** menu, click **Go to
   Line**.

1. Enter a line number.

### To copy text in the Script Pane

1. In the Script Pane, select the text that you want to copy.

1. Press <kbd>CTRL</kbd>+<kbd>C</kbd> or, on the toolbar, click the **Copy** icon, or on the
   **Edit** menu, click **Copy**.

### To cut text in the Script Pane

1. In the Script Pane, select the text that you want to cut.
1. Press <kbd>CTRL</kbd>+<kbd>X</kbd> or, on the toolbar, click the **Cut** icon, or on the **Edit**
   menu, click **Cut**.

### To paste text into the Script Pane

Press <kbd>CTRL</kbd>+<kbd>V</kbd> or, on the toolbar, click the **Paste** icon, or on the **Edit**
menu, click **Paste**.

### To undo an action in the Script Pane

Press <kbd>CTRL</kbd>+<kbd>Z</kbd> or, on the toolbar, click the **Undo** icon, or on the **Edit**
menu, click **Undo**.

### To redo an action in the Script Pane

Press <kbd>CTRL</kbd>+<kbd>Y</kbd> or, on the toolbar, click the **Redo** icon, or on the **Edit**
menu, click **Redo**.

## How to save a script

An asterisk appears next to the script name to mark a file that hasn't been saved since it was
changed. The asterisk disappears when the file is saved.

### To save a script

Press <kbd>CTRL</kbd>+<kbd>S</kbd> or, on the toolbar, click the **Save** icon, or on the **File**
menu, click **Save**.

### To save and name a script

1. On the **File** menu, click **Save As**. The **Save As** dialog box will appear.
1. In the **File name** box, enter a name for the file.
1. In the **Save as type** box, select a file type. For example, in the **Save as type** box,
   select 'PowerShell Scripts (`*.ps1`)'.
1. Click **Save**.

### To save a script in ASCII encoding

By default, Windows PowerShell ISE saves new script files (`.ps1`), script data files (`.psd1`), and
script module files (`.psm1`) as Unicode (BigEndianUnicode). To save a script in another
encoding, such as ASCII (ANSI), use the **Save** or **SaveAs** methods on the
[$psISE.CurrentFile](object-model/the-ise-object-model-hierarchy.md) object.

The following command saves a new script as MyScript.ps1 with ASCII encoding.

```powershell
$psISE.CurrentFile.SaveAs("MyScript.ps1", [System.Text.Encoding]::ASCII)
```

The following command replaces the current script file with a file with the same name, but with
ASCII encoding.

```powershell
$psISE.CurrentFile.Save([System.Text.Encoding]::ASCII)
```

The following command gets the encoding of the current file.

```powershell
$psISE.CurrentFile.encoding
```

Windows PowerShell ISE supports the following encoding options: ASCII, BigEndianUnicode, Unicode,
UTF32, UTF7, UTF8, and Default. The value of the Default option varies with the system.

Windows PowerShell ISE doesn't change the encoding of script files when you use the Save or
Save As commands.

## See Also

- [Exploring the Windows PowerShell ISE](exploring-the-windows-powershell-ise.md)

# /./reference/windows-powershell/ise/keyboard-shortcuts-for-the-windows-powershell-ise.md

    ---
    description: This article is a list of the keyboard shortcuts used in the PowerShell ISE.
    ms.date: 03/04/2024
    ms.topic: ui-reference
    title: Keyboard Shortcuts for the Windows PowerShell ISE
    ---

# Keyboard Shortcuts for the Windows PowerShell ISE

Use the following keyboard shortcuts to perform actions in Windows PowerShell Integrated Scripting
Environment (ISE). Windows PowerShell ISE is available as part of the Windows Server and Windows
client operating systems.

## Keyboard shortcuts for editing text

You can use the following keyboard shortcuts when you edit text.

|              Action              |              Keyboard Shortcuts               |                                                                                                                                           Use in                                                                                                                                           |
| -------------------------------- | --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Help**                         | <kbd>F1</kbd>                                 | Script Pane **Important:** You can specify that <kbd>F1</kbd> help comes from Microsoft Learn or downloaded Help (see `Update-Help`). To select, click **Tools**, **Options**, then on the **General Settings** tab, set or clear **Use local help content instead of online content.** |
| **Select All**                   | <kbd>CTRL</kbd>+<kbd>A</kbd>                  | Script Pane                                                                                                                                                                                                                                                                                |
| **Copy**                         | <kbd>CTRL</kbd>+<kbd>C</kbd>                  | Script Pane, Command Pane, Output Pane                                                                                                                                                                                                                                                     |
| **Cut**                          | <kbd>CTRL</kbd>+<kbd>X</kbd>                  | Script Pane, Command Pane                                                                                                                                                                                                                                                                  |
| **Expand or Collapse Outlining** | <kbd>CTRL</kbd>+<kbd>M</kbd>                  | Script Pane                                                                                                                                                                                                                                                                                |
| **Find in Script**               | <kbd>CTRL</kbd>+<kbd>F</kbd>                  | Script Pane                                                                                                                                                                                                                                                                                |
| **Find Next in Script**          | <kbd>F3</kbd>                                 | Script Pane                                                                                                                                                                                                                                                                                |
| **Find Previous in Script**      | <kbd>SHIFT</kbd>+<kbd>F3</kbd>                | Script Pane                                                                                                                                                                                                                                                                                |
| **Find Matching Brace**          | <kbd>CTRL</kbd>+<kbd>]</kbd>                  | Script Pane                                                                                                                                                                                                                                                                                |
| **Paste**                        | <kbd>CTRL</kbd>+<kbd>V</kbd>                  | Script Pane, Command Pane                                                                                                                                                                                                                                                                  |
| **Make Lowercase**               | <kbd>CTRL</kbd>+<kbd>U</kbd>                  | Script Pane, Command Pane                                                                                                                                                                                                                                                                  |
| **Make Uppercase**               | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>U</kbd> | Script Pane, Command Pane                                                                                                                                                                                                                                                                  |
| **Redo**                         | <kbd>CTRL</kbd>+<kbd>Y</kbd>                  | Script Pane, Command Pane                                                                                                                                                                                                                                                                  |
| **Replace in Script**            | <kbd>CTRL</kbd>+<kbd>H</kbd>                  | Script Pane                                                                                                                                                                                                                                                                                |
| **Save**                         | <kbd>CTRL</kbd>+<kbd>S</kbd>                  | Script Pane                                                                                                                                                                                                                                                                                |
| **Select All**                   | <kbd>CTRL</kbd>+<kbd>A</kbd>                  | Script Pane, Command Pane, Output Pane                                                                                                                                                                                                                                                     |
| **Show Snippets**                | <kbd>CTRL</kbd>+<kbd>J</kbd>                  | Script Pane, Command Pane                                                                                                                                                                                                                                                                  |
| **Undo**                         | <kbd>CTRL</kbd>+<kbd>Z</kbd>                  | Script Pane, Command Pane                                                                                                                                                                                                                                                                  |
| **Show Intellisense Help**       | <kbd>CTRL</kbd>+<kbd>Space</kbd>              | Script Pane                                                                                                                                                                                                                                                                                |
| **Delete word to left**          | <kbd>CTRL</kbd>+<kbd>Backspace</kbd>          | Script Pane                                                                                                                                                                                                                                                                                |
| **Delete word to right**         | <kbd>CTRL</kbd>+<kbd>Delete</kbd>             | Script Pane                                                                                                                                                                                                                                                                                |

## Keyboard shortcuts for running scripts

You can use the following keyboard shortcuts when you run scripts in the Script Pane.

|            Action            |                                                                                                             Keyboard Shortcut                                                                                                             |
| ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **New**                      | <kbd>CTRL</kbd>+<kbd>N</kbd>                                                                                                                                                                                                              |
| **Open**                     | <kbd>CTRL</kbd>+<kbd>O</kbd>                                                                                                                                                                                                              |
| **Run**                      | <kbd>F5</kbd>                                                                                                                                                                                                                             |
| **Run Selection**            | <kbd>F8</kbd>                                                                                                                                                                                                                             |
| **Stop Execution**           | <kbd>CTRL</kbd>+<kbd>BREAK</kbd>. <kbd>CTRL</kbd>+<kbd>C</kbd> can be used when the context is unambiguous (when there is no text selected).                                                                                              |
| **Tab** (to next script)     | <kbd>CTRL</kbd>+<kbd>TAB</kbd> **Note:** Tab to next script works only when you have a single Windows PowerShell tab open, or when you have more than one Windows PowerShell tab open, but the focus is in the Script Pane.               |
| **Tab** (to previous script) | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>TAB</kbd> **Note:** Tab to previous script works when you have only one Windows PowerShell tab open, or if you have more than one Windows PowerShell tab open, and the focus is in the Script Pane. |

## Keyboard shortcuts for customizing the view

You can use the following keyboard shortcuts to customize the view in Windows PowerShell ISE. They
are accessible from all the panes in the application.

|                        Action                         |               Keyboard Shortcut               |
| ----------------------------------------------------- | --------------------------------------------- |
| **Go to Command (v2) or Console (v3 and later) Pane** | <kbd>CTRL</kbd>+<kbd>D</kbd>                  |
| **Go to Output Pane (v2 only)**                       | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>O</kbd> |
| **Go to Script Pane**                                 | <kbd>CTRL</kbd>+<kbd>I</kbd>                  |
| **Show Script Pane**                                  | <kbd>CTRL</kbd>+<kbd>R</kbd>                  |
| **Hide Script Pane**                                  | <kbd>CTRL</kbd>+<kbd>R</kbd>                  |
| **Move Script Pane Up**                               | <kbd>CTRL</kbd>+<kbd>1</kbd>                  |
| **Move Script Pane Right**                            | <kbd>CTRL</kbd>+<kbd>2</kbd>                  |
| **Maximize Script Pane**                              | <kbd>CTRL</kbd>+<kbd>3</kbd>                  |
| **Zoom In**                                           | <kbd>CTRL</kbd>+<kbd>+</kbd>                  |
| **Zoom Out**                                          | <kbd>CTRL</kbd>+<kbd>-</kbd>                  |

## Keyboard shortcuts for debugging scripts

You can use the following keyboard shortcuts when you debug scripts.

|           Action           |               Keyboard Shortcut                |                Use in                |
| -------------------------- | ---------------------------------------------- | ------------------------------------ |
| **Run/Continue**           | <kbd>F5</kbd>                                  | Script Pane, when debugging a script |
| **Step Into**              | <kbd>F11</kbd>                                 | Script Pane, when debugging a script |
| **Step Over**              | <kbd>F10</kbd>                                 | Script Pane, when debugging a script |
| **Step Out**               | <kbd>SHIFT</kbd>+<kbd>F11</kbd>                | Script Pane, when debugging a script |
| **Display Call Stack**     | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>D</kbd>  | Script Pane, when debugging a script |
| **List Breakpoints**       | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>L</kbd>  | Script Pane, when debugging a script |
| **Toggle Breakpoint**      | <kbd>F9</kbd>                                  | Script Pane, when debugging a script |
| **Remove All Breakpoints** | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>F9</kbd> | Script Pane, when debugging a script |
| **Stop Debugger**          | <kbd>SHIFT</kbd>+<kbd>F5</kbd>                 | Script Pane, when debugging a script |

> [!NOTE]
> You can also use the keyboard shortcuts designed for the Windows PowerShell console when you debug
> scripts in Windows PowerShell ISE. To use these shortcuts, you must type the shortcut in the
> Command Pane and press <kbd>ENTER</kbd>.

|                        Action                        | Keyboard Shortcut |                Use in                 |
| ---------------------------------------------------- | ----------------- | ------------------------------------- |
| **Continue**                                         | `C`               | Console Pane, when debugging a script |
| **Step Into**                                        | `S`               | Console Pane, when debugging a script |
| **Step Over**                                        | `V`               | Console Pane, when debugging a script |
| **Step Out**                                         | `O`               | Console Pane, when debugging a script |
| **Repeat Last Command** (for Step Into or Step Over) | <kbd>ENTER</kbd>  | Console Pane, when debugging a script |
| **Display Call Stack**                               | `K`               | Console Pane, when debugging a script |
| **Stop Debugging**                                   | `Q`               | Console Pane, when debugging a script |
| **List the Script**                                  | `L`               | Console Pane, when debugging a script |
| **Display Console Debugging Commands**               | `H` or `?`        | Console Pane, when debugging a script |

## Keyboard shortcuts for Windows PowerShell tabs

You can use the following keyboard shortcuts when you use Windows PowerShell tabs.

|             Action              |                                                        Keyboard Shortcut                                                        |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Close PowerShell Tab**        | <kbd>CTRL</kbd>+<kbd>W</kbd>                                                                                                    |
| **New PowerShell Tab**          | <kbd>CTRL</kbd>+<kbd>T</kbd>                                                                                                    |
| **Previous PowerShell tab**     | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>TAB</kbd>. This shortcut works only when no files are open on any Windows PowerShell tab. |
| **Next Windows PowerShell tab** | <kbd>CTRL</kbd>+<kbd>TAB</kbd>. This shortcut works only when no files are open on any Windows PowerShell tab.                  |

## Keyboard shortcuts for starting and exiting

You can use the following keyboard shortcuts to exit the Windows PowerShell ISE or to start a new
Windows PowerShell session outside of the ISE.

|          Action          |                                            Keyboard Shortcut                                             |
| ------------------------ | -------------------------------------------------------------------------------------------------------- |
| **Exit**                 | <kbd>ALT</kbd>+<kbd>F4</kbd> closes the ISE.                                                             |
| **Start PowerShell.exe** | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>P</kbd> opens a new Windows PowerShell session outside of the ISE. |

## See Also

- [PowerShell Magazine: The Complete List of Windows PowerShell ISE Keyboard Shortcuts][01]

<!-- link references -->
[01]: https://www.powershellmagazine.com/2013/01/29/the-complete-list-of-powershell-ise-3-0-keyboard-shortcuts/

# /./reference/windows-powershell/ise/accessibility-in-windows-powershell-ise.md

    ---
    description: This topic describes the accessibility features of Windows PowerShell Integrated Scripting Environment (ISE) that you might find helpful.
    ms.date: 12/19/2019
    ms.topic: ui-reference
    title: Accessibility in Windows PowerShell ISE
    ---

# Accessibility in Windows PowerShell ISE

This topic describes the accessibility features of Windows PowerShell Integrated Scripting
Environment (ISE) that you might find helpful.

- [How to change the size and location of the Console and Script Panes](#how-to-change-the-size-and-location-of-the-console-and-script-panes)
- [Keyboard shortcuts for editing text](#keyboard-shortcuts-for-editing-text)
- [Keyboard shortcuts for running scripts](#keyboard-shortcuts-for-running-scripts)
- [Keyboard shortcuts for customizing the view](#keyboard-shortcuts-for-customizing-the-view)
- [Keyboard shortcuts for debugging scripts](#keyboard-shortcuts-for-debugging-scripts)
- [Keyboard shortcuts for Windows PowerShell tabs](#keyboard-shortcuts-for-windows-powershell-tabs)
- [Keyboard shortcuts for starting and exiting](#keyboard-shortcuts-for-starting-and-exiting)
- [Breakpoint management with cmdlets](#breakpoint-management)

Microsoft is committed to making its products and services easier for everyone to use. The following
topics provide information about the features, products, and services that make Windows PowerShell
ISE more accessible for people with disabilities.

In addition to accessibility features and utilities in Microsoft Windows, the following features
make Windows PowerShell ISE more accessible for people with disabilities:

- Keyboard Shortcuts

- Syntax Coloring Table and the ability to modify several other color settings using the
  [$psISE.Options](object-model/The-ISEOptions-Object.md) scripting object.

- Text Size Change

## How to change the size and location of the Console and Script Panes

You can use the following steps to change the size and location of the Console Pane and the Script
Pane. When you open the Windows PowerShell ISE again, the size and location changes you made will be
retained.

### To resize the Script Pane and Console Pane

1. Pause the pointer on the split line between the Script Pane and Console Pane.

2. When the mouse pointer changes to a two-headed arrow, drag the border to change the size of the pane.

### To move the Script Pane and Console Pane

Do one of the following:

- To move the Script Pane above the Console Pane, press <kbd>CTRL</kbd>+<kbd>1</kbd> or, on the
  toolbar, click the **Show Script Pane Top** icon, or in the **View** menu, click **Show Script
  Pane Top**.

- To move the Script Pane to the right of the Console Pane, press <kbd>CTRL</kbd>+<kbd>2</kbd> or,
  on the toolbar, click the **Show Script Pane Right** icon, or in the **View** menu, click **Show
  Script Pane Right**.

- To maximize the Script Pane, press <kbd>CTRL</kbd>+<kbd>3</kbd> or, on the toolbar, click the
  **Show Script Pane Maximized** icon, or in the **View** menu, click **Show Script Pane
  Maximized**.

- To maximize the Console Pane and hide the Script Pane, on the far right edge of the row of tabs,
  click the **Hide Script Pane** icon, in the **View** menu, click to deselect the **Show Script
  Pane** menu option.

- To display the Script Pane when the Console Pane is maximized, on the far right edge of the row of
  tabs, click the **Show Script Pane** icon, or in the **View** menu, click to select the **Show
  Script Pane** menu option.

## Keyboard shortcuts for editing text

You can use the following keyboard shortcuts when you edit text.

|           Action            |       Keyboard Shortcuts       |          Use in           |
| --------------------------- | ------------------------------ | ------------------------- |
| **Copy**                    | <kbd>CTRL</kbd>+<kbd>C</kbd>   | Script Pane, Console Pane |
| **Cut**                     | <kbd>CTRL</kbd>+<kbd>X</kbd>   | Script Pane, Console Pane |
| **Find in Script**          | <kbd>CTRL</kbd>+<kbd>F</kbd>   | Script Pane               |
| **Find Next in Script**     | <kbd>F3</kbd>                  | Script Pane               |
| **Find Previous in Script** | <kbd>SHIFT</kbd>+<kbd>F3</kbd> | Script Pane               |
| **Paste**                   | <kbd>CTRL</kbd>+<kbd>V</kbd>   | Script Pane, Console Pane |
| **Redo**                    | <kbd>CTRL</kbd>+<kbd>Y</kbd>   | Script Pane, Console Pane |
| **Replace in Script**       | <kbd>CTRL</kbd>+<kbd>H</kbd>   | Script Pane               |
| **Save**                    | <kbd>CTRL</kbd>+<kbd>S</kbd>   | Script Pane               |
| **Select All**              | <kbd>CTRL</kbd>+<kbd>A</kbd>   | Script Pane, Console Pane |
| **Undo**                    | <kbd>CTRL</kbd>+<kbd>Z</kbd>   | Script Pane, Console Pane |

## Keyboard shortcuts for running scripts

You can use the following keyboard shortcuts when you run scripts in the Script Pane.

|            Action            |                                                                                                     Keyboard Shortcut                                                                                                      |
| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **New**                      | <kbd>CTRL</kbd>+<kbd>N</kbd>                                                                                                                                                                                               |
| **Open**                     | <kbd>CTRL</kbd>+<kbd>O</kbd>                                                                                                                                                                                               |
| **Run**                      | <kbd>F5</kbd>                                                                                                                                                                                                              |
| **Run Selection**            | <kbd>F8</kbd>                                                                                                                                                                                                              |
| **Stop Execution**           | <kbd>CTRL</kbd>+<kbd>BREAK</kbd>. <kbd>CTRL</kbd>+<kbd>C</kbd> can be used when the context is unambiguous (when there is no text selected).                                                                               |
| **Tab** (to next script)     | <kbd>CTRL</kbd>+<kbd>TAB</kbd> **Note:** Tab to next script works only when you have a single PowerShell tab open, or when you have more than one PowerShell tab open, but the focus is in the Script Pane.                |
| **Tab** (to previous script) | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>TAB</kbd> **Note:** Tab to previous script works when you have only one PowerShell tab open, or if you have more  than one PowerShell tab open, and the focus is in the Script Pane. |

## Keyboard shortcuts for customizing the view

You can use the following keyboard shortcuts to customize the view in Windows PowerShell ISE. They
are accessible from all the panes in the application.

|           Action           |         Keyboard Shortcut        |
| -------------------------- | -------------------------------- |
| **Go to Console Pane**     | <kbd>CTRL</kbd>+<kbd>D</kbd>     |
| **Go to Script Pane**      | <kbd>CTRL</kbd>+<kbd>I</kbd>     |
| **Show Script Pane**       | <kbd>CTRL</kbd>+<kbd>R</kbd>     |
| **Hide Script Pane**       | <kbd>CTRL</kbd>+<kbd>R</kbd>     |
| **Move Script Pane Up**    | <kbd>CTRL</kbd>+<kbd>1</kbd>     |
| **Move Script Pane Right** | <kbd>CTRL</kbd>+<kbd>2</kbd>     |
| **Maximize Script Pane**   | <kbd>CTRL</kbd>+<kbd>3</kbd>     |
| **Zoom In**                | <kbd>CTRL</kbd>+<kbd>PLUS</kbd>  |
| **Zoom Out**               | <kbd>CTRL</kbd>+<kbd>MINUS</kbd> |

## Keyboard shortcuts for debugging scripts

You can use the following keyboard shortcuts when you debug scripts.

|           Action           |               Keyboard Shortcut                |                Use in                |
| -------------------------- | ---------------------------------------------- | ------------------------------------ |
| **Run/Continue**           | <kbd>F5</kbd>                                  | Script Pane, when debugging a script |
| **Step Into**              | <kbd>F11</kbd>                                 | Script Pane, when debugging a script |
| **Step Over**              | <kbd>F10</kbd>                                 | Script Pane, when debugging a script |
| **Step Out**               | <kbd>SHIFT</kbd>+<kbd>F11</kbd>                | Script Pane, when debugging a script |
| **Display Call Stack**     | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>D</kbd>  | Script Pane, when debugging a script |
| **List Breakpoints**       | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>L</kbd>  | Script Pane, when debugging a script |
| **Toggle Breakpoint**      | <kbd>F9</kbd>                                  | Script Pane, when debugging a script |
| **Remove All Breakpoints** | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>F9</kbd> | Script Pane, when debugging a script |
| **Stop Debugger**          | <kbd>SHIFT</kbd>+<kbd>F5</kbd>                 | Script Pane, when debugging a script |

> [!NOTE]
> You can also use the keyboard shortcuts designed for the Windows PowerShell console when you debug
> scripts in Windows PowerShell ISE. To use these shortcuts, you must type the shortcut in the
> Console Pane and press <kbd>ENTER</kbd>.

|                 Action                  |      Keyboard Shortcut       |                Use in                 |
| --------------------------------------- | ---------------------------- | ------------------------------------- |
| **Continue**                            | <kbd>C</kbd>                 | Console Pane, when debugging a script |
| **Step Into**                           | <kbd>S</kbd>                 | Console Pane, when debugging a script |
| **Step Over**                           | <kbd>V</kbd>                 | Console Pane, when debugging a script |
| **Step Out**                            | <kbd>O</kbd>                 | Console Pane, when debugging a script |
| **Repeat Last Command**(Step Into/Over) | <kbd>ENTER</kbd>             | Console Pane, when debugging a script |
| **Display Call Stack**                  | <kbd>K</kbd>                 | Console Pane, when debugging a script |
| **Stop Debugging**                      | <kbd>Q</kbd>                 | Console Pane, when debugging a script |
| **List the Script**                     | <kbd>L</kbd>                 | Console Pane, when debugging a script |
| **Display Console Debugging Commands**  | <kbd>H</kbd> or <kbd>?</kbd> | Console Pane, when debugging a script |

## Keyboard shortcuts for Windows PowerShell tabs

You can use the following keyboard shortcuts when you use Windows PowerShell tabs.

|             Action              |                                 Keyboard Shortcut                                  |
| ------------------------------- | ---------------------------------------------------------------------------------- |
| **Close PowerShell Tab**        | <kbd>CTRL</kbd>+<kbd>W</kbd>                                                       |
| **New PowerShell Tab**          | <kbd>CTRL</kbd>+<kbd>T</kbd>                                                       |
| **Previous PowerShell tab**     | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>TAB</kbd> (Only when no files are open on any PowerShell tab) |
| **Next Windows PowerShell tab** | <kbd>CTRL</kbd>+<kbd>TAB</kbd> (Only when no files are open on any PowerShell tab) |

## Keyboard shortcuts for starting and exiting

You can use the following keyboard shortcuts to start the Windows PowerShell console
(**PowerShell.exe**) or to exit Windows PowerShell ISE.

|                        Action                         |               Keyboard Shortcut               |
| ----------------------------------------------------- | --------------------------------------------- |
| **Exit**                                              | <kbd>ALT</kbd>+<kbd>F4</kbd>                  |
| **Start PowerShell.exe** (Windows PowerShell console) | <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>P</kbd> |

## Breakpoint Management

For the visually impaired, breakpoint information is available through the cmdlets for managing
breakpoints, such as
[Get-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Get-PSBreakpoint) and
[Set-PSBreakpoint](/powershell/module/Microsoft.PowerShell.Utility/Set-PSBreakpoint). For more
information please see 'How to manage breakpoints' in
[How to Debug Scripts in the Windows PowerShell ISE](How-to-Debug-Scripts-in-Windows-PowerShell-ISE.md).

## See Also

[Introducing the Windows PowerShell ISE](Introducing-the-Windows-PowerShell-ISE.md)

# /./reference/windows-powershell/ise/object-model/purpose-of-the-windows-powershell-ise-scripting-object-model.md

    ---
    description: Purpose of the Windows PowerShell ISE Scripting Object Model
    ms.date: 12/31/2019
    title: Purpose of the Windows PowerShell ISE Scripting Object Model
    ---

# Purpose of the Windows PowerShell ISE Scripting Object Model

Objects are associated with the form and function of Windows PowerShell Integrated Scripting
Environment (ISE). The object model reference provides details about the member properties and
methods that these objects expose. Examples are provided to show how you can use scripts to
directly access these methods and properties. The scripting object model makes the following range
of tasks easier.

## Customizing the appearance of Windows PowerShell ISE

You can use the object model to modify the application settings and options. For example, you can
modify them as follows:

- Change the color of errors, warnings, verbose outputs, and debug outputs.
- Get or set the background colors for the Command pane, the Output pane, and the Script pane.
- Set the foreground color for the Output pane.
- Set the font name and font size for Windows PowerShell ISE.
- Configure warnings. This setting includes warnings that are issued when a file is opened
  in multiple PowerShell tabs or when a script in the file is run before the file has been saved.
- Switch between a view where the Script pane and the Output pane are side-by-side and a
  view where the Script pane is on top of the Output pane.
- Dock the Command pane to the bottom or the top of the Output pane.

## Enhancing the functionality of Windows PowerShell ISE

You can use the object model to enhance the functionality of Windows PowerShell ISE. For example,
you can:

- Add and modify the instance of Windows PowerShell ISE itself. For example, to change the menus,
  you can add new menu items and map the new menu items to scripts.
- Create scripts that perform some of the tasks that you can perform by using the menu commands and
  buttons in Windows PowerShell ISE. For example, you can add, remove, or select a PowerShell tab.
- Complement tasks that can be performed by using menu commands and buttons. For example, you can
  rename a PowerShell tab.
- Manipulate text buffers for the Command pane, the Output pane, and the Script pane that are
  associated with a file. For example, you can:
  - Get or set all text.
  - Get or set a text selection.
  - Run a script or run a selected portion of a script.
  - Scroll a line into view.
  - Insert text at a caret position.
  - Select a block of text.
  - Get the last line number.
- Perform file operations. For example, you can:
  - Open a file, save a file, or save a file by using a different name.
  - Determine whether a file has been changed after it was last saved.
  - Get the file name.
  - Select a file.

## Automating tasks

You can use the scripting object model to create keyboard shortcuts for frequent operations.

## See also

- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-ise-object-model-hierarchy.md

    ---
    description: This article shows the hierarchy of objects that are part of Windows PowerShell ISE.
    ms.date: 12/31/2019
    title: The ISE Object Model Hierarchy
    ---

# The ISE Object Model Hierarchy

This article shows the hierarchy of objects that are part of Windows PowerShell Integrated Scripting
Environment (ISE). Windows PowerShell ISE is included in Windows PowerShell 3.0, 4.0, and 5.1. Click
an object to take you to the reference documentation for the class that defines the object.

## $psISE Object

The `$psISE` object is the [root object](The-ObjectModelRoot-Object.md) of the Windows PowerShell
ISE object hierarchy. Located at the top level, it makes the following objects available for
scripting:

## [$psISE.CurrentFile](The-ISEFile-Object.md)

The `$psISE.CurrentFile` object is an instance of the [ISEFile](The-ISEFile-Object.md) class.

## [$psISE.CurrentPowerShellTab](The-PowerShellTab-Object.md)

The `$psISE.CurrentPowerShellTab` object is an instance of the [PowerShellTab](The-PowerShellTab-Object.md) class.

## $psISE.CurrentVisibleHorizontalTool

The `$psISE.CurrentVisibleHorizontalTool` object is an instance of the [ISEAddOnTool](The-ISEAddOnTool-Object.md)
class. It represents the installed add-on tool that is currently docked to the top edge of the
Windows PowerShell ISE window.

## $psISE.CurrentVisibleVerticalTool

The `$psISE.CurrentVisibleHorizontalTool` object is an instance of the [ISEAddOnTool](The-ISEAddOnTool-Object.md)
class. It represents the installed add-on tool that is currently docked to the right-hand edge of
the Windows PowerShell ISE window.

## [$psISE.Options](The-ISEOptions-Object.md)

The `$psISE.Options` object is an instance of the [ISEOptions](The-ISEOptions-Object.md) class. The
ISEOptions object represents various settings for Windows PowerShell ISE. It is an instance of the
Microsoft.PowerShell.Host.ISE.ISEOptions class.

## [$psISE.PowerShellTabs](The-PowerShellTabCollection-Object.md)

The `$psISE.PowerShellTabs` object is an instance of the [PowerShellTabCollection](The-PowerShellTabCollection-Object.md)
class. It is a collection of all the currently open PowerShell tabs that represent the available
Windows PowerShell run environments on the local computer or on connected remote computers. Each
member in the collection is an instance of the [PowerShellTab](The-PowerShellTab-Object.md) class.

## See Also

- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-objectmodelroot-object.md

    ---
    description: The $psISE object, which is the principal root object in PowerShell ISE is an instance of the Microsoft.PowerShell.Host.ISE.ObjectModelRoot class. This topic describes the properties of the ObjectModelRoot object.
    ms.date: 08/25/2017
    title: The ObjectModelRoot Object
    ---

# The ObjectModelRoot Object

The `$psISE` object, which is the principal root object in Windows PowerShell&reg; Integrated Scripting
Environment (ISE) is an instance of the Microsoft.PowerShell.Host.ISE.ObjectModelRoot class. This
topic describes the properties of the **ObjectModelRoot** object.

## Properties

### CurrentFile

> Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the file, which is associated with this host object that currently
has the focus.

### CurrentPowerShellTab

> Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the PowerShell tab that has the focus.

### CurrentVisibleHorizontalTool

> Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the currently visible
Windows PowerShell ISE add-on tool that is located in
the horizontal tool pane at the bottom of the editor.

### CurrentVisibleVerticalTool

> Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the currently visible Windows PowerShell ISE add-on tool that is
located in the vertical tool pane on the right side of the editor.

### Options

> Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the various options that can change settings in Windows PowerShell
ISE.

### PowerShellTabs

> Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the collection of the PowerShell tabs, which are open in Windows
PowerShell ISE. By default, this object contains one PowerShell tab. However, you can add more
PowerShell tabs to this object by using scripts or by using the menus in Windows PowerShell ISE.

## See Also

- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-iseaddontoolcollection-object.md

    ---
    description: The ISEAddOnToolCollection object is a collection of **ISEAddOnTool** objects.
    ms.date: 12/31/2019
    title: The ISEAddOnToolCollection Object
    ---

# The ISEAddOnToolCollection Object

The **ISEAddOnToolCollection** object is a collection of **ISEAddOnTool** objects. An example is the
`$psISE.CurrentPowerShellTab.VerticalAddOnTools` object.

## Methods

### Add\( Name, ControlType, \[IsVisible\] \)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Adds a new add-on tool to the collection. It returns the newly added add-on tool. Before you run
this command, you must install the add-on tool on the local computer and load the assembly.

**Name** - String
Specifies the display name of the add-on tool that is added to Windows PowerShell ISE.

**ControlType** -Type
Specifies the control that is added.

**\[IsVisible\]** - optional Boolean
If set to `$true`, the add-on tool is immediately visible in the associated tool pane.

```powershell
# Load a DLL with an add-on and then add it to the ISE
[reflection.assembly]::LoadFile("c:\test\ISESimpleSolution\ISESimpleSolution.dll")
$psISE.CurrentPowerShellTab.VerticalAddOnTools.Add("Solutions", [ISESimpleSolution.Solution], $true)
```

### Remove\( Item \)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Removes the specified add-on tool from the collection.

**Item** - Microsoft.PowerShell.Host.ISE.ISEAddOnTool
Specifies the object to be removed from Windows PowerShell ISE.

```powershell
# Load a DLL with an add-on and then add it to the ISE
[reflection.assembly]::LoadFile("c:\test\ISESimpleSolution\ISESimpleSolution.dll")
$psISE.CurrentPowerShellTab.VerticalAddOnTools.Add("Solutions", [ISESimpleSolution.Solution], $true)
```

### SetSelectedPowerShellTab\( psTab \)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Selects the PowerShell tab that the **psTab** parameter specifies.

**psTab** - Microsoft.PowerShell.Host.ISE.PowerShellTab
The PowerShell tab to select.

```powershell
$newTab = $psISE.PowerShellTabs.Add()
# Change the DisplayName of the new PowerShell tab.
$newTab.DisplayName = 'Brand New Tab'
```

### Remove\( psTab \)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Removes the PowerShell tab that the **psTab** parameter specifies.

**psTab** - Microsoft.PowerShell.Host.ISE.PowerShellTab
The PowerShell tab to remove.

```powershell
$newTab = $psISE.PowerShellTabs.Add()
Change the DisplayName of the new PowerShell tab.
$newTab.DisplayName = 'This tab will go away in 5 seconds'
sleep 5
$psISE.PowerShellTabs.Remove($newTab)
```

## See Also

- [The PowerShellTab Object](The-PowerShellTab-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-iseaddontool-object.md

    ---
    description: An ISEAddonTool object represents an installed add-on tool that provides additional functionality to Windows PowerShell ISE.
    ms.date: 06/05/2017
    title: The ISEAddOnTool Object
    ---

# The ISEAddOnTool Object

An **ISEAddonTool** object represents an installed add-on tool that provides additional
functionality to Windows PowerShell ISE. An example is the **Commands** tool that you can display by
clicking **View**, then **Show Command Add-on**. This tool is then accessible to you by manipulating
the various available **ISEAddOnTool** objects.

Each add-on tool can be associated with either the vertical pane or the horizontal pane. The
vertical pane is docked to the right edge of Windows PowerShell ISE. The horizontal pane is docked
to the bottom edge.

Each PowerShell tab in Windows PowerShell ISE can have its own set of add-on tools installed. See
[$psISE.CurrentPowerShellTab.HorizontalAddOnTools](The-PowerShellTab-Object.md) and
[$psISE.CurrentPowerShellTab.VerticalAddOnTools](The-PowerShellTab-Object.md) to access the
collection of tools available to the currently selected tab or the same properties on any of the
**PowerShellTab** objects in the [$psISE.PowerShellTabs](The-PowerShellTabCollection-Object.md)
collection object.

## Methods

There are no Windows PowerShell ISE-specific methods available for objects of this class.

## Properties

### Control

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The **Control** property provides read access to many of the details of the Commands add-on tool.

```powershell
# View the properties of the Commands add-on tool.
# (assumes that it is visible in the vertical pane)
$psISE.CurrentVisibleVerticalTool.Control
```

```Output
HostObject                  : Microsoft.PowerShell.Host.ISE.ObjectModelRoot
Content                     :
HasContent                  :
ContentTemplate             :
ContentTemplateSelector     :
ContentStringFormat         :
BorderBrush                 :
BorderThickness             :
Background                  :
Foreground                  :
FontFamily                  :
FontSize                    :
FontStretch                 :
FontStyle                   :
FontWeight                  :
HorizontalContentAlignment  :
VerticalContentAlignment    :
TabIndex                    :
IsTabStop                   :
Padding                     :
Template                    : System.Windows.Controls.ControlTemplate
Style                       :
OverridesDefaultStyle       :
UseLayoutRounding           :
Triggers                    : {}
TemplatedParent             :
Resources                   : {System.Windows.Controls.TabItem}
DataContext                 :
BindingGroup                :
Language                    :
Name                        :
Tag                         :
InputScope                  :
ActualWidth                 : 370.75
ActualHeight                : 676.559097412109
LayoutTransform             :
Width                       :
MinWidth                    :
MaxWidth                    :
Height                      :
MinHeight                   :
MaxHeight                   :
FlowDirection               : LeftToRight
Margin                      :
HorizontalAlignment         :
VerticalAlignment           :
FocusVisualStyle            :
Cursor                      :
ForceCursor                 :
IsInitialized               : True
IsLoaded                    :
ToolTip                     :
ContextMenu                 :
Parent                      :
HasAnimatedProperties       :
InputBindings               :
CommandBindings             :
AllowDrop                   :
DesiredSize                 : 227.66,676.559097412109
IsMeasureValid              : True
IsArrangeValid              : True
RenderSize                  : 370.75,676.559097412109
RenderTransform             :
RenderTransformOrigin       :
IsMouseDirectlyOver         : False
IsMouseOver                 : False
IsStylusOver                : False
IsKeyboardFocusWithin       : False
IsMouseCaptured             :
IsMouseCaptureWithin        : False
IsStylusDirectlyOver        : False
IsStylusCaptured            :
IsStylusCaptureWithin       : False
IsKeyboardFocused           : False
IsInputMethodEnabled        :
Opacity                     :
OpacityMask                 :
BitmapEffect                :
Effect                      :
BitmapEffectInput           :
CacheMode                   :
Uid                         :
Visibility                  : Visible
ClipToBounds                : False
Clip                        :
SnapsToDevicePixels         : False
IsFocused                   :
IsEnabled                   :
IsHitTestVisible            :
IsVisible                   : True
Focusable                   :
PersistId                   : 1
IsManipulationEnabled       :
AreAnyTouchesOver           : False
AreAnyTouchesDirectlyOver   :
AreAnyTouchesCapturedWithin : False
AreAnyTouchesCaptured       :
TouchesCaptured             : {}
TouchesCapturedWithin       : {}
TouchesOver                 : {}
TouchesDirectlyOver         : {}
DependencyObjectType        : System.Windows.DependencyObjectType
IsSealed                    : False
Dispatcher                  : System.Windows.Threading.Dispatcher
```

### IsVisible

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The Boolean property that indicates whether the add-on tool is currently visible in its assigned
pane. If it is visible, you can set the **IsVisible** property to `$false` to hide the tool, or set
the **IsVisible** property to `$true` to make an add-on tool visible on its PowerShell tab. Note
that after an add-on tool is hidden, it is no longer accessible through the
**CurrentVisibleHorizontalTool** or **CurrentVisibleVerticalTool** objects, and therefore cannot be
made visible by using this property on that object.

```powershell
# Hide the current tool in the vertical tool pane
$psISE.CurrentVisibleVerticalTool.IsVisible = $false
# Show the first tool on the currently selected PowerShell tab
$psISE.CurrentPowerShellTab.VerticalAddOnTools[0].IsVisible = $true
```

### Name

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-only property that gets the name of the add-on tool.

```powershell
# Gets the name of the visible vertical pane add-on tool.
$psISE.CurrentVisibleVerticalTool.Name
```

```Output
Commands
```

## See Also

- [The ISEAddOnToolCollection Object](The-ISEAddOnToolCollection-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-iseeditor-object.md

    ---
    description: An ISEEditor object is an instance of the Microsoft.PowerShell.Host.ISE.ISEEditor class. The Console pane is an ISEEditor object.
    ms.date: 12/31/2019
    title: The ISEEditor Object
    ---

# The ISEEditor Object

An **ISEEditor** object is an instance of the Microsoft.PowerShell.Host.ISE.ISEEditor class. The
Console pane is an **ISEEditor** object. Each [ISEFile](The-ISEFile-Object.md) object has an
associated **ISEEditor** object. The following sections list the methods and properties of an
**ISEEditor** object.

## Methods

### Clear\(\)

Supported in Windows PowerShell ISE 2.0 and later.

Clears the text in the editor.

```powershell
# Clears the text in the Console pane.
$psISE.CurrentPowerShellTab.ConsolePane.Clear()
```

### EnsureVisible\(int lineNumber\)

Supported in Windows PowerShell ISE 2.0 and later.

Scrolls the editor so that the line that corresponds to the specified **lineNumber** parameter value
is visible. It throws an exception if the specified line number is outside the range of 1,last line
number, which defines the valid line numbers.

**lineNumber**
The number of the line that is to be made visible.

```powershell
# Scrolls the text in the Script pane so that the fifth line is in view.
$psISE.CurrentFile.Editor.EnsureVisible(5)
```

### Focus\(\)

Supported in Windows PowerShell ISE 2.0 and later.

Sets the focus to the editor.

```powershell
# Sets focus to the Console pane.
$psISE.CurrentPowerShellTab.ConsolePane.Focus()
```

### GetLineLength\(int lineNumber \)

Supported in Windows PowerShell ISE 2.0 and later.

Gets the line length as an integer for the line that is specified by the line number.

**lineNumber**
The number of the line of which to get the length.

**Returns**
The line length for the line at the specified line number.

```powershell
# Gets the length of the first line in the text of the Command pane.
$psISE.CurrentPowerShellTab.ConsolePane.GetLineLength(1)
```

### GoToMatch\(\)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Moves the caret to the matching character if the **CanGoToMatch** property of the editor object is
`$true`, which occurs when the caret is immediately before an opening parenthesis, bracket, or
brace - `(`,`[`,`{` - or immediately after a closing parenthesis, bracket, or brace - `)`,`]`,`}`. The caret
is placed before an opening character or after a closing character. If the **CanGoToMatch** property
is `$false`, then this method does nothing.

```powershell
# Goes to the matching character if CanGoToMatch() is $true
$psISE.CurrentPowerShellTab.ConsolePane.GoToMatch()
```

### InsertText\( text \)

Supported in Windows PowerShell ISE 2.0 and later.

Replaces the selection with text or inserts text at the current caret position.

**text** - String
The text to insert.

See the [Scripting Example](#scripting-example) later in this topic.

### Select\( startLine, startColumn, endLine, endColumn \)

Supported in Windows PowerShell ISE 2.0 and later.

Selects the text from the **startLine**, **startColumn**, **endLine**, and **endColumn** parameters.

**startLine** - Integer
The line where the selection starts.

**startColumn** - Integer
The column within the start line where the selection starts.

**endLine** - Integer
The line where the selection ends.

**endColumn** - Integer
The column within the end line where the selection ends.

See the  [Scripting Example](#scripting-example) later in this topic.

### SelectCaretLine\(\)

Supported in Windows PowerShell ISE 2.0 and later.

Selects the entire line of text that currently contains the caret.

```powershell
# First, set the caret position on line 5.
$psISE.CurrentFile.Editor.SetCaretPosition(5,1)
# Now select that entire line of text
$psISE.CurrentFile.Editor.SelectCaretLine()
```

### SetCaretPosition\( lineNumber, columnNumber \)

Supported in Windows PowerShell ISE 2.0 and later.

Sets the caret position at the line number and the column number. It throws an exception if either
the caret line number or the caret column number are out of their respective valid ranges.

**lineNumber** - Integer
The caret line number.

**columnNumber** - Integer
The caret column number.

```powershell
# Set the CaretPosition.
$psISE.CurrentFile.Editor.SetCaretPosition(5,1)
```

### ToggleOutliningExpansion\(\)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Causes all the outline sections to expand or collapse.

```powershell
# Toggle the outlining expansion
$psISE.CurrentFile.Editor.ToggleOutliningExpansion()
```

## Properties

### CanGoToMatch

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-only Boolean property to indicate whether the caret is next to a parenthesis, bracket, or
brace - `()`, `[]`, `{}`. If the caret is immediately before the opening character or immediately
after the closing character of a pair, then this property value is `$true`. Otherwise, it is
`$false`.

```powershell
# Test to see if the caret is next to a parenthesis, bracket, or brace
$psISE.CurrentFile.Editor.CanGoToMatch
```

### CaretColumn

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the column number that corresponds to the position of the caret.

```powershell
# Get the CaretColumn.
$psISE.CurrentFile.Editor.CaretColumn
```

### CaretLine

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the number of the line that contains the caret.

```powershell
# Get the CaretLine.
$psISE.CurrentFile.Editor.CaretLine
```

### CaretLineText

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the complete line of text that contains the caret.

```powershell
# Get all of the text on the line that contains the caret.
$psISE.CurrentFile.Editor.CaretLineText
```

### LineCount

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the line count from the editor.

```powershell
# Get the LineCount.
$psISE.CurrentFile.Editor.LineCount
```

### SelectedText

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the selected text from the editor.

See the  [Scripting Example](#scripting-example) later in this topic.

### Text

Supported in Windows PowerShell ISE 2.0 and later.

The read/write property that gets or sets the text in the editor.

See the [Scripting Example](#scripting-example) later in this topic.

## Scripting Example

```powershell
# This illustrates how you can use the length of a line to
# select the entire line and shows how you can make it lowercase.
# You must run this in the Console pane. It will not run in the Script pane.
# Begin by getting a variable that points to the editor.
$myEditor = $psISE.CurrentFile.Editor
# Clear the text in the current file editor.
$myEditor.Clear()

# Make sure the file has five lines of text.
$myEditor.InsertText("LINE1 `n")
$myEditor.InsertText("LINE2 `n")
$myEditor.InsertText("LINE3 `n")
$myEditor.InsertText("LINE4 `n")
$myEditor.InsertText("LINE5 `n")

# Use the GetLineLength method to get the length of the third line.
$endColumn = $myEditor.GetLineLength(3)
# Select the text in the first three lines.
$myEditor.Select(1, 1, 3, $endColumn + 1)
$selection = $myEditor.SelectedText
# Clear all the text in the editor.
$myEditor.Clear()
# Add the selected text back, but in lower case.
$myEditor.InsertText($selection.ToLower())
```

## See Also

- [The ISEFile Object](The-ISEFile-Object.md)
- [The PowerShellTab Object](The-PowerShellTab-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-isefilecollection-object.md

    ---
    description: The ISEFileCollection object is a collection of ISEFile objects.
    ms.date: 12/31/2019
    title: The ISEFileCollection Object
    ---

# The ISEFileCollection Object

The **ISEFileCollection** object is a collection of **ISEFile** objects. An example is the
`$psISE.CurrentPowerShellTab.Files` collection.

## Methods

### Add\( \[FullPath\] \)

Supported in Windows PowerShell ISE 2.0 and later.

Creates and returns a new untitled file and adds it to the collection. The **IsUntitled** property
of the newly created file is `$true`.

**\[FullPath\]** - Optional string The fully specified path of the file. An exception is generated
if you include the **FullPath** parameter and a relative path, or if you use a file name instead of
the full path.

```powershell
# Adds a new untitled file to the collection of files in the current PowerShell tab.
$newFile = $psISE.CurrentPowerShellTab.Files.Add()

# Adds a file specified by its full path to the collection of files in the current PowerShell tab.
$psISE.CurrentPowerShellTab.Files.Add("$pshome\Examples\profile.ps1")
```

### Remove\( File, \[Force\] \)

Supported in Windows PowerShell ISE 2.0 and later.

Removes a specified file from the current PowerShell tab.

**File** - String The ISEFile file that you want to remove from the collection. If the file has not
been saved, this method throws an exception. Use the **Force** switch parameter to force the removal
of an unsaved file.

**\[Force\]** - optional Boolean If set to `$true`, grants permission to remove the file even if it
has not been saved after last use. The default is `$false`.

```powershell
# Removes the first opened file from the file collection associated with the current PowerShell tab.
# If the file has not yet been saved, then an exception is generated.
$firstfile = $psISE.CurrentPowerShellTab.Files[0]
$psISE.CurrentPowerShellTab.Files.Remove($firstfile)

# Removes the first opened file from the file collection associated with the current PowerShell tab, even if it has not been saved.
$firstfile = $psISE.CurrentPowerShellTab.Files[0]
$psISE.CurrentPowerShellTab.Files.Remove($firstfile, $true)
```

### SetSelectedFile\( selectedFile \)

Supported in Windows PowerShell ISE 2.0 and later.

Selects the file that is specified by the **SelectedFile** parameter.

**SelectedFile** - Microsoft.PowerShell.Host.ISE.ISEFile
The ISEFile file that you want to select.

```powershell
# Selects the specified file.
$firstfile = $psISE.CurrentPowerShellTab.Files[0]
$psISE.CurrentPowerShellTab.Files.SetSelectedFile($firstfile)
```

## See Also

- [The ISEFile Object](The-ISEFile-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-isefile-object.md

    ---
    description: An ISEFile object represents a file in Windows PowerShell ISE.
    ms.date: 12/31/2019
    title: The ISEFile Object
    ---

# The ISEFile Object

An **ISEFile** object represents a file in Windows PowerShell Integrated Scripting Environment
(ISE). It is an instance of the **Microsoft.PowerShell.Host.ISE.ISEFile** class. This topic lists
its member methods and member properties. The `$psISE.CurrentFile` and the files in the Files
collection in a PowerShell tab are all instances of the ****Microsoft.PowerShell.Host.ISE.ISEFile**
class.

## Methods

### Save\( \[saveEncoding\] \)

Supported in Windows PowerShell ISE 2.0 and later.

Saves the file to disk.

`[saveEncoding]` - optional [System.Text.Encoding](/dotnet/api/system.text.encoding) An optional
character encoding parameter to be used for the saved file. The default value is **UTF8**.

### Exceptions

- **System.IO.IOException**: The file could not be saved.

```powershell
# Save the file using the default encoding (UTF8)
$psISE.CurrentFile.Save()

# Save the file as ASCII.
$psISE.CurrentFile.Save([System.Text.Encoding]::ASCII)

# Gets the current encoding.
$myfile = $psISE.CurrentFile
$myfile.Encoding
```

### SaveAs\(filename, \[saveEncoding\]\)

Supported in Windows PowerShell ISE 2.0 and later.

Saves the file with the specified file name and encoding.

**filename** - String
The name to be used to save the file.

`[saveEncoding]` - optional [System.Text.Encoding](/dotnet/api/system.text.encoding) An optional
character encoding parameter to be used for the saved file. The default value is **UTF8**.

### Exceptions

- **System.ArgumentNullException**: The **filename** parameter is null.
- **System.ArgumentException**: The **filename** parameter is empty.
- **System.IO.IOException**: The file could not be saved.

```powershell
# Save the file with a full path and name.
$fullpath = "c:\temp\newname.txt"
$psISE.CurrentFile.SaveAs($fullPath)
# Save the file with a full path and name and explicitly as UTF8.
$psISE.CurrentFile.SaveAs($fullPath, [System.Text.Encoding]::UTF8)
```

## Properties

### DisplayName

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the string that contains the display name of this file. The name is
shown on the **File** tab at the top of the editor. The presence of an asterisk `(*)` at the end of
the name indicates that the file has changes that have not been saved.

```powershell
# Shows the display name of the file.
$psISE.CurrentFile.DisplayName
```

### Editor

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the [editor object](The-ISEEditor-Object.md) that is used for the
specified file.

```powershell
# Gets the editor and the text.
$psISE.CurrentFile.Editor.Text
```

### Encoding

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the original file encoding. This is a **System.Text.Encoding**
object.

```powershell
# Shows the encoding for the file.
$psISE.CurrentFile.Encoding
```

### FullPath

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the string that specifies the full path of the opened file.

```powershell
# Shows the full path for the file.
$psISE.CurrentFile.FullPath
```

### IsSaved

Supported in Windows PowerShell ISE 2.0 and later.

The read-only Boolean property that returns `$true` if the file has been saved after it was last
modified.

```powershell
# Determines whether the file has been saved since it was last modified.
$myfile = $psISE.CurrentFile
$myfile.IsSaved
```

### IsUntitled

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that returns `$true` if the file has never been given a title.

```powershell
# Determines whether the file has never been given a title.
$psISE.CurrentFile.IsUntitled
$psISE.CurrentFile.SaveAs("temp.txt")
$psISE.CurrentFile.IsUntitled
```

## See Also

- [The ISEFileCollectionObject](The-ISEFileCollection-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-isemenuitemcollection-object.md

    ---
    description: An ISEMenuItemCollection object is a collection of ISEMenuItem objects.
    ms.date: 10/05/2021
    title: The ISEMenuItemCollection Object
    ---

# The ISEMenuItemCollection Object

An **ISEMenuItemCollection** object is a collection of **ISEMenuItem** objects. It is an instance of
the **Microsoft.PowerShell.Host.ISE.ISEMenuItemCollection** class. An example is the
`$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus` object that is used to customize the **Add-On**
menu in Windows PowerShell&reg; Integrated Scripting Environment (ISE).

## Method

### Add\(string DisplayName, System.Management.Automation.ScriptBlock Action, System.Windows.Input.KeyGesture Shortcut \)

Supported in Windows PowerShell ISE 2.0 and later.

Adds a menu item to the collection.

**DisplayName**
The display name of the menu to be added.

**Action** The **System.Management.Automation.ScriptBlock** object that specifies the action that is
associated with this menu item.

**Shortcut**
The keyboard shortcut for the action.

**Returns**
The **ISEMenuItem** object that was just added.

```powershell
# Create an Add-ons menu with a fast access key and a shortcut.
# Note the use of "_"  as opposed to the "&" for mapping to the fast access key letter for the menu item.
$menuAdded = $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('_Process', {Get-Process}, 'Alt+P')
```

### Clear\(\)

Supported in Windows PowerShell ISE 2.0 and later.

Removes all submenus from the menu item.

```powershell
# Remove all custom submenu items from the AddOns menu
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear()
```

## See Also

- [The ISEMenuItem Object](The-ISEMenuItem-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-isemenuitem-object.md

    ---
    description: An ISEMenuItem object is an instance of the Microsoft.PowerShell.Host.ISE.ISEMenuItem class. All menu objects on the **Add-ons** menu are instances of the ISEMenuItem class.
    ms.date: 10/05/2021
    title: The ISEMenuItem Object
    ---

# The ISEMenuItem Object

An **ISEMenuItem** object is an instance of the **Microsoft.PowerShell.Host.ISE.ISEMenuItem** class.
All menu objects on the **Add-ons** menu are instances of the
**Microsoft.PowerShell.Host.ISE.ISEMenuItem** class.

## Properties

### DisplayName

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the display name of the menu item.

```powershell
# Get the display name of the Add-ons menu item
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear()
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('_Process', {Get-Process}, 'Alt+P')
$psISE.CurrentPowerShellTab.AddOnsMenu.DisplayName
```

### Action

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the block of script. It invokes the action when you click the menu
item.

```powershell
# Get the action associated with the first submenu item.
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear()
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('_Process', {Get-Process}, 'Alt+P')
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus[0].Action

# Invoke the script associated with the first submenu item
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus[0].Action.Invoke()
```

### Shortcut

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the Windows input keyboard shortcut for the menu item.

```powershell
# Get the shortcut for the first submenu item.
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear()
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('_Process', {Get-Process}, 'Alt+P')
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus[0].Shortcut
```

### Submenus

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the [list of submenus](The-ISEMenuItemCollection-Object.md) of the
menu item.

```powershell
# List the submenus of the Add-ons menu
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear()
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('_Process', {Get-Process}, 'Alt+P')
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus
```

## Scripting example

To better understand the use of the Add-ons menu and its scriptable properties, read through the
following scripting example.

```powershell
# This is a scripting example that shows the use of the Add-ons menu.
# Clear the Add-ons menu if any entries currently exist
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear()

# Add an Add-ons menu item with a shortcut and fast access key.
# Note the use of "_"  as opposed to the "&" for mapping to the fast access key letter for the menu item.
$menuAdded = $psISE.CurrentPowerShellTab.AddOnsMenu.SubMenus.Add('_Process', {Get-Process}, 'Alt+P')
# Add a nested menu - a parent and a child submenu item.
$parentAdded = $psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('Parent', $null, $null)
$parentAdded.SubMenus.Add('_Dir', {dir}, 'Alt+D')
```

## See Also

- [The ISEMenuItemCollection Object](The-ISEMenuItemCollection-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-iseoptions-object.md

    ---
    description: The ISEOptions object represents various settings for Windows PowerShell ISE.
    ms.date: 12/31/2019
    title: The ISEOptions Object
    ---

# The ISEOptions Object

The **ISEOptions** object represents various settings for Windows PowerShell ISE. It is an instance
of the **Microsoft.PowerShell.Host.ISE.ISEOptions** class.

The **ISEOptions** object provides the following methods and properties.

## Methods

### RestoreDefaultConsoleTokenColors\(\)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Restores the default values of the token colors in the Console pane.

```powershell
# Changes the color of the commands in the Console pane to red and then restores it to its default value.
$psISE.Options.ConsoleTokenColors["Command"] = 'red'
$psISE.Options.RestoreDefaultConsoleTokenColors()
```

### RestoreDefaults\(\)

Supported in Windows PowerShell ISE 2.0 and later.

Restores the default values of all options settings in the Console pane. It also resets the behavior
of various warning messages that provide the standard check box to prevent the message from being
shown again.

```powershell
# Changes the background color in the Console pane and then restores it to its default value.
$psISE.Options.ConsolePaneBackgroundColor = 'orange'
$psISE.Options.RestoreDefaults()
```

### RestoreDefaultTokenColors\(\)

Supported in Windows PowerShell ISE 2.0 and later.

Restores the default values of the token colors in the Script pane.

```powershell
# Changes the color of the comments in the Script pane to red and then restores it to its default value.
$psISE.Options.TokenColors["Comment"] = 'red'
$psISE.Options.RestoreDefaultTokenColors()
```

### RestoreDefaultXmlTokenColors\(\)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Restores the default values of the token colors for XML elements that are displayed in Windows
PowerShell ISE. Also see [XmlTokenColors](#xmltokencolors).

```powershell
# Changes the color of the comments in XML data to red and then restores it to its default value.
$psISE.Options.XmlTokenColors["Comment"] = 'red'
$psISE.Options.RestoreDefaultXmlTokenColors()
```

## Properties

### AutoSaveMinuteInterval

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the number of minutes between automatic save operations of your files by Windows
PowerShell ISE. The default value is 2 minutes. The value is an integer.

```powershell
# Changes the number of minutes between automatic save operations to every 3 minutes.
$psISE.Options.AutoSaveMinuteInterval = 3
```

### CommandPaneBackgroundColor

This feature is present in Windows PowerShell ISE 2.0, but was removed or renamed in later versions
of the ISE. For later versions, see [ConsolePaneBackgroundColor](#consolepanebackgroundcolor).

Specifies the background color for the Command pane. It is an instance of the
**System.Windows.Media.Color** class.

```powershell
# Changes the background color of the Command pane to orange.
$psISE.Options.CommandPaneBackgroundColor = 'orange'
```

### CommandPaneUp

This feature is present in Windows PowerShell ISE 2.0, but was removed or renamed in later versions
of the ISE.

Specifies whether the Command pane is located above the Output pane.

```powershell
# Moves the Command pane to the top of the screen.
$psISE.Options.CommandPaneUp  = $true
```

### ConsolePaneBackgroundColor

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the background color for the Console pane. It is an instance of the
**System.Windows.Media.Color** class.

```powershell
# Changes the background color of the Console pane to red.
$psISE.Options.ConsolePaneBackgroundColor = 'red'
```

### ConsolePaneForegroundColor

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the foreground color of the text in the Console pane.

```powershell
# Changes the foreground color of the text in the Console pane to yellow.
$psISE.Options.ConsolePaneForegroundColor  = 'yellow'
```

### ConsolePaneTextBackgroundColor

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the background color of the text in the Console pane.

```powershell
# Changes the background color of the Console pane text to pink.
$psISE.Options.ConsolePaneTextBackgroundColor = 'pink'
```

### ConsoleTokenColors

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the colors of the IntelliSense tokens in the Windows PowerShell ISE Console pane. This
property is a dictionary object that contains name/value pairs of token types and colors for the
Console pane. To change the colors of the IntelliSense tokens in the Script pane, see [TokenColors](#tokencolors).
To reset the colors to the default values, see [RestoreDefaultConsoleTokenColors](#restoredefaultconsoletokencolors).
Token colors can be set for the following: Attribute, Command, CommandArgument, CommandParameter,
Comment, GroupEnd, GroupStart, Keyword, LineContinuation, LoopLabel, Member, NewLine, Number,
Operator, Position, StatementSeparator, String, Type, Unknown, Variable.

```powershell
# Sets the color of commands to green.
$psISE.Options.ConsoleTokenColors["Command"] = 'green'
# Sets the color of keywords to magenta.
$psISE.Options.ConsoleTokenColors["Keyword"] = 'magenta'
```

### DebugBackgroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the background color for the debug text that appears in the Console pane. It is an
instance of the **System.Windows.Media.Color** class.

```powershell
# Changes the background color for the debug text that appears in the Console pane to blue.
$psISE.Options.DebugBackgroundColor = '#0000FF'
```

### DebugForegroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the foreground color for the debug text that appears in the Console pane. It is an
instance of the **System.Windows.Media.Color** class.

```powershell
# Changes the foreground color for the debug text that appears in the Console pane to yellow.
$psISE.Options.DebugForegroundColor = 'yellow'
```

### DefaultOptions

Supported in Windows PowerShell ISE 2.0 and later.

A collection of properties that specify the default values to be used when the Reset methods are used.

```powershell
# Displays the name of the default options. This example is from ISE 4.0.
$psISE.Options.DefaultOptions
```

```Output
SelectedScriptPaneState                   : Top
ShowDefaultSnippets                       : True
ShowToolBar                               : True
ShowOutlining                             : True
ShowLineNumbers                           : True
TokenColors                               : {[Attribute, #FF00BFFF], [Command, #FF0000FF], [CommandArgument, #FF8A2BE2], [CommandParameter, #FF000080]...}
ConsoleTokenColors                        : {[Attribute, #FFB0C4DE], [Command, #FFE0FFFF], [CommandArgument, #FFEE82EE], [CommandParameter, #FFFFE4B5]...}
XmlTokenColors                            : {[Comment, #FF006400], [CommentDelimiter, #FF008000], [ElementName, #FF8B0000], [MarkupExtension, #FFFF8C00]...}
DefaultOptions                            : Microsoft.PowerShell.Host.ISE.ISEOptions
FontSize                                  : 9
Zoom                                      : 100
FontName                                  : Lucida Console
ErrorForegroundColor                      : #FFFF0000
ErrorBackgroundColor                      : #00FFFFFF
WarningForegroundColor                    : #FFFF8C00
WarningBackgroundColor                    : #00FFFFFF
VerboseForegroundColor                    : #FF00FFFF
VerboseBackgroundColor                    : #00FFFFFF
DebugForegroundColor                      : #FF00FFFF
DebugBackgroundColor                      : #00FFFFFF
ConsolePaneBackgroundColor                : #FF012456
ConsolePaneTextBackgroundColor            : #FF012456
ConsolePaneForegroundColor                : #FFF5F5F5
ScriptPaneBackgroundColor                 : #FFFFFFFF
ScriptPaneForegroundColor                 : #FF000000
ShowWarningForDuplicateFiles              : True
ShowWarningBeforeSavingOnRun              : True
UseLocalHelp                              : True
AutoSaveMinuteInterval                    : 2
MruCount                                  : 10
ShowIntellisenseInConsolePane             : True
ShowIntellisenseInScriptPane              : True
UseEnterToSelectInConsolePaneIntellisense : True
UseEnterToSelectInScriptPaneIntellisense  : True
IntellisenseTimeoutInSeconds              : 3
```

### ErrorBackgroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the background color for error text that appears in the Console pane. It is an instance of
the **System.Windows.Media.Color** class.

```powershell
# Changes the background color for the error text that appears in the Console pane to black.
$psISE.Options.ErrorBackgroundColor = 'black'
```

### ErrorForegroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the foreground color for error text that appears in the Console pane. It is an instance of
the **System.Windows.Media.Color** class.

```powershell
# Changes the foreground color for the error text that appears in the console pane to green.
$psISE.Options.ErrorForegroundColor = 'green'
```

### FontName

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the font name currently in use in both the Script pane and the Console pane.

```powershell
# Changes the font used in both panes.
$psISE.Options.FontName = 'Courier New'
```

### FontSize

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the font size as an integer. It is used in the Script pane, the Command pane, and the
Output pane. The valid range of values is 8 through 32.

```powershell
# Changes the font size in all panes.
$psISE.Options.FontSize = 20
```

### IntellisenseTimeoutInSeconds

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the number of seconds that IntelliSense uses to try to resolve the currently typed text.
After this number of seconds, IntelliSense times out and enables you to continue typing. The default
value is 3 seconds. The value is an integer.

```powershell
# Changes the number of seconds for IntelliSense syntax recognition to 5.
$psISE.Options.IntellisenseTimeoutInSeconds = 5
```

### MruCount

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the number of recently opened files that Windows PowerShell ISE tracks and displays at the
bottom of the **File Open** menu. The default value is 10. The value is an integer.

```powershell
# Changes the number of recently used files that appear at the bottom of the File Open menu to 5.
$psISE.Options.MruCount = 5
```

### OutputPaneBackgroundColor

This feature is present in Windows PowerShell ISE 2.0, but was removed or renamed in later versions
of the ISE. For later versions, see [ConsolePaneBackgroundColor](#consolepanebackgroundcolor).

The read/write property that gets or sets the background color for the Output pane itself. It is an
instance of the **System.Windows.Media.Color** class.

```powershell
# Changes the background color of the Output pane to gold.
$psISE.Options.OutputPaneForegroundColor = 'gold'
```

### OutputPaneTextForegroundColor

This feature is present in Windows PowerShell ISE 2.0, but was removed or renamed in later versions
of the ISE. For later versions, see [ConsolePaneForegroundColor](#consolepaneforegroundcolor).

The read/write property that changes the foreground color of the text in the Output pane in Windows
PowerShell ISE 2.0.

```powershell
# Changes the foreground color of the text in the Output Pane to blue.
$psISE.Options.OutputPaneTextForegroundColor  = 'blue'
```

### OutputPaneTextBackgroundColor

This feature is present in Windows PowerShell ISE 2.0, but was removed or renamed in later versions
of the ISE. For later versions, see [ConsolePaneTextBackgroundColor](#consolepanetextbackgroundcolor).

The read/write property that changes the background color of the text in the Output pane.

```powershell
# Changes the background color of the Output pane text to pink.
$psISE.Options.OutputPaneTextBackgroundColor = 'pink'
```

### ScriptPaneBackgroundColor

Supported in Windows PowerShell ISE 2.0 and later.

The read/write property that gets or sets the background color for files. It is an instance of the
**System.Windows.Media.Color** class.

```powershell
# Sets the color of the script pane background to yellow.
$psISE.Options.ScriptPaneBackgroundColor = 'yellow'
```

### ScriptPaneForegroundColor

Supported in Windows PowerShell ISE 2.0 and later.

The read/write property that gets or sets the foreground color for non-script files in the Script pane.
To set the foreground color for script files, use the [TokenColors](#tokencolors).

```powershell
# Sets the foreground to color of non-script files in the script pane to green.
$psISE.Options.ScriptPaneBackgroundColor = 'green'
```

### SelectedScriptPaneState

Supported in Windows PowerShell ISE 2.0 and later.

The read/write property that gets or sets the position of the Script pane on the display. The string
can be either 'Maximized', 'Top', or 'Right'.

```powershell
# Moves the Script Pane to the top.
$psISE.Options.SelectedScriptPaneState = 'Top'
# Moves the Script Pane to the right.
$psISE.Options.SelectedScriptPaneState = 'Right'
# Maximizes the Script Pane
$psISE.Options.SelectedScriptPaneState = 'Maximized'
```

### ShowDefaultSnippets

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether the <kbd>CTRL</kbd>+<kbd>J</kbd> list of snippets includes the starter set that is included in
Windows PowerShell. When set to `$false`, only user-defined snippets appear in the <kbd>CTRL</kbd>+<kbd>J</kbd> list.
The default value is `$true`.

```powershell
# Hide the default snippets from the CTRL+J list.
$psISE.Options.ShowDefaultSnippets = $false
```

### ShowIntellisenseInConsolePane

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether IntelliSense offers syntax, parameter, and value suggestions in the Console pane.
The default value is `$true`.

```powershell
# Turn off IntelliSense in the console pane.
$psISE.Options.ShowIntellisenseInConsolePane = $false
```

### ShowIntellisenseInScriptPane

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether IntelliSense offers syntax, parameter, and value suggestions in the Script pane.
The default value is `$true`.

```powershell
# Turn off IntelliSense in the Script pane.
$psISE.Options.ShowIntellisenseInScriptPane = $false
```

### ShowLineNumbers

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether the Script pane displays line numbers in the left margin. The default value is `$true`.

```powershell
# Turn off line numbers in the Script pane.
$psISE.Options.ShowLineNumbers = $false
```

### ShowOutlining

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether the Script pane displays expandable and collapsible brackets next to sections of
code in the left margin. When they are displayed, you can click the minus `-` icons next to a
block of text to collapse it or click the plus `+` icon to expand a block of text. The default
value is `$true`.

```powershell
# Turn off outlining in the Script pane.
$psISE.Options.ShowOutlining = $false
```

### ShowToolBar

Supported in Windows PowerShell ISE 2.0 and later.

Specifies whether the ISE toolbar appears at the top of the Windows PowerShell ISE window. The
default value is `$true`.

```powershell
# Show the toolbar.
$psISE.Options.ShowToolBar = $true
```

### ShowWarningBeforeSavingOnRun

Supported in Windows PowerShell ISE 2.0 and later.

Specifies whether a warning message appears when a script is saved automatically before it is run.
The default value is `$true`.

```powershell
# Enable the warning message when an attempt
# is made to run a script without saving it first.
$psISE.Options.ShowWarningBeforeSavingOnRun = $true
```

### ShowWarningForDuplicateFiles

Supported in Windows PowerShell ISE 2.0 and later.

Specifies whether a warning message appears when the same file is opened in different PowerShell
tabs. If set to `$true`, to open the same file in multiple tabs displays this message: "A copy of
this file is open in another Windows PowerShell tab. Changes made to this file will affect all open
copies." The default value is `$true`.

```powershell
# Enable the warning message when a file is
# opened in multiple PowerShell tabs.
$psISE.Options.ShowWarningForDuplicateFiles = $true
```

### TokenColors

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the colors of the IntelliSense tokens in the Windows PowerShell ISE Script pane. This
property is a dictionary object that contains name/value pairs of token types and colors for the
Script pane. To change the colors of the IntelliSense tokens in the Console pane, see [ConsoleTokenColors](#consoletokencolors).
To reset the colors to the default values, see [RestoreDefaultTokenColors](#restoredefaulttokencolors).
Token colors can be set for the following: Attribute, Command, CommandArgument, CommandParameter,
Comment, GroupEnd, GroupStart, Keyword, LineContinuation, LoopLabel, Member, NewLine, Number,
Operator, Position, StatementSeparator, String, Type, Unknown, Variable.

```powershell
# Sets the color of commands to green.
$psISE.Options.TokenColors["Command"] = "green"
# Sets the color of keywords to magenta.
$psISE.Options.TokenColors["Keyword"] = "magenta"
```

### UseEnterToSelectInConsolePaneIntellisense

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether you can use the Enter key to select an IntelliSense provided option in the Console
pane. The default value is `$true`.

```powershell
# Turn off using the ENTER key to select an IntelliSense provided option in the Console pane.
$psISE.Options.UseEnterToSelectInConsolePaneIntellisense = $false
```

### UseEnterToSelectInScriptPaneIntellisense

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether you can use the Enter key to select an IntelliSense-provided option in the Script
pane. The default value is `$true`.

```powershell
# Turn on using the Enter key to select an IntelliSense provided option in the Console pane.
$psISE.Options.UseEnterToSelectInConsolePaneIntellisense = $true
```

### UseLocalHelp

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies whether the locally installed Help or the online Help appears when you press <kbd>F1</kbd>
with the cursor positioned in a keyword. If set to `$true`, then a pop-up window shows content from
the locally installed Help. You can install the Help files by running the `Update-Help` command. If
set to `$false`, then your browser opens to a page on Microsoft Learn.

```powershell
# Sets the option for the online help to be displayed.
$psISE.Options.UseLocalHelp = $false
# Sets the option for the local Help to be displayed.
$psISE.Options.UseLocalHelp = $true
```

### VerboseBackgroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the background color for verbose text that appears in the Console pane. It is a
**System.Windows.Media.Color** object.

```powershell
# Changes the background color for verbose text to blue.
$psISE.Options.VerboseBackgroundColor ='#0000FF'
```

### VerboseForegroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the foreground color for verbose text that appears in the Console pane. It is a
**System.Windows.Media.Color** object.

```powershell
# Changes the foreground color for verbose text to yellow.
$psISE.Options.VerboseForegroundColor = 'yellow'
```

### WarningBackgroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the background color for warning text that appears in the Console pane. It is a
**System.Windows.Media.Color** object.

```powershell
# Changes the background color for warning text to blue.
$psISE.Options.WarningBackgroundColor = '#0000FF'
```

### WarningForegroundColor

Supported in Windows PowerShell ISE 2.0 and later.

Specifies the foreground color for warning text that appears in the Output pane. It is a
**System.Windows.Media.Color** object.

```powershell
# Changes the foreground color for warning text to yellow.
$psISE.Options.WarningForegroundColor = 'yellow'
```

### XmlTokenColors

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies a dictionary object that contains name/value pairs of token types and colors for XML
content that is displayed in Windows PowerShell ISE. Token colors can be set for the following:
Attribute, Command, CommandArgument, CommandParameter, Comment, GroupEnd, GroupStart, Keyword,
LineContinuation, LoopLabel, Member, NewLine, Number, Operator, Position, StatementSeparator,
String, Type, Unknown, Variable. Also see [RestoreDefaultXmlTokenColors](#restoredefaultxmltokencolors).

```powershell
# Sets the color of XML element names to green.
$psISE.Options.XmlTokenColors["ElementName"] = 'green'
# Sets the color of XML comments to magenta.
$psISE.Options.XmlTokenColors["Comment"] = 'magenta'
```

### Zoom

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Specifies the relative size of text in both the Console and Script panes. The default value is 100.
Smaller values cause the text in Windows PowerShell ISE to appear smaller while larger numbers cause
text to appear larger. The value is an integer that ranges from 20 to 400.

```powershell
# Changes the text in the Windows PowerShell ISE to be double its normal size.
$psISE.Options.Zoom = 200
```

## See Also

- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-isesnippetcollection-object.md

    ---
    description: The ISESnippetCollection object is a collection of ISESnippet objects. The files collection that is associated with a PowerShellTab object is a member of this class.
    ms.date: 12/31/2019
    title: The ISESnippetCollection Object
    ---

# The ISESnippetCollection Object

The **ISESnippetCollection** object is a collection of **ISESnippet** objects. The files collection
that is associated with a **PowerShellTab** object is a member of this class. An example is the
`$psISE.CurrentPowerShellTab.Files` collection.

## Methods

### Load\( FilePathName \)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Loads a `.snippets.ps1xml` file that contains user-defined snippets. The easiest way to create
snippets is to use the `New-IseSnippet` cmdlet, which automatically stores them in your profile folder
so that they are loaded every time that you start Windows PowerShell ISE.

**FilePathName** - String
The path and file name to a .snippets.ps1xml file that contains snippet definitions.

```powershell
# Loads a custom snippet file into the current PowerShell tab.
$SnipFile = Join-Path ( Split-Path $profile) 'Snippets\MySnips.snippets.ps1xml' $psISE.CurrentPowerShellTab.Snippets.Add($SnipPath)
```

## See Also

- [The ISESnippetObject](The-ISESnippetObject.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-isesnippetobject.md

    ---
    description: An ISESnippet object is an instance of the Microsoft.PowerShell.Host.ISE.ISESnippet class.
    ms.date: 06/05/2017
    title: The ISESnippetObject
    ---

# The ISESnippetObject

An **ISESnippet** object is an instance of the Microsoft.PowerShell.Host.ISE.ISESnippet class. The
members of the `$psISE.CurrentPowerShellTab.Snippets` collection are all examples of **ISESnippet**
objects. The easiest way to create a snippet is to use the
[New-IseSnippet](/powershell/module/ISE/New-IseSnippet) cmdlet.

## Properties

### Author

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-only property that gets the name of the author of the snippet.

```powershell
# Get the author of the first snippet item
$psISE.CurrentPowerShellTab.Snippets.Item(0).Author
```

### CodeFragment

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-only property that gets the code fragment to be inserted into the editor.

```powershell
# Get the code fragment associated with the first snippet item.
$psISE.CurrentPowerShellTab.Snippets.Item(0).CodeFragment
```

### Shortcut

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-only property that gets the Windows keyboard shortcut for the menu item.

```powershell
# Get the shortcut for the first submenu item.
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Clear()
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus.Add('_Process', {Get-Process}, 'Alt+P')
$psISE.CurrentPowerShellTab.AddOnsMenu.Submenus[0].Shortcut
```

## See Also

- [The ISESnippetCollection Object](The-ISESnippetCollection-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](purpose-of-the-windows-powershell-ise-scripting-object-model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-powershelltabcollection-object.md

    ---
    description: The PowerShellTab collection object is a collection of PowerShellTab objects. Each PowerShellTab object functions as a separate runtime environment.
    ms.date: 06/05/2017
    title: The PowerShellTabCollection Object
    ---
# The PowerShellTabCollection Object

The **PowerShellTab** collection object is a collection of **PowerShellTab** objects. Each
**PowerShellTab** object functions as a separate runtime environment. It is an instance of
Microsoft.PowerShell.Host.ISE.PowerShellTabs class. An example is the `$psISE.PowerShellTabs`
object.

## Methods

### Add\(\)

Supported in Windows PowerShell ISE 2.0 and later.

Adds a new PowerShell tab to the collection. It returns the newly added tab.

```powershell
$newTab = $psISE.PowerShellTabs.Add()
$newTab.DisplayName = 'Brand New Tab'
```

### Remove\(Microsoft.PowerShell.Host.ISE.PowerShellTab psTab\)

Supported in Windows PowerShell ISE 2.0 and later.

Removes the tab that is specified by the **psTab** parameter.

**psTab**
The PowerShell tab to remove.

```powershell
$newTab = $psISE.PowerShellTabs.Add()
Change the DisplayName of the new PowerShell tab.
$newTab.DisplayName = 'This tab will go away in 5 seconds'
sleep 5
$psISE.PowerShellTabs.Remove($newTab)
```

### SetSelectedPowerShellTab\(Microsoft.PowerShell.Host.ISE.PowerShellTab psTab\)

Supported in Windows PowerShell ISE 2.0 and later.

Selects the PowerShell tab that is specified by the **psTab** parameter to make it the currently
active PowerShell tab.

**psTab**
The PowerShell tab to select.

```powershell
# Save the current tab in a variable and rename it
$oldTab = $psISE.CurrentPowerShellTab
$psISE.CurrentPowerShellTab.DisplayName = 'Old Tab'
# Create a new tab and give it a new display name
$newTab = $psISE.PowerShellTabs.Add()
$newTab.DisplayName = 'Brand New Tab'
# Switch back to the original tab
$psISE.PowerShellTabs.SelectedPowerShellTab = $oldTab
```

## See Also

- [The PowerShellTab Object](The-PowerShellTab-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/the-powershelltab-object.md

    ---
    description: The PowerShellTab object represents a Windows PowerShell runtime environment.
    ms.date: 06/05/2017
    title: The PowerShellTab Object
    ---

# The PowerShellTab Object

The **PowerShellTab** object represents a Windows PowerShell runtime environment.

## Methods

### Invoke\( Script \)

Supported in Windows PowerShell ISE 2.0 and later.

Runs the given script in the PowerShell tab.

> [!NOTE]
> This method only works on other PowerShell tabs, not the PowerShell tab from which it is run. It
> does not return any object or value. If the code modifies any variable, then those changes persist
> on the tab against which the command was invoked.

**Script** - System.Management.Automation.ScriptBlock or String
The script block to run.

```powershell
# Manually create a second PowerShell tab before running this script.
# Return to the first PowerShell tab and type the following command
$psISE.PowerShellTabs[1].Invoke({dir})
```

### InvokeSynchronous\( Script, \[useNewScope\], millisecondsTimeout \)

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

Runs the given script in the PowerShell tab.

> [!NOTE]
> This method only works on other PowerShell tabs, not the PowerShell tab from which it is run. The
> script block is run and any value that is returned from the script is returned to the run
> environment from which you invoked the command. If the command takes longer to run than the
> **millesecondsTimeout** value specifies, then the command fails with an exception: "The operation
> has timed out."

**Script** - System.Management.Automation.ScriptBlock or String
The script block to run.

**\[useNewScope\]** -  Optional Boolean that defaults to `$true`
If set to `$true`, then a new scope is created within which to run the command. It does not modify
the runtime environment of the PowerShell tab that is specified by the command.

**\[millisecondsTimeout\]** -  Optional integer that defaults to **500**.
If the command does not finish within the specified time, then the command generates a
**TimeoutException** with the message "The operation has timed out."

```powershell
# Create a new PowerShell tab and then switch back to the first
$psISE.PowerShellTabs.Add()
$psISE.PowerShellTabs.SetSelectedPowerShellTab($psISE.PowerShellTabs[0])

# Invoke a simple command on the other tab, in its own scope
$psISE.PowerShellTabs[1].InvokeSynchronous('$x=1', $false)
# You can switch to the other tab and type '$x' to see that the value is saved there.

# This example sets a value in the other tab (in a different scope)
# and returns it through the pipeline to this tab to store in $a
$a = $psISE.PowerShellTabs[1].InvokeSynchronous('$z=3;$z')
$a

# This example runs a command that takes longer than the allowed timeout value
# and measures how long it runs so that you can see the impact
Measure-Command {$psISE.PowerShellTabs[1].InvokeSynchronous('sleep 10', $false, 5000)}
```

## Properties

### AddOnsMenu

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the Add-ons menu for the PowerShell tab.

```powershell
# Clear the Add-ons menu if one exists.
$psISE.CurrentPowerShellTab.AddOnsMenu.SubMenus.Clear()
# Create an AddOns menu with an accessor.
# Note the use of "_"  as opposed to the "&" for mapping to the fast key letter for the menu item.
$menuAdded = $psISE.CurrentPowerShellTab.AddOnsMenu.SubMenus.Add('_Process', {Get-Process}, 'Alt+P')
# Add a nested menu.
$parentAdded = $psISE.CurrentPowerShellTab.AddOnsMenu.SubMenus.Add('Parent', $null, $null)
$parentAdded.SubMenus.Add('_Dir', {dir}, 'Alt+D')
# Show the Add-ons menu on the current PowerShell tab.
$psISE.CurrentPowerShellTab.AddOnsMenu
```

### CanInvoke

Supported in Windows PowerShell ISE 2.0 and later.

The read-only Boolean property that returns a `$true` value if a script can be invoked with the [Invoke( Script )](#invoke-script-)
method.

```powershell
# CanInvoke will be false if the PowerShell
# tab is running a script that takes a while, and you
# check its properties from another PowerShell tab. It is
# always false if checked on the current PowerShell tab.
# Manually create a second PowerShell tab before running this script.
# Return to the first tab and type
$secondTab = $psISE.PowerShellTabs[1]
$secondTab.CanInvoke
$secondTab.Invoke({sleep 20})
$secondTab.CanInvoke
```

### ConsolePane

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions. In Windows
PowerShell ISE 2.0 this was named **CommandPane**.

The read-only property that gets the Console pane [editor](The-ISEEditor-Object.md) object.

```powershell
# Gets the Console Pane editor.
$psISE.CurrentPowerShellTab.ConsolePane
```

### DisplayName

Supported in Windows PowerShell ISE 2.0 and later.

The read-write property that gets or sets the text that is displayed on the PowerShell tab. By
default, tabs are named "PowerShell #", where the # represents a number.

```powershell
$newTab = $psISE.PowerShellTabs.Add()
# Change the DisplayName of the new PowerShell tab.
$newTab.DisplayName = 'Brand New Tab'
```

### ExpandedScript

Supported in Windows PowerShell ISE 2.0 and later.

The read-write Boolean property that determines whether the Script pane is expanded or hidden.

```powershell
# Toggle the expanded script property to see its effect.
$psISE.CurrentPowerShellTab.ExpandedScript = !$psISE.CurrentPowerShellTab.ExpandedScript
```

### Files

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the [collection of script files](The-ISEFileCollection-Object.md)
that are open in the PowerShell tab.

```powershell
$newFile = $psISE.CurrentPowerShellTab.Files.Add()
$newFile.Editor.Text = "a`r`nb"
# Gets the line count
$newFile.Editor.LineCount
```

### Output

This feature is present in Windows PowerShell ISE 2.0, but was removed or renamed in later versions
of the ISE. In later versions of Windows PowerShell ISE, you can use the **ConsolePane** object for
the same purposes.

The read-only property that gets the Output pane of the current [editor](The-ISEEditor-Object.md).

```powershell
# Clears the text in the Output pane.
$psISE.CurrentPowerShellTab.output.clear()
```

### Prompt

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the current prompt text. Note: the **Prompt** function can be
overridden by the user'&trade;s profile. If the result is other than a simple string, then this property
returns nothing.

```powershell
# Gets the current prompt text.
$psISE.CurrentPowerShellTab.Prompt
```

### ShowCommands

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-write property that indicates if the Commands pane is currently displayed.

```powershell
# Gets the current status of the Commands pane and stores it in the $a variable
$a = $psISE.CurrentPowerShellTab.ShowCommands
# if $a is $false, then turn the Commands pane on by changing the value to $true
if (!$a) {$psISE.CurrentPowerShellTab.ShowCommands = $true}
```

### StatusText

Supported in Windows PowerShell ISE 2.0 and later.

The read-only property that gets the **PowerShellTab** status text.

```powershell
# Gets the current status text,
$psISE.CurrentPowerShellTab.StatusText
```

### HorizontalAddOnToolsPaneOpened

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-only property that indicates whether the horizontal Add-Ons tool pane is currently open.

```powershell
# Gets the current state of the horizontal Add-ons tool pane.
$psISE.CurrentPowerShellTab.HorizontalAddOnToolsPaneOpened
```

### VerticalAddOnToolsPaneOpened

Supported in Windows PowerShell ISE 3.0 and later, and not present in earlier versions.

The read-only property that indicates whether the vertical Add-Ons tool pane is currently open.

```powershell
# Turns on the Commands pane
$psISE.CurrentPowerShellTab.ShowCommands = $true
# Gets the current state of the vertical Add-ons tool pane.
$psISE.CurrentPowerShellTab.HorizontalAddOnToolsPaneOpened
```

## See Also

- [The PowerShellTabCollection Object](The-PowerShellTabCollection-Object.md)
- [Purpose of the Windows PowerShell ISE Scripting Object Model](Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)
- [The ISE Object Model Hierarchy](The-ISE-Object-Model-Hierarchy.md)

# /./reference/windows-powershell/ise/object-model/other-useful-scripting-objects.md

    ---
    description: This article describes objects that provide additional scripting functionality in the Windows PowerShell ISE.
    ms.date: 06/05/2017
    title: Other Useful Scripting Objects
    ---
# Other Useful Scripting Objects

The following objects provide additional scripting functionality in Windows PowerShell ISE. They
are not part of the **$psISE** hierarchy.

## Useful Scripting objects

### $psUnsupportedConsoleApplications

There are some limitations on how Windows PowerShell ISE interacts with console applications. A
command or an automation script that requires user intervention might not work the way it works
from the Windows PowerShell console. You might want to block these commands or scripts from running
in the Windows PowerShell ISE Command pane. The **$psUnsupportedConsoleApplications** object keeps
a list of such commands. If you try to run the commands in this list, you get a message that they
are not supported. The following script adds an entry to the list.

```powershell
# List the unsupported commands
$psUnsupportedConsoleApplications

# Add a command to this list
$psUnsupportedConsoleApplications.Add('Mycommand')

# Show the augmented list of commands
$psUnsupportedConsoleApplications
```

### $psLocalHelp

This is a dictionary object that maintains a context-sensitive mapping between Help topics and
their associated links in the local compiled HTML Help file. It is used to locate the local Help
for a particular topic. You can add or delete topics from this list. The following code example
shows some example key-value pairs that are contained in `$psLocalHelp`.

```powershell
# See the local help map
$psLocalHelp | Format-List
```

```Output
Key   : Add-Computer
Value : WindowsPowerShellHelp.chm::/html/093f660c-b8d5-43cf-aa0c-54e5e54e76f9.htm

Key   : Add-Content
Value : WindowsPowerShellHelp.chm::/html/0c836a1b-f389-4e9a-9325-0f415686d194.htm
```

The following script adds an entry to the list.

```powershell
$psLocalHelp.Add("get-myNoun", "c:\MyFolder\MyHelpChm.chm::/html/0198854a-1298-57ae-aa0c-87b5e5a84712.htm")
```

### $psOnlineHelp

This is a dictionary object that maintains a context-sensitive mapping between topic titles of Help
topics and their associated external URLs. It is used to locate the Help for a particular topic on
the web. You can add or delete topics from this list.

```powershell
$psOnlineHelp | Format-List
```

```Output
Key   : Add-Computer
Value : https://go.microsoft.com/fwlink/p/?LinkID=135194

Key   : Add-Content
Value : https://go.microsoft.com/fwlink/p/?LinkID=113278
```

The following script adds an entry to the list.

```powershell
$psOnlineHelp.Add("get-myNoun", "https://www.mydomain.com/MyNoun.html")
```

## See Also

[Purpose of the Windows PowerShell ISE Scripting Object Model](./Purpose-of-the-Windows-PowerShell-ISE-Scripting-Object-Model.md)

# /./reference/windows-powershell/starting-windows-powershell.md

    ---
    description: This article explains the ways of starting various versions of PowerShell.
    ms.date: 03/04/2024
    title: Starting Windows PowerShell
    ---

# Starting Windows PowerShell

Windows PowerShell is a scripting engine that's embedded into multiple hosts. The most common hosts
you'll start are the interactive command-line `powershell.exe` and the Interactive Scripting
Environment `powershell_ise.exe`.

## PowerShell has renamed binary

PowerShell version 6 and higher uses .NET Core. Supported versions are available on Windows, macOS,
and Linux.

Beginning in PowerShell 6, the PowerShell binary was renamed `pwsh.exe` for Windows and `pwsh` for
macOS and Linux. You can start PowerShell preview versions using `pwsh-preview`. For more
information, see [About pwsh][04].

To find cmdlet reference and installation documentation for PowerShell 7, use the following links:

|       Document       |                  Link                  |
| -------------------- | -------------------------------------- |
| Cmdlet reference     | [PowerShell Module Browser][02]        |
| Windows installation | [Installing PowerShell on Windows][07] |
| macOS installation   | [Installing PowerShell on macOS][06]   |
| Linux installation   | [Installing PowerShell on Linux][05]   |

To view content for other PowerShell versions, see [How to use the PowerShell documentation][01].

### From the Start Menu

- Open the **Start** menu, type **Windows PowerShell**, select **Windows PowerShell**, then select
  **Open**.

### At the Command Prompt

In Windows Command shell, Windows PowerShell, or Windows PowerShell ISE, to start Windows
PowerShell, type: `PowerShell`.

You can also use the parameters of the `powershell.exe` program to customize the session. For more
information, see [PowerShell.exe Command-Line Help][03].

### With Administrative privileges (Run as administrator)

Open the **Start** menu, type **Windows PowerShell**, select **Windows PowerShell**, and then
select **Run as administrator**.

## How to Start Windows PowerShell ISE on Earlier Releases of Windows

Use any of the following methods to start Windows PowerShell ISE.

### From the Start Menu

- Open the **Start** menu, type **ISE**, select **Windows PowerShell ISE**, then select **Open**.

### At the Command Prompt

In Windows Command shell, Windows PowerShell, or Windows PowerShell ISE, to start Windows
PowerShell, type: `PowerShell_ISE`. In Windows PowerShell, you can use the alias `ise`.

### With Administrative privileges (Run as administrator)

Click **Start**, type **ISE**, right-click **Windows PowerShell ISE**, and then click **Run as
administrator**.

## Starting the 32-Bit Version of Windows PowerShell

When using a 64-bit computer, **Windows PowerShell (x86)**, a 32-bit version of Windows PowerShell
is installed in addition to the 64-bit version. When you run Windows PowerShell, the 64-bit version
runs by default.

However, you might occasionally need to run **Windows PowerShell (x86)**, such as when you're using
a module that requires the 32-bit version or when you're connecting remotely to a 32-bit computer.

To start a 32-bit version of Windows PowerShell, use any of the following procedures.

- Click **Start**, type **Windows PowerShell**, select **Windows PowerShell (x86)**, then select
  **Open**.

<!-- link references -->
[01]: ../how-to-use-docs.md
[02]: https://learn.microsoft.com/powershell/module/
[03]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/About/about_PowerShell_exe
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_pwsh
[05]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-linux
[06]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-macos
[07]: https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-windows

# /./reference/windows-powershell/wmf-overview.md

    ---
    description: WMF is a prerequisite for Windows PowerShell. This articles shows the history of WMF versions and provides information about how to find and install WMF.
    ms.date: 11/03/2023
    ms.topic: overview
    title: Windows Management Framework (WMF)
    ---

# Windows Management Framework

Windows Management Framework (WMF) provides a consistent management interface for Windows. WMF
provides a seamless way to manage various versions of Windows client and Windows Server. WMF
installer packages contain updates to management functionality and are available for older versions
of Windows.

> [!NOTE]
> WMF 5.1 is the only supported version of WMF and is included in all currently supported versions
> of Windows. This information in this article provides a history of WMF versions.

WMF installation adds and/or updates the following features:

- Windows PowerShell
- Windows PowerShell Desired State Configuration (DSC)
- Windows PowerShell Integrated Script Environment (ISE)
- Windows Remote Management (WinRM)
- Windows Management Instrumentation (WMI)
- Windows PowerShell Web Services (Management OData IIS Extension)
- Software Inventory Logging (SIL)
- Server Manager CIM Provider

## WMF Release Notes

To learn about various enhancements in PowerShell and other components of a given WMF, please refer
to the links below to review the release notes:

- [WMF 5.1][08]
- [WMF 5.0][07]

## WMF availability across Windows operating systems

|         OS Version         |     End of Support     |      WMF 5.1      | WMF 5.0  | WMF 4.0  | WMF 3.0  | WMF 2.0  |
| -------------------------- | ---------------------- | ----------------- | -------- | -------- | -------- | -------- |
| Windows Server 2022        | [2031-10-14][04]       | Included          |          |          |          |          |
| Windows Server 2019        | [2029-01-09][04]       | Included          |          |          |          |          |
| Windows Server 2016        | [2027-01-11][04]       | Included          |          |          |          |          |
| Windows 11                 | [2025-10-14][03]       | Included          |          |          |          |          |
| Windows 10                 | [2025-10-14][03]       | Included in 1607+ | Included |          |          |          |
| Windows Server 2012 R2     | [_Out of support_][02] | [Yes][05]         | Yes      | Included |          |          |
| Windows 8.1                | [_Out of support_][02] | [Yes][05]         | Yes      | Included |          |          |
| Windows Server 2012        | [_Out of support_][02] | [Yes][05]         | Yes      | Yes      | Included |          |
| Windows 8                  | [_Out of support_][01] |                   |          |          | Included |          |
| Windows Server 2008 R2 SP1 | [_Out of support_][01] | [Yes][05]         | Yes      | Yes      | Yes      | Included |
| Windows 7 SP1              | [_Out of support_][01] | [Yes][05]         | Yes      | Yes      | Yes      | Included |
| Windows Server 2008 SP2    | [_Out of support_][01] |                   |          |          | Yes      | Yes      |
| Windows Vista              | [_Out of support_][01] |                   |          |          |          | Yes      |
| Windows Server 2003        | [_Out of support_][01] |                   |          |          |          | Yes      |
| Windows XP                 | [_Out of support_][01] |                   |          |          | Yes      | Yes      |

- **Included**: The features of the specified version of WMF were shipped in the indicated version
  of Windows client or Windows Server.
- **Out of support**: These products are no longer supported by Microsoft. You must upgrade to a
  supported version. For more information, see the [Microsoft Lifecycle Policy][06] page.

> [!NOTE]
> The version of WMF that shipped in an operating system is supported for the lifetime of support
> for that version of the operating system. The standalone installers for WMF 5.0 and older are no
> longer available or supported.

<!-- link refs -->
[01]: https://learn.microsoft.com/lifecycle/products/?products=windows
[02]: https://learn.microsoft.com/windows/release-health/status-windows-8.1-and-windows-server-2012-r2
[03]: https://learn.microsoft.com/windows/release-health/supported-versions-windows-client
[04]: https://learn.microsoft.com/windows/release-health/windows-server-release-info
[05]: https://aka.ms/wmf51download
[06]: https://support.microsoft.com/lifecycle
[07]: https://learn.microsoft.com/previous-versions/powershell/scripting/windows-powershell/wmf/whats-new/release-notes#wmf-50-changes
[08]: https://learn.microsoft.com/previous-versions/powershell/scripting/windows-powershell/wmf/whats-new/release-notes#wmf-51-changes

# /./reference/security/security-features.md

    ---
    description: PowerShell has several features designed to improve the security of your scripting environment.
    ms.date: 09/29/2023
    title: PowerShell security features
    ---
# PowerShell security features

PowerShell has several features designed to improve the security of your scripting environment.

## Execution policy

PowerShell's execution policy is a safety feature that controls the conditions under which
PowerShell loads configuration files and runs scripts. This feature helps prevent the execution of
malicious scripts. You can use a Group Policy setting to set execution policies for computers and
users. Execution policies only apply to the Windows platform.

For more information see [about_Execution_Policies][02].

## Module and script block logging

Module Logging allows you to enable logging for selected PowerShell modules. This setting is
effective in all sessions on the computer. Pipeline execution events for the specified modules are
recorded in the Windows PowerShell log in Event Viewer.

Script Block Logging enables logging for the processing of commands, script blocks, functions, and
scripts - whether invoked interactively, or through automation. This information is logged to the
**Microsoft-Windows-PowerShell/Operational** event log.

For more information, see the following articles:

- [about_Group_Policy_Settings][03]
- [about_Logging_Windows][06]
- [about_Logging_Non-Windows][05]

## AMSI Support

The Windows Antimalware Scan Interface (AMSI) is an API that allows application actions to be passed
to an antimalware scanner, such as Windows Defender, to be scanned for malicious payloads. Beginning
with PowerShell 5.1, PowerShell running on Windows 10 (and higher) passes all script blocks to AMSI.

PowerShell 7.3 extends the data that's sent to AMSI for inspection. It now includes all invocations
of .NET method members.

For more information about AMSI, see [How AMSI helps][11].

## Constrained language mode

**ConstrainedLanguage** mode protects your system by limiting the cmdlets and .NET types that can be
used in a PowerShell session. For a full description, see [about_Language_Modes][04].

## Application Control

Windows 10 includes two technologies, [Windows Defender Application Control (WDAC)][10] and
[AppLocker][07] that you can use to control applications. They allow you to create a lockdown
experience to help secure your PowerShell environment.

For more information about how PowerShell supports AppLocker and WDAC, see
[Using Windows Defender Application Control][01].

### Changes in PowerShell 7.4

On Windows, when PowerShell runs under a Windows Defender Application Control (WDAC) policy, it
changes its behavior based on the defined security policy. Under a WDAC policy, PowerShell runs
trusted scripts and modules allowed by the policy in Full Language mode. All other scripts and
script blocks are untrusted and run in Constrained Language mode. PowerShell throws errors when the
untrusted scripts attempt to perform disallowed actions. It's difficult to know why a script fails
to run correctly in Constrained Language mode.

PowerShell 7.4 now supports WDAC policies in **Audit** mode. In audit mode, PowerShell runs the
untrusted scripts in Constrained Language mode but logs messages to the event log instead of
throwing errors. The log messages describe what restrictions would apply if the policy was in
**Enforce** mode.

### Changes in PowerShell 7.3

- PowerShell 7.3 now supports the ability to block or allow PowerShell script files via the WDAC API.

### Changes in PowerShell 7.2

- There was a corner-case scenario in AppLocker where you only have **Deny** rules and constrained
  mode isn't used to enforce the policy that allows you to bypass the execution policy. Beginning in
  PowerShell 7.2, a change was made to ensure AppLocker rules take precedence over a
  `Set-ExecutionPolicy -ExecutionPolicy Bypass` command.

- PowerShell 7.2 now disallows the use of the `Add-Type` cmdlet in a **NoLanguage** mode PowerShell
  session on a locked down machine.

- PowerShell 7.2 now disallows scripts from using COM objects in AppLocker system lock down
  conditions. Cmdlet that use COM or DCOM internally aren't affected.

### Security Servicing Criteria

PowerShell follows the [Microsoft Security Servicing Criteria for Windows][13]. The table below
outlines the features that meet the servicing criteria and those that do not.

|                  Feature                   |       Type       |
| ------------------------------------------ | ---------------- |
| System Lockdown - with WDAC                | Security Feature |
| Constrained language mode - with WDAC      | Security Feature |
| System Lockdown - with AppLocker           | Defense in Depth |
| Constrained language mode - with AppLocker | Defense in Depth |
| Execution Policy                           | Defense in Depth |

## Software Bill of Materials (SBOM)

Beginning with PowerShell 7.2, all install packages contain a Software Bill of Materials (SBOM). The
SBOM is found at `$PSHOME/_manifest/spdx_2.2/manifest.spdx.json`. The creation and publishing of the
SBOM is the first step to modernize Federal Government cybersecurity and enhance software supply
chain security.

The PowerShell team is also producing SBOMs for modules that they own but ship separately from
PowerShell. SBOMs will be added in the next release of the module. For modules, the SBOM is
installed in the module's folder under `_manifest/spdx_2.2/manifest.spdx.json`.

For more information about this initiative, see the blog post
[Generating Software Bills of Materials (SBOMs) with SPDX at Microsoft][12].

<!-- link references -->
[01]: ./application-control.md
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_execution_policies
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_group_policy_settings#turn-on-module-logging
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_language_modes
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_logging_non-windows
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_logging_windows
[07]: https://learn.microsoft.com/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker
[10]: https://learn.microsoft.com/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control
[11]: https://learn.microsoft.com/windows/win32/amsi/how-amsi-helps
[12]: https://devblogs.microsoft.com/engineering-at-microsoft/generating-software-bills-of-materials-sboms-with-spdx-at-microsoft/
[13]: https://www.microsoft.com/msrc/windows-security-servicing-criteria

# /./reference/security/application-control.md

    ---
    description: You can secure your PowerShell environments on Windows using Windows Defender Application Control (WDAC).
    ms.date: 11/30/2023
    title: Using Windows Defender Application Control
    ---
# Using Windows Defender Application Control

Windows 10 includes two technologies, [Windows Defender Application Control (WDAC)][04] and
[AppLocker][01] that you can use to control applications. They allow you to create a lockdown
experience to help secure your PowerShell environment

**AppLocker** builds on the application control features of Software Restriction Policies. AppLocker
contains capabilities and extensions that enable you to create rules to allow or deny apps from
running based on unique identities of files and to specify the users or groups that are allowed to
run those apps.

> [!NOTE]
> When [choosing between WDAC or AppLocker][03], we recommend that you implement application control
> using WDAC rather than AppLocker. Microsoft is continually improving WDAC and Microsoft management
> platforms are extending their support for WDAC. Although AppLocker may continue to receive
> security fixes, it won't receive feature enhancements.

**WDAC** was introduced with Windows 10 and allows organizations to control the drivers and
applications are allowed to run on their Windows devices. WDAC is designed as a security feature
under the servicing criteria defined by the Microsoft Security Response Center (MSRC).

For more information about AppLocker and WDAC, see [Application Controls for Windows][04] and
[WDAC and AppLocker feature availability][02].

## WDAC policy enforcement

When PowerShell runs under a WDAC policy, it changes its behavior based on the defined security
policy. Under a WDAC policy, PowerShell runs trusted scripts and modules allowed by the policy in
Full Language mode. All other scripts and script blocks are untrusted and run in Constrained
Language mode. PowerShell throws errors when the untrusted scripts attempt to perform actions that
aren't allowed in Constrained Language mode. It can be difficult to know why a script failed to run
correctly in Constrained Language mode.

## WDAC policy auditing

PowerShell 7.4 added a new feature to support WDAC policies in **Audit** mode. In audit mode,
PowerShell runs the untrusted scripts in Constrained Language mode without errors, but logs messages
to the event log instead. The log messages describe what restrictions would apply if the policy was
in **Enforce** mode.

### Viewing audit events

PowerShell logs audit events to the **PowerShellCore/Analytic** event log. You must enable
the Analytic log. To enable the Analytic log in the Windows Event Viewer, right-click on the
**PowerShellCore/Analytic** log and select **Enable Log**.

Or, you can run the following command from an elevated PowerShell session.

```powershell
wevtutil.exe sl PowerShellCore/Analytic /enabled:true /quiet
```

You can view the events in the Windows Event Viewer or use the `Get-WinEvent` cmdlet to retrieve the
events.

```powershell
Get-WinEvent -LogName PowerShellCore/Analytic -Oldest |
    Where-Object Id -eq 16387 | Format-List
```

```Output
TimeCreated  : 4/19/2023 10:11:07 AM
ProviderName : PowerShellCore
Id           : 16387
Message      : WDAC Audit.

    Title: Method or Property Invocation
    Message: Method or Property 'WriteLine' on type 'System.Console' invocation will not
        be allowed in ConstrainedLanguage mode.
        At C:\scripts\Test1.ps1:3 char:1
        + [System.Console]::WriteLine("pwnd!")
        + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    FullyQualifiedId: MethodOrPropertyInvocationNotAllowed
```

The event message includes the script position where the restriction would be applied. This
information helps you understand where you need to change your script so that it runs under the WDAC
policy.

> [!IMPORTANT]
> Once you have reviewed the audit events, you should disable the Analytic log. Analytic logs grow
> quickly and consume large amounts of disk space.

### Viewing audit events in the PowerShell debugger

If you set the `$DebugPreference` variable to `Break` for an interactive PowerShell session,
PowerShell will break into the command-line script debugger at the current location in the script
where the audit event occurred. This allows you to debug your code and inspect the current state of
the script in real time.

<!-- link references -->
[01]: https://learn.microsoft.com/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker
[02]: https://learn.microsoft.com/windows/security/threat-protection/windows-defender-application-control/feature-availability
[03]: https://learn.microsoft.com/windows/security/threat-protection/windows-defender-application-control/wdac-and-applocker-overview#choose-when-to-use-wdac-or-applocker
[04]: https://learn.microsoft.com/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control

# /./reference/security/preventing-script-injection.md

    ---
    description: This article explains how to prevent script injection attacks using single quote escaping.
    ms.date: 02/10/2023
    title: Preventing script injection attacks
    ---
# Preventing script injection attacks

PowerShell scripts, like other programming languages, can be vulnerable to injection attacks. An
injection attack occurs when a user provides input to a vulnerable function that includes extra
commands. The vulnerable function runs the extra commands, which can be a serious security
vulnerability. For example, a malicious user could abuse the vulnerable function to run arbitrary
code on a remote computer, possibly compromising that computer and gaining access to other machines
on the network.

Once you are aware of the issue, there are several ways to protect against injection attacks.

## Example of vulnerable code

PowerShell code injection vulnerabilities involve user input that contains script code. The user
input is added to vulnerable script where it's parsed and run by PowerShell.

```powershell
function Get-ProcessById
{
    param ($ProcId)

    Invoke-Expression -Command "Get-Process -Id $ProcId"
}
```

The `Get-ProcessById` function looks up a local process by its Id value. It takes a `$ProcId`
parameter argument of any type. The `$ProcId` is then converted to a string and inserted into
another script that's parsed and run using the `Invoke-Expression` cmdlet. This function works fine
when a valid process Id integer is passed in.

```powershell
Get-ProcessById $pid

 NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName
 ------    -----      -----     ------      --  -- -----------
     97    50.09     132.72       1.20   12528   3 pwsh
```

However, the `$ProcId` parameter doesn't specify a type. It accepts any arbitrary string value that
can include other commands.

```powershell
Get-ProcessById "$pid; Write-Host 'pwnd!'"
```

In this example, the function correctly retrieved the process identified by `$pid`, but also ran the
injected script `Write-Host 'pwnd!'`.

```Output
 NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName
 ------    -----      -----     ------      --  -- -----------
     92    45.66     122.52       1.06   21736   3 pwsh
pwnd!
```

## Ways to guard against injection attacks

The are several ways to guard against an injection attack.

### Use typed input

You can specify a type for the `$ProcId` argument.

```powershell
function Get-ProcessById
{
    param ([int] $ProcId)

    Invoke-Expression -Command "Get-Process -Id $ProcId"
}
Get-ProcessById "$pid; Write-Host 'pwnd!'"
```

```Output
Get-ProcessById:
Line |
   7 |  Get-ProcessById "$pid; Write-Host 'pwnd!'"
     |                  ~~~~~~~~~~~~~~~~~~~~~~~~~
     | Cannot process argument transformation on parameter 'ProcId'. Cannot convert value
"8064; Write-Host 'pwnd!'" to type "System.Int32". Error: "The input string '8064; Write-Host 'pwnd!'
was not in a correct format."
```

Here, the `$ProcId` input parameter is restricted to an integer type, so an error occurs when a
string is passed in that can't be converted to an integer.

### Don't use `Invoke-Expression`

Instead of using `Invoke-Expression`, directly call `Get-Process`, and let PowerShell's parameter
binder validate the input.

```powershell
function Get-ProcessById
{
    param ($ProcId)

    Get-Process -Id $ProcId
}
Get-ProcessById "$pid; Write-Host 'pwnd!'"
```

```Output
Get-Process:
Line |
   5 |      Get-Process -Id $ProcId
     |                      ~~~~~~~
     | Cannot bind parameter 'Id'. Cannot convert value "8064; Write-Host 'pwnd!'" to type
"System.Int32". Error: "The input string '8064; Write-Host 'pwnd!' was not in a correct
format."
```

As a best practice, you should avoid using `Invoke-Expression`, especially when handling user input.
`Invoke-Expression` is dangerous because it parses and runs whatever string content you provide,
making it vulnerable to injection attacks. It's better to rely on PowerShell parameter binding.

### Wrap strings in single quotes

However, there are times when using `Invoke-Expression` is unavoidable and you also need to handle
user string input. You can safely handle user input using single quotes around each string input
variable. The single quote ensures that PowerShell's parser treats the user input as a single string
literal.

```powershell
function Get-ProcessById
{
    param ($ProcId)

    Invoke-Expression -Command "Get-Process -Id '$ProcId'"
}

Get-ProcessById "$pid; Write-Host 'pwnd!'"
```

```Output
Get-Process: Cannot bind parameter 'Id'. Cannot convert value "8064; Write-Host " to type
"System.Int32". Error: "The input string '8064; Write-Host' was not in a correct format."
```

However, this version of the function isn't yet completely safe from injection attacks. A malicious
user can still use single quotes in their input to inject code.

```powershell
Get-ProcessById "$pid'; Write-Host 'pwnd!';'"
```

This example uses single quotes in the user input to force the function to run three separate
statements, one of which is arbitrary code injected by the user.

```Output
 NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName
 ------    -----      -----     ------      --  -- -----------
     97    46.08     183.10       1.08    2524   3 pwsh
pwnd!
```

### Use the `EscapeSingleQuotedStringContent()` method

To protect against the user inserting their own single quote characters to exploit the function you
must use the `EscapeSingleQuotedStringContent()` API. This is a static public method of the PowerShell
**System.Management.Automation.Language.CodeGeneration** class. This method makes the user input safe
by escaping any single quotes included in the user input.

```powershell
function Get-ProcessById
{
    param ($ProcId)

    $ProcIdClean = [System.Management.Automation.Language.CodeGeneration]::
        EscapeSingleQuotedStringContent("$ProcId")
    Invoke-Expression -Command "Get-Process -Id '$ProcIdClean'"
}
Get-ProcessById "$pid'; Write-Host 'pwnd!';'"
```

```Output
Get-Process: Cannot bind parameter 'Id'. Cannot convert value "8064'; Write-Host 'pwnd!';'" to type
"System.Int32". Error: "The input string '8064'; Write-Host 'pwnd!';'' was not in a correct format."
```

For more information, see [EscapeSingleQuotedStringContent()][01].

## Detecting vulnerable code with Injection Hunter

**Injection Hunter** is a module written by Lee Holmes that contains PowerShell Script Analyzer
rules for detecting code injection vulnerabilities. Use one of the following commands to install the
module from the PowerShell Gallery:

```powershell
# Use PowerShellGet v2.x
Install-Module InjectionHunter

# Use PowerShellGet v3.x
Install-PSResource InjectionHunter
```

You can use this to automate security analysis during builds, continuous integration processes,
deployments, and other scenarios.

```powershell
$RulePath = (Get-Module -list InjectionHunter).Path
Invoke-ScriptAnalyzer -CustomRulePath $RulePath -Path .\Invoke-Dangerous.ps1
```

```Output
RuleName                            Severity     ScriptName Line  Message
--------                            --------     ---------- ----  -------
InjectionRisk.InvokeExpression      Warning      Invoke-Dan 3     Possible script injection risk via the
                                                 gerous.ps1       Invoke-Expression cmdlet. Untrusted input can cause
                                                                  arbitrary PowerShell expressions to be run.
                                                                  Variables may be used directly for dynamic parameter
                                                                  arguments, splatting can be used for dynamic
                                                                  parameter names, and the invocation operator can be
                                                                  used for dynamic command names. If content escaping
                                                                  is truly needed, PowerShell has several valid quote
                                                                  characters, so  [System.Management.Automation.Languag
                                                                  e.CodeGeneration]::Escape* should be used.
```

For more information, see [PSScriptAnalyzer][02].

<!-- TODO: Add instructions for VS Code once it gets fixed -->

## Related links

- [Lee Holmes' blog post about Injection Hunter][03]
- [Injection Hunter][04]

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.management.automation.language.codegeneration.escapesinglequotedstringcontent
[02]: https://learn.microsoft.com/powershell/utility-modules/psscriptanalyzer/overview
[03]: https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/
[04]: https://www.powershellgallery.com/packages/InjectionHunter

# /./reference/security/securing-restricted-sessions.md

    ---
    description: This article explains how to secure a restricted PowerShell session that is used for secure remote access.
    ms.date: 10/10/2023
    title: Securing a restricted PowerShell remoting session
    ---
# Securing a restricted PowerShell remoting session

There are scenarios where you want to host a PowerShell session that, for security reasons, has been
limited to a subset of PowerShell commands.

By definition, a restricted session is one where `Import-Module` isn't allowed to be used. There may
be other limitations, but this is the primary requirement. If the user can import a module, then
they can run anything they want.

Examples of restricted sessions include:

- Just-Enough-Administration (JEA)
- Custom restricted remoting implementations such as the Exchange and Teams modules

For most system administrators, JEA provides the best experience for creating restricted sessions
and should be your first choice. For more information about JEA, see the [JEA Overview][01].

## Recommendations for custom session implementations

If your scenario requires a custom implementation, then you should follow these recommendations.

### Limit the use and capabilities of PowerShell providers

Review how the allowed providers are used to ensure that you don't create vulnerabilities in your
restricted session implementation.

> [!WARNING]
> Don't allow the **FileSystem** provider. If users can write to any part of the file system, it's
> possible to completely bypass security.
>
> Don't allow the **Certificate** provider. With the provider enabled, a user could gain access to
> stored private keys.

### Don't allow commands that can create new runspaces

> [!WARNING]
> The `*-Job` cmdlets can create new runspaces without the restrictions.

### Don't allow the `Trace-Command` cmdlet.

> [!WARNING]
> Using `Trace-Command` brings all traced commands into the session.

### Don't create your own proxy implementations for the restricted commands

PowerShell has a set of proxy commands for restricted command scenarios. These proxy commands
ensure that input parameters can't compromise the security of the session. The following commands
have restricted proxies:

- `Exit-PSSession`
- `Get-Command`
- `Get-FormatData`
- `Get-Help`
- `Measure-Object`
- `Out-Default`
- `Select-Object`

If you create your own implementation of these commands, you may inadvertently allow users to run
code prohibited by the JEA proxy commands.

You can run the following command to get a list of restricted commands:

```powershell
$commands = [System.Management.Automation.CommandMetadata]::GetRestrictedCommands(
    [System.Management.Automation.SessionCapabilities]::RemoteServer
)
```

You can examine the restricted proxy commands by using the following command:

```powershell
$commands = [System.Management.Automation.CommandMetadata]::GetRestrictedCommands(
    [System.Management.Automation.SessionCapabilities]::RemoteServer
)
$getHelpProxyBlock = [System.Management.Automation.ProxyCommand]::Create($commands['Get-Help'])
```

### Configure the session to use NoLanguage mode

PowerShell `NoLanguage` mode disables the PowerShell scripting language completely. You can't run
scripts or use variables. You can only run native commands and cmdlets.

For more information about language modes, see [about_Language_Modes][03].

### Don't allow the debugger to be used in the session

By default, the PowerShell debugger runs code in `FullLanguage` mode. Set the
**UseFullLanguageModeInDebugger** property in the **SessionState** to false.

For more information, see [UseFullLanguageModeInDebugger][02].

<!-- link references -->
[01]: remoting/jea/overview.md
[02]: https://learn.microsoft.com/dotnet/api/system.management.automation.sessionstate.usefulllanguagemodeindebugger?#system-management-automation-sessionstate-usefulllanguagemodeindebugger
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_language_modes

# /./reference/security/remoting/jea/overview.md

    ---
    description: JEA is a security technology that enables delegated administration for anything managed by PowerShell.
    ms.date: 11/16/2022
    title: Overview of Just Enough Administration (JEA)
    ---

# Just Enough Administration

Just Enough Administration (JEA) is a security technology that enables delegated administration for
anything managed by PowerShell. With JEA, you can:

- **Reduce the number of administrators on your machines** using virtual accounts or group-managed
  service accounts to perform privileged actions on behalf of regular users.
- **Limit what users can do** by specifying which cmdlets, functions, and external commands they can
  run.
- **Better understand what your users are doing** with transcripts and logs that show you exactly
  which commands a user executed during their session.

**Why is JEA important?**

Highly privileged accounts used to administer your servers pose a serious security risk. Should an
attacker compromise one of these accounts, they could launch [lateral attacks][01] across your
organization. Each compromised account gives an attacker access to even more accounts and resources,
and puts them one step closer to stealing company secrets, launching a denial-of-service attack, and
more.

It's not always easy to remove administrative privileges, either. Consider the common scenario where
the DNS role is installed on the same machine as your Active Directory Domain Controller. Your DNS
administrators require local administrator privileges to fix issues with the DNS server. But to do
so, you must make them members of the highly privileged **Domain Admins** security group. This
approach effectively gives DNS Administrators control over your whole domain and access to all
resources on that machine.

JEA addresses this problem through the principle of **Least Privilege**. With JEA, you can configure
a management endpoint for DNS administrators that gives them access only to the PowerShell commands
they need to get their job done. This means you can provide the appropriate access to repair a
poisoned DNS cache or restart the DNS server without unintentionally giving them rights to Active
Directory, or to browse the file system, or run potentially dangerous scripts. Better yet, when the
JEA session is configured to use temporary privileged virtual accounts, your DNS administrators can
connect to the server using **non-admin** credentials and still run commands that typically require
admin privileges. JEA enables you to remove users from widely privileged local/domain administrator
roles and carefully control what they can do on each machine.

## Next steps

To learn more about the requirements to use JEA, see the [Prerequisites][03] article.

## Samples and DSC resource

Sample JEA configurations and the JEA DSC resource can be found in the
[JEA GitHub repository][02].

<!-- link references -->
[01]: https://aka.ms/pth
[02]: https://github.com/PowerShell/JEA
[03]: prerequisites.md

# /./reference/security/remoting/jea/prerequisites.md

    ---
    description: This article describes the prerequisites that must be satisfied to start using JEA.
    ms.date: 10/23/2023
    title: JEA Prerequisites
    ---
# JEA Prerequisites

Just Enough Administration is a feature included in PowerShell 5.0 and higher. This article
describes the prerequisites that must be satisfied to start using JEA.

## Check which version of PowerShell is installed

To check which version of PowerShell is installed on your system, check the `$PSVersionTable`
variable in a Windows PowerShell prompt.

```powershell
$PSVersionTable.PSVersion
```

```Output
Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      14393  1000
```

JEA is available with PowerShell 5.0 and higher. For full functionality, it's recommended that you
install the latest version of PowerShell available for your system. The following table describes
JEA's availability on Windows Server:

| Server Operating System |                JEA Availability                |
| ----------------------- | ---------------------------------------------- |
| Windows Server 2016+    | Preinstalled                                   |
| Windows Server 2012 R2  | Full functionality with WMF 5.1                |
| Windows Server 2012     | Full functionality with WMF 5.1                |
| Windows Server 2008 R2  | Reduced functionality<sup>1</sup> with WMF 5.1 |

You can also use JEA on your home or work computer:

| Client Operating System |                   JEA Availability                   |
| ----------------------- | ---------------------------------------------------- |
| Windows 10 1607+        | Preinstalled                                         |
| Windows 10 1603, 1511   | Preinstalled, with reduced functionality<sup>2</sup> |
| Windows 10 1507         | Not available                                        |
| Windows 8, 8.1          | Full functionality with WMF 5.1                      |
| Windows 7               | Reduced functionality<sup>1</sup> with WMF 5.1       |

- <sup>1</sup> JEA can't be configured to use group-managed service accounts on Windows Server 2008
  R2 or Windows 7. Virtual accounts and other JEA features *are* supported.

- <sup>2</sup> The following JEA features aren't supported on Windows 10 versions 1511 and 1603:

  - Running as a group-managed service account
  - Conditional access rules in session configurations
  - The user drive
  - Granting access to local user accounts

  To get support for these features, update Windows to version 1607 (Anniversary Update) or higher.

### Install Windows Management Framework

If you're running an older version of PowerShell, you may need to update your system with the latest
Windows Management Framework (WMF) update. For more information, see the [WMF documentation][02].

It's recommended that you test your workload's compatibility with WMF before upgrading all of your
servers.

Windows 10 users should install the latest feature updates to obtain the current version of Windows
PowerShell.

## Enable PowerShell Remoting

PowerShell Remoting provides the foundation on which JEA is built. It's necessary to ensure
PowerShell Remoting is enabled and properly secured before you can use JEA. For more information,
see [WinRM Security][01].

PowerShell Remoting is enabled by default on Windows Server 2012 and higher. You can enable
PowerShell Remoting by running the following command in an elevated PowerShell window.

```powershell
Enable-PSRemoting
```

## Enable PowerShell module and script block logging (optional)

The following steps enable logging for all PowerShell actions on your system. PowerShell Module
Logging isn't required for JEA, however it's recommended you turn on logging to ensure the commands
users run are logged in a central location.

You can configure the PowerShell Module Logging policy using Group Policy.

1. Open the Local Group Policy Editor on a workstation or a Group Policy Object in the Group Policy
   Management Console on an Active Directory Domain Controller
1. Navigate to **Computer Configuration\\Administrative Templates\\Windows Components\\Windows
   PowerShell**
1. Double-click on **Turn on Module Logging**
1. Click **Enabled**
1. In the Options section, click on **Show** next to Module Names
1. Type `*` in the pop-up window to log commands from all modules.
1. Click **OK** to set the policy
1. Double-click on **Turn on PowerShell Script Block Logging**
1. Click **Enabled**
1. Click **OK** to set the policy
1. (On domain-joined machines only) Run `gpupdate` or wait for Group Policy to process the updated
   policy and apply the settings

You can also enable system-wide PowerShell transcription through Group Policy.

## Next steps

- [Create a role capability file][04]
- [Create a session configuration file][05]

## See also

- [WinRM Security][01]
- [PowerShell ♥ the Blue Team][03]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/scripting/learn/remoting/winrmsecurity
[02]: https://learn.microsoft.com/powershell/scripting/wmf/overview
[03]: https://devblogs.microsoft.com/powershell/powershell-the-blue-team/
[04]: role-capabilities.md
[05]: session-configurations.md

# /./reference/security/remoting/jea/role-capabilities.md

    ---
    description: >-
      A role capability is a PowerShell data file with the .psrc extension that lists all the cmdlets,
      functions, providers, and external programs that are made available to connecting users.
    ms.date: 02/02/2023
    title: JEA Role Capabilities
    ---

# JEA Role Capabilities

When creating a JEA endpoint, you need to define one or more role capabilities that describe what
someone can do in a JEA session. A role capability is a PowerShell data file with the `.psrc`
extension that lists all the cmdlets, functions, providers, and external programs that are made
available to connecting users.

## Determine which commands to allow

The first step in creating a role capability file is to consider what the users need access to. The
requirements gathering process can take a while, but it's important. Giving users access
to too few cmdlets and functions can prevent them from getting their job done. Allowing access to
too many cmdlets and functions can allow users to do more than you intended and weaken your security
stance.

How you go about this process depends on your organization and goals. The following tips can help
ensure you're on the right path.

1. **Identify** the commands users are using to get their jobs done. This may involve surveying IT
   staff, checking automation scripts, or analyzing PowerShell session transcripts and logs.
1. **Update** use of command-line tools to PowerShell equivalents, where possible, for the best
   auditing and JEA customization experience. External programs can't be constrained as granularly
   as native PowerShell cmdlets and functions in JEA.
1. **Restrict** the scope of the cmdlets to only allow specific parameters or parameter values. This
   is especially important if users should manage only part of a system.
1. **Create** custom functions to replace complex commands or commands that are difficult to
   constrain in JEA. A simple function that wraps a complex command or applies additional validation
   logic can offer additional control for admins and end-user simplicity.
1. **Test** the scoped list of allowable commands with your users or automation services, and adjust
   as necessary.

### Examples of potentially dangerous commands

Careful selection of commands is important to ensure the JEA endpoint doesn't allow the user to
elevate their permissions.

> [!IMPORTANT]
> Essential information required for user successCommands in a JEA session are often run with
> elevated privileges.

The following list contains examples of commands that can be used maliciously if allowed in an
unconstrained state. This isn't an exhaustive list and should only be used as a cautionary starting
point.

- **Risk:** Granting the connecting user admin privileges to bypass JEA

  **Example:**

  ```powershell
  Add-LocalGroupMember -Member 'CONTOSO\jdoe' -Group 'Administrators'
  ```

  **Related commands:**

  - `Add-ADGroupMember`
  - `Add-LocalGroupMember`
  - `net.exe`
  - `dsadd.exe`
- **Risk:** Running arbitrary code, such as malware, exploits, or custom scripts to bypass
  protections

  **Example:**

  ```powershell
  Start-Process -FilePath '\\san\share\malware.exe'
  ```

  **Related commands:**

  - `Start-Process`
  - `New-Service`
  - `Invoke-Item`
  - `Invoke-WmiMethod`
  - `Invoke-CimMethod`
  - `Invoke-Expression`
  - `Invoke-Command`
  - `New-ScheduledTask`
  - `Register-ScheduledJob`

## Create a role capability file

You can create a new PowerShell role capability file with the [New-PSRoleCapabilityFile][04] cmdlet.

```powershell
New-PSRoleCapabilityFile -Path .\MyFirstJEARole.psrc
```

You should edit the created role capability file to allow only the commands required for the role.
The PowerShell help documentation contains several examples of how you can configure the file.

### Allowing PowerShell cmdlets and functions

To authorize users to run PowerShell cmdlets or functions, add the cmdlet or function name to the
**VisibleCmdlets** or **VisibleFunctions** fields. If you aren't sure whether a command is a cmdlet
or function, you can run `Get-Command <name>` and check the **CommandType** property in the output.

```powershell
VisibleCmdlets = @('Restart-Computer', 'Get-NetIPAddress')
```

Sometimes the scope of a specific cmdlet or function is too broad for your users' needs. A DNS
admin, for example, may only need access to restart the DNS service. In multi-tenant environments,
tenants have access to self-service management tools. Tenants should be limited to managing their
own resources. For these cases, you can restrict which parameters are exposed from the cmdlet or
function.

```powershell
VisibleCmdlets = @{
    Name       = 'Restart-Computer'
    Parameters = @{ Name = 'Name' }
}
```

In more advanced scenarios, you may also need to restrict the values a user may use with these
parameters. Role capabilities let you define a set of values or a regular expression pattern that
determine what input is allowed.

```powershell
VisibleCmdlets = @(
    @{
        Name       = 'Restart-Service'
        Parameters = @{ Name = 'Name'; ValidateSet = @('Dns', 'Spooler') }
    }
    @{
        Name       = 'Start-Website'
        Parameters = @{ Name = 'Name'; ValidatePattern = 'HR_*' }
    }
)
```

> [!NOTE]
> The [common PowerShell parameters][02] are always allowed, even if you restrict the available
> parameters. You shouldn't explicitly list them in the Parameters field.

The list below describes the various ways you can customize a visible cmdlet or function. You can
mix and match any of the below in the **VisibleCmdlets** field.

- **Use case:** Allow the user to run `My-Func` without any restrictions on the parameters.

  ```powershell
  @{ Name = 'My-Func' }
  ```

- **Use case:** Allow the user to run `My-Func` from the module **MyModule** without any
  restrictions on the parameters.

  ```powershell
  @{ Name = 'MyModule\My-Func' }
  ```

- **Use case:** Allow the user to run any cmdlet or function with the verb `My`.

  ```powershell
  @{ Name = 'My-*' }
  ```

- **Use case:** Allow the user to run any cmdlet or function with the noun `Func`.

  ```powershell
  @{ Name = '*-Func' }
  ```

- **Use case:** Allow the user to run `My-Func` with the `Param1` and `Param2` parameters. Any
  value can be supplied to the parameters.

  ```powershell
  @{ Name = 'My-Func'; Parameters = @{ Name = 'Param1'}, @{ Name = 'Param2' }}
  ```

- **Use case:** Allow the user to run `My-Func` with the `Param1` parameter. Only `Value1` and
  `Value2` can be supplied to the parameter.

  ```powershell
  @{
      Name       = 'My-Func'
      Parameters = @{ Name = 'Param1'; ValidateSet = @('Value1', 'Value2') }
  }
  ```

- **Use case:** Allow the user to run `My-Func` with the `Param1` parameter. Any value starting
  with `contoso` can be supplied to the parameter.

  ```powershell
  @{
      Name       = 'My-Func'
      Parameters = @{ Name = 'Param1'; ValidatePattern = 'contoso.*' }
  }
  ```

> [!WARNING]
> For best security practices, it isn't recommended to use wildcards when defining visible cmdlets
> or functions. Instead, you should explicitly list each trusted command to ensure no other commands
> that share the same naming scheme are unintentionally authorized.

You can't apply both a **ValidatePattern** and **ValidateSet** to the same cmdlet or function.

If you do, the **ValidatePattern** overrides the **ValidateSet**.

For more information about **ValidatePattern**, check out [this _Hey, Scripting Guy!_ post][09] and
the [PowerShell Regular Expressions][03] reference content.

### Allowing external commands and PowerShell scripts

To allow users to run executables and PowerShell scripts (`.ps1`) in a JEA session, you have to add
the full path to each program in the **VisibleExternalCommands** field.

```powershell
VisibleExternalCommands = @(
    'C:\Windows\System32\whoami.exe'
    'C:\Program Files\Contoso\Scripts\UpdateITSoftware.ps1'
)
```

Where possible, use PowerShell cmdlet or function equivalents for any external executables you
authorize since you have control over the parameters allowed with PowerShell cmdlets and functions.

Many executables allow you to read the current state and then change it by providing different
parameters.

For example, consider the role of a file server admin that manages network shares hosted on a
system. One way of managing shares is to use `net share`. However, allowing `net.exe` is dangerous
because the user could use the command to gain admin privileges with the command
`net group Administrators unprivilegedjeauser /add`. A more secure option is to allow the
[Get-SmbShare][06] cmdlet, which achieves the same result but has a much more limited scope.

When making external commands available to users in a JEA session, always specify the complete path
to the executable. This prevents the execution of similarly named and potentially malicious programs
located elsewhere on the system.

### Allowing access to PowerShell providers

By default, no PowerShell providers are available in JEA sessions. This reduces the risk of
sensitive information and configuration settings being disclosed to the connecting user.

When necessary, you can allow access to the PowerShell providers using the `VisibleProviders`
command. For a full list of providers, run `Get-PSProvider`.

```powershell
VisibleProviders = 'Registry'
```

For simple tasks that require access to the file system, registry, certificate store, or other
sensitive providers, consider writing a custom function that works with the provider on the user's
behalf. The functions, cmdlets, and external programs available in a JEA session aren't subject to
the same constraints as JEA. They can access any provider by default. Also consider using the
[user drive][11] when users need to copy files to or from a JEA endpoint.

### Creating custom functions

You can author custom functions in a role capability file to simplify complex tasks for your end
users. Custom functions are also useful when you require advanced validation logic for cmdlet
parameter values. You can write simple functions in the **FunctionDefinitions** field:

```powershell
VisibleFunctions = 'Get-TopProcess'

FunctionDefinitions = @{
    Name        = 'Get-TopProcess'
    ScriptBlock = {
        param($Count = 10)

        Get-Process |
            Sort-Object -Property CPU -Descending |
            Microsoft.PowerShell.Utility\Select-Object -First $Count
    }
}
```

> [!IMPORTANT]
> Don't forget to add the name of your custom functions to the **VisibleFunctions** field so they
> can be run by the JEA users.

The body (script block) of custom functions runs in the default language mode for the system and
isn't subject to JEA's language constraints. This means that functions can access the file system
and registry, and run commands that weren't made visible in the role capability file. Take care to
avoid running arbitrary code when using parameters. Avoid piping user input directly into cmdlets
like `Invoke-Expression`.

In the above example, notice that the fully qualified module name (FQMN)
`Microsoft.PowerShell.Utility\Select-Object` was used instead of the shorthand `Select-Object`.
Functions defined in role capability files are still subject to the scope of JEA sessions, which
includes the proxy functions JEA creates to constrain existing commands.

By default, `Select-Object` is a constrained cmdlet in all JEA sessions that doesn't allow the
selection of arbitrary properties on objects. To use the unconstrained `Select-Object` in functions,
you must explicitly request the full implementation using the FQMN. Any constrained cmdlet in a JEA
session has the same constraints when invoked from a function. For more information, see
[about_Command_Precedence][01].

If you're writing several custom functions, it's more convenient to put them in a PowerShell script
module. You make those functions visible in the JEA session using the **VisibleFunctions** field
like you would with built-in and third-party modules.

For tab completion to work properly in JEA sessions you must include the built-in function
`tabexpansion2` in the **VisibleFunctions** list.

## Make the role capabilities available to a configuration

Prior to PowerShell 6, for PowerShell to find a role capability file it must be stored in a
`RoleCapabilities` folder in a PowerShell module. The module can be stored in any folder included
in the `$env:PSModulePath` environment variable, however you shouldn't place it in
`$env:SystemRoot\System32` or a folder where untrusted users could modify the files.

The following example creates a PowerShell script module called **ContosoJEA** in the
`$env:ProgramFiles` path to host the role capabilities file.

```powershell
# Create a folder for the module
$modulePath = Join-Path $env:ProgramFiles "WindowsPowerShell\Modules\ContosoJEA"
New-Item -ItemType Directory -Path $modulePath

# Create an empty script module and module manifest.
# At least one file in the module folder must have the same name as the folder itself.
$rootModulePath = Join-Path $modulePath "ContosoJEAFunctions.psm1"
$moduleManifestPath = Join-Path $modulePath "ContosoJEA.psd1"
New-Item -ItemType File -Path $RootModulePath
New-ModuleManifest -Path $moduleManifestPath -RootModule "ContosoJEAFunctions.psm1"

# Create the RoleCapabilities folder and copy in the PSRC file
$rcFolder = Join-Path $modulePath "RoleCapabilities"
New-Item -ItemType Directory $rcFolder
Copy-Item -Path .\MyFirstJEARole.psrc -Destination $rcFolder
```

For more information about PowerShell modules, see [Understanding a PowerShell Module][07].

Starting in PowerShell 6, the **RoleDefinitions** property was added to the session configuration
file. This property lets you specify the location of a role configuration file for your role
definition. See the examples in [New-PSSessionConfigurationFile][05].

## Updating role capabilities

You can edit a role capability file to update the settings at any time. Any new JEA sessions started
after the role capability has been updated will reflect the revised capabilities.

This is why controlling access to the role capabilities folder is so important. Only highly trusted
administrators should be allowed to change role capability files. If an untrusted user can change
role capability files, they can easily give themselves access to cmdlets that allow them to elevate
their privileges.

For administrators looking to lock down access to the role capabilities, ensure Local System has
read-only access to the role capability files and containing modules.

## How role capabilities are merged

Users are granted access to all matching role capabilities in the [session configuration file][10]
when they enter a JEA session. JEA tries to give the user the most permissive set of commands
allowed by any of the roles.

### VisibleCmdlets and VisibleFunctions

The most complex merge logic affects cmdlets and functions, which can have their parameters and
parameter values limited in JEA.

The rules are as follows:

1. If a cmdlet is only made visible in one role, it's visible to the user with any applicable
   parameter constraints.
1. If a cmdlet is made visible in more than one role, and each role has the same constraints on the
   cmdlet, the cmdlet is visible to the user with those constraints.
1. If a cmdlet is made visible in more than one role, and each role allows a different set of
   parameters, the cmdlet and all the parameters defined across every role are visible to the user.
   If one role doesn't have constraints on the parameters, all parameters are allowed.
1. If one role defines a validate set or validate pattern for a cmdlet parameter, and the other role
   allows the parameter but doesn't constrain the parameter values, the validate set or pattern is
   ignored.
1. If a validate set is defined for the same cmdlet parameter in more than one role, all values from
   all validate sets are allowed.
1. If a validate pattern is defined for the same cmdlet parameter in more than one role, any values
   that match any of the patterns are allowed.
1. If a validate set is defined in one or more roles, and a validate pattern is defined in another
   role for the same cmdlet parameter, the validate set is ignored and rule (6) applies to the
   remaining validate patterns.

Below is an example of how roles are merged according to these rules:

```powershell
# Role A Visible Cmdlets
$roleA = @{
    VisibleCmdlets = @(
        'Get-Service'
         @{
            Name       = 'Restart-Service'
            Parameters = @{ Name = 'DisplayName'; ValidateSet = 'DNS Client' }
        }
    )
}

# Role B Visible Cmdlets
$roleB = @{
    VisibleCmdlets = @(
        @{
            Name       = 'Get-Service';
            Parameters = @{ Name = 'DisplayName'; ValidatePattern = 'DNS.*' }
        }
        @{
            Name       = 'Restart-Service'
            Parameters = @{ Name = 'DisplayName'; ValidateSet = 'DNS Server' }
        }
    )
}

# Resulting permissions for a user who belongs to both role A and B
# - The constraint in role B for the DisplayName parameter on Get-Service
#   is ignored because of rule #4
# - The ValidateSets for Restart-Service are merged because both roles use
#   ValidateSet on the same parameter per rule #5
$mergedAandB = @{
    VisibleCmdlets = @(
        'Get-Service'
        @{
            Name = 'Restart-Service';
            Parameters = @{
                Name = 'DisplayName'
                ValidateSet = 'DNS Client', 'DNS Server'
            }
        }
    )
}
```

### VisibleExternalCommands, VisibleAliases, VisibleProviders, ScriptsToProcess

All other fields in the role capability file are added to a cumulative set of allowable external
commands, aliases, providers, and startup scripts. Any command, alias, provider, or script available
in one role capability is available to the JEA user.

Be careful to ensure that the combined set of providers from one role capability and
cmdlets/functions/commands from another don't allow users unintentional access to system resources.
For example, if one role allows the `Remove-Item` cmdlet and another allows the `FileSystem`
provider, you are at risk of a JEA user deleting arbitrary files on your computer. Additional
information about identifying users' effective permissions can be found in the [auditing JEA][08]
article.

## Next steps

[Create a session configuration file][10]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_command_precedence
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_commonparameters
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_regular_expressions
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/new-psrolecapabilityfile
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/new-pssessionconfigurationfile
[06]: https://learn.microsoft.com/powershell/module/smbshare/get-smbshare
[07]: https://learn.microsoft.com/powershell/scripting/developer/windows-powershell
[08]: audit-and-report.md
[09]: https://devblogs.microsoft.com/scripting/validate-powershell-parameters-before-running-the-script/
[10]: session-configurations.md
[11]: session-configurations.md#user-drive

# /./reference/security/remoting/jea/session-configurations.md

    ---
    description: Session configurations define who can use the JEA endpoint and which roles they have access to.
    ms.date: 11/16/2022
    title: JEA Session Configurations
    ---

# JEA Session Configurations

A JEA endpoint is registered on a system by creating and registering a PowerShell session
configuration file. Session configurations define who can use the JEA endpoint and which roles they
have access to. They also define global settings that apply to all users of the JEA session.

## Create a session configuration file

To register a JEA endpoint, you must specify how that endpoint is configured. There are many options
to consider. The most important options are:

- Who has access to the JEA endpoint
- Which roles they may be assigned
- Which identity JEA uses under the covers
- The name of the JEA endpoint

These options are defined in a PowerShell data file with a `.pssc` extension known as a PowerShell
session configuration file. The session configuration file can be edited using any text editor.

Run the following command to create a blank template configuration file.

```powershell
New-PSSessionConfigurationFile -SessionType RestrictedRemoteServer -Path .\MyJEAEndpoint.pssc
```

> [!TIP]
> Only the most common configuration options are included in the template file by default. Use the
> `-Full` switch to include all applicable settings in the generated PSSC.

The `-SessionType RestrictedRemoteServer` field indicates that the session configuration is used by
JEA for secure management. Sessions of this type operate in **NoLanguage** mode and only have access
to the following default commands (and aliases):

- `Clear-Host` (`cls`, `clear`)
- `Exit-PSSession` (`exsn`, `exit`)
- `Get-Command` (`gcm`)
- `Get-FormatData`
- `Get-Help`
- `Measure-Object` (`measure`)
- `Out-Default`
- `Select-Object` (`select`)

No PowerShell providers are available, nor are any external programs (executables or scripts).

For more information about language modes, see [about_Language_modes][01].

### Choose the JEA identity

Behind the scenes, JEA needs an identity (account) to use when running a connected user's commands.
You define which identity JEA uses in the session configuration file.

#### Local Virtual Account

Local virtual accounts are useful when all roles defined for the JEA endpoint are used to manage the
local machine and a local administrator account is sufficient to run the commands successfully.
Virtual accounts are temporary accounts that are unique to a specific user and only last for the
duration of their PowerShell session. On a member server or workstation, virtual accounts belong to
the local computer's **Administrators** group. On an Active Directory Domain Controller, virtual
accounts belong to the domain's **Domain Admins** group.

```powershell
# Setting the session to use a virtual account
RunAsVirtualAccount = $true
```

If the roles defined by the session configuration don't require full administrative privilege, you
can specify the security groups to which the virtual account will belong. On a member server or
workstation, the specified security groups must be local groups, not groups from a domain.

When one or more security groups are specified, the virtual account isn't assigned to the local or
domain administrators group.

```powershell
# Setting the session to use a virtual account that only belongs to the NetworkOperator and NetworkAuditor local groups
RunAsVirtualAccount = $true
RunAsVirtualAccountGroups = 'NetworkOperator', 'NetworkAuditor'
```

> [!NOTE]
> Virtual accounts are temporarily granted the Logon as a service right in the local server security
> policy. If one of the VirtualAccountGroups specified has already been granted this right in the
> policy, the individual virtual account will no longer be added and removed from the policy. This
> can be useful in scenarios such as domain controllers where revisions to the domain controller
> security policy are closely audited. This is only available in Windows Server 2016 with the
> November 2018 or later rollup and Windows Server 2019 with the January 2019 or later rollup.

#### Group-managed service account

A group-managed service account (GMSA) is the appropriate identity to use when JEA users need to
access network resources such as file shares and web services. GMSAs give you a domain identity that's used to authenticate with resources on any machine within the domain. The rights that a GMSA
provides are determined by the resources you're accessing. You don't have admin rights on any
machines or services unless the machine or service administrator has explicitly granted those rights
to the GMSA.

```powershell
# Configure JEA sessions to use the GMSA in the local computer's domain
# with the sAMAccountName of 'MyJEAGMSA'
GroupManagedServiceAccount = 'Domain\MyJEAGMSA'
```

GMSAs should only be used when necessary:

- It's difficult to trace back actions to a user when using a GMSA. Every user shares the same
  run-as identity. You must review PowerShell session transcripts and logs to correlate individual
  users with their actions.

- The GMSA may have access to many network resources that the connecting user doesn't need
  access to. Always try to limit effective permissions in a JEA session to follow the principle of
  least privilege.

> [!NOTE]
> Group managed service accounts are only available on domain-joined machines using PowerShell 5.1
> or newer.

For more information about securing a JEA session, see the
[security considerations][07] article.

### Session transcripts

It's recommended that you configure a JEA endpoint to automatically record transcripts of users'
sessions. PowerShell session transcripts contain information about the connecting user, the run as
identity assigned to them, and the commands run by the user. They can be useful to an auditing team
who needs to understand who made a specific change to a system.

To configure automatic transcription in the session configuration file, provide a path to a folder
where the transcripts should be stored.

```powershell
TranscriptDirectory = 'C:\ProgramData\JEAConfiguration\Transcripts'
```

Transcripts are written to the folder by the **Local System** account, which requires read and write
access to the directory. Standard users should have no access to the folder. Limit the number of
security administrators that have access to audit the transcripts.

### User drive

If your connecting users need to copy files to or from the JEA endpoint, you can enable the user
drive in the session configuration file. The user drive is a **PSDrive** that's mapped to a unique
folder for each connecting user. This folder allows users to copy files to or from the system
without giving them access to the full file system or exposing the FileSystem provider. The user
drive contents are persistent across sessions to accommodate situations where network connectivity
may be interrupted.

```powershell
MountUserDrive = $true
```

By default, the user drive allows you to store a maximum of 50MB of data per user. You can limit the
amount of data a user can consume with the *UserDriveMaximumSize* field.

```powershell
# Enables the user drive with a per-user limit of 500MB (524288000 bytes)
MountUserDrive = $true
UserDriveMaximumSize = 524288000
```

If you don't want data in the user drive to be persistent, you can configure a scheduled task on
the system to automatically clean up the folder every night.

> [!NOTE]
> The user drive is only available in PowerShell 5.1 or newer.

For more information about PSDrives, see [Managing PowerShell drives][03].

### Role definitions

Role definitions in a session configuration file define the mapping of **users** to **roles**. Every
user or group included in this field is granted permission to the JEA endpoint when it's registered.
Each user or group can be included as a key in the hashtable only once, but can be assigned multiple
roles. The name of the role capability should be the name of the role capability file, without the
`.psrc` extension.

```powershell
RoleDefinitions = @{
    'CONTOSO\JEA_DNS_ADMINS'    = @{ RoleCapabilities = 'DnsAdmin', 'DnsOperator', 'DnsAuditor' }
    'CONTOSO\JEA_DNS_OPERATORS' = @{ RoleCapabilities = 'DnsOperator', 'DnsAuditor' }
    'CONTOSO\JEA_DNS_AUDITORS'  = @{ RoleCapabilities = 'DnsAuditor' }
}
```

If a user belongs to more than one group in the role definition, they get access to the roles of
each. When two roles grant access to the same cmdlets, the most permissive parameter set is granted
to the user.

When specifying local users or groups in the role definitions field, be sure to use the computer
name, not **localhost** or wildcards. You can check the computer name by inspecting the
`$env:COMPUTERNAME` variable.

```powershell
RoleDefinitions = @{
    'MyComputerName\MyLocalGroup' = @{ RoleCapabilities = 'DnsAuditor' }
}
```

### Role capability search order

As shown in the example above, role capabilities are referenced by the base name of the role
capability file. The base name of a file is the filename without the extension. If multiple role
capabilities are available on the system with the same name, PowerShell uses its implicit search
order to select the effective role capability file. JEA does **not** give access to all role
capability files with the same name.

JEA uses the `$env:PSModulePath` environment variable to determine which paths to scan for role
capability files. Within each of those paths, JEA looks for valid PowerShell modules that contain a
"RoleCapabilities" subfolder. As with importing modules, JEA prefers role capabilities that are
shipped with Windows to custom role capabilities with the same name.

For all other naming conflicts, precedence is determined by the order in which Windows enumerates
the files in the directory. The order isn't guaranteed to be alphabetical. The first role capability
file found that matches the specified name is used for the connecting user. Since the role
capability search order isn't deterministic, it's **strongly recommended** that role capabilities
have unique filenames.

### Conditional access rules

All users and groups included in the **RoleDefinitions** field are automatically granted access to
JEA endpoints. Conditional access rules allow you to refine this access and require users to belong
to additional security groups that don't impact the roles to which they're assigned. This is useful
when you want to integrate a just-in-time privileged access management solution, smartcard
authentication, or other multifactor authentication solution with JEA.

Conditional access rules are defined in the RequiredGroups field in a session configuration file.
There, you can provide a hashtable (optionally nested) that uses 'And' and 'Or' keys to construct
your rules. Here are some examples of how to use this field:

```powershell
# Example 1: Connecting users must belong to a security group called "elevated-jea"
RequiredGroups = @{ And = 'elevated-jea' }

# Example 2: Connecting users must have signed on with 2 factor authentication or a smart card
# The 2 factor authentication group name is "2FA-logon" and the smart card group
# name is "smartcard-logon"
RequiredGroups = @{ Or = '2FA-logon', 'smartcard-logon' }

# Example 3: Connecting users must elevate into "elevated-jea" with their JIT system and
# have logged on with 2FA or a smart card
RequiredGroups = @{ And = 'elevated-jea', @{ Or = '2FA-logon', 'smartcard-logon' }}
```

> [!NOTE]
> Conditional access rules are only available in PowerShell 5.1 or newer.

### Other properties

Session configuration files can also do everything a role capability file can do, just without the
ability to give connecting users access to different commands. If you want to allow all users access
to specific cmdlets, functions, or providers, you can do so right in the session configuration file.
For a full list of supported properties in the session configuration file, run
`Get-Help New-PSSessionConfigurationFile -Full`.

## Testing a session configuration file

You can test a session configuration using the [Test-PSSessionConfigurationFile][02] cmdlet. It's
recommended that you test your session configuration file if you've manually edited the `.pssc`
file. Testing ensures the syntax is correct. If a session configuration file fails this test, it
can't be registered on the system.

## Sample session configuration file

The following example shows how to create and validate a session configuration for JEA. The role
definitions are created and stored in the `$roles` variable for convenience and readability. it isn't
a requirement to do so.

```powershell
$roles = @{
    'CONTOSO\JEA_DNS_ADMINS'    = @{ RoleCapabilities = 'DnsAdmin', 'DnsOperator', 'DnsAuditor' }
    'CONTOSO\JEA_DNS_OPERATORS' = @{ RoleCapabilities = 'DnsOperator', 'DnsAuditor' }
    'CONTOSO\JEA_DNS_AUDITORS'  = @{ RoleCapabilities = 'DnsAuditor' }
}

$parameters = @{
    SessionType = 'RestrictedRemoteServer'
    Path = '.\JEAConfig.pssc'
    RunAsVirtualAccount = $true
    TranscriptDirectory = 'C:\ProgramData\JEAConfiguration\Transcripts'
    RoleDefinitions = $roles
    RequiredGroups = @{ Or = '2FA-logon', 'smartcard-logon' }
}
New-PSSessionConfigurationFile @parameters
Test-PSSessionConfigurationFile -Path .\JEAConfig.pssc # should yield True
```

## Updating session configuration files

To change the properties of a JEA session configuration, including the mapping of users to roles,
you must [unregister][05]. Then, [re-register][04] the JEA session configuration using an updated
session configuration file.

## Next steps

- [Register a JEA configuration][04]
- [Author JEA roles][06]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_language_modes
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/test-pssessionconfigurationfile
[03]: https://learn.microsoft.com/powershell/scripting/samples/managing-windows-powershell-drives
[04]: register-jea.md
[05]: register-jea.md#unregistering-jea-configurations
[06]: role-capabilities.md
[07]: security-considerations.md

# /./reference/security/remoting/jea/register-jea.md

    ---
    description: Registering the JEA endpoint with the system makes the endpoint available for use by users and automation engines.
    ms.date: 11/16/2022
    title: Registering JEA Configurations
    ---
# Registering JEA Configurations

Once you have your [role capabilities][08] and [session configuration file][09] created, the last
step is to register the JEA endpoint. Registering the JEA endpoint with the system makes the
endpoint available for use by users and automation engines.

## Single machine configuration

For small environments, you can deploy JEA by registering the session configuration file using the
[Register-PSSessionConfiguration][03] cmdlet.

Before you begin, ensure that the following prerequisites have been met:

- One or more roles has been created and placed in the **RoleCapabilities** folder of a PowerShell
  module.
- A session configuration file has been created and tested.
- The user registering the JEA configuration has administrator rights on the system.
- You've selected a name for your JEA endpoint.

The name of the JEA endpoint is required when users connect to the system using JEA. The
[Get-PSSessionConfiguration][02] cmdlet lists the names of the endpoints on a system. Endpoints that
start with `microsoft` are typically shipped with Windows. The `microsoft.powershell` endpoint is
the default endpoint used when connecting to a remote PowerShell endpoint.

```powershell
Get-PSSessionConfiguration | Select-Object Name
```

```Output
Name
----
microsoft.powershell
microsoft.powershell.workflow
microsoft.powershell32
```

Run the following command to register the endpoint.

```powershell
Register-PSSessionConfiguration -Path .\MyJEAConfig.pssc -Name 'JEAMaintenance' -Force
```

> [!WARNING]
> The previous command restarts the WinRM service on the system. This terminates all PowerShell
> remoting sessions and any ongoing DSC configurations. We recommended you take production machines
> offline before running the command to avoid disrupting business operations.

After registration, you're ready to [use JEA][10]. You may delete the session configuration file at
any time. The configuration file isn't used after registration of the endpoint.

## Multi-machine configuration with DSC

When deploying JEA on multiple machines, the simplest deployment model uses the JEA
[Desired State Configuration (DSC)][01] resource to quickly and consistently deploy JEA on each
machine.

To deploy JEA with DSC, ensure the following prerequisites are met:

- One or more role capabilities have been authored and added to a PowerShell module.
- The PowerShell module containing the roles is stored on a (read-only) file share accessible by
  each machine.
- Settings for the session configuration have been determined. You don't need to create a session
  configuration file when using the JEA DSC resource.
- You have credentials that allow administrative actions on each machine or access to the DSC pull
  server used to manage the machines.
- You've downloaded the [JEA DSC resource][07].

Create a DSC configuration for your JEA endpoint on a target machine or pull server. In this
configuration, the **JustEnoughAdministration** DSC resource defines the session configuration file
and the **File** resource copies the role capabilities from the file share.

The following properties are configurable using the DSC resource:

- Role Definitions
- Virtual account groups
- Group-managed service account name
- Transcript directory
- User drive
- Conditional access rules
- Startup scripts for the JEA session

The syntax for each of these properties in a DSC configuration is consistent with the PowerShell
session configuration file.

Below is a sample DSC configuration for a general server maintenance module. It assumes that a valid
PowerShell module containing role capabilities is located on the `\\myfileshare\JEA` file share.

```powershell
Configuration JEAMaintenance
{
    Import-DscResource -Module JustEnoughAdministration, PSDesiredStateConfiguration

    File MaintenanceModule
    {
        SourcePath = "\\myfileshare\JEA\ContosoMaintenance"
        DestinationPath = "C:\Program Files\WindowsPowerShell\Modules\ContosoMaintenance"
        Checksum = "SHA-256"
        Ensure = "Present"
        Type = "Directory"
        Recurse = $true
    }

    JeaEndpoint JEAMaintenanceEndpoint
    {
        EndpointName = "JEAMaintenance"
        RoleDefinitions = "@{ 'CONTOSO\JEAMaintenanceAuditors' = @{ RoleCapabilities = 'GeneralServerMaintenance-Audit' }; 'CONTOSO\JEAMaintenanceAdmins' = @{ RoleCapabilities = 'GeneralServerMaintenance-Audit', 'GeneralServerMaintenance-Admin' } }"
        TranscriptDirectory = 'C:\ProgramData\JEAConfiguration\Transcripts'
        DependsOn = '[File]MaintenanceModule'
    }
}
```

Next, the configuration is applied on a system by directly invoking the
[Local Configuration Manager][05] or updating the [pull server configuration][06].

The DSC resource also allows you to replace the default **Microsoft.PowerShell** endpoint. When
replaced, the resource automatically registers a backup endpoint named
**Microsoft.PowerShell.Restricted**. The backup endpoint has the default WinRM ACL that allows
Remote Management Users and local Administrators group members to access it.

## Unregistering JEA configurations

The [Unregister-PSSessionConfiguration][04] cmdlet removes a JEA endpoint. Unregistering a JEA
endpoint prevents new users from creating new JEA sessions on the system. It also allows you to
update a JEA configuration by re-registering an updated session configuration file using the same
endpoint name.

```powershell
# Unregister the JEA endpoint called "ContosoMaintenance"
Unregister-PSSessionConfiguration -Name 'ContosoMaintenance' -Force
```

> [!WARNING]
> Unregistering a JEA endpoint causes the WinRM service to restart. This interrupts most remote
> management operations in progress, including other PowerShell sessions, WMI invocations, and some
> management tools. Only unregister PowerShell endpoints during planned maintenance windows.

## Next steps

[Test the JEA endpoint][10]

<!-- link references -->
[01]: ../../../dsc/overview.md
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-pssessionconfiguration
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/register-pssessionconfiguration
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/Unregister-PSSessionConfiguration
[05]: https://learn.microsoft.com/powershell/scripting/dsc/managing-nodes/metaConfig
[06]: https://learn.microsoft.com/powershell/scripting/dsc/pull-server/pullServer
[07]: https://github.com/powershell/JEA/tree/master/DSC%20Resource
[08]: role-capabilities.md
[09]: session-configurations.md
[10]: using-jea.md

# /./reference/security/remoting/jea/using-jea.md

    ---
    description: This article describes the various ways you can connect to and use a JEA endpoint.
    ms.date: 02/02/2023
    title: Using JEA
    ---

# Using JEA

This article describes the various ways you can connect to and use a JEA endpoint.

## Using JEA interactively

If you're testing your JEA configuration or have simple tasks for users, you can use JEA the same
way you would a regular PowerShell remoting session. For complex remoting tasks, it's recommended to
use [implicit remoting][09]. Implicit remoting allows users to operate with the data objects
locally.

To use JEA interactively, you need:

- The name of the computer you're connecting to (can be the local machine)
- The name of the JEA endpoint registered on that computer
- Credentials that have access to the JEA endpoint on that computer

Given that information, you can start a JEA session using the [New-PSSession][05] or
[Enter-PSSession][02] cmdlets.

```powershell
$sessionParams = @{
    ComputerName      = 'localhost'
    ConfigurationName = 'JEAMaintenance'
    Credential        = Get-Credential
}
Enter-PSSession @sessionParams
```

If the current user account has access to the JEA endpoint, you can omit the **Credential**
parameter.

When the PowerShell prompt changes to `[localhost]: PS>` you know that you're now interacting with
the remote JEA session. You can run `Get-Command` to check which commands are available. Consult
with your administrator to learn if there are any restrictions on the available parameters or
allowed parameter values.

Remember, JEA sessions operate in `NoLanguage` mode. Some of the ways you typically use PowerShell
may not be available. For instance, you can't use variables to store data or inspect the properties
on objects returned from cmdlets. The following example shows two approaches to get the same
commands to work in `NoLanguage` mode.

```powershell
# Using variables is prohibited in NoLanguage mode. The following will not work:
# $vm = Get-VM -Name 'SQL01'
# Start-VM -VM $vm

# You can use pipes to pass data through to commands that accept input from the pipeline
Get-VM -Name 'SQL01' | Start-VM

# You can also wrap subcommands in parentheses and enter them inline as arguments
Start-VM -VM (Get-VM -Name 'SQL01')

# You can also use parameter sets that don't require extra data to be passed in
Start-VM -VMName 'SQL01'
```

For more complex command invocations that make this approach difficult, consider using
[implicit remoting][09] or [creating custom functions][12] that wrap the functionality you require.
For more information on `NoLanguageMode`, see [about_Language_Modes][13].

## Using JEA with implicit remoting

PowerShell has an implicit remoting model that lets you import proxy cmdlets from a remote machine
and interact with them as if they were local commands. Implicit remoting is explained in this _Hey,
Scripting Guy!_ [blog post][10]. Implicit remoting is useful when working with JEA because it
allows you to work with JEA cmdlets in a full language mode. You can use tab completion, variables,
manipulate objects, and even use local scripts to automate tasks against a JEA endpoint. Anytime you
invoke a proxy command, the data is sent to the JEA endpoint on the remote machine and executed
there.

Implicit remoting works by importing cmdlets from an existing PowerShell session. You can optionally
choose to prefix the nouns of each proxy cmdlet with a string of your choosing. The prefix allows
you to distinguish the commands that are for the remote system. A temporary script module containing
all the proxy commands is created and imported for the duration of your local PowerShell session.

```powershell
# Create a new PSSession to your JEA endpoint
$jeaSession = New-PSSession -ComputerName 'SERVER01' -ConfigurationName 'JEAMaintenance'

# Import the entire PSSession and prefix each imported cmdlet with "JEA"
Import-PSSession -Session $jeaSession -Prefix 'JEA'

# Invoke "Get-Command" on the remote JEA endpoint using the proxy cmdlet
Get-JEACommand
```

> [!IMPORTANT]
> Some systems may not be able to import an entire JEA session due to constraints in the default JEA
> cmdlets. To get around this, only import the commands you need from the JEA session by explicitly
> providing their names to the `-CommandName` parameter. A future update will address the issue with
> importing entire JEA sessions on affected systems.

If you're unable to import a JEA session because of JEA constraints on the default parameters,
follow the steps below to filter out the default commands from the imported set. You can continue
use commands like `Select-Object`, but you'll just use the local version installed on your computer
instead of the one imported from the remote JEA session.

```powershell
# Create a new PSSession to your JEA endpoint
$jeaSession = New-PSSession -ComputerName 'SERVER01' -ConfigurationName 'JEAMaintenance'

# Get a list of all the commands on the JEA endpoint
$commands = Invoke-Command -Session $jeaSession -ScriptBlock { Get-Command }

# Filter out the default cmdlets
$jeaDefaultCmdlets = @(
    'Clear-Host'
    'Exit-PSSession'
    'Get-Command'
    'Get-FormatData'
    'Get-Help'
    'Measure-Object'
    'Out-Default'
    'Select-Object'
)
$filteredCommands = $commands.Name | Where-Object { $jeaDefaultCmdlets -notcontains $_ }

# Import only commands explicitly added in role capabilities and prefix each
# imported cmdlet with "JEA"
Import-PSSession -Session $jeaSession -Prefix 'JEA' -CommandName $filteredCommands
```

You can also persist the proxied cmdlets from implicit remoting using [Export-PSSession][06]. For
more information about implicit remoting, see the documentation for [Import-PSSession][07] and
[Import-Module][03].

## Using JEA programmatically

JEA can also be used in automation systems and in user applications, such as in-house helpdesk apps
and websites. The approach is the same as that for building apps that talk to unconstrained
PowerShell endpoints. Ensure the program is designed to work with limitation imposed by JEA.

For simple, one-off tasks, you can use [Invoke-Command][04] to run commands in a JEA session.

```powershell
Invoke-Command -ComputerName 'SERVER01' -ConfigurationName 'JEAMaintenance' -ScriptBlock {
    Get-Process
    Get-Service
}
```

To check which commands are available for use when you connect to a JEA session, run `Get-Command`
and iterate through the results to check for the allowed parameters.

```powershell
$commandParameters = @{
    ComputerName      = 'SERVER01'
    ConfigurationName = 'JEAMaintenance'
    ScriptBlock       = { Get-Command }
}
Invoke-Command @commandParameters |
    Where-Object { $_.CommandType -in @('Function', 'Cmdlet') } |
    Format-Table Name, Parameters
```

If you're building a C# app, you can create a PowerShell runspace that connects to a JEA session by
specifying the configuration name in a [WSManConnectionInfo][01] object.

```csharp
// using System.Management.Automation;
var computerName = "SERVER01";
var configName   = "JEAMaintenance";
// See https://learn.microsoft.com/dotnet/api/system.management.automation.pscredential
var creds        = // create a PSCredential object here

WSManConnectionInfo connectionInfo = new WSManConnectionInfo(
    false,                 // Use SSL
    computerName,          // Computer name
    5985,                  // WSMan Port
    "/wsman",              // WSMan Path
                           // Connection URI with config name
    string.Format(
        CultureInfo.InvariantCulture,
        "http://schemas.microsoft.com/powershell/{0}",
        configName
    ),
    creds                  // Credentials
);

// Now, use the connection info to create a runspace where you can run the commands
using (Runspace runspace = RunspaceFactory.CreateRunspace(connectionInfo))
{
    // Open the runspace
    runspace.Open();

    using (PowerShell ps = PowerShell.Create())
    {
        // Set the PowerShell object to use the JEA runspace
        ps.Runspace = runspace;

        // Now you can add and invoke commands
        ps.AddCommand("Get-Command");
        foreach (var result in ps.Invoke())
        {
            Console.WriteLine(result);
        }
    }

    // Close the runspace
    runspace.Close();
}
```

## Using JEA with PowerShell Direct

Hyper-V in Windows 10 and Windows Server 2016 offers [PowerShell Direct][08], a feature that allows
Hyper-V administrators to manage virtual machines with PowerShell regardless of the network
configuration or remote management settings on the virtual machine.

You can use PowerShell Direct with JEA to give a Hyper-V administrator limited access to your VM.
This can be useful if you lose network connectivity to your VM and need a datacenter admin to fix
the network settings.

No additional configuration is required to use JEA over PowerShell Direct. However, the guest
operating system running inside the virtual machine must be Windows 10, Windows Server 2016, or
higher. The Hyper-V admin can connect to the JEA endpoint by using the `-VMName` or `-VMId`
parameters on PSRemoting cmdlets:

```powershell
$sharedParams = @{
    ConfigurationName = 'NICMaintenance'
    Credential        = Get-Credential -UserName 'localhost\JEAformyHoster'
}
# Entering a JEA session using PowerShell Direct when the VM name is unique
Enter-PSSession -VMName 'SQL01' @sharedParams

# Entering a JEA session using PowerShell Direct using VM ids
$vm = Get-VM -VMName 'MyVM' | Select-Object -First 1
Enter-PSSession -VMId $vm.VMId @sharedParams
```

It's recommended you create a dedicated user account with the minimum rights needed to manage the
system for use by a Hyper-V administrator. Remember, even an unprivileged user can sign into a
Windows machine by default, including using unconstrained PowerShell. That allows them to browse the
file system and learn more about your OS environment. To lock down a Hyper-V administrator and limit
them to only access a VM using PowerShell Direct with JEA, you must deny local logon rights to the
Hyper-V admin's JEA account.

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.wsmanconnectioninfo
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/enter-pssession
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/import-module
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/invoke-command
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/New-PSSession
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/Export-PSSession
[07]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/import-pssession
[08]: https://learn.microsoft.com/virtualization/hyper-v-on-windows/user-guide/powershell-direct
[09]: #using-jea-with-implicit-remoting
[10]: https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/
[12]: role-capabilities.md#creating-custom-functions
[13]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_Language_Modes

# /./reference/security/remoting/jea/security-considerations.md

    ---
    description: >-
        Since JEA allows these users to run administrative commands without having full administrator
        access, you can then remove those users from highly privileged security groups.
    ms.date: 10/10/2023
    title: JEA Security Considerations
    ---
# JEA Security Considerations

JEA helps you improve your security posture by reducing the number of permanent administrators on
your machines. JEA uses a PowerShell session configuration to create a new entry point for users to
manage the system. Users who need elevated, but not unlimited, access to the machine to do
administrative tasks can be granted access to the JEA endpoint. Since JEA allows these users to run
administrative commands without having full administrator access, you can then remove those users
from highly privileged security groups.

## Run-As account

Each JEA endpoint has a designated **run-as** account under which the connecting user's actions are
executed. This account is configurable in the [session configuration file][03], and the account you
choose has a significant bearing on the security of your endpoint.

**Virtual accounts** are the recommended way of configuring the **run-as** account. Virtual accounts
are one-time, temporary local accounts that are created for the connecting user to use during the
duration of their JEA session. As soon as their session is terminated, the virtual account is
destroyed and can't be used anymore. The connecting user doesn't know the credentials for the
virtual account. The virtual account can't be used to access the system via other means like
Remote Desktop or an unconstrained PowerShell endpoint.

By default, virtual accounts are members of the local **Administrators** group on the machine. This
membership gives them full rights to manage anything on the system, but no rights to manage
resources on the network. When the user connects to other machines from the JEA session, the user
context is that of the local computer account, not the virtual account.

Domain controllers are a special case since there isn't a local **Administrators** group. Instead,
virtual accounts belong to **Domain Admins** and can manage the directory services on the domain
controller. The domain identity is still restricted for use on the domain controller where the JEA
session was instantiated. Any network access appears to come from the domain controller computer
object instead.

In both cases, you may assign the virtual account to specific security groups, especially when the
task can be done without local or domain administrator privileges. If you already have a security
group defined for your administrators, grant the virtual account membership to that group. Group
membership for virtual accounts is limited to local security groups on workstation and member
servers. On domain controllers, virtual accounts must be members of domain security groups. Once the
virtual account has been added to one or more security groups, it no longer belongs to the default
groups (local or domain administrators).

The following table summarizes the possible configuration options and resulting permissions for
virtual accounts:

|        Computer type         | Virtual account group configuration |                   Local user context                    | Network user context |
| ---------------------------- | ----------------------------------- | ------------------------------------------------------- | -------------------- |
| Domain controller            | Default                             | Domain user, member of `<DOMAIN>\Domain Admins`         | Computer account     |
| Domain controller            | Domain groups A and B               | Domain user, member of `<DOMAIN>\A`, `<DOMAIN>\B`       | Computer account     |
| Member server or workstation | Default                             | Local user, member of `BUILTIN\Administrators`          | Computer account     |
| Member server or workstation | Local groups C and D                | Local user, member of `<COMPUTER>\C` and `<COMPUTER>\D` | Computer account     |

When you look at Security audit and Application event logs, you see that each JEA user session has a
unique virtual account. This unique account helps you track user actions in a JEA endpoint back to
the original user who ran the command. Virtual account names follow the format
`WinRM Virtual Users\WinRM_VA_<ACCOUNTNUMBER>_<DOMAIN>_<sAMAccountName>` For example, if user
**Alice** in domain **Contoso** restarts a service in a JEA endpoint, the username associated with
any service control manager events would be `WinRM Virtual Users\WinRM_VA_1_contoso_alice`.

**Group-managed service accounts (gMSAs)** are useful when a member server needs to have access to
network resources in the JEA session. For example, when a JEA endpoint is used to control access to
a REST API service hosted on a different machine. It's easy to write functions to invoke the REST
APIs, but you need a network identity to authenticate with the API. Using a group-managed service
account makes the second hop possible while maintaining control over which computers can use the
account. The security group (local or domain) memberships of the gMSA defined the effective
permissions for the gMSA account.

When a JEA endpoint is configured to use a gMSA, the actions of all JEA users appear to come from
the same gMSA. The only way to trace actions back to a specific user is to identify the set of
commands run in a PowerShell session transcript.

**Pass-through credentials** are used when you don't specify a **run-as** account. PowerShell uses
the connecting user's credential to run commands on the remote server. To use pass-through
credentials, you must grant the connecting user direct access to privileged management groups. This
configuration is **NOT** recommended for JEA. If the connecting user already has administrator
privileges, they can bypass JEA and manage the system using other access methods.

**Standard run-as accounts** allow you to specify any user account under which the entire PowerShell
session runs. Session configurations using fixed **run-as** accounts (with the `-RunAsCredential`
parameter) aren't JEA-aware. Role definitions no longer function as expected. Every user authorized
to access the endpoint is assigned the same role.

You shouldn't use a **RunAsCredential** on a JEA endpoint because it's difficult to trace actions
back to specific users and lacks support for mapping users to roles.

## WinRM Endpoint ACL

As with regular PowerShell remoting endpoints, each JEA endpoint has a separate access control list
(ACL) that controls who can authenticate with the JEA endpoint. If improperly configured, trusted
users may not be able to access the JEA endpoint, and untrusted users may have access. The WinRM ACL
doesn't affect the mapping of users to JEA roles. Mapping is controlled by the **RoleDefinitions**
field in the session configuration file used to register the endpoint.

By default, when a JEA endpoint has multiple role capabilities, the WinRM ACL is configured to allow
access to all mapped users. For example, a JEA session configured using the following commands
grants full access to `CONTOSO\JEA_Lev1` and `CONTOSO\JEA_Lev2`.

```powershell
$roles = @{ 'CONTOSO\JEA_Lev1' = 'Lev1Role'; 'CONTOSO\JEA_Lev2' = 'Lev2Role' }
New-PSSessionConfigurationFile -Path '.\jea.pssc' -SessionType RestrictedRemoteServer -RoleDefinitions $roles -RunAsVirtualAccount
Register-PSSessionConfiguration -Path '.\jea.pssc' -Name 'MyJEAEndpoint'
```

You can audit user permissions with the [Get-PSSessionConfiguration][01]
cmdlet.

```powershell
Get-PSSessionConfiguration -Name 'MyJEAEndpoint' | Select-Object Permission
```

```Output
Permission
----------
CONTOSO\JEA_Lev1 AccessAllowed
CONTOSO\JEA_Lev2 AccessAllowed
```

To change which users have access, run either
`Set-PSSessionConfiguration -Name 'MyJEAEndpoint' -ShowSecurityDescriptorUI` for an interactive
prompt or `Set-PSSessionConfiguration -Name 'MyJEAEndpoint' -SecurityDescriptorSddl <SDDL string>`
to update the permissions. Users need at least _Invoke_ rights to access the JEA endpoint.

It's possible to create a JEA endpoint that doesn't map a defined role to every user that has
access. These users can start a JEA session, but only have access to the default cmdlets. You can
audit user permissions in a JEA endpoint by running `Get-PSSessionCapability`. For more information,
see [Auditing and Reporting on JEA][02].

## Least privilege roles

When designing JEA roles, it's important to remember that the virtual and group-managed service
accounts running behind the scenes can have unrestricted access to the local machine. JEA role
capabilities help limit the commands and applications that can be run in that privileged context.
Improperly designed roles can allow dangerous commands that may permit a user to break out of the
JEA boundaries or obtain access to sensitive information.

For example, consider the following role capability entry:

```powershell
@{
    VisibleCmdlets = 'Microsoft.PowerShell.Management\*-Process'
}
```

This role capability allows users to run any PowerShell cmdlet with the noun **Process** from the
**Microsoft.PowerShell.Management** module. Users may need to access cmdlets like `Get-Process` to
see what applications are running on the system and `Stop-Process` to kill applications that aren't
responding. However, this entry also allows `Start-Process`, which can be used to start up an
arbitrary program with full administrator permissions. The program doesn't need to be installed
locally on the system. A connected user could start a program from a file share that gives the user
local administrator privileges, runs malware, and more.

A more secure version of this same role capability would look like:

```powershell
@{
    VisibleCmdlets = 'Microsoft.PowerShell.Management\Get-Process',
                     'Microsoft.PowerShell.Management\Stop-Process'
}
```

Avoid using wildcards in role capabilities. Be sure to regularly audit effective user permissions to
see which commands are accessible to a user. For more information, see the _Check effective rights_
section of the [Auditing and Reporting on JEA][02] article.

## Best practice recommendations

The following are best practice recommendations to ensure the security of your JEA endpoints:

### Limit the use and capabilities of PowerShell providers

Review how the allowed providers are used to ensure that you don't create vulnerabilities in your
configured session.

> [!WARNING]
> Don't allow the **FileSystem** provider. If users can write to any part of the file system, it's
> possible to completely bypass security.
>
> Don't allow the **Certificate** provider. With the provider enabled, a user could gain access to
> stored private keys.

### Don't allow commands that can create new runspaces.

> [!WARNING]
> The `*-Job` cmdlets can create new runspaces without the restrictions.

### Don't allow the `Trace-Command` cmdlet.

> [!WARNING]
> Using `Trace-Command` brings all traced commands into the session.

### Don't create your own proxy implementations for the _restricted commands_.

PowerShell has a set of proxy commands for restricted command scenarios. These proxy commands
ensure that input parameters can't compromise the security of the session. The following commands
have restricted proxies:

- `Exit-PSSession`
- `Get-Command`
- `Get-FormatData`
- `Get-Help`
- `Measure-Object`
- `Out-Default`
- `Select-Object`

If you create your own implementation of these commands, you may inadvertently allow users to run
code prohibited by the JEA proxy commands.

## JEA doesn't protect against admins

One of the core principles of JEA is that it allows nonadministrators to do some administrative
tasks. JEA doesn't protect against users who already have administrator privileges. Users who belong
**Domain Admins**, local **Administrators**, or other highly privileged groups can circumvent JEA's
protections in other ways. For example, they could sign in with RDP, use remote MMC consoles, or
connect to unconstrained PowerShell endpoints. Also, local administrator on a system can modify JEA
configurations to add more users or change a role capability to extend the scope of what a user can
do in their JEA session. It's important to evaluate your JEA users' extended permissions to see if
there are other ways to gain privileged access to the system.

In addition to using JEA for regular day-to-day maintenance, it's common to have a just-in-time
privileged access management system. These systems allow designated users to temporarily become
a local administrator only after they complete a workflow that documents their use of those
permissions.

<!-- link references -->
[01]: xref:Microsoft.PowerShell.Core.Get-PSSessionConfiguration
[02]: audit-and-report.md#check-effective-rights-for-a-specific-user
[03]: session-configurations.md

# /./reference/security/remoting/jea/audit-and-report.md

    ---
    description: Auditing helps you assess that the correct people have access to the JEA endpoint and their assigned roles are still appropriate.
    ms.date: 11/16/2022
    title: Auditing and Reporting on JEA
    ---

# Auditing and Reporting on JEA

After you've deployed JEA, you need to regularly audit the JEA configuration. Auditing helps you
assess that the correct people have access to the JEA endpoint and their assigned roles are still
appropriate.

## Find registered JEA sessions on a machine

To check which JEA sessions are registered on a machine, use the
[Get-PSSessionConfiguration][02]
cmdlet.

```powershell
# Filter for sessions that are configured as 'RestrictedRemoteServer' to
# find JEA-like session configurations
Get-PSSessionConfiguration | Where-Object { $_.SessionType -eq 'RestrictedRemoteServer' }
```

```Output
Name          : JEAMaintenance
PSVersion     : 5.1
StartupScript :
RunAsUser     :
Permission    : CONTOSO\JEA_DNS_ADMINS AccessAllowed, CONTOSO\JEA_DNS_OPERATORS AccessAllowed,
                CONTOSO\JEA_DNS_AUDITORS AccessAllowed
```

The effective rights for the endpoint are listed in the **Permission** property. These users have
the right to connect to the JEA endpoint. However, the roles and commands they have access to is
determined by the **RoleDefinitions** property in the [session configuration file][05] that was used
to register the endpoint. Expand the **RoleDefinitions** property to evaluate the role mappings in a
registered JEA endpoint.

```powershell
# Get the desired session configuration
$jea = Get-PSSessionConfiguration -Name 'JEAMaintenance'

# Enumerate users/groups and which roles they have access to
$jea.RoleDefinitions.GetEnumerator() | Select-Object Name, @{
  Name = 'Role Capabilities'
  Expression = { $_.Value.RoleCapabilities }
}
```

## Find available role capabilities on the machine

JEA gets role capabilities from the `.psrc` files stored in the **RoleCapabilities** folder inside a
PowerShell module. The following function finds all role capabilities available on a computer.

```powershell
function Find-LocalRoleCapability {
    $results = @()

    # Find modules with a "RoleCapabilities" subfolder and add any PSRC files to the result set
    Get-Module -ListAvailable | ForEach-Object {
        $psrcpath = Join-Path -Path $_.ModuleBase -ChildPath 'RoleCapabilities'
        if (Test-Path $psrcpath) {
            $results += Get-ChildItem -Path $psrcpath -Filter *.psrc
        }
    }

    # Format the results nicely to make it easier to read
    $results | Select-Object @{ Name = 'Name'; Expression = { $_.Name.TrimEnd('.psrc') }}, @{
        Name = 'Path'; Expression = { $_.FullName }
    } | Sort-Object Name
}
```

> [!NOTE]
> The order of results from this function isn't necessarily the order in which the role capabilities
> will be selected if multiple role capabilities share the same name.

## Check effective rights for a specific user

The [Get-PSSessionCapability][01] cmdlet enumerates all the commands available on a JEA endpoint
based on a user's group memberships. The output of `Get-PSSessionCapability` is identical to that of
the specified user running `Get-Command -CommandType All` in a JEA session.

```powershell
Get-PSSessionCapability -ConfigurationName 'JEAMaintenance' -Username 'CONTOSO\Alice'
```

If your users aren't permanent members of groups that would grant them additional JEA rights, this
cmdlet may not reflect those extra permissions. This happens when using just-in-time privileged
access management systems to allow users to temporarily belong to a security group. Carefully
evaluate the mapping of users to roles and capabilities to ensure that users only get the level of
access needed to do their jobs successfully.

## PowerShell event logs

If you enabled module or script block logging on the system, you can see events in the Windows event
logs for each command a user runs in a JEA session. To find these events, open
**Microsoft-Windows-PowerShell/Operational** event log and look for events with event ID **4104**.

Each event log entry includes information about the session in which the command was run. For JEA
sessions, the event includes information about the **ConnectedUser** and the **RunAsUser**. The
**ConnectedUser** is the actual user who created the JEA session. The **RunAsUser** is the account
JEA used to execute the command.

Application event logs show changes being made by the **RunAsUser**. So having module and script
logging enabled is required to trace a specific command invocation back to the **ConnectedUser**.

## Application event logs

Commands run in a JEA session that interact with external applications or services may log events to
their own event logs. Unlike PowerShell logs and transcripts, other logging mechanisms don't capture
the connected user of the JEA session. Instead, those applications only log the virtual run-as user.
To determine who ran the command, you need to consult a [session transcript][03] or correlate
PowerShell event logs with the time and user shown in the application event log.

The WinRM log can also help you correlate run-as users to the connecting user in an application
event log. Event ID **193** in the **Microsoft-Windows-Windows Remote Management/Operational** log
records the security identifier (SID) and account name for both the connecting user and run as user
for every new JEA session.

## Session transcripts

If you configured JEA to create a transcript for each user session, a text copy of every user's
actions are stored in the specified folder.

The following command (as an administrator) finds all transcript directories.

```powershell
Get-PSSessionConfiguration |
  Where-Object { $_.TranscriptDirectory -ne $null } |
    Format-Table Name, TranscriptDirectory
```

Each transcript starts with information about the time the session started, which user connected to
the session, and which JEA identity was assigned to them.

```
**********************
Windows PowerShell transcript start
Start time: 20160710144736
Username: CONTOSO\Alice
RunAs User: WinRM Virtual Users\WinRM VA_1_CONTOSO_Alice
Machine: SERVER01 (Microsoft Windows NT 10.0.14393.0)
[...]
```

The body of the transcript contains information about each command the user invoked. The exact
syntax of the command used is unavailable in JEA sessions because of the way commands are
transformed for PowerShell remoting. However, you can still determine the effective command that was
executed. Below is an example transcript snippet from a user running `Get-Service Dns` in a JEA
session:

```
PS>CommandInvocation(Get-Service): "Get-Service"
>> ParameterBinding(Get-Service): name="Name"; value="Dns"
>> CommandInvocation(Out-Default): "Out-Default"
>> ParameterBinding(Out-Default): name="InputObject"; value="Dns"

Running  Dns                DNS Server
```

A **CommandInvocation** line is written for each command a user runs. **ParameterBindings** record
each parameter and value supplied with the command. In the previous example, you can see that the
parameter **Name** was supplied the with value **Dns** for the `Get-Service` cmdlet.

The output of each command also triggers a **CommandInvocation**, usually to `Out-Default`. The
**InputObject** of `Out-Default` is the PowerShell object returned from the command. The details of
that object are printed a few lines below, closely mimicking what the user would have seen.

## See also

[*PowerShell ♥ the Blue Team* blog post on security][04]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/Get-PSSessionCapability
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-pssessionconfiguration
[03]: #session-transcripts
[04]: https://devblogs.microsoft.com/powershell/powershell-the-blue-team/
[05]: session-configurations.md

# /./reference/security/remoting/running-remote-commands.md

    ---
    description: Explains the methods for running commands on remote systems using PowerShell.
    ms.date: 07/03/2023
    title: Running Remote Commands
    ---
# Running Remote Commands

You can run commands on one or hundreds of computers with a single PowerShell command. Windows
PowerShell supports remote computing using various technologies, including WMI, RPC, and
WS-Management.

PowerShell supports WMI, WS-Management, and SSH remoting. In PowerShell 7 and higher, RPC is
supported only on Windows.

For more information about remoting in PowerShell, see the following articles:

- [SSH Remoting in PowerShell][09]
- [WSMan Remoting in PowerShell][10]

## Windows PowerShell remoting without configuration

Many Windows PowerShell cmdlets have the **ComputerName** parameter that enables you to collect data
and change settings on one or more remote computers. These cmdlets use varying communication
protocols and work on all Windows operating systems without any special configuration.

These cmdlets include:

- [Restart-Computer][23]
- [Test-Connection][25]
- [Clear-EventLog][17]
- [Get-EventLog][18]
- [Get-HotFix][19]
- [Get-Process][20]
- [Get-Service][21]
- [Set-Service][24]
- [Get-WinEvent][16]
- [Get-WmiObject][22]

Typically, cmdlets that support remoting without special configuration have the **ComputerName**
parameter and don't have the **Session** parameter. To find these cmdlets in your session, type:

```powershell
Get-Command | Where-Object {
    $_.Parameters.Keys -contains "ComputerName" -and
    $_.Parameters.Keys -notcontains "Session"
}
```

## Windows PowerShell remoting

Using the WS-Management protocol, Windows PowerShell remoting lets you run any Windows PowerShell
command on one or more remote computers. You can establish persistent connections, start interactive
sessions, and run scripts on remote computers.

To use Windows PowerShell remoting, the remote computer must be configured for remote management.
For more information, including instructions, see [About Remote Requirements][04].

Once you have configured Windows PowerShell remoting, many remoting strategies are available to you.
This article lists just a few of them. For more information, see [About Remote][02].

### Start an interactive session

To start an interactive session with a single remote computer, use the [Enter-PSSession][11] cmdlet.
For example, to start an interactive session with the Server01 remote computer, type:

```powershell
Enter-PSSession Server01
```

The command prompt changes to display the name of the remote computer. Any commands that you type at
the prompt run on the remote computer and the results are displayed on the local computer.

To end the interactive session, type:

```powershell
Exit-PSSession
```

For more information about the `Enter-PSSession` and `Exit-PSSession` cmdlets, see:

- [Enter-PSSession][11]
- [Exit-PSSession][12]

### Run a Remote Command

To run a command on one or more computers, use the [Invoke-Command][13] cmdlet. For example, to run
a [Get-UICulture][27] command on the Server01 and Server02 remote computers, type:

```powershell
Invoke-Command -ComputerName Server01, Server02 -ScriptBlock {Get-UICulture}
```

The output is returned to your computer.

```output
LCID    Name     DisplayName               PSComputerName
----    ----     -----------               --------------
1033    en-US    English (United States)   server01.corp.fabrikam.com
1033    en-US    English (United States)   server02.corp.fabrikam.com
```

### Run a Script

To run a script on one or many remote computers, use the **FilePath** parameter of the
`Invoke-Command` cmdlet. The script must be on or accessible to your local computer. The results are
returned to your local computer.

For example, the following command runs the `DiskCollect.ps1` script on the remote computers,
Server01 and Server02.

```powershell
Invoke-Command -ComputerName Server01, Server02 -FilePath c:\Scripts\DiskCollect.ps1
```

### Establish a Persistent Connection

Use the `New-PSSession` cmdlet to create a persistent session on a remote computer. The following
example creates remote sessions on Server01 and Server02. The session objects are stored in the `$s`
variable.

```powershell
$s = New-PSSession -ComputerName Server01, Server02
```

Now that the sessions are established, you can run any command in them. And because the sessions are
persistent, you can collect data from one command and use it in another command.

For example, the following command runs a `Get-HotFix` command in the sessions in the `$s` variable
and it saves the results in the `$h` variable. The `$h` variable is created in each of the sessions
in `$s`, but it doesn't exist in the local session.

```powershell
Invoke-Command -Session $s {$h = Get-HotFix}
```

Now you can use the data in the `$h` variable with other commands in the same session. The results
are displayed on the local computer. For example:

```powershell
Invoke-Command -Session $s {$h | where {$_.InstalledBy -ne "NT AUTHORITY\SYSTEM"}}
```

### Advanced Remoting

PowerShell includes cmdlets that allow you to:

- Configure and create remote sessions both from the local and remote ends
- Create customized and restricted sessions
- Import commands from a remote session that actually run implicitly on the remote session
- Configure the security of a remote session

PowerShell on Windows includes a WSMan provider. The provider creates a `WSMAN:` drive that lets you
navigate through a hierarchy of configuration settings on the local computer and remote computers.

For more information about the WSMan provider, see [WSMan Provider][07] and
[About WS-Management Cmdlets][06], or in the Windows PowerShell console, type `Get-Help wsman`.

For more information, see:

- [PowerShell Remoting FAQ][08]
- [Register-PSSessionConfiguration][15]
- [Import-PSSession][26]

For help with remoting errors, see [about_Remote_Troubleshooting][05].

## See Also

- [about_Remote][03]
- [about_Remote_Requirements][04]
- [about_Remote_Troubleshooting][05]
- [about_PSSessions][01]
- [about_WS-Management_Cmdlets][06]
- [Invoke-Command][13]
- [Import-PSSession][26]
- [New-PSSession][14]
- [Register-PSSessionConfiguration][15]
- [WSMan Provider][07]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_PSSessions
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote_faq
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_remote_requirements
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_Remote_Troubleshooting
[06]: https://learn.microsoft.com/powershell/module/microsoft.wsman.management/about/about_ws-management_cmdlets
[07]: https://learn.microsoft.com/powershell/module/microsoft.wsman.management/about/about_wsman_provider
[08]: powershell-remoting-faq.yml
[09]: ssh-remoting-in-powershell.md
[10]: wsman-remoting-in-powershell.md
[11]: xref:Microsoft.PowerShell.Core.Enter-PSSession
[12]: xref:Microsoft.PowerShell.Core.Exit-PSSession
[13]: xref:Microsoft.PowerShell.Core.Invoke-Command
[14]: xref:Microsoft.PowerShell.Core.New-PSSession
[15]: xref:Microsoft.PowerShell.Core.Register-PSSessionConfiguration
[16]: xref:Microsoft.PowerShell.Diagnostics.Get-WinEvent
[17]: xref:Microsoft.PowerShell.Management.Clear-EventLog
[18]: xref:Microsoft.PowerShell.Management.Get-EventLog
[19]: xref:Microsoft.PowerShell.Management.Get-HotFix
[20]: xref:Microsoft.PowerShell.Management.Get-Process
[21]: xref:Microsoft.PowerShell.Management.Get-Service
[22]: xref:Microsoft.PowerShell.Management.Get-WmiObject
[23]: xref:Microsoft.PowerShell.Management.Restart-Computer
[24]: xref:Microsoft.PowerShell.Management.Set-Service
[25]: xref:Microsoft.PowerShell.Management.Test-Connection
[26]: xref:Microsoft.PowerShell.Utility.Import-PSSession
[27]: xref:Microsoft.PowerShell.Utility.Get-UICulture

# /./reference/security/remoting/ssh-remoting-in-powershell.md

    ---
    description: Explains how to set up the SSH protocol for PowerShell remoting.
    ms.date: 11/06/2023
    title: PowerShell Remoting Over SSH
    ---

# PowerShell remoting over SSH

## Overview

PowerShell remoting normally uses WinRM for connection negotiation and data transport. SSH is now
available for Linux and Windows platforms and allows true multiplatform PowerShell remoting.

WinRM provides a robust hosting model for PowerShell remote sessions. SSH-based remoting doesn't
currently support remote endpoint configuration and Just Enough Administration (JEA).

SSH remoting lets you do basic PowerShell session remoting between Windows and Linux computers. SSH
remoting creates a PowerShell host process on the target computer as an SSH subsystem. Eventually
we'll implement a general hosting model, similar to WinRM, to support endpoint configuration and
JEA.

The `New-PSSession`, `Enter-PSSession`, and `Invoke-Command` cmdlets now have a new parameter set to
support this new remoting connection.

```
[-HostName <string>]  [-UserName <string>]  [-KeyFilePath <string>]
```

To create a remote session, you specify the target computer with the **HostName** parameter and
provide the user name with **UserName**. When running the cmdlets interactively, you're prompted for
a password. You can also use SSH key authentication using a private key file with the
**KeyFilePath** parameter. Creating keys for SSH authentication varies by platform.

## General setup information

PowerShell 6 or higher, and SSH must be installed on all computers. Install both the SSH client
(`ssh.exe`) and server (`sshd.exe`) so that you can remote to and from the computers. OpenSSH for
Windows is now available in Windows 10 build 1809 and Windows Server 2019. For more information, see
[Manage Windows with OpenSSH][06]. For Linux, install SSH, including sshd server, that's appropriate
for your platform. You also need to install PowerShell from GitHub to get the SSH remoting feature.
The SSH server must be configured to create an SSH subsystem to host a PowerShell process on the
remote computer. And, you must enable **password** or **key-based** authentication.

## Install the SSH service on a Windows computer

1. Install the latest version of PowerShell. For more information, see
   [Installing PowerShell on Windows][03].

   You can confirm that PowerShell has SSH remoting support by listing the `New-PSSession` parameter
   sets. You'll notice there are parameter set names that begin with **SSH**. Those parameter sets
   include **SSH** parameters.

   ```powershell
   (Get-Command New-PSSession).ParameterSets.Name
   ```

   ```Output
   Name
   ----
   SSHHost
   SSHHostHashParam
   ```

1. Install the latest Win32 OpenSSH. For installation instructions, see
   [Getting started with OpenSSH][04].

   > [!NOTE]
   > If you want to set PowerShell as the default shell for OpenSSH, see
   > [Configuring Windows for OpenSSH][07].

1. Edit the `sshd_config` file located at `$env:ProgramData\ssh`.

   Make sure password authentication is enabled:

   ```
   PasswordAuthentication yes
   ```

   Create the SSH subsystem that hosts a PowerShell process on the remote computer:

   ```
   Subsystem powershell c:/progra~1/powershell/7/pwsh.exe -sshs -nologo
   ```

   > [!NOTE]
   > Starting in PowerShell 7.4, you no longer need to use the `-nologo` parameter when running
   > PowerShell in SSH server mode.

   > [!NOTE]
   > The default location of the PowerShell executable is `c:/progra~1/powershell/7/pwsh.exe`. The
   > location can vary depending on how you installed PowerShell.
   >
   > You must use the 8.3 short name for any file paths that contain spaces. There's a bug in
   > OpenSSH for Windows that prevents spaces from working in subsystem executable paths. For more
   > information, see this [GitHub issue][09].
   >
   > The 8.3 short name for the `Program Files` folder in Windows is usually `Progra~1`. However,
   > you can use the following command to make sure:
   >
   > ```powershell
   > Get-CimInstance Win32_Directory -Filter 'Name="C:\\Program Files"' |
   >   Select-Object EightDotThreeFileName
   > ```
   >
   > ```Output
   > EightDotThreeFileName
   > ---------------------
   > c:\progra~1
   > ```

   Optionally, enable key authentication:

   ```
   PubkeyAuthentication yes
   ```

   For more information, see [Managing OpenSSH Keys][05].

1. Restart the **sshd** service.

   ```powershell
   Restart-Service sshd
   ```

1. Add the path where OpenSSH is installed to your Path environment variable. For example,
   `C:\Program Files\OpenSSH\`. This entry allows for the `ssh.exe` to be found.

## Install the SSH service on an Ubuntu Linux computer

1. Install the latest version of PowerShell, see [Installing PowerShell on Ubuntu][01].
1. Install [Ubuntu OpenSSH Server][10].

   ```bash
   sudo apt install openssh-client
   sudo apt install openssh-server
   ```

1. Edit the `sshd_config` file at location `/etc/ssh`.

   Make sure password authentication is enabled:

   ```
   PasswordAuthentication yes
   ```

   Optionally, enable key authentication:

   ```
   PubkeyAuthentication yes
   ```

   For more information about creating SSH keys on Ubuntu, see the manpage for
   [ssh-keygen][08].

   Add a PowerShell subsystem entry:

   ```
   Subsystem powershell /usr/bin/pwsh -sshs -nologo
   ```

   > [!NOTE]
   > The default location of the PowerShell executable is `/usr/bin/pwsh`. The location can vary
   > depending on how you installed PowerShell.

   > [!NOTE]
   > Starting in PowerShell 7.4, you no longer need to use the `-nologo` parameter when running
   > PowerShell in SSH server mode.

1. Restart the **ssh** service.

   ```bash
   sudo systemctl restart sshd.service
   ```

## Install the SSH service on a macOS computer

1. Install the latest version of PowerShell. For more information,
   [Installing PowerShell on macOS][02].

   Make sure SSH Remoting is enabled by following these steps:

   1. Open `System Settings`.
   1. Click on `General`
   1. Click on `Sharing`.
   1. Check `Remote Login` to set `Remote Login: On`.
   1. Allow access to the appropriate users.

1. Edit the `sshd_config` file at location `/private/etc/ssh/sshd_config`.

   Use a text editor such as **nano**:

   ```bash
   sudo nano /private/etc/ssh/sshd_config
   ```

   Make sure password authentication is enabled:

   ```
   PasswordAuthentication yes
   ```

   Add a PowerShell subsystem entry:

   ```
   Subsystem powershell /usr/local/bin/pwsh -sshs -nologo
   ```

   > [!NOTE]
   > The default location of the PowerShell executable is `/usr/local/bin/pwsh`. The location can
   > vary depending on how you installed PowerShell.

   > [!NOTE]
   > Starting in PowerShell 7.4, you no longer need to use the `-nologo` parameter when running
   > PowerShell in SSH server mode.

   Optionally, enable key authentication:

   ```
   PubkeyAuthentication yes
   ```

1. Restart the **sshd** service.

   ```bash
   sudo launchctl stop com.openssh.sshd
   sudo launchctl start com.openssh.sshd
   ```

> [!NOTE]
> When you upgrade your operating system, the SSH configuration file might be overwritten. Make sure
> you check the configuration file after an upgrade.

## Authentication

PowerShell remoting over SSH relies on the authentication exchange between the SSH client and SSH
service and doesn't implement any authentication schemes itself. The result is that any configured
authentication schemes including multi-factor authentication are handled by SSH and independent of
PowerShell. For example, you can configure the SSH service to require public key authentication and
a one-time password for added security. Configuration of multi-factor authentication is outside the
scope of this documentation. Refer to documentation for SSH on how to correctly configure
multi-factor authentication and validate it works outside of PowerShell before attempting to use it
with PowerShell remoting.

> [!NOTE]
> Users retain the same privileges in remote sessions. Meaning, Administrators have access to an
> elevated shell, and normal users do not.

## PowerShell remoting example

The easiest way to test remoting is to try it on a single computer. In this example, we create a
remote session back to the same Linux computer. We're using PowerShell cmdlets interactively so we
see prompts from SSH asking to verify the host computer and prompting for a password. You can do the
same thing on a Windows computer to ensure remoting is working. Then, remote between computers by
changing the host name.

### Linux to Linux

```powershell
$session = New-PSSession -HostName UbuntuVM1 -UserName TestUser
```

```Output
The authenticity of host 'UbuntuVM1 (9.129.17.107)' can't be established.
ECDSA key fingerprint is SHA256:2kCbnhT2dUE6WCGgVJ8Hyfu1z2wE4lifaJXLO7QJy0Y.
Are you sure you want to continue connecting (yes/no)?
TestUser@UbuntuVM1s password:
```

```powershell
$session
```

```Output
 Id Name   ComputerName    ComputerType    State    ConfigurationName     Availability
 -- ----   ------------    ------------    -----    -----------------     ------------
  1 SSH1   UbuntuVM1       RemoteMachine   Opened   DefaultShell             Available
```

```powershell
Enter-PSSession $session
```

```Output
[UbuntuVM1]: PS /home/TestUser> uname -a
Linux TestUser-UbuntuVM1 4.2.0-42-generic 49~16.04.1-Ubuntu SMP Wed Jun 29 20:22:11 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux

[UbuntuVM1]: PS /home/TestUser> Exit-PSSession
```

```powershell
Invoke-Command $session -ScriptBlock { Get-Process pwsh }
```

```Output
Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName    PSComputerName
-------  ------    -----      -----     ------     --  -- -----------    --------------
      0       0        0         19       3.23  10635 635 pwsh           UbuntuVM1
      0       0        0         21       4.92  11033 017 pwsh           UbuntuVM1
      0       0        0         20       3.07  11076 076 pwsh           UbuntuVM1
```

### Linux to Windows

```powershell
Enter-PSSession -HostName WinVM1 -UserName PTestName
```

```
PTestName@WinVM1s password:
```

```powershell
[WinVM1]: PS C:\Users\PTestName\Documents> cmd /c ver
```

```Output
Microsoft Windows [Version 10.0.10586]
```

### Windows to Windows

```powershell
C:\Users\PSUser\Documents>pwsh.exe
```

```Output
PowerShell
Copyright (c) Microsoft Corporation. All rights reserved.
```

```powershell
$session = New-PSSession -HostName WinVM2 -UserName PSRemoteUser
```

```Output
The authenticity of host 'WinVM2 (10.13.37.3)' can't be established.
ECDSA key fingerprint is SHA256:kSU6slAROyQVMEynVIXAdxSiZpwDBigpAF/TXjjWjmw.
Are you sure you want to continue connecting (yes/no)?
Warning: Permanently added 'WinVM2,10.13.37.3' (ECDSA) to the list of known hosts.
PSRemoteUser@WinVM2's password:
```

```powershell
$session
```

```Output
 Id Name            ComputerName    ComputerType    State         ConfigurationName     Availability
 -- ----            ------------    ------------    -----         -----------------     ------------
  1 SSH1            WinVM2          RemoteMachine   Opened        DefaultShell             Available
```

```powershell
Enter-PSSession -Session $session
```

```Output
[WinVM2]: PS C:\Users\PSRemoteUser\Documents> $PSVersionTable

Name                           Value
----                           -----
PSEdition                      Core
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}
SerializationVersion           1.1.0.1
BuildVersion                   3.0.0.0
CLRVersion
PSVersion                      6.0.0-alpha
WSManStackVersion              3.0
PSRemotingProtocolVersion      2.3
GitCommitId                    v6.0.0-alpha.17


[WinVM2]: PS C:\Users\PSRemoteUser\Documents>
```

### Limitations

- The **sudo** command doesn't work in a remote session to a Linux computer.

- PSRemoting over SSH doesn't support Profiles and doesn't have access to `$PROFILE`. Once in a
  session, you can load a profile by dot sourcing the profile with the full filepath. This isn't
  related to SSH profiles. You can configure the SSH server to use PowerShell as the default shell
  and to load a profile through SSH. See the SSH documentation for more information.

- Prior to PowerShell 7.1, remoting over SSH didn't support second-hop remote sessions. This
  capability was limited to sessions using WinRM. PowerShell 7.1 allows `Enter-PSSession` and
  `Enter-PSHostProcess` to work from within any interactive remote session.

## See also

- [Installing PowerShell on Linux][01]
- [Installing PowerShell on macOS][02]
- [Installing PowerShell on Windows][03]
- [Manage Windows with OpenSSH][06]
- [Managing OpenSSH Keys][05]
- [Ubuntu SSH][10]

<!-- link references -->
[01]: ../../install/install-ubuntu.md
[02]: ../../install/installing-powershell-on-macos.md
[03]: ../../install/installing-powershell-on-windows.md#msi
[04]: https://learn.microsoft.com/windows-server/administration/openssh/openssh_install_firstuse
[05]: https://learn.microsoft.com/windows-server/administration/openssh/openssh_keymanagement
[06]: https://learn.microsoft.com/windows-server/administration/openssh/openssh_overview
[07]: https://learn.microsoft.com/windows-server/administration/openssh/openssh_server_configuration
[08]: http://manpages.ubuntu.com/manpages/xenial/man1/ssh-keygen.1.html
[09]: https://github.com/PowerShell/Win32-OpenSSH/issues/784
[10]: https://ubuntu.com/server/docs/service-openssh

# /./reference/security/remoting/wsman-remoting-in-powershell.md

    ---
    description: Remoting in PowerShell using WSMan
    ms.date: 10/03/2023
    title: Using WS-Management (WSMan) Remoting in PowerShell
    ---
# Using WS-Management (WSMan) Remoting in PowerShell

## Enabling PowerShell remoting

To enable PowerShell remoting run the `Enable-PSRemoting` cmdlet in an elevated PowerShell session.
Running `Enable-PSRemoting` configures a remoting endpoint for the specific installation version
that you are running the cmdlet in. For example, when you run `Enable-PSRemoting` while running
PowerShell 7.3, PowerShell creates a remoting endpoint runs PowerShell 7.3. If you run
`Enable-PSRemoting` while running PowerShell 7-preview, PowerShell creates a remoting endpoint that
runs PowerShell 7-preview. You can create multiple remoting endpoints for different versions of that
run side-by-side.

Running `Enable-PSRemoting` creates two endpoints for that version.

- One has a simple name corresponding to the PowerShell major version. that hosts the session. For
  example, **PowerShell.7.3**.
- The other configuration name contains the full version number. For example, **PowerShell.7.3.7**.

You can connect to the latest version of PowerShell 7 host version using the simple name,
**PowerShell.7.3**. You can connect to a specific version of PowerShell using the longer,
version-specific name.

Use the **ConfigurationName** parameter with the `New-PSSession` and `Enter-PSSession` cmdlets to
connect to a named configuration.

## WSMan remoting isn't supported on non-Windows platforms

Since the release of PowerShell 6, support for remoting over WS-Management (WSMan) on non-Windows
platforms has only been available to a limited set of Linux distributions. All versions of those
distributions that supported WSMan are no longer supported by the Linux vendors that created them.

On non-Windows, WSMan relied on the [Open Management Infrastructure (OMI)][01] project, which no
longer supports PowerShell remoting. The OMI WSMan client is dependent on **OpenSSL 1.0**. Most
Linux distributions have moved to **OpenSSL 2.0**, which isn't backward-compatible. At this time,
there is no supported distribution that has the dependencies needed for the OMI WSMan client to
work.

The outdated libraries and supporting code have been removed for non-Windows platforms. WSMan-based
remoting is still supported between Windows systems. Remoting over SSH is supported for all
platforms. For more information, see [PowerShell remoting over SSH][03].

> [!NOTE]
> Users may be able to get WSMan remoting to work using the [PSWSMan][02] module. This module isn't
> supported or maintained by Microsoft.

## Further reading

- [Enable-PSRemoting][04]
- [Enter-PSSession][05]
- [New-PSSession][06]

<!-- link references -->
[01]: https://github.com/Microsoft/omi
[02]: https://www.powershellgallery.com/packages/PSWSMan
[03]: SSH-Remoting-in-PowerShell.md
[04]: xref:Microsoft.PowerShell.Core.Enable-PSRemoting
[05]: xref:Microsoft.PowerShell.Core.Enter-PSSession
[06]: xref:Microsoft.PowerShell.Core.New-PSSession

# /./reference/security/remoting/winrm-security.md

    ---
    description: This document covers security concerns, recommendations, and best practices when using PowerShell Remoting.
    ms.date: 10/23/2023
    title: Security considerations for PowerShell Remoting using WinRM
    ---

# Security Considerations for PowerShell Remoting using WinRM

PowerShell Remoting is the recommended way to manage Windows systems. PowerShell Remoting is enabled
by default in Windows Server 2012 R2 and higher. This document covers security concerns,
recommendations, and best practices when using PowerShell Remoting.

## What is PowerShell Remoting?

PowerShell Remoting uses [Windows Remote Management (WinRM)][04] to allow users to run PowerShell
commands on remote computers. WinRM is the Microsoft implementation of the
[Web Services for Management (WS-Management)][05] protocol. You can find more information about
using PowerShell Remoting at [Running Remote Commands][08].

PowerShell Remoting isn't the same as using the **ComputerName** parameter of a cmdlet to run it on
a remote computer, which uses Remote Procedure Call (RPC) as its underlying protocol.

## PowerShell Remoting default settings

PowerShell Remoting (and WinRM) listen on the following ports:

- HTTP: 5985
- HTTPS: 5986

By default, PowerShell Remoting only allows connections from members of the Administrators group.
Sessions are launched under the user's context, so all operating system access controls applied to
individual users and groups continue to apply to them while connected over PowerShell Remoting.

On private networks, the default Windows Firewall rule for PowerShell Remoting accepts all
connections. On public networks, the default Windows Firewall rule allows PowerShell Remoting
connections only from within the same subnet. You have to explicitly change that rule to open
PowerShell Remoting to all connections on a public network.

> [!Warning]
> The firewall rule for public networks is meant to protect the computer from potentially malicious
> external connection attempts. Use caution when removing this rule.

## Process isolation

PowerShell Remoting uses WinRM for communication between computers. WinRM runs as a service under
the Network Service account, and spawns isolated processes running as user accounts to host
PowerShell instances. An instance of PowerShell running as one user has no access to a process
running an instance of PowerShell as another user.

## Event logs generated by PowerShell Remoting

FireEye has provided a good summary of the event logs and other security evidence generated by
PowerShell Remoting sessions, available at [Investigating PowerShell Attacks][06].

## Encryption and transport protocols

It's helpful to consider the security of a PowerShell Remoting connection from two perspectives:
initial authentication, and ongoing communication.

Regardless of the transport protocol used (HTTP or HTTPS), WinRM always encrypts all PowerShell
remoting communication after initial authentication.

### Initial authentication

Authentication confirms the identity of the client to the server - and ideally - the server to the
client.

When a client connects to a domain server using its computer name, the default authentication
protocol is [Kerberos][02]. Kerberos guarantees both the user identity and server identity without
sending any sort of reusable credential.

When a client connects to a domain server using its IP address, or connects to a workgroup server,
Kerberos authentication isn't possible. In that case, PowerShell Remoting relies on the
[NTLM authentication protocol][03]. The NTLM authentication protocol guarantees the user identity
without sending any sort of delegable credential. To prove user identity, the NTLM protocol requires
that both the client and server compute a session key from the user's password without ever
exchanging the password itself. The server typically doesn't know the user's password, so it
communicates with the domain controller, which does know the user's password and calculates the
session key for the server.

The NTLM protocol doesn't, however, guarantee server identity. As with all protocols that use NTLM
for authentication, an attacker with access to a domain-joined computer's machine account could
invoke the domain controller to compute an NTLM session-key and thereby impersonate the server.

NTLM-based authentication is disabled by default, but may be permitted by either configuring SSL on
the target server, or by configuring the WinRM TrustedHosts setting on the client.

#### Using SSL certificates to validate server identity during NTLM-based connections

Since the NTLM authentication protocol can't ensure the identity of the target server (only that it
already knows your password), you can configure target servers to use SSL for PowerShell Remoting.
Assigning a SSL certificate to the target server (if issued by a Certificate Authority that the
client also trusts) enables NTLM-based authentication that guarantees both the user identity and
server identity.

#### Ignoring NTLM-based server identity errors

If deploying a SSL certificate to a server for NTLM connections is infeasible, you may suppress the
resulting identity errors by adding the server to the WinRM **TrustedHosts** list. Please note that
adding a server name to the **TrustedHosts** list shouldn't be considered as any form of statement
of the trustworthiness of the hosts themselves - as the NTLM authentication protocol can't
guarantee that you are in fact connecting to the host you are intending to connect to. Instead, you
should consider the TrustedHosts setting to be the list of hosts for which you wish to suppress the
error generated by being unable to verify the server's identity.

### Ongoing Communication

Once initial authentication is complete, the WinRM encrypts the ongoing communication. When
connecting over HTTPS, the TLS protocol is used to negotiate the encryption used to transport data.
When connecting over HTTP, message-level encryption is determined by initial authentication protocol
used.

- Basic authentication provide no encryption.
- NTLM authentication uses an RC4 cipher with a 128-bit key.
- Kerberos authentication encryption is determined by the `etype` in the TGS ticket. This is AES-256
  on modern systems.
- CredSSP encryption is uses the TLS cipher suite that was negotiated in the handshake.

## Making the second hop

By default, PowerShell Remoting uses Kerberos (if available) or NTLM for authentication. Both of
these protocols authenticate to the remote machine without sending credentials to it. This is the
most secure way to authenticate, but because the remote machine doesn't have the user's credentials,
it can't access other computers and services on the user's behalf. This is known as the "second hop
problem".

There are several ways to avoid this problem. For descriptions of these methods, and the pros and
cons of each, see [Making the second hop in PowerShell Remoting][07].

## References

- [Windows Remote Management (WinRM)][04]
- [Web Services for Management (WS-Management)][05]
- [2.2.9.1 Encrypted Message Types][01]
- [Kerberos][02]
- [NTLM authentication protocol][03]
- [Investigating PowerShell Attacks][06]

<!-- link references -->
[01]: https://learn.microsoft.com/openspecs/windows_protocols/ms-wsmv/58421aa4-861a-4410-831a-c999f094cdb7
[02]: https://learn.microsoft.com/windows/win32/secauthn/microsoft-kerberos
[03]: https://learn.microsoft.com/windows/win32/secauthn/microsoft-ntlm
[04]: https://learn.microsoft.com/windows/win32/winrm/portal
[05]: https://www.dmtf.org/sites/default/files/standards/documents/DSP0226_1.2.0.pdf
[06]: https://www.mandiant.com/resources/investigating-powershell-attacks
[07]: PS-remoting-second-hop.md
[08]: running-remote-commands.md

# /./reference/security/remoting/ps-remoting-second-hop.md

    ---
    description: This article explains the various methods for configuring second-hop authentication for PowerShell remoting, including the security implications and recommendations.
    ms.date: 10/23/2023
    title: Making the second hop in PowerShell Remoting
    ---

# Making the second hop in PowerShell Remoting

The "second hop problem" refers to a situation like the following:

1. You are logged in to _ServerA_.
1. From _ServerA_, you start a remote PowerShell session to connect to _ServerB_.
1. A command you run on _ServerB_ via your PowerShell Remoting session attempts to access a resource
   on _ServerC_.
1. Access to the resource on _ServerC_ is denied, because the credentials you used to create the
   PowerShell Remoting session aren't passed from _ServerB_ to _ServerC_.

There are several ways to address this problem. The following table lists the methods in order of
preference.

|                      Configuration                       |                                  Note                                  |
| -------------------------------------------------------- | ---------------------------------------------------------------------- |
| CredSSP                                                  | Balances ease of use and security                                      |
| Resource-based Kerberos constrained delegation           | Higher security with simpler configuration                             |
| Kerberos constrained delegation                          | High security but requires Domain Administrator                         |
| Kerberos delegation (unconstrained)                      | Not recommended                                                        |
| Just Enough Administration (JEA)                         | Can provide the best security but requires more detailed configuration |
| PSSessionConfiguration using RunAs                       | Simpler to configure but requires credential management                |
| Pass credentials inside an `Invoke-Command` script block | Simplest to use but you must provide credentials                       |

## CredSSP

You can use the [Credential Security Support Provider (CredSSP)][12] for authentication. CredSSP
caches credentials on the remote server (_ServerB_), so using it opens you up to credential theft
attacks. If the remote computer is compromised, the attacker has access to the user's credentials.
CredSSP is disabled by default on both client and server computers. You should enable CredSSP only
in the most trusted environments. For example, a domain administrator connecting to a domain
controller because the domain controller is highly trusted.

For more information about security concerns when using CredSSP for PowerShell Remoting, see
[Accidental Sabotage: Beware of CredSSP][19].

For more information about credential theft attacks, see
[Mitigating Pass-the-Hash (PtH) Attacks and Other Credential Theft][18].

For an example of how to enable and use CredSSP for PowerShell remoting, see
[Enable PowerShell "Second-Hop" Functionality with CredSSP][15].

### Pros

- It works for all servers with Windows Server 2008 or later.

### Cons

- Has security vulnerabilities.
- Requires configuration of both client and server roles.
- doesn't work with the Protected Users group. For more information, see
  [Protected Users Security Group][11].

## Kerberos constrained delegation

You can use legacy constrained delegation (not resource-based) to make the second hop. Configure
Kerberos constrained delegation with the option "Use any authentication protocol" to allow protocol
transition.

### Pros

- Requires no special coding
- Credentials aren't stored.

### Cons

- Doesn't support the second hop for WinRM.
- Requires Domain Administrator access to configure.
- Must be configured on the Active Directory object of the remote server (_ServerB_).
- Limited to one domain. Can't cross domains or forests.
- Requires rights to update objects and Service Principal Names (SPNs).
- _ServerB_ can acquire a Kerberos ticket to _ServerC_ on behalf of the user without user
  intervention.

> [!NOTE]
> Active Directory accounts that have the **Account is sensitive and can't be delegated** property
> set can't be delegated. For more information, see
> [Security Focus: Analysing 'Account is sensitive and can't be delegated' for Privileged Accounts][01]
> and [Kerberos Authentication Tools and Settings][09].

## Resource-based Kerberos constrained delegation

Using resource-based Kerberos constrained delegation (introduced in Windows Server 2012), you
configure credential delegation on the server object where resources reside. In the second hop
scenario described above, you configure _ServerC_ to specify from where it accepts delegated
credentials.

### Pros

- Credentials aren't stored.
- Configured using PowerShell cmdlets. No special coding required.
- Doesn't require Domain Administrator access to configure.
- Works across domains and forests.

### Cons

- Requires Windows Server 2012 or later.
- Doesn't support the second hop for WinRM.
- Requires rights to update objects and Service Principal Names (SPNs).

> [!NOTE]
> Active Directory accounts that have the **Account is sensitive and can't be delegated** property
> set can't be delegated. For more information, see
> [Security Focus: Analysing 'Account is sensitive and can't be delegated' for Privileged Accounts][01]
> and [Kerberos Authentication Tools and Settings][09].

### Example

Let's look at a PowerShell example that configures resource-based constrained delegation on
_ServerC_ to allow delegated credentials from a _ServerB_. This example assumes that all servers are
running supported versions of Windows Server, and that there is at least one Windows domain
controller for each trusted domain.

Before you can configure constrained delegation, you must add the `RSAT-AD-PowerShell` feature to
install the Active Directory PowerShell module, and then import that module into your session:

```powershell
Add-WindowsFeature RSAT-AD-PowerShell
Import-Module ActiveDirectory
Get-Command -ParameterName PrincipalsAllowedToDelegateToAccount
```

Several available cmdlets now have a **PrincipalsAllowedToDelegateToAccount** parameter:

```Output
CommandType Name                 ModuleName
----------- ----                 ----------
Cmdlet      New-ADComputer       ActiveDirectory
Cmdlet      New-ADServiceAccount ActiveDirectory
Cmdlet      New-ADUser           ActiveDirectory
Cmdlet      Set-ADComputer       ActiveDirectory
Cmdlet      Set-ADServiceAccount ActiveDirectory
Cmdlet      Set-ADUser           ActiveDirectory
```

The **PrincipalsAllowedToDelegateToAccount** parameter sets the Active Directory object attribute
**msDS-AllowedToActOnBehalfOfOtherIdentity**, which contains an access control list (ACL) that
specifies which accounts have permission to delegate credentials to the associated account (in our
example, it will be the machine account for _ServerA_).

Now let's set up the variables we'll use to represent the servers:

```powershell
# Set up variables for reuse
$ServerA = $env:COMPUTERNAME
$ServerB = Get-ADComputer -Identity ServerB
$ServerC = Get-ADComputer -Identity ServerC
```

WinRM (and therefore PowerShell remoting) runs as the computer account by default. You can see this
by looking at the **StartName** property of the `winrm` service:

```powershell
Get-CimInstance Win32_Service -Filter 'Name="winrm"' | Select-Object StartName
```

```Output
StartName
---------
NT AUTHORITY\NetworkService
```

For _ServerC_ to allow delegation from a PowerShell remoting session on _ServerB_, we must set the
**PrincipalsAllowedToDelegateToAccount** parameter on _ServerC_ to the computer object of _ServerB_:

```powershell
# Grant resource-based Kerberos constrained delegation
Set-ADComputer -Identity $ServerC -PrincipalsAllowedToDelegateToAccount $ServerB

# Check the value of the attribute directly
$x = Get-ADComputer -Identity $ServerC -Properties msDS-AllowedToActOnBehalfOfOtherIdentity
$x.'msDS-AllowedToActOnBehalfOfOtherIdentity'.Access

# Check the value of the attribute indirectly
Get-ADComputer -Identity $ServerC -Properties PrincipalsAllowedToDelegateToAccount
```

The Kerberos [Key Distribution Center (KDC)][13] caches denied-access attempts (negative cache) for
15 minutes. If _ServerB_ has previously attempted to access _ServerC_, you need to clear the
cache on _ServerB_ by invoking the following command:

```powershell
Invoke-Command -ComputerName $ServerB.Name -Credential $cred -ScriptBlock {
    klist purge -li 0x3e7
}
```

You could also restart the computer, or wait at least 15 minutes to clear the cache.

After clearing the cache, you can successfully run code from _ServerA_ through _ServerB_ to
_ServerC_:

```powershell
# Capture a credential
$cred = Get-Credential Contoso\Alice

# Test kerberos double hop
Invoke-Command -ComputerName $ServerB.Name -Credential $cred -ScriptBlock {
    Test-Path \\$($using:ServerC.Name)\C$
    Get-Process lsass -ComputerName $($using:ServerC.Name)
    Get-EventLog -LogName System -Newest 3 -ComputerName $($using:ServerC.Name)
}
```

In this example, the `$using` variable is used to make the `$ServerC` variable visible to _ServerB_.
For more information about the `$using` variable, see [about_Remote_Variables][06].

To allow multiple servers to delegate credentials to _ServerC_, set the value of the
**PrincipalsAllowedToDelegateToAccount** parameter on _ServerC_ to an array:

```powershell
# Set up variables for each server
$ServerB1 = Get-ADComputer -Identity ServerB1
$ServerB2 = Get-ADComputer -Identity ServerB2
$ServerB3 = Get-ADComputer -Identity ServerB3
$ServerC  = Get-ADComputer -Identity ServerC

$servers = @(
    $ServerB1,
    $ServerB2,
    $ServerB3
)

# Grant resource-based Kerberos constrained delegation
Set-ADComputer -Identity $ServerC -PrincipalsAllowedToDelegateToAccount $servers
```

If you want to make the second hop across domains, use the **Server** parameter to specify
fully-qualified domain name (FQDN) of the domain controller of the domain to which _ServerB_
belongs:

```powershell
# For ServerC in Contoso domain and ServerB in other domain
$ServerB = Get-ADComputer -Identity ServerB -Server dc1.alpineskihouse.com
$ServerC = Get-ADComputer -Identity ServerC
Set-ADComputer -Identity $ServerC -PrincipalsAllowedToDelegateToAccount $ServerB
```

To remove the ability to delegate credentials to ServerC, set the value of the
**PrincipalsAllowedToDelegateToAccount** parameter on _ServerC_ to `$null`:

```powershell
Set-ADComputer -Identity $ServerC -PrincipalsAllowedToDelegateToAccount $null
```

### Information on resource-based Kerberos constrained delegation

- [What's New in Kerberos Authentication][10]
- [How Windows Server 2012 Eases the Pain of Kerberos Constrained Delegation, Part 1][16]
- [How Windows Server 2012 Eases the Pain of Kerberos Constrained Delegation, Part 2][17]
- [Understanding Kerberos Constrained Delegation for Microsoft Entra application proxy deployments with Integrated Windows Authentication][14]
- [[MS-ADA2] Active Directory Schema Attributes M2.210 Attribute msDS-AllowedToActOnBehalfOfOtherIdentity][MS-ADA2]
- [[MS-SFU] Kerberos Protocol Extensions: Service for User and Constrained Delegation Protocol 1.3.2 S4U2proxy][MS-SFU]
- [Remote Administration Without Constrained Delegation Using PrincipalsAllowedToDelegateToAccount][03]

## Kerberos delegation (unconstrained)

You can also use Kerberos unconstrained delegation to make the second hop. Like all Kerberos
scenarios, credentials aren't stored. This method doesn't support the second hop for WinRM.

> [!WARNING]
> This method provides no control of where delegated credentials are used. It's less secure than
> CredSSP. This method should only be used for testing scenarios.

## Just Enough Administration (JEA)

JEA allows you to restrict what commands an administrator can run during a PowerShell session. It
can be used to solve the second hop problem.

For information about JEA, see [Just Enough Administration][08].

### Pros

- No password maintenance when using a virtual account.

### Cons

- Requires WMF 5.0 or later.
- Requires configuration on every intermediate server (_ServerB_).

## PSSessionConfiguration using RunAs

You can create a session configuration on _ServerB_ and set its **RunAsCredential** parameter.

For information about using **PSSessionConfiguration** and **RunAs** to solve the second hop
problem, see [Another solution to multi-hop PowerShell remoting][02].

### Pros

- Works with any server with WMF 3.0 or later.

### Cons

- Requires configuration of **PSSessionConfiguration** and **RunAs** on every intermediate server
  (_ServerB_).
- Requires password maintenance when using a domain **RunAs** account

## Pass credentials inside an Invoke-Command script block

You can pass credentials inside the **ScriptBlock** parameter of a call to the
[Invoke-Command][07] cmdlet.

### Pros

- Doesn't require special server configuration.
- Works on any server running WMF 2.0 or later.

### Cons

- Requires an awkward code technique.
- If running WMF 2.0, requires different syntax for passing arguments to a remote session.

### Example

The following example shows how to pass credentials in a script block:

```powershell
# This works without delegation, passing fresh creds
# Note $Using:Cred in nested request
$cred = Get-Credential Contoso\Administrator
Invoke-Command -ComputerName ServerB -Credential $cred -ScriptBlock {
    hostname
    Invoke-Command -ComputerName ServerC -Credential $Using:cred -ScriptBlock {hostname}
}
```

## See also

[PowerShell Remoting Security Considerations][20]

<!-- link references -->
[01]: https://learn.microsoft.com/archive/blogs/poshchap/security-focus-analysing-account-is-sensitive-and-cannot-be-delegated-for-privileged-accounts
[02]: https://learn.microsoft.com/archive/blogs/sergey_babkins_blog/another-solution-to-multi-hop-powershell-remoting
[03]: https://learn.microsoft.com/archive/blogs/taylorb/remote-administration-without-constrained-delegation-using-principalsallowedtodelegatetoaccount
[06]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Core/About/about_Remote_Variables
[07]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/invoke-command
[08]: https://learn.microsoft.com/powershell/scripting/learn/remoting/jea/overview
[09]: https://learn.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc738673(v=ws.10)
[10]: https://learn.microsoft.com/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/hh831747(v=ws.11)
[11]: https://learn.microsoft.com/windows-server/security/credentials-protection-and-management/protected-users-security-group
[12]: https://learn.microsoft.com/windows/win32/secauthn/credential-security-support-provider
[13]: https://learn.microsoft.com/windows/win32/secauthn/key-distribution-center
[14]: https://aka.ms/kcdpaper
[15]: https://devblogs.microsoft.com/scripting/enable-powershell-second-hop-functionality-with-credssp/
[16]: https://www.itprotoday.com/windows-server/how-windows-server-2012-eases-pain-kerberos-constrained-delegation-part-1
[17]: https://www.itprotoday.com/windows-server/how-windows-server-2012-eases-pain-kerberos-constrained-delegation-part-2
[18]: https://www.microsoft.com/download/details.aspx?id=36036
[19]: https://www.powershellmagazine.com/2014/03/06/accidental-sabotage-beware-of-credssp
[20]: winrm-security.md
[MS-ADA2]: https://learn.microsoft.com/openspecs/windows_protocols/ms-ada2/cea4ac11-a4b2-4f2d-84cc-aebb4a4ad405
[MS-SFU]: https://learn.microsoft.com/openspecs/windows_protocols/ms-sfu/bde93b0e-f3c9-4ddf-9f44-e1453be7af5a

# /./reference/dsc/overview.md

    ---
    description: DSC is a management platform in PowerShell that enables you to manage your IT and development infrastructure with configuration as code.
    ms.date: 02/02/2023
    title: PowerShell Desired State Configuration (DSC)
    ---

# PowerShell Desired State Configuration (DSC) Overview

DSC is a management platform in PowerShell that enables you to manage your IT and development
infrastructure with configuration as code.

There are three versions of DSC available:

- DSC 1.1 is the legacy version of DSC that originally shipped in Windows PowerShell 5.1.
- DSC 2.0 is the version of DSC that shipped in PowerShell 7.

  With the release of PowerShell 7.2, the **PSDesiredStateConfiguration** module is no longer
  included in the PowerShell package. Separating DSC into its own module allows us to invest and
  develop DSC independent of PowerShell and reduces the size of the PowerShell package. Users of DSC
  will enjoy the benefit of upgrading DSC without the need to upgrade PowerShell, accelerating time
  to deployment of new DSC features. Users that want to continue using DSC v2 can download
  **PSDesiredStateConfiguration** 2.0.5 from the PowerShell Gallery.
- DSC 3.0 is the new version of DSC. This version is a preview release that is still being
  developed. Users working with non-Windows environments can expect cross-platform features in DSC
  3.0. DSC 3.0 is the version that is supported by the [machine configuration][01] feature of Azure
  Automanage.

The documentation for DSC has been moved to a new location so that we can manage the DSC
version-specific information separate from the versions of PowerShell.

See the new documentation in [Desired State Configuration 2.0][02].

[01]: https://learn.microsoft.com/azure/governance/machine-configuration/overview
[02]: https://learn.microsoft.com/powershell/dsc/overview

# /./reference/gallery/overview.md

    ---
    description: The PowerShellGet module provides commands to interact with the PowerShell Gallery, the central repository for PowerShell modules, scripts, and DSC resources.
    ms.date: 04/12/2023
    title: The PowerShell Gallery
    ---

# The PowerShell Gallery

The [PowerShell Gallery][02] is the central repository for PowerShell content. In it, you can find
PowerShell scripts, modules containing PowerShell cmdlets and Desired State Configuration (DSC)
resources. Some of these packages are authored by Microsoft, and others are authored by the
PowerShell community.

The **PowerShellGet** module contains cmdlets for discovering, installing, updating, and publishing
PowerShell packages from the PowerShell Gallery. These packages can contain artifacts such as
Modules, DSC Resources, Role Capabilities, and Scripts. Make sure you have the latest version of
**PowerShellGet** installed.

The documentation for **PowerShellGet** and the PowerShell Gallery has been moved to a new location
so that we can manage the version-specific information separate from the versions of PowerShell.

See the new documentation in [PowerShellGet and the PowerShell Gallery][01].

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/gallery/overview
[02]: https://www.powershellgallery.com

# /./reference/community/community-support.md

    ---
    description: List of resources created for and by PowerShell users
    ms.date: 11/16/2022
    title: PowerShell community support resources
    ---
# Getting support from the community

The PowerShell Community is a vibrant and active group of users. This article can help you get
connected with other member of the community.

The PowerShell community can file issues, bugs, or feature requests in our
[GitHub](https://github.com/powershell/powershell/issues) repository. If you have questions, you may
find help from other members of the community in one of these public forums:

- [User Groups](https://aka.ms/psusergroup)
- [PowerShell Tech Community](https://techcommunity.microsoft.com/t5/PowerShell/ct-p/WindowsPowerShell)
- [DSC Community](https://dsccommunity.org/)
- [PowerShell.org](https://forums.powershell.org/)
- [StackOverFlow](https://stackoverflow.com/questions/tagged/powershell)
- [r/PowerShell subreddit](https://www.reddit.com/r/PowerShell/)
- PowerShell Virtual User Group - join via:
  - [Slack](https://aka.ms/psslack)
  - [Discord](https://aka.ms/psdiscord)

For information about our support policy, see the
[PowerShell Support Lifecycle](/powershell/scripting/powershell-support-lifecycle).

# /./reference/community/hall-of-fame.md

    ---
    description: List of the GitHub users that have the most contributions to the PowerShell-Doc project.
    ms.date: 04/01/2024
    title: Community contributor Hall of Fame
    ---
# Community Contributor Hall of Fame

The PowerShell Community is a vibrant and collaborative group. We greatly appreciate all the help
and support we get from the community. You can be a contributor too. To learn how, read our
[Contributor's Guide][contrib].

These GitHub users are the All-Time Top Community Contributors.

## Pull Requests merged

Pull Requests help us fix those issues and make the documentation better for everyone.

|   PRs Merged    | 2015 | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 | 2022 | 2023 | 2024 | Grand Total |
| --------------- | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ----------: |
| Community       |    3 |  194 |  446 |  464 |  318 |  161 |  100 |  122 |  108 |   13 |        1929 |
| matt9ucci       |      |      |  157 |   80 |   30 |    1 |    6 |      |      |      |         274 |
| nschonni        |      |      |      |   14 |  138 |   10 |      |      |      |      |         162 |
| kiazhi          |      |   25 |   79 |   12 |      |      |      |      |      |      |         116 |
| alexandair      |      |   57 |    7 |   26 |    2 |    1 |      |      |      |      |          93 |
| doctordns       |      |    5 |   32 |   20 |    7 |    9 |    5 |      |    1 |      |          79 |
| sethvs          |      |      |    1 |   43 |      |   20 |    1 |   10 |      |    1 |          76 |
| ehmiiz          |      |      |      |      |      |      |      |   22 |   14 |      |          36 |
| yecril71pl      |      |      |      |      |      |   21 |    3 |    3 |      |      |          27 |
| Dan1el42        |      |   20 |      |      |      |      |      |      |      |      |          20 |
| skycommand      |      |      |    1 |    3 |    3 |    6 |      |    1 |    4 |      |          18 |
| NReilingh       |      |    2 |      |   13 |    3 |      |      |      |      |      |          18 |
| it-praktyk      |      |      |      |   16 |    1 |      |      |      |      |      |          17 |
| vors            |      |   15 |    1 |      |      |      |      |      |      |      |          16 |
| kvprasoon       |      |    2 |    1 |    7 |    2 |    2 |    2 |      |      |      |          16 |
| markekraus      |      |      |   11 |    5 |      |      |      |      |      |      |          16 |
| purdo17         |      |      |      |   13 |      |      |      |      |      |      |          13 |
| k-takai         |      |      |      |    5 |    1 |    7 |      |      |      |      |          13 |
| PlagueHO        |      |   10 |      |      |    1 |      |      |      |      |      |          11 |
| exchange12rocks |      |      |    7 |    3 |      |      |    1 |      |      |      |          11 |
| bergmeister     |      |      |    1 |    3 |    3 |    1 |    1 |    1 |    1 |      |          11 |

## GitHub issues opened

GitHub issues help us identify errors and gaps in our documentation.

|  Issues Opened  | 2015 | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 | 2022 | 2023 | 2024 | Grand Total |
| --------------- | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ----------: |
| Community       |    3 |   54 |   95 |  212 |  563 |  558 |  365 |  225 |  271 |   69 |        2415 |
| mklement0       |      |      |   19 |   60 |   56 |   61 |   28 |    8 |   20 |   13 |         265 |
| ehmiiz          |      |      |      |      |      |      |      |   20 |   14 |      |          34 |
| iSazonov        |      |      |    1 |    4 |   10 |    8 |    4 |    3 |      |      |          30 |
| jszabo98        |      |      |      |    2 |   15 |    6 |    1 |      |    1 |      |          25 |
| juvtib          |      |      |      |      |      |   15 |    7 |      |      |      |          22 |
| doctordns       |      |      |    5 |    3 |    5 |    7 |    1 |      |      |      |          21 |
| peetrike        |      |      |      |    1 |      |    4 |    2 |    6 |    4 |    2 |          19 |
| vexx32          |      |      |      |    3 |   11 |      |      |    3 |      |      |          17 |
| iRon7           |      |      |      |      |      |    2 |    2 |    2 |   10 |      |          16 |
| KirkMunro       |      |      |      |    7 |    7 |    1 |      |      |      |      |          15 |
| JustinGrote     |      |      |      |    1 |    3 |    6 |    1 |    1 |    2 |    1 |          15 |
| alexandair      |      |    9 |    4 |    2 |      |      |      |      |      |      |          15 |
| clamb123        |      |      |      |      |      |      |   14 |      |      |      |          14 |
| tabad           |      |      |      |      |      |      |      |      |   11 |    2 |          13 |
| rkeithhill      |      |      |    1 |    2 |    2 |    2 |    3 |    1 |    2 |      |          13 |
| kilasuit        |      |      |      |      |    3 |    2 |    1 |    4 |    1 |    2 |          13 |
| trollyanov      |      |      |      |      |      |      |   11 |    1 |      |      |          12 |
| jsilverm        |      |      |      |      |      |    8 |      |      |    4 |      |          12 |
| CarloToso       |      |      |      |      |      |      |      |      |   11 |      |          11 |
| vors            |    1 |    6 |    2 |    1 |      |      |      |      |      |      |          10 |
| UberKluger      |      |      |      |      |      |    1 |    7 |    2 |      |      |          10 |
| matt9ucci       |      |      |    2 |    5 |      |      |    2 |      |    1 |      |          10 |
| Liturgist       |      |      |      |      |    1 |    1 |    1 |    2 |    4 |    1 |          10 |
| LaurentDardenne |      |      |    3 |    2 |      |      |      |    5 |      |      |          10 |

<!-- Link references -->
[contrib]: contributing/overview.md

# /./reference/community/2023-updates.md

    ---
    description: List of changes to the PowerShell documentation for 2023
    ms.date: 01/02/2024
    title: What's New in PowerShell-Docs for 2023
    ---
# What's new in PowerShell Docs for 2023

This article lists notable changes made to docs each month and celebrates the contributions from the
community.

Help us make the documentation better for you. Read the [Contributor's Guide][contrib] to learn how
to get started.

## 2023-Dec

Lots of minor updates but no new content. The Docs team is taking a break for the holidays.

### Top Community Contributors

GitHub stats

- 24 PRs merged (4 from Community)
- 21 issues opened (18 from Community)
- 18 issues closed (15 Community issues closed)

The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|  GitHub Id   | PRs merged | Issues opened |
| ------------ | :--------: | :-----------: |
| Blake-Madden |     2      |               |
| shyguyCreate |     1      |               |
| ryanperrymba |     1      |               |
| jp2images    |     1      |               |
| mklement0    |            |       2       |

## 2023-Nov

Updated content

- Updated release notes for PowerShell 7.4.0 GA
  - [What's New in PowerShell 7.4 - PowerShell](/powershell/scripting/whats-new/what-s-new-in-powershell-74)
  - [PowerShell Gallery - Microsoft.PowerShell.WhatsNew 0.5.4](https://www.powershellgallery.com/packages/Microsoft.PowerShell.WhatsNew)
  - [PowerShell SDK 7.4 reference - .NET API browser](/dotnet/api/?view=powershellsdk-7.4.0&preserve-view=true)
- Retired Windows PowerShell content to archive site
  - Added [What is Windows PowerShell?](/powershell/scripting/windows-powershell/overview)
- Major updates to:
  [about_Classes](/powershell/module/microsoft.powershell.core/about/about_classes) and
  [about_Enum](/powershell/module/microsoft.powershell.core/about/about_classes)

New content

- New Class articles added
  - [about Classes Constructors](/powershell/module/microsoft.powershell.core/about/about_classes_constructors)
  - [about Classes Inheritance](/powershell/module/microsoft.powershell.core/about/about_classes_inheritance)
  - [about Classes Methods](/powershell/module/microsoft.powershell.core/about/about_classes_methods)
  - [about Classes Properties](/powershell/module/microsoft.powershell.core/about/about_classes_properties)

### Top Community Contributors

GitHub stats

- 37 PRs merged (7 from Community)
- 32 issues opened (31 from Community)
- 33 issues closed (31 Community issues closed)


The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|  GitHub Id  | PRs merged | Issues opened |
| ----------- | :--------: | :-----------: |
| jmiller76   |     2      |               |
| VShrubowich |     1      |               |
| TEBandCo    |     1      |               |
| skycommand  |     1      |               |
| darthwalsh  |     1      |               |
| diecknet    |     1      |               |
| tabad       |            |       7       |
| mklement0   |            |       2       |
| radkedan    |            |       2       |

## 2023-Oct

New content

- [Securing a restricted PowerShell remoting session](/powershell/scripting/dev-cross-plat/security/securing-restricted-sessions)

Updated content

- Updated release notes for PowerShell 7.4-rc.1
- Updated release notes for PSReadLine GA 2.3.4
- Updated release notes for PSResourceGet 1.0.0

Docs platform changes

- Released new feedback experience at the bottom of each page

### Top Community Contributors

GitHub stats

- 55 PRs merged (11 from Community)
- 41 issues opened (37 from Community)
- 37 issues closed (33 Community issues closed)

The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|      GitHub Id      | PRs merged | Issues opened |
| ------------------- | :--------: | :-----------: |
| baardhermansen      |     1      |               |
| diecknet            |     1      |               |
| dipstar             |     1      |               |
| ehmiiz              |     1      |       1       |
| G2-Games            |     1      |               |
| indented-automation |     1      |               |
| jhribal             |     1      |               |
| Joeselorm           |     1      |               |
| matziq              |     1      |               |
| RAJU2529            |     1      |               |
| ThomasNieto         |     1      |       2       |
| iRon7               |            |       2       |
| JustinWebDev        |            |       2       |
| o-l-a-v             |            |       2       |
| tabad               |            |       4       |

## 2023-Sep

New content

- [How to create a feedback provider](../dev-cross-plat/create-feedback-provider.md)

Updated Content

- Updated [What's new in PowerShell 7.4](../whats-new/What-s-New-in-PowerShell-74.md) for PowerShell
  7.4-preview.6
- Documented the changes to search scope in [How to use the documentation](../how-to-use-docs.md)
- Updated
  [What's new in Crescendo 1.1](/powershell/utility-modules/crescendo/whats-new/whats-new-in-crescendo-11)
  for the GA release
- Updated the setup scripts for supported Linux distributions
- Updated DSC v3 content for the alpha.3 release

Quality improvement project contributions

- @ehmiiz contributed 5 PRs to update 35 files

New Learn platform features

- Deployed the new feedback experience at that bottom of each page

### Top Community Contributors

GitHub stats

- 52 PRs merged (9 from Community)
- 24 issues opened (22 from Community)
- 24 issues closed (23 Community issues closed)

The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| ehmiiz          |     5      |       5       |
| bubbletroubles  |     1      |               |
| JamesDBartlett3 |     1      |               |
| not-not-kevin   |     1      |               |
| skycommand      |     1      |               |
| jsilverm        |            |       3       |
| mklement0       |            |       2       |

## 2023-Aug

New content

66 New articles for DSC v3 (alpha)
- See [Microsoft Desired State Configuration v3 overview](/powershell/dsc/overview?view=dsc-3.0&preserve-view=true)
  to get started with the new documentation

Updated Content

- Crescendo 1.1-RC1 release updates
  - [What's new in Crescendo 1.1](/powershell/utility-modules/crescendo/whats-new/whats-new-in-crescendo-11)

- New PSResourceGet beta24 content updates
  - See [Supported repository configurations](/powershell/gallery/powershellget/supported-repositories)

- Lots updates for the PowerShell 7.4-preview.5 release
  - [What's New in PowerShell 7.4 (preview)](../whats-new/what-s-new-in-powershell-74.md)
  - New features for 10 cmdlets

- Updated support status and installation notes for Raspberry Pi
  - [Community support for PowerShell on Linux - PowerShell](/powershell/scripting/install/community-support#raspberry-pi-os)

### Top Community Contributors

GitHub stats

- 29 PRs merged (3 from Community)
- 16 issues opened (12 from Community)
- 21 issues closed (17 Community issues closed)

The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| ehmiiz          |     1      |       1       |
| crisman         |     1      |               |
| deadlydog       |     1      |               |
| JamesDBartlett3 |     1      |               |

## 2023-Jul

Updated content

- 7.4-preview.4 [release notes](../whats-new/What-s-New-in-PowerShell-74.md)
- Add publish information to [Supported repository configurations](/powershell/gallery/powershellget/supported-repositories)
- Updated the release notes shipped with [Get-WhatsNew](https://www.powershellgallery.com/packages/Microsoft.PowerShell.WhatsNew)
- Fixed invalid ///-comments in SDK API reference
- Updated the man page that ships in PowerShell for Linux and macOS

### Top Community Contributors

GitHub stats

- 31 PRs merged (10 from Community)
- 21 issues opened (17 from Community)
- 17 issues closed (13 Community issues closed)


The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|   GitHub Id   | PRs merged | Issues opened |
| ------------- | :--------: | :-----------: |
| crisman       |     2      |       3       |
| TSanzo-BLE    |     2      |               |
| MilekJakub    |     1      |               |
| Atman-Shastri |     1      |               |
| BraveJhawk    |     1      |               |
| coolhome      |     1      |               |
| johndward01   |     1      |               |
| lor3k         |     1      |               |

## 2023-Jun

New Azure Cloud Shell content

- [Using Cloud Shell in an Azure virtual network](/azure/cloud-shell/private-vnet)
- [Deploy Azure Cloud Shell in a VNET with quickstart templates](/azure/cloud-shell/quickstart-deploy-vnet)

New PowerShellGet v3 content

- [Supported repository configurations](/powershell/gallery/powershellget/supported-repositories)
- Cmdlet reference for [Microsoft.PowerShell.PSResourceGet](/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x&preserve-view=true)
- Cmdlet reference for the [PowerShellGet compatibility module](/powershell/module/powershellget/?view=powershellget-3.x&preserve-view=true)

Lot of updates for the PowerShell 7.4-preview.4 release

- [What's New in PowerShell 7.4 (preview)](../whats-new/What-s-New-in-PowerShell-74.md)
- [Using Experimental Features in PowerShell](../learn/experimental-features.md)
- New features for 12 cmdlets

Quality Project contributions

- @XXLMandalorian013 contributed 3 PRs to update 2 files in the
  MicrosoftDocs/windows-docs-powershell repository

### Top Community Contributors

GitHub stats

- 59 PRs merged (15 from Community)
- 44 issues opened (30 from Community)
- 47 issues closed (31 Community issues closed)

The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|  GitHub Id  | PRs merged | Issues opened |
| ----------- | :--------: | :-----------: |
| thegraffix  |     4      |               |
| crisman     |     4      |       3       |
| RAJU2529    |     1      |               |
| dstreefkerk |     1      |               |
| vontompers  |     1      |               |
| mubed       |     1      |               |
| Frederisk   |     1      |               |
| khaffner    |     1      |               |
| noamper     |     1      |               |
| aksarben    |            |       4       |

## 2023-May

New content

- New cmdlet in 7.4 - [Get-SecureRandom](xref:Microsoft.PowerShell.Utility.Get-SecureRandom)
- [Using Windows Defender Application Control](/powershell/scripting/learn/application-control)

Updated content

- [How to use the PowerShell documentation](/powershell/scripting/how-to-use-docs)
  - Added descriptions for various navigation elements on the site
  - Added information about how to use the new **Download PDF** feature
- [Exploring the Windows PowerShell ISE](/powershell/scripting/windows-powershell/ise/exploring-the-windows-powershell-ise)
  - Added screenshots for the ISE user interface elements
- Update documentation for [Add-Member](xref:Microsoft.PowerShell.Utility.Add-Member)
  - Corrected some parameter values
  - Improved the description and added examples for the **SecondValue** parameter

Quality Project contributions

- @robderickson contributed 1 PR to update 10 files in the MicrosoftDocs/windows-docs-powershell
  repository

### Top Community Contributors

GitHub stats

- 38 PRs merged (7 from Community)
- 24 issues opened (18 from Community)
- 20 issues closed (17 Community issues closed)

The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

| GitHub Id  | PRs merged | Issues opened |
| ---------- | :--------: | :-----------: |
| rwp0       |     1      |               |
| pronichkin |     1      |               |
| Ooggle     |     1      |               |
| mavaddat   |     1      |               |
| IanKemp    |     1      |               |
| mcdonaldjc |     1      |               |
| Brizio     |     1      |               |
| dotnvo     |     1      |               |
| r0bfr      |     1      |               |
| mklement0  |            |       3       |
| aksarben   |            |       2       |
| crisman    |            |       2       |

## 2023-April

New content

- [Handling errors in Crescendo](/powershell/utility-modules/crescendo/advanced/handling-errors)
- [Transforming arguments in Crescendo](/powershell/utility-modules/crescendo/advanced/transforming-arguments)

Updated content

- Updated release notes for PowerShell 7.4-preview.3
- Migrated the PowerShell Gallery and PowerShellGet docs to new location to enable version selectors
  for [PowerShellGet](/powershell/gallery/overview)

PowerShell Summit 2023 - Hack-a-Doc event

- We hosted a Hack-a-Doc event on April 27th. Special thanks to the following 19 people. They
  contributed 62 PRs to update 204 files in the
  [MicrosoftDocs/windows-powershell-docs](https://github.com/MicrosoftDocs/windows-powershell-docs)
  repository.

|     GitHub Id     |       name       | Count of PRs | Count of file |
| ----------------- | ---------------- | -----------: | ------------: |
| RobBiddle         | Robert Biddle    |           28 |            48 |
| pbossman          | Phil Bossman     |            1 |            27 |
| ThomasNieto       | Thomas Nieto     |            1 |            24 |
| kevinCefalu       | Kevin Cefalu     |            1 |            24 |
| robderickson      | Rob Derickson    |            4 |            17 |
| Snozzberries      | Michael Soule    |           13 |            16 |
| Spoonsk           | Joseph Gast      |            1 |            12 |
| thedavecarroll    | Dave Carroll     |            1 |            11 |
| raynbowbrite      | Vanda Paladino   |            2 |             7 |
| majst32           | Melissa Januszko |            1 |             6 |
| XXLMandalorian013 | Drew McClellan   |            1 |             4 |
| ThePoShWolf       | Anthony Howell   |            1 |             1 |
| mdowst            | Matthew Dowst    |            1 |             1 |
| thepowerstring    |                  |            1 |             1 |
| KevinMarquette    | Kevin Marquette  |            1 |             1 |
| 53883             |                  |            1 |             1 |
| zockan            | Michael Svegmar  |            1 |             1 |
| lanwench          | Paula Kingsley   |            1 |             1 |
| stevenjudd        | Steven Judd      |            1 |             1 |
| Grand Total       |                  |           62 |           204 |

### Top Community Contributors

GitHub stats

- 23 PRs merged (2 from Community)
- 16 issues opened (14 from Community)
- 17 issues closed (15 Community issues closed)

The following people contributed to PowerShell docs this month by submitting pull requests or
filing issues. Thank you!

|    GitHub Id     | PRs merged | Issues opened |
| ---------------- | :--------: | :-----------: |
| NLZ              |     1      |               |
| Jonathan-Quilter |     1      |               |

## 2023-March

New content

- [Create a class-based DSC Resource for Machine Configuration](/powershell/dsc/tutorials/create-dsc-resource-machine-config)
- [Using PSReadLine key handlers](/powershell/scripting/learn/shell/using-keyhandlers)

Updated content

- Release notes for [PowerShell 7.4-preview.2](/powershell/scripting/whats-new/what-s-new-in-powershell-74)

Quality project updates from the community

- One of our top contributors [@ehmiiz][ehmiiz] blogged about contributing to Docs
  - [How to Learn Git, Markdown and PowerShell by Contributing to the PowerShell-Docs Repository](https://www.ehmiiz.se/blog/ps_docs_contributions/)

### Top Community Contributors

GitHub stats

- 60 PRs merged (13 from Community)
- 44 issues opened (31 from Community)
- 50 issues closed (36 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| skycommand     |     2      |               |
| martincostello |     1      |               |
| iRon7          |     1      |       4       |
| chrullrich     |     1      |               |
| FlintyLemming  |     1      |               |
| ehmiiz         |     1      |               |
| vvavrychuk     |     1      |               |
| bb-froggy      |     1      |               |
| BenjamimCS     |     1      |               |
| kirillkrylov   |     1      |               |
| bergmeister    |     1      |               |
| lizy14         |     1      |               |
| CarloToso      |            |       5       |
| MartinGC94     |            |       2       |
| rgl            |            |       2       |

## 2023-February

New Content

- [Preventing script injection attacks](/powershell/scripting/dev-cross-plat/security/preventing-script-injection)
  (Thanks [@PaulHigin][PaulHigin])

Content updates

- Major update to
  [about_PowerShell_Config](/powershell/module/microsoft.powershell.core/about/about_powershell_config)
- Update to
  [about_Logging_Non-Windows](/powershell/module/microsoft.powershell.core/about/about_logging_non-windows)
  for macOS instructions
- Major update to [Class-based DSC Resources](/powershell/dsc/concepts/class-based-resources) and
  other related articles for DSC v2

Quality project updates from the community

- Added alias information to 4 cmdlet articles (Thanks [@ehmiiz][ehmiiz]!)

### Top Community Contributors

GitHub stats

- 35 PRs merged (8 from Community)
- 20 issues opened (14 from Community)
- 17 issues closed (10 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| joshua-russell |     4      |       1       |
| 1NF053C        |     1      |               |
| doctordns      |     1      |               |
| Hrxn           |     1      |               |
| KyleMit        |     1      |               |
| VertigoRay     |     1      |               |
| ehmiiz         |     1      |               |
| ArmaanMcleod   |            |       2       |
| mklement0      |            |       2       |

## 2023-January

New Content

- [What's new in PowerShell 7.4 (preview)](/powershell/scripting/whats-new/what-s-new-in-powershell-74)
- [about_Data_Files](/powershell/module/microsoft.powershell.core/about/about_data_files)

Content updates

- Updated docs for 7.4-preview.1 release
- Major update to [about_Language_Modes](/powershell/module/microsoft.powershell.core/about/about_language_modes)
- Major update to [about_Logging_Non-Windows](/powershell/module/microsoft.powershell.core/about/about_logging_non-windows)

Quality project updates from the community

- Added alias information to 40 cmdlet articles (Thanks [@ehmiiz][ehmiiz]!)
- Added alias information to 52 cmdlet articles (Thanks [@szabolevo][szabolevo]!)

### Top Community Contributors

GitHub stats

- 71 PRs merged (21 from Community)
- 53 issues opened (33 from Community)
- 62 issues closed (40 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|  GitHub Id  | PRs merged | Issues opened |
| ----------- | :--------: | :-----------: |
| ehmiiz      |     5      |       5       |
| szabolevo   |     5      |       7       |
| anderjef    |     2      |               |
| turbedi     |     1      |               |
| desk7       |     1      |               |
| cobrabr     |     1      |               |
| ZYinMD      |     1      |               |
| tompazourek |     1      |               |
| kenyon      |     1      |               |
| cjvandyk    |     1      |               |
| JTBrinkmann |     1      |               |
| mklement0   |            |       4       |
| CarloToso   |            |       3       |
| KyleMit     |            |       2       |
| iRon7       |            |       2       |

<!-- Link references -->
[contrib]: contributing/overview.md
[ehmiiz]: https://github.com/ehmiiz
[szabolevo]: https://github.com/szabolevo
[PaulHigin]: https://github.com/PaulHigin

# /./reference/community/2022-updates.md

    ---
    description: List of changes to the PowerShell documentation for 2022
    ms.date: 06/28/2023
    title: What's New in PowerShell-Docs for 2022
    ---
# What's new in PowerShell Docs for 2022

This article lists notable changes made to docs each month and celebrates the contributions from the
community.

Help us make the documentation better for you. Read the [Contributor's Guide][contrib] to learn how
to get started.

## 2022-December

New Content

- [about_PSItem](/powershell/module/microsoft.powershell.core/about/about_psitem)
- [Configuring a light colored theme](/powershell/scripting/learn/shell/using-light-theme)
- [What's new in Crescendo 1.1](/powershell/utility-modules/crescendo/whats-new/whats-new-in-crescendo-11)
- [Export-CrescendoCommand](/powershell/module/microsoft.powershell.crescendo/export-crescendocommand)
- PowerShell 7.4 (preview) cmdlet reference - a direct copy of the 7.3 content in preparation for
  the preview release of PowerShell 7.4

More Quality project updates

- Added alias information to 83 cmdlet articles (Thanks @ehmiiz!)
- Added alias information to 8 cmdlet articles (Thanks @szabolevo!)

GitHub stats

- 51 PRs merged (14 from Community)
- 50 issues opened (28 from Community)
- 46 issues closed (23 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|  GitHub Id  | PRs merged | Issues opened |
| ----------- | :--------: | :-----------: |
| ehmiiz      |     8      |       7       |
| changeworld |     3      |               |
| szabolevo   |     1      |               |
| amkhrjee    |     1      |               |
| xtqqczze    |     1      |       3       |
| ALiwoto     |     1      |       2       |
| mklement0   |            |       3       |

## 2022-November

New Content

- [Contributing quality improvements](contributing/quality-improvements.md)
  - See examples under [Quality project updates](#quality-nov)
- [Product terminology and branding guidelines](contributing/product-terminology.md)
- [Labelling in GitHub](contributing/labelling-in-github.md)

Content updates

- Updated release notes for the PowerShell 7.3 GA release
- Updated [about_Telemetry](/powershell/module/microsoft.powershell.core/about/about_telemetry)
- Improved the description of delay-binding in
  [about_Script_Blocks](/powershell/module/Microsoft.PowerShell.Core/About/about_Script_Blocks)
- Added a best practice recommendation to
  [about_Functions_Advanced_Parameters](/powershell/module/Microsoft.PowerShell.Core/About/about_Functions_Advanced_Parameters)

<span id='quality-nov'>Quality project updates</span>

- Added alias information to 129 cmdlet articles (Thanks @ehmiiz!)
- Added links to PRs in the PowerShell 7.3 release notes (Thanks @skycommand!)
- Converted hyperlinks to link references in 5 articles (Thanks @chadmando!)

GitHub stats

- 52 PRs merged (12 from Community)
- 41 issues opened (27 from Community)
- 42 issues closed (28 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| ehmiiz         |     9      |       8       |
| chadmando      |     1      |               |
| baardhermansen |     1      |               |
| skycommand     |     1      |               |
| mklement0      |            |       3       |
| peetrike       |            |       2       |

## 2022-October

New Content

- [Create a class-based DSC Resource](/powershell/dsc/tutorials/create-class-based-resource?view=dsc-2.0&preserve-view=true)
- [Hacktoberfest and other hack-a-thon events](/powershell/scripting/community/contributing/hackathons?)

Content updates

- [Hacktoberfest 2022](https://github.com/MicrosoftDocs/PowerShell-Docs/pulls?q=is%3Apr+is%3Aclosed+label%3Ahacktoberfest-accepted)
  cleanup efforts
  - Thank you to @ehmiiz, @TSanzo-BLE, and @chadmando for their Hacktoberfest PRs! Their 11 PRs
    touched 114 articles.
- Published PowerShell SDK .NET API content for
  [PowerShell 7.2](/dotnet/api/?view=powershellsdk-7.2.0&preserve-view=true) and
  [7.3-preview](/dotnet/api/?view=powershellsdk-7.3.0&preserve-view=true)
  - The first updates since PowerShell 7.1 released in November 2020
  - Removed the unsupported versions 6.0 and 7.1
- Added a list of aliases not available on Linux and macOS to
  [PowerShell differences on non-Windows platforms](/powershell/scripting/whats-new/unix-support)

GitHub stats

- 65 PRs merged (21 from Community)
- 42 issues opened (28 from Community)
- 34 issues closed (23 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|      GitHub Id      | PRs merged | Issues opened |
| ------------------- | :--------: | :-----------: |
| ehmiiz              |     5      |       5       |
| TSanzo-BLE          |     4      |               |
| yecril71pl          |     2      |               |
| chadmando           |     2      |               |
| GigaScratch         |     1      |       1       |
| rbleattler          |     1      |               |
| spjeff              |     1      |               |
| adamdriscoll        |     1      |               |
| manuelcarriernunes  |     1      |               |
| michelangelobottura |     1      |               |
| dmpe                |     1      |               |
| KamilPacanek        |     1      |               |
| SetTrend            |            |       2       |

## 2022-September

No new content this month.

Content updates

- [PSScriptAnalyzer 1.21](/powershell/utility-modules/psscriptanalyzer/overview) update release
- Release notes for [7.3-preview.8](/powershell/scripting/whats-new/what-s-new-in-powershell-73)

GitHub stats

- 31 PRs merged (8 from Community)
- 18 issues opened (9 from Community)
- 16 issues closed (8 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| DonaldDWebster |     1      |               |
| emerconghaile  |     1      |               |
| floojah        |     1      |               |
| imere          |     1      |               |
| mcdonaldjc     |     1      |               |
| rayden84       |     1      |               |
| sirsql         |     1      |               |
| tig            |     1      |               |
| b-long         |            |       2       |

## 2022-August

New content

- New [landing page](/powershell/scripting/whats-new/overview) for What's new content

- Shell experience docs
  - [Running commands in the shell](/powershell/scripting/learn/shell/running-commands)

- DSC 2.0 docs
  - [Conceptual](/powershell/dsc/overview?view=dsc-2.0&preserve-view=true)
    content - 15 new articles
  - [PSDscResources](/powershell/dsc/reference/psdscresources/overview?view=dsc-2.0&preserve-view=true)
    module reference - 58 new articles

Content updates

- [PowerShell VS Code docs](https://code.visualstudio.com/docs/languages/powershell)
- Release notes for [7.3-preview.7](/powershell/scripting/whats-new/what-s-new-in-powershell-73)
- Cleaned up markdown tables in About topics for better accessibility and localization

Other Projects

- [Get-WhatsNew](https://devblogs.microsoft.com/powershell/announcing-the-release-of-get-whatsnew/)
  cmdlet released - This cmdlet displays release notes for all versions of PowerShell so you can see
  what's new for a particular version.

GitHub stats

- 57 PRs merged (16 from Community)
- 24 issues opened (12 from Community)
- 26 issues closed (15 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|         GitHub Id         | PRs merged | Issues opened |
| ------------------------- | :--------: | :-----------: |
| sethvs                    |     4      |               |
| BEEDELLROKEJULIANLOCKHART |     1      |               |
| Chemerevsky               |     1      |               |
| ClaudioESSilva            |     1      |               |
| davidhaymond              |     1      |               |
| DavidMetcalfe             |     1      |               |
| dharmatech                |     1      |               |
| kozhemyak                 |     1      |               |
| mcawai                    |     1      |               |
| NaridaL                   |     1      |               |
| Nicicalu                  |     1      |               |
| sdarwin                   |     1      |               |
| seansaleh                 |     1      |               |

## 2022-July

New content

- [Optimizing your shell experience](/powershell/scripting/learn/shell/optimize-shell)
- [Using tab completion](/powershell/scripting/learn/shell/tab-completion)
- [Using command predictors](/powershell/scripting/learn/shell/using-predictors)
- [Getting dynamic help](/powershell/scripting/learn/shell/dynamic-help)
- [Using aliases](/powershell/scripting/learn/shell/using-aliases)
- [Customizing your shell environment](/powershell/scripting/learn/shell/creating-profiles)

Content updates

- Updated PowerShell 7.3-preview.6 [release notes](/powershell/scripting/whats-new/what-s-new-in-powershell-73)
- Started reviewing and testing PowerShellGet v3 cmdlet reference (currently in beta) to ensure
  accuracy and release readiness.
- Refresh of our Community [Contributor Guide](https://aka.ms/PSDocsContributor)

### Top Community Contributors

GitHub stats

- 50 PRs merged (6 from Community)
- 22 issues opened (14 from Community)
- 29 issues closed (19 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|  GitHub Id   | PRs merged | Issues opened |
| ------------ | :--------: | :-----------: |
| Alvynskio    |     1      |               |
| bergmeister  |     1      |               |
| BusHero      |     1      |               |
| lewis-yeung  |     1      |               |
| sethvs       |     1      |               |
| tommymaynard |     1      |               |

## 2022-June

New content migrated from GitHub wiki

- [Limitations of PowerShell transcripts](/powershell/scripting/learn/deep-dives/output-missing-from-transcript)
- [Avoid using Invoke-Expression](/powershell/scripting/learn/deep-dives/avoid-using-invoke-expression)
- [Avoid assigning variables in expressions](/powershell/scripting/learn/deep-dives/avoid-assigning-variables-in-expressions)
- [about_Case-Sensitivity](/powershell/module/microsoft.powershell.core/about/about_case-sensitivity)
- Updated [about_Arrays](/powershell/module/microsoft.powershell.core/about/about_arrays)

New SecretManagement content

- [Understanding the security features of SecretManagement and SecretStore](/powershell/utility-modules/secretmanagement/security-concepts)
- [Using the SecretStore in automation](/powershell/utility-modules/secretmanagement/how-to/using-secrets-in-automation)
- [Using Azure Key Vault in automation](/powershell/utility-modules/secretmanagement/how-to/using-azure-keyvault)

Content updates

- Updated release notes for 7.3-preview.5 and PSReadLine 2.2.6

### Top Community Contributors

GitHub stats

- 44 PRs merged (8 from Community)
- 23 issues opened (14 from Community)
- 23 issues closed (13 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

| GitHub Id  | PRs merged | Issues opened |
| ---------- | :--------: | :-----------: |
| mcdonaldjc |     2      |       1       |
| radrow     |     1      |               |
| yecril71pl |     1      |               |
| muhahaaa   |     1      |               |
| windin7cc  |     1      |               |
| fabiod89   |     1      |               |
| NaridaL    |     1      |               |

## 2022-May

New content

- [Create a Crescendo configuration using the Crescendo cmdlets](/powershell/utility-modules/crescendo/advanced/using-crescendo-cmdlets)
- [Overview of the SecretManagement and SecretStore modules](/powershell/utility-modules/secretmanagement/overview)
- [Get started with the SecretStore module](/powershell/utility-modules/secretmanagement/get-started/using-secretstore)
- [Understanding the SecretManagement module](/powershell/utility-modules/secretmanagement/get-started/understanding-secretmanagement)
- [Managing a SecretStore vault](/powershell/utility-modules/secretmanagement/how-to/manage-secretstore)

Content updates

- Renamed the `staging` branch to `main`
- Updated the Table of Contents for easier discovery
  - Moved Support Lifecycle to the top level
  - Moved Contributor Guide to the top level
- 7.3-preview.4 release notes
- Bulk formatting cleanup for many docs
  - PowerShell-Docs content - 272 files
  - Secrets management - 17 files
- Updated the PSScriptAnalyzer README and deleted docs that were migrated to Microsoft Learn
- Removed CentOS and Fedora from docs - no longer supported
- Retired 7.1 content - no longer supported
  - Collapse release notes into diff article
  - Delete or move content to archive repo

### Top Community Contributors

GitHub stats

- 53 PRs merged (12 from Community)
- 38 issues opened (21 from Community)
- 39 issues closed (26 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id     | PRs merged | Issues opened |
| ---------------- | :--------: | :-----------: |
| tommymaynard     |     5      |               |
| naveensrinivasan |     2      |               |
| rikurauhala      |     1      |               |
| joshua6point0    |     1      |               |
| rhorber          |     1      |               |
| Raton-Laveur     |     1      |               |
| StephenRoille    |     1      |               |
| krlinus          |            |       2       |

## 2022-April

New content

- No new content this month

Content updates

- Rewrote the install instructions for [PowerShellGet](/powershell/gallery/powershellget/install-powershellget)
- Created separate article for
  [Installing PowerShellGet on older Windows systems](/powershell/gallery/powershellget/install-on-older-systems)

Other projects

- PowerShell + DevOps Summit April 25-28
  - Gave presentation about contributing to Docs
  - Lightning demo about argument completers
  - Interview for the [PowerShell Podcast](https://powershellpodcast.podbean.com/e/contributing-to-powershell-made-easy-with-sean-wheeler/)

### Top Community Contributors

GitHub stats

- 24 PRs merged (3 from Community)
- 22 issues opened (17 from Community)
- 21 issues closed (15 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| Hrxn           |     1      |               |
| kevinholtkamp  |     1      |               |
| MikeyBronowski |     1      |               |
| tommymaynard   |            |       4       |

## 2022-March

New Content

- New PowerShell docs
  - [about_Member-Access_Enumeration](/powershell/module/microsoft.powershell.core/about/about_member-access_enumeration)
  - [about_Module_Manifests](/powershell/module/microsoft.powershell.core/about/about_module_manifests)
  - [How to create a command-line predictor](/powershell/scripting/dev-cross-plat/create-cmdline-predictor)
- Utility modules updates
  - New docs for Crescendo release
    - [Install Crescendo](/powershell/utility-modules/crescendo/get-started/install-crescendo)
    - [Choose a command-line tool](/powershell/utility-modules/crescendo/get-started/choose-command-line-tool)
    - [Decide which features to amplify](/powershell/utility-modules/crescendo/get-started/research-tool)
    - [Create a Crescendo cmdlet](/powershell/utility-modules/crescendo/get-started/create-new-cmdlet)
    - [Generate and test a Crescendo module](/powershell/utility-modules/crescendo/get-started/generate-module)
  - Moved PlatyPS article from PowerShell docs to the PlatyPS documentation
    - [Moved PlatyPS article](https://learn.microsoft.com/en-us/powershell/utility-modules/platyps/create-help-using-platyps)
  - Migrated more PSScriptAnalyzer documentation from the source code repository
    - [Using PSScriptAnalyzer](/powershell/utility-modules/psscriptanalyzer/using-scriptanalyzer)
    - [Rules and recommendations](/powershell/utility-modules/psscriptanalyzer/rules-recommendations)
    - [Creating custom rules](/powershell/utility-modules/psscriptanalyzer/create-custom-rule)

Content updates

- Bulk cleanup of related links in About_ topics
- Added issue and PR templates to all docs repos
- Updates for 7.3 preview content
  - New tab completions
  - Support for SSH options on remoting cmdlets
  - New experimental feature `PSAMSIMethodInvocationLogging`

Other projects

- Created a prototype cmdlet `Get-WhatsNew` based on the
  [draft RFC](https://github.com/PowerShell/PowerShell-RFC/pull/317)
  - Check out the RFC and provide feedback

New team member

- Welcome [Mikey Lombardi](https://github.com/michaeltlombardi) to the docs team

### Top Community Contributors

GitHub stats

- 49 PRs merged (8 from Community)
- 26 issues opened (14 from Community)
- 33 issues closed (18 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| AspenForester  |     1      |               |
| codaamok       |     1      |               |
| DianaKuzmenko  |     1      |               |
| MikeyBronowski |     1      |               |
| poshdude       |     1      |               |
| robcmo         |     1      |               |
| sertdfyguhi    |     1      |               |
| stampycode     |     1      |               |

## 2022-February

New Content

- [about_Calling_Generic_Methods](/powershell/module/microsoft.powershell.core/about/about_calling_generic_methods?view=powershell-7.3&preserve-view=true)

Content updates

- Catching up on issues
- Updates for 7.3 preview content

### Top Community Contributors

GitHub stats

- 22 PRs merged (3 from Community)
- 24 issues opened (19 from Community)
- 18 issues closed (16 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| sethvs          |     2      |               |
| guilhermgonzaga |     1      |               |

## 2022-January

New Content

- No new content. We're down to one writer for PowerShell. I was out of the office for half of
  December for vacation then half of January for COVID.

Content updates

- Catching up on issues
- Updates for 7.3 preview content

### Top Community Contributors

GitHub stats

- 51 PRs merged (10 from Community)
- 29 issues opened (26 from Community)
- 46 issues closed (39 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| sethvs          |     3      |               |
| UberKluger      |     1      |               |
| MiguelDomingues |     1      |               |
| reZach          |     1      |               |
| Hertz-Hu        |     1      |               |
| julian-hansen   |     1      |               |
| Hrxn            |     1      |               |
| peteraritchie   |     1      |               |

<!-- Link references -->
[contrib]: contributing/overview.md

# /./reference/community/2021-updates.md

    ---
    description: List of changes to the PowerShell documentation for 2021
    ms.date: 02/02/2023
    title: What's New in PowerShell-Docs for 2021
    ---
# What's new in PowerShell Docs for 2021

This article lists notable changes made to docs each month and celebrates the contributions from the
community.

Help us make the documentation better for you. Read the [Contributor's Guide][contrib] to learn how
to get started.

## 2021-December

New Content

- Added PowerShell 7.3-preview.1 [preview content]
- New DSC 3.0 content
  - [PowerShell Desired State Configuration overview](/powershell/dsc/overview?view=dsc-3.0&preserve-view=true)
  - [Manage configuration using PowerShell DSC](/powershell/dsc/getting-started/getting-started?view=dsc-3.0&preserve-view=true)
  - [DSC Configurations](/powershell/dsc/concepts/configurations?view=dsc-3.0&preserve-view=true)
  - [DSC Resources](/powershell/dsc/concepts/resources?view=dsc-3.0&preserve-view=true)

Content updates

- Moved Desired State Configuration [content](/powershell/dsc/overview) to new docset and repository
  - DSC is now being developed outside of the PowerShell product.
  - The move allows for better versioning of documentation for DSC.

### Top Community Contributors

GitHub stats

- 24 PRs merged (4 from Community)
- 30 issues opened (26 from Community)
- 12 issues closed (7 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| dAu6jARL        |     1      |               |
| shriharshmishra |     1      |               |
| a-sync          |     1      |               |
| bogdangrigg     |     1      |               |

## 2021-November

New Content
- [about_Built-in_Functions](/powershell/module/microsoft.powershell.core/about/about_built-in_functions)

Content updates

- PowerShell 7.2 GA documentation updates
- Update GitHub Issue and PR templates - piloting the new YAML-based forms for issues
- Updated Crescendo reference for Preview 4 release

### Top Community Contributors

GitHub stats

- 48 PRs merged (13 from Community)
- 31 issues opened (24 from Community)
- 34 issues closed (28 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|  GitHub Id  | PRs merged | Issues opened |
| ----------- | :--------: | :-----------: |
| matt9ucci   |     4      |               |
| yecril71pl  |     3      |               |
| tholabrk    |     1      |               |
| lukejjh     |     1      |               |
| Oechiih     |     1      |               |
| bergmeister |     1      |               |
| Hrxn        |     1      |               |
| jebeckham   |     1      |               |

## 2021-October

New Content

- PSScriptAnalyzer documentation
  - [Overview](/powershell/utility-modules/psscriptanalyzer/overview)
  - [Rules documentation](/powershell/utility-modules/psscriptanalyzer/rules/readme)

Content updates

- Lots of general editorial and freshness updates across 450 files
- PowerShell 7.2-rc.1 documentation updates

### Top Community Contributors

GitHub stats

- 49 PRs merged (12 from Community)
- 33 issues opened (30 from Community)
- 33 issues closed (32 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| doctordns       |     4      |               |
| diecknet        |     1      |               |
| Kagre           |     1      |               |
| KexyBiscuit     |     1      |               |
| JohnRoos        |     1      |               |
| Zhu-Panda       |     1      |               |
| philanderson888 |     1      |               |
| BlackFalcons    |     1      |               |
| milaandahiya    |     1      |               |
| mklement0       |            |       2       |

## 2021-September

New Content

- SDK documentation
  - [How to validate an argument using a script](/powershell/scripting/developer/cmdlet/how-to-validate-an-argument-using-script)
  - [ValidateScript Attribute Declaration](/powershell/scripting/developer/cmdlet/validatescript-attribute-declaration)
- Learning content
  - [PowerShell security features](/powershell/scripting/learn/security-features)

Content updates

- Install documentation - Did a complete rewrite of the setup documentation. There is now a separate
  article for each supported OS.
  - [Install on Windows](/powershell/scripting/install/Installing-PowerShell-on-Windows)
  - [Install on macOS](/powershell/scripting/install/Installing-PowerShell-on-macOS)
  - [Install on Linux](/powershell/scripting/install/Installing-PowerShell-on-Linux)
    - [Alpine](/powershell/scripting/install/install-alpine)
    - CentOS
    - [Debian](/powershell/scripting/install/install-debian)
    - Fedora
    - [Raspberry Pi OS](/powershell/scripting/install/install-raspbian)
    - [Red Hat Enterprise Linux](/powershell/scripting/install/install-rhel)
    - [Ubuntu](/powershell/scripting/install/install-ubuntu)
    - [Alternate install methods](/powershell/scripting/install/install-other-linux)
    - [Community supported Linux](/powershell/scripting/install/community-support)
- Supporting documentation
  - [Using PowerShell in Docker](/powershell/scripting/install/PowerShell-in-Docker)
  - [Arm Processor support](/powershell/scripting/install/PowerShell-on-ARM)
  - [Microsoft Update for PowerShell FAQ](/powershell/scripting/install/microsoft-update-faq)
  - [PowerShell Support Lifecycle](/powershell/scripting/install/powershell-support-lifecycle)
- Reformatted and updated the PSScriptAnalyzer rules documentation. Next month we plan to publish these
  docs to Microsoft Learn.
  - [Rules documentation on GitHub](https://github.com/PowerShell/PSScriptAnalyzer/tree/master/docs/Rules)
- Lots of general editorial updates across 4500 files
- PowerShell 7.2-preview.10 documentation updates

### Top Community Contributors

GitHub stats

- 68 PRs merged (6 from Community)
- 32 issues opened (29 from Community)
- 49 issues closed (41 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|  GitHub Id  | PRs merged | Issues opened |
| ----------- | :--------: | :-----------: |
| RaghuRocks3 |     1      |               |
| Zhu-Panda   |     1      |               |
| Jaykul      |     1      |               |
| juvtib      |     1      |               |
| przmv       |     1      |               |
| mklement0   |            |       2       |

## 2021-August

New content

- [about_ANSI_Terminals](/powershell/module/microsoft.powershell.core/about/about_ansi_terminals?view=powershell-7.2&preserve-view=true)
- [about_PSCustomObject](/powershell/module/microsoft.powershell.core/about/about_pscustomobject)

Content updates

- PowerShell 7.2-preview.9 documentation updates

### Top Community Contributors

GitHub stats

- 66 PRs merged (14 from Community)
- 42 issues opened (30 from Community)
- 53 issues closed (38 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| AvrumFeldman    |     1      |               |
| benmccallum     |     1      |               |
| bitdeft         |            |       2       |
| BraINstinct0    |     1      |               |
| diddledani      |     1      |               |
| doctordns       |     1      |               |
| gravitional     |     1      |               |
| homotechsual    |     1      |               |
| imba-tjd        |     1      |               |
| juvtib          |     1      |               |
| kozhemyak       |     1      |               |
| omarys          |     1      |               |
| ryandasilva2992 |     1      |               |
| sethvs          |     1      |               |
| sneakernuts     |     1      |               |

## 2021-July

New content

- [about_Functions_Argument_Completion](/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion)
- [about_Tab_Expansion](/powershell/module/microsoft.powershell.core/about/about_Tab_Expansion)

Content updates

- [about_Functions_Advanced_Parameters](/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters) - major updates and links to new articles
- PowerShell 7.2-preview.8 documentation updates

### Top Community Contributors

GitHub stats

- 51 PRs merged (9 from Community)
- 56 issues opened (50 from Community)
- 59 issues closed (52 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id   | PRs merged | Issues opened |
| ------------- | :--------: | :-----------: |
| rkeithhill    |     2      |               |
| juvtib        |     2      |               |
| SetTrend      |     1      |               |
| Rob-S         |     1      |               |
| xtqqczze      |     1      |               |
| akashdabhi03  |     1      |               |
| kurtmckee     |     1      |               |
| clamb123      |            |      13       |
| mklement0     |            |       2       |
| jerryKahnPerl |            |       2       |

## 2021-June

New content

- [about_Intrinsic_Members](/powershell/module/microsoft.powershell.core/about/about_intrinsic_members)
- [about_Booleans](/powershell/module/microsoft.powershell.core/about/about_booleans)

Content updates

- Converted [about_remote_faq](/powershell/scripting/learn/remoting/powershell-remoting-faq) to new
  Yaml format and moved to conceptual TOC
- Moved **PSDesiredStateConfiguration** out of 7.2 docs and into PowerShell-Docs-Modules
  - DSC is being removed from PowerShell to become an optional module that is loaded from the
    PowerShell Gallery
  - Long-term plan is to move all DSC documentation out of PowerShell-Docs into a new repository for
    DSC content
- Totally rewrote the PowerShell release notes to summarize the current state, making it easier for
  users to find the information without having to read every release note.
  - [Differences between Windows PowerShell 5.1 and PowerShell (core) 7.x](/powershell/scripting/whats-new/differences-from-windows-powershell)
  - [PowerShell differences on non-Windows platforms](/powershell/scripting/whats-new/unix-support)
- PowerShell 7.2-preview.7 documentation updates

### Top Community Contributors

GitHub stats

- 43 PRs merged (1 from Community)
- 36 issues opened (32 from Community)
- 49 issues closed (41 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|       GitHub Id        | PRs merged | Issues opened |
| ---------------------- | :--------: | :-----------: |
| rkeithhill             |     1      |               |
| frenchiveruti          |            |       2       |
| paulaustin-automutatio |            |       2       |
| ringerc                |            |       2       |
| trollyanov             |            |       2       |
| UberKluger             |            |       2       |

## 2021-May

New Content

- Migrated two articles from the Windows Server content to the PowerShell docset
  - [PowerShell scripting performance considerations](/powershell/scripting/dev-cross-plat/performance/script-authoring-considerations)
  - [PowerShell module authoring considerations](/powershell/scripting/dev-cross-plat/performance/module-authoring-considerations)
- Added [PowerShell Language Specification 3.0](/powershell/scripting/lang-spec/chapter-01)
  - The specification document is available from the Microsoft Download
    Center as a [Microsoft Word document](https://www.microsoft.com/download/details.aspx?id=36389).
- Updated content for PowerShell 7.2-Preview6 release
- Moved Samples under the Learn node in the Table of Contents

### Top Community Contributors

GitHub stats

- 53 PRs merged (6 from Community)
- 37 issues opened (35 from Community)
- 39 issues closed (36 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id     | PRs merged | Issues opened |
| ---------------- | :--------: | :-----------: |
| kvprasoon        |     2      |               |
| jErprog          |     1      |               |
| aamnah           |     1      |               |
| BetaLyte         |     1      |               |
| TheNCuber        |     1      |               |
| trollyanov       |            |       6       |
| Tarjei-stavanger |            |       3       |
| aungminko93750   |            |       3       |
| SetTrend         |            |       2       |
| cdichter         |            |       2       |
| reuvygroovy      |            |       2       |

## 2021-April

New Content

- Published new Learn content   [Write your first PowerShell code](/training/modules/powershell-write-first/)
- Updated docs for PowerShell 7.2-preview.5
- Updated metadata on ~3300 articles in the Windows module documentation
  - Preparing for Windows Server 2022 release and fixing updateable help
  - This is still a work in progress

### Top Community Contributors

GitHub stats

- 45 PRs merged (5 from Community)
- 42 issues opened (33 from Community)
- 55 issues closed (32 Community issues closed)

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| ealmonte32      |     1      |               |
| hananyajacobson |     1      |               |
| MarcChasse      |     1      |               |
| Melvin-Abraham  |     1      |               |
| robertkruk      |     1      |               |
| MikeMM70        |            |       2       |

## 2021-March

New content

- Working on simplify and expanding the [Overview](/powershell/scripting/overview) content
  - Added [What is a PowerShell command?](/powershell/scripting/powershell-commands)
- Started a new tutorial series - [PowerShell Bits](/powershell/scripting/learn/tutorials/00-introduction)
  - [Discover PowerShell](/powershell/scripting/learn/tutorials/01-discover-powershell)
- Help content for PowerShell [utility modules](/powershell/utility-modules/overview)
  - Microsoft.PowerShell.Crescendo
  - Microsoft.PowerShell.SecretManagement
  - Microsoft.PowerShell.SecretStore
  - PlatyPS
  - PSScriptAnalyzer
- Working with the Windows team to update help for [Windows management modules](/powershell/windows/get-started)
  - Added content for Windows Server 2019 and Windows Server 2022 (preview)
  - Continuing to work on improving updateable help for these modules
- PowerShell 7.2-preview documentation updates

### Top Community Contributors

GitHub stats

- 42 PRs merged (5 from Community)
- 63 issues opened (42 from Community)
- 47 issues closed

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

| GitHub Id  | PRs merged | Issues opened |
| ---------- | :--------: | :-----------: |
| bl-ue      |     1      |               |
| brianary   |     1      |               |
| Lx         |     1      |               |
| matt9ucci  |     1      |               |
| kfasick    |     1      |               |
| mklement0  |            |      10       |
| juvtib     |            |       6       |
| BoJackem23 |            |       2       |

## 2021-February

New content
- PowerShell 7.2-preview documentation updates

### Top Community Contributors

GitHub stats

- 40 PRs merged (12 from Community)
- 40 issues opened (30 from Community)
- 35 issues closed

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| bbodenmiller    |     1      |               |
| brianary        |     1      |               |
| exchange12rocks |     1      |               |
| IvenBach        |     1      |               |
| jamiepinheiro   |     1      |               |
| jdoubleu        |     1      |               |
| LogicalToolkit  |     1      |               |
| matt9ucci       |     1      |               |
| mihir-ajmera    |     1      |               |
| revolter        |     1      |               |
| secretGeek      |     1      |               |
| springcomp      |     1      |               |
| Ayanmullick     |            |       2       |

## 2021-January

New content

- PowerShell 7.2-preview documentation updates

### Top Community Contributors

GitHub stats

- 44 PRs merged (14 from Community)
- 46 issues opened (38 from Community)
- 35 issues closed

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| AndreyMatrosov |     4      |               |
| revolter       |     2      |               |
| cconrad        |     1      |               |
| Hrxn           |     1      |               |
| kilasuit       |     1      |               |
| NN---          |     1      |               |
| snickler       |     1      |               |
| vinian         |     1      |               |
| zeekbrown      |     1      |               |
| brianary       |            |       2       |
| mklement0      |            |       2       |
| plastikfan     |            |       2       |

<!-- Link references -->
[contrib]: contributing/overview.md

# /./reference/community/2020-updates.md

    ---
    description: List of changes to the PowerShell documentation for 2020
    ms.date: 02/02/2023
    title: What's New in PowerShell Docs for 2020
    ---

# What's new in PowerShell Docs for 2020

This article lists notable changes made to docs each month and celebrates the contributions from the
community.

Help us make the documentation better for you. Read the [Contributor's Guide][contrib] to learn how
to get started.

<!-- Link references -->
[contrib]: contributing/overview.md
<!-- --------------- -->

## 2020-December

- Updated contributor guide
  - documented the `&preserve_view=true` query parameter for hyperlinks
  - documented cross-reference syntax for hyperlinks
  - added information about localization

- GitHub stats
  - 44 PRs merged (11 from Community)
  - 50 issues opened (43 from Community)
  - 50 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|      GitHub Id      | PRs merged | Issues opened |
| ------------------- | :--------: | :-----------: |
| doctordns           |     3      |       2       |
| chadbaldwin         |     1      |               |
| dawedawe            |     1      |               |
| dumpvn              |     1      |               |
| kvprasoon           |     1      |               |
| lbearl              |     1      |               |
| petershen0307       |     1      |               |
| skycommand          |     1      |               |
| springcomp          |     1      |               |
| Cwilson-dataselfcom |            |       5       |
| bobbybatatina       |            |       2       |

## 2020-November

- PowerShell 7.1 GA Release
  - What's New in PowerShell 7.1
  - Converted 7.1 docs to release status
  - Added 7.2 (preview) docs
  - Retired v6 docs to archive repository

- Blog posts
  - [You've got Help!](https://devblogs.microsoft.com/powershell/youve-got-help/)
  - [Updating help for the PSReadLine module](https://devblogs.microsoft.com/powershell/updating-help-for-the-psreadline-module-in-windows-powershell-5-1/)

- Documentation maintenance
  - Updated 137 articles to remove MSDN and TechNet references
  - Updated 171 articles to indicate Windows-only compatibility
  - Updated 38 articles to address build warnings and suggestions
  - Added include to 24 DSC articles
  - Major rewrite of the PowerShell Jobs articles
    - [about_Jobs](/powershell/module/microsoft.powershell.core/about/about_jobs)
    - [about_Remote_Jobs](/powershell/module/microsoft.powershell.core/about/about_remote_jobs)
    - [about_Thread_Jobs](/powershell/module/microsoft.powershell.core/about/about_thread_jobs)

- GitHub stats
  - 50 PRs merged (8 from Community)
  - 55 issues opened (45 from Community)
  - 51 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id    | PRs merged | Issues opened |
| --------------- | :--------: | :-----------: |
| AlanFlorance    |     1      |               |
| gilbertbw       |     1      |               |
| ianwalkeruk     |     1      |               |
| JeremyTBradshaw |     1      |               |
| matt9ucci       |     1      |               |
| Rob-S           |     1      |               |
| ShaydeNofziger  |     1      |               |
| skycommand      |     1      |               |
| juvtib          |            |       8       |
| iRon7           |            |       2       |
| l-ip            |            |       2       |
| stephenrgentry  |            |       2       |
| Vixb1122        |            |       2       |

## 2020-October

- New articles
  - [about_Character_Encoding](/powershell/module/microsoft.powershell.core/about/about_character_encoding)
  - [about_Output_Streams](/powershell/module/microsoft.powershell.core/about/about_output_streams)
  - [Using Visual Studio Code to debug compiled cmdlets](/powershell/scripting/dev-cross-plat/vscode/using-vscode-for-debugging-compiled-cmdlets) (thanks @fsackur)
  - [Add Credential support to PowerShell functions](/powershell/scripting/learn/deep-dives/add-credentials-to-powershell-functions) (thanks @joshduffney)

- Documentation maintenance
  - Updates for 7.1-rc content
  - Updated all article descriptions to improve SEO

- GitHub stats
  - 61 PRs merged (7 from Community)
  - 49 issues opened (42 from Community)
  - 61 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|  GitHub Id   | PRs merged | Issues opened |
| ------------ | :--------: | :-----------: |
| doctordns    |     1      |               |
| escape208    |     1      |               |
| nickdevore   |     1      |               |
| fsackur      |     1      |               |
| Duffney      |     1      |               |
| skycommand   |     1      |               |
| yecril71pl   |     1      |               |
| mklement0    |            |       3       |
| Abdullah0820 |            |       2       |

## 2020-September

- Documentation maintenance
  - Updates for 7.1-preview content

- Community presentation
  - How to contribute to Docs for RTPUG - https://www.youtube.com/watch?v=0_DEB61YOMc

- GitHub stats
  - 41 PRs merged (9 from Community)
  - 52 issues opened (47 from Community)
  - 51 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id     | PRs merged | Issues opened |
| ---------------- | :--------: | :-----------: |
| doctordns        |     1      |               |
| fatherjack       |     1      |               |
| goforgold        |     1      |               |
| jonathanweinberg |     1      |               |
| kvprasoon        |     1      |               |
| skycommand       |     1      |               |
| springcomp       |     1      |               |
| themichaelbender |     1      |               |
| toddryan         |     1      |               |
| mklement0        |            |      13       |
| setpeetrike      |            |       2       |

## 2020-August

- New PowerShell documentation
  - [About_Calculated_Properties](/powershell/module/microsoft.powershell.core/about/about_calculated_properties)
  - [Writing Progress across multiple threads with Foreach Parallel](/powershell/scripting/learn/deep-dives/write-progress-across-multiple-threads)
- Documentation maintenance
  - Updates for 7.1-preview content

- GitHub stats
  - 69 PRs merged (26 from Community)
  - 68 issues opened (49 from Community)
  - 58 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|    GitHub Id     | PRs merged | Issues opened |
| ---------------- | :--------: | :-----------: |
| sethvs           |     10     |       2       |
| yecril71pl       |     10     |               |
| mklement0        |     1      |       7       |
| springcomp       |     1      |       2       |
| SquirrelAssassin |            |       2       |
| thorstenbutz     |            |       2       |
| aetos382         |     1      |               |
| crumdev          |     1      |               |
| joshSi           |     1      |               |
| kmoad            |     1      |               |

## 2020-July

- New PowerShell documentation
  - Resurrected old [ETS docs](/powershell/scripting/developer/ets/overview) - 7 articles added
  - Added article about [creating updateable help using PlatyPS](https://learn.microsoft.com/en-us/powershell/utility-modules/platyps/create-help-using-platyps)
- Documentation maintenance
  - Updates for 7.1-preview content
  - Updated page header - simplified menu choices and added a download button
  - Fixed several `Update-Help` issues
    - Help for PSDesiredStateConfiguration and ThreadJob modules now downloads
    - Published updateable help for PowerShell 7.1 preview
    - Updateable help for PowerShell 5.1 now includes About topics

- GitHub stats
  - 99 PRs merged (29 from Community)
  - 51 issues opened (44 from Community)
  - 71 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filing
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| yecril71pl     |     10     |       3       |
| sethvs         |     10     |               |
| springcomp     |     3      |       2       |
| txtor          |     2      |       1       |
| baardhermansen |     1      |               |
| skycommand     |     1      |               |
| srjennings     |     1      |               |
| xtqqczze       |     1      |               |
| mklement0      |            |       3       |
| Allexxann      |            |       2       |
| sharpninja     |            |       2       |
| XuHeng1021     |            |       2       |

## 2020-June

- New PowerShell documentation
  - Published new [PowerShell 101](../learn/ps101/00-introduction.md) content contributed by Mike F.
    Robbins
  - Added two recent blog posts from Rob Holt to the **Scripting and development** docs
    - [Choosing the right PowerShell NuGet package for your .NET project](/powershell/scripting/dev-cross-plat/choosing-the-right-nuget-package)
    - [Resolving PowerShell module assembly dependency conflicts](/powershell/scripting/dev-cross-plat/resolving-dependency-conflicts)
- Documentation maintenance
  - Archived older content to [https://aka.ms/PSLegacyDocs](https://aka.ms/PSLegacyDocs)
    - PowerShell Web Access SDK content
    - PowerShell Workflows SDK content
  - Updates for 7.1-preview content

- GitHub stats
  - 83 PRs merged (15 from Community)
  - 68 issues opened (52 from Community)
  - 74 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filling
issues. Thank you!

|   GitHub Id   | PRs merged | Issues opened |
| ------------- | :--------: | :-----------: |
| doctordns     |     3      |               |
| gabrielmccoll |     2      |               |
| adrianhale    |     1      |               |
| aisbergde     |     1      |               |
| beatcracker   |     1      |               |
| bergmeister   |     1      |               |
| DarioArzaba   |     1      |               |
| gforceg       |     1      |               |
| jpomfret      |     1      |               |
| Karl-WE       |     1      |               |
| signalwarrant |     1      |               |
| skycommand    |     1      |               |
| tkhadimullin  |     1      |               |
| johnkberry    |            |       2       |
| juvtib        |            |       2       |
| mklement0     |            |       2       |
| Sagatboy33    |            |       4       |

## 2020-May

- New PowerShell documentation
  - Created a new [Deep dives](../learn/deep-dives/overview.md) section containing content from
    community contributor Kevin Marquette
    - [Everything you want to know about arrays](../learn/deep-dives/everything-about-arrays.md)
    - [Everything you want to know about hashtables](../learn/deep-dives/everything-about-hashtable.md)
    - [Everything you want to know about PSCustomObject](../learn/deep-dives/everything-about-pscustomobject.md)
    - [Everything you want to know about string substitution](../learn/deep-dives/everything-about-string-substitutions.md)
    - [Everything you want to know about if/then/else](../learn/deep-dives/everything-about-if.md)
    - [Everything you want to know about switch](../learn/deep-dives/everything-about-switch.md)
    - [Everything you want to know about exceptions](../learn/deep-dives/everything-about-exceptions.md)
    - [Everything you want to know about $null](../learn/deep-dives/everything-about-null.md)
    - [Everything you want to know about ShouldProcess](../learn/deep-dives/everything-about-shouldprocess.md)
    - [How to create a Standard Library binary module](../dev-cross-plat/create-standard-library-binary-module.md)
  - Published the [PowerShell 7.0 .NET API](/dotnet/api/?view=powershellsdk-7.0.0&preserve-view=true)
    reference
  - `Update-Help -Force` for PowerShell 5.1 now downloads updated content for the core PowerShell
    modules
- Documentation maintenance
  - Major reorganization of the Table of Contents
    - New content under **Learning PowerShell**
    - Windows PowerShell 5.1 content collected in one location
  - Archived older content to [https://aka.ms/PSLegacyDocs](https://aka.ms/PSLegacyDocs)
    - PowerShell Web Access
    - PowerShell Workflows Guide
  - Updates for 7.1-preview content

- GitHub stats
  - 81 PRs merged (21 from Community)
  - 61 issues opened (53 from Community)
  - 64 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filling
issues. Thank you!

|   GitHub Id    | PRs merged | Issues opened |
| -------------- | :--------: | :-----------: |
| nschonni       |     10     |               |
| xtqqczze       |     2      |       1       |
| kilasuit       |     1      |       1       |
| davidseibel    |     1      |               |
| doctordns      |     1      |               |
| jhoffmann271   |     1      |               |
| KevinMarquette |     1      |               |
| klitztuch      |     1      |               |
| markojorge     |     1      |               |
| perjahn        |     1      |               |
| schuelermine   |     1      |               |
| jsilverm       |            |       7       |
| mklement0      |            |       5       |
| cam1170        |            |       2       |
| JustinGrote    |            |       2       |
| peetrike       |            |       2       |

## 2020-April

- New documents
  - PowerShell documentation
    - [Using Experimental Features](/powershell/scripting/whats-new/experimental-features)
    - [about_PSModulePath](/powershell/module/microsoft.powershell.core/about/about_psmodulepath)
  - Wiki articles
    - [The case for and against Invoke-Expression](https://github.com/MicrosoftDocs/PowerShell-Docs/wiki/The-case-for-and-against-Invoke-Expression)
    - [Variables can be assigned values as part of an expression (with limitations)](https://github.com/MicrosoftDocs/PowerShell-Docs/wiki/Variables-can-be-assigned-values-as-part-of-an-expression-(with-limitations))

- Documentation maintenance
  - Now publishing updates to Microsoft Learn on a daily schedule
    - Monday-Friday 3pm Redmond Time (UTC-8)
  - Restructured the Community content
  - Many editorial cleanups
  - Updated Contributor Guide
    - Clarified some formatting rules
    - New information about table formatting

- GitHub stats
  - 74 PRs merged (8 from Community)
  - 79 issues opened (71 from Community)
  - 102 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filling
issues. Thank you!

|   GitHub Id   | PRs merged | Issues opened |
| ------------- | :--------: | :-----------: |
| ScSurber      |     1      |       1       |
| alexandair    |     1      |               |
| bmkaiser      |     1      |               |
| hyoshioka0128 |     1      |               |
| jpomfret      |     1      |               |
| raydixon      |     1      |               |
| signalwarrant |     1      |               |
| mklement0     |            |       8       |
| reinierk      |            |       3       |
| scabon        |            |       2       |
| Abdullah0820  |            |       2       |
| awooga        |            |       2       |
| Damag3d       |            |       2       |
| Fiasco123     |            |       2       |
| Jasonthurston |            |       2       |

## 2020-March

- New documents
  - The PowerShell Docs community pages
    - [Community resources](/powershell/scripting/community/community-support) page
    - [What's new in PowerShell Docs](#2020-march) page (this page)
    - [PowerShell Infographic](https://github.com/MicrosoftDocs/PowerShell-Docs/blob/main/assets/PowerShell_7_Infographic.pdf)
      added to the Digital Art page
    - [PowerShell-Doc contributor guide](/powershell/scripting/community/contributing/overview)
  - New PowerShell content
    - [Migrating from Windows PowerShell 5.1 to PowerShell 7](/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7)
    - [PowerShell 7 module compatibility list](/PowerShell/scripting/whats-new/module-compatibility)
    - [Using PowerShell in Docker](/powershell/scripting/install/powershell-in-docker)
  - New Wiki content
    - [PowerShell prevents exceptions for non existent keys for types that implement IDictionary TKey, TValue](https://github.com/MicrosoftDocs/PowerShell-Docs/wiki/PowerShell-prevents-exceptions-for-non-existent-keys-for-types-that-implement-IDictionary-TKey,-TValue-)
    - [PowerShell's treatment of namespaces is case insensitive but case preserving](https://github.com/MicrosoftDocs/PowerShell-Docs/wiki/PowerShell's-treatment-of-namespaces-is-case-insensitive-but-case-preserving)

- Documentation maintenance
  - Massive cleanup of broken links
  - Cleanup of old and duplicate issues

- GitHub stats
  - 100 PRs merged (14 from Community)
  - 68 issues opened (56 from Community)
  - 109 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filling
issues. Thank you!

- k-takai - 7 PRs
- mklement0 - 5 issues
- juvtib - 4 issues
- iSazonov - 3 issue
- doctordns - 2 issues
- mdorantesm - 2 issues
- qt3m45su0najc7 - 2 issues

## 2020-February

- New documents
  - [about_Parameter_Sets](/powershell/module/microsoft.powershell.core/about/about_parameter_sets)
  - [Release history of modules and cmdlets](/powershell/scripting/whats-new/cmdlet-versions)
- PowerShell 7 documentation updates
- Updates to address issues
- Ran PlatyPS to verify parameter info for all cmdlets and versions
- GitHub stats
  - 52 PRs merged (9 from Community)
  - 49 issues opened (42 from Community)
  - 55 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filling
issues. Thank you!

- Maamue - 2 PRs
- doctordns - 2 PRs
- mklement0 - 4 issues
- he852100 - 3 issues
- VectorBCO - 2 issues
- metablaster - 2 issues

## 2020-January

- New documents
  - [about_Windows_PowerShell_Compatibility](/powershell/module/microsoft.powershell.core/about/about_Windows_PowerShell_Compatibility)
- PowerShell 7 documentation updates
- Updates to address issues
- GitHub stats
  - 58 PRs merged (7 from Community)
  - 57 issues opened (43 from Community)
  - 70 issues closed

### Top Community Contributors

The following people have contributed to PowerShell docs by submitting pull requests or filling
issues. Thank you!

- Makovec - 3 PRs
- mklement0 - 9 issues
- mvadu - 2 issues
- razos - 2 issues
- VLoub - 2 issues
- doctordns - 2 issues

# /./reference/community/digital-art.md

    ---
    author: sdwheeler
    description: Download PowerShell related artwork and posters
    ms.author: sewhee
    ms.date: 06/28/2023
    title: PowerShell Digital Art
    ---
# PowerShell Digital Art

_The legends are true! The powerful shell that ensures safe passage to the cloud. But how?_

Please enjoy the digital artwork linked below. Demonstrate to your peers that _you have been
entrusted with the Scrolls of Monad!_

## PowerShell Infographics

- [PowerShell Infographic][09]

## Comic

- [PowerShell Hero Comic (High resolution)][02]
- [PowerShell Hero Comic (Print resolution)][03]
- [PowerShell Hero Comic (Web resolution)][04]

## Wallpaper

- [PowerShell Hero Comic Wallpaper (4k resolution)][06]
- [PowerShell Hero Pink Wallpaper (4k resolution)][07]
- [PowerShell Hero White Wallpaper (4k resolution)][08]

## Poster

- [PowerShell Hero Poster][05]

## PowerShell Hero

- [PowerShell Hero Image][01]

### Microsoft PowerShell Logo and Digital Art Guidelines

As a general rule, third parties may not use Microsoft logos and artwork without permission. The
following are the limited circumstances under which third parties may use the Microsoft PowerShell
logo and artwork.

- For non-commercial purposes (documentation or on a website) that reference your connection with
  Microsoft PowerShell.

Any uses outside of these guidelines as determined by Microsoft is strictly prohibited. Do not use
the Microsoft PowerShell logo or artwork in products, product packaging, or other business services
for which a formal license is required.

Microsoft reserves the right in its sole discretion to terminate or modify permission to display the
logo or artwork, and may request that third parties modify or delete any use of the logo or artwork
that, in Microsoft's sole judgment, does not comply with these guidelines or might otherwise impair
Microsoft's rights in the logo.

<!-- link references -->
[01]: https://aka.ms/powershellhero
[02]: https://aka.ms/powershellherocomic_highres
[03]: https://aka.ms/powershellherocomic_print
[04]: https://aka.ms/powershellherocomic_web
[05]: https://aka.ms/powershellheroposter
[06]: https://aka.ms/powershellherowallpaper
[07]: https://aka.ms/powershellherowallpaper1
[08]: https://aka.ms/powershellherowallpaper2
[09]: https://github.com/MicrosoftDocs/PowerShell-Docs/blob/main/assets/PowerShell_7_Infographic.pdf

# /./reference/dev-cross-plat/vscode/using-vscode.md

    ---
    description: Using Visual Studio Code for PowerShell Development
    ms.date: 09/09/2022
    title: Using Visual Studio Code for PowerShell Development
    ---

# Using Visual Studio Code for PowerShell Development

[Visual Studio Code][01] (VS Code) is a cross-platform script editor by Microsoft. Together with
the [PowerShell extension][02], it provides a rich and interactive script editing experience,
making it easier to write reliable PowerShell scripts. Visual Studio Code with the PowerShell
extension is the recommended editor for writing PowerShell scripts.

It supports the following PowerShell versions:

- PowerShell 7.2 and higher (Windows, macOS, and Linux)
- Windows PowerShell 5.1 (Windows-only) with .NET Framework 4.8

> [!NOTE]
> Visual Studio Code isn't the same as [Visual Studio][03].

## Getting started

Before you begin, make sure PowerShell exists on your system. For modern workloads on Windows,
macOS, and Linux, see the following links:

- [Installing PowerShell on Linux][04]
- [Installing PowerShell on macOS][05]
- [Installing PowerShell on Windows][06]

For traditional Windows PowerShell workloads, see [Installing Windows PowerShell][07].

> [!IMPORTANT]
> The [Windows PowerShell ISE][08] is still available for Windows. However, it's no longer in
> active feature development. The ISE only works with PowerShell 5.1 and older. As a component of
> Windows, it continues to be officially supported for security and high-priority servicing fixes.
> we've no plans to remove the ISE from Windows.

## Install VS Code and the PowerShell Extension

1. Install Visual Studio Code. For more information, see the overview
   [Setting up Visual Studio Code][09].

   There are installation instructions for each platform:

   - [Running Visual Studio Code on Windows][10]
   - [Running Visual Studio Code on macOS][11]
   - [Running Visual Studio Code on Linux][12]

1. Install the PowerShell Extension.

   1. Launch the VS Code app by typing `code` in a console or `code-insiders` if you installed
      Visual Studio Code Insiders.
   1. Launch **Quick Open** on Windows or Linux by pressing <kbd>Ctrl</kbd>+<kbd>P</kbd>. On macOS,
      press <kbd>Cmd</kbd>+<kbd>P</kbd>.
   1. In Quick Open, type `ext install powershell` and press **Enter**.
   1. The **Extensions** view opens on the Side Bar. Select the PowerShell extension from Microsoft.
   1. Click the **Install** button on the PowerShell extension from Microsoft.
   1. After the install, if you see the **Install** button turn into **Reload**, Click on
      **Reload**.
   1. After VS Code has reloaded, you're ready for editing.

For example, to create a new file, click **File > New**. To save it, click **File > Save** and then
provide a filename, such as `HelloWorld.ps1`. To close the file, click the `X` next to the filename.
To exit VS Code, **File > Exit**.

### Installing the PowerShell Extension on Restricted Systems

Some systems are set up to require validation of all code signatures. You may receive the following
error:

```
Language server startup failed.
```

This problem can occur when PowerShell's execution policy is set by Windows Group Policy. To
manually approve PowerShell Editor Services and the PowerShell extension for VS Code, open a
PowerShell prompt and run the following command:

```powershell
Import-Module $HOME\.vscode\extensions\ms-vscode.powershell*\modules\PowerShellEditorServices\PowerShellEditorServices.psd1
```

You're prompted with **Do you want to run software from this untrusted publisher?** Type `A` to run
the file. Then, open VS Code and verify that the PowerShell extension is functioning properly. If
you still have problems getting started, let us know in a [GitHub issue][13].

### Choosing a version of PowerShell to use with the extension

With PowerShell installing side-by-side with Windows PowerShell, it's now possible to use a specific
version of PowerShell with the PowerShell extension. This feature looks at a few well-known paths on
different operating systems to discover installations of PowerShell.

Use the following steps to choose the version:

1. Open the **Command Palette** on Windows or Linux with
   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>. On macOS, use
   <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>.
1. Search for **Session**.
1. Click on **PowerShell: Show Session Menu**.
1. Choose the version of PowerShell you want to use from the list.

If you installed PowerShell to a non-typical location, it might not show up initially in the Session
Menu. You can extend the session menu by [adding your own custom paths][14] as described below.

The PowerShell session menu can also be accessed from the `{}` icon in the bottom right corner of
status bar. Hovering on or selecting this icon displays a shortcut to the session menu and a small
pin icon. If you select the pin icon, the version number is added to the status bar. The version
number is a shortcut to the session menu requiring fewer clicks.

> [!NOTE]
> Pinning the version number replicates the behavior of the extension in versions of VS Code before
> 1.65. The 1.65 release of VS Code changed the APIs the PowerShell extension uses and standardized
> the status bar for language extensions.

## Configuration settings for Visual Studio Code

First, if you're not familiar with how to change settings in VS Code, we recommend reading
[Visual Studio Code's settings][15] documentation.

After reading the documentation, you can add configuration settings in `settings.json`.

```json
{
    "editor.renderWhitespace": "all",
    "editor.renderControlCharacters": true,
    "files.trimTrailingWhitespace": true,
    "files.encoding": "utf8bom",
    "files.autoGuessEncoding": true
}
```

If you don't want these settings to affect all files types, VS Code also allows per-language
configurations. Create a language-specific setting by putting settings in a `[<language-name>]`
field. For example:

```json
{
    "[powershell]": {
        "files.encoding": "utf8bom",
        "files.autoGuessEncoding": true
    }
}
```

> [!TIP]
> For more information about file encoding in VS Code, see
> [Understanding file encoding][16]. Also, check out
> [How to replicate the ISE experience in VS Code][17] for other tips on how to configure VS
> Code for PowerShell editing.

### Adding your own PowerShell paths to the session menu

You can add other PowerShell executable paths to the session menu through the
[Visual Studio Code setting][18]:
`powershell.powerShellAdditionalExePaths`.

You can do this using the GUI:

1. From the **Command Palette** search for and select **Open User Settings**. Or use the
   keyboard shortcut on Windows or Linux <kbd>Ctrl</kbd>+<kbd>,</kbd>. On macOS, use
   <kbd>Cmd</kbd>+<kbd>,</kbd>.
1. In the **Settings** editor, search for **PowerShell Additional Exe Paths**.
1. Click **Add Item**.
1. For the **Key** (under **Item**), provide your choice of name for this additional PowerShell
   installation.
1. For the **Value** (under **Value**), provide the absolute path to the executable itself.

You can add as many additional paths as you like. The added items show up in the session menu with
the given key as the name.

Alternatively you can add key-value pairs to the object
`powershell.powerShellAdditionalExePaths` in your `settings.json`:

```json
{
    "powershell.powerShellAdditionalExePaths": {
        "Downloaded PowerShell": "C:/Users/username/Downloads/PowerShell/pwsh.exe",
        "Built PowerShell": "C:/Users/username/src/PowerShell/src/powershell-win-core/bin/Debug/net6.0/win7-x64/publish/pwsh.exe"
    },
}
```

> [!NOTE]
> Prior to version 2022.5.0 of the extension, this setting was a list of objects with the required
> keys `exePath` and `versionName`. A breaking change was introduced to support configuration via
> GUI. If you had previously configured this setting, please convert it the new format. The value
> given for `versionName` is now the **Key**, and the value given for `exePath` is now the
> **Value**. You can do this more easily by resetting the value and using the Settings interface.

To set the default PowerShell version, set the value `powershell.powerShellDefaultVersion` to the
text displayed in the session menu (the text used for the key):

```json
{
    "powershell.powerShellAdditionalExePaths": {
        "Downloaded PowerShell": "C:/Users/username/Downloads/PowerShell/pwsh.exe",
    },
    "powershell.powerShellDefaultVersion": "Downloaded PowerShell",
}
```

After you've configured this setting, restart VS Code or to reload the current VS Code window from
the **Command Palette**, type `Developer: Reload Window`.

If you open the session menu, you now see your additional PowerShell installations.

> [!TIP]
> If you build PowerShell from source, this is a great way to test out your local build of
> PowerShell.

## Debugging with Visual Studio Code

### No-workspace debugging

In VS Code version 1.9 (or higher), you can debug PowerShell scripts without opening the folder that
contains the PowerShell script.

1. Open the PowerShell script file with **File > Open File...**
1. Set a breakpoint - select a line then press <kbd>F9</kbd>
1. Press <kbd>F5</kbd> to start debugging

You should see the Debug actions pane appear that allows you to break into the debugger, step,
resume, and stop debugging.

### Workspace debugging

Workspace debugging refers to debugging in the context of a folder that you've opened from the
**File** menu using **Open Folder...**. The folder you open is typically your PowerShell project
folder or the root of your Git repository. Workspace debugging allows you to define multiple debug
configurations other than just debugging the currently open file.

Follow these steps to create a debug configuration file:

1. Open the **Debug** view on Windows or Linux by pressing
   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>D</kbd>. On macOS, press
   <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>D</kbd>.
1. Click the **create a launch.json file** link.
1. From the **Select Environment** prompt, choose **PowerShell**.
1. Choose the type of debugging you'd like to use:

   - **Launch Current File** - Launch and debug the file in the currently active editor window
   - **Launch Script** - Launch and debug the specified file or command
   - **Interactive Session** - Debug commands executed from the Integrated Console
   - **Attach** - Attach the debugger to a running PowerShell Host Process

VS Code creates a directory and a file `.vscode\launch.json` in the root of your workspace folder to
store the debug configuration. If your files are in a Git repository, you typically want to commit
the `launch.json` file. The contents of the `launch.json` file are:

```json
{
  "version": "0.2.0",
  "configurations": [
      {
          "type": "PowerShell",
          "request": "launch",
          "name": "PowerShell Launch (current file)",
          "script": "${file}",
          "args": [],
          "cwd": "${file}"
      },
      {
          "type": "PowerShell",
          "request": "attach",
          "name": "PowerShell Attach to Host Process",
          "processId": "${command.PickPSHostProcess}",
          "runspaceId": 1
      },
      {
          "type": "PowerShell",
          "request": "launch",
          "name": "PowerShell Interactive Session",
          "cwd": "${workspaceRoot}"
      }
  ]
}
```

This file represents the common debug scenarios. When you open this file in the editor, you see an
**Add Configuration...** button. You can click this button to add more PowerShell debug
configurations. One useful configuration to add is **PowerShell: Launch Script**. With this
configuration, you can specify a file containing optional arguments that are used whenever you press
<kbd>F5</kbd> no matter which file is active in the editor.

After the debug configuration is established, you can select the configuration you want to use
during a debug session. Select a configuration from the debug configuration drop-down in the
**Debug** view's toolbar.

## Troubleshooting the PowerShell extension

If you experience any issues using VS Code for PowerShell script development, see the
[troubleshooting guide][19] on GitHub.

## Useful resources

There are a few videos and blog posts that may be helpful to get you started using the PowerShell
extension for VS Code:

### Videos

- [Using Visual Studio Code as Your Default PowerShell Editor][20]
- [Visual Studio Code: deep dive into debugging your PowerShell scripts][21]

### Blog posts

- [PowerShell Extension][22]
- [Write and debug PowerShell scripts in Visual Studio Code][23]
- [Debugging Visual Studio Code Guidance][24]
- [Debugging PowerShell in Visual Studio Code][25]
- [Get started with PowerShell development in Visual Studio Code][26]
- [Visual Studio Code editing features for PowerShell development - Part 1][27]
- [Visual Studio Code editing features for PowerShell development - Part 2][28]
- [Debugging PowerShell script in Visual Studio Code - Part 1][29]
- [Debugging PowerShell script in Visual Studio Code - Part 2][30]

## PowerShell extension project source code

The PowerShell extension's source code can be found on [GitHub][31].

If you're interested in contributing, Pull Requests are greatly appreciated. Follow along with the
[developer documentation][32] on GitHub to get started.

<!-- Link references -->
[01]: https://code.visualstudio.com/
[02]: https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell
[03]: https://visualstudio.microsoft.com/
[04]: ../../install/Installing-PowerShell-on-Linux.md
[05]: ../../install/Installing-PowerShell-on-macOS.md
[06]: ../../install/Installing-PowerShell-on-Windows.md
[07]: ../../install/Installing-Windows-PowerShell.md
[08]: ../../windows-powershell/ise/Introducing-the-Windows-PowerShell-ISE.md
[09]: https://code.visualstudio.com/Docs/setup/setup-overview
[10]: https://code.visualstudio.com/docs/setup/windows
[11]: https://code.visualstudio.com/docs/setup/mac
[12]: https://code.visualstudio.com/docs/setup/linux
[13]: https://github.com/PowerShell/vscode-powershell/issues
[14]: #adding-your-own-powershell-paths-to-the-session-menu
[15]: https://code.visualstudio.com/docs/getstarted/settings
[16]: understanding-file-encoding.md
[17]: How-To-Replicate-the-ISE-Experience-In-VSCode.md
[18]: https://code.visualstudio.com/docs/getstarted/settings
[19]: https://github.com/PowerShell/vscode-powershell/blob/master/docs/troubleshooting.md
[20]: https://youtu.be/bGn45vIeAMM
[21]: https://youtu.be/cSbIXmlkr8o
[22]: https://learn.microsoft.com/archive/blogs/cdndevs/visual-studio-code-powershell-extension
[23]: https://devblogs.microsoft.com/powershell/announcing-powershell-language-support-for-visual-studio-code-and-more/
[24]: https://johnpapa.net/debugging-with-visual-studio-code/
[25]: https://github.com/PowerShell/vscode-powershell/tree/master/examples
[26]: https://devblogs.microsoft.com/scripting/get-started-with-powershell-development-in-visual-studio-code/
[27]: https://devblogs.microsoft.com/scripting/visual-studio-code-editing-features-for-powershell-development-part-1/
[28]: https://devblogs.microsoft.com/scripting/visual-studio-code-editing-features-for-powershell-development-part-2/
[29]: https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/
[30]: https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/
[31]: https://github.com/PowerShell/vscode-powershell
[32]: https://github.com/PowerShell/vscode-powershell/blob/master/docs/development.md

# /./reference/dev-cross-plat/vscode/How-To-Replicate-the-ISE-Experience-In-VSCode.md

    ---
    description: How to replicate the ISE experience in Visual Studio Code
    ms.date: 11/16/2022
    title: How to replicate the ISE experience in Visual Studio Code
    ---

# How to replicate the ISE experience in Visual Studio Code

While the PowerShell extension for VS Code doesn't seek complete feature parity with the PowerShell
ISE, there are features in place to make the VS Code experience more natural for users of the ISE.

This document tries to list settings you can configure in VS Code to make the user experience a bit
more familiar compared to the ISE.

## ISE Mode

> [!NOTE]
> This feature is available in the PowerShell Preview extension since version 2019.12.0 and in the
> PowerShell extension since version 2020.3.0.

The easiest way to replicate the ISE experience in Visual Studio Code is by turning on "ISE Mode".
To do this, open the command palette (<kbd>F1</kbd> OR <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>
OR <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> on macOS) and type in "ISE Mode". Select
"PowerShell: Enable ISE Mode" from the list.

This command automatically applies the settings described below The result looks like this:

![Visual Studio Code in ISE Mode][09]

## ISE Mode configuration settings

ISE Mode makes the following changes to VS Code settings.

- Key bindings

  |               Function                |         ISE Binding          |              VS Code Binding                |
  | ------------------------------------- | ---------------------------- | ------------------------------------------- |
  | Interrupt and break debugger          | <kbd>Ctrl</kbd>+<kbd>B</kbd> | <kbd>F6</kbd>                               |
  | Execute current line/highlighted text | <kbd>F8</kbd>                | <kbd>F8</kbd>                               |
  | List available snippets               | <kbd>Ctrl</kbd>+<kbd>J</kbd> | <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>J</kbd> |

  > [!NOTE]
  > You can [configure your own key bindings][09] in VS Code as well.

- Simplified ISE-like UI

  If you're looking to simplify the Visual Studio Code UI to look more closely to the UI of the ISE,
  apply these two settings:

  ```json
  "workbench.activityBar.visible": false,
  "debug.openDebug": "neverOpen",
  ```

  These settings hide the "Activity Bar" and the "Debug Side Bar" sections shown inside the red box
  below:

  ![Highlighted section includes Activity Bar and Debug Side Bar][07]

  The end result looks like this:

  ![Simplified view of VS Code][08]

- Tab completion

  To enable more ISE-like tab completion, add this setting:

  ```json
  "editor.tabCompletion": "on",
  ```

- No focus on console when executing

  To keep the focus in the editor when you execute with <kbd>F8</kbd>:

  ```json
  "powershell.integratedConsole.focusConsoleOnExecute": false
  ```

  The default is `true` for accessibility purposes.

- Don't start integrated console on startup

  To stop the integrated console on startup, set:

  ```json
  "powershell.integratedConsole.showOnStartup": false
  ```

  > [!NOTE]
  > The background PowerShell process still starts to provide IntelliSense, script analysis, symbol
  > navigation, etc., but the console won't be shown.

- Assume files are PowerShell by default

  To make new/untitled files, register as PowerShell by default:

  ```json
  "files.defaultLanguage": "powershell",
  ```

- Color scheme

  There are a number of ISE themes available for VS Code to make the editor look much more like the
  ISE.

  In the [Command Palette][01] type `theme` to get `Preferences: Color Theme` and press
  <kbd>Enter</kbd>. In the drop-down list, select `PowerShell ISE`.

  You can set this theme in the settings with:

  ```json
  "workbench.colorTheme": "PowerShell ISE",
  ```

- PowerShell Command Explorer

  Thanks to the work of [@corbob][04], the PowerShell extension has the beginnings of its own
  command explorer.

  In the [Command Palette][01], enter `PowerShell Command Explorer` and press <kbd>Enter</kbd>.

- Open in the ISE

  If you want to open a file in the Windows PowerShell ISE anyway, open the [Command Palette][01],
  search for "open in ise", then select **PowerShell: Open Current File in PowerShell ISE**.

## Other resources

- 4sysops has [a great article][02] on configuring VS Code to be more like the ISE.
- Mike F Robbins has [a great post][06] on setting up VS Code.

## VS Code Tips

- Command Palette

  The Command Palette is handy way of executing commands in VS Code. Open the command palette using
  <kbd>F1</kbd> OR <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> OR
  <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> on macOS.

  For more information, see [the VS Code documentation][03].

- Hide the Debug Console panel

  The PowerShell extension uses the built-in debugging interface of VS Code to allow for debugging
  of PowerShell scripts and modules. However, the extension does not use the Debug Console panel. To
  hide the Debug Console, right-click on **Debug Console** and select **Hide 'Debug Console'**.

  ![Screenshot show how to hide the Debug Console panel.][10]

  For more information about debugging PowerShell with Visual Studio Code, see [Using VS Code][11].

## More settings

If you know of more ways to make VS Code feel more familiar for ISE users, contribute to this doc.
If there's a compatibility configuration you're looking for, but you can't find any way to enable
it, [open an issue][05] and ask away!

We're always happy to accept PRs and contributions as well!

<!-- link references -->
[01]: #vs-code-tips
[02]: https://4sysops.com/archives/make-visual-studio-code-look-and-behave-like-powershell-ise/
[03]: https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette
[04]: https://github.com/corbob
[05]: https://github.com/PowerShell/VSCode-powershell/issues/new/choose
[06]: https://mikefrobbins.com/2017/08/24/how-to-install-visual-studio-code-and-configure-it-as-a-replacement-for-the-powershell-ise/
[07]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/How-To-Replicate-the-ISE-Experience-In-VSCode/1-highlighted-sidebar.png
[08]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/How-To-Replicate-the-ISE-Experience-In-VSCode/2-simplified-ui.png
[09]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/How-To-Replicate-the-ISE-Experience-In-VSCode/3-ise-mode.png
[10]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/How-To-Replicate-the-ISE-Experience-In-VSCode/4-debug-console.png
[11]: using-vscode.md#debugging-with-visual-studio-code

# /./reference/dev-cross-plat/vscode/Using-VSCode-for-Remote-Editing-and-Debugging.md

    ---
    description: Using Visual Studio Code for remote editing and debugging
    ms.date: 11/16/2022
    title: Using Visual Studio Code for remote editing and debugging
    ---
# Using Visual Studio Code for remote editing and debugging

For those of you that are familiar with the ISE, you may recall that you could run `psedit file.ps1`
from the integrated console to open files - local or remote - right in the ISE.

This feature is also available in the PowerShell extension for VSCode. This guide shows you how to
do it.

## Prerequisites

This guide assumes that you have:

- A remote resource (ex: a VM, a container) that you have access to
- PowerShell running on it and the host machine
- VSCode and the PowerShell extension for VSCode

This feature works on PowerShell and Windows PowerShell.

This feature also works when connecting to a remote machine via WinRM, PowerShell Direct, or SSH. If
you want to use SSH, but are using Windows, check out the [Win32 version of SSH][03]!

> [!IMPORTANT]
> The `Open-EditorFile` and `psedit` commands only work in the **PowerShell Integrated Console**
> created by the PowerShell extension for VSCode.

## Usage examples

These examples show remote editing and debugging from a MacBook Pro to an Ubuntu VM running in
Azure. The process is identical on Windows.

### Local file editing with Open-EditorFile

With the PowerShell extension for VSCode started and the PowerShell Integrated Console opened, we
can type `Open-EditorFile foo.ps1` or `psedit foo.ps1` to open the local foo.ps1 file right in the
editor.

![Open-EditorFile foo.ps1 works locally][04]

> [!NOTE]
> The file `foo.ps1` must already exist.

From there, we can:

- Add breakpoints to the gutter

  ![Adding a breakpoint to the gutter][05]

- Hit F5 to debug the PowerShell script.

  ![debugging the local PowerShell script][06]

While debugging, you can interact with the debug console, check out the variables in the scope on
the left, and all the other standard debugging tools.

### Remote file editing with Open-EditorFile

Now let's get into remote file editing and debugging. The steps are nearly the same, there's just
one thing we need to do first - enter our PowerShell session to the remote server.

There's a cmdlet for to do so. It's called `Enter-PSSession`.

In short:

- `Enter-PSSession -ComputerName foo` starts a session via WinRM
- `Enter-PSSession -ContainerId foo` and `Enter-PSSession -VmId foo` start a session via PowerShell
  Direct
- `Enter-PSSession -HostName foo` starts a session via SSH

For more information, see the documentation for
[Enter-PSSession][01].

Since we're remoting to an Ubuntu VM in Azure, we're using SSH.

First, in the Integrated Console, run `Enter-PSSession`. You're connected to the remote session when
`[<hostname>]` shows up to the left of your prompt.

![Call Enter-PSSession to connect to a remote session][07]

Now, we can do the same steps as if we're editing a local script.

1. Run `Open-EditorFile test.ps1` or `psedit test.ps1` to open the remote `test.ps1` file

   ![Edit the script on the remote system][08]

1. Edit the file/set breakpoints

   ![Edit and set breakpoints][09]

1. Start debugging (F5) the remote file

   ![Debugging the remote script][10]

If you have any problems, you can open issues in the [GitHub repo][02].

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/enter-pssession
[02]: https://github.com/powershell/vscode-powershell
[03]: https://github.com/PowerShell/Win32-OpenSSH
[04]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/Using-VSCode-for-Remote-Editing-and-Debugging/1-open-local-file.png
[05]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/Using-VSCode-for-Remote-Editing-and-Debugging/2-adding-breakpoint-gutter.png
[06]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/Using-VSCode-for-Remote-Editing-and-Debugging/3-local-debug.png
[07]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/Using-VSCode-for-Remote-Editing-and-Debugging/4-enter-pssession.png
[08]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/Using-VSCode-for-Remote-Editing-and-Debugging/5-open-remote-file.png
[09]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/Using-VSCode-for-Remote-Editing-and-Debugging/6-set-breakpoints.png
[10]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/Using-VSCode-for-Remote-Editing-and-Debugging/7-start-debugging.png

# /./reference/dev-cross-plat/vscode/understanding-file-encoding.md

    ---
    description: Configure file encoding in VS Code and PowerShell
    ms.date: 11/29/2023
    title: Understanding file encoding in VS Code and PowerShell
    ---
# Understanding file encoding in VS Code and PowerShell

When using VS Code to create and edit PowerShell scripts, it's important that your files are saved
using the correct character encoding format.

## What is file encoding and why is it important?

VS Code manages the interface between a human entering strings of characters into a buffer and
reading/writing blocks of bytes to the filesystem. When VS Code saves a file, it uses a text
encoding to decide what bytes each character becomes. For more information, see
[about_Character_Encoding][01].

Similarly, when PowerShell runs a script it must convert the bytes in a file to characters to
reconstruct the file into a PowerShell program. Since VS Code writes the file and PowerShell reads
the file, they need to use the same encoding system. This process of parsing a PowerShell script
goes: _bytes_ -> _characters_ -> _tokens_ -> _abstract syntax tree_ -> _execution_.

Both VS Code and PowerShell are installed with a sensible default encoding configuration. However,
the default encoding used by PowerShell has changed with the release of PowerShell 6. To ensure you
have no problems using PowerShell or the PowerShell extension in VS Code, you need to configure your
VS Code and PowerShell settings properly.

## Common causes of encoding issues

Encoding problems occur when the encoding of VS Code or your script file doesn't match the expected
encoding of PowerShell. There is no way for PowerShell to automatically determine the file encoding.

You're more likely to have encoding problems when you're using characters not in the
[7-bit ASCII character set][02]. For example:

<!-- markdownlint-disable MD038 -->
- Extended non-letter characters like em-dash (`—`), non-breaking space (` `) or left double
  quotation mark (`"`)
- Accented latin characters (`É`, `ü`)
- Non-latin characters like Cyrillic (`Д`, `Ц`)
- CJK characters (`本`, `화`, `が`)

Common reasons for encoding issues are:

- The encodings of VS Code and PowerShell haven't been changed from their defaults. For PowerShell
  5.1 and below, the default encoding is different from VS Code's.
- Another editor has opened and overwritten the file in a new encoding. This often happens with the
  ISE.
- The file is checked into source control in an encoding that's different from what VS Code or
  PowerShell expects. This can happen when collaborators use editors with different encoding
  configurations.

### How to tell when you have encoding issues

Often encoding errors present themselves as parse errors in scripts. If you find strange character
sequences in your script, this can be the problem. In the example below, an en-dash (`–`) appears as
the characters `â&euro;"`:

```Output
Send-MailMessage : A positional parameter cannot be found that accepts argument 'Testing FuseMail SMTP...'.
At C:\Users\<User>\<OneDrive>\Development\PowerShell\Scripts\Send-EmailUsingSmtpRelay.ps1:6 char:1
+ Send-MailMessage â&euro;"From $from â&euro;"To $recipient1 â&euro;"Subject $subject  ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (:) [Send-MailMessage], ParameterBindingException
    + FullyQualifiedErrorId : PositionalParameterNotFound,Microsoft.PowerShell.Commands.SendMailMessage
```

This problem occurs because VS Code encodes the character `–` in UTF-8 as the bytes
`0xE2 0x80 0x93`. When these bytes are decoded as Windows-1252, they're interpreted as the
characters `â&euro;"`.

Some strange character sequences that you might see include:

<!-- markdownlint-disable MD038 -->
- `â&euro;"` instead of `–` (an en-dash)
- `â&euro;"` instead of `—` (an em-dash)
- `Ã„2` instead of `Ä`
- `Â` instead of ` `  (a non-breaking space)
- `Ã&copy;` instead of `é`
<!-- markdownlint-enable MD038 -->

This handy [reference][28] lists the common patterns that indicate a UTF-8/Windows-1252 encoding
problem.

## How the PowerShell extension in VS Code interacts with encodings

The PowerShell extension interacts with scripts in a number of ways:

1. When scripts are edited in VS Code, the contents are sent by VS Code to the extension. The
   [Language Server Protocol][19] mandates that this content is transferred in UTF-8. Therefore, it
   isn't possible for the extension to get the wrong encoding.
1. When scripts are executed directly in the Integrated Console, they're read from the file by
   PowerShell directly. If PowerShell's encoding differs from VS Code's, something can go wrong
   here.
1. When a script that's open in VS Code references another script that isn't open in VS Code, the
   extension falls back to loading that script's content from the file system. The PowerShell
   extension defaults to UTF-8 encoding, but uses [byte-order mark][23], or BOM, detection to select
   the correct encoding.

The problem occurs when assuming the encoding of BOM-less formats (like [UTF-8][26] with no BOM
and [Windows-1252][27]). The PowerShell extension defaults to UTF-8. The extension can't
change VS Code's encoding settings. For more information, see
[issue #824][09].

## Choosing the right encoding

Different systems and applications can use different encodings:

- In .NET Standard, on the web, and in the Linux world, UTF-8 is now the dominant encoding.
- Many .NET Framework applications use [UTF-16][25]. For historical reasons, this is sometimes
  called "Unicode", a term that now refers to a broad [standard][06] that includes both UTF-8 and
  UTF-16.
- On Windows, many native applications that predate Unicode continue to use Windows-1252 by default.

Unicode encodings also have the concept of a byte-order mark (BOM). BOMs occur at the beginning of
text to tell a decoder which encoding the text is using. For multi-byte encodings, the BOM also
indicates [endianness][05] of the encoding. BOMs are designed to be bytes that rarely occur in
non-Unicode text, allowing a reasonable guess that text is Unicode when a BOM is present.

BOMs are optional and their adoption isn't as popular in the Linux world because a dependable
convention of UTF-8 is used everywhere. Most Linux applications presume that text input is encoded
in UTF-8. While many Linux applications will recognize and correctly handle a BOM, a number don't,
leading to artifacts in text manipulated with those applications.

**Therefore**:

- If you work primarily with Windows applications and Windows PowerShell, you should prefer an
  encoding like UTF-8 with BOM or UTF-16.
- If you work across platforms, you should prefer UTF-8 with BOM.
- If you work mainly in Linux-associated contexts, you should prefer UTF-8 without BOM.
- Windows-1252 and latin-1 are essentially legacy encodings that you should avoid if possible.
  However, some older Windows applications may depend on them.
- It's also worth noting that script signing is [encoding-dependent][11], meaning a change of
  encoding on a signed script will require resigning.

## Configuring VS Code

VS Code's default encoding is UTF-8 without BOM.

To set [VS Code's encoding][04], go to the VS Code settings (<kbd>Ctrl</kbd>+<kbd>,</kbd>) and set
the `"files.encoding"` setting:

```json
"files.encoding": "utf8bom"
```

Some possible values are:

- `utf8`: [UTF-8] without BOM
- `utf8bom`: [UTF-8] with BOM
- `utf16le`: Little endian [UTF-16]
- `utf16be`: Big endian [UTF-16]
- `windows1252`: [Windows-1252]

You should get a dropdown for this in the GUI view, or completions for it in the JSON view.

You can also add the following to autodetect encoding when possible:

```json
"files.autoGuessEncoding": true
```

If you don't want these settings to affect all files types, VS Code also allows per-language
configurations. Create a language-specific setting by putting settings in a `[<language-name>]`
field. For example:

```json
"[powershell]": {
    "files.encoding": "utf8bom",
    "files.autoGuessEncoding": true
}
```

You may also want to consider installing the [Gremlins tracker][18] for Visual Studio Code. This
extension reveals certain Unicode characters that easily corrupted because they're invisible or look
like other normal characters.

## Configuring PowerShell

PowerShell's default encoding varies depending on version:

- In PowerShell 6+, the default encoding is UTF-8 without BOM on all platforms.
- In Windows PowerShell, the default encoding is usually Windows-1252, which is an extension of
  [latin-1][24] (also known as ISO 8859-1).

In PowerShell 5+ you can find your default encoding with this:

```powershell
[psobject].Assembly.GetTypes() | Where-Object { $_.Name -eq 'ClrFacade'} |
  ForEach-Object {
    $_.GetMethod('GetDefaultEncoding', [System.Reflection.BindingFlags]'nonpublic,static').Invoke($null, @())
  }
```

The following [script][07] can be used to determine what encoding your PowerShell session infers for
a script without a BOM.

```powershell
$badBytes = [byte[]]@(0xC3, 0x80)
$utf8Str = [System.Text.Encoding]::UTF8.GetString($badBytes)
$bytes = [System.Text.Encoding]::ASCII.GetBytes('Write-Output "') + [byte[]]@(0xC3, 0x80) + [byte[]]@(0x22)
$path = Join-Path ([System.IO.Path]::GetTempPath()) 'encodingtest.ps1'

try
{
    [System.IO.File]::WriteAllBytes($path, $bytes)

    switch (& $path)
    {
        $utf8Str
        {
            return 'UTF-8'
            break
        }

        default
        {
            return 'Windows-1252'
            break
        }
    }
}
finally
{
    Remove-Item $path
}
```

It's possible to configure PowerShell to use a given encoding more generally using profile settings.
See the following articles:

- @mklement0's [answer about PowerShell encoding on StackOverflow][21].
- @rkeithhill's [blog post about dealing with BOM-less UTF-8 input in PowerShell][20].

It's not possible to force PowerShell to use a specific input encoding. PowerShell 5.1 and below,
running on Windows with the locale set to en-US, defaults to Windows-1252 encoding when there's no
BOM. Other locale settings may use a different encoding. To ensure interoperability, it's best to
save scripts in a Unicode format with a BOM.

> [!IMPORTANT]
> Any other tools you have that touch PowerShell scripts may be affected by your encoding choices or
> re-encode your scripts to another encoding.

### Existing scripts

Scripts already on the file system may need to be re-encoded to your new chosen encoding. In the
bottom bar of VS Code, you'll see the label UTF-8. Click it to open the action bar and select **Save
with encoding**. You can now pick a new encoding for that file. See [VS Code's encoding][04]
for full instructions.

If you need to re-encode multiple files, you can use the following script:

```powershell
Get-ChildItem *.ps1 -Recurse | ForEach-Object {
    $content = Get-Content -Path $_
    Set-Content -Path $_.Fullname -Value $content -Encoding UTF8 -PassThru -Force
}
```

### The PowerShell Integrated Scripting Environment (ISE)

If you also edit scripts using the PowerShell ISE, you need to synchronize your encoding settings
there.

The ISE should honor a BOM, but it's also possible to use reflection to [set the encoding][03]. Note
that this wouldn't be persisted between startups.

### Source control software

Some source control tools, such as git, ignore encodings; git just tracks the bytes. Others, like
Azure DevOps or Mercurial, may not. Even some git-based tools rely on decoding text.

When this is the case, make sure you:

- Configure the text encoding in your source control to match your VS Code configuration.
- Ensure all your files are checked into source control in the relevant encoding.
- Be wary of changes to the encoding received through source control. A key sign of this is a diff
  indicating changes but where nothing seems to have changed (because bytes have but characters have
  not).

### Collaborators' environments

On top of configuring source control, ensure that your collaborators on any files you share don't
have settings that override your encoding by re-encoding PowerShell files.

### Other programs

Any other program that reads or writes a PowerShell script may re-encode it.

Some examples are:

- Using the clipboard to copy and paste a script. This is common in scenarios like:
  - Copying a script into a VM
  - Copying a script out of an email or webpage
  - Copying a script into or out of a Microsoft Word or PowerPoint document
- Other text editors, such as:
  - Notepad
  - vim
  - Any other PowerShell script editor
- Text editing utilities, like:
  - `Get-Content`/`Set-Content`/`Out-File`
  - PowerShell redirection operators like `>` and `>>`
  - `sed`/`awk`
- File transfer programs, like:
  - A web browser, when downloading scripts
  - A file share

Some of these tools deal in bytes rather than text, but others offer encoding configurations. In
those cases where you need to configure an encoding, you need to make it the same as your editor
encoding to prevent problems.

## Other resources on encoding in PowerShell

There are a few other nice posts on encoding and configuring encoding in PowerShell that are worth a
read:

- [about_Character_Encoding][01]
- @mklement0's [summary of PowerShell encoding on StackOverflow][22]
- Previous issues opened on VS Code-PowerShell for encoding problems:
  - [#1308][12]
  - [#1628][13]
  - [#1680][14]
  - [#1744][15]
  - [#1751][16]
- [The classic _Joel on Software_ write up about Unicode][29]
- [Encoding in .NET Standard][08]

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_character_encoding
[02]: https://ascii.cl/
[03]: https://bensonxion.wordpress.com/2012/04/25/powershell-ise-default-saveas-encoding/
[04]: https://code.visualstudio.com/docs/editor/codebasics#_file-encoding-support
[05]: https://en.wikipedia.org/wiki/Endianness
[06]: https://en.wikipedia.org/wiki/Unicode
[07]: https://gist.github.com/rjmholt/3d8dd4849f718c914132ce3c5b278e0e
[08]: https://github.com/dotnet/standard/issues/260#issuecomment-289549508
[09]: https://github.com/Microsoft/VSCode/issues/824
[11]: https://github.com/PowerShell/PowerShell/issues/3466
[12]: https://github.com/PowerShell/VSCode-powershell/issues/1308
[13]: https://github.com/PowerShell/VSCode-powershell/issues/1628
[14]: https://github.com/PowerShell/VSCode-powershell/issues/1680
[15]: https://github.com/PowerShell/VSCode-powershell/issues/1744
[16]: https://github.com/PowerShell/VSCode-powershell/issues/1751
[18]: https://marketplace.visualstudio.com/items?itemName=nhoizey.gremlins
[19]: https://microsoft.github.io/language-server-protocol/
[20]: https://rkeithhill.wordpress.com/2010/05/26/handling-native-exe-output-encoding-in-utf8-with-no-bom/
[21]: https://stackoverflow.com/a/40098904
[22]: https://stackoverflow.com/questions/40098771/changing-powershells-default-output-encoding-to-utf-8
[23]: https://wikipedia.org/wiki/Byte_order_mark
[24]: https://wikipedia.org/wiki/ISO/IEC_8859-1
[25]: https://wikipedia.org/wiki/UTF-16
[26]: https://wikipedia.org/wiki/UTF-8
[27]: https://wikipedia.org/wiki/Windows-1252
[28]: https://www.i18nqa.com/debug/utf8-debug.html
[29]: https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/

# /./reference/dev-cross-plat/vscode/using-vscode-for-debugging-compiled-cmdlets.md

    ---
    description: How to set a build task and launch configuration for a PSModule project in .NET Core
    ms.date: 11/16/2022
    title: Using Visual Studio Code to debug compiled cmdlets
    ---
# Using Visual Studio Code to debug compiled cmdlets

This guide shows you how to interactively debug C# source code for a compiled PowerShell module
using Visual Studio Code (VS Code) and the C# extension.

Some familiarity with the Visual Studio Code debugger is assumed.

- For a general introduction to the VS Code debugger, see [Debugging in Visual Studio Code][02].

- For examples of debugging PowerShell script files and modules, see
  [Using Visual Studio Code for remote editing and debugging][10].

This guide assumes you have read and followed the instructions in the
[Writing Portable Modules][01] guide.

## Creating a build task

Build your project automatically before launching a debugging session. Rebuilding ensures that you
debug the latest version of your code.

Configure a build task:

1. In the **Command Palette**, run the **Configure Default Build Task** command.

   [Run Configure Default Build Task][05]

1. In the **Select a task to configure** dialog, choose **Create tasks.json file from template**.

1. In the **Select a Task Template** dialog, choose **.NET Core**.

A new `tasks.json` file is created if one doesn't exist yet.

To test your build task:

1. In the **Command Palette**, run the **Run Build Task** command.

1. In the **Select the build task to run** dialog, choose **build**.

### Information about DLL files being locked

By default, a successful build doesn't show output in the terminal pane. If you see output that
contains the text **Project file doesn't exist**, you should edit the `tasks.json` file. Include the
explicit path to the C# project expressed as `"${workspaceFolder}/myModule"`. In this example,
`myModule` is the name of the project folder. This entry must go after the `build` entry in the
`args` list as follows:

```json
    {
        "label": "build",
        "command": "dotnet",
        "type": "shell",
        "args": [
            "build",
            "${workspaceFolder}/myModule",
            // Ask dotnet build to generate full paths for file names.
            "/property:GenerateFullPaths=true",
            // Do not generate summary otherwise it leads to duplicate errors in Problems panel
            "/consoleloggerparameters:NoSummary",
        ],
        "group": "build",
        "presentation": {
            "reveal": "silent"
        },
        "problemMatcher": "$msCompile"
    }
```

When debugging, your module DLL is imported into the PowerShell session in the VS Code terminal. The
DLL becomes locked. The following message is displayed when you run the build task without closing
the terminal session:

```Output
Could not copy "obj\Debug\netstandard2.0\myModule.dll" to "bin\Debug\netstandard2.0\myModule.dll"`.
```

Terminal sessions must be closed before you rebuild.

## Setting up the debugger

To debug the PowerShell cmdlet, you need to set up a custom launch configuration. This
configuration is used to:

- Build your source code
- Start PowerShell with your module loaded
- Leave PowerShell open in the terminal pane

When you invoke your cmdlet in the terminal session, the debugger stops at any breakpoints set in
your source code.

### Configuring launch.json for PowerShell

1. Install the [C# for Visual Studio Code][03] extension

1. In the Debug pane, add a debug configuration

1. In the `Select environment` dialog, choose `.NET Core`

1. The `launch.json` file is opened in the editor. With your cursor inside the `configurations`
   array, you see the `configuration` picker. If you don't see this list, select
   **Add Configuration**.

1. To create a default debug configuration, select **Launch .NET Core Console App**:

   [Launch .NET Core Console App][04]

1. Edit the `name`, `program`, `args`, and `console` fields as follows:

   ```json
    {
        "name": "PowerShell cmdlets: pwsh",
        "type": "coreclr",
        "request": "launch",
        "preLaunchTask": "build",
        "program": "pwsh",
        "args": [
            "-NoExit",
            "-NoProfile",
            "-Command",
            "Import-Module ${workspaceFolder}/myModule/bin/Debug/netstandard2.0/myModule.dll",
        ],
        "cwd": "${workspaceFolder}",
        "stopAtEntry": false,
        "console": "integratedTerminal"
    }
   ```

The `program` field is used to launch `pwsh` so that the cmdlet being debugged can be run. The
`-NoExit` argument prevents the PowerShell session from exiting as soon as the module is imported.
The path in the `Import-Module` argument is the default build output path when you've followed the
[Writing Portable Modules][01] guide. If you've created a module manifest (`.psd1` file), you should
use the path to that instead. The `/` path separator works on Windows, Linux, and macOS. You must
use the integrated terminal to run the PowerShell commands you want to debug.

> [!NOTE]
> If the debugger doesn't stop at any breakpoints, look in the Visual Studio Code Debug Console for
> a line that says:
>
> ```
> Loaded '/path/to/myModule.dll'. Skipped loading symbols. Module is optimized and the debugger option 'Just My Code' is enabled.
> ```
>
> If you see this, add `"justMyCode": false` to your launch config (at the same level as
> `"console": "integratedTerminal"`.

### Configuring launch.json for Windows PowerShell

This launch configuration works for testing your cmdlets in Windows PowerShell (`powershell.exe`).
Create a second launch configuration with the following changes:

1. `name` should be `PowerShell cmdlets: powershell`

1. `type` should be `clr`

1. `program` should be `powershell`

   It should look like this:

   ```json
    {
        "name": "PowerShell cmdlets: powershell",
        "type": "clr",
        "request": "launch",
        "preLaunchTask": "build",
        "program": "powershell",
        "args": [
            "-NoExit",
            "-NoProfile",
            "-Command",
            "Import-Module ${workspaceFolder}/myModule/bin/Debug/netstandard2.0/myModule.dll",
        ],
        "cwd": "${workspaceFolder}",
        "stopAtEntry": false,
        "console": "integratedTerminal"
    }
   ```

## Launching a debugging session

Now everything is ready to begin debugging.

- Place a breakpoint in the source code for the cmdlet you want to debug:

  [A breakpoint shows as a red dot in the gutter][08]

- Ensure that the relevant **PowerShell cmdlets** configuration is selected in the configuration
  drop-down menu in the **Debug** view:

  [Select the launch configuration][07]

- Press <kbd>F5</kbd> or click on the **Start Debugging** button

- Switch to the terminal pane and invoke your cmdlet:

  [Invoke the cmdlet][06]

- Execution stops at the breakpoint:

  [Executions halts at breakpoint][09]

You can step through the source code, inspect variables, and inspect the call stack.

To end debugging, click **Stop** in the debug toolbar or press <kbd>Shift</kbd>+<kbd>F5</kbd>. The
shell used for debugging exits and releases the lock on the compiled DLL file.

<!-- link references -->
[01]: ../writing-portable-modules.md
[02]: https://code.visualstudio.com/docs/editor/debugging
[03]: https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp
[04]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/using-vscode-for-debugging-compiled-cmdlets/add-configuration-dialog.png
[05]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/using-vscode-for-debugging-compiled-cmdlets/configure-default-build-task.png
[06]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/using-vscode-for-debugging-compiled-cmdlets/invoke-the-cmdlet.png
[07]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/using-vscode-for-debugging-compiled-cmdlets/select-launch-configuration.png
[08]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/using-vscode-for-debugging-compiled-cmdlets/set-breakpoint.png
[09]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/vscode/media/using-vscode-for-debugging-compiled-cmdlets/stopped-at-breakpoint.png
[10]: using-vscode-for-remote-editing-and-debugging.md

# /./reference/dev-cross-plat/performance/script-authoring-considerations.md

    ---
    description: Scripting for Performance in PowerShell
    ms.date: 06/23/2023
    title: PowerShell scripting performance considerations
    ---

# PowerShell scripting performance considerations

PowerShell scripts that leverage .NET directly and avoid the pipeline tend to be faster than
idiomatic PowerShell. Idiomatic PowerShell uses cmdlets and PowerShell functions, often leveraging
the pipeline, and resorting to .NET only when necessary.

>[!NOTE]
> Many of the techniques described here aren't idiomatic PowerShell and may reduce the readability
> of a PowerShell script. Script authors are advised to use idiomatic PowerShell unless performance
> dictates otherwise.

## Suppressing output

There are many ways to avoid writing objects to the pipeline.

- Assigning to `$null`
- Casting to `[void]`
- File redirection to `$null`
- Pipe to `Out-Null`

The speeds of assigning to `$null`, casting to `[void]`, and file redirection to `$null` are almost
identical. However, calling `Out-Null` in a large loop can be significantly slower, especially in
PowerShell 5.1.

```powershell
$tests = @{
    'Assign to $null' = {
        $arrayList = [System.Collections.ArrayList]::new()
        foreach ($i in 0..$args[0]) {
            $null = $arraylist.Add($i)
        }
    }
    'Cast to [void]' = {
        $arrayList = [System.Collections.ArrayList]::new()
        foreach ($i in 0..$args[0]) {
            [void]$arraylist.Add($i)
        }
    }
    'Redirect to $null' = {
        $arrayList = [System.Collections.ArrayList]::new()
        foreach ($i in 0..$args[0]) {
            $arraylist.Add($i) > $null
        }
    }
    'Pipe to Out-Null' = {
        $arrayList = [System.Collections.ArrayList]::new()
        foreach ($i in 0..$args[0]) {
            $arraylist.Add($i) | Out-Null
        }
    }
}

10kb, 50kb, 100kb | ForEach-Object {
    $groupResult = foreach ($test in $tests.GetEnumerator()) {
        $ms = (Measure-Command { & $test.Value $_ }).TotalMilliseconds

        [pscustomobject]@{
            Iterations        = $_
            Test              = $test.Key
            TotalMilliseconds = [math]::Round($ms, 2)
        }

        [GC]::Collect()
        [GC]::WaitForPendingFinalizers()
    }

    $groupResult = $groupResult | Sort-Object TotalMilliseconds
    $groupResult | Select-Object *, @{
        Name       = 'RelativeSpeed'
        Expression = {
            $relativeSpeed = $_.TotalMilliseconds / $groupResult[0].TotalMilliseconds
            [math]::Round($relativeSpeed, 2).ToString() + 'x'
        }
    }
}
```

These tests were run on a Windows 11 machine in PowerShell 7.3.4. The results are shown below:

```Output
Iterations Test              TotalMilliseconds RelativeSpeed
---------- ----              ----------------- -------------
     10240 Assign to $null               36.74 1x
     10240 Redirect to $null             55.84 1.52x
     10240 Cast to [void]                62.96 1.71x
     10240 Pipe to Out-Null              81.65 2.22x
     51200 Assign to $null              193.92 1x
     51200 Cast to [void]               200.77 1.04x
     51200 Redirect to $null            219.69 1.13x
     51200 Pipe to Out-Null             329.62 1.7x
    102400 Redirect to $null            386.08 1x
    102400 Assign to $null              392.13 1.02x
    102400 Cast to [void]               405.24 1.05x
    102400 Pipe to Out-Null             572.94 1.48x
```

The times and relative speeds can vary depending on the hardware, the version of PowerShell, and the
current workload on the system.

## Array addition

Generating a list of items is often done using an array with the addition operator:

```powershell
$results = @()
$results += Do-Something
$results += Do-SomethingElse
$results
```

Array addition is inefficient because arrays have a fixed size. Each addition to the array creates
a new array big enough to hold all elements of both the left and right operands. The elements of
both operands are copied into the new array. For small collections, this overhead may not matter.
Performance can suffer for large collections.

There are a couple of alternatives. If you don't actually require an array, instead consider using
a typed generic list (**List\<T\>**):

```powershell
$results = [System.Collections.Generic.List[object]]::new()
$results.AddRange((Do-Something))
$results.AddRange((Do-SomethingElse))
$results
```

The performance impact of using array addition grows exponentially with the size of the collection
and the number additions. This code compares explicitly assigning values to an array with using
array addition and using the `Add()` method on a **List\<T\>**. It defines explicit assignment as
the baseline for performance.

```powershell
$tests = @{
    'PowerShell Explicit Assignment' = {
        param($count)

        $result = foreach($i in 1..$count) {
            $i
        }
    }
    '.Add(..) to List<T>' = {
        param($count)

        $result = [Collections.Generic.List[int]]::new()
        foreach($i in 1..$count) {
            $result.Add($i)
        }
    }
    '+= Operator to Array' = {
        param($count)

        $result = @()
        foreach($i in 1..$count) {
            $result += $i
        }
    }
}

5kb, 10kb, 100kb | ForEach-Object {
    $groupResult = foreach($test in $tests.GetEnumerator()) {
        $ms = (Measure-Command { & $test.Value -Count $_ }).TotalMilliseconds

        [pscustomobject]@{
            CollectionSize    = $_
            Test              = $test.Key
            TotalMilliseconds = [math]::Round($ms, 2)
        }

        [GC]::Collect()
        [GC]::WaitForPendingFinalizers()
    }

    $groupResult = $groupResult | Sort-Object TotalMilliseconds
    $groupResult | Select-Object *, @{
        Name       = 'RelativeSpeed'
        Expression = {
            $relativeSpeed = $_.TotalMilliseconds / $groupResult[0].TotalMilliseconds
            [math]::Round($relativeSpeed, 2).ToString() + 'x'
        }
    }
}
```

These tests were run on a Windows 11 machine in PowerShell 7.3.4.

```Output
CollectionSize Test                           TotalMilliseconds RelativeSpeed
-------------- ----                           ----------------- -------------
          5120 PowerShell Explicit Assignment             26.65 1x
          5120 .Add(..) to List<T>                       110.98 4.16x
          5120 += Operator to Array                      402.91 15.12x
         10240 PowerShell Explicit Assignment              0.49 1x
         10240 .Add(..) to List<T>                       137.67 280.96x
         10240 += Operator to Array                     1678.13 3424.76x
        102400 PowerShell Explicit Assignment             11.18 1x
        102400 .Add(..) to List<T>                      1384.03 123.8x
        102400 += Operator to Array                   201991.06 18067.18x
```

When you're working with large collections, array addition is dramatically slower than adding to
a **List\<T\>**.

When using a **List\<T\>**, you need to create the list with a specific type, like **String** or
**Int**. When you add objects of a different type to the list, they are cast to the specified type.
If they can't be cast to the specified type, the method raises an exception.

```powershell
$intList = [System.Collections.Generic.List[int]]::new()
$intList.Add(1)
$intList.Add('2')
$intList.Add(3.0)
$intList.Add('Four')
$intList
```

```Output
MethodException:
Line |
   5 |  $intList.Add('Four')
     |  ~~~~~~~~~~~~~~~~~~~~
     | Cannot convert argument "item", with value: "Four", for "Add" to type
     "System.Int32": "Cannot convert value "Four" to type "System.Int32".
     Error: "The input string 'Four' was not in a correct format.""

1
2
3
```

When you need the list to be a collection of different types of objects, create it with **Object**
as the list type. You can enumerate the collection inspect the types of the objects in it.

```powershell
$objectList = [System.Collections.Generic.List[object]]::new()
$objectList.Add(1)
$objectList.Add('2')
$objectList.Add(3.0)
$objectList.GetEnumerator().ForEach({ "$_ is $($_.GetType())" })
```

```Output
1 is int
2 is string
3 is double
```

If you do require an array, you can call the `ToArray()` method on the list or you can let
PowerShell create the array for you:

```powershell
$results = @(
    Do-Something
    Do-SomethingElse
)
```

In this example, PowerShell creates an **ArrayList** to hold the results written to the pipeline
inside the array expression. Just before assigning to `$results`, PowerShell converts the
**ArrayList** to an **object[]**.

## String addition

Strings are immutable. Each addition to the string actually creates a new string big enough to hold
the contents of both the left and right operands, then copies the elements of both operands into
the new string. For small strings, this overhead may not matter. For large strings, this can affect
performance and memory consumption.

There are at least two alternatives:

- The `-join` operator concatenates strings
- The .NET **StringBuilder** class provides a mutable string

The following example compares the performance of these three methods of building a string.

```powershell
$tests = @{
    'StringBuilder' = {
        $sb = [System.Text.StringBuilder]::new()
        foreach ($i in 0..$args[0]) {
            $sb = $sb.AppendLine("Iteration $i")
        }
        $sb.ToString()
    }
    'Join operator' = {
        $string = @(
            foreach ($i in 0..$args[0]) {
                "Iteration $i"
            }
        ) -join "`n"
        $string
    }
    'Addition Assignment +=' = {
        $string = ''
        foreach ($i in 0..$args[0]) {
            $string += "Iteration $i`n"
        }
        $string
    }
}

10kb, 50kb, 100kb | ForEach-Object {
    $groupResult = foreach ($test in $tests.GetEnumerator()) {
        $ms = (Measure-Command { & $test.Value $_ }).TotalMilliseconds

        [pscustomobject]@{
            Iterations        = $_
            Test              = $test.Key
            TotalMilliseconds = [math]::Round($ms, 2)
        }

        [GC]::Collect()
        [GC]::WaitForPendingFinalizers()
    }

    $groupResult = $groupResult | Sort-Object TotalMilliseconds
    $groupResult | Select-Object *, @{
        Name       = 'RelativeSpeed'
        Expression = {
            $relativeSpeed = $_.TotalMilliseconds / $groupResult[0].TotalMilliseconds
            [math]::Round($relativeSpeed, 2).ToString() + 'x'
        }
    }
}
```


These tests were run on a Windows 10 machine in PowerShell 7.3.4. The output shows that the `-join`
operator is the fastest, followed by the **StringBuilder** class.

```Output
Iterations Test                   TotalMilliseconds RelativeSpeed
---------- ----                   ----------------- -------------
     10240 Join operator                       7.08 1x
     10240 StringBuilder                      54.10 7.64x
     10240 Addition Assignment +=            724.16 102.28x
     51200 Join operator                      41.76 1x
     51200 StringBuilder                     318.06 7.62x
     51200 Addition Assignment +=          17693.06 423.68x
    102400 Join operator                     106.98 1x
    102400 StringBuilder                     543.84 5.08x
    102400 Addition Assignment +=          90693.13 847.76x
```

The times and relative speeds can vary depending on the hardware, the version of PowerShell, and the
current workload on the system.

## Processing large files

The idiomatic way to process a file in PowerShell might look something like:

```powershell
Get-Content $path | Where-Object { $_.Length -gt 10 }
```

This can be an order of magnitude slower than using .NET APIs directly:

```powershell
try
{
    $stream = [System.IO.StreamReader]::new($path)
    while ($line = $stream.ReadLine())
    {
        if ($line.Length -gt 10)
        {
            $line
        }
    }
}
finally
{
    $stream.Dispose()
}
```

### Looking up entries by property in large collections

It's common to need to use a shared property to identify the same record in different collections,
like using a name to retrieve an ID from one list and an email from another. Iterating over the
first list to find the matching record in the second collection is slow. In particular, the
repeated filtering of the second collection has a large overhead.

Given two collections, one with an **ID** and **Name**, the other with **Name** and **Email**:

```powershell
$Employees = 1..10000 | ForEach-Object {
    [PSCustomObject]@{
        Id   = $_
        Name = "Name$_"
    }
}

$Accounts = 2500..7500 | ForEach-Object {
    [PSCustomObject]@{
        Name = "Name$_"
        Email = "Name$_@fabrikam.com"
    }
}
```

The usual way to reconcile these collections to return a list of objects with the **ID**, **Name**,
and **Email** properties might look like this:

```powershell
$Results = $Employees | ForEach-Object -Process {
    $Employee = $_

    $Account = $Accounts | Where-Object -FilterScript {
        $_.Name -eq $Employee.Name
    }

    [pscustomobject]@{
        Id    = $Employee.Id
        Name  = $Employee.Name
        Email = $Account.Email
    }
}
```

However, that implementation has to filter all 5000 items in the `$Accounts` collection once for
every item in the `$Employee` collection. That can take minutes, even for this single-value lookup.

Instead, you can make a [hash table][02] that uses the shared **Name** property as a key and the
matching account as the value.

```powershell
$LookupHash = @{}
foreach ($Account in $Accounts) {
    $LookupHash[$Account.Name] = $Account
}
```

Looking up keys in a hash table is much faster than filtering a collection by property values.
Instead of checking every item in the collection, PowerShell can check if the key is defined and
use its value.

```powershell
$Results = $Employees | ForEach-Object -Process {
    $Email = $LookupHash[$_.Name].Email
    [pscustomobject]@{
        Id    = $_.Id
        Name  = $_.Name
        Email = $Email
    }
}
```

This is much faster. While the looping filter took minutes to complete, the hash lookup takes less
than a second.

## Avoid Write-Host

It's generally considered poor practice to write output directly to the console, but when it makes
sense, many scripts use `Write-Host`.

If you must write many messages to the console, `Write-Host` can be an order of magnitude slower
than `[Console]::WriteLine()` for specific hosts like `pwsh.exe`, `powershell.exe`, or
`powershell_ise.exe`. However, `[Console]::WriteLine()` isn't guaranteed to work in all hosts. Also,
output written using `[Console]::WriteLine()` doesn't get written to transcripts started by
`Start-Transcript`.

Instead of using `Write-Host`, consider using [Write-Output][01].

### JIT compilation

PowerShell compiles the script code to bytecode that's interpreted. Beginning in PowerShell 3, for
code that's repeatedly executed in a loop, PowerShell can improve performance by Just-in-time (JIT)
compiling the code into native code.

Loops that have fewer than 300 instructions are eligible for JIT-compilation. Loops larger than that
are too costly to compile. When the loop has executed 16 times, the script is JIT-compiled in the
background. When the JIT-compilation completes, execution is transferred to the compiled code.

## Avoid repeated calls to a function

Calling a function can be an expensive operation. If you calling a function in a long running tight
loop, consider moving the loop inside the function.

Consider the following examples:

```powershell
$ranGen = New-Object System.Random
$RepeatCount = 10000

'Basic for-loop = {0}ms' -f (Measure-Command -Expression {
    for ($i = 0; $i -lt $RepeatCount; $i++) {
        $Null = $ranGen.Next()
    }
}).TotalMilliseconds

'Wrapped in a function = {0}ms' -f (Measure-Command -Expression {
    function Get-RandNum_Core {
        param ($ranGen)
        $ranGen.Next()
    }

    for ($i = 0; $i -lt $RepeatCount; $i++) {
        $Null = Get-RandNum_Core $ranGen
    }
}).TotalMilliseconds

'For-loop in a function = {0}ms' -f (Measure-Command -Expression {
    function Get-RandNum_All {
        param ($ranGen)
        for ($i = 0; $i -lt $RepeatCount; $i++) {
            $Null = $ranGen.Next()
        }
    }

    Get-RandNum_All $ranGen
}).TotalMilliseconds
```

The **Basic for-loop** example is the base line for performance. The second example wraps the random
number generator in a function that's called in a tight loop. The third example moves the loop
inside the function. The function is only called once but the code still generates 10000 random
numbers. Notice the difference in execution times for each example.

```Output
Basic for-loop = 47.8668ms
Wrapped in a function = 820.1396ms
For-loop in a function = 23.3193ms
```

## Avoid wrapping cmdlet pipelines

Most cmdlets are implemented for the pipeline, which is a sequential syntax and process. For
example:

```powershell
cmdlet1 | cmdlet2 | cmdlet3
```

Initializing a new pipeline can be expensive, therefore you should avoid wrapping a cmdlet
pipeline into another existing pipeline.

Consider the following example. The `Input.csv` file contains 2100 lines. The `Export-Csv` command
is wrapped inside the `ForEach-Object` pipeline. The `Export-Csv` cmdlet is invoked for every
iteration of the `ForEach-Object` loop.

```powershell
'Wrapped = {0:N2} ms' -f (Measure-Command -Expression {
    Import-Csv .\Input.csv | ForEach-Object -Begin { $Id = 1 } -Process {
        [PSCustomObject]@{
            Id = $Id
            Name = $_.opened_by
        } | Export-Csv .\Output1.csv -Append
    }
}).TotalMilliseconds

Wrapped = 15,968.78 ms
```

For the next example, the `Export-Csv` command was moved outside of the `ForEach-Object` pipeline.
In this case, `Export-Csv` is invoked only once, but still processes all objects passed out of
`ForEach-Object`.

```powershell
'Unwrapped = {0:N2} ms' -f (Measure-Command -Expression {
      Import-Csv .\Input.csv | ForEach-Object -Begin { $Id = 2 } -Process {
          [PSCustomObject]@{
              Id = $Id
              Name = $_.opened_by
          }
      } | Export-Csv .\Output2.csv
  }).TotalMilliseconds

Unwrapped = 42.92 ms
```

The unwrapped example is 372 times faster. Also, notice that the first implementation requires the
**Append** parameter, which isn't required for the later implementation.

<!-- Link reference definitions -->
[01]: https://learn.microsoft.com/powershell/module/Microsoft.PowerShell.Utility/Write-Output
[02]: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-hashtable

# /./reference/dev-cross-plat/performance/module-authoring-considerations.md

    ---
    description: PowerShell module authoring considerations
    ms.date: 11/16/2022
    title: PowerShell module authoring considerations
    ---

# PowerShell module authoring considerations

This document includes some guidelines related to how a module is authored for best performance.

## Module Manifest Authoring

A module manifest that doesn't use the following guidelines can have a noticeable impact on general
PowerShell performance even if the module isn't used in a session.

Command auto-discovery analyzes each module to determine which commands the module exports and this
analysis can be expensive. The results of module analysis are cached per user, but the cache isn't
available on first run, which is a typical scenario with containers. During module analysis, if the
exported commands can be fully determined from the manifest, more expensive analysis of the module
can be avoided.

### Guidelines

- In the module manifest, don't use wildcards in the `AliasesToExport`, `CmdletsToExport`, and
  `FunctionsToExport` entries.

- If the module doesn't export commands of a particular type, specify this explicitly in the
  manifest by specifying `@()`. A missing or `$null` entry is equivalent to specifying the wildcard
  `*`.

The following should be avoided where possible:

```powershell
@{
    FunctionsToExport = '*'

    # Also avoid omitting an entry, it's equivalent to using a wildcard
    # CmdletsToExport = '*'
    # AliasesToExport = '*'
}
```

Instead, use:

```powershell
@{
    FunctionsToExport = 'Format-Hex', 'Format-Octal'
    CmdletsToExport = @()  # Specify an empty array, not $null
    AliasesToExport = @()  # Also ensure all three entries are present
}
```

## Avoid CDXML

When deciding how to implement your module, there are three primary choices:

- Binary (usually C#)
- Script (PowerShell)
- CDXML (an XML file wrapping CIM)

If the speed of loading your module is important, CDXML is roughly an order of magnitude slower than
a binary module.

A binary module loads the fastest because it's compiled ahead of time and can use NGen to JIT
compile once per machine.

A script module typically loads a bit more slowly than a binary module because PowerShell must parse
the script before compiling and executing it.

A CDXML module is typically much slower than a script module because it must first parse an XML file
which then generates quite a bit of PowerShell script that's then parsed and compiled.

# /./reference/dev-cross-plat/writing-portable-modules.md

    ---
    description: This article explains how to create modules new modules or update existing modules so that they work across the platforms supported by PowerShell.
    ms.date: 11/16/2022
    title: Writing Portable Modules
    ---

# Portable Modules

Windows PowerShell is written for [.NET Framework][06] while PowerShell Core is written for
[.NET Core][03]. Portable modules are modules that work in both Windows PowerShell and PowerShell
Core. While .NET Framework and .NET Core are highly compatible, there are differences in the
available APIs between the two. There are also differences in the APIs available in Windows
PowerShell and PowerShell Core. Modules intended to be used in both environments need to be aware of
these differences.

## Porting an existing module

### Porting a PSSnapIn

PowerShell [SnapIns][09] aren't supported in PowerShell Core. However, it's trivial to convert a
PSSnapIn to a PowerShell module. Typically, the PSSnapIn registration code is in a single source
file of a class that derives from [PSSnapIn][01]. Remove this source file from the build; it's no
longer needed.

Use [New-ModuleManifest][08] to create a new module manifest that replaces the need for the PSSnapIn
registration code. Some values from the **PSSnapIn** (such as **Description**) can be reused within
the module manifest.

The **RootModule** property in the module manifest should be set to the name of the assembly
(`.dll`) implementing the cmdlets.

### The .NET Portability Analyzer (aka APIPort)

To port modules written for Windows PowerShell to work with PowerShell Core, start with the
[.NET Portability Analyzer][11]. Run this tool against your compiled assembly to determine if the
.NET APIs used in the module are compatible with .NET Framework, .NET Core, and other .NET runtimes.
The tool suggests alternate APIs if they exist. Otherwise, you may need to add [runtime checks][02]
and restrict capabilities not available in specific runtimes.

## Creating a new module

If creating a new module, the recommendation is to use the [.NET CLI][05].

### Installing the PowerShell Standard module template

Once the .NET CLI is installed, install a template library to generate a simple PowerShell module.
The module will be compatible with Windows PowerShell, PowerShell Core, Windows, Linux, and macOS.

The following example shows how to install the template:

```powershell
dotnet new install Microsoft.PowerShell.Standard.Module.Template
```

```output
The following template packages will be installed:
   Microsoft.PowerShell.Standard.Module.Template

Success: Microsoft.PowerShell.Standard.Module.Template::0.1.3 installed the following templates:
Template Name               Short Name  Language  Tags
--------------------------  ----------  --------  -------------------------
PowerShell Standard Module  psmodule    [C#]      Library/PowerShell/Module
```

### Creating a new module project

After the template is installed, you can create a new PowerShell module project using that template.
In this example, the sample module is called 'myModule'.

```
PS> mkdir myModule

    Directory: C:\Users\Steve

Mode LastWriteTime Length Name
---- ------------- ------ ----
d----- 8/3/2018 2:41 PM myModule

PS> cd myModule
PS C:\Users\Steve\myModule> dotnet new psmodule
The template "PowerShell Standard Module" was created successfully.

Processing post-creation actions...
Restoring  C:\Users\Steve\myModule\myModule.csproj:
  Determining projects to restore...
  Restored C:\Users\Steve\myModule\myModule.csproj (in 184 ms).
Restore succeeded.
```

### Building the module

Use standard .NET CLI commands to build the project.

```powershell
dotnet build
```

```output
PS C:\Users\Steve\myModule> dotnet build
MSBuild version 17.6.3+07e294721 for .NET
  Determining projects to restore...
  All projects are up-to-date for restore.
  PowerShellPG -> C:\Users\Steve\myModule\bin\Debug\netstandard2.0\myModule.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:02.36
```

### Testing the module

After building the module, you can import it and execute the sample cmdlet.

```powershell
Import-Module .\bin\Debug\netstandard2.0\myModule.dll
Test-SampleCmdlet -?
Test-SampleCmdlet -FavoriteNumber 7 -FavoritePet Cat
```

```output
NAME
    Test-SampleCmdlet

SYNTAX
    Test-SampleCmdlet [-FavoriteNumber] <int> [[-FavoritePet] {Cat | Dog | Horse}] [<CommonParameters>]


ALIASES
    None


REMARKS
    None


FavoriteNumber FavoritePet
-------------- -----------
             7 Cat
```

### Debugging the module

For a guide on setting up Visual Studio Code to debug the module, see
[Using Visual Studio Code for debugging compiled cmdlets][15].

## Supporting technologies

The following sections describe in detail some of the technologies used by this template.

### .NET Standard Library

[.NET Standard][07] is a formal specification of .NET APIs that are available in all .NET
implementations. Managed code targeting .NET Standard works with the .NET Framework and .NET Core
versions that are compatible with that version of the .NET Standard.

> [!NOTE]
> Although an API may exist in .NET Standard, the API implementation in .NET Core may throw a
> `PlatformNotSupportedException` at runtime, so to verify compatibility with Windows PowerShell
> and PowerShell Core, the best practice is to run tests for your module within both environments.
> Also run tests on Linux and macOS if your module is intended to be cross-platform.

Targeting .NET Standard helps ensure that, as the module evolves, incompatible APIs don't
accidentally get introduced into the module. Incompatibilities are discovered at compile time
instead of runtime.

However, it isn't required to target .NET Standard for a module to work with both Windows PowerShell
and PowerShell Core, as long as you use compatible APIs. The Intermediate Language (IL) is
compatible between the two runtimes. You can target .NET Framework 4.6.1, which is compatible with
.NET Standard 2.0. If you don't use APIs outside of .NET Standard 2.0, then your module works with
PowerShell Core 6 without recompilation.

### PowerShell Standard Library

The [PowerShell Standard][12] library is a formal specification of PowerShell APIs available in all
PowerShell versions greater than or equal to the version of that standard.

For example, [PowerShell Standard 5.1][13] is compatible with both Windows PowerShell 5.1 and
PowerShell Core 6.0 or newer.

We recommend you compile your module using PowerShell Standard Library. The library ensures the APIs
are available and implemented in both Windows PowerShell and PowerShell Core 6. PowerShell Standard
is intended to always be forwards-compatible. A module built using PowerShell Standard Library 5.1
will always be compatible with future versions of PowerShell.

### Module Manifest

#### Indicating Compatibility With Windows PowerShell and PowerShell Core

After validating that your module works with both Windows PowerShell and PowerShell Core, the module
manifest should explicitly indicate compatibility by using the [CompatiblePSEditions][10] property.
A value of `Desktop` means that the module is compatible with Windows PowerShell, while a value of
`Core` means that the module is compatible with PowerShell Core. Including both `Desktop` and `Core`
means that the module is compatible with both Windows PowerShell and PowerShell Core.

> [!NOTE]
> `Core` doesn't automatically mean that the module is compatible with Windows, Linux, and macOS.
> The **CompatiblePSEditions** property was introduced in PowerShell v5. Module manifests that use
> the **CompatiblePSEditions** property fail to load in versions prior to PowerShell v5.

### Indicating OS Compatibility

First, validate that your module works on Linux and macOS. Next, indicate compatibility with those
operating systems in the module manifest. This makes it easier for users to find your module for
their operating system when published to the [PowerShell Gallery][14].

Within the module manifest, the `PrivateData` property has a `PSData` sub-property. The optional
`Tags` property of `PSData` takes an array of values that show up in PowerShell Gallery. The
PowerShell Gallery supports the following compatibility values:

| Tag               | Description                                |
|-------------------|--------------------------------------------|
| PSEdition_Core    | Compatible with PowerShell Core 6          |
| PSEdition_Desktop | Compatible with Windows PowerShell         |
| Windows           | Compatible with Windows                    |
| Linux             | Compatible with Linux (no specific distro) |
| macOS             | Compatible with macOS                      |

Example:

```powershell
@{
    GUID = "4ae9fd46-338a-459c-8186-07f910774cb8"
    Author = "Microsoft Corporation"
    CompanyName = "Microsoft Corporation"
    Copyright = "(C) Microsoft Corporation. All rights reserved."
    HelpInfoUri = "https://go.microsoft.com/fwlink/?linkid=855962"
    ModuleVersion = "1.2.4"
    PowerShellVersion = "3.0"
    ClrVersion = "4.0"
    RootModule = "PackageManagement.psm1"
    Description = 'PackageManagement (a.k.a. OneGet) is a new way to discover and install software packages from around the web.
 it's a manager or multiplexer of existing package managers (also called package providers) that unifies Windows package management with a single Windows PowerShell interface. With PackageManagement, you can do the following.
  - Manage a list of software repositories in which packages can be searched, acquired and installed
  - Discover software packages
  - Seamlessly install, uninstall, and inventory packages from one or more software repositories'

    CmdletsToExport = @(
        'Find-Package',
        'Get-Package',
        'Get-PackageProvider',
        'Get-PackageSource',
        'Install-Package',
        'Import-PackageProvider'
        'Find-PackageProvider'
        'Install-PackageProvider'
        'Register-PackageSource',
        'Set-PackageSource',
        'Unregister-PackageSource',
        'Uninstall-Package'
        'Save-Package'
    )

    FormatsToProcess  = @('PackageManagement.format.ps1xml')

    PrivateData = @{
        PSData = @{
            Tags = @('PackageManagement', 'PSEdition_Core', 'PSEdition_Desktop', 'Windows', 'Linux', 'macOS')
            ProjectUri = 'https://oneget.org'
        }
    }
}
```

### Dependency on Native Libraries

Modules intended for use across different operating systems or processor architectures may depend on
a managed library that itself depends on some native libraries.

Prior to PowerShell 7, one would have to have custom code to load the appropriate native dll so that
the managed library can find it correctly.

With PowerShell 7, native binaries to load are searched in sub-folders within the managed library's
location following a subset of the [.NET RID Catalog][04] notation.

```
managed.dll folder
    |
    |--- 'win-x64' folder
    |       |--- native.dll
    |
    |--- 'win-x86' folder
    |       |--- native.dll
    |
    |--- 'win-arm' folder
    |       |--- native.dll
    |
    |--- 'win-arm64' folder
    |       |--- native.dll
    |
    |--- 'linux-x64' folder
    |       |--- native.so
    |
    |--- 'linux-x86' folder
    |       |--- native.so
    |
    |--- 'linux-arm' folder
    |       |--- native.so
    |
    |--- 'linux-arm64' folder
    |       |--- native.so
    |
    |--- 'osx-x64' folder
    |       |--- native.dylib
```

<!-- link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.management.automation.pssnapin
[02]: https://learn.microsoft.com/dotnet/api/system.runtime.interopservices.runtimeinformation.frameworkdescription#System_Runtime_InteropServices_RuntimeInformation_FrameworkDescription
[03]: https://learn.microsoft.com/dotnet/core/
[04]: https://learn.microsoft.com/dotnet/core/rid-catalog
[05]: https://learn.microsoft.com/dotnet/core/tools/?tabs=netcore2x
[06]: https://learn.microsoft.com/dotnet/framework/
[07]: https://learn.microsoft.com/dotnet/standard/net-standard
[08]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/new-modulemanifest
[09]: https://learn.microsoft.com/powershell/scripting/developer/cmdlet/modules-and-snap-ins
[10]: https://learn.microsoft.com/powershell/gallery/concepts/module-psedition-support
[11]: https://github.com/Microsoft/dotnet-apiport
[12]: https://github.com/PowerShell/PowerShellStandard
[13]: https://www.nuget.org/packages/PowerShellStandard.Library/5.1.0
[14]: https://www.powershellgallery.com
[15]: vscode/using-vscode-for-debugging-compiled-cmdlets.md

# /./reference/dev-cross-plat/create-standard-library-binary-module.md

    ---
    description: The PowerShell Standard Library allows us to create cross platform modules that work in both PowerShell and with Windows PowerShell 5.1.
    ms.custom: contributor-KevinMarquette
    ms.date: 02/02/2023
    title: How to create a Standard Library Binary Module
    ---
# How to create a Standard Library binary module

I recently had an idea for module that I wanted to implement as a binary module. I have yet to
create one using the [PowerShell Standard Library][04] so this felt like a good opportunity. I used
the [Creating a cross-platform binary module][03] guide to create this module without any
roadblocks. We're going to walk that same process and I'll add a little extra commentary along the
way.

> [!NOTE]
> The [original version][07] of this article appeared on the blog written by [@KevinMarquette][08].
> The PowerShell team thanks Kevin for sharing this content with us. Please check out his blog at
> [PowerShellExplained.com][05].

## What's the PowerShell Standard Library?

The PowerShell Standard Library allows us to create cross platform modules that work in both
PowerShell and Windows PowerShell 5.1.

## Why binary modules?

When you are writing a module in C# you give up easy access to PowerShell cmdlets and functions. But
if you are creating a module that doesn't depend on a lot of other PowerShell commands, the
performance benefit can be significant. PowerShell was optimized for the administrator, not the
computer. By switching to C#, you get to shed the overhead added by PowerShell.

For example, we have a critical process that does a lot of work with JSON and hashtables. We
optimized the PowerShell as much as we could but the process still takes 12 minutes to complete. The
module already contained a lot of C# style PowerShell. This makes conversion to a binary module
clean and simple. By converting to a binary module, we reduced the process time from over 12 minutes
to under four minutes.

### Hybrid modules

You can mix binary cmdlets with PowerShell advanced functions. Everything you know about script
modules applies the same way. The empty `psm1` file is included so you can add other PowerShell
functions later.

Almost all of the compiled cmdlets that I have created started out as PowerShell functions first.
All of our binary modules are really hybrid modules.

### Build scripts

I kept the build script simple here. I generally use a large `Invoke-Build` script as part of my
CI/CD pipeline. It does more magic like running Pester tests, running **PSScriptAnalyzer**, managing
versioning, and publishing to the PSGallery. Once I started using a build script for my modules, I
was able to find lots of things to add to it.

## Planning the module

The plan for this module is to create a `src` folder for the C# code and structure the rest like I
would for a script module. This includes using a build script to compile everything into an `Output`
folder. The folder structure looks like this:

```
MyModule
├───src
├───Output
│   └───MyModule
├───MyModule
│   ├───Data
│   ├───Private
│   └───Public
└───Tests
```

## Getting Started

First I need to create the folder and create the git repo. I'm using `$module` as a placeholder for
the module name. This should make it easier for you to reuse these examples if needed.

```powershell
$module = 'MyModule'
New-Item -Path $module -Type Directory
Set-Location $module
git init
```

Then create the root level folders.

```powershell
New-Item -Path 'src' -Type Directory
New-Item -Path 'Output' -Type Directory
New-Item -Path 'Tests' -Type Directory
New-Item -Path $module -Type Directory
```

### Binary module setup

This article is focused on the binary module so that's where we'll start. This section pulls
examples from the [Creating a cross-platform binary module][03] guide. Review that guide if you need
more details or have any issues.

First thing we want to do is check the version of the [dotnet core SDK][09] that we have installed.
I'm using 2.1.4, but you should have 2.0.0 or newer before continuing.

```powershell
PS> dotnet --version
2.1.4
```

I'm working out of the `src` folder for this section.

```powershell
Set-Location 'src'
```

Using the dotnet command, create a new class library.

```powershell
dotnet new classlib --name $module
```

This created the library project in a subfolder but I don't want that extra level of nesting. I'm
going to move those files up a level.

```powershell
Move-Item -Path .\$module\* -Destination .\
Remove-Item $module -Recurse
```

Set the .NET core SDK version for the project. I have the 2.1 SDK so I'm going to specify `2.1.0`.
Use `2.0.0` if you're using the 2.0 SDK.

```powershell
dotnet new globaljson --sdk-version 2.1.0
```

Add the **PowerShell Standard Library** [NuGet package][10] to the project. Make sure you use the
most recent version available for the level of compatibility that you need. I would default to the
latest version but I don't think this module leverages any features newer than PowerShell 3.0.

```powershell
dotnet add package PowerShellStandard.Library --version 7.0.0-preview.1
```

We should have a src folder that looks like this:

```powershell
PS> Get-ChildItem
    Directory: \MyModule\src

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----        7/14/2018   9:51 PM                obj
-a----        7/14/2018   9:51 PM             86 Class1.cs
-a----        7/14/2018  10:03 PM            259 MyModule.csproj
-a----        7/14/2018  10:05 PM             45 global.json
```

Now we're ready to add our own code to the project.

### Building a binary cmdlet

We need to update the `src\Class1.cs` to contain this starter cmdlet:

```csharp
using System;
using System.Management.Automation;

namespace MyModule
{
    [Cmdlet( VerbsDiagnostic.Resolve , "MyCmdlet")]
    public class ResolveMyCmdletCommand : PSCmdlet
    {
        [Parameter(Position=0)]
        public Object InputObject { get; set; }

        protected override void EndProcessing()
        {
            this.WriteObject(this.InputObject);
            base.EndProcessing();
        }
    }
}
```

Rename the file to match the class name.

```powershell
Rename-Item .\Class1.cs .\ResolveMyCmdletCommand.cs
```

Then we can build our module.

```powershell
PS> dotnet build

Microsoft (R) Build Engine version 15.5.180.51428 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

Restore completed in 18.19 ms for C:\workspace\MyModule\src\MyModule.csproj.
MyModule -> C:\workspace\MyModule\src\bin\Debug\netstandard2.0\MyModule.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:02.19
```

We can call `Import-Module` on the new dll to load our new cmdlet.

```powershell
PS> Import-Module .\bin\Debug\netstandard2.0\$module.dll
PS> Get-Command -Module $module

CommandType Name                    Version Source
----------- ----                    ------- ------
Cmdlet      Resolve-MyCmdlet        1.0.0.0 MyModule
```

If the import fails on your system, try updating .NET to 4.7.1 or newer. The
[Creating a cross-platform binary module][03] guide goes into more details on .NET support and
compatibility for older versions of .NET.

### Module manifest

It's cool that we can import the dll and have a working module. I like to keep going with it and
create a module manifest. We need the manifest if we want to publish to the PSGallery later.

From the root of our project, we can run this command to create the module manifest that we need.

```powershell
$manifestSplat = @{
    Path              = ".\$module\$module.psd1"
    Author            = 'Kevin Marquette'
    NestedModules     = @('bin\MyModule.dll')
    RootModule        = "$module.psm1"
    FunctionsToExport = @('Resolve-MyCmdlet')
}
New-ModuleManifest @manifestSplat
```

I'm also going to create an empty root module for future PowerShell functions.

```powershell
Set-Content -Value '' -Path ".\$module\$module.psm1"
```

This allows me to mix both normal PowerShell functions and binary cmdlets in the same project.

### Building the full module

I compile everything together into an output folder. We need to create a build script to do that. I
would normally add this to an `Invoke-Build` script, but we can keep it simple for this example. Add
this to a `build.ps1` at the root of the project.

```powershell
$module = 'MyModule'
Push-Location $PSScriptRoot

dotnet build $PSScriptRoot\src -o $PSScriptRoot\output\$module\bin
Copy-Item "$PSScriptRoot\$module\*" "$PSScriptRoot\output\$module" -Recurse -Force

Import-Module "$PSScriptRoot\Output\$module\$module.psd1"
Invoke-Pester "$PSScriptRoot\Tests"
```

These commands build our DLL and place it into our `output\$module\bin` folder. It then copies the
other module files into place.

```
Output
└───MyModule
    ├───MyModule.psd1
    ├───MyModule.psm1
    └───bin
        ├───MyModule.deps.json
        ├───MyModule.dll
        └───MyModule.pdb
```

At this point, we can import our module with the psd1 file.

```powershell
Import-Module ".\Output\$module\$module.psd1"
```

From here, we can drop the `.\Output\$module` folder into our `$env:PSModulePath` directory and it
autoloads our command whenever we need it.

### Update: dotnet new PSModule

I learned that the `dotnet` tool has a `PSModule` template.

All the steps that I outlined above are still valid, but this template cuts many of them out. It's
still a fairly new template that's still getting some polish placed on it. Expect it to keep getting
better from here.

This is how you use install and use the PSModule template.

```powershell
dotnet new -i Microsoft.PowerShell.Standard.Module.Template
dotnet new psmodule
dotnet build
Import-Module "bin\Debug\netstandard2.0\$module.dll"
Get-Module $module
```

This minimally-viable template takes care of adding the .NET SDK, PowerShell Standard Library, and
creates an example class in the project. You can build it and run it right away.

## Important details

Before we end this article, here are a few other details worth mentioning.

### Unloading DLLs

Once a binary module is loaded, you can't really unload it. The DLL file is locked until you unload
it. This can be annoying when developing because every time you make a change and want to build it,
the file is often locked. The only reliable way to resolve this is to close the PowerShell session
that loaded the DLL.

### VS Code reload window action

I do most of my PowerShell dev work in [VS Code][02]. When I'm working on a binary module (or a
module with classes), I've gotten into the habit of reloading VS Code every time I build.
<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> pops the command window and `Reload Window` is always
at the top of my list.

### Nested PowerShell sessions

One other option is to have good Pester test coverage. Then you can adjust the build.ps1 script to
start a new PowerShell session, perform the build, run the tests, and close the session.

### Updating installed modules

This locking can be annoying when trying to update your locally installed module. If any session has
it loaded, you have to go hunt it down and close it. This is less of an issue when installing from a
PSGallery because module versioning places the new one in a different folder.

You can set up a local PSGallery and publish to that as part of your build. Then do your local
install from that PSGallery. This sounds like a lot of work, but this can be as simple as starting a
docker container. I cover a way to do that in my post on
[Using a NuGet server for a PSRepository][06].

## Final thoughts

I didn't touch on the C# syntax for creating a cmdlet, but there is plenty of documentation on it
in the [Windows PowerShell SDK][01]. It's definitely something worth experimenting with as a
stepping stone into more serious C#.

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/scripting/developer/windows-powershell-reference
[02]: https://code.visualstudio.com
[03]: https://github.com/PowerShell/PowerShell/blob/master/docs/cmdlet-example/command-line-simple-example.md
[04]: https://github.com/PowerShell/PowerShellStandard
[05]: https://powershellexplained.com/
[06]: https://powershellexplained.com/2018-03-03-Powershell-Using-a-NuGet-server-for-a-PSRepository/
[07]: https://powershellexplained.com/2018-08-04-Powershell-Standard-Library-Binary-Module/
[08]: https://twitter.com/KevinMarquette
[09]: https://www.microsoft.com/net/download/core
[10]: https://www.nuget.org/packages/PowerShellStandard.Library/

# /./reference/dev-cross-plat/choosing-the-right-nuget-package.md

    ---
    description: Alongside the executable packages published with each PowerShell release, the PowerShell team also maintains several packages available on NuGet. These packages allow targeting PowerShell as an API platform in .NET.
    ms.custom: rjmholt
    ms.date: 11/16/2022
    title: Choosing the right PowerShell NuGet package for your .NET project
    ---
# Choosing the right PowerShell NuGet package for your .NET project

Alongside the `pwsh` executable packages published with each PowerShell release, the PowerShell team
also maintains several packages available on [NuGet][25]. These packages allow targeting PowerShell
as an API platform in .NET.

As a .NET application that provides APIs and expects to load .NET libraries implementing its own
(binary modules), it's essential that PowerShell be available in the form of a NuGet package.

Currently there are several NuGet packages that provide some representation of the PowerShell API
surface area. Which package to use with a particular project hasn't always been made clear. This
article sheds some light on a few common scenarios for PowerShell-targeting .NET projects and how to
choose the right NuGet package to target for your PowerShell-oriented .NET project.

## Hosting vs referencing

Some .NET projects seek to write code to be loaded into a pre-existing PowerShell runtime (such as
`pwsh`, `powershell.exe`, the PowerShell Integrated Console or the ISE), while others want to run
PowerShell in their own applications.

- **Referencing** is for when a project, usually a module, is intended to be loaded into PowerShell.
  It must be compiled against the APIs that PowerShell provides in order to interact with it, but
  the PowerShell implementation is supplied by the PowerShell process loading it in. For
  referencing, a project can use [reference assemblies][07] or the actual runtime assemblies as a
  compilation target, but must ensure that it does not publish any of these with its build.
- **Hosting** is when a project needs its own implementation of PowerShell, usually because it is a
  standalone application that needs to run PowerShell. In this case, pure reference assemblies
  cannot be used. Instead, a concrete PowerShell implementation must be depended upon. Because a
  concrete PowerShell implementation must be used, a specific version of PowerShell must be chosen
  for hosting; a single host application cannot multi-target PowerShell versions.

### Publishing projects that target PowerShell as a reference

> [!NOTE]
> We use the term **publish** in this article to refer to running `dotnet publish`, which places a
> .NET library into a directory with all of its dependencies, ready for deployment to a particular
> runtime.

In order to prevent publishing project dependencies that are just being used as compilation
reference targets, it is recommended to set the [PrivateAssets][06] attribute:

```xml
<PackageReference Include="PowerShellStandard.Library" Version="5.1.0.0" PrivateAssets="all" />
```

If you forget to do this and use a reference assembly as your target, you may see issues related to
using the reference assembly's default implementation instead of the actual implementation. This may
take the form of a `NullReferenceException`, since reference assemblies often mock the
implementation API by simply returning `null`.

## Key kinds of PowerShell-targeting .NET projects

While any .NET library or application can embed PowerShell, there are some common scenarios that use
PowerShell APIs:

- **Implementing a PowerShell binary module**

  PowerShell binary modules are .NET libraries loaded by PowerShell that must implement PowerShell
  APIs like the [PSCmdlet][04] or [CmdletProvider][03] types in order to expose cmdlets or providers
  respectively. Because they are loaded in, modules seek to compile against references to PowerShell
  without publishing it in their build. It's also common for modules to want to support multiple
  PowerShell versions and platforms, ideally with a minimum of overhead of disk space, complexity,
  or repeated implementation. See [about_Modules][09] for more information about modules.

- **Implementing a PowerShell Host**

  A PowerShell Host provides an interaction layer for the PowerShell runtime. It is a specific form
  of _hosting_, where a [PSHost][01] is implemented as a new user interface to PowerShell. For
  example, the PowerShell ConsoleHost provides a terminal user interface for PowerShell executables,
  while the PowerShell Editor Services Host and the ISE Host both provide an editor-integrated
  partially graphical user interface around PowerShell. While it's possible to load a host onto an
  existing PowerShell process, it's much more common for a host implementation to act as a
  standalone PowerShell implementation that redistributes the PowerShell engine.

- **Calling into PowerShell from another .NET application**

  As with any application, PowerShell can be called as a subprocess to run workloads. However, as a
  .NET application, it's also possible to invoke PowerShell in-process to get back full .NET objects
  for use within the calling application. This is a more general form of _hosting_, where the
  application holds its own PowerShell implementation for internal use. Examples of this might be a
  service or daemon running PowerShell to manage machine state or a web application that runs
  PowerShell on request to do something like manage cloud deployments.

- **Unit testing PowerShell modules from .NET**

  While modules and other libraries designed to expose functionality to PowerShell should be
  primarily tested from PowerShell (we recommend [Pester][15]), sometimes it's necessary to unit
  test APIs written for a PowerShell module from .NET. This situation involves the module code
  trying to target a number of PowerShell versions, while testing should run it on specific,
  concrete implementations.

## PowerShell NuGet packages at a glance

In this article, we'll cover the following NuGet packages
that expose PowerShell APIs:

- [PowerShellStandard.Library][31], a reference assembly that enables building a single assembly
  that can be loaded by multiple PowerShell runtimes.
- [Microsoft.PowerShell.SDK][12], the way to target and rehost the whole PowerShell SDK
- The [System.Management.Automation][32] package, the core PowerShell runtime and engine
  implementation, that can be useful in minimal hosted implementations and for version-specific
  targeting scenarios.
- The **Windows PowerShell reference assemblies**, the way to target and effectively rehost Windows
  PowerShell (PowerShell versions 5.1 and below).

> [!NOTE]
> The [PowerShell NuGet][30] package is not a .NET library package at all, but instead provides the
> PowerShell dotnet global tool implementation. This should not be used by any projects, since it
> only provides an executable.

## PowerShellStandard.Library

The PowerShell Standard library is a reference assembly that captures the intersection of the APIs
of PowerShell versions 7, 6 and 5.1. This provides a compile-time-checked API surface to compile
.NET code against, allowing .NET projects to target PowerShell versions 7, 6 and 5.1 without risking
calling an API that won't be there.

PowerShell Standard is intended for writing PowerShell modules, or other code only intended to be
run after loading it into a PowerShell process. Because it is a reference assembly, PowerShell
Standard contains no implementation itself, so provides no functionality for standalone
applications.

### Using PowerShell Standard with different .NET runtimes

PowerShell Standard targets the [.NET Standard 2.0][08] target runtime, which is a façade runtime
designed to provide a common surface area shared by .NET Framework and .NET Core. This allows
targeting a single runtime to produce a single assembly that will work with multiple PowerShell
versions, but has the following consequences:

- The PowerShell loading the module or library must be running a minimum of .NET 4.6.1; .NET 4.6 and
  .NET 4.5.2 do not support .NET Standard. Note that a newer Windows PowerShell version does not
  mean a newer .NET Framework version; Windows PowerShell 5.1 may run on .NET 4.5.2.
- In order to work with a PowerShell running .NET Framework 4.7.1 or below, the .NET 4.6.1
  [NETStandard.Library][29] implementation is required to provide the netstandard.dll and other shim
  assemblies in older .NET Framework versions.

PowerShell 6+ provides its own shim assemblies for type forwarding from .NET Framework 4.6.1 (and
above) to .NET Core. This means that as long as a module uses only APIs that exist in .NET Core,
PowerShell 6+ can load and run it when it has been built for .NET Framework 4.6.1 (the `net461`
runtime target).

This means that binary modules using PowerShell Standard to target multiple PowerShell versions with
a single published DLL have two options:

1. Publishing an assembly built for the `net461` target runtime. This involves:
   - Publishing the project for the `net461` runtime
   - Also compiling against the `netstandard2.0` runtime (without using its build output) to ensure
     that all APIs used are also present in .NET Core.

1. Publishing an assembly build for the `netstandard2.0` target runtime. This requires:
   - Publishing the project for the `netstandard2.0` runtime
   - Taking the `net461` dependencies of NETStandard.Library and copying them into the project
     assembly's publish location so that the assembly is type-forwarded corrected in .NET Framework.

To build PowerShell modules or libraries targeting older .NET Framework versions, it may be
preferable to target multiple .NET runtimes. This will publish an assembly for each target runtime,
and the correct assembly will need to be loaded at module load time (for example with a small psm1
as the root module).

### Testing PowerShell Standard projects in .NET

When it comes to testing your module in .NET test runners like xUnit, remember that compile-time
checks can only go so far. You must test your module against the relevant PowerShell platforms.

To test APIs built against PowerShell Standard in .NET, you should add `Microsoft.Powershell.SDK` as
a testing dependency with .NET Core (with the version set to match the desired PowerShell version),
and the appropriate Windows PowerShell reference assemblies with .NET Framework.

For more information on PowerShell Standard and using it to write a binary module that works in
multiple PowerShell versions, see [this blog post][14]. Also see the
[PowerShell Standard repository][19] on GitHub.

## Microsoft.PowerShell.SDK

`Microsoft.PowerShell.SDK` is a meta-package that pulls together all of the components of the
PowerShell SDK into a single NuGet package. A self-contained .NET application can use
Microsoft.PowerShell.SDK to run arbitrary PowerShell functionality without depending on any external
PowerShell installations or libraries.

> [!NOTE]
> The PowerShell SDK just refers to all the component packages that make up PowerShell, and which
> can be used for .NET development with PowerShell.

A given `Microsoft.Powershell.SDK` version contains the concrete implementation of the same version
of the PowerShell application; version 7.0 contains the implementation of PowerShell 7.0 and running
commands or scripts with it will largely behave like running them in PowerShell 7.0.

Running PowerShell commands from the SDK is mostly, but not totally, the same as running them from
`pwsh`. For example, [Start-Job][10] currently depends on the `pwsh` executable being available, and
so will not work with `Microsoft.Powershell.SDK` by default.

Targeting `Microsoft.Powershell.SDK` from a .NET application allows you to integrate with all of
PowerShell's implementation assemblies, such as `System.Management.Automation`,
`Microsoft.PowerShell.Management`, and other module assemblies.

Publishing an application targeting `Microsoft.Powershell.SDK` will include all these assemblies,
and any dependencies PowerShell requires. It will also include other assets that PowerShell required
in its build, such as the module manifests for `Microsoft.PowerShell.*` modules and the `ref`
directory required by [Add-Type][11].

Given the completeness of `Microsoft.Powershell.SDK`, it's best suited for:

- Implementation of PowerShell hosts.
- xUnit testing of libraries targeting PowerShell reference assemblies.
- Invoking PowerShell in-process from a .NET application.

`Microsoft.PowerShell.SDK` may also be used as a reference target when a .NET project is intended to
be used as a module or otherwise loaded by PowerShell, but depends on APIs only present in a
particular version of PowerShell. Note that an assembly published against a specific version of
`Microsoft.PowerShell.SDK` will only be safe to load and use in that version of PowerShell. To
target multiple PowerShell versions with specific APIs, multiple builds are required, each targeting
their own version of `Microsoft.Powershell.SDK`.

> [!NOTE]
> The PowerShell SDK is only available for PowerShell versions 6 and up. To provide equivalent
> functionality with Windows PowerShell, use the Windows PowerShell reference assemblies described
> below.

## System.Management.Automation

The `System.Management.Automation` package is the heart of the PowerShell SDK. It exists on NuGet,
primarily, as an asset for `Microsoft.Powershell.SDK` to pull in. However, it can also be used
directly as a package for smaller hosting scenarios and version-targeting modules.

Specifically, the `System.Management.Automation` package may be a preferable provider of PowerShell
functionality when:

- You're only looking to use PowerShell language functionality (in the
  `System.Management.Automation.Language` namespace) like the PowerShell parser, AST, and AST
  visitor APIs (for example for static analysis of PowerShell).
- You only wish to execute specific commands from the `Microsoft.PowerShell.Core` module and can
  execute them in a session state created with the [CreateDefault2][05] factory method.

Additionally, `System.Management.Automation` is a useful reference assembly when:

- You wish to target APIs that are only present within a specific PowerShell version
- You won't be depending on types occurring outside the `System.Management.Automation` assembly (for
  example, types exported by cmdlets in `Microsoft.PowerShell.*` modules).

## Windows PowerShell reference assemblies

For PowerShell versions 5.1 and older (Windows PowerShell), there is no SDK to provide an
implementation of PowerShell, since Windows PowerShell's implementation is a part of Windows.

Instead, the Windows PowerShell reference assemblies provide both reference targets and a way to
rehost Windows PowerShell, acting the same as the PowerShell SDK does for versions 6 and up.

Rather than being differentiated by version, Windows PowerShell reference assemblies have a
different package for each version of Windows PowerShell:

- [PowerShell 5.1][28]
- [PowerShell 4][27]
- [PowerShell 3][26]

Information on how to use the Windows PowerShell reference assemblies can be found in the
[Windows PowerShell SDK][12].

## Real-world examples using these NuGet packages

Different PowerShell tooling projects target different PowerShell NuGet packages depending on their
needs. Listed here are some notable examples.

### PSReadLine

[PSReadLine][20], the PowerShell module that provides much of PowerShell's rich console experience,
targets PowerShell Standard as a dependency rather than a specific PowerShell version, and targets
the `net461` .NET runtime in its [csproj][21].

PowerShell 6+ supplies its own shim assemblies that allow a DLL targeting the `net461` runtime to
"just work" when loaded in (by redirecting binding to .NET Framework's `mscorlib.dll` to the
relevant .NET Core assembly).

This simplifies PSReadLine's module layout and delivery significantly, since PowerShell Standard
ensures the only APIs used will be present in both PowerShell 5.1 and PowerShell 6+, while also
allowing the module to ship with only a single assembly.

The .NET 4.6.1 target does mean that Windows PowerShell running on
.NET 4.5.2 and .NET 4.6 is not supported though.

### PowerShell Editor Services

[PowerShell Editor Services][16] (PSES) is the backend for the [PowerShell extension][24] for
[Visual Studio Code][13], and is actually a form of PowerShell module that gets loaded by a
PowerShell executable and then takes over that process to rehost PowerShell within itself while also
providing Language Service Protocol and Debug Adapter features.

PSES provides concrete implementation targets for `netcoreapp2.1` to target PowerShell 6+ (since
PowerShell 7's `netcoreapp3.1` runtime is backwards compatible) and `net461` to target Windows
PowerShell 5.1, but contains most of its logic in a second assembly that targets `netstandard2.0`
and PowerShell Standard. This allows it to pull in dependencies required for .NET Core and .NET
Framework platforms, while still simplifying most of the codebase behind a uniform abstraction.

Because it is built against PowerShell Standard, PSES requires a runtime implementation of
PowerShell in order to be tested correctly. To do this, [PSES's xUnit][18] tests pull in
`Microsoft.PowerShell.SDK` and `Microsoft.PowerShell.5.ReferenceAssemblies` in order to provide a
PowerShell implementation in the test environment.

As with PSReadLine, PSES cannot support .NET 4.6 and below, but it [performs a check][17] at runtime
before calling any of the APIs that could cause a crash on the lower .NET Framework runtimes.

### PSScriptAnalyzer

[PSScriptAnalyzer][22], the linter for PowerShell, must target syntactic elements only introduced in
certain versions of PowerShell. Because recognition of these syntactic elements is accomplished by
implementing an [AstVisitor2][02], it's not possible to use PowerShellStandard and also implement
AST visitor methods for newer PowerShell syntaxes.

Instead, PSScriptAnalyzer [targets each PowerShell version][23] as a build configuration, and
produces a separate DLL for each of them. This increases build size and complexity, but allows:

- Version-specific API targeting
- Version-specific functionality to be implemented with essentially no runtime cost
- Total support for Windows PowerShell all the way down to .NET Framework 4.5.2

## Summary

In this article, we've listed and discussed the NuGet packages available to target when implementing
a .NET project that uses PowerShell, and the reasons you might have for using one over another.

If you've skipped to the summary, some broad recommendations are:

- PowerShell **modules** should compile against PowerShell Standard if they only require APIs common
  to different PowerShell versions.
- PowerShell **hosts and applications** that need to run PowerShell internally should target the
  PowerShell SDK for PowerShell 6+ or the relevant Windows PowerShell reference assemblies for
  Windows PowerShell.
- PowerShell modules that need **version-specific APIs** should target the PowerShell SDK or Windows
  PowerShell reference assemblies for the required PowerShell versions, using them as reference
  assemblies (that is, not publishing the PowerShell dependencies).

<!--link references -->
[01]: https://learn.microsoft.com/dotnet/api/system.management.automation.host.pshost
[02]: https://learn.microsoft.com/dotnet/api/system.management.automation.language.astvisitor2
[03]: https://learn.microsoft.com/dotnet/api/system.management.automation.provider.cmdletprovider
[04]: https://learn.microsoft.com/dotnet/api/system.management.automation.pscmdlet
[05]: https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.initialsessionstate.createdefault2
[06]: https://learn.microsoft.com/dotnet/core/tools/csproj#packagereference
[07]: https://learn.microsoft.com/dotnet/standard/assembly/reference-assemblies
[08]: https://learn.microsoft.com/dotnet/standard/net-standard
[09]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_modules
[10]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/start-job
[11]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/add-type
[12]: https://learn.microsoft.com/powershell/scripting/developer/windows-powershell
[13]: https://code.visualstudio.com/
[14]: https://devblogs.microsoft.com/powershell/powershell-standard-library-build-single-module-that-works-across-windows-powershell-and-powershell-core/
[15]: https://github.com/Pester/Pester
[16]: https://github.com/PowerShell/PowerShellEditorServices/
[17]: https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/src/PowerShellEditorServices.Hosting/EditorServicesLoader.cs#L231-L251
[18]: https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/test/PowerShellEditorServices.Test/PowerShellEditorServices.Test.csproj#L15-L20
[19]: https://github.com/PowerShell/PowerShellStandard
[20]: https://github.com/PowerShell/PSReadLine
[21]: https://github.com/PowerShell/PSReadLine/blob/master/PSReadLine/PSReadLine.csproj
[22]: https://github.com/powershell/psscriptanalyzer
[23]: https://github.com/PowerShell/PSScriptAnalyzer/blob/master/Engine/Engine.csproj
[24]: https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell
[25]: https://www.nuget.org/
[26]: https://www.nuget.org/packages/Microsoft.PowerShell.3.ReferenceAssemblies/
[27]: https://www.nuget.org/packages/Microsoft.PowerShell.4.ReferenceAssemblies/
[28]: https://www.nuget.org/packages/Microsoft.PowerShell.5.ReferenceAssemblies/
[29]: https://www.nuget.org/packages/NETStandard.Library/
[30]: https://www.nuget.org/packages/PowerShell/
[31]: https://www.nuget.org/packages/PowerShellStandard.Library/
[32]: https://www.nuget.org/packages/System.Management.Automation/

# /./reference/dev-cross-plat/resolving-dependency-conflicts.md

    ---
    description: When writing a binary PowerShell module in C#, it's natural to take dependencies on other packages or libraries to provide functionality.
    ms.custom: rjmholt
    ms.date: 08/08/2022
    title: Resolving PowerShell module assembly dependency conflicts
    ---
# Resolving PowerShell module assembly dependency conflicts

When writing a binary PowerShell module in C#, it's natural to take dependencies on other packages
or libraries to provide functionality. Taking dependencies on other libraries is desirable for code
reuse. PowerShell always loads assemblies into the same context. This presents issues when a
module's dependencies conflict with already-loaded DLLs and may prevent using two otherwise
unrelated modules in the same PowerShell session.

If you've had this problem, you've seen an error message like this:

![Assembly load conflict error message][1]


This article looks at some ways dependency conflicts occur in PowerShell and ways to mitigate
dependency conflict issues. Even if you're not a module author, there are some tricks in here that
might help you with dependency conflicts occurring in modules that you use.

## Why do dependency conflicts occur?

In .NET, dependency conflicts occur when two versions of the same assembly are loaded into the same
_Assembly Load Context_. This term means slightly different things on different .NET platforms,
which is covered [later][2] in this article. This conflict is a common problem that occurs in any
software where versioned dependencies are used.

Conflict issues are compounded by the fact that a project almost never deliberately or directly
depends on two versions of the same dependency. Instead, the project has two or more dependencies
that each require a different version of the same dependency.

For example, say your .NET application, `DuckBuilder`, brings in two dependencies, to perform parts
of its functionality and looks like this:

[Two dependencies of DuckBuilder rely on different versions of Newtonsoft.Json][3]


                       ┌─────────────────────────────────────┐
                       │                                     │
                       │          DuckBuilder,v1.0.0         │
                       │                                     │
                       └────┬───────────────────────────┬────┘
                            │                           │
     ┌──────────────────────V────────┐       ┌──────────V──────────────────┐
     │                               │       │                             │
     │    Contoso.ZipTools,v2.0.3    │       │ Fabrikam.FileHelpers,v0.8.0 │
     │                               │       │                             │
     └─────────────┬─────────────────┘       └─────────────────┬───────────┘
                   │                                           │
    ┌──────────────V───────────┐                   ┌───────────V─────────────┐
    │                          │                   │                         │
    │ Newtonsoft.Json,v11.0.2  │ <------ ⊘ ------> │ Newtonsoft.Json,v12.0.3 │
    │                          │                   │                         │
    └──────────────────────────┘                   └─────────────────────────┘


Because `Contoso.ZipTools` and `Fabrikam.FileHelpers` both depend on different versions of
**Newtonsoft.Json**, there may be a dependency conflict depending on how each dependency is loaded.

### Conflicting with PowerShell's dependencies

In PowerShell, the dependency conflict issue is magnified because PowerShell's own dependencies are
loaded into the same shared context. This means the PowerShell engine and all loaded PowerShell
modules must not have conflicting dependencies. A classic example of this is **Newtonsoft.Json**:

[FictionalTools module depends on newer version of Newtonsoft.Json than PowerShell][4]


    ┌─────────────────────────────┐
    │                             │
    │   Newtonsoft.Json,v11.0.2   │<────┐
    │                             │     │
    └──────────────A──────────────┘     │
                   │                    │
      ┌────────────┴────────────┐       │
      │                         │       │
      │        PowerShell       │       │
      │                         │       │
      └─────────────┬───────────┘       │
                    │                   ⊘
      ┌─────────────V───────────┐       │
      │                         │       │
      │     FictionalTools      │       │
      │                         │       │
      └─────────────────────────┘       │
                    │                   │
    ┌───────────────V─────────────┐     │
    │                             │     │
    │   Newtonsoft.Json,v12.0.3   │<────┘
    │                             │
    └─────────────────────────────┘

In this example, the module `FictionalTools` depends on **Newtonsoft.Json** version `12.0.3`, which is
a newer version of **Newtonsoft.Json** than `11.0.2` that ships in the example PowerShell.

> [!NOTE]
> This is an example. PowerShell 7.0 currently ships with **Newtonsoft.Json 12.0.3**. Newer versions
> of PowerShell have newer versions of **Newtonsoft.Json**.

Because the module depends on a newer version of the assembly, it won't accept the version that
PowerShell already has loaded. But because PowerShell has already loaded a version of the assembly,
the module can't load its own version using the conventional load mechanism.

### Conflicting with another module's dependencies

Another common scenario in PowerShell is that a module is loaded that depends on one version of an
assembly, and then another module is loaded later that depends on a different version of that
assembly.

This often looks like the following:

[Two PowerShell modules require different versions of the Microsoft.Extensions.Logging dependency][5]

                            ┌────────────────────────────────────┐
                            │                                    │
                            │             PowerShell             │
                            │                                    │
                            └───┬───────────────────────────┬────┘
                                │                           │
            ┌───────────────────V──┐                    ┌───V──────────────────┐
            │                      │                    │                      │
            │    FictionalTools    │                    │  FilesystemManager   │
            │                      │                    │                      │
            └──────────┬───────────┘                    └──────────┬───────────┘
                       │                                           │
    ┌──────────────────V─────────────────┐       ┌─────────────────V───────────────────┐
    │                                    │       │                                     │
    │ Microsoft.Extensions.Loggin,v3.1.4 │<- ⊘ ->│ Microsoft.Extensions.Logging,v2.2.0 │
    │                                    │       │                                     │
    └────────────────────────────────────┘       └─────────────────────────────────────┘

In this case, the `FictionalTools` module requires a newer version of `Microsoft.Extensions.Logging`
than the `FilesystemManager` module.

Imagine these modules load their dependencies by placing the dependency assemblies in the same
directory as the root module assembly. This allows .NET to implicitly load them by name. If we're
running PowerShell 7.0 (on top of .NET Core 3.1), we can load and run `FictionalTools`, then load
and run `FilesystemManager` without issue. However, in a new session, if we load and run
`FilesystemManager`, then load `FictionalTools`, we get a `FileLoadException` from the
`FictionalTools` command because it requires a newer version of `Microsoft.Extensions.Logging` than
the one loaded. `FictionalTools` can't load the version needed because an assembly of the same name
has already been loaded.

## PowerShell and .NET

PowerShell runs on the .NET platform, which is responsible for resolving and loading assembly
dependencies. We must understand how .NET operates here to understand dependency conflicts.

We must also confront the fact that different versions of PowerShell run on different .NET
implementations. In general, PowerShell 5.1 and below run on .NET Framework, while PowerShell 6 and
above run on .NET Core. These two implementations of .NET load and handle assemblies differently.
This means that resolving dependency conflicts can vary depending on the underlying .NET platform.

### Assembly Load Contexts

In .NET, an _Assembly Load Context_ (ALC) is a runtime namespace into which assemblies are loaded.
The assemblies' names must be unique. This concept allows assemblies to be uniquely resolved by name
in each ALC.

### Assembly reference loading in .NET

The semantics of assembly loading depend on both the .NET implementation (.NET Core vs .NET
Framework) and the .NET API used to load a particular assembly. Rather than go into detail here,
there are links in the [Further reading][6] section that go into great detail on how .NET assembly
loading works in each .NET implementation.

In this article we'll refer to the following mechanisms:

- Implicit assembly loading (effectively `Assembly.Load(AssemblyName)`), when .NET implicitly tries
  to load an assembly by name from a static assembly reference in .NET code.
- `Assembly.LoadFrom()`, a plugin-oriented loading API that adds handlers to resolve dependencies of
  the loaded DLL. This method may not resolve dependencies the way we want.
- `Assembly.LoadFile()`, a basic loading API intended to load only the assembly asked for and does
  not handle any dependencies.

### Differences in .NET Framework vs .NET Core

The way these APIs work has changed in subtle ways between .NET Core and .NET Framework, so it's
worth reading through the included [links][7]. Importantly, Assembly Load Contexts and other
assembly resolution mechanisms have changed between .NET Framework and .NET Core.

In particular, .NET Framework has the following features:

- The Global Assembly Cache, for machine-wide assembly resolution
- Application Domains, which work like in-process sandboxes for assembly isolation, but also present
  a serialization layer to contend with
- A limited assembly load context model that has a fixed set of assembly load contexts, each with
  their own behavior:
  - The default load context, where assemblies are loaded by default
  - The load-from context, for loading assemblies manually at runtime
  - The reflection-only context, for safely loading assemblies
    to read their metadata without running them
  - The mysterious void that assemblies loaded with `Assembly.LoadFile(string path)` and
    `Assembly.Load(byte[] asmBytes)` live in

For more information, see [Best Practices for Assembly Loading][8].

.NET Core (and .NET 5+) has replaced this complexity with a simpler model:

- No Global Assembly Cache. Applications bring all their own dependencies. This removes an external
  factor for dependency resolution in applications, making dependency resolution more reproducible.
  PowerShell, as the plugin host, complicates this slightly for modules. Its dependencies in
  `$PSHOME` are shared with all modules.
- Only one Application Domain, and no ability to create new ones. The Application Domain concept
  is maintained in .NET to be the global state of the .NET process.
- A new, extensible Assembly Load Context (ALC) model. Assembly resolution can be namespaced by putting it
  in a new ALC. .NET processes begin with a single default ALC into which all assemblies are
  loaded (except for those loaded with `Assembly.LoadFile(string)` and `Assembly.Load(byte[])`). But
  the process can create and define its own custom ALCs with its own loading logic. When an assembly
  is loaded, the first ALC it's loaded into is responsible for resolving its dependencies. This
  creates opportunities to implement powerful .NET plugin loading mechanisms.

In both implementations, assemblies are loaded lazily. This means that they're loaded when a method
requiring their type is run for the first time.

For example, here are two versions of the same code that load a dependency at different times.

The first always loads its dependency when `Program.GetRange()` is called, because the dependency
reference is lexically present within the method:

```csharp
using Dependency.Library;

public static class Program
{
    public static List<int> GetRange(int limit)
    {
        var list = new List<int>();
        for (int i = 0; i < limit; i++)
        {
            if (i >= 20)
            {
                // Dependency.Library will be loaded when GetRange is run
                // because the dependency call occurs directly within the method
                DependencyApi.Use();
            }

            list.Add(i);
        }
        return list;
    }
}
```

The second loads its dependency only if the `limit` parameter is 20 or more, because of the internal
indirection through a method:

```csharp
using Dependency.Library;

public static class Program
{
    public static List<int> GetNumbers(int limit)
    {
        var list = new List<int>();
        for (int i = 0; i < limit; i++)
        {
            if (i >= 20)
            {
                // Dependency.Library is only referenced within
                // the UseDependencyApi() method,
                // so will only be loaded when limit >= 20
                UseDependencyApi();
            }

            list.Add(i);
        }
        return list;
    }

    private static void UseDependencyApi()
    {
        // Once UseDependencyApi() is called, Dependency.Library is loaded
        DependencyApi.Use();
    }
}
```

This is a good practice since it minimizes the memory and filesystem I/O and uses the resources more
efficiently. The unfortunate a side effect of this is that we won't know that the assembly fails to
load until we reach the code path that tries to load the assembly.

It can also create a timing condition for assembly load conflicts. If two parts of the same program
try to load different versions of the same assembly, the version loaded depends on which code path
is run first.

For PowerShell, this means that the following factors can affect an assembly load conflict:

- Which module was loaded first?
- Was the code path that uses the dependency library run?
- Does PowerShell load a conflicting dependency at startup or only under certain code paths?

## Quick fixes and their limitations

In some cases, it's possible to make small adjustments to your module and fix things with minimal
effort. But these solutions tend to come with caveats. While they may apply to your module, they
won't work for every module.

### Change your dependency version

The simplest way to avoid dependency conflicts is to agree on a dependency. This may be possible
when:

- Your conflict is with a direct dependency of your module and you control the version.
- Your conflict is with an indirect dependency, but you can configure your direct dependencies to
  use a workable indirect dependency version.
- You know the conflicting version and can rely on it not changing.

The **Newtonsoft.Json** package is a good example of this last scenario. This is a dependency of
PowerShell 6 and above, and isn't used in Windows PowerShell. Meaning a simple way to resolve
versioning conflicts is to target the lowest version of **Newtonsoft.Json** across the PowerShell
versions you wish to target.

For example, PowerShell 6.2.6 and PowerShell 7.0.2 both currently use **Newtonsoft.Json** version
12.0.3. To create a module targeting Windows PowerShell, PowerShell 6, and PowerShell 7, you would
target **Newtonsoft.Json 12.0.3** as a dependency and include it in your built module. When the
module is loaded in PowerShell 6 or 7, PowerShell's own **Newtonsoft.Json** assembly is already
loaded. Since it's the version required for your module, resolution succeeds. In Windows PowerShell,
the assembly isn't already present in PowerShell, so it's loaded from your module folder instead.

Generally, when targeting a concrete PowerShell package, like **Microsoft.PowerShell.Sdk** or
**System.Management.Automation**, NuGet should be able to resolve the right dependency versions
required. Targeting both Windows PowerShell and PowerShell 6+ becomes more difficult because you
must choose between targeting multiple frameworks or **PowerShellStandard.Library**.

Circumstances where pinning to a common dependency version won't work include:

- The conflict is with an indirect dependency, and none of your dependencies can be configured to
  use a common version.
- The other dependency version is likely to change often, so settling on a common version is only a
  short-term fix.

### Use the dependency out of process

This solution is more for module users than module authors. This is a solution to use when
confronted with a module that won't work due to an existing dependency conflict.

Dependency conflicts occur because two versions of the same assembly are loaded into the same .NET
process. A simple solution is to load them into different processes, as long as you can still
use the functionality from both together.

In PowerShell, there are several ways to achieve this:

- Invoke PowerShell as a subprocess

  To run a PowerShell command out of the current process, start a new PowerShell process directly
  with the command call:

  ```powershell
  pwsh -c 'Invoke-ConflictingCommand'
  ```

  The main limitation here is that restructuring the result can be trickier or more error prone than
  other options.

- The PowerShell job system

  The PowerShell job system also runs commands out of process, by sending commands to a new
  PowerShell process and returning the results:

  ```powershell
  $result = Start-Job { Invoke-ConflictingCommand } | Receive-Job -Wait
  ```

  In this case, you just need to be sure that any variables and state are passed in correctly.

  The job system can also be slightly cumbersome when running small commands.

- PowerShell remoting

  When it's available, PowerShell remoting can be a useful way to run commands out of process. With
  remoting, you can create a fresh **PSSession** in a new process, call its commands over PowerShell
  remoting, then use the results locally with the other modules containing the conflicting
  dependencies.

  An example might look like this:

  ```powershell
  # Create a local PowerShell session
  # where the module with conflicting assemblies will be loaded
  $s = New-PSSession

  # Import the module with the conflicting dependency via remoting,
  # exposing the commands locally
  Import-Module -PSSession $s -Name ConflictingModule

  # Run a command from the module with the conflicting dependencies
  Invoke-ConflictingCommand
  ```

- Implicit remoting to Windows PowerShell

  Another option in PowerShell 7 is to use the `-UseWindowsPowerShell` flag on `Import-Module`. This
  imports the module through a local remoting session into Windows PowerShell:

  ```powershell
  Import-Module -Name ConflictingModule -UseWindowsPowerShell
  ```

  Be aware that modules may not be compatible with or may work differently with Windows PowerShell.

#### When out-of-process invocation should not be used

As a module author, out-of-process command invocation is difficult to bake into a module and may
have edge cases that cause issues. In particular, remoting and jobs may not be available in all
environments where your module needs to work. However, the general principle of moving the
implementation out of process and allowing the PowerShell module to be a thinner client, may still
be applicable.

As a module user, there are cases where out-of-process invocation won't work:

- When PowerShell remoting is unavailable because you don't have privileges to use it or it
  is not enabled.
- When a particular .NET type is needed from output as input to a method or another command.
  Commands running over PowerShell remoting emit deserialized objects rather than strongly-typed
  .NET objects. This means that method calls and strongly typed APIs don't work with the output of
  commands imported over remoting.

## More robust solutions

The previous solutions all had scenarios and modules that don't work. However, they also have the
virtue of being relatively simple to implement correctly. The following solutions are more robust,
but require more effort to implement correctly and can introduce subtle bugs if not written
carefully.

### Loading through .NET Core Assembly Load Contexts

[Assembly Load Contexts][9] (ALCs) were introduced in .NET Core 1.0 to specifically address the need
to load multiple versions of the same assembly into the same runtime.

Within .NET, they offer the most robust solution to the problem of loading conflicting versions of
an assembly. However, custom ALCs are not available in .NET Framework. This means that this solution
only works in PowerShell 6 and above.

Currently, the best example of using an ALC for dependency isolation in PowerShell is in PowerShell
Editor Services, the language server for the PowerShell extension for Visual Studio Code. An
[ALC is used][10] to prevent PowerShell Editor Services' own dependencies from clashing with those
in PowerShell modules.

Implementing module dependency isolation with an ALC is conceptually difficult, but we will work
through a minimal example. Imagine we have a simple module that is only intended to work in
PowerShell 7. The source code is organized as follows:

```
+ AlcModule.psd1
+ src/
    + TestAlcModuleCommand.cs
    + AlcModule.csproj
```

The cmdlet implementation looks like this:

```csharp
using Shared.Dependency;

namespace AlcModule
{
    [Cmdlet(VerbsDiagnostic.Test, "AlcModule")]
    public class TestAlcModuleCommand : Cmdlet
    {
        protected override void EndProcessing()
        {
            // Here's where our dependency gets used
            Dependency.Use();
            // Something trivial to make our cmdlet do *something*
            WriteObject("done!");
        }
    }
}
```

The (heavily simplified) manifest, looks like this:

```powershell
@{
    Author = 'Me'
    ModuleVersion = '0.0.1'
    RootModule = 'AlcModule.dll'
    CmdletsToExport = @('Test-AlcModule')
    PowerShellVersion = '7.0'
}
```

And the `csproj` looks like this:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Shared.Dependency" Version="1.0.0" />
    <PackageReference Include="Microsoft.PowerShell.Sdk" Version="7.0.1" PrivateAssets="all" />
  </ItemGroup>
</Project>
```

When we build this module, the generated output has the following layout:

```
AlcModule/
  + AlcModule.psd1
  + AlcModule.dll
  + Shared.Dependency.dll
```

In this example, our problem is in the `Shared.Dependency.dll` assembly, which is our imaginary
conflicting dependency. This is the dependency that we need to put behind an ALC so that we can use
the module-specific version.

We need to re-engineer the module so that:

- Module dependencies are only loaded into our custom ALC, and not into PowerShell's ALC, so
  there can be no conflict. Moreover, as we add more dependencies to our project, we don't want to
  continuously add more code to keep loading working. Instead, we want reusable, generic dependency
  resolution logic.
- Loading the module still works as normal in PowerShell. Cmdlets and other types that the
  PowerShell module system needs are defined within PowerShell's own ALC.

To mediate these two requirements, we must break up our module into two assemblies:

- A cmdlets assembly, `AlcModule.Cmdlets.dll`, that contains definitions of all the types that
  PowerShell's module system needs to load our module correctly. Namely, any implementations of the
  `Cmdlet` base class and the class that implements `IModuleAssemblyInitializer`, which sets up the
  event handler for `AssemblyLoadContext.Default.Resolving` to properly load `AlcModule.Engine.dll`
  through our custom ALC. Since PowerShell 7 deliberately hides types defined in assemblies loaded
  in other ALCs, any types that are meant to be publicly exposed to PowerShell must also be defined
  here. Finally, our custom ALC definition needs to be defined in this assembly. Beyond that, as
  little code as possible should live in this assembly.
- An engine assembly, `AlcModule.Engine.dll`, that handles the actual implementation of the module.
  Types from this are available in the PowerShell ALC, but it's initially loaded through our custom
  ALC. Its dependencies are only loaded into the custom ALC. Effectively, this becomes a _bridge_
  between the two ALCs.

Using this bridge concept, our new assembly situation looks like this:

[Diagram representing AlcModule.Engine.dll bridging the two ALCs][11]

    ┌──────────────────────────────────────┐        ┌───────────────────────────────────────┐
    │                                      │        │                                       │
    │         PowerShell (Default)         │        │          AlcModule (Custom)           │
    │         Assembly Load Context        │        │        Assembly Load Context          │
    │                                      │        │                                       │
    │  ┌───────────────────────┐    ┌──────────────────────┐    ┌───────────────────────┐   │
    │  │                       │    │                      │    │                       │   │
    │  │ AlcModule.Cmdlets.dll │<---│ AlcModule.Engine.dll │<---│ Shared.Dependency.dll │   │
    │  │                       │    │                      │    │                       │   │
    │  └───────────────────────┘    └──────────────────────┘    └───────────────────────┘   │
    │                                      │        │                                       │
    └──────────────────────────────────────┘        └───────────────────────────────────────┘


To make sure the default ALC's dependency probing logic doesn't resolve the dependencies to be
loaded into the custom ALC, we need to separate these two parts of the module in different
directories. The new module layout has the following structure:

```
AlcModule/
  AlcModule.Cmdlets.dll
  AlcModule.psd1
  Dependencies/
  | + AlcModule.Engine.dll
  | + Shared.Dependency.dll
```

To see how the implementation changes, we'll start with the implementation of
`AlcModule.Engine.dll`:

```csharp
using Shared.Dependency;

namespace AlcModule.Engine
{
    public class AlcEngine
    {
        public static void Use()
        {
            Dependency.Use();
        }
    }
}
```

This is a simple container for the dependency, `Shared.Dependency.dll`, but you should think of it
as the .NET API for your functionality that the cmdlets in the other assembly wrap for PowerShell.

The cmdlet in `AlcModule.Cmdlets.dll` looks like this:

```csharp
// Reference our module's Engine implementation here
using AlcModule.Engine;

namespace AlcModule.Cmdlets
{
    [Cmdlet(VerbsDiagnostic.Test, "AlcModule")]
    public class TestAlcModuleCommand : Cmdlet
    {
        protected override void EndProcessing()
        {
            AlcEngine.Use();
            WriteObject("done!");
        }
    }
}
```

At this point, if we were to load **AlcModule** and run `Test-AlcModule`, we get a
**FileNotFoundException** when the default ALC tries to load `Alc.Engine.dll` to run
`EndProcessing()`. This is good, since it means the default ALC can't find the dependencies we want
to hide.

Now we need to add code to `AlcModule.Cmdlets.dll` so that it knows how to resolve
`AlcModule.Engine.dll`. First we must define our custom ALC to resolve assemblies from our module's
`Dependencies` directory:

```csharp
namespace AlcModule.Cmdlets
{
    internal class AlcModuleAssemblyLoadContext : AssemblyLoadContext
    {
        private readonly string _dependencyDirPath;

        public AlcModuleAssemblyLoadContext(string dependencyDirPath)
        {
            _dependencyDirPath = dependencyDirPath;
        }

        protected override Assembly Load(AssemblyName assemblyName)
        {
            // We do the simple logic here of looking for an assembly of the given name
            // in the configured dependency directory.
            string assemblyPath = Path.Combine(
                _dependencyDirPath,
                $"{assemblyName.Name}.dll");

            if (File.Exists(assemblyPath))
            {
                // The ALC must use inherited methods to load assemblies.
                // Assembly.Load*() won't work here.
                return LoadFromAssemblyPath(assemblyPath);
            }

            // For other assemblies, return null to allow other resolutions to continue.
            return null;
        }
    }
}
```

Then we need to hook up our custom ALC to the default ALC's `Resolving` event, which is the ALC
version of the `AssemblyResolve` event on Application Domains. This event is fired to find
`AlcModule.Engine.dll` when `EndProcessing()` is called.

```csharp
namespace AlcModule.Cmdlets
{
    public class AlcModuleResolveEventHandler : IModuleAssemblyInitializer, IModuleAssemblyCleanup
    {
        // Get the path of the dependency directory.
        // In this case we find it relative to the AlcModule.Cmdlets.dll location
        private static readonly string s_dependencyDirPath = Path.GetFullPath(
            Path.Combine(
                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                "Dependencies"));

        private static readonly AlcModuleAssemblyLoadContext s_dependencyAlc =
            new AlcModuleAssemblyLoadContext(s_dependencyDirPath);

        public void OnImport()
        {
            // Add the Resolving event handler here
            AssemblyLoadContext.Default.Resolving += ResolveAlcEngine;
        }

        public void OnRemove(PSModuleInfo psModuleInfo)
        {
            // Remove the Resolving event handler here
            AssemblyLoadContext.Default.Resolving -= ResolveAlcEngine;
        }

        private static Assembly ResolveAlcEngine(AssemblyLoadContext defaultAlc, AssemblyName assemblyToResolve)
        {
            // We only want to resolve the Alc.Engine.dll assembly here.
            // Because this will be loaded into the custom ALC,
            // all of *its* dependencies will be resolved
            // by the logic we defined for that ALC's implementation.
            //
            // Note that we are safe in our assumption that the name is enough
            // to distinguish our assembly here,
            // since it's unique to our module.
            // There should be no other AlcModule.Engine.dll on the system.
            if (!assemblyToResolve.Name.Equals("AlcModule.Engine"))
            {
                return null;
            }

            // Allow our ALC to handle the directory discovery concept
            //
            // This is where Alc.Engine.dll is loaded into our custom ALC
            // and then passed through into PowerShell's ALC,
            // becoming the bridge between both
            return s_dependencyAlc.LoadFromAssemblyName(assemblyToResolve);
        }
    }
}
```

With the new implementation, take a look at the sequence of calls that occurs when the
module is loaded and `Test-AlcModule` is run:

[Sequence diagram of calls using the custom ALC to load dependencies][12]

        ┌─┐   
        ║"│   
        └┬┘   
        ┌┼┐   
         │                  ┌──────────┐  ┌────────────────────┐          ┌────────────────────┐   ┌────────────────────────────┐   ┌────────────────────┐    ┌─────────┐     ┌──────────┐
        ┌┴┐                 │PowerShell│  │AlcModuleInitializer│          │DefaultALC.Resolving│   │AlcModuleAssemblyLoadContext│   │TestAlcModuleCommand│    │AlcEngine│     │Dependency│
      Prompt                └────┬─────┘  └─────────┬──────────┘          └─────────┬──────────┘   └─────────────┬──────────────┘   └─────────┬──────────┘    └────┬────┘     └────┬─────┘
        │                        │        customALC=new()(static initialization)    │                            │                            │                    │               │      
        │ ───────────────────────────────────────────────────────────────────────────────────────────────────────>                            │                    │               │      
        │                        │                  │                               │                            │                            │                    │               │      
        │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ── ─ ─ ─ ─ ─ ─ ─                             │                    │               │      
        │                        │                  │                               │                            │                            │                    │               │      
        │ Import-Module AlcModule│                  │                               │                            │                            │                    │               │      
        │ ───────────────────────>                  │                               │                            │                            │                    │               │      
        │                        │    new()         │                               │                            │                            │                    │               │      
        │                        │ ─────────────────>                               │                            │                            │                    │               │      
        │                        │                  │                               │                            │                            │                    │               │      
        │                        │ <── ─ ─ ─ ─ ─ ─ ─                               │                            │                            │                    │               │      
        │                        │   OnImport()     │                               │                            │                            │                    │               │      
        │                        │ ─────────────────>                               │                            │                            │                    │               │      
        │                        │                  │  add_Event(ResolveAlcEngine)  │                            │                            │                    │               │      
        │                        │                  │ ──────────────────────────────>                            │                            │                    │               │      
        │                        │                  │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│                            │                            │                    │               │      
        │                        │ <─ ─ ─ ─ ─ ─ ─ ─ ─                               │                            │                            │                    │               │      
        │                        │                  │                               │                            │                            │                    │               │      
        │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─                  │                               │                            │                            │                    │               │      
        │     Test-AlcModule     │                  │                               │                            │                            │                    │               │      
        │ ───────────────────────>                  │                               │                            │                            │                    │               │      
        │                        │                  │                        EndProcessing()                     │                            │                    │               │      
        │                        │ ───────────────────────────────────────────────────────────────────────────────────────────────────────────>                    │               │      
        │                        │                  │                               │       Resolving(assembly not found in default ALC)      │                    │               │      
        │                        │                  │                               │ <────────────────────────────────────────────────────────                    │               │      
        │                        │                  │       ResolveAlcEngine()      │                            │                            │                    │               │      
        │                        │                  │ <──────────────────────────────                            │                            │                    │               │      
        │                        │                  │                       LoadFromAssemblyName()               │                            │                    │               │      
        │                        │                  │ ───────────────────────────────────────────────────────────>                            │                    │               │      
        │                        │                  │                               │                            │────┐                       │                    │               │      
        │                        │                  │                               │                            │    │ Load()                │                    │               │      
        │                        │                  │                               │                            │<───┘                       │                    │               │      
        │                        │                  │                               │                            │────┐                       │                    │               │      
        │                        │                  │                               │                            │    │ LoadFromAssemblyPath()│                    │               │      
        │                        │                  │                               │                            │<───┘                       │                    │               │      
        │                        │                  │                               │                            │                            │                    │               │      
        │                        │                  │                               │ <─ ─ ─ ─ ─ ─  ─ ─ ─ ─ ─ ─ ─                             │                    │               │      
        │                        │                  │                               │                            │                            │                    │               │      
        │                        │                  │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│                            │                            │                    │               │      
        │                        │                  │  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─> │                            │                            │                    │               │      
        │                        │                  │                               │  ─ ─ ─ ─ ─ ─  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─  ─ ─ ─ ─ ─>                    │               │      
        │                        │                  │                               │                            │                            │          Use()     │               │      
        │                        │                  │                               │                            │                            │ ──────────────────>│               │      
        │                        │                  │                               │                            │                            │                    │     Use()     │      
        │                        │                  │                               │                            │                            │                    │──────────────>│      
        │                        │                  │                               │                            │                            │                    │<─ ─ ─ ─ ── ─ ─│      
        │                        │                  │                               │                            │                            │ <─ ─ ─ ─ ─ ─ ─ ─ ─ │               │      
        │                        │                  │                               │                            │                            │────┐               │               │      
        │                        │                  │                               │                            │                            │    │ WriteObject   │               │      
        │                        │                  │                               │                            │                            │<───┘               │               │      
        │                        │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ── ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ── ─ ─ ─ ─ │                    │               │      
        │ <─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │                  │                               │                            │                            │                    │               │      
      Prompt                ┌────┴─────┐  ┌─────────┴──────────┐          ┌─────────┴──────────┐   ┌─────────────┴──────────────┐   ┌─────────┴──────────┐    ┌────┴────┐     ┌────┴─────┐
        ┌─┐                 │PowerShell│  │AlcModuleInitializer│          │DefaultALC.Resolving│   │AlcModuleAssemblyLoadContext│   │TestAlcModuleCommand│    │AlcEngine│     │Dependency│
        ║"│                 └──────────┘  └────────────────────┘          └────────────────────┘   └────────────────────────────┘   └────────────────────┘    └─────────┘     └──────────┘
        └┬┘   
        ┌┼┐   
         │    
        ┌┴┐   


    @startuml
    actor A as "Prompt"
    participant B as "PowerShell"
    participant C as "AlcModuleInitializer"
    participant D as "DefaultALC.Resolving"
    participant E as "AlcModuleAssemblyLoadContext"
    participant F as "TestAlcModuleCommand"
    A -> E : customALC=new()(static initialization)
    E --> A
    A -> B : Import-Module AlcModule
    B -> C : new()
    C --> B
    B -> C : OnImport()
    C -> D : add_Event(ResolveAlcEngine)
    D --> C
    C --> B
    B --> A
    A -> B : Test-AlcModule
    B -> F : EndProcessing()
    F -> D : Resolving(assembly not found in default ALC)
    D -> C : ResolveAlcEngine()
    C -> E : LoadFromAssemblyName()
    E -> E : Load()
    E -> E : LoadFromAssemblyPath()
    E --> D
    D --> C
    C --> D
    D --> F
    F -> AlcEngine : Use()
    AlcEngine -> Dependency : Use()
    Dependency --> AlcEngine
    AlcEngine --> F
    F -> F : WriteObject
    F --> B
    B --> A
    @enduml

Some points of interest are:

- The `IModuleAssemblyInitializer` is run first when the module loads and sets the `Resolving`
  event.
- We don't load the dependencies until `Test-AlcModule` is run and its `EndProcessing()` method
  is called.
- When `EndProcessing()` is called, the default ALC fails to find `AlcModule.Engine.dll` and fires
  the `Resolving` event.
- Our event handler hooks up the custom ALC to the default ALC and loads `AlcModule.Engine.dll`
  only.
- When `AlcEngine.Use()` is called within `AlcModule.Engine.dll`, the custom ALC again kicks
  in to resolve `Shared.Dependency.dll`. Specifically, it always loads _our_ `Shared.Dependency.dll`
  since it never conflicts with anything in the default ALC and only looks in our `Dependencies`
  directory.

Assembling the implementation, our new source code layout looks like this:

```
+ AlcModule.psd1
+ src/
  + AlcModule.Cmdlets/
  | + AlcModule.Cmdlets.csproj
  | + TestAlcModuleCommand.cs
  | + AlcModuleAssemblyLoadContext.cs
  | + AlcModuleInitializer.cs
  |
  + AlcModule.Engine/
  | + AlcModule.Engine.csproj
  | + AlcEngine.cs
```

AlcModule.Cmdlets.csproj looks like:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\AlcModule.Engine\AlcModule.Engine.csproj" />
    <PackageReference Include="Microsoft.PowerShell.Sdk" Version="7.0.1" PrivateAssets="all" />
  </ItemGroup>
</Project>
```

AlcModule.Engine.csproj looks like this:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Shared.Dependency" Version="1.0.0" />
  </ItemGroup>
</Project>
```

So, when we build the module, our strategy is:

- Build `AlcModule.Engine`
- Build `AlcModule.Cmdlets`
- Copy everything from `AlcModule.Engine` into the `Dependencies` directory, and remember what we
  copied
- Copy everything from `AlcModule.Cmdlets` that wasn't in `AlcModule.Engine` into the base module
  directory

Since the module layout here is so crucial to dependency separation, here's a build script to use
from the source root:

```powershell
param(
    # The .NET build configuration
    [ValidateSet('Debug', 'Release')]
    [string]
    $Configuration = 'Debug'
)

# Convenient reusable constants
$mod = "AlcModule"
$netcore = "netcoreapp3.1"
$copyExtensions = @('.dll', '.pdb')

# Source code locations
$src = "$PSScriptRoot/src"
$engineSrc = "$src/$mod.Engine"
$cmdletsSrc = "$src/$mod.Cmdlets"

# Generated output locations
$outDir = "$PSScriptRoot/out/$mod"
$outDeps = "$outDir/Dependencies"

# Build AlcModule.Engine
Push-Location $engineSrc
dotnet publish -c $Configuration
Pop-Location

# Build AlcModule.Cmdlets
Push-Location $cmdletsSrc
dotnet publish -c $Configuration
Pop-Location

# Ensure out directory exists and is clean
Remove-Item -Path $outDir -Recurse -ErrorAction Ignore
New-Item -Path $outDir -ItemType Directory
New-Item -Path $outDeps -ItemType Directory

# Copy manifest
Copy-Item -Path "$PSScriptRoot/$mod.psd1"

# Copy each Engine asset and remember it
$deps = [System.Collections.Generic.Hashtable[string]]::new()
Get-ChildItem -Path "$engineSrc/bin/$Configuration/$netcore/publish/" |
    Where-Object { $_.Extension -in $copyExtensions } |
    ForEach-Object { [void]$deps.Add($_.Name); Copy-Item -Path $_.FullName -Destination $outDeps }

# Now copy each Cmdlets asset, not taking any found in Engine
Get-ChildItem -Path "$cmdletsSrc/bin/$Configuration/$netcore/publish/" |
    Where-Object { -not $deps.Contains($_.Name) -and $_.Extension -in $copyExtensions } |
    ForEach-Object { Copy-Item -Path $_.FullName -Destination $outDir }
```

Finally, we have a general way to isolate our module's dependencies in an Assembly Load Context that
remains robust over time as more dependencies are added.

For a more detailed example, go to this [GitHub repository][13]. This example demonstrates how to
migrate a module to use an ALC, while keeping that module working in .NET Framework. It also shows
how to use .NET Standard and PowerShell Standard to simplify the core implementation.

This solution is also used by the [Bicep PowerShell module][14], and the blog post
[Resolving PowerShell Module Conflicts][15] is another good read about this solution.

### Assembly resolving handler for side-by-side loading

Although being robust, the solution described above requires the module assembly to not directly
reference the dependency assemblies, but instead, reference a wrapper assembly that references the
dependency assemblies. The wrapper assembly acts like a bridge, forwarding the calls from the module
assembly to the dependency assemblies. This makes it usually a non-trivial amount of work to adopt
this solution:

- For a new module, this would add additional complexity to the design and implementation
- For an existing module, this would require significant refactoring

There is a simplified solution to achieve side-by-side assembly loading, by hooking up a `Resolving`
event with a custom `AssemblyLoadContext` instance. Using this method is easier for the module
author but has two limitations. Check out the [PowerShell-ALC-Samples][16] repository for sample
code and documentation that describes these limitations and detailed scenarios for this solution.

> [!IMPORTANT]
> Do not use `Assembly.LoadFile` for the dependency isolation purpose. Using `Assembly.LoadFile`
> creates a _Type Identity_ issue when another module loads a different version of the same assembly
> into the default `AssemblyLoadContext`. While this API loads an assembly to a separate
> `AssemblyLoadContext` instance, the assemblies loaded are discoverable by PowerShell's
> [type resolution code][33]. Therefore, there could be duplicate types with the same fully qualifed
> type name available from two different ALCs.

### Custom Application Domains

The final and most extreme option for assembly isolation is to use custom **Application Domains**.
**Application Domains** are only available in .NET Framework. They are used to provide in-process
isolation between parts of a .NET application. One of the uses is to isolate assembly loads from
each other within the same process.

However, **Application Domains**are serialization boundaries. Objects in one application domain
can't be referenced and used directly by objects in another application domain. You can work around
this by implementing `MarshalByRefObject`. But when you don't control the types, as is often the
case with dependencies, it's not possible to force an implementation here. The only solution is to
make large architectural changes. The serialization boundary also has serious performance
implications.

Because **Application Domains** have this serious limitation, are complicated to implement, and only
work in .NET Framework, we won't give an example of how you might use them here. While they're worth
mentioning as a possibility, they're not recommended.

If you're interested in trying to use a custom application domain, the following links might help:

- [Conceptual documentation on Application Domains][17]
- [Examples for using Application Domains][18]

## Solutions for dependency conflicts that don't work for PowerShell

Finally, we'll address some possibilities that come up when researching .NET dependency conflicts in
.NET that can look promising, but generally won't work for PowerShell.

These solutions have the common theme that they are changes to deployment configurations for an
environment where you control the application and possibly the entire machine. These solutions are
oriented toward scenarios like web servers and other applications deployed to server environments,
where the environment is intended to host the application and is free to be configured by the
deploying user. They also tend to be very much .NET Framework oriented, meaning they don't work with
PowerShell 6 or higher.

If you know that your module is only used in Windows PowerShell 5.1 environments that you have total
control over, some of these may be options. In general however, **modules shouldn't modify global
machine state like this**. It can break configurations that cause problems in `powershell.exe`,
other modules, or other dependent applications that cause your module to fail in unexpected ways.

### Static binding redirect with app.config to force using the same dependency version

.NET Framework applications can take advantage of an `app.config` file to configure some application
behaviors declaratively. It's possible to write an `app.config` entry that configures assembly
binding to redirect assembly loading to a particular version.

Two issues with this for PowerShell are:

- .NET Core doesn't support `app.config`, so this solution only applies to `powershell.exe`.
- `powershell.exe` is a shared application that lives in the `System32` directory. It's likely that
  your module won't be able to modify its contents on many systems. Even if it can, modifying
  the `app.config` could break an existing configuration or affect the loading of other modules.

### Setting `codebase` with app.config

For the same reasons, trying to configure the `codebase` setting in `app.config` is not going to
work in PowerShell modules.

### Installing dependencies to the Global Assembly Cache (GAC)

Another way to resolve dependency version conflicts in .NET Framework is to install dependencies to
the GAC, so that different versions can be loaded side-by-side from the GAC.

Again, for PowerShell modules, the chief issues here are:

- The GAC only applies to .NET Framework, so this does not help in PowerShell 6 and above.
- Installing assemblies to the GAC is a modification of global machine state and may cause
  side-effects in other applications or to other modules. It may also be difficult to do correctly,
  even when your module has the required access privileges. Getting it wrong could cause serious,
  machine-wide issues in other .NET applications.

## Further reading

There's plenty more to read on .NET assembly version dependency conflicts. Here are some nice
jumping off points:

- [.NET: Assemblies in .NET][19]
- [.NET Core: The managed assembly loading algorithm][20]
- [.NET Core: Understanding System.Runtime.Loader.AssemblyLoadContext][21]
- [.NET Core: Discussion about side-by-side assembly loading solutions][22]
- [.NET Framework: Redirecting assembly versions][23]
- [.NET Framework: Best practices for assembly loading][24]
- [.NET Framework: How the runtime locates assemblies][25]
- [.NET Framework: Resolve assembly loads][26]
- [StackOverflow: Assembly binding redirect, how and why?][27]
- [PowerShell: Discussion about implementing AssemblyLoadContexts][28]
- [PowerShell: `Assembly.LoadFile()` doesn't load into default AssemblyLoadContext][29]
- [Rick Strahl: When does a .NET assembly dependency get loaded?][30]
- [Jon Skeet: Summary of versioning in .NET][31]
- [Nate McMaster: Deep dive into .NET Core primitives][32]

<!-- link references -->
[1]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/media/resolving-dependency-conflicts/moduleconflict.png
[2]: #powershell-and-net
[3]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/media/resolving-dependency-conflicts/dep-conflict.jpg
[4]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/media/resolving-dependency-conflicts/engine-conflict.jpg
[5]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/media/resolving-dependency-conflicts/mod-conflict.jpg
[6]: #further-reading
[7]: #further-reading
[8]: https://learn.microsoft.com/dotnet/framework/deployment/best-practices-for-assembly-loading
[9]: https://learn.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext
[10]: https://github.com/PowerShell/PowerShellEditorServices/blob/master/src/PowerShellEditorServices.Hosting/Internal/PsesLoadContext.cs
[11]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/media/resolving-dependency-conflicts/alc-diagram.jpg
[12]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/media/resolving-dependency-conflicts/alc-sequence.png
[13]: https://github.com/rjmholt/ModuleDependencyIsolationExample
[14]: https://github.com/PSBicep/PSBicep
[15]: https://pipe.how/get-assemblyloadcontext/
[16]: https://github.com/daxian-dbw/PowerShell-ALC-Samples
[17]: https://learn.microsoft.com/dotnet/framework/app-domains/application-domains
[18]: https://learn.microsoft.com/dotnet/framework/app-domains/use
[19]: https://learn.microsoft.com/dotnet/standard/assembly/
[20]: https://learn.microsoft.com/dotnet/core/dependency-loading/loading-managed
[21]: https://learn.microsoft.com/dotnet/core/dependency-loading/understanding-assemblyloadcontext
[22]: https://github.com/dotnet/runtime/issues/13471
[23]: https://learn.microsoft.com/dotnet/framework/configure-apps/redirect-assembly-versions
[24]: https://learn.microsoft.com/dotnet/framework/deployment/best-practices-for-assembly-loading
[25]: https://learn.microsoft.com/dotnet/framework/deployment/how-the-runtime-locates-assemblies
[26]: https://learn.microsoft.com/dotnet/standard/assembly/resolve-loads
[27]: https://stackoverflow.com/questions/43365736/assembly-binding-redirect-how-and-why
[28]: https://github.com/PowerShell/PowerShell/issues/11571
[29]: https://github.com/PowerShell/PowerShell/issues/12052
[30]: https://weblog.west-wind.com/posts/2012/Nov/03/Back-to-Basics-When-does-a-NET-Assembly-Dependency-get-loaded
[31]: https://codeblog.jonskeet.uk/2019/06/30/versioning-limitations-in-net/
[32]: https://natemcmaster.com/blog/2017/12/21/netcore-primitives/
[33]: https://github.com/PowerShell/PowerShell/blob/918bb8c952af1d461abfc98bc709a1d359168a1c/src/System.Management.Automation/utils/ClrFacade.cs#L56-L61

# /./reference/dev-cross-plat/create-cmdline-predictor.md

    ---
    description: This article describes how to create a command-line predictor to help with command completion in PowerShell.
    ms.date: 12/01/2022
    title: How to create a command-line predictor
    ---
# How to create a command-line predictor

PSReadLine 2.1.0 introduced the concept of a smart command-line predictor by implementing the
Predictive IntelliSense feature. PSReadLine 2.2.2 expanded on that feature by adding a plugin model
that allows you create your own command-line predictors.

Predictive IntelliSense enhances tab completion by providing suggestions, on the command line, as
you type. The prediction suggestion appears as colored text following your cursor. This enables you
to discover, edit, and execute full commands based on matching predictions from your command
history or additional domain-specific plugins.

## System requirements

To create and use a plugin predictor, you must be using the following versions of software:

- PowerShell 7.2 (or higher) - provides the APIs necessary for creating a command predictor
- PSReadLine 2.2.2 (or higher) - allows you to configure PSReadLine to use the plugin

## Overview of a predictor

A predictor is a PowerShell binary module. The module must implement the
`System.Management.Automation.Subsystem.Prediction.ICommandPredictor` interface. This interface
declares the methods used to query for prediction results and provide feedback.

A predictor module must register a `CommandPredictor` subsystem with PowerShell's `SubsystemManager`
when loaded and unregister itself when unloaded.

The following diagram shows the architecture of a predictor in PowerShell.

[Architecture](https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat/media/create-cmdline-predictor/predictor-architecture.png)

         ┌───────────────────┐
         │     PSReadLine    │
         └─────────┬─────────┘
                   │    CommandPrediction PredictInputAsync
         ┌─────────V──────────┐
         │  PowerShellEngine  │
         │────────────────────│
         ┌────────────────────┐
         │ Subsysstem Manager ├─────┐
         └────────A───────────┘     │ Call 'GetSuggestion'
    Register /    │      ┌──────────V─────────┐
    Unregister    │      │ <<interface>>      │
    the predictor │      │ ICommandPredicator │
                  │      └──────────A─────────┘
         ┌────────┴─────────┐       │ Implement interface
         │ Predictor Module ├───────┘
         └──────────────────┘



## Creating the code

To create a predictor, you must have the .NET 6 SDK installed for your platform. For more
information on the SDK, see [Download .NET 6.0](https://dotnet.microsoft.com/download/dotnet/6.0).

Create a new PowerShell module project by following these steps:

1. Use the `dotnet` command-line tool to create a starter classlib project.

   ```powershell
   dotnet new classlib --name SamplePredictor
   ```

1. Edit the `SamplePredictor.csproj` to contain the following information:

   ```xml
   <Project Sdk="Microsoft.NET.Sdk">

     <PropertyGroup>
       <TargetFramework>net6.0</TargetFramework>
     </PropertyGroup>

     <ItemGroup>
       <PackageReference Include="Microsoft.PowerShell.SDK" Version="7.2.0" />
     </ItemGroup>

   </Project>
   ```

1. Delete the default `Class1.cs` file created by `dotnet` and copy the following code to a
   `SamplePredictorClass.cs` file in your project folder.

   ```csharp
   using System;
   using System.Collections.Generic;
   using System.Threading;
   using System.Management.Automation;
   using System.Management.Automation.Subsystem;
   using System.Management.Automation.Subsystem.Prediction;

   namespace PowerShell.Sample
   {
       public class SamplePredictor : ICommandPredictor
       {
           private readonly Guid _guid;

           internal SamplePredictor(string guid)
           {
               _guid = new Guid(guid);
           }

           /// <summary>
           /// Gets the unique identifier for a subsystem implementation.
           /// </summary>
           public Guid Id => _guid;

           /// <summary>
           /// Gets the name of a subsystem implementation.
           /// </summary>
           public string Name => "SamplePredictor";

           /// <summary>
           /// Gets the description of a subsystem implementation.
           /// </summary>
           public string Description => "A sample predictor";

           /// <summary>
           /// Get the predictive suggestions. It indicates the start of a suggestion rendering session.
           /// </summary>
           /// <param name="client">Represents the client that initiates the call.</param>
           /// <param name="context">The <see cref="PredictionContext"/> object to be used for prediction.</param>
           /// <param name="cancellationToken">The cancellation token to cancel the prediction.</param>
           /// <returns>An instance of <see cref="SuggestionPackage"/>.</returns>
           public SuggestionPackage GetSuggestion(PredictionClient client, PredictionContext context, CancellationToken cancellationToken)
           {
               string input = context.InputAst.Extent.Text;
               if (string.IsNullOrWhiteSpace(input))
               {
                   return default;
               }

               return new SuggestionPackage(new List<PredictiveSuggestion>{
                   new PredictiveSuggestion(string.Concat(input, " HELLO WORLD"))
               });
           }

           #region "interface methods for processing feedback"

           /// <summary>
           /// Gets a value indicating whether the predictor accepts a specific kind of feedback.
           /// </summary>
           /// <param name="client">Represents the client that initiates the call.</param>
           /// <param name="feedback">A specific type of feedback.</param>
           /// <returns>True or false, to indicate whether the specific feedback is accepted.</returns>
           public bool CanAcceptFeedback(PredictionClient client, PredictorFeedbackKind feedback) => false;

           /// <summary>
           /// One or more suggestions provided by the predictor were displayed to the user.
           /// </summary>
           /// <param name="client">Represents the client that initiates the call.</param>
           /// <param name="session">The mini-session where the displayed suggestions came from.</param>
           /// <param name="countOrIndex">
           /// When the value is greater than 0, it's the number of displayed suggestions from the list
           /// returned in <paramref name="session"/>, starting from the index 0. When the value is
           /// less than or equal to 0, it means a single suggestion from the list got displayed, and
           /// the index is the absolute value.
           /// </param>
           public void OnSuggestionDisplayed(PredictionClient client, uint session, int countOrIndex) { }

           /// <summary>
           /// The suggestion provided by the predictor was accepted.
           /// </summary>
           /// <param name="client">Represents the client that initiates the call.</param>
           /// <param name="session">Represents the mini-session where the accepted suggestion came from.</param>
           /// <param name="acceptedSuggestion">The accepted suggestion text.</param>
           public void OnSuggestionAccepted(PredictionClient client, uint session, string acceptedSuggestion) { }

           /// <summary>
           /// A command line was accepted to execute.
           /// The predictor can start processing early as needed with the latest history.
           /// </summary>
           /// <param name="client">Represents the client that initiates the call.</param>
           /// <param name="history">History command lines provided as references for prediction.</param>
           public void OnCommandLineAccepted(PredictionClient client, IReadOnlyList<string> history) { }

           /// <summary>
           /// A command line was done execution.
           /// </summary>
           /// <param name="client">Represents the client that initiates the call.</param>
           /// <param name="commandLine">The last accepted command line.</param>
           /// <param name="success">Shows whether the execution was successful.</param>
           public void OnCommandLineExecuted(PredictionClient client, string commandLine, bool success) { }

           #endregion;
       }

       /// <summary>
       /// Register the predictor on module loading and unregister it on module un-loading.
       /// </summary>
       public class Init : IModuleAssemblyInitializer, IModuleAssemblyCleanup
       {
           private const string Identifier = "843b51d0-55c8-4c1a-8116-f0728d419306";

           /// <summary>
           /// Gets called when assembly is loaded.
           /// </summary>
           public void OnImport()
           {
               var predictor = new SamplePredictor(Identifier);
               SubsystemManager.RegisterSubsystem(SubsystemKind.CommandPredictor, predictor);
           }

           /// <summary>
           /// Gets called when the binary module is unloaded.
           /// </summary>
           public void OnRemove(PSModuleInfo psModuleInfo)
           {
               SubsystemManager.UnregisterSubsystem(SubsystemKind.CommandPredictor, new Guid(Identifier));
           }
       }
   }
   ```

   The following example code returns the string "HELLO WORLD" for the prediction result for all
   user input. Since the sample predictor doesn't process any feedback, the code doesn't implement
   the feedback methods from the interface. Change the prediction and feedback code to meet the
   needs of your predictor.

   > [!NOTE]
   > The list view of **PSReadLine** doesn't support multiline suggestions. Each suggestion
   > should be a single line. If your code has a multiline suggestion, you should split the lines
   > into separate suggestions or join the lines with a semicolon (`;`).

1. Run `dotnet build` to produce the assembly. You can find the compiled assembly in the
   `bin/Debug/net6.0` location of your project folder.

   > [!NOTE]
   > To ensure a responsive user experience, the ICommandPredictor interface has a 20ms time out
   > for responses from the Predictors. Your predictor code must return results in less than 20ms
   > to be displayed.

## Using your predictor plugin

To try out your new predictor, open a new PowerShell 7.2 session and run the following commands:

```powershell
Set-PSReadLineOption -PredictionSource HistoryAndPlugin
Import-Module .\bin\Debug\net6.0\SamplePredictor.dll
```

With the assembly is loaded in the session, you see the text "HELLO WORLD" appear as you type in the
terminal. You can press <kbd>F2</kbd> to switch between the `Inline` view and the `List` view.

For more information about PSReadLine options, see
[Set-PSReadLineOption](/powershell/module/psreadline/set-psreadlineoption).

You can get a list of installed predictors, using the following command:

```powershell
Get-PSSubsystem -Kind CommandPredictor
```

```Output
Kind              SubsystemType      IsRegistered Implementations
----              -------------      ------------ ---------------
CommandPredictor  ICommandPredictor          True {SamplePredictor}
```

> [!NOTE]
> `Get-PSSubsystem` is an experimental cmdlet that was introduced in PowerShell 7.1 You must enable
> the `PSSubsystemPluginModel` experimental feature to use this cmdlet. For more information, see
> [Using Experimental Features](../learn/experimental-features.md#pssubsystempluginmodel).

# /./reference/dev-cross-plat/create-feedback-provider.md

    ---
    description: This article describes how to create a feedback provider.
    ms.date: 11/14/2023
    title: How to create a feedback provider
    ---
# How to create a feedback provider

PowerShell 7.4 introduced the concept of feedback providers. A feedback provider is a
PowerShell module that implements the `IFeedbackProvider` interface to provide command suggestions
based on user command execution attempts. The provider is triggered when there's a success or
failure execution. Feedback providers use information from the success or failure to provide
feedback.

## Prerequisites

To create a feedback provider, you must satisfy the following prerequisites:

- Install PowerShell 7.4 or higher
  - You must enable the `PSFeedbackProvider` experimental feature to enable support for feedback
  providers and predictors. For more information, see [Using Experimental Features][02].
- Install .NET 8 SDK - 8.0.0 or higher
  - See the [Download .NET 8.0][09] page to get the latest version of the SDK.

## Overview of a feedback provider

A feedback provider is a PowerShell binary module that implements the
`System.Management.Automation.Subsystem.Feedback.IFeedbackProvider` interface. This interface
declares the methods to get feedback based on the command line input. The feedback interface can
provide suggestions based on the success or failure of the command invoked by the user. The
suggestions can be anything that you want. For example, you might suggest ways to address an
error or better practices, like avoiding the use of aliases. For more information, see the
[What are Feedback Providers?][08] blog post.

The following diagram shows the architecture of a feedback provider:

[Diagram of the feedback provider architecture.][05]


    ┌─────────────────────────────┐
    │                             │
    │  PowerShell Console Host    │
    │                             │
    └──────────────┬──────────────┘
                   │  FeedbackHub.GetFeeedback
      ┌────────────V────────────┐  
      │    PowerShell Engine    │
      │╭───────────────────────╮│  Call 'GetFeedBack'  
      ││   Subsystem Manager   ││<──────┐
      └────────────A────────────┘       │
                   │                    │
     Register /    │      ┌─────────────V───────────┐
     Unregister    │      │                         │
     the feedback  │      │       <<interface>>     │
     Providers     │      │     IFeedbackProvider   │
                   │      │                         │
                   │      └─────────────────────────┘
                   │                   │
    ┌──────────────┴─────────────┐     │
    │                            │     │Implement interface
    │  Feedback Provider Module  │<────┘
    │                            │
    └────────────────────────────┘


The following examples walk you through the process of creating a simple feedback provider. Also,
you can register the provider with the command predictor interface to add feedback suggestions to
the command-line predictor experience. For more information about predictors, see
[Using predictors in PSReadLine][03] and [How to create a command line predictor][04].

## Step 1 - Create a new class library project

Use the following command to create a new project in the project directory:

```powershell
dotnet new classlib --name MyFeedbackProvider
```

Add a package reference for the `System.Management.Automation` package to your
`.csproj` file. The following example shows the updated `.csproj` file:

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="System.Management.Automation" Version="7.4.0-preview.3">
        <ExcludeAssets>contentFiles</ExcludeAssets>
        <PrivateAssets>All</PrivateAssets>
    </PackageReference>
  </ItemGroup>
</Project>
```

> [!NOTE]
> You should change the version of the `System.Management.Automation` assembly to match the version
> of the PowerShell preview that you are targeting. The minimum version is 7.4.0-preview.3.


## Step 2 - Add the class definition for your provider

Change the name of the `Class1.cs` file to match the name of your provider. This example uses
`myFeedbackProvider.cs`. This file contains the two main classes that define the feedback provider.
The following example shows the basic template for the class definitions.

```csharp
using System.Management.Automation;
using System.Management.Automation.Subsystem;
using System.Management.Automation.Subsystem.Feedback;
using System.Management.Automation.Subsystem.Prediction;
using System.Management.Automation.Language;

namespace myFeedbackProvider;

public sealed class myFeedbackProvider : IFeedbackProvider, ICommandPredictor
{

}

public class Init : IModuleAssemblyInitializer, IModuleAssemblyCleanup
{

}
```

## Step 3 - Implement the Init class

The `Init` class registers and unregisters the feedback provider with the subsystem manager. The
`OnImport()` method runs when the binary module is being loaded. The `OnRemove()`
method runs when the binary module is being removed. This example registers both
the feedback provider and command predictor subsystem.

```csharp
public class Init : IModuleAssemblyInitializer, IModuleAssemblyCleanup
{
    private const string Id = "<ADD YOUR GUID HERE>";

    public void OnImport()
    {
        var feedback = new myFeedbackProvider(Id);
        SubsystemManager.RegisterSubsystem(SubsystemKind.FeedbackProvider, feedback);
        SubsystemManager.RegisterSubsystem(SubsystemKind.CommandPredictor, feedback);
    }

    public void OnRemove(PSModuleInfo psModuleInfo)
    {
        SubsystemManager.UnregisterSubsystem<ICommandPredictor>(new Guid(Id));
        SubsystemManager.UnregisterSubsystem<IFeedbackProvider>(new Guid(Id));
    }
}
```

Replace the `<ADD YOUR GUID HERE>` placeholder value with a unique Guid. You can generate a Guid
using the `New-Guid` cmdlet.

```powershell
New-Guid
```

The Guid is a unique identifier for your provider. The provider must have a unique Id to be
registered with the subsystem.

## Step 4 - Add class members and define the constructor

The following code implements the properties defined in the interfaces, adds needed class members, and creates the constructor for the `myFeedbackProvider` class.

```csharp
/// <summary>
/// Gets the global unique identifier for the subsystem implementation.
/// </summary>
private readonly Guid _guid;
public Guid Id => _guid;

/// <summary>
/// Gets the name of a subsystem implementation, this will be the name displayed when triggered
/// </summary>
public string Name => "myFeedbackProvider";

/// <summary>
/// Gets the description of a subsystem implementation.
/// </summary>
public string Description => "This is very simple feedback provider";

/// <summary>
/// Default implementation. No function is required for a feedback provider.
/// </summary>
Dictionary<string, string>? ISubsystem.FunctionsToDefine => null;

/// <summary>
/// Gets the types of trigger for this feedback provider.
/// </summary>
/// <remarks>
/// The default implementation triggers a feedback provider by <see cref="FeedbackTrigger.CommandNotFound"/> only.
/// </remarks>
public FeedbackTrigger Trigger => FeedbackTrigger.All;

/// <summary>
/// List of candidates from the feedback provider to be passed as predictor results
/// </summary>
private List<string>? _candidates;

/// <summary>
/// PowerShell session used to run PowerShell commands that help create suggestions.
/// </summary>
private PowerShell _powershell;

internal myFeedbackProvider(string guid)
{
    _guid = new Guid(guid); // Save guid
    _powershell = PowerShell.Create(); // Create PowerShell instance
}
```

## Step 5 - Create the GetFeedback() method

The `GetFeedback` method takes two parameters, `context` and `token`. The `context` parameter
receives the information about the trigger so you can decide how to respond with suggestions. The
`token` parameter is used for cancellation. This function returns a `FeedbackItem` containing the
suggestion.

```csharp
/// <summary>
/// Gets feedback based on the given commandline and error record.
/// </summary>
/// <param name="context">The context for the feedback call.</param>
/// <param name="token">The cancellation token to cancel the operation.</param>
/// <returns>The feedback item.</returns>
public FeedbackItem? GetFeedback(FeedbackContext context, CancellationToken token)
{
    // Target describes the different kinds of triggers to activate on,
    var target = context.Trigger;
    var commandLine = context.CommandLine;
    var ast = context.CommandLineAst;

    // defining the header and footer variables
    string header;
    string footer;

    // List of the actions
    List<string>? actions = new List<string>();

    // Trigger on success code goes here

    // Trigger on error code goes here

    return null;
}
```

The following image shows how these fields are used in the suggestions that are displayed to the
user.

![Screenshot of example feedback providers][06]

### Create suggestions for a Success trigger

For a successful invocation, we want to expand any aliases used in the last execution. Using the
`CommandLineAst`, we identify any aliased commands and create a suggestion to use the fully
qualified command name instead.

```csharp
// Trigger on success
if (target == FeedbackTrigger.Success)
{
    // Getting the commands from the AST and only finding those that are Commands
    var astCmds = ast.FindAll((cAst) => cAst is CommandAst, true);

    // Inspect each of the commands
    foreach(var command in astCmds)
    {

        // Get the command name
        var aliasedCmd = ((CommandAst) command).GetCommandName();

        // Check if its an alias or not, if so then add it to the list of actions
        if(TryGetAlias(aliasedCmd, out string commandString))
        {
            actions.Add($"{aliasedCmd} --> {commandString}");
        }
    }

    // If no alias was found return null
    if(actions.Count == 0)
    {
        return null;
    }

    // If aliases are found, set the header to a description and return a new FeedbackItem.
    header = "You have used an aliased command:";
    // Copy actions to _candidates for the predictor
    _candidates = actions;

    return new FeedbackItem(header, actions);
}
```

### Implement the TryGetAlias() method

The `TryGetAlias()` method is a private helper function that returns a boolean value to indicate
whether the command is an alias. In the class constructor, we created a PowerShell instance that we
can use to run PowerShell commands. The `TryGetAlias()` method uses this PowerShell instance to
invoke the `GetCommand` method to determine if the command is an alias. The `AliasInfo` object
returned by `GetCommand` contains full name of the aliased command.

```csharp
/// <summary>
/// Checks if a command is an alias.
/// </summary>
/// <param name="command">The command to check if alias</param>
/// <param name="targetCommand">The referenced command by the aliased command</param>
/// <returns>True if an alias and false if not</returns>
private bool TryGetAlias(string command, out string targetCommand)
{
    // Create PowerShell runspace as a session state proxy to run GetCommand and check
    // if its an alias
    AliasInfo? pwshAliasInfo =
        _powershell.Runspace.SessionStateProxy.InvokeCommand.GetCommand(command, CommandTypes.Alias) as AliasInfo;

    // if its null then it is not an aliased command so just return false
    if(pwshAliasInfo is null)
    {
        targetCommand = String.Empty;
        return false;
    }

    // Set targetCommand to referenced command name
    targetCommand = pwshAliasInfo.ReferencedCommand.Name;
    return true;
}
```

### Create suggestions for a Failure trigger

When a command execution fails, we want to suggest that the user `Get-Help` to get more information
about how to use the command.

```csharp
// Trigger on error
if (target == FeedbackTrigger.Error)
{
    // Gets the command that caused the error.
    var erroredCommand = context.LastError?.InvocationInfo.MyCommand;
    if (erroredCommand is null)
    {
        return null;
    }

    header = $"You have triggered an error with the command {erroredCommand}. Try using the following command to get help:";

    actions.Add($"Get-Help {erroredCommand}");
    footer = $"You can also check online documentation at https://learn.microsoft.com/en-us/powershell/module/?term={erroredCommand}";

    // Copy actions to _candidates for the predictor
    _candidates = actions;
    return new FeedbackItem(header, actions, footer, FeedbackDisplayLayout.Portrait);
}
```

## Step 6 - Send suggestions to the command line predictor

Another way your feedback provider can enhance the user experience is to provide command suggestions
to the **ICommandPredictor** interface. For more information about creating a command line
predictor, see [How to create a command line predictor][04].

The following code implements the methods necessary from the **ICommandPredictor** interface to add predictor behavior to your feedback
provider.

- `CanAcceptFeedback()` - This method returns a Boolean value that indicates whether the predictor accepts a specific type of feedback.
- `GetSuggestion()` - This method returns a `SuggestionPackage` object that contains the suggestions to be displayed by the predictor.
- `OnCommandLineAccepted()` - This method is called when a command line is accepted to execute.

```csharp
/// <summary>
/// Gets a value indicating whether the predictor accepts a specific kind of feedback.
/// </summary>
/// <param name="client">Represents the client that initiates the call.</param>
/// <param name="feedback">A specific type of feedback.</param>
/// <returns>True or false, to indicate whether the specific feedback is accepted.</returns>
public bool CanAcceptFeedback(PredictionClient client, PredictorFeedbackKind feedback)
{
    return feedback switch
    {
        PredictorFeedbackKind.CommandLineAccepted => true,
        _ => false,
    };
}

/// <summary>
/// Get the predictive suggestions. It indicates the start of a suggestion rendering session.
/// </summary>
/// <param name="client">Represents the client that initiates the call.</param>
/// <param name="context">The <see cref="PredictionContext"/> object to be used for prediction.</param>
/// <param name="cancellationToken">The cancellation token to cancel the prediction.</param>
/// <returns>An instance of <see cref="SuggestionPackage"/>.</returns>
public SuggestionPackage GetSuggestion(
    PredictionClient client,
    PredictionContext context,
    CancellationToken cancellationToken)
{
    if (_candidates is not null)
    {
        string input = context.InputAst.Extent.Text;
        List<PredictiveSuggestion>? result = null;

        foreach (string c in _candidates)
        {
            if (c.StartsWith(input, StringComparison.OrdinalIgnoreCase))
            {
                result ??= new List<PredictiveSuggestion>(_candidates.Count);
                result.Add(new PredictiveSuggestion(c));
            }
        }

        if (result is not null)
        {
            return new SuggestionPackage(result);
        }
    }

    return default;
}

/// <summary>
/// A command line was accepted to execute.
/// The predictor can start processing early as needed with the latest history.
/// </summary>
/// <param name="client">Represents the client that initiates the call.</param>
/// <param name="history">History command lines provided as references for prediction.</param>
public void OnCommandLineAccepted(PredictionClient client, IReadOnlyList<string> history)
{
    // Reset the candidate state once the command is accepted.
    _candidates = null;
}
```

## Step 7 - Build the feedback provider

Now you are ready to build and begin using your feedback provider! To build the project, run the
following command:

```powershell
dotnet build
```

This command create the PowerShell module as a DLL file in the following path of your project
folder: `bin/Debug/net8.0/myFeedbackProvider`

You may run into the error `error NU1101: Unable to find package System.Management.Automation.`
when building on Windows machines. To fix this add a `nuget.config` file to your project directory
and add the following:

```yaml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
  <disabledPackageSources>
    <clear />
  </disabledPackageSources>
</configuration>
```

## Using a feedback provider

To test your new feedback provider, import the compiled module into your PowerShell session. This
can be done by importing the folder described after building has succeeded:

```powershell
Import-Module ./bin/Debug/net8.0/myFeedbackProvider
```

Once you're satisfied with your module, you should create a module manifest, publish it to the
PowerShell Gallery, and install it in your `$env:PSModulePath`. For more information, see
[How to create a module manifest][01]. You can add the `Import-Module` command to your `$PROFILE`
script so the module is available in PowerShell session.

You can get a list of installed feedback providers, using the following command:

```powershell
Get-PSSubsystem -Kind FeedbackProvider
```

```Output
Kind              SubsystemType      IsRegistered Implementations
----              -------------      ------------ ---------------
FeedbackProvider  IFeedbackProvider          True {general}
```

> [!NOTE]
> `Get-PSSubsystem` is an experimental cmdlet that was introduced in PowerShell 7.1 You must enable
> the `PSSubsystemPluginModel` experimental feature to use this cmdlet. For more information, see
> [Using Experimental Features][02].

The following screenshot shows some example suggestions from the new provider.

![Screenshot of success and error feedback provider triggers][07]

The following is a GIF showing how the predictor integration works from the new provider.

![GIF of predictor system working with feedback provider][10]

## Other feedback providers

We have created other feedback provider that can be used as a good reference for deeper examples.

### command-not-found

The `command-not-found` feedback provider utilizes the `command-not-found` utility tool on Linux systems
to provide suggestions when native commands are attempted to run but are missing. You can find the code
in the [GitHub Repository][11] or can download for yourself on the [PowerShell Gallery][12].

### PowerShell Adapter

The `Microsoft.PowerShell.PowerShellAdapter` is a feedback provider that helps you convert text outputs
from native commands into PowerShell objects. It detects "adapters" on your system and suggests you to use
them when you use the native command. You can learn more about PowerShell Adapters from,
[PowerShell Adapter Feedback Provider][13] blog post. You can also find teh code in the [GitHub Repository][14]
or can download for yourself on the [PowerShell Gallery][15].

## Appendix - Full implementation code

The following code combines the previous examples into the find full implementation of the provider
class.

```csharp
using System.Management.Automation;
using System.Management.Automation.Subsystem;
using System.Management.Automation.Subsystem.Feedback;
using System.Management.Automation.Subsystem.Prediction;
using System.Management.Automation.Language;

namespace myFeedbackProvider;

public sealed class myFeedbackProvider : IFeedbackProvider, ICommandPredictor
{
    /// <summary>
    /// Gets the global unique identifier for the subsystem implementation.
    /// </summary>
    private readonly Guid _guid;
    public Guid Id => _guid;

    /// <summary>
    /// Gets the name of a subsystem implementation, this will be the name displayed when triggered
    /// </summary>
    public string Name => "myFeedbackProvider";

    /// <summary>
    /// Gets the description of a subsystem implementation.
    /// </summary>
    public string Description => "This is very simple feedback provider";

    /// <summary>
    /// Default implementation. No function is required for a feedback provider.
    /// </summary>
    Dictionary<string, string>? ISubsystem.FunctionsToDefine => null;

    /// <summary>
    /// Gets the types of trigger for this feedback provider.
    /// </summary>
    /// <remarks>
    /// The default implementation triggers a feedback provider by <see cref="FeedbackTrigger.CommandNotFound"/> only.
    /// </remarks>
    public FeedbackTrigger Trigger => FeedbackTrigger.All;

    /// <summary>
    /// List of candidates from the feedback provider to be passed as predictor results
    /// </summary>
    private List<string>? _candidates;

    /// <summary>
    /// PowerShell session used to run PowerShell commands that help create suggestions.
    /// </summary>
    private PowerShell _powershell;

    // Constructor
    internal myFeedbackProvider(string guid)
    {
        _guid = new Guid(guid); // Save guid
        _powershell = PowerShell.Create(); // Create PowerShell instance
    }

    #region IFeedbackProvider
    /// <summary>
    /// Gets feedback based on the given commandline and error record.
    /// </summary>
    /// <param name="context">The context for the feedback call.</param>
    /// <param name="token">The cancellation token to cancel the operation.</param>
    /// <returns>The feedback item.</returns>
    public FeedbackItem? GetFeedback(FeedbackContext context, CancellationToken token)
    {
        // Target describes the different kinds of triggers to activate on,
        var target = context.Trigger;
        var commandLine = context.CommandLine;
        var ast = context.CommandLineAst;

        // defining the header and footer variables
        string header;
        string footer;

        // List of the actions
        List<string>? actions = new List<string>();

        // Trigger on success
        if (target == FeedbackTrigger.Success)
        {
            // Getting the commands from the AST and only finding those that are Commands
            var astCmds = ast.FindAll((cAst) => cAst is CommandAst, true);

            // Inspect each of the commands
            foreach(var command in astCmds)
            {

                // Get the command name
                var aliasedCmd = ((CommandAst) command).GetCommandName();

                // Check if its an alias or not, if so then add it to the list of actions
                if(TryGetAlias(aliasedCmd, out string commandString))
                {
                    actions.Add($"{aliasedCmd} --> {commandString}");
                }
            }

            // If no alias was found return null
            if(actions.Count == 0)
            {
                return null;
            }

            // If aliases are found, set the header to a description and return a new FeedbackItem.
            header = "You have used an aliased command:";
            // Copy actions to _candidates for the predictor
            _candidates = actions;

            return new FeedbackItem(header, actions);
        }

        // Trigger on error
        if (target == FeedbackTrigger.Error)
        {
            // Gets the command that caused the error.
            var erroredCommand = context.LastError?.InvocationInfo.MyCommand;
            if (erroredCommand is null)
            {
                return null;
            }

            header = $"You have triggered an error with the command {erroredCommand}. Try using the following command to get help:";

            actions.Add($"Get-Help {erroredCommand}");
            footer = $"You can also check online documentation at https://learn.microsoft.com/en-us/powershell/module/?term={erroredCommand}";

            // Copy actions to _candidates for the predictor
            _candidates = actions;
            return new FeedbackItem(header, actions, footer, FeedbackDisplayLayout.Portrait);
        }
        return null;
    }

    /// <summary>
    /// Checks if a command is an alias.
    /// </summary>
    /// <param name="command">The command to check if alias</param>
    /// <param name="targetCommand">The referenced command by the aliased command</param>
    /// <returns>True if an alias and false if not</returns>
    private bool TryGetAlias(string command, out string targetCommand)
    {
        // Create PowerShell runspace as a session state proxy to run GetCommand and check
        // if its an alias
        AliasInfo? pwshAliasInfo =
            _powershell.Runspace.SessionStateProxy.InvokeCommand.GetCommand(command, CommandTypes.Alias) as AliasInfo;

        // if its null then it is not an aliased command so just return false
        if(pwshAliasInfo is null)
        {
            targetCommand = String.Empty;
            return false;
        }

        // Set targetCommand to referenced command name
        targetCommand = pwshAliasInfo.ReferencedCommand.Name;
        return true;
    }
    #endregion IFeedbackProvider

    #region ICommandPredictor

    /// <summary>
    /// Gets a value indicating whether the predictor accepts a specific kind of feedback.
    /// </summary>
    /// <param name="client">Represents the client that initiates the call.</param>
    /// <param name="feedback">A specific type of feedback.</param>
    /// <returns>True or false, to indicate whether the specific feedback is accepted.</returns>
    public bool CanAcceptFeedback(PredictionClient client, PredictorFeedbackKind feedback)
    {
        return feedback switch
        {
            PredictorFeedbackKind.CommandLineAccepted => true,
            _ => false,
        };
    }

    /// <summary>
    /// Get the predictive suggestions. It indicates the start of a suggestion rendering session.
    /// </summary>
    /// <param name="client">Represents the client that initiates the call.</param>
    /// <param name="context">The <see cref="PredictionContext"/> object to be used for prediction.</param>
    /// <param name="cancellationToken">The cancellation token to cancel the prediction.</param>
    /// <returns>An instance of <see cref="SuggestionPackage"/>.</returns>
    public SuggestionPackage GetSuggestion(
        PredictionClient client,
        PredictionContext context,
        CancellationToken cancellationToken)
    {
        if (_candidates is not null)
        {
            string input = context.InputAst.Extent.Text;
            List<PredictiveSuggestion>? result = null;

            foreach (string c in _candidates)
            {
                if (c.StartsWith(input, StringComparison.OrdinalIgnoreCase))
                {
                    result ??= new List<PredictiveSuggestion>(_candidates.Count);
                    result.Add(new PredictiveSuggestion(c));
                }
            }

            if (result is not null)
            {
                return new SuggestionPackage(result);
            }
        }

        return default;
    }

    /// <summary>
    /// A command line was accepted to execute.
    /// The predictor can start processing early as needed with the latest history.
    /// </summary>
    /// <param name="client">Represents the client that initiates the call.</param>
    /// <param name="history">History command lines provided as references for prediction.</param>
    public void OnCommandLineAccepted(PredictionClient client, IReadOnlyList<string> history)
    {
        // Reset the candidate state once the command is accepted.
        _candidates = null;
    }

    #endregion;
}

public class Init : IModuleAssemblyInitializer, IModuleAssemblyCleanup
{
    private const string Id = "<ADD YOUR GUID HERE>";

    public void OnImport()
    {
        var feedback = new myFeedbackProvider(Id);
        SubsystemManager.RegisterSubsystem(SubsystemKind.FeedbackProvider, feedback);
        SubsystemManager.RegisterSubsystem(SubsystemKind.CommandPredictor, feedback);
    }

    public void OnRemove(PSModuleInfo psModuleInfo)
    {
        SubsystemManager.UnregisterSubsystem<ICommandPredictor>(new Guid(Id));
        SubsystemManager.UnregisterSubsystem<IFeedbackProvider>(new Guid(Id));
    }
}
```

<!-- link references -->
[01]: ../developer/module/how-to-write-a-powershell-module-manifest.md
[02]: ../learn/experimental-features.md#pssubsystempluginmodel
[03]: ../learn/shell/using-predictors.md
[04]: ./create-cmdline-predictor.md
[05]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat//media/create-feedback-provider/feedback-provider-arch.png
[06]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat//media/create-feedback-provider/feedback-provider-fields.png
[07]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat//media/create-feedback-provider/feedback-provider-output.png
[08]: https://devblogs.microsoft.com/powershell/what-are-feedback-providers/
[09]: https://dotnet.microsoft.com/download/dotnet/8.0
[10]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/dev-cross-plat//media/create-feedback-provider/feedback-provider-predictor.gif
[11]: https://github.com/PowerShell/command-not-found
[12]: https://www.powershellgallery.com/packages/command-not-found
[13]: https://devblogs.microsoft.com/powershell/powershell-adapter-feedback-provider/
[14]: https://github.com/PowerShell/JsonAdapter
[15]: https://www.powershellgallery.com/packages/Microsoft.PowerShell.PSAdapter


# /./lang-spec/chapter-01.md - PowerShell Language Specification 3.0

    ---
    description: This Language Specification describe the syntax, semantics, and behavior of the PowerShell language.
    ms.date: 05/19/2021
    title: Windows PowerShell Language Specification 3.0
    ---
# Windows PowerShell Language Specification 3.0

The _Windows PowerShell Language Specification 3.0_ was published in December 2012 and is based on
PowerShell 3.0. The specification document is available as a Microsoft Word document from the
Microsoft Download Center at:
[https://www.microsoft.com/download/details.aspx?id=36389](https://www.microsoft.com/download/details.aspx?id=36389)

That Word document has been converted for presentation here on Microsoft Learn. During conversion,
some editorial changes have been made to accommodate formatting for the Docs platform. Some typos
and minor errors have been corrected.

> [!IMPORTANT]
> The contents of this documentation may not reflect the current state of PowerShell in its current
> version. There is no plan to update this documentation to reflect the current state. This
> documentation is presented here for historical reference.

## 1. Introduction

PowerShell is a command-line *shell* and scripting language, designed especially for system
administrators.

Most shells operate by executing a command or utility in a new process, and presenting the results
to the user as text. These shells also have commands that are built into the shell and run in the
shell process. Because there are few built-in commands, many utilities have been created to
supplement them. PowerShell is very different. Instead of processing text, the shell processes
objects. PowerShell also includes a large set of built-in commands with each having a consistent
interface and these can work with user-written commands.

An *object* is a data entity that has *properties* (i.e., characteristics) and *methods* (i.e.,
actions that can be performed on the object). All objects of the same type have the same base set of
properties and methods, but each *instance* of an object can have different property values.

A major advantage of using objects is that it is much easier to *pipeline* commands; that is, to
write the output of one command to another command as input. (In a traditional command-line
environment, the text output from one command needs to be manipulated to meet the input format of
another.)

PowerShell includes a very rich scripting language that supports constructs for looping, conditions,
flow-control, and variable assignment. This language has syntax features and keywords similar to
those used in the C# programming language ([§C.][§C.]).

There are four kinds of commands in PowerShell: scripts, functions and methods, cmdlets, and native
commands.

- A file of commands is called a *script*. By convention, a script has a filename extension of .ps1.
  The top-most level of a PowerShell program is a script, which, in turn, can invoke other commands.

- PowerShell supports modular programming via named procedures. A procedure written in PowerShell is
  called a *function*, while an external procedure made available by the execution environment (and
  typically written in some other language) is called a *method*.

- A *cmdlet* (pronounced "command-let") is a simple, single-task command-line tool. Although a
  cmdlet can be used on its own, the full power of cmdlets is realized when they are used in
  combination to perform complex tasks.

- A *native command* is part of the host environment.

Each time the PowerShell runtime environment begins execution, it begins what is called a *session*.
Commands then execute within the context of that session.

This specification defines the PowerShell language, the built-in cmdlets, and the use of objects via
the pipeline.

Unlike most shells, which accept and return text, Windows PowerShell is built on top of the .NET
Framework common language runtime (CLR) and the .NET Framework, and accepts and returns .NET
Framework objects.

<!-- reference links -->
[§C.]: chapter-16.md

# /./lang-spec/chapter-02.md - Lexical Structure

    ---
    description: This specification shows the syntax of the PowerShell language using a lexical grammar and a syntactic grammar.
    ms.date: 05/19/2021
    title: Lexical structure
    ---
# 2. Lexical Structure

## 2.1 Grammars

This specification shows the syntax of the PowerShell language using two grammars. The *lexical
grammar* ([§B.1][§B.1]) shows how Unicode characters are combined to form line terminators, comments,
white space, and tokens. The *syntactic grammar* ([§B.2][§B.2]) shows how the tokens resulting from the
lexical grammar are combined to form PowerShell scripts.

For convenience, fragments of these grammars are replicated in appropriate places throughout this
specification.

Any use of the characters 'a' through 'z' in the grammars is case insensitive. This means that
letter case in variables, aliases, function names, keywords, statements, and operators is ignored.
However, throughout this specification, such names are written in lowercase, except for some
automatic and preference variables.

## 2.2 Lexical analysis

### 2.2.1 Scripts

Syntax:

> [!TIP]
> The `~opt~` notation in the syntax definitions indicates that the lexical entity is optional in
> the syntax.

```Syntax
input:
    input-elements~opt~   signature-block~opt~

input-elements:
    input-element
    input-elements   input-element

input-element:
    whitespace
    comment
    token

signature-block:
    signature-begin   signature   signature-end

signature-begin:
    new-line-character   # SIG # Begin signature block   new-line-character

signature:
    base64 encoded signature blob in multiple single-line-comments

signature-end:
    new-line-character   # SIG # End signature block   new-line-character
```

Description:

The input source stream to a PowerShell translator is the *input* in a script, which contains a
sequence of Unicode characters. The lexical processing of this stream involves the reduction of
those characters into a sequence of tokens, which go on to become the input of syntactic analysis.

A script is a group of PowerShell commands stored in a *script-file*. The script itself has no name,
per se, and takes its name from its source file. The end of that file indicates the end of the
script.

A script may optionally contain a digital signature. A host environment is not required to process
any text that follows a signature or anything that looks like a signature. The creation and use of
digital signatures are not covered by this specification.

### 2.2.2 Line terminators

Syntax:

```Syntax
new-line-character:
    Carriage return character (U+000D)
    Line feed character (U+000A)
    Carriage return character (U+000D) followed by line feed character (U+000A)

new-lines:
    new-line-character
    new-lines new-line-character
```

Description:

The presence of *new-line-character*s in the input source stream divides it into lines that can be
used for such things as error reporting and the detection of the end of a single-line comment.

A line terminator can be treated as white space ([§2.2.4][§2.2.4]).

### 2.2.3 Comments

Syntax:

```Syntax
comment:
    single-line-comment
    requires-comment
    delimited-comment

single-line-comment:
    # input-characters~opt~

input-characters:
    input-character
    input-characters input-character

input-character:
    Any Unicode character except a new-line-character

requires-comment:
    #requires whitespace command-arguments

dash:
    - (U+002D)
    EnDash character (U+2013)
    EmDash character (U+2014)
    Horizontal bar character (U+2015)

dashdash:
    dash dash

delimited-comment:
    < # delimited-comment-text~opt~ hashes >

delimited-comment-text:
    delimited-comment-section
    delimited-comment-text delimited-comment-section

delimited-comment-section:
    >
    hashes~opt~  not-greater-than-or-hash

hashes:
    #
    hashes #

not-greater-than-or-hash:
    Any Unicode character except > or #
```

Description:

Source code can be annotated by the use of *comments*.

A *single-line-comment* begins with the character `#` and ends with a *new-line-character*.

A *delimited-comment* begins with the character pair `<#` and ends with the character pair `#>`.
It can occur as part of a source line, as a whole source line, or it can span any number of source
lines.

A comment is treated as white space.

The productions above imply that

- Comments do not nest.
- The character sequences <# and #> have no special meaning in a single-line comment.
- The character # has no special meaning in a delimited comment.

The lexical grammar implies that comments cannot occur inside tokens.

(See §A for information about creating script files that contain special-valued comments that are
used to generate documentation from script files.)

A *requires-comment* specifies the criteria that have to be met for its containing script to be
allowed to run. The primary criterion is the version of PowerShell being used to run the script. The
minimum version requirement is specified as follows:

`#requires -Version N[.n]`

Where *N* is the (required) major version and *n* is the (optional) minor version.

A *requires-comment* can be present in any script file; however, it cannot be present inside a
function or cmdlet. It must be the first item on a source line. A script can contain multiple
*requires-comment*s.

A character sequence is only recognized as a comment if that sequence begins with `#` or `<#`. For
example, hello#there is considered a single token whereas hello #there is considered the token hello
followed by a single-line comment. As well as following white space, the comment start sequence can
also be preceded by any expression-terminating or statement-terminating character (such as `)`, `}`,
`]`, `'`, `"`, or `;`).

A *requires-comment* cannot be present inside a snap-in.

There are four other forms of a *requires-comment*:

```Syntax
#requires --Assembly AssemblyId
#requires --Module ModuleName
#requires --PsSnapIn PsSnapIn [ -Version *N* [.n] ]
#requires --ShellId ShellId
```

### 2.2.4 White space

Syntax:

```Syntax
whitespace:
    Any character with Unicode class Zs, Zl, or Zp
    Horizontal tab character (U+0009)
    Vertical tab character (U+000B)
    Form feed character (U+000C)
    ` (The backtick character U+0060) followed by new-line-character
```

Description:

*White space* consists of any sequence of one or more *whitespace* characters.

Except for the fact that white space may act as a separator for tokens, it is ignored.

Unlike some popular languages, PowerShell does not consider line-terminator characters ([§2.2.2][§2.2.2])
to be white space. However, a line terminator can be treated as white space by preceding it
immediately by a backtick character, `` ` `` (U+0060). This is necessary when the contents of a line
are complete syntactically, yet the following line contains tokens intended to be associated with
the previous line. For example,

```powershell
$number = 10 # assigns 10 to $number; nothing is written to the pipeline
+ 20 # writes 20 to the pipeline
- 50 # writes -50 to the pipeline
$number # writes $number's value, 10, to the pipeline
```

In this example, the backtick indicates the source line is continued. The following expression is
equivalent to `$number = 10 + 20 - 50`.

```powershell
$number = 10 `
+ 20 `
- 50
$number # writes $number's value to the pipeline
-20
```

## 2.3 Tokens

Syntax:

```Syntax
token:
    keyword
    variable
    command
    command-parameter
    command-argument-token
    integer-literal
    real-literal
    string-literal
    type-literal
    operator-or-punctuator
```

Description:

A *token* is the smallest lexical element within the PowerShell language.

Tokens can be separated by *new-lines*, comments, white space, or any combination thereof.

### 2.3.1 Keywords

Syntax:

```Syntax
keyword: one of
    begin          break          catch       class
    continue       data           define      do
    dynamicparam   else           elseif      end
    exit           filter         finally     for
    foreach        from           function    if
    in             inlinescript   parallel    param
    process        return         switch      throw
    trap           try            until       using
    var            while          workflow
```

Description:

A *keyword* is a sequence of characters that has a special meaning when used in a context-dependent
place. Most often, this is as the first token in a *statement*; however, there are other locations,
as indicated by the grammar. (A token that looks like a keyword, but is not being used in a keyword
context, is a *command-name* or a *command-argument*.)

The keywords `class`, `define`, `from`, `using`, and `var` are reserved for future use.

> [!NOTE]
> Editor's Note: The `class` and `using` keywords were introduced in PowerShell 5.0. See
> [about_Classes](/powershell/module/microsoft.powershell.core/about/about_classes) and
> [about_Using](/powershell/module/microsoft.powershell.core/about/about_using).

### 2.3.2 Variables

Syntax:

```Syntax
variable:
    $$
    $?
    $^
    $   variable-scope~opt~  variable-characters
    @   variable-scope~opt~  variable-characters
    braced-variable


braced-variable:
    ${   variable-scope~opt~   braced-variable-characters   }

variable-scope:
    global:
    local:
    private:
    script:
    using:
    workflow:
    variable-namespace

variable-namespace:
    variable-characters   :

variable-characters:
    variable-character
    variable-characters   variable-character

variable-character:
    A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nd
    _   (The underscore character U+005F)
    ?

braced-variable-characters:
    braced-variable-character
    braced-variable-characters   braced-variable-character

braced-variable-character:
    Any Unicode character except
        }   (The closing curly brace character U+007D)
        `   (The backtick character U+0060)
    escaped-character

escaped-character:
    `   (The backtick character U+0060) followed by any Unicode character
```

Description:

Variables are discussed in detail in (§5). The variable $? is discussed in [§2.3.2.2][§2.3.2.2]. Scopes are
discussed in [§3.5][§3.5].

The variables `$$` and `$^` are reserved for use in an interactive environment, which is outside the
scope of this specification.

There are two ways of writing a variable name: A *braced variable name*, which begins with `$`,
followed by a curly bracket-delimited set of one or more almost-arbitrary characters; and an
*ordinary variable name*, which also begins with `$`, followed by a set of one or more characters
from a more restrictive set than a braced variable name allows. Every ordinary variable name can be
expressed using a corresponding braced variable name.

```powershell
$totalCost
$Maximum_Count_26

$végösszeg # Hungarian
$итог # Russian
$総計 # Japanese (Kanji)

${Maximum_Count_26}
${Name with`twhite space and `{punctuation`}}
${E:\\File.txt}
```

There is no limit on the length of a variable name, all characters in a variable name are
significant, and letter case is *not* distinct.

There are several different kinds of variables: user-defined ([§2.3.2.1][§2.3.2.1]), automatic
([§2.3.2.2][§2.3.2.2]), and preference ([§2.3.2.3][§2.3.2.3]). They can all coexist in the same scope ([§3.5][§3.5]).

Consider the following function definition and calls:

```powershell
function Get-Power ([long]$base, [int]$exponent) { ... }

Get-Power 5 3 # $base is 5, $exponent is 3
Get-Power -exponent 3 -base 5 # " " "
```

Each argument is passed by position or name, one at a time. However, a set of arguments can be
passed as a group with expansion into individual arguments being handled by the runtime environment.
This automatic argument expansion is known as *splatting*. For example,

```powershell
$values = 5,3 # put arguments into an array
Get-Power @values

$hash = @{ exponent = 3; base = 5 } # put arguments into a Hashtable
Get-Power @hash

function Get-Power2 { Get-Power @args } # arguments are in an array

Get-Power2 --exponent 3 --base 5 # named arguments splatted named in
@args
Get-Power2 5 3 # position arguments splatted positionally in @args
```

This is achieved by using `@` instead of `$` as the first character of the variable being passed.
This notation can only be used in an argument to a command.

Names are partitioned into various namespaces each of which is stored on a virtual drive
([§3.1][§3.1]). For example, variables are stored on `Variable:`, environment variables are stored on
`Env:`, functions are stored on `Function:`, and aliases are stored on `Alias:`. All of these names
can be accessed as variables using the *variable-namespace* production within *variable-scope*. For
example,

```powershell
function F { "Hello from F" }
$Function:F # invokes function F

Set-Alias A F
$Alias:A # invokes function F via A

$Count = 10
$Variable:Count # accesses variable Count
$Env:Path # accesses environment variable Path
```

Any use of a variable name with an explicit `Variable:` namespace is equivalent to the use of that
same variable name without that qualification. For example, `$v` and `$Variable:v` are
interchangeable.

As well as being defined in the language, variables can also be defined by the cmdlet
[New-Variable](xref:Microsoft.PowerShell.Utility.New-Variable).

#### 2.3.2.1 User-defined variables

Any variable name allowed by the grammar but not used by automatic or preference variables is
available for user-defined variables.

User-defined variables are created and managed by user-defined script.

#### 2.3.2.2 Automatic variables

Automatic variables store state information about the PowerShell environment. Their values can be
read in user-written script but not written.

> [!NOTE]
> The table originally found in this document was removed to reduce duplication. For a complete list
> of automatic variables, see
> [about_Automatic_Variables](/powershell/module/microsoft.powershell.core/about/about_automatic_variables).

#### 2.3.2.3 Preference variables

Preference variables store user preferences for the session. They are created and initialized by the
PowerShell runtime environment. Their values can be read and written in user-written script.

> [!NOTE]
> The table originally found in this document was removed to reduce duplication. For a complete list
> of preference variables, see
> [about_Preference_Variables](/powershell/module/microsoft.powershell.core/about/about_preference_variables).

### 2.3.3 Commands

Syntax:

```Syntax
generic-token:
    generic-token-parts

generic-token-parts:
    generic-token-part
    generic-token-parts generic-token-part

generic-token-part:
    expandable-string-literal
    verbatim-here-string-literal
    variable
    generic-token-char

generic-token-char:
    Any Unicode character except
        {   }   (   )   ;   ,   |   &   $
        ` (The backtick character U+0060)
        double-quote-character
        single-quote-character
        whitespace
        new-line-character
        escaped-character

generic-token-with-subexpr-start:
    generic-token-parts $(
```

### 2.3.4 Parameters

Syntax:

```Syntax
command-parameter:
    dash first-parameter-char parameter-chars colon~opt~

first-parameter-char:
    A Unicode character of classes Lu, Ll, Lt, Lm, or Lo
    _ (The underscore character U+005F)
    ?

parameter-chars:
    parameter-char
    parameter-chars parameter-char

parameter-char:
    Any Unicode character except
        { } ( ) ; , \| & . [
        colon
        whitespace
        new-line-character

colon:
    : (The colon character U+003A)

verbatim-command-argument-chars:
    verbatim-command-argument-part
    verbatim-command-argument-chars verbatim-command-argument-part

verbatim-command-argument-part:
    verbatim-command-string
    & non-ampersand-character
    Any Unicode character except
        |
        new-line-character

non-ampersand-character:
    Any Unicode character except &

verbatim-command-string:
    double-quote-character non-double-quote-chars
    double-quote-character

non-double-quote-chars:
    non-double-quote-char
    non-double-quote-chars non-double-quote-char

non-double-quote-char:
    Any Unicode character except
        double-quote-character
```

Description:

When a command is invoked, information may be passed to it via one or more *arguments* whose values
are accessed from within the command through a set of corresponding *parameters*. The process of
matching parameters to arguments is called *parameter binding*.

There are three kinds of argument:

- Switch parameter ([§8.10.5][§8.10.5]) -- This has the form *command-parameter* where
  *first-parameter-char* and *parameter-chars* together make up the switch name, which corresponds
  to the name of a parameter (without its leading `-`) in the command being invoked. If the trailing
  colon is omitted, the presence of this argument indicates that the corresponding parameter be set
  to `$true`. If the trailing colon is present, the argument immediately following must designate a
  value of type bool, and the corresponding parameter is set to that value. For example, the
  following invocations are equivalent:

  ```powershell
  Set-MyProcess -Strict
  Set-MyProcess -Strict: $true
  ```

- Parameter with argument ([§8.10.2][§8.10.2]) -- This has the form *command-parameter* where
  *first-parameter-char* and *parameter-chars* together make up the parameter name, which
  corresponds to the name of a parameter (without its leading -) in the command being invoked. There
  must be no trailing colon. The argument immediately following designates an associated value. For
  example, given a command `Get-Power`, which has parameters `$base` and `$exponent`, the following
  invocations are equivalent:

  ```powershell
  Get-Power -base 5 -exponent 3
  Get-Power -exponent 3 -base 5
  ```

- Positional argument ([§8.10.2][§8.10.2]) - Arguments and their corresponding parameters inside commands
  have positions with the first having position zero. The argument in position 0 is bound to the
  parameter in position 0; the argument in position 1 is bound to the parameter in position 1; and
  so on. For example, given a command `Get-Power`, that has parameters `$base` and `$exponent` in
  positions 0 and 1, respectively, the following invokes that command:

  ```powershell
  Get-Power 5 3
  ```

See [§8.2][§8.2] for details of the special parameters `--` and `--%`.

When a command is invoked, a parameter name may be abbreviated; any distinct leading part of the
full name may be used, provided that is unambiguous with respect to the names of the other
parameters accepted by the same command.

For information about parameter binding see [§8.14][§8.14].

### 2.3.5 Literals

Syntax:

```Syntax
literal:
    integer-literal
    real-literal
    string-literal
```

#### 2.3.5.1 Numeric literals

There are two kinds of numeric literals: integer ([§2.3.5.1.1][§2.3.5.1.1]) and real ([§2.3.5.1.2][§2.3.5.1.2]). Both
can have multiplier suffixes ([§2.3.5.1.3][§2.3.5.1.3]).

##### 2.3.5.1.1 Integer literals

Syntax:

```Syntax
integer-literal:
    decimal-integer-literal
    hexadecimal-integer-literal

decimal-integer-literal:
    decimal-digits numeric-type-suffix~opt~ numeric-multiplier~opt~

decimal-digits:
    decimal-digit
    decimal-digit decimal-digits

decimal-digit: one of
    0  1  2  3  4  5  6  7  8  9

numeric-type-suffix:
    long-type-suffix
    decimal-type-suffix

hexadecimal-integer-literal:
    0x hexadecimal-digits long-type-suffix~opt~
    numeric-multiplier~opt~

hexadecimal-digits:
    hexadecimal-digit
    hexadecimal-digit decimal-digits

hexadecimal-digit: one of
    0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f

long-type-suffix:
    l

numeric-multiplier: one of
    kb mb gb tb pb
```

Description:

The type of an integer literal is determined by its value, the presence or absence of
*long-type-suffix*, and the presence of a *numeric-multiplier* ([§2.3.5.1.3][§2.3.5.1.3]).

For an integer literal with no *long-type-suffix*

- If its value can be represented by type int ([§4.2.3][§4.2.3]), that is its type;
- Otherwise, if its value can be represented by type long ([§4.2.3][§4.2.3]), that is its type.
- Otherwise, if its value can be represented by type decimal ([§2.3.5.1.2][§2.3.5.1.2]), that is its type.
- Otherwise, it is represented by type double ([§2.3.5.1.2][§2.3.5.1.2]).

For an integer literal with *long-type-suffix*

- If its value can be represented by type long ([§4.2.3][§4.2.3]), that is its type;
- Otherwise, that literal is ill formed.

In the twos-complement representation of integer values, there is one more negative value than there
is positive. For the int type, that extra value is ‑2147483648. For the long type, that extra value
is ‑9223372036854775808. Even though the token 2147483648 would ordinarily be treated as a literal
of type long, if it is preceded immediately by the unary - operator, that operator and literal are
treated as a literal of type int having the smallest value. Similarly, even though the token
9223372036854775808 would ordinarily be treated as a real literal of type decimal, if it is
immediately preceded by the unary - operator, that operator and literal are treated as a literal of
type long having the smallest value.

Some examples of integer literals are 123 (int), 123L (long), and 200000000000 (long).

There is no such thing as an integer literal of type byte.

##### 2.3.5.1.2 Real literals

Syntax:

```Syntax
real-literal:
    decimal-digits . decimal-digits exponent-part~opt~ decimal-type-suffix~opt~ numeric-multiplier~opt~
    . decimal-digits exponent-part~opt~ decimal-type-suffix~opt~ numeric-multiplier~opt~
    decimal-digits exponent-part decimal-type-suffix~opt~ numeric-multiplier~opt~

exponent-part:
    e sign~opt~  decimal-digits

sign: one of
    +
    dash

decimal-type-suffix:
    d
    l

numeric-multiplier: one of
    kb mb gb tb pb

dash:
    - (U+002D)
    EnDash character (U+2013)
    EmDash character (U+2014)
    Horizontal bar character (U+2015)
```

Description:

A real literal may contain a *numeric-multiplier* ([§2.3.5.1.3][§2.3.5.1.3]).

There are two kinds of real literal: *double* and *decimal*. These are indicated by the absence or
presence, respectively, of *decimal-type-suffix*. (There is no such thing as a *float real
literal*.)

A double real literal has type double ([§4.2.4.1][§4.2.4.1]). A decimal real literal has type decimal
([§4.2.4.2][§4.2.4.2]). Trailing zeros in the fraction part of a decimal real literal are significant.

If the value of *exponent-part*'s *decimal-digits* in a double real literal is less than the
minimum supported, the value of that double real literal is 0. If the value of *exponent-part*'s
*decimal-digits* in a decimal real literal is less than the minimum supported, that literal is ill
formed. If the value of *exponent-part*'s *decimal-digits* in a double or decimal real literal is
greater than the maximum supported, that literal is ill formed.

Some examples of double real literals are 1., 1.23, .45e35, 32.e+12, and 123.456E-231.

Some examples of decimal real literals are 1d (which has scale 0), 1.20d (which has scale 2),
1.23450e1d (i.e., 12.3450, which has scale 4), 1.2345e3d (i.e., 1234.5, which has scale 1),
1.2345e-1d (i.e., 0.12345, which has scale 5), and 1.2345e-3d (i.e., 0.0012345, which has scale 7).

> [!NOTE]
> Because a double real literal need not have a fraction or exponent part, the grouping parentheses
> in (123).M are needed to ensure that the property or method M is being selected for the integer
> object whose value is 123. Without those parentheses, the real literal would be ill-formed.

> [!NOTE]
> Although PowerShell does not provide literals for infinities and NaNs, double real literal-like
> equivalents can be obtained from the static read-only properties PositiveInfinity,
> NegativeInfinity, and NaN of the types float and double ([§4.2.4.1][§4.2.4.1]).

The grammar permits what starts out as a double real literal to have an `l` or `L` type suffix. Such
a token is really an integer literal whose value is represented by type long.

> [!NOTE]
> This feature has been retained for backwards compatibility with earlier versions of PowerShell.
> However, programmers are discouraged from using integer literals of this form as they can easily
> obscure the literal's actual value. For example, 1.2L has value 1, 1.2345e1L has value 12, and
> 1.2345e-5L has value 0, none of which is immediately obvious.

##### 2.3.5.1.3 Multiplier suffixes

Syntax:

```Syntax
numeric-multiplier: *one of*
    kb mb gb tb pb
```

Description:

For convenience, integer and real literals can contain a *numeric-multiplier*, which indicates one
of a set of commonly used powers of 10. *numeric-multiplier* can be written in any combination of
upper- or lowercase letters.

| **Multiplier** | **Meaning**                                 | **Example**                    |
|----------------|---------------------------------------------|--------------------------------|
| kb             | kilobyte (1024)                             | 1kb ≡ 1024                     |
| mb             | megabyte (1024 x 1024)                      | 1.30Dmb ≡ 1363148.80           |
| gb             | gigabyte (1024 x 1024 x 1024)               | 0x10Gb ≡ 17179869184           |
| tb             | terabyte (1024 x 1024 x 1024 x 1024)        | 1.4e23tb ≡ 1.5393162788864E+35 |
| pb             | petabyte (1024 x 1024 x 1024 x 1024 x 1024) | 0x12Lpb ≡ 20266198323167232    |

#### 2.3.5.2 String literals

Syntax:

```Syntax
string-literal:
    expandable-string-literal
    expandable-here-string-literal
    verbatim-string-literal
    verbatim-here-string-literal

expandable-string-literal:
    double-quote-character expandable-string-characters~opt~  dollars~opt~ double-quote-character

double-quote-character:
    " (U+0022)
    Left double quotation mark (U+201C)
    Right double quotation mark (U+201D)
    Double low-9 quotation mark (U+201E)

expandable-string-characters:
      expandable-string-part
      expandable-string-characters
      expandable-string-part

expandable-string-part:
    Any Unicode character except
        $
        double-quote-character
        ` (The backtick character U+0060)
    braced-variable
    $ Any Unicode character except
        (
        {
        double-quote-character
        ` (The backtick character U+0060)*
    $ escaped-character
    escaped-character
    double-quote-character double-quote-character

dollars:
    $
    dollars $

expandable-here-string-literal:
    @  double-quote-character  whitespace~opt~  new-line-character
        expandable-here-string-characters~opt~  new-line-character  double-quote-character  @

expandable-here-string-characters:
    expandable-here-string-part
    expandable-here-string-characters  expandable-here-string-part

expandable-here-string-part:
    Any Unicode character except
        $
        new-line-character
    braced-variable
    $ Any Unicode character except
        (
        new-line-character
    $ new-line-character  Any Unicode character except double-quote-char
    $ new-line-character double-quote-char  Any Unicode character except @
    new-line-character  Any Unicode character except double-quote-char
    new-line-character double-quote-char  Any Unicode character except @

expandable-string-with-subexpr-start:
    double-quote-character  expandable-string-chars~opt~  $(

expandable-string-with-subexpr-end:
    double-quote-char

expandable-here-string-with-subexpr-start:
    @  double-quote-character  whitespace~opt~  new-line-character  expandable-here-string-chars~opt~  $(

expandable-here-string-with-subexpr-end:
    new-line-character  double-quote-character  @

verbatim-string-literal:
    single-quote-character verbatim-string-characters~opt~ single-quote-char

single-quote-character:
    ' (U+0027)
    Left single quotation mark (U+2018)
    Right single quotation mark (U+2019)
    Single low-9 quotation mark (U+201A)
    Single high-reversed-9 quotation mark (U+201B)

verbatim-string-characters:
    verbatim-string-part
    verbatim-string-characters verbatim-string-part

verbatim-string-part:
    *Any Unicode character except* single-quote-character
    single-quote-character  single-quote-character

verbatim-here-string-literal:
    @ single-quote-character whitespace~opt~  new-line-character
        verbatim-here-string-characters~opt~  new-line-character
            single-quote-character *@*

verbatim-*here-string-characters:
    verbatim-here-string-part
    verbatim-here-string-characters  verbatim-here-string-part

verbatim-here-string-part:
    Any Unicode character except* new-line-character
    new-line-character  Any Unicode character except single-quote-character
    new-line-character  single-quote-character  Any Unicode character except @
```

Description:

There are four kinds of string literals:

- *verbatim-string-literal* (single-line single-quoted), which is a sequence of zero or more
  characters delimited by a pair of *single-quote-character*s. Examples are '' and 'red'.
- *expandable-string-literal* (single-line double-quoted), which is a sequence of zero or more
  characters delimited by a pair of *double-quote-character*s. Examples are "" and "red".
- *verbatim-here-string-literal* (multi-line single-quoted), which is a sequence of zero or more
  characters delimited by the character pairs @*single-quote-character* and
  *single-quote-character*@, respectively, all contained on two or more source lines. Examples are:

  ```powershell
  @'
  '@

  @'
  line 1
  '@

  @'
  line 1
  line 2
  '@
  ```

- *expandable-here-string-literal* (multi-line double-quoted), which is a sequence of zero or more
  characters delimited by the character pairs @*double-quote-character* and
  *double-quote-character*@, respectively, all contained on two or more source lines. Examples are:

  ```powershell
  @"
  "@

  @"
  line 1
  "@

  @"
  line 1
  line 2
  "@
  ```

For *verbatim-here-string-literal*s and *expandable-here-string-literal*s, except for white space
(which is ignored) no characters may follow on the same source line as the opening
delimiter-character pair, and no characters may precede on the same source line as the closing
delimiter character pair.

The *body* of a *verbatim-here-string-literal* or an *expandable-here-string-literal* begins at the
start of the first source line following the opening delimiter, and ends at the end of the last
source line preceding the closing delimiter. The body may be empty. The line terminator on the last
source line preceding the closing delimiter is not part of that literal's body.

A literal of any of these kinds has type string ([§4.3.1][§4.3.1]).

The character used to delimit a *verbatim-string-literal* or *expandable-string-literal* can be
contained in such a string literal by writing that character twice, in succession. For example,
`'What''s the time?'` and `"I said, ""Hello""."`. However, a *single-quote-character* has no
special meaning inside an *expandable-string-literal*, and a *double-quote-character* has no special
meaning inside a *verbatim-string-literal*.

An *expandable-string-literal* and an *expandable-here-string-literal* may contain
*escaped-character*s ([§2.3.7][§2.3.7]). For example, when the following string literal is written to the
pipeline, the result is as shown below:

```powershell
"column1`tcolumn2`nsecond line, `"Hello`", ```Q`5`!"
```

```Output
column1<horizontal-tab>column2<new-line>
second line, "Hello", `Q5!
```

If an *expandable-string-literal* or *expandable-here-string-literal* contains the name of a
variable, unless that name is preceded immediately by an escape character, it is replaced by the
string representation of that variable's value ([§6.7][§6.7]). This is known as *variable substitution*.

> [!NOTE]
> If the variable name is part of some larger expression, only the variable name is replaced. For
> example, if `$a` is an array containing the elements 100 and 200, `">$a.Length<"` results in
> `>100 200.Length<` while `">$($a.Length)<"` results in `>2<`. See sub-expression expansion below.

For example, the source code

```powershell
$count = 10
"The value of `$count is $count"
```

results in the *expandable-string-literal*

```Output
The value of $count is 10.
```

Consider the following:

```powershell
$a = "red","blue"
"`$a[0] is $a[0], `$a[0] is $($a[0])" # second [0] is taken literally
```

The result is

```Output
$a[0] is red blue[0], $a[0] is red
```

*expandable-string-literal*s and *expandable-here-string-literal*s also support a kind of
substitution called *sub-expression expansion*, by treating text of the form `$( ... )` as a
*sub-expression* ([§7.1.6][§7.1.6]). Such text is replaced by the string representation of that
expression's value ([§6.8][§6.8]). Any white space used to separate tokens within *sub-expression*'s
*statement-list* is ignored as far as the result string's construction is concerned.

The examples,

```powershell
$count = 10
"$count + 5 is $($count + 5)"
"$count + 5 is `$($count + 5)"
"$count + 5 is `$(`$count + 5)"
```

result in the following *expandable-string-literal*s:

```Output
10 + 5 is 15
10 + 5 is $(10 + 5)
10 + 5 is $($count + 5)
```

The following source,

```powershell
$i = 5; $j = 10; $k = 15
"`$i, `$j, and `$k have the values $( $i; $j; $k )"
```

results in the following *expandable-string-literal*:

```Output
$i, $j, and $k have the values 5 10 15
```

These four lines could have been written more succinctly as follows:

```powershell
"`$i, `$j, and `$k have the values $(($i = 5); ($j = 10); ($k = 15))"
```

In the following example,

```powershell
"First 10 squares: $(for ($i = 1; $i -le 10; ++$i) { "$i $($i*$i) " })"
```

the resulting *expandable-string-literal* is as follows:

```Output
First 10 squares: 1 1 2 4 3 9 4 16 5 25 6 36 7 49 8 64 9 81 10 100
```

As shown, a *sub-expression* can contain string literals having both variable substitution and
sub-expression expansion. Note also that the inner *expandable-string-literal*'s delimiters need
not be escaped; the fact that they are inside a *sub-expression* means they cannot be terminators
for the outer *expandable-string-literal*.

An *expandable-string-literal* or *expandable-here-string-literal* containing a variable
substitution or sub-expression expansion is evaluated each time that literal is used; for example,

```powershell
$a = 10
$s1 = "`$a = $($a; ++$a)"
"`$s1 = >$s1<"
$s2 = "`$a = $($a; ++$a)"
"`$s2 = >$s2<"
$s2 = $s1
"`$s2 = >$s2<"
```

which results in the following *expandable-string-literal*s:

```Output
$s1 = >$a = 10<
$s2 = >$a = 11<
$s2 = >$a = 10<
```

The contents of a *verbatim-here-string-literal* are taken verbatim, including any leading or
trailing white space within the body. As such, embedded *single-quote-character*s need not be
doubled-up, and there is no substitution or expansion. For example,

```powershell
$lit = @'
That's it!
2 * 3 = $(2*3)
'@
```

which results in the literal

```Output
That's it!
2 * 3 = $(2*3)
```

The contents of an *expandable-here-string-literal* are subject to substitution and expansion, but
any leading or trailing white space within the body but outside any *sub-expression*s is taken
verbatim, and embedded *double-quote-character*s need not be doubled-up. For example,

```powershell
$lit = @"
That's it!
2 * 3 = $(2*3)
"@
```

which results in the following literal when expanded:

```powershell
That's it!
2 * 3 = 6
```

For both *verbatim-here-string-literal*s and *expandable-here-string-literal*s, each line terminator
within the body is represented in the resulting literal in an implementation-defined manner. For
example, in

```powershell
$lit = @"
abc
xyz
"@
```

the second line of the body has two leading spaces, and the first and second lines of the body have
line terminators; however, the terminator for the second line of the body is *not* part of that
body. The resulting literal is equivalent to:
`"abc<implementation-defined character sequence>xyz"`.

> [!NOTE]
> To aid readability of source, long string literals can be broken across multiple source lines
> without line terminators being inserted. This is done by writing each part as a separate literal
> and concatenating the parts with the + operator ([§7.7.2][§7.7.2]). This operator allows its operands to
> designate any of the four kinds of string literal.

> [!NOTE]
> Although there is no such thing as a character literal per se, the same effect can be achieved by
> accessing the first character in a 1-character string, as follows: `[char]"A"` or `"A"[0]`.

For both *verbatim-here-string-literal*s and *expandable-here-string-literal*s, each line terminator
within the body is represented exactly as it was provided.

#### 2.3.5.3 Null literal

See the automatic variable `$null` ([§2.3.2.2][§2.3.2.2]).

#### 2.3.5.4 Boolean literals

See the automatic variables `$false` and `$true` ([§2.3.2.2][§2.3.2.2]).

#### 2.3.5.5 Array literals

PowerShell allows expressions of array type (§9) to be written using the unary comma operator
([§7.2.1][§7.2.1]), *array-expression* ([§7.1.7][§7.1.7]), the binary comma operator ([§7.3][§7.3]), and the range
operator ([§7.4][§7.4]).

#### 2.3.5.6 Hash literals

PowerShell allows expressions of type Hashtable (§10) to be written using a
*hash-literal-expression* ([§7.1.9][§7.1.9])

#### 2.3.5.7 Type names

Syntax:

```Syntax
type-name:
    type-identifier
    type-name . type-identifier

type-identifier:
    type-characters

type-characters:
    type-character
    type-characters type-character

type-character:
    A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nd
    _ (The underscore character U+005F)

array-type-name:
    type-name [

generic-type-name:
    type-name [
```

### 2.3.6 Operators and punctuators

Syntax:

```Syntax
operator-or-punctuator: one of
    {   }   [   ]   (   )   @(   @{   $(   ;
    &&  ||  &   |   ,   ++  ..   ::   .
    !   *   /   %   +   -   --
    -and   -band   -bnot   -bor
    -bxor   -not   -or     -xor
    assignment-operator
    merging-redirection-operator
    file-redirection-operator
    comparison-operator
    format-operator

assignment-operator: one of
    =  -=  +=  *=  /=  %=

file-redirection-operator: one of
    >  >>  2>  2>>  3>  3>>  4>  4>>
    5>  5>>  6>  6>>  *>  *>>  <

merging-redirection-operator: one of
    *>&1  2>&1  3>&1  4>&1  5>&1  6>&1
    *>&2  1>&2  3>&2  4>&2  5>&2  6>&2

comparison-operator: *one of
    -as           -ccontains      -ceq
    -cge          -cgt            -cle
    -clike        -clt            -cmatch
    -cne          -cnotcontains   -cnotlike
    -cnotmatch    -contains       -creplace
    -csplit       -eq             -ge
    -gt           -icontains      -ieq
    -ige          -igt            -ile
    -ilike        -ilt            -imatch
    -in           -ine            -inotcontains
    -inotlike     -inotmatch      -ireplace
    -is           -isnot          -isplit
    -join         -le             -like
    -lt           -match          -ne
    -notcontains  -notin         -notlike
    -notmatch     -replace       -shl*
    -shr          -split

format-operator:
    -f
```

Description:

`&&` and `||` are reserved for future use.

> [!NOTE]
> Editor's Note: The pipeline chain operators `&&` and `||` were introduced in PowerShell 7. See
> [about_Pipeline_Chain_Operators](/powershell/module/microsoft.powershell.core/about/about_pipeline_chain_operators).

The name following *dash* in an operator is reserved for that purpose only in an operator context.

An operator that begins with *dash* must not have any white space between that *dash* and the token
that follows it.

### 2.3.7 Escaped characters

Syntax:

```Syntax
escaped-character:
    ` (The backtick character U+0060) followed by any Unicode character
```

Description:

An *escaped character* is a way to assign a special interpretation to a character by giving it a
prefix Backtick character (U+0060). The following table shows the meaning of each
*escaped-character*:

| Escaped Character |                            Meaning                             |
|-------------------|----------------------------------------------------------------|
| `` `a ``          | Alert (U+0007)                                                 |
| `` `b ``          | Backspace (U+0008)                                             |
| `` `f ``          | Form-feed (U+000C)                                             |
| `` `n ``          | New-line (U+000A)                                              |
| `` `r ``          | Carriage return (U+000D)                                       |
| `` `t ``          | Horizontal tab (U+0009)                                        |
| `` `v ``          | Vertical tab (U+0009)                                          |
| `` `' ``          | Single quote (U+0027)                                          |
| `` `" ``          | Double quote (U+0022)                                          |
| ` `` `            | Backtick (U+0060)                                              |
| `` `0 ``          | NUL (U+0000)                                                   |
| `` `x ``          | If `x` is a character other than those characters shown above, |
|                   | the backtick character is ignored and `x` is taken literally.  |

The implication of the final entry in the table above is that spaces that would otherwise separate
tokens can be made part of a token instead. For example, a file name containing a space can be
written as ``Test` Data.txt`` (as well as `'Test Data.txt'` or `"Test Data.txt"`).

<!-- reference links -->
[§2.2.2]: chapter-02.md#222-line-terminators
[§2.2.4]: chapter-02.md#224-white-space
[§2.3.2.1]: chapter-02.md#2321-user-defined-variables
[§2.3.2.2]: chapter-02.md#2322-automatic-variables
[§2.3.2.3]: chapter-02.md#2323-preference-variables
[§2.3.5.1.1]: chapter-02.md#23511-integer-literals
[§2.3.5.1.2]: chapter-02.md#23512-real-literals
[§2.3.5.1.3]: chapter-02.md#23513-multiplier-suffixes
[§2.3.7]: chapter-02.md#237-escaped-characters
[§3.1]: chapter-03.md#31-providers-and-drives
[§3.5]: chapter-03.md#35-scopes
[§4.2.3]: chapter-04.md#423-integer
[§4.2.4.1]: chapter-04.md#4241-float-and-double
[§4.2.4.2]: chapter-04.md#4242-decimal
[§4.3.1]: chapter-04.md#431-strings
[§6.7]: chapter-06.md#67-conversion-to-object
[§6.8]: chapter-06.md#68-conversion-to-string
[§7.1.6]: chapter-07.md#716--operator
[§7.1.7]: chapter-07.md#717--operator
[§7.1.9]: chapter-07.md#719-hash-literal-expression
[§7.2.1]: chapter-07.md#721-unary-comma-operator
[§7.3]: chapter-07.md#73-binary-comma-operator
[§7.4]: chapter-07.md#74-range-operator
[§7.7.2]: chapter-07.md#772-string-concatentaion
[§8.10.2]: chapter-08.md#8102-workflow-functions
[§8.10.5]: chapter-08.md#8105-the-switch-type-constraint
[§8.14]: chapter-08.md#814-parameter-binding
[§8.2]: chapter-08.md#82-pipeline-statements
[§B.1]: chapter-15.md#b1-lexical-grammar
[§B.2]: chapter-15.md#b2-syntactic-grammar

# /./lang-spec/chapter-03.md - Basic concepts

    ---
    description: PowerShell providers allow access to data and components from the command line. The data is presented in a consistent format that resembles a file system drive.
    ms.date: 05/19/2021
    title: Basic concepts
    ---
# 3. Basic concepts

## 3.1 Providers and drives

A *provider* allows access to data and components that would not otherwise be easily accessible at
the command line. The data is presented in a consistent format that resembles a file system drive.

The data that a provider exposes appears on a *drive*, and the data is accessed via a *path* just
like with a disk drive. Built-in cmdlets for each provider manage the data on the provider drive.

PowerShell includes the following set of built-in providers to access the different types of data
stores:

| **Provider** | **Drive Name**  | **Description**                     | **Ref.** |
|--------------|-----------------|-------------------------------------|----------|
| Alias        | Alias:          | PowerShell aliases                  | [§3.1.1][§3.1.1]   |
| Environment  | Env:            | Environment variables               | [§3.1.2][§3.1.2]   |
| FileSystem   | A:, B:, C:, ... | Disk drives, directories, and files | [§3.1.3][§3.1.3]   |
| Function     | Function:       | PowerShell functions                | [§3.1.4][§3.1.4]   |
| Variable     | Variable:       | PowerShell variables                | [§3.1.5][§3.1.5]   |

Windows PowerShell:

| **Provider** |                    **Drive Name**                     |             **Description**              |
| ------------ | ----------------------------------------------------- | ---------------------------------------- |
| Certificate  | Cert:                                                 | x509 certificates for digital signatures |
| Registry     | HKLM: (HKEY_LOCAL_MACHINE), HKCU: (HKEY_CURRENT_USER) | Windows registry                         |
| WSMan        | WSMan:                                                | WS-Management configuration information  |

The following cmdlets deal with providers and drives:

- [Get-PSProvider](xref:Microsoft.PowerShell.Management.Get-PSProvider): Gets information about one
  or more providers
- [Get-PSDrive](xref:Microsoft.PowerShell.Management.Get-PSDrive): Gets information about one or more drives

The type of an object that represents a provider is described in [§4.5.1][§4.5.1]. The type of an object
that represents a drive is described in [§4.5.2][§4.5.2].

### 3.1.1 Aliases

An *alias* is an alternate name for a command. A command can have multiple aliases, and the original
name and all of its aliases can be used interchangeably. An alias can be reassigned. An alias is an
item ([§3.3][§3.3]).

An alias can be assigned to another alias; however, the new alias is not an alias of the original
command.

The provider Alias is a flat namespace that contains only objects that represent the aliases. The
variables have no child items.

PowerShell comes with a set of built-in aliases.

The following cmdlets deal with aliases:

- [New-Alias](xref:Microsoft.PowerShell.Utility.New-Alias): Creates an alias
- [Set-Alias](xref:Microsoft.PowerShell.Utility.Set-Alias): Creates or changes one or more aliases
- [Get-Alias](xref:Microsoft.PowerShell.Utility.Get-Alias): Gets information about one or more
  aliases
- [Export-Alias](xref:Microsoft.PowerShell.Utility.Export-Alias): Exports one or more aliases to a
  file

When an alias is created for a command using `New-Alias`, parameters to that command cannot be
included in that alias. However, direct assignment to a variable in the Alias: namespace does permit
parameters to be included.

> [!NOTE]
> It is a simple matter, however, to create a function that does nothing more than contain the
> invocation of that command with all desired parameters, and to assign an alias to that function.

The type of an object that represents an alias is described in [§4.5.4][§4.5.4].

Alias objects are stored on the drive Alias: ([§3.1][§3.1]).

### 3.1.2 Environment variables

The PowerShell environment provider allows operating system environment variables to be retrieved,
added, changed, cleared, and deleted.

The provider Environment is a flat namespace that contains only objects that represent the
environment variables. The variables have no child items.

An environment variable's name cannot include the equal sign (`=`).

Changes to the environment variables affect the current session only.

An environment variable is an item ([§3.3][§3.3]).

The type of an object that represents an environment variable is described in [§4.5.6][§4.5.6].

Environment variable objects are stored on the drive Env: ([§3.1][§3.1]).

### 3.1.3 File system

The PowerShell file system provider allows directories and files to be created, opened, changed, and
deleted.

The file system provider is a hierarchical namespace that contains objects that represent the
underlying file system.

Files are stored on drives with names like A:, B:, C:, and so on ([§3.1][§3.1]). Directories and files
are accessed using path notation ([§3.4][§3.4]).

A directory or file is an item ([§3.3][§3.3]).

### 3.1.4 Functions

The PowerShell function provider allows functions ([§8.10][§8.10]) and filters ([§8.10][§8.10].1) to be
retrieved, added, changed, cleared, and deleted.

The provider Function is a flat namespace that contains only the function and filter objects.
Neither functions nor filters have child items.

Changes to the functions affect the current session only.

A function is an item ([§3.3][§3.3]).

The type of an object that represents a function is described in [§4.5.10][§4.5.10]. The type of an object
that represents a filter is described in [§4.5.11][§4.5.11].

Function objects are stored on drive Function: ([§3.1][§3.1]).

### 3.1.5 Variables

Variables can be defined and manipulated directly in the PowerShell language.

The provider Variable is a flat namespace that contains only objects that represent the variables.
The variables have no child items.

The following cmdlets also deal with variables:

- [New-Variable](xref:Microsoft.PowerShell.Utility.New-Variable): Creates a variable
- [Set-Variable](xref:Microsoft.PowerShell.Utility.Set-Variable): Creates or changes the
  characteristics of one or more variables
- [Get-Variable](xref:Microsoft.PowerShell.Utility.Get-Variable): Gets information about one or more
  variables
- [Clear-Variable](xref:Microsoft.PowerShell.Utility.Clear-Variable): Deletes the value of one or
  more variables
- [Remove-Variable](xref:Microsoft.PowerShell.Utility.Remove-Variable): Deletes one or more
  variables

As a variable is an item ([§3.3][§3.3]), it can be manipulated by most Item-related cmdlets.

The type of an object that represents a variable is described in [§4.5.3][§4.5.3].

Variable objects are stored on drive Variable: ([§3.1][§3.1]).

## 3.2 Working locations

The *current working location* is the default location to which commands point. This is the location
used if an explicit path ([§3.4][§3.4]) is not supplied when a command is invoked. This location
includes the *current drive*.

A PowerShell host may have multiple drives, in which case, each drive has its own current location.

When a drive name is specified without a directory, the current location for that drive is implied.

The current working location can be saved on a stack, and then set to a new location. Later, that
saved location can be restored from that stack and made the current working location. There are two
kinds of location stacks: the *default working location stack*, and zero or more user-defined *named
working location stacks*. When a session begins, the default working location stack is also the
*current working location stack*. However, any named working location stack can be made the current
working location stack.

The following cmdlets deal with locations:

- [Set-Location](xref:Microsoft.PowerShell.Management.Set-Location): Establishes the current working
  location
- [Get-Location](xref:Microsoft.PowerShell.Management.Get-Location): Determines the current working
  location for the specified drive(s), or the working locations for the specified stack(s)
- [Push-Location](xref:Microsoft.PowerShell.Management.Push-Location): Saves the current working
  location on the top of a specified stack of locations
- [Pop-Location](xref:Microsoft.PowerShell.Management.Pop-Location): Restores the current working
  location from the top of a specified stack of locations

The object types that represents a working location and a stack of working locations are described
in [§4.5.5][§4.5.5].

## 3.3 Items

An *item* is an alias ([§3.1.1][§3.1.1]), a variable ([§3.1.5][§3.1.5]), a function ([§3.1.4][§3.1.4]), an environment
variable ([§3.1.2][§3.1.2]), or a file or directory in a file system ([§3.1.3][§3.1.3]).

The following cmdlets deal with items:

- [New-Item](xref:Microsoft.PowerShell.Management.New-Item): Creates a new item
- [Set-Item](xref:Microsoft.PowerShell.Management.Set-Item): Changes the value of one or more items
- [Get-Item](xref:Microsoft.PowerShell.Management.Get-Item): Gets the items at the specified
  location
- [Get-ChildItem](xref:Microsoft.PowerShell.Management.Get-ChildItem): Gets the items and child
  items at the specified location
- [Copy-Item](xref:Microsoft.PowerShell.Management.Copy-Item): Copies one or more items from one
  location to another
- [Move-Item](xref:Microsoft.PowerShell.Management.Move-Item): Moves one or more items from one
  location to another
- [Rename-Item](xref:Microsoft.PowerShell.Management.Rename-Item): Renames an item
- [Invoke-Item](xref:Microsoft.PowerShell.Management.Invoke-Item): Performs the default action on
  one or more items
- [Clear-Item](xref:Microsoft.PowerShell.Management.Clear-Item): Deletes the contents of one or more
  items, but does not delete the items (see
- [Remove-Item](xref:Microsoft.PowerShell.Management.Remove-Item): Deletes the specified items

The following cmdlets deal with the content of items:

- [Get-Content](xref:Microsoft.PowerShell.Management.Get-Content): Gets the content of the item
- [Add-Content](xref:Microsoft.PowerShell.Management.Add-Content): Adds content to the specified
  items
- [Set-Content](xref:Microsoft.PowerShell.Management.Set-Content): Writes or replaces the content in
  an item
- [Clear-Content](xref:Microsoft.PowerShell.Management.Clear-Content): Deletes the contents of an
  item

The type of an object that represents a directory is described in [§4.5.17][§4.5.17]. The type of an object
that represents a file is described in [§4.5.18][§4.5.18].

## 3.4 Path names

All items in a data store accessible through a PowerShell provider can be identified uniquely by
their path names. A *path name* is a combination of the item name, the container and subcontainers
in which the item is located, and the PowerShell drive through which the containers are accessed.

Path names are divided into one of two types: fully qualified and relative. A *fully qualified path
name* consists of all elements that make up a path. The following syntax shows the elements in a
fully qualified path name:

> [!TIP]
> The `~opt~` notation in the syntax definitions indicates that the lexical entity is optional in
> the syntax.

```Syntax
path:
    provider~opt~   drive~opt~   containers~opt~   item

provider:
    module~opt~   provider   ::

module:
    module-name   \

drive:
    drive-name   :

containers:
    container   \
    containers container   \
```

*module-name* refers to the parent module.

*provider* refers to the PowerShell provider through which the data store is accessed.

*drive* refers to the PowerShell drive that is supported by a particular PowerShell provider.

A *container* can contain other containers, which can contain other containers, and so on, with the
final container holding an *item*. Containers must be specified in the hierarchical order in which
they exist in the data store.

Here is an example of a path name:

`E:\Accounting\InvoiceSystem\Production\MasterAccount\MasterFile.dat`

If the final element in a path contains other elements, it is a *container element*; otherwise,
it's a *leaf element*.

In some cases, a fully qualified path name is not needed; a relative path name will suffice. A
*relative path name* is based on the current working location. PowerShell allows an item to be
identified based on its location relative to the current working location. A relative path name
involves the use of some special characters. The following table describes each of these characters
and provides examples of relative path names and fully qualified path names. The examples in the
table are based on the current working directory being set to C:\Windows:

| **Symbol** |              **Description**               | **Relative path**  | **Fully qualified path** |
| ---------- | ------------------------------------------ | ------------------ | ------------------------ |
| `.`        | Current working location                   | `.\System`         | `C:\Windows\System`      |
| `..`       | Parent of the current working location     | `..\Program Files` | `C:\Program Files`       |
| `\`        | Drive root of the current working location | `\Program Files`   | `C:\Program Files`       |
| none       | No special characters                      | `System`           | `C:\Windows\System`      |

To use a path name in a command, enter that name as a fully qualified or
relative path name.

The following cmdlets deal with paths:

- [Convert-Path](xref:Microsoft.PowerShell.Management.Convert-Path): Converts a path from a
  PowerShell path to a PowerShell provider path
- [Join-Path](xref:Microsoft.PowerShell.Management.Join-Path): Combines a path and a child path into
  a single path
- [Resolve-Path](xref:Microsoft.PowerShell.Management.Resolve-Path): Resolves the wildcard
  characters in a path
- [Split-Path](xref:Microsoft.PowerShell.Management.Split-Path): Returns the specified part of a
  path
- [Test-Path](xref:Microsoft.PowerShell.Management.Test-Path): Determines whether the elements of a
  path exist or if a path is well formed

Some cmdlets (such as [Add-Content](xref:Microsoft.PowerShell.Management.Add-Content) and
`Copy-Item` use file filters. A *file filter* is a mechanism for specifying the criteria for
selecting from a set of paths.

The object type that represents a resolved path is described in [§4.5.5][§4.5.5]. Paths are often
manipulated as strings.

## 3.5 Scopes

### 3.5.1 Introduction

A name can denote a variable, a function, an alias, an environment variable, or a drive. The same
name may denote different items at different places in a script. For each different item that a name
denotes, that name is visible only within the region of script text called its *scope*. Different
items denoted by the same name either have different scopes, or are in different name spaces.

Scopes may nest, in which case, an outer scope is referred to as a *parent scope,* and any nested
scopes are *child scopes* of that parent. The scope of a name is the scope in which it is defined
and all child scopes, unless it is made private. Within a child scope, a name defined there hides
any items defined with the same name in parent scopes.

Unless dot source notation ([§3.5.5][§3.5.5]) is used, each of the following creates a new scope:

- A script file
- A script block
- A function or filter

Consider the following example:

```powershell
# start of script
$x = 2; $y = 3
Get-Power $x $y

#function defined in script

function Get-Power([int]$x, [int]$y)
{
if ($y -gt 0) { return $x * (Get-Power $x (--$y)) }

else { return 1 }
}
# end of script
```

The scope of the variables `$x` and `$y` created in the script is the body of that script, including
the function defined inside it. Function `Get-Power` defines two parameters with those same names.
As each function has its own scope, these variables are different from those defined in the parent
scope, and they hide those from the parent scope. The function scope is nested inside the script
scope.

Note that the function calls itself recursively. Each time it does so, it creates yet another nested
scope, each with its own variables `$x` and `$y`.

Here is a more complex example, which also shows nested scopes and reuse of names:

```powershell
# start of script scope
$x = 2              # top-level script-scope $x created
                    # $x is 2
F1                  # create nested scope with call to function F1
                    # $x is 2
F3                  # create nested scope with call to function F3
                    # $x is 2

function F1 {       # start of function scope
                    # $x is 2
    $x = $true      # function-scope $x created
                    # $x is $true

    & {             # create nested scope with script block
                    # $x is $true
        $x = 12.345 # scriptblock-scope $x created
                    # $x is 12.345
    }               # end of scriptblock scope, local $x goes away

                    # $x is $true
    F2              # create nested scope with call to function F2
                    # $x is $true
}                   # end of function scope, local $x goes away

function F2 {       # start of function scope
                    # $x is $true
    $x = "red"      # function-scope $x created
                    # $x is "red"
}                   # end of function scope, local $x goes away

function F3 {       # start of function scope
                    # $x is 2
    if ($x -gt 0) {
                    # $x is 2
        $x = "green"
                    # $x is "green"
    }               # end of block, but not end of any scope
                    # $x is still "green"
}                   # end of function scope, local $x goes away
# end of script scope
```

### 3.5.2 Scope names and numbers

PowerShell supports the following scopes:

- Global: This is the top-most level scope. All automatic and preference variables are defined in
  this scope. The global scope is the parent scope of all other scopes, and all other scopes are
  child scopes of the global scope.

- Local: This is the current scope at any execution point within a script, script block, or
  function. Any scope can be the local scope.

- Script: This scope exists for each script file that is executed. The script scope is the parent
  scope of all scopes created from within it. A script block does *not* have its own script scope;
  instead, its script scope is that of its nearest ancestor script file. Although there is no such
  thing as module scope, script scope provides the equivalent.

Names can be declared private, in which case, they are not visible outside of their parent scope,
not even to child scopes. The concept of private is not a separate scope; it's an alias for local
scope with the addition of hiding the name if used as a writable location.

Scopes can be referred to by a number, which describes the relative position of one scope to
another. Scope 0 denotes the local scope, scope 1 denotes a 1-generation ancestor scope, scope 2
denotes a 2-generation ancestor scope, and so on. (Scope numbers are used by cmdlets that manipulate
variables.)

### 3.5.3 Variable name scope

As shown by the following production, a variable name can be specified with any one of six different
scopes:

```Syntax
variable-scope:
    global:
    local:
    private:
    script:
    using:
    workflow:
    variable-namespace
```

The scope is optional. The following table shows the meaning of each in all possible contexts. It
also shows the scope when no scope is specified explicitly:

| **Scope Modifier** |                                  **Within a Script File**                                  |                                 **Within a Script Block**                                  |                                   **Within a Function**                                    |
| ------------------ | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------ |
| global             | Global scope                                                                               | Global scope                                                                               | Global scope                                                                               |
| script             | Nearest ancestor script file's scope or Global if there is no nearest ancestor script file | Nearest ancestor script file's scope or Global if there is no nearest ancestor script file | Nearest ancestor script file's scope or Global if there is no nearest ancestor script file |
| private            | Global/Script/Local scope                                                                  | Local scope                                                                                | Local scope                                                                                |
| local              | Global/Script/Local scope                                                                  | Local scope                                                                                | Local scope                                                                                |
| using              | Implementation defined                                                                     | Implementation defined                                                                     | Implementation defined                                                                     |
| workflow           | Implementation defined                                                                     | Implementation defined                                                                     | Implementation defined                                                                     |
| none               | Global/Script/Local scope                                                                  | Local scope                                                                                | Local scope                                                                                |

Variable scope information can also be specified when using the family of cmdlets listed in
([§3.1.5][§3.1.5]). In particular, refer to the parameter `Scope`, and the parameters `Option Private` and
`Option AllScope` for more information.

The scope `using` is used to access variables defined in another scope while running scripts via
cmdlets like `Start-Job`, `Invoke-Command`, or within an *inlinescript-statement*. For example:

```powershell
$a = 42
Invoke-Command --ComputerName RemoteServer { $using:a } # returns 42
workflow foo
{
    $b = "Hello"
    inlinescript { $using:b }
}
foo # returns "Hello"
```

The scope workflow is used with a *parallel-statement* or *sequence-statement* to access a variable
defined in the workflow.

### 3.5.4 Function name scope

A function name may also have one of the four different scopes, and the visibility of that name is
the same as for variables ([§3.5.3][§3.5.3]).

### 3.5.5 Dot source notation

When a script file, script block, or function is executed from within another script file, script
block, or function, the executed script file creates a new nested scope. For example,

```powershell
Script1.ps1
& "Script1.ps1"
& { ... }
FunctionA
```

However, when *dot source notation* is used, no new scope is created before the command is executed,
so additions/changes it would have made to its own local scope are made to the current scope
instead. For example,

```powershell
. Script2.ps1
. "Script2.ps1"
. { ... }
. FunctionA
```

### 3.5.6 Modules

Just like a top-level script file is at the root of a hierarchical nested scope tree, so too is each
module ([§3.14][§3.14]). However, by default, only those names exported by a module are available by name
from within the importing context. The Global parameter of the cmdlet
[Import-Module](xref:Microsoft.PowerShell.Core.Import-Module) allows exported names to have
increased visibility.

## 3.6 ReadOnly and Constant Properties

Variables and aliases are described by objects that contain a number of properties. These properties
are set and manipulated by two families of cmdlets ([§3.1.5][§3.1.5], [§3.1.1][§3.1.1]). One such property is
Options, which can be set to ReadOnly or Constant (using the Option parameter). A variable or alias
marked ReadOnly can be removed, and its properties can changed provided the Force parameter is
specified. However, a variable or alias marked Constant cannot be removed nor have its properties
changed.

## 3.7 Method overloads and call resolution

### 3.7.1 Introduction

As stated in §1, an external procedure made available by the execution environment (and written in
some language other than PowerShell) is called a *method*.

The name of a method along with the number and types of its parameters are collectively called that
method's *signature*. (Note that the signature does not include the method's return type.) The
execution environment may allow a type to have multiple methods with the same name provided each has
a different signature. When multiple versions of some method are defined, that method is said to be
*overloaded*. For example, the type Math ([§4.3.8][§4.3.8]) contains a set of methods called `Abs`, which
computes the absolute value of a specified number, where the specified number can have one of a
number of types. The methods in that set have the following signatures:

```powershell
Abs(decimal)
Abs(float)
Abs(double)
Abs(int)
Abs(long)
Abs(SByte)
Abs(Int16)
```

In this case, all of the methods have the same number of arguments; their signatures differ by
argument type only.

Another example involves the type Array ([§4.3.2][§4.3.2]), which contains a set of methods called Copy
that copies a range of elements from one array to another, starting at the beginning of each array
(by default) or at some designated element. The methods in that set have the following signatures:

```powershell
Copy(Array, Array, int)
Copy(Array, Array, long)
Copy(Array, int, Array, int, int)
Copy(Array, long, Array, long, long)
```

In this case, the signatures differ by argument type and, in some cases, by argument number as well.

In most calls to overloaded methods, the number and type of the arguments passed exactly match one
of the overloads, and the method selected is obvious. However, if that is not the case, there needs
to be a way to resolve which overloaded version to call, if any. For example,

```powershell
[Math]::Abs([byte]10) # no overload takes type byte
[Array]::Copy($source, 3, $dest, 5L, 4) # both int and long indexes
```

Other examples include the type **string** (i.e.; **System.String**), which has numerous overloaded
methods.

Although PowerShell has rules for resolving method calls that do not match an overloaded signature
exactly, PowerShell does not itself provide a way to define overloaded methods.

> [!NOTE]
> Editor's Note: PowerShell 5.0 added the ability to define script-based classes. These classes can
> contain overloaded methods.

### 3.7.2 Method overload resolution

Given a method call ([§7.1.3][§7.1.3]) having a list of argument expressions, and a set of *candidate
method*s (i.e., those methods that could be called), the mechanism for selecting the *best method*
is called *overload resolution*.

Given the set of applicable candidate methods ([§3.7.3][§3.7.3]), the best method in that set is selected.
If the set contains only one method, then that method is the best method. Otherwise, the best method
is the one method that is better than all other methods with respect to the given argument list
using the rules shown in [§3.7.4][§3.7.4]. If there is not exactly one method that is better than all
other methods, then the method invocation is ambiguous and an error is reported.

The best method must be accessible in the context in which it is called. For example, a PowerShell
script cannot call a method that is private or protected.

The best method for a call to a static method must be a static method, and the best method for a
call to an instance method must be an instance method.

### 3.7.3 Applicable method

A method is said to be *applicable* with respect to an argument list A when one of the following is
true:

- The number of arguments in A is identical to the number of parameters that the method accepts.
- The method has M required parameters and N optional parameters, and the number of arguments in A
  is greater than or equal to M, but less than N.
- The method accepts a variable number of arguments and the number of arguments in A is greater than
  the number of parameters that the method accepts.

In addition to having an appropriate number of arguments, each argument in A must match the
parameter-passing mode of the argument, and the argument type must match the parameter type, or
there must be a conversion from the argument type to the parameter type.

If the argument type is ref ([§4.3.6][§4.3.6]), the corresponding parameter must also be ref, and the
argument type for conversion purposes is the type of the property Value from the ref argument.

If the argument type is `ref`, the corresponding parameter could be `out` instead of `ref`.

If the method accepts a variable number of arguments, the method may be applicable in either *normal
form* or *expanded form*. If the number of arguments in A is identical to the number of parameters
that the method accepts and the last parameter is an array, then the form depends on the rank of one
of two possible conversions:

- The rank of the conversion from the type of the last argument in A to the array type for the last
  parameter.
- The rank of the conversion from the type of the last argument in A to the element type of the
  array type for the last parameter.

If the first conversion (to the array type) is better than the second conversion (to the element
type of the array), then the method is applicable in normal form, otherwise it is applicable in
expanded form.

If there are more arguments than parameters, the method may be applicable in expanded form only. To
be applicable in expanded form, the last parameter must have array type. The method is replaced with
an equivalent method that has the last parameter replaced with sufficient parameters to account for
each unmatched argument in A. Each additional parameter type is the element type of the array type
for the last parameter in the original method. The above rules for an applicable method are applied
to this new method and argument list A.

### 3.7.4 Better method

Given an argument list A with a set of argument expressions `{ E~1~, E~2~, ..., E~N~ }` and two
application methods `M~P~` and `M~Q~` with parameter types `{ P~1~, P~2~, ..., P~N~ }` and
`{ Q~1~, Q~2~, ..., Q~N~ }`, `M~P~` is defined to be a better method than `M~Q~` if the *cumulative
ranking of conversions* for `M~P~` is better than that for `M~Q~`.

The cumulative ranking of conversions is calculated as follows. Each conversion is worth a different
value depending on the number of parameters, with the conversion of `E~1~` worth N, `E~2~` worth
N-1, down to `E~N~` worth 1. If the conversion from `E~X~` to `P~X~` is better than that from `E~X~`
to `Q~X~`, the `M~P~` accumulates N-X+1; otherwise, `M~Q~` accumulates N-X+1. If `M~P~` and `M~Q~`
have the same value, then the following tie breaking rules are used, applied in order:

- The cumulative ranking of conversions between parameter types (ignoring argument types) is
  computed in a manner similar to the previous ranking, so `P~1~` is compared against `Q~1~`, `P~2~`
  against `Q~2~`, ..., and `P~N~` against `Q~N~`. The comparison is skipped if the argument was
  `$null`, or if the parameter types are not numeric types. The comparison is also skipped if the
  argument conversion `E~X~` loses information when converted to `P~X~` but does not lose
  information when converted to `Q~X~`, or vice versa. If the parameter conversion types are
  compared, then if the conversion from `P~X~` to `Q~X~` is better than that from `Q~X~` to `P~X~`,
  the `M~P~` accumulates N-X+1; otherwise, `M~Q~` accumulates N-X+1. This tie breaking rule is
  intended to prefer the *most specific method* (i.e., the method with parameters having the
  smallest data types) if no information is lost in conversions, or to prefer the *most general
  method* (i.e., the method with the parameters with the largest data types) if conversions result
  in loss of information.
- If both methods use their expanded form, the method with more parameters is the better method.
- If one method uses the expanded form and the other uses normal form, the method using normal form
  is the better method.

### 3.7.5 Better conversion

The text below marked like this is specific to Windows PowerShell.

Conversions are ranked in the following manner, from lowest to highest:

- `T~1~[]` to `T~2~[]` where no assignable conversion between `T~1~` and `T~2~` exists
- T to string where T is any type
- `T~1~` to `T~2~` where `T~1~` or `T~2~` define a custom conversion in an implementation-defined
  manner
- `T~1~` to `T~2~` where `T~1~` implements IConvertible
- `T~1~` to `T~2~` where `T~1~` or `T~2~` implements the method `T~2~ op_Implicit(T1)`
- `T~1~` to `T~2~` where `T~1~` or `T~2~` implements the method `T~2~ op_Explicit(T1)`
- `T~1~` to `T~2~` where `T~2~` implements a constructor taking a single argument of type `T~1~`
- Either of the following conversions:
  - string to `T` where `T` implements a static method `T Parse(string)` or
    `T Parse(string, IFormatProvider)`
  - `T~1~` to `T~2~` where `T~2~` is any enum and `T~1~` is either string or a collection of objects
    that can be converted to string
- `T` to PSObject where `T` is any type
- Any of the following conversions: `Language`
  - T to bool where `T` is any numeric type
  - string to `T` where `T` is `regex`, `wmisearcher`, `wmi`, `wmiclass`, `adsi`, `adsisearcher`, or
    `type`
  - `T` to `bool`
  - T~1~ to `Nullable[T~2~]` where a conversion from `T~1~` to `T~2~` exists
  - `T` to void
  - `T~1~[]` to `T~2~[]` where an assignable conversion between `T~1~` and `T~2~` exists
  - `T~1~` to `T~2~[]` where `T~1~` is a collection
  - `IDictionary` to `Hashtable`
  - `T` to `ref`
  - `T` to `xml`
  - `scriptblock` to `delegate`
  - `T~1~` to `T~2~` where `T~1~` is an integer type and `T~2~` is an enum
- `$null` to `T` where `T` is any value type
- `$null` to `T` where `T` is any reference type
- Any of the following conversions:
  - byte to `T` where `T` is `SByte`

  - `UInt16` to `T` where `T` is `SByte`, `byte`, or `Int16`
  - `Int16` to `T` where `T` is `SByte` or `byte`
  - `UInt32` to `T` where `T` is `SByte`, `byte`, `Int16`, `UInt16`, or `int`
  - `int` to `T` where `T` is `SByte`, `byte`, `Int16`, or `UInt16`
  - `UInt64` to `T` where `T` is `SByte`, `byte`, `Int16`, `UInt16`, `int`, `UInt32`, or `long`
  - `long` to `T` where `T` is `SByte`, `byte`, `Int16`, `UInt16`, `int`, or `UInt32`
  - `float` to `T` where `T` is any integer type or `decimal`
  - `double` to `T` where `T` is any integer type or `decimal`
  - `decimal` to `T` where `T` is any integer type
- Any of the following conversions:
  - `SByte` to `T` where `T` is `byte`, `uint6`, `UInt32`, or `UInt64`
  - `Int16` to `T` where `T` is `UInt16`, `UInt32`, or `UInt64`
  - `int` to `T` where `T` is `UInt32` or `UInt64`
  - `long` to `UInt64`
  - `decimal` to `T` where `T` is `float` or `double`
- Any of the following conversions:
  - `T` to `string` where `T` is any numeric type
  - `T` to `char` where `T` is any numeric type
  - `string` to `T` where `T` is any numeric type
- Any of the following conversions, these conversion are considered an assignable conversions:
  - `byte` to `T` where `T` is `Int16`, `UInt16`, `int`, `UInt32`, `long`, `UInt64`, `single`,
    `double`, or `decimal`
  - `SByte` to `T` where `T` is `Int16`, `UInt16`, `int`, `UInt32`, `long`, `UInt64`, `single`,
    `double`, or `decimal`
  - `UInt16` to `T` where `T` is `int`, `UInt32`, `long`, or `UInt64`, `single`, `double`, or
    `decimal`
  - `Int16` to `T` where `T` is `int`, `UInt32`, `long`, or `UInt64`, `single`, `double`, or
    `decimal`
  - `UInt32` to `T` where `T` is `long`, or `UInt64`, `single`, `double`, or `decimal`
  - `int` to `T` where `T` is `long`, `UInt64`, `single`, `double`, or `decimal`
  - `single` to `double`
- `T~1~` to `T~2~` where `T~2~` is a base class or interface of `T~1~`. This conversion is
  considered an assignable conversion.
- `string` to `char[]`
- `T` to `T` -- This conversion is considered an assignable conversion.

For each conversion of the form `T~1~` to `T~2~[]` where `T~1~` is not an array and no other
conversion applies, if there is a conversion from `T~1~` to `T~2~`, the rank of the conversion is
worse than the conversion from `T~1~` to `T~2~`, but better than any conversion ranked less than the
conversion from `T~1~` to `T~2~`

## 3.8 Name lookup

It is possible to have commands of different kinds all having the same name. The order in which name
lookup is performed in such a case is alias, function, cmdlet, and external command.

## 3.9 Type name lookup

[§7.1.10][§7.1.10] contains the statement, "A *type-literal* is represented in an implementation by some
unspecified *underlying type*. As a result, a type name is a synonym for its underlying type."
Example of types are `int`, `double`, `long[]`, and `Hashtable`.

Type names are matched as follows: Compare a given type name with the list of built-in *type
accelerators*, such as int, long, double. If a match is found, that is the type. Otherwise, presume
the type name is fully qualified and see if such a type exists on the host system. If a match is
found, that is the type. Otherwise, add the namespace prefix `System.`. If a match is found, that is
the type. Otherwise, the type name is in error. This algorithm is applied for each type argument for
generic types. However, there is no need to specify the arity (the number of arguments or operands
taken by a function or operator).

## 3.10 Automatic memory management

Various operators and cmdlets result in the allocation of memory for reference-type objects, such as
strings and arrays. The allocation and freeing of this memory is managed by the PowerShell runtime
system. That is, PowerShell provides automatic *garbage collection*.

## 3.11 Execution order

A *side effect* is a change in the state of a command's execution environment. A change to the
value of a variable (via the assignment operators or the pre- and post-increment and decrement
operators) is a side effect, as is a change to the contents of a file.

Unless specified otherwise, statements are executed in lexical order.

Except as specified for some operators, the order of evaluation of terms in an expression and the
order in which side effects take place are both unspecified.

An expression that invokes a command involves the expression that designates the command, and zero
or more expressions that designate the arguments whose values are to be passed to that command. The
order in which these expressions are evaluated relative to each other is unspecified.

## 3.12 Error handling

When a command fails, this is considered an *error*, and information about that error is recorded in
an *error record*, whose type is unspecified ([§4.5.15][§4.5.15]); however, this type supports
subscripting.

An error falls into one of two categories. Either it terminates the operation (a *terminating
error*) or it doesn't (a *non-terminating error*). With a terminating error, the error is recorded
and the operation stops. With a non-terminating error, the error is recorded and the operation
continues.

Non-terminating errors are written to the error stream. Although that information can be redirected
to a file, the error objects are first converted to strings and important information in those
objects would not be captured making diagnosis difficult if not impossible. Instead, the error text
can be redirected ([§7.12][§7.12]) and the error object saved in a variable, as in
`$Error1 = command 2>&1`.

The automatic variable `$Error` contains a collection of error records that represent recent errors,
and the most recent error is in `$Error[0]`. This collection is maintained in a buffer such that old
records are discarded as new ones are added. The automatic variable `$MaximumErrorCount` controls
the number of records that can be stored.

`$Error` contains all of the errors from all commands mixed in together in one collection. To
collect the errors from a specific command, use the common parameter [ErrorVariable][ErrorVariable],
which allows a user-defined variable to be specified to hold the collection.

## 3.13 Pipelines

A *pipeline* is a series of one or more commands each separated by the pipe operator `|` (U+007C).
Each command receives input from its predecessor and writes output to its successor. Unless the
output at the end of the pipeline is discarded or redirected to a file, it is sent to the host
environment, which may choose to write it to standard output. Commands in a pipeline may also
receive input from arguments. For example, consider the following use of commands `Get-ChildItem`,
`Sort-Object`, and `Process-File`, which create a list of file names in a given file system
directory, sort a set of text records, and perform some processing on a text record, respectively:

```powershell
Get-ChildItem
Get-ChildItem e:*.txt | Sort-Object -CaseSensitive | Process-File >results.txt
```

In the first case, `Get-ChildItem` creates a collection of names of the files in the current/default
directory. That collection is sent to the host environment, which, by default, writes each
element's value to standard output.

In the second case, `Get-ChildItem` creates a collection of names of the files in the directory
specified, using the argument `e:*.txt`. That collection is written to the command `Sort-Object`,
which, by default, sorts them in ascending order, sensitive to case (by virtue of the
**CaseSensitive** argument). The resulting collection is then written to command `Process-File`,
which performs some (unknown) processing. The output from that command is then redirected to the
file `results.txt`.

If a command writes a single object, its successor receives that object and then terminates after
writing its own object(s) to its successor. If, however, a command writes multiple objects, they are
delivered one at a time to the successor command, which executes once per object. This behavior is
called *streaming*. In stream processing, objects are written along the pipeline as soon as they
become available, not when the entire collection has been produced.

When processing a collection, a command can be written such that it can do special processing before
the initial element and after the final element.

## 3.14 Modules

A *module* is a self-contained reusable unit that allows PowerShell code to be partitioned,
organized, and abstracted. A module can contain commands (such as cmdlets and functions) and items
(such as variables and aliases) that can be used as a single unit.

Once a module has been created, it must be *imported* into a session before the commands and items
within it can be used. Once imported, commands and items behave as if they were defined locally. A
module is imported explicitly with the `Import-Module` command. A module may also be imported
automatically as determined in an implementation defined manner.

The type of an object that represents a module is described in [§4.5.12][§4.5.12].

Modules are discussed in detail in [§11.][§11.]

## 3.15 Wildcard expressions

A wildcard expression may contain zero or more of the following elements:

<table>
<thead>
<tr class="header">
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Character other than *, ?, or [</td>
<td>Matches that one character</td>
</tr>
<tr class="even">
<td>*</td>
<td>Matches zero or more characters. To match a * character, use [*].</td>
</tr>
<tr class="odd">
<td>?</td>
<td>Matches any one character. To match a ? character, use [?].</td>
</tr>
<tr class="even">
<td>[<em>set</em>]</td>
<td><p>Matches any one character from <em>set</em>, which cannot be empty.</p>
<p>If <em>set</em> begins with ], that right square bracket is considered part of <em>set</em> and the next right square bracket terminates the set; otherwise, the first right square bracket terminates the set.</p>
<p>If <em>set</em> begins or ends with -, that hyphen-minus is considered part of <em>set</em>; otherwise, it indicates a range of consecutive Unicode code points with the characters either side of the hyphen-minus being the inclusive range delimiters. For example, A-Z indicates the 26 uppercase English letters, and 0-9 indicates the 10 decimal digits.</p></td>
</tr>
</tbody>
</table>

> [!NOTE]
> More information can be found in,
> [The Open Group Base Specifications: Pattern Matching", IEEE Std 1003.1, 2004 Edition.](http://www.opengroup.org/onlinepubs/000095399/utilities/xcu_chap02.html#tag_02_13_01).
> However, in PowerShell, the escape character is backtick, not backslash.

## 3.16 Regular expressions

A regular expression may contain zero or more of the following elements:

<table>
<thead>
<tr class="header">
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Character other than ., [, ^, *, $, or \</td>
<td>Matches that one character</td>
</tr>
<tr class="even">
<td>.</td>
<td>Matches any one character. To match a . character, use \..</td>
</tr>
<tr class="odd">
<td>[<em>set</em>]<br />
[^<em>set</em>]</td>
<td><p>The [<em>set</em>] form matches any one character from <em>set</em>. The [^<em>set</em>] form matches no characters from <em>set</em>. <em>set</em> cannot be empty.</p>
<p>If <em>set</em> begins with ] or ^], that right square bracket is considered part of <em>set</em> and the next right square bracket terminates the set; otherwise, the first right square bracket terminates the set.</p>
<p>If <em>set</em> begins with - or ^-, or ends with -, that hyphen-minus is considered part of <em>set</em>; otherwise, it indicates a range of consecutive Unicode code points with the characters either side of the hyphen-minus being the inclusive range delimiters. For example, A-Z indicates the 26 uppercase English letters, and 0-9 indicates the 10 decimal digits.</p></td>
</tr>
<tr class="even">
<td>*</td>
<td>Matches zero of more occurrences of the preceding element.</td>
</tr>
<tr class="odd">
<td>+</td>
<td>Matches one of more occurrences of the preceding element.</td>
</tr>
<tr class="even">
<td>?</td>
<td>Matches zero of one occurrences of the preceding element.</td>
</tr>
<tr class="odd">
<td>^</td>
<td>Matches at the start of the string. To match a ^ character, use \^.</td>
</tr>
<tr class="even">
<td>$</td>
<td>Matches at the end of the string. To match a $ character, use $.</td>
</tr>
<tr class="odd">
<td>\<em>c</em></td>
<td>Escapes character <em>c</em>, so it isn't recognized as a regular expression element.</td>
</tr>
</tbody>
</table>

> [!NOTE]
> More information can be found in,
> [The Open Group Base Specifications: Regular Expressions, IEEE Std 1003.1, 2004 Edition.](http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap09.html).

Windows PowerShell: Character classes available in Microsoft .NET Framework regular expressions are
supported, as follows:

|  Element   |                                                                                                            Description                                                                                                             |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `\p{name}` | Matches any character in the named character class specified by *name*. Supported names are Unicode groups and block ranges such as Ll, Nd, Z, IsGreek, and IsBoxDrawing.                                                          |
| `\P{name}` | Matches text not included in the groups and block ranges specified in *name*.                                                                                                                                                      |
| `\w`       | Matches any word character. Equivalent to the Unicode character categories `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}]`. If ECMAScript-compliant behavior is specified with the ECMAScript option, \w is equivalent to `[a-zA-Z_0-9]`. |
| `\W`       | Matches any non-word character. Equivalent to the Unicode categories `[\^\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}]`.                                                                                                                   |
| `\s`       | Matches any white space character. Equivalent to the Unicode character categories` [\f\n\r\t\v\x85\p{Z}]`.                                                                                                                         |
| `\S`       | Matches any non-white-space character. Equivalent to the Unicode character categories `[\^\f\n\r\t\v\x85\p{Z}]`.                                                                                                                   |
| `\d`       | Matches any decimal digit. Equivalent to `\p{Nd}` for Unicode and `[0-9]` for non-Unicode behavior.                                                                                                                                |
| `\D`       | Matches any non-digit. Equivalent to `\P{Nd}` for Unicode and `[\^0-9]` for non-Unicode behavior.                                                                                                                                  |

Quantifiers available in Microsoft .NET Framework regular expressions are supported, as follows:

| Element |                                      Description                                      |
| ------- | ------------------------------------------------------------------------------------- |
| `*`     | Specifies zero or more matches; for example, `\w* `or `(abc)*.` Equivalent to `{0,}`. |
| `+`     | Matches repeating instances of the preceding characters.                              |
| `?`     | Specifies zero or one matches; for example, `\w?` or `(abc)?`. Equivalent to `{0,1}`. |
| `{n}`   | Specifies exactly *n* matches; for example, `(pizza){2}`.                             |
| `{n,}`  | Specifies at least *n* matches; for example, `(abc){2,}`.                             |
| `{n,m}` | Specifies at least *n*, but no more than *m*, matches.                                |

<!-- reference links -->
[§11.]: chapter-11.md#11-modules
[§3.1.1]: chapter-03.md#311-aliases
[§3.1.2]: chapter-03.md#312-environment-variables
[§3.1.3]: chapter-03.md#313-file-system
[§3.1.4]: chapter-03.md#314-functions
[§3.1.5]: chapter-03.md#315-variables
[§3.1]: chapter-03.md#31-providers-and-drives
[§3.14]: chapter-03.md#314-modules
[§3.3]: chapter-03.md#33-items
[§3.4]: chapter-03.md#34-path-names
[§3.5.3]: chapter-03.md#353-variable-name-scope
[§3.5.5]: chapter-03.md#355-dot-source-notation
[§3.7.3]: chapter-03.md#373-applicable-method
[§3.7.4]: chapter-03.md#374-better-method
[§4.3.2]: chapter-04.md#432-arrays
[§4.3.6]: chapter-04.md#436-the-ref-type
[§4.3.8]: chapter-04.md#438-the-math-type
[§4.5.1]: chapter-04.md#451-provider-description-type
[§4.5.10]: chapter-04.md#4510-function-description-type
[§4.5.11]: chapter-04.md#4511-filter-description-type
[§4.5.12]: chapter-04.md#4512-module-description-type
[§4.5.15]: chapter-04.md#4515-error-record-description-type
[§4.5.17]: chapter-04.md#4517-directory-description-type
[§4.5.18]: chapter-04.md#4518-file-description-type
[§4.5.2]: chapter-04.md#452-drive-description-type
[§4.5.3]: chapter-04.md#453-variable-description-type
[§4.5.4]: chapter-04.md#454-alias-description-type
[§4.5.5]: chapter-04.md#455-working-location-description-type
[§4.5.6]: chapter-04.md#456-environment-variable-description-type
[§7.1.10]: chapter-07.md#7110-type-literal-expression
[§7.1.3]: chapter-07.md#713-invocation-expressions
[§7.12]: chapter-07.md#712-redirection-operators
[§8.10.1]: chapter-08.md#8101-filter-functions
[§8.10]: chapter-08.md#810-function-definitions
[ErrorVariable]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_commonparameters

# /./lang-spec/chapter-04.md - Types

    ---
    description: In PowerShell, each value has a type, and types fall into one of two main categories - value types and reference types.
    ms.date: 05/26/2023
    title: Types
    ---
# 4. Types

In PowerShell, each value has a type, and types fall into one of two main categories: **value types**
and **reference types**. Consider the type `int`, which is typical of value types. A value of type
`int` is completely self-contained; all the bits needed to represent that value are stored in that
value, and every bit pattern in that value represents a valid value for its type. Now, consider the
array type `int[]`, which is typical of reference types. A so-called value of an array type can hold
either a reference to an object that actually contains the array elements, or the **null reference**
whose value is `$null`. The important distinction between the two type categories is best
demonstrated by the differences in their semantics during assignment. For example,

```powershell
$i = 100 # $i designates an int value 100
$j = $i # $j designates an int value 100, which is a copy

$a = 10,20,30 # $a designates an object[], Length 3, value 10,20,30
$b = $a # $b designates exactly the same array as does $a, not a copy
$a[1] = 50 # element 1 (which has a value type) is changed from 20 to 50
$b[1] # $b refers to the same array as $a, so $b[1] is 50
```

As we can see, the assignment of a reference type value involves a **shallow copy**; that is, a copy
of the reference to the object rather than its actual value. In contrast, a **deep copy** requires
making a copy of the object as well.

A **numeric** type is one that allows representation of integer or fractional values, and that
supports arithmetic operations on those values. The set of numerical types includes the integer
([§4.2.3][§4.2.3]) and real number ([§4.2.4][§4.2.4]) types, but does not include bool
([§4.2.1][§4.2.1]) or char ([§4.2.2][§4.2.2]). An implementation may provide other numeric types
(such as signed byte, unsigned integer, and integers of other sizes).

A **collection** is a group of one or more related items, which need not have the same type.
Examples of collection types are arrays, stacks, queues, lists, and hash tables. A program can
_enumerate_ (or _iterate_) over the elements in a collection, getting access to each element one at
a time. Common ways to do this are with the foreach statement ([§8.4.4][§8.4.4]) and the
[ForEach-Object](xref:Microsoft.PowerShell.Core.ForEach-Object) cmdlet. The type of an object that
represents an enumerator is described in [§4.5.16][§4.5.16].

In this chapter, there are tables that list the accessible members for a given type. For methods,
the **Type** is written with the following form: _returnType_/_argumentTypeList_. If the argument
type list is too long to fit in that column, it is shown in the **Purpose** column instead.

Other integer types are `SByte`, `Int16`, `UInt16`, `UInt32`, and `UInt64`, all in the namespace
**System**.

Many collection classes are defined as part of the **System.Collections** or
**System.Collections.Generic** namespaces. Most collection classes implement the interfaces
`ICollection`, `IComparer`, `IEnumerable`, `IList`, `IDictionary`, and `IDictionaryEnumerator` and
their generic equivalents.

You can also use shorthand names for some types. For more information, see
[about_Type_Accelerators](/powershell/module/microsoft.powershell.core/about/about_type_accelerators).

## 4.1 Special types

### 4.1.1 The void type

This type cannot be instantiated. It provides a means to discard a value explicitly using the cast
operator ([§7.2.9][§7.2.9]).

### 4.1.2 The null type

The _null type_ has one instance, the automatic variable $null ([§2.3.2.2][§2.3.2.2]), also known as
the null value. This value provides a means for expressing "nothingness" in reference contexts. The
characteristics of this type are unspecified.

### 4.1.3 The object type

Every type in PowerShell except the null type ([§4.1.2][§4.1.2]) is derived directly or indirectly
from the type object, so object is the ultimate base type of all non-null types. A variable
constrained ([§5.3][§5.3]) to type object is really not constrained at all, as it can contain a
value of any type.

## 4.2 Value types

### 4.2.1 Boolean

The Boolean type is `bool`. There are only two values of this type, **False** and **True**,
represented by the automatic variables `$false` and `$true`, respectively ([§2.3.2.2][§2.3.2.2]).

In PowerShell, `bool` maps to `System.Boolean`.

### 4.2.2 Character

A character value has type char, which is capable of storing any UTF-16-encoded 16-bit Unicode code
point.

The type char has the following accessible members:

|   **Member**    |       **Member Kind**       |  **Type**   |                          **Purpose**                           |
| --------------- | --------------------------- | ----------- | -------------------------------------------------------------- |
| MaxValue        | Static property (read-only) | char        | The largest possible value of type char                        |
| MinValue        | Static property (read-only) | char        | The smallest possible value of type char                       |
| IsControl       | Static method               | bool/char   | Tests if the character is a control character                  |
| IsDigit         | Static method               | bool/char   | Tests if the character is a decimal digit                      |
| IsLetter        | Static method               | bool/char   | Tests if the character is an alphabetic letter                 |
| IsLetterOrDigit | Static method               | bool/char   | Tests if the character is a decimal digit or alphabetic letter |
| IsLower         | Static method               | bool/char   | Tests if the character is a lowercase alphabetic letter        |
| IsPunctuation   | Static method               | bool/char   | Tests if the character is a punctuation mark                   |
| IsUpper         | Static method               | bool/char   | Tests if the character is an uppercase alphabetic letter       |
| IsWhiteSpace    | Static method               | bool/char   | Tests if the character is a white space character.             |
| ToLower         | Static method               | char/string | Converts the character to lowercase                            |
| ToUpper         | Static method               | char/string | Converts the character to uppercase                            |

Windows PowerShell: char maps to System.Char.

### 4.2.3 Integer

There are two signed integer types, both of use two's-complement
representation for negative values:

- Type `int`, which uses 32 bits giving it a range of -2147483648 to +2147483647, inclusive.
- Type `long`, which uses 64 bits giving it a range of -9223372036854775808 to +9223372036854775807,
  inclusive.

Type int has the following accessible members:

| **Member** |       **Member Kind**       | **Type** |               **Purpose**               |
| ---------- | --------------------------- | -------- | --------------------------------------- |
| MaxValue   | Static property (read-only) | int      | The largest possible value of type int  |
| MinValue   | Static property (read-only) | int      | The smallest possible value of type int |

Type long has the following accessible members:

| **Member** |       **Member Kind**       | **Type** |               **Purpose**                |
| ---------- | --------------------------- | -------- | ---------------------------------------- |
| MaxValue   | Static property (read-only) | long     | The largest possible value of type long  |
| MinValue   | Static property (read-only) | long     | The smallest possible value of type long |

There is one unsigned integer type:

- Type `byte`, which uses 8 bits giving it a range of 0 to 255, inclusive.

Type `byte` has the following accessible members:

| **Member** |       **Member Kind**       | **Type** |               **Purpose**                |
| ---------- | --------------------------- | -------- | ---------------------------------------- |
| MaxValue   | Static property (read-only) | byte     | The largest possible value of type byte  |
| MinValue   | Static property (read-only) | byte     | The smallest possible value of type byte |

In PowerShell, `byte`, `int`, and `long` map to `System.Byte`, `System.Int32`, and `System.Int64`,
respectively.

### 4.2.4 Real number

#### 4.2.4.1 float and double

There are two real (or floating-point) types:

- Type `float` uses the 32-bit IEEE single-precision representation.
- Type `double` uses the 64-bit IEEE double-precision representation.

A third type name, `single`, is a synonym for type `float`; `float` is used throughout this
specification.

Although the size and representation of the types `float` and `double` are defined by this
specification, an implementation may use extended precision for intermediate results.

Type float has the following accessible members:

|    **Member**    |       **Member Kind**       | **Type** |                **Purpose**                |
| ---------------- | --------------------------- | -------- | ----------------------------------------- |
| MaxValue         | Static property (read-only) | float    | The largest possible value of type float  |
| MinValue         | Static property (read-only) | float    | The smallest possible value of type float |
| NaN              | Static property (read-only) | float    | The constant value Not-a-Number           |
| NegativeInfinity | Static property (read-only) | float    | The constant value negative infinity      |
| PositiveInfinity | Static property (read-only) | float    | The constant value positive infinity      |

Type double has the following accessible members:

|    **Member**    |       **Member Kind**       | **Type** |                **Purpose**                 |
| ---------------- | --------------------------- | -------- | ------------------------------------------ |
| MaxValue         | Static property (read-only) | double   | The largest possible value of type double  |
| MinValue         | Static property (read-only) | double   | The smallest possible value of type double |
| NaN              | Static property (read-only) | double   | The constant value Not-a-Number            |
| NegativeInfinity | Static property (read-only) | double   | The constant value negative infinity       |
| PositiveInfinity | Static property (read-only) | double   | The constant value positive infinity       |

In PowerShell, `float` and `double` map to `System.Single` and `System.Double`, respectively.

#### 4.2.4.2 decimal

Type decimal uses a 128-bit representation. At a minimum it must support a scale **s** such that 0
<= _s_ <= at least 28, and a value range -79228162514264337593543950335 to
79228162514264337593543950335. The actual representation of decimal is implementation defined.

Type decimal has the following accessible members:

| **Member** |       **Member Kind**       | **Type** |                 **Purpose**                 |
| ---------- | --------------------------- | -------- | ------------------------------------------- |
| MaxValue   | Static property (read-only) | decimal  | The largest possible value of type decimal  |
| MinValue   | Static property (read-only) | decimal  | The smallest possible value of type decimal |

> [!NOTE]
> Decimal real numbers have a characteristic called _scale_,  which represents the number of digits
> to the right of the decimal point. For example, the value 2.340 has a scale of 3 where trailing
> zeros are significant. When two decimal real numbers are added or subtracted, the scale of the
> result is the larger of the two scales. For example, 1.0 + 2.000 is 3.000, while 5.0 - 2.00 is
> 3.00. When two decimal real numbers are multiplied, the scale of the result is the sum of the two
> scales. For example, 1.0 * 2.000 is 2.0000. When two decimal real numbers are divided, the scale
> of the result is the scale of the first less the scale of the second. For example, 4.00000/2.000
> is 2.00. However, a scale cannot be less than that needed to preserve the correct result. For
> example, 3.000/2.000, 3.00/2.000, 3.0/2.000, and 3/2 are all 1.5.

In PowerShell, `decimal` maps to `System.Decimal`. The representation of decimal is as follows:

- When considered as an array of four `int` values it contains the following elements:
  - Index 0 (bits 0‑31) contains the low-order 32 bits of the decimal's coefficient.
  - Index 1 (bits 32‑63) contains the middle 32 bits of the decimal's coefficient.
  - Index 2 (bits 64‑95) contains the high-order 32 bits of the decimal's coefficient.
  - Index 3 (bits 96‑127) contains the sign bit and scale, as follows:
    - bits 0--15 are zero
    - bits 16‑23 contains the scale as a value 0--28
    - bits 24‑30 are zero
    - bit 31 is the sign (0 for positive, 1 for negative)

### 4.2.5 The switch type

This type is used to constrain the type of a parameter in a command ([§8.10.5][§8.10.5]). If an
argument having the corresponding parameter name is present the parameter tests $true; otherwise, it
tests `$false`.

In PowerShell, `switch` maps to `System.Management.Automation.SwitchParameter`.

### 4.2.6 Enumeration types

An enumeration type is one that defines a set of named constants representing all the possible
values that can be assigned to an object of that enumeration type. In some cases, the set of values
are such that only one value can be represented at a time. In other cases, the set of values are
distinct powers of two, and by using the -bor operator ([§7.8.5][§7.8.5]), multiple values can be
encoded in the same object.

The PowerShell environment provides a number of enumeration types, as described in the following
sections.

#### 4.2.6.1 Action-Preference type

This implementation-defined type has the following mutually
exclusive-valued accessible members:

|    **Member**    |   **Member Kind**    |                                               **Purpose**                                               |
| ---------------- | -------------------- | ------------------------------------------------------------------------------------------------------- |
| Continue         | Enumeration constant | The PowerShell runtime will continue processing and notify the user that an action has occurred.        |
| Inquire          | Enumeration constant | The PowerShell runtime will stop processing and ask the user how it should proceed.                     |
| SilentlyContinue | Enumeration constant | The PowerShell runtime will continue processing without notifying the user that an action has occurred. |
| Stop             | Enumeration constant | The PowerShell runtime will stop processing when an action occurs.                                      |

In PowerShell, this type is `System.Management.Automation.ActionPreference`.

#### 4.2.6.2 Confirm-Impact type

This implementation-defined type has the following mutually exclusive-valued accessible members:

| **Member** |   **Member Kind**    |                                      **Purpose**                                       |
| ---------- | -------------------- | -------------------------------------------------------------------------------------- |
| High       | Enumeration constant | The action performed has a high risk of losing data, such as reformatting a hard disk. |
| Low        | Enumeration constant | The action performed has a low risk of losing data.                                    |
| Medium     | Enumeration constant | The action performed has a medium risk of losing data.                                 |
| None       | Enumeration constant | Do not confirm any actions (suppress all requests for confirmation).                   |

In PowerShell, this type is `System.Management.Automation.ConfirmImpact`.

#### 4.2.6.3 File-Attributes type

This implementation-defined type has the following accessible members, which can be combined:

|    **Member**     |   **Member Kind**    |                                                                                                                  **Purpose**                                                                                                                  |
| ----------------- | -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Archive           | Enumeration constant | The file's archive status. Applications use this attribute to mark files for backup or removal.                                                                                                                                               |
| Compressed        | Enumeration constant | The file is compressed.                                                                                                                                                                                                                       |
| Device            |                      | Reserved for future use.                                                                                                                                                                                                                      |
| Directory         | Enumeration constant | The file is a directory.                                                                                                                                                                                                                      |
| Encrypted         | Enumeration constant | The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this means that encryption is the default for newly created files and directories.                                        |
| Hidden            | Enumeration constant | The file is hidden, and thus is not included in an ordinary directory listing.                                                                                                                                                                |
| Normal            | Enumeration constant | The file is normal and has no other attributes set. This attribute is valid only if used alone.                                                                                                                                               |
| NotContentIndexed | Enumeration constant | The file will not be indexed by the operating system's content indexing service.                                                                                                                                                              |
| Offline           | Enumeration constant | The file is offline. The data of the file is not immediately available.                                                                                                                                                                       |
| ReadOnly          | Enumeration constant | The file is read-only.                                                                                                                                                                                                                        |
| ReparsePoint      | Enumeration constant | The file contains a reparse point, which is a block of user-defined data associated with a file or a directory.                                                                                                                               |
| SparseFile        | Enumeration constant | The file is a sparse file. Sparse files are typically large files whose data are mostly zeros.                                                                                                                                                |
| System            | Enumeration constant | The file is a system file. The file is part of the operating system or is used exclusively by the operating system.                                                                                                                           |
| Temporary         | Enumeration constant | The file is temporary. File systems attempt to keep all of the data in memory for quicker access rather than flushing the data back to mass storage. A temporary file should be deleted by the application as soon as it is no longer needed. |

In PowerShell, this type is System.IO.FileAttributes with attribute
FlagsAttribute.

#### 4.2.6.4 Regular-Expression-Option type

This implementation-defined type has the following accessible members, which can be combined:

| **Member** |   **Member Kind**    |                   **Purpose**                    |
| ---------- | -------------------- | ------------------------------------------------ |
| IgnoreCase | Enumeration constant | Specifies that the matching is case-insensitive. |
| None       | Enumeration constant | Specifies that no options are set.               |

An implementation may provide other values.

In PowerShell, this type is `System.Text.RegularExpressions.RegexOptions` with attribute
`FlagsAttribute`. The following extra values are defined: `Compiled`, `CultureInvariant`,
`ECMAScript`, `ExplicitCapture`, `IgnorePatternWhitespace`, `Multiline`, `RightToLeft`,
`Singleline`.

## 4.3 Reference types

### 4.3.1 Strings

A string value has type string and is an immutable sequence of zero or more characters of type char
each containing a UTF-16-encoded 16-bit Unicode code point.

Type string has the following accessible members:

| **Member** |  **Member Kind**  |    **Type**     |                         **Purpose**                         |
| ---------- | ----------------- | --------------- | ----------------------------------------------------------- |
| Length     | Instance Property | int (read-only) | Gets the number of characters in the string                 |
| ToLower    | Instance Method   | string          | Creates a new string that contains the lowercase equivalent |
| ToUpper    | Instance Method   | string          | Creates a new string that contains the uppercase equivalent |

In PowerShell, `string` maps to `System.String`.

### 4.3.2 Arrays

All array types are derived from the type `Array`. This type has the following accessible members:

<table>
<thead>
<tr class="header">
<th><strong>Member</strong></th>
<th><strong>Member Kind</strong></th>
<th><strong>Type</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Length</td>
<td>Instance Property (read-only)</td>
<td>int</td>
<td>Number of elements in the array</td>
</tr>
<tr class="even">
<td>Rank</td>
<td>Instance Property (read-only)</td>
<td>int</td>
<td>Number of dimensions in the array</td>
</tr>
<tr class="odd">
<td>Copy</td>
<td>Static Method</td>
<td>void/see Purpose column</td>
<td><p>Copies a range of elements from one array to another. There are four versions, where <em>source</em> is the source array, <em>destination</em> is the destination array, <em>count</em> is the number of elements to copy, and <em>sourceIndex</em> and <em>destinationIndex</em> are the starting locations in their respective arrays:</p>
<p>Copy(<em>source</em>, <em>destination</em>, int <em>count</em>)<br />
Copy(<em>source</em>, <em>destination</em>, long <em>count</em>)<br />
Copy(<em>source</em>, <em>sourceIndex</em>, <em>destination</em>, <em>destinationIndex</em>, int <em>count</em>)<br />
Copy(<em>source</em>, <em>sourceIndex</em>, <em>destination</em>, <em>destinationIndex</em>, long <em>count</em>)</p></td>
</tr>
<tr class="even">
<td>GetLength</td>
<td>Instance Method (read-only)</td>
<td>int/none</td>
<td><p>Number of elements in a given dimension</p>
<p>GetLength(int <em>dimension</em>)</p></td>
</tr>
</tbody>
</table>

For more details on arrays, see [§9.][§9.]

In PowerShell, `Array` maps to `System.Array`.

### 4.3.3 Hashtables

Type Hashtable has the following accessible members:

| **Member** |  **Member Kind**  |        **Type**        |                     **Purpose**                     |
| ---------- | ----------------- | ---------------------- | --------------------------------------------------- |
| Count      | Instance Property | int                    | Gets the number of key/value pairs in the Hashtable |
| Keys       | Instance Property | Implementation-defined | Gets a collection of all the keys                   |
| Values     | Instance Property | Implementation-defined | Gets a collection of all the values                 |
| Remove     | Instance Method   | void/none              | Removes the designated key/value                    |

For more details on Hashtables, see §10.

In PowerShell, `Hashtable` maps to `System.Collections.Hashtable`. `Hashtable` elements are stored
in an object of type `DictionaryEntry`, and the collections returned by Keys and Values have type
`ICollection`.

### 4.3.4 The xml type

Type xml implements the W3C Document Object Model (DOM) Level 1 Core and the Core DOM Level 2. The
DOM is an in-memory (cache) tree representation of an XML document and enables the navigation and
editing of this document. This type supports the subscript operator [] ([§7.1.4.4][§7.1.4.4]).

In PowerShell, `xml` maps to `System.Xml.XmlDocument`.

### 4.3.5 The regex type

Type `regex` provides machinery for supporting regular expression processing. It is used to
constrain the type of a parameter ([§5.3][§5.3]) whose corresponding argument might contain a
regular expression.

In PowerShell, `regex` maps to `System.Text.RegularExpressions.Regex`.

### 4.3.6 The ref type

Ordinarily, arguments are passed to commands by value. In the case of an argument having some value
type a copy of the value is passed. In the case of an argument having some reference type a copy of
the reference is passed.

Type ref provides machinery to allow arguments to be passed to commands by reference, so the
commands can modify the argument's value. Type ref has the following accessible members:

| **Member** |        **Member Kind**         |                **Type**                 |              **Purpose**              |
| ---------- | ------------------------------ | --------------------------------------- | ------------------------------------- |
| Value      | Instance property (read-write) | The type of the value being referenced. | Gets/sets the value being referenced. |

Consider the following function definition and call:

```powershell
function Doubler {
    param ([ref]$x) # parameter received by reference
    $x.Value *= 2.0 # note that 2.0 has type double
}

$number = 8 # designates a value of type int, value 8
Doubler([ref]$number) # argument received by reference
$number # designates a value of type double, value 8.0
```

Consider the case in which $number is type-constrained:

```powershell
[int]$number = 8 # designates a value of type int, value 8
Doubler([ref]$number) # argument received by reference
$number # designates a value of type int, value 8
```

As shown, both the argument and its corresponding parameter must be declared `ref`.

In PowerShell, `ref` maps to `System.Management.Automation.PSReference`.

### 4.3.7 The scriptblock type

Type `scriptblock` represents a precompiled block of script text ([§7.1.8][§7.1.8]) that can be used
as a single unit. It has the following accessible members:

<table>
<thead>
<tr class="header">
<th><strong>Member</strong></th>
<th><strong>Member Kind</strong></th>
<th><strong>Type</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Attributes</td>
<td>Instance property (read-only)</td>
<td>Collection of attributes</td>
<td>Gets the attributes of the script block.</td>
</tr>
<tr class="even">
<td>File</td>
<td>Instance property (read-only)</td>
<td>string</td>
<td>Gets the name of the file in which the script block is defined.</td>
</tr>
<tr class="odd">
<td>Module</td>
<td>Instance property (read-only)</td>
<td>implementation defined ([§4.5.12][§4.5.12])</td>
<td>Gets information about the module in which the script block is defined.</td>
</tr>
<tr class="even">
<td>GetNewClosure</td>
<td>Instance method</td>
<td>scriptblock<br />
/none</td>
<td>Retrieves a script block that is bound to a module. Any local variables that are in the context of the caller will be copied into the module.</td>
</tr>
<tr class="odd">
<td>Invoke</td>
<td>Instance method</td>
<td>Collection of object/object[]</td>
<td>Invokes the script block with the specified arguments and returns the results.</td>
</tr>
<tr class="even">
<td>InvokeReturnAsIs</td>
<td>Instance method</td>
<td>object/object[]</td>
<td>Invokes the script block with the specified arguments and returns any objects generated.</td>
</tr>
<tr class="odd">
<td>Create</td>
<td>Static method</td>
<td>scriptblock<br />
/string</td>
<td>Creates a new scriptblock object that contains the specified script.</td>
</tr>
</tbody>
</table>

In PowerShell, `scriptblock` maps to `System.Management.Automation.ScriptBlock`. `Invoke` returns a
collection of `PSObject`.

### 4.3.8 The math type

Type `math` provides access to some constants and methods useful in mathematical computations. It
has the following accessible members:

<table>
<thead>
<tr class="header">
<th><strong>Member</strong></th>
<th><strong>Member Kind</strong></th>
<th><strong>Type</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E</td>
<td>Static property (read-only)</td>
<td>double</td>
<td>Natural logarithmic base</td>
</tr>
<tr class="even">
<td>PI</td>
<td>Static property (read-only)</td>
<td>double</td>
<td>Ratio of the circumference of a circle to its diameter</td>
</tr>
<tr class="odd">
<td>Abs</td>
<td>Static method</td>
<td>numeric/numeric</td>
<td>Absolute value (the return type is the same as the type of the argument passed in)</td>
</tr>
<tr class="even">
<td>Acos</td>
<td>Static method</td>
<td>double / double</td>
<td>Angle whose cosine is the specified number</td>
</tr>
<tr class="odd">
<td>Asin</td>
<td>Static method</td>
<td>double / double</td>
<td>Angle whose sine is the specified number</td>
</tr>
<tr class="even">
<td>Atan</td>
<td>Static method</td>
<td>double / double</td>
<td>Angle whose tangent is the specified number</td>
</tr>
<tr class="odd">
<td>Atan2</td>
<td>Static method</td>
<td>double / double <em>y</em>, double <em>x</em></td>
<td>Angle whose tangent is the quotient of two specified numbers <em>x</em> and <em>y</em></td>
</tr>
<tr class="even">
<td>Ceiling</td>
<td>Static method</td>
<td><p>decimal / decimal</p>
<p>double / double</p></td>
<td>smallest integer greater than or equal to the specified number</td>
</tr>
<tr class="odd">
<td>Cos</td>
<td>Static method</td>
<td>double / double</td>
<td>Cosine of the specified angle</td>
</tr>
<tr class="even">
<td>Cosh</td>
<td>Static method</td>
<td>double / double</td>
<td>Hyperbolic cosine of the specified angle</td>
</tr>
<tr class="odd">
<td>Exp</td>
<td>Static method</td>
<td>double / double</td>
<td>e raised to the specified power</td>
</tr>
<tr class="even">
<td>Floor</td>
<td>Static method</td>
<td><p>decimal / decimal</p>
<p>double / double</p></td>
<td>Largest integer less than or equal to the specified number</td>
</tr>
<tr class="odd">
<td>Log</td>
<td>Static method</td>
<td><p>double / double <em>number</em></p>
<p>double / double <em>number</em>, double <em>base</em></p></td>
<td>Logarithm of number using base e or base <em>base</em></td>
</tr>
<tr class="even">
<td>Log10</td>
<td>Static method</td>
<td>double / double</td>
<td>Base-10 logarithm of a specified number</td>
</tr>
<tr class="odd">
<td>Max</td>
<td>Static method</td>
<td>numeric/numeric</td>
<td>Larger of two specified numbers (the return type is the same as the type of the arguments passed in)</td>
</tr>
<tr class="even">
<td>Min</td>
<td>Static method</td>
<td>numeric/numeric, numeric</td>
<td>Smaller of two specified numbers (the return type is the same as the type of the arguments passed in)</td>
</tr>
<tr class="odd">
<td>Pow</td>
<td>Static method</td>
<td>double / double <em>x</em>, double <em>y</em></td>
<td>A specified number <em>x</em> raised to the specified power <em>y</em></td>
</tr>
<tr class="even">
<td>Sin</td>
<td>Static method</td>
<td>double / double</td>
<td>Sine of the specified angle</td>
</tr>
<tr class="odd">
<td>Sinh</td>
<td>Static method</td>
<td>double / double</td>
<td>Hyperbolic sine of the specified angle</td>
</tr>
<tr class="even">
<td>Sqrt</td>
<td>Static method</td>
<td>double / double</td>
<td>Square root of a specified number</td>
</tr>
<tr class="odd">
<td>Tan</td>
<td>Static method</td>
<td>double / double</td>
<td>Tangent of the specified angle</td>
</tr>
<tr class="even">
<td>Tanh</td>
<td>Static method</td>
<td>double / double</td>
<td>Hyperbolic tangent of the specified angle</td>
</tr>
</tbody>
</table>

In PowerShell, `Math` maps to `System.Math`.

### 4.3.9 The ordered type

Type `ordered` is a pseudo type used only for conversions.

### 4.3.10 The pscustomobject type

Type `pscustomobject` is a pseudo type used only for conversions.

## 4.4 Generic types

A number of programming languages and environments provide types that can be _specialized_.  Many of
these types are referred to as _container types_,  as instances of them are able to contain objects
of some other type. Consider a type called Stack that can represent a stack of values, which can be
pushed on and popped off. Typically, the user of a stack wants to store only one kind of object on
that stack. However, if the language or environment does not support type specialization, multiple
distinct variants of the type Stack must be implemented even though they all perform the same task,
just with different type elements.

Type specialization allows a _generic type_ to be implemented such that it can be constrained to
handling some subset of types when it is used. For example,

- A generic stack type that is specialized to hold strings might be written as `Stack[string]`.
- A generic dictionary type that is specialized to hold int keys with associated string values might
  be written as `Dictionary[int,string]`.
- A stack of stack of strings might be written as `Stack[Stack[string]]`.

Although PowerShell does not define any built-in generic types, it can use such types if they are
provided by the host environment. See the syntax in [§7.1.10][§7.1.10].

The complete name for the type `Stack[string]` suggested above is
`System.Collections.Generic.Stack[string]`. The complete name for the type `Dictionary[int,string]`
suggested above is `System.Collections.Generic.Dictionary[int,string]`.

## 4.5 Anonymous types

In some circumstances, an implementation of PowerShell creates objects of some type, and those
objects have members accessible to script. However, the actual name of those types need not be
specified, so long as the accessible members are specified sufficiently for them to be used. That
is, scripts can save objects of those types and access their members without actually knowing those
types' names. The following subsections specify these types.

### 4.5.1 Provider description type

This type encapsulates the state of a provider. It has the following accessible members:

| **Member** |        **Member Kind**        |              **Type**               |                **Purpose**                |
| ---------- | ----------------------------- | ----------------------------------- | ----------------------------------------- |
| Drives     | Instance property (read-only) | Implementation defined ([§4.5.2][§4.5.2]) | A collection of drive description objects |
| Name       | Instance property (read-only) | string                              | The name of the provider                  |

In PowerShell, this type is `System.Management.Automation.ProviderInfo`.

### 4.5.2 Drive description type

This type encapsulates the state of a drive. It has the following accessible members:

|   **Member**    |        **Member Kind**         | **Type** |                      **Purpose**                       |
| --------------- | ------------------------------ | -------- | ------------------------------------------------------ |
| CurrentLocation | Instance property (read-write) | string   | The current working location ([§3.1.4][§3.1.4]) of the drive |
| Description     | Instance property (read-write) | string   | The description of the drive                           |
| Name            | Instance property (read-only)  | string   | The name of the drive                                  |
| Root            | Instance property (read-only)  | string   | The name of the drive                                  |

In PowerShell, this type is `System.Management.Automation.PSDriveInfo`.

### 4.5.3 Variable description type

This type encapsulates the state of a variable. It has the following accessible members:

| **Member**  |        **Member Kind**         |               **Type**               |                                                                                        **Purpose**                                                                                         |
| ----------- | ------------------------------ | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Attributes  | Instance property (read-only)  | Implementation defined               | A collection of attributes                                                                                                                                                                 |
| Description | Instance property (read-write) | string                               | The description assigned to the variable via the [New-Variable](xref:Microsoft.PowerShell.Utility.New-Variable) or [Set-Variable](xref:Microsoft.PowerShell.Utility.Set-Variable) cmdlets. |
| Module      | Instance property (read-only)  | Implementation defined ([§4.5.12][§4.5.12]) | The module from which this variable was exported                                                                                                                                           |
| ModuleName  | Instance property (read-only)  | string                               | The module in which this variable was defined                                                                                                                                              |
| Name        | Instance property (read-only)  | string                               | The name assigned to the variable when it was created in the PowerShell language or via the `New-Variable` and `Set-Variable` cmdlets.                                                     |
| Options     | Instance property (read-write) | string                               | The options assigned to the variable via the `New-Variable` and `Set-Variable` cmdlets.                                                                                                    |
| Value       | Instance property (read-write) | object                               | The value assigned to the variable when it was assigned in the PowerShell language or via the `New-Variable` and `Set-Variable` cmdlets.                                                   |

In PowerShell, this type is `System.Management.Automation.PSVariable`.

Windows PowerShell: The type of the attribute collection is
System.Management.Automation.PSVariableAttributeCollection.

### 4.5.4 Alias description type

This type encapsulates the state of an alias. It has the following accessible members:

|    **Member**     |        **Member Kind**         |               **Type**               |                                                                                        **Purpose**                                                                                         |
| ----------------- | ------------------------------ | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| CommandType       | Instance property (read-only)  | Implementation defined               | Should compare equal with "Alias".                                                                                                                                                         |
| Definition        | Instance property (read-only)  | string                               | The command or alias to which the alias was assigned via the [New-Alias](xref:Microsoft.PowerShell.Utility.New-Alias) or [Set-Alias](xref:Microsoft.PowerShell.Utility.Set-Alias) cmdlets. |
| Description       | Instance property (read-write) | string                               | The description assigned to the alias via the `New-Alias` or `Set-Alias` cmdlets.                                                                                                          |
| Module            | Instance property (read-only)  | Implementation defined ([§4.5.12][§4.5.12]) | The module from which this alias was exported                                                                                                                                              |
| ModuleName        | Instance property (read-only)  | string                               | The module in which this alias was defined                                                                                                                                                 |
| Name              | Instance property (read-only)  | string                               | The name assigned to the alias when it was created via the `New-Alias` or `Set-Alias` cmdlets.                                                                                             |
| Options           | Instance property (read-write) | string                               | The options assigned to the alias via the New-Alias `New-Alias` or `Set-Alias` cmdlets.                                                                                                    |
| OutputType        | Instance property (read-only)  | Implementation defined collection    | Specifies the types of the values output by the command to which the alias refers.                                                                                                         |
| Parameters        | Instance property (read-only)  | Implementation defined collection    | The parameters of the command.                                                                                                                                                             |
| ParameterSets     | Instance property (read-only)  | Implementation defined collection    | Information about the parameter sets associated with the command.                                                                                                                          |
| ReferencedCommand | Instance property (read-only)  | Implementation defined               | Information about the command that is immediately referenced by this alias.                                                                                                                |
| ResolvedCommand   | Instance property (read-only)  | Implementation defined               | Information about the command to which the alias eventually resolves.                                                                                                                      |

In PowerShell, this type is `System.Management.Automation.AliasInfo`.

### 4.5.5 Working location description type

This type encapsulates the state of a working location. It has the following accessible members:

|  **Member**  |        **Member Kind**        |              **Type**               |           **Purpose**            |
| ------------ | ----------------------------- | ----------------------------------- | -------------------------------- |
| Drive        | Instance property (read-only) | Implementation defined ([§4.5.2][§4.5.2]) | A drive description object       |
| Path         | Instance property (read-only) | string                              | The working location             |
| Provider     | Instance property (read-only) | Implementation defined ([§4.5.1][§4.5.1]) | The provider                     |
| ProviderPath | Instance property (read-only) | string                              | The current path of the provider |

A stack of working locations is a collection of working location objects, as described above.

In PowerShell, a current working location is represented by an object of type
`System.Management.Automation.PathInfo`. A stack of working locations is represented by an object of
type `System.Management.Automation.PathInfoStack`, which is a collection of `PathInfo` objects.

### 4.5.6 Environment variable description type

This type encapsulates the state of an environment variable. It has the following accessible
members:

| **Member** |        **Member Kind**         | **Type** |              **Purpose**              |
| ---------- | ------------------------------ | -------- | ------------------------------------- |
| Name       | Instance property (read-write) | string   | The name of the environment variable  |
| Value      | Instance property (read-write) | string   | The value of the environment variable |

In PowerShell, this type is `System.Collections.DictionaryEntry`. The name of the variable is the
dictionary key. The value of the environment variable is the dictionary value. **Name** is an
`AliasProperty` that equates to **Key**.

### 4.5.7 Application description type

This type encapsulates the state of an application. It has the following accessible members:

|  **Member**   |        **Member Kind**         |               **Type**               |                            **Purpose**                            |
| ------------- | ------------------------------ | ------------------------------------ | ----------------------------------------------------------------- |
| CommandType   | Instance property (read-only)  | Implementation defined               | Should compare equal with "Application".                          |
| Definition    | Instance property (read-only)  | string                               | A description of the application.                                 |
| Extension     | Instance property (read-write) | string                               | The extension of the application file.                            |
| Module        | Instance property (read-only)  | Implementation defined ([§4.5.12][§4.5.12]) | The module that defines this command.                             |
| ModuleName    | Instance property (read-only)  | string                               | The name of the module that defines the command.                  |
| Name          | Instance property (read-only)  | string                               | The name of the command.                                          |
| OutputType    | Instance property (read-only)  | Implementation defined collection    | Specifies the types of the values output by the command.          |
| Parameters    | Instance property (read-only)  | Implementation defined collection    | The parameters of the command.                                    |
| ParameterSets | Instance property (read-only)  | Implementation defined collection    | Information about the parameter sets associated with the command. |
| Path          | Instance property (read-only)  | string                               | Gets the path of the application file.                            |

In PowerShell, this type is `System.Management.Automation.ApplicationInfo`.

### 4.5.8 Cmdlet description type

This type encapsulates the state of a cmdlet. It has the following accessible members:

|     **Member**      |        **Member Kind**         |               **Type**               |                                                            **Purpose**                                                            |
| ------------------- | ------------------------------ | ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------- |
| CommandType         | Instance property (read-only)  | Implementation defined               | Should compare equal with "Cmdlet".                                                                                               |
| DefaultParameterSet | Instance property (read-only)  | Implementation defined               | The default parameter set that is used if PowerShell cannot determine which parameter set to use based on the supplied arguments. |
| Definition          | Instance property (read-only)  | string                               | A description of the cmdlet.                                                                                                      |
| HelpFile            | Instance property (read-write) | string                               | The path to the Help file for the cmdlet.                                                                                         |
| ImplementingType    | Instance property (read-write) | Implementation defined               | The type that implements the cmdlet.                                                                                              |
| Module              | Instance property (read-only)  | Implementation defined ([§4.5.12][§4.5.12]) | The module that defines this cmdlet.                                                                                              |
| ModuleName          | Instance property (read-only)  | string                               | The name of the module that defines the cmdlet.                                                                                   |
| Name                | Instance property (read-only)  | string                               | The name of the cmdlet.                                                                                                           |
| Noun                | Instance property (read-only)  | string                               | The noun name of the cmdlet.                                                                                                      |
| OutputType          | Instance property (read-only)  | Implementation defined collection    | Specifies the types of the values output by the cmdlet.                                                                           |
| Parameters          | Instance property (read-only)  | Implementation defined collection    | The parameters of the cmdlet.                                                                                                     |
| ParameterSets       | Instance property (read-only)  | Implementation defined collection    | Information about the parameter sets associated with the cmdlet.                                                                  |
| Verb                | Instance property (read-only)  | string                               | The verb name of the cmdlet.                                                                                                      |
| PSSnapIn            | Instance property (read-only)  | Implementation defined               | Windows PowerShell: Information about the Windows PowerShell snap-in that is used to register the cmdlet.                         |

In PowerShell, this type is `System.Management.Automation.CmdletInfo`.

### 4.5.9 External script description type

This type encapsulates the state of an external script (one that is directly executable by
PowerShell, but is not built-in). It has the following accessible members:

|    **Member**    |        **Member Kind**        |               **Type**               |                                 **Purpose**                                  |
| ---------------- | ----------------------------- | ------------------------------------ | ---------------------------------------------------------------------------- |
| CommandType      | Instance property (read-only) | Implementation defined               | Should compare equal with "ExternalScript".                                  |
| Definition       | Instance property (read-only) | string                               | A definition of the script.                                                  |
| Module           | Instance property (read-only) | Implementation defined ([§4.5.12][§4.5.12]) | The module that defines this script.                                         |
| ModuleName       | Instance property (read-only) | string                               | The name of the module that defines the script.                              |
| Name             | Instance property (read-only) | string                               | The name of the script.                                                      |
| OriginalEncoding | Instance property (read-only) | Implementation defined               | The original encoding used to convert the characters of the script to bytes. |
| OutputType       | Instance property (read-only) | Implementation defined collection    | Specifies the types of the values output by the script.                      |
| Parameters       | Instance property (read-only) | Implementation defined collection    | The parameters of the script.                                                |
| ParameterSets    | Instance property (read-only) | Implementation defined collection    | Information about the parameter sets associated with the script.             |
| Path             | Instance property (read-only) | string                               | The path to the script file.                                                 |
| ScriptBlock      | Instance property (read-only) | scriptblock                          | The external script.                                                         |
| ScriptContents   | Instance property (read-only) | string                               | The original contents of the script.                                         |

In PowerShell, this type is `System.Management.Automation.ExternalScriptInfo`.

### 4.5.10 Function description type

This type encapsulates the state of a function. It has the following accessible members:

|     **Member**      |        **Member Kind**         |               **Type**               |                                                                                                                                                                      **Purpose**                                                                                                                                                                      |
| ------------------- | ------------------------------ | ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| CmdletBinding       | Instance property (read-only)  | bool                                 | Indicates whether the function uses the same parameter binding that compiled cmdlets use (see [§12.3.5][§12.3.5]).                                                                                                                                                                                                                                           |
| CommandType         | Instance property (read-only)  | Implementation defined               | Can be compared for equality with "Function" or "Filter" to see which of those this object represents.                                                                                                                                                                                                                                                |
| DefaultParameterSet | Instance property (read-only)  | string                               | Specifies the parameter set to use if that cannot be determined from the arguments (see [§12.3.5][§12.3.5]).                                                                                                                                                                                                                                                 |
| Definition          | Instance property (read-only)  | string                               | A string version of ScriptBlock                                                                                                                                                                                                                                                                                                                       |
| Description         | Instance property (read-write) | string                               | The description of the function.                                                                                                                                                                                                                                                                                                                      |
| Module              | Instance property (read-only)  | Implementation defined ([§4.5.12][§4.5.12]) | The module from which this function was exported                                                                                                                                                                                                                                                                                                      |
| ModuleName          | Instance property (read-only)  | string                               | The module in which this function was defined                                                                                                                                                                                                                                                                                                         |
| Name                | Instance property (read-only)  | string                               | The name of the function                                                                                                                                                                                                                                                                                                                              |
| Options             | Instance property (read-write) | Implementation defined               | The scope options for the function ([§3.5.4][§3.5.4]).                                                                                                                                                                                                                                                                                                      |
| OutputType          | Instance property (read-only)  | Implementation defined collection    | Specifies the types of the values output, in order (see [§12.3.6][§12.3.6]).                                                                                                                                                                                                                                                                                 |
| Parameters          | Instance property (read-only)  | Implementation defined collection    | Specifies the parameter names, in order. If the function acts like a cmdlet (see CmdletBinding above) the [common parameters][common parameters] are included at the end of the collection.                                                                                                                                                                            |
| ParameterSets       | Instance property (read-only)  | Implementation defined collection    | Information about the parameter sets associated with the command. For each parameter, the result shows the parameter name and type, and indicates if the parameter is mandatory, by position or a switch parameter. If the function acts like a cmdlet (see CmdletBinding above) the [common parameters][common parameters] are included at the end of the collection. |
| ScriptBlock         | Instance property (read-only)  | scriptblock ([§4.3.6][§4.3.6])             | The body of the function                                                                                                                                                                                                                                                                                                                              |

In PowerShell, this type is `System.Management.Automation.FunctionInfo`.

- `CommandType` has type `System.Management.Automation.CommandTypes`.
- `Options` has type `System.Management.Automation.ScopedItemOptions`.
- `OutputType` has type
  `System.Collections.ObjectModel.ReadOnlyCollection``1[[System.Management.Automation.PSTypeName,System.Management.Automation]]`.
- `Parameters` has type
  `System.Collections.Generic.Dictionary``2[[System.String,mscorlib],[System.Management.Automation.ParameterMetadata,System.Management.Automation]]`.
- `ParameterSets` has type
  `System.Collections.ObjectModel.ReadOnlyCollection``1[[System.Management.Automation.CommandParameterSetInfo,System.Management.Automation]]`.
- Visibility has type `System.Management.Automation.SessionStateEntryVisibility`.
- PowerShell also has a property called **Visibility**.

### 4.5.11 Filter description type

This type encapsulates the state of a filter. It has the same set of accessible members as the
function description type ([§4.5.10][§4.5.10]).

In PowerShell, this type is `System.Management.Automation.FilterInfo`. It has the same set of
properties as `System.Management.Automation.FunctionInfo` ([§4.5.11][§4.5.11]).

### 4.5.12 Module description type

This type encapsulates the state of a module. It has the following accessible members:

| **Member**  |        **Member Kind**         |        **Type**        |                     **Purpose**                      |
| ----------- | ------------------------------ | ---------------------- | ---------------------------------------------------- |
| Description | Instance property (read-write) | string                 | The description of the module (set by the manifest)  |
| ModuleType  | Instance property (read-only)  | Implementation defined | The type of the module (Manifest, Script, or Binary) |
| Name        | Instance property (read-only)  | string                 | The name of the module                               |
| Path        | Instance property (read-only)  | string                 | The module's path                                    |

In PowerShell, this type is `System.Management.Automation.PSModuleInfo`. The type of `ModuleType` is
`System.Management.Automation.ModuleType`.

### 4.5.13 Custom object description type

This type encapsulates the state of a custom object. It has no accessible members.

In PowerShell, this type is `System.Management.Automation.PSCustomObject`. The cmdlets
`Import-Module` and `New-Object` can generate an object of this type.

### 4.5.14 Command description type

The automatic variable `$PsCmdlet` is an object that represents the cmdlet or function being
executed. The type of this object is implementation defined; it has the following accessible
members:

<table>
<thead>
<tr class="header">
<th><strong>Member</strong></th>
<th><strong>Member Kind</strong></th>
<th><strong>Type</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ParameterSetName</td>
<td>Instance property (read-only)</td>
<td>string</td>
<td>Name of the current parameter set (see ParameterSetName)</td>
</tr>
<tr class="even">
<td>ShouldContinue</td>
<td>Instance method</td>
<td><p>Overloaded</p>
<p>/bool</p></td>
<td>Requests confirmation of an operation from the user.</td>
</tr>
<tr class="odd">
<td>ShouldProcess</td>
<td>Instance method</td>
<td><p>Overloaded</p>
<p>/bool</p></td>
<td>Requests confirmation from the user before an operation is performed.</td>
</tr>
</tbody>
</table>

In PowerShell, this type is System.Management.Automation.PSScriptCmdlet.

### 4.5.15 Error record description type

The automatic variable `$Error` contains a collection of error records that represent recent errors
([§3.12][§3.12]). Although the type of this collection is unspecified, it does support subscripting
to get access to individual error records.

In PowerShell, the collection type is `System.Collections.ArrayList`. The type of an individual
error record in the collection is `System.Management.Automation.ErrorRecord`. This type has the
following public properties:

- CategoryInfo - Gets information about the category of the error.
- ErrorDetails - Gets and sets more detailed error information, such as a replacement error message.
- Exception - Gets the exception that is associated with this error record.
- FullyQualifiedErrorId - Gets the fully qualified error identifier for this error record.
- InvocationInfo - Gets information about the command that was invoked when the error occurred.
- PipelineIterationInfo - Gets the status of the pipeline when this error record was created
- TargetObject - Gets the object that was being processed when the error occurred.

### 4.5.16 Enumerator description type

A number of variables are enumerators for collections (§4). The automatic variable `$foreach` is the
enumerator created for any `foreach` statement. The automatic variable `$input` is the enumerator
for a collection delivered to a function from the pipeline. The automatic variable `$switch` is the
enumerator created for any `switch` statement.

The type of an enumerator is implementation defined; it has the
following accessible members:

| **Member** |        **Member Kind**        | **Type**  |                                                                                                 **Purpose**                                                                                                  |
| ---------- | ----------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Current    | Instance property (read-only) | object    | Gets the current element in the collection. If the enumerator is not currently positioned at an element of the collection, the behavior is implementation defined.                                           |
| MoveNext   | Instance method               | None/bool | Advances the enumerator to the next element of the collection. Returns $true if the enumerator was successfully advanced to the next element; $false if the enumerator has passed the end of the collection. |

In PowerShell, these members are defined in the interface `System.IEnumerator`, which is implemented
by the types identified below. If the enumerator is not currently positioned at an element of the
collection, an exception of type `InvalidOperationException` is raised. For `$foreach`, this type is
`System.Array+SZArrayEnumerator`. For `$input`, this type is
`System.Collections.ArrayList+ArrayListEnumeratorSimple`. For `$switch`, this type is
`System.Array+SZArrayEnumerator`.

### 4.5.17 Directory description type

The cmdlet [New-Item](xref:Microsoft.PowerShell.Management.New-Item) can create items of various
kinds including FileSystem directories. The type of a directory description object is implementation
defined; it has the following accessible members:

|  **Member**   |        **Member Kind**         |               **Type**                |                             **Purpose**                             |
| ------------- | ------------------------------ | ------------------------------------- | ------------------------------------------------------------------- |
| Attributes    | Instance property (read-write) | Implementation defined ([§4.2.6.3][§4.2.6.3]) | Gets or sets one or more of the attributes of the directory object. |
| CreationTime  | Instance property (read-write) | Implementation defined ([§4.5.19][§4.5.19])  | Gets and sets the creation time of the directory object.            |
| Extension     | Instance property (read- only) | string                                | Gets the extension part of the directory name.                      |
| FullName      | Instance property (read-only)  | string                                | Gets the full path of the directory.                                |
| LastWriteTime | Instance property (read-write) | Implementation defined ([§4.5.19][§4.5.19])  | Gets and sets the time when the directory was last written to.      |
| Name          | Instance property (read- only) | string                                | Gets the name of the directory.                                     |

In PowerShell, this type is `System.IO.DirectoryInfo`. The type of the **Attributes** property is
`System.IO.FileAttributes`.

### 4.5.18 File description type

The cmdlet `New-Item` can create items of various kinds including FileSystem files. The type of a
file description object is implementation defined; it has the following accessible members:

|  **Member**   |        **Member Kind**         |               **Type**                |                                            **Purpose**                                             |
| ------------- | ------------------------------ | ------------------------------------- | -------------------------------------------------------------------------------------------------- |
| Attributes    | Instance property (read-write) | Implementation defined ([§4.2.6.3][§4.2.6.3]) | Gets or sets one or more of the attributes of the file object.                                     |
| BaseName      | Instance property (read- only) | string                                | Gets the name of the file excluding the extension.                                                 |
| CreationTime  | Instance property (read-write) | Implementation defined ([§4.5.19][§4.5.19])  | Gets and sets the creation time of the file object.                                                |
| Extension     | Instance property (read- only) | string                                | Gets the extension part of the file name.                                                          |
| FullName      | Instance property (read-only)  | string                                | Gets the full path of the file.                                                                    |
| LastWriteTime | Instance property (read-write) | Implementation defined ([§4.5.19][§4.5.19])  | Gets and sets the time when the file was last written to.                                          |
| Length        | Instance property (read- only) | long                                  | Gets the size of the file, in bytes.                                                               |
| Name          | Instance property (read- only) | string                                | Gets the name of the file.                                                                         |
| VersionInfo   | Instance property (read- only) | Implementation defined                | Windows PowerShell: This ScriptProperty returns a System.Diagnostics.FileVersionInfo for the file. |

In PowerShell, this type is `System.IO.FileInfo`.

### 4.5.19 Date-Time description type

The type of a date-time description object is implementation defined; it has the following
accessible members:

| **Member** |        **Member Kind**        | **Type** |                             **Purpose**                              |
| ---------- | ----------------------------- | -------- | -------------------------------------------------------------------- |
| Day        | Instance property (read-only) | int      | Gets the day component of the month represented by this instance.    |
| Hour       | Instance property (read-only) | int      | Gets the hour component of the date represented by this instance.    |
| Minute     | Instance property (read-only) | int      | Gets the minute component of the date represented by this instance.  |
| Month      | Instance property (read-only) | int      | Gets the month component of the date represented by this instance.   |
| Second     | Instance property (read-only) | int      | Gets the seconds component of the date represented by this instance. |
| Year       | Instance property (read-only) | int      | Gets the year component of the date represented by this instance.    |

An object of this type can be created by cmdlet [Get-Date](xref:Microsoft.PowerShell.Utility.Get-Date).

In PowerShell, this type is `System.DateTime`.

### 4.5.20 Group-Info description type

The type of a **group-info** description object is implementation defined; it has the following
accessible members:

| Member |          Member Kind          |               Type                |                    Purpose                    |
| ------ | ----------------------------- | --------------------------------- | --------------------------------------------- |
| Count  | Instance property (read-only) | int                               | Gets the number of elements in the group.     |
| Group  | Instance property (read-only) | Implementation-defined collection | Gets the elements of the group.               |
| Name   | Instance property (read-only) | string                            | Gets the name of the group.                   |
| Values | Instance property (read-only) | Implementation-defined collection | Gets the values of the elements of the group. |

An object of this type can be created by cmdlet [Group-Object](xref:Microsoft.PowerShell.Utility.Group-Object).

In PowerShell, this type is `Microsoft.PowerShell.Commands.GroupInfo`.

### 4.5.21 Generic-Measure-Info description type

The type of a **generic-measure-info** description object is implementation defined; it has the
following accessible members:

| **Member** |        **Member Kind**        | **Type** |                             **Purpose**                             |
| ---------- | ----------------------------- | -------- | ------------------------------------------------------------------- |
| Average    | Instance property (read-only) | double   | Gets the average of the values of the properties that are measured. |
| Count      | Instance property (read-only) | int      | Gets the number of objects with the specified properties.           |
| Maximum    | Instance property (read-only) | double   | Gets the maximum value of the specified properties.                 |
| Minimum    | Instance property (read-only) | double   | Gets the minimum value of the specified properties.                 |
| Property   | Instance property (read-only) | string   | Gets the property to be measured.                                   |
| Sum        | Instance property (read-only) | double   | Gets the sum of the values of the specified properties.             |

An object of this type can be created by cmdlet [Measure-Object](xref:Microsoft.PowerShell.Utility.Measure-Object).

In PowerShell, this type is `Microsoft.PowerShell.Commands.GenericMeasureInfo`.

### 4.5.22 Text-Measure-Info description type

The type of a **text-info** description object is implementation defined; it has the following
accessible members:

| **Member** |        **Member Kind**        | **Type** |                     **Purpose**                     |
| ---------- | ----------------------------- | -------- | --------------------------------------------------- |
| Characters | Instance property (read-only) | int      | Gets the number of characters in the target object. |
| Lines      | Instance property (read-only) | int      | Gets the number of lines in the target object.      |
| Property   | Instance property (read-only) | string   | Gets the property to be measured.                   |
| Words      | Instance property (read-only) | int      | Gets the number of words in the target object.      |

An object of this type can be created by cmdlet `Measure-Object`.

In PowerShell, this type is `Microsoft.PowerShell.Commands.TextMeasureInfo`.

### 4.5.23 Credential type

A credential object can then be used in various security operations. The type of a credential object
is implementation defined; it has the following accessible members:

|  Member  |          Member Kind          |          Type          |      Purpose       |
| -------- | ----------------------------- | ---------------------- | ------------------ |
| Password | Instance property (read-only) | Implementation defined | Gets the password. |
| UserName | Instance property (read-only) | string                 | Gets the username. |

An object of this type can be created by cmdlet [Get-Credential](xref:Microsoft.PowerShell.Security.Get-Credential).

In PowerShell, this type is `System.Management.Automation.PSCredential`.

### 4.5.24 Method designator type

The type of a method designator is implementation defined; it has the
following accessible members:

| **Member** | **Member Kind** |            **Type**             |                                                                 **Purpose**                                                                  |
| ---------- | --------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| Invoke     | Instance method | object/variable number and type | Takes a variable number of arguments, and indirectly calls the method referred to by the parent method designator, passing in the arguments. |

An object of this type can be created by an _invocation-expression_ ([§7.1.3][§7.1.3]).

In PowerShell, this type is System.Management.Automation.PSMethod.

### 4.5.25 Member definition type

This type encapsulates the definition of a member. It has the following accessible members:

| **Member** |        **Member Kind**        |        **Type**        |               **Purpose**               |
| ---------- | ----------------------------- | ---------------------- | --------------------------------------- |
| Definition | Instance property (read-only) | string                 | Gets the definition of the member.      |
| MemberType | Instance property (read-only) | Implementation defined | Gets the PowerShell type of the member. |
| Name       | Instance property (read-only) | string                 | Gets the name of the member.            |
| TypeName   | Instance property (read-only) | string                 | Gets the type name of the member.       |

In PowerShell, this type is `Microsoft.PowerShell.Commands.MemberDefinition`.

## 4.6 Type extension and adaptation

A PowerShell implementation includes a family of core types (which are documented in this chapter)
that each contain their own set of _base members_.  Those members can be methods or properties, and
they can be instance or static members. For example, the base members of the type string
([§4.3.1][§4.3.1]) are the instance property Length and the instance methods ToLower and ToUpper.

When an object is created, it contains all the instance properties of that object's type, and the
instance methods of that type can be called on that object. An object may be customized via the
addition of instance members at runtime. The result is called a _custom object_.  Any members added
to an instance exist only for the life of that instance; other instances of the same core type are
unaffected.

The base member set of a type can be augmented by the addition of the following kinds of members:

- _adapted members_,  via the _Extended Type System_ (ETS), most details of which are unspecified.
- _extended members_,  via the cmdlet [Add-Member](xref:Microsoft.PowerShell.Utility.Add-Member).

In PowerShell, extended members can also be added via `types.ps1xml` files. Adapted and extended
members are collectively called **synthetic** _members_.

The ETS adds the following members to all PowerShell objects: **psbase**, **psadapted**,
**psextended**, and **pstypenames**. See the **Force** and **View** parameters in the cmdlet
[Get-Member](xref:Microsoft.PowerShell.Utility.Get-Member) for more information on these members.

An instance member may hide an extended and/or adapted member of the same name, and an extended
member may hide an adapted member. In such cases, the member sets **psadapted** and **psextended**
can be used to access those hidden members.

If a `types.ps1xml` specifies a member called **Supports**, `obj.psextended` provides access to just
that member and not to a member added via `Add-Member`.

There are three ways create a custom object having a new member M:

1. This approach can be used to add one or more NoteProperty members.

   ```powershell
   $x = New-Object PSObject -Property @{M = 123}
   ```

1. This approach can be used to add NoteProperty or ScriptMethod members.

   ```powershell
   $x = New-Module -AsCustomObject {$M = 123 ; Export-ModuleMember --Variable M}
   ```

1. This approach can be used to add any kind of member.

   ```powershell
   $x = New-Object PSObject
   Add-Member -InputObject $x -Name M -MemberType NoteProperty -Value 123
   ```

`PSObject` is the base type of all PowerShell types.

<!-- reference links -->
[§12.3.5]: chapter-12.md#1235-the-cmdletbinding-attribute
[§12.3.6]: chapter-12.md#1236-the-outputtype-attribute
[§2.3.2.2]: chapter-02.md#2322-automatic-variables
[§3.1.4]: chapter-03.md#314-functions
[§3.12]: chapter-03.md#312-error-handling
[§3.5.4]: chapter-03.md#354-function-name-scope
[§4.1.2]: chapter-04.md#412-the-null-type
[§4.2.1]: chapter-04.md#421-boolean
[§4.2.2]: chapter-04.md#422-character
[§4.2.3]: chapter-04.md#423-integer
[§4.2.4]: chapter-04.md#424-real-number
[§4.2.6.3]: chapter-04.md#4263-file-attributes-type
[§4.3.1]: chapter-04.md#431-strings
[§4.3.6]: chapter-04.md#436-the-ref-type
[§4.5.1]: chapter-04.md#451-provider-description-type
[§4.5.10]: chapter-04.md#4510-function-description-type
[§4.5.11]: chapter-04.md#4511-filter-description-type
[§4.5.12]: chapter-04.md#4512-module-description-type
[§4.5.16]: chapter-04.md#4516-enumerator-description-type
[§4.5.19]: chapter-04.md#4519-date-time-description-type
[§4.5.2]: chapter-04.md#452-drive-description-type
[§5.3]: chapter-05.md#53-constrained-variables
[§7.1.10]: chapter-07.md#7110-type-literal-expression
[§7.1.3]: chapter-07.md#713-invocation-expressions
[§7.1.4.4]: chapter-07.md#7144-subscripting-an-xml-document
[§7.1.8]: chapter-07.md#718-script-block-expression
[§7.2.9]: chapter-07.md#729-cast-operator
[§7.8.5]: chapter-07.md#785-shift-operators
[§8.10.5]: chapter-08.md#8105-the-switch-type-constraint
[§8.4.4]: chapter-08.md#844-the-foreach-statement
[§9.]: chapter-09.md#9-arrays
[common parameters]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_commonparameters

# /./lang-spec/chapter-05.md - Variables

    ---
    description: A variable represents a storage location for a value, and that value has a type.
    ms.date: 05/19/2021
    title: Variables
    ---
# 5. Variables

A variable represents a storage location for a value, and that value has a type. Traditional
procedural programming languages are statically typed; that is, the runtime type of a variable is
that with which it was declared at compile time. Object-oriented languages add the idea of
inheritance, which allows the runtime type of a variable to be that with which it was declared at
compile time or some type derived from that type. Being a dynamically typed language, PowerShell's
variables do not have types, per se. In fact, variables are not defined; they simply come into being
when they are first assigned a value. And while a variable may be constrained ([§5.3][§5.3]) to holding
a value of a given type, type information in an assignment cannot always be verified statically.

At different times, a variable may be associated with values of different types either through
assignment ([§7.11][§7.11]) or the use of the `++` and `‑‑` operators ([§7.1.5][§7.1.5], [§7.2.6][§7.2.6]). When the
value associated with a variable is changed, that value's type may change. For example,

```powershell
$i = "abc"        # $i holds a value of type string
$i = 2147483647   # $i holds a value of type int
++$i              # $i now holds a value of type double because
                  # 2147483648 is too big to fit in type int
```

Any use of a variable that has not been created results in the value $null. To see if a variable has
been defined, use the [Test-Path](xref:Microsoft.PowerShell.Management.Test-Path) cmdlet.

## 5.1 Writable location

A *writable location* is an expression that designates a resource to which a command has both read
and write access. A writable location may be a variable ([§5][§5]), an array element ([§9][§9]), an associated
value in a Hashtable accessed via a subscript ([§10][§10]), a property ([§7.1.2][§7.1.2]), or storage managed by
a provider ([§3.1][§3.1]).

## 5.2 Variable categories

PowerShell defines the following categories of variables: static variables, instance variables,
array elements, Hashtable key/value pairs, parameters, ordinary variables, and variables on provider
drives. The subsections that follow describe each of these categories.

In the following example

```powershell
function F ($p1, $p2) {
    $radius = 2.45
    $circumference = 2 * ([Math]::PI) * $radius

    $date = Get-Date -Date "2010-2-1 10:12:14 pm"
    $month = $date.Month

    $values = 10, 55, 93, 102
    $value = $values[2]

    $h1 = @{ FirstName = "James"; LastName = "Anderson" }
    $h1.FirstName = "Smith"

    $Alias:A = "Help"
    $Env:MyPath = "e:\Temp"
    ${E:output.txt} = 123
    $function:F = { "Hello there" }
    $Variable:v = 10
}
```

- `[Math::PI]` is a static variable
- `$date.Month` is an instance variable
- `$values[2]` is an array element
- `$h1.FirstName` is a `Hashtable` key whose corresponding value is $h1['FirstName']`
- `$p1` and `$p2` are parameters
- `$radius`, `$circumference`, `$date`, `$month`, `$values`, `$value`, and `$h1` are ordinary
  variables
- `$Alias:A`, `$Env:MyPath`, `${E:output.txt}`, and `$function:F` are variables on the corresponding
  provider drives.
- `$Variable:v` is actually an ordinary variable written with its fully qualified provider drive.

### 5.2.1 Static variables

A data member of an object that belongs to the object's type rather than to that particular instance
of the type is called a *static variable*. See [§4.2.3][§4.2.3], [§4.2.4.1][§4.2.4.1], and [§4.3.8][§4.3.8] for some
examples.

PowerShell provides no way to create new types that contain static variables; however, objects of
such types may be provided by the host environment.

Memory for creating and deleting objects containing static variables is managed by the host
environment and the garbage collection system.

See [§7.1.2][§7.1.2] for information about accessing a static variable.

A static data member can be a field or a property.

### 5.2.2 Instance variables

A data member of an object that belongs to a particular instance of the object's type rather than to
the type itself is called an *instance variable*. See [§4.3.1][§4.3.1], [§4.3.2][§4.3.2], and [§4.3.3][§4.3.3] for
some examples.

A PowerShell host environment might provide a way to create new types that contain instance
variables or to add new instance variables to existing types.

Memory for creating and deleting objects containing static variables is managed by the host
environment and the garbage collection system.

See [§7.1.2][§7.1.2] for information about accessing an instance variable.

An instance data member can be a field or a property.

### 5.2.3 Array elements

An array can be created via a unary comma operator ([§7.2.1][§7.2.1]), *sub-expression* ([§7.1.6][§7.1.6]),
*array-expression* ([§7.1.7][§7.1.7]), binary comma operator ([§7.3][§7.3]), range operator ([§7.4][§7.4]), or
[New-Object](xref:Microsoft.PowerShell.Utility.New-Object) cmdlet.

Memory for creating and deleting arrays is managed by the host environment and the garbage
collection system.

Arrays and array elements are discussed in [§9][§9].

### 5.2.4 Hashtable key/value pairs

A Hashtable is created via a hash literal ([§2.3.5.6][§2.3.5.6]) or the
[New-Object](xref:Microsoft.PowerShell.Utility.New-Object) cmdlet. A new key/value pair can be added
via the `[]` operator ([§7.1.4.3][§7.1.4.3]).

Memory for creating and deleting Hashtables is managed by the host environment and the garbage
collection system.

Hashtables are discussed in [§10][§10].

### 5.2.5 Parameters

A parameter is created when its parent command is invoked, and it is initialized with the value of
the argument provided in the invocation or by the host environment. A parameter ceases to exist when
its parent command terminates.

Parameters are discussed in [§8.10][§8.10].

### 5.2.6 Ordinary variables

An *ordinary variable* is defined by an *assignment-expression* ([§7.11][§7.11]) or a *foreach-statement*
([§8.4.4][§8.4.4]). Some ordinary variables are predefined by the host environment while others are
transient, coming and going as needed at runtime.

The lifetime of an ordinary variable is that part of program execution during which storage is
guaranteed to be reserved for it. This lifetime begins at entry into the scope with which it is
associated, and ends no sooner than the end of the execution of that scope. If the parent scope is
entered recursively or iteratively, a new instance of the local variable is created each time.

The storage referred to by an ordinary variable is reclaimed independently of the lifetime of that
variable.

An ordinary variable can be named explicitly with a **Variable:** namespace prefix ([§5.2.7][§5.2.7]).

### 5.2.7 Variables on provider drives

The concept of providers and drives is introduced in [§3.1][§3.1], with each provider being able to
provide its own namespace drive(s). This allows resources on those drives to be accessed as though
they were ordinary variables ([§5.2.6][§5.2.6]). In fact, an ordinary variable is stored on the file
system provider drive Variable: ([§3.1.5][§3.1.5]) and can be accessed by its ordinary name or its fully
qualified namespace name.

Some namespace variable types are constrained implicitly ([§5.3][§5.3]).

## 5.3 Constrained variables

By default, a variable may designate a value of any type. However, a variable may be *constrained*
to designating values of a given type by specifying that type as a type literal before its name in
an assignment or a parameter. For example,

```powershell
[int]$i = 10   # constrains $i to designating ints only
$i = "Hello"   # error, no conversion to int
$i = "0x10"    # ok, conversion to int
$i = $true     # ok, conversion to int

function F ([int]$p1, [switch]$p2, [regex]$p3) { ... }
```

Any variable belonging to the namespace **Env:**, **Alias:**, or to the file system namespace
([§2.3.2][§2.3.2], [§3.1][§3.1]) is constrained implicitly to the type `string`. Any variable belonging to the
namespace **Function:** ([§2.3.2][§2.3.2], [§3.1][§3.1]) is constrained implicitly to the type `scriptblock`.

<!-- reference links -->
[§2.3.2]: chapter-02.md#232-variables
[§2.3.5.6]: chapter-02.md#2356-hash-literals
[§3.1.5]: chapter-03.md#315-variables
[§3.1]: chapter-03.md#31-providers-and-drives
[§4.2.3]: chapter-04.md#423-integer
[§4.2.4.1]: chapter-04.md#4241-float-and-double
[§4.3.1]: chapter-04.md#431-strings
[§4.3.2]: chapter-04.md#432-arrays
[§4.3.3]: chapter-04.md#433-hashtables
[§4.3.8]: chapter-04.md#438-the-math-type
[§5]: chapter-05.md#5-variables
[§5.2.6]: chapter-05.md#526-ordinary-variables
[§5.2.7]: chapter-05.md#527-variables-on-provider-drives
[§5.3]: chapter-05.md#53-constrained-variables
[§7.1.2]: chapter-07.md#712-member-access
[§7.1.4.3]: chapter-07.md#7143-subscripting-a-hashtable
[§7.1.5]: chapter-07.md#715-postfix-increment-and-decrement-operators
[§7.1.6]: chapter-07.md#716--operator
[§7.1.7]: chapter-07.md#717--operator
[§7.11]: chapter-07.md#711-assignment-operators
[§7.2.1]: chapter-07.md#721-unary-comma-operator
[§7.2.6]: chapter-07.md#726-prefix-increment-and-decrement-operators
[§7.3]: chapter-07.md#73-binary-comma-operator
[§7.4]: chapter-07.md#74-range-operator
[§8.10]: chapter-08.md#810-function-definitions
[§8.4.4]: chapter-08.md#844-the-foreach-statement
[§9]: chapter-09.md#9-arrays
[§10]: chapter-10.md#10-hashtables

# /./lang-spec/chapter-06.md - Conversions

    ---
    description: A type conversion is performed when a value of one type is used in a context that requires a different type.
    ms.date: 05/19/2021
    title: Conversions
    ---
# 6. Conversions

A *type conversion* is performed when a value of one type is used in a context that requires a
different type. If such a conversion happens automatically it is known as *implicit conversion*. (A
common example of this is with some operators that need to convert one or more of the values
designated by their operands.) Implicit conversion is permitted provided the sense of the source
value is preserved, such as no loss of precision of a number when it is converted.

The cast operator ([§7.2.9][§7.2.9]) allows for *explicit conversion*.

Conversions are discussed below, with supplementary information being provided as necessary in the
description of each operator in [§6.19][§6.19].

Explicit conversion of a value to the type it already has causes no change to that value or its
representation.

The rules for handing conversion when the value of an expression is being bound to a parameter are
covered in [§6.17][§6.17].

## 6.1 Conversion to void

A value of any type can be discarded explicitly by casting it to type void. There is no result.

## 6.2 Conversion to bool

The rules for converting any value to type bool are as follows:

- A numeric or char value of zero is converted to False; a numeric or char value of non-zero is
  converted to True.
- A value of null type is converted to False.
- A string of length 0 is converted to False; a string of length > 0 is converted to True.
- A switch parameter with value `$true` is converted to True, and one with value `$false` is
  converted to False.
- All other non-null reference type values are converted to True.

If the type implements IList:

- If the object's Length > 2, the value is converted to True.
- If the object's Length is 1 and that first element is not itself an IList, then if that element's
  value is true, the value is converted to True.
- Otherwise, if the first element's Count >= 1, the value is converted to True.
- Otherwise, the value is converted to False.

## 6.3 Conversion to char

The rules for converting any value to type char are as follows:

- The conversion of a value of type bool, decimal, float, or double is in error.
- A value of null type is converted to the null (U+0000) character.
- An integer type value whose value can be represented in type char has that value; otherwise, the
  conversion is in error.
- The conversion of a string value having a length other than 1 is in error.
- A string value having a length 1 is converted to a char having that one character's value.
- A numeric type value whose value after rounding of any fractional part can be represented in the
  destination type has that rounded value; otherwise, the conversion is in error.
- For other reference type values, if the reference type supports such a conversion, that conversion
  is used; otherwise, the conversion is in error.

## 6.4 Conversion to integer

The rules for converting any value to type byte, int, or long are as
follows:

- The bool value False is converted to zero; the bool value True is converted to 1.
- A char type value whose value can be represented in the destination type has that value;
  otherwise, the conversion is in error.
- A numeric type value whose value after rounding of any fractional part can be represented in the
  destination type has that rounded value; otherwise, the conversion is in error.
- A value of null type is converted to zero.
- A string that represents a number is converted as described in [§6.16][§6.16]. If after truncation of
  the fractional part the result can be represented in the destination type the string is well
  formed and it has the destination type; otherwise, the conversion is in error. If the string does
  not represent a number, the conversion is in error.
- For other reference type values, if the reference type supports such a conversion, that conversion
  is used; otherwise, the conversion is in error.

## 6.5 Conversion to float and double

The rules for converting any value to type float or double are as
follows:

- The bool value False is converted to zero; the bool value True is converted to 1.
- A char value is represented exactly.
- A numeric type value is represented exactly, if possible; however, for int, long, and decimal
  conversions to float, and for long and decimal conversions to double, some of the least
  significant bits of the integer value may be lost.
- A value of null type is converted to zero.
- A string that represents a number is converted as described in [§6.16][§6.16]; otherwise, the
  conversion is in error.
- For other reference type values, if the reference type supports such a conversion, that conversion
  is used; otherwise, the conversion is in error.

## 6.6 Conversion to decimal

The rules for converting any value to type decimal are as follows:

- The bool value False is converted to zero; the bool value True is converted to 1.
- A char type value is represented exactly.
- A numeric type value is represented exactly; however, if that value is too large or too small to
  fit in the destination type, the conversion is in error.
- A value of null type is converted to zero.
- A string that represents a number is converted as described in [§6.16][§6.16]; otherwise, the
  conversion is in error.
- For other reference type values, if the reference type supports such a conversion, that conversion
  is used; otherwise, the conversion is in error.
- The scale of the result of a successful conversion is such that the fractional part has no
  trailing zeros.

## 6.7 Conversion to object

The value of any type except the null type (4.1.2) can be converted to type object. The value
retains its type and representation.

## 6.8 Conversion to string

The rules for converting any value to type string are as follows:

- The bool value `$false` is converted to "False"; the bool value `$true` is converted to "True".
- A char type value is converted to a 1-character string containing that char.
- A numeric type value is converted to a string having the form of a corresponding numeric literal.
  However, the result has no leading or trailing spaces, no leading plus sign, integers have base
  10, and there is no type suffix. For a decimal conversion, the scale is preserved. For values of
  -∞, +∞, and NaN, the resulting strings are "-Infinity", "Infinity", and "NaN", respectively.
- A value of null type is converted to the empty string.
- For a 1-dimensional array, the result is a string containing the value of each element in that
  array, from start to end, converted to string, with elements being separated by the current Output
  Field Separator ([§2.3.2.2][§2.3.2.2]). For an array having elements that are themselves arrays, only the
  top-level elements are converted. The string used to represent the value of an element that is an
  array, is implementation defined. For a multi-dimensional array, it is flattened ([§9.12][§9.12]) and
  then treated as a 1‑dimensional array.
- A value of null type is converted to the empty string.
- A scriptblock type value is converted to a string containing the text of that block without the
  delimiting { and } characters.
- For an enumeration type value, the result is a string containing the name of each enumeration
  constant encoded in that value, separated by commas.
- For other reference type values, if the reference type supports such a conversion, that conversion
  is used; otherwise, the conversion is in error.

The string used to represent the value of an element that is an array has the form `System.type[]`,
`System.type[,]`, and so on. For other reference types, the method `ToString` is called. For other
enumerable types, the source value is treated like a 1-dimensional array.

## 6.9 Conversion to array

The rules for converting any value to an array type are as follows:

- The target type may not be a multidimensional array.
- A value of null type is retained as is.
- For a scalar value other than `$null` or a value of type hashtable, a new 1-element array is
  created whose value is the scalar after conversion to the target element type.
- For a 1-dimensional array value, a new array of the target type is created, and each element is
  copied with conversion from the source array to the corresponding element in the target array.
- For a multi-dimensional array value, that array is first flattened ([§9.12][§9.12]), and then treated
  as a 1-dimensional array value.
- A string value is converted to an array of char having the same length with successive characters
  from the string occupying corresponding positions in the array.

For other enumerable types, a new 1-element array is created whose value is the corresponding
element after conversion to the target element type, if such a conversion exists. Otherwise, the
conversion is in error.

## 6.10 Conversion to xml

The object is converted to type string and then into an XML Document object of type `xml`.

## 6.11 Conversion to regex

An expression that designates a value of type string may be converted to type `regex`.

## 6.12 Conversion to scriptblock

The rules for converting any value to type `scriptblock` are as follows:

- A string value is treated as the name of a command optionally following by arguments to a call to
  that command.

## 6.13 Conversion to enumeration types

The rules for converting any value to an enumeration type are as
follows:

- A value of type string that contains one of the named values (with regard for case) for an
  enumeration type is converted to that named value.
- A value of type string that contains a comma-separated list of named values (with regard for case)
  for an enumeration type is converted to the bitwise-OR of all those named values.

## 6.14 Conversion to other reference types

The rules for converting any value to a reference type other than an array type or string are as
follows:

- A value of null type is retained as is.
- Otherwise, the behavior is implementation defined.

A number of pieces of machinery come in to play here; these include the possible use of single
argument constructors or default constructors if the value is a hashtable, implicit and explicit
conversion operators, and Parse methods for the target type; the use of Convert.ConvertTo; and the
ETS conversion mechanism.

## 6.15 Usual arithmetic conversions

If neither operand designates a value having numeric type, then

- If the left operand designates a value of type bool, the conversion is in error.
- Otherwise, all operands designating the value `$null` are converted to zero of type int and the
  process continues with the numeric conversions listed below.
- Otherwise, if the left operand designates a value of type char and the right operand designates a
  value of type bool, the conversion is in error.
- Otherwise, if the left operand designates a value of type string but does not represent a number
  ([§6.16][§6.16]), the conversion is in error.
- Otherwise, if the right operand designates a value of type string but does not represent a number
  ([§6.16][§6.16]), the conversion is in error.
- Otherwise, all operands designating values of type string are converted to numbers ([§6.16][§6.16]),
  and the process continues with the numeric conversions listed below.
- Otherwise, the conversion is in error.

Numeric conversions:

- If one operand designates a value of type decimal, the value designated by the other operand is
  converted to that type, if necessary. The result has type decimal.
- Otherwise, if one operand designates a value of type double, the value designated by the other
  operand is converted to that type, if necessary. The result has type double.
- Otherwise, if one operand designates a value of type float, the values designated by both operands
  are converted to type double, if necessary. The result has type double.
- Otherwise, if one operand designates a value of type long, the value designated by the other
  operand value is converted to that type, if necessary. The result has the type first in the
  sequence long and double that can represent its value.
- Otherwise, the values designated by both operands are converted to type int, if necessary. The
  result has the first in the sequence int, long, double that can represent its value without
  truncation.

## 6.16 Conversion from string to numeric type

Depending on its contents, a string can be converted explicitly or
implicitly to a numeric value. Specifically,

- An empty string is converted to the value zero.
- Leading and trailing spaces are ignored; however, a string may not consist of spaces only.
- A string containing only white space and/or line terminators is converted to the value zero.
- One leading + or - sign is permitted.
- An integer number may have a hexadecimal prefix (0x or 0X).
- An optionally signed exponent is permitted.
- Type suffixes and multipliers are not permitted.
- The case-distinct strings "-Infinity", "Infinity", and "NaN" are recognized as the values -∞, +∞,
  and NaN, respectively.

## 6.17 Conversion during parameter binding

For information about parameter binding see [§8.14][§8.14].

When the value of an expression is being bound to a parameter, there are extra conversion
considerations, as described below:

- If the parameter type is switch ([§4.2.5][§4.2.5], [§8.10.5][§8.10.5]) and the parameter has no
  argument, the value of the parameter in the called command is set to `$true`. If the parameter
  type is other than switch, a parameter having no argument is in error.
- If the parameter type is switch and the argument value is `$null`, the parameter value is set to
  `$false`.
- If the parameter type is object or is the same as the type of the argument, the argument's value
  is passed without conversion.
- If the parameter type is not object or scriptblock, an argument having type scriptblock is
  evaluated and its result is passed as the argument's value. (This is known as *delayed script
  block binding*.) If the parameter type is object or scriptblock, an argument having type
  scriptblock is passed as is.
- If the parameter type is a collection of type T2, and the argument is a scalar of type T1, that
  scalar is converted to a collection of type T2 containing one element. If necessary, the scalar
  value is converted to type T2 using the conversion rules of this section.
- If the parameter type is a scalar type other than object and the argument is a collection, the
  argument is in error.
- If the expected parameter type is a collection of type T2, and the argument is a collection of
  type T1, the argument is converted to a collection of type T2 having the same length as the
  argument collection. If necessary, the argument collection element values are converted to type T2
  using the conversion rules of this section.
- If the steps above and the conversions specified earlier in this chapter do not suffice, the rules
  in [§6.18][§6.18] are applied. If those fail, the parameter binding fails.

## 6.18 .NET Conversion

For an implicit conversion, PowerShell's built-in conversions are tried first. If they cannot
resolve the conversion, the .NET custom converters below are tried, in order, from top to bottom. If
a conversion is found, but it throws an exception, the conversion has failed.

- **PSTypeConverter**: There are two ways of associating the implementation of the
  **PSTypeConverter** class with its target class: through the type configuration file
  (types.ps1xml) or by applying the `System.ComponentModel.TypeConverterAttribute` attribute to the
  target class. Refer to the PowerShell SDK documentation for more information.

- **TypeConverter**: This CLR type provides a unified way of converting types of values to other
  types, as well as for accessing standard values and sub-properties. The most common type of
  converter is one that converts to and from a text representation. The type converter for a class
  is bound to the class with a `System.ComponentModel.TypeConverterAttribute`. Unless this attribute
  is overridden, all classes that inherit from this class use the same type converter as the base
  class. Refer to the PowerShell SDK and the Microsoft .NET framework documentation for more
  information.

- **Parse Method**: If the source type is string and the destination type has a method called
  `Parse`, that method is called to perform the conversion.

- **Constructors**: If the destination type has a constructor taking a single argument whose type is
  that of the source type, that constructor is called to perform the conversion.

- **Implicit Cast Operator**: If the source type has an implicit cast operator that converts to the
  destination type, that operator is called to perform the conversion.

- **Explicit Cast Operator**: If the source type has an explicit cast operator that converts to the
  destination type, that operator is called to perform the conversion. If the destination type has
  an explicit cast operator that converts from the source type, that operator is called to perform
  the conversion.

- **IConvertable**: `System.Convert.ChangeType` is called to perform the conversion.

## 6.19 Conversion to ordered

The rules for converting any value to the pseudo-type ordered are as
follows:

- If the value is a hash literal ([§2.3.5.6][§2.3.5.6]), the result is an object with an implementation
  defined type that behaves like a hashtable and the order of the keys matches the order specified
  in the hash literal.
- Otherwise, the behavior is implementation defined.

Only hash literals ([§2.3.5.6][§2.3.5.6]) can be converted to ordered. The result is an instance of
`System.Collections.Specialized.OrderedDictionary`.

## 6.20 Conversion to pscustomobject

The rules for converting any value to the pseudo-type pscustomobject are
as follows:

- A value of type hashtable is converted to a PowerShell object. Each key in the hashtable becomes a
  NoteProperty with the corresponding value.
- Otherwise, the behavior is implementation defined.

The conversion is always allowed but does not change the type of the value.

<!-- reference links -->
[§2.3.2.2]: chapter-02.md#2322-automatic-variables
[§2.3.5.6]: chapter-02.md#2356-hash-literals
[§4.2.5]: chapter-04.md#425-the-switch-type
[§6.16]: chapter-06.md#616-conversion-from-string-to-numeric-type
[§6.17]: chapter-06.md#617-conversion-during-parameter-binding
[§6.18]: chapter-06.md#618-net-conversion
[§6.19]: chapter-06.md#619-conversion-to-ordered
[§7.2.9]: chapter-07.md#729-cast-operator
[§8.10.5]: chapter-08.md#8105-the-switch-type-constraint
[§8.14]: chapter-08.md#814-parameter-binding
[§9.12]: chapter-09.md#912-multidimensional-array-flattening

# /./lang-spec/chapter-07.md - Expressions

    ---
    description: An expression is a sequence of operators and operands that designates a method, a function, a writable location, or a value; specifies the computation of a value; produces one or more side effects; or performs some combination thereof.
    ms.date: 05/19/2021
    title: Expressions
    ---
# 7. Expressions

Syntax:

```Syntax
expression:
    logical-expression
```

Description:

An *expression* is a sequence of operators and operands that designates a method, a function, a
writable location, or a value; specifies the computation of a value; produces one or more side
effects; or performs some combination thereof. For example,

- The literal 123 is an expression that designates the int value 123.
- The expression `1,2,3,4` designates the 4-element array object having the values shown.
- The expression `10.4 * $a` specifies a computation.
- The expression `$a++` produces a side effect.
- The expression `$a[$i--] = $b[++$j]` performs a combination of these things.

Except as specified for some operators, the order of evaluation of terms in an expression and the
order in which side effects take place are both unspecified. Examples of unspecified behavior
include the following: `$i++ + $i`, `$i + --$i`, and `$w[$j++] = $v[$j]`.

An implementation of PowerShell may provide support for user-defined types, and those types may have
operations defined on them. All details of such types and operations are implementation defined.

A *top-level expression* is one that is not part of some larger expression. If a top-level
expression contains a side-effect operator the value of that expression is not written to the
pipeline; otherwise, it is. See [§7.1.1][§7.1.1] for a detailed discussion of this.

Ordinarily, an expression that designates a collection (§4) is enumerated into its constituent
elements when the value of that expression is used. However, this is not the case when the
expression is a cmdlet invocation. For example,

```powershell
$x = 10,20,30
$a = $($x; 99)                     # $a.Length is 4

$x = New-Object 'int[]' 3
$a = $($x; 99)                     # equivalent, $a.Length is 4

$a = $(New-Object 'int[]' 3; 99)   # $a.Length is 2
```

In the first two uses of the `$(...)` operator, the expression designating the collection is the
variable `$x`, which is enumerated resulting in three `int` values, plus the `int` 99. However, in
the third case, the expression is a direct call to a cmdlet, so the result is not enumerated, and
`$a` is an array of two elements, `int[3]` and `int`.

If an operation is not defined by PowerShell, the type of the value designated by the left operand
is inspected to see if it has a corresponding `op_<operation>` method.

## 7.1 Primary expressions

Syntax:

```Syntax
primary-expression:
    value
    member-access
    element-access
    invocation-expression
    post-increment-expression
    post-decrement-expression

value:
    parenthesized-expression
    sub-expression
    array-expression
    script-block-expression
    hash-literal-expression
    literal
    type-literal
    variable
```

### 7.1.1 Grouping parentheses

Syntax:

> [!TIP]
> The `~opt~` notation in the syntax definitions indicates that the lexical entity is optional in
> the syntax.

```Syntax
parenthesized-expression:
    ( new-lines~opt~ pipeline new-lines~opt~ )
```

Description:

A parenthesized expression is a *primary-expression* whose type and value are the same as those of
the expression without the parentheses. If the expression designates a variable then the
parenthesized expression designates that same variable. For example, `$x.m` and `($x).m` are
equivalent.

Grouping parentheses may be used in an expression to document the default precedence and
associativity within that expression. They can also be used to override that default precedence and
associativity. For example,

```powershell
4 + 6 * 2    # 16
4 + (6 * 2)  # 16 document default precedence
(4 + 6) * 2  # 20 override default precedence
```

Ordinarily, grouping parentheses at the top-most level are redundant. However, that is not always
the case. Consider the following example:

```powershell
2,4,6       # Length 3; values 2,4,6
(2,4),6     # Length 2; values [object[]],int
```

In the second case, the parentheses change the semantics, resulting in an array whose two elements
are an array of 2 ints and the scalar int 6.

Here's another exception:

```powershell
23.5/2.4          # pipeline gets 9.79166666666667
$a = 1234 * 3.5   # value not written to pipeline
$a                # pipeline gets 4319
```

In the first and third cases, the value of the result is written to the pipeline. However, although
the expression in the second case is evaluated, the result is not written to the pipeline due to the
presence of the side-effect operator = at the top level. (Removal of the `$a = ` part allows the
value to be written, as `*` is not a side-effect operator.)

To stop a value of any expression not containing top-level side effects from being written to the
pipeline, discard it explicitly, as follows:

```powershell
# None of these value are written to pipeline
[void](23.5/2.4)
[void]$a
$null = $a
$a > $null
```

To write to the pipeline the value of any expression containing top-level side effects, enclose that
expression in parentheses, as follows:

```powershell
($a = 1234 * 3.5) # pipeline gets 4319
```

As such, the grouping parentheses in this case are not redundant.

In the following example, we have variable substitution ([§2.3.5.2][§2.3.5.2]) taking place in a string
literal:

```powershell
">$($a = -23)<"    # value not written to pipeline, get
><
">$(($a = -23))<"  # pipeline gets >-23<
```

In the first case, the parentheses represent a *sub-expression*'s delimiters *not* grouping
parentheses, and as the top-level expression contains a side-effect operator, the expression's value
is not written to the pipeline. Of course, the `>` and `<` characters are still written.) If
grouping parenthesis are added -- as shown in the second case -- writing is enabled.

The following examples each contain top-level side-effect operators:

```powershell
$a = $b = 0      # value not written to pipeline
$a = ($b = 0)    # value not written to pipeline
($a = ($b = 0))  # pipeline gets 0

++$a             # value not written to pipeline
(++$b)           # pipeline gets 1

$a--             # value not written to pipeline
($b--)           # pipeline gets 1
```

The use of grouping parentheses around an expression containing no top-level side effects makes
those parentheses redundant. For example;

```powershell
$a      # pipeline gets 0
($a)    # no side effect, so () redundant
```

Consider the following example that has two side effects, neither of which is at the top level:

```powershell
12.6 + ($a = 10 - ++$b) # pipeline gets 21.6.
```

The result is written to the pipeline, as the top-level expression has no side effects.

### 7.1.2 Member access

Syntax:

```Syntax
member-access: Note no whitespace is allowed after primary-expression. 
    primary-expression . member-name
    primary-expression :: member-name
```

Description:

The operator `.` is used to select an instance member from an object, or a key from a `Hashtable`.
The left operand must designate an object, and the right operand must designate an accessible
instance member.

Either the right operand designates an accessible instance member within the type of the object
designated by the left operand or, if the left operand designates an array, the right operand
designates accessible instance members within each element of the array.

White space is not permitted before the `.` operator.

This operator is left associative.

The operator `::` is used to select a static member from a given type. The left operand must
designate a type, and the right-hand operand must designate an accessible static member within that
type.

White space is not permitted before the `::` operator.

This operator is left associative.

If the right-hand operand designates a writable location within the type of the object designated by
the left operand, then the whole expression designates a writable location.

Examples:

```powershell
$a = 10, 20, 30
$a.Length                    # get instance property

(10, 20, 30).Length

$property = "Length"
$a.$property                 # property name is a variable

$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123
}
$h1.FirstName                # designates the key FirstName
$h1.Keys                     # gets the collection of keys

[int]::MinValue              # get static property
[double]::PositiveInfinity   # get static property
$property = "MinValue"
[long]::$property            # property name is a variable

foreach ($t in [byte], [int], [long]) {
    $t::MaxValue             # get static property
}

$a = @{ID = 1 }, @{ID = 2 }, @{ID = 3 }
$a.ID                        # get ID from each element in the array
```

### 7.1.3 Invocation expressions

Syntax:

```Syntax
invocation-expression: Note no whitespace is allowed after primary-expression. 
    primary-expression . member-name argument-list
    primary-expression :: member-name argument-list

argument-list:
    ( argument-expression-list~opt~ new-lines~opt~ )
```

Description:

An *invocation-expression* calls the method designated by *primary-expression*.*member-name* or
*primary-expression*::*member-name*. The parentheses in *argument-list* contain a possibly empty,
comma-separated list of expressions, which designate the *arguments* whose values are passed to the
method. Before the method is called, the arguments are evaluated and converted according to the
rules of §6, if necessary, to match the types expected by the method. The order of evaluation of
*primary-expression*.*member-name*, *primary-expression*::*member-name*, and the arguments is
unspecified.

This operator is left associative.

The type of the result of an *invocation-expression* is a *method designator* ([§4.5.24][§4.5.24]).

Examples:

```powershell
[math]::Sqrt(2.0)            # call method with argument 2.0
[char]::IsUpper("a")         # call method
$b = "abc#$%XYZabc"
$b.ToUpper()                 # call instance method

[math]::Sqrt(2)              # convert 2 to 2.0 and call method
[math]::Sqrt(2D)             # convert 2D to 2.0 and call method
[math]::Sqrt($true)          # convert $true to 1.0 and call method
[math]::Sqrt("20")           # convert "20" to 20 and call method

$a = [math]::Sqrt            # get method descriptor for Sqrt
$a.Invoke(2.0)               # call Sqrt via the descriptor
$a = [math]::("Sq"+"rt")     # get method descriptor for Sqrt
$a.Invoke(2.0)               # call Sqrt via the descriptor
$a = [char]::ToLower         # get method descriptor for ToLower
$a.Invoke("X")               # call ToLower via the descriptor
```

### 7.1.4 Element access

Syntax:

```Syntax
element-access: Note no whitespace is allowed between primary-expression and [.
    primary-expression [ new-lines~opt~ expression new-lines~opt~ ]
```

Description:

There must not be any white space between *primary-expression* and the left square bracket (`[`).

#### 7.1.4.1 Subscripting an array

Description:

Arrays are discussed in detail in [§9.][§9.] If *expression* is a 1-dimensional array, see
[§7.1.4.5][§7.1.4.5].

When *primary-expression* designates a 1-dimensional array *A*, the operator `[]` returns the
element located at `A[0 + expression]` after the value of *expression* has been converted to `int`.
The result has the element type of the array being subscripted. If *expression* is negative,
`A[expression]` designates the element located at `A[A.Length + expression]`.

When *primary-expression* designates a 2-dimensional array *B*, the operator `[]` returns the
element located at `B[0 + row,0 + column]` after the value of the *row* and *column* components of
*expression* (which are specified as a comma-separated list) have been converted to `int`. The
result has the element type of the array being subscripted. Unlike for a 1-dimensional array,
negative positions have no special meaning.

When *primary-expression* designates an array of three or more dimensions, the rules for
2-dimensional arrays apply and the dimension positions are specified as a comma-separated list of
values.

If a read access on a non-existing element is attempted, the result is `$null`. It is an error to
write to a non-existing element.

For a multidimensional-array subscript expression, the order of evaluation of the dimension position
expressions is unspecified. For example, given a 3-dimensional array `$a`, the behavior of
`$a[$i++,$i,++$i]` is unspecified.

If *expression* is an array, see [§7.1.4.5][§7.1.4.5].

This operator is left associative.

Examples:

```powershell
$a = [int[]](10,20,30) # [int[]], Length 3
$a[1] # returns int 20
$a[20] # no such position, returns $null
$a[-1] # returns int 30, i.e., $a[$a.Length-1]
$a[2] = 5 # changes int 30 to int 5
$a[20] = 5 # implementation-defined behavior

$a = New-Object 'double[,]' 3,2
$a[0,0] = 10.5 # changes 0.0 to 10.5
$a[0,0]++ # changes 10.5 to 10.6

$list = ("red",$true,10),20,(1.2, "yes")
$list[2][1] # returns string "yes"

$a = @{ A = 10 },@{ B = $true },@{ C = 123.45 }
$a[1]["B"] # $a[1] is a Hashtable, where B is a key

$a = "red","green"
$a[1][4] # returns string "n" from string in $a[1]
```

If a write access to a non-existing element is attempted, an **IndexOutOfRange** exception is
raised.

#### 7.1.4.2 Subscripting a string

Description:

When *primary-expression* designates a string *S*, the operator `[]` returns the character located
in the zero-based position indicated by *expression*, as a char. If *expression* is greater than or
equal to that string's length, the result is `$null`. If *expression* is negative,
`S[expression]` designates the element located at `S[S.Length + expression]`.

Examples:

```powershell
$s = "Hello"   # string, Length 5, positions 0-4
$c = $s[1]     # returns "e" as a string
$c = $s[20]    # no such position, returns $null
$c = $s[-1]    # returns "o", i.e., $s[$s.Length-1]
```

#### 7.1.4.3 Subscripting a Hashtable

Description:

When *primary-expression* designates a Hashtable, the operator `[]` returns the value(s) associated
with the key(s) designated by *expression*. The type of *expression* is not restricted.

When *expression* is a single key name, the result is the associated value and has that type, unless
no such key exists, in which case, the result is `$null`. If `$null` is used as the key the behavior
is implementation defined. If *expression* is an array of key names, see [§7.1.4.5][§7.1.4.5].

If *expression* is an array, see [§7.1.4.5][§7.1.4.5].

Examples:

```powershell
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
$h1['FirstName']     # the value associated with key FirstName
$h1['BirthDate']     # no such key, returns $null

$h1 = @{ 10 = "James"; 20.5 = "Anderson"; $true = 123 }
$h1[10]              # returns value "James" using key 10
$h1[20.5]            # returns value "Anderson" using key 20.5
$h1[$true]           # returns value 123 using key $true
```

When *expression* is a single key name, if `$null` is used as the only value to subscript a
Hashtable, a **NullArrayIndex** exception is raised.

#### 7.1.4.4 Subscripting an XML document

Description:

When *primary-expression* designates an object of type xml, *expression* is converted to string, if
necessary, and the operator `[]` returns the first child element having the name specified by
*expression*. The type of *expression* must be string. The type of the result is implementation
defined. The result can be subscripted to return its first child element. If no child element exists
with the name specified by *expression*, the result is `$null`. The result does not designate a
writable location.

Examples:

```powershell
$x = [xml]@"
<Name>
<FirstName>Mary</FirstName>
<LastName>King</LastName>
</Name>
"@

$x['Name']                # refers to the element Name
$x['Name']['FirstName']   # refers to the element FirstName within Name
$x['FirstName']           # No such child element at the top level, result is `$null`
```

The type of the result is `System.Xml.XmlElement` or `System.String`.

#### 7.1.4.5 Generating array slices

When *primary-expression* designates an object of a type that is enumerable (§4) or a Hashtable, and
*expression* is a 1-dimensional array, the result is an array slice ([§9.9][§9.9]) containing the
elements of *primary-expression* designated by the elements of *expression*.

In the case of a Hashtable, the array slice contains the associated values to the keys provided,
unless no such key exists, in which case, the corresponding element is `$null`. If `$null` is used
as any key name the behavior is implementation defined.

Examples:

```powershell
$a = [int[]](30,40,50,60,70,80,90)
$a[1,3,5]                 # slice has Length 3, value 40,60,80
++$a[1,3,5][1]            # preincrement 60 in array 40,60,80
$a[,5]                    # slice with Length 1
$a[@()]                   # slice with Length 0
$a[-1..-3]                # slice with Length 0, value 90,80,70
$a = New-Object 'int[,]' 3,2
$a[0,0] = 10; $a[0,1] = 20; $a[1,0] = 30
$a[1,1] = 40; $a[2,0] = 50; $a[2,1] = 60
$a[(0,1),(1,0)]           # slice with Length 2, value 20,30, parens needed
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
$h1['FirstName']          # the value associated with key FirstName
$h1['BirthDate']          # no such key, returns $null
$h1['FirstName','IDNum']  # returns [object[]], Length 2 (James/123)
$h1['FirstName','xxx']    # returns [object[]], Length 2 (James/$null)
$h1[$null,'IDNum']        # returns [object[]], Length 1 (123)
```

Windows PowerShell: When *expression* is a collection of two or more key names, if `$null` is used
as any key name that key is ignored and has no corresponding element in the resulting array.

### 7.1.5 Postfix increment and decrement operators

Syntax:

```Syntax
post-increment-expression:
    primary-expression ++

post-decrement-expression:
    primary-expression dashdash

dashdash:
    --
```

Description:

The *primary-expression* must designate a writable location having a value of numeric type (§4) or
the value `$null`. If the value designated by the operand is `$null`, that value is converted to
type int and value zero before the operator is evaluated. The type of the value designated by
*primary-expression* may change when the result is stored. See [§7.11][§7.11] for a discussion of type
change via assignment.

The result produced by the postfix `++` operator is the value designated by the operand. After that
result is obtained, the value designated by the operand is incremented by 1 of the appropriate type.
The type of the result of expression `E++` is the same as for the result of the expression `E + 1`
([§7.7][§7.7]).

The result produced by the postfix `--` operator is the value designated by the operand. After that
result is obtained, the value designated by the operand is decremented by 1 of the appropriate type.
The type of the result of expression `E--` is the same as for the result of the expression `E - 1`
([§7.7][§7.7]).

These operators are left associative.

Examples:

```powershell
$i = 0                # $i = 0
$i++                  # $i is incremented by 1
$j = $i--             # $j takes on the value of $i before the decrement

$a = 1,2,3
$b = 9,8,7
$i = 0
$j = 1
$b[$j--] = $a[$i++]   # $b[1] takes on the value of $a[0], then $j is
                      # decremented, $i incremented

$i = 2147483647       # $i holds a value of type int
$i++                  # $i now holds a value of type double because
                      # 2147483648 is too big to fit in type int

[int]$k = 0           # $k is constrained to int
$k = [int]::MaxValue  # $k is set to 2147483647
$k++                  # 2147483648 is too big to fit, imp-def bahavior

$x = $null            # target is unconstrained, $null goes to [int]0
$x++                  # value treated as int, 0->1
```

### 7.1.6 $(...) operator

Syntax:

```Syntax
sub-expression:
    $( new-lines~opt~ statement-list~opt~ new-lines~opt~ )
```

Description:

If *statement-list* is omitted, the result is `$null`. Otherwise, *statement-list* is evaluated. Any
objects written to the pipeline as part of the evaluation are collected in an unconstrained
1-dimensional array, in order. If the array of collected objects is empty, the result is `$null`. If
the array of collected objects contains a single element, the result is that element; otherwise, the
result is the unconstrained 1-dimensional array of collected results.

Examples:

```powershell
$j = 20
$($i = 10) # pipeline gets nothing
$(($i = 10)) # pipeline gets int 10
$($i = 10; $j) # pipeline gets int 20
$(($i = 10); $j) # pipeline gets [object[]](10,20)
$(($i = 10); ++$j) # pipeline gets int 10
$(($i = 10); (++$j)) # pipeline gets [object[]](10,22)
$($i = 10; ++$j) # pipeline gets nothing
$(2,4,6) # pipeline gets [object[]](2,4,6)
```

### 7.1.7 @(...) operator

Syntax:

```Syntax
array-expression:
    @( new-lines~opt~ statement-list~opt~ new-lines~opt~ )
```

Description:

If *statement-list* is omitted, the result is an unconstrained 1-dimensional array of length zero.
Otherwise, *statement-list* is evaluated, and any objects written to the pipeline as part of the
evaluation are collected in an unconstrained 1-dimensional array, in order. The result is the
(possibly empty) unconstrained 1-dimensional array.

Examples:

```powershell
$j = 20
@($i = 10)             # 10 not written to pipeline, result is array of 0
@(($i = 10))           # pipeline gets 10, result is array of 1
@($i = 10; $j)         # 10 not written to pipeline, result is array of 1
@(($i = 10); $j)       # pipeline gets 10, result is array of 2
@(($i = 10); ++$j)     # pipeline gets 10, result is array of 1
@(($i = 10); (++$j))   # pipeline gets both values, result is array of 2
@($i = 10; ++$j)       # pipeline gets nothing, result is array of 0

$a = @(2,4,6)          # result is array of 3
@($a)                  # result is the same array of 3
@(@($a))               # result is the same array of 3
```

### 7.1.8 Script block expression

Syntax:

```Syntax
script-block-expression:
    { new-lines~opt~ script-block new-lines~opt~ }

script-block:
    param-block~opt~ statement-terminators~opt~ script-block-body~opt~

script-block-body:
    named-block-list
    statement-list
```

Description:

*param-block* is described in [§8.10.9][§8.10.9]. *named-block-list* is described in [§8.10.7][§8.10.7].

A script block is an unnamed block of statements that can be used as a single unit. Script blocks
can be used to invoke a block of code as if it was a single command, or they can be assigned to
variables that can be executed.

The *named-block-list* or *statement-list* is executed and the type and value(s) of the result are
the type and value(s) of the results of those statement sets.

A *script-block-expression* has type scriptblock ([§4.3.7][§4.3.7]).

If *param-block* is omitted, any arguments passed to the script block are available via `$args`
([§8.10.1][§8.10.1]).

During parameter binding, a script block can be passed either as a script block object or as the
result after the script block has been evaluated. See [§6.17][§6.17] for further information.

### 7.1.9 Hash literal expression

Syntax:

```Syntax
hash-literal-expression:
    @{ new-lines~opt~ hash-literal-body~opt~ new-lines~opt~ }

hash-literal-body:
    hash-entry
    hash-literal-body statement-terminators hash-entry

hash-entry:
    key-expression = new-lines~opt~ statement

key-expression:
    simple-name
    unary-expression

statement-terminators:
    statement-terminator
    statement-terminators statement-terminator

statement-terminator:
    ;
    new-line-character
```

Description:

A *hash-literal-expression* is used to create a Hashtable (§10) of zero or more elements each of
which is a key/value pair.

The key may have any type except the null type. The associated values may have any type, including
the null type, and each of those values may be any expression that designates the desired value,
including `$null`.

The ordering of the key/value pairs is not significant.

Examples:

```powershell
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
$last = "Anderson"; $IDNum = 120
$h2 = @{ FirstName = "James"; LastName = $last; IDNum = $IDNum + 3 }
$h3 = @{ }
$h4 = @{ 10 = "James"; 20.5 = "Anderson"; $true = 123 }
```

which creates two Hashtables, `$h1` and `$h2`, each containing three key/value pairs, and a third,
`$h3`, that is empty. Hashtable `$h4` has keys of various types.

### 7.1.10 Type literal expression

Syntax:

```Syntax
type-literal:
    [ type-spec ]

type-spec:
    array-type-name new-lines~opt~ dimension~opt~ ]
    generic-type-name new-lines~opt~ generic-type-arguments ]
    type-name

dimension:
    ,
    dimension ,

generic-type-arguments:
    type-spec new-lines~opt~
    generic-type-arguments , new-lines~opt~ type-spec

array-type-name:
    type-name [

generic-type-name:
    type-name [
```

Description:

A *type-literal* is represented in an implementation by some unspecified *underlying type*. As a
result, a type name is a synonym for its underlying type.

Type literals are used in a number of contexts:

- Specifying an explicit conversion (§6, [§7.2.9][§7.2.9])
- Creating a type-constrained array ([§9.4][§9.4])
- Accessing the static members of an object ([§7.1.2][§7.1.2])
- Specifying a type constraint on a variable ([§5.3][§5.3]) or a function parameter ([§8.10.2][§8.10.2])

Examples:

Examples of type literals are `[int]`, `[object[]`, and `[int[,,]]`. A generic stack type ([§4.4][§4.4])
that is specialized to hold strings might be written as `[Stack[string]]`, and a generic dictionary
type that is specialized to hold `int` keys with associated string values might be written as
`[Dictionary[int,string]]`.

The type of a *type-literal* is `System.Type`. The complete name for the type `Stack[string]`
suggested above is `System.Collections.Generic.Stack[int]`. The complete name for the type
`Dictionary[int,string]` suggested above is `System.Collections.Generic.Dictionary[int,string]`.

## 7.2 Unary operators

Syntax:

```Syntax
unary-expression:
    primary-expression
    expression-with-unary-operator

expression-with-unary-operator:
    , new-lines~opt~ unary-expression
    -not new-lines~opt~ unary-expression
    ! new-lines~opt~ unary-expression
    -bnot new-lines~opt~ unary-expression
    + new-lines~opt~ unary-expression
    dash new-lines~opt~ unary-expression
    pre-increment-expression
    pre-decrement-expression
    cast-expression
    -split new-lines~opt~ unary-expression
    -join new-lines~opt~ unary-expression

dash:*
    - (U+002D)
    EnDash character (U+2013)
    EmDash character (U+2014)
    Horizontal bar character (U+2015)

pre-increment-expression:
    ++ new-lines~opt~ unary-expression

pre-decrement-expression:
    dashdash new-lines~opt~ unary-expression

cast-expression:
    type-literal unary-expression

dashdash:
    dash dash
```

### 7.2.1 Unary comma operator

Description:

This operator creates an unconstrained 1-dimensional array having one element, whose type and value
are that of *unary-expression*.

This operator is right associative.

Examples:

```powershell
$a = ,10         # create an unconstrained array of 1 element, $a[0],
                 # which has type int

$a = ,(10,"red") # create an unconstrained array of 1 element,
$a[0],
                 # which is an unconstrained array of 2 elements,
                 # $a[0][0] an int, and $a[0][1] a string

$a = ,,10        # create an unconstrained array of 1 element, which is
                 # an unconstrained array of 1 element, which is an int
                 # $a[0][0] is the int. Contrast this with @(@(10))
```

### 7.2.2 Logical NOT

Description:

The operator -not converts the value designated by *unary-expression* to type bool ([§6.2][§6.2]), if
necessary, and produces a result of that type. If *unary-expression*'s value is True, the result is
False, and vice versa. The operator ! is an alternate spelling for -not.

This operator is right associative.

Examples:

```powershell
-not $true         # False
-not -not $false   # False
-not 0             # True
-not 1.23          # False
!"xyz"             # False
```

### 7.2.3 Bitwise NOT

Description:

The operator -bnot converts the value designated by *unary-expression* to an integer type
([§6.4][§6.4]), if necessary. If the converted value can be represented in type int then that is the
result type. Else, if the converted value can be represented in type long then that is the result
type. Otherwise, the expression is ill formed. The resulting value is the ones-complement of the
converted value.

This operator is right associative.

Examples:

```powershell
-bnot $true         # int with value 0xFFFFFFFE
-bnot 10            # int with value 0xFFFFFFF5
-bnot 2147483648.1  # long with value 0xFFFFFFFF7FFFFFFF
-bnot $null         # int with value 0xFFFFFFFF
-bnot "0xabc"       # int with value 0xFFFFF543
```

### 7.2.4 Unary plus

Description:

An expression of the form +*unary-expression* is treated as if it were written as
`0 + unary-expression` ([§7.7][§7.7]). The integer literal 0 has type `int`.

This operator is right associative.

Examples:

```powershell
+123L         # type long, value 123
+0.12340D     # type decimal, value 0.12340
+"0xabc"      # type int, value 2748
```

### 7.2.5 Unary minus

Description:

An expression of the form -*unary-expression* is treated as if it were written as
`0 - unary-expression` ([§7.7][§7.7]). The integer literal 0 has type `int`.

This operator is right associative.

Examples:

-$true # type int, value -1
-123L # type long, value -123
-0.12340D # type decimal, value -0.12340

### 7.2.6 Prefix increment and decrement operators

Description:

The *unary-expression* must designate a writable location having a value of numeric type (§4) or the
value `$null`. If the value designated by its *unary-expression* is `$null`, *unary-expression*'s
value is converted to type int and value zero before the operator is evaluated.

> [!NOTE]
> The type of the value designated by *unary-expression* may change when the result is stored. See
> [§7.11][§7.11] for a discussion of type change via assignment.

For the prefix `++` operator, the value of *unary-expression* is incremented by 1 of the appropriate
type. The result is the new value after incrementing has taken place. The expression `++E` is
equivalent to `E += 1` ([§7.11.2][§7.11.2]).

For the prefix `--` operator, the value of *unary-expression* is decremented by 1 of the appropriate
type. The result is the new value after decrementing has taken place. The expression `--E` is
equivalent to `E -= 1` ([§7.11.2][§7.11.2]).

These operators are right associative.

Examples:

```powershell
$i = 0                # $i = 0
$++i                  # $i is incremented by 1
$j = --$i             # $i is decremented then $j takes on the value of $i

$a = 1,2,3
$b = 9,8,7
$i = 0;
$j = 1
$b[--$j] = $a[++$i]   # $j is # decremented, $i incremented, then $b[0]
                      # takes on the value of $a[1]

$i = 2147483647       # $i holds a value of type int
++$i                  # $i now holds a value of type double because
                      # 2147483648 is too big to fit in type int

[int]$k = 0           # $k is constrained to int
$k = [int]::MinValue  # $k is set to -2147483648
$--k                  # -2147483649 is too small to fit, imp-def behavior

$x = $null            # target is unconstrained, $null goes to [int]0
$--x                  # value treated as int, 0->-1
```

### 7.2.7 The unary -join operator

Description:

The unary `-join` operator produces a string that is the concatenation of the value of one or more
objects designated by *unary-expression*. (A separator can be inserted by using the binary version
of this operator ([§7.8.4.4][§7.8.4.4]).)

*unary-expression* can be a scalar value or a collection.

Examples:

```powershell
-join (10, 20, 30)             # result is "102030"
-join (123, $false, 19.34e17)  # result is "123False1.934E+18"
-join 12345                    # result is "12345"
-join $null                    # result is ""
```

### 7.2.8 The unary -split operator

Description:

The unary `-split` operator splits one or more strings designated by *unary-expression*, returning
their subparts in a constrained 1-dimensional array of string. It treats any contiguous group of
white space characters as the delimiter between successive subparts. (An explicit delimiter string
can be specified by using the binary version of this operator ([§7.8.4.5][§7.8.4.5]).) This operator has two
variants ([§7.8][§7.8]).

The delimiter text is not included in the resulting strings. Leading and trailing white space in the
input string is ignored. An input string that is empty or contains white space only results in an
array of 1 string, which is empty.

*unary-expression* can designate a scalar value or an array of strings.

Examples:

```powershell
-split " red\`tblue\`ngreen " # 3 strings: "red", "blue", "green"
-split ("yes no", "up down") # 4 strings: "yes", "no", "up", "down"
-split " " # 1 (empty) string
```

### 7.2.9 Cast operator

Description:

This operator converts explicitly (§6) the value designated by *unary-expression* to the type
designated by *type-literal*. If *type-literal* is other than void, the type of the result is the
named type, and the value is the value after conversion. If *type-literal* is void, no object is
written to the pipeline and there is no result.

When an expression of any type is cast to that same type, the resulting type and value is the
*unary-expression*'s type and value.

This operator is right associative.

Examples:

```powershell
[bool]-10        # a bool with value True
[int]-10.70D     # a decimal with value -10
[int]10.7        # an int with value 11
[long]"+2.3e+3"  # a long with value 2300
[char[]]"Hello"  # an array of 5 char with values H, e, l, l, and o.
```

## 7.3 Binary comma operator

Syntax:

```Syntax
array-literal-expression:
    unary-expression
    unary-expression , new-lines~opt~ array-literal-expression
```

Description:

The binary comma operator creates a 1-dimensional array whose elements are the values designated by
its operands, in lexical order. The array has unconstrained type.

Examples:

```powershell
2,4,6                    # Length 3; values 2,4,6
(2,4),6                  # Length 2; values [object[]],int
(2,4,6),12,(2..4)        # Length 3; [object[]],int,[object[]]
2,4,6,"red",$null,$true  # Length 6
```

The addition of grouping parentheses to certain binary comma expressions does not document the
default precedence; instead, it changes the result.

## 7.4 Range operator

Syntax:

```Syntax
range-expression:
array-literal-expression
range-expression *..* new-lines~opt~
array-literal-expression
```

Description:

A *range-expression* creates an unconstrained 1-dimensional array whose elements are the values of
the int sequence specified by the range bounds. The values designated by the operands are converted
to int, if necessary ([§6.4][§6.4]). The operand designating the lower value after conversion is the
*lower bound*, while the operand designating the higher value after conversion is the *upper bound*.
Both bounds may be the same, in which case, the resulting array has length 1. If the left operand
designates the lower bound, the sequence is in ascending order. If the left operand designates the
upper bound, the sequence is in descending order.

Conceptually, this operator is a shortcut for the corresponding binary comma operator sequence. For
example, the range `5..8` can also be generated using `5,6,7,8`. However, if an ascending or
descending sequence is needed without having an array, an implementation may avoid generating an
actual array. For example, in `foreach ($i in 1..5) { ... }`, no array need be created.

A *range-expression* can be used to specify an array slice ([§9.9][§9.9]).

Examples:

```powershell
1..10        # ascending range 1..10
-500..-495   # descending range -500..-495
16..16       # sequence of 1

$x = 1.5
$x..5.40D    # ascending range 2..5

$true..3     # ascending range 1..3
-2..$null    # ascending range -2..0
"0xf".."0xa" # descending range 15..10
```

## 7.5 Format operator

Syntax:

```Syntax
format-expression:
    range-expression
    format-expression format-operator new-lines~opt~ range-expression

format-operator:
    dash f

dash:
    - (U+002D)
    EnDash character (U+2013)
    EmDash character (U+2014)
    Horizontal bar character (U+2015)
```

Description:

A format-expression formats one or more values designated by *range-expression* according to a
*format specification string* designated by *format-expression*. The positions of the values
designated by *range-expression* are numbered starting at zero and increasing in lexical order. The
result has type `string`.

A format specification string may contain zero or more format specifications each having the
following form:

`{N [ ,M ][ : FormatString ]}`

*N* represents a (required) *range-expression* value position, *M* represents the (optional) minimum
display width, and *FormatString* indicates the (optional) format. If the width of a formatted value
exceeds the specified width, the width is increased accordingly. Values whose positions are not
referenced in *FormatString* are ignored after being evaluated for any side effects. If *N* refers
to a non-existent position, the behavior is implementation defined. Value of type `$null` and void
are formatted as empty strings. Arrays are formatted as for *sub-expression* ([§7.1.6][§7.1.6]). To
include the characters "{" and "}" in a format specification without their being interpreted as
format delimiters, write them as "{{" and "}}", respectively.

For a complete definition of format specifications, see the type `System.IFormattable` in Ecma
Technical Report TR/84.

Examples:

```powershell
`$i` = 10; $j = 12
"{2} <= {0} + {1}\`n" -f $i,$j,($i+$j)  # 22 <= 10 + 12
">{0,3}<" -f 5                          # > 5<
">{0,-3}<" -f 5                         # >5 <
">{0,3:000}<" -f 5                      # >005<
">{0,5:0.00}<" -f 5.0                   # > 5.00<
">{0:C}<" -f 1234567.888                # >$1,234,567.89<
">{0:C}<" -f -1234.56                   # >($1,234.56)<
">{0,12:e2}<" -f 123.456e2              # > 1.23e+004<
">{0,-12:p}<" -f -0.252                 # >-25.20 % <
$format = ">{0:x8}<"
$format -f 123455                       # >0001e23f<
```

In a format specification if *N* refers to a non-existent position, a **FormatError** is raised.

## 7.6 Multiplicative operators

Syntax:

```Syntax
multiplicative-expression:
    format-expression
    multiplicative-expression * new-lines~opt~ format-expression
    multiplicative-expression / new-lines~opt~ format-expression
    multiplicative-expression % new-lines~opt~ format-expression
```

### 7.6.1 Multiplication

Description:

The result of the multiplication operator `*` is the product of the values designated by the two
operands after the usual arithmetic conversions ([§6.15][§6.15]) have been applied.

This operator is left associative.

Examples:

```powershell
12 * -10L      # long result -120
-10.300D * 12  # decimal result -123.600
10.6 * 12      # double result 127.2
12 * "0xabc"   # int result 32976
```

### 7.6.2 String replication

Description:

When the left operand designates a string the binary `*` operator creates a new string that contains
the one designated by the left operand replicated the number of times designated by the value of the
right operand as converted to integer type ([§6.4][§6.4]).

This operator is left associative.

Examples:

```powershell
"red" * "3"       # string replicated 3 times
"red" * 4         # string replicated 4 times
"red" * 0         # results in an empty string
"red" * 2.3450D   # string replicated twice
"red" * 2.7       # string replicated 3 times
```

### 7.6.3 Array replication

Description:

When the left operand designates an array the binary `*` operator creates a new unconstrained
1‑dimensional array that contains the value designated by the left operand replicated the number of
times designated by the value of the right operand as converted to integer type ([§6.4][§6.4]). A
replication count of zero results in an array of length 1. If the left operand designates a
multidimensional array, it is flattened ([§9.12][§9.12]) before being used.

This operator is left associative.

Examples:

```powershell
$a = [int[]](10,20)              # [int[]], Length 2*1
$a * "3"                         # [object[]], Length 2*3
$a * 4                           # [object[]], Length 2*4
$a * 0                           # [object[]], Length 2*0
$a * 2.3450D                     # [object[]], Length 2*2
$a * 2.7                         # [object[]], Length 2*3
(New-Object 'float[,]' 2,3) * 2  # [object[]], Length 2*2
```

### 7.6.4 Division

Description:

The result of the division operator `/` is the quotient when the value designated by the left
operand is divided by the value designated by the right operand after the usual arithmetic
conversions ([§6.15][§6.15]) have been applied.

If an attempt is made to perform integer or decimal division by zero, an implementation-defined
terminating error is raised.

This operator is left associative.

Examples:

```powershell
10/-10      # int result -1
12/-10      # double result -1.2
12/-10D     # decimal result 1.2
12/10.6     # double result 1.13207547169811
12/"0xabc"  # double result 0.00436681222707424
```

If an attempt is made to perform integer or decimal division by zero, a **RuntimeException**
exception is raised.

### 7.6.5 Remainder

Description:

The result of the remainder operator `%` is the remainder when the value designated by the left
operand is divided by the value designated by the right operand after the usual arithmetic
conversions ([§6.15][§6.15]) have been applied.

If an attempt is made to perform integer or decimal division by zero, an implementation-defined
terminating error is raised.

Examples:

```powershell
10 % 3          # int result 1
10.0 % 0.3      # double result 0.1
10.00D % "0x4"  # decimal result 2.00
```

If an attempt is made to perform integer or decimal division by zero, a **RuntimeException**
exception is raised.

## 7.7 Additive operators

Syntax:

```Syntax
additive-expression:
    multiplicative-expression
    additive-expression + new-lines~opt~ multiplicative-expression
    additive-expression dash new-lines~opt~ multiplicative-expression
```

### 7.7.1 Addition

Description:

The result of the addition operator `+` is the sum of the values designated by the two operands
after the usual arithmetic conversions ([§6.15][§6.15]) have been applied.

This operator is left associative.

Examples:

```powershell
12 + -10L       # long result 2
-10.300D + 12   # decimal result 1.700
10.6 + 12       # double result 22.6
12 + "0xabc"    # int result 2760
```

### 7.7.2 String concatentaion

Description:

When the left operand designates a string the binary `+` operator creates a new string that contains
the value designated by the left operand followed immediately by the value(s) designated by the
right operand as converted to type string ([§6.8][§6.8]).

This operator is left associative.

Examples:

```powershell
"red" + "blue"      # "redblue"
"red" + "123"       # "red123"
"red" + 123         # "red123"
"red" + 123.456e+5  # "red12345600"
"red" + (20,30,40)  # "red20 30 40"
```

### 7.7.3 Array concatenation

Description:

When the left operand designates an array the binary `+` operator creates a new unconstrained
1‑dimensional array that contains the elements designated by the left operand followed immediately
by the value(s) designated by the right operand. Multidimensional arrays present in either operand
are flattened ([§9.12][§9.12]) before being used.

This operator is left associative.

Examples:

```powershell
$a = [int[]](10,20)               # [int[]], Length 2
$a + "red"                        # [object[]], Length 3
$a + 12.5,$true                   # [object[]], Length 4
$a + (New-Object 'float[,]' 2,3)  # [object[]], Length 8
(New-Object 'float[,]' 2,3) + $a  # [object[]], Length 8
```

### 7.7.4 Hashtable concatenation

Description:

When both operands designate Hashtables the binary `+` operator creates a new Hashtable that
contains the elements designated by the left operand followed immediately by the elements designated
by the right operand.

If the Hashtables contain the same key, an implementation-defined terminating error is raised.

This operator is left associative.

Examples:

```powershell
$h1 = @{ FirstName = "James"; LastName = "Anderson" }
$h2 = @{ Dept = "Personnel" }
$h3 = $h1 + $h2      # new Hashtable, Count = 3
```

If the Hashtables contain the same key, an exception of type **BadOperatorArgument** is raised.

### 7.7.5 Subtraction

Description:

The result of the subtraction operator `-` is the difference when the value designated by the right
operand is subtracted from the value designated by the left operand after the usual arithmetic
conversions ([§6.15][§6.15]) have been applied.

This operator is left associative.

Examples:

```powershell
12 - -10L      # long result 2c
-10.300D - 12  # decimal result -22.300
10.6 - 12      # double result -1.4
12 - "0xabc"   # int result -2736
```

## 7.8 Comparison operators

Syntax:

```Syntax
comparison-operator: one of
    dash as           dash ccontains     dash ceq
    dash cge          dash cgt           dash cle
    dash clike        dash clt           dash cmatch
    dash cne          dash cnotcontains  dash cnotlike
    dash cnotmatch    dash contains      dash creplace
    dash csplit       dash eq            dash ge
    dash gt           dash icontains     dash ieq
    dash ige          dash igt           dash ile
    dash ilike        dash ilt           dash imatch
    dash in           dash ine           dash inotcontains
    dash inotlike     dash inotmatch     dash ireplace
    dash is           dash isnot         dash isplit
    dash join         dash le            dash like
    dash lt           dash match         dash ne
    dash notcontains  dash notin         dash notlike
    dash notmatch     dash replace       dash shl
    dash shr          dash split

dash:
    - (U+002D)
    EnDash character (U+2013)
    EmDash character (U+2014)
    Horizontal bar character (U+2015)
```

Description:

The type of the value designated by the left operand determines how the value designated by the
right operand is converted (§6), if necessary, before the comparison is done.

Some *comparison-operator*s (written here as -*op*) have two variants, one that is case sensitive
(-c*op*), and one that is not (-i*op*). The -*op* version is equivalent to -i*op*. Case sensitivity
is meaningful only with comparisons of values of type string. In non-string comparison contexts, the
two variants behave the same.

These operators are left associative.

### 7.8.1 Equality and relational operators

Description:

There are two *equality* *operators*: equality (`-eq`) and inequality (`-ne`); and four *relational
operators*: less-than (`-lt`), less-than-or-equal-to (`-le`), greater-than (`-gt`), and
greater-than-or-equal-to (`-ge`). Each of these has two variants ([§7.8][§7.8]).

For two strings to compare equal, they must have the same length and contents, and letter case, if
appropriate.

If the value designated by the left operand is not a collection, the result has type `bool`.
Otherwise, the result is a possibly empty unconstrained 1-dimensional array containing the elements
of the collection that test True when compared to the value designated by the right operand.

Examples:

```powershell
10 -eq "010"           # True, int comparison
"010" -eq 10           # False, string comparison
"RED" -eq "Red"        # True, case-insensitive comparison
"RED" -ceq "Red"       # False, case-sensitive comparison
"ab" -lt "abc"         # True

10,20,30,20,10 -ne 20  # 10,30,10, Length 3
10,20,30,20,10 -eq 40  # Length 0
10,20,30,20,10 -ne 40  # 10,20,30,20,10, Length 5
10,20,30,20,10 -gt 25  # 30, Length 1
0,1,30 -ne $true       # 0,30, Length 2
0,"00" -eq "0"         # 0 (int), Length 1
```

### 7.8.2 Containment operators

Description:

There are four *containment* *operators*: contains (`-contains`), does-not-contain (`‑notcontains`),
in (`-in`) and not-in (`-notin`). Each of these has two variants ([§7.8][§7.8]).

The containment operators return a result of type bool that indicates whether a value occurs (or
does not occur) at least once in the elements of an array. With `-contains` and `‑notcontains`, the
value is designated by the right operand and the array is designated by the left operand. With -in
and `-notin`, the operands are reversed. The value is designated by the left operand and the array
is designated by the right operand.

For the purposes of these operators, if the array operand has a scalar value, the scalar value is
treated as an array of one element.

Examples:

```powershell
10,20,30,20,10 -contains 20     # True
10,20,30,20,10 -contains 42.9   # False
10,20,30 -contains "10"         # True
"010",20,30 -contains 10        # False
10,20,30,20,10 -notcontains 15  # True
"Red",20,30 -ccontains "RED"    # False
```

### 7.8.3 Type testing and conversion operators

Description:

The type operator `-is` tests whether the value designated by the left operand has the type, or is
derived from a type that has the type, designated by the right operand. The right operand must
designate a type or a value that can be converted to a type (such as a string that names a type).
The type of the result is `bool`. The type operator `-isnot` returns the logical negation of the
corresponding `-is` form.

The type operator `-as` attempts to convert the value designated by the left operand to the type
designated by the right operand. The right operand must designate a type or a value that can be
converted to a type (such as a string that names a type). If the conversion fails, `$null` is
returned; otherwise, the converted value is returned and the return type of that result is the
runtime type of the converted value.

Examples:

```powershell
$a = 10            # value 10 has type int
$a -is [int]       # True

$t = [int]
$a -isnot $t       # False
$a -is "int"       # True
$a -isnot [double] # True

$x = [int[]](10,20)
$x -is [int[]]     # True

$a = "abcd"        # string is derived from object
$a -is [object]    # True

$x = [double]
foreach ($t in [int],$x,[decimal],"string") {
    $b = (10.60D -as $t) * 2  # results in int 22, double 21.2
}                             # decimal 21.20, and string "10.6010.60"
```

### 7.8.4 Pattern matching and text manipulation operators

#### 7.8.4.1 The -like and -notlike operators

Description:

If the left operand does not designate a collection, the result has type `bool`. Otherwise, the
result is a possibly empty unconstrained 1-dimensional array containing the elements of the
collection that test True when compared to the value designated by the right operand. The right
operand may designate a string that contains wildcard expressions ([§3.15][§3.15]). These operators have
two variants ([§7.8][§7.8]).

Examples:

```powershell
"Hello" -like "h*"                   # True, starts with h
"Hello" -clike "h*"                  # False, does not start with lowercase h
"Hello" -like "*l*"                  # True, has an l in it somewhere
"Hello" -like "??l"                  # False, no length match

"-abc" -like "[-xz]*"                # True, - is not a range separator
"#$%\^&" -notlike "*[A-Za-z]"        # True, does not end with alphabetic character
"He" -like "h[aeiou]?*"              # False, need at least 3 characters
"When" -like "*[?]"                  # False, ? is not a wildcard character
"When?" -like "*[?]"                 # True, ? is not a wildcard character

"abc","abbcde","abcgh" -like "abc*"  # object[2], values
"abc" and "abcgh"
```

#### 7.8.4.2 The -match and -notmatch operators

Description:

If the left operand does not designate a collection, the result has type `bool` and if that result
is `$true`, the elements of the Hashtable `$matches` are set to the strings that match (or
do-not-match) the value designated by the right operand. Otherwise, the result is a possibly empty
unconstrained 1-dimensional array containing the elements of the collection that test True when
compared to the value designated by the right operand, and `$matches` is not set. The right operand
may designate a string that contains regular expressions ([§3.16][§3.16]), in which case, it is referred
to as a *pattern*. These operators have two variants ([§7.8][§7.8]).

These operators support submatches ([§7.8.4.6][§7.8.4.6]).

Examples:

```powershell
"Hello" -match ".l"                    # True, $matches key/value is 0/"el"
"Hello" -match '\^h.*o$'               # True, $matches key/value is
0/"Hello"
"Hello" -cmatch '\^h.*o$'              # False, $matches not set
"abc\^ef" -match ".\\\^e"              # True, $matches key/value is 0/"c\^e"

"abc" -notmatch "[A-Za-z]"             # False
"abc" -match "[\^A-Za-z]"              # False
"He" -match "h[aeiou]."                # False, need at least 3 characters
"abc","abbcde","abcgh" -match "abc.*"  # Length is 2, values "abc", "abcgh"
```

#### 7.8.4.3 The -replace operator

Description:

The `-replace` operator allows text replacement in one or more strings designated by the left
operand using the values designated by the right operand. This operator has two variants
([§7.8][§7.8]). The right operand has one of the following forms:

- The string to be located, which may contain regular expressions ([§3.16][§3.16]). In this case, the
  replacement string is implicitly "".
- An array of 2 objects containing the string to be located, followed by the replacement string.

If the left operand designates a string, the result has type string. If the left operand designates
a 1‑dimensional array of string, the result is an unconstrained 1-dimensional array, whose length is
the same as for left operand's array, containing the input strings after replacement has completed.

This operator supports submatches ([§7.8.4.6][§7.8.4.6]).

Examples:

```powershell
"Analogous","an apple" -replace "a","*"      # "*n*logous","*n *pple"
"Analogous" -creplace "[aeiou]","?"          # "An?l?g??s"
"Analogous","an apple" -replace '\^a',"%%A"  # "%%Analogous","%%An apple"
"Analogous" -replace "[aeiou]",'$&$&'        # "AAnaaloogoouus"
```

#### 7.8.4.4 The binary -join operator

Description:

The binary `-join` operator produces a string that is the concatenation of the value of one or more
objects designated by the left operand after having been converted to string ([§6.7][§6.7]), if
necessary. The string designated by the right operand is used to separate the (possibly empty)
values in the resulting string.

The left operand can be a scalar value or a collection.

Examples:

```powershell
(10, 20, 30) -join "\|"    # result is "10\|20\|30"
12345 -join ","            # result is "12345", no separator needed
($null,$null) -join "<->"  # result is "<->", two zero-length values
```

#### 7.8.4.5 The binary -split operator

Description:

The binary `-split` operator splits one or more strings designated by the left operand, returning
their subparts in a constrained 1-dimensional array of string. This operator has two variants
([§7.8][§7.8]). The left operand can designate a scalar value or an array of strings. The right operand
has one of the following forms:

- A *delimiter string*
- An array of 2 objects containing a delimiter string followed by a numeric *split count*
- An array of 3 objects containing a delimiter string, a numeric split count, and an *options
  string*
- A script block
- An array of 2 objects containing a script block followed by a numeric split count

The delimiter string may contain regular expressions ([§3.16][§3.16]). It is used to locate subparts with
the input strings. The delimiter is not included in the resulting strings. If the left operand
designates an empty string, that results in an empty string element. If the delimiter string is an
empty string, it is found at every character position in the input strings.

By default, all subparts of the input strings are placed into the result as separate elements;
however, the split count can be used to modify this behavior. If that count is negative, zero, or
greater than or equal to the number of subparts in an input string, each subpart goes into a
separate element. If that count is less than the number of subparts in the input string, there are
count elements in the result, with the final element containing all of the subparts beyond the first
**count - 1** subparts.

An options string contains zero or more *option names* with each adjacent pair separated by a comma.
Leading, trailing, and embedded white space is ignored. Option names may be in any order and are
case-sensitive.

If an options string contains the option name **SimpleMatch**, it may also contain the option name
**IgnoreCase**. If an options string contains the option name **RegexMatch** or it does not contain
either **RegexMatch** or **SimpleMatch**, it may contain any option name except **SimpleMatch**.
However, it must not contain both **Multiline** and **Singleline**.

Here is the set of option names:

|       **Option**        |                                           **Description**                                            |
| ----------------------- | ---------------------------------------------------------------------------------------------------- |
| CultureInvariant        | Ignores cultural differences in language when evaluating the delimiter.                              |
| ExplicitCapture         | Ignores non-named match groups so that only explicit capture groups are returned in the result list. |
| IgnoreCase              | Force case-insensitive matching, even if `-csplit` is used.                                          |
| IgnorePatternWhitespace | Ignores unescaped white space and comments marked with the number sign (#).                          |
| Multiline               | This mode recognizes the start and end of lines and strings. The default mode is **Singleline**.     |
| RegexMatch              | Use regular expression matching to evaluate the delimiter. This is the default.                      |
| SimpleMatch             | Use simple string comparison when evaluating the delimiter.                                          |
| Singleline              | This mode recognizes only the start and end of strings. It is the default mode.                      |

The script block ([§7.1.8][§7.1.8]) specifies the rules for determining the delimiter, and must evaluate
to type bool.

Examples:

```powershell
"one,forty two,," -split ","              # 5 strings: "one" "forty two" "" ""

"abc","de" -split ""                      # 9 strings: "" "a" "b" "c" "" "" "d" "e" ""

"ab,cd","1,5,7,8" -split ",", 2           # 4 strings: "ab" "cd" "1" "5,7,8"

"10X20x30" -csplit "X", 0, "SimpleMatch"  # 2 strings: "10" "20x30"

"analogous" -split "[AEIOU]", 0, "RegexMatch, IgnoreCase"
                                          # 6 strings: "" "n" "l" "g" "" "s"

"analogous" -split { $_ -eq "a" -or $_ -eq "o" }, 4
                                          # 4 strings: "" "n" "l" "gous"
```

#### 7.8.4.6 Submatches

The pattern being matched by `-match`, `-notmatch`, and `-replace` may contain subparts (called
*submatches*) delimited by parentheses. Consider the following example:

`"red" -match "red"`

The result is `$true` and key 0 of `$matches` contains "red", that part of the string designated by
the left operand that exactly matched the pattern designated by the right operand.

In the following example, the whole pattern is a submatch:

`"red" -match "(red)"`

As before, key 0 contains "red"; however, key 1 also contains "red", which is that part of the
string designated by the left operand that exactly matched the submatch.

Consider the following, more complex, pattern:

`"red" -match "((r)e)(d)"`

This pattern allows submatches of "r", "re", "d", or "red".

Again, key 0 contains "red". Key 1 contains "re", key 2 contains "r", and key 3 contains "d". The
key/value pairs are in matching order from left-to-right in the pattern, with longer string matches
preceding shorter ones.

In the case of `-replace`, the replacement text can access the submatches via names of the form
`$n`, where the first match is `$1`, the second is `$3`, and so on. For example,

```powershell
"Monday morning" -replace '(Monday|Tuesday) (morning|afternoon|evening)','the $2 of $1'
```

The resulting string is "the morning of Monday".

Instead of having keys in `$matches` be zero-based indexes, submatches can be named using the form
`?<*name*>`. For example, `"((r)e)(d)"` can be written with three named submatches, m1, m2, and m3,
as follows: `"(?<m1>(?<m2>r)e)(?<m3>d)"`.

### 7.8.5 Shift operators

Description:

The shift left (`-shl`) operator and shift right (`-shr`) operator convert the value designed by the
left operand to an integer type and the value designated by the right operand to int, if necessary,
using the usual arithmetic conversions ([§6.15][§6.15]).

The shift left operator shifts the left operand left by a number of bits computed as described
below. The low-order empty bit positions are set to zero.

The shift right operator shifts the left operand right by a number of bits computed as described
below. The low-order bits of the left operand are discarded, the remaining bits shifted right. When
the left operand is a signed value, the high-order empty bit positions are set to zero if the left
operand is non-negative and set to one if the left operand is negative. When the left operand is an
unsigned value, the high-order empty bit positions are set to zero.

When the left operand has type int, the shift count is given by the low-order five bits of the right
operand. When the right operand has type long, the shift count is given by the low-order six bits of
the right operand.

Examples:

```powershell
0x0408 -shl 1             # int with value 0x0810
0x0408 -shr 3             # int with value 0x0081
0x100000000 -shr 0xfff81  # long with value 0x80000000
```

## 7.9 Bitwise operators

Syntax:

```Syntax
bitwise-expression:
    comparison-expression
    bitwise-expression -band new-lines~opt~ comparison-expression
    bitwise-expression -bor new-lines~opt~ comparison-expression
    bitwise-expression -bxor new-lines~opt~ comparison-expression
```

Description:

The bitwise AND operator `-band`, the bitwise OR operator `-bor`, and the bitwise XOR operator -bxor
convert the values designated by their operands to integer types, if necessary, using the usual
arithmetic conversions ([§6.15][§6.15]). After conversion, if both values have type int that is the type
of the result. Otherwise, if both values have type long, that is the type of the result. If one
value has type int and the other has type long, the type of the result is long. Otherwise, the
expression is ill formed. The result is the bitwise AND, bitwise OR, or bitwise XOR, respectively,
of the possibly converted operand values.

These operators are left associative. They are commutative if neither operand contains a side
effect.

Examples:

```powershell
0x0F0F -band 0xFE    # int with value 0xE
0x0F0F -band 0xFEL   # long with value 0xE
0x0F0F -band 14.6    # long with value 0xF

0x0F0F -bor 0xFE     # int with value 0xFFF
0x0F0F -bor 0xFEL    # long with value 0xFFF
0x0F0F -bor 14.40D   # long with value 0xF0F

0x0F0F -bxor 0xFE    # int with value 0xFF1
0x0F0F -bxor 0xFEL   # long with value 0xFF1
0x0F0F -bxor 14.40D  # long with value 0xF01
0x0F0F -bxor 14.6    # long with value 0xF00
```

## 7.10 Logical operators

Syntax:

```Syntax
logical-expression:
    bitwise-expression
    logical-expression -and new-lines~opt~ bitwise-expression
    logical-expression -or new-lines~opt~ bitwise-expression
    logical-expression -xor new-lines~opt~ bitwise-expression
```

Description:

The logical AND operator `-and` converts the values designated by its operands to `bool`, if
necessary ([§6.2][§6.2]). The result is the logical AND of the possibly converted operand values, and
has type `bool`. If the left operand evaluates to False the right operand is not evaluated.

The logical OR operator `-or` converts the values designated by its operands to `bool`, if necessary
([§6.2][§6.2]). The result is the logical OR of the possibly converted operand values, and has type
`bool`. If the left operand evaluates to True the right operand is not evaluated.

The logical XOR operator `-xor` converts the values designated by its operands to `bool`
([§6.2][§6.2]). The result is the logical XOR of the possibly converted operand values, and has type
`bool`.

These operators are left associative.

Examples:

```powershell
$j = 10
$k = 20
($j -gt 5) -and (++$k -lt 15)   # True -and False -> False
($j -gt 5) -and ($k -le 21)     # True -and True -> True
($j++ -gt 5) -and ($j -le 10)   # True -and False -> False
($j -eq 5) -and (++$k -gt 15)   # False -and True -> False

$j = 10
$k = 20
($j++ -gt 5) -or (++$k -lt 15)  # True -or False -> True
($j -eq 10) -or ($k -gt 15)     # False -or True -> True
($j -eq 10) -or (++$k -le 20)   # False -or False -> False

$j = 10
$k = 20
($j++ -gt 5) -xor (++$k -lt 15) # True -xor False -> True
($j -eq 10) -xor ($k -gt 15)    # False -xor True -> True
($j -gt 10) -xor (++$k -le 25)  # True -xor True -> False
```

## 7.11 Assignment operators

Syntax:

```Syntax
assignment-expression:
    expression assignment-operator statement

assignment-operator: *one of
    =   dash =   +=   *=   /=   %=
```

Description:

An assignment operator stores a value in the writable location designated by *expression*. For a
discussion of *assignment-operator* `=` see [§7.11.1][§7.11.1]. For a discussion of all other
*assignment-operator*s see [§7.11.2][§7.11.2].

An assignment expression has the value designated by *expression* after the assignment has taken
place; however, that assignment expression does not itself designate a writable location. If
*expression* is type-constrained ([§5.3][§5.3]), the type used in that constraint is the type of the
result; otherwise, the type of the result is the type after the usual arithmetic conversions
([§6.15][§6.15]) have been applied.

This operator is right associative.

### 7.11.1 Simple assignment

Description:

In *simple assignment* (`=`), the value designated by *statement* replaces the value stored in the
writable location designated by *expression*. However, if *expression* designates a non-existent key
in a Hashtable, that key is added to the Hashtable with an associated value of the value designated
by *statement*.

As shown by the grammar, *expression* may designate a comma-separated list of writable locations.
This is known as *multiple assignment*. *statement* designates a list of one or more comma-separated
values. The commas in either operand list are part of the multiple-assignment syntax and do *not*
represent the binary comma operator. Values are taken from the list designated by *statement*, in
lexical order, and stored in the corresponding writable location designated by *expression*. If the
list designated by *statement* has fewer values than there are *expression* writable locations, the
excess locations take on the value `$null`. If the list designated by *statement* has more values
than there are *expression* writable locations, all but the right-most *expression* location take on
the corresponding *statement* value and the right-most *expression* location becomes an
unconstrained 1-dimensional array with all the remaining *statement* values as elements.

For statements that have values ([§8.1.2][§8.1.2]), *statement* can be a statement.

Examples:

```powershell
$a = 20; $b = $a + 12L             # $b has type long, value 22
$hypot = [Math]::Sqrt(3*3 + 4*4)   # type double, value 5
$a = $b = $c = 10.20D              # all have type decimal, value 10.20
$a = (10,20,30),(1,2)              # type [object[]], Length 2
[int]$x = 10.6                     # type int, value 11
[long]$x = "0xabc"                 # type long, value 0xabc
$a = [float]                       # value type literal [float]
$i,$j,$k = 10,"red",$true          # $i is 10, $j is "red", $k is True
$i,$j = 10,"red",$true             # $i is 10, $j is [object[]], Length 2
$i,$j = (10,"red"),$true           # $i is [object[]], Length 2, $j is True
$i,$j,$k = 10                      # $i is 10, $j is $null, $k is $null

$h = @{}
[int] $h.Lower, [int] $h.Upper = -split "10 100"

$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
$h1.Dept = "Finance"               # adds element Finance
$h1["City"] = "New York"           # adds element City

[int]$Variable:v = 123.456         # v takes on the value 123
${E:output.txt} = "a"              # write text to the given file
$Env:MyPath = "x:\data\file.txt"   # define the environment variable
$Function:F = { param ($a, $b) "Hello there, $a, $b" }
F 10 "red"                         # define and invoke a function
function Demo { "Hi there from inside Demo" }
$Alias:A = "Demo"                  # create alias for function Demo
A                                  # invoke function Demo via the alias
```

### 7.11.2 Compound assignment

Description:

A *compound assignment* has the form `E1 op= E2`, and is equivalent to the simple assignment
expression `E1 = E1 op (E2)` except that in the compound assignment case the expression *E1* is
evaluated only once. If *expression* is type-constrained ([§5.3][§5.3]), the type used in that
constraint is the type of the result; otherwise, the type of the result is determined by *op*. For
`*=`, see [§7.6.1][§7.6.1], [§7.6.2][§7.6.2], [§7.6.3][§7.6.3]; for `/=`, see [§7.6.4][§7.6.4]; for `%=`, see [§7.6.5][§7.6.5];
for `+=`, see [§7.7.1][§7.7.1], [§7.7.2][§7.7.2], [§7.7.3][§7.7.3]; for `-=`, see [§7.7.5][§7.7.5].

> [!NOTE]
> An operand designating an unconstrained value of numeric type may have its type changed by an
> assignment operator when the result is stored.

Examples:

```powershell
$a = 1234; $a *= (3 + 2)  # type is int, value is 1234 * (3 + 2)
$b = 10,20,30             # $b[1] has type int, value 20
$b[1] /= 6                # $b[1] has type double, value 3.33...

$i = 0
$b = 10,20,30
$b[++$i] += 2             # side effect evaluated only once

[int]$Variable:v = 10     # v takes on the value 10
$Variable:v -= 3          # 3 is subtracted from v

${E:output.txt} = "a"     # write text to the given file
${E:output.txt} += "b"    # append text to the file giving ab
${E:output.txt} *= 4      # replicate ab 4 times giving abababab
```

## 7.12 Redirection operators

Syntax:

```Syntax
pipeline:
    assignment-expression
    expression redirections~opt~ pipeline-tail~opt~
    command verbatim-command-argument~opt~ pipeline-tail~opt~

redirections:
    redirection
    redirections redirection

redirection:
    merging-redirection-operator
    file-redirection-operator redirected-file-name

redirected-file-name:
    command-argument
    primary-expression

file-redirection-operator: one of
    >   >>   2>   2>>   3>   3>>   4>   4>>
    5>  5>>  6>   6>>   >    >>    <

merging-redirection-operator: one of
    >&1   2>&1   3>&1   4>&1   5>&1   6>&1
    >&2   1>&2   3>&2   4>&2   5>&2   6>&2
```

Description:

The redirection operator `>` takes the standard output from the pipeline and redirects it to the
location designated by *redirected-file-name*, overwriting that location's current contents.

The redirection operator `>>` takes the standard output from the pipeline and redirects it to the
location designated by *redirected-file-name*, appending to that location's current contents, if
any. If that location does not exist, it is created.

The redirection operator with the form `n>` takes the output of stream *n* from the pipeline and
redirects it to the location designated by *redirected-file-name*, overwriting that location's
current contents.

The redirection operator with the form `n>>` takes the output of stream *n* from the pipeline and
redirects it to the location designated by *redirected-file-name*, appending to that location's
current contents, if any. If that location does not exist, it is created.

The redirection operator with the form `m>&n` writes output from stream *m* to the same location as
stream *n*.

The following are the valid streams:

| Stream |                                       Description                                       |
| ------ | --------------------------------------------------------------------------------------- |
| 1      | Standard output stream                                                                  |
| 2      | Error output stream                                                                     |
| 3      | Warning output stream                                                                   |
| 4      | Verbose output stream                                                                   |
| 5      | Debug output stream                                                                     |
| *      | Standard output, error output, warning output, verbose output, and debug output streams |

The redirection operators `1>&2`, `6>`, `6>>` and `<` are reserved for future use.

If on output the value of *redirected-file-name* is `$null`, the output is discarded.

Ordinarily, the value of an expression containing a top-level side effect is not written to the
pipeline unless that expression is enclosed in a pair of parentheses. However, if such an expression
is the left operand of an operator that redirects standard output, the value is written.

Examples:

```powershell
$i = 200                       # pipeline gets nothing
$i                             # pipeline gets result
$i > output1.txt               # result redirected to named file
++$i >> output1.txt            # result appended to named file
type file1.txt 2> error1.txt   # error output redirected to named file
type file2.txt 2>> error1.txt  # error output appended to named file
dir -Verbose 4> verbose1.txt   # verbose output redirected to named file

# Send all output to output2.txt
dir -Verbose -Debug -WarningAction Continue *> output2.txt

# error output redirected to named file, verbose output redirected
# to the same location as error output
dir -Verbose 4>&2 2> error2.txt
```

<!-- reference links -->
[§2.3.5.2]: chapter-02.md#2352-string-literals
[§3.15]: chapter-03.md#315-wildcard-expressions
[§3.16]: chapter-03.md#316-regular-expressions
[§4.3.7]: chapter-04.md#437-the-scriptblock-type
[§4.4]: chapter-04.md#44-generic-types
[§4.5.24]: chapter-04.md#4524-method-designator-type
[§5.3]: chapter-05.md#53-constrained-variables
[§6.15]: chapter-06.md#615-usual-arithmetic-conversions
[§6.17]: chapter-06.md#617-conversion-during-parameter-binding
[§6.2]: chapter-06.md#62-conversion-to-bool
[§6.4]: chapter-06.md#64-conversion-to-integer
[§6.7]: chapter-06.md#67-conversion-to-object
[§6.8]: chapter-06.md#68-conversion-to-string
[§7.1.1]: chapter-07.md#711-grouping-parentheses
[§7.1.2]: chapter-07.md#712-member-access
[§7.1.4.5]: chapter-07.md#7145-generating-array-slices
[§7.1.6]: chapter-07.md#716--operator
[§7.1.8]: chapter-07.md#718-script-block-expression
[§7.11.1]: chapter-07.md#7111-simple-assignment
[§7.11.2]: chapter-07.md#7112-compound-assignment
[§7.11]: chapter-07.md#711-assignment-operators
[§7.2.9]: chapter-07.md#729-cast-operator
[§7.6.1]: chapter-07.md#761-multiplication
[§7.6.2]: chapter-07.md#762-string-replication
[§7.6.3]: chapter-07.md#763-array-replication
[§7.6.4]: chapter-07.md#764-division
[§7.6.5]: chapter-07.md#765-remainder
[§7.7.1]: chapter-07.md#771-addition
[§7.7.2]: chapter-07.md#772-string-concatentaion
[§7.7.3]: chapter-07.md#773-array-concatenation
[§7.7.5]: chapter-07.md#775-subtraction
[§7.7]: chapter-07.md#77-additive-operators
[§7.8.4.4]: chapter-07.md#7844-the-binary--join-operator
[§7.8.4.5]: chapter-07.md#7845-the-binary--split-operator
[§7.8.4.6]: chapter-07.md#7846-submatches
[§7.8]: chapter-07.md#78-comparison-operators
[§8.1.2]: chapter-08.md#812-statement-values
[§8.10.1]: chapter-08.md#8101-filter-functions
[§8.10.2]: chapter-08.md#8102-workflow-functions
[§8.10.7]: chapter-08.md#8107-named-blocks
[§8.10.9]: chapter-08.md#8109-param-block
[§9.]: chapter-09.md#9-arrays
[§9.12]: chapter-09.md#912-multidimensional-array-flattening
[§9.4]: chapter-09.md#94-constraining-element-types
[§9.9]: chapter-09.md#99-array-slices

# /./lang-spec/chapter-08.md - Statements

    ---
    description: A statement specifies some sort of action that is to be performed.
    ms.date: 05/16/2022
    title: Statements
    ---
# 8. Statements

## 8.1 Statement blocks and lists

Syntax:

> [!TIP]
> The `~opt~` notation in the syntax definitions indicates that the lexical entity is optional in
> the syntax.

```Syntax
statement-block:
    new-lines~opt~ { statement-list~opt~ new-lines~opt~ }

statement-list:
    statement
    statement-list statement

statement:
    if-statement
    label~opt~ labeled-statement
    function-statement
    flow-control-statement statement-terminator
    trap-statement
    try-statement
    data-statement
    inlinescript-statement
    parallel-statement
    sequence-statement
    pipeline statement-terminator

statement-terminator:
    ;
    new-line-character
```

Description:

A *statement* specifies some sort of action that is to be performed. Unless indicated otherwise
within this clause, statements are executed in lexical order.

A *statement-block* allows a set of statements to be grouped into a single syntactic unit.

### 8.1.1 Labeled statements

Syntax:

```Syntax
labeled-statement:
    switch-statement
    foreach-statement
    for-statement
    while-statement
    do-statement
```

Description:

An iteration statement ([§8.4][§8.4]) or a switch statement ([§8.6][§8.6]) may optionally be preceded
immediately by one statement label, *label*. A statement label is used as the optional target of a
break ([§8.5.1][§8.5.1]) or continue ([§8.5.2][§8.5.2]) statement. However, a label does not alter the flow of
control.

White space is not permitted between the colon (`:`) and the token that follows it.

Examples:

```powershell
:go_here while ($j -le 100) {
    # ...
}

:labelA
for ($i = 1; $i -le 5; ++$i) {
    :labelB
    for ($j = 1; $j -le 3; ++$j) {
        :labelC
        for ($k = 1; $k -le 2; ++$k) {
            # ...
        }
    }
}
```

### 8.1.2 Statement values

The value of a statement is the cumulative set of values that it writes to the pipeline. If the
statement writes a single scalar value, that is the value of the statement. If the statement writes
multiple values, the value of the statement is that set of values stored in elements of an
unconstrained 1-dimensional array, in the order in which they were written. Consider the following
example:

`$v = for ($i = 10; $i -le 5; ++$i) { }`

There are no iterations of the loop and nothing is written to the pipeline. The value of the
statement is `$null`.

`$v = for ($i = 1; $i -le 5; ++$i) { }`

Although the loop iterates five times nothing is written to the pipeline. The value of the statement
is $null.

`$v = for ($i = 1; $i -le 5; ++$i) { $i }`

The loop iterates five times each time writing to the pipeline the `int` value `$i`. The value of
the statement is `object[]` of Length 5.

`$v = for ($i = 1; $i -le 5; ) { ++$i }`

Although the loop iterates five times nothing is written to the pipeline. The value of the statement
is `$null`.

`$v = for ($i = 1; $i -le 5; ) { (++$i) }`

The loop iterates five times with each value being written to the pipeline. The value of the
statement is `object[]` of Length 5.

`$i = 1; $v = while ($i++ -lt 2) { $i }`

The loop iterates once. The value of the statement is the `int` with value 2.

Here are some other examples:

```powershell
# if $count is not currently defined then define it with int value 10
$count = if ($count -eq $null) { 10 } else { $count }

$i = 1
$v = while ($i -le 5) {
    $i                   # $i is written to the pipeline
    if ($i -band 1) {

        "odd"            # conditionally written to the pipeline

    }

    ++$i                 # not written to the pipeline

}
# $v is object[], Length 8, value 1,"odd",2,3,"odd",4,5,"odd"
```

## 8.2 Pipeline statements

Syntax:

```Syntax
pipeline:
    assignment-expression
    expression redirections~opt~ pipeline-tail~opt~
    command verbatim-command-argument~opt~ pipeline-tail~opt~

assignment-expression:
    expression assignment-operator statement

pipeline-tail:
    | new-lines~opt~ command
    | new-lines~opt~ command pipeline-tail

command:
    command-name command-elements~opt~
    command-invocation-operator command-module~opt~ command-name-expr command-elements~opt~

command-invocation-operator: one of
    &   .

command-module:
    primary-expression

command-name:
    generic-token
    generic-token-with-subexpr

generic-token-with-subexpr:
    No whitespace is allowed between ) and command-name.
    generic-token-with-subexpr-start statement-list~opt~ )

command-namecommand-name-expr:
    command-name

primary-expressioncommand-elements:
    command-element
    command-elements command-element

command-element:
    command-parameter
    command-argument
    redirection

command-argument:
    command-name-expr

verbatim-command-argument:
    --% verbatim-command-argument-chars
```

Description:

*redirections* is discussed in [§7.12][§7.12]; *assignment-expression* is discussed in [§7.11][§7.11]; and the
*command-invocation-operator* dot (`.`) is discussed in [§3.5.5][§3.5.5]. For a discussion of
argument-to-parameter mapping in command invocations, see [§8.14][§8.14].

The first command in a *pipeline* is an expression or a command invocation. Typically, a command
invocation begins with a *command-name*, which is usually a bare identifier. *command-elements*
represents the argument list to the command. A newline or n unescaped semicolon terminates a
pipeline.

A command invocation consists of the command's name followed by zero or more arguments. The rules
governing arguments are as follows:

- An argument that is not an expression, but which contains arbitrary text without unescaped white
  space, is treated as though it were double quoted. Letter case is preserved.

- Variable substitution and sub-expression expansion ([§2.3.5.2][§2.3.5.2]) takes place inside
  *expandable-string-literal*s and *expandable-here-string-literal*s.

- Text inside quotes allows leading, trailing, and embedded white space to be included in the
  argument's value. [*Note*: The presence of whitespace in a quoted argument does not turn a single
  argument into multiple arguments. *end note*]

- Putting parentheses around an argument causes that expression to be evaluated with the result
  being passed instead of the text of the original expression.

- To pass an argument that looks like a switch parameter ([§2.3.4][§2.3.4]) but is not intended as such,
  enclose that argument in quotes.

- When specifying an argument that matches a parameter having the `[switch]` type constraint
  ([§8.10.5][§8.10.5]), the presence of the argument name on its own causes that parameter to be set to
  `$true`. However, the parameter's value can be set explicitly by appending a suffix to the
  argument. For example, given a type constrained parameter *p*, an argument of `-p:$true` sets p to
  True, while `-p:$false` sets p to False.

- An argument of `--` indicates that all arguments following it are to be passed in their actual
  form as though double quotes were placed around them.

- An argument of `--%` indicates that all arguments following it are to be passed with minimal
  parsing and processing. This argument is called the verbatim parameter. Arguments after the
  verbatim parameter are not PowerShell expressions even if they are syntactically valid PowerShell
  expressions.

If the command type is Application, the parameter `--%` is not passed to the command. The arguments
after `--%` have any environment variables (strings surrounded by `%`) expanded. For example:

```powershell
echoargs.exe --% "%path%" # %path% is replaced with the value $env:path
```

The order of evaluation of arguments is unspecified.

For information about parameter binding see [§8.14][§8.14]. For information about name lookup see
[§3.8][§3.8].

Once argument processing has been completed, the command is invoked. If the invoked command
terminates normally ([§8.5.4][§8.5.4]), control reverts to the point in the script or function immediately
following the command invocation. For a description of the behavior on abnormal termination see
`break` ([§8.5.1][§8.5.1]), `continue` ([§8.5.2][§8.5.2]), `throw` ([§8.5.3][§8.5.3]), `exit` ([§8.5.5][§8.5.5]), `try`
([§8.7][§8.7]), and `trap` ([§8.8][§8.8]).

Ordinarily, a command is invoked by using its name followed by any arguments. However, the
command-invocation operator, &, can be used. If the command name contains unescaped white space, it
must be quoted and invoked with this operator. As a script block has no name, it too must be invoked
with this operator. For example, the following invocations of a command call `Get-Factorial` are
equivalent:

```powershell
Get-Factorial 5
& Get-Factorial 5
& "Get-Factorial" 5
```

Direct and indirect recursive function calls are permitted. For example,

```powershell
function Get-Power([int]$x, [int]$y) {
    if ($y -gt 0) { return $x * (Get-Power $x (--$y)) }
    else { return 1 }
}
```

Examples:

```powershell
New-Object 'int[,]' 3,2
New-Object -ArgumentList 3,2 -TypeName 'int[,]'

dir e:\PowerShell\Scripts\*statement*.ps1 | Foreach-Object {$_.Length}

dir e:\PowerShell\Scripts\*.ps1 | Select-String -List "catch" | Format-Table path,linenumber -AutoSize
```

## 8.3 The if statement

Syntax:

```Syntax
if-statement:
    if new-lines~opt~ ( new-lines~opt~ pipeline new-lines~opt~ ) statement-block
        elseif-clauses~opt~ else-clause~opt~

elseif-clauses:
    elseif-clause
    elseif-clauses elseif-clause

elseif-clause:
    new-lines~opt~ elseif new-lines~opt~ ( new-lines~opt~ pipeline new-lines~opt~ ) statement-block

else-clause:
    new-lines~opt~ else statement-block
```

Description:

The *pipeline* controlling expressions must have type bool or be implicitly convertible to that
type. The *else-clause* is optional. There may be zero or more *elseif-clause*s.

If the top-level *pipeline* tests True, then its *statement-block* is executed and execution of the
statement terminates. Otherwise, if an *elseif-clause* is present, if its *pipeline* tests True,
then its *statement-block* is executed and execution of the statement terminates. Otherwise, if an
*else-clause* is present, its *statement-block* is executed.

Examples:

```powershell
$grade = 92
if ($grade -ge 90) { "Grade A" }
elseif ($grade -ge 80) { "Grade B" }
elseif ($grade -ge 70) { "Grade C" }
elseif ($grade -ge 60) { "Grade D" }
else { "Grade F" }
```

## 8.4 Iteration statements

### 8.4.1 The while statement

Syntax:

```Syntax
while-statement:
    while new-lines~opt~ ( new-lines~opt~ while-condition new-lines~opt~ ) statement-block

while-condition:
    new-lines~opt~ pipeline
```

Description:

The controlling expression *while-condition* must have type bool or be implicitly convertible to
that type. The loop body, which consists of *statement-block*, is executed repeatedly until the
controlling expression tests False. The controlling expression is evaluated before each execution of
the loop body.

Examples:

```powershell
$i = 1
while ($i -le 5) {                     # loop 5 times
    "{0,1}`t{1,2}" -f $i, ($i*$i)
    ++$i
}
```

### 8.4.2 The do statement

Syntax:

```Syntax
do-statement:
    do statement-block new-lines~opt~ while new-lines~opt~ ( while-condition new-lines~opt~ )
    do statement-block new-lines~opt~ until new-lines~opt~ ( while-condition new-lines~opt~ )

while-condition:
    new-lines~opt~ pipeline
```

Description:

The controlling expression *while-condition* must have type bool or be implicitly convertible to
that type. In the while form, the loop body, which consists of *statement-block*, is executed
repeatedly while the controlling expression tests True. In the until form, the loop body is executed
repeatedly until the controlling expression tests True. The controlling expression is evaluated
after each execution of the loop body.

Examples:

```powershell
$i = 1
do {
    "{0,1}`t{1,2}" -f $i, ($i * $i)
}
while (++$i -le 5)                 # loop 5 times

$i = 1
do {
    "{0,1}`t{1,2}" -f $i, ($i * $i)
}
until (++$i -gt 5)                 # loop 5 times
```

### 8.4.3 The for statement

Syntax:

```Syntax
for-statement:
    for new-lines~opt~ (
        new-lines~opt~ for-initializer~opt~ statement-terminator
        new-lines~opt~ for-condition~opt~ statement-terminator
        new-lines~opt~ for-iterator~opt~
        new-lines~opt~ ) statement-block

    for new-lines~opt~ (
        new-lines~opt~ for-initializer~opt~ statement-terminator
        new-lines~opt~ for-condition~opt~
        new-lines~opt~ ) statement-block

    for new-lines~opt~ (
        new-lines~opt~ for-initializer~opt~
        new-lines~opt~ ) statement-block

for-initializer:
    pipeline

for-condition:
    pipeline

for-iterator:
    pipeline
```

Description:

The controlling expression *for-condition* must have type bool or be implicitly convertible to that
type. The loop body, which consists of *statement-block*, is executed repeatedly while the
controlling expression tests True. The controlling expression is evaluated before each execution of
the loop body.

Expression *for-initializer* is evaluated before the first evaluation of the controlling expression.
Expression *for-initializer* is evaluated for its side effects only; any value it produces is
discarded and is not written to the pipeline.

Expression *for-iterator* is evaluated after each execution of the loop body. Expression
*for-iterator* is evaluated for its side effects only; any value it produces is discarded and is not
written to the pipeline.

If expression *for-condition* is omitted, the controlling expression tests True.

Examples:

```powershell
for ($i = 5; $i -ge 1; --$i) { # loop 5 times
    "{0,1}`t{1,2}" -f $i, ($i * $i)
}

$i = 5
for (; $i -ge 1; ) { # equivalent behavior
    "{0,1}`t{1,2}" -f $i, ($i * $i)
    --$i
}
```

### 8.4.4 The foreach statement

Syntax:

```Syntax
foreach-statement:
    foreach new-lines~opt~ foreach-parameter~opt~ new-lines~opt~
        ( new-lines~opt~ variable new-lines~opt~ *in* new-lines~opt~ pipeline
        new-lines~opt~ ) statement-block

foreach-parameter:
    -parallel
```

Description:

The loop body, which consists of *statement-block*, is executed for each element designated by the
variable *variable* in the collection designated by *pipeline*. The scope of *variable* is not
limited to the foreach statement. As such, it retains its final value after the loop body has
finished executing. If *pipeline* designates a scalar (excluding the value $null) instead of a
collection, that scalar is treated as a collection of one element. If *pipeline* designates the
value `$null`, *pipeline* is treated as a collection of zero elements.

If the *foreach-parameter* `-parallel` is specified, the behavior is implementation defined.

The *foreach-parameter* `‑parallel` is only allowed in a workflow ([§8.10.2][§8.10.2]).

Every foreach statement has its own enumerator, `$foreach` ([§2.3.2.2][§2.3.2.2], [§4.5.16][§4.5.16]), which exists
only while that loop is executing.

The objects produced by *pipeline* are collected before *statement-block* begins to execute.
However, with the [ForEach-Object](xref:Microsoft.PowerShell.Core.ForEach-Object) cmdlet,
*statement-block* is executed on each object as it is produced.

Examples:

```powershell
$a = 10, 53, 16, -43
foreach ($e in $a) {
    ...
}
$e # the int value -43

foreach ($e in -5..5) {
    ...
}

foreach ($t in [byte], [int], [long]) {
    $t::MaxValue # get static property
}

foreach ($f in Get-ChildItem *.txt) {
    ...
}

$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
foreach ($e in $h1.Keys) {
    "Key is " + $e + ", Value is " + $h1[$e]
}
```

## 8.5 Flow control statements

Syntax:

```Syntax
flow-control-statement:
    break label-expression~opt~
    continue label-expression~opt~
    throw pipeline~opt~
    return pipeline~opt~
    exit pipeline~opt~

label-expression:
    simple-name
    unary-expression
```

Description:

A flow-control statement causes an unconditional transfer of control to some other location.

### 8.5.1 The break statement

Description:

A break statement with a *label-expression* is referred to as a *labeled break statement*. A break
statement without a *label-expression* is referred to as an *unlabeled break statement*.

Outside a trap statement, an unlabeled break statement directly within an iteration statement
([§8.4][§8.4]) terminates execution of that smallest enclosing iteration statement. An unlabeled break
statement directly within a switch statement ([§8.6][§8.6]) terminates pattern matching for the current
switch's *switch-condition*. See ([§8.8][§8.8]) for details of using break from within a trap statement.

An iteration statement or a switch statement may optionally be preceded immediately by one statement
label ([§8.1.1][§8.1.1]).Such a statement label may be used as the target of a labeled break statement, in
which case, that statement terminates execution of the targeted enclosing iteration statement.

A labeled break need not be resolved in any local scope; the search for a matching label may
continue up the calling stack even across script and function-call boundaries. If no matching label
is found, the current command invocation is terminated.

The name of the label designated by *label-expression* need not have a constant value.

If *label-expression* is a *unary-expression*, it is converted to a string.

Examples:

```powershell
$i = 1
while ($true) { # infinite loop
    if ($i * $i -gt 100) {
        break # break out of current while loop
    }
    ++$i
}

$lab = "go_here"
:go_here
for ($i = 1; ; ++$i) {
    if ($i * $i -gt 50) {
        break $lab # use a string value as target
    }
}

:labelA
for ($i = 1; $i -le 2; $i++) {

    :labelB
    for ($j = 1; $j -le 2; $j++) {

        :labelC
        for ($k = 1; $k -le 3; $k++) {
            if (...) { break labelA }
        }
    }
}
```

### 8.5.2 The continue statement

Description:

A `continue` statement with a *label-expression* is referred to as a *labeled continue statement*. A
continue statement without a *label-expression* is referred to as an *unlabeled continue statement*.

The use of `continue` from within a trap statement is discussed in [§8.8][§8.8].

An unlabeled `continue` statement within a loop terminates execution of the current loop and
transfers control to the closing brace of the smallest enclosing iteration statement ([§8.4][§8.4]). An
unlabeled `continue` statement within a switch terminates execution of the current `switch`
iteration and transfers control to the smallest enclosing `switch`'s *switch-condition* ([§8.6][§8.6]).

An iteration statement or a `switch` statement ([§8.6][§8.6]) may optionally be preceded immediately by
one statement label ([§8.1.1][§8.1.1]). Such a statement label may be used as the target of an enclosed
labeled `continue` statement, in which case, that statement terminates execution of the current loop
or `switch` iteration, and transfers control to the targeted enclosing iteration or `switch`
statement label.

A labeled `continue` need not be resolved in any local scope; the search for a matching label may
`continue` up the calling stack even across script and function-call boundaries. If no matching
label is found, the current command invocation is terminated.

The name of the label designated by *label-expression* need not have a constant value.

If *label-expression* is a *unary-expression*, it is converted to a string.

Examples:

```powershell
$i = 1
while (...) {
    ...
    if (...) {
        continue # start next iteration of current loop
    }
    ...
}

$lab = "go_here"
:go_here
for (...; ...; ...) {
    if (...) {
        continue $lab # start next iteration of labeled loop
    }
}

:labelA
for ($i = 1; $i -le 2; $i++) {

    :labelB
    for ($j = 1; $j -le 2; $j++) {

        :labelC
        for ($k = 1; $k -le 3; $k++) {
            if (...) { continue labelB }
        }
    }
}
```

### 8.5.3 The throw statement

Description:

An exception is a way of handling a system- or application-level error condition. The throw
statement raises an exception. (See [§8.7][§8.7] for a discussion of exception handling.)

If *pipeline* is omitted and the throw statement is not in a *catch-clause*, the behavior is
implementation defined. If *pipeline* is present and the throw statement is in a *catch-clause*, the
exception that was caught by that *catch-clause* is re-thrown after any *finally-clause* associated
with the *catch-clause* is executed.

If *pipeline* is present, the type of the exception thrown is implementation defined.

When an exception is thrown, control is transferred to the first catch clause in an enclosing try
statement that can handle the exception. The location at which the exception is thrown initially is
called the *throw point*. Once an exception is thrown the steps described in [§8.7][§8.7] are followed
repeatedly until a catch clause that matches the exception is found or none can be found.

Examples:

```powershell
throw
throw 100
throw "No such record in file"
```

If *pipeline* is omitted and the throw statement is not from within a *catch-clause*, the text
"ScriptHalted" is written to the pipeline, and the type of the exception raised is
`System.Management.Automation.RuntimeException`.

If *pipeline* is present, the exception raised is wrapped in an object of type
`System.Management.Automation.RuntimeException`, which includes information about the exception as a
`System.Management.Automation.ErrorRecord` object (accessible via `$_`).

Example 1: `throw 123` results in an exception of type **RuntimeException**. From within the catch
block, `$_.TargetObject` contains the object wrapped inside, in this case, a `System.Int32` with
value 123.

Example 2: `throw "xxx"` results in an exception of type **RuntimeException**. From within the catch
block, `$_.TargetObject` contains the object wrapped inside, in this case, a `System.String` with
value "xxx".

Example 3: `throw 10,20` results in an exception of type **RuntimeException**. From within the catch
block, `$_.TargetObject` contains the object wrapped inside, in this case, a `System.Object[]`, an
unconstrained array of two elements with the `System`.Int32` values 10 and 20.

### 8.5.4 The return statement

Description:

The `return` statement writes to the pipeline the value(s) designated by *pipeline*, if any, and
returns control to the function or script's caller. A function or script may have zero or more
`return` statements.

If execution reaches the closing brace of a function an implied `return` without *pipeline* is
assumed.

The `return` statement is a bit of "syntactic sugar" to allow programmers to express themselves as
they can in other languages; however, the value returned from a function or script is actually all
of the values written to the pipeline by that function or script plus any value(s) specified by
*pipeline*. If only a scalar value is written to the pipeline, its type is the type of the value
returned; otherwise, the return type is an unconstrained 1-dimensional array containing all the
values written to the pipeline.

Examples:

```powershell
function Get-Factorial ($v) {
    if ($v -eq 1) {
        return 1 # return is not optional
    }

    return $v * (Get-Factorial ($v - 1)) # return is optional
}
```

The caller to `Get-Factorial` gets back an `int`.

```powershell
function Test {
    "text1" # "text1" is written to the pipeline
    # ...
    "text2" # "text2" is written to the pipeline
    # ...
    return 123 # 123 is written to the pipeline
}
```

The caller to `Test` gets back an unconstrained 1-dimensional array of three elements.

### 8.5.5 The exit statement

Description:

The exit statement terminates the current script and returns control and an *exit code* to the host
environment or the calling script. If *pipeline* is provided, the value it designates is converted
to int, if necessary. If no such conversion exists, or if *pipeline* is omitted, the int value zero
is returned.

Examples:

```powershell
exit $count # terminate the script with some accumulated count
```

## 8.6 The switch statement

Syntax:

```Syntax
switch-statement:
    switch new-lines~opt~ switch-parameters~opt~ switch-condition switch-body

switch-parameters:
    switch-parameter
    switch-parameters switch-parameter

switch-parameter:
    -regex
    -wildcard
    -exact
    -casesensitive
    -parallel

switch-condition:
    ( new-lines~opt~ pipeline new-lines~opt~ )
    -file new-lines~opt~ switch-filename

switch-filename:
    command-argument
    primary-expression

switch-body:
    new-lines~opt~ { new-lines~opt~ switch-clauses }

switch-clauses:
    switch-clause
    switch-clauses switch-clause

switch-clause:
    switch-clause-condition statement-block statement-terimators~opt~

switch-clause-condition:
    command-argument
    primary-expression
```

Description:

If *switch-condition* designates a single value, control is passed to one or more matching pattern
statement blocks. If no patterns match, some default action can be taken.

A switch must contain one or more *switch-clause*s, each starting with a pattern (a *non-default
switch clause*), or the keyword `default` (a *default switch clause*). A switch must contain zero or
one `default` switch clauses, and zero or more non-default switch clauses. Switch clauses may be
written in any order.

Multiple patterns may have the same value. A pattern need not be a literal, and a switch may have
patterns with different types.

If the value of *switch-condition* matches a pattern value, that pattern's *statement-block* is
executed. If multiple pattern values match the value of *switch-condition*, each matching pattern's
*statement-block* is executed, in lexical order, unless any of those *statement-block*s contains a
`break` statement ([§8.5.1][§8.5.1]).

If the value of *switch-condition* does not match any pattern value, if a `default` switch clause
exists, its *statement-block* is executed; otherwise, pattern matching for that *switch-condition*
is terminated.

Switches may be nested, with each switch having its own set of switch clauses. In such instances, a
switch clause belongs to the innermost switch currently in scope.

On entry to each *statement-block*, `$_` is automatically assigned the value of the
*switch-condition* that caused control to go to that *statement-block*. `$_` is also available in
that *statement-block*'s *switch-clause-condition*.

Matching of non-strings is done by testing for equality ([§7.8.1][§7.8.1]).

If the matching involves strings, by default, the comparison is case-insensitive. The presence of
the *switch-parameter* `-casesensitive` makes the comparison case-sensitive.

A pattern may contain wildcard characters ([§3.15][§3.15]), in which case, wildcard string comparisons
are performed, but only if the *switch-parameter* -wildcard is present. By default, the comparison
is case-insensitive.

A pattern may contain a regular expression ([§3.16][§3.16]), in which case, regular expression string
comparisons are performed, but only if the *switch-parameter* `-regex` is present. By default, the
comparison is case-insensitive. If `-regex` is present and a pattern is matched, `$matches` is
defined in the *switch-clause* *statement-block* for that pattern.

A *switch-parameter* may be abbreviated; any distinct leading part of a parameter may be used. For
example, `‑regex`, `‑rege`, `‑reg`, `‑re`, and `‑r` are equivalent.

If conflicting *switch-parameter*s are specified, the lexically final one prevails. The presence of
`‑exact` disables `-regex` and `-wildcard`; it has no affect on `‑case`, however.

If the *switch-parameter* `‑parallel` is specified, the behavior is implementation defined.

The *switch-parameter* `‑parallel` is only allowed in a workflow ([§8.10.2][§8.10.2]).

If a pattern is a *script-block-expression*, that block is evaluated and the result is converted to
bool, if necessary. If the result has the value `$true`, the corresponding *statement-block* is
executed; otherwise, it is not.

If *switch-condition* designates multiple values, the switch is applied to each value in lexical
order using the rules described above for a *switch-condition* that designates a single value. Every
switch statement has its own enumerator, `$switch` ([§2.3.2.2][§2.3.2.2], [§4.5.16][§4.5.16]), which exists only
while that switch is executing.

A switch statement may have a label, and it may contain labeled and unlabeled break ([§8.5.1][§8.5.1]) and
continue ([§8.5.2][§8.5.2]) statements.

If *switch-condition* is `-file` *switch-filename*, instead of iterating over the values in an
expression, the switch iterates over the values in the file designated by *switch-filename*.The file
is read a line at a time with each line comprising a value. Line terminator characters are not
included in the values.

Examples:

```powershell
$s = "ABC def`nghi`tjkl`fmno @#$"
$charCount = 0; $pageCount = 0; $lineCount = 0; $otherCount = 0
for ($i = 0; $i -lt $s.Length; ++$i) {
    ++$charCount
    switch ($s[$i]) {
        "`n" { ++$lineCount }
        "`f" { ++$pageCount }
        "`t" { }
        " " { }
        default { ++$otherCount }
    }
}

switch -wildcard ("abc") {
    a* { "a*, $_" }
    ?B? { "?B? , $_" }
    default { "default, $_" }
}

switch -regex -casesensitive ("abc") {
    ^a* { "a*" }
    ^A* { "A*" }
}

switch (0, 1, 19, 20, 21) {
    { $_ -lt 20 } { "-lt 20" }
    { $_ -band 1 } { "Odd" }
    { $_ -eq 19 } { "-eq 19" }
    default { "default" }
}
```

## 8.7 The try/finally statement

Syntax:

```Syntax
try-statement:
    try statement-block catch-clauses
    try statement-block finally-clause
    try statement-block catch-clauses finally-clause

catch-clauses:
    catch-clause
    catch-clauses catch-clause

catch-clause:
    new-lines~opt~ catch catch-type-list~opt~
    statement-block

catch-type-list:
    new-lines~opt~ type-literal
    catch-type-list new-lines~opt~ , new-lines~opt~

type-literalfinally-clause:
    new-lines~opt~ finally statement-block
```

Description:

The try statement provides a mechanism for catching exceptions that occur during execution of a
block. The try statement also provides the ability to specify a block of code that is always
executed when control leaves the try statement. The process of raising an exception via the throw
statement is described in [§8.5.3][§8.5.3].

A *try block* is the *statement-block* associated with the try statement. A *catch block* is the
*statement-block* associated with a *catch-clause*. A *finally block* is the *statement-block*
associated with a *finally-clause*.

A *catch-clause* without a *catch-type-list* is called a *general catch clause*.

Each *catch-clause* is an *exception handler*, and a *catch-clause* whose *catch-type-list* contains
the type of the raised exception is a *matching catch clause*. A general catch clause matches all
exception types.

Although *catch-clauses* and *finally-clause* are optional, at least one of them must be present.

The processing of a thrown exception consists of evaluating the following steps repeatedly until a
catch clause that matches the exception is found.

- In the current scope, each try statement that encloses the throw point is examined. For each try
  statement *S*, starting with the innermost try statement and ending with the outermost try
  statement, the following steps are evaluated:

  - If the `try` block of *S* encloses the throw point and if *S* has one or more catch clauses, the
    catch clauses are examined in lexical order to locate a suitable handler for the exception. The
    first catch clause that specifies the exception type or a base type of the exception type is
    considered a match. A general catch clause is considered a match for any exception type. If a
    matching catch clause is located, the exception processing is completed by transferring control
    to the block of that catch clause. Within a matching catch clause, the variable `$_` contains a
    description of the current exception.

  - Otherwise, if the `try` block or a `catch` block of *S* encloses the throw point and if *S* has
    a `finally` block, control is transferred to the finally block. If the `finally` block throws
    another exception, processing of the current exception is terminated. Otherwise, when control
    reaches the end of the `finally` block, processing of the current exception is continued.

- If an exception handler was not located in the current scope, the steps above are then repeated
  for the enclosing scope with a throw point corresponding to the statement from which the current
  scope was invoked.

- If the exception processing ends up terminating all scopes, indicating that no handler exists for
  the exception, then the behavior is unspecified.

To prevent unreachable catch clauses in a try block, a catch clause may not specify an exception
type that is equal to or derived from a type that was specified in an earlier catch clause within
that same try block.

The statements of a `finally` block are always executed when control leaves a `try` statement. This
is true whether the control transfer occurs as a result of normal execution, as a result of
executing a `break`, `continue`, or `return` statement, or as a result of an exception being thrown
out of the `try` statement.

If an exception is thrown during execution of a `finally` block, the exception is thrown out to the
next enclosing `try` statement. If another exception was in the process of being handled, that
exception is lost. The process of generating an exception is further discussed in the description of
the `throw` statement.

`try` statements can co-exist with `trap` statements; see [§8.8][§8.8] for details.

Examples:

```powershell
$a = new-object 'int[]' 10
$i = 20 # out-of-bounds subscript

while ($true) {
    try {
        $a[$i] = 10
        "Assignment completed without error"
        break
    }

    catch [IndexOutOfRangeException] {
        "Handling out-of-bounds index, >$_<`n"
        $i = 5
    }

    catch {
        "Caught unexpected exception"
    }

    finally {
        # ...
    }
}
```

Each exception thrown is raised as a `System.Management.Automation.RuntimeException`. If there are
type-specific *catch-clause*s in the `try` block, the **InnerException** property of the exception
is inspected to try and find a match, such as with the type `System.IndexOutOfRangeException` above.

## 8.8 The trap statement

Syntax:

```Syntax
trap-statement:
    *trap* new-lines~opt~ type-literal~opt~ new-lines~opt~ statement-block
```

Description:

A `trap` statement with and without *type-literal* is analogous to a `catch` block ([§8.7][§8.7]) with
and without *catch-type-list*, respectively, except that a `trap` statement can trap only one type
at a time.

Multiple `trap` statements can be defined in the same *statement-block*, and their order of
definition is irrelevant. If two `trap` statements with the same *type-literal* are defined in the
same scope, the lexically first one is used to process an exception of matching type.

Unlike a `catch` block, a `trap` statement matches an exception type exactly; no derived type
matching is performed.

When an exception occurs, if no matching `trap` statement is present in the current scope, a
matching trap statement is searched for in the enclosing scope, which may involve looking in the
calling script, function, or filter, and then in its caller, and so on. If the lookup ends up
terminating all scopes, indicating that no handler exists for the exception, then the behavior is
unspecified.

A `trap` statement's *statement-body* only executes to process the corresponding exception;
otherwise, execution passes over it.

If a `trap`'s *statement-body* exits normally, by default, an error object is written to the error
stream, the exception is considered handled, and execution continues with the statement immediately
following the one in the scope containing the `trap` statement that made the exception visible. The
cause of the exception might be in a command called by the command containing the `trap` statement.

If the final statement executed in a `trap`'s *statement-body* is continue ([§8.5.2][§8.5.2]), the writing
of the error object to the error stream is suppressed, and execution continues with the statement
immediately following the one in the scope containing the trap statement that made the exception
visible. If the final statement executed in a `trap`'s *statement-body* is break ([§8.5.1][§8.5.1]), the
writing of the error object to the error stream is suppressed, and the exception is re-thrown.

Within a `trap` statement the variable `$_` contains a description of the current error.

Consider the case in which an exception raised from within a `try` block does not have a matching
`catch` block, but a matching `trap` statement exists at a higher block level. After the `try`
block's finally clause is executed, the `trap` statement gets control even if any parent scope has a
matching `catch` block. If a `trap` statement is defined within the `try` block itself, and that
`try` block has a matching `catch` block, the `trap` statement gets control.

Examples:

In the following example, the error object is written and execution continues with the statement
immediately following the one that caused the trap; that is, "Done" is written to the pipeline.

```powershell
$j = 0; $v = 10/$j; "Done"
trap { $j = 2 }
```

In the following example, the writing of the error object is suppressed and execution continues with
the statement immediately following the one that caused the trap; that is, "Done" is written to the
pipeline.

```powershell
$j = 0; $v = 10/$j; "Done"
trap { $j = 2; continue }
```

In the following example, the writing of the error object is suppressed and the exception is
re-thrown.

```powershell
$j = 0; $v = 10/$j; "Done"
trap { $j = 2; break }
```

In the following example, the trap and exception-generating statements are in the same scope. After
the exception is caught and handled, execution resumes with writing 1 to the pipeline.

```powershell
&{trap{}; throw '\...'; 1}
```

In the following example, the trap and exception-generating statements are in different scopes.
After the exception is caught and handled, execution resumes with writing 2 (not 1) to the pipeline.

```powershell
trap{} &{throw '\...'; 1}; 2
```

## 8.9 The data statement

Syntax:

```Syntax
data-statement:
    data new-lines~opt~ data-name data-commands-allowed~opt~ statement-block

data-name:
    simple-name

data-commands-allowed:
    new-lines~opt~ -supportedcommand data-commands-list

data-commands-list:
    new-lines~opt~ data-command
    data-commands-list , new-lines~opt~ data-command

data-command:
    command-name-expr
```

Description:

A data statement creates a *data section*, keeping that section's data separate from the code. This
separation supports facilities like separate string resource files for text, such as error messages
and Help strings. It also helps support internationalization by making it easier to isolate, locate,
and process strings that will be translated into different languages.

A script or function can have zero or more data sections.

The *statement-block* of a data section is limited to containing the following PowerShell features
only:

- All operators except `-match`
- The `if` statement
- The following automatic variables: `$PsCulture`, `$PsUICulture`, `$true`, `$false`, and `$null`.
- Comments
- Pipelines
- Statements separated by semicolons (`;`)
- Literals
- Calls to the [ConvertFrom-StringData](xref:Microsoft.PowerShell.Utility.ConvertFrom-StringData)
  cmdlet
- Any other cmdlets identified via the **supportedcommand** parameter

If the `ConvertFrom-StringData` cmdlet is used, the key/value pairs can be expressed using any form
of string literal. However, *expandable-string-literal*s and *expandable-here-string-literal*s must
not contain any variable substitutions or sub-expression expansions.

Examples:

The **SupportedCommand** parameter indicates that the given cmdlets or functions generate data only.
For example, the following data section includes a user-written cmdlet, `ConvertTo-XML`, which
formats data in an XML file:

```powershell
data -supportedCommand ConvertTo-XML {
    Format-XML -strings string1, string2, string3
}
```

Consider the following example, in which the data section contains a `ConvertFrom-StringData`
command that converts the strings into a hash table, whose value is assigned to `$messages`.

```powershell
$messages = data {
    ConvertFrom-StringData -stringdata @'
    Greeting = Hello
    Yes = yes
    No = no
'@
}
```

The keys and values of the hash table are accessed using `$messages.Greeting`, `$messages.Yes`, and
`$messages.No`, respectively.

Now, this can be saved as an English-language resource. German- and Spanish-language resources can
be created in separate files, with the following data sections:

```powershell
$messages = data {
    ConvertFrom-StringData -stringdata @"
    Greeting = Guten Tag
    Yes = ja
    No = nein
"@
}

$messagesS = data {
    ConvertFrom-StringData -stringdata @"
    Greeting = Buenos días
    Yes = sí
    No = no
"@
}
```

If *dataname* is present, it names the variable (without using a leading `$`) into which the value
of the data statement is to be stored. Specifically, `$name = data { ... }` is equivalent to
`data name { ... }`.

## 8.10 Function definitions

Syntax:

```Syntax
function-statement:
    function new-lines~opt~ function-name function-parameter-declaration~opt~ { script-block }
    filter new-lines~opt~ function-name function-parameter-declaration~opt~ { script-block }
    workflow new-lines~opt~ function-name function-parameter-declaration~opt~ { script-block }

function-name:
    command-argument

command-argument:
    command-name-expr

function-parameter-declaration:
    new-lines~opt~ ( parameter-list new-lines~opt~ )

parameter-list:
    script-parameter
    parameter-list new-lines~opt~ , script-parameter

script-parameter:
    new-lines~opt~ attribute-list~opt~ new-lines~opt~ variable script-parameter-default~opt~

script-block:
    param-block~opt~ statement-terminators~opt~ script-block-body~opt~

param-block:
    new-lines~opt~ attribute-list~opt~ new-lines~opt~ param new-lines~opt~
        ( parameter-list~opt~ new-lines~opt~ )

parameter-list:
    script-parameter
    parameter-list new-lines~opt~ , script-parameter

script-parameter-default:
    new-lines~opt~ = new-lines~opt~ expression

script-block-body:
    named-block-list
    statement-list

named-block-list:
    named-block
    named-block-list named-block

named-block:
    block-name statement-block statement-terminators~opt~

block-name: one of
    dynamicparam   begin   process   end
```

Description:

A *function definition* specifies the name of the function, filter, or workflow being defined and
the names of its parameters, if any. It also contains zero or more statements that are executed to
achieve that function's purpose.

Each function is an instance of the class `System.Management.Automation.FunctionInfo`.

### 8.10.1 Filter functions

Whereas an ordinary function runs once in a pipeline and accesses the input collection via `$input`,
a *filter* is a special kind of function that executes once for each object in the input collection.
The object currently being processed is available via the variable `$_`.

A filter with no named blocks ([§8.10.7][§8.10.7]) is equivalent to a function with a process block, but
without any begin block or end block.

Consider the following filter function definition and calls:

```powershell
filter Get-Square2 { # make the function a filter
    $_ * $_ # access current object from the collection
}

-3..3 | Get-Square2 # collection has 7 elements
6, 10, -3 | Get-Square2 # collection has 3 elements
```

Each filter is an instance of the class `System.Management.Automation.FilterInfo` ([§4.5.11][§4.5.11]).

### 8.10.2 Workflow functions

A workflow function is like an ordinary function with implementation defined semantics. A workflow
function is translated to a sequence of Windows Workflow Foundation activities and executed in the
Windows Workflow Foundation engine.

### 8.10.3 Argument processing

Consider the following definition for a function called `Get-Power`:

```powershell
function Get-Power ([long]$base, [int]$exponent) {
    $result = 1
    for ($i = 1; $i -le $exponent; ++$i) {
        $result *= $base
    }
    return $result
}
```

This function has two parameters, `$base` and `$exponent`. It also contains a set of statements
that, for non-negative exponent values, computes `$base^$exponent^` and returns the result to
`Get-Power`'s caller.

When a script, function, or filter begins execution, each parameter is initialized to its
corresponding argument's value. If there is no corresponding argument and a default value
([§8.10.4][§8.10.4]) is supplied, that value is used; otherwise, the value `$null` is used. As such, each
parameter is a new variable just as if it was initialized by assignment at the start of the
*script-block*.

If a *script-parameter* contains a type constraint (such as `[long]` and `[int]` above), the value
of the corresponding argument is converted to that type, if necessary; otherwise, no conversion
occurs.

When a script, function, or filter begins execution, variable `$args` is defined inside it as an
unconstrained 1-dimensional array, which contains all arguments not bound by name or position, in
lexical order.

Consider the following function definition and calls:

```powershell
function F ($a, $b, $c, $d) { ... }

F -b 3 -d 5 2 4       # $a is 2, $b is 3, $c is 4, $d is 5, $args Length 0
F -a 2 -d 3 4 5       # $a is 2, $b is 4, $c is 5, $d is 3, $args Length 0
F 2 3 4 5 -c 7 -a 1   # $a is 1, $b is 2, $c is 7, $d is 3, $args Length 2
```

For more information about parameter binding see [§8.14][§8.14].

### 8.10.4 Parameter initializers

The declaration of a parameter *p* may contain an initializer, in which case, that initializer's
value is used to initialize *p* provided *p* is not bound to any arguments in the call.

Consider the following function definition and calls:

```powershell
function Find-Str ([string]$str, [int]$start_pos = 0) { ... }

Find-Str "abcabc" # 2nd argument omitted, 0 used for $start_pos
Find-Str "abcabc" 2 # 2nd argument present, so it is used for $start_pos
```

### 8.10.5 The [switch] type constraint

When a switch parameter is passed, the corresponding parameter in the command must be constrained by
the type switch. Type switch has two values, True and False.

Consider the following function definition and calls:

```powershell
function Process ([switch]$trace, $p1, $p2) { ... }

Process 10 20                # $trace is False, $p1 is 10, $p2 is 20
Process 10 -trace 20         # $trace is True, $p1 is 10, $p2 is 20
Process 10 20 -trace         # $trace is True, $p1 is 10, $p2 is 20
Process 10 20 -trace:$false  # $trace is False, $p1 is 10, $p2 is 20
Process 10 20 -trace:$true   # $trace is True, $p1 is 10, $p2 is 20
```

### 8.10.6 Pipelines and functions

When a script, function, or filter is used in a pipeline, a collection of values is delivered to
that script or function. The script, function, or filter gets access to that collection via the
enumerator $input ([§2.3.2.2][§2.3.2.2], [§4.5.16][§4.5.16]), which is defined on entry to that script, function,
or filter.

Consider the following function definition and calls:

```powershell
function Get-Square1 {
    foreach ($i in $input) {   # iterate over the collection
        $i * $i
    }
}

-3..3 | Get-Square1            # collection has 7 elements
6, 10, -3 | Get-Square1        # collection has 3 elements
```

### 8.10.7 Named blocks

The statements within a *script-block* can belong to one large unnamed block, or they can be
distributed into one or more named blocks. Named blocks allow custom processing of collections
coming from pipelines; named blocks can be defined in any order.

The statements in a *begin block* (i.e.; one marked with the keyword begin) are executed once,
before the first pipeline object is delivered.

The statements in a *process block* (i.e.; one marked with the keyword process) are executed for
each pipeline object delivered. (`$_` provides access to the current object being processed from the
input collection coming from the pipeline.) This means that if a collection of zero elements is sent
via the pipeline, the process block is not executed at all. However, if the script or function is
called outside a pipeline context, this block is executed exactly once, and `$_` is set to `$null`,
as there is no current collection object.

The statements in an *end block* (i.e.; one marked with the keyword end) are executed once, after
the last pipeline object has been delivered.

### 8.10.8 dynamicparam block

The subsections of [§8.10][§8.10] thus far deal with *static parameters*, which are defined as part of
the source code. It is also possible to define *dynamic parameters* via a *dynamicparam block*,
another form of named block ([§8.10.7][§8.10.7]), which is marked with the keyword `dynamicparam`. Much of
this machinery is implementation defined.

Dynamic parameters are parameters of a cmdlet, function, filter, or script that are available under
certain conditions only. One such case is the **Encoding** parameter of the `Set-Item` cmdlet.

In the *statement-block*, use an if statement to specify the conditions under which the parameter is
available in the function. Use the [New-Object](xref:Microsoft.PowerShell.Utility.New-Object) cmdlet
to create an object of an implementation-defined type to represent the parameter, and specify its
name. Also, use `New-Object` to create an object of a different implementation-defined type to
represent the implementation-defined attributes of the parameter.

The following example shows a function with standard parameters called Name and Path, and an
optional dynamic parameter named **DP1**. The **DP1** parameter is in the PSet1 parameter set and
has a type of `Int32`. The **DP1** parameter is available in the Sample function only when the value
of the Path parameter contains "HKLM:", indicating that it is being used in the `HKEY_LOCAL_MACHINE`
registry drive.

```powershell
function Sample {
    Param ([String]$Name, [String]$Path)
    dynamicparam {
        if ($path -match "*HKLM*:") {
            $dynParam1 = New-Object System.Management.Automation.RuntimeDefinedParameter("dp1", [Int32], $attributeCollection)

            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.ParameterSetName = 'pset1'
            $attributes.Mandatory = $false

            $attributeCollection = New-Object -Type System.Collections.ObjectModel.Collection``1[System.Attribute]
            $attributeCollection.Add($attributes)

            $paramDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add("dp1", $dynParam1)
            return $paramDictionary
        }
    }
}
```

The type used to create an object to represent a dynamic parameter is
`System.Management.Automation.RuntimeDefinedParameter`.

The type used to create an object to represent the attributes of the parameter is
`System.Management.Automation.ParameterAttribute`.

The implementation-defined attributes of the parameter include **Mandatory**, **Position**, and
**ValueFromPipeline**.

### 8.10.9 param block

A *param-block* provides an alternate way of declaring parameters. For example, the following sets
of parameter declarations are equivalent:

```powershell
function FindStr1 ([string]$str, [int]$start_pos = 0) { ... }
function FindStr2 {
    param ([string]$str, [int]$start_pos = 0) ...
}
```

A *param-block* allows an *attribute-list* on the *param-block* whereas a
*function-parameter-declaration* does not.

A script may have a *param-block* but not a *function-parameter-declaration*. A function or filter
definition may have a *function-parameter-declaration* or a *param-block*, but not both.

Consider the following example:

```powershell
param ( [Parameter(Mandatory = $true, ValueFromPipeline=$true)]
        [string[]] $ComputerName )
```

The one parameter, `$ComputerName`, has type `string[]`, it is required, and it takes input from the
pipeline.

See [§12.3.7][§12.3.7] for a discussion of the **Parameter** attribute and for more examples.

## 8.11 The parallel statement

Syntax:

```Syntax
parallel-statement:
    *parallel* statement-block
```

The parallel statement contains zero or more statements that are executed in an implementation
defined manner.

A parallel statement is only allowed in a workflow ([§8.10.2][§8.10.2]).

## 8.12 The sequence statement

Syntax:

```Syntax
sequence-statement:
    *sequence* statement-block
```

The sequence statement contains zero or more statements that are executed in an implementation
defined manner.

A sequence statement is only allowed in a workflow ([§8.10.2][§8.10.2]).

## 8.13 The inlinescript statement

Syntax:

```Syntax
inlinescript-statement:
    inlinescript statement-block
```

The inlinescript statement contains zero or more statements that are executed in an implementation
defined manner.

A inlinescript statement is only allowed in a workflow ([§8.10.2][§8.10.2]).

## 8.14 Parameter binding

When a script, function, filter, or cmdlet is invoked, each argument can be bound to the
corresponding parameter by position, with the first parameter having position zero.

Consider the following definition fragment for a function called `Get-Power`, and the calls to it:

```powershell
function Get-Power ([long]$base, [int]$exponent) { ... }

Get-Power 5 3       # argument 5 is bound to parameter $base in position 0
                    # argument 3 is bound to parameter $exponent in position 1
                    # no conversion is needed, and the result is 5 to the power 3

Get-Power 4.7 3.2   # double argument 4.7 is rounded to int 5, double argument
                    # 3.2 is rounded to int 3, and result is 5 to the power 3

Get-Power 5         # $exponent has value $null, which is converted to int 0

Get-Power           # both parameters have value $null, which is converted to int 0
```

When a script, function, filter, or cmdlet is invoked, an argument can be bound to the corresponding
parameter by name. This is done by using a *parameter with argument*, which is an argument that is
the parameter's name with a leading dash (-), followed by the associated value for that argument.
The parameter name used can have any case-insensitive spelling and can use any prefix that uniquely
designates the corresponding parameter. When choosing parameter names, avoid using the names of the
[common parameters](/powershell/module/microsoft.powershell.core/about/about_commonparameters).

Consider the following calls to function `Get-Power`:

```powershell
Get-Power -base 5 -exponent 3   # -base designates $base, so 5 is
                                # bound to that, exponent designates
                                # $exponent, so 3 is bound to that

Get-Power -Exp 3 -BAs 5         # $base takes on 5 and $exponent takes on 3

Get-Power -e 3 -b 5             # $base takes on 5 and $exponent takes on 3
```

On the other hand, calls to the following function

```powershell
function Get-Hypot ([double]$side1, [double]$side2) {
    return [Math]::Sqrt($side1 * $side1 + $side2 * $side2)
}
```

must use parameters `-side1` and `-side2`, as there is no prefix that uniquely designates the
parameter.

The same parameter name cannot be used multiple times with or without different associated argument
values.

Parameters can have attributes (§12). For information about the individual attributes see the
sections within [§12.3][§12.3]. For information about parameter sets see [§12.3][§12.3].7.

A script, function, filter, or cmdlet can receive arguments via the invocation command line, from
the pipeline, or from both. Here are the steps, in order, for resolving parameter binding:

1. Bind all named parameters, then
1. Bind positional parameters, then
1. Bind from the pipeline by value ([§12.3.7][§12.3.7]) with exact match, then
1. Bind from the pipeline by value ([§12.3.7][§12.3.7]) with conversion, then
1. Bind from the pipeline by name ([§12.3.7][§12.3.7]) with exact match, then
1. Bind from the pipeline by name ([§12.3.7][§12.3.7]) with conversion

Several of these steps involve conversion, as described in [§6.][§6.] However, the set of conversions
used in binding is not exactly the same as that used in language conversions. Specifically,

- Although the value `$null` can be cast to bool, `$null` cannot be bound to `bool`.
- When the value `$null` is passed to a switch parameter for a cmdlet, it is treated as if `$true`
  was passed. However, when passed to a switch parameter for a function, it is treated as if
  `$false` was passed.
- Parameters of type bool or switch can only bind to numeric or bool arguments.
- If the parameter type is not a collection, but the argument is some sort of collection, no
  conversion is attempted unless the parameter type is object or PsObject. (The main point of this
  restriction is to disallow converting a collection to a string parameter.) Otherwise, the usual
  conversions are attempted.

If the parameter type is `IList` or `ICollection<T>`, only those conversions via Constructor,
op_Implicit, and op_Explicit are attempted. If no such conversions exist, a special conversion for
parameters of "collection" type is used, which includes `IList`, `ICollection<T>`, and arrays.

Positional parameters prefer to be bound without type conversion, if possible. For example,

```powershell
function Test {
    [CmdletBinding(DefaultParameterSetname = "SetB")]
    param([Parameter(Position = 0, ParameterSetname = "SetA")]
        [decimal]$dec,
        [Parameter(Position = 0, ParameterSetname = "SetB")]
        [int]$in
    )
    $PsCmdlet.ParameterSetName
}

Test 42d   # outputs "SetA"
Test 42    # outputs "SetB"
```

<!-- reference links -->
[§12.3.7]: chapter-12.md#1237-the-parameter-attribute
[§12.3]: chapter-12.md#123-reserved-attributes
[§2.3.2.2]: chapter-02.md#2322-automatic-variables
[§2.3.4]: chapter-02.md#234-parameters
[§2.3.5.2]: chapter-02.md#2352-string-literals
[§3.15]: chapter-03.md#315-wildcard-expressions
[§3.16]: chapter-03.md#316-regular-expressions
[§3.5.5]: chapter-03.md#355-dot-source-notation
[§3.8]: chapter-03.md#38-name-lookup
[§4.5.11]: chapter-04.md#4511-filter-description-type
[§4.5.16]: chapter-04.md#4516-enumerator-description-type
[§6.]: chapter-06.md#6-conversions
[§7.11]: chapter-07.md#711-assignment-operators
[§7.12]: chapter-07.md#712-redirection-operators
[§7.8.1]: chapter-07.md#781-equality-and-relational-operators
[§8.1.1]: chapter-08.md#811-labeled-statements
[§8.10.2]: chapter-08.md#8102-workflow-functions
[§8.10.4]: chapter-08.md#8104-parameter-initializers
[§8.10.5]: chapter-08.md#8105-the-switch-type-constraint
[§8.10.7]: chapter-08.md#8107-named-blocks
[§8.10]: chapter-08.md#810-function-definitions
[§8.14]: chapter-08.md#814-parameter-binding
[§8.4]: chapter-08.md#84-iteration-statements
[§8.5.1]: chapter-08.md#851-the-break-statement
[§8.5.2]: chapter-08.md#852-the-continue-statement
[§8.5.3]: chapter-08.md#853-the-throw-statement
[§8.5.4]: chapter-08.md#854-the-return-statement
[§8.5.5]: chapter-08.md#855-the-exit-statement
[§8.6]: chapter-08.md#86-the-switch-statement
[§8.7]: chapter-08.md#87-the-tryfinally-statement
[§8.8]: chapter-08.md#88-the-trap-statement

# /./lang-spec/chapter-09.md - Arrays

    ---
    description: PowerShell supports arrays of one or more dimensions with each dimension having zero or more elements.
    ms.date: 12/09/2022
    title: Arrays
    ---
# 9. Arrays

## 9.1 Introduction

PowerShell supports arrays of one or more dimensions with each dimension having zero or more
*elements*. Within a dimension, elements are numbered in ascending integer order starting at zero.
Any individual element can be accessed via the array subscript operator `[]` ([§7.1.4][§7.1.4]). The
number of dimensions in an array is called its *rank*.

An element can contain a value of any type including an array type. An array having one or more
elements whose values are of any array type is called a *jagged array*. A *multidimensional array*
has multiple dimensions, in which case, the number of elements in each row of a dimension is the
same. An element of a jagged array may contain a multidimensional array, and vice versa.

Multidimensional arrays are stored in row-major order. The number of elements in an array is called
that array's *length*, which is fixed when the array is created. As such, the elements in a
1-dimensional array *A* having length *N* can be accessed (i.e., *subscripted*) using the
expressions `A[0], A[1], ..., A[N-1]`. The elements in a 2-dimensional array *B* having *M* rows,
with each row having *N* columns, can be accessed using the expressions
`B[0,0], B[0,1], ..., B[0,N-1], B[1,0], B[1,1], ..., B[1,N-1], ..., B[M-1,0], B[M-1,1], ..., B[M-1,N-1]`.
And so on for arrays with three or more dimensions.

By default, an array is *polymorphic*; i.e., its elements do not need to all have the same type. For
example,

```powershell
$items = 10,"blue",12.54e3,16.30D # 1-D array of length 4
$items[1] = -2.345
$items[2] = "green"

$a = New-Object 'object[,]' 2,2 # 2-D array of length 4
$a[0,0] = 10
$a[0,1] = $false
$a[1,0] = "red"
$a[1,1] = $null
```

A 1-dimensional array has type `type[]`, a 2-dimensional array has type `type[,]`, a 3-dimensional
array has type `type[,,]`, and so on, where *type* is object for an unconstrained type array, or the
constrained type for a constrained array ([§9.4][§9.4]).

All array types are derived from the type Array ([§4.3.2][§4.3.2]).

## 9.2 Array creation

An array is created via an *array creation expression*, which has the following forms: unary comma
operator ([§7.2.1][§7.2.1]) ,*array-expression* ([§7.1.7][§7.1.7]), binary comma operator ([§7.3][§7.3]), range
operator ([§7.4][§7.4]), or [New-Object](xref:Microsoft.PowerShell.Utility.New-Object) cmdlet.

Here are some examples of array creation and usage:

```powershell
$values = 10, 20, 30
for ($i = 0; $i -lt $values.Length; ++$i) {
    "`$values[$i] = $($values[$i])"
}

$x = , 10                         # x refers to an array of length 1
$x = @(10)                        # x refers to an array of length 1
$x = @()                          # x refers to an array of length 0

$a = New-Object 'object[,]' 2, 2  # create a 2x2 array of anything
$a[0, 0] = 10                     # set to an int value
$a[0, 1] = $false                 # set to a boolean value
$a[1, 0] = "red"                  # set to a string value
$a[1, 1] = 10.50D                 # set to a decimal value
foreach ($e in $a) {              # enumerate over the whole array
    $e
}
```

The following is written to the pipeline:

```Output
$values[0] = 10
$values[1] = 20
$values[2] = 30

10
False
red
10.50
```

The default initial value of any element not explicitly initialized is the default value for that
element's type (that is, `$false`, zero, or `$null`).

## 9.3 Array concatenation

Arrays of arbitrary type and length can be concatenated via the `+` and `+=` operators, both of
which result in the creation of a new unconstrained 1-dimensional array. The existing arrays are
unchanged. See [§7.7.3][§7.7.3] for more information, and [§9.4][§9.4] for a discussion of adding to an array
of constrained type.

## 9.4 Constraining element types

A 1-dimensional array can be created so that it is type-constrained by prefixing the array-creation
expression with an array type cast. For example,

```powershell
$a = [int[]](1,2,3,4)   # constrained to int
$a[1] = "abc"           # implementation-defined behavior
$a += 1.23              # new array is unconstrained
```

The syntax for creating a multidimensional array requires the specification of a type, and that type
becomes the constraint type for that array. However, by specifying type `object[]`, there really is
no constraint as a value of any type can be assigned to an element of an array of that type.

Concatenating two arrays ([§7.7.3][§7.7.3]) always results in a new array that is unconstrained even if
both arrays are constrained by the same type. For example,

```powershell
$a = [int[]](1,2,3)    # constrained to int
$b = [int[]](10,20)    # constrained to int
$c = $a + $b           # constraint not preserved
$c = [int[]]($a + $b)  # result explicitly constrained to int
```

## 9.5 Arrays as reference types

As array types are reference types, a variable designating an array can be made to refer to any
array of any rank, length, and element type. For example,

```powershell
$a = 10,20                     # $a refers to an array of length 2
$a = 10,20,30                  # $a refers to a different array, of length 3
$a = "red",10.6                # $a refers to a different array, of length 2
$a = New-Object 'int[,]' 2,3   # $a refers to an array of rank 2
```

Assignment of an array involves a shallow copy; that is, the variable assigned to refers to the same
array, no copy of the array is made. For example,

```powershell
$a = 10,20,30
">$a<"
$b = $a         # make $b refer to the same array as $a
">$b<"

$a[0] = 6       # change value of [0] via $a
">$a<"
">$b<"          # change is reflected in $b

$b += 40        # make $b refer to a new array
$a[0] = 8       # change value of [0] via $a
">$a<"
">$b<"          # change is not reflected in $b
```

The following is written to the pipeline:

```Output
>10 20 30<
>10 20 30<
>6 20 30<
>6 20 30<
>8 20 30<
>6 20 30 40<
```

## 9.6 Arrays as array elements

Any element of an array can itself be an array. For example,

```powershell
$colors = "red", "blue", "green"
$list = $colors, (,7), (1.2, "yes") # parens in (,7) are redundant; they
                                    # are intended to aid readability
"`$list refers to an array of length $($list.Length)"
">$($list[1][0])<"
">$($list[2][1])<"
```

The following is written to the pipeline:

```Output
$list refers to an array of length 3
>7<
>yes<
```

`$list[1]` refers to an array of 1 element, the integer 7, which is accessed via `$list[1][0]`, as
shown. Compare this with the following subtly different case:

```powershell
$list = $colors, 7, (1.2, "yes") # 7 has no prefix comma
">$($list[1])<"
```

Here, `$list[1]` refers to a scalar, the integer 7, which is accessed via `$list[1]`.

Consider the following example,

```powershell
$x = [string[]]("red","green")
$y = 12.5, $true, "blue"
$a = New-Object 'object[,]' 2,2
$a[0,0] = $x               # element is an array of 2 strings
$a[0,1] = 20               # element is an int
$a[1,0] = $y               # element is an array of 3 objects
$a[1,1] = [int[]](92,93)   # element is an array of 2 ints
```

## 9.7 Negative subscripting

This is discussed in [§7.1.4.1][§7.1.4.1].

## 9.8 Bounds checking

This is discussed in [§7.1.4.1][§7.1.4.1].

## 9.9 Array slices

An *array slice* is an unconstrained 1-dimensional array whose elements are copies of zero or more
elements from a collection. An array slice is created via the subscript operator `[]`
([§7.1.4.5][§7.1.4.5]).

## 9.10 Copying an array

A contiguous set of elements can be copied from one array to another using the method
`[Array]::Copy`. For example,

```powershell
$a = [int[]](10,20,30)
$b = [int[]](0,1,2,3,4,5)
[Array]::Copy($a, $b, 2)        # $a[0]->$b[0],
$a[1]->$b[1]
[Array]::Copy($a, 1, $b, 3, 2)  # $a[1]->$b[3],
$a[2]->$b[4]
```

## 9.11 Enumerating over an array

Although it is possible to loop through an array accessing each of its elements via the subscript
operator, we can enumerate over that array's elements using the foreach statement. For a
multidimensional array, the elements are processed in row-major order. For example,

```powershell
$a = 10, 53, 16, -43
foreach ($elem in $a) {
    # do something with element via $elem
}

foreach ($elem in -5..5) {
    # do something with element via $elem
}

$a = New-Object 'int[,]' 3, 2
foreach ($elem in $a) {
    # do something with element via $elem
}
```

## 9.12 Multidimensional array flattening

Some operations on a multidimensional array (such as replication ([§7.6.3][§7.6.3]) and concatenation
([§7.7.3][§7.7.3])) require that array to be *flattened*; that is, to be turned into a 1-dimensional array
of unconstrained type. The resulting array takes on all the elements in row-major order.

Consider the following example:

```powershell
$a = "red",$true
$b = (New-Object 'int[,]' 2,2)
$b[0,0] = 10
$b[0,1] = 20
$b[1,0] = 30
$b[1,1] = 40
$c = $a + $b
```

The array designated by `$c` contains the elements "red", `$true`, 10, 20, 30, and 40.

<!-- reference links -->
[§4.3.2]: chapter-04.md#432-arrays
[§7.1.4.1]: chapter-07.md#7141-subscripting-an-array
[§7.1.4.5]: chapter-07.md#7145-generating-array-slices
[§7.1.4]: chapter-07.md#714-element-access
[§7.1.7]: chapter-07.md#717--operator
[§7.2.1]: chapter-07.md#721-unary-comma-operator
[§7.3]: chapter-07.md#73-binary-comma-operator
[§7.4]: chapter-07.md#74-range-operator
[§7.6.3]: chapter-07.md#763-array-replication
[§7.7.3]: chapter-07.md#773-array-concatenation
[§9.4]: chapter-09.md#94-constraining-element-types

# /./lang-spec/chapter-10.md - Hashtables

    ---
    description: A Hashtable represents a collection of key/value pair objects that supports efficient retrieval of a value when indexed by the key.
    ms.date: 05/19/2021
    title: Hashtables
    ---
# 10. Hashtables

Syntax:

> [!TIP]
> The `~opt~` notation in the syntax definitions indicates that the lexical entity is optional in
> the syntax.

```Syntax
hash-literal-expression:
    @{ new-lines~opt~ hash-literal-body~opt~ new-lines~opt~ }

hash-literal-body:
    hash-entry
    hash-literal-body statement-terminators hash-entry

hash-entry:
    key-expression = new-lines~opt~ statement

key-expression:
    simple-name
    unary-expression

statement-terminator:
    ;
    new-line-character
```

## 10.1 Introduction

The type Hashtable represents a collection of *key/value pair* objects that supports efficient
retrieval of a value when indexed by the key. Each key/value pair is an *element*, which is stored
in some implementation-defined object type.

An element's key cannot be the null value. There are no restrictions on the type of a key or value.
Duplicate keys are not supported.

Given a key/value pair object, the key and associated value can be obtained by using the instance
properties Key and Value, respectively.

Given one or more keys, the corresponding value(s) can be accessed via the Hashtable subscript
operator `[]` ([§7.1.4.3][§7.1.4.3]).

All Hashtables have type `Hashtable` ([§4.3.3][§4.3.3]).

The order of the keys in the collection returned by Keys is unspecified; however, it is the same
order as the associated values in the collection returned by Values.

Here are some examples involving Hashtables:

```powershell
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
$h1.FirstName # designates the key FirstName
$h1["LastName"] # designates the associated value for key LastName
$h1.Keys # gets the collection of keys
```

`Hashtable` elements are stored in an object of type **DictionaryEntry**, and the collections
returned by Keys and Values have type **ICollection**.

## 10.2 Hashtable creation

A `Hashtable` is created via a hash literal ([§7.1.9][§7.1.9]) or the
[New-Object](xref:Microsoft.PowerShell.Utility.New-Object) cmdlet. It can be created with zero or
more elements. The Count property returns the current element count.

## 10.3 Adding and removing Hashtable elements

An element can be added to a `Hashtable` by assigning ([§7.11.1][§7.11.1]) a value to a non-existent key
name or to a subscript ([§7.1.4.3][§7.1.4.3]) that uses a non-existent key name. Removal of an element
requires the use of the Remove method. For example,

```powershell
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
$h1.Dept = "Finance" # adds element Finance
$h1["Salaried"] = $false # adds element Salaried
$h1.Remove("Salaried") # removes element Salaried
```

## 10.4 Hashtable concatenation

Hashtables can be concatenated via the `+` and `+=` operators, both of which result in the creation
of a new `Hashtable`. The existing Hashtables are unchanged. See [§7.7.4][§7.7.4] for more information.

## 10.5 Hashtables as reference types

As `Hashtable` is a reference type, assignment of a `Hashtable` involves a shallow copy; that is,
the variable assigned to refers to the same `Hashtable`; no copy of the `Hashtable` is made. For
example,

```powershell
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123 }
$h2 = $h1
$h1.FirstName = "John" # change key's value in $h1
$h2.FirstName # change is reflected in $h2
```

## 10.6 Enumerating over a Hashtable

To process every pair in a `Hashtable`, use the **Keys** property to retrieve the list of keys as an
array, and then enumerate over the elements of that array getting the associated value via the
**Value** property or a subscript, as follows

```powershell
$h1 = @{ FirstName = "James"; LastName = "Anderson"; IDNum = 123}
foreach ($e in $h1.Keys) {
   "Key is " + $e + ", Value is " + $h1[$e]
}
```

<!-- reference links -->
[§4.3.3]: chapter-04.md#433-hashtables
[§7.1.4.3]: chapter-07.md#7143-subscripting-a-hashtable
[§7.1.9]: chapter-07.md#719-hash-literal-expression
[§7.11.1]: chapter-07.md#7111-simple-assignment
[§7.7.4]: chapter-07.md#774-hashtable-concatenation

# /./lang-spec/chapter-11.md - Modules

    ---
    description: A module is a self-contained reusable unit of PowerShell code. A module can contain commands (such as cmdlets and functions) and items (such as variables and aliases).
    ms.date: 05/19/2021
    title: Modules
    ---
# 11. Modules

## 11.1 Introduction

As stated in [§3.14][§3.14], a module is a self-contained reusable unit that allows PowerShell code to be
partitioned, organized, and abstracted. A module can contain one or more *module members*, which are
commands (such as cmdlets and functions) and items (such as variables and aliases). The names of
these members can be kept private to the module or they may be *exported* to the session into which
the module is *imported*.

There are three different *module types*: manifest, script, and binary. A *manifest module* is a
file that contains information about a module, and controls certain aspects of that module's use. A
*script module* is a PowerShell script file with a file extension of `.psm1` instead of `.ps1`. A
*binary module* contains class types that define cmdlets and providers. Unlike script modules,
binary modules are written in compiled languages. Binary modules are not covered by this
specification.

A binary module is a .NET assembly (i.e.; a DLL) that was compiled against the PowerShell libraries.

Modules may *nest*; that is, one module may import another module. A module that has associated
nested modules is a *root module*.

When a PowerShell session is created, by default, no modules are imported.

When modules are imported, the search path used to locate them is defined by the environment
variable **PSModulePath**.

The following cmdlets deal with modules:

- [Get-Module](xref:Microsoft.PowerShell.Core.Get-Module): Identifies the modules that have been, or
can be imported
- [Import-Module](xref:Microsoft.PowerShell.Core.Import-Module): Adds one or more modules to the
  current session (see [§11.4][§11.4])
- [Export-ModuleMember](xref:Microsoft.PowerShell.Core.Export-ModuleMember): Identifies the module
  members that are to be exported
- [Remove-Module](xref:Microsoft.PowerShell.Core.Remove-Module): Removes one or more modules from
  the current session (see [§11.5][§11.5])
- [New-Module](xref:Microsoft.PowerShell.Core.New-Module): Creates a dynamic module (see [§11.7][§11.7])

## 11.2 Writing a script module

A script module is a script file. Consider the following script module:

```powershell
function Convert-CentigradeToFahrenheit ([double]$tempC) {
    return ($tempC * (9.0 / 5.0)) + 32.0
}
New-Alias c2f Convert-CentigradeToFahrenheit

function Convert-FahrenheitToCentigrade ([double]$tempF) {
    return ($tempF - 32.0) * (5.0 / 9.0)
}
New-Alias f2c Convert-FahrenheitToCentigrade

Export-ModuleMember -Function Convert-CentigradeToFahrenheit
Export-ModuleMember -Function Convert-FahrenheitToCentigrade
Export-ModuleMember -Alias c2f, f2c
```

This module contains two functions, each of which has an alias. By default, all function names, and
only function names are exported. However, once the cmdlet `Export-ModuleMember` has been used to
export anything, then only those things exported explicitly will be exported. A series of commands
and items can be exported in one call or a number of calls to this cmdlet; such calls are cumulative
for the current session.

## 11.3 Installing a script module

A script module is defined in a script file, and modules can be stored in any directory. The
environment variable PSModulePath points to a set of directories to be searched when module-related
cmdlets look for modules whose names do not include a fully qualified path. Additional lookup paths
can be provided; for example,

`$Env:PSModulepath = $Env:PSModulepath + ";<additional-path>"`

Any additional paths added affect the current session only.

Alternatively, a fully qualified path can be specified when a module is imported.

## 11.4 Importing a script module

Before the resources in a module can be used, that module must be imported into the current session,
using the cmdlet `Import-Module`. `Import-Module` can restrict the resources that it actually
imports.

When a module is imported, its script file is executed. That process can be configured by defining
one or more parameters in the script file, and passing in corresponding arguments via the
ArgumentList parameter of `Import-Module`.

Consider the following script that uses these functions and aliases defined in [§11.2][§11.2]:

`Import-Module` "E:\Scripts\Modules\PSTest\_Temperature" -Verbose

```powershell
"0 degrees C is " + (Convert-CentigradeToFahrenheit 0) + " degrees F"
"100 degrees C is " + (c2f 100) + " degrees F"
"32 degrees F is " + (Convert-FahrenheitToCentigrade 32) + " degrees C"
"212 degrees F is " + (f2c 212) + " degrees C"
```

Importing a module causes a name conflict when commands or items in the module have the same names
as commands or items in the session. A name conflict results in a name being hidden or replaced. The
Prefix parameter of `Import-Module` can be used to avoid naming conflicts. Also, the **Alias**,
**Cmdlet**, **Function**, and **Variable** parameters can limit the selection of commands to be
imported, thereby reducing the chances of name conflict.

Even if a command is hidden, it can be run by qualifying its name with the name of the module in
which it originated. For example, `& M\F 100` invokes the function *F* in module *M*, and passes it
the argument 100.

When the session includes commands of the same kind with the same name, such as two cmdlets with the
same name, by default it runs the most recently added command.

See [§3.5.6][§3.5.6] for a discussion of scope as it relates to modules.

## 11.5 Removing a script module

One or more modules can be removed from a session via the cmdlet `Remove-Module`.

Removing a module does not uninstall the module.

In a script module, it is possible to specify code that is to be executed prior to that module's
removal, as follows:

`$MyInvocation.MyCommand.ScriptBlock.Module.OnRemove = { *on-removal-code* }`

## 11.6 Module manifests

As stated in [§11.1][§11.1], a manifest module is a file that contains information about a module, and
controls certain aspects of that module's use.

A module need not have a corresponding manifest, but if it does, that manifest has the same name as
the module it describes, but with a `.psd1` file extension.

A manifest contains a limited subset of PowerShell script, which returns a Hashtable containing a
set of keys. These keys and their values specify the *manifest elements* for that module. That is,
they describe the contents and attributes of the module, define any prerequisites, and determine how
the components are processed.

Essentially, a manifest is a data file; however, it can contain references to data types, the if
statement, and the arithmetic and comparison operators. (Assignments, function definitions and loops
are not permitted.) A manifest also has read access to environment variables and it can contain
calls to the cmdlet `Join-Path`, so paths can be constructed.

> [!NOTE]
> Editor's Note: The original document contains a list of keys allowed in a module manifest file.
> That list is outdated and incomplete. For a complete list of keys in a module manifest, see
> [New-ModuleManifest](/powershell/module/microsoft.powershell.core/new-modulemanifest).

The only key that is required is **ModuleVersion**.

Here is an example of a simple manifest:

```powershell
@{
ModuleVersion = '1.0'
Author = 'John Doe'
RequiredModules = @()
FunctionsToExport = 'Set*','Get*','Process*'
}
```

The key **GUID** has a `string` value. This specifies a Globally Unique IDentifier (GUID) for the
module. The **GUID** can be used to distinguish among modules having the same name. To create a new
GUID, call the method `[guid]::NewGuid()`.

## 11.7 Dynamic modules

A *dynamic module* is a module that is created in memory at runtime by the cmdlet `New-Module`; it
is not loaded from disk. Consider the following example:

```powershell
$sb = {
    function Convert-CentigradeToFahrenheit ([double]$tempC) {
        return ($tempC * (9.0 / 5.0)) + 32.0
    }

    New-Alias c2f Convert-CentigradeToFahrenheit

    function Convert-FahrenheitToCentigrade ([double]$tempF) {
        return ($tempF - 32.0) * (5.0 / 9.0)
    }

    New-Alias f2c Convert-FahrenheitToCentigrade

    Export-ModuleMember -Function Convert-CentigradeToFahrenheit
    Export-ModuleMember -Function Convert-FahrenheitToCentigrade
    Export-ModuleMember -Alias c2f, f2c
}

New-Module -Name MyDynMod -ScriptBlock $sb
Convert-CentigradeToFahrenheit 100
c2f 100
```

The script block `$sb` defines the contents of the module, in this case, two functions and two
aliases to those functions. As with an on-disk module, only functions are exported by default, so
`Export-ModuleMember` cmdlets calls exist to export both the functions and the aliases.

Once `New-Module` runs, the four names exported are available for use in the session, as is shown by
the calls to the `Convert-CentigradeToFahrenheit` and c2f.

Like all modules, the members of dynamic modules run in a private module scope that is a child of
the global scope. `Get-Module` cannot get a dynamic module, but `Get-Command` can get the exported
members.

To make a dynamic module available to `Get-Module`, pipe a `New-Module` command to `Import-Module`,
or pipe the module object that `New-Module` returns, to `Import-Module`. This action adds the
dynamic module to the `Get-Module` list, but it does not save the module to disk or make it
persistent.

## 11.8 Closures

A dynamic module can be used to create a *closure*, a function with attached data. Consider the
following example:

```powershell
function Get-NextID ([int]$startValue = 1) {
    $nextID = $startValue
    {
        ($script:nextID++)
    }.GetNewClosure()
}

$v1 = Get-NextID      # get a scriptblock with $startValue of 0
& $v1                 # invoke Get-NextID getting back 1
& $v1                 # invoke Get-NextID getting back 2

$v2 = Get-NextID 100  # get a scriptblock with $startValue of 100
& $v2                 # invoke Get-NextID getting back 100
& $v2                 # invoke Get-NextID getting back 101
```

The intent here is that `Get-NextID` return the next ID in a sequence whose start value can be
specified. However, multiple sequences must be supported, each with its own `$startValue` and
`$nextID` context. This is achieved by the call to the method `[scriptblock]::GetNewClosure`
([§4.3.7][§4.3.7]).

Each time a new closure is created by `GetNewClosure`, a new dynamic module is created, and the
variables in the caller's scope (in this case, the script block containing the increment) are copied
into this new module. To ensure that the nextId defined inside the parent function (but outside the
script block) is incremented, the explicit script: scope prefix is needed.

Of course, the script block need not be a named function; for example:

```powershell
$v3 = & {      # get a scriptblock with $startValue of 200
    param ([int]$startValue = 1)
    $nextID = $startValue
    {
        ($script:nextID++)
    }.GetNewClosure()
} 200

& $v3          # invoke script getting back 200
& $v3          # invoke script getting back 201
```

<!-- reference links -->
[§11.1]: chapter-11.md#111-introduction
[§11.2]: chapter-11.md#112-writing-a-script-module
[§11.4]: chapter-11.md#114-importing-a-script-module
[§11.5]: chapter-11.md#115-removing-a-script-module
[§11.7]: chapter-11.md#117-dynamic-modules
[§3.14]: chapter-03.md#314-modules
[§3.5.6]: chapter-03.md#356-modules
[§4.3.7]: chapter-04.md#437-the-scriptblock-type

# /./lang-spec/chapter-12.md - Attributes

    ---
    description: An attribute object associates predefined system information with a target element, which can be a param block or a parameter.
    ms.date: 05/19/2021
    title: Attributes
    ---
# 12. Attributes

An *attribute* object associates predefined system information with a *target element*, which can be
a param block or a parameter ([§8.10][§8.10]). Each attribute object has an *attribute type*.

Information provided by an attribute is also known as *metadata*. Metadata can be examined by the
command or the execution environment to control how the command processes data or before run time by
external tools to control how the command itself is processed or maintained.

Multiple attributes can be applied to the same target element.

## 12.1 Attribute specification

> [!TIP]
> The `~opt~` notation in the syntax definitions indicates that the lexical entity is optional in
> the syntax.

```Syntax
attribute-list:
    attribute
    attribute-list new-lines~opt~ attribute

attribute:
    [ new-lines~opt~ attribute-name ( attribute-arguments new-lines~opt~ ) new-lines~opt~ ]
    type-literal

attribute-name:
    type-spec

attribute-arguments:
    attribute-argument
    attribute-argument new-lines~opt~ ,
    attribute-arguments

attribute-argument:
    new-lines~opt~ expression
    new-lines~opt~ simple-name
    new-lines~opt~ simple-name = new-lines~opt~ expression
```

An attribute consists of an *attribute-name* and an optional list of positional and named arguments.
The positional arguments (if any) precede the named arguments. A named argument consists of a
*simple-name*, optionally followed by an equal sign and followed by an *expression*. If the
expression is omitted, the value `$true` is assumed.

The *attribute-name* is a reserved attribute type ([§12.3][§12.3]) or some implementation-defined
attribute type.

## 12.2 Attribute instances

An attribute instance is an object of an attribute type. The instance represents an attribute at
run-time.

To create an object of some attribute type *A*, use the notation `A()`. An attribute is declared by
enclosing its instance inside `[]`, as in `[A()]`. Some attribute types have positional and named
parameters ([§8.14][§8.14]), just like functions and cmdlets. For example,

`[A(10,IgnoreCase=$true)]`

shows an instance of type *A* being created using a positional parameter whose argument value is 10,
and a named parameter, **IgnoreCase**, whose argument value is `$true`.

## 12.3 Reserved attributes

The attributes described in the following sections can be used to augment or modify the behavior of
PowerShell functions, filters, scripts, and cmdlets.

### 12.3.1 The Alias attribute

This attribute is used in a *script-parameter* to specify an alternate name for a parameter. A
parameter may have multiple aliases, and each alias name must be unique within a *parameter-list*.
One possible use is to have different names for a parameter in different parameter sets (see
**ParameterSetName**).

The attribute argument has type string[].

Consider a function call `Test1` that has the following param block, and which is called as shown:

```powershell
param (
    [Parameter(Mandatory = $true)]
    [Alias("CN")]
    [Alias("name", "system")]
    [string[]] $ComputerName
)

Test1 "Mars", "Saturn"                # pass argument by position
Test1 -ComputerName "Mars", "Saturn"  # pass argument by name
Test1 -CN "Mars", "Saturn"            # pass argument using first alias
Test1 -name "Mars", "Saturn"          # pass argument using second alias
Test1 -sys "Mars", "Saturn"           # pass argument using third alias
```

Consider a function call `Test2` that has the following param block, and which is called as shown:

```powershell
param (
    [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
    [Alias('PSPath')]
    [string] $LiteralPath
)

Get-ChildItem "E:\*.txt" | Test2 -LiteralPath { $_ ; "`n`t";
    $_.FullName + ".bak" }
Get-ChildItem "E:\*.txt" | Test2
```

Cmdlet `Get-ChildItem` (alias `Dir`) adds to the object it returns a new **NoteProperty** of type
`string`, called **PSPath**.

### 12.3.2 The AllowEmptyCollection attribute

This attribute is used in a *script-parameter* to allow an empty collection as the argument of a
mandatory parameter.

Consider a function call `Test` that has the following param block, and which is called as shown:

```powershell
param (
    [parameter(Mandatory = $true)]
    [AllowEmptyCollection()]
    [string[]] $ComputerName
)

Test "Red", "Green" # $computerName has Length 2
Test "Red" # $computerName has Length 1
Test -comp @() # $computerName has Length 0
```

### 12.3.3 The AllowEmptyString attribute

This attribute is used in a *script-parameter* to allow an empty string as the argument of a
mandatory parameter.

Consider a function call `Test` that has the following param block, and which is called as shown:

```powershell
param (
    [parameter(Mandatory = $true)]
    [AllowEmptyString()]
    [string] $ComputerName
)

Test "Red" # $computerName is "Red"
Test "" # empty string is permitted
Test -comp "" # empty string is permitted
```

### 12.3.4 The AllowNull attribute

This attribute is used in a *script-parameter* to allow $null as the argument of a mandatory
parameter for which no implicit conversion is available.

Consider a function call Test that has the following param block, and which is called as shown:

```powershell
param (
    [parameter(Mandatory = $true)]
    [AllowNull()]
    [int[]] $Values
)

Test 10, 20, 30     # $values has Length 3, values 10, 20, 30
Test 10, $null, 30  # $values has Length 3, values 10, 0, 30
Test -val $null     # $values has value $null
```

Note that the second case above does not need this attribute; there is already an implicit
conversion from `$null` to int.

### 12.3.5 The CmdletBinding attribute

This attribute is used in the *attribute-list* of *param-block* of a function to indicate that
function acts similar to a cmdlet. Specifically, it allows functions to access a number of methods
and properties through the $PsCmdlet variable by using begin, process, and end named blocks
([§8.10.7][§8.10.7]).

When this attribute is present, positional arguments that have no matching positional parameters
cause parameter binding to fail and $args is not defined. (Without this attribute $args would take
on any unmatched positional argument values.)

The following arguments are used to define the characteristics of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SupportsShouldProcess (named)</td>
<td><p>Type: bool; Default value: $false</p>
<p>Specifies whether the function supports calls to the ShouldProcess method, which is used to prompt the user for feedback before the function makes a change to the system. A value of $true indicates that it does. A value of $false indicates that it doesn't.</p></td>
</tr>
<tr class="even">
<td>ConfirmImpact (named)</td>
<td><p>Type: string; Default value: "Medium"</p>
<p>Specifies the impact level of the action performed. The call to the ShouldProcess method displays a confirmation prompt only when the ConfirmImpact argument is greater than or equal to the value of the $ConfirmPreference preference variable.</p>
<p>The possible values of this argument are:</p>
<p>None: Suppress all requests for confirmation.</p>
<p>Low: The action performed has a low risk of losing data.</p>
<p>Medium: The action performed has a medium risk of losing data.</p>
<p>High: The action performed has a high risk of losing data.</p>
<p>The value of $ConfirmPreference can be set so that only cmdlets with an equal or higher impact level can request confirmation before they perform their operation. For example, if $ConfirmPreference is set to Medium, cmdlets with a Medium or High impact level can request confirmation. Requests from cmdlets with a low impact level are suppressed.</p></td>
</tr>
<tr class="odd">
<td>DefaultParameterSetName (named)</td>
<td><p>Type: string; Default value: "__AllParameterSets"</p>
<p>Specifies the parameter set to use if that cannot be determined from the arguments. See the named argument ParameterSetName in the attribute Parameter ([§12.3.7][§12.3.7]).</p></td>
</tr>
<tr class="even">
<td>PositionalBinding (named)</td>
<td><p>Type: bool; Default value: $true</p>
<p>Specifies whether positional binding is supported or not. The value of this argument is ignored if any parameters specify non-default values for either the named argument Position or the named argument ParameterSetName in the attribute Parameter ([§12.3.7][§12.3.7]). Otherwise, if the argument is $false then no parameters are positional, otherwise parameters are assigned a position based on the order the parameters are specified.</p></td>
</tr>
</tbody>
</table>

Here's is an example of the framework for using this attribute:

```powershell
[CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = "Low")]
param ( ... )

begin { ... }
Get-process { ... }
end { ... }
```

### 12.3.6 The OutputType attribute

This attribute is used in the *attribute-list* of *param-block* to specify the types returned. The
following arguments are used to define the characteristics of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Type (position 0)</td>
<td><p>Type: string[] or array of type literals</p>
<p>A list of the types of the values that are returned.</p></td>
</tr>
<tr class="even">
<td>ParameterSetName (named)</td>
<td><p>Type: string[]</p>
<p>Specifies the parameter sets that return the types indicated by the corresponding elements of the Type parameter.</p></td>
</tr>
</tbody>
</table>

Here are several examples of this attribute's use:

```powershell
[OutputType([int])] param ( ... )
[OutputType("double")] param ( ... )
[OutputType("string","string")] param ( ... )
```


### 12.3.7 The Parameter attribute

This attribute is used in a *script-parameter*. The following named arguments are used to define the
characteristics of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HelpMessage (named)</td>
<td><p>Type: string</p>
<p>This argument specifies a message that is intended to contain a short description of the parameter. This message is used in an implementation-defined manner when the function or cmdlet is run yet a mandatory parameter having a HelpMessage does not have a corresponding argument.</p>
<p>The following example shows a parameter declaration that provides a description of the parameter.</p>
<p>param ( [Parameter(Mandatory = $true,<br />
HelpMessage = "An array of computer names.")]<br />
[string[]] $ComputerName )</p>
<p>Windows PowerShell: If a required parameter is not provided the runtime prompts the user for a parameter value. The prompt dialog box includes the HelpMessage text.</p></td>
</tr>
<tr class="even">
<td>Mandatory (named)</td>
<td><p>Type: bool; Default value: $false</p>
<p>This argument specifies whether the parameter is required within the given parameter set (see ParameterSetName argument below). A value of $true indicates that it is. A value of $false indicates that it isn't.</p>
<p>param ( [Parameter(Mandatory = $true)]<br />
[string[]] $ComputerName )</p>
<p>Windows PowerShell: If a required parameter is not provided the runtime prompts the user for a parameter value. The prompt dialog box includes the HelpMessage text, if any.</p></td>
</tr>
<tr class="odd">
<td>ParameterSetName (named)</td>
<td><p>Type: string; Default value: "__AllParameterSets"</p>
<p>It is possible to write a single function or cmdlet that can perform different actions for different scenarios. It does this by exposing different groups of parameters depending on the action it wants to take. Such parameter groupings are called <em>parameter sets</em>.</p>
<p>The argument ParameterSetName specifies the parameter set to which a parameter belongs. This behavior means that each parameter set must have one unique parameter that is not a member of any other parameter set.</p>
<p>For parameters that belong to multiple parameter sets, add a Parameter attribute for each parameter set. This allows the parameter to be defined differently for each parameter set.</p>
<p>A parameter set that contains multiple positional parameters must define unique positions for each parameter. No two positional parameters can specify the same position.</p>
<p>If no parameter set is specified for a parameter, the parameter belongs to all parameter sets.</p>
<p>When multiple parameter sets are defined, the named argument DefaultParameterSetName of the attribute CmdletBinding ([§12.3.5][§12.3.5]) is used to specify the default parameter set. The runtime uses the default parameter set if it cannot determine the parameter set to use based on the information provided by the command, or raises an exception if no default parameter set has been specified.</p>
<p>The following example shows a function Test with a parameter declaration of two parameters that belong to two different parameter sets, and a third parameter that belongs to both sets:</p>
<p>param ( [Parameter(Mandatory = $true,<br />
ParameterSetName = "Computer")]<br />
[string[]] $ComputerName,</p>
<p>[Parameter(Mandatory = $true,<br />
ParameterSetName = "User")]<br />
[string[]] $UserName,</p>
<p>[Parameter(Mandatory = $true,<br />
ParameterSetName = "Computer")]<br />
[Parameter(ParameterSetName = "User")]<br />
[int] $SharedParam = 5 )</p>
<p>if ($PsCmdlet.ParameterSetName -eq "Computer")<br />
{<br />
# handle "Computer" parameter set<br />
}</p>
<p>elseif ($PsCmdlet.ParameterSetName -eq "User")<br />
{<br />
# handle "User" parameter set<br />
}<br />
…<br />
}</p>
<p>Test -ComputerName "Mars","Venus" -SharedParam 10<br />
Test -UserName "Mary","Jack"<br />
Test -UserName "Mary","Jack" -SharedParam 20</p></td>
</tr>
<tr class="even">
<td>Position (named)</td>
<td><p>Type: int</p>
<p>This argument specifies the position of the parameter in the argument list. If this argument is not specified, the parameter name or its alias must be specified explicitly when the parameter is set. If none of the parameters of a function has positions, positions are assigned to each parameter based on the order in which they are received.</p>
<p>The following example shows the declaration of a parameter whose value must be specified as the first argument when the function is called.</p>
<p>param ( [Parameter(Position = 0)]<br />
[string[]] $ComputerName )</p></td>
</tr>
<tr class="odd">
<td>ValueFromPipeline (named)</td>
<td><p>Type: bool; Default value: $false</p>
<p>This argument specifies whether the parameter accepts input from a pipeline object. A value of $true indicates that it does. A value of $false indicates that it does not.</p>
<p>Specify $true if the function or cmdlet accesses the complete object, not just a property of the object.</p>
<p>Only one parameter in a parameter set can declare ValueFromPipeline as $true.</p>
<p>The following example shows the parameter declaration of a mandatory parameter, $ComputerName, that accepts the input object that is passed to the function from the pipeline.</p>
<p>param ( [Parameter(Mandatory = $true,<br />
ValueFromPipeline=$true)]<br />
[string[]] $ComputerName )</p>
<p>For an example of using this parameter in conjunction with the Alias attribute see [§12.3.1][§12.3.1]. </p></td>
</tr>
<tr class="even">
<td>ValueFromPipelineByPropertyName (named)</td>
<td><p>Type: bool; Default value: $false</p>
<p>This argument specifies whether the parameter takes its value from a property of a pipeline object that has either the same name or the same alias as this parameter. A value of $true indicates that it does. A value of $false indicates that it does not.</p>
<p>Specify $true if the following conditions are true: the parameter accesses a property of the piped object, and the property has the same name as the parameter, or the property has the same alias as the parameter.</p>
<p>A parameter having ValueFromPipelineByPropertyName set to $true need not have a parameter in the same set with ValueFromPipeline set to $true.</p>
<p>If a function has a parameter $ComputerName, and the piped object has a ComputerName property, the value of the ComputerName property is assigned to the $ComputerName parameter of the function:</p>
<p>param ( [parameter(Mandatory = $true,<br />
ValueFromPipelineByPropertyName = $true)]<br />
[string[]] $ComputerName )</p>
<p>Multiple parameters in a parameter set can define the ValueFromPipelineByPropertyName as $true. Although, a single input object cannot be bound to multiple parameters, different properties in that input object may be bound to different parameters.</p>
<p>When binding a parameter with a property of an input object, the runtime environment first looks for a property with the same name as the parameter.  If such a property does not exist, the runtime environment looks for aliases to that parameter, in their declaration order, picking the first such alias for which a property exists.</p>
<p>function Process-Date<br />
{<br />
param(<br />
[Parameter(ValueFromPipelineByPropertyName=$true)]<br />
[int]$Year,</p>
<p>[Parameter(ValueFromPipelineByPropertyName=$true)]<br />
[int]$Month,</p>
<p>[Parameter(ValueFromPipelineByPropertyName=$true)]<br />
[int]$Day<br />
)</p>
<p>process { … }<br />
}<br />
<br />
Get-Date | Process-Date</p></td>
</tr>
<tr class="odd">
<td>ValueFromRemainingArguments (named)</td>
<td><p>Type: bool; Default value: $false</p>
<p>This argument specifies whether the parameter accepts all of the remaining arguments that are not bound to the parameters of the function. A value of $true indicates that it does. A value of $false indicates that it does not.</p>
<p>The following example shows a parameter $others that accepts all the remaining arguments of the input object that is passed to the function Test:</p>
<p>param ( [parameter(Mandatory = $true)][int] $p1,<br />
[parameter(Mandatory = $true)][int] $p2,<br />
[parameter(ValueFromRemainingArguments = $true)]<br />
[string[]] $others )</p>
<p>Test 10 20 # $others has Length 0<br />
Test 10 20 30 40 # $others has Length 2, value 30,40</p></td>
</tr>
</tbody>
</table>

An implementation may define other attributes as well.

The following attributes are provided as well:

- **HelpMessageBaseName**: Specifies the location where resource identifiers reside. For example,
  this parameter could specify a resource assembly that contains Help messages that are to be
  localized.
- **HelpMessageResourceId**: Specifies the resource identifier for a Help message.

### 12.3.8 The PSDefaultValue attribute

This attribute is used in a *script-parameter* to provide additional information about the
parameter. The attribute is used in an implementation defined manner. The following arguments are
used to define the characteristics of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Help (named)</td>
<td><p>Type: string</p>
<p>This argument specifies a message that is intended to contain a short description of the default value of a parameter. This message is used in an implementation-defined manner.</p>
<p>Windows PowerShell: The message is used as part of the description of the parameter for the help topic displayed by the [Get-Help](xref:Microsoft.PowerShell.Core.Get-Help) cmdlet.</p></td>
</tr>
<tr class="even">
<td>Value (named)</td>
<td><p>Type: object</p>
<p>This argument specifies a value that is intended to be the default value of a parameter. The value is used in an implementation-defined manner.</p>
<p>Windows PowerShell: The value is used as part of the description of the parameter for the help topic displayed by the [Get-Help](xref:Microsoft.PowerShell.Core.Get-Help)cmdlet when the Help property is not specified.</p></td>
</tr>
</tbody>
</table>

### 12.3.9 The SupportsWildcards attribute

This attribute is used in a *script-parameter* to provide additional information about the
parameter. The attribute is used in an implementation defined manner.

This attribute is used as part of the description of the parameter for the help topic displayed by
the [Get-Help](xref:Microsoft.PowerShell.Core.Get-Help) cmdlet.

### 12.3.10 The ValidateCount attribute

This attribute is used in a *script-parameter* to specify the minimum and maximum number of argument
values that the parameter can accept. The following arguments are used to define the characteristics
of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MinLength (position 0)</td>
<td><p>Type: int</p>
<p>This argument specifies the minimum number of argument values allowed.</p></td>
</tr>
<tr class="even">
<td>MaxLength (position 1)</td>
<td><p>Type: int</p>
<p>This argument specifies the maximum number of argument values allowed.</p></td>
</tr>
</tbody>
</table>

In the absence of this attribute, the parameter's corresponding argument value list can be of any
length.

Consider a function call Test that has the following param block, and which is called as shown:

```powershell
param (
    [ValidateCount(2, 5)]
    [int[]] $Values
)

Temp 10, 20, 30
Temp 10                         # too few argument values
Temp 10, 20, 30, 40, 50, 60     # too many argument values

[ValidateCount(3, 4)]$Array = 1..3
$Array = 10                     # too few argument values
$Array = 1..100                 # too many argument values
```

### 12.3.11 The ValidateLength attribute

This attribute is used in a *script-parameter* or *variable* to specify the minimum and maximum
length of the parameter's argument, which must have type string. The following arguments are used to
define the characteristics of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MinLength (position 0)</td>
<td><p>Type: int</p>
<p>This argument specifies the minimum number of characters allowed.</p></td>
</tr>
<tr class="even">
<td>MaxLength (position 1)</td>
<td><p>Type: int</p>
<p>This argument specifies the maximum number of characters allowed.</p></td>
</tr>
</tbody>
</table>

In the absence of this attribute, the parameter's corresponding argument can be of any length.

Consider a function call Test that has the following param block, and which is called as shown:

```powershell
param ( [parameter(Mandatory = $true)]
[ValidateLength(3,6)]
[string[]] $ComputerName )

Test "Thor","Mars"     # length is ok
Test "Io","Mars"       # "Io" is too short
Test "Thor","Jupiter"  # "Jupiter" is too long
```

### 12.3.12 The ValidateNotNull attribute

This attribute is used in a *script-parameter* or *variable* to specify that the argument of the
parameter cannot be `$null` or be a collection containing a null-valued element.

Consider a function call `Test` that has the following param block, and which is called as `shown:

```powershell
param (
    [ValidateNotNull()]
    [string[]] $Names
)

Test "Jack", "Jill"     # ok
Test "Jane", $null      # $null array element value not allowed
Test $null              # null array not allowed

[ValidateNotNull()]$Name = "Jack" # ok
$Name = $null           # null value not allowed
```

### 12.3.13 The ValidateNotNullOrEmpty attribute

This attribute is used in a *script-parameter* or *variable* to specify that the argument if the
parameter cannot be $null, an empty string, or an empty array, or be a collection containing a
$null-valued or empty string element.

Consider a function call `Test` that has the following param block, and which is called as shown:

```powershell
param (
    [ValidateNotNullOrEmpty()]
    [string[]] $Names
)

Test "Jack", "Jill"    # ok
Test "Mary", ""        # empty string not allowed
Test "Jane", $null     # $null array element value not allowed
Test $null             # null array not allowed
Test @()               # empty array not allowed

[ValidateNotNullOrEmpty()]$Name = "Jack" # ok
$Name = ""             # empty string not allowed
$Name = $null          # null value not allowed
```

### 12.3.14 The ValidatePattern attribute

This attribute is used in a *script-parameter* or *variable* to specify a regular expression for
matching the pattern of the parameter's argument. The following arguments are used to define the
characteristics of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RegexString (position 0)</td>
<td><p>Type: String</p>
<p>A regular expression that is used to validate the parameter's argument</p></td>
</tr>
<tr class="even">
<td>Options (named)</td>
<td><p>Type: Regular-Expression-Option</p>
<p>See [§4.2.6.4][§4.2.6.4] for the allowed values.</p></td>
</tr>
</tbody>
</table>

If the argument is a collection, each element in the collection must match the pattern.

Consider a function call `Test` that has the following param block, and which is called as shown:

```powershell
param (
    [ValidatePattern('\^[A-Z][1-5][0-9]$')]
    [string] $Code,

    [ValidatePattern('\^(0x|0X)([A-F]|[a-f]|[0-9])([A-F]|[a-f]|[0-9])$')]
    [string] $HexNum,

    [ValidatePattern('\^[+|-]?[1-9]$')]
    [int] $Minimum
)

Test -c A12 # matches pattern
Test -c A63 # does not match pattern

Test -h 0x4f # matches pattern
Test -h "0XB2" # matches pattern
Test -h 0xK3 # does not match pattern

Test -m -4 # matches pattern
Test -m "+7" # matches pattern
Test -m -12 # matches pattern, but is too long

[ValidatePattern('\^[a-z][a-z0-9]\*$')]$ident = "abc"
$ident = "123" # does not match pattern
```

### 12.3.15 The ValidateRange attribute

This attribute is used in a *script-parameter* or *variable* to specify the minimum and maximum
values of the parameter's argument. The following arguments are used to define the characteristics
of the parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MinRange (position 0)</td>
<td><p>Type: object</p>
<p>This argument specifies the minimum value allowed.</p></td>
</tr>
<tr class="even">
<td>MaxRange (position 1)</td>
<td><p>Type: object</p>
<p>This argument specifies the maximum value allowed.</p></td>
</tr>
</tbody>
</table>

In the absence of this attribute, there is no range restriction.

Consider a function call `Test1` that has the following param block, and which is called as shown:

```powershell
param (
    [parameter(Mandatory = $true)]
    [ValidateRange(1, 10)]
    [int] $StartValue
)

Test1 2
Test1 -st 7
Test1 -3 # value is too small
Test1 12 # value is too large
```

Consider a function call Test2 that has the following param block and calls:

```powershell
param (
    [parameter(Mandatory = $true)]
    [ValidateRange("b", "f")]
    [string] $Name
)

Test2 "Bravo" # ok
Test2 "Alpha" # value compares less than the minimum
Test2 "Hotel" # value compares greater than the maximum
```

Consider a function call `Test3` that has the following param block, and which is called as shown:

```powershell
param (
    [parameter(Mandatory = $true)]
    [ValidateRange(0.002, 0.003)]
    [double] $Distance
)

Test3 0.002
Test3 0.0019    # value is too small
Test3 "0.005"   # value is too large

[ValidateRange(13, 19)]$teenager = 15
$teenager = 20  # value is too large
```

### 12.3.16 The ValidateScript attribute

This attribute is used in a *script-parameter* or *variable* to specify a script that is to be used
to validate the parameter's argument.

The argument in position 1 is a *script-block-expression*.

Consider a function call `Test` that has the following param block, and which is called as shown:

```powershell
param (
    [Parameter(Mandatory = $true)]
    [ValidateScript( { ($_ -ge 1 -and $_ -le 3) -or ($_ -ge 20) })]
    [int] $Count
)

Test 2 # ok, valid value
Test 25 # ok, valid value
Test 5 # invalid value
Test 0 # invalid value

[ValidateScript({$_.Length --gt 7})]$password = "password" # ok
$password = "abc123" # invalid value
```

### 12.3.17 The ValidateSet attribute

This attribute is used in a *script-parameter* or *variable* to specify a set of valid values for
the argument of the parameter. The following arguments are used to define the characteristics of the
parameter:

<table>
<thead>
<tr class="header">
<th><strong>Parameter Name</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ValidValues (position 0)</td>
<td><p>Type: string[]</p>
<p>The set of valid values.</p></td>
</tr>
<tr class="even">
<td>IgnoreCase (named)</td>
<td><p>Type: bool; Default value: $true</p>
<p>Specifies whether case should be ignored for parameters of type string.</p></td>
</tr>
</tbody>
</table>

If the parameter has an array type, every element of the corresponding argument array must match an
element of the value set.

Consider a function call `Test` that has the following param block, and which is called as shown:

```powershell
param ( [ValidateSet("Red", "Green", "Blue")]
    [string] $Color,

    [ValidateSet("up", "down", "left", "right", IgnoreCase =
        $false)]
    [string] $Direction

)

Test -col "RED"    # case is ignored, is a member of the set
Test -col "white"  # case is ignored, is not a member of the set

Test -dir "up"     # case is not ignored, is a member of the set
Test -dir "Up"     # case is not ignored, is not a member of the set

[ValidateSet(("Red", "Green", "Blue")]$color = "RED" # ok, case is ignored
$color = "Purple"  # case is ignored, is not a member of the set
```

<!-- reference links -->
[§12.3.1]: chapter-12.md#1231-the-alias-attribute
[§12.3.5]: chapter-12.md#1235-the-cmdletbinding-attribute
[§12.3.7]: chapter-12.md#1237-the-parameter-attribute
[§12.3]: chapter-12.md#123-reserved-attributes
[§4.2.6.4]: chapter-04.md#4264-regularexpressionoption-type
[§8.10.7]: chapter-08.md#8107-named-blocks
[§8.10]: chapter-08.md#810-function-definitions
[§8.14]: chapter-08.md#814-parameter-binding

# /./lang-spec/chapter-13.md - Cmdlets

    ---
    description: A cmdlet is a single-feature command that manipulates objects in PowerShell. Cmdlets can be recognized by their name format, a verb and noun separated by a dash.
    ms.date: 05/19/2021
    title: Cmdlets
    ---
# 13. Cmdlets

A cmdlet is a single-feature command that manipulates objects in PowerShell. Cmdlets can be
recognized by their name format, a verb and noun separated by a dash (`-`), such as `Get-Help`,
`Get-Process`, and `Start-Service`. A *verb pattern* is a verb expressed using wildcards, as
in `W*`. A *noun pattern* is a noun expressed using wildcards, as in *event*.

Cmdlets should be simple and be designed to be used in combination with other cmdlets. For example,
**Get** cmdlets should only retrieve data, **Set** cmdlets should only establish or change data,
**Format** cmdlets should only format data, and **Out** cmdlets should only direct the output to a
specified destination.

For each cmdlet, provide a help file that can be accessed by typing:

`get-help *cmdlet-name* -detailed`

The detailed view of the cmdlet help file should include a description of the cmdlet, the command
syntax, descriptions of the parameters, and an example that demonstrate the use of that cmdlet.

Cmdlets are used similarly to operating system commands and utilities. PowerShell commands are not
case-sensitive.

> [!NOTE]
> Editor's note: The original document contains a list of cmdlet with descriptions, syntax diagrams,
> parameter definitions, and examples. This information is incomplete and out dated. For current
> information about cmdlet, consult the **Reference** section of the
> [PowerShell documentation](/powershell/scripting/overview).

## 13.1 Common parameters

The *common parameters* are a set of cmdlet parameters that can be used with any cmdlet. They are
implemented by the PowerShell runtime environment itself, not by the cmdlet developer, and they are
automatically available to any cmdlet or function that uses the **Parameter** attribute
([§12.3.7][§12.3.7]) or **CmdletBinding** attribute ([§12.3.5][§12.3.5]).

Although the common parameters are accepted by any cmdlet, they might not have any semantics for
that cmdlet. For example, if a cmdlet does not generate any verbose output, using the **Verbose**
common parameter has no effect.

Several common parameters override system defaults or preferences that can be set via preference
variables ([§2.3.2.3][§2.3.2.3]). Unlike the preference variables, the common parameters affect only the
commands in which they are used.

> [!NOTE]
> Editor's note: The original document contains a list of the Common Parameters. This information is
> incomplete and out dated. For current information see
> [about_CommonParameters](/powershell/module/microsoft.powershell.core/about/about_commonparameters).

<!-- reference links -->
[§12.3.5]: chapter-12.md#1235-the-cmdletbinding-attribute
[§12.3.7]: chapter-12.md#1237-the-parameter-attribute
[§2.3.2.3]: chapter-02.md#2323-preference-variables

# /./lang-spec/chapter-14.md - A. Comment-Based Help

    ---
    description: PowerShell provides a mechanism for programmers to document their scripts using special comment directives. The Get-Help cmdlet generates documentation from these directives.
    ms.date: 05/19/2021
    title: Comment-Based Help
    ---

# A. Comment-Based Help

PowerShell provides a mechanism for programmers to document their scripts using special comment
directives. Comments using such syntax are called *help comments*. The cmdlet
[Get-Help](xref:Microsoft.PowerShell.Core.Get-Help) generates documentation from these directives.

## A.1 Introduction

A help comment contains a *help directive* of the form .*name* followed on one or more subsequent
lines by the help content text. The help comment can be made up of a series of
*single-line-comment*s or a *delimited-comment* ([§2.2.3][§2.2.3]). The set of comments comprising the
documentation for a single entity is called a *help topic*.

For example,

```powershell
# <help-directive-1>
# <help-content-1>
...

# <help-directive-n>
# <help-content-n>
```

or

```powershell
<#
<help-directive-1>
<help-content-1>
...

<help-directive-n>
<help-content-n>
#>
```

All of the lines in a help topic must be contiguous. If a help topic follows a comment that is not
part of that topic, there must be at least one blank line between the two.

The directives can appear in any order, and some of the directives may appear multiple times.

Directive names are not case-sensitive.

When documenting a function, help topics may appear in one of three locations:

- Immediately before the function definition with no more than one blank line between the last line
  of the function help and the line containing the function statement.
- Inside the function's body immediately following the opening curly bracket.
- Inside the function's body immediately preceding the closing curly bracket.

When documenting a script file, help topics may appear in one of two locations:

- At the beginning of the script file, optionally preceded by comments and blank lines only. If the
  first item in the script after the help is a function definition, there must be at least two blank
  lines between the end of the script help and that function declaration. Otherwise, the help will
  be interpreted as applying to the function instead of the script file.
- At the end of the script file.

## A.2 Help directives

### A.2.1 .DESCRIPTION

Syntax:

```Syntax
.DESCRIPTION
```

Description:

This directive allows for a detailed description of the function or script. (The `.SYNOPSIS`
directive ([§A.2.11][§A.2.11]) is intended for a brief description.) This directive can be used only once
in each topic.

Examples:

```powershell
<#
.DESCRIPTION
Computes Base to the power Exponent. Supports non-negative integer
powers only.
#>
```

### A.2.2 .EXAMPLE

Syntax:

```Syntax
.EXAMPLE
```

Description:

This directive allows an example of command usage to be shown.

If this directive occurs multiple times, each associated help content block is displayed as a
separate example.

Examples:

```powershell
<#
.EXAMPLE
Get-Power 3 4
81

.EXAMPLE
Get-Power -Base 3 -Exponent 4
81
#>
```

### A.2.3 .EXTERNALHELP

Syntax:

```Syntax
.EXTERNALHELP <XMLHelpFilePath>
```

Description:

This directive specifies the path to an XML-based help file for the script or function.

Although comment-based help is easier to implement, XML-based Help is required if more precise
control is needed over help content or if help topics are to be translated into multiple languages.
The details of XML-based help are not defined by this specification.

Examples:

```powershell
<#
.ExternalHelp C:\MyScripts\Update-Month-Help.xml
#>
```

### A.2.4 .FORWARDHELPCATEGORY

Syntax:

```Syntax
.FORWARDHELPCATEGORY <Category>
```

Description:

Specifies the help category of the item in **ForwardHelpTargetName** ([§A.2.5][§A.2.5]). Valid values are
**Alias**, **All**, **Cmdlet**, **ExternalScript**, **FAQ**, **Filter**, **Function**, **General**,
**Glossary**, **HelpFile**, **Provider**, and **ScriptCommand**. Use this directive to avoid
conflicts when there are commands with the same name.

Examples:

See [§A.2.5][§A.2.5].

### A.2.5 .FORWARDHELPTARGETNAME

Syntax:

```Syntax
.FORWARDHELPTARGETNAME <Command-Name>
```

Description:

Redirects to the help topic specified by `<Command-Name>`.

Examples:

```powershell
function Help {
<#
.FORWARDHELPTARGETNAME Get-Help
.FORWARDHELPCATEGORY Cmdlet
#>
    ...
}
```

The command `Get-Help help` is treated as if it were `Get-Help Get-Help` instead.

### A.2.6 .INPUTS

Syntax:

```Syntax
.INPUTS
```

Description:

The pipeline can be used to pipe one or more objects to a script or function. This directive is used
to describe such objects and their types.

If this directive occurs multiple times, each associated help content block is collected in the one
documentation entry, in the directives' lexical order.

Examples:

```powershell
<#
.INPUTS
None. You cannot pipe objects to Get-Power.

.INPUTS
For the Value parameter, one or more objects of any kind can be written
to the pipeline. However, the object is converted to a string before it
is added to the item.
#>
function Process-Thing {
    param ( ...
        [Parameter(ValueFromPipeline=$true)]
        [object[]]$Value,
        ...
    )
    ...
}
```

### A.2.7 .LINK

Syntax:

```Syntax
.LINK
```

Description:

This directive specifies the name of a related topic.

If this directive occurs multiple times, each associated help content block is collected in the one
documentation entry, in the directives' lexical order.

The Link directive content can also include a URI to an online version of the same help topic. The
online version is opens when Get-Help is invoked with the Online parameter. The URI must begin with
"http" or "https".

Examples:

```powershell
<#
.LINK
Online version: http://www.acmecorp.com/widget.html

.LINK
Set-ProcedureName
#>
```

### A.2.8 .NOTES

Syntax:

```Syntax
.NOTES
```

Description:

This directive allows additional information about the function or script to be provided. This
directive can be used only once in each topic.

Examples:

```powershell
<#
.Notes
*arbitrary text goes here*
#>
```

### A.2.9 .OUTPUTS

Syntax:

```Syntax
.OUTPUTS
```

Description:

This directive is used to describe the objects output by a command.

If this directive occurs multiple times, each associated help content block is collected in the one
documentation entry, in the directives' lexical order.

Examples:

```powershell
<#
.OUTPUTS
double - Get-Power returns Base to the power Exponent.

.OUTPUTS
None unless the -PassThru switch parameter is used.
#>
```

### A.2.10 .PARAMETER

Syntax:

```Syntax
.PARAMETER <Parameter-Name>
```

Description:

This directive allows for a detailed description of the given parameter. This directive can be used
once for each parameter. Parameter directives can appear in any order in the comment block; however,
the order in which their corresponding parameters are actually defined in the source determines the
order in which the parameters and their descriptions appear in the resulting documentation.

An alternate format involves placing a parameter description comment immediately before the
declaration of the corresponding parameter variable's name. If the source contains both a parameter
description comment and a Parameter directive, the description associated with the Parameter
directive is used.

Examples:

```powershell
<#
.PARAMETER Base
The integer value to be raised to the Exponent-th power.

.PARAMETER Exponent
The integer exponent to which Base is to be raised.
#>

function Get-Power {
    param ([long]$Base, [int]$Exponent)
    ...
}

function Get-Power {
    param ([long]
        # The integer value to be raised to the Exponent-th power.
        $Base,
        [int]
        # The integer exponent to which Base is to be raised.
        $Exponent
    )
    ...
}
```

### A.2.11 .SYNOPSIS

Syntax:

```powershell
.SYNOPSIS
```

Description:

This directive allows for a brief description of the function or script. (The `.DESCRIPTION`
directive ([§A.2.1][§A.2.1]) is intended for a detailed description.) This directive can be used only once
in each topic.

Examples:

```powershell
<#
.SYNOPSIS
Computes Base to the power Exponent.
#>
```

<!-- reference links -->
[§2.2.3]: chapter-02.md#223-comments
[§A.2.1]: chapter-14.md#a21-description
[§A.2.11]: chapter-14.md#a211-synopsis
[§A.2.5]: chapter-14.md#a25-forwardhelptargetname

# /./lang-spec/chapter-15.md - B. Grammar

    ---
    description: This appendix contains summaries of the lexical and syntactic grammars found in the main documents.
    ms.date: 05/19/2021
    title: Appendix A - Grammar
    ---
# B. Grammar

This appendix contains summaries of the lexical and syntactic grammars found in the main document.

> [!TIP]
> The `~opt~` notation in the syntax definitions indicates that the lexical entity is optional in
> the syntax.

## B.1 Lexical grammar

```Syntax
input:
    input-elements~opt~ signature-block~opt~

input-elements:
    input-element
    input-elements input-element

input-element:
    whitespace
    comment
    token

signature-block:
    signature-begin signature signature-end

signature-begin:
    new-line-character # SIG # Begin signature block new-line-character

signature:
    base64 encoded signature blob in multiple single-line-comments

signature-end:
    new-line-character # SIG # End signature block new-line-character
```

### B.1.1 Line terminators

```Syntax
new-line-character:
    Carriage return character (U+000D)
    Line feed character (U+000A)
    Carriage return character (U+000D) followed by line feed character (U+000A)

new-lines:
    new-line-character
    new-lines new-line-character
```

### B.1.2 Comments

```Syntax
comment:
    single-line-comment
    requires-comment
    delimited-comment

single-line-comment:
    # input-characters~opt~

input-characters:
    input-character
    input-characters input-character

input-character:
    Any Unicode character except a new-line-character

requires-comment:
    #requires whitespace command-arguments

dash:
    - (U+002D)
    EnDash character (U+2013)
    EmDash character (U+2014)
    Horizontal bar character (U+2015)

dashdash:
    dash dash

delimited-comment:
    <# delimited-comment-text~opt~ hashes >

delimited-comment-text:
    delimited-comment-section
    delimited-comment-text delimited-comment-section

delimited-comment-section:
    >
    hashes~opt~ not-greater-than-or-hash

hashes:
    #
    hashes #

not-greater-than-or-hash:
    Any Unicode character except > or #
```

### B.1.3 White space

```Syntax
whitespace:
    Any character with Unicode class Zs, Zl, or Zp
    Horizontal tab character (U+0009)
    Vertical tab character (U+000B)
    Form feed character (U+000C)
    ` (The backtick character U+0060) followed by new-line-character
```

### B.1.4 Tokens

```Syntax
token:
    keyword
    variable
    command
    command-parameter
    command-argument-token
    integer-literal
    real-literal
    string-literal
    type-literal
    operator-or-punctuator
```

### B.1.5 Keywords

```Syntax
keyword: one of
    begin          break          catch       class
    continue       data           define      do
    dynamicparam   else           elseif      end
    exit           filter         finally     for
    foreach        from           function    if
    in             inlinescript   parallel    param
    process        return         switch      throw
    trap           try            until       using
    var            while          workflow
```

### B.1.6 Variables

```Syntax
variable:
    $$
    $?
    $^
    $   variable-scope~opt~  variable-characters
    @   variable-scope~opt~  variable-characters
    braced-variable


braced-variable:
    ${   variable-scope~opt~   braced-variable-characters   }

variable-scope:
    global:
    local:
    private:
    script:
    using:
    workflow:
    variable-namespace

variable-namespace:
    variable-characters   :

variable-characters:
    variable-character
    variable-characters   variable-character

variable-character:
    A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nd
    _   (The underscore character U+005F)
    ?

braced-variable-characters:
    braced-variable-character
    braced-variable-characters   braced-variable-character

braced-variable-character:
    Any Unicode character except
        }   (The closing curly brace character U+007D)
        `   (The backtick character U+0060)
    escaped-character

escaped-character:
    `   (The backtick character U+0060) followed by any Unicode character
```

### B.1.7 Commands

```Syntax
generic-token:
    generic-token-parts

generic-token-parts:
    generic-token-part
    generic-token-parts generic-token-part

generic-token-part:
    expandable-string-literal
    verbatim-here-string-literal
    variable
    generic-token-char

generic-token-char:
    Any Unicode character except
        {   }   (   )   ;   ,   |   &   $
        ` (The backtick character U+0060)
        double-quote-character
        single-quote-character
        whitespace
        new-line-character
        escaped-character

generic-token-with-subexpr-start:
    generic-token-parts $(
```

### B.1.8 Parameters

```Syntax
command-parameter:
    dash first-parameter-char parameter-chars colon~opt~

first-parameter-char:
    A Unicode character of classes Lu, Ll, Lt, Lm, or Lo
    _ (The underscore character U+005F)
    ?

parameter-chars:
    parameter-char
    parameter-chars parameter-char

parameter-char:
    Any Unicode character except
        { } ( ) ; , | & . [
        colon
        whitespace
        new-line-character

colon:
    : (The colon character U+003A)

verbatim-command-argument-chars:
    verbatim-command-argument-part
    verbatim-command-argument-chars verbatim-command-argument-part

verbatim-command-argument-part:
    verbatim-command-string
    & non-ampersand-character
    Any Unicode character except
        |
        new-line-character

non-ampersand-character:
    Any Unicode character except &

verbatim-command-string:
    double-quote-character non-double-quote-chars
    double-quote-character

non-double-quote-chars:
    non-double-quote-char
    non-double-quote-chars non-double-quote-char

non-double-quote-char:
    Any Unicode character except
        double-quote-character
```

### B.1.9 Literals

```Syntax
literal:
    integer-literal
    real-literal
    string-literal
```

#### B.1.9.1 Integer Literals

```Syntax
integer-literal:
    decimal-integer-literal
    hexadecimal-integer-literal

decimal-integer-literal:
    decimal-digits numeric-type-suffix~opt~ numeric-multiplier~opt~

decimal-digits:
    decimal-digit
    decimal-digit decimal-digits

decimal-digit: one of
    0  1  2  3  4  5  6  7  8  9

numeric-type-suffix:
    long-type-suffix
    decimal-type-suffix

hexadecimal-integer-literal:
    0x hexadecimal-digits long-type-suffix~opt~
    numeric-multiplier~opt~

hexadecimal-digits:
    hexadecimal-digit
    hexadecimal-digit decimal-digits

hexadecimal-digit: one of
    0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f

long-type-suffix:
    l

numeric-multiplier: one of
    kb mb gb tb pb
```

#### B.1.9.2 Real Literals

```Syntax
real-literal:
    decimal-digits . decimal-digits exponent-part~opt~ decimal-type-suffix~opt~ numeric-multiplier~opt~
    . decimal-digits exponent-part~opt~ decimal-type-suffix~opt~ numeric-multiplier~opt~
    decimal-digits exponent-part decimal-type-suffix~opt~ numeric-multiplier~opt~

exponent-part:
    e sign~opt~  decimal-digits

sign: one of
    +
    dash

decimal-type-suffix:
    d
    l
```

#### B.1.9.3 String Literals

```Syntax
string-literal:
    expandable-string-literal
    expandable-here-string-literal
    verbatim-string-literal
    verbatim-here-string-literal

expandable-string-literal:
    double-quote-character expandable-string-characters~opt~  dollars~opt~ double-quote-character

double-quote-character:
    " (U+0022)
    Left double quotation mark (U+201C)
    Right double quotation mark (U+201D)
    Double low-9 quotation mark (U+201E)

expandable-string-characters:
      expandable-string-part
      expandable-string-characters
      expandable-string-part

expandable-string-part:
    Any Unicode character except
        $
        double-quote-character
        ` (The backtick character U+0060)
    braced-variable
    $ Any Unicode character except
        (
        {
        double-quote-character
        ` (The backtick character U+0060)*
    $ escaped-character
    escaped-character
    double-quote-character double-quote-character

dollars:
    $
    dollars $

expandable-here-string-literal:
    @  double-quote-character  whitespace~opt~  new-line-character
        expandable-here-string-characters~opt~  new-line-character  double-quote-character  @

expandable-here-string-characters:
    expandable-here-string-part
    expandable-here-string-characters  expandable-here-string-part

expandable-here-string-part:
    Any Unicode character except
        $
        new-line-character
    braced-variable
    $ Any Unicode character except
        (
        new-line-character
    $ new-line-character  Any Unicode character except double-quote-char
    $ new-line-character double-quote-char  Any Unicode character except @
    new-line-character  Any Unicode character except double-quote-char
    new-line-character double-quote-char  Any Unicode character except @

expandable-string-with-subexpr-start:
    double-quote-character  expandable-string-chars~opt~  $(

expandable-string-with-subexpr-end:
    double-quote-char

expandable-here-string-with-subexpr-start:
    @  double-quote-character whitespace~opt~ new-line-character expandable-here-string-chars~opt~  $(

expandable-here-string-with-subexpr-end:
    new-line-character  double-quote-character  @

verbatim-string-literal:
    single-quote-character verbatim-string-characters~opt~ single-quote-char

single-quote-character:
    ' (U+0027)
    Left single quotation mark (U+2018)
    Right single quotation mark (U+2019)
    Single low-9 quotation mark (U+201A)
    Single high-reversed-9 quotation mark (U+201B)

verbatim-string-characters:
    verbatim-string-part
    verbatim-string-characters verbatim-string-part

verbatim-string-part:
    *Any Unicode character except* single-quote-character
    single-quote-character  single-quote-character

verbatim-here-string-literal:
    @ single-quote-character whitespace~opt~  new-line-character
        verbatim-here-string-characters~opt~  new-line-character
            single-quote-character *@*

verbatim-*here-string-characters:
    verbatim-here-string-part
    verbatim-here-string-characters  verbatim-here-string-part

verbatim-here-string-part:
    Any Unicode character except* new-line-character
    new-line-character  Any Unicode character except single-quote-character
    new-line-character  single-quote-character  Any Unicode character except @
```

### B.1.10 Simple Names

```Syntax
simple-name:
    simple-name-first-char simple-name-chars

simple-name-first-char:
    A Unicode character of classes Lu, Ll, Lt, Lm, or Lo
    _ (The underscore character U+005F)

simple-name-chars:
    simple-name-char
    simple-name-chars simple-name-char

simple-name-char:
    A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nd
    _ (The underscore character U+005F)
```

### B.1.11 Type Names

```Syntax
type-name:
    type-identifier
    type-name . type-identifier

type-identifier:
    type-characters

type-characters:
    type-character
    type-characters type-character

type-character:
    A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nd
    _ (The underscore character U+005F)

array-type-name:
    type-name [

generic-type-name:
    type-name [
```

### B.1.12 Operators and punctuators

```Syntax
operator-or-punctuator: one of
    {   }   [   ]   (   )   @(   @{   $(   ;
    &&  ||  &   |   ,   ++  ..   ::   .
    !   *   /   %   +
    dash       dashdash
    dash and   dash band   dash bnot   dash bor
    dash bxor  dash not    dash or     dash xor
    assignment-operator
    merging-redirection-operator
    file-redirection-operator
    comparison-operator
    format-operator

assignment-operator: one of
    =    dash =    +=    *=    /=    %=

file-redirection-operator: one of
    >  >>  2>  2>>  3>  3>>  4>  4>>
    5>  5>>  6>  6>>  *>  *>>  <

merging-redirection-operator: one of
    *>&1  2>&1  3>&1  4>&1  5>&1  6>&1
    *>&2  1>&2  3>&2  4>&2  5>&2  6>&2

comparison-operator: one of
    dash as           dash ccontains      dash ceq
    dash cge          dash cgt            dash cle
    dash clike        dash clt            dash cmatch
    dash cne          dash cnotcontains   dash cnotlike
    dash cnotmatch    dash contains       dash creplace
    dash csplit       dash eq             dash ge
    dash gt           dash icontains      dash ieq
    dash ige          dash igt            dash ile
    dash ilike        dash ilt            dash imatch
    dash in           dash ine            dash inotcontains
    dash inotlike     dash inotmatch      dash ireplace
    dash is           dash isnot          dash isplit
    dash join         dash le             dash like
    dash lt           dash match          dash ne
    dash notcontains  dash notin         dash notlike
    dash notmatch     dash replace       dash shl*
    dash shr          dash split

format-operator:
    dash f
```

## B.2 Syntactic grammar

### B.2.1 Basic concepts

```Syntax
script-file:
    script-block

module-file:
    script-block

interactive-input:
    script-block

data-file:
    statement-list
```

### B.2.2 Statements

```Syntax
script-block:
    param-block~opt~ statement-terminators~opt~ script-block-body~opt~

param-block:
    new-lines~opt~ attribute-list~opt~ new-lines~opt~ param new-lines~opt~
        ( parameter-list~opt~ new-lines~opt~ )

parameter-list:
    script-parameter
    parameter-list new-lines~opt~ , script-parameter

script-parameter:
    new-lines~opt~ attribute-list~opt~ new-lines~opt~ variable script-parameter-default~opt~

script-parameter-default:
    new-lines~opt~ = new-lines~opt~ expression

script-block-body:
    named-block-list
    statement-list

named-block-list:
    named-block
    named-block-list named-block

named-block:
    block-name statement-block statement-terminators~opt~

block-name: one of
    dynamicparam begin process end

statement-block:
    new-lines~opt~ { statement-list~opt~ new-lines~opt~ }

statement-list:
    statement
    statement-list statement

statement:
    if-statement
    label~opt~ labeled-statement
    function-statement
    flow-control-statement statement-terminator
    trap-statement
    try-statement
    data-statement
    inlinescript-statement
    parallel-statement
    sequence-statement
    pipeline statement-terminator

statement-terminator:
    ;
    new-line-character

statement-terminators:
    statement-terminator
    statement-terminators statement-terminator

if-statement:
    if new-lines~opt~ ( new-lines~opt~ pipeline new-lines~opt~ ) statement-block
        elseif-clauses~opt~ else-clause~opt~

elseif-clauses:
    elseif-clause
    elseif-clauses elseif-clause

elseif-clause:
    new-lines~opt~ elseif new-lines~opt~ ( new-lines~opt~ pipeline new-lines~opt~ ) statement-block

else-clause:
    new-lines~opt~ else statement-block

labeled-statement:
    switch-statement
    foreach-statement
    for-statement
    while-statement
    do-statement

switch-statement:
    switch new-lines~opt~ switch-parameters~opt~ switch-condition switch-body

switch-parameters:
    switch-parameter
    switch-parameters switch-parameter

switch-parameter:
    -regex
    -wildcard
    -exact
    -casesensitive
    -parallel

switch-condition:
    ( new-lines~opt~ pipeline new-lines~opt~ )
    -file new-lines~opt~ switch-filename

switch-filename:
    command-argument
    primary-expression

switch-body:
    new-lines~opt~ { new-lines~opt~ switch-clauses }

switch-clauses:
    switch-clause
    switch-clauses switch-clause

switch-clause:
    switch-clause-condition statement-block statement-terimators~opt~

switch-clause-condition:
    command-argument
    primary-expression

foreach-statement:
    foreach new-lines~opt~ foreach-parameter~opt~ new-lines~opt~
        ( new-lines~opt~ variable new-lines~opt~ in new-lines~opt~ pipeline
        new-lines~opt~ ) statement-block

foreach-parameter:
    -parallel

for-statement:
    for new-lines~opt~ (
        new-lines~opt~ for-initializer~opt~ statement-terminator
        new-lines~opt~ for-condition~opt~ statement-terminator
        new-lines~opt~ for-iterator~opt~
        new-lines~opt~ ) statement-block
    for new-lines~opt~ (
        new-lines~opt~ for-initializer~opt~ statement-terminator
        new-lines~opt~ for-condition~opt~
        new-lines~opt~ ) statement-block
    for new-lines~opt~ (
        new-lines~opt~ for-initializer~opt~
        new-lines~opt~ ) statement-block

for-initializer:
    pipeline

for-condition:
    pipeline

for-iterator:
    pipeline

while-statement:
    while new-lines~opt~ ( new-lines~opt~ while-condition new-lines~opt~ ) statement-block

do-statement:
    do statement-block new-lines~opt~ while new-lines~opt~ ( while-condition new-lines~opt~ )
    do statement-block new-lines~opt~ until new-lines~opt~ ( while-condition new-lines~opt~ )

while-condition:
    new-lines~opt~ pipeline

function-statement:
    function new-lines~opt~ function-name function-parameter-declaration~opt~ { script-block }
    filter new-lines~opt~ function-name function-parameter-declaration~opt~ { script-block }
    workflow new-lines~opt~ function-name function-parameter-declaration~opt~ { script-block }

function-name:
    command-argument

function-parameter-declaration:
    new-lines~opt~ ( parameter-list new-lines~opt~ )

flow-control-statement:
    break label-expression~opt~
    continue label-expression~opt~
    throw pipeline~opt~
    return pipeline~opt~
    exit pipeline~opt~

label-expression:
    simple-name
    unary-expression

trap-statement:
    trap new-lines~opt~ type-literal~opt~ new-lines~opt~ statement-block

try-statement:
    try statement-block catch-clauses
    try statement-block finally-clause
    try statement-block catch-clauses finally-clause

catch-clauses:
    catch-clause
    catch-clauses catch-clause

catch-clause:
    new-lines~opt~ catch catch-type-list~opt~ statement-block

catch-type-list:
    new-lines~opt~ type-literal
    catch-type-list new-lines~opt~ , new-lines~opt~ type-literal

finally-clause:
    new-lines~opt~ finally statement-block

data-statement:
    data new-lines~opt~ data-name data-commands-allowed~opt~
    statement-block

data-name:
    simple-name

data-commands-allowed:
    new-lines~opt~ -supportedcommand data-commands-list

data-commands-list:
    new-lines~opt~ data-command
    data-commands-list , new-lines~opt~ data-command

data-command:
    command-name-expr

inlinescript-statement:
    inlinescript statement-block

parallel-statement:
    parallel statement-block

sequence-statement:
    sequence statement-block

pipeline:
    assignment-expression
    expression redirections~opt~ pipeline-tail~opt~
    command verbatim-command-argument~opt~ pipeline-tail~opt~

assignment-expression:
    expression assignment-operator statement

pipeline-tail:
    | new-lines~opt~ command
    | new-lines~opt~ command pipeline-tail

command:
    command-name command-elements~opt~
    command-invocation-operator command-module~opt~ command-name-expr command-elements~opt~

command-invocation-operator: one of
    &   .

command-module:
    primary-expression

command-name:
    generic-token
    generic-token-with-subexpr

generic-token-with-subexpr:
    No whitespace is allowed between ) and command-name.
    generic-token-with-subexpr-start statement-list~opt~ ) command-name

command-name-expr:
    command-name
    primary-expression

command-elements:
    command-element
    command-elements command-element

command-element:
    command-parameter
    command-argument
    redirection

command-argument:
    command-name-expr

verbatim-command-argument:
    --% verbatim-command-argument-chars

redirections:
    redirection
    redirections redirection

redirection:
    merging-redirection-operator
    file-redirection-operator redirected-file-name

redirected-file-name:
    command-argument
    primary-expression
```

### B.2.3 Expressions

```Syntax
expression:
    logical-expression

logical-expression:
    bitwise-expression
    logical-expression -and new-lines~opt~ bitwise-expression
    logical-expression -or new-lines~opt~ bitwise-expression
    logical-expression -xor new-lines~opt~ bitwise-expression

bitwise-expression:
    comparison-expression
    bitwise-expression -band new-lines~opt~ comparison-expression
    bitwise-expression -bor new-lines~opt~ comparison-expression
    bitwise-expression -bxor new-lines~opt~ comparison-expression

comparison-expression:
    additive-expression
    comparison-expression comparison-operator new-lines~opt~
    additive-expression

additive-expression:
    multiplicative-expression
    additive-expression + new-lines~opt~ multiplicative-expression
    additive-expression dash new-lines~opt~ multiplicative-expression

multiplicative-expression:
    format-expression
    multiplicative-expression \ new-lines~opt~ format-expression
    multiplicative-expression / new-lines~opt~ format-expression
    multiplicative-expression % new-lines~opt~ format-expression

format-expression:
    range-expression
    format-expression format-operator new-lines~opt~ range-expression

range-expression:
    array-literal-expression
    range-expression .. new-lines~opt~ array-literal-expression

array-literal-expression:
    unary-expression
    unary-expression , new-lines~opt~ array-literal-expression

unary-expression:
    primary-expression
    expression-with-unary-operator

expression-with-unary-operator:
    , new-lines~opt~ unary-expression
    -not new-lines~opt~ unary-expression
    ! new-lines~opt~ unary-expression
    -bnot new-lines~opt~ unary-expression
    + new-lines~opt~ unary-expression
    dash new-lines~opt~ unary-expression
    pre-increment-expression
    pre-decrement-expression
    cast-expression
    -split new-lines~opt~ unary-expression
    -join new-lines~opt~ unary-expression

pre-increment-expression:
    ++ new-lines~opt~ unary-expression

pre-decrement-expression:
    dashdash new-lines~opt~ unary-expression

cast-expression:
    type-literal unary-expression

attributed-expression:
    type-literal variable

primary-expression:
    value
    member-access
    element-access
    invocation-expression
    post-increment-expression
    post-decrement-expression

value:
    parenthesized-expression
    sub-expression
    array-expression
    script-block-expression
    hash-literal-expression
    literal
    type-literal
    variable

parenthesized-expression:
    ( new-lines~opt~ pipeline new-lines~opt~ )

sub-expression:
    $( new-lines~opt~ statement-list~opt~ new-lines~opt~ )

array-expression:
    @( new-lines~opt~ statement-list~opt~ new-lines~opt~ )

script-block-expression:
    { new-lines~opt~ script-block new-lines~opt~ }

hash-literal-expression:
    @{ new-lines~opt~ hash-literal-body~opt~ new-lines~opt~ }

hash-literal-body:
    hash-entry
    hash-literal-body statement-terminators hash-entry

hash-entry:
    key-expression = new-lines~opt~ statement

key-expression:
    simple-name
    unary-expression

post-increment-expression:
    primary-expression ++

post-decrement-expression:
    primary-expression dashdash

member-access: Note no whitespace is allowed after
    primary-expression.
    primary-expression . member-name
    primary-expression :: member-name

element-access: Note no whitespace is allowed between primary-expression and [.
    primary-expression [ new-lines~opt~ expression new-lines~opt~ ]

invocation-expression: Note no whitespace is allowed after
    primary-expression.
    primary-expression . member-name argument-list
    primary-expression :: member-name argument-list

argument-list:
    ( argument-expression-list~opt~ new-lines~opt~ )

argument-expression-list:
    argument-expression
    argument-expression new-lines~opt~ , argument-expression-list

argument-expression:
    new-lines~opt~ logical-argument-expression

logical-argument-expression:
    bitwise-argument-expression
    logical-argument-expression -and new-lines~opt~ bitwise-argument-expression
    logical-argument-expression -or  new-lines~opt~ bitwise-argument-expression
    logical-argument-expression -xor new-lines~opt~ bitwise-argument-expression

bitwise-argument-expression:
    comparison-argument-expression
    bitwise-argument-expression -band new-lines~opt~ comparison-argument-expression
    bitwise-argument-expression -bor  new-lines~opt~ comparison-argument-expression
    bitwise-argument-expression -bxor new-lines~opt~ comparison-argument-expression

comparison-argument-expression:
    additive-argument-expression
    comparison-argument-expression comparison-operator
        new-lines~opt~ additive-argument-expression

additive-argument-expression:
    multiplicative-argument-expression
    additive-argument-expression +    new-lines~opt~ multiplicative-argument-expression
    additive-argument-expression dash new-lines~opt~ multiplicative-argument-expression

multiplicative-argument-expression:
    format-argument-expression
    multiplicative-argument-expression \ new-lines~opt~ format-argument-expression
    multiplicative-argument-expression / new-lines~opt~ format-argument-expression
    multiplicative-argument-expression % new-lines~opt~ format-argument-expression

format-argument-expression:
    range-argument-expression
    format-argument-expression format-operator new-lines~opt~ range-argument-expression

range-argument-expression:
    unary-expression
    range-expression .. new-lines~opt~ unary-expression

member-name:
    simple-name
    string-literal
    string-literal-with-subexpression
    expression-with-unary-operator
    value

string-literal-with-subexpression:
    expandable-string-literal-with-subexpr
    expandable-here-string-literal-with-subexpr

expandable-string-literal-with-subexpr:
    expandable-string-with-subexpr-start statement-list~opt~ )
        expandable-string-with-subexpr-characters expandable-string-with-subexpr-end
    expandable-here-string-with-subexpr-start statement-list~opt~ )
        expandable-here-string-with-subexpr-characters
        expandable-here-string-with-subexpr-end

expandable-string-with-subexpr-characters:
    expandable-string-with-subexpr-part
    expandable-string-with-subexpr-characters expandable-string-with-subexpr-part

expandable-string-with-subexpr-part:
    sub-expression
    expandable-string-part

expandable-here-string-with-subexpr-characters:
    expandable-here-string-with-subexpr-part
    expandable-here-string-with-subexpr-characters expandable-here-string-with-subexpr-part

expandable-here-string-with-subexpr-part:
    sub-expression
    expandable-here-string-part

type-literal:
    [ type-spec ]

type-spec:
    array-type-name new-lines~opt~ dimension~opt~ ]
    generic-type-name new-lines~opt~ generic-type-arguments ]
    type-name

dimension:
    ,
    dimension ,

generic-type-arguments:
    type-spec new-lines~opt~
    generic-type-arguments , new-lines~opt~ type-spec
```

### B.2.4 Attributes

```Syntax
attribute-list:
    attribute
    attribute-list new-lines~opt~ attribute

attribute:
    [ new-lines~opt~ attribute-name ( attribute-arguments new-lines~opt~ ) new-lines~opt~ ]
    type-literal

attribute-name:
    type-spec

attribute-arguments:
    attribute-argument
    attribute-argument new-lines~opt~ , attribute-arguments

attribute-argument:
    new-lines~opt~ expression
    new-lines~opt~ simple-name
    new-lines~opt~ simple-name = new-lines~opt~ expression
```

<!-- reference links -->

# /./lang-spec/chapter-16.md - C. References

    ---
    description: This appendix contains a list of references to computing standards used in PowerShell.
    ms.date: 01/18/2023
    title: Appendix B - References
    ---
# C. References

ANSI/IEEE 754−2008, _Binary floating-point arithmetic for microprocessor systems_.

ECMA-334, _C# Language Specification_, 4th edition (June 2006),
[https://www.ecma-international.org/publications-and-standards/standards/ecma-334/][04].
[This Ecma publication is also approved as ISO/IEC 23270:2006.]

The Open Group Base Specifications: Pattern Matching, IEEE Std 1003.1, 2004 Edition.
[http://www.opengroup.org/onlinepubs/000095399/utilities/xcu_chap02.html#tag_02_13_01][02]

The Open Group Base Specifications: Regular Expressions, IEEE Std 1003.1, 2004 Edition.
[http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap09.html][01].

Ecma Technical Report TR/84, _Common Language Infrastructure (CLI) - Information Derived from
Partition IV XML File_, 4th edition (June 2006),
[https://www.ecma-international.org/publications-and-standards/technical-reports/ecma-tr-84/][05].
This TR was also published as ISO/IEC TR 23272:2006.

ISO 639-1, _Codes for the representation of names of languages - Part 1: Alpha-2 code._

ISO 3166-1, _Codes for the representation of names of countries and their subdivisions - Part 1:
Country codes._

ISO/IEC 10646-1/AMD1:1996, Amendment 1 to ISO/IEC 10646-1:1993, _Transformation Format for 16 planes
of group 00 (UTF-16)_.

_The Unicode Standard_, Edition 5.2. The Unicode Consortium,
[http://www.unicode.org/standard/standard.html][03].

<!-- updated link references -->
[01]: http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap09.html
[02]: http://www.opengroup.org/onlinepubs/000095399/utilities/xcu_chap02.html#tag_02_13_01
[03]: http://www.unicode.org/standard/standard.html
[04]: https://www.ecma-international.org/publications-and-standards/standards/ecma-334/
[05]: https://www.ecma-international.org/publications-and-standards/technical-reports/ecma-tr-84/

# /./reference/community/contributing/overview.md

    ---
    description: This article outlines the steps required to contribute to the PowerShell documentation.
    ms.date: 07/25/2022
    title: Contributing to PowerShell documentation
    ---
# Contributing to PowerShell documentation

Thank you for your support of PowerShell!

The Contributor's Guide is a collection of articles that describe the tools and processes we use to
create documentation at Microsoft. Some of these guides cover information common to any
documentation set published to `learn.microsoft.com`. Other guides are specific to how we write
documentation for PowerShell.

The common articles are available in our centralized [Contributor's Guide][1]. The
PowerShell-specific guides are available here.

## Ways to contribute

There are two ways to contribute. Both contributions are valuable to us.

- [Filing issues][2] helps us identify problems and gaps in our documentation. Sometimes the issues
  are difficult to resolve, requiring more investigation and research. The issue process allows us
  to have a conversation about the problem and develop a satisfactory resolution.

- [Submitting a pull request][3] to add or change content is a more involved process. The following
  information outlines the tools, processes, and standards for submitting content to the
  documentation.

## Prepare to make a contribution

Contributing to the documentation requires a GitHub account. Use the following checklist to install
and configure the tools you need to make contributions.

1. [Sign up for GitHub][4]
1. [Install Git and Markdown tools][5]
1. [Install the Docs Authoring Pack][6]
1. [Install Posh-Git][7] - not required but recommended
1. [Set up a local Git repository][8]
1. [Review Git and GitHub fundamentals][9]

## Get started writing docs

There are two ways to contribute changes to the documentation:

1. [Quick edits to existing docs][10] - Minor corrections, fixing typos, or small additions
1. [Full GitHub workflow for docs][11] - large changes, multiple versions, adding or changing
   images, or contributing new articles

Also, read the [Writing essentials][12] section of the centralized Contributor's Guide. Another
excellent resource is the [Microsoft Writing Style Guide][13].

Minor corrections or clarifications to documentation and code examples in public repositories are
covered by the [learn.microsoft.com Terms of Use][14].

Use the full GitHub workflow when you're making significant changes. If you're not an employee of
Microsoft, our PR validation system adds a comment to the pull request asking you to sign the online
[Contribution Licensing Agreement (CLA)][15]. You must complete this step before we can review or
accept your pull request. Signing the CLA is only required the first time you submit a PR in the
repository. You will be asked to sign the CLA for each time you contribute to a new repository.

## Code of conduct

All repositories that publish to Microsoft Learn have adopted the
[Microsoft Open Source Code of Conduct][16] or the
[.NET Foundation Code of Conduct][17]. For more
information, see the [Code of Conduct FAQ][18].

## Next steps

The following articles cover information specific to PowerShell documentation. Where there's overlap
with the guidance in the centralized Contributor's Guide, we call out how those rules differ for the
PowerShell content.

Review the following documents:

- [Get started writing docs][19]
- [Markdown best practices][21]
- [PowerShell-Docs style guide][22]
- [How to file an issue][2]
- [Submitting a pull request][20]

Additional resources

- [Editorial checklist][23]
- [How we manage issues][24]
- [How we manage pull requests][25]

<!--link references-->
[1]: https://learn.microsoft.com/contribute/
[2]: file-an-issue.md
[3]: pull-requests.md
[4]: https://learn.microsoft.com/contribute/get-started-setup-github
[5]: https://learn.microsoft.com/contribute/get-started-setup-tools
[6]: https://learn.microsoft.com/contribute/how-to-write-docs-auth-pack
[7]: https://www.powershellgallery.com/packages/posh-git
[8]: https://learn.microsoft.com/contribute/get-started-setup-local
[9]: https://learn.microsoft.com/contribute/git-github-fundamentals
[10]: https://learn.microsoft.com/contribute/#quick-edits-to-existing-documents
[11]: https://learn.microsoft.com/contribute/how-to-write-workflows-major
[12]: https://learn.microsoft.com/contribute/style-quick-start
[13]: https://learn.microsoft.com/style-guide/welcome/
[14]: https://learn.microsoft.com/legal/termsofuse
[15]: https://cla.microsoft.com/
[16]: https://opensource.microsoft.com/codeofconduct/
[17]: https://dotnetfoundation.org/code-of-conduct
[18]: https://opensource.microsoft.com/codeofconduct/faq/
[19]: get-started-writing.md
[20]: pull-requests.md
[21]: general-markdown.md
[22]: powershell-style-guide.md
[23]: editorial-checklist.md
[24]: managing-issues.md
[25]: managing-pull-requests.md

# /./reference/community/contributing/get-started-writing.md

    ---
    description: This article is an overview of how to get started as a contributor to the PowerShell documentation.
    ms.date: 07/26/2022
    title: Get started contributing to PowerShell documentation
    ---
# Get started contributing to PowerShell documentation

This article is an overview of how to get started as a contributor to the PowerShell documentation.

## PowerShell-Docs structure

The [PowerShell-Docs repository][1] is divided into two groups of content: reference and
conceptual.

### Reference content

The reference content is the PowerShell cmdlet reference for the cmdlets that ship in PowerShell.
The cmdlet [reference][2] is collected in versioned folders (like 5.1, 7.0, and 7.2), which contain
reference for the modules that ship with PowerShell. This content is also used to create the help
information displayed by the `Get-Help` cmdlet.

### Conceptual content

The [conceptual documentation][3] isn't organized by version. All articles are displayed for every
version of PowerShell.

> [!NOTE]
> Anytime a conceptual article is added, removed, or renamed, the TOC must be updated and deleted or
> renamed files must be redirected.

## Creating new articles

A GitHub issue must be created for any new document you want to contribute. Check for existing
issues to make sure you're not duplicating efforts. Assigned issues are considered to be
`in progress`. If you wish to collaborate on an issue, contact the person assigned to the issue.

Similar to the PowerShell [RFC process][4], create an issue before you write the content. The issue
ensures you don't waste time and effort on work that gets rejected by the PowerShell-Docs team. The
issue allows us to consult with you on the scope of the content and where it fits in the PowerShell
documentation. All articles must be included in the Table of Contents (TOC). The proposed TOC
location should be included in the issue discussion.

> [!NOTE]
> The TOC for reference content is autogenerated by the publishing system. You don't have to update
> the TOC.

## Updating existing articles

Where applicable, cmdlet reference articles are duplicated across all versions of PowerShell
maintained in this repository. When reporting an issue about a cmdlet reference or an `About_`
article, list the versions of the article that have the problem.

Apply the appropriate change to each version of the file.

## Localized content

The PowerShell documentation is written in English and translated into 17 other languages. The
English content is stored in the GitHub repository named `MicrosoftDocs/PowerShell-Docs`. Issues
found in the translated content should be submitted to the English repository.

All translations start from the English content first. We use both human and machine translation.

| Translation method  |                              Languages                               |
| ------------------- | -------------------------------------------------------------------- |
| Human translation   | de-DE, es-ES, fr-FR, it-IT, ja-JP, ko-KR, pt-BR, ru-RU, zh-CN, zh-TW |
| Machine translation | cs-CZ, hu-HU, nl-NL, pl-PL, pt-PT, sv-SE, tr-TR                      |

The content translated by machine translation may not always result in correct word choices and
grammar. If you find an error in translation for any language, rather than in the technical details
of the article, open an issue explaining why you think the translation is wrong.

Some translation issues can be fixed by changing the English source files. However, some issues may
require updates to our internal translation system. For those cases, we must submit the issue to our
internal localization team for review and response.

## Next steps

There are two common ways of submitting changes in GitHub. Both methods are described in the central
Contributor's Guide:

1. You can make [quick edits to existing documents][5] in the GitHub web interface.
1. Use the [full GitHub workflow][6] for adding new articles, updating multiple files, or other
   large changes.

Before starting any changes, you should create a fork of the PowerShell-Docs repository. The changes
should be made in a working branch in you copy of the PowerShell-Docs. If you're using the **quick
edit** method in GitHub, these steps are handled for you. If you're using the **full GitHub
workflow**, you must be set up to [work locally][7].

Both methods end with the creation of a Pull Request (PR). See [Submitting a pull request][8] for
more information and best practices.

<!--link refs-->
[1]: https://github.com/MicrosoftDocs/PowerShell-Docs
[2]: https://github.com/MicrosoftDocs/PowerShell-Docs/tree/main/reference
[3]: https://github.com/MicrosoftDocs/PowerShell-Docs/tree/main/reference/docs-conceptual
[4]: https://github.com/PowerShell/powershell-rfc/blob/master/RFC0000-RFC-Process.md
[5]: https://learn.microsoft.com/contribute/#quick-edits-to-existing-documents
[6]: https://learn.microsoft.com/contribute/how-to-write-workflows-major#making-your-changes
[7]: https://learn.microsoft.com/contribute/get-started-setup-local#fork-the-repository
[8]: pull-requests.md

# /./reference/community/contributing/using-github-codespaces.md

    ---
    description: >-
        This article describes the process for contributing to the documentation using GitHub
        Codespaces as an authoring environment.
    ms.date: 05/10/2023
    title: Contribute using GitHub Codespaces
    ---

# Contribute using GitHub Codespaces

GitHub has a feature called [Codespaces][01] that you can use to contribute to the PowerShell
documentation without having to install or configure any software locally. When you use a
codespace, you get the same authoring tools the team uses for writing and editing.

You can use a codespace in your browser, making your contributions in VS Code hosted over the
internet. If you have VS Code installed locally, you can connect to the codespace there too.

## Available tools

When you use a codespace to contribute to the PowerShell documentation, your editor has these tools
already available for you:

- [Markdownlint][02] for checking your Markdown syntax.
- [cSpell][03] for checking your spelling.
- [Vale][04] for checking your prose.
- The [Learn Authoring Pack][05] for inserting platform-specific syntax, previewing your
  contribution, and more.
- The [Reflow Markdown][06] extension for wrapping your Markdown as needed, making reading and
  editing easier.
- The [Table Formatter][07] extension for making your tables more readable without having to
  manually align columns.
- The [change-case][08] extension for converting the casing of your headings and prose.
- The [GitLens][09] extension for reviewing historical file changes.
- The [PowerShell][10] extension for interacting authoring PowerShell examples.
- The [Gremlins tracker for Visual Studio Code][11] for finding problematic characters in your
  Markdown.

## Cost

GitHub Codespaces can be used for free up to 120 core-hours per month. With the configuration we
recommend in this article, that means up to 60 hours of free usage per month. The monthly usage is
calculated across all your repositories, not just documentation.

For more information about pricing, see [About billing for GitHub Codespaces][12].

> [!TIP]
> If you're comfortable using containers and Docker, you can get the same experience as using
> GitHub Codespaces in VS Code by using the devcontainer defined for the PowerShell documentation
> repositories. There's no cost associated with using devcontainers. For more information, see
> the [Dev Containers tutorial][13].

## Creating your GitHub Codespace

To create your GitHub Codespace for contributing to PowerShell documentation, follow these steps:

1. Open [https://github.com/codespaces][14] in your browser.
1. Select the "New codespace" button in the top right of the page.
1. In the "Create a new codespace" page, select the "Select a repository" button and type the name
   of the repository you want to contribute to, like `MicrosoftDocs/PowerShell-Docs`.
1. Leave all other settings as their default.
1. Select the "Create codespace" button.

After following these steps, GitHub creates a new codespace for that repository and sets it up for
you. When the codespace is ready, the page refreshes and shows the web editor UI for the codespace.
The UI is based on VS Code and works the same way.

## Opening your GitHub Codespace

To open your GitHub Codespace in the browser, follow these steps:

1. Open [https://github.com/codespaces][14] in your browser.
1. The page lists your codespaces. Find the created codespace for the repository you want to
   contribute to and select it.

After you select your codespace, GitHub opens it in the same window. From here, you're ready to
contribute.

To open your GitHub Codespace in VS Code, follow the steps in
[Using GitHub Codespaces in Visual Studio Code][15].

## Authoring in your GitHub Codespace

Once you have your GitHub Codespace open in your browser or VS Code, contributing to the
documentation follows the same process.

The rest of this article describes a selection of tasks you can do in your GitHub Codespace while
writing or editing your contribution.

### Extract a reference link

When you want to turn an inline link, like `[some text](destination.md)`, into a reference link like
`[some text][01]`, select the link destination in the editor. Then you can either:

1. Right click on the link destination and select "Refactor..." in the context menu.
1. Press <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>R</kbd>.

Either action raises the refactoring context menu. Select "Extract to link definition" in the
context menu. This replaces the `(destination.md)` in the link with `[def]`. You can rename the
definition by typing a name in.

For the PowerShell documentation, we use two-digit numerical reference link definitions, like
`[01]` or `[31]`. Only use reference link definitions in about topics and conceptual documentation.
Don't use reference link definitions in cmdlet reference documentation.

### Fix prose style violations

When you review an article in your codespace, Vale automatically checks the article when you first
open it and every time you save it. If Vale finds any style violations, it highlights them in the
document with colored squiggles.

Hover over a violation to see more information about it.

Select the rule's name in the hover information to open a web page that explains the rule. Select
the rule's filename (ending in `.yml`) to open the rule and review its implementation.

If the rule supports a quick fix, you can select "Quick Fix..." in the hover information for the
violation and apply one of the suggested fixes by selecting it from the context menu. You can also
press <kbd>Ctrl</kbd>+<kbd>.</kbd> when your cursor is on a highlighted problem to apply a quick
fix if the rule supports it.

If the rule doesn't support quick fixes, read the rule's message and fix it if you can. If
you're not sure how to fix it, the editors can make a suggestion when reviewing your PR.

### Fix syntax problems

When you review an article in your codespace, Markdownlint automatically checks the article when
you open it and as you type. If Markdownlint finds any syntax problems, it highlights them in the
document with colored squiggles.

Hover over a violation to see more information about it.

Select the rule's ID in the hover information to open a web page that explains the rule.

If the rule supports a quick fix, you can select "Quick Fix..." in the hover information for the
violation and apply one of the suggested fixes by selecting it from the context menu. You can also
press <kbd>Ctrl</kbd>+<kbd>.</kbd> when your cursor is on a highlighted problem to apply a quick
fix if the rule supports it.

If the rule doesn't support quick fixes, read the rule's message and fix it if you can. If
you're not sure how to fix it, the editors can make a suggestion when reviewing your PR.

You can also apply fixes to all syntax violations in an article. To do so, open the command palette
and type `Fix all supported markdownlint violations in the document`. As you type, the command
palette filters the available commands. Select the "Fix all supported markdownlint violations in
the document" command. When you do, Markdownlint updates the document to resolve any violations it
has a quick fix for.

### Format a table

To format a Markdown table, place your cursor in or on the table in your Markdown. Open the Command
Palette and search for the `Table: Format Current` command. When you select that command, it
updates the Markdown for your table to align and pad the table for improved readability.

It converts a table defined like this:

```markdown
| foo | bar | baz |
|:--:|:--|-:|
| a | b | c |
```

Into this:

```markdown
|  foo  | bar  | baz  |
| :---: | :--- | ---: |
|   a   | b    |    c |
```

### Insert an alert

The documentation uses [alerts][16] to make information more notable to a reader.

To insert an alert, you can, open the Command Palette and search for the `Learn: Alert` command.
When you select that command, it opens a context menu. Select the alert type you want to add. When
you do, the command inserts the alert's Markdown at your cursor in the document.

### Make a heading use sentence casing

To convert a heading's casing, highlight the heading's text except for the leading `#` symbols,
which set the heading level. When you have the text highlighted, open the Command Palette and
search for the `Change case sentence` command. When you select that command, it converts the casing
of the highlighted text.

You can also use the casing commands for any text in the document.

### Open the Command Palette

You can use VS Code's [Command Palette][17] to run many helpful commands.

To open the Command Palette in the UI, select "View" in the top menu bar. Then select "Command
Palette..." in the context menu.

To open the Command Palette with your keyboard, press the key combination for your operating system:

- Windows and Linux: <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>
- macOS: <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>

### Preview your contribution

To preview your contribution, open the Command Palette and search for the `Markdown: Open Preview`
command. When you select that command, VS Code opens a preview of the active document. The
preview's style matches the Learn platform.

> [!NOTE]
> Site-relative and cross-reference links won't work in the preview.

### Reflow your content

To limit the line lengths for a paragraph in a document, place your cursor on the paragraph. Then
open the Command Palette and search for the `Reflow Markdown` command. When you select the command,
it updates the current paragraph's line lengths to the configured length. For our repositories,
that length is 99 characters.

When using this command for block quotes, make sure the paragraph in the block quote you're
reflowing is surrounded by blank lines. Otherwise, the command reflows every paragraph together.

> [!CAUTION]
> Don't use this command when editing about topics. The lines in those documents must not be
> longer than 80 characters. There's currently no way for a repository to configure different line
> lengths by folder or filename, so reflow doesn't work for about topic documents.

### Review all problems in a document

To review all syntax and style rule violations in a document, open the Problems View.

To open the Problems View in the UI, select "View" in the top menu bar. Then select "Problems" in
the context menu.

To open the Problems View with your keyboard, press the key combination for your operating system:

- Windows and Linux: <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>
- macOS: <kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>

The Problems View displays all errors, warnings, and suggestions for the open document. Select a
problem to scroll to it in the document.

You can filter the problems by type or text matching.

### Updating the ms.date metadata

To update the `ms.date` metadata for an article, open the Command Palette and search for the
`Learn: Update "ms.date" Metadata Value` command. When you select the command, it updates the
metadata to the current date.

## Additional resources

The tasks and commands described in this article don't cover everything you can do with VS Code or
the installed extensions.

For more information on using VS Code, see these articles:

- [Visual Studio Code Tips and Tricks][18]
- [Basic Editing][19]
- [Using Git source control in VS Code][20]
- [Markdown and Visual Studio Code][21]

For more information about the installed extensions, see their documentation:

- [change-case][08]
- [GitLens][09]
- [Gremlins tracker for Visual Studio Code][11]
- [Learn Authoring Pack][05]
- [markdownlint][02]
- [Reflow Markdown][06]
- [Table Formatter][07]

<!-- Reference link definitions -->
[01]: https://github.com/features/codespaces
[02]: https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint
[03]: https://cspell.org/
[04]: https://vale.sh/
[05]: https://marketplace.visualstudio.com/items?itemName=docsmsft.docs-authoring-pack
[06]: https://marketplace.visualstudio.com/items?itemName=marvhen.reflow-markdown
[07]: https://marketplace.visualstudio.com/items?itemName=shuworks.vscode-table-formatter
[08]: https://marketplace.visualstudio.com/items?itemName=wmaurer.change-case
[09]: https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens
[10]: https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell
[11]: https://marketplace.visualstudio.com/items?itemName=nhoizey.gremlins
[12]: https://docs.github.com/en/billing/managing-billing-for-github-codespaces/about-billing-for-github-codespaces
[13]: https://code.visualstudio.com/docs/devcontainers/tutorial
[14]: https://github.com/codespaces
[15]: https://docs.github.com/codespaces/developing-in-codespaces/using-github-codespaces-in-visual-studio-code
[16]: https://learn.microsoft.com/contribute/markdown-reference#alerts-note-tip-important-caution-warning
[17]: https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette
[18]: https://code.visualstudio.com/docs/getstarted/tips-and-tricks
[19]: https://code.visualstudio.com/docs/editor/codebasics
[20]: https://code.visualstudio.com/docs/sourcecontrol/overview
[21]: https://code.visualstudio.com/docs/languages/markdown

# /./reference/community/contributing/general-markdown.md

    ---
    description: This article provides specific guidance for using Markdown in our documentation.
    ms.date: 07/26/2022
    title: Markdown best practices
    ---
# Markdown best practices

This article provides specific guidance for using Markdown in our documentation. This is not a
tutorial for Markdown, but list specific rules and best practice for Markdown in the PowerShell
docs. If you need a tutorial for Markdown, see this [Markdown cheatsheet][1].

## Markdown specifics

The Microsoft Open Publishing System (OPS) that builds our documentation uses [markdig][2] to
process the Markdown documents. Markdig parses the documents based on the rules of the latest
[CommonMark][3] specification.

The CommonMark spec is much stricter about the construction of some Markdown elements. Pay close
attention to the details provided in this document.

We use the [markdownlint][4] extension in VS Code to enforce our style and formatting rules. This
extension is installed as part of the **Learn Authoring Pack**.

### Blank lines, spaces, and tabs

Blank lines also signal the end of a block in Markdown.

- There should be a single blank between Markdown blocks of different types -- for example, between
  a paragraph and a list or header.
- Don't use more than one blank line. Multiple blank lines render as a single blank line in HTML
  and serve no purpose.
- Within a code block, consecutive blank lines break the code block.

Spacing is significant in Markdown.

- Remove extra spaces at the end of lines. Trailing spaces can change how Markdown renders.
- Always uses spaces instead of hard tabs.

### Titles and headings

Only use [ATX headings][5] (# style, as opposed to `=` or `-` style headers).

- Use sentence case - only proper nouns and the first letter of a title or header should be
  capitalized
- There must be a single space between the `#` and the first letter of the heading
- Headings should be surrounded by a single blank line
- Only one H1 per document
- Header levels should increment by one -- don't skip levels
- Avoid using bold or other markup in headers

### Limit line length to 100 characters

This applies to conceptual articles and cmdlet reference. Limiting the line length improves the
readability of git diffs and history. It also makes it easier for other writers to make
contributions.

Use the [Reflow Markdown][6] extension in VS Code to reflow paragraphs to fit the prescribed line
length.

About_topics are limited to 80 characters. For more specific information, see
[Formatting About_ files][7].

### Lists

If your list has multiple sentences or paragraphs, consider using a sublevel header rather than a
list.

List should be surrounded by a single blank line.

#### Unordered lists

- Don't end list items with a period unless they contain multiple sentences.
- Use the hyphen character (`-`) for list item bullets. This avoids confusion with bold or italic
  markup that uses the asterisk (`*`).
- To include a paragraph or other elements under a bullet item, insert a line break and align
  indentation with the first character after the bullet.

For example:

```markdown
This is a list that contain child elements under a bullet item.

- First bullet item

  Sentence explaining the first bullet.

  - Child bullet item

    Sentence explaining the child bullet.

- Second bullet item
- Third bullet item
```

This is a list that contains child elements under a bullet item.

- First bullet item

  Sentence explaining the first bullet.

  - Child bullet item

    Sentence explaining the child bullet.

- Second bullet item
- Third bullet item

#### Ordered lists

- All items in a numbered listed should use the number `1.` rather than incrementing each item.
  - Markdown rendering increments the value automatically.
  - This makes reordering items easier and standardizes the indentation of subordinate content.
- To include a paragraph or other elements under a numbered item, align indentation with the first
  character after the item number.

For example:

```markdown
1. For the first element, insert a single space after the 1. Long sentences should be wrapped to the
   next line and must line up with the first character after the numbered list marker.

   To include a second element, insert a line break after the first and align indentations. The
   indentation of the second element must line up with the first character after the numbered list
   marker.

1. The next numbered item starts here.
```

The resulting Markdown is rendered as follows:

1. For the first element, insert a single space after the 1. Long sentences should be wrapped to the
   next line and must line up with the first character after the numbered list marker.

   To include a second element, insert a line break after the first and align indentations. The
   indentation of the second element must line up with the first character after the numbered list
   marker.

1. The next numbered item starts here.

### Images

The syntax to include an image is:

```markdown
![[alt text]](<folderPath>)

Example:
![Introduction](./media/overview/Introduction.png)
```

Where `alt text` is a brief description of the image and `<folderPath>` is a relative path to the
image.

- Alternate text is required to support screen readers for the visually impaired.
- Images should be stored in a `media/<article-name>` folder within the folder containing the
  article.
  - Create a folder that matches the filename of your article under the `media` folder. Copy the
    images for that article to that new folder.
- Don't share images between articles.
  - If an image is used by multiple articles, each folder must have a copy of that image.
  - This prevents a change to an image in one article affecting another article.

The following image file types are supported: `*.png`, `*.gif`, `*.jpeg`, `*.jpg`, `*.svg`

### Markdown extensions supported by Open Publishing

The [Learn Authoring Pack][8] contains tools that support features unique to our publishing
system. Alerts are a Markdown extension to create blockquotes that render with colors and icons
highlighting the significance of the content. The following alert types are supported:

```markdown
> [!NOTE]
> Information the user should notice even if skimming.

> [!TIP]
> Optional information to help a user be more successful.

> [!IMPORTANT]
> Essential information required for user success.

> [!CAUTION]
> Negative potential consequences of an action.

> [!WARNING]
> Dangerous certain consequences of an action.
```

These alerts look like this on Microsoft Learn:

Note block

> [!NOTE]
> Information the user should notice even if skimming.

Tip block

> [!TIP]
> Optional information to help a user be more successful.

Important block

> [!IMPORTANT]
> Essential information required for user success.

Caution block

> [!CAUTION]
> Negative potential consequences of an action.

Warning block

> [!WARNING]
> Dangerous certain consequences of an action.

### Hyperlinks

- Hyperlinks must use Markdown syntax `[friendlyname](url-or-path)`.
- [Link references][9] are supported.
- The publishing system supports three types of links:
  - URL links
  - File links
  - Cross-reference links
- All URLs to external websites should use HTTPS unless that isn't valid for the target site.
- Links must have a friendly name, usually the title of the linked article
- Don't use backticks, bold, or other markup inside the brackets of a hyperlink.
- Bare URLs may be used when you're documenting a specific URI and must be enclosed in backticks.
  For example:

  ```markdown
  By default, if you don't specify this parameter, the DMTF standard resource URI
  `http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/` is used and the class name is appended to it.
  ```

#### URL-type Links

- URL links to other articles on `learn.microsoft.com` must use site-relative paths. The simplest
  way to create a relative link is to copy the URL from your browser then remove
  `https://learn.microsoft.com/en-us` from the value you paste into markdown.
- Don't include locales in URLs on Microsoft properties (remove `/en-us` from URL).
- Remove any unnecessary query parameters from the URL. Examples that should be removed:
  - `?view=powershell-5.1` - used to link to a specific version of PowerShell
  - `?redirectedfrom=MSDN` - added to the URL when you get redirected from an old article to its new
    location
- If you need to link to a specific version of a document, you must add the `&preserve-view=true`
  parameter to the query string. For example: `?view=powershell-5.1&preserve-view=true`
- URL links don't contain file extensions (for example, no `.md`)

#### File-type links

- A file link is used to link from one reference article to another, or from one conceptual
  article to another. If you need to link from a conceptual article to a reference article you must
  use a URL link.
- Use relative filepaths (for example: `../folder/file.md`)
- All file paths use forward-slash (`/`) characters
- Include the file extension (for example, `.md`)

#### Cross-reference links

Cross-reference links are a special feature supported by the publishing system. You can use
cross-reference links in conceptual articles to link to .NET API or cmdlet reference.

- For links to .NET API reference, see [Use links in documentation][10] in the central Contributor
  Guide.
- Links to cmdlet reference have the following format: `xref:<module-name>.<cmdlet-name>`. For
  example, to link to the `Get-Content` cmdlet in the **Microsoft.PowerShell.Management** module.

  `[Get-Content](xref:Microsoft.PowerShell.Management.Get-Content)`

#### Deep linking

Deep linking is allowed on both URL and file links.

- The anchor text must be lowercase
- Add the anchor to the end of the target path. For example:
  - `[about_Splatting](about_Splatting.md#splatting-with-arrays)`
  - `[custom key bindings](https://code.visualstudio.com/docs/getstarted/keybindings#_custom-keybindings-for-refactorings)`

For more information, see [Use links in documentation][11].

## Next steps

[PowerShell style guide][12]

<!-- link references -->
[1]: https://www.markdownguide.org/cheat-sheet/
[2]: https://github.com/lunet-io/markdig
[3]: https://spec.commonmark.org/
[4]: https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint
[5]: https://github.github.com/gfm/#atx-headings
[6]: https://marketplace.visualstudio.com/items?itemName=marvhen.reflow-markdown
[7]: powershell-style-guide.md#formatting-about_-files
[8]: https://learn.microsoft.com/contribute/how-to-write-docs-auth-pack
[9]: https://spec.commonmark.org/0.29/#link-reference-definitions
[10]: https://learn.microsoft.com/contribute/how-to-write-links#xref-cross-reference-links
[11]: https://learn.microsoft.com/contribute/how-to-write-links
[12]: powershell-style-guide.md

# /./reference/community/contributing/powershell-style-guide.md

    ---
    description: This article provides the rules of style for writing PowerShell documentation.
    ms.date: 11/14/2022
    title: PowerShell-Docs style guide
    ---
# PowerShell-Docs style guide

This article provides style guidance specific to the PowerShell-Docs content. It builds on the
information outlined in the [Overview][1].

## Formatting command syntax elements

- Always use the full name for cmdlets and parameters. Avoid using aliases unless you're
  specifically demonstrating the alias.
- Property, parameter, object, type names, class names, class methods should be **bold**.
  - Property and parameter values should be wrapped in backticks (`` ` ``).
  - When referring to types using the bracketed style, use backticks. For example:
    `[System.Io.FileInfo]`
- Language keywords, cmdlet names, functions, variables, native EXEs, file paths, and inline syntax
  examples should be wrapped in backtick (`` ` ``) characters.

  For example:

  ~~~markdown
  The following code uses `Get-ChildItem` to list the contents of `C:\Windows` and assigns
  the output to the `$files` variable.

  ```powershell
  $files = Get-ChildItem C:\Windows
  ```
  ~~~

  - PowerShell keywords and operators should be all lowercase

  - Use proper (Pascal) casing for cmdlet names and parameters

  - When referring to a parameter by name, the name should be **bold**. When illustrating the use of
    a parameter with the hyphen prefix, the parameter should be wrapped in backticks. For example:

    ```markdown
    The parameter's name is **Name**, but it's typed as `-Name` when used on the command
    line as a parameter.
    ```

  - When showing example usage of an external command, the example should be wrapped in backticks.
    Always include the file extension in the native command. For example:

    ```markdown
    To start the spooler service on a remote computer named DC01, you type:
    `sc.exe \\DC01 start spooler`.
    ```

    Including the file extension ensures that the correct command is executed according to
    PowerShell's command precedence.

## Markdown for code samples

Markdown supports two different code styles:

- **Code spans (inline)** - marked by a single backtick (`` ` ``) character. Used within a paragraph
  rather than as a standalone block.
- **Code blocks** - a multi-line block surrounded by triple-backtick (`` ``` ``) strings. Code
  blocks may also have a language label following the backticks. The language label enables syntax
  highlighting for the contents of the code block.

All code blocks should be contained in a code fence. Never use indentation for code blocks. Markdown
allows this pattern but it can be problematic and should be avoided.

A code block is one or more lines of code surrounded by a triple-backtick (`` ``` ``) code fence.
The code fence markers must be on their own line before and after the code sample. The opening
marker may have an optional language label. The language label enables syntax highlighting on the
rendered webpage.

For a full list of supported language tags, see [Fenced code blocks][2] in the centralized
contributor guide.

Publishing also adds a **Copy** button that can copy the contents of the code block to the
clipboard. This allows you to paste the code into a script to test the code sample. However, not all
examples are intended to be run as written. Some code blocks are basic illustrations of PowerShell
concepts.

There are three types code blocks used in our documentation:

1. Syntax blocks
1. Illustrative examples
1. Executable examples

### Syntax code blocks

Syntax code blocks are used to describe the syntactic structure of a command. Don't use a language
tag on the code fence. This example illustrates all the possible parameters of the `Get-Command`
cmdlet.

~~~markdown
```
Get-Command [-Verb <String[]>] [-Noun <String[]>] [-Module <String[]>]
  [-FullyQualifiedModule <ModuleSpecification[]>] [-TotalCount <Int32>] [-Syntax]
  [-ShowCommandInfo] [[-ArgumentList] <Object[]>] [-All] [-ListImported]
  [-ParameterName <String[]>] [-ParameterType <PSTypeName[]>] [<CommonParameters>]
```
~~~

This example describes the `for` statement in generalized terms:

~~~markdown
```
for (<init>; <condition>; <repeat>)
{<statement list>}
```
~~~

### Illustrative examples

Illustrative examples are used to explain a PowerShell concept. They aren't meant to be copied and
pasted for execution. These are most commonly used for simple examples that are easy to understand.
The code block can include the PowerShell prompt and example output.

Here's a simple example illustrating the PowerShell comparison operators. In this case, we don't
intend the reader to copy and run this example.

~~~markdown
```powershell
PS> 2 -eq 2
True

PS> 2 -eq 3
False

PS> 1,2,3 -eq 2
2

PS> "abc" -eq "abc"
True

PS> "abc" -eq "abc", "def"
False

PS> "abc", "def" -eq "abc"
abc
```
~~~

### Executable examples

Complex examples, or examples that are intended to be copied and executed, should use the following
block-style markup:

~~~markdown
```powershell
<Your PowerShell code goes here>
```
~~~

The output displayed by PowerShell commands should be enclosed in an **Output** code block to
prevent syntax highlighting. For example:

~~~markdown
```powershell
Get-Command -Module Microsoft.PowerShell.Security
```

```Output
CommandType  Name                        Version    Source
-----------  ----                        -------    ------
Cmdlet       ConvertFrom-SecureString    3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       ConvertTo-SecureString      3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Get-Acl                     3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Get-AuthenticodeSignature   3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Get-CmsMessage              3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Get-Credential              3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Get-ExecutionPolicy         3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Get-PfxCertificate          3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       New-FileCatalog             3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Protect-CmsMessage          3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Set-Acl                     3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Set-AuthenticodeSignature   3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Set-ExecutionPolicy         3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Test-FileCatalog            3.0.0.0    Microsoft.PowerShell.Security
Cmdlet       Unprotect-CmsMessage        3.0.0.0    Microsoft.PowerShell.Security
```
~~~

The **Output** code label isn't an official "language" supported by the syntax highlighting system.
However, this label is useful because our publishing system adds the "Output" label to the code box
frame on the web page. The "Output" code box has no syntax highlighting.

## Coding style rules

### Avoid line continuation in code samples

Avoid using line continuation characters (`` ` ``) in PowerShell code examples. These are hard to
see and can cause problems if there are extra spaces at the end of the line.

- Use PowerShell [splatting][3] to reduce line length for cmdlets that have several parameters.
- Take advantage of PowerShell's natural line break opportunities, like after pipe (`|`) characters,
  opening braces (`{`), parentheses (`(`), and brackets (`[`).

### Avoid using PowerShell prompts in examples

Use of the prompt string is discouraged and should be limited to scenarios that are meant to
illustrate command-line usage. For most of these examples, the prompt string should be `PS>`. This
prompt is independent of OS-specific indicators.

Prompts are required in examples to illustrate commands that alter the prompt or when the path
displayed is significant to the scenario. The following example illustrates how the prompt changes
when using the Registry provider.

```powershell
PS C:\> cd HKCU:\System\
PS HKCU:\System\> dir

    Hive: HKEY_CURRENT_USER\System

Name                   Property
----                   --------
CurrentControlSet
GameConfigStore        GameDVR_Enabled                       : 1
                       GameDVR_FSEBehaviorMode               : 2
                       Win32_AutoGameModeDefaultProfile      : {2, 0, 1, 0...}
                       Win32_GameModeRelatedProcesses        : {1, 0, 1, 0...}
                       GameDVR_HonorUserFSEBehaviorMode      : 0
                       GameDVR_DXGIHonorFSEWindowsCompatible : 0
```

### Don't use aliases in examples

Use the full name of all cmdlets and parameters unless you're specifically documenting the alias.
Cmdlet and parameter names must use the proper [Pascal-cased][4] names.

### Using parameters in examples

Avoid using positional parameters. In general, you should always include the parameter name in an
example, even if the parameter is positional. This reduces the chance of confusion in your examples.

## Formatting cmdlet reference articles

Cmdlet reference articles have a specific structure. This structure is defined by [PlatyPS][5].
PlatyPS generates the cmdlet help for PowerShell modules in Markdown. After editing the Markdown
files, PlatyPS is used create the MAML help files used by the `Get-Help` cmdlet.

PlatyPS has a schema that expects a specific structure for cmdlet reference. The
[platyPS.schema.md][6] document attempts to describe this structure. Schema violations cause build
errors that must be fixed before we can accept your contribution.

- Don't remove any of the ATX header structures. PlatyPS expects a specific set of headers.
- The **Input type** and **Output type** headers must have a type. If the cmdlet doesn't take input
  or return a value, then use the value `None`.
- Inline code spans can be used in any paragraph.
- Fenced code blocks are only allowed in the **EXAMPLES** section.

In the PlatyPS schema, **EXAMPLES** is an H2 header. Each example is an H3 header. Within an
example, the schema doesn't allow code blocks to be separated by paragraphs. The schema allows the
following structure:

```
### Example X - Title sentence

0 or more paragraphs
1 or more code blocks
0 or more paragraphs.
```

Number each example and add a brief title.

For example:

~~~markdown
### Example 1: Get cmdlets, functions, and aliases

This command gets the PowerShell cmdlets, functions, and aliases that are installed on the
computer.

```powershell
Get-Command
```

### Example 2: Get commands in the current session

```powershell
Get-Command -ListImported
```
~~~

## Formatting About_ files

`About_*` files are written in Markdown but are shipped as plain text files. We use [Pandoc][7] to
convert the Markdown to plain text. `About_*` files are formatted for the best compatibility across
all versions of PowerShell and with the publishing tools.

Basic formatting guidelines:

- Limit paragraph lines to 80 characters
- Limit code blocks to 76 characters
- Limit blockquotes and alerts to 78 characters
- When using these special meta-characters `\`,`$`, and `<`:
  - Within a header, these characters must be escaped using a leading `\` character or enclosed in
    code spans using backticks (`` ` ``)
  - Within a paragraph, these characters should be put into code spans. For example:

    ```markdown
    ### The purpose of the \$foo variable

    The `$foo` variable is used to store ...
    ```

- Markdown tables
  - For `About_*` topics, tables must fit within 76 characters
    - If the content doesn't fit within 76 character limit, use bullet lists instead
  - Use opening and closing `|` characters on each line

## Next steps

[Editorial checklist][8]

<!-- link references -->
[1]: overview.md#get-started-writing-docs
[2]: https://learn.microsoft.com/contribute/code-in-docs#inline-code-blocks
[3]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_splatting
[4]: https://en.wikipedia.org/wiki/PascalCase
[5]: https://github.com/powershell/platyps
[6]: https://github.com/PowerShell/platyPS/blob/master/platyPS.schema.md
[7]: https://pandoc.org
[8]: editorial-checklist.md

# /./reference/community/contributing/editorial-checklist.md

    ---
    description: This is a summarized list of rules for editing PowerShell documentation.
    ms.date: 11/16/2022
    title: Editorial checklist
    ---
# Editor's checklist

This is a summary of rules to apply when writing new or updating existing articles. See other
articles in the Contributor's Guide for detailed explanations and examples of these rules.

## Metadata

- `ms.date`: must be in the format **MM/DD/YYYY**
  - Change the date when there is a significant or factual update
    - Reorganizing the article
    - Fixing factual errors
    - Adding new information
  - Don't change the date if the update is insignificant
    - Fixing typos and formatting
- `title`: unique string of 43-59 characters long (including spaces)
  - Don't include site identifier (it's autogenerated)
  - Use sentence case - capitalize only the first word and any proper nouns
- `description`: 115-145 characters including spaces - this abstract displays in the search result

## Formatting

- Backtick syntax elements that appear, inline, within a paragraph
  - Cmdlet names `Verb-Noun`
  - Variable `$counter`
  - Syntactic examples `Verb-Noun -Parameter`
  - File paths `C:\Program Files\PowerShell`, `/usr/bin/pwsh`
  - URLs that aren't meant to be clickable in the document
  - Property or parameter values
- Use bold for property names, parameter names, class names, module names, entity names, object or
  type names
  - Bold is used for semantic markup, not emphasis
  - Bold - use asterisks `**`
- Italic - use underscore `_`
  - Only used for emphasis, not for semantic markup
- Line breaks at 100 columns (or at 80 for **about_Topics**)
- No hard tabs - use spaces only
- No trailing spaces on lines
- PowerShell keywords and operators should be all lowercase
- Use proper (Pascal) casing for cmdlet names and parameters

### Headers

- H1 is first - only one H1 per article
- Use [ATX Headers][1] only
- Use sentence case for all headers
- Don't skip levels - no H3 without an H2
- Max depth of H3 or H4
- Blank line before and after
- PlatyPS enforces specific headers in its schema - don't add or remove headers

### Code blocks

- Blank line before and after
- Use tagged code fences - **powershell**, **Output**, or other appropriate language ID
- Untagged fence - syntax blocks or other shells
- Put output in separate code block except for basic examples where you don't intend the for the
  reader to use the **Copy** button
- See list of [supported languages][2]

### Lists

- Indented properly
- Blank line before first item and after last item
- Bullet - use hyphen (`-`) not asterisk (`*`) to reduce confusion with emphasis
- For numbered lists, all numbers are "1."

## Terminology

- PowerShell vs. Windows PowerShell
- See [Product Terminology][3]

## Cmdlet reference examples

- Must have at least one example in cmdlet reference
- Examples should be just enough code to demonstrate the usage
- PowerShell syntax
  - Use full names of cmdlets and parameters - no aliases
  - Use splatting for parameters when the command line gets too long
  - Avoid using line continuation backticks - only use when necessary
- Remove or simplify the PowerShell prompt (`PS>`) except where required for the example
- Cmdlet reference example must follow the following PlatyPS schema

  ~~~markdown
  ### Example 1 - Descriptive title

  Zero or more short descriptive paragraphs explaining the context of the example followed by one or
  more code blocks. Recommend at least one and no more than two.

  ```powershell
  ... one or more PowerShell code statements ...
  ```

  ```Output
  Example output of the code above.
  ```

  Zero or more optional follow up paragraphs that explain the details of the code and output.
  ~~~

- don't put paragraphs between the code blocks. All descriptive content must come before or after
  the code blocks.

## Linking to other documents

- When linking outside the docset or between cmdlet reference and conceptual
  - Use site-relative URLs when linking to Microsoft Learn (remove `https://learn.microsoft.com/en-us`)
  - don't include locales in URLs on Microsoft properties (eg. remove `/en-us` from URL)
  - All URLs to external websites should use HTTPS unless that's not valid for the target site
- When linking within the docset
  - Use the relative filepath (e.g. `../folder/file.md`)
- All paths use forward-slash (`/`) characters
- Image links should have unique alt text

<!-- line references -->
[1]: https://github.github.com/gfm/#atx-headings
[2]: https://learn.microsoft.com/contribute/code-in-docs#supported-languages
[3]: product-terminology.md

# /./reference/community/contributing/product-terminology.md

    ---
    description: This article contains guidelines for the proper use of product names and terms.
    ms.date: 11/14/2022
    title: Product terminology and branding guidelines
    ---
# Product terminology and branding guidelines

When writing about any product it's important to correctly and consistently use product names and
terminology. This guide defines product names and terminology related to PowerShell. Note the
capitalization of specific words or use cases.

## PowerShell (collective name)

Use **PowerShell** to describe the scripting language and an interactive shell.

### PowerShell (product name)

The cross-platform version of PowerShell that's built on .NET (core), rather than the .NET
Framework. PowerShell can be installed on Windows, Linux, and macOS.

### PowerShell Core (product deprecated)

The name used for PowerShell v6, built on .NET Core. This name shouldn't be used.

### Windows PowerShell (product name)

The version of PowerShell that ships in Windows, which requires the full .NET Framework.

Guidelines

- First mention - use "Windows PowerShell"
- Subsequent mentions - Use "PowerShell" unless the use case requires "Windows PowerShell" to be
  more specific:

  > In PowerShell, the `Invoke-WebRequest` cmdlet returns **BasicHtmlWebResponseObject**

  > In Windows PowerShell, the `Invoke-WebRequest` cmdlet returns **HtmlWebResponseObject**

## PowerShell modules

PowerShell modules are add-ons that containing PowerShell cmdlets that manage specific products or
services.

For example:

- Azure PowerShell
- Az.Accounts module
- Windows management module
- Hyper-V module
- Microsoft Graph PowerShell SDK
- Exchange PowerShell

Guidelines

- Always use the collective name or the more specific module name when referring to a PowerShell
  module
- Never refer to a module as "PowerShell"

## Azure PowerShell (collective name)

The branded group of products containing PowerShell modules used to manage Azure.

There are several versions of Azure PowerShell products available. Each product contains multiple
named modules.

Guidelines

- Use "Azure PowerShell" as the collective name for the product
- Always use the collective name, never just "PowerShell"
- Use the more specific product name when referring to a specific version

### Az PowerShell (product name)

The currently supported collection of modules for use with Azure.

### AzureRM PowerShell (product name)

The earlier collection of modules that use the Azure Resource Manager model for managing Azure
resources. This product is deprecated and will not be supported after February 29, 2024.

### Azure Service Management PowerShell (product name)

The earliest collection of modules is for managing legacy Azure resources that use Service
Management APIs.

### Azure PowerShell-related products

These products are used to manage Azure resources but aren't included in one of the Azure PowerShell
product collections.

- Azure Active Directory PowerShell
- Azure Information Protection PowerShell
- Azure Deployment Manager PowerShell
- Azure Elastic Database Jobs PowerShell
- Azure Service Fabric PowerShell
- Azure Stack PowerShell

Guidelines

- Always use the full proper name of the product or the specific PowerShell module name

## Other PowerShell-related products

### Visual Studio Code (VS Code)

This is Microsoft's free, open source editor.

Guidelines

- First mention - use the full name
- Subsequent mentions - you can use "VS Code"
- Never use "VSCode"

### PowerShell Extension for Visual Studio Code

The extension turns VS Code into the preferred IDE for PowerShell.

Guidelines

- First mention - use the full name
- Subsequent mentions - you can use "PowerShell extension"

# /./reference/community/contributing/file-an-issue.md

    ---
    description: This article explains how to give feedback about the PowerShell documentation.
    ms.date: 07/26/2022
    title: How to file a PowerShell-Docs issue
    ---
# How to file a PowerShell-Docs issue

There are two ways to create an issue:

1. Use the feedback controls at the bottom of the page.
1. File an issue in GitHub directly

## Using the feedback controls

For a full description of the feedback controls, see the Docs Team blog announcing this
[feature][1].

At the bottom of most pages on `learn.microsoft.com`, you'll see two feedback buttons. One is a link
for product feedback and one is for documentation feedback. The documentation feedback requires a
GitHub account. Clicking the button takes you in GitHub and presents an issue template. Enter your
feedback and submit the form.

> [!NOTE]
> The feedback tool not a support channel. This is a way to ask questions to clarify documentation
> or to report errors and omissions. If you need technical support, see [Community resources][2].

## Filing issues on GitHub

To file a GitHub issue directly, you can click the [New issue][3] button in the PowerShell-Docs
repository. Click the **Get started** button for the issue you want to create. The GitHub issue
template helps you provide the information needed to address the problem you're reporting.

Before you file a new issue, read through existing issues to see if your problem has already been
reported. This helps avoid duplication and your issue may have been answered already. If you find an
existing issue, you can add your comments, related questions, or answers.

## Next steps

See [Get started writing][4].

## Additional resources

[How we manage issues][5]

<!-- reference links -->
[1]: https://learn.microsoft.com/teamblog/a-new-feedback-system-is-coming-to-docs
[2]: ../community-support.md
[3]: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/new/choose
[4]: get-started-writing.md
[5]: managing-issues.md

# /./reference/community/contributing/pull-requests.md

    ---
    description: This article explains how to submit pull requests to the PowerShell-Docs repository.
    ms.date: 07/26/2022
    title: How to submit pull requests
    ---
# How to submit pull requests

To make changes to content, submit a pull request (PR) from your fork. A pull request must be
reviewed before it can be merged. For best results, review the [editorial checklist][1] before
submitting your pull request.

## Using git branches

The default branch for PowerShell-Docs is the `main` branch. Changes made in working branches are
merged into the `main` branch before then being published. The `main` branch is merged into the
`live` branch every weekday at 3:00 PM (Pacific Time). The `live` branch contains the content that
is published to `learn.microsoft.com`.

Before starting any changes, create a working branch in your local copy of the PowerShell-Docs
repository. When working locally, be sure to synchronize your local repository before creating your
working branch. The working branch should be created from an update-to-date copy of the `main`
branch.

All pull requests should target the `main` branch. Don't submit change to the `live` branch. Changes
made in the `main` branch get merged into `live`, overwriting any changes made to `live`.

## Make the pull request process work better for everyone

The simpler and more focused you can make your PR, the faster it can be reviewed and merged.

### Avoid pull requests that update large numbers of files or contain unrelated changes

Avoid creating PRs that contain unrelated changes. Separate minor updates to existing articles from
new articles or major rewrites. Work on these changes in separate working branches.

Bulk changes create PRs with large numbers of changed files. Limit your PRs to a maximum of 50
changed files. Large PRs are difficult to review and are more prone to contain errors.

### Renaming or deleting files

When renaming or deleting files, there must be an issue associated with the PR. That issue must
discuss the need to rename or delete the files.

Avoid mixing content additions or change with file renames and deletes. Any file that's renamed or
deleted must be added to the global redirection file. When possible, update any files that link to
the renamed or deleted content, including any TOC files.

### Avoid editing repository configuration files

Avoid modifying repository configuration files. Limit your changes where possible to the Markdown
content files and any supporting image files needed for the content.

Incorrect modifications to repository configuration files can break the build, introduce
vulnerabilities or accessibility issues, or violate organizational standards. Repository
configuration files are any files that match one or more of these patterns:

- `*.yml`
- `.github/**`
- `.localization-config`
- `.openpublishing*`
- `LICENSE*`
- `reference/docfx.json`
- `reference/mapping/**`
- `tests/**`
- `ThirdPartyNotices`
- `tools/**`

For safety and security, if you believe you have discovered a bug or potential improvement for a
repository configuration file, [file an issue][2]. The maintainers will review and implement any
fixes or improvements as needed.

## Use the PR template

When you create a PR, a template is automatically inserted into the PR body for you. It looks like
this:

```md
# PR Summary

<!--
    Delete this comment block and summarize your changes and list
    related issues here. For example:

    This changes fixes problem X in the documentation for Y.

    - Fixes #1234
    - Resolves #1235
-->

## PR Checklist

<!--
    These items are mandatory. For your PR to be reviewed and merged,
    ensure you have followed these steps. As you complete the steps,
    check each box by replacing the space between the brackets with an
    x or by clicking on the box in the UI after your PR is submitted.
-->

- [ ] **Descriptive Title:** This PR's title is a synopsis of the changes it proposes.
- [ ] **Summary:** This PR's summary describes the scope and intent of the change.
- [ ] **Contributor's Guide:** I have read the [contributors guide][contrib].
- [ ] **Style:** This PR adheres to the [style guide][style].

<!--
    If your PR is a work in progress, please mark it as a draft or
    prefix it with "(WIP)" or "WIP:"

    This helps us understand whether or not your PR is ready to review.
-->

[contrib]: https://learn.microsoft.com/powershell/scripting/community/contributing/overview
[style]: https://learn.microsoft.com/powershell/scripting/community/contributing/powershell-style-guide
```

In the "PR Summary" section, write a short summary of your changes and list any related issues by
their issue number, like `#1234`. If your PR fixes or resolves the issue, use GitHub's
[autoclose][3] feature so the issue is automatically closed when your PR is merged.

Review the items in the "PR Checklist" section and check them off as you complete each one. You must
follow the directions and check each item for the team to approve your PR.

If your PR is a work-in-progress, set it to [draft mode][4] or prefix your PR title with `WIP`.

## Expectations Comment

After you submit your PR, a bot will comment on your PR to provide you with resources and to set
expectations for the rest of the process. Always review this comment, even if you've contributed
before, because it contains accurate and up-to-date information.

![example expectation comment][5]

## Docs PR validation service

The Docs PR validation service is a GitHub app that runs validation rules on your changes. You must
fix any errors or warnings reported by the validation service.

You'll see the following behavior:

1. You submit a PR.
1. In the GitHub comment that indicates the status of your PR, you'll see the status of "checks"
   enabled on the repository. In this example, there are two checks enabled, "Commit Validation" and
   "OpenPublishing.Build":

   ![validation status - some checks failed][6]

   The build can pass even if commit validation fails.

1. Click **Details** for more information.
1. On the Details page, you'll see all the validation checks that failed, with information about how
   to fix the issues.
1. When validation succeeds, the following comment is added to the PR:

   ![Validation status: success][7]

> [!NOTE]
> If you are an external (not a Microsoft employee) contributor you don't have access to the
> detailed build reports or preview links.

When the PR is reviewed, you may be asked to make changes or fix validation warning messages. The
PowerShell-Docs team can help you understand validation errors and editorial requirements.

## GitHub Actions

Several different GitHub Actions run against your changes to validate and provide context for you
and the reviewers.

### Checklist verification

If your PR is not in [draft mode][4] and is not prefixed with `WIP`, a GitHub Action inspects your
PR to verify that you have checked every item in the PR template's checklist. If this check fails,
the team won't review or merge your PR. The checklist items are mandatory.

### Authorization verification

If your PR targets the `live` branch or modifies any repository configuration files, a GitHub Action
checks your permissions to verify that you are authorized to submit those changes.

Only repository administrators are authorized to target the `live` branch or modify repository
configuration files.

### Versioned content change reporting

If your PR adds, removes, or modifies any versioned content a GitHub Action analyzes your changes
and writes a report summarizing the types of changes made to versioned content.

This report is useful for seeing if there are other versions of the file(s) you modified and whether
or not those versions have also been updated in the changeset.

To find the versioned content report for your PR:

1. Selecting the "Checks" tab on your PR page.
1. Select the "Reporting" job from the list of jobs.
1. Select the "..." button in the top right.
1. Select "View job summary."

![Example of a versioned content change report][8]

## Next steps

[PowerShell-Docs style guide][9]

## Additional resources

[How we manage pull requests][10]

<!--link refs-->
[1]: editorial-checklist.md
[2]: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/new/choose
[3]: https://help.github.com/en/articles/closing-issues-using-keywords
[4]: https://docs.github.com/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request
[5]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/community/contributing/media/pull-requests/expectations.png
[6]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/community/contributing/media/pull-requests/validation-failed.png
[7]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/community/contributing/media/pull-requests/build-validation.png
[8]: https://learn.microsoft.com/en-us/powershell/docs-conceptual/community/contributing/media/pull-requests/version-report.png
[9]: powershell-style-guide.md
[10]: managing-pull-requests.md

# /./reference/community/contributing/quality-improvements.md

    ---
    description: >-
        This article describes the process for contributing quality improvements to the documentation.
    ms.date: 06/28/2023
    title: Contributing quality improvements
    ---

# Contributing quality improvements

For [Hacktoberfest 2022][31], we [piloted a process][19] for contributing quality improvements to
the PowerShell content. This guide continues and generalizes that process, providing a low-friction
way for community members to contribute and collaborate on GitHub through enhancing the quality of
documentation.

We're focusing on these quality areas:

<!-- - [Aliases][04] -->
- [Formatting code samples][05]
- [Formatting command syntax][06]
- [Link References][07]
- [Markdown linting][08]
- [Spelling][09]

## Project Tracking

We're tracking contributions with the [PowerShell Docs Quality Contributions][23] GitHub Project.

The project page has several views for the issues and PRs related to this effort:

<!-- markdownlint-disable MD044 -->

- The [Open issues][24] view shows all open issues.
- The [Completed][25] view shows merged PRs.
- The [PowerShell][26] view shows open issues for documentation in the [PowerShell-Docs][14],
  [PowerShell-Docs-DSC][15], and [PowerShell-Docs-Modules][17] repositories.
- The [Windows PowerShell][27] view shows open issues for documentation in the
  [windows-powershell-docs repository][21].
- The [Azure PowerShell][28] view shows open issues for documentation in the
  [azure-docs-powershell repository][12].
- The [Open PRs][29] view shows all open PRs.

<!-- markdownlint-enable MD044 -->

<!-- ## Aliases

We're working through documenting the aliases for every cmdlet.

In the Notes section, add the information to the beginning of the section using this format:

```md
PowerShell includes the following aliases for `<Cmdlet-Name>`:

- All platforms:
  - `<alias>`
- Linux:
  - `<alias>`
- macOS:
  - `<alias>`
- Windows:
  - `<alias>`
```

If there is more than one alias for a platform, add it on a separate line as a new list item. If a
platform has no aliases, omit it from the list.

For Windows PowerShell, use one of these formats instead:

1. When the cmdlet has at least one alias

   ```md
   Windows PowerShell includes the following aliases for `<Cmdlet-Name>`:

   - `<alias>`
   ```

1. When the cmdlet haas no aliases

   ```md
   Windows Powershell includes no aliases for `<Cmdlet-Name>`.
   ```
-->
## Formatting code samples

All code samples should follow the [style guidelines][03] for PowerShell content. Those rules are
repeated in abbreviated form here for convenience:

- All code blocks should be contained in a triple-backtick code fence (`` ``` ``).
- Line length for code blocks is limited to `90` characters except in About topics, where it's
  limited to `76` characters.
- Avoid using line continuation characters (`` ` ``) in PowerShell code examples.
  - Use splatting or natural line break opportunities, like after pipe (`|`) characters, opening
    braces (`}`), parentheses (`(`), and brackets (`[`) to limit line length.
- Only include the PowerShell prompt for illustrative examples where the code is not intended for
  copy-pasting.
- Don't use aliases in examples unless you're specifically documenting the alias.
- Avoid using positional parameters. Use the parameter name, even if the parameter is positional.

## Formatting command syntax

All prose should follow the [style guidelines][02] for PowerShell content. Those rules are repeated
here for convenience:

- Always use the full name for cmdlets and parameters. Avoid using aliases unless you're
  specifically demonstrating the alias.
- Property, parameter, object, type names, class names, class methods should be **bold**.
  - Property and parameter values should be wrapped in backticks (`` ` ``).
  - When referring to types using the bracketed style, use backticks. For example:
    `[System.Io.FileInfo]`
- PowerShell module names should be **bold**.
- PowerShell keywords and operators should be all lowercase.
- Use proper (Pascal) casing for cmdlet names and parameters.
- When referring to a parameter by name, the name should be **bold**. When illustrating the use of
  a parameter with the hyphen prefix, the parameter should be wrapped in backticks.
- When showing example usage of an external command, the example should be wrapped in backticks.
  Always include the file extension of the external command.

## Link references

For maintainability and readability of the markdown source for our documentation, we're converting
our conceptual documentation to use link references instead of inline links.

For example, instead of:

```md
The [Packages tab][31] displays all available
packages in the PowerShell Gallery.
```

It should be:

```md
The [Packages tab][31] displays all available packages in the PowerShell Gallery.
```

> [!NOTE]
> When you replace an inline link, reflow the content to wrap at 100 characters. You can use the
> [reflow-markdown][30] VS Code extension to do this quickly.

At the bottom of the file, add a markdown comment before the definition of the links.

```md
<!-- Link references -->
[01]: https://www.powershellgallery.com/packages
```

Make sure that:

1. The links are defined in the order they appear in the document.
1. Every link points to the correct location.
1. The link reference definitions are at the bottom of the file after the markdown comment and are
   in the correct order.

## Markdown linting

For any article in one of the participating repositories, opening the article in VS Code displays
linting warnings. Address any of these warnings you find, except:

- [MD022/blanks-around-headings/blanks-around-headers][11] for the `Synopsis` header in cmdlet
  reference documents. For those items, the rule violation is intentional to ensure the
  documentation builds correctly with PlatyPS.

Make sure of the line lengths and use the [Reflow Markdown][30] extension to fix any long lines.

## Spelling

Sometimes, despite our best efforts, typos and misspellings get through and end up in the
documentation. These mistakes make documentation harder to follow and localize. Fixing these
mistakes makes the documentation more readable, especially for non-English speakers who rely on
accurate translations.

## Process

We encourage you to choose one or more of the quality areas and an article (or group of articles)
to improve. Once you've decided what articles and content areas you want to work on, follow these
steps:

<!-- markdownlint-disable MD044 -->

1. Check the [project][23] for issues filed for this effort to avoid duplicating efforts.
1. Open a new issue in the appropriate repository:
   - Open an issue in [MicrosoftDocs/PowerShell-Docs][20] for PowerShell reference and conceptual
     content.
   - Open an issue in [MicrosoftDocs/PowerShell-Docs-Dsc][16] for DSC content
   - Open an issue in [MicrosoftDocs/PowerShell-Docs-Modules][18] for Crescendo, PlatyPS,
     PSScriptAnalyzer, SecretManagement, and SecretStore content.
   - Open an issue in [MicrosoftDocs/azure-docs-powershell][13] for Azure PowerShell content.
   - Open an issue in [MicrosoftDocs/windows-powershell-docs][22] for Windows PowerShell module
     content.
1. Follow our [contributor's guide][01] to get setup for making your changes.
1. Submit your pull request. Ensure:

   1. Your PR title has the `Quality:` prefix.
   1. Your PR body references the issue it resolves as an unordered list item and uses one of the
      [linking keywords][10].

      For example, if you're working on issue `123`, the body of your PR should include the
      following Markdown:

      ```md
      - resolves #123
      ```

   The content developers will review your work as soon as they can to help you get it merged.

<!-- markdownlint-enable MD044 -->

<!-- Link References -->
[01]: https://learn.microsoft.com/powershell/scripting/community/contributing/overview#prepare-to-make-a-contribution
[02]: https://learn.microsoft.com/powershell/scripting/community/contributing/powershell-style-guide#formatting-command-syntax-elements
[03]: https://learn.microsoft.com/powershell/scripting/community/contributing/powershell-style-guide#markdown-for-code-samples
<!-- [04]: #aliases -->
[05]: #formatting-code-samples
[06]: #formatting-command-syntax
[07]: #link-references
[08]: #markdown-linting
[09]: #spelling
[10]: https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword
[11]: https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md#md022
[12]: https://github.com/MicrosoftDocs/azure-docs-powershell
[13]: https://github.com/MicrosoftDocs/azure-docs-powershell/issues/new?template=02-quality.yml&title=Quality%3A+
[14]: https://github.com/MicrosoftDocs/PowerShell-Docs
[15]: https://github.com/MicrosoftDocs/PowerShell-Docs-Dsc
[16]: https://github.com/MicrosoftDocs/PowerShell-Docs-Dsc/issues/new?template=02-quality.yml&title=Quality%3A+
[17]: https://github.com/MicrosoftDocs/PowerShell-Docs-Modules
[18]: https://github.com/MicrosoftDocs/PowerShell-Docs-Modules/issues/new?template=02-quality.yml&title=Quality%3A+
[19]: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/9257
[20]: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/new?template=02-quality.yml&title=Quality%3A+
[21]: https://github.com/MicrosoftDocs/windows-powershell-docs
[22]: https://github.com/MicrosoftDocs/windows-powershell-docs/issues/new?template=02-quality.yml&title=Quality%3A+
[23]: https://github.com/orgs/MicrosoftDocs/projects/15
[24]: https://github.com/orgs/MicrosoftDocs/projects/15/views/1
[25]: https://github.com/orgs/MicrosoftDocs/projects/15/views/2
[26]: https://github.com/orgs/MicrosoftDocs/projects/15/views/3
[27]: https://github.com/orgs/MicrosoftDocs/projects/15/views/4
[28]: https://github.com/orgs/MicrosoftDocs/projects/15/views/5
[29]: https://github.com/orgs/MicrosoftDocs/projects/15/views/6
[30]: https://marketplace.visualstudio.com/items?itemName=marvhen.reflow-markdown
[31]: https://www.powershellgallery.com/packages

# /./reference/community/contributing/hackathons.md

    ---
    description: This article describes how we manage and support hack-a-thon events like Hacktoberfest.
    ms.date: 10/04/2022
    title: Hacktoberfest and other hack-a-thon events
    ---
# Hacktoberfest and other hack-a-thon events

Hacktoberfest is an annual worldwide event held during October. The event encourages open source
developers to contribute to repositories through pull requests (PR). GitHub hosts many open source
repositories that contribute to Microsoft Learn content. Several repositories actively participate
in Hacktoberfest.

## How to contribute

Before you can contribute to an open source repo, you must first configure your account to
contribute to Microsoft Learn. If you have never completed this process, start by
[signing up for a GitHub account][01]. Be sure to [install Git and the Markdown tools][02].

To get credit for participation, [register with Hacktoberfest][03] and read their
[participation guide][04].

## Find a repo that needs your help

The PowerShell-Docs team is supporting Hacktoberfest contributions for several PowerShell
documentation repositories. We have defined a set of cleanup tasks designed to be simple for first
time contributors. Full information can be found in the [Hacktoberfest meta-issue][05].

To be successful with these tasks, you should:

- Have a general understanding of PowerShell syntax
- Have an understanding of [splatting][06]
- Be able to read and follow the [PowerShell-Docs style guide][07] and [Editorial checklist][08]
- Basic familiarity with Markdown

Before contributing should read the meta-issue. When you are ready to start, open a new issue using
the Hacktoberfest issue template (linked below):

- [MicrosoftDocs/PowerShell-Docs][09]
- [MicrosoftDocs/PowerShell-Docs-DSC][10]
- [MicrosoftDocs/PowerShell-Docs-Modules][11]
- [MicrosoftDocs/windows-powershell-docs][12]
- [MicrosoftDocs/azure-docs-powershell][13]

### Quality expectations

To have a successful contribution to an open source Microsoft Learn repository, create a meaningful
and impactful PR. The following examples from the official Hacktoberfest site are considered
**_low-quality contributions_**:

- PRs that are automated (for example, scripted opening PRs to remove whitespace, fix typos, or
  optimize images)
- PRs that are disruptive (for example, taking someone else's branch or commits and making a PR)
- PRs that are regarded by a project maintainer as a hindrance vs. helping
- A submission that's clearly an attempt to simply +1 your PR count for October

Finally, one PR to fix a typo is fine, but five PRs to remove a stray whitespace are not.

For more information, see [Hacktoberfest: Values][14].

### Open a PR

A _PR_ provides a convenient way for a contributor to propose a set of changes. When opening a PR,
specify in the original comment that it's intended to contribute to _hacktoberfest_. Successful PRs
have these common characteristics:

- The PR adds value.
- The contributor is receptive to feedback.
- The intended changes are well articulated.
- The changes are related to an existing issue.

If you're proposing a PR without a corresponding issue, create an issue first. For more information,
see [GitHub: About pull requests][15].

## See also

- [Git and GitHub essentials for Microsoft Learn documentation][16]
- [Official Hacktoberfest site][17]

<!-- link references -->
[01]: https://learn.microsoft.com/contribute/get-started-setup-github
[02]: https://learn.microsoft.com/contribute/get-started-setup-tools
[03]: https://hacktoberfest.com/auth/
[04]: https://hacktoberfest.com/participation/
[05]: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/9257
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_splatting
[07]: https://learn.microsoft.com/powershell/scripting/community/contributing/powershell-style-guide
[08]: https://learn.microsoft.com/powershell/scripting/community/contributing/editorial-checklist
[09]: https://github.com/MicrosoftDocs/PowerShell-Docs/issues/new?assignees=&labels=&template=00-hacktoberfest.yml&title=%F0%9F%8E%83+2022%3A+
[10]: https://github.com/MicrosoftDocs/PowerShell-Docs-DSC/issues/new?assignees=&labels=&template=00-hacktoberfest.yml&title=%F0%9F%8E%83+2022%3A+
[11]: https://github.com/MicrosoftDocs/PowerShell-Docs-Modules/issues/new?assignees=&labels=&template=00-hacktoberfest.yml&title=%F0%9F%8E%83+2022%3A+
[12]: https://github.com/MicrosoftDocs/windows-powershell-docs/issues/new?assignees=&labels=&template=00-hacktoberfest.yml&title=%F0%9F%8E%83+2022%3A+
[13]: https://github.com/MicrosoftDocs/azure-docs-powershell/issues/new?assignees=&labels=&template=00-hacktoberfest.yml&title=%F0%9F%8E%83+2022%3A+
[14]: https://hacktoberfest.com/participation/#values
[15]: https://docs.github.com/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests
[16]: https://learn.microsoft.com/contribute/git-github-fundamentals
[17]: https://hacktoberfest.com/

# /./reference/community/contributing/managing-issues.md

    ---
    description: This article explains how the PowerShell-Docs team manages issues.
    ms.date: 11/09/2022
    title: How we manage issues
    ---
# How we manage issues

This article documents how we manage issues in the PowerShell-Docs repository. This article is
designed to be a job aid for members of the PowerShell-Docs team. It's published here to provide
process transparency for our public contributors.

## Sources of issues

- Community contributors
- Internal contributors
- Transcriptions of comments from social media channels
- Feedback via the Docs feedback form

## Response time targets

80% of new issues are closed within 3 business days.

- Triaged - 1 business days
- Fix or change - 10 business days

### Labeling & Milestones

#### Label Types

- **Area** - Identifies the part of PowerShell or the docs that the issue is discussing
- **Issue** - The type of issue: like bug, feedback, or idea
- **Priority** - The priority of the issue; value range 0-3 (high-low)
- **Quality** - The [quality improvement][03] effort the issue commits to resolving
- **Status** - The status of the work item or why it was closed
- **Tag** - Used to for additional classification like availability or doc-a-thons
- **Waiting** - Shows that we're waiting on some external person or event

For more information on specific labels, see [Labeling][02].

#### Milestones

Issues and PRs should be tagged with the appropriate milestone. If the issue doesn't apply to a
specific version, then no milestone is used. PRs and related issues for changes that have yet to be
merged into the PowerShell code base should be assigned to the **Future** milestone. After the code
change has been merged, change the milestone to the appropriate version.

| Milestone |                Description                |
| --------- | ----------------------------------------- |
| 7.0.0     | Work items related to PowerShell 7.0      |
| 7.2.0     | Work items related to PowerShell 7.2      |
| 7.3.0     | Work items related to PowerShell 7.3      |
| Future    | Work items a future version of PowerShell |

## Triage process

PowerShell docs team members review the issues daily and triage new issues as they arrive. The team
meets weekly to discuss difficult issues need triage and prioritize the work.

### Misplaced product feedback

- Enter a comment redirecting the customer to the correct feedback channel.
- Optional: Copy the issue to the appropriate product feedback location, add a link to the copied
  item, and close the issue.

  The default location for PowerShell issues is
  [https://github.com/PowerShell/PowerShell/issues/new/choose][01].

### Support requests

- If the support question is simple, answer it politely and close the issue.
- If the question is more complicated, or the submitter replies with more questions, redirect them
  to forums and support channels. Suggested text for redirecting to forums:

  ```Markdown
  > This is not the right forum for these kinds of questions. Try posting your question in a
  > community support forum. For a list of community forums see:
  > https://learn.microsoft.com/powershell/scripting/community/community-support
  ```

### Code of conduct violations

- Edit the issue to remove any offensive content, if necessary
- Enter a comment indicating the issue is spam, close the issue, and then lock it to prevent further
  comments
- Each violation should be discussed in the weekly triage to determine the need for further action

<!-- link references -->
[01]: https://github.com/PowerShell/PowerShell/issues/new/choose
[02]: labelling-in-github.md
[03]: quality-improvements.md

# /./reference/community/contributing/managing-pull-requests.md

    ---
    description: This article explains how the PowerShell-Docs team manages pull requests.
    ms.date: 07/25/2022
    title: How we manage pull requests
    ---
# Managing pull requests

This article documents how we manage pull requests in the PowerShell-Docs repository. This article
is designed to be a job aid for members of the PowerShell-Docs team. It's published here to provide
process transparency for our public contributors.

## Best practices

- The person submitting the PR shouldn't merge the PR without a peer review.
- Assign the peer reviewer when the PR is submitted. Early assignment allows the reviewer to respond
  sooner with editorial remarks.
- Use comments to describe the nature of the change being submitted. Be sure to @mention the
  reviewer. For example, if the change is minor and you don't need a full technical review, explain
  this in a comment.
- Reviewers should use the comment suggestion feature, when appropriate, to make it easier for the
  author to accept the suggested change. For more information, see
  [Reviewing proposed changes in a pull request][1].

## PR Process steps

1. Writer: Create PR
   - Fill out the [PR template][2]
   - Link any issues resolved by the PR
   - Use GitHub's [autoclose][3] feature to close the issue
   - Work through and check off each item in the checklist
1. Writer: Assign peer reviewer
1. Reviewer: proofreads and comments (as necessary)
1. Writer: Incorporate review feedback
1. Both: Review preview rendering
1. Both: Review validation report - fix warnings and errors
1. Reviewer: Mark review "Approved"
1. Repo Admin: Merge PR (see below for criteria)

## Content Reviewer Checklist

See the [editorial checklist][4] for a more comprehensive list.

- Proofread for grammar, style, concision, technical accuracy
- Ensure examples still apply for the target version
- Check Preview rendering
- Check metadata - ms.date, remove ms.assetid, ensure required fields
- Validate markdown correctness
  - See style guide for content-specific formatting rules
- Reorganize examples as follows:
  - Intro sentence(s)
  - Code and output
  - Detailed explanation of code (as necessary)
- Check hyperlinks for accuracy
  - Replace or remove TechNet/MSDN links
  - Ensure minimum number of redirects to target
  - Ensure HTTPS
  - Correct link type
    - File links for local files
    - URL links for files outside of the docset
  - Remove locales from URLs
  - Simplify URLs pointing to `learn.microsoft.com`
- Verify versioned content is correct across all versions
  - Review the [versioned content change report][5] to see summarized changes

## Branch Merge Process

The `main` branch is the only branch that's merged into `live`. Merges from short-lived (working)
branches should be squashed.

| _Merge from/to_  | _release-branch_ |      _main_      |   _live_    |
| ---------------- | :--------------: | :--------------: | :---------: |
| _working-branch_ | squash and merge | squash and merge | Not allowed |
| _release-branch_ |     &mdash;      |      merge       | Not allowed |
| _main_           |      rebase      |     &mdash;      |    merge    |

### PR Merger checklist

- Content review complete
- Correct target branch for the change
- No merge conflicts
- All validation and build step pass
  - Warnings and suggestions should be fixed (see [Notes][6] for exceptions)
  - No broken links
  - The [Checklist][7] action ran and passed
  - If an [Authorization][8] check was triggered, it passed
- Merge according to table

### Notes

The following warnings can be ignored:

```
Can't find service name for `<version>/<modulepath>/About/About.md`
```

```
Metadata with following name(s) are not allowed to be set in Yaml header, or as file level
metadata in docfx.json, or as global metadata in docfx.json: `locale`. They are generated by
Docs platform, so the values set in these 3 places will be ignored. Please remove them from all
3 places to resolve the warning.
```

When a PR is merged, the HEAD of the target branch is changed. Any open PRs that were based on the
previous HEAD are now outdated. The outdated PR can be merged using Admin rights to override the
merge warnings in GitHub. This is safe to do if the previously merged PRs haven't touched the same
files. Clicking the **Update Branch** button is the safest option. Choose **Update with rebase**
option. For more information see [Updating your pull request branch][9].

## Publishing to Live

Periodically, the changes accumulated in the `main` branch need to be published to the live
website.

- The `main` branch is merged to `live` each weekday at 3pm PST.
- The `main` branch should be merged to `live` after any significant change.
  - Changes to 50 or more files
  - After merging a release branch
  - Changes to repo or docset configurations (docfx.json, OPS configs, build scripts, etc.)
  - Changes to the redirection file
  - Changes to the TOC
  - After merging a "project" branch (content reorg, bulk update, etc.)

<!-- link references -->
[1]: https://docs.github.com/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request
[2]: pull-requests.md#use-the-pr-template
[3]: https://help.github.com/en/articles/closing-issues-using-keywords
[4]: editorial-checklist.md
[5]: pull-requests.md#versioned-content-change-reporting
[6]: #notes
[7]: pull-requests.md#checklist-verification
[8]: pull-requests.md#authorization-verification
[9]: https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/keeping-your-pull-request-in-sync-with-the-base-branch#updating-your-pull-request-branch

# /./reference/community/contributing/labelling-in-github.md

    ---
    description: This article explains how the PowerShell-Docs team uses labels in GitHub.
    ms.date: 12/16/2022
    title: Labelling in GitHub
    ---

# Labelling in GitHub

This article documents how we label issues and pull requests in the PowerShell-Docs repository.
This article is designed to be a job aid for members of the PowerShell-Docs team. It's published
here to provide process transparency for our public contributors.

Labels always have a name and a description that is prefixed with their type.

## Area labels

Area labels identify the parts of PowerShell or the documentation that the issue relates to.

|          Label           |                                     Related Content                                      |
| :----------------------- | :--------------------------------------------------------------------------------------- |
| `area-about`             | The `about_*` topic articles.                                                            |
| `area-archive`           | The [Microsoft.PowerShell.Archive][03] module.                                           |
| `area-cim`               | The [CimCmdlets][01] module.                                                             |
| `area-community`         | Community-facing projects, including the contributor's guide and monthly updates.        |
| `area-conceptual`        | Conceptual (non-reference) articles.                                                     |
| `area-console`           | The console host                                                                         |
| `area-core`              | The [Microsoft.PowerShell.Core][04] module.                                              |
| `area-crescendo`         | The [Crescendo][02] module.                                                              |
| `area-debugging`         | Debugging PowerShell.                                                                    |
| `area-diagnostics`       | The [Microsoft.PowerShell.Diagnostics][05] module.                                       |
| `area-dsc`               | PowerShell Desired State Configuration.                                                  |
| `area-editorsvcs`        | The PowerShell editor services.                                                          |
| `area-engine`            | The PowerShell engine.                                                                   |
| `area-error-handling`    | Error handling in PowerShell                                                             |
| `area-experimental`      | PowerShell's experimental features                                                       |
| `area-gallery`           | The PowerShell Gallery.                                                                  |
| `area-helpsystem`        | The Help services, including the pipeline and `*-Help` cmdlets.                          |
| `area-host`              | The [Microsoft.PowerShell.Host][06] module.                                              |
| `area-ise`               | The PowerShell ISE.                                                                      |
| `area-jea`               | The Just Enough Administration feature.                                                  |
| `area-language`          | The PowerShell syntax and keywords.                                                      |
| `area-learn`             | The structured [training content][18] for PowerShell.                                    |
| `area-localaccounts`     | The [Microsoft.PowerShell.LocalAccounts][07] module.                                     |
| `area-localization`      | Localization problems or opportunities for the content.                                  |
| `area-management`        | The [Microsoft.PowerShell.Management][08] module.                                        |
| `area-native-cmds`       | Using native commands in PowerShell.                                                     |
| `area-omi`               | Open Management Infrastructure & CDXML.                                                  |
| `area-ops-issue`         | Building and rendering the content on the site.                                          |
| `area-other`             | Miscellaneous modules. <!-- Should we keep this? -->                                     |
| `area-overview`          | The overview section in the conceptual content.                                          |
| `area-packagemanagement` | The [PackageManagement][11] module.                                                      |
| `area-parallelism`       | Content covering parallel processing, such as using `ForEach-Object` or PowerShell Jobs. |
| `area-platyps`           | The [PlatyPS][12] module.                                                                |
| `area-portability`       | Cross-platform compatibility.                                                            |
| `area-powershellget`     | The [PowerShellGet][13] module.                                                          |
| `area-providers`         | PowerShell providers.                                                                    |
| `area-psreadline`        | The [PSReadline][14] module.                                                             |
| `area-release-notes`     | The PowerShell release notes.                                                            |
| `area-remoting`          | The PowerShell remoting feature and cmdlets.                                             |
| `area-scriptanalyzer`    | The [PSScriptAnalyzer][15] module.                                                       |
| `area-sdk-docs`          | The conceptual documentation for the PowerShell SDK.                                     |
| `area-sdk-ref`           | The .NET API reference documentation for the PowerShell SDK.                             |
| `area-security`          | The [Microsoft.PowerShell.Security][09] module and security concepts in general.         |
| `area-setup`             | Installing and configuring PowerShell.                                                   |
| `area-threadjob`         | The [ThreadJob][16] module.                                                              |
| `area-utility`           | The [Microsoft.PowerShell.Utility][10] module.                                           |
| `area-versions`          | Issues with the versioning of the documentation.                                         |
| `area-vscode`            | The VS Code PowerShell extension.                                                        |
| `area-wincompat`         | The Windows Compatibility feature.                                                       |
| `area-wmf`               | The Windows Management Framework.                                                        |
| `area-workflow`          | The Windows PowerShell Workflow feature.                                                 |

## Issue labels

Issue labels distinguish issues by purpose.

|          Label           |                       Issue Category                        |
| :----------------------- | :---------------------------------------------------------- |
| `issue-doc-bug`          | Errors or ambiguities in the content                        |
| `issue-doc-idea`         | Requests for new content                                    |
| `issue-kudos`            | Praise, positive feedback, or thanks rather than work items |
| `issue-product-feedback` | Feedback or problems with the product itself                |
| `issue-question`         | Support questions                                           |

## Priority labels

Priority labels rank which work items need to be worked on before others. These labels are only
used when needed to manage large sets of work items.

| Label  | Priority Level |
| -----: | :------------- |
| `Pri0` | Highest        |
| `Pri1` | High           |
| `Pri2` | Medium         |
| `Pri3` | Low            |

## Project Labels

Project labels indicate what ongoing GitHub Project a work item is related to. These labels are
used for automatically adding work items to a project on creation.

|       Label       |                Project                |
| ----------------: | :------------------------------------ |
| `project-quality` | The [quality improvement project][19] |

## Quality labels

Quality labels categorize work items for the [quality improvement][19] effort.

|              Label              |                               Improvement                               |
| :------------------------------ | :---------------------------------------------------------------------- |
| `quality-aliases`               | Ensure cmdlet aliases are documented                                    |
| `quality-format-code-samples`   | Ensure proper casing, line length, and other formatting in code samples |
| `quality-format-command-syntax` | Ensure proper casing and formatting for command syntax                  |
| `quality-link-references`       | Ensure links in conceptual docs are defined as numbered references      |
| `quality-markdownlint`          | Ensure content follows markdownlint rules                               |
| `quality-spelling`              | Ensure proper casing and spelling for words                             |

## Status labels

Status labels indicate why a work item was closed or shouldn't be merged. Issues are only given
status labels when they're closed without a related PR.

|             Label             |                       Status                        |
| :---------------------------- | :-------------------------------------------------- |
| `resolution-answered`         | Closed by existing documentation                    |
| `resolution-duplicate`        | Closed as duplicate issue                           |
| `resolution-external`         | Closed by customer or outside resource              |
| `resolution-no-repro`         | Unable to reproduce the reported issue              |
| `resolution-refer-to-support` | Closed and referred to community or product support |
| `resolution-wont-fix`         | Closed as won't fix                                 |

## Tag labels

Tag labels add independent context for work items.

|           Label           |                                  Purpose                                  |
| :------------------------ | :------------------------------------------------------------------------ |
| `in-progress`             | Someone is actively working on the item                                   |
| `go-live`                 | The work item is related to a specific release                            |
| `doc-a-thon`              | The work item is related to a doc-a-thon                                  |
| `up-for-grabs`            | Any contributor may volunteer to resolve the work item                    |
| `hacktoberfest-accepted`  | The PR is accepted for inclusion in [#hacktoberfest][17]                  |
| `hacktoberfest-candidate` | The PR is a candidate for inclusion in [#hacktoberfest][17]               |
| `needs-triage`            | The issue needs to be triaged by the team before it is ready to be worked |
| `code-of-conduct`         | Closed for spam, trolling, or code of conduct violations                  |
| `do-not-merge`            | The PR isn't meant to be merged                                           |

## Waiting labels

Waiting labels indicate that a work item can't be resolved until an external condition is met.

|         Label         |                        Waiting For                        |
| :-------------------- | :-------------------------------------------------------- |
| `hold-for-pr`         | Upstream PR to be merged                                  |
| `hold-for-release`    | Upstream product to release                               |
| `needs-investigation` | Waiting for team member to verify or research             |
| `needs-more-info`     | Additional details or clarification from work item author |
| `needs-response`      | Response from work item author                            |
| `review-shiproom`     | Shiproom discussion with the PowerShell team              |

<!-- link references -->
[01]: https://learn.microsoft.com/powershell/module/cimcmdlets
[02]: https://learn.microsoft.com/powershell/module/microsoft.powershell.crescendo
[03]: https://learn.microsoft.com/powershell/module/microsoft.powershell.archive
[04]: https://learn.microsoft.com/powershell/module/microsoft.powershell.core
[05]: https://learn.microsoft.com/powershell/module/microsoft.powershell.diagnostics
[06]: https://learn.microsoft.com/powershell/module/microsoft.powershell.host
[07]: https://learn.microsoft.com/powershell/module/microsoft.powershell.localaccounts
[08]: https://learn.microsoft.com/powershell/module/microsoft.powershell.management
[09]: https://learn.microsoft.com/powershell/module/microsoft.powershell.security
[10]: https://learn.microsoft.com/powershell/module/microsoft.powershell.utility
[11]: https://learn.microsoft.com/powershell/module/packagemanagement
[12]: https://learn.microsoft.com/powershell/module/platyps
[13]: https://learn.microsoft.com/powershell/module/powershellget
[14]: https://learn.microsoft.com/powershell/module/psreadline
[15]: https://learn.microsoft.com/powershell/module/psscriptanalyzer
[16]: https://learn.microsoft.com/powershell/module/threadjob
[17]: hackathons.md
[18]: https://learn.microsoft.com/training
[19]: quality-improvements.md

# /./reference/install/powershell-support-lifecycle.md

    ---
    description: Details the policies governing support for PowerShell
    ms.date: 02/23/2024
    ms.topic: lifecycle
    title: PowerShell Support Lifecycle
    ---
# PowerShell Support Lifecycle

> [!NOTE]
> This document is about support for PowerShell. Windows PowerShell (1.0 - 5.1) is a component of
> the Windows operating system. Components receive the same support as their parent product or
> platform. For more information, see [Product and Services Lifecycle Information][03].

PowerShell is supported under the [Microsoft Modern Lifecycle Policy][02], but support dates are
linked to [.NET and .NET Core Support Policy][06]. In this servicing approach, customers can choose
Long Term Support (LTS) releases or current releases.

An **LTS** release of PowerShell is built on an LTS release of .NET. Updates to an LTS release only
contain critical security updates and servicing fixes that are designed to minimize impact to
existing workloads. LTS releases of PowerShell are supported until the end-of-support for .NET.

A **current** release is a release that occurs between LTS releases. Current releases can contain
critical fixes, innovations, and new features. A current release is supported for six months after
the next release (current or LTS).

> [!IMPORTANT]
> You must have the latest patch update installed to qualify for support. For example, if you're
> running PowerShell 7.4.0 and 7.4.1 has been released, you must update to 7.4.1 to qualify for
> support.

## Supported platforms

PowerShell runs on multiple operating systems (OS) and processor architectures. To be supported by
Microsoft, the OS must meet the following criteria:

- The version and processor architecture of the OS is supported by .NET Core.
- The version of the OS is supported for at least one year.
- The version of the OS isn't an interim release or equivalent.
- The version of the OS is currently supported by the OS publisher.
- The PowerShell team has tested the version of the distribution.

When a platform version reaches end-of-life as defined by the platform owner, PowerShell also ends
support on that platform version. Previously released packages remain available for customers
needing access but formal support and updates of any kind are no longer be provided.

### Windows

[!INCLUDE [Windows support](../../includes/windows-support.md)]

### macOS

[!INCLUDE [macOS support](../../includes/macos-support.md)]

### Alpine Linux

[!INCLUDE [Alpine support](../../includes/alpine-support.md)]

### Debian Linux

[!INCLUDE [Debian support](../../includes/debian-support.md)]

### Red Hat Enterprise Linux (RHEL)

[!INCLUDE [RHEL support](../../includes/rhel-support.md)]

### Ubuntu Linux

[!INCLUDE [Ubuntu support](../../includes/ubuntu-support.md)]

## Windows PowerShell Compatibility

The support lifecycle for PowerShell doesn't cover modules that ship outside of the PowerShell
release package. For example, using the `ActiveDirectory` module that ships as part of Windows
Server is supported under the [Windows Support Lifecycle][01].

## Experimental features

[Experimental features][05] aren't intended to be used in production environments. We appreciate
feedback on experimental features and we provide best-effort support for them.

## Notes on licensing

PowerShell is released under the [MIT license][10]. Under this license, and without a paid support
agreement, users are limited to [community support][04]. With community support, Microsoft makes no
guarantees of responsiveness or fixes.

## Getting support

Support for PowerShell is delivered via traditional Microsoft support agreements, including
[paid support][12], [Microsoft Enterprise Agreements][14], and [Microsoft Software Assurance][15].
You can also pay for [assisted support][11] for PowerShell by filing a support request for your
problem.

There are multiple [community support][04] options. You can file an issue, bug, or feature request on
GitHub. Also, you can get help from other members of the community in the Microsoft
[PowerShell Tech Community][13] or any of the community forums listed on the [PowerShell][04] hub
page. If you have a problem that requires immediate attention, you should use the traditional, paid
support options.

> [!IMPORTANT]
> You must have the latest patch update installed to qualify for support. For example, if you're
> running PowerShell 7.3 and 7.3.1 has been released, you must update to 7.3.1 to qualify for
> support.

## PowerShell End-of-support dates

Based on these lifecycle policies, the following table lists the dates when support for the current
versions of PowerShell end:

|      Version       |   Release Date    |  End-of-support   |
| ------------------ | ----------------- | ----------------- |
| 7.4 (LTS-current)  | November 16, 2023 | November 10, 2026 |
| 7.3 (Stable)       | November 9, 2022  | May 8, 2024       |
| 7.2 (LTS-previous) | November 8, 2021  | November 8, 2024  |

Support for PowerShell on a specific platform is based on the support policy of the version of .NET
used.

- PowerShell 7.4 (LTS-current) is based on the [.NET 8.0 Supported OS Lifecycle Policy][09]
- PowerShell 7.3 (Stable) is based on the [.NET 7.0 Supported OS Lifecycle Policy][08]
- PowerShell 7.2 (LTS-previous) is based on the [.NET 6.0 Supported OS Lifecycle Policy][07]

End of support dates for already retired versions were:

|  Version  |    Release Date    |   End-of-support   |
| --------- | ------------------ | ------------------ |
| 7.0 (LTS) | March 4, 2020      | December 3, 2022   |
| 7.1       | November 11, 2020  | May 8, 2022        |
| 6.2       | March 28, 2019     | September 4, 2020  |
| 6.1       | September 13, 2018 | September 28, 2019 |
| 6.0       | January 20, 2018   | February 13, 2019  |

## Release history

The following table contains a timeline of the major releases of PowerShell. This table is provided
for historical reference. It isn't intended for use to determine the support lifecycle.

|            Version            | Release Date |                                      Note                                       |
| ----------------------------- | :----------: | ------------------------------------------------------------------------------- |
| PowerShell 7.5 (preview)      |     TBA      | Built on .NET 9.0.0-preview.1                                                   |
| PowerShell 7.4 (LTS-current)  |   Nov-2023   | Built on .NET 8.0.0                                                             |
| PowerShell 7.3                |   Nov-2022   | Built on .NET 7.0                                                               |
| PowerShell 7.2 (LTS-previous) |   Nov-2021   | Built on .NET 6.0 (LTS-previous)                                                |
| PowerShell 7.1                |   Nov-2020   | Built on .NET 5.0                                                               |
| PowerShell 7.0 (LTS)          |   Mar-2020   | Built on .NET Core 3.1 (LTS)                                                    |
| PowerShell 6.2                |   Mar-2019   | Built on .NET Core 2.1                                                          |
| PowerShell 6.1                |   Sep-2018   | Built on .NET Core 2.1                                                          |
| PowerShell 6.0                |   Jan-2018   | First release, built on .NET Core 2.0. Installable on Windows, Linux, and macOS |
| Windows PowerShell 5.1        |   Aug-2016   | Released in Windows 10 Anniversary Update and Windows Server 2016, WMF 5.1      |
| Windows PowerShell 5.0        |   Feb-2016   | Released in Windows Management Framework (WMF) 5.0                              |
| Windows PowerShell 4.0        |   Oct-2013   | Integrated in Windows 8.1 and with Windows Server 2012 R2, WMF 4.0              |
| Windows PowerShell 3.0        |   Oct-2012   | Integrated in Windows 8 and with Windows Server 2012 WMF 3.0                    |
| Windows PowerShell 2.0        |   Jul-2009   | Integrated in Windows 7 and Windows Server 2008 R2, WMF 2.0                     |
| Windows PowerShell 1.0        |   Nov-2006   | Optional component of Windows Server 2008                                       |

Run the following command to see the full version number of .NET used by the version of PowerShell
you're running:

```powershell
[System.Runtime.InteropServices.RuntimeInformation]::FrameworkDescription
```

<!-- link references -->
[01]: https://learn.microsoft.com/lifecycle/faq/windows
[02]: https://learn.microsoft.com/lifecycle/policies/modern
[03]: https://learn.microsoft.com/lifecycle/products/
[04]: https://learn.microsoft.com/powershell/scripting/community/community-support
[05]: https://learn.microsoft.com/powershell/scripting/learn/experimental-features
[06]: https://dotnet.microsoft.com/platform/support/policy/dotnet-core
[07]: https://github.com/dotnet/core/blob/main/release-notes/6.0/supported-os.md
[08]: https://github.com/dotnet/core/blob/main/release-notes/7.0/supported-os.md
[09]: https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md
[10]: https://github.com/PowerShell/PowerShell/blob/master/LICENSE.txt
[11]: https://support.microsoft.com/supportforbusiness/productselection
[12]: https://support.serviceshub.microsoft.com/supportforbusiness
[13]: https://techcommunity.microsoft.com/t5/PowerShell/ct-p/WindowsPowerShell
[14]: https://www.microsoft.com/licensing/licensing-programs/enterprise
[15]: https://www.microsoft.com/licensing/licensing-programs/software-assurance-default
