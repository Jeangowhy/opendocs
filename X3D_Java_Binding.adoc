:icons: font
:stem: latexmath
:source-highlighter: highlight.js
:standards: https://www.web3d.org/standards
== Part2: Java Binding (19777-2)

Extensible 3D (X3D) language bindings +
Part 2:  Java

ISO/IEC 19777-2:2005

This document is Part 2 of ISO/IEC 19777, Extensible 3D (X3D) language
bindings. The full title of this part of the International Standard is:
_Information technology — Computer graphics and image processing —
Extensible 3D (X3D) language bindings — Part 2: Java._

• <<foreword, Foreword>>
• <<introduction, Introduction>>
• 1 <<scope, Scope>>
• 2 <<references, Normative references>>
• 3 <<concepts, Concepts>>
• 4 <<tables, Tables>>
• 5 <<types, Type definitions>>
• 6 <<functions, Function definitions>>
• A <<compilation, Constructs in compilation order>>
• B <<abstracts, Abstract node interfaces>>
• C <<concretes, Concrete node interfaces>>
• D <<examples, Examples>>

The *_Foreword_* provides background on the standards process for X3D
language bindings. The *_Introduction_* describes the purpose of X3D
language bindings. The following clauses define this part of ISO/IEC
19777:

. *_Scope_* defines the problem area that the Java language binding of
X3D addresses.
. *_Normative references_* lists the normative standards referenced in
this part of ISO/IEC 19777.
. *_Concepts_* describes various fundamentals of the Java language
binding of X3D.
. *_Tables_* describes the mapping between abstract names and bound
names.
. *_Type definitions_* specifies the binding of abstract data types to
Java data types.
. *_Function definitions_* specifies binding of abstract service and
function definitions to Java function definitions.

There are several annexes included in the specification:

[loweralpha]
. *_Compilation order_* contains all bound constructs in compilation
order.
. *_Abstract node interfaces_* contains definitions of Java interfaces
that match with abstract node types defined in IS0/IEC 19775-1.
. *_Concrete node interfaces_* contains definitions of Java interfaces
that match with the concrete nodes defined in IS0/IEC 19775-1.
. *_Examples_* includes a variety of Java bound example files.

NOTE: Java Platform 的 SAI（Serviceability Agent Interface）规范是用于支持 Java 虚拟机（JVM）诊断和调试的关键技术组件。目标：提供一套接口和工具，允许开发者或工具（如调试器、性能分析器）访问 JVM 的内部状态，即使 JVM 已崩溃或处于不可响应状态。适用场景：生成堆转储（Heap Dump）分析内存泄漏；获取线程快照（Thread Dump）诊断死锁或性能瓶颈；监控 JVM 运行时状态（如 GC 行为、类加载信息）。

[[foreword]]
== Foreword

http://www.iso.org/[ISO] (the International Organization for
Standardization) and http://www.iec.ch/[IEC] (the International
Electrotechnical Commission) form a specialized system for worldwide
standardization. National bodies that are members of ISO or IEC
participate in the development of International Standards through
technical committees established by the respective organization to deal
with particular fields of technical activity. ISO and IEC technical
committees collaborate in fields of mutual interest. Other international
organizations, governmental and non-governmental, in liaison with ISO
and IEC, also take part in the work. In the field of information
technology, ISO and IEC have established a joint technical committee,
http://www.jtc1.org/[ISO/IEC JTC 1].

International Standards are drafted in accordance with the rules given
in the ISO/IEC Directives, Part 2.

The main task of the joint technical committee is to prepare
International Standards. Draft International Standards adopted by the
joint technical committee are circulated to national bodies for voting.
Publication as an International Standard requires approval by at least
75 % of the national bodies casting a vote.

Attention is drawn to the possibility that some of the elements of this
document may be the subject of patent rights. ISO and IEC shall not be
held responsible for identifying any or all such patent rights.

International Standard ISO/IEC 18024 was prepared by Joint Technical
Committee ISO/IEC JTC 1, _Information technology_, Subcommittee 24,
_Computer graphics and image processing_, in collaboration with
http://www.web3d.org/[Web3D Consortium, Inc.]

ISO/IEC 19777 consists of the following parts, under the general title
_Information technology — Computer graphics and image processing —
Extensible 3D (X3D) language bindings:_

_Part 1: ECMAScript_ +
_Part 2: Java (this part)_

[[introduction]]
== Introduction

=== Purpose

Extensible 3D (X3D) is a system for describing interactive 3D objects
and worlds as defined in ISO/IEC 19775. An inherent part of X3D is the
ability to modify the behaviour of these objects through scripting and
external programming. This part of ISO/IEC 19777 specifies the binding
of the application programmer interface defined in ISO/IEC 19775-2 to
the Java programming language.

[[scope]]
== 1 Scope

The Extensible 3D (X3D) specification, ISO/IEC 19775, specifies a
language independent application programmer interface (API) to a set of
services and functions. For integration into a programming language, the
X3D abstract interfaces are embedded in a language dependent layer
obeying the particular conventions of that language. This part of
ISO/IEC 19777 specifies such a language dependent layer for the Java
programming language.

[[references]]
== 2 Normative references

The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

The <<bibliography, Bibliography>> contains a list of informative
documents and technology.

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Identifier |Reference
|[[I639]]*I639* |http://www.iso.org/[ISO] 639:1988 Code for the
representation of names of languages.

|[[I3166]]*I3166* |http://www.iso.org/[ISO] 3166:1997 (all parts) Codes
for the representation of names of countries and their subdivisions.

|[[I8632]]*I8632* |http://www.iso.org/[ISO/IEC] 8632:1992 (all parts)
Information technology ― Computer graphics ― Metafile for the storage
and transfer of picture description information.

|[[I9899]]*I9899* |http://www.iso.org/[ISO/IEC] 9899:1990 Programming
languages — C.

|[[I10641]]*I10641* |http://www.iso.org/[ISO/IEC] 10641:1993
Information technology — Computer graphics and image processing —
Conformance testing of implementations of graphics standards.

|[[I10646_1]]*I10646-1* |http://www.iso.org/[ISO/IEC] 10646-1:2000
Information technology — Universal Multiple-Octet Coded Character Set
(UCS) - Part 1: Architecture and Basic Multilingual Plane, Internet
standards track protocol.

|[[I11172_1]]*I11172-1* |http://www.iso.org/[ISO/IEC] 11172-1:1993
Information technology — Coding of moving pictures and associated audio
for digital storage media at up to about 1,5 Mbit/s — Part 1: Systems.

|[[I14772_1]]*I14772-1* |http://www.iso.org/[ISO/IEC] 14772-1:1997
Information technology — Computer graphics and image processing — The
Virtual reality modeling language (VRML) — Part 1: Functional
specification.

|[[I18026]]*I18026* |http://www.iso.org/[ISO/IEC] 18026:200x
Information technology — Computer graphics — Spatial Reference Model
(SRM)

|[[I19775_1]]*I19775-1* |http://www.iso.org/[ISO/IEC] 19775-1:2004
Information technology — Computer graphics and image processing —
Extensible 3D (X3D) — Architecture and base components.

|[[I19775_2]]*I19775-2* |http://www.iso.org/[ISO/IEC] 19775-2:2004
Information technology — Computer graphics and image processing —
Extensible 3D (X3D) — Scene access interface (SAI).

|[[JAVA]]*JAVA* a|
"The Java Language Specification" by James Gosling, Bill Joy and Guy
Steele, Addison Wesley, Reading Massachusetts, 1996, ISBN
0-201-63451-1. +
http://java.sun.com/docs/books/jls/index.html

"The Java Virtual Machine Specification" by Tim Lindhold and Frank
Yellin, Addison Wesley, Reading Massachusetts, 1996, ISBN
0-201-63452-X. +
http://java.sun.com/docs/books/vmspec/index.html

|[[RFC1738]]*RFC1738* |IETF RFC 1738, Uniform Resource Locator,
Internet standards track protocol. +
http://ds.internic.net/rfc/rfc1738.txt[http://www.ietf.org/rfc/rfc1738.txt?number=1738]

|[[RFC1766]]*RFC1766* |IETF RFC 1766, Tags for the Identification of
Languages, Internet standards track protocol. +
http://ds.internic.net/rfc/rfc1766.txt[http://www.ietf.org/rfc/rfc1766.txt?number=1766]

|[[RFC1808]]*RFC1808* |IETF RFC 1808 Relative Uniform Resource Locator,
Internet standards track protocol. +
http://ds.internic.net/rfc/rfc1808.txt[http://www.ietf.org/rfc/rfc1808.txt?number=1808]

|[[RFC2077]]*RFC2077* |IETF RFC 2077, The Model Primary Content Type
for Multipurpose Internet Mail Extensions, IETF Internet standards track
protocol. +
ftp://ftp.internic.net/rfc/rfc2077.txt[http://www.ietf.org/rfc/rfc2077.txt?number=2077]

|[[RFC2141]]*RFC2141* |IETF RFC 2141 Universal Resource Name, Internet
standards track protocol. +
http://ds.internic.net/rfc/rfc2141.txt[http://www.ietf.org/rfc/rfc2141.txt?number=2141]

|[[RFC2397]]*RFC2397* |IETF RFC 2397, The "data" URL scheme, Internet
standards track protocol. +
http://www.ietf.org/rfc/rfc2397.txt?number=2397
|===

[[concepts]]
== 3 Concepts

[[IntroductionAndTOC]]
=== 3.1 Introduction and table of contents

[[Introduction]]
==== 3.1.1 Introduction

This clause describes key concepts in this part of ISO/IEC 19777. This
includes conformance criteria and abstract concepts of the binding
defined in this part of ISO/IEC 19777 to the abstract definitions
specified in <<I19775_2, Part 2 of ISO/IEC 19775>>, Scene access
interface (SAI).

[[Topics]]
==== 3.1.2 Topics

See <<Table4.1, Table 3.1>> for the table of contents for this clause.

[[t-Topics]]
Table 3.1 — Topics in this clause

* <<IntroductionAndTOC, 3.1 Introduction and Table of Contents>>
** <<Introduction, 3.1.1 Introduction>>
** <<Topics, 3.1.2 Topics>>
** <<Conventions, 3.1.3 Conventions>>
* <<GeneralConcepts, 3.2 General concepts>>
** <<ScopeOfSpecification, 3.2.1 Scope of specification>>
** <<Conformance, 3.2.2 Conformance>>
** <<ImplementationDependencies, 3.2.3 Implementation dependencies>>
** <<TypesOfJavaBrowsers, 3.2.4 Types of Java browsers>>
* <<LanguageSpecificConcepts, 3.3 Language specific concepts>>
** <<General, 3.3.1 General>>
*** <<LBConceptsIntroduction, 3.3.1.1 Introduction>>
*** <<ProvisionOfClasses, 3.3.1.2 Provision of classes>>
*** <<RequiredJavaVersion, 3.3.1.3 Required Java version>>
*** <<PackageStructure, 3.3.1.4 Package structure>>
*** <<RobustnessAndErrorHandling, 3.3.1.5 Robustness and error handling>>
** <<Sessions, 3.3.2 Sessions>>
*** <<SessionsIntroduction, 3.3.2.1 Introduction>>
*** <<Component, 3.3.2.2 Component>>
*** <<WebBrowserPlugin, 3.3.2.3 Web browser plug-in>>
** <<Identifiers, 3.3.3 Identifiers>>
*** <<IdentifierEquivalence, 3.3.3.1 Identifier equivalence>>
*** <<DataStorage, 3.3.3.2 Data storage>>
*** <<Serialization, 3.3.3.3 Serialization>>
** <<RelativeURLs, 3.3.4 Relative URLs>>
*** <<RelativeURLsIntroduction, 3.3.4.1 Introduction>>
*** <<JavaApplications, 3.3.4.2 Java applications>>
*** <<Applets, 3.3.4.3 Applets>>
*** <<RemoteApplications, 3.3.4.4 Remote applications>>
** <<FieldAccess, 3.3.5 Field access>>
** <<NULLNodes, 3.3.5.1 NULL nodes>>
*** <<ExternalInteractions, 3.3.5.2 External interactions>>
*** <<SettingMFNodeFields, 3.3.5.3 Setting MFNode fields>>
*** <<ArrayRepresentation, 3.3.5.4 Array representations>>
*** <<Set1Value, 3.3.5.5 set1Value>>
**** <<set1ValueGeneral, 3.3.5.5.1 General>>
**** <<set1ValueInternalInteractions, 3.3.5.5.2 Internal interactions>>
**** <<Set1ValueExternalInteractions, 3.3.5.5.3 External interactions>>
** <<DisposingOfRresources, 3.3.6 Disposing of resources>>

[[Conventions]]
==== 3.1.3 Conventions

The following type-setting conventions are used to indicate a particular
meaning to the text in this document.

[[t-Conventions]]
Table 3.2 — Type-setting Conventions in this clause

[opts="autowidth",frame=ends,grid=rows]
|===
|`+name+` |Words written in monospaced font are direct description of a
particular Java class, field or property. This text may also provide a
link to the specific documentation (provided in javadoc style
documentation) to provide greater definition of the information

|`+methodName()+` |Indicates a particular java method call. This may be
representative of the general method name (where there are overloaded
versions of the method) or just the method. No arguments definitions are
provided unless needed in context to define the particular method
specifically. The capitalization of the method name exactly follows the
name of the method

|`+ClassName.methodName()+` |The first word indicates the name of the
class and is qualified with the method name. The capitalization of the
class name follows the exact naming of the class. The method argument
presentation is the same as that for the plain method name.

|`+package.name.ClassName+` |All words up to the class name represent
the package definition that the class belongs to. Referred to as the
fully qualified class name. The last word is the name of the class.
Capitalization follows the exact definition of the class and package.
|===

[[GeneralConcepts]]
=== 3.2 General concepts

[[ScopeOfSpecification]]
==== 3.2.1 Scope of specification

The Java platform provides an implementation of the SAI specification.
It provides a complete binding to the specification within the
restrictions and implementation specific capabilities as defined in this
standard. The specification provides a browser implementation
independent way of accessing the browser capabilities through the Java
language.

[[Conformance]]
==== 3.2.2 Conformance

Java support is not required for a conforming implementation of the SAI.
A browser supporting a Java language interface for the SAI shall conform
to 7 Conformance of <<I19775_2, Part 2 of ISO/IEC 19775-2>> and shall
conform to the provisions of this part of ISO/IEC 19777.

An implementation shall not modify the classes and interfaces defined in
this part of ISO/IEC 19777 with specific methods or additional methods
defined by the implementation.

[[ImplementationDependencies]]
==== 3.2.3 Implementation dependencies

Implementation dependent for the scope of this annex is defined to be
the browser writer implementation of the Java classes and how they
interact with the environment and the X3D browser.

The listing of the implementation of all Java classes, interfaces and
exceptions used for binding to the services is provided in
<<CompilationOrder, Annex A, Compilation Order>>.

A browser implementation may supplement the specification defined in
this annex with further classes, exceptions and interfaces. The browser
implementation shall not directly modify these classes, exceptions and
interfaces, but may extend them using the standard Java language
facilities, within the rules defined by
<<PackageStructure, 3.3.1.4, Package Structure>>.

[[TypesOfJavaBrowsers]]
==== 3.2.4 Types of Java browsers

A X3D browser that can be accessed through a Java API can take one of
two forms. The first form is as a plugin to a web browser. The Java code
exists as an applet and accesses the plugin. The second form is a
component that is available to be directly embedded in the Java
framework. This form will subclass the Java Component class found in
`+java.awt.Component+`.

[[LanguageSpecificConcepts]]
=== 3.3 Language specific concepts

[[General]]
==== 3.3.1 General

[[LBConceptsIntroduction]]
===== 3.3.1.1 Introduction

This specification provides a set of implementation independent base
classes and interfaces (hereafter known simply as classes) that
represent the possible interactions with the X3D scene through the SAI.
Browser specific implementation dependencies shall to remain hidden to
the general user. Where classes are declared to be abstract, it is
expected that the browser specific implementation shall derive from
these classes as required.

An implementation shall not modify these base classes and interfaces
with their own specific methods or additional methods.

The difference between the two forms of the browser is limited to how to
initially obtain the browser reference. Once this has been obtained, the
services provided shall not differ. The term application is used to
describe the Java code that wishes to access the X3D browser, regardless
of how the initial reference to the browser was obtained.

[[ProvisionOfClasses]]
===== 3.3.1.2 Provision of classes

A browser that supports the SAI Java implementation may supply the base
classes as part of the distribution. The design of the classes is such
that only one copy of the classes defined by this application needs to
be placed on the machine although multiple copies are permitted.
Implementation dependent classes need only to be supplied with the
browser and accessed by setting the CLASSPATH to point to the
appropriate implementation dependent classes.

It is recommended that the implementation of the classes defined by this
specification are placed in either a zip file or Java Archive (JAR file)
under the `+$java.home/lib/ext +`directory.

[[RequiredJavaVersion]]
==== 3.3.1.3 Required Java version

The minimum required version of the Java Virtual Machine and associated
libraries is version 1.3 (formally known as Java 2 Version 1.3). It is
recommended that browsers support version 1.4 or later to fully support
built-in XML processing as part of the core libraries.

[[PackageStructure]]
===== 3.3.1.4 Package structure

The Java bindings to the SAI shall be provided under the
`+org.web3d.x3d.sai+` package structure. All classes, interfaces and
exceptions defined in this Annex shall be assumed to be a member of this
package unless explicitly stated otherwise. General concepts such as
field types, exceptions, and types that represent the core data types
shall be defined in this package.

Interfaces that represent the concrete node types shall be defined in a
sub-package named after that component. The sub-package name shall be
the short, formal form of the component as used in the COMPONENT
statement. For example:

[source,listing]
----
    org.web3d.x3d.sai.group
    org.web3d.x3d.sai.ext_shadow
    org.web3d.x3d.sai.mybrowser_overlay
----

[[RobustnessAndErrorHandling]]
===== 3.3.1.5 Robustness and error handling

User code may generate unexpected and uncaught errors at times,
particularly unchecked exceptions derived from
`+java.lang.RuntimeException+`. A browser implementation shall be aware
of this and behave appropriately. An exception generated in user code
shall not be treated as fatal. The browser shall catch the exception,
optionally log it somewhere (e.g., the browser console), and then
continue as though nothing happened.

There shall be one exception to this rule. Exceptions generated during
the initialization phase of the script shall be treated as fatal. The
exception shall be caught, reported, the class unloaded after which the
browser implementation shall move on to loading the next URL.

[[Sessions]]
==== 3.3.2 Sessions

[[SessionsIntroduction]]
===== 3.3.2.1 Introduction

A session for Java based communications is dependent on the type of
handle established: applet or component.

The difference between the two forms of the browser is limited to how to
initially obtain the browser reference. Once this has been obtained, the
services provided shall not differ. The term application is used to
describe the Java code that wishes to access the X3D browser, regardless
of how the initial reference to the browser was obtained.

[[Component]]
===== 3.3.2.2 Component

An X3D browser is established by creating a new instance of the X3D
component class. Options on the createBrowser service reference as
defined in 6.2.3, createBrowser in <<I19775_2, Part 2 of ISO/IEC 19775>>
may be used to control the properties of the browser. For
example a property can be used to ask for a SWING-based component rather
than AWT, or for a software off-screen renderer rather on-screen.
Definitions of the standardized properties that may be used are defined
in <<CreateBrowser, 6.2.3, createBrowser>>.

A browser implementation may also add their own additional properties.

At the point where the browser object is instantiated, it contains no
scene graph. To load the initial scene the `+loadURL()+` method is
called or the user code creates a new, empty scene and populates it with
nodes. If the application has registered as a listener for browser
events, it shall receive the initialize event as specified in
<<I19775_2, Part 2 of ISO/IEC 19775>>.

Components that define on-screen renderers follow the normal rules for
any class derived from `+java.awt.Component+`. It may be freely added to
any container and have extra components added that may partially or
completely obscure the area of the window that is being used to render
the X3D world. At no time shall the actions of other components that
partially or complete obscure the X3D browser cause execution of the X3D
event model to suspend or complete.

Note that this allows application code to draw over the top of the X3D
window and attach any `+java.awt.event+` listener as it requires without
modifying the functionality of the X3D browser and vice versa.

[[WebBrowserPlugin]]
===== 3.3.2.3 Web browser plug-in

When the X3D browser exists as an element embedded in a HTML page to
which a Java applet has access, it shall use the underlying web browser
APIs to access the plugin. The session is defined to last as long as
that particular plugin instance is associated with a currently active
page. A factory class shall be provided to obtain a reference to a X3D
browser plugin in an implementation independent manner.

The browser shall also provide notification to the listening
applications of when the world is no longer displayed on the page. When
the browser is removed from visibility it shall generate a shutdown
event to all registered listeners. If the browser becomes visible again
an initialized event shall be generated. If a new page is loaded with a
X3D browser as part of it, it will contain a different Browser reference
and hence the applet will not receive any such notification of its
presence.

[[Identifiers]]
==== 3.3.3 Identifiers

[[IdentifierEquivalence]]
===== 3.3.3.1 Identifier equivalence

Due to the nature of Java to native code interaction, it is possible
that two instances of a Java class may refer to the same node or field
inside the X3D scene (that is, using the `+==+` comparison will be
`+false+`). For this reason, an identifier of a node or field cannot be
implied to mean the same instance reference of the class representation.
The representation of an Identifier in Java classes is implementation
dependent. However, class instances may be checked for equivalence by
calling the `+equals()+` method of the appropriate class.
Implementations of the classes shall override the `+equals()+` method so
that comparing two nodes, fields or other classes that require an
identifier will return the correct result.

[[DataStorage]]
===== 3.3.3.2 Data storage

In the class structure, it is possible to associate user definable data
references with each field of a node and with the node itself. If one
reference to a node has data associated with it, this information shall
be available to all references to that node at all times. For example,
if a field has data associated with it, is then disposed and a later
application references that node, the data shall still remain (if that
other application is Java based). There is no requirement to store this
information if the node/field is no longer referenced by external
applications or the internal scene graph, or if the external application
is not Java based.

Within a single function call the identifier shall be identical. This
ensures that the following semantics seem logical to the end user:

....
  O1 = new SFVec3f(0, 0, 0);
  O2 = new SFVec3f(2, 4, 0);
  O1.setX(6);                        // O1 is (0, 6, 0)
  O2.setX(O1.getX());                // O2 is (2, 6, 0)
  myTranslationField.setValue(02).   //call translation.setValue(2, 6, 0);
....

[[Serialization]]
===== 3.3.3.3 Serialization

Java serialization may be used to either store the state of the scene
graph (for example in a database or file) or communicate between two
applications/applets interfacing with the same browser. Because
serialization does not maintain the same Java reference, calls to the
`+equals()+` method shall produce the correct result. The specification
has not defined classes to be serializable. This is implementation
dependent.

[[RelativeURLs]]
==== 3.3.4 Relative URLs

[[RelativeURLsIntroduction]]
===== 3.3.4.1 Introduction

Due to the different environments in which a Java-based X3D may find
itself, this binding defines the following additional behaviour for Java
implementations apply to processing of relative URLs.

[[JavaApplications]]
===== 3.3.4.2 Java applications

For standalone Java applications, the current working directory is
determined by using the `+user.dir+` system property of the application.
If a RURL is passed to the browser, it shall be resolved in equivalent
terms to the following statements:

[source,listing]
----
    String url_base = System.getProperty("user.dir");
    String complete_url = "file://" + url_base + <relative_url>;
    java.net.URL url = new URL(complete_url);
----

[[Applets]]
===== 3.3.4.3 Applets

The base document of the browser is considered to be the web page in
which the browser is embedded if the X3D Browser does not have a X3D
world loaded.

If the applet also creates a component-based X3D browser, the base
document determination shall be treated in exactly the same manner as
<<JavaApplications, 3.3.4.2 Java applications>> if there is not a base
world already loaded. Note that this normally will produce different
base documents if an applet accesses both a plug-in and a
component-based browser simultaneously.

[[RemoteApplications]]
===== 3.3.4.4 Remote applications

If a browser is located remotely to the application using it (for
example using an RMI implementation), the base url is considered to be
the base URL of the world. If no world URL has yet been set, the
appropriate action shall be either of the previous two sections
depending on how the browser was started.

[[FieldAccess]]
==== 3.3.5 Field access

[[NULLNodes]]
===== 3.3.5.1 NULL nodes

The Java `+null+` reference to an object shall be treated as the
equivalent of the X3D `+NULL+` value. Where an SFNode field has its
value set to `+null+`, this shall clear the field of the node reference
causing the default behaviour defined by the parent node to be used for
that field. When reading a value of an SFNode field where it is empty,
the return value shall be `+null+`.

[[ExternalInteractions]]
===== 3.3.5.2 External interactions

If `+beginUpdate()+` has been called and multiple individual setValue
actions have been performed on a single field, the result when
`+endUpdate()+` is called shall be a single event with all of the
individual values set. If two calls are made to set a particular array
index, the last value written shall be used.

If `+beginUpdate()+`has not been called, the result shall be an event
that contains the entire field value with the individual value changed.
Multiple setValue actions on the field object shall result in the
equivalent number of events being generated inside the X3D browser.

[[SettingMFNodeFields]]
===== 3.3.5.3 Setting MFNode fields

MFNodes are represented as an array of Node instances. It is possible
that during the creation of the array some or all of contents may
contain null references. The browser shall maintain nulls and keep them
in the order. This is equivalent to saying that there is nothing to
render for this index.

[[ArrayRepresentation]]
===== 3.3.5.4 Array representations

In MF fields, arrays are used to represent the data contained in the X3D
field. Setting the value of that field with an array of length zero
shall result in the contents of the field being cleared and is the
equivalent of the X3D text file declaration of:

[source,listing]
----
    SomeNode {
        MFField []
    }
----

An empty MF field shall return an array of length zero if queried about
its value. The `+ size()+` method of the MFField base class shall return
a value of 0.

Attempting to set the value of the field with `+null+` shall generate an
`+IllegalArgumentException+`.

[[Set1Value]]
===== 3.3.5.5 set1Value

[[set1ValueGeneral]]
====== 3.3.5.5.1 General

MFField classes contain a `+ set1Value()+` method for setting an
individual value in the field. The behaviour is dependent on whether the
call is made from an internal interaction or an external interaction.

[[set1ValueInternalInteractions]]
====== 3.3.5.5.2 Internal Interactions

Multiple `+set1Value()+` calls to the field shall result in the all of
the changes being aggregated together in a single event. This event is
propagated when the user code returns control to the browser and the
browser continues with the event cascade processing.

When the browser is processing a new event cascade all of the changes
made up until this current cascade evaluation are aggregated into a
single event and sent. This allows asynchronous scripts to use the
set1Value() call and aggregate a collection of changes together.
However, note that there is no guarantee or notification of when a
browser implementation may choose to evaluate the new event cascade
generated in such a circumstance and user code shall take precautions to
assure their desired effect.

[[Set1ValueExternalInteractions]]
====== 3.3.5.5.3 External Interactions

If `+beginUpdate()+` has been called and multiple `+set1Value()+`
methods have been called on that field, the result when `+ endUpdate()+`
is called shall be a single event with all of the individual values set.
If two calls are made to set a particular array index, the last value
written shall be used.

If `+beginUpdate()+`has not been called, the result shall be an event
that contains the entire field value with the individual value changed.
Multiple `+set1Value()+` calls to the field shall result in the
equivalent number of events being generated inside the X3D browser.

[[DisposingOfResources]]
==== 3.3.6 Disposing of resources

Of particular concern to Java implementations is the disposal of
resources used by the Java environment. The garbage collection
environment creates problems when dealing with native code
implementations of the X3D browser. An explicit `+dispose()+` method is
provided with all classes representing X3D entities so that the
application can explicitly dispose of the resources used by the browser
implementation.

For safety purposes, where a class defines a `+dispose()+` method, it
shall also override the default `+finalize()+` method provided by
`+java.lang.Object+` and call the `+dispose()+` method. This shall
ensure that even if the user has not explicitly called dispose on
objects, when the object reference goes out of scope, all resources
shall be freed regardless avoiding potential memory leaks.

Once a node has had the dispose method of, method calls on the node
shall generate an `+InvalidNodeException+`.

[[tables]]
== 4 Tables

[[IntroductionAndTOC]]
=== 4.1 Introduction and table of contents

[[Introduction]]
==== 4.1.1 Introduction

This clause contains tables defining abbreviations used and mapping
abstract names from ISO/IEC 19775-2 (see <<I19775, 2.I19775>>]) to
those of this binding.

[[Topics]]
==== 4.1.2 Topics

See <<t-Topics, Table 4.1>> for the table of contents for this clause.

[[t-Topics]]
Table 4.1 — Topics in this clause

* <<IntroductionAndTOC, 4.1 Introduction and Table of Contents>>
** <<Introduction, 4.1.1 Introduction>>
** <<Topics, 4.1.2 Topics>>
* <<MappingOfAbstractNames, 4.2 Mappings of abstract names to Java binding names>>
** <<DataTypes, 4.2.1 Data types>>
** <<ErrorTypes, 4.2.2 Error types>>
** <<EventTypes, 4.2.3 Event types>>
** <<BrowserServices, 4.2.4 Browser services>>
** <<ContextServices, 4.2.5 Execution context services>>
** <<SceneServices, 4.2.6 Scene services>>
** <<NodeServices, 4.2.7 Node services>>
** <<FieldServices, 4.2.8 Field services>>
** <<RouteServices, 4.2.9 Route services>>
** <<PrototypeServices, 4.2.10 Prototype services>>
** <<ScriptServices, 4.2.11 Script content services>>
** <<MatrixServices, 4.2.12 Matrix services>> +
 
* <<t-Topics, Table 4.1 — Topics in this clause>>
* <<t-DataTypesToJavaMapping, Table 4.2 — Data type names listed alphabetically by abstract name>>
* <<t-DataClassesToJavaMapping, Table 4.3 — Data class names listed alphabetically by abstract name>>
* <<t-ErrorTypeToJavaMapping, Table 4.4 — Error class names listed alphabetically by abstract name>>
* <<t-EventTypesToJavaMapping, Table 4.5 — Event type names listed alphabetically by abstract name>>
* <<t-BrowserSerivesToJavaMapping, Table 4.6 — Browser services listed alphabetically by abstract name>>
* <<t-ContextServicesToJavaMapping, Table 4.7 — Execution context services listed alphabetically by abstract name>>
* <<t-SceneServicesToJavaMapping, Table 4.8 — Scene services listed alphabetically by abstract name>>
* <<t-NodeServicesToJavaMapping, Table 4.9 — Node services listed alphabetically by abstract name>>
* <<t-FieldServicesToJavaMapping, Table 4.10 — Field services listed alphabetically by abstract name>>
* <<t-RouteServicesToJavaMapping, Table 4.11 — Route services listed alphabetically by abstract name>>
* <<t-ProtoServicesToJavaMapping, Table 4.12 — Prototype services listed alphabetically by abstract name>>
* <<t-ScriptServicesToJavaMapping, Table 4.13 — Script services listed alphabetically by abstract name>>
* <<t-MatrixServicesToJavaMapping, Table 4.14 — Utility services listed alphabetically by abstract name>>

[[MappingOfAbstractNames]]
=== 4.2 Mappings of abstract names to Java binding namesnamesnamesnames

[[DataTypes]]
===== 4.2.1 Data types

In <<t-DataTypesToJavaMapping, Table 4.2>>, each row lists an abstract
name of a data type from ISO/IEC 19775-2 followed by the corresponding
bound name. The names of data types used to reference data items are not
included but may be found in <<t-DataClassesToJavaMapping, Table 4.3>>.

[[t-DataTypesToJavaMapping]]
Table 4.2 — Data type names listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name           |Bound Name
|SAIAction               |N/A
|SAIBoolean              |boolean
|SAIBrowserApp           |X3DComponent
|SAIBrowserName          |java.lang.string
|SAIBrowserRef           |Browser +
ExternalBrowser
|SAIBrowserVersion       |java.lang.String
|SAIComponentDeclaration |ComponentInfo class
|SAIComponent            |(java.lang.String, int)
|SAIEncoding             |int
|SAIExecutionContext     |X3DExecutionContext
|SAIFieldAccess          |X3DFieldTypes
|SAIFieldName            |java.lang.String
|SAIFieldType            |X3DFieldTypes
|SAIFieldValue           |various. Defined by field type. See Table 5.4
|SAIFrameRate            |float
|SAILoadState            |X3DLoadStates
|SAINavSpeed             |float
|SAINodeID               |X3DNode and derived-types
|SAINodeType             |X3DNodeTypes
|SAIParameterList        |java.lang.String
|SAIPropertyList         |java.util.Map
|SAIRequesterID          |java.lang.Object
|SAIString               |java.lang.String
|SAIURL                  |java.util.String
|null                    |null
|===

[[t-DataClassesToJavaMapping]]
Table 4.3 — Data class names listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name           |Bound Name
|SAIBrowserRef           |Browser +
ExternalBrowser
|SAIComponentDeclaration |ComponentInfo
|SAIExecutionContextID   |X3DExecutionContext
|SAIFieldDeclaration     |X3DFieldDefinition
|SAIFieldValue           |various. Defined by field type
|SAILoadState            |X3DLoadStates
|SAINodeID               |X3DNode and derived-types
|SAIProfileDeclaration   |ProfileInfo
|SAIProtoDeclaration     |X3DProtoDeclaration
|SAIRoute                |X3DRoute
|SAIScript               |X3DScriptNodeType
|SAIScriptImplementation |X3DScriptImplementation +
X3DPerFrameObserverScript
|SAIScene                |X3DScene
|===

[[ErrorTypes]]
===== 4.2.2 Error types

In <<t-ErrorTypeToJavaMapping, Table 4.4>>, each row lists an abstract
name of an exception from ISO/IEC 19775-2 followed by the corresponding
bound name.

[[t-ErrorTypeToJavaMapping]]
Table 4.4 — Error class names listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name                 |Bound Name
|SAI_BROWSER_UNAVAILABLE       |NoSuchBrowserException
|SAI_CONNECTION_ERROR          |ConnectionException
|SAI_INSUFFICIENT_CAPABILITIES |InsufficientCapabilitiesException
|SAI_DISPOSED                  |InvalidBrowserException +
InvalidExecutionContextException +
InvalidNodeException +
InvalidRouteException +
InvalidProtoException
|SAI_IMPORTED_NODE             |InvalidImportException
|SAI_INVALID_ACCESS_TYPE       |InvalidWritableFieldException +
InvalidReadableFieldException
|SAI_INVALID_BROWSER           |InvalidBrowserException
|SAI_INVALID_DOCUMENT          |InvalidDocumentException
|SAI_INVALID_NAME              |InvalidNodeException +
InvalidNameException
|SAI_INVALID_NODE              |InvalidNodeException
|SAI_INVALID_FIELD             |InvalidFieldException
|SAI_INVALID_OPERATION_TIMING  |InvalidOperationTimingException
|SAI_INVALID_URL               |InvalidURLException
|SAI_INVALID_X3D               |InvalidX3DException
|SAI_NODE_NOT_AVAILABLE        |NodeUnavailableException
|SAI_NODE_IN_USE               |NodeInUseException
|SAI_NOT_SHARED                |BrowserNotSharedException
|SAI_NOT_SUPPORTED             |NotSupportedException
|SAI_URL_UNAVAILABLE           |URLUnavailableException
|===

[[EventTypes]]
===== 4.2.3 Event types

In <<t-EventTypesToJavaMapping, Table 4.5>>, each row lists an
abstract name of an event type from ISO/IEC 19775-2 followed by the
corresponding bound name.

[[t-EventTypesToJavaMapping]]
Table 4.5 — Event type names listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name               |Bound Name
|SAIBrowserEvent             |BrowserEvent
|SAI_BROWSER_ConnectionError |CONNECTION_ERROR
|SAIFieldEvent               |X3DFieldEvent
|SAI_BROWSER_Initialized     |INITIALIZED
|SAI_BROWSER_Shutdown        |SHUTDOWN
|SAI_BROWSER_URLError        |URL_ERROR
|===

[[BrowserServices]]
===== 4.2.4 Browser services

In <<t-BrowserSerivesToJavaMapping, Table 4.6>>, each row lists an
abstract name of an event type from ISO/IEC 19775-2 followed by the
corresponding bound name.

[[t-BrowserSerivesToJavaMapping]]
Table 4.6 — Browser services listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name             |Bound Name
|getBrowser                |ExternalBrowser getBrowser(java.applet.Applet) +
ExternalBrowser getBrowser(java.applet.Applet, java.lang.String, int) +
ExternalBrowser getBrowser(java.net.InetAddress, int)
|createBrowser             |X3DComponent createBrowser(java.util.Map)
|getName                   |String getName()
|String getVersion         |getVersion()
|getCurrentSpeed           |float getCurrentSpeed()
|getCurrentFrameRate       |float getCurrentFrameRate()
|getSupportedProfiles      |ProfileInfo[] getSupportedProfiles
|getProfile                |ProfileInfo getProfile(java.lang.String)
|getSupportedComponents    |ComponentInfo[] getSupportedComponent()
|getComponent              |ComponentInfo getComponent(java.lang.String, int)
|getExecutionContext       |ExecutionContext getExecutionContext()
|createScene               |X3DScene createScene(ProfileInfo, ComponentInfo[])
|replaceWorld              |replaceWorld(X3DScene)
|importDocument            |X3DScene importDocument(org.w3c.dom.Node)
|loadURL                   |void loadURL(java.lang.String[], java.lang.String[])
|setDescription            |void setDescription(java.lang.String)
|createX3DFromString       |X3DScene createX3DFromString(java.lang.String)
|createX3DFromStream       |X3DScene createX3DFromString(java.io.InputStream)
|createX3DFromURL          |X3DScene createX3DFromURL(java.lang.String[])
|Update Control            |void beginUpdate() +
void endUpdate()
|Register Browser Interest |void addBrowserListener(BrowserListener) +
void removeBrowserListener(BrowserListener)
|getRenderingProperties    |java.util.Map getRenderingProperties()
|getBrowserProperties      |java.util.Map getBrowserProperties()
|changeViewpoint           |void nextViewpoint() + void previousViewpoint() +
void firstViewpoint() +
void lastViewpoint()
|Print                     |void print(Object) +
void println(Object)
|Dispose                   |void dispose()
|===

[[ContextServices]]
===== 4.2.5 Execution context services

In <<t-ContextServicesToJavaMapping, Table 4.7>>, each row lists an
abstract name of an execution context service from ISO/IEC 19775-2
followed by the corresponding bound name.

[[t-ContextServicesToJavaMapping]]
Table 4.7 — Execution context
services listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name                    |Bound Name
|getSpecificationVersion          |String getSpecificationVersion()
|getEncoding                      |int getEncoding()
|getProfile                       |ProfileInfo getProfile()
|getComponents                    |ComponentInfo[] getComponents()
|getWorldURL                      |String getWorldURL()
|getNode                          |X3DNode getNamedNode(java.lang.String) +
X3DNode getExportedNode(java.lang.String)
|createNode                       |X3DNode createNode(java.lang.String)
|createProto                      |X3DNode createProto(java.lang.String)
|Named node handling              |void updateNamedNode(java.lang.String, X3DNode) +
void updateImportedNode(java.lang.String, java.lang.String, X3DNode) +
void removeNamedNode(java.lang.String) +
void removeImportedNode(java.lang.String)
|getProtoDeclaration              |X3DProtoDeclaration getProtoDeclaration(java.lang.String)
|PROTO Declaration Handling       |void updateProtoDeclaration(java.lang.String, X3DProtoDeclaration) +
void removeProtoDeclaration(java.lang.String)
|getExternProtoDeclaration        |X3DExternProtoDeclaration getExternProtoDeclaration(java.lang.String)
|EXTERNPROTO Declaration Handling |void updateExternProtoDeclaration(java.lang.String,
X3DExternProtoDeclaration) +
void removeExternProtoDeclaration(java.lang.String)
|getRootNodes                     |X3DNode[] getRootNodes
|getRoutes                        |X3DRoute[] getRoutes()
|Dynamic Route Handling           |X3DRoute[] addRoute(X3DNode, java.lang.String, X3DNode, java.lang.String) +
void removeRoute(X3DRoute)
|Dispose                          |void dispose()
|===

[[SceneServices]]
===== 4.2.6 Scene services

In <<t-SceneServicesToJavaMapping, Table 4.8>>, each row lists an
abstract name of an scene service from ISO/IEC 19775-2 followed by the
corresponding bound name.

[[t-SceneServicesToJavaMapping]]
Table 4.8 — Scene services listed
alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name  |Bound Name
|getMetaData    |java.lang.String getMetaData(java.lang.String)
|setMetaData    |void setMetaData(java.lang.String, java.lang.String)
|getNode        |X3DNode getExportedNode(java.lang.String)
|Named Node Handling |void updateExportedNode(java.lang.String,
java.lang.String) +
void removeExportedNode(java.lang.String)
|Root Node Handling |void addRootNode(X3DNode) +
void removeRootNode(X3DNode);
|===

[[NodeServices]]
===== 4.2.7 Node services

In <<t-NodeServicesToJavaMapping, Table 4.9>>, each row lists an
abstract name of an node service from ISO/IEC 19775-2 followed by the
corresponding bound name.

[[t-NodeServicesToJavaMapping]]
Table 4.9 — Node services listed
alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name |Bound Name
|getName |String getName()
|getType |int[] getType()
|getField |X3DField getField(java.lang.String)
|getFieldDefinitions |X3DFieldDefinition getFieldDefinitions()
|Dispose |void dispose()
|===

[[FieldServices]]
===== 4.2.8 Field services

In <<t-FieldServicesToJavaMapping, Table 4.10>>, each row lists an
abstract name of a field service from ISO/IEC 19775-2 followed by the
corresponding bound name.

[[t-FieldServicesToJavaMapping]]
Table 4.10 — Field services listed
alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name           |Bound Name

|getName                 |String getName()
|getType                 |int getType()
|getAccessType           |boolean isWritable() +
boolean isReadable()
|getValue                |_type_ getValue() +
void getValue(_type_) +
_type_ get1Value(int) +
|setValue                |void setValue(_type_) +
void get1Value(int, _type_)
|Register Field Interest |void
addFieldEventListener(X3DFieldEventListener) +
void removeFieldEventListener(X3DFieldEventListener)
|Dispose                 |void dispose()
|===

[[RouteServices]]
===== 4.2.9 Route services

In <<t-RouteServicesToJavaMapping, Table 4.11>>, each row lists an
abstract name of a route service from ISO/IEC 19775-2 followed by the
corresponding bound name.

[[t-RouteServicesToJavaMapping]]
Table 4.11 — Route services listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name          |Bound Name
|getSourceNode          |X3DNode getSourceNode()
|getSourceField         |java.lang.String getSourceField()
|getDestinationNode     |X3DNode getDestinationNode()
|getDestinationField    |java.lang.String getDestinationField()
|Dispose                |dispose()
|===

[[PrototypeServices]]
===== 4.2.10 Prototype services

In <<t-ProtoServicesToJavaMapping, Table 4.12>>, each row lists an
abstract name of a prototype service from ISO/IEC 19775-2 followed by
the corresponding bound name.

[[t-ProtoServicesToJavaMapping]]
Table 4.12 — Prototype services listed
alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name          |Bound Name
|isExternProto          |_instanceof_ operator
|createInstance         |X3DProtoInstance createInstance()
|getFieldDefinitions    |X3DFieldDefinition[] getFieldDefinitions
|Check Load State       |int getLoadState()
|Request Immediate Load |void loadNow()
|Dispose                |dispose()
|===

[[ScriptServices]]
===== 4.2.11 Script content services

In <<t-ScriptServicesToJavaMapping, Table 4.13>>, each row lists an
abstract name of a script content service from ISO/IEC 19775-2 followed
by the corresponding bound name.

[[t-ScriptServicesToJavaMapping]]
Table 4.13 — Script content services
listed alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name          |Bound Name
|setBrowser             |void setBrowser(Browser)
|setFields              |setFields(X3DScriptNode, java.util.Map)
|initialize             |void initialize()
|prepareEvents          |void prepareEvents()
|eventsProcessed        |void eventsProcessed()
|shutdown               |void shutdown()
|===

[[MatrixServices]]
===== 4.2.12 Matrix services

In <<t-MatrixServicesToJavaMapping, Table 4.14>>, each row lists an
abstract name of a matrix service from <<I19775_2, Part 2 of ISO/IEC 19775>>
followed by the corresponding bound name.

[[t-MatrixServicesToJavaMapping]]
Table 4.14 — Matrix services listed
alphabetically by abstract name

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Name   |Bound Name
|set             |void set(SFVec3f, SFRotation, SFVec3f, SFRotation, SFVec3f).
|get             |void get(SFVec3f, SFRotation, SFVec3f)
|inverse         |void inverse()
|transpose       |void transpose()
|Matrix.multiply |void multiplyLeft(Matrix) +
void multiplyRight(Matrix)
|Matrix Multiply with vector |void multiplyLeft(Matrix, SFVec3f) +
void multiplyLeft(Matrix, SFVec3d) +
void multiplyRight(Matrix, SFVec3f) +
void multiplyRight(Matrix, SFVec3d)
|===

[[types]]
== 5 Type definitions

[[IntroductionAndTOC]]
=== 5.1 Introduction and table of contents

[[Introduction]]
==== 5.1.1 Introduction

The X3D Scene Authoring Interface (see <<I19775, 2.[I19775>>]) defines
a set of fundamental abstract data types. This clause specifies the
mapping from those data types to the data types defined in this binding.
All implementation-dependent data types are defined after all
implementation independent data types in each category.

[[Topics]]
==== 5.1.2 Topics

See <<t-Topics, Table 5.1>> for the table of contents for this clause.

[[t-Topics]]
Table 5.1 — Topics in this clause

* <<IntroductionAndTOC, 5.1 Introduction and Table of Contents>>
** <<Introduction, 5.1.1 Introduction>>
** <<Topics, 5.1.2 Topics>>
* <<DataTtypeDefinitions, 5.2 Data type definitions>>
** <<SAIAction, 5.2.1 SAIAction>>
** <<SAIBrowserApp, 5.2.2 SAIBrowserApp>>
** <<SAIBrowserName, 5.2.3 SAIBrowserName>>
** <<SAIBrowserRef, 5.2.4 SAIBrowserRef>>
** <<SAIBrowserVersion, 5.2.5 SAIBrowserVersion>>
** <<SAIComponentDeclaration, 5.2.6 SAIComponentDeclaration>>
** <<SAIComponentID, 5.2.7 SAIComponentID>>
** <<SAIExecutionContextID, 5.2.8 SAIExecutionContextID>>
** <<SAIFieldAccess, 5.2.9 SAIFieldAccess>>
** <<SAIFieldDefinition, 5.2.10 SAIFieldDefinition>>
** <<SAIFieldID, 5.2.11 SAIFieldID>>
** <<SAIFieldName, 5.2.12 SAIFieldName>>
** <<SAIFieldType, 5.2.13 SAIFieldType>>
** <<SAIFieldValue, 5.2.14 SAIFieldValue>>
** <<SAIFrameRate, 5.2.15 SAIFrameRate>>
** <<SAILoadState, 5.2.16 SAILoadState>>
** <<SAINavSpeed, 5.2.17 SAINavSpeed>>
** <<SAINodeID, 5.2.18 SAINodeID>>
** <<SAINodeType, 5.2.19 SAINodeType>>
** <<SAIParameterList, 5.2.20 SAIParameterList>>
** <<SAIProfileDeclaration, 5.2.21 SAIProfileDeclaration>>
** <<SAIPropertyList, 5.2.22 SAIPropertyList>>
** <<SAIProtoDeclaration, 5.2.23 SAIProtoDeclaration>>
** <<SAIRequesterID, 5.2.24 SAIRequesterID>>
** <<SAIRoute, 5.2.25 SAIRoute>>
** <<SAIScript, 5.2.26 SAIScript>>
** <<SAIScriptImplementation, 5.2.27 SAIScriptImplementation>>
** <<SAIScene, 5.2.28 SAIScene>>
** <<SAIString, 5.2.29 SAIString>>
** <<SAIURL, 5.2.30 SAIURL>>
* <<ErrorDataTypes, 5.3 Error data types>>
** <<SAIError, 5.3.1 SAIError>>
** <<SAIBrowserUnavailable, 5.3.2 SAI_BROWSER_UNAVAILABLE>>
** <<SAIConnectionError, 5.3.3 SAI_CONNECTION_ERROR>>
** <<SAIDisposed, 5.3.4 SAI_DISPOSED>>
** <<SAIImportedNode, 5.3.5 SAI_IMPORTED_NODE>>
** <<SAIInsufficientCapabilities, 5.3.6 SAI_INSUFFICIENT_CAPABILITIES>>
** <<SAIInvalidAccessType, 5.3.7 SAI_INVALID_ACCESS_TYPE>>
** <<SAIInvalidBrowser, 5.3.8 SAI_INVALID_BROWSER>>
** <<SAIInvalidDocument, 5.3.9 SAI_INVALID_DOCUMENT>>
** <<SAIInvalidField, 5.3.10 SAI_INVALID_FIELD>>
** <<SAIInvalidName, 5.3.11 SAI_INVALID_NAME>>
** <<SAIInvalidNode, 5.3.12 SAI_INVALID_NODE>>
** <<SAIInvalidOperationTiming, 5.3.13 SAI_INVALID_OPERATION_TIMING>>
** <<SAIInvalidURL, 5.3.14 SAI_INVALID_URL>>
** <<SAIInvalidX3D, 5.3.15 SAI_INVALID_X3D>>
** <<SAINodeNotAvailable, 5.3.16 SAI_NODE_NOT_AVAILABLE>>
** <<SAINodeNotAvailable, 5.3.17 SAI_NODE_IN_USE>>
** <<SAINotShared, 5.3.18 SAI_NOT_SHARED>>
** <<SAINotSupported, 5.3.19 SAI_NOT_SUPPORTED>>
** <<SAIURLUnavailable, 5.3.20 SAI_URL_UNAVAILABLE>>
* <<EventTypes, 5.4 Event types>>
** <<EventTypesConcepts, 5.4.1 Concepts>>
** <<SAIBrowserEvent, 5.4.2 SAIBrowserEvent>>
** <<SAIBConnectionError, 5.4.3 SAI_B_ConnectionError>>
** <<SAIBInitialized, 5.4.4 SAI_B_Initialized>>
** <<SAIBShutdown, 5.4.5 SAI_B_Shutdown>>
** <<SAIBURLError, 5.4.6 SAI_B_URLError>>
** <<EventTypesSAIFieldEvent, 5.4.7 SAIFieldEvent>>

[[DataTtypeDefinitions]]
=== 5.2 Data type definitions

[[SAIAction]]
==== 5.2.1 SAIAction

The action type is dependent on the method used.
<<SAIActionToJavaImplementationMapping, Table 5.2>> defines the
mapping between each service, the valid action types for that service
and the Java implementation of that action. Actions are mapped as method
names describing the action.

[[t-SAIActionToJavaMapping]]
Table 5.2 — SAIAction to Java implementation mapping

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Service |Action Type     |Java Implementation
|dynamicRouteHandling 
  |Add Route              |`+X3DExecutionContext.addRoute()+`
| |Delete Route           |`+X3DExecutionContext.deleteRoute()+`
|updateControl 
  |Begin Update           |`+ExternalBrowser.beginUpdate()+`
| |End Update             |`+ExternalBrowser.endUpdate()+`
|registerBrowserInterest 
  |Add                    |`+Browser.addBrowserListener()+`
| |Remove                 |`+Browser.removeBrowserListener()+`
|registerFieldInterest 
  |Add                    |`+X3DField.addFieldEventListener()+`
| |Remove                 |`+X3DField.removeFieldEventListener()+`
|shareWorld 
  |share                  |`+ExternalBrowser.shareBrowser()+`
| |unshare                |`+ExternalBrowser.unshareBrowser()+`
|getNode 
  |DEF node               |`+X3DExecutionContext.getNamedNode()+`
| |IMPORT node            |`+X3DExecutionContext.getImportNode()+`
| |EXPORT node            |`+X3DScene.getExportNode()+`
|namedNodeHandling 
  |add/update DEF node    |`+X3DScene.updateNamedNode()+`
| |remove DEF node        |`+X3DScene.removeNamedNode()+`
| |add/update IMPORT node |`+X3DScene.updateExportedNode()+`
| |remove IMPORT node     |`+X3DScene.removeExportedNode()+`
| |add/update EXPORT node |`+X3DScene.updateImportedNode()+`
| |remove EXPORT node     |`+X3DScene.removeImportedNode()+`
|protoDeclarationHandling 
  |add/update Proto       |`+X3DScene.updateProtoNode()+`
| |remove Proto           |`+X3DScene.removeProtoNode()+`
|externprotoDeclarationHandling 
  |add/update ExternProto |`+X3DScene.updateExternProtoNode()+`
| |remove ExternProto     |`+X3DScene.removeExternProtoNode()+`
|rootNodeHandling 
  |add root node          |`+X3DScene.addRootNode()+`
| |remove root node       |`+X3DScene.removeRootNode()+`
|changeViewpoint 
  |next                   |`+Browser.nextViewpoint()+`
| |previous               |`+Browser.previousViewpoint()+`
| |first                  |`+Browser.firstViewpoint()+`
| |last                   |`+Browser.lastViewpoint()+` 
|===

[[SAIBrowserApp]]
==== 5.2.2 SAIBrowserApp

The data type is implemented as the interface `+X3DComponent+`. The
capability to obtain a SAIBrowserRef is implemented in the
`+getBrowser()+` method which returns an instance of the
`+ExternalBrowser+` class.

[[SAIBrowserName]]
==== 5.2.3 SAIBrowserName

The data type is implemented as a `+java.lang.String+`.

[[SAIBrowserRef]]
==== 5.2.4 SAIBrowserRef

The browser reference type is defined to be an instance of the
`+Browser+` interface. This is the base representation used for both
internal and external interaction. For external-only interactions, a
derived interface of the `+Browser+` class is used: `+ExternalBrowser+`.

[[SAIBrowserVersion]]
==== 5.2.5 SAIBrowserVersion

The data type is implemented as a `+java.lang.String+`. The NULL value
is defined as the Java `+null+` primitive type.

[[SAIComponentDeclaration]]
==== 5.2.6 SAIComponentDeclaration

The component declaration is represented by the `+ComponentInfo+` class.
This class presents a read-only view of a component and it's
information.

[[SAIComponentID]]
==== 5.2.7 SAIComponent

The component ID is represented as two separate objects. The name of the
component is defined using `+java.lang.String+` and the level is
represented using the standard Java `+int+` primitive type.

[[SAIExecutionContextID]]
==== 5.2.8 SAIExecutionContext

The execution context is represented by the `+X3DExecutionContext+`
interface.

[[SAIFieldAccess]]
==== 5.2.9 SAIFieldAccess

Field access is driven by the state of the field object. It shall have
two methods to determine if it is readable (`+isReadable()+`) and
Writable (`+isWritable()+`) These methods shall return `+true+` if the
field is readable or writable respectively at the current state in time.
Note that for a given field the return value for a particular SAIFieldID
may change over time dependent on the current state in the life cycle.

[[SAIFieldDefinition]]
==== 5.2.10 SAIFieldDefinition

The field declaration is represented by the class `+X3DFieldDefinition+`
class.

[[SAIFieldID]]
==== 5.2.11 SAIFieldID

The field identifier is represented as an instance of the class
`+X3DField+`. For each specific X3D field type, there shall be a derived
class that represents the field type, and includes strong type checking
for the values. An implementation is not required to return the same
instance of Field for every query, but shall ensure that equivalence
checking is correct through the implementation of the `+equals()+`
method.

[[SAIFieldName]]
==== 5.2.12 SAIFieldName

The name of the field is implemented as a `+java.lang.String+`.

[[SAIFieldType]]
==== 5.2.13 SAIFieldType

The field type may be represented in two alternative fashions.

The first alternative is provided through `+getType()+` method provided
in the `+X3DField+` class. This returns an int which has one of the
values defined by the constant types also defined in that class as shown
in <<t-MappingOfX3DFieldTypeToJava, Table 5.3>>. Constant int values
are provided and all implementations shall use these values. This will
ensure that classes compiled with one set of implementation classes will
run with all browsers as the compiler will inline these constants. The
end user is strongly advised not to use the direct numerical values, and
use only the types definitions. The types are defined in the
`+X3DFieldTypes+` interface. If a component defines new field types then
the numerical values assigned shall not override the values already
defined.

[[t-MappingOfX3DFieldTypeToJava]]
Table 5.3 — Mapping of X3D Field type to Java representation

[opts="header,autowidth",frame=ends,grid=rows]
|===
|X3D Field type |Java representation                |Value
|SFBool         |`+static final int SFBool+`        |1
|MFBool         |`+static final int MFBool+`        |2
|MFColor        |`+static final int MFColor+`       |25
|SFColor        |`+static final int SFColor+`       |26
|MFColorRGBA    |`+static final int MFColorRGBA+`   |27
|SFColorRGBA    |`+static final int SFColorRGBA+`   |28
|SFDouble       |`+static final int SFDouble+`      |9
|MFDouble       |`+static final int MFDouble+`      |10
|SFFloat        |`+static final int SFFloat+`       |7
|MFFloat        |`+static final int MFFloat+`       |8
|SFImage        |`+static final int SFImage+`       |29
|MFImage        |`+static final int MFImage+`       |30
|SFInt32        |`+static final int SFInt32+`       |4
|MFInt32        |`+static final int MFInt32+`       |3
|SFLong         |`+static final int SFLong+`        |5
|MFLong         |`+static final int MFLong+`        |6
|SFNode         |`+static final int SFNode+`        |13
|MFNode         |`+static final int MFNode+`        |14
|SFRotation     |`+static final int SFRotation+`    |24
|MFRotation     |`+static final int MFRotation+`    |23
|SFString       |`+static final int SFString+`      |31
|MFString       |`+static final int MFString+`      |32
|SFTime         |`+static final int SFTime+`        |11
|MFTime         |`+static final int MFTime+`        |12
|SFVec2f        |`+static final int SFVec2f+`       |15
|MFVec2f        |`+static final int MFVec2f+`       |16
|SFVec2d        |`+static final int SFVec2d+`       |17
|MFVec2d        |`+static final int MFVec2d+`       |18
|SFVec3f        |`+static final int SFVec3f+`       |19
|MFVec3f        |`+static final int MFVec3f+`       |20
|SFVec3d        |`+static final int SFVec3d+`       |21
|MFVec3d        |`+static final int MFVec3d+`       |22
|===

The second alternative is provided by the class hierarchy. The
`+X3DField+` class is derived to provide implementations of the exact
field type. These classes are defined in the same package
(`+org.web3d.x3d.sai+`) package.

[[SAIFieldValue]]
==== 5.2.14 SAIFieldValue

The field value is defined on a per class and per field type instance.
See the definitions of the individual field type classes for the exact
definition of each type. As a general rule, the X3D data type maps the
the equivalent Java primitive type using the mapping in
<<MappingOfX3DDataTypesToJava, Table 5.4>>

[[t-MappingOfX3DDataTypesToJava]]
Table 5.4 — Mapping of X3D data
types to Java primitive data types

[opts="header,autowidth",frame=ends,grid=rows]
|===
|X3D Field Type                 |Java Primitive Type
|Bool                           |boolean
|Int32                          |int
|Long                           |long
|Float, Vec2f, Vec3f, Rotation  |float
|Double, Vec2d, Vec3d           |double
|Color                          |float
|String                         |String
|Time                           |double
|Image                          |int
|===

[[SAIFrameRate]]
==== 5.2.15 SAIFrameRate

The data type is implemented as the Java primitive type `+float+`. A
null value is defined as the value `+0.0f+`.

[[SAILoadState]]
==== 5.2.16 SAILoadState

The load state is implemented as an integer primitive value. The values
for each state are defined in <<t-LoadStateTypeValueDefintions, Table 5.5>>.
The definitions of the values can be found in the
`+X3DLoadStateTypes+` interface.

[[t-LoadStateTypeValueDefintions]]
Table 5.5 — Load state type value
defintions

[opts="header,autowidth",frame=ends,grid=rows]
|===
|State       |Java Constant                         |Value
|NOT_STARTED |`+static final int LOAD_NOT_STARTED+` |1
|IN_PROGRESS |`+static final int LOAD_IN_PROGRESS+` |2
|COMPLETE    |`+static final int LOAD_COMPLETE+`    |3
|FAILED      |`+static final int LOAD_FAILED+`      |4
|===

It is strongly recommended that the end user does not use the direct int
values. They should be using the defined constant types.

[[SAINavSpeed]]
==== 5.2.17 SAINavSpeed

The data type is implemented as the Java primitive type `+float+`. A
null value is defined as the value `+0.0f+`.

[[SAINodeID]]
==== 5.2.18 SAINodeID

The node identifier is represented as an instance of `+X3DNode+`.

[[SAINodeType]]
==== 5.2.19 SAINodeType

The node type is represented as a `+java.lang.String+`.

[[SAIParameterList]]
==== 5.2.20 SAIParameterList

The data type is represented by the values in the
<<t-MappingSAIParameterListToJava, Table 5.6>>. The table defines the
services that use the data type, the method of the BrowserFactory class
and the lists of argument types that method takes.

[[t-MappingSAIParameterListToJava]]
Table 5.6 — Mapping of
SAIParameterList to Java parameter lists

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Service    |method           |Java Parameters
|getBrowser |`+getBrowser()+` |`+java.applet.Applet+`
|           |`+getBrowser()+` |`+java.applet.Applet, String, int+`
|           |`+getBrowser()+` |`+java.net.InetAddress, int+`
|createBrowser |`+createVrmlComponent()+` |None
|===

[[SAIProfileDeclaration]]
==== 5.2.21 SAIProfileDeclaration

The component declaration is represented by the `+ProfileInfo+` class.
This class presents a read-only view of a profile and it's information.

[[SAIPropertyList]]
==== 5.2.22 SAIPropertyList

The data type is implemented as an array of `+java.lang.String+`.
Key/Value pairs are represented using the `+java.util.Map+` abstract
data structure.

[[SAIProtoDeclaration]]
==== 5.2.23 SAIProtoDeclaration

The proto declaration is represented by two separate interfaces - one
each for PROTO and EXTERNPROTOs. For PROTOs, the interface is
`+X3DProtoDeclaration+`. For EXTERNPROTOs the interface is
`+X3DExternProtoDeclaration+`.

[[SAIRequesterID]]
==== 5.2.24 SAIRequesterID

The requestor ID is represented as an instance of one of two classes
depending on what information is being requested.

The requestor ID is an instance of the class implementing the interface
`+BrowserListener+` when the service request is registerBrowserInterest
as specified in 6.3.20, registerBrowserInterest of ISO/IEC 19775-2 (see
<<I19775, 2.[I19775>>]).

The requestor ID is an instance of the class implementing the interface
`+X3DEventListener+` when the service request is registerFieldInterest
as specified in 6.7.7 registerFieldInterest of ISO/IEC 19775-2 (see
<<I19775, 2.[I19775>>]).

[[SAIRoute]]
==== 5.2.25 SAIRoute

Routes are represented by the immutable data interface
`+org.web3d.x3d.sai.X3DRoute+`. This allows fetching of all the route
information, but it may not be changed. Browser's shall not expose to
the end user extended versions of this class that allow direct
modification of the route.

[[SAIScript]]
==== 5.2.26 SAIScript

This is the external, containing node representation of the script that
is passed to the script implementation class during the initialisation
phase. It shall be represented by the abstract interface type
`+X3DScriptNode+`. This represents the abstract node type as there may
be more than one script node type.

[[SAIScriptImplementation]]
==== 5.2.27 SAIScriptImplementation

The script implementation is marked by the interface
`+X3DScriptImplementation+`. This marker interface must be present on
the user class that is defined in the URL of the Script node. If it is
not present, an error shall be generated, the URL ignored and the next
URL in the list loaded.

[[SAIScene]]
==== 5.2.28 SAIScene

The scene is represented by the interface `+X3DScene+` that extends the
`+X3DExecutionContext+` interface. The scene interface holds all the
methods that represent the Scene Services. A full definition of the
interface and all its methods is in <<SceneServices, 6.5 Scene Services>>.

[[SAIString]]
==== 5.2.29 SAIString

The string is implemented as a `+java.lang.String+`.

[[SAIURL]]
==== 5.2.30 SAIURL

The URL is implemented as a `+java.lang.String+`.

[[ErrorDataTypes]]
=== 5.3 Error data types

[[SAIError]]
==== 5.3.1 SAIError

Java implementations of the errors rely on a set of derived classes
based on the SAIError type.

The error type is implemented as the exception class `+X3DException+`.
This exception is in turn derived from the standard Java error type of
`+java.lang.RuntimeException+`. All exceptions (errors) defined in this
specification shall be derived from `+X3DException+`.

[[SAIBrowserUnavailable]]
==== 5.3.2 SAI_BROWSER_UNAVAILABLE

The error type is implemented as the exception class
`+NoSuchBrowserException+`.

[[SAIConnectionError]]
==== 5.3.3 SAI_CONNECTION_ERROR

The error type is implemented as the exception class
`+ConnectionException+`.

[[SAIDisposed]]
==== 5.3.4 SAI_DISPOSED

The error type is implemented as two separate dual purpose exception
classes depending on their scope.

`+InvalidBrowserException+` is used to indicate that an
<<SAIBrowserRef, SAIBrowserRef>> has been disposed.

`+InvalidExecutionContextException+` is used to indicate that an
<<SAIExecutionContextID, SAIExecutionContextID>> has been disposed.

`+InvalidNodeException+` is used to indicate that an
<<SAINodeID, SAINodeID>> has been disposed.

`+InvalidRouteException+` is used to indicate that an
<<SAIRouteID, SAIRouteID>> has been disposed.

`+InvalidProtoException+` is used to indicate that an
<<SAIProtoDeclaration, SAIProtoDeclaration>> has been disposed.

[[SAIImportedNode]]
==== 5.3.5 SAI_IMPORTED_NODE

The error type is implemented as the exception class
`+InvalidImportException+`.

[[SAIInsufficientCapabilities]]
==== 5.3.6 SAI_INSUFFICIENT_CAPABILITIES

The error type is implemented as the exception class
`+InsufficientCapabilitiesException+`.

[[SAIInvalidAccessType]]
==== 5.3.7 SAI_INVALID_ACCESS_TYPE

The error type is implemented as two separate exceptions based on the
implementation of <<SAINodeID, SAINodeID>> and the rules defined in
<<t-SAIActionToJavaMapping, Table 5.2>>. These classes also derive
from `+InvalidFieldException+`.

`+InvalidWritableFieldException+` is used to indicate the named field is
not accessible as a writable field when attempting to create a route
with the `+X3DScene.addRoute()+` method.

`+InvalidReadableFieldException+` is used to indicate the named field is
not accessible as a readable field when attempting to create a route
with the `+X3DScene.addRoute()+` method.

[[SAIInvalidBrowser]]
==== 5.3.8 SAI_INVALID_BROWSER

The error type is implemented as the exception class
`+InvalidBrowserException+`.

[[SAIInvalidDocument]]
==== 5.3.9 SAI_INVALID_DOCUMENT

The error type is implemented as the exception class
`+InvalidDocumentException+`.

[[SAIInvalidField]]
==== 5.3.10 SAI_INVALID_FIELD

The error type is implemented as the exception class
`+InvalidFieldException+`. Note that there are two derived classes from
this class (`+InvalidWritableFieldException+` and
`+InvalidReadableFieldException)+` that may be used at times where this
error may be generated.

[[SAIInvalidName]]
==== 5.3.11 SAI_INVALID_NAME

The error type is expressed as different exceptions dependent on the
situation. The `+X3DExecutionContext.getNamedNode()+`,
`+X3DScene.getExportedNode()+` and
`+X3DExecutionContext.getImportedNode()+` methods use the
`+InvalidNodeException+`. When accessing fields of a node, the error is
expressed as an `+InvalidFieldException+`.

[[SAIInvalidNode]]
==== 5.3.12 SAI_INVALID_NODE

The error type is implemented as the exception class
`+InvalidNodeException.+`

[[SAIInvalidOperationTiming]]
==== 5.3.13 SAI_INVALID_OPERATION_TIMING

The error type is implemented as the exception class
`+InvalidOperationTimingException+`.

[[SAIInvalidURL]]
==== 5.3.14 SAI_INVALID_URL

The error type is implemented as the exception class
`+InvalidURLException+`.

[[SAIInvalidX3D]]
==== 5.3.15 SAI_INVALID_X3D

The error type is implemented as the exception class
`+InvalidX3DException+`.

[[SAINodeNotAvailable]]
==== 5.3.16 SAI_NODE_NOT_AVAILABLE

The error type is implemented as the exception class
`+NodeUnavailableException+`.

[[SAINodeInUse]]
==== 5.3.17 SAI_NODE_IN_USE

The error type is implemented as the exception class
`+NodeInUseException+`.

[[SAINotShared]]
==== 5.3.18 SAI_NOT_SHARED

The error type is implemented as the exception class
`+BrowserNotSharedException+`.

[[SAINotSupported]]
==== 5.3.19 SAI_NOT_SUPPORTED

The error type is implemented as the exception class
`+NotSupportedException+`.

[[SAIURLUnavailable]]
==== 5.3.20 SAI_URL_UNAVAILABLE

The error type is implemented as the exception class
`+URLUnavailableException+`.

[[EventTypes]]
=== 5.4 Event types

[[EventTypesConcepts]]
==== 5.4.1 Concepts

The Java implementation of the event handling and types is based around
the Java AWT event listener model. A single event class is used to
encapsulate the type of event and then parameters defining the actual
event item that occurred.

All event classes are derived from `+java.util.EventObject+`. The
`+getSource()+` method of that class is employed to return the source
that generated the event. When the event comes from a field, the return
value of `+getSource()+` may be cast to `+X3DField+` or one of its
derived types. If the event come from the browser, the source may be
cast to `+Browser+` or `+ExternalBrowser+`.

[[SAIBrowserEvent]]
==== 5.4.2 SAIBrowserEvent

The event type is implemented in the class `+BrowserEvent+`. Each of the
individual events are expressed as actions that the event then passes to
the registered listeners. The action type of the individual event is
available through the `+getID()+` method.

[[SAIBConnectionError]]
==== 5.4.3 SAI_BROWSER_ConnectionError

The event type is implemented as the `+CONNECTION_ERROR+` value for the
browser event ID.

[[SAIBInitialized]]
==== 5.4.4 SAI_BROWSER_Initialized

The event type is implemented as the `+INITIALIZED+` value for the
browser event ID.

[[SAIBShutdown]]
==== 5.4.5 SAI_BROWSER_Shutdown

The event type is implemented as the `+SHUTDOWN+` value for the browser
event ID.

[[SAIBURLError]]
==== 5.4.6 SAI_BROWSER_URLError

The event type is implemented as the `+URL_ERROR+` value for the browser
event ID.

[[EventTypesSAIFieldEvent]]
==== 5.4.7 SAIFieldEvent

The event type is implemented as the class `+X3DFieldEvent+`. This class
contains methods for obtaining the source of the event, the time (in X3D
time) and any user defined data that occurred with the event.

[[functions]]
== 6 Function definitions

[[IntroductionAndTopics]]
=== 6.1 Introduction and topics

[[Introduction]]
==== 6.1.1 Introduction

This clause describes key concepts in this part of ISO/IEC 19777. This
includes conformance criteria and abstract concepts of the binding
specified in this part of ISO/IEC 19777 to the abstract definitions
specified in ISO/IEC 19775-2 (see <<I19775, 2.[19775>>]).

[[Topics]]
==== 6.1.2 Topics

See <<t-Topics, Table 6.1>> for the table of contents for this clause.

[[t-Topics]]
Table 6.1 — Topics in this clause

* <<IntroductionAndTopics, 6.1 Introduction and Topics>>
** <<Introduction, 6.1.1 Introduction>>
** <<Topics, 6.1.2 Topics>>
* <<BrowserServicesAndConnections, 6.2 Browser services and connections>>
** <<BrowserFactory, 6.2.1 BrowserFactory>>
** <<getBrowser, 6.2.2 getBrowser>>
*** <<WebPluginBrowser, 6.2.2.1 Web plug-in browser>>
*** <<RemoteBrowser, 6.2.2.2 Remote browser>>
** <<CreateBrowser, 6.2.3 createBrowser>>
* <<BrowserServices, 6.3 Browser services>>
** <<getName, 6.3.1 getName>>
** <<getVersion, 6.3.2 getVersion>>
** <<getCirremtSpeed, 6.3.3 getCurrentSpeed>>
** <<getCurrentFrameRate, 6.3.4 getCurrentFrameRate>>
** <<getSupportedProfiles, 6.3.5 getSupportedProfiles>>
** <<ExecutionContextGetProfile, 6.3.6 getProfile>>
** <<getSupportedComponents, 6.3.7 getSupportedComponents>>
** <<getComponent, 6.3.8 getComponent>>
** <<getExecutionContext, 6.3.9 getExecutionContext>>
** <<createScene, 6.3.10 createScene>>
** <<replaceWorld, 6.3.11 replaceWorld>>
** <<importDocument, 6.3.12 importDocument>>
** <<loadURL, 6.3.13 loadURL>>
** <<setDescription, 6.3.14 setDescription>>
** <<createX3DFromString, 6.3.15 createX3DFromString>>
** <<createX3DFromStream, 6.3.16 createX3DFromStream>>
** <<createX3DFromURL, 6.3.17 createX3DFromURL>>
** <<UpdateControl, 6.3.18 updateControl>>
** <<RegisterBrowserInterest, 6.3.19 registerBrowserInterest>>
** <<getRenderingProperties, 6.3.20 getRenderingProperties>>
** <<getBrowserProperties, 6.3.21 getBrowserProperties>>
** <<changeViewpoint, 6.3.22 changeViewpoint>>
** <<print, 6.3.23 print>>
** <<Dispose, 6.3.24 dispose>>
* <<ExecutionContextServices, 6.4 Execution context services>>
** <<getSpecificationVersion, 6.4.1 getSpecificationVersion>>
** <<getEncoding, 6.4.2 getEncoding>>
** <<ExecutionContextGetProfile, 6.4.3 getProfile>>
** <<getComponents, 6.4.4 getComponents>>
** <<getWorldURL, 6.4.5 getWorldURL>>
** <<getNode, 6.4.6 getNode>>
** <<createProto, 6.4.7 createNode>>
** <<createProto, 6.4.8 createProto>>
** <<NamedNodeHandling, 6.4.9 namedNodeHandling>>
** <<getProtoDeclaration, 6.4.10 getProtoDeclaration>>
** <<ProtoDeclarationHandling, 6.4.11 protoDeclarationHandling>>
** <<getExternProtoDeclaration, 6.4.12 getExternprotoDeclaration>>
** <<ExternProtoDeclarationHandling, 6.4.13 externprotoDeclarationHandling>>
** <<getRootNodes, 6.4.14 getRootNodes>>
** <<getRoutes, 6.4.15 getRoutes>>
** <<DynamicRouteHandling, 6.4.16 dynamicRouteHandling>>
* <<SceneServices, 6.5 Scene services>>
** <<SceneGeneralConcepts, 6.5.1 General concepts>>
** <<getMetaData, 6.5.2 getMetadata>>
** <<setMetaData, 6.5.3 setMetadata>>
** <<SceneGetNode, 6.5.4 getNode>>
** <<SceneNamedNodeHandling, 6.5.5 namedNodeHandling>>
** <<SceneRootNodeHandling, 6.5.6 rootNodeHandling>>
* <<NodeServices, 6.6 Node services>>
** <<NodeRepresentation, 6.6.1 Node representation>>
** <<NodeGetTypeName, 6.6.2 getTypeName>>
** <<NodeGetType, 6.6.3 getType>>
** <<getField, 6.6.4 getField>>
** <<getFieldDefinitions, 6.6.5 getFieldDefinitions>>
** <<NodeDispose, 6.6.6 dispose>>
* <<FieldServices, 6.7 Field services>>
** <<FieldRepresentation, 6.7.1 Field representation>>
** <<getAccessType, 6.7.2 getAccessType>>
** <<getType, 6.7.3 getType>>
** <<FieldGetName, 6.7.4 getName>>
** <<getValue, 6.7.5 getValue>>
** <<setValue, 6.7.6 setValue>>
** <<RegisterFieldInterest, 6.7.7 registerFieldInterest>>
** <<FieldDispose, 6.7.8 dispose>>
* <<RouteServices, 6.8 Route services>>
** <<RouteRepresentation, 6.8.1 Route representation>>
** <<getSourceNode, 6.8.2 getSourceNode>>
** <<getSourceField, 6.8.3 getSourceField>>
** <<getDestinationNode, 6.8.4 getDestinationNode>>
** <<getDestinationField, 6.8.5 getDestinationField>>
** <<RouteDispose, 6.8.6 dispose>>
* <<PrototypeServices, 6.9 Prototype services>>
** <<isExternProto, 6.9.1 isExternproto>>
** <<createInstance, 6.9.2 createInstance>>
** <<ProtoGetFieldDefinitions, 6.9.3 getFieldDefinitions>>
** <<checkLoadState, 6.9.4 checkLoadState>>
** <<RequestImmediateLoad, 6.9.5 requestImmediateLoad>>
** <<ProtoDispose, 6.9.6 dispose>>
* <<SCriptContentServices, 6.10 Script content services>>
** <<ImplementationMarkerInterface, 6.10.1 implementationMarkerInterface>>
** <<PrepareEventsNotification, 6.10.2 prepareEvents notification>>
* <<MatrixServices, 6.11 Matrix services>>
** <<MatrixDescription, 6.11.1 Description>>
** <<Matrix3, 6.11.2 Matrix3>>
** <<Matrix4, 6.11.3 Matrix4>>

[[BrowserServicesAndConnections]]
=== 6.2 Browser services and connections

[[BrowserFactory]]
==== 6.2.1 BrowserFactory

The following scenarios are possible when creating a reference to an X3D
browser:

[loweralpha]
. Java applet to X3D plug-in in a web browser,
. server application talking to a browser on a separate machine, or
. a component in a standalone Java application.

Each of these requires a separate solution in order to maintain
implementation dependence.

The method of access to an X3D browser shall be through a single factory
style class. This class contains methods for each type of access. To
provide implementation independence, the `+BrowserFactoryImpl+`
interface for the implementation dependent parts is defined. Browsers
shall subclass this interface to provide the necessary dependent code.
This interface is loaded by the X3D browser factory using dynamic
methods or by having the code explicitly set.

A properties file called `+x3d.properties+`, if resident in the user's
`+CLASSPATH,+` shall be used to determine the name of the class to be
loaded. The name of the property in the properties file shall be:

`+org.web3d.x3d.sai.factory.class+`

which shall be set to the fully qualified name of the browser factory
class implementation to be loaded. The implementation of this class
shall not reside within the `+org.web3d.*+` class hierarchy but shall
reside in the browser writer's own class hierarchy. The browser factory
shall also contain a `+setBrowserFactoryImpl()+` method to allow an
explicit setting of the factory implementation. If this method is the
first method called of all the factory methods, it shall be used as the
factory implementation. If any other method is called prior to calling
this method, the name of the factory implementation shall be drawn from
the properties file and loaded. Any attempt to call the set
implementation method shall result in a `+X3DException+` being
generated.

The factory implementation shall return the appropriate subclasses for
each of the methods. If the implementation does not support the
particular connection requested, it shall generate a
`+NotSupportedException+`. If it is supported, it shall return the
appropriate subclass of the object for that method.

[[getBrowser]]
==== 6.2.2 getBrowser

[[WebPluginBrowser]]
===== 6.2.2.1 Web plug-in browser

[source,listing]
----
ExternalBrowser BrowserFactory.getBrowser(Applet)
    throws NotSupportedException,
           NoSuchBrowserException,
           ConnectionException

ExternalBrowser BrowserFactory.getBrowser(Applet, String, int)
    throws NotSupportedException,
           NoSuchBrowserException,
           ConnectionException
----

A browser that operates as part of a web browser requires a number of
different parameters for correct determination of the plug-in to access.
Due to the nature of web pages, it is possible that an applet on one
page may access either more that one X3D plug-in or that the plug-in
exists in another HTML frame. The applet form of the `+ getBrowser()+`
method requires a reference to the accessing applet, the name of the
frame and the index of the frame in the nominated frame. The frame name
is a string representing the name of the frame. The index is the number
of the X3D browser in the page (where there might be more than one)
starting from 0.

[[RemoteBrowser]]
===== 6.2.2.2 Remote browser

[source,listing]
----
ExternalBrowser BrowserFactory.getBrowser(java.net.InetAddress, int)
    throws NotSupportedException,
           NoSuchBrowserException,
           java.net.UnknownHostException,
           ConnectionException
----

An application server may wish to access browsers on client machines.
The third variant of the getBrowser request requires an IP address (or
machine name) and a port number. The server application requests the
browser reference of the remote machine. Once the browser reference is
returned, the server application may manipulate the browser contents
like any other SAI using application.

The port number of the protocol may be any port number. There is no
defined default port to which a browser will listen. The protocol
between the application and the browser is also not defined.

[[CreateBrowser]]
==== 6.2.3 createBrowser

[source,listing]
----
X3DComponent BrowserFactory.createX3DComponent(java.util.Map)
    throws NotSupportedException
----

The component browser is required to fit into the standard
`+java.awt.Component+` model and is implemented as a subclass of
`+X3DComponent+`. It shall derive from `+java.awt.Component+` and also
provide a `+getBrowser()+` method that returns a reference to a standard
`+Browser+` object. The component implementation may implement the
component in any manner it requires. Both lightweight components (all
rendering performed in Java) and heavyweight components (with peer
interfaces extending from `+java.awt.peer.ComponentPeer+`) are
permitted. These details shall be hidden within the implementation
specific classes and not accessible to the general API user.

The factory class shall include a method that generates an instance of
this component class. Each call to the component shall result in a new
independent instance of a X3D browser capable of running as a component.
The browser shall be capable of running either within a web browser
environment (e.g., Java applet window with a X3D browser in it) or in
standalone applications with the restrictions appropriate to the
underlying environment. It shall also use whatever hints are supported
in the parameter argument passed to it. These hints are in the same form
as those passed to loadURL.

[[BrowserServices]]
=== 6.3 Browser services

[[getName]]
==== 6.3.1 getName

[source,listing]
----
String Browser.getName()
    throws InvalidBrowserException
----

The name returned is a String representing the name of the browser. If
this is not supported, `+null+` shall be returned.

[[getVersion]]
==== 6.3.2 getVersion

[source,listing]
----
String Browser.getVersion()
    throws InvalidBrowserException
----

The version returned is a String representing the version number of the
browser. If this is not supported, `+null+` shall be returned.

[[getCirremtSpeed]]
==== 6.3.3 getCurrentSpeed

[source,listing]
----
float Browser.getCurrentSpeed()
    throws InvalidBrowserException
----

The speed value returned shall be a floating point number. A value of
0.0 shall be returned if currentSpeed is not supported.

[[getCurrentFrameRate]]
==== 6.3.4 getCurrentFrameRate

[source,listing]
----
float Browser.getCurrentFrameRate()
    throws InvalidBrowserException
----

The frame rate value shall be a floating point number. A value of 0.0
shall be returned if currentFrameRate is not supported.

[[getSupportedProfiles]]
==== 6.3.5 getSupportedProfiles

[source,listing]
----
ProfileInfo[] Browser.getSupportedProfiles()
    throws InvalidBrowserException
----

The returned array will always contain at least one item and will be
exactly the number of profiles that this browser supports.

[[getProfile]]
=== 6.3.6 getProfile

[source,listing]
----
ProfileInfo Browser.getProfile(String)
    throws InvalidBrowserException,
           NotSupportedException
----

The profile declaration that corresponds to the named profile is
returned if the browser supports that profile. If the browser does not
support the profile, the `+NotSupportedException +`shall be thrown.

[[getSupportedComponents]]
==== 6.3.7 getSupportedComponents

[source,listing]
----
ComponentInfo[] Browser.getSupportedComponents()
    throws InvalidBrowserException
----

A list of the component declarations for all components that are
supported is returned with their respective support levels.

[[getComponent]]
==== 6.3.8 getComponent

[source,listing]
----
ComponentInfo Browser.getComponent(String, int)
    throws InvalidBrowserException,
           NotSupportedException
----

The component declaration that corresponds to the named component and
level is returned if the browser supports that capability. If the
browser does not support the named component and the requested level,
the `+NotSupportedException+` shall be thrown.

[[getExecutionContext]]
==== 6.3.9 getExecutionContext

[source,listing]
----
X3DExecutionContext Browser.getExecutionContext()
    throws InvalidBrowserException,
           InvalidOperationTimingException
----

If the execution context is the full scene rather than inside a PROTO
instance, the `+X3DExecutionContext+` instance returned will be an
instance of the derived `+X3DScene+` interface. User code may test for
this using the `+instanceof+` operator.

[[createScene]]
==== 6.3.10 createScene

[source,listing]
----
X3DScene Browser.createScene(ProfileInfo, ComponentInfo[])
    throws InvalidBrowserException,
           InvalidOperationTimingException
----

A new, empty scene is created that represents the given profile and
component collection. The profile shall always be specified and, if no
supplementary components are desired, the second parameter shall be
`+null+`.

[[replaceWorld]]
===== 6.3.11 replaceWorld

[source,listing]
----
void Browser.replaceWorld(X3DScene)
    throws InvalidBrowserException,
           InvalidOperationTimingException
----

The world is replaced with the new scene. If the parameter is `+null,+`
the existing scene is cleared and the browser is left with no scene and
no activity; nothing shall be rendered.

[[importDocument]]
===== 6.3.12 importDocument

[source,listing]
----
X3DScene Browser.importDocument(org.w3c.dom.Node)
    throws InvalidBrowserException,
           InvalidOperationTimingException,
           InvalidDocumentException
----

A document described by the standard DOM classes is converted to an X3D
scene.

[[loadURL]]
==== 6.3.13 loadURL

[source,listing]
----
void Browser.loadURL(String[], java.util.Map)
    throws InvalidBrowserException,
           InvalidOperationTimingException,
           InvalidURLException
----

The parameters shall be an array of strings for the URL list and an
array of Strings for the parameters. If the browser determines that it
cannot load any of the URLs passed, the browser event listener shall
receive an event notifying it of an error.

If the parameters list is a zero length array or is `+null+`, the action
is to replace the world in the current browser. The properties defined
in <<t-PropertyListForLoadURL, Table 6.2>> are standard values that
shall be supported in addition to the other required values (see ISO/IEC
19775-1 9.2.4 Browser Options).

[[t-PropertyListForLoadURL]]
Table 6.2 — Property list for loadURL

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Key |Value |Description of Function

|replace |true |Replaces the entire page that browser is embedded in. If
the browser is a standalone browser this shall have no effect.

| |false |The browser shall replace the contents of the currently loaded
world with the new world specified by the URL argument. The same effect
as providing no value to the parameters argument.

|target |_`+<frameName>+`_ |The name of the frame shall be used to load
the browser as the contents of the named HTML frame.
|===

Individual browser implementations may support extra property
definitions.

[[setDescription]]
==== 6.3.14 setDescription

[source,listing]
----
void Browser.setDescription(String)
    throws InvalidBrowserException,
           InvalidOperationTimingException,
----

This service sets the description string of the browser. If the browser
is running as a plug-in, this shall set the title of the page (if the
containing web browser supports this). For component browsers the result
shall be implementation dependent.

[[createX3DFromString]]
==== 6.3.15 createX3DFromString

[source,listing]
----
X3DScene Browser.createX3DFromString(String)
    throws InvalidBrowserException,
           InvalidX3DException,
           InvalidOperationTimingException,
           NotSupportedException
----

An X3DScene instance corresponding to the given string is returned. The
parameter shall be a string that contains legal syntax as defined in
this specification. The string may be any one of the formal encodings
defined by this specification.

The header statement need not be present as the first line in the
string. If the string does not contain legal X3D syntax, an
`+InvalidX3DException+` shall be generated. If the encoding of the given
string is not supported, the `+ NotSupportedException+` shall be
generated.

[[createX3DFromStream]]
==== 6.3.16 createX3DFromStream

[source,listing]
----
X3DScene Browser.createX3DFromStream(java.io.InputStream)
    throws InvalidBrowserException,
           InvalidX3DException,
           InvalidOperationTimingException,
           NotSupportedException,
           java.io.IOException
----

An X3DScene instance corresponding to the given stream is returned. The
parameter shall be an already established stream that contains legal
syntax as defined in this specification. The string may be any one of
the formal encodings defined by this specification.

The header statement need not be present as the first line in the
stream. If the stream does not contain legal X3D syntax, an
`+InvalidX3DException+` shall be generated. If the encoding of the given
stream is not supported, the `+ NotSupportedException+` shall be
generated.

[[createX3DFromURL]]
==== 6.3.17 createX3DFromURL

[source,listing]
----
X3DScene Browser.createX3DFromURL(String[])
    throws InvalidBrowserException,
           InvalidX3DException,
           InvalidOperationTimingException,
           NotSupportedException,
           java.io.IOException
----

The parameter list shall consist of an array of Strings describing the
list of URLs. If the browser determines that it cannot load any of the
URLs passed, the browser event listener shall receive an event notifying
it of an error and the return value shall be `+null+`.

The header statement need not be present as the first line in the
content identified by the URL. If the content identified by the URL does
not contain legal X3D syntax, an `+InvalidX3DException+` shall be
generated. If the encoding of the given content is not supported, the
`+ NotSupportedException+` shall be generated.

[[UpdateControl]]
==== 6.3.18 updateControl

[source,listing]
----
void ExternalBrowser.beginUpdate()
    throws InvalidBrowserException

void ExternalBrowser.endUpdate()
    throws InvalidBrowserException
----

This service is split into two separate methods beginUpdate and
endUpdate. The functionality is as described in 6.3.19, Update Control
of ISO/IEC 19775-2 (see <<I19775, 2.[I19775>>]).

[[RegisterBrowserInterest]]
==== 6.3.19 registerBrowserInterest

[source,listing]
----
void Browser.addBrowserListener(BrowserListener)
    throws InvalidBrowserException

void Browser.removeBrowserListener(BrowserListener)
    throws InvalidBrowserException
----

Registering interest in browser events is through a browser event
listener. The listener is an interface which is passed browser events
when the state of the browser changes or asynchronous error messages is
sent (for example, inability to load any of the requested URLs). Methods
shall be provided to allow listeners to be added and removed
dynamically. A separate event class shall be used to indicate the event
information. This class has a predefined number of events although
specific browser implementations may send more events than the defined
values. The toString() method shall be overridden in this case to
provide more information to the user in determining the extra event
types to deal with them. Any extra event types shall not have values
below the figure defined by `+LAST_IDENTIFIER+`.

The signature for `+BrowserListener+` shall be:

[source,listing]
----
public interface BrowserListener extends java.util.EventListener
public void BrowserListener.browserChanged(BrowserEvent evt)
----

The signature for `+BrowserEvent+` shall be:

[source,listing]
----
public class BrowserEvent extends java.util.EventObject
public int BrowserEvent.getID()
----

The Browser object that generated the event shall be the return value of
the `+getSource()+` method of the base `+java.util.EventObject+`
interface.

[[getRenderingProperties]]
==== 6.3.20 getRenderingProperties

[source,listing]
----
java.util.Map Browser.getRenderingProperties()
    throws InvalidBrowserException,
           InvalidOperationTimingException
----

The map will contain key/value pairs for all the available rendering
properties that may be set. A table of the standard properties is
defined in Table 9.2 Browser properties of ISO/IEC 19775-1 (see
<<I19775, 2.[I19775>>]). All keys shall be `+java.lang.String+`
instances that name the property. Values may be of the Java class
wrapper type representing the primitive value. For example, numerical
values will be returned as instances of `+java.lang.Number+`.

If the property does not exist in the table, it shall be interpreted as
not being supported by the browser implementation.

The map shall be immutable. It shall be an error for the user to attempt
to insert or change the existing properties.

[[getBrowserProperties]]
==== 6.3.21 getBrowserProperties

[source,listing]
----
java.util.Map Browser.getBrowserProperties()
    throws InvalidBrowserException,
           InvalidOperationTimingException
----

The map will contain key/value pairs for all the available rendering
properties that may be set. A table of the standard properties is
defined in Table 9.2 Browser properties of ISO/IEC 19775-1 (see
<<I19775, 2.[I19775>>]). All keys shall be `+java.lang.String+`
instances that name the property. Values may be of the Java class
wrapper type representing the primitive value. For example, numerical
values will be returned as instances of `+java.lang.Number+`.

Where the properties represents the extensions of the browser interface
available, the key shall be the SAI extension name, and the value will
be a `+java.lang.Boolean+` representing true or false values. If the
browser supports the extended interface, there shall be an entry with a
true value. If an entry has a false value, or there is no entry at all
for the named extension, then that shall be treated as the browser not
supporting that extension.

The map shall be immutable. It shall be an error for the user to attempt
to insert or change the existing properties.

[[changeViewpoint]]
==== 6.3.22 changeViewpoint

[source,listing]
----
void Browser.nextViewpoint()
    throws InvalidBrowserException

void Browser.previousViewpoint()
    throws InvalidBrowserException

void Browser.firstViewpoint()
    throws InvalidBrowserException

void Browser.lastViewpoint()
    throws InvalidBrowserException
----

Change the viewpoint to the position given. All details are in
accordance with the actions defined for this service request.

[[print]]
==== 6.3.23 print

[source,listing]
----
void Browser.print(Object)
    throws InvalidBrowserException

void Browser.println(Object)
    throws InvalidBrowserException
----

Print information directly to the console of the browser. The browser
has the option of redirecting the `+System.out+` and `+System.err+`
InputStreams to wherever considered appropriate, but shall always have
these two methods print directly to the console. Note that the
definition provided expands slightly on the abstract requirements which
is just for a `+java.lang.String+`. Since `+java.lang.Object+` is the
base object type for all types in Java, including strings, the
conformance requirements are already met.

[[Dispose]]
==== 6.3.24 dispose

[source,listing]
----
void Browser.dispose()
    throws InvalidOperationTimingException
----

Dispose shall notify the browser that the Java implementation is no
longer interested in the X3D browser. Any further requests to methods of
this instance of the browser interface shall generate an
`+InvalidBrowserException+`.

[[ExecutionContextServices]]
=== 6.4 Execution context services

[[getSpecificationVersion]]
==== 6.4.1 getSpecificationVersion

[source,listing]
----
String X3DExecutionContext.getSpecificationVersion()
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

The string shall represent the basic specification version used by the
parsed file in decimal format. For example, a scene conforming to this
specification will return the value "3.0".

[[getEncoding]]
==== 6.4.2 getEncoding

[source,listing]
----
int X3DExecutionContext.getEncoding()
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

The encoding constant is defined as a constant that is part of the
X3DExecutionContext interface. The values for these are defined in
<<t-ConstantsForEncoding, Table 6.3>>.

[[t-ConstantsForEncoding]]
Table 6.3 — Constants describing the
encoding for current scene

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Encoding |Java Constant |Value |Comment
|NO_SCENE |`+static final int NO_SCENE+` |0 |There is no scene defined.
This value should never be seen directly.

|SCRIPTED_ENCODING |`+static final int SCRIPTED_ENCODING+` + |1 |The
scene was created dynamically through scripting calls.

|ASCII_ENCODING |`+static final int ASCII_ENCODING+` + |2 |The scene
described an original VRML 1.0 encoding.

|CLASSIC_VRML_ENCODING |`+static final int CLASSIC_VRML_ENCODING+` |3
|The scene is encoded using the Classic VRML encoding. The scene may be
VRML 97 or this specification.

|XML_ENCODING |`+static final int XML_ENCODING+` + |4 |The scene was
encoding using the XML file format.

|BINARY_ENCODING |`+static final int BINARY_ENCODING+` + |5 |The scene
was encoded using the binary format specified in ISO/IEC 19776-3.  It
shall be an error to use this value to describe a browser-specific
proprietary binary format.

|BIFS_ENCODING |`+static final int BIFS_ENCODING+` + |6 |The scene was
encoded using the MPEG4 BIFS encoding.

|LAST_STD_ENCODING |`+static final int LAST_STD_ENCODING+` + |100 |A
definition of the last constant used by the standard encodings. A
browser is permitted to allow other, proprietary encoding mechanisms,
and therefore any constant used to describe that shall use a value
greater than this number. Code using these values shall not expect to be
transportable across multiple browser implementations.
|===

[[ExecutionContextGetProfile]]
==== 6.4.3 getProfile

[source,listing]
----
ProfileInfo X3DExecutionContext.getProfile()
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

The profile declaration as defined for this scene is returned.

[[getComponents]]
==== 6.4.4 getComponents

[source,listing]
----
ComponentInfo[] X3DExecutionContext.getComponents()
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

A listing of the explicit components declared in this scene is returned.
If the scene does not have any extra components declared, this function
shall return `+null+`.

[[getWorldURL]]
==== 6.4.5 getWorldURL

[source,listing]
----
String X3DExecutionContext.getWorldURL()
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

The URL used to specify the current scene is returned. The world URL
shall be a string indicating the complete world URL as defined in 6.4.5,
getWorldURL of ISO/IEC 19775-2 (see <<I19775, 2. I19775>>).

[[getNode]]
==== 6.4.6 getNode

[source,listing]
----
X3DNode X3DExecutionContext.getNamedNode(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           NodeNotAvailableException,
           InvalidNameException

X3DNode X3DExecutionContext.getImportedNode(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           NodeNotAvailableException,
           InvalidNameException
----

The return value is a Node reference. The parameter is a String defining
the DEF name of the required node. If the browser cannot find the node
name, an `+InvalidNodeException+` shall be generated.

[[createNode]]
==== 6.4.7 createNode

[source,listing]
----
X3DNode X3DExecutionContext.createNode(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException
----

The return value is a X3DNode reference if it is part of the currently
set profile. If the node is not available in the current profile and
components, the browser shall generate `+InvalidNameException+`.

[[createProto]]
==== 6.4.8 createProto

[source,listing]
----
X3DProtoInstance X3DExecutionContext.createProto(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException
----

The return value is a proto instance reference if it can be found using
the name spacing rule for protos. If the proto name cannot be found, the
browser shall generate `+InvalidNameException+`.

[[NamedNodeHandling]]
==== 6.4.9 namedNodeHandling

[source,listing]
----
void X3DExecutionContext.updateNamedNode(String, X3DNode)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException,
           ImportedNodeException

void X3DExecutionContext.updateImportedNode(String, String, X3DNode)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException,
           ImportedNodeException


void X3DExecutionContext.removeNamedNode(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException

void X3DExecutionContext.removeImportedNode(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException
----

Separate method signatures are defined for each of the operation types.
This allows for strong type safety.

[[getProtoDeclaration]]
==== 6.4.10 getProtoDeclaration

[source,listing]
----
X3DProtoDeclaration X3DExecutionContext.getProtoDeclaration(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException
----

[[ProtoDeclarationHandling]]
==== 6.4.11 protoDeclarationHandling

[source,listing]
----
void X3DExecutionContext.updateProtoDeclaration(String, X3DProtoDeclaration)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException

void X3DExecutionContext.removeProtoDeclaration(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException
----

[[getExternProtoDeclaration]]
==== 6.4.12 getExternprotoDeclaration

[source,listing]
----
X3DExternProtoDeclaration X3DExecutionContext.getExternProtoDeclaration(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException,
           URLUnavailableException
----

[[ExternProtoDeclarationHandling]]
==== 6.4.13 externprotoDeclarationHandling

[source,listing]
----
void X3DExecutionContext.updateExternProtoDeclaration(String, X3DExternProtoDeclaration)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException

void X3DExecutionContext.removeExternProtoDeclaration(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

[[getRootNodes]]
==== 6.4.14 getRootNodes

[source,listing]
----
X3DNode[] X3DExecutionContext.getRootNodes()
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

Get a listing of the root nodes in the current execution context. If
this context is a proto, then this will list all of the top-level nodes
of the proto. The order shall be maintained as declared in the source
encoding. If there are no root level nodes, this shall return `+null+`.

[[getRoutes]]
==== 6.4.15 getRoutes

[source,listing]
----
X3DRoute[] X3DExecutionContext.getRoutes()
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

Show the list of routes currently available in the execution context. If
there are no routes the method shall return `+null+`.

[[DynamicRouteHandling]]
==== 6.4.16 dynamicRouteHandling

[source,listing]
----
X3DRoute X3DExecutionContext.addRoute(X3DNode, String, X3DNode, String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNodeException,
           InvalidFieldException

void X3DExecutionContext.deleteRoute(X3DRoute)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

This service is split into two separate methods: addRoute and
deleteRoute. They both take the same argument list. The first parameter
is a Node reference that the event will leave from. The second is a
String describing the name of the output-capable field. Third and forth
parameters are the destination node reference and the input-capable
field as a String. If either of the Node references have been disposed
of, an `+InvalidNodeException+` shall be generated. If either of the
nodes do not contain the nominated input-capable / output-capable
fields, an `+InvalidWritableFieldException+` /
`+InvalidReadableFieldException+` shall be generated appropriately.

[[SceneServices]]
=== 6.5 Scene services

[[SceneGeneralConcepts]]
==== 6.5.1 General concepts

Scene services are implemented by the `+X3DScene+` interface, which
extends from the `+X3DExecutionContext+` interface. The additional
methods required by the extra services are described below.

[[getMetaData]]
==== 6.5.2 getMetadata

[source,listing]
----
String X3DScene.getMetaData(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

The string describes a metadata key and the return value shall be the
metadata value previously set. If no metadata value is set, the return
value is `+null+`.

[[setMetaData]]
==== 6.5.3 setMetadata

[source,listing]
----
void X3DScene.setMetaData(String, String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

The metadata value specified by the metadata key is set or changed to
the new metadata value. The first parameter is the metadata key and the
second parameter is the metadata value to use. If the metadata value is
null, it shall be treated as deleting any currently set item of metadata
for that metadata key.

[[SceneGetNode]]
==== 6.5.4 getNode

[source,listing]
----
X3DNode X3DScene.getExportedNode(String)
    throws InvalidExecutionContext
           InvalidOperationTimingException,
           NodeNotAvailableException,
           InvalidNameException
----

The return value is a Node reference. The parameter is a String defining
the DEF name of the required node. If the browser cannot find the node
name, an `+InvalidNodeException+` shall be generated.

[[SceneNamedNodeHandling]]
==== 6.5.5 namedNodeHandling

[source,listing]
----
void X3DScene.updateExportedNode(String, String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException

void X3DScene.removeExportedNode(String)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           InvalidNameException
----

[[SceneRootNodeHandling]]
==== 6.5.6 rootNodeHandling

[source,listing]
----
void X3DScene.addRootNode(X3DNode)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException,
           NodeInUseException,
           InsufficientCapabilitiesException

void X3DScene.removeRootNode(X3DNode)
    throws InvalidExecutionContextException,
           InvalidOperationTimingException
----

[[NodeServices]]
=== 6.6 Node services

[[NodeRepresentation]]
==== 6.6.1 Node representation

Node services are implemented as the class `+X3DNode+`. This is a base
interface to represent any node in the system. Additional interfaces
that extend the base `+X3DNode+` interface are defined as part of this
specification and shall be supported. The additional interfaces
represent each of the abstract node types as defined in ISO/IEC 19775-1
(see <<I19775, 2.[I19775>>]). An additional capability that a browser
may support is to provide interfaces that represent the individual node
types. If a browser supports this capability, it shall return TRUE for
the browser property CONCRETE_NODES (see
<<getBrowserProperties, 6.3.24 getBrowserProperties>>).

[[NodeGetTypeName]]
==== 6.6.2 getTypeName

[source,listing]
----
String X3DNode.getNodeName()
    throws InvalidNodeException
----

The getTypeName service is implemented through the getNodeName method.
For a built-in node the method shall return the node's specified type
name. For an instance of a PROTO, the method shall return the name of
the PROTO.

[[NodeGetType]]
==== 6.6.3 getType

[source,listing]
----
int[] X3DNode.getType()
    throws InvalidNodeException
----

The getType service is implemented as the method `+getType()+`. The
method shall return an array of int values that represent all of the
base node types of which the node is composed. For example, a Group node
would return an array of length two, with the two values
`+X3DGroupingNode+` and `+X3DBoundedObject+`. The definition of the int
values shall be found in the `+X3DNodeTypes+` interface as constants.
The constants that shall be defined in the `+X3DNodeTypes+` interface is
defined in <<t-NodeTypeConstantValue, Table 6.4>>.

[[t-NodeTypeConstantValue]]
Table 6.4 — Node type constant value definitions

[opts="header,autowidth",frame=ends,grid=rows]
|===
|Abstract Node Type          |Java Constant     |Value
|X3DBoundedObject            |`static final int X3DBoundedObject`            |1
|X3DMetadataObject           |`static final int X3DMetadataObject`           |2
|X3DUrlObject                |`static final int X3DUrlObject`                |3
|X3DAppearanceNode           |`static final int X3DAppearanceNode`           |10
|X3DAppearanceChildNode      |`static final int X3DAppearanceChildNode`      |11
|X3DMaterialNode             |`static final int X3DMaterialNode`             |12
|X3DTextureNode              |`static final int X3DTextureNode`              |13
|X3DTexture2DNode            |`static final int X3DTexture2DNode`            |14
|X3DTextureTransformNode     |`static final int X3DTextureTransformNode`     |16
|X3DTextureTransform2DNode   |`static final int X3DTextureTransform2DNode`   |17
|X3DGeometryNode             |`static final int X3DGeometryNode`             |18
|X3DGeometricPropertyNode    |`static final int X3DGeometricPropertyNode`    |19
|X3DParametricGeometryNode   |`static final int X3DParametricGeometryNode`   |20
|X3DNurbsSurfaceGeometryNode |`static final int X3DNurbsSurfaceGeometryNode` |21
|X3DColorNode                |`static final int X3DColorNode`                |22
|X3DCoordinateNode           |`static final int X3DCoordinateNode`           |23
|X3DNormalNode               |`static final int X3DNormalNode`               |24
|X3DTextureCoordinateNode    |`static final int X3DTextureCoordinateNode`    |25
|X3DFontStyleNode            |`static final int X3DFontStyleNode`            |26
|X3DProtoInstance            |`static final int X3DProtoInstance`            |27
|X3DChildNode                |`static final int X3DChildNode`                |28
|X3DBindableNode             |`static final int X3DBindableNode`             |29
|X3DBackgroundNode           |`static final int X3DBackgroundNode`           |30
|X3DGroupingNode             |`static final int X3DGroupingNode`             |31
|X3DShapeNode                |`static final int X3DShapeNode`                |32
|X3DInterpolatorNode         |`static final int X3DInterpolatorNode`         |33
|X3DLightNode                |`static final int X3DLightNode`                |34
|X3DScriptNode               |`static final int X3DScriptNode`               |35
|X3DSensorNode               |`static final int X3DSensorNode`               |36
|X3DEnvironmentalSensorNode  |`static final int X3DEnvironmentalSensorNode`  |37
|X3DKeyDeviceSensorNode      |`static final int X3DKeyDeviceSensorNode`      |38
|X3DNetworkSensorNode        |`static final int X3DNetworkSensorNode`        |39
|X3DPointingDeviceSensorNode |`static final int X3DPointingDeviceSensorNode` |40
|X3DDragSensorNode           |`static final int X3DDragSensorNode`           |41
|X3DTouchSensorNode          |`static final int X3DTouchSensorNode`          |42
|X3DSequencerNode            |`static final int X3DSequencerNode`            |43
|X3DTimeDependentNode        |`static final int X3DTimeDependentNode`        |44
|X3DSoundSourceNode          |`static final int X3DSoundSourceNode`          |45
|X3DTriggerNode              |`static final int X3DTriggerNode`              |46
|X3DInfoNode                 |`static final int X3DInfoNode`                 |47
|X3DNurbsControlCurveNode    |`static final int X3DNurbsControlCurveNode`    |48
|===

Nodes types defined as standard extension types, but not formalized as
part of this specification shall start with constant value of 100. Types
that are browser-specific extensions to this interface shall have a
starting constant value offset of 1000.

If this node instance represents a prototype instance, this method shall
return an array of length one with the value `+X3DProtoInstance+` as the
value. The implementation node type shall be made available through the
`+X3DProtoInstance.getImplementationType()+` method.

[[getField]]
==== 6.6.4 getField

[source,listing]
----
X3DField X3DNode.getField(String)
    throws InvalidNodeException,
           InvalidOperationTimingException,
           InvalidFieldException
----

The getField service is implemented as the method
`+getField(String)+`,`+ +`which allows access to all field types. The
normal field name or with the _set__ or __changed_ modifier may be used
to describe the writable and readable fields respectively or either form
may be used to access a readable and writable field.

[[getFieldDefinitions]]
==== 6.6.5 getFieldDefinitions

[source,listing]
----
X3DFieldDefinition[] X3DNode.getFieldDefinitions()
    throws InvalidNodeException,
           InvalidOperationTimingException,
----

Fetch a list of all field defintions of a node. Nodes that do not
contain any fields (for example a blank PROTO) shall return `+null+`.

[[NodeDispose]]
==== 6.6.6 dispose

[source,listing]
----
void X3DNode.dispose()
    throws InvalidOperationTimingException
----

Dispose shall notify the browser that the Java implementation is no
longer interested in this node instance and it is free to do as required
with the node representation. Any further requests to methods of this
instance of the node reference shall generate an InvalidNodeException.
If two separate instances of the same class represent the same node (as
defined by the `+equals()+` method returning `+true+`) and one has
dispose called, this shall not effect the other instance.

[[FieldServices]]
==== 6.7 Field services

[[FieldRepresentation]]
==== 6.7.1 Field representation

The Java implementation of the field services does not directly follow
the model outlined in 6.7, Field Services of ISO/IEC 19775-2 (see
<<I19775, 2.[I19775>>]). Instead, it makes heavy use of the
object-oriented nature of Java to provide directly the capabilities
suggested by the services specified. All the services are implemented in
the classes provided in the `+org.web3d.x3d.sai+` package.

The basic field is defined by the interface `+X3DField+`. A derived
interface of this, `+MField+` is used to represent the sub set of all
field types that represent multiple-values. From these base interfaces,
there shall be derived interfaces for each of the appropriate field
types.

The following outlines how the Java binding conforms to the requirements
of the SAI.

[[getAccessType]]
==== 6.7.2 getAccessType

getAccessType is represented by two methods of the `+X3DField+`
interface.

[source,listing]
----
boolean X3DField.isWritable()
    throws InvalidOperationTimingException,
           InvalidFieldException

boolean X3DField.isReadable()
    throws InvalidOperationTimingException,
           InvalidFieldException
----

These methods describe whether the field is readable or writable at the
time the method is called. The values that the methods return may change
over time as the lifecycle of the node changes and can be determined
from _Table 4.2 — Permitted field access capabilities_ during the node
lifecycle of ISO/IEC 19775-2 (see <<I19775, 2.[I19775>>]).

[[getType]]
==== 6.7.3 getType

[source,listing]
----
int X3DFieldDefintion.getType()
    throws InvalidFieldException
----

The type of an `+X3DField+` is determined by the field definition class
`+X3DFieldDefinition+` and it's method `+getType()+`. The `+getType()+`
method returns an identifier of the type of field that the instance of
the interface represents. The list of legal type identifiers is included
as public final variables in the interface `+X3DFieldTypes+`. The return
value of the `+getType()+` method shall be one of these values.

[[FieldGetName]]
==== 6.7.4 getName

[source,listing]
----
String X3DFieldDefintion.getName()
    throws InvalidFieldException
----

The getName service is supported through the `+getName()+` method on the
X3DFieldDefinition that accompanies the given field.

[[getValue]]
==== 6.7.5 getValue

[source,listing]
----
type X3DField.getValue()
    throws InvalidOperationTimingException,
           InvalidReadableFieldException,
           InvalidFieldException

void X3DField.getValue(type)
    throws InvalidOperationTimingException,
           InvalidReadableFieldException,
           InvalidFieldException

int MField.getSize()
    throws InvalidOperationTimingException,
           InvalidReadableFieldException,
           InvalidFieldException
----

The `+ getValue()+` method returns values in a format appropriate to the
individual field type. For single valued field types, the return value
of the method is used to pass values to user code. If the method returns
an array of value. The implementation may reuse return value references
between calls to the methods. User code should not expect to have
consistent data values if it holds an array value.

For multi-valued fields derived from the base interface MField, the
getSize() method provides a number which is the number of elements
currently set in that field. An element is the equivalent single value
type. For example:

[source,listing]
----
field MFFloat [ 0.5 0.2 14]
----

would return a size of three, where

[source,listing]
----
field MFVec3f [ 0.5 0.2 14]
----

would return a size of one. The corresponding getValue() field defines
void as the return type. The parameter takes a user provided array of
the appropriate data type (see <<t-MappingOfX3DDataTypesToJava, Table 5.4 
— Mapping of X3D data types to Java primitive data types>>) into
which the values shall be copied. If the array is not of sufficient
length to contain all the field values, the browser implementation shall
copy as many values in as possible, starting from the zero^th^ element
of the underlying field value.

A `+get1Value()+` method is provided for all multi-valued fields. This
allows access to a single value out of the many values. When an attempt
is made to access a value at an index greater than the number of items
in that field, a `+java.lang.ArrayIndexOutOfBoundsException+` shall be
generated. The following example shows signature of this method for
setting an MFInt32 field:

[source,listing]
----
void MFInt32.set1Value(int index, int value)
    throws InvalidOperationTimingException,
           InvalidFieldValueException,
           InvalidWritableFieldException,
           InvalidFieldException,
           ArrayIndexOutOfBoundsException
----

The SFImage/MFImage field types shall define an additional behaviour.
The getValue service will be supplemented by the `+getImage()+` method.
This shall return an instance of
`+java.awt.image.WritableRenderedImage+`. Typically, the concrete class
will be an instance of `+java.awt.image.BufferedImage+`, but this shall
not be required. User code may make use of the `+instanceof+` operator
to check for this. Drawing to this image shall have no effect on the
visual output or the value of the field, until the corresponding
`+setImage()+` method is called. (See B.4.18 MFImage for more details)

[[setValue]]
==== 6.7.6 setValue

[source,listing]
----
void X3DField.setValue(type)
    throws InvalidOperationTimingException,
           InvalidFieldValueException,
           InvalidWritableFieldException,
           InvalidFieldException,
           ImportedNodeException
----

A `+set1Value()+` method is provided for MFields. This allows the
ability to change a single value of a field without having to re-create
the entire array of values. When an attempt is made to set a value at an
index greater than the number of items in that field, a
`+java.lang.ArrayIndexOutOfBoundsException+` shall be generated.

To append a value to a value to an exising multi-valued field, an
`+append()+` method shall be defined. This shall place the new value on
the end of the existing array and increase the size by one.

To insert a value into a given position of an existing multi-valued
field, an `+insertValue()+` method shall be defined. This method shall
take the index of the value to be inserted and the value. All items from
the index to the end of the array shall be moved up one index value and
the new value copied into the now vacant index position. The size shall
be increased by one. When an attempt is made to set a value at an index
greater than the number of items in that field, a
`+java.lang.ArrayIndexOutOfBoundsException+` shall be generated.

To completely clear a field, a `+clear()+` method shall be defined. When
this is called, all values set in the field shall be removed and the
size is set to zero.

To remove an individual value from a field, a `+remove()+` method shall
be defined. This shall take the index of the item to be removed. The
return value shall be null. All items above the given index shall move
down one position in the underlying representation.

The SFImage/MFImage field types shall define an additional behaviour.
The setValue service will be supplemented by `+setImage()+` methods.
These shall have the following signature:

[source,listing]
----
void SFImage.setImage(java.awt.image.RenderedImage)
    throws InvalidOperationTimingException,
           InvalidFieldValueException,
           InvalidWritableFieldException,
           InvalidFieldException

void SFImage.setSubImage(java.awt.image.RenderedImage, int, int, int, int, int, int)
    throws InvalidOperationTimingException,
           InvalidFieldValueException,
           InvalidWritableFieldException,
           InvalidFieldException
----

The former replaces the entire image with the new image. There shall be
no restrictions and shall be treated the same as the integer-based
SFImage. The second form copies the image as a sub-image region to
replace a portion of the current image. The integer parameters, in
order, are: source image width, source image height, source image x
location offset, source image y location offset, destination image x
location offset and destination y location offset. The sub image set
shall not resize the base image representation and therefore performs an
intersection clip of the provided image. The user provided image shall
be of the same format (pixel depth, pixel representation) as the
original image obtained through the `+getImage()+` method.

[[RegisterFieldInterest]]
==== 6.7.7 registerFieldInterest

[source,listing]
----
void X3DField.addFieldEventListener(X3DFieldEventListener)
    throws InvalidOperationTimingException,
           InvalidFieldException

void X3DField.removeFieldEventListener(X3DFieldEventListener)
    throws InvalidOperationTimingException,
           InvalidFieldException
----

This specification only requires that there shall be listeners available
for readable fields. Browser implementations may also permit adding
listeners to writable fields. It shall be an error to register a
listener with initialize-only fields.

The signature of the X3DFieldEventListener shall be:

[source,listing]
----
public interface X3DFieldEventListener extends java.util.EventListener
void X3DFieldEventListener.readableFieldChanged(X3DFieldEvent evt)
----

The signature of the X3DFieldEvent object shall be:

[source,listing]
----
public class X3DFieldEvent extends java.util.EventObject
public double X3DFieldEvent.getTime()
public Object X3DFieldEvent.getData()
----

The field that caused the listener to trigger shall be made available
through the getSource() method of the`+ java.util.EventObject+` base
class.

[[FieldDispose]]
==== 6.7.8 dispose

[source,listing]
----
void X3DField.dispose()
    throws InvalidOperationTimingException
----

[[RouteServices]]
=== 6.8 Route services

[[RouteRepresentation]]
==== 6.8.1 Route representation

Route services are implemented as the interface `+X3DRoute+`. This
interface has four methods as defined in the remainder of this
subclause.

[[getSourceNode]]
==== 6.8.2 getSourceNode

[source,listing]
----
X3DNode X3DRoute.getSourceNode()
    throws InvalidOperationTimingException,
           InvalidRouteException
----

The node representation that is used at the source of the ROUTE is
returned.

[[getSourceField]]
==== 6.8.3 getSourceField

[source,listing]
----
String X3DRoute.getSourceField()
    throws InvalidOperationTimingException,
           InvalidRouteException
----

The name of the source field in the source node is returned.

[[getDestinationNode]]
==== 6.8.4 getDestinationNode

[source,listing]
----
X3DNode X3DRoute.getDestinationNode()
    throws InvalidOperationTimingException,
           InvalidRouteException
----

The node representation that is used at the source of the ROUTE is
returned.

[[getDestinationField]]
==== 6.8.5 getDestinationField

[source,listing]
----
String X3DRoute.getDestinationField()
    throws InvalidOperationTimingException,
           InvalidRouteException
----

The name of the destination field in the node is returned.

[[RouteDispose]]
==== 6.8.6 dispose

[source,listing]
----
void X3Route.dispose()
    throws InvalidOperationTimingException
----

[[PrototypeServices]]
=== 6.9 Prototype services

[[isExternProto]]
==== 6.9.1 isExternproto

[source,listing]
----
X3DProtoDeclaration
X3DExternProtoDeclaration
----

Protos are represented by the specific class for the capability. This
service request is implemented by using the derived class types and the
Java `+instanceof+` operator.

[[createInstance]]
==== 6.9.2 createInstance

[source,listing]
----
X3DProtoInstance X3DProtoDeclaration.createInstance()
    throws InvalidOperationTimingException,
           InvalidProtoException

X3DProtoInstance X3DExternProtoDeclaration.createInstance()
    throws InvalidOperationTimingException,
           InvalidRouteException,
           InvalidNodeException
----

Both interfaces have a createInstance() method that instantiates a new
prototype instance. If the EXTERNPROTO instance has not yet been
fetched, the implementation shall throw `+InvalidNodeException+`.

[[ProtoGetFieldDefinitions]]
==== 6.9.3 getFieldDefinitions

[source,listing]
----
X3DFieldDefinition[] X3DProtoDeclaration.getFieldDefinitions()
    throws InvalidOperationTimingException,
           InvalidProtoException

X3DFieldDefinition[] X3DExternProtoDeclaration.getFieldDefinitions()
    throws InvalidOperationTimingException,
           InvalidProtoException
----

[[checkLoadState]]
==== 6.9.4 checkLoadState

[source,listing]
----
int X3DExternProtoDeclaration.getLoadState()
    throws InvalidOperationTimingException,
           InvalidProtoException
----

The values returned by this method are defined in
<<t-LoadStateTypeValueDefintions, Table 5.5 — Load state type value defintions>>.

[[RequestImmediateLoad]]
==== 6.9.5 requestImmediateLoad

[source,listing]
----
void X3DExternProtoDeclaration.loadNow()
    throws InvalidOperationTimingException,
           InvalidProtoException
----

[[ProtoDispose]]
==== 6.9.6 dispose

[source,listing]
----
void X3DProtoDeclaration.dispose()
    throws InvalidOperationTimingException

void X3DExternProtoDeclaration.dispose()
    throws InvalidOperationTimingException
----

[[ScriptContentServices]]
=== 6.10 Script content services

[[ImplementationMarkerInterface]]
==== 6.10.1 implementationMarkerInterface

Java code that is to run as a script is marked by implementing the
`+X3DScriptImplementation+` interface.

[source,listing]
----
void X3DScriptImplementation.setBrowser(Browser browser)
void X3DScriptImplementation.setFields(X3DScriptNode externalView, java.util.Map fields)
void X3DScriptImplementation.initialize()
void X3DScriptImplementation.eventsProcessed()
void X3DScriptImplementation.shutdown()
----

[[PrepareEventsNotification]]
==== 6.10.2 prepareEvents notification

For efficiency reasons, a derived interface is defined for scripts that
wish to know about pre-"event cascade" processing.  The derived
interface shall be named `+X3DPerFrameObserverScript+` and extends
`+X3DScriptImplementation+`. The additional method signature shall be:

[source,listing]
----
void X3DPerFrameObserverScript.prepareEvents()
----

[[MatrixServices]]
=== 6.11 Matrix services

[[MatrixDescription]]
==== 6.11.1 Description

The matrix services are provided by two specialized classes that
represent a 3x3 and 4x4 matrix. The internal implementation of these
classes are not defined. When initially constructed, both matrices
default to an identity matrix.

[[Matrix3]]
==== 6.11.2 Matrix3

[source,listing]
----
public class Matrix3 {
    public Matrix3();
    public void setIdentity();
    public void set(int row, int column)
    public float get(int row, int column)
    public void setTransform(SFVec2f translation,
                             SFVec3f rotation,
                             SFVec2f scale,
                             SFVec3f scaleOrientation,
                             SFVec2f center)
    public void getTransform(SFVec2f translation,
                             SFVec3f rotation,
                             SFVec2f scale)
    public Matrix3 inverse()
    public Matrix3 transpose()
    public Matrix3 multiplyLeft(Matrix3 mat)
    public Matrix3 multiplyRight(Matrix3 mat)
    public Matrix3 multiplyRowVector(SFVec3f vec)
    public Matrix3 multiplyColVector(SFVec3f vec)
}
----

[[Matrix4]]
==== 6.11.3 Matrix4

[source,listing]
----
public class Matrix4 {
    public Matrix4();
    public void setIdentity();
    public void set(int row, int column)
    public float get(int row, int column)
    public void setTransform(SFVec3f translation,
                             SFRotation rotation,
                             SFVec3f scale,
                             SFRotation scaleOrientation,
                             SFVec3f center)
    public void getTransform(SFVec3f translation,
                             SFRotation rotation,
                             SFVec3f scale)
    public Matrix3 inverse()
    public Matrix3 transpose()
    public Matrix3 multiplyLeft(Matrix4 mat)
    public Matrix3 multiplyRight(Matrix4 mat)
    public Matrix3 multiplyRowVector(SFVec3f vec)
    public Matrix3 multiplyColVector(SFVec3f vec)
}
----

[[compilation]]
== Annex A Constructs in compilation order

[[IntroductionAndTopics]]
=== A.1 Introduction and topics

[[Introduction]]
==== A.1.1 Introduction

The following represents one possible ordering of the constructs in this
part of ISO/IEC 19777 that will compile correctly. Other orderings are
possible and may be used by conforming implementations.

[[Topics]]
==== A.1.2 Topics

See <<Table6.1, Table 6.1>> for the table of contents for this clause.

[[TopicsTable]]
Table 6.1 — Topics in this clause

* <<IntroductionAndTopics, A.1 Introduction and topics>>
** <<Introduction, A.1.1 Introduction>>
** <<Topics, A.1.2 Topics>>
* <<ClassHeirarchy, A.2 Class heirarchy>>
* <<CompilationOrder, A.3 Compilation order>>

This annex provides a listing of all the constructs defined in this Part
in compilation order.

[[ClassHeirarchy]]
=== A.2 Class heirarchy

[source,listing]
----
Package org.web3d.x3d.sai
 +- org.web3d.x3d.sai.Browser
 +- org.web3d.x3d.sai.BrowserFactory
 +- org.web3d.x3d.sai.BrowserFactoryImpl
 +- org.web3d.x3d.sai.BrowserEvent
 +- org.web3d.x3d.sai.BrowserListener
 +- org.web3d.x3d.sai.X3DBoundedObject
 +- org.web3d.x3d.sai.X3DMetadataObject
 +- org.web3d.x3d.sai.X3DURLObject
 +- org.web3d.x3d.sai.X3ProtoDeclaration
 +- org.web3d.x3d.sai.X3ExternProtoDeclaration
 +- org.web3d.x3d.sai.X3Route
 +- org.web3d.x3d.sai.X3DExecutionContext
   +- org.web3d.x3d.sai.X3DScene
 +- org.web3d.x3d.sai.ComponentInfo
 +- org.web3d.x3d.sai.ProfileInfo
 +- org.web3d.x3d.sai.X3DFieldTypes
 +- org.web3d.x3d.sai.X3DNodeTypes
 +- org.web3d.x3d.sai.X3DComponent
 +- org.web3d.x3d.sai.X3DScriptImplementation
   +- org.web3d.x3d.sai.X3DPerFrameObserverScript
 +- org.web3d.x3d.sai.X3DFieldDefinition
 +- org.web3d.x3d.sai.X3DFieldEvent
 +- org.web3d.x3d.sai.X3DFieldEventListener
 +- org.web3d.x3d.sai.X3DField
   +- org.web3d.x3d.sai.MFField
     +- org.web3d.x3d.sai.MFColor
     +- org.web3d.x3d.sai.MFColorRGBA
     +- org.web3d.x3d.sai.MFDouble
     +- org.web3d.x3d.sai.MFFloat
     +- org.web3d.x3d.sai.MFImage   
     +- org.web3d.x3d.sai.MFInt32
     +- org.web3d.x3d.sai.MFNode
     +- org.web3d.x3d.sai.MFRotation
     +- org.web3d.x3d.sai.MFString
     +- org.web3d.x3d.sai.MFTime
     +- org.web3d.x3d.sai.MFVec2d
     +- org.web3d.x3d.sai.MFVec2f
     +- org.web3d.x3d.sai.MFVec3d
     +- org.web3d.x3d.sai.MFVec3f
   +- org.web3d.x3d.sai.SFBool
   +- org.web3d.x3d.sai.SFColor
   +- org.web3d.x3d.sai.SFColorRGBA
   +- org.web3d.x3d.sai.SFDouble
   +- org.web3d.x3d.sai.SFFloat
   +- org.web3d.x3d.sai.SFInt32
   +- org.web3d.x3d.sai.SFNode
   +- org.web3d.x3d.sai.SFRotation
   +- org.web3d.x3d.sai.SFString
   +- org.web3d.x3d.sai.SFTime
   +- org.web3d.x3d.sai.SFVec2d
   +- org.web3d.x3d.sai.SFVec2f
   +- org.web3d.x3d.sai.SFVec3d
   +- org.web3d.x3d.sai.SFVec3f
 +- org.web3d.x3d.sai.X3DNode
   +- org.web3d.x3d.sai.X3DAppearanceNode
   +- org.web3d.x3d.sai.X3DChildNode
     +- org.web3d.x3d.sai.X3DAudioClipNode
     +- org.web3d.x3d.sai.X3DBackgroundNode
     +- org.web3d.x3d.sai.X3DBindableNode
     +- org.web3d.x3d.sai.X3DGroupingNode
     +- org.web3d.x3d.sai.X3DInfoNode
     +- org.web3d.x3d.sai.X3DInterpolatorNode
     +- org.web3d.x3d.sai.X3DLightNode
     +- org.web3d.x3d.sai.X3DNetworkSensorNode
     +- org.web3d.x3d.sai.X3DSensorNode
       +- org.web3d.x3d.sai.X3DPointingDeviceSensorNode
         +- org.web3d.x3d.sai.X3DDragSensorNode
         +- org.web3d.x3d.sai.X3DTouchSensorNode
       +- org.web3d.x3d.sai.X3DEnvironmentalSensorNode
       +- org.web3d.x3d.sai.X3DKeyDeviceSensorNode
     +- org.web3d.x3d.sai.X3DScriptNode
     +- org.web3d.x3d.sai.X3DSequencerNode
     +- org.web3d.x3d.sai.X3DShapeNode
     +- org.web3d.x3d.sai.X3DSoundNode
     +- org.web3d.x3d.sai.X3DTriggerNode
   +- org.web3d.x3d.sai.X3DGeometricPropertyNode
     +- org.web3d.x3d.sai.X3DColorNode
     +- org.web3d.x3d.sai.X3DNormalNode
     +- org.web3d.x3d.sai.X3DTextureCoordinateNode
     +- org.web3d.x3d.sai.X3DCoordinateNode
   +- org.web3d.x3d.sai.X3DAppearanceChildNode
     +- org.web3d.x3d.sai.X3DMaterialNode
     +- org.web3d.x3d.sai.X3DTextureNode
       +- org.web3d.x3d.sai.X3DTexture2DNode
     +- org.web3d.x3d.sai.X3DTextureTransformNode
       +- org.web3d.x3d.sai.X3DTextureTransform2DNode
   +- org.web3d.x3d.sai.X3DFontStyleNode
   +- org.web3d.x3d.sai.X3DGeometryNode
     +- org.web3d.x3d.sai.X3DComposedGeometryNode
     +- org.web3d.x3d.sai.X3DParametricGeometryNode
       +- org.web3d.x3d.sai.X3DNurbsSurfaceGeometryNode
   +- org.web3d.x3d.sai.X3DNurbsControlCurveNode
   +- org.web3d.x3d.sai.X3DProtoInstance
   +- org.web3d.x3d.sai.X3DSoundSourceNode
   +- org.web3d.x3d.sai.X3DTimeDependentNode
 +- org.web3d.x3d.sai.X3DException
   +- org.web3d.x3d.sai.BrowserNotSharedException
   +- org.web3d.x3d.sai.ConnectionException
   +- org.web3d.x3d.sai.ImportedNodeException
   +- org.web3d.x3d.sai.InsufficientCapabilitiesException
   +- org.web3d.x3d.sai.InvalidBrowserException
   +- org.web3d.x3d.sai.InvalidDocumentException
   +- org.web3d.x3d.sai.InvalidExecutionContextException
   +- org.web3d.x3d.sai.InvalidFieldException
   +- org.web3d.x3d.sai.InvalidFieldValueException
   +- org.web3d.x3d.sai.InvalidNodeException
   +- org.web3d.x3d.sai.InvalidOperationTimingException
   +- org.web3d.x3d.sai.InvalidProtoException
   +- org.web3d.x3d.sai.InvalidReadableFieldException
   +- org.web3d.x3d.sai.InvalidRouteException
   +- org.web3d.x3d.sai.InvalidURLException
   +- org.web3d.x3d.sai.InvalidWritableFieldException
   +- org.web3d.x3d.sai.InvalidX3DException
   +- org.web3d.x3d.sai.NodeInUseException
   +- org.web3d.x3d.sai.NodeUnavailableException
   +- org.web3d.x3d.sai.NoSuchBrowserException
   +- org.web3d.x3d.sai.NotSupportedException
   +- org.web3d.x3d.sai.URLUnavailableException
----

[[CompilationOrder]]
=== A.3 Compilation order

[source,listing]
----
X3DException.java
URLUnavailableException.java
NoSuchBrowserException.java
NotSupportedException.java
InvalidX3DException.java
InvalidURLException.java
InvalidNodeException.java
InvalidBrowserException.java
InvalidExecutionContextException.java
InvalidFieldException.java
InvalidFieldValueException.java
InvalidReadableFieldException.java
InvalidWritableFieldException.java
InvalidDocumentException.java
InvalidRouteException.java
InvalidProtoException.java
InvalidOperationTimingException.java
ImportedNodeException.java
InsufficientCapabilitiesException.java
ConnectionException.java
NodeUnavailableException.java
NodeInUseException.java
BrowserNotSharedException.java
X3DFieldEvent.java
X3DFieldEventListener.java
BrowserEvent.java
BrowserListener.java
X3DFieldTypes.java
X3DLoadStateTypes.java
X3DField.java
X3DFieldDefinition.java
X3DNodeTypes.java
X3DMetadataObject.java 
X3DNode.java
X3DProtoInstance.java
X3DProtoDeclaration.java
X3DExternProtoDeclaration.java
ComponentInfo.java
ProfileInfo.java
Browser.java
ExternalBrowser.java
X3DComponent.java
BrowserFactoryImpl.java
BrowserFactory.java
DefaultBrowserImpl.java
X3DRoute.java
X3DExecutionContext.java
X3DScene.java
X3DBoundedObject.java
X3DAppearanceChildNode.java
X3DMaterialNode.java
X3DTextureNode.java
X3DTexture2DNode.java
X3DTextureTransformNode.java
X3DTextureTransform2DNode.java
X3DAppearanceNode.java
X3DGeometricPropertyNode.java
X3DColorNode.java
X3DCoordinateNode.java
X3DNormalNode.java
X3DTextureCoordinateNode.java
X3DGeometryNode.java
X3DTextNode.java
X3DComposedGeometryNode.java
X3DParametricGeometryNode.java
X3DNurbsControlCurveNode.java
X3DNurbsSurfaceGeometryNode.java
X3DChildNode.java
X3DBindableNode.java
X3DBackgroundNode.java
X3DGroupingNode.java
X3DShapeNode.java
X3DInterpolatorNode.java
X3DFontStyleNode.java
X3DSensorNode.java
X3DSequencerNode.java
X3DEnvironmentalSensorNode.java
X3DKeyDeviceSensorNode.java
X3DNetworkSensorNode.java
X3DPointingDeviceSensorNode.java
X3DDragSensorNode.java
X3DTouchSensorNode.java
X3DTriggerNode.java
X3DAudioClipNode.java
X3DSoundSourceNode.java
X3DSoundNode.java
X3DTimeDependentNode.java
X3DInfoNode.java
X3DScriptImplementation.java
X3DPerFrameObserverScript.java
SFBool.java
SFColor.java
SFColorRGBA.java
SFDouble.java
SFFloat.java
SFImage.java
SFInt32.java
SFNode.java
SFRotation.java
SFString.java
SFTime.java
SFVec2d.java
SFVec2f.java
SFVec3d.java
SFVec3f.java
MFBool.java
MFColor.java
MFColorRGBA.java
MFDouble.java
MFFloat.java
MFInt32.java
MFNode.java
MFRotation.java
MFString.java
MFTime.java
MFVec2d.java
MFVec2f.java
MFVec3d.java
MFVec3f.java
----

[[abstracts]]
== Annex B Abstract node Interfaces


[[IntroductionAndTopics]]
=== B.1 Introduction and topics

[[Introduction]]
==== B.1.1 Introduction

This annex provides the definition of the interface signature for each
interface that represents the abstract node instance defined in IS0/IEC
19775-2 (see <<I19775, 2. 19775>>).

[[Topics]]
==== B.1.2 Topics

See <<TopicsTable, Table B.1>> for the topics in this clause.

[[TopicsTable]]
Table B.1 — Topics

* <<IntroductionAndTopics, B.1 Introduction and topics>>
** <<Introduction, B.1.1 Introduction>>
** <<Topics, B.1.2 Topics>>
** <<Conventions, B.1.3 Conventions>>
* <<NodeTypeInterfaces, B.2 Node type interfaces>>
** <<X3DAppearanceChildNode, B.2.1 X3DAppearanceChildNode>>
** <<X3DAppearanceNode, B.2.2 X3DAppearanceNode>>
** <<X3DAudioClipNode, B.2.3 X3DAudioClipNode>>
** <<X3DBackgroundNode, B.2.4 X3DBackgroundNode>>
** <<X3DBindableNode, B.2.5 X3DBindableNode>>
** <<X3DChildNode, B.2.6 X3DChildNode>>
** <<X3DColorNode, B.2.7 X3DColorNode>>
** <<X3DComposedGeometryNode, B.2.8 X3DComposedGeometryNode>>
** <<X3DCoordinateNode, B.2.9 X3DCoordinateNode>>
** <<X3DDragSensorNode, B.2.10 X3DDragSensorNode>>
** <<X3DEnvironmentalSensorNode, B.2.11 X3DEnvironmentalSensorNode>>
** <<X3DFontStyleNode, B.2.12 X3DFontStyleNode>>
** <<X3DGeometricPropertyNode, B.2.13 X3DGeometricPropertyNode>>
** <<X3DGeometryNode, B.2.14 X3DGeometryNode>>
** <<X3DGroupingNode, B.2.15 X3DGroupingNode>>
** <<X3DInfoNode, B.2.16 X3DInfoNode>>
** <<X3DInterpolatorNode, B.2.17 X3DInterpolatorNode>>
** <<X3DKeyDeviceSensorNode, B.2.18 X3DKeyDeviceSensorNode>>
** <<X3DLightNode, B.2.19 X3DLightNode>>
** <<X3DMaterialNode, B.2.20 X3DMaterialNode>>
** <<X3DNetworkSensorNode, B.2.21 X3DNetworkSensorNode>>
** <<X3DNode, B.2.22 X3DNode>>
** <<X3DNormalNode, B.2.23 X3DNormalNode>>
** <<X3DParametricGeometryNode, B.2.24 X3DParametricGeometryNode>>
** <<X3DPointingDeviceSensorNode, B.2.25 X3DPointingDeviceSensorNode>>
** <<X3DProtoInstance, B.2.26 X3DProtoInstance>>
** <<X3DScriptNode, B.2.27 X3DScriptNode>>
** <<X3DSensorNode, B.2.28 X3DSensorNode>>
** <<X3DSequencerNode, B.2.29 X3DSequencerNode>>
** <<X3DShapeNode, B.2.30 X3DShapeNode>>
** <<X3DSoundNode, B.2.31 X3DSoundNode>>
** <<X3DSoundSourceNode, B.2.32 X3DSoundSourceNode>>
** <<X3DTextNode, B.2.33 X3DTextNode>>
** <<X3DTextureCoordinateNode, B.2.34 X3DTextureCoordinateNode>>
** <<X3DTextureNode, B.2.35 X3DTextureNode>>
** <<X3DTexture2DNode, B.2.36 X3DTexture2DNode>>
** <<X3DTextureTransformNode, B.2.37 X3DTextureTransformNode>>
** <<X3DTextureTransform2DNode, B.2.38 X3DTextureTransform2DNode>>
** <<X3DTimeDependentNode, B.2.39 X3DTimeDependentNode>>
** <<X3DTouchSensorNode, B.2.40 X3DTouchSensorNode>>
** <<X3DTouchSensorNode, B.2.41 X3DTriggerNode>>
* <<AuxiliaryNodeTypeInterfaces, B.3 Auxiliary node type interfaces>>
** <<X3DBoundedObject, B.3.1 X3DBoundedObject>>
** <<X3DMetadataObject, B.3.2 X3DMetadataObject>>
** <<X3DUrlObject, B.3.3 X3DURLObject>>
* <<ServiceInterfaces, B.4 Field interfaces>>
** <<X3DFieldTypes, B.4.1 X3DFieldTypes>>
** <<X3DFieldEvent, B.4.2 X3DFieldEvent>>
** <<X3DFieldEventListener, B.4.3 X3DFieldEventListener>>
** <<X3DFieldDefinition, B.4.4 X3DFieldDefinition>>
** <<X3DField, B.4.5 X3DField>>
** <<MField, B.4.6 MField>>
** <<SFBool, B.4.7 SFBool>>
** <<MFBool, B.4.8 MFBool>>
** <<SFColor, B.4.9 SFColor>>
** <<MFColor, B.4.10 MFColor>>
** <<SFColorRGBA, B.4.11 SFColorRGBA>>
** <<MFColorRGBA, B.4.12 MFColorRGBA>>
** <<SFDouble, B.4.13 SFDouble>>
** <<MFDouble, B.4.14 MFDouble>>
** <<SFFloat, B.4.15 SFFloat>>
** <<MFFloat, B.4.16 MFFloat>>
** <<SFImage, B.4.17 SFImage>>
** <<MFImage, B.4.18 MFImage>>
** <<SFInt32, B.4.19 SFInt32>>
** <<MFInt32, B.4.20 MFInt32>>
** <<SFNode, B.4.21 SFNode>>
** <<MFNode, B.4.22 MFNode>>
** <<SFRotation, B.4.23 SFRotation>>
** <<MFRotation, B.4.24 MFRotation>>
** <<SFString, B.4.25 SFString>>
** <<MFString, B.4.26 MFString>>
** <<SFTime, B.4.27 SFTime>>
** <<MFTime, B.4.28 MFTime>>
** <<SFVec2d, B.4.29 SFVec2d>>
** <<MFVec2d, B.4.30 MFVec2d>>
** <<SFVec2f, B.4.31 SFVec2f>>
** <<MFVec2f, B.4.32 MFVec2f>>
** <<SFVec3d, B.4.33 SFVec3d>>
** <<MFVec3d, B.4.34 MFVec3d>>
** <<SFVec3f, B.4.35 SFVec3f>>
** <<MFVec3f, B.4.36 MFVec3f>>
* <<ServiceInterfaces, B.5 Service interfaces>>
** <<BrowserEvent, B.5.1 BrowserEvent>>
** <<BrowserFactory, B.5.2 BrowserFactory>>
** <<ServiceX3DFieldEvent, B.5.3 X3DFieldEvent>>
** <<Matrix3, B.5.4 Matrix3>>
** <<Matrix4, B.5.5 Matrix4>>
* <<StatementInterfaces, B.6 Statement interfaces>>
** <<ComponentInfo, B.6.1 ComponentInfo>>
** <<ProfileInfo, B.6.2 ProfileInfo>>
* <<ExceptionDefinitions, B.7 Exception definitions>>
** <<ProfileInfo, B.7.1 X3DException>>
** <<BrowserNotSharedException, B.7.2 BrowserNotSharedException>>
** <<ConnectionException, B.7.3 ConnectionException>>
** <<ImportedNodeException, B.7.4 ImportedNodeException>>
** <<InsufficientCapabilitiesException, B.7.5 InsufficientCapabilitiesException>>
** <<InvalidBrowserException, B.7.6 InvalidBrowserException>>
** <<InvalidDocumentException, B.7.7 InvalidDocumentException>>
** <<InvalidExecutionContextException, B.7.8 InvalidExecutionContextException>>
** <<InvalidFieldException, B.7.9 InvalidFieldException>>
** <<InvalidFieldValueException, B.7.10 InvalidFieldValueException>>
** <<InvalidNodeException, B.7.11 InvalidNodeException>>
** <<InvalidOperationTimingException, B.7.12 InvalidOperationTimingException>>
** <<InvalidProtoException, B.7.13 InvalidProtoException>>
** <<InvalidRouteException, B.7.14 InvalidRouteException>>
** <<InvalidURLException, B.7.15 InvalidURLException>>
** <<InvalidX3DException, B.7.16 InvalidX3DException>>
** <<NodeInUseException, B.7.17 NodeInUseException>>
** <<NodeUnavailableException, B.7.18 NodeUnavailableException>>
** <<NoSuchBrowserException, B.7.19 NoSuchBrowserException>>
** <<NotSupportedException, B.7.20 NotSupportedException>>
** <<URLUnavailableException, B.7.21 URLUnavailableException>>

[[Conventions]]
==== B.1.3 Conventions

This annex describes all the known interfaces that represent abstract
node types. It also defines the other types such as interfaces that
represent fields scenes etc. The convention used is to provide the
definition of the class using the Java language syntax as would be seen
in a Java source file.

The naming convention used by to construct interfaces follows these
rules:

* The name of the interface is identical to the abstract type name
* The interface extends interfaces defined by the abstract node type
* Method names use the same name as the field. In addition, a get or set
modifier is prepended and the first letter of the field name is
capitalized. There is two exceptions to this rule - the `+addChildren+`
and `+removeChildren+` methods of the grouping node are left untouched.
* Methods shall be provided to set and get every field of every node
type regardless for initializeOnly and inputOutput access types.
Exceptions shall be declared for the ability to read and write that
field in accordance with the node lifecycle model. inputOnly fields
shall have Setter methods defined, but no getters. OutputOnly fields
shall have getters methods defined, but no setters.
* Fields that are represented by Java primitive value types, setter
methods return the appropriate primitive value.
* Fields that are represented by Java primitive value types, getter
methods take the appropriate primitive value and return void. Optionally
the method may throw an InvalidFieldValue if there is range checking or
other form of validity checking required.
* Fields that represent SFNode data types, there shall be two forms of
the setter method. One form takes the most-derived form of the abstract
type interface as possible (for example X3DMaterialNode for the
setMaterial method of the X3DAppearanceNode interface). The other shall
take an instance of X3DProtoInstance. This second method shall also
declare an exception for the proto instance representing an invalid
field type (the first node of the proto instance does not match the
requirements of this field)
* Fields that represent SFNode data types, the getter shall always
return X3DNode instances. (The user must then determine whether the node
is an X3DProtoInstance or other node type).
* Fields that represent MFNode data types the setter method shall take
an array of X3DNode instances. It shall declare an exception for the any
node isntance that represents a proto instance where that instances
represents an invalid field type (the first node of the proto instance
does not match the requirements of this field)
* Fields that represent an MFNode, the getter method shall take an array
of X3DNode and copy the values into the user-provided array. The return
type shall be void.
* Fields that represent any multi-valued data type, shall have getter
methods that take an array of the appropriate primitive data type that
the user supplies. The implementation then copies the values into that
array. If the array is not big enough for the number of values, an
ArrayIndexOutOfBoundsException may be thrown.
* Fields that represent any multi-valued data type, shall have a method
to request the number of items currently valid in that field. The number
represents the number of items of the data type, not the number of items
in the array. For example, if the MFRotation field says it has 3
elements, the required array length to read the values will need to be
12 (3 * 4 floats per rotation value)
* Fields that represent any multi-valued data type shall have a setter
that takes take an array of the appropriate primitive data type.

Extra convenience methods may be supplied by the interfaces on an
as-desired basis.

[[NodeTypeInterfaces]]
=== B.2 Node type interfaces

[[X3DAppearanceChildNode]]
==== B.2.1 X3DAppearanceChildNode

[source,listing]
----
public interface X3DAppearanceChildNode extends X3DNode {
}
----

[[X3DAppearanceNode]]
==== B.2.2 X3DAppearanceNode

[source,listing]
----
public interface X3DAppearanceNode extends X3DNode {
}
----

[[X3DAudioClipNode]]
==== B.2.3 X3DAudioClipNode

[source,listing]
----
public interface X3DAudioClipNode
    extends X3DTimeDependentNode, X3DUrlObject {

    public String getDescription();

    public void setDescription(String str);

    public float getPitch();

    public void setPitch(float pitch) throws InvalidFieldValueException;

    public double getDuration();

    public getDuration(double time);
}
----

[[X3DBindableNode]]
==== B.2.4 X3DBackgroundNode

[source,listing]
----
public interface X3DBackgroundNode extends X3DBindableNode {

    public int getNumSkyAngle();

    public void getSkyAngle(float[] angles);

    public void setSkyAngle(float[] angles);

    public int getNumGroundAngle();

    public void getGroundAngle(float[] angle);

    public void setGroundAngle(float[] angle);

    public int getNumSkyColor();

    public void getSkyColor(float[] colors);

    public void setSkyColor(float[] colors);

    public int getNumGroundColor();

    public void getGroundColor(float[] color);

    public void setGroundColor(float[] color);
}
----

[[X3DBindableNode]]
==== B.2.5 X3DBindableNode

[source,listing]
----
public interface X3DBindableNode extends X3DChildNode {

    public void setBind(boolean enable);

    public boolean isBound();

    public double getBindTime();
}
----

[[X3DChildNode]]
==== B.2.6 X3DChildNode

[source,listing]
----
public interface X3DChildNode extends X3DNode {
}
----

[[X3DColorNode]]
==== B.2.7 X3DColorNode

[source,listing]
----
public interface X3DColorNode extends X3DGeometricPropertyNode {

    public int getNumColors();

    public int getNumComponents();

    public void setColor(float[] colors);

    public void getColor(float[] color);
}
----

[[X3DComposedGeometryNode]]
==== B.2.8 X3DComposedGeometryNode

[source,listing]
----
public interface X3DComposedGeometryNode extends X3DGeometryNode {

    public X3DNode getColor();

    public void setColor(X3DColorNode node);

    public void setColor(X3DProtoInstance comp)
        throws InvalidFieldValueException;

    public X3DNode getCoord();

    public void setCoord(X3DCoordinateNode node);

    public void setCoord(X3DProtoInstance node)
        throws InvalidFieldValueException;

    public X3DNode getTexCoord();

    public void setTexCoord(X3DTextureCoordinateNode node);

    public void setTexCoord(X3DProtoInstance node)
        throws InvalidFieldValueException;

    public X3DNode getNormal();

    public void setNormal(X3DNormalNode node);

    public void setNormal(X3DProtoInstance node)
        throws InvalidFieldValueException;

    public boolean getIsSolid();

    public void setIsSolid(boolean solid)
        throws InvalidWritableFieldException;

    public boolean getIsCCW();

    public void setIsCCW(boolean ccw);
        throws InvalidWritableFieldException;

    public boolean getColorPerVertex();

    public void setColorPerVertex(boolean perVertex);
        throws InvalidWritableFieldException;

    public boolean getNormalPerVertex();

    public void setNormalPerVertex(boolean perVertex);
        throws InvalidWritableFieldException;
}
----

[[X3DCoordinateNode]]
==== B.2.9 X3DCoordinateNode

[source,listing]
----
public interface X3DCoordinateNode extends X3DGeometricPropertyNode {

    public int getNumCoordinates();

    public void setPoint(float[] points);

    public void getPoint(float[] points);
}
----

[[X3DDragSensorNode]]
==== B.2.10 X3DDragSensorNode

[source,listing]
----
public interface X3DDragSensorNode extends X3DPointingDeviceSensorNode {

    public void setAutoOffset(boolean newAutoOffset);

    public boolean getAutoOffset();

    public void getTrackPoint(float[] point);
}
----

[[X3DEnvironmentalSensorNode]]
==== B.2.11 X3DEnvironmentalSensorNode

[source,listing]
----
public interface X3DEnvironmentalSensorNode extends X3DSensorNode {

    public double getEnterTime();

    public double getExitTime();

    public void getCenter(float[] pos);

    public void setCenter(float[] pos);

    public void getSize(float[] size);

    public void setSize(float[] size);
}
----

[[X3DFontStyleNode]]
==== B.2.12 X3DFontStyleNode

[source,listing]
----
public interface X3DFontStyleNode extends X3DNode {

    public int PLAIN_STYLE = java.awt.Font.PLAIN;
    public int ITALIC_STYLE = java.awt.Font.ITALIC;
    public int BOLD_STYLE = java.awt.Font.BOLD;
    public int BOLDITALIC_STYLE = java.awt.Font.BOLD + java.awt.Font.ITALIC;

    public int BEGIN_JUSTIFY = 1;
    public int END_JUSTIFY = 2;
    public int MIDDLE_JUSTIFY = 3;
    public int FIRST_JUSTIFY = 4;

    public Font getFont();

    public int getHorizontalJustification();

    public int getVerticalJustification();

    public float getSpacing();

    public float getSize();

    public boolean isTopToBottom();

    public boolean isLeftToRight();
}
----

[[X3DGeometricPropertyNode]]
==== B.2.13 X3DGeometricPropertyNode

[source,listing]
----
public interface X3DGeometricPropertyNode extends X3DNode {
}
----

[[X3DGeometryNode]]
==== B.2.14 X3DGeometryNode

[source,listing]
----
public interface X3DGeometryNode extends X3DNode {
}
----

[[X3DGroupingNode]]
==== B.2.15 X3DGroupingNode

[source,listing]
----
public interface X3DGroupingNode extends X3DChildNode, X3DBoundedObject {

    public void getChildren(X3DNode[] nodes);

    public void setChildren(X3DNode[] kids)
        throws InvalidNodeException;

    public void addChildren(X3DNode[] added)
        throws InvalidNodeException;

    public void addChild(X3DNode added)
        throws InvalidNodeException;

    public void removeChildren(X3DNode[] removed)
        throws InvalidNodeException;

    public void removeChild(X3DNode removed)
        throws InvalidNodeException;

    public int getNumChildren();
}
----

[[X3DInfoNode]]
==== B.2.16 X3DInfoNode

[source,listing]
----
public interface X3DInfoNode extends X3DChildNode {
}
----

[[X3DInterpolatorNode]]
==== B.2.17 X3DInterpolatorNode

[source,listing]
----
public interface X3DInterpolatorNode extends X3DChildNode {
    public void setFraction(float value);

    public int getNumKeys();

    public void setKey(float[] keys);

    public void getKey(float[] keys);
}
----

[[X3DKeyDeviceSensorNode]]
==== B.2.18 X3DKeyDeviceSensorNode

[source,listing]
----
public interface X3DKeyDeviceSensorNode extends X3DSensorNode {
}
----

[[X3DLightNode]]
==== B.2.19 X3DLightNode

[source,listing]
----
public interface X3DLightNode extends X3DChildNode {

    public boolean getOn();

    public void setOn(boolean state);

    public float getAmbientIntensity();

    public void setAmbientIntensity(float intensity)
        throws InvalidFieldValueException;

    public void getColor(float[] color);

    public void setColor(float[] color)
        throws InvalidFieldValueException;

    public float getIntensity();

    public void setIntensity(float newIntensity)
        throws InvalidFieldValueException;
}
----

[[X3DMaterialNode]]
==== B.2.20 X3DMaterialNode

[source,listing]
----
public interface X3DMaterialNode extends X3DAppearanceChildNode {
}
----

[[X3DNetworkSensorNode]]
==== B.2.21 X3DNetworkSensorNode

[source,listing]
----
public interface X3DNetworkSensorNode extends X3DSensorNode {
}
----

[[X3DNode]]
==== B.2.22 X3DNode

[source,listing]
----
public interface X3DNode extends X3DMetadataObject {

    public String getNodeName()
      throws InvalidNodeException;

    public X3DFieldDefinition[] getFieldDefinitions()
        throws InvalidNodeException;

    public void realize()
        throws InvalidNodeException;

    public boolean isRealized()
        throws InvalidNodeException;

    public int[] getNodeType()
        throws InvalidNodeException;

    public X3DField getField(String name)
        throws InvalidFieldException, InvalidNodeException;

    public void dispose()
      throws InvalidNodeException;
}
----

[[X3DNormalNode]]
==== B.2.23 X3DNormalNode

[source,listing]
----
public interface X3DNormalNode extends X3DGeometricPropertyNode {

    public int getNumNormals();

    public void setVector(float[] value);

    public void getVector(float[] value);
}
----

[[X3DParametricGeometryNode]]
==== B.2.24 X3DParametricGeometryNode

[source,listing]
----
public interface X3DParametricGeometryNode extends X3DGeometryNode {
}
----

[[X3DPointingDeviceSensorNode]]
==== B.2.25 X3DPointingDeviceSensorNode

[source,listing]
----
public interface X3DPointingDeviceSensorNode extends X3DSensorNode {
}
----

[[X3DProtoInstance]]
==== B.2.26 X3DProtoInstance

[source,listing]
----
public interface X3DProtoInstance extends X3DNode {
    public int[] getImplementationTypes();
}
----

[[X3DScriptNode]]
==== B.2.27 X3DScriptNode

[source,listing]
----
public interface X3DScriptNode
    extends X3DChildNode, X3DUrlObject {
}
----

[[X3DSensorNode]]
==== B.2.28 X3DSensorNode

[source,listing]
----
public interface X3DSensorNode extends X3DChildNode {
    public void setEnabled(boolean state);

    public boolean getEnabled();

    public boolean getIsActive();
}
----

[[X3DSequencerNode]]
==== B.2.29 X3DSequencerNode

[source,listing]
----
public interface X3DSequencerNode extends X3DChildNode {
    public void setFraction(float fraction);

    public int getNumKey();

    public void getKey(float[] keys);

    public void setKey(float[] keys);

    public int getNumKeyValue();
}
----

[[X3DShapeNode]]
==== B.2.30 X3DShapeNode

[source,listing]
----
public interface X3DShapeNode extends X3DChildNode {

    public X3DNode getAppearance();

    public void setAppearance(X3DAppearanceNode app);

    public void setAppearance(X3DProtoInstance app);

    public X3DNode getGeometry();

    public void setGeometry(X3DGeometryNode geom);

    public void setGeometry(X3DProtoInstance geom);
}
----

[[X3DSoundNode]]
==== B.2.31 X3DSoundNode

[source,listing]
----
public interface X3DSoundNode extends X3DChildNode {
}
----

[[X3DSoundSourceNode]]
==== B.2.32 X3DSoundSourceNode

[source,listing]
----
public interface X3DSoundSourceNode extends X3DTimeDependentNode {

    public float getPitch();

    public void setPitch(float pitch) throws InvalidFieldValueException;

    public void setDescription(String text);

    public String getDescription(String text);
}
----

[[X3DTextNode]]
==== B.2.33 X3DTextNode

[source,listing]
----
public interface X3DTextNode extends X3DGeometryNode {

    public void setFontStyle(X3DFontStyleNode fs);

    public void setFontStyle(X3DProtoInstance fs);

    public X3DNode getFontStyle();

    public int getNumText();

    public void setText(String[] text);

    public void getText(String[] text);
}
----

[[X3DTextureCoordinateNode]]
==== B.2.34 X3DTextureCoordinateNode

[source,listing]
----
public interface X3DTextureCoordinateNode extends X3DGeometricPropertyNode {

    public int getNumCoordinates();

    public int getNumComponents();

    public void setPoint(float[] points);

    public void getPoint(float[] points);
}
----

[[X3DTextureNode]]
==== B.2.35 X3DTextureNode

[source,listing]
----
public interface X3DTextureNode extends X3DAppearanceChildNode {
}
----

[[X3DTexture2DNode]]
==== B.2.36 X3DTexture2DNode

[source,listing]
----
public interface X3DTexture2DNode extends X3DTextureNode {

    public void setRepeatS(boolean state);

    public boolean getRepeatS();

    public void setRepeatT(boolean state);

    public boolean getRepeatT();
}
----

[[X3DTextureTransformNode]]
==== B.2.37 X3DTextureTransformNode

[source,listing]
----
public interface X3DTextureTransformNode extends X3DAppearanceChildNode {
}
----

[[X3DTextureTransform2DNode]]
==== B.2.38 X3DTextureTransform2DNode

[source,listing]
----
public interface X3DTextureTransform2DNode extends X3DTextureTransformNode {
    public void getCenter(float[] position);

    public void setCenter(float[] position);

    public float getRotation();

    public void setRotation(float angle);

    public void getScale(float[] scale);

    public void setScale(float[] scale);

    public void getTranslation(float[] trans);

    public void setTranslation(float[] trans);
}
----

[[X3DTimeDependentNode]]
==== B.2.39 X3DTimeDependentNode

[source,listing]
----
public interface X3DTimeDependentNode extends X3DChildNode {

    public boolean getIsActive();

    public boolean getIsPaused();

    public double getElapsedTime();

    public void setNumLoops(float count);

    public float getNumLoops();

    public void setLoop(boolean loop);

    public boolean getLoop();

    public void setStartTime(double time);

    public double getStartTime();

    public void setStopTime(double time);

    public double getStopTime();

    public void setPauseTime(double time);

    public double getPauseTime();

    public void setUnPauseTime(double time);

    public double getUnPauseTime();
}
----

[[X3DTouchSensorNode]]
==== B.2.40 X3DTouchSensorNode

[source,listing]
----
public interface X3DTouchSensorNode
    extends X3DPointingDeviceSensorNode {

    public boolean getIsOver();

    public double getEnterTime();

    public double getTouchTime();
}
----

[[X3DTriggerNode]]
==== B.2.41 X3DTriggerNode

[source,listing]
----
public interface X3DTriggerNode
    extends X3DChildNode {
}
----

[[AuxiliaryNodeTypeInterfaces]]
=== B.3 Auxiliary node type interfaces

[[X3DBoundedObject]]
==== B.3.1 X3DBoundedObject

[source,listing]
----
public interface X3DBoundedObject {
}
----

[[X3DMetadataObject]]
==== B.3.2 X3DMetadataObject

[source,listing]
----
public interface X3DMetadataObject {
    public void setMetadata(X3DMetadataObject data);

    public X3DMetadataObject getMetadata();

    public void setStandard(String std);

    public String getStandard();

    public void setName(String name);

    public String getName();
}
----

[[X3DUrlObject]]
==== B.3.3 X3DUrlObject

[source,listing]
----
public interface X3DUrlObject {
    public int getNumUrls();

    public void getUrl(String[] urls);

    public void setUrl(String[] urls);
}
----

[[FieldInterfaces]]
=== B.4 Field interfaces

[[X3DFieldTypes]]
==== B.4.1 X3DFieldTypes

[source,listing]
----
public interface X3DFieldTypes {

    public int INPUT_ONLY = 1;
    public int INITIALIZE_ONLY = 2;
    public int INPUT_OUTPUT = 3;
    public int OUTPUT_ONLY = 4;

    public int SFBOOL = 1;
    public int MFBOOL = 2;
    public int SFCOLOR = 21;
    public int MFCOLOR = 22;
    public int SFCOLORRGBA = 23;
    public int MFCOLORRGBA = 24;
    public int SFDOUBLE = 7;
    public int MFDOUBLE = 8;
    public int SFFLOAT = 5;
    public int MFFLOAT = 6;
    public int SFIMAGE = 25;
    public int MFIMAGE = 26;
    public int SFINT32 = 3;
    public int MFINT32 = 4;
    public int SFNODE = 11;
    public int MFNODE = 12;
    public int SFROTATION = 19;
    public int MFROTATION = 20;
    public int SFSTRING = 27;
    public int MFSTRING = 28;
    public int SFTIME = 9;
    public int MFTIME = 10;
    public int SFVEC2F = 13;
    public int MFVEC2F = 14;
    public int SFVEC3F = 15;
    public int MFVEC3F = 16;
    public int SFVEC3D = 17;
    public int MFVEC3D = 18;
}
----

[[X3DFieldEvent]]
==== B.4.2 X3DFieldEvent

[source,listing]
----
public class X3DFieldEvent extends java.util.EventObject {

    public X3DFieldEvent(Object src, double ts, Object data);

    public double getTime();

    public Object getData();
}
----

[[X3DFieldEventListener]]
==== B.4.3 X3DFieldEventListener

[source,listing]
----
public interface X3DFieldEventListener extends java.util.EventListener {
    public void readableFieldChanged(X3DFieldEvent evt);
}
----

[[X3DFieldDefinition]]
==== B.4.4 X3DFieldDefinition

[source,listing]
----
public interface X3DFieldDefinition {

    public String getName();

    public int getAccessType();

    public int getFieldType();

    public String getFieldTypeString();
}
----

[[X3DField]]
==== B.4.5 X3DField

[source,listing]
----
public interface X3DField {

    public X3DFieldDefinition getDefinition();

    public boolean isReadable();

    public boolean isWritable();

    public void addX3DEventListener(X3DFieldEventListener l);

    public void removeX3DEventListener(X3DFieldEventListener l);

    public void setUserData(Object data);

    public Object getUserData();
}
----

[[MField]]
==== B.4.6 MField

[source,listing]
----
public interface MField extends X3DField {

    public int size();

    public void clear();

    public void remove(int index);
}
----

[[SFBool]]
==== B.4.7 SFBool

[source,listing]
----
public interface SFBool extends X3DField {

    public boolean getValue();

    public void setValue(boolean value);
}
----

[[MFBool]]
==== B.4.8 MFBool

[source,listing]
----
public interface MFBool extends MField {

    public void getValue(boolean[] vals);

    public boolean get1Value(int index);

    public void setValue(int size, boolean[] value);

    public void set1Value(int index, boolean value)
        throws ArrayIndexOutOfBoundsException;

    public void append(boolean value);

    public void insertValue(int index, boolean value);
}
----

[[SFColor]]
==== B.4.9 SFColor

[source,listing]
----
public interface SFColor extends X3DField {

    public void getValue(float[] value);

    public void setValue(float[] value);
}
----

[[MFColor]]
==== B.4.10 MFColor

[source,listing]
----
public interface MFColor extends MField {

    public void getValue(float[][] value);

    public void getValue(float[] value);

    public void get1Value(int index, float[] value);

    public void setValue(int numColors, float[] value);

    public void setValue(int numColors, float[][] value);

    public void set1Value(int index, float[] value);

    public void append(float[] value);

    public void insertValue(int index, float[] value);
}
----

[[SFColorRGBA]]
==== B.4.11 SFColorRGBA

[source,listing]
----
public interface SFColorRGBA extends X3DField {

    public void getValue(float[] value);

    public void setValue(float[] value);
}
----

[[MFColorRGBA]]
==== B.4.12 MFColorRGBA

[source,listing]
----
public interface MFColorRGBA extends MField {

    public void getValue(float[][] value);

    public void getValue(float[] value);

    public void get1Value(int index, float[] value);

    public void setValue(int numColors, float[] value);

    public void setValue(int numColors, float[][] value);

    public void set1Value(int index, float[] value);

    public void append(float[] value);

    public void insertValue(int index, float[] value);
}
----

[[SFDouble]]
==== B.4.13 SFDouble

[source,listing]
----
public interface SFDouble extends X3DField {

    public double getValue();

    public void setValue(double value);
}
----

[[MFDouble]]
==== B.4.14 MFDouble

[source,listing]
----
public interface MFDouble extends MField {

    public void getValue(double[] values);

    public double get1Value(int index)
        throws ArrayIndexOutOfBoundsException;

    public void setValue(int size, double[] value);

    public void set1Value(int index, double value)
        throws ArrayIndexOutOfBoundsException;

    public void append(double[] value);

    public void insertValue(int index, double[] value);
}
----

[[SFFloat]]
==== B.4.15 SFFloat

[source,listing]
----
public interface SFFloat extends X3DField {

    public float getValue();

    public void setValue(float value);
}
----

[[MFFloat]]
==== B.4.16 MFFloat

[source,listing]
----
public interface MFFloat extends MField {

    public void getValue(float[] values);

    public float get1Value(int index)
        throws ArrayIndexOutOfBoundsException;

    public void setValue(int size, float[] value);

    public void set1Value(int index, float value)
        throws ArrayIndexOutOfBoundsException;

    public void append(float[] value);

    public void insertValue(int index, float[] value);
}
----

[[SFImage]]
==== B.4.17 SFImage

[source,listing]
----
public interface SFImage extends X3DField {

    public int getWidth();

    public int getHeight();

    public int getComponents();

    public void getPixels(int[] pixels);

    public java.awt.image.WritableRenderedImage getImage();


    public void setValue(int width,
                         int height,
                         int components,
                         int[] pixels);

    public void setImage(java.awt.image.RenderedImage image);

    public void setSubImage(java.awt.image.RenderedImage image,
                            int srcWidth,
                            int srcHeight,
                            int srcXOffset,
                            int srcYOffset,
                            int destXOffset,
                            int destYOffset);
}
----

[[MFImage]]
==== B.4.18 MFImage

[source,listing]
----
public interface MFImage extends MField {

    public int getWidth(int imgIndex);

    public int getHeight(int imgIndex);

    public int getComponents(int imgIndex);

    public void getPixels(int imgIndex, int[] pixels);

    public WritableRenderedImage getImage(int imgIndex);

    public void setImage(int imgIndex, RenderedImage img);

    public void setSubImage(int imgIndex,
                            RenderedImage img,
                            int srcWidth,
                            int srcHeight,
                            int srcXOffset,
                            int srcYOffset,
                            int destXOffset,
                            int destYOffset);

    public void set1Value(int index, int value);

    public void set1Value(int imgIndex,
                          int width,
                          int height,
                          int components,
                          int[] pixels);

    public void setValue(int[] value);

    public void setImage(RenderedImage[] img);

    public void append(RenderedImage value);

    public void insertValue(int index, RenderedImage value);
----

[[SFInt32]]
==== B.4.19 SFInt32

[source,listing]
----
public interface SFInt32 extends X3DField {

    public int getValue();

    public void setValue(int value);
}
----

[[MFInt32]]
==== B.4.20 MFInt32

[source,listing]
----
public interface MFInt32 extends MField {

    public void getValue(int[] values);

    public int get1Value(int index)
        throws ArrayIndexOutOfBoundsException;

    public void setValue(int size, int[] value);

    public void set1Value(int index, int value)
        throws ArrayIndexOutOfBoundsException;

    public void append(int[] value);

    public void insertValue(int index, int[] value);
}
----

[[SFNode]]
==== B.4.21 SFNode

[source,listing]
----
public interface SFNode extends X3DField {

    public X3DNode getValue();

    public void setValue(X3DNode value)
      throws InvalidNodeException;
}
----

[[MFNode]]
==== B.4.22 MFNode

[source,listing]
----
public interface MFNode extends MField {

    public void getValue(X3DNode[] nodes);

    public X3DNode get1Value(int index);

    public void setValue(int size, X3DNode[] value);

    public void set1Value(int index, X3DNode value);

    public void append(X3DNode value);

    public void insertValue(int index, X3DNode value);
}
----

[[SFRotation]]
==== B.4.23 SFRotation

[source,listing]
----
public interface SFRotation extends X3DField {

    public void getValue(float[] value);

    public void setValue(float[] value);
}
----

[[MFRotation]]
==== B.4.24 MFRotation

[source,listing]
----
public interface MFRotation extends MField {

    public void getValue(float[][] value);

    public void getValue(float[] value);

    public void get1Value(int index, float[] value);

    public void setValue(int numRotations, float[] value);

    public void setValue(int numRotations, float[][] value);

    public void set1Value(int index, float[] value);

    public void append(float[] value);

    public void insertValue(int index, float[] value);
}
----

[[SFString]]
==== B.4.25 SFString

[source,listing]
----
public interface SFString extends X3DField {

    public String getValue();

    public void setValue(String value);
}
----

[[MFString]]
==== B.4.26 MFString

[source,listing]
----
public interface MFString extends MField {

    public void getValue(String[] value);

    public String get1Value(int index);

    public void setValue(int numStrings, String[] value);

    public void set1Value(int index, String value);

    public void append(String[] value);

    public void insertValue(int index, String[] value);
}
----

[[SFTime]]
==== B.4.27 SFTime

[source,listing]
----
public interface SFTime extends X3DField {

    public double getValue();

    public long getJavaValue();

    public void setValue(double value);

    public void setValue(long value);
}
----

[[MFTime]]
==== B.4.28 MFTime

[source,listing]
----
public interface MFTime extends MField {

    public void getValue(double[] value);

    public double get1Value(int index);

    public long get1JavaValue(int index);

    public void setValue(int size, double[] value);

    public void setValue(int size, long[] value);

    public void set1Value(int index, double value);

    public void set1Value(int index, long value);

    public void append(double value);

    public void append(long value);

    public void insertValue(int index, long value);

    public void insertValue(int index, double value);
}
----

[[SFVec2d]]
==== B.4.29 SFVec2d

[source,listing]
----
public interface SFVec2d extends X3DField {

    public void getValue(double[] value);

    public void setValue(double[] value);
}
----

[[MFVec2d]]
==== B.4.30 MFVec2d

[source,listing]
----
public interface MFVec2d extends MField {

    public void getValue(double[][] value);

    public void getValue(double[] value);

    public void get1Value(int index, double[] value);

    public void setValue(int size, double[] value);

    public void setValue(int size, double[][] value);

    public void set1Value(int index, double[] value);

    public void append(double[] value);

    public void insertValue(int index, double[] value);
}
----

[[SFVec2f]]
==== B.4.31 SFVec2f

[source,listing]
----
public interface SFVec2f extends X3DField {

    public void getValue(float[] value);

    public void setValue(float[] value);
}
----

[[MFVec2f]]
==== B.4.32 MFVec2f

[source,listing]
----
public interface MFVec2f extends MField {

    public void getValue(float[][] value);

    public void getValue(float[] value);

    public void get1Value(int index, float[] value);

    public void setValue(int size, float[] value);

    public void setValue(int size, float[][] value);

    public void set1Value(int index, float[] value);

    public void append(float[] value);

    public void insertValue(int index, float[] value);
}
----

[[SFVec3d]]
==== B.4.33 SFVec3d

[source,listing]
----
public interface SFVec3d extends X3DField {

    public void getValue(double[] value);

    public void setValue(double[] value);
}
----

[[MFVec3d]]
==== B.4.34 MFVec3d

[source,listing]
----
public interface MFVec3d extends MField {

    public void getValue(double[][] value);

    public void getValue(double[] value);

    public void get1Value(int index, double[] value);

    public void setValue(int size, double[] value);

    public void setValue(int size, double[][] value);

    public void set1Value(int index, double[] value);

    public void append(double[] value);

    public void insertValue(int index, double[] value);
}
----

[[SFVec3f]]
==== B.4.35 SFVec3f

[source,listing]
----
public interface SFVec3f extends X3DField {

    public void getValue(float[] value);

    public void setValue(float[] value);
}
----

[[MFVec3f]]
==== B.4.36 MFVec3f

[source,listing]
----
public interface MFVec3f extends MField {

    public void getValue(float[][] value);

    public void getValue(float[] value);

    public void get1Value(int index, float[] value);

    public void setValue(int size, float[] value);

    public void setValue(int size, float[][] value);

    public void set1Value(int index, float[] value);

    public void append(float[] value);

    public void insertValue(int index, float[] value);
}
----

[[ServiceInterfaces]]
=== B.5 Service interfaces

[[BrowserEvent]]
==== B.5.1 BrowserEvent

[source,listing]
----
public class BrowserEvent extends EventObject {
    public static final int INITIALIZED = 0;
    public static final int SHUTDOWN = 1;
    public static final int URL_ERROR = 2;
    public static final int CONNECTION_ERROR = 10;
    public static final int LAST_IDENTIFIER = 100;

    public BrowserEvent(Object browser, int action);
    public int getID();
}
----

[[BrowserFactory]]
==== B.5.2 BrowserFactory

[source,listing]
----
public class BrowserFactory {
    private BrowserFactory();

    public static void setBrowserFactoryImpl(
        BrowserFactoryImpl fac)
        throws IllegalArgumentException,
               X3DException,
               SecurityException;

    public static X3DComponent createX3DComponent(Map params)
        throws NotSupportedException;

    public static ExternalBrowser getBrowser(Applet applet)
        throws NotSupportedException,
               NoSuchBrowserException,
               ConnectionException;

    public static ExternalBrowser getBrowser(Applet applet,
                                             String frameName,
                                             int index)
        throws NotSupportedException,
               NoSuchBrowserException,
               ConnectionException;

    public static ExternalBrowser getBrowser(InetAddress address, int port)
        throws NotSupportedException,
               NoSuchBrowserException,
               UnknownHostException,
               ConnectionException;
}
----

[[ServiceX3DFieldEvent]]
==== B.5.3 X3DFieldEvent

[source,listing]
----
public class X3DFieldEvent extends EventObject {
    public X3DFieldEvent(Object src, double ts, Object data);
    public double getTime();
    public Object getData();
}
----

[[Matrix3]]
==== B.5.4 Matrix3

[source,listing]
----
public class Matrix3 {
    public Matrix3();
    public void setIdentity();
    public void set(int row, int column)
    public float get(int row, int column)
    public void setTransform(SFVec2f translation,
                             SFVec3f rotation,
                             SFVec2f scale,
                             SFVec3f scaleOrientation,
                             SFVec2f center)
    public void getTransform(SFVec2f translation,
                             SFVec3f rotation,
                             SFVec2f scale)
    public Matrix3 inverse()
    public Matrix3 transpose()
    public Matrix3 multiplyLeft(Matrix3 mat)
    public Matrix3 multiplyRight(Matrix3 mat)
    public Matrix3 multiplyRowVector(SFVec3f vec)
    public Matrix3 multiplyColVector(SFVec3f vec)
}
----

[[Matrix4]]
==== B.5.5 Matrix4

[source,listing]
----
public class Matrix4 {
    public Matrix4();
    public void setIdentity();
    public void set(int row, int column)
    public float get(int row, int column)
    public void setTransform(SFVec3f translation,
                             SFRotation rotation,
                             SFVec3f scale,
                             SFRotation scaleOrientation,
                             SFVec3f center)
    public void getTransform(SFVec3f translation,
                             SFRotation rotation,
                             SFVec3f scale)
    public Matrix3 inverse()
    public Matrix3 transpose()
    public Matrix3 multiplyLeft(Matrix4 mat)
    public Matrix3 multiplyRight(Matrix4 mat)
    public Matrix3 multiplyRowVector(SFVec3f vec)
    public Matrix3 multiplyColVector(SFVec3f vec)
}
----

[[StatementInterfaces]]
=== B.6 Statement interfaces

[[ComponentInfo]]
==== B.6.1 ComponentInfo

[source,listing]
----
public interface ComponentInfo {
    public String getName();
    public int getLevel();
    public String getTitle();
    public String getProviderURL();
    public String toX3DString();
}
----

[[ProfileInfo]]
==== B.6.2 ProfileInfo

[source,listing]
----
public interface ProfileInfo {
    public String getName();
    public String getTitle();
    public ComponentInfo[] getComponents();
    public String toX3DString();
}
----

[[ExceptionDefinitions]]
=== B.7 Exception definitions

[[X3DException]]
==== B.7.1 X3DException

[source,listing]
----
public class X3DException extends RuntimeException {
    public X3DException();
    public X3DException(String);
}
----

[[BrowserNotSharedException]]
==== B.7.2 BrowserNotSharedException

[source,listing]
----
public class BrowserNotSharedException extends X3DException {
    public BrowserNotSharedException();
    public BrowserNotSharedException(String);
}
----

[[ConnectionException]]
==== B.6.3 ConnectionException

[source,listing]
----
public class ConnectionException extends X3DException {
    public ConnectionException();
    public ConnectionException(String);
}
----

[[ImportedNodeException]]
==== B.6.4 ImportedNodeException

[source,listing]
----
public class ImportedNodeException extends X3DException {
    public ImportedNodeException();
    public ImportedNodeException(String);
}
----

[[InsufficientCapabilitiesException]]
==== B.7.5 InsufficientCapabilitiesException

[source,listing]
----
public class InsufficientCapabilitiesException extends X3DException {
    public InsufficientCapabilitiesException();
    public InsufficientCapabilitiesException(String);
}
----

[[InvalidBrowserException]]
==== B.7.6 InvalidBrowserException

[source,listing]
----
public class InvalidBrowserException extends X3DException {
    public InvalidBrowserException();
    public InvalidBrowserException(String);
}
----

[[InvalidDocumentException]]
==== B.7.7 InvalidDocumentException

[source,listing]
----
public class InvalidDocumentException extends X3DException {
    public InvalidDocumentException();
    public InvalidDocumentException(String);
}
----

[[InvalidExecutionContextException]]
==== B.7.8 InvalidExecutionContextException

[source,listing]
----
public class InvalidExecutionContextException extends X3DException {
    public InvalidExecutionContextException();
    public InvalidExecutionContextException(String);
}
----

[[InvalidFieldException]]
==== B.7.9 InvalidFieldException

[source,listing]
----
public class InvalidFieldException extends X3DException {
    public InvalidFieldException();
    public InvalidFieldException(String);
}
----

[[InvalidFieldValueException]]
==== B.7.10 InvalidFieldValueException

[source,listing]
----
public class InvalidFieldValueException extends X3DException {
    public InvalidFieldValueException();
    public InvalidFieldValueException(String);
}
----

[[InvalidNodeException]]
==== B.7.11 InvalidNodeException

[source,listing]
----
public class InvalidNodeException extends X3DException {
    public InvalidNodeException();
    public InvalidNodeException(String);
}
----

[[InvalidOperationTimingException]]
==== B.7.12 InvalidOperationTimingException

[source,listing]
----
public class InvalidOperationTimingException extends X3DException {
    public InvalidOperationTimingException();
    public InvalidOperationTimingException(String);
}
----

[[InvalidProtoException]]
==== B.7.13 InvalidProtoException

[source,listing]
----
public class InvalidProtoException extends X3DException {
    public InvalidProtoException();
    public InvalidProtoException(String);
}
----

[[InvalidRouteException]]
==== B.7.14 InvalidRouteException

[source,listing]
----
public class InvalidRouteException extends X3DException {
    public InvalidRouteException();
    public InvalidRouteException(String);
}
----

[[InvalidURLException]]
==== B.7.15 InvalidURLException

[source,listing]
----
public class InvalidURLException extends X3DException {
    public InvalidURLException();
    public InvalidURLException(String);
}
----

[[InvalidX3DException]]
==== B.7.16 InvalidX3DException

[source,listing]
----
public class InvalidX3DException extends X3DException {
    public InvalidX3DException();
    public InvalidX3DException(String);
}
----

[[NodeInUseException]]
==== B.7.17 NodeInUseException

[source,listing]
----
public class NodeInUseException extends X3DException {
    public NodeInUseException();
    public NodeInUseException(String);
}
----

[[NodeUnavailableException]]
==== B.7.18 NodeUnavailableException

[source,listing]
----
public class NodeUnavailableException extends X3DException {
    public NodeUnavailableException();
    public NodeUnavailableException(String);
}
----

[[NoSuchBrowserException]]
==== B.7.19 NoSuchBrowserException

[source,listing]
----
public class NoSuchBrowserException extends X3DException {
    public NoSuchBrowserException();
    public NoSuchBrowserException(String);
}
----

[[NotSupportedException]]
==== B.7.20 NotSupportedException

[source,listing]
----
public class NotSupportedException extends X3DException {
    public NotSupportedException();
    public NotSupportedException(String);
}
----

[[URLUnavailableException]]
==== B.7.21 URLUnavailableException

[source,listing]
----
public class URLUnavailableException extends X3DException {
    public URLUnavailableException();
    public URLUnavailableException(String);
}
----

[[concretes]]
== Annex C Concrete node interfaces

interfaces

=== C.1 Introduction and topics

[[Introduction]]
==== C.1.1 Introduction

This annex provides the definition of the rules to generate interface
signature for each interface that represents the concrete node instance
as defined in IS0/IEC 19775-1 (see <<I19775, 2.[19775>>]).

[[Topics]]
==== C.1.2 Topics

See <<TopicsTable, Table C.1>> for the topics in this clause.

[[TopicsTable]]
Table C.1 — Topics

* <<IntroductionAndTOC, C.1 Introduction and Topics>>
** <<Introduction, C.1.1 Introduction>>
** <<Topics, C.1.2 Topic>>
* <<GenerationRules, C.2 Generation rules>>
** <<PackageDefinition, C.2.1 Package definition>>
** <<ClassDefinitions, C.2.2 Class definitions>>
** <<ClassDerivation, C.2.3 Class derivation>>
** <<X3DAudioClipNode, C.2.4 Method declarations>>
* <<Examples, C.3 Examples>>
** <<Group, C.3.1 Group>>
** <<Text, C.3.2 Text>>
** <<ColorInterpolator, C.3.3 ColorInterpolator>>

[[GenerationRules]]
=== C.2 Generation rules

[[PackageDefinition]]
==== C.2.1 Package definition

Each concrete class shall belong to the sub-package name according to
the component formal name under the `+org.web3d.x3d.sai+` parent
package. (See 3.3.1.4 Package Structure)

[[ClassDefinitions]]
==== C.2.2 Class definitions

Concrete node representations in Java shall be expressed as public
interfaces.

[[ClassDerivation]]
==== C.2.3 Class derivation

Each concrete node shall extend the interfaces defined in Annex B as
appropriate for the abstract node requirements for each node type. For
example, The Inline interface definition is:

....
    public interface Inline extends X3DChildNode, X3DBoundedObject, X3DUrlObject {
      ...
    }
....

[[MethodDeclarations]]
==== C.2.4 Method declarations

Within each node interface there shall be methods to read and set the
values for every field. The naming convention for each field method
shall follow the definition in <<Conventions, B.1.2 Conventions>> for
the abstract interfaces. Where fields are already covered by the
abstract interface, the concrete interface is not required to redeclare
the same methods. The concrete interface shall declare methods that are
not defined by the abstract node representation.

[[Examples]]
=== C.3 Examples

[[Group]]
==== C.3.1 Group

No additional field definitions are required because all fields are
covered by the base interfaces.

[source,listing]
----
package org.web3d.x3d.sai.group;

import org.web3d.x3d.sai.*;

public interface Group extends X3DGroupingNode {
}
----

[[Text]]
==== C.3.2 Text

Text is a type of X3DGeometryNode, which does not have any fields
defined in the base node, so all fields must be declared.

[source,listing]
----
package org.web3d.x3d.sai.text;

import org.web3d.x3d.sai.*;

public interface Text extends X3DGeometryNode {
    public void setFontStyle(X3DFontStyleNode node);

    public void setFontStyle(X3DProtoInstance node);

    public X3DNode getFontStyle();

    public void setLength(float[] length);

    public int getNumLength();

    public void getLength(float[] length);

    public void setMaxExtent(float extend);

    public float getMaxExtent();

    public void setString(String[] string);

    public int getNumString();

    public void getString(String[] string);

}
----

[[ColorInterpolator]]
==== C.3.3 ColorInterpolator

Text is a type of X3DInterpolatorNode, which has some fields defined in
the abstract node type as well as some local fields.

[source,listing]
----
package org.web3d.x3d.sai.interpolator;

import org.web3d.x3d.sai.*;

public interface ColorInterpolator extends X3DInterpolatorNode {
    public void setKeyValue(float[] keyValue);

    public int getNumKeyValue();

    public void getKeyValue(float[] keyValue);

    public void getValueChanged(float[] color);
}
----

[[examples]]
== Annex D Examples

[[IntroductionAndTopics]]
=== D.1 Introduction and topics

[[Introduction]]
==== D.1.1 Introduction

This annex provides a variety of X3D examples showing ECMAScript
operations.

[[Topics]]
==== D.1.2 Topics

<<t-Topics, Table D.1>> contains a table of contents that lists the
topics in this clause:

[[t-Topics]]
Table D.1 — Topics in this annex

* <<IntroductionAndTopics, D.1 Introduction and topics>>
** <<Introduction, D.1.1 Introduction>>
** <<Topics, D.1.2 Topics>>
* <<TouchSensorIsOverEvent, D.2 TouchSensor isOver event>>
* <<CreateNodes, D.3 Create nodes>>
* <<PerFrameNotification, D.4 Per frame notification>>
* <<AddDynamicRoutes, D.5 Add dynamic routes>>
* <<CreateNodesFromAPrototype, D.6 Create nodes from prototype>> +


[[TouchSensorIsOverEvent]]
=== D.2 TouchSensor isOver event

This example demonstrates a scripted response to a TouchSensor isOver
event by changing the color of a Box from blue to red:

[source,listing]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd">
<X3D profile="Immersive">
  <head>
    <meta content="TouchSensorIsOverEvent.x3d" name="filename"/>
    <meta content="Xeena VRML importer" name="translator"/>
    <meta content="23 February 2005" name="imported"/>
    <meta content="23 February 2005" name="revised"/>
    <meta
content="X3D-Edit, http://www.web3D.org/TaskGroups/x3d/translation/README.X3D-Edit.html" name="generator"/>
    <meta content="Vrml97ToX3dNist, http://ovrt.nist.gov/v2_x3d.html" name="generator"/>
  </head>
  <Scene>
    <Group>
      <Shape>
        <Appearance>
          <Material DEF="MAT" diffuseColor="0 0 1"/>
        </Appearance>
        <Box/>
      </Shape>
      <TouchSensor DEF="TS"/>
    </Group>
    <Script DEF="SC" url="&quot;SAIExample1.class&quot; ">
      <field accessType="inputOnly" name="isOver" type="SFBool"/>
      <field accessType="outputOnly" name="diffuseColor_changed" type="SFColor"/>
    </Script>
    <ROUTE fromField="isOver" fromNode="TS" toField="isOver" toNode="SC"/>
    <ROUTE fromField="diffuseColor_changed" fromNode="SC"
      toField="set_diffuseColor" toNode="MAT"/>
  </Scene>
</X3D>
----

[source,listing]
----
// Standard imports
import java.util.Map;
// Application specific imports
import org.web3d.x3d.sai.*;

public class SAIExample1
    implements X3DScriptImplementation, X3DFieldEventListener {

    /** Color Constant, RED */
    private static final float[] RED = new float[] {1.0f, 0, 0};

    /** Color Constant, BLUE */
    private static final float[] BLUE = new float[] {0, 0, 1.0f};

    /** A mapping for fieldName(String) to an X3DField object */
    private Map fields;

    /** The isOver field */
    private SFBool isOver;

    /** The diffuseColor_changed field */
    private SFColor diffuseColor;

    //----------------------------------------------------------
    // Methods from the X3DScriptImplementation interface.
    //----------------------------------------------------------
    /**
     * Set the browser instance to be used by this script implementation.
     *
     * @param browser The browser reference to keep
     */
    public void setBrowser(Browser browser) {
    }

    /**
     * Set the listing of fields that have been declared in the file for
     * this node. .
     *
     * @param The external view of ourselves, so you can add routes to yourself
     *    using the standard API calls
     * @param fields The mapping of field names to instances
     */
    public void setFields(X3DScriptNode externalView, Map fields) {
        this.fields = fields;
    }

    /**
     * Notification that the script has completed the setup and should go
     * about its own internal initialization.
     */
    public void initialize() {
        isOver = (SFBool) fields.get("isOver");
        diffuseColor = (SFColor) fields.get("diffuseColor_changed");

        // Listen to events on isOver
        isOver.addX3DEventListener(this);
    }

    /**
     * Notification that this script instance is no longer in use by the
     * scene graph and should now release all resources.
     */
    public void shutdown() {
    }

    /**
     * Notification that all the events in the current cascade have finished
     * processing.
     */
    public void eventsProcessed() {
    }

    //----------------------------------------------------------
    // Methods from the X3DFieldEventListener interface.
    //----------------------------------------------------------

    /**
     * Handle field changes.
     *
     * @param evt The field event
     */
    public void readableFieldChanged(X3DFieldEvent evt) {
        if (evt.getSource() == isOver) {
            if (isOver.getValue() == true)
                diffuseColor.setValue(RED);
            else
                diffuseColor.setValue(BLUE);
        } else {
            System.out.println("Unhandled event: " + evt);
        }
    }
}
----

https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/Examples/TouchSensorIsOverEvent.x3d[Click here] to view this example in a 3D scene window.

[[CreateNodes]]
=== D.3 Create nodes

This example shows using createX3DFromString to create nodes:

[source,listing]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd">
<X3D profile="Immersive">
  <head>
    <meta content="CreateNodes.x3d" name="filename"/>
    <meta content="Xeena VRML importer" name="translator"/>
    <meta content="*enter date of initial version here*" name="created"/>
    <meta content="23 February 2005" name="imported"/>
    <meta content="23 February 2005" name="revised"/>
    <meta content="X3D-Edit, http://www.web3D.org/TaskGroups/x3d/translation/README.X3D-Edit.html" name="generator"/>
    <meta content="Vrml97ToX3dNist, http://ovrt.nist.gov/v2_x3d.html" name="generator"/>
  </head>
  <Scene>
    <Transform DEF="HOLDER" translation="-2.0 0.0 0.0"/>
    <Script DEF="SC" url="SAIExample.class">
      <field accessType="outputOnly" name="children" type="MFNode"/>
    </Script>
    <ROUTE fromField="children" fromNode="SC" toField="children" toNode="HOLDER"/>
  </Scene>
</X3D>
----

[source,listing]
----
// Standard imports
import java.util.Map;

// Application specific imports
import org.web3d.x3d.sai.*;

public class SAIExample2
    implements X3DScriptImplementation {

    /** Color Constant, RED */
    private static final float[] RED = new float[] {1.0f, 0, 0};

    /** A mapping for fieldName(String) to an X3DField object */
    private Map fields;

    /** A reference to the browser */
    private Browser browser;

    /** The field to place the generated nodes via createX3DFromString */
    private MFNode children;

    //----------------------------------------------------------
    // Methods from the X3DScriptImplementation interface.
    //----------------------------------------------------------
    /**
     * Set the browser instance to be used by this script implementation.
     *
     * @param browser The browser reference to keep
     */
    public void setBrowser(Browser browser) {
        this.browser = browser;
    }

    /**
     * Set the listing of fields that have been declared in the file for
     * this node. .
     *
     * @param The external view of ourselves, so you can add routes to yourself
     *    using the standard API calls
     * @param fields The mapping of field names to instances
     */
    public void setFields(X3DScriptNode externalView, Map fields) {
        this.fields = fields;
    }

    /**
     * Notification that the script has completed the setup and should go
     * about its own internal initialization.
     */
    public void initialize() {
        children = (MFNode) fields.get("children");

        // Create nodes directly in the parent scene
        X3DScene scene = (X3DScene) browser.getExecutionContext();

        X3DShapeNode shape = (X3DShapeNode) scene.createNode("Shape");
        X3DGeometryNode box = (X3DGeometryNode) scene.createNode("Box");

        shape.setGeometry(box);
        scene.addRootNode(shape);


        // Create children using the createX3DFromString service
        String vrmlCmd =
            "PROFILE Interchange  Shape { geometry Sphere{} }";

        X3DScene tmpScene = browser.createX3DFromString(vrmlCmd);
        X3DNode[] nodes = tmpScene.getRootNodes();

        // Nodes must be removed before adding to another scene
        for(int i=0; i < nodes.length; i++) {
            tmpScene.removeRootNode(nodes[i]);
        }

        children.setValue(nodes.length,nodes);
    }

    /**
     * Notification that this script instance is no longer in use by the
     * scene graph and should now release all resources.
     */
    public void shutdown() {
    }

    /**
     * Notification that all the events in the current cascade have finished
     * processing.
     */
    public void eventsProcessed() {
    }
}
----

https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/Examples/CreateNodes.x3d[Click here] to view this example in a 3D scene window.

[[PerFrameNotification]]
=== D.4 Per frame notification

This example shows how to use per frame notification to produce a frame
rate annotation:

[source,listing]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "http://www.web3d.org/specifications/x3d-3.0.dtd"
                     "file:///www.web3d.org/TaskGroups/x3d/translation/x3d-3.0.dtd">
<X3D profile="Immersive">
  <head>
    <meta content="PerFrameNotification.x3d" name="filename"/>
    <meta content="Xeena VRML importer" name="translator"/>
    <meta content="23 February 2005" name="imported"/>
    <meta content="23 February 2005" name="revised"/>
    <meta content="X3D-Edit, http://www.web3D.org/TaskGroups/x3d/translation/README.X3D-Edit.html" name="generator"/>
    <meta content="Vrml97ToX3dNist, http://ovrt.nist.gov/v2_x3d.html" name="generator"/>
  </head>
  <Scene>
    <Script DEF="SC" url="&quot;SAIExample3.class&quot; "/>
  </Scene>
</X3D>
----

[source,listing]
----
// Standard imports
import java.util.Map;
// Application specific imports
import org.web3d.x3d.sai.*;

public class SAIExample3
    implements X3DPerFrameObserverScript {

    /** When did the last frame start */
    private long lastStartTime;

    //----------------------------------------------------------
    // Methods from the X3DScriptImplementation interface.
    //----------------------------------------------------------
    /**
     * Set the browser instance to be used by this script implementation.
     *
     * @param browser The browser reference to keep
     */
    public void setBrowser(Browser browser) {
    }

    /**
     * Set the listing of fields that have been declared in the file for
     * this node. .
     *
     * @param The external view of ourselves, so you can add routes to yourself
     *    using the standard API calls
     * @param fields The mapping of field names to instances
     */
    public void setFields(X3DScriptNode externalView, Map fields) {
    }

    /**
     * Notification that the script has completed the setup and should go
     * about its own internal initialization.
     */
    public void initialize() {
        lastStartTime = System.currentTimeMillis();
    }

    /**
     * Notification that this script instance is no longer in use by the
     * scene graph and should now release all resources.
     */
    public void shutdown() {
    }

    /**
     * Notification that all the events in the current cascade have finished
     * processing.
     */
    public void eventsProcessed() {
    }

    //----------------------------------------------------------
    // Methods from the X3DPerFrameObserver interface.
    //----------------------------------------------------------

    /**
     * Start of frame notification.
     */
    public void prepareEvents() {
        float frameTime = (System.currentTimeMillis() - lastStartTime) / 1000f;
        lastStartTime = System.currentTimeMillis();

        float fps = 1.0f / frameTime;
        System.out.println("FPS: " + fps);
    }
}
----

https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/Examples/PerFrameNotification.x3d[Click here] to view this example in a 3D scene window.

[[AddDynamicRoutes]]
=== D.5 Add dynamic routes

This example shows adding dynamic routes:

[source,listing]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd">
<X3D profile="Immersive">
  <Scene>
    <Script DEF="SC" url="SAIExample4.class">
      <field accessType="inputOnly" name="touchTime" type="SFTime"/>
    </Script>
  </Scene>
</X3D>
----

[source,listing]
----
// Standard imports
import java.util.Map;
// Application specific imports
import org.web3d.x3d.sai.*;

public class SAIExample4
    implements X3DScriptImplementation, X3DFieldEventListener {

    /** A mapping for fieldName(String) to an X3DField object */
    private Map fields;

    /** A reference to the browser */
    private Browser browser;

    /** inputOnly touchTime */
    private SFTime touchTime;

    /** initializeOnly selfRef */
    private X3DScriptNode selfRef;

    //----------------------------------------------------------
    // Methods from the X3DScriptImplementation interface.
    //----------------------------------------------------------
    /**
     * Set the browser instance to be used by this script implementation.
     *
     * @param browser The browser reference to keep
     */
    public void setBrowser(Browser browser) {
        this.browser = browser;
    }

    /**
     * Set the listing of fields that have been declared in the file for
     * this node. .
     *
     * @param The external view of ourselves, so you can add routes to yourself
     *    using the standard API calls
     * @param fields The mapping of field names to instances
     */
    public void setFields(X3DScriptNode externalView, Map fields) {
        this.fields = fields;
        selfRef = externalView;
    }

    /**
     * Notification that the script has completed the setup and should go
     * about its own internal initialization.
     */
    public void initialize() {
        touchTime = (SFTime) fields.get("touchTime");

        // Listen to events on touchTime
        touchTime.addX3DEventListener(this);

        // Create nodes directly in the parent scene
        X3DScene scene = (X3DScene) browser.getExecutionContext();

        X3DShapeNode shape = (X3DShapeNode) scene.createNode("Shape");
        X3DGeometryNode box = (X3DGeometryNode) scene.createNode("Box");
        X3DNode touchSensor = scene.createNode("TouchSensor");

        shape.setGeometry(box);

        // Create a Group to hold the nodes
        X3DGroupingNode group = (X3DGroupingNode) scene.createNode("Group");

        // Add the shape and sensor to the group
        group.addChild(shape);
        group.addChild(touchSensor);

        // Add the nodes to the scene
        scene.addRootNode(group);

        // Get a handle to the toplevel execution context
        scene.addRoute(touchSensor,"touchTime", selfRef, "touchTime");
    }

    /**
     * Notification that this script instance is no longer in use by the
     * scene graph and should now release all resources.
     */
    public void shutdown() {
    }

    /**
     * Notification that all the events in the current cascade have finished
     * processing.
     */
    public void eventsProcessed() {
    }

    //----------------------------------------------------------
    // Methods from the X3DFieldEventListener interface.
    //----------------------------------------------------------

    /**
     * Handle field changes.
     *
     * @param evt The field event
     */
    public void readableFieldChanged(X3DFieldEvent evt) {
        if (evt.getSource() == touchTime) {
            System.out.println("Poke!");
        } else {
            System.out.println("Unhandled event: " + evt);
        }
    }
}
----

https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/Examples/AddDynamicRoutes.x3d[Click here] to view this example in a 3D scene window.

[[CreateNodesFromAPrototype]]
=== D.6 Create nodes from a prototype

This example shows creation of nodes from a prototype:

[source,listing]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd">
<X3D profile="Immersive">
  <Scene>
    <ProtoDeclare name="ColoredSphere">
      <ProtoInterface>
        <field accessType="initializeOnly" name="color" type="SFColor" value="0.0 0.0 0.0"/>
      </ProtoInterface>
      <ProtoBody>
        <Shape>
          <Appearance>
            <Material>
              <IS>
                <connect nodeField="diffuseColor" protoField="color"/>
              </IS>
            </Material>
          </Appearance>
          <Sphere/>
        </Shape>
      </ProtoBody>
    </ProtoDeclare>
    <Script DEF="SC" url="SAIExample5.class"/>
  </Scene>
</X3D>
----

[source,listing]
----
// Standard imports
import java.util.Map;
// Application specific imports
import org.web3d.x3d.sai.*;

public class SAIExample5
    implements X3DScriptImplementation {

    /** Color Constant, RED */
    private static final float[] RED = new float[] {1.0f, 0, 0};

    /** A mapping for fieldName(String) to an X3DField object */
    private Map fields;

    /** A reference to the browser */
    private Browser browser;

    /** The field to place the generated nodes via createX3DFromString */
    private MFNode children;

    //----------------------------------------------------------
    // Methods from the X3DScriptImplementation interface.
    //----------------------------------------------------------
    /**
     * Set the browser instance to be used by this script implementation.
     *
     * @param browser The browser reference to keep
     */
    public void setBrowser(Browser browser) {
        this.browser = browser;
    }

    /**
     * Set the listing of fields that have been declared in the file for
     * this node. .
     *
     * @param The external view of ourselves, so you can add routes to yourself
     *    using the standard API calls
     * @param fields The mapping of field names to instances
     */
    public void setFields(X3DScriptNode externalView, Map fields) {
        this.fields = fields;
    }

    /**
     * Notification that the script has completed the setup and should go
     * about its own internal initialization.
     */
    public void initialize() {
        // Create nodes directly in the parent scene
        X3DScene scene = (X3DScene) browser.getExecutionContext();

        // Create protoInstance nodes

        // Get the proto declaration declared in the main scene
        X3DProtoDeclaration protoDecl = scene.getProto("ColoredSphere");

        // Create a new instance of this proto
        X3DProtoInstance instance = protoDecl.createInstance();

        // Get the color field and set it to red
        SFColor color = (SFColor) instance.getField("color");
        color.setValue(RED);

        // Add the created proto instance to the scene
        scene.addRootNode(instance);
    }

    /**
     * Notification that this script instance is no longer in use by the
     * scene graph and should now release all resources.
     */
    public void shutdown() {
    }

    /**
     * Notification that all the events in the current cascade have finished
     * processing.
     */
    public void eventsProcessed() {
    }
}
----

https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/Examples/CreateNodesFromPrototype.x3d[Click here] to view this example in a 3D scene window.
