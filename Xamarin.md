
# XAML 可扩展应用标记语言
- [Quick Start Single-Page](https://docs.microsoft.com/zh-cn/xamarin/get-started/quickstarts/single-page)
- [Quick Start Multi-Page](https://docs.microsoft.com/en-us/xamarin/get-started/quickstarts/multi-page)
- [XAML Overview](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/)
- [Xamarin.Forms tutorials](https://docs.microsoft.com/en-us/xamarin/get-started/tutorials/)
- [XAML Hot Reload for Xamarin.Forms](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/hot-reload)
- [XAML Namespaces in Xamarin.Forms](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/namespaces)
- [XAML Code Samples](https://docs.microsoft.com/en-us/samples/browse/?languages=csharp%2Cxaml)
- []()


XAML - Extensible Application Markup Language 是实现 MVVM - Model View ViewModel 数据驱动编程模式非常好的工具，这是一种能将 UI 和代码很好地解耦的设计模式。在 MVVM 做得比较好的框架，比如 React/Angular/Vue 都是大量用户在使用，可见这是多么成功的编程模式。

目前，WPF、 UWP、 Xamarin 等一众框架都基于 XAML 技术，Xamarin.Forms 4.1+ 支持热重载 XAML Hot Reload，需要 Visual Studio 2019 支持，但是不能执重载事件处理关系的更改。

XAML 相比等价代码的优势：

- XAML 简洁可读性好；
- XML 的层次结构表达了 UI 组件的层次结构；
- XAML 适合手写与适合可视化设计 Visual Designer;

XAML 缺点也明显：

- XAML 不可以写代码；
- XAML 不可以使用循环控制，但可以给 ListView 这样的组件设置 ItemsSource 填充数据以生成组件列表；
- XAML 不可以使用条件处理，但可以通过数绑定中的代码实现；
- XAML 通常不能实例化没有定义无参数构造函数的类；
- XAML 通常不能调用方法；

XAML 与 XML 的一些差异特性：

- 属性元素 Property elements 如 BoxView 的 Color 属性

		<BoxView Color="Aqua"</BoxView>

- 附加属性 Attached properties

		<BoxView>
			<BoxView.Color> Aqua </BoxView.Color>
		</BoxView>

- 标记扩展 Markup extensions


列如，一个单一的页面 MainPage.xaml 有以下代码：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 x:Class="XamarinVS2019.Views.MainPage">
		<StackLayout Margin="10,35,10,10">
			<Label Text="Notes"
				   HorizontalOptions="Center"
				   FontAttributes="Bold" />
			<Editor x:Name="editor"
					Placeholder="Enter your note"
					HeightRequest="100" />
			<Grid>
				<Grid.ColumnDefinitions>
					<ColumnDefinition Width="*" />
					<ColumnDefinition Width="*" />
				</Grid.ColumnDefinitions>
				<Button Text="Save"
						Clicked="OnSaveButtonClicked" />
				<Button Grid.Column="1"
						Text="Delete"
						Clicked="OnDeleteButtonClicked"/>
			</Grid>
		</StackLayout>
	</ContentPage>
<!-- ``` -->


该 XAML 代码中的 `xmlns` 和 `x:Class` 两个属性很重要，分别引入命名空间和定义 XAML 生成类的名字。

以声明的方式定义页面的用户界面的组件对象，用到的组件对象包含用于显示文本的 Label、 用于文本输入的 Editor 以及两个指示应用程序保存或删除文件的 Button 实例。 这两个 Button 实例水平放置在布局组件 Grid 中，而 Label、 Editor 和 Grid 垂直放置在布局组件 StackLayout 中。

ContentPage 是 Xamarin 框架中的基础类型。

所有组件对象在 XAML 中都是以 XML 节点表示，所有属性都有对应的对象类型，由基础架构读取还原成 UI 组件对象。

可以采用多种技术在源 XAML 中保留空格，使最终表示不会受 XAML 处理器空格规范化的影响。
xml:space="preserve" 指定此属性保留元素的空格。

在编译器编译后形成相应的代码类实现，类名由 `x:Class` 指令设定，文件名加以后缀 MainPage.xaml.g.cs，表示 Gernerated 自动生成的，它会实现 InitializeComponent() 方法，这也就是为何可以在配套的 MainPage.xaml.cs 代码中调用此方法而不用去定义 ：

<!-- ```C# -->
	//------------------------------------------------------------------------------
	// <auto-generated>
	//     此代码由工具生成。
	//     运行时版本:4.0.30319.42000
	//
	//     对此文件的更改可能会导致不正确的行为，并且如果
	//     重新生成代码，这些更改将会丢失。
	// </auto-generated>
	//------------------------------------------------------------------------------

	[assembly: global::Xamarin.Forms.Xaml.XamlResourceIdAttribute("XamarinVS2019.Views.MainPage.xaml", "Views/MainPage.xaml", typeof(global::XamarinVS2019.Views.MainPage))]

	namespace XamarinVS2019.Views {
		
		
		[global::Xamarin.Forms.Xaml.XamlFilePathAttribute("Views\\MainPage.xaml")]
		public partial class MainPage : global::Xamarin.Forms.MasterDetailPage {
			
			[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Xamarin.Forms.Build.Tasks.XamlG", "2.0.0.0")]
			private void InitializeComponent() {
				global::Xamarin.Forms.Xaml.Extensions.LoadFromXaml(this, typeof(MainPage));
			}
		}
	}
<!-- ``` -->

配套的 MainPage.xaml.cs 中例如有以下代码：


<!-- ```C# -->
	using System;
	using System.IO;
	using Xamarin.Forms;

	namespace XamarinVS2019.Views
	{
		public partial class MainPage : ContentPage
		{
			string _fileName = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "notes.txt");

			public MainPage()
			{
				InitializeComponent();

				if (File.Exists(_fileName))
				{
					editor.Text = File.ReadAllText(_fileName);
				}
			}

			void OnSaveButtonClicked(object sender, EventArgs e)
			{
				File.WriteAllText(_fileName, editor.Text);
			}

			void OnDeleteButtonClicked(object sender, EventArgs e)
			{
				if (File.Exists(_fileName))
				{
					File.Delete(_fileName);
				}
				editor.Text = string.Empty;
			}
		}
	}
<!-- ``` -->

此代码定义一个 `_fileName` 字段，该字段引用名为 notes.txt 的文件r的路径，而该文件将便笺数据存储在应用程序的本地应用程序数据文件夹中。 如果有文件，则在执行页构造函数时读取文件并将其显示在 Editor 中。 按 Save Button 时，会执行 OnSaveButtonClicked 事件处理程序，它将 Editor 的内容保存到文件中。 按 Delete Button 时，会执行 OnDeleteButtonClicked 事件处理程序，它会删除文件并删除 Editor 中的任何文本。 


运行时 Xamarin.Forms XAML 的实现类加载时，就会执行 LoadFromXaml，这种动态加载能力也会带来性能损耗：

<!-- ```C# -->
	using Xamarin.Forms.Xaml;
	...

	string navigationButtonXAML = "<Button Text=\"Navigate\" />";
	Button navigationButton = new Button().LoadFromXaml(navigationButtonXAML);
	...
	_stackLayout.Children.Add(navigationButton);


	// See the sample for the full XAML string
	string pageXAML = @"<?xml version=\"1.0\" encoding=\"utf-8\"?>
		...
		<Label x:Name=\"monkeyName\"\n />\n</StackLayout>\n</ContentPage>";
	ContentPage page = new ContentPage().LoadFromXaml(pageXAML);

	Label monkeyLabel = page.FindByName<Label>("monkeyName");
	monkeyLabel.Text = "Seated Monkey";
	...
<!-- ``` -->


## XAML & Layout starting 布局
https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/layout
https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/alignment-margins-and-padding-overview
https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.stackpanel?view=netcore-3.1
https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.stacklayout?view=xamarin-forms
https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.flexlayout?view=xamarin-forms


中的布局和 HTML 有相似的内容，如边距、边框、长度、宽度等等，但更多是不同。XAML 中所有属性都是对象，C# 有对应的类型，比如 Style 属性设置的对象，需要先在 XAML 资源区定义样式对象，如要使用 Fill 属性则需要相应的 Brush 类对象或继承对象。

设置左、上、右、下边距为 0、200、-150、100，指定控件的长度和宽度是基本的布局属性，在不指定长宽的条件下，边距可以影响大小：

	<Grid Margin="0,200,-150,100">
		<Button  Width="100" Height="50">MyButton</Button>
	</Grid>

还有 MinWidth MinHeight MaxWidth MaxHeight 等。

和边距设置相似补白属性 Padding="20,6,20,6" 也是按左、上、右、下的数值设置，也可以简单为两组  Padding="24,6" 即左右和上下，还可以设置一组表示四边。

边界宽度设置也类似 BorderThickness，但是边界颜色控制属性只能设置统一的笔刷，如 BorderBrush="AliceBlue"。

用来设置边角圆滑度的 CornerRadius 属性设置一个 CornerRadius 对象实例，其构造函数可以一 Double 或 4 个 Double 值来定义 TopLeft, TopRight, BottomLeft, BottomRight 四角。


在 WPF 中考虑布局时, 必须了解环绕所有元素的边界框。 布局 FrameworkElement 系统所使用的每个都可以被视为一个将其插入到布局中的矩形。 LayoutInformation 类返回元素的布局分配或槽的边界。 矩形的大小通过计算可用屏幕空间、任何约束的大小、特定于布局的属性 (如边距和填充) 以及父Panel元素的单个行为来确定。 处理此数据时, 布局系统能够计算特定Panel的所有子级的位置。 务必记住, 在父元素上定义的大小调整特征，如 Border 会影响其子级。

设置对象垂直 VerticalAlignment 和水平 HorizontalAlignment 对齐方式，可以改变其在容器的对齐位置，不指定则默认 Stretch 扩展到容器边界：

| 对齐属性  | 对齐方式 |
| :------   | :------ |
| Left  | 子元素与父元素的已分配布局空间的左端对齐。 |
| Center    | 子元素与父元素的已分配布局空间的中心对齐，不扩张。 |
| Right | 子元素与父元素的已分配布局空间的右端对齐。 |
| Stretch   | 拉伸子元素以填充父元素的已分配布局空间。 显式 Width 值 Height 和值优先。 |

对象在未指定长宽时，默认就是扩展到容器边界的大小，但如果垂直、水平对齐为 Stretch 之外的对齐方式时，对象的大小就以其内容的大小为准。比如垂直设置剧中，但未设置高度，那么就以内容的最大尺寸为准。

对于 Xamarin 框架，文字可以使用 HorizontalTextAlignment 或 VerticalTextAlignment 进行对齐。和对齐方式相应的是布局属性 VerticalOptions 和 HorizontalOptions，它们设置的 LayoutOptions 结构对象只有 Alignment 和 Expands 两个属性，可选值如下：

| 布局选项  | 作用 |
| :-------- | :-------- |
| Center    | 居中不扩张 |
| CenterAndExpand   | 居中，扩张 |
| End       | 排列到布局的结束位置，不扩张 |
| EndAndExpand  | 排列到布局的结束位置，扩张 |
| Fill      | 填充空间，不留 Padding，不扩张 |
| FillAndExpand | 填充空间，不留 Padding，扩张 |
| Start     | 排列到布局的开始位置，不扩张 |
| StartAndExpand    | 排列到布局的开始位置，扩张 |

在 Xamarin 框架中，组件要通过 HeightRequest 和 WidthRequest 获取高度或宽度，就需要设置合适的布局属性，这些数值是与像素无关的单位，需要在布局设置前提下对组件起修饰作用。

XAML 应用的框架多，应该注意其通用特性的总结。


Grid 布局元素可以设置列数和行数，通过 RowDefinition 和 ColumnDefinition 定义，并放入 Grid.RowDefinitions 或 Grid.ColumnDefinitions 集合中。每行或列指定的尺寸使用像素表达，后可以跟星号表示贪婪占据空间，对于多个贪婪设置，则能填这其前面的数值进行比例分配。

<!-- ```xml -->
	<Grid>
		<Grid.RowDefinitions>
			<RowDefinition Height="20*"/>
			<RowDefinition Height="20*"/>
			<RowDefinition Height="20*"/>
			<RowDefinition/>
		</Grid.RowDefinitions>
		<Grid.ColumnDefinitions>
			<ColumnDefinition Width="30*"/>
			<ColumnDefinition Width="20*"/>
		</Grid.ColumnDefinitions>

		<Button Grid.RowSpan="2" Grid.Column="0" Grid.Row="0" Padding="24,6" 
			VerticalAlignment="Center" HorizontalAlignment="Center">My Button</Button>

		<Label>Enter your first name:</Label>
		<TextBox Grid.Row="0" Grid.Column="1" Name="firstName" Margin="0,5,10,5"/>

		<Label>Enter your last name:</Label>
		<TextBox Grid.Row="1" Grid.Column="1" Name="lastName" Margin="0,5,10,5"/>
	</Grid>
<!-- ``` -->


定义好行列后，就可以在 Grid 布局内的组件上设置所在布局位置：

- `Grid.RowSpan` 指定行数跨度；
- `Grid.Row` 指定所在行号，以 0 索引开始；
- `Grid.ColumnSpan` 指定例数跨度；
- `Grid.Column` 指定所在列号，以 0 索引开始；

如果不指定，默认为 0 行 0 例，如上面的 Label 和 Text Box 都会挤在一起。


布局系统为 Children 集合的每个成员完成两个传递、一个度量值处理和一个排列处理过程。 每个子 Panel 元素都提供 MeasureOverride 自己 ArrangeOverride 的和方法来实现其自己的特定布局行为。

在度量值处理过程中, 将对 Children 集合中的每个成员进行计算。 此过程首先调用 Measure 方法。 此方法在父 Panel 元素的实现中调用, 无需显式调用即可进行布局。

首先, 计算的 UIElement 本机大小属性, Clip 例如和 Visibility。 这会生成一个名 constraintSize 为的值, MeasureCore 该值将传递给。

其次, 会处理在上 FrameworkElement 定义的框架属性, 这会影响 constraintSize 的值。 这些属性通常 UIElement 描述基础的大小调整特征, 例如 Height Width Margin 和 Style。 其中每个属性都可以更改显示元素所需的空间。 MeasureOverride 然后, 将 constraintSize 作为参数调用。


WPF 包含一组从 Panel 派生的元素。 这些 Panel 元素可以实现许多复杂的布局。 例如, 可以通过使用 StackPanel 元素轻松实现堆栈元素, 而使用 Canvas 可以实现更复杂和更自由的流动布局。

下表汇总了可用的布局Panel元素。

| 面板名称  | 描述 |
| :-------  | :------- |
| Canvas    | 定义一个区域, 可在其中通过相对于区域的 Canvas 坐标以显式方式来定位子元素。 |
| DockPanel | 定义一个区域，可在其中使子元素相互水平或垂直排列。 |
| Grid      | 定义由列和行组成的灵活的网格区域。 |
| StackPanel    | 堆叠布局将子元素排列成水平或垂直的一行。 |
| VirtualizingPanel | 为 Panel 虚拟化其子数据集合的元素提供一个框架。 这是一个抽象类。 |
| WrapPanel | 按从左到右的顺序位置定位子元素，在包含框的边缘处将内容切换到下一行。 后续排序按从上到下或从右到左的顺序进行, 具体取决于属性 Orientation 是  StackOrientation.Horizontal 或 Vertical。 |

这些基本的布局背后的布局思维在 XAML 模型中是通用的，如下，WPF 和 Xamarin 的对应布局组件，FlexLayout 是更强大的一种布局：

| WPF       | Xamarin   |
| :------   | :------   |
| System.Windows.Controls.Grid  | Xamarin.Forms.Grid |
| System.Windows.Controls.StackPanel    | Xamarin.Forms.StackLayout |
| System.Windows.Controls.FlexLayout    | Xamarin.Forms.WrapPanel |

Xamarin 还提供更多布局组件选择，如 ItemsLayout/ GridItemsLayout。

以 XAML 代码方式使用 AbsoluteLayout 布局：

	<AbsoluteLayout VerticalOptions="FillAndExpand"
					HorizontalOptions="FillAndExpand">
		<BoxView    AbsoluteLayout.LayoutBounds="0.25, 0.25, 0.5, 0.5"
					Color="Blue"
					AbsoluteLayout.LayoutFlags="All" />
	</AbsoluteLayout>

以 C# 代码方式使用 RelativeLayout 布局：

<!-- ```C# -->
	public class RelativeLayoutExample : ContentPage
	{
		public RelativeLayoutExample ()
		{
			this.Padding = new Thickness (10, Device.OnPlatform (20, 0, 0), 10, 5);
		
			Label heading = new Label {
				Text = "RelativeLayout Example",
				TextColor = Color.Red,
			};
		
			Label relativelyPositioned = new Label {
				Text = "Positioned relative to my parent."
			};
		
			RelativeLayout relativeLayout = new RelativeLayout ();
		
			relativeLayout.Children.Add (heading, Constraint.RelativeToParent ((parent) => {
				return 0;
			}));
		
			relativeLayout.Children.Add (relativelyPositioned,
				Constraint.RelativeToParent ((parent) => {
					return parent.Width / 3;
				}),
				Constraint.RelativeToParent ((parent) => {
					return parent.Height / 2;
				}));
			this.Content = relativeLayout;
		}
	}
<!-- ``` -->


对于需要使用 Panel 任何预定义元素无法实现的布局的应用程序, 可以通过 Panel 继承和重写 MeasureOverride 和 ArrangeOverride 方法来实现自定义布局行为。

布局是一个递归过程。 Children 集合中的每个子元素都将在每次调用布局系统的过程中得到处理。 因此，应避免在不必要时触发布局系统。 

如果依赖属性的值可能导致布局系统被初始化，则会使用公共标志对该依赖属性进行标记。 AffectsMeasure 和 AffectsArrange 提供了一些有用的线索, 其中的属性值更改将强制布局系统进行递归更新。 通常, 任何可能影响元素边界框大小的属性都应将标志 AffectsMeasure 设置为 true。 

如果可能, 请使用 RenderTransform 而不 LayoutTransform 是。

LayoutTransform 会影响内容 UI 是一种非常有用的方法， 但是, 如果变换的效果不必影响其他元素的位置, 则最好 RenderTransform, 因为 RenderTransform 不会调用布局系统。 LayoutTransform 会, 并强制执行递归布局更新以考虑受影响元素的新位置。

避免不必要的 UpdateLayout 调用。

UpdateLayout 方法强制执行递归布局更新, 并且通常不需要这样做。 除非你确定需要进行完整更新，否则请依赖布局系统为你调用此方法。

使用大型 Children 集合时, 请考虑 VirtualizingStackPanel 使用而不是常规 StackPanel。

通过虚拟化子集合, VirtualizingStackPanel 只会将对象保存在当前在父级的视区中。 因此，在大多数情况下，性能得到显著提高。


WPF 图形系统使用与设备无关的单位来实现分辨率和设备独立性。 每个与设备无关的像素会自动调整为系统的每英寸点数 (dpi) 设置。 这为 WPF 应用程序提供了针对不同 dpi 设置的适当缩放, 并使应用程序能够自动识别 dpi。

但是, 这种 dpi 独立性可能会因为抗锯齿而产生不规则边缘渲染。 这些伪影通常被视为模糊或半透明边缘，当边缘的位置落在设备像素的中间而不是设备像素之间时，就可能出现。 布局系统提供了一种通过布局倒圆对此进行调整的方法。 布局舍入是布局系统在布局传递中舍入任何非整数像素值的情况。

默认情况下禁用布局舍入，请使用组件的属性 UseLayoutRounding="True"，FrameworkElement 指定任意事件处理，启用布局舍入。 因为它是一个依赖属性，所以该值将传播到可视化树中的所有子级。 若要为整个 UI 启用布局舍入, 请在 UseLayoutRounding 为 True 根容器上设置为。

	<Label UseLayoutRounding="True" FrameworkElement.SizeChanged="Label_SizeChanged">Enter your last name:</Label>

	private void Label_SizeChanged(object sender, SizeChangedEventArgs e)
	{

	}


## XAML & Event Handlers 
https://docs.microsoft.com/en-us/dotnet/api/system.eventhandler
https://docs.microsoft.com/en-us/dotnet/standard/events/
https://docs.microsoft.com/en-us/dotnet/framework/winforms/event-handlers-overview-windows-forms

编辑 MainPage.xaml，在布局组件，如 `</StackLayout>` 结束之前添加此 XAML：

	<Button Text="Click Me" Clicked="Button_Clicked" />

编辑 MainPage.xaml.cs，将此代码添加到类的末尾：

	int count = 0;
	void Button_Clicked(object sender, System.EventArgs e)
	{
		count++;
		((Button)sender).Text = $"You clicked {count} times.";
	}

在点击按钮时触发 Clicked 指定的事件处理函数。

基本的事件委托对象类型：

<!-- ```C# -->
	public delegate void EventHandler(object sender, EventArgs e);
	public delegate void KeyEventHandler(object sender, KeyEventArgs e);
	public delegate void MouseEventHandler(object sender, MouseEventArgs e);

	this.Click += handler;
	this.Click += new EventHandler(handler);
	this.Click += new MouseEventHandler(handler);
	this.Load += (sender, eventArgs) => Console.WriteLine("Form load");
	this.Load += handler; // also override by OnLoad event handler method
	// private void handler(object sender, EventArgs e)
	// protected override void OnLoad(EventArgs e)
<!-- ``` -->

定义对象的事件，以代码方式调用委托对象的 Invoke 方法触发事件处理函数，注意委托类型的多播用法 Multicast Delegates，即通过 += 号绑定多个 handler，也可以使用 -= 移除已经绑定的 handler：

<!-- ```C# -->
	class Counter
	{
		public event EventHandler ThresholdReached;

		protected virtual void OnThresholdReached(EventArgs e)
		{
			EventHandler handler = ThresholdReached;
			handler?.Invoke(this, e);
		}

		// provide remaining implementation for the class
	}

	class Program
	{
		static void Main()
		{
			var c = new Counter();
			c.ThresholdReached += c_ThresholdReached;

			// provide remaining implementation for the class
		}

		static void c_ThresholdReached(object sender, EventArgs e)
		{
			Console.WriteLine("The threshold was reached.");
		}
	}
<!-- ``` -->

可以继承 EventArgs 对象，扩展出项目需要的事件参数对象：

	public class ThresholdReachedEventArgs : EventArgs
	{
		public int Threshold { get; set; }
		public DateTime TimeReached { get; set; }
	}


事件流程处理上，通常采用观察者模式 Observer Design Pattern，事件出现时发往中心，对某事件关注的一方向中心注册事件处理函数，或者称为订阅事件 Subscribe。事件触发时由中心统一分发事件参数对象到处理函数。上面代码的委托对象的多播，就是注册多事件处理函数的一种方式。一个良好的观察者模式设计，事件只可以由任意的 Provider 供应，由任意的 Observer 订阅。

多事件处理函数的发起处理可以使用 System.ComponentModel.EventHandlerList 实现，可以使用 Dictionary 去记录注册的事件处理函数。

 DoubleClick event occurring, the MouseDown, MouseUp, and Click 


## XAML Markup Extensions
- https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/xaml-basics/xaml-markup-extensions
- https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/resources-wpf
- https://docs.microsoft.com/en-us/xamarin/get-started/quickstarts/deepdive
- https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/markup-extensions/
- https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.Boxview
- https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.color
- https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.label
- https://docs.microsoft.com/zh-cn/windows/uwp/xaml-platform/xaml-overview


在 XAML 中设置组件的属性，根据属性对象类型的不同，有多种方式。简单的有数值或字符串类型，更多的是使用其它对象类型来设置属性。

比如设置颜色，Color 属性设置的是一个提供 RGBA 或 HSL 颜色值的 Color 结构体，它提供灰度、RGB、RGBA 三种构造函数。可以使用 Color 定义好的命名颜色，比如 Color.Red，Color.Blue，直接填名字即可。也可以设置一个十六进制色值字符串，#FF0080 由编译器进行处理成符合 Color 构造函数的参数：

	<BoxView Color="Blue" CornerRadius="16"/>
	<BoxView Color="#FF0080" />
	<BoxView Color="#AARRGGBB"" />
	<BoxView Color="{StaticResource themeColor}" />

设置属性的内嵌标签方式，也就是吸附属性 Attached Properties，使用组件类型加点号，再跟属性名：

	<BoxView>
		<BoxView.Color>
			Aqua
		</BoxView.Color>
	</BoxView>

又比如 Label 组件 VerticalOptions 属性设置的 VerticalOptions 对象类型，它也有两个属性 Alignment 和 Expands，那么也同样适用内嵌标签设置属性的方式：

	<Label>
		...
		<Label.VerticalOptions>
			<LayoutOptions Alignment="Center" />
		</Label.VerticalOptions>
	</Label>

布局中提到的，如 Grid 布局对象，也经常使用这种方式来定义行列：

<!-- ```xml -->
	<Grid>
		<Grid.RowDefinitions>
			<RowDefinition Height="Auto" />
			<RowDefinition Height="*" />
			<RowDefinition Height="100" />
		</Grid.RowDefinitions>
		<Grid.ColumnDefinitions>
			<ColumnDefinition Width="Auto" />
			<ColumnDefinition Width="*" />
			<ColumnDefinition Width="100" />
		</Grid.ColumnDefinitions>
		...
	</Grid>
<!-- ``` -->

每个样式对象 Style 可以包含一系列 Setter 对象，可以设置 Value 属性：

	<ContentPage.Resources>
		<!-- Implicit styles -->
		<Style TargetType="{x:Type Editor}">
			<Setter Property="BackgroundColor"
					Value="{StaticResource AppBackgroundColor}" />
		</Style>
		...
	</ContentPage.Resources>


这些标签的层级结构就是通过组件 Content 和 Children 属性关联的，这两属性在 XAML 中无处不在。

XAML 中所有属性都是对象，C# 有对应的类型，比如 Style 属性设置的对象，需要先在 XAML 资源区定义样式对象，如要使用 Fill 属性则需要相应的 Brush 类对象或继承对象。注意 `<Page.Resources>` 表示在 Page 类上定义资源，如果是在 Window 对象的 XAML 上定义资源，那么就是 `<Window.Resources>`：

<!-- ```xml -->
	<Page.Resources>
		<Style TargetType="Border" x:Key="PageBackground">
		  <Setter Property="Background" Value="Blue"/>
		</Style>

		<SolidColorBrush x:Key="buttonBackground">Yellow</SolidColorBrush>
		<SolidColorBrush x:Key="borderBrush">Red</SolidColorBrush>
		<LinearGradientBrush x:Key="linearGradientBackground" StartPoint="0,0" EndPoint="1,1">
			<GradientStop Color="Blue" Offset="0"></GradientStop>
			<GradientStop Color="White" Offset="0.5"></GradientStop>
			<GradientStop Color="Red" Offset="1"></GradientStop>
		</LinearGradientBrush>

		<ResourceDictionary>
			<Color x:Key="Primary">#2196F3</Color>
			<Color x:Key="Accent">#96d1ff</Color>
			<Color x:Key="LightTextColor">#999999</Color>
		</ResourceDictionary>

		<Style TargetType="TextBlock">
			<Setter Property="HorizontalAlignment" Value="Center" />
			<Setter Property="FontFamily" Value="Comic Sans MS"/>
			<Setter Property="FontSize" Value="14"/>
		</Style>
	</Page.Resources>

	<Border Style="{StaticResource PageBackground}">

	<Path
		Data="M10,100 C 60,0 100,200 150,100 z"
		Fill="{StaticResource linearGradientBackground}"
		Stroke="Black"
		StrokeThickness="2" />

	<Path
		Data="M10,100 C 60,0 100,200 150,100 z"
		Fill="{StaticResource linearGradientBackground}"
		Stroke="Black"
		StrokeThickness="2" >
		<Path.RenderTransform>
			<ScaleTransform ScaleX="3.0" ScaleY="3.0" />
		</Path.RenderTransform>
	</Path>

	<Button Margin="0,10,0,0" Text="Learn more"
			Command="{Binding OpenWebCommand}"
			BackgroundColor="{StaticResource Primary}"
			TextColor="White" />
<!-- ``` -->


资源是可以在应用程序中的不同位置重复使用的对象。 WPF 支持不同类型的资源。 这些资源主要分为两种类型的资源： XAML 资源和资源数据文件。 XAML 资源的示例包括画笔和样式。 资源数据文件是应用程序所需的不可执行的数据文件。

定义资源时设置的 `x:Key` 则此设置密钥先由 `x:Key` 指令分配，或在调用 ResourceDictionary.Add 时作为参数传入，如果资源定义中使用 `<ResourceDictionary>` 组件。




定义好资源后可以通过不同的标记扩展方法来重复使用。

| 扩展标记  | 用法要点 |
| :------   | :------ |
| Binding   | 绑定标记扩展将属性值延迟为数据绑定值，创建中间表达式对象并解释在运行时应用于元素及其绑定的数据上下文。 |
| ColorConvertedBitmap  | 提供一种方法，用于指定没有嵌入的配置文件的位图源。 颜色上下文/配置文件由 URI 指定，与映像源 URI 相同。 |
| ComponentResourceKey  | 定义和引用从外部程序集加载的资源的键，targetTypeName
targetID 分别指定在资源程序集定义的类型名称和资源 ID，ID 类似 x:Key 指令。 使得资源查找可以在程序集中指定目标类型，而不是在程序集或类中指定显式资源字典。 |
| DynamicResource   | 使用推迟资源绑定到属性，该资源的查找行为类似于运行时查找。 |
| RelativeSource    | 指定 RelativeSource 绑定源的属性，以便在绑定标记扩展中使用，或在设置在 XAML 中RelativeSource建立的Binding元素的属性时使用。 |
| StaticResource    | 通过查找对已定义XAML资源的引用为任何属性属性提供一个值。 该资源的查找行为类似于加载时查找，它将查找以前从当前XAML页面的标记加载的资源以及其他应用程序源，并将该资源值生成为运行时对象中的属性值。 |
| TemplateBinding   | 连接某一控件模板中的属性值，使之成为模板化控件上另一个属性的值。 |
| ThemeDictionary   | 为集成第三方控件的自定义控件创作者或应用程序提供一种方法，用于加载要在设置控件样式时使用的特定于主题的资源字典。 |


标记扩展是实现 IMarkupExtension 接口的类，在 XAML 中用很明显的花括号调用。

Data Binding 标记扩展的功能太多了，以致要独立一个章节去介绍它的使用。


ConstraintExpression 约束标记扩展通常和 RelativeLayout 相对定位扩展一起使用，

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 x:Class="XamlSamples.RelativeLayoutPage"
				 Title="RelativeLayout Page">

		<RelativeLayout>

			<!-- Upper left -->
			<BoxView Color="Red"
					 RelativeLayout.XConstraint=
						 "{ConstraintExpression Type=Constant, Constant=0}"
					 RelativeLayout.YConstraint=
						 "{ConstraintExpression Type=Constant, Constant=0}" />
			<!-- Upper right -->
			<BoxView Color="Green"
					 RelativeLayout.XConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Width,
												Factor=1,
												Constant=-40}"
					 RelativeLayout.YConstraint=
						 "{ConstraintExpression Type=Constant, Constant=0}" />
			<!-- Lower left -->
			<BoxView Color="Blue"
					 RelativeLayout.XConstraint=
						 "{ConstraintExpression Type=Constant, Constant=0}"
					 RelativeLayout.YConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Height,
												Factor=1,
												Constant=-40}" />
			<!-- Lower right -->
			<BoxView Color="Yellow"
					 RelativeLayout.XConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Width,
												Factor=1,
												Constant=-40}"
					 RelativeLayout.YConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Height,
												Factor=1,
												Constant=-40}" />

			<!-- Centered and 1/3 width and height of parent -->
			<BoxView x:Name="oneThird"
					 Color="Red"
					 RelativeLayout.XConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Width,
												Factor=0.33}"
					 RelativeLayout.YConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Height,
												Factor=0.33}"
					 RelativeLayout.WidthConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Width,
												Factor=0.33}"
					 RelativeLayout.HeightConstraint=
						 "{ConstraintExpression Type=RelativeToParent,
												Property=Height,
												Factor=0.33}"  />

			<!-- 1/3 width and height of previous -->
			<BoxView Color="Blue"
					 RelativeLayout.XConstraint=
						 "{ConstraintExpression Type=RelativeToView,
												ElementName=oneThird,
												Property=X}"
					 RelativeLayout.YConstraint=
						 "{ConstraintExpression Type=RelativeToView,
												ElementName=oneThird,
												Property=Y}"
					 RelativeLayout.WidthConstraint=
						 "{ConstraintExpression Type=RelativeToView,
												ElementName=oneThird,
												Property=Width,
												Factor=0.33}"
					 RelativeLayout.HeightConstraint=
						 "{ConstraintExpression Type=RelativeToView,
												ElementName=oneThird,
												Property=Height,
												Factor=0.33}"  />
		</RelativeLayout>
	</ContentPage>
<!-- ``` -->

ColorConvertedBitmap 标记扩展 XAML 属性用法：

	<object property="{ColorConvertedBitmap imageSource sourceIIC destinationIIC}" ... />

ComponentResourceKey 标记扩展使用：

<!-- ```xml -->
	<object x:Key="{ComponentResourceKey {x:Type targetTypeName}, targetID}" ... />  

	<object x:Key="{ComponentResourceKey TypeInTargetAssembly={x:Type targetTypeName}, ResourceID=targetID}" ... />  

	<object property="{DynamicResource {ComponentResourceKey {x:Type targetTypeName}, targetID}}" ... />  

	<object property="{DynamicResource {ComponentResourceKey TypeInTargetAssembly={x:Type targetTypeName}, ResourceID=targetID}}" ... />  
<!-- ``` -->

StaticResource 和 DynamicResource 绑定资源的 XAML 属性用法：

	<object property="{StaticResource key}" ... />  
	<object property="{DynamicResource key}" ... />  

资源的 XAML 对象元素用法，直接设置：

	<object>  
	  <object.property>  
		<StaticResource ResourceKey="key" ... />  
		<DynamicResource ResourceKey="key" ... />  
	  </object.property>  
	</object>  



### Markup Extensions
- https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/xaml-overview
- https://docs.microsoft.com/zh-cn/windows/uwp/xaml-platform/x-bind-markup-extension

常用的标记扩展：

- {x:Type someClass} 

	相当 typeof 给属性设置对应类实例的 Type 类型对象，它通常和 C# 的反射技术关联。

- {x:Bind} UWP 专有数据绑定扩展
- {x:Binding ...} 数据绑定
- {x:Reference obj} {x:Reference Name=obje} 在绑定时引用对象
- {x:FontImage } 
- {x:OnIdiom Phone="1", Tablet="2"} 根据不同设备，如 Desktop/TV/Watch 进行设置，对应 Device.Idiom 用法。
- {x:OnPlatform } 平台条件选择扩展
- {x:RelativeSource } 
- {x:DataTemplate } 
- {x:DynamicResource  } 
- {x:StaticResource } 

在不特别说明的情况下，x:Static 和 Static，x:StaticResource 和 StaticResource 这样的绑定表达是等价的。

在 AXML 含 XAML 2009 的 x: 命名空间下还定义了以下功能，包括标记扩展和指令扩展：

- x:Array   Markup Extension
- x:Null    Markup Extension
- x:Static  Markup Extension
- x:Type    Markup Extension

- x:Code Intrinsic XAML Type
- x:XData Intrinsic XAML Type


XAML 属性 Attribute：

- x:Shared  Attribute

- x:load	可使用 x:Load 优化启动、可视化树创建和 XAML 应用的内存使用。

		<object x:Load="True" .../>
		<object x:Load="False" .../>
		<object x:Load="{x:Bind Path.to.a.boolean, Mode=OneWay}" .../>


XAML 指令 Directive：

- x:Arguments Directive
- x:FactoryMethod Directive
- x:Class   为 XAML 页面提供 Code-Behind 类指定代码命名空间和代码类名称。

		<object x:Class="namespace.classname"...>
		...
		</object>

- x:ClassModifier   Directive
- x:FieldModifier

	修改 XAML 编译行为，使指定对象引用的字段被定义有 public 访问权限而不是默认的 private 行为。x:Name 属性还必须在同一元素上进行提供。

		<object x:FieldModifier="public".../>

- x:Key     资源字典最常用的指令，定义一个主键以引用资源；

	XAML 属性使用方法

		<ResourceDictionary>
			<object x:Key="stringKeyValue".../>
		</ResourceDictionary>

	XAML 属性使用方法（隐式 ResourceDictionary）

		<object.Resources>
			<object x:Key="stringKeyValue".../>
		</object.Resources>

- x:Member  Directive
- x:Members Directive
- x:Name    定义一个标识名字，以在 C# 代码中引用 XAML 的组件；
- x:Property    Directive
- x:Subclass    Directive
- x:TypeArguments   Directive
- x:Uid     标识某些元素，将本地化的资源用于组件的一些属性值。

		<Button x:Uid="GoButton" Content="Go"/>


## Data Binding & Markup Extension
- [数据绑定基础知识](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/xaml/xaml-basics/data-binding-basics)
- [Xamarin.Forms 数据绑定](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/data-binding/)
- [From Data Bindings to MVVM](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/xaml-basics/data-bindings-to-mvvm)
- [Passing Constructor Arguments](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/passing-arguments)
- [Bindable Properties](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/bindable-properties)
- [AXML x: Namespace Features](https://docs.microsoft.com/en-us/dotnet/desktop-wpf/xaml-services/namespace-language-features)
- [Type Converters and Markup Extensions for XAML](https://docs.microsoft.com/en-us/dotnet/desktop-wpf/xaml-services/type-converters-and-markup-extensions)
- [WPF XAML Extensions](https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/wpf-xaml-extensions)
- []()


Data Binding 标记扩展用在各种数据绑定场合，允许对两个对象的属性进行链接，以便其中一个对象的更改会导致另一个对象发生变化。这是一个 MVVM 模式中非常有用的工具，而数据绑定可以完全在代码中定义，XAML 提供快捷方式和便利性。

因此， Xamarin.Forms 最重要的标记扩展之一就是数据绑定，所有数据绑定用的标记扩展对象都由 BindingBase 派生而来。

Binding 这种编程方式在 wPF 框架就已经引入使用了，可以查询到 API 文档中，存在同名的 Xamarin.Forms.Binding 和 System.Windows.Forms.Binding 还有 System.Windows.Data.BindingBase，但它们确实是不同用途的绑定工具。

扩展标记是继承 System.Windows.Markup.MarkupExtension 这个虚拟类，以满足 XAML 语法表达以获取数据的特殊类型，比如 x:Static 这个静态标记扩展：

	[System.Windows.Markup.MarkupExtensionReturnType(typeof(System.Object))]
	public class StaticExtension : System.Windows.Markup.MarkupExtension

它就会从 XAML 标记扩展标签中传入的字符串指定的路径信息，去获取数据，返回 Object 类型给绑定的数据的组件属性。

有多个标记扩展是从 WPF 引入使用的：

- Binding Markup Extension
- ColorConvertedBitmap Markup Extension
- ComponentResourceKey Markup Extension
- DynamicResource Markup Extension
- RelativeSource MarkupExtension
- StaticResource Markup Extension
- TemplateBinding Markup Extension
- ThemeDictionary Markup Extension

标记扩展类看作是数据源的处理接口，那么 XAML 的数据绑定语法就相当于数据源接口与 XAML 的中间层规范。

看一看完整的 Xamarin 的 Binding 对象构造函数：

	Binding(String, BindingMode, IValueConverter, Object, String, Object)

BindingBase 为其提供了基础参数定义：

| 参数名称  | 用途        |
| :------   | :------   |
| Converter | y设置绑定时的数据转换器，IValueConverter 接口 |
| ConverterParameter    | 传入转换器的参数 |
| FallbackValue | 保守值，当绑定的对象没有提供有效数据时的替代值 |
| Mode  | 绑定模式 |
| Path  | 绑定对象提供数据的属性路径 |
| Source    | 设置单一绑定源以替代 BindingContext 的继承绑定 |
| StringFormat  | 设置格式化字符串，类似转换器的作用 |
| TargetNullValue   | 当绑定的目标为 null 时提供此值作为边界值 |
| UpdateSourceEventName | Xamarin.Forms 框架平台内部用途 |

BindingMode 枚举对象定义了 5 种绑定模式：

| Default   | 默认模式 |
| OneWay    | 单向，绑定来源值到目标对象 |
| OneWayToSource    | 单向，绑定目标对象的值到来源  |
| TwoWay    | 双向，绑定值在来源对象和目标对象间今流动，那边有变动就往另一边流 |
| OneTime   | 单次，值从来源传到目标，只在 BindingContext 改变时一次有效 |

大多数可绑定属性的默认绑定模式都是 OneWay，但以下属性的默认绑定模式为 TwoWay：

- DatePicker.Date 属性
- Editor、Entry、SearchBar、EntryCell 的 Text 属性
- ListView.IsRefreshing 属性
- MultiPage.SelectedItem 属性
- Picker 的 SelectedIndex 和 SelectedItem 属性
- Slider、Stepper 的 Value 属性
- Switch.IsToggled 属性
- SwitchCell.On 属性
- TimePicker.Time 属性

这些特定属性被定义为 TwoWay 的理由非常充分。



### x:Static Extension

和 StaticResource 标记扩展返回资源定义的对象不同，x:Static 标记扩展用来访问以下内容，它是 AXML 内部固有特性：

- a public static field
- a public static property
- a public constant field
- an enumeration member.

x:Static 标记扩展使用示例：

<!-- ```xml -->
	<Label Text="Hello, XAML!"
		   VerticalOptions="{x:Static LayoutOptions.Start}"
		   HorizontalTextAlignment="{x:Static TextAlignment.Center}"
		   TextColor="{x:Static Color.Aqua}" />
<!-- ``` -->

x:Static 标记扩展这种能力是在 XAML 命名空间引入的，注意 XAML 文档的开头引入的 xmlns:x，它表示用 x 命名空间引用对应的 XAML 规范：

	xmlns="http://xamarin.com/schemas/2014/forms"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"

通常还使用 .NET 的命名空间，如列子中的 local 和 sys ：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:local="clr-namespace:XamlSamples"
				 xmlns:sys="clr-namespace:System;assembly=netstandard"
				 x:Class="XamlSamples.StaticConstantsPage"
				 Title="Static Constants Page"
				 Padding="{x:Static local:AppConstants.PagePadding}">

		<StackLayout BindingContext="{x:Static sys:DateTime.Now}" …>
		   <Label Text="Hello, XAML!"
				  TextColor="{x:Static local:AppConstants.BackgroundColor}"
				  BackgroundColor="{x:Static local:AppConstants.ForegroundColor}"
				  Font="{x:Static local:AppConstants.TitleFont}"
				  HorizontalOptions="Center" />


		  <BoxView WidthRequest="{x:Static sys:Math.PI}"
				   HeightRequest="{x:Static sys:Math.E}"
				   Color="{x:Static local:AppConstants.ForegroundColor}"
				   HorizontalOptions="Center"
				   VerticalOptions="CenterAndExpand"
				   Scale="100" />
		</StackLayout>
	</ContentPage>
<!-- ``` -->

比如，访问工程中 XamarinVS2019 命名空间下的 App 类的静态字符串字段 AzureBackendUrl，引入命名空间和使用，注意冒号的使用：

	xmlns:local="clr-namespace:XamarinVS2019"

<!-- ```xml -->
	<Label>
		<Label.FormattedText>
			<FormattedString>
				<FormattedString.Spans>
					<Span Text="Data Server:" />
					<Span Text=" " />
					<Span Text="{local:App.AzureBackendUrl}" FontAttributes="Bold" />
					<Span Text=" " />
				</FormattedString.Spans>
			</FormattedString>
		</Label.FormattedText>
	</Label>
<!-- ``` -->



### x:Binding Extension

例如绑定一个命令，在 C# 代码文件中定义 ICommand ：

<!-- ```C# -->
	public AboutViewModel()
	{
		OpenWebCommand = new Command(async () => await Browser.OpenAsync("https://xamarin.com"));
	}

	public ICommand OpenWebCommand { get; }
<!-- ``` -->

在 XAML 中使用 Binding 标记扩展进行绑定：

	<Button Text="Learn more" Command="{Binding OpenWebCommand}" TextColor="White" />

数据绑定连接两个对象 Source 和 Target 的属性，上面的 Command 实例就是源对象，而 Button 就是目标对象，目标的 Command 属性必须是可绑定属性，这意味着目标对象必须派生自 BindableObject 。

`BindingContext` 作为目标对象的属性必须设置一个源对象，并且执行目标对象的 `SetBinding` 方法，通常与 `Binding` 这个密封类型结合使用，以将该对象的属性绑定到源对象的属性。


在标记中，也需要执行代码中所需的步骤，只不过 Binding 标记扩展取代 SetBinding 调用和 Binding 密封类。

在 XAML 中定义数据绑定时，有多种方式设置 BindingContext 目标对象的。 有时，从代码隐藏文件，有时使用 StaticResource 或 x:Static 标记扩展设置，有时是 BindingContext 属性元素标记的内容。


绑定 Binding 表达式语法：

<!-- ```xml -->
	<object property="{Binding}" .../>  
	<object property="{Binding .}" .../>  
	<object property="{Binding  bindProp1=value1[, bindPropN=valueN]*}" ...  
	<object property="{Binding  bindProp1=value1, Mode=TwoWay}" ...  
	/>  
	<object property="{Binding Path}" .../>  
	<object property="{Binding Path[, bindPropN=valueN]*}" .../>  
<!-- ``` -->


可以定义数据绑定，以便链接同一页上两个视图组件的属性。 在这种情况下，可以 BindingContext 使用标记扩展设置目标对象的 `x:Reference` 。

下面是一个 XAML 文件，其中包含一个 Slider 和两个 Label 视图组件，其中一个由 Binding Path 绑定指定属性值来控制旋转，另一个通过 Binding Value 绑定 Slider 的值以显示出来。

注意，两个 x:Reference 表达的差别，前一个通过 Name 传入，后一个直接使用 slider 引用，因为 ReferenceExtension 类实现中定义了 `
[Xamarin.Forms.ContentProperty("Name")]` 属性特性，所以不用显式指定 Name 属性。

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 x:Class="XamlSamples.SliderBindingsPage"
				 Title="Slider Bindings Page">

		<StackLayout>
			<Label Text="ROTATION"
				   BindingContext="{x:Reference Name=slider}"
				   Rotation="{Binding Path=Value}"
				   FontAttributes="Bold"
				   FontSize="Large"
				   HorizontalOptions="Center"
				   VerticalOptions="CenterAndExpand" />

			<Slider x:Name="slider"
					Maximum="360"
					VerticalOptions="CenterAndExpand" />

			<Label BindingContext="{x:Reference slider}"
				   Text="{Binding Value, StringFormat='The angle is {0:F0} degrees'}"
				   FontAttributes="Bold"
				   FontSize="Large"
				   HorizontalOptions="Center"
				   VerticalOptions="CenterAndExpand" />
		</StackLayout>
	</ContentPage>
<!-- ``` -->

XAML 并不会对非字符串类型作隐式转换，需要提供 StringFormat 字符串在执行 String.Format 静态方法时格式化。

以下例子使用几个 Slider 来控制名为 myLabel 标签组件的字体大小和旋转，Slider 在 BindingContext 指定了要控制的 myLabel，而其它用来显示信息的标签则在 BindingContext 中指定了对应的 Slider 对象。所有 Label 都是目标对象，但是在 XAML 中可以使用 TwoWay 和 OneWayToSource 等绑定方式，在源对象上设置 BindingContext。

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 x:Class="XamarinVS2019.Views.AboutPage"
				 xmlns:vm="clr-namespace:XamarinVS2019.ViewModels"
				 Padding="5"
				 Title="Slider Transforms Page">
		<Grid>
			<Grid.RowDefinitions>
				<RowDefinition Height="*" />
				<RowDefinition Height="Auto" />
				<RowDefinition Height="Auto" />
				<RowDefinition Height="Auto" />
				<RowDefinition Height="Auto" />
			</Grid.RowDefinitions>

			<Grid.ColumnDefinitions>
				<ColumnDefinition Width="*" />
				<ColumnDefinition Width="Auto" />
			</Grid.ColumnDefinitions>

			<!-- Scaled and rotated Label -->
			<Label x:Name="myLabel"
				   Text="TEXT"
				   HorizontalOptions="Center"
				   VerticalOptions="CenterAndExpand" />

			<!-- Slider and identifying Label for Scale -->
			<Slider x:Name="scaleSlider"
					BindingContext="{x:Reference myLabel}"
					Grid.Row="1" Grid.Column="0"
					Maximum="10"
					Value="{Binding Scale, Mode=TwoWay}" />

			<Label BindingContext="{x:Reference scaleSlider}"
				   Text="{Binding Value, StringFormat='Scale = {0:F1}'}"
				   Grid.Row="1" Grid.Column="1"
				   VerticalTextAlignment="Center" />

			<!-- Slider and identifying Label for Rotation -->
			<Slider x:Name="rotationSlider"
					BindingContext="{x:Reference myLabel}"
					Grid.Row="2" Grid.Column="0"
					Maximum="360"
					Value="{Binding Rotation, Mode=OneWayToSource}" />

			<Label BindingContext="{x:Reference rotationSlider}"
				   Text="{Binding Value, StringFormat='Rotation = {0:F0}'}"
				   Grid.Row="2" Grid.Column="1"
				   VerticalTextAlignment="Center" />

			<!-- Slider and identifying Label for RotationX -->
			<Slider x:Name="rotationXSlider"
					BindingContext="{x:Reference myLabel}"
					Grid.Row="3" Grid.Column="0"
					Maximum="360"
					Value="{Binding RotationX, Mode=OneWayToSource}" />

			<Label BindingContext="{x:Reference rotationXSlider}"
				   Text="{Binding Value, StringFormat='RotationX = {0:F0}'}"
				   Grid.Row="3" Grid.Column="1"
				   VerticalTextAlignment="Center" />

			<!-- Slider and identifying Label for RotationY -->
			<Slider x:Name="rotationYSlider"
					BindingContext="{x:Reference myLabel}"
					Grid.Row="4" Grid.Column="0"
					Maximum="360"
					Value="{Binding RotationY, Mode=OneWayToSource}" />

			<Label BindingContext="{x:Reference rotationYSlider}"
				   Text="{Binding Value, StringFormat='RotationY = {0:F0}'}"
				   Grid.Row="4" Grid.Column="1"
				   VerticalTextAlignment="Center" />
		</Grid>
	</ContentPage>
<!-- ``` -->


## Binding with ListView Template
- [Xamarin.Forms ListView](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/listview/)
- [Xamarin.Forms ListView](https://www.cnblogs.com/peterYong/p/11848807.html)
- [Custom ListView Cells](https://link.jianshu.com/?t=https://developer.xamarin.com/guides/xamarin-forms/user-interface/listview/customizing-cell-appearance/#Custom_Cells)

展示 XAML 的数据绑定强大功能，没什么比 ListView 模板更好了。

ListView 组件支持多种交互，IsPullToRefreshEnabled 可以设置允许用户下拉刷新内容，当然，使用 RefreshView 组件也可以实现下拉刷新动作。设置 Cell 单元的 ContextActions 上下文，添加 MenuItem 定自定义操作。SelectionMode 属性可以设置条目可单选 Single 或不可选，Selection 选择允许开发人员将功能附加到列表项上的选择和取消选择事件。IsGroupingEnabled 设置分组数据呈现。


为项定义模板，需要将 ItemTemplate 属性作为组件元素分解为 DataTemplate ，然后引用 ViewCell 。 对于 ViewCell.View 属性，可以定义一个或多个视图的布局，以显示每个项。 ListView 可滚动和可选择。

定义数据源的 XAML 和等价 C#：

<!-- ```XML -->
	<ListView>
	  <ListView.ItemsSource>
		  <x:Array Type="{x:Type x:String}">
			<x:String>mono</x:String>
			<x:String>monodroid</x:String>
			...
		  </x:Array>
	  </ListView.ItemsSource>
	</ListView>
<!-- ``` -->


<!-- ```C# -->
	var listView = new ListView();
	listView.ItemsSource = new string[]
	{
		"mono",
		"monodroid",
		"monotouch",
		"monorail",
		...
	};
<!-- ``` -->

绑定字符串对象集合直接显示字符串条目，如果集合元素是对象，那就执行 ToString 转换，通过 x:Static 来绑定后面实的数据源：

	<ListView ItemsSource="{x:Static local:NamedColor.All}" />

下面是一个简单示例：

<!-- ```xml -->
	<ListView ItemsSource="{x:Static local:NamedColor.All}">
		<ListView.ItemTemplate>
			<DataTemplate>
				<ViewCell>
		
		<ViewCell.View>
			<Label Text="{Binding FriendlyName}" />
		</ViewCell.View>

				</ViewCell>
			</DataTemplate>
		</ListView.ItemTemplate>
	</ListView>
<!-- ``` -->

XamlSamples 项目包含一个 NamedColor 的类，需要在 XAML 头部引用。 

	xmlns:local="clr-namespace:XamlSamples"

每个 NamedColor 对象通过静态构造函数创建一个 IEnumerable<NamedColor> All 集合，该集合包含通过反射技术获取到 Color 结构定义的颜色值。需要注意的是 Xamarin 的 Color 对象的颜色定义在字段中，不能用 GetProperties 反射方法去获取，需要使用 GetFields 或扩展方法 GetRuntimeFields。

使用 ObservableCollection 数据源对象替代 IEnumerable 可以在列表操作数据，删除或更新时，同步到数据源。ObservableCollection 不是线程安全的，会导致 UI 更新执行修改在同一线程上进行，如果该线程不是主 UI 线程，则将导致异常。

使用 x:Static  标记扩展将静态属性 NamedColor.All 设置为 ListView 的 ItemsSource 属性值，就可以渲染出视图。

ViewCell 是一个级简的组件，只通过 View 属性来设置 Content 里面的视图组件，可以自定义内嵌像 Grid 或 StackLayout 这样的 View 组件放置多个子级视图组件：

	[Xamarin.Forms.ContentProperty("View")]
	public class ViewCell : Xamarin.Forms.Cell

前面在 ViewCell 中只是放了一个 Label 组件，可以用其它布局再组织视图，因为 ViewCell.View 定义了 ContentProperty 特性，可以省略 `<ViewCell.View>`：

<!-- ```xml -->
	<ViewCell>
		<StackLayout VerticalOptions="Center" Orientation="Horizontal" Padding="8">
			<Frame BorderColor="AliceBlue" CornerRadius="24" Padding="0">
				<BoxView 
				HeightRequest="48" 
				WidthRequest="16" BackgroundColor="{Binding Color}" />
			</Frame>
			<StackLayout VerticalOptions="Start" Padding="0">
				<Label Text="{Binding FriendlyName}" />
				<StackLayout Orientation="Horizontal">
					<Label Text="{Binding ColorHex}"  />
					<Label Text="{Binding Name}"  />
				</StackLayout>
			</StackLayout>
		</StackLayout>
		<ViewCell.ContextActions>
			<MenuItem Clicked="OnMore"
					  CommandParameter="{Binding .}"
					  Text="More" />
			<MenuItem Clicked="OnDelete"
					  CommandParameter="{Binding .}"
					  Text="Delete" IsDestructive="True" />
		</ViewCell.ContextActions>
	</ViewCell>
<!-- ``` -->

对应的事件处理函数：

<!-- ```C# -->
	void OnTapped (object sender, ItemTappedEventArgs args)
	{
		var item = sender as NamedColor;
	}

	void OnMore(object sender, EventArgs args)
	{
		var menu = (MenuItem)sender;
	}

	 void OnDelete(object sender, EventArgs args)
	{
		var menu = (MenuItem)sender;
		var item = menu.CommandParameter as NamedColor;
	}
<!-- ``` -->

ListView 可以设置 `ItemTapped` 事件处理，事件处理器接收的 sender 就是列表中的条目。Cell 对象可以设置 ContextActions 菜单，添加多个 MenuItem 以响应用户交互事件，Android 环境下长按列表条目即在顶部出现菜单，iOS 上滑动出现菜单。MenuItem 的 `Clicked` 关联点击事件响应处理函数，MenuItem 有三个常用属性属性：

- Text – string 类型，表示 MenuItem 显示文本。
- Icon – FileImageSource 类型设置 MenuItem 图标，等价 IconImage。
- IsDestructive – bool 类型，值为 true 时 iOS 平台 MenuItem 以红色背景渲染。

默认情况下触发事件的是 MenuItem 对象即响应点击事件中 sender 是 MenuItem，绑定数据到 MenuItem.CommandParameter 属性即可以在事件处理时确定操作的关联条目，这里使用的 `{Binding .}` 表示绑定整个 NamedColor 实例。而 More 这个菜单没有绑定数据，只会在 Text 属性显示菜单的文字。菜单呈现后，用户还可能点击其它条目，事件处理器中接收到的部分最后选中的那个。

使用 Meuitem.Command 来处理点击事件要绑定一个 Command 实例，它需要封装一个 Action 委托对象，可以使用 Lambada 表达式定义：

		OpenWebCommand = new Command(async () => await Browser.OpenAsync("https://xamarin.com"));

编写事件处理函数时注意一下 event 是 C# 的关键字，不要当 EventArgs 的变量名字使用了。

`ItemTappedEventArgs` 主要参数：

- Group 被点击的条目所属集合，没有分组时就是默认的一个条目分为一个集合
- Item  被点击的条目引用
- ItemIndex 条目索引号


运行时 Cell.ForceUpdateSize 方法更新 cell 大小。



除了 ViewCell 这个，Xamarin.Forms 内置单元格 Cell 对象：

- TextCell 控件用于显示文本，并带有可选的第二行以显示详细文本。
- ImageCell 控件与 TextCell 相似，但在文本左侧包含一个图像。
- SwitchCell 控件用于呈现和捕获打开/关闭或真/假状态。
- EntryCell 控件用于呈现用户可以编辑的文本数据。


TextCell 用来显示文本：

- Text  第一行主要内容，以较大字体显示
- Detail    第二行次要内容，以较小字体显示
- TextColor Text 文本颜色
- DetailColor   Detail 文本颜色

ImageCell 相比 TextCell 可以在 Cell 左侧显示图片信息。

	<TextCell Text="{Binding FriendlyName}" Detail="{Binding .Name}}"  />


### ViewList & NamedColor 参考代码

AXML 代码：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:local="clr-namespace:XamlSamples"
				 x:Class="XamlSamples.ListViewDemoPage"
				 Title="ListView Demo Page">

		<ContentPage.Resources>
			<ResourceDictionary>
				<OnPlatform x:Key="boxSize"
							x:TypeArguments="x:Double">
					<On Platform="iOS, Android, UWP" Value="50" />
				</OnPlatform>

				<OnPlatform x:Key="rowHeight"
							x:TypeArguments="x:Int32">
					<On Platform="iOS, Android, UWP" Value="60" />
				</OnPlatform>

				<local:DoubleToIntConverter x:Key="intConverter" />

			</ResourceDictionary>
		</ContentPage.Resources>

		<ListView ItemsSource="{x:Static local:NamedColor.All}"
				  RowHeight="{StaticResource rowHeight}">
			<ListView.ItemTemplate>
				<DataTemplate>
					<ViewCell>
						<StackLayout Padding="5, 5, 0, 5"
									 Orientation="Horizontal"
									 Spacing="15">

							<BoxView WidthRequest="{StaticResource boxSize}"
									 HeightRequest="{StaticResource boxSize}"
									 Color="{Binding Color}" />

							<StackLayout Padding="5, 0, 0, 0"
										 VerticalOptions="Center">

								<Label Text="{Binding FriendlyName}"
									   FontAttributes="Bold"
									   FontSize="Medium" />

								<StackLayout Orientation="Horizontal"
											 Spacing="0">
									<Label Text="{Binding Color.R,
										   Converter={StaticResource intConverter},
										   ConverterParameter=255,
										   StringFormat='R={0:X2}'}" />

									<Label Text="{Binding Color.G,
										   Converter={StaticResource intConverter},
										   ConverterParameter=255,
										   StringFormat=', G={0:X2}'}" />

									<Label Text="{Binding Color.B,
										   Converter={StaticResource intConverter},
										   ConverterParameter=255,
										   StringFormat=', B={0:X2}'}" />
								</StackLayout>
							</StackLayout>
						</StackLayout>
					</ViewCell>
				</DataTemplate>
			</ListView.ItemTemplate>
		</ListView>
	</ContentPage>
<!-- ``` -->


NamedColor 实现和 IValueConverter 值转换接口的 Convert 和 ConvertBack 两个方法实现：

<!-- ```C# -->
	using System;
	using System.Reflection;
	using System.Text;
	using Xamarin.Forms;
	using System.Collections.Generic;
	using System.Globalization;

	namespace XamlSample
	{
		public class NamedColor
		{
			public string Name { private set; get; }
			public string FriendlyName { private set; get; }
			public Color Color { private set; get; }
			public String ColorHex { private set; get; }

			public static List<NamedColor> All { private set; get; }
			public static List<String> AllName { private set; get; }

			static NamedColor()
			{
				All = new List<NamedColor>();
				AllName = new List<string>();
				Color color = new Color();

				//var fields = color.GetType().GetFields();
				var props = color.GetType().GetRuntimeFields();
				StringBuilder builder = new StringBuilder();
				foreach (FieldInfo pi in props)
				{
					if (pi.FieldType != typeof(Color))
					{
						continue;
					}

					int idx = 0;
					builder.Clear();
					builder.Append($"[{All.Count,2}] ");
					AllName.Add($"[{AllName.Count,2}] " + pi.Name);
					foreach (char ch in pi.Name)
					{
						if (idx++ != 0 && char.IsUpper(ch)) builder.Append(' ');
						builder.Append(ch);
					}
					All.Add(new NamedColor { 
						Name = pi.Name, 
						FriendlyName = builder.ToString(), 
						Color = (Color)pi.GetValue(null),
						ColorHex = ((Color)pi.GetValue(null)).ToHex()
						});
					if (All.Count > 50)
					{
						break;
					}
				}
			}
		}

		class DoubleToIntConverter : IValueConverter
		{
			public object Convert(object value, Type targetType,
								  object parameter, CultureInfo culture)
			{
				double multiplier;

				if (!Double.TryParse(parameter as string, out multiplier))
					multiplier = 1;

				return (int)Math.Round(multiplier * (double)value);
			}

			public object ConvertBack(object value, Type targetType,
									  object parameter, CultureInfo culture)
			{
				double divider;

				if (!Double.TryParse(parameter as string, out divider))
					divider = 1;

				return ((double)(int)value) / divider;
			}
		}
	}
<!-- ``` -->


在 XAML 中实例化后，供其它 Binding 标记使用，注意 Binding 内嵌了 StaticResource 标记扩展：

<!-- ```xml -->
	<local:DoubleToIntConverter x:Key="intConverter" />

	<Label Text="{Binding Color.R,
						  Converter={StaticResource intConverter},
						  ConverterParameter=255,
						  StringFormat='R={0:X2}'}" />
<!-- ``` -->


### TextCell & EntryCell
https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.textcell

<!-- ```C# -->
	public class App : Application
	{
		public App()
		{
			MainPage = new ContentPage {
				Content = new TableView {
					Intent = TableIntent.Form,
					Root = new TableRoot ("Table Title") {
						new TableSection ("Section 1 Title") {
							new TextCell {
								Text = "TextCell Text",
								Detail = "TextCell Detail"
							},
							new EntryCell {
								Label = "EntryCell:",
								Placeholder = "default keyboard",
								Keyboard = Keyboard.Default
							}
						},
						new TableSection ("Section 2 Title") {
							new EntryCell {
								Label = "Another EntryCell:",
								Placeholder = "phone keyboard",
								Keyboard = Keyboard.Telephone
							},
							new SwitchCell {
								Text = "SwitchCell:"
							}
						}
					}
				}
			}; 
		}
		// OnStart, OnSleep, OnResume overrides omitted...
	}
<!-- ``` -->

### ImageCell
https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.imagecell


<!-- ```C# -->
	using System;
	using Xamarin.Forms;
		
	namespace FormsGallery
	{
		class ImageCellDemoPage : ContentPage
		{
			public ImageCellDemoPage()
			{
				Label header = new Label
				{
					Text = "ImageCell",
					FontSize = Device.GetNamedSize (NamedSize.Large, typeof(Label)),
					HorizontalOptions = LayoutOptions.Center
				};
		
				TableView tableView = new TableView
				{
					Intent = TableIntent.Form,
					Root = new TableRoot
					{
						new TableSection
						{
							new ImageCell
							{
								// Some differences with loading images in initial release.
								ImageSource =
									Device.OnPlatform(ImageSource.FromUri(new Uri("http://xamarin.com/images/index/ide-xamarin-studio.png")),
									ImageSource.FromFile("ide_xamarin_studio.png"),
									ImageSource.FromFile("Images/ide-xamarin-studio.png")),
								Text = "This is an ImageCell",
								Detail = "This is some detail text",
							}
						}
					}
				};
		
				// Accomodate iPhone status bar.
				this.Padding = new Thickness(10, Device.OnPlatform(20, 0, 0), 10, 5);
		
				// Build the page.
				this.Content = new StackLayout
				{
					Children =
					{
						header,
						tableView
					}
				};
			}
		}
	}
<!-- ``` -->


### ListView 参考

ListView 属性

- Footer    object类型，获取、设置列表底部的字符串或视图。
- FooterTemplate    DataTemplate类型，获取、设置列表底部数据模版。
- Header    object类型，获取、设置列表顶部的字符串或视图。
- HeaderTemplate    DataTemplate类型，获取、设置列表定部数据模版。

HeaderTemplate 和 FooterTemplate 不是必须的，它们会随 ListView 一起滚动：

<!-- ```xml -->
	<ListView x:Name="listView">
		<ListView.Header>
			ListView Header
		</ListView.Header>
		<ListView.Footer>
			ListView Footer
		</ListView.Footer>
	</ListView>
<!-- ``` -->


- IsGroupingEnabled bool类型，表示是否对列表进行分组。
- GroupDisplayBinding   绑定分组头的值。
- GroupHeaderTemplate   DataTemplate类型，分组头的数据模版。
- GroupShortNameBinding 绑定分组跳转列表中的值。

XAML 中绑定数据设置 IsGroupingEnabled true 分组，绑定数据源的 GroupTitle 到 GroupDisplayBinding ，可选绑定数据到 GroupShortNameBinding ，ListView.RowHeight 属性节点定义不同平台 Item 显示不同高度。结合 Custum Cell ，定义 ItemTemplate 的值：

<!-- ```C# -->
	var aGroup = new ListViewGroup
	{
		GroupTitle = "A Title",
		ShortName = "A"
	};
	aGroup.Add("Abs");
	aGroup.Add("Apple");
	aGroup.Add("Are");
	aGroup.Add("Add");
	Items.Add(aGroup);

	<ListView ItemsSource="{x:Static local:ListViewGroup.Items}"
			  IsGroupingEnabled="true"
			  GroupDisplayBinding="{Binding GroupTitle}"
			  GroupShortNameBinding="{Binding ShortName}">

		<ListView.GroupHeaderTemplate>
			<DataTemplate>
				 <TextCell Text="{Binding Title}"
						   Detail="{Binding ShortName}"
						   TextColor="#f35e20"
						   DetailColor="#503026" />
			</DataTemplate>
		</ListView.GroupHeaderTemplate>
<!-- ``` -->


- HasUnevenRows bool类型，表示要甩列表内容决定不同行高，默认值 false。
- RowHeight 表示列表行高。

	默认 ListView 中的所有行都具有相同的高度，运行时更改行大小调整的过度使用会导致性能下降。

- IsPullToRefreshEnabled    bool类型，表示列表是否可以进行下拉刷新。
- IsRefreshing  bool类型，表示列表是否正在刷新。
- RefreshControlColor 属性设置下拉刷新时的图样颜色。

- SelectionMode 类型为 ListViewSelectionMode 设置条目可单选 Single 或不可选 None
- SelectedItem  object类型，表示列表当前选中对象。

- SeparatorColor    Color类型，设置列表分割条的颜色。
- SeparatorVisibility   枚举类型，None 不显示分割条。

- Horizo​​ntalScrollBarVisibility 
- VerticalScrollBarVisibility 

	ScrollBarVisibility 枚举值，设置水平或垂直滚动​​条何时可见：

	- Default 默认值，平台的默认滚动条行为。
	- Always 指示滚动条将可见，即使内容适合视图。
	- Never 表示即使内容不适合视图，也不显示滚动条。

ListView 事件

- ItemAppearing 列表条目显示时触发，ListView 滑动使 Item 显示在屏幕内。
- ItemDisappearing  列表条目消失时触发，ListView 滑动使 Item 消失在屏幕内。
- ItemSelected  选择新的 Item 时触发。
- ItemTapped    列表元素 Item 被点击是触发。
- Refreshing    列表刷新事件。

当 SelectionMode 属性设置为 Single 时，可以选择 ListView 中的项目，触发 ItemSelected 和 ItemTapped 事件，并且 SelectedItem 属性将设置为所选项目的值。

当 SelectionMode 为 None 时，将无法选择 ListView 中的项目，将不会触发 ItemSelected 事件，并且 SelectedItem 属性将保持为null。 但是，在点击过程中，仍会触发 ItemTapped 事件，并且被轻按的项目将短暂突出显示。

当选择一个项目并将 SelectionMode 属性更改为 None 时，SelectedItem 属性将设置为 null，并且将使用空项触发 ItemSelected 事件。

触发 Refreshing 事件以启动刷新，并且 IsRefreshing 属性将自动设置为 true 。刷新 ListView 内容的任何代码均应由 Refreshing 事件处理程序或 RefreshCommand 指定的方法执行。 刷新之后，应将 IsRefreshing 属性设置为 false，或应调用 EndRefresh 方法以指示刷新已完成。

定义 RefreshCommand 时，可以指定命令的 CanExecute 方法来启用或禁用命令。

	<ListView  RefreshCommand="{Binding ComListRefreshCommand}" IsRefreshing="{Binding ComListIsRefreshing}">

	private void ComListRefreshCommandAsync()
	{
		//....
		ComListIsRefreshing = false;  //刷新完成
	}


提高 ListView 的性能：

- 对于绑定的数据源用 IList<T> 集合代替 IEnumerable<T> 集合。
- 尽量使用 Forms 提供的 Cell（TextCell / SwitchCell），避免自定义 Cell。
- 自定 Cell 时减少布局嵌套和使用视图，布局尽量使用 AbsoluteLayout 和 Grid，对于 LayoutOptions 属性尽量设置为 Fill。
- 显示不规律数据时用 TableView 代替 ListView。
- 减少 Cell.ForceUpdateSize 方法的调用。
- 避免将 ListView 放置在 ScrollView 中使用。
- 过于复杂的 Cell，尽量使用 Custom Renderer。



## MVVM & Data Binding

要点：

- 数据绑定基本使用方法；
- TwoWay 交互式双向绑定
- Viewmodel 与 View 间的命令传达

MVVM - Model View ViewModel 编程模式在概念上利用 XAML 来构建的，XAML 用户界面称作视图 View。 View 使用的基本数据称为模型 Model，在视图和模型之间使用中间名为 ViewModel。View 通常通过 XAML 文件中定义的 `BindingContext` 绑定 ViewModel 的实例为其提供数据。

作为 Viewmodel 介绍，下面定义 XML 命名空间声明，以允许 XAML 文件引用其他程序集中的类。 下面定义的 XML 命名空间声明使用 System ：

	xmlns:sys="clr-namespace:System;assembly=netstandard"

程序可以使用 x:Static 扩展标签获取静态属性，如当前日期和时间 DateTime.Now ，并将 DateTime 设置到 BindingContext 上，为 StackLayout 提供数据：

	<StackLayout BindingContext="{x:Static sys:DateTime.Now}" …>

BindingContext 是一个特殊属性，在元素上设置，该元素的所有子级都将继承该属性。 这意味着的所有子级 StackLayout 都具有相同的 BindingContext ，并且它们可以包含与该对象的属性的简单绑定。

Binding 可以指定绑定的路径，如下面的 Year 或 Day，解析时根据路径找到数据。没有指定绑定路径的绑定，意味着 DateTime 值本身用于 StringFormat ：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:sys="clr-namespace:System;assembly=netstandard"
				 x:Class="XamlSamples.OneShotDateTimePage"
				 Title="One-Shot DateTime Page">

		<StackLayout BindingContext="{x:Static sys:DateTime.Now}"
					 HorizontalOptions="Center"
					 VerticalOptions="Center">

			<Label Text="{Binding Year, StringFormat='The year is {0}'}" />
			<Label Text="{Binding StringFormat='The month is {0:MMMM}'}" />
			<Label Text="{Binding Day, StringFormat='The day is {0}'}" />
			<Label Text="{Binding StringFormat='The time is {0:T}'}" />

		</StackLayout>
	</ContentPage>
<!-- ``` -->

静态绑定在第一次生成页面时，日期和时间设置一次，并且永远不会发生更改。

在 MVVM 的简单示例中，根本没有模型，该模式只涉及与数据绑定关联的视图和 ViewModel。
下面 ViewModel 中只包含一个名为的属性 DateTime ，通过 Device.StartTimer 设置的定时器更新该属性，每秒更新一次。

<!-- ```C# -->
	using System;
	using System.ComponentModel;
	using Xamarin.Forms;

	namespace XamlSamples
	{
		class ClockViewModel : INotifyPropertyChanged
		{
			DateTime dateTime;

			public event PropertyChangedEventHandler PropertyChanged;

			public ClockViewModel()
			{
				this.DateTime = DateTime.Now;

				Device.StartTimer(TimeSpan.FromSeconds(1), () =>
					{
						this.DateTime = DateTime.Now;
						return true; // recursion
					});
			}

			public DateTime DateTime
			{
				set
				{
					if (dateTime != value)
					{
						dateTime = value;

						if (PropertyChanged != null)
						{
							PropertyChanged(this, new PropertyChangedEventArgs("DateTime"));
						}
					}
				}
				get
				{
					return dateTime;
				}
			}
		}
	}
<!-- ``` -->

注意，实现 INotifyPropertyChanged 接口，绑定机制会自动添加 PropertyChanged 事件的处理函数跟踪属性变化，同时触发事件时传入的属性名字 "DateTime" 必需和视图中要绑定的属性一致，否则 Xamarin.Forms 的数据绑定机制不会认为是数据属性有更新，比如，将其误写成 "DateTIme"，这样就是很难发现的错误，编译器检查不了。

<!-- ```xml -->
	<Label Text="{Binding DateTime, StringFormat='{0:T}'}"
		   FontSize="Large"
		   HorizontalOptions="Center"
		   VerticalOptions="Center">
		<Label.BindingContext>
			<local:ClockViewModel />
		</Label.BindingContext>
	</Label>
<!-- ``` -->

在 .Net 4.5 或 C# 5.0 中，可以使用 `[CallerMemberName]` 特性来避免这种手写可能导致的字符串不匹配问题。改进后的流程大概如下：

<!-- ```C# -->
	public class MyUIClass : INotifyPropertyChanged
	{
		public event PropertyChangedEventHandler PropertyChanged;

		public void OnPropertyChanged([CallerMemberName] string propertyName = null)
		{
			PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		}

		public DateTime DateTime
		{ 
			...
			OnPropertyChanged(); // No Property Name Here
		}
	}
<!-- ``` -->

在 C# 5.0 之前，这种需求只能通过运行时获取属性数据，相比 [CallerMemberName] 静态编译要消耗 CPU：

	new StackTrace(true).GetFrame(1).GetMethod().Name



### TwoWay Binding

对于基于基础数据模型的交互式视图，MVVM 通常与双向数据绑定一起使用。
每个绑定都是默认值 OneWay，只需从 BindableContext 绑定的对象获取数据。 在绑定时，可以设置 Mode 模式属性为 TwoWay 这样，不仅可以获取数据的同时，还可以在修改数据后按原路返回数据到绑定对象上。

设置模式 Mode 为 OneWayToSource 还可以实现数据的逆向流动，和 OneWay 刚好相反。

这允许 Slider 从 ViewModel 进行初始化。 请注意，在 Color Aqua 对 ViewModel 进行实例化时，属性设置为。 但中的更改 Slider 还需要为 ViewModel 中的属性设置新值，然后计算新的颜色。

例如实现 HSLViewModel 模型提供 HSL 颜色分量数据，配合 Slider 组件来实现 TwoWay 的数据交互。

对 HSL 各分量 Saturation Luminosity 的更改导致 Color 属性发生更改，更改 Color 也导致其他三个属性更改。 这似乎是一个无限循环，只不过在值不改变时，就不会调用 PropertyChanged 事件。


下面的 XAML 文件包含， BoxView 其 Color 属性绑定到 ViewModel 的 Color 属性，三个控制 HSL 分量的 Slider 使用了 TwoWay 绑定，拖动它就可将新的值回传到 NamedColor 的属性上。还有三个 Label 绑定到 Hue 、 Saturation 和 Luminosity 以显示当前的值：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:local="clr-namespace:XamarinVS2019.ViewModels"
				 x:Class="XamarinVS2019.Views.HSLViewPage"
				 Title="{Binding Title}">
		<ContentPage.BindingContext>
			<local:HSLViewModel Color="Aqua" />
		</ContentPage.BindingContext>

		<StackLayout>
			<BoxView Color="{Binding Color}" VerticalOptions="FillAndExpand"
					 RotationX="{Binding Hue}" RotationY="{Binding Saturation}" />

			<Label Text="{Binding Hue, StringFormat='Hue = {0:F2}'}"
				   HorizontalOptions="Center" />

			<Slider Value="{Binding Hue, Mode=TwoWay}" />

			<Label Text="{Binding Saturation, StringFormat='Saturation = {0:F2}'}"
				   HorizontalOptions="Center" />

			<Slider Value="{Binding Saturation, Mode=TwoWay}" />

			<Label Text="{Binding Luminosity, StringFormat='Luminosity = {0:F2}'}"
				   HorizontalOptions="Center" />

			<Slider Value="{Binding Luminosity, Mode=TwoWay}" Margin="0,0,0,32"/>
		</StackLayout>
	</ContentPage>
<!-- ``` -->

<!-- ```C# -->
	using System;
	using Xamarin.Forms;
	using System.ComponentModel;
	using System.Runtime.CompilerServices;
	using System.Collections.Generic;

	namespace XamarinVS2019.ViewModels
	{
		public class HSLViewModel : INotifyPropertyChanged
		{
			Color _color;
			Double _hue, _saturation, _luminosity;

			// new string Title = "HSL Color Scroll Page";
			// public HSLViewModel()
			// {
			//     Title = "HSL Color Scroll Page";
			// }
			public event PropertyChangedEventHandler PropertyChanged;

			public void OnPropertyChanged([CallerMemberName] string name = "")
			{
				PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
			}

			private bool setProperty<T>(ref T store, T value, 
					[CallerMemberName] string name = null, Action onChanged = null)
			{
				if (EqualityComparer<T>.Default.Equals(store, value)) return false;
				store = value;
				onChanged?.Invoke();
				OnPropertyChanged(name);
				return true;
			}

			public Color Color 
			{
				get { return _color; }
				set 
				{
					if (_color==value) return;
					_color = value;
					Hue = value.Hue;
					Saturation = value.Saturation;
					Luminosity = value.Luminosity;
					OnPropertyChanged();
				}
			}
			public Double Hue 
			{
				get { return _hue; }
				set
				{
					if (setProperty(ref _hue, value))
					{
						updateColor();
					}
				}
			}
			public Double Saturation 
			{
				get { return _saturation; }
				set
				{
					if (setProperty(ref _saturation, value))
					{
						updateColor();
					}
				}
			}
			public Double Luminosity 
			{
				get { return _luminosity; }
				set
				{
					if (setProperty(ref _luminosity, value))
					{
						updateColor();
					}
				}
			}

			void updateColor()
			{
				Color = Color.FromHsla(Hue, Saturation, Luminosity);
			}

		}
	}
<!-- ``` -->

### ICommand with View

除了数据直接绑定的做法，View 和 ViewModel 之间还有一种约束更大的一点的通信，即命令 Command。

当视图需要触发包含在 ViewModel 中的各种操作时，通过按钮等 UI 组件绑定一个 Command 对像来执行 ViewModel 上定义的命令。当组件上使用 Command 后，就不能再包含 Clicked 事件的处理程序，因为这会将 ViewModel 关联到特定的用户界面模式。

命令接口对象的使用，使得 Viewmodel 对象更独立于特定用户界面，但仍允许在用户界面调用 ViewModel 中定义的方法。

以下 Xamarin.Forms 组件支持使用命令接口：

- Button
- MenuItem
- TextCell
- ImageCell
- ListView
- TapGestureRecognizer

这些元素定义了两个属性：

- Command 类型为 System.Windows.Input.ICommand
- CommandParameter 类型为 Object，用于传递命令参数

特别地，还有 ToolbarItem 和 SearchBar 两种组件：

- SearchBar 定义 SearchCommand 和 SearchCommandParameter 属性；
- ListView 定义 RefreshCommand 属性，这不用附带参数 ；

ICommand 接口定义了两个方法和一个事件：

- void Execute(object arg)
- bool CanExecute(object arg)
- event EventHandler CanExecuteChanged

ViewModel 可以定义类型的属性 ICommand，然后，可以将这些属性绑定到每个 Button 或其他元素的 `Command` 属性，或者可能绑定到实现此接口的自定义视图。 可选地，将需要传递给命令执行函数的参数绑定到 `CommandParameter` 属性。 在内部，每当用户点击 Button 就会执行命令的 Execute 回调函数，并将参数传递给方法，都会调用方法 Execute CommandParameter 。

CanExecute 方法和 CanExecuteChanged 事件用于在 Button 点击可能当前无效的情况下，在这种情况下， Button 应禁用自身。 Button CanExecute Command 第一次设置属性和 CanExecuteChanged 触发事件时调用。 如果 CanExecute 返回 false ，则将 Button 禁用自身，而不会生成 Execute 调用。

例子，输入电话号码的简单键盘视图模型，暴露了 `InputString` 和 `DisplayText` 用于键盘输入字符的保存和显示。 另外，暴露了 `AddCharCommand`
和 `DeleteCharCommand` 两个命令。在输入的过程中，使用 `FormatText` 方法对内容进行格式后再显示。

命令还可以调用异步方法。 async await 在指定方法时，可以使用和关键字实现此目的 Execute ：

	DownloadCommand = new Command (async () => await DownloadAsync ());

这表示该 DownloadAsync 方法为 Task ，应等待：

	async Task DownloadAsync ()
	{
	    await Task.Run (() => Do_File_Download ());
	}

请注意，在构造函数中，命令对象实例化时，参数中 Execute 和 CanExecute 回调方法定义为 lambda 函数。

<!-- ```C# -->
	using System;
	using System.ComponentModel;
	using System.Windows.Input;
	using Xamarin.Forms;

	namespace XamarinVS2019.ViewModels
	{
	    class KeypadViewModel : INotifyPropertyChanged
	    {
	        string inputString = "";
	        string displayText = "";
	        char[] specialChars = { '*', '#' };

	        public event PropertyChangedEventHandler PropertyChanged;

	        public KeypadViewModel()
	        {
	            AddCharCommand = new Command<string>((key) =>
	                {
	                    InputString += key;
	                });

	            DeleteCharCommand = new Command(() =>
	                {
	                    InputString = InputString.Substring(0, InputString.Length - 1);
	                },
	                () =>
	                {
	                    return InputString.Length > 0;
	                });
	        }

	        public string InputString
	        {
	            protected set
	            {
	                if (inputString != value)
	                {
	                    inputString = value;
	                    OnPropertyChanged("InputString");
	                    DisplayText = FormatText(inputString);

	                    // Perhaps the delete button must be enabled/disabled.
	                    ((Command)DeleteCharCommand).ChangeCanExecute();
	                }
	            }

	            get { return inputString; }
	        }

	        public string DisplayText
	        {
	            protected set
	            {
	                if (displayText != value)
	                {
	                    displayText = value;
	                    OnPropertyChanged("DisplayText");
	                }
	            }
	            get { return displayText; }
	        }

	        public ICommand AddCharCommand { protected set; get; }

	        public ICommand DeleteCharCommand { protected set; get; }

	        string FormatText(string str)
	        {
	            bool hasNonNumbers = str.IndexOfAny(specialChars) != -1;
	            string formatted = str;

	            if (hasNonNumbers || str.Length < 4 || str.Length > 10)
	            {
	            }
	            else if (str.Length < 8)
	            {
	                formatted = String.Format("{0}-{1}",
	                                          str.Substring(0, 3),
	                                          str.Substring(3));
	            }
	            else
	            {
	                formatted = String.Format("({0}) {1}-{2}",
	                                          str.Substring(0, 3),
	                                          str.Substring(3, 3),
	                                          str.Substring(6));
	            }
	            return formatted;
	        }

	        protected void OnPropertyChanged(string propertyName)
	        {
	            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
	        }
	    }
	}
<!-- ``` -->

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             xmlns:d="http://xamarin.com/schemas/2014/forms/design"
	             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
	             mc:Ignorable="d"
	             x:Class="XamarinVS2019.Views.KeypadPage"
	             xmlns:local="clr-namespace:XamarinVS2019.ViewModels"
	              Title="Keypad Page"> 

	    <Grid HorizontalOptions="CenterAndExpand" VerticalOptions="Center">
	        <Grid.BindingContext>
	            <local:KeypadViewModel />
	        </Grid.BindingContext>
	        
	        <Grid.RowDefinitions>
	            <RowDefinition Height="Auto" />
	            <RowDefinition Height="Auto" />
	            <RowDefinition Height="Auto" />
	            <RowDefinition Height="Auto" />
	            <RowDefinition Height="Auto" />
	        </Grid.RowDefinitions>

	        <Grid.ColumnDefinitions>
	            <ColumnDefinition Width="80" />
	            <ColumnDefinition Width="80" />
	            <ColumnDefinition Width="80" />
	        </Grid.ColumnDefinitions>

	        <!-- Internal Grid for top row of items -->
	        <Grid Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="3">

	            <Grid.ColumnDefinitions>
	                <ColumnDefinition Width="*" />
	                <ColumnDefinition Width="Auto" />
	            </Grid.ColumnDefinitions>
	            
	            <Frame OutlineColor="Accent" Grid.Column="0">
	                <Label HorizontalOptions="CenterAndExpand" Text="{Binding DisplayText}" />
	            </Frame>
	            <Button Text="&#x21E6;"
	                    Command="{Binding DeleteCharCommand}"
	                    Grid.Column="1"
	                    BorderWidth="0" />
	        </Grid>

	        <Button Grid.Row="1" Grid.Column="0" Text="1" Command="{Binding AddCharCommand}" CommandParameter="1" />
	        <Button Grid.Row="1" Grid.Column="1" Text="2" Command="{Binding AddCharCommand}" CommandParameter="2" />
	        <Button Grid.Row="1" Grid.Column="2" Text="3" Command="{Binding AddCharCommand}" CommandParameter="3" />

	        <Button Grid.Row="2" Grid.Column="0" Text="4" Command="{Binding AddCharCommand}" CommandParameter="4" />
	        <Button Grid.Row="2" Grid.Column="1" Text="5" Command="{Binding AddCharCommand}" CommandParameter="5" />
	        <Button Grid.Row="2" Grid.Column="2" Text="6" Command="{Binding AddCharCommand}" CommandParameter="6" />

	        <Button Grid.Row="3" Grid.Column="0" Text="7" Command="{Binding AddCharCommand}" CommandParameter="7" />
	        <Button Grid.Row="3" Grid.Column="1" Text="8" Command="{Binding AddCharCommand}" CommandParameter="8" />
	        <Button Grid.Row="3" Grid.Column="2" Text="9" Command="{Binding AddCharCommand}" CommandParameter="9" />

	        <Button Grid.Row="4" Grid.Column="0" Text="*" Command="{Binding AddCharCommand}" CommandParameter="*" />
	        <Button Grid.Row="4" Grid.Column="1" Text="0" Command="{Binding AddCharCommand}" CommandParameter="0" />
	        <Button Grid.Row="4" Grid.Column="2" Text="#" Command="{Binding AddCharCommand}" CommandParameter="#" /> 

	    </Grid>
	</ContentPage>
<!-- ``` -->


## XAML Controls
- [XAML Controls](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/xaml/xaml-controls)
- [UI - User Interface](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/)

用户界面对象即视图，也是组件，如标签、按钮和滑块，这些对象通常称为控件或其他图形编程环境中的小组件。 Xamarin.Forms 所有组件都从 View 基类派生。Xamarin.Forms 可以从 XAML 文件引用定义的所有视图组件。

展示组件：

- `BoxView` 显示特定颜色的矩形。
- `Expander` 提供可扩展容器来托管任何内容。
- `Image` 显示位图
- `Label` 显示一个或多个文本行。
- `Map` 显示地图 <maps:Map ItemsSource="{Binding Locations}" />
- `MediaElement` 播放视频或音频。
- `WebView` 显示网页或 HTML 内容。

命令组件：

- `Button` 显示矩形对象中的文本。
- `RadioButton` 允许从集中选择一个选项。
- `RefreshView` 提供可滚动内容的请求刷新功能。
- `SearchBar` 搜索栏接受用于执行搜索的用户输入。
- `SwipeView` 提供通过轻扫手势显示的上下文菜单项。

表单设置：

- `CheckBox` 允许选择 boolean 值。
- `Slider` 滑块允许 double 从连续范围中选择值。
- `Stepper` 步进器允许 double 从增量范围中选择值。
- `Switch` 允许选择 boolean 值。
- `DatePicker` 允许选择日期。
- `TimePicker` 允许选择一段时间 TimeSpan。

编辑文本的视图

- `Entry` 条目允许输入和编辑单个文本行。
- `Editor` 编辑器允许输入和编辑多行文本。

指示活动的视图：

- `ActivityIndicator` 显示一个动画来表明应用程序参与了长时间的活动，而不提供任何进度指示。
- `ProgressBar` 显示一个进度动画，用于显示应用程序正在经历长时间的活动。

显示集合的视图：

- `CarouselView` 显示一个可侧滑滚动的数据项列表。
- `IndicatorView` 指示器表示 CarouselView 中的项数的指示器。
- `CollectionView` 使用不同的布局规范显示可滚动的数据项列表。
- `ListView` 显示可选择数据项的可滚动列表。
- `Picker` 选取器显示文本字符串列表中的选择项。
- `TableView` 显示交互式行的列表。

其他控件：

- `MenuItem` 菜单条目
- `ToolbarItem` 工具栏条目

除了以下用户界面组件，还有一系列布局组件影响着用户界面的排版：

- `AbsoluteLayout` 用于使用显式值或相对于布局大小的值对元素进行定位和调整大小。 
- `FlexLayout` 类似 StackLayout 在堆栈中水平或垂直显示子元素。
- `Grid` 用于显示行和列中的元素，
- `RelativeLayout` 用于相对于布局或同级元素的属性来定位元素和调整其大小。
- `StackLayout` 维堆栈中的元素是水平或垂直的。
- `ContentView` 包含一个 Content 子元素，通常用于创建自定义的可重用控件。 
- `Frame` 边框用于使用可以配置颜色、阴影和其他选项的边框来包装视图。
- `ScrollView` 滚动内容布局，默认情况下，它会垂直滚动其内容。


### Color
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/colors

Color 类提供多种方法来生成实例，也提供 R、G、B 三色彩分量，Double 值：

- 常见命名颜色的集合，包括 Red 、 Green 和 Blue 等。
- `FromHex` 与 HTML 中使用的语法类似的字符串值，例如 "00FF00"。 可以指定为第一对字符 Alpha（"CC00FF00"）。
- `FromHsla` 色调、饱和度和发光度 double 值，具有可选的 alpha 值（0.0-1.0）。
- `FromHsv` 色调、饱和度和值 int double 。
- `FromHsva` 色调、饱和度和值 int double 。
- `FromRgb` 红色、绿色和蓝色 int 值（0-255）。
- `FromRgba` 红色、绿色、蓝色和 alpha int 值（0-255）。
- `FromUint` 设置 double 表示argb的单个值。

示例：

	var red    = new Label { Text = "Red",   BackgroundColor = Color.Red };
	var orange = new Label { Text = "Orange",BackgroundColor = Color.FromHex("FF6A00") };
	var yellow = new Label { Text = "Yellow",BackgroundColor = Color.FromHsla(0.167, 1.0, 0.5, 1.0) };
	var green  = new Label { Text = "Green", BackgroundColor = Color.FromRgb (38, 127, 0) };
	var blue   = new Label { Text = "Blue",  BackgroundColor = Color.FromRgba(0, 38, 255, 255) };
	var indigo = new Label { Text = "Indigo",BackgroundColor = Color.FromRgb (0, 72, 255) };
	var violet = new Label { Text = "Violet",BackgroundColor = Color.FromHsla(0.82, 1, 0.25, 1) };

	var transparent = new Label { Text = "Transparent",BackgroundColor = Color.Transparent };
	var @default = new Label    { Text = "Default",    BackgroundColor = Color.Default };
	var accent = new Label      { Text = "Accent",     BackgroundColor = Color.Accent };

使用定义的颜色名称或此处显示的十六进制表示形式，还可以在 XAML 中引用颜色：

	<Label Text="Sea color" BackgroundColor="Aqua" />
	<Label Text="RGB" BackgroundColor="#00FF00" />
	<Label Text="Alpha plus RGB" BackgroundColor="#CC00FF00" />
	<Label Text="Tiny RGB" BackgroundColor="#0F0" />
	<Label Text="Tiny Alpha plus RGB" BackgroundColor="#C0F0" />

Color 实例包括以下附加方法：

- `AddLuminosity` 通过用 Color 提供的增量修改发光度来返回。
- `MultiplyAlpha`  Color 通过修改 alpha 返回，并将其乘以提供的 alpha 值。
- `ToHex` 返回的十六进制 string 表示形式 Color 。
- `WithHue` 返回 Color ，将色相替换为提供的值。
- `WithLuminosity` 返回 Color ，将发光度替换为提供的值。
- `WithSaturation` 返回 Color ，将饱和度替换为提供的值。

Xamarin.Forms.Color可以执行与类型之间的隐式转换 System.Drawing.Color ：

	Xamarin.Forms.Color xfColor = Xamarin.Forms.Color.FromRgb(0, 72, 255);
	System.Drawing.Color sdColor = System.Drawing.Color.FromArgb(38, 127, 0);

	// Implicity convert from a Xamarin.Forms.Color to a System.Drawing.Color
	System.Drawing.Color sdColor2 = xfColor;

	// Implicitly convert from a System.Drawing.Color to a Xamarin.Forms.Color
	Xamarin.Forms.Color xfColor2 = sdColor;


### DataPages
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/datapages/get-started
- https://www.nuget.org/packages/Xamarin.Forms.Pages/

Xamarin.Forms 于 2016 年推出 DataPages，并以预览版的形式提供，供用户试用。

注意：这是试用模块，以学习编程思维为主，了解 DataPages 的使用过程及其如何便利化编程工作。

DataPages 提供了一个 API，用于快速轻松地将数据源绑定到预先生成的视图。 数据将以列表项和详细信息页自动呈现，并可使用主题进行自定义。使开发人员能够快速轻松地使用受支持的数据源，并使用可使用主题自定义的内置 UI 基架对其进行呈现。


预览版有一些可供使用的预生成数据源：

- JsonDataSource
- AzureDataSource 单独 NuGet
- AzureEasyTableDataSource  单独 NuGet


包括以下页面和控件，以便轻松绑定到提供的数据源：

- `ListDataPage` 请参阅入门示例。
- `DirectoryPage` 启用了分组的列表。
- `PersonDetailPage` 针对特定对象类型（联系人项）自定义的单个数据项视图。
- `DataView` 用于以一般方式从源公开数据的视图。
- `CardView` 包含图像、标题文本和说明文本的样式视图。
- `HeroImage` 像呈现视图。
- `ListItem` 预建的列表项视图，其布局类似于 iIOS 和 Android 本机的列表项。


在后台数据源遵循 IDataSource 接口。Xamarin.Forms 基础结构通过以下属性与数据源进行交互：

- Data 可显示的数据项的只读列表。
- IsLoading 一个布尔值，该值指示数据是否已加载并可用于呈现。
- [key] 用于检索元素的索引器。 键对应于数据项对象的命名属性。

有 MaskKey、 UnmaskKey 两种方法用于隐藏或显示数据项属性，即是否阻止其呈现。

使用 DataPages 要先安装依赖，DataPages 使用了 Xamarin.Forms 主题，必需安装主题基础，和任一主题包，安装 NuGet 包命令如下：

- dotnet add package Xamarin.Forms.pages --version 4.6.0.847
- dotnet add package Xamarin.Forms.theme.base --version 1.0.0.43-pre1
- dotnet add package Xamarin.Forms.theme.light --version 1.0.0.43-pre1
- dotnet add package Xamarin.Forms.theme.dark --version 1.0.0.43-pre1

在预览版本中，主题可能无法在运行时加载。 将下面显示的代码添加到相关项目中 LoadApplication 以修复此错误。

iOS 系统修改 AppDelegate.cs：

	var x = typeof(Xamarin.Forms.Themes.DarkThemeResources);
	x = typeof(Xamarin.Forms.Themes.LightThemeResources);
	x = typeof(Xamarin.Forms.Themes.iOS.UnderlineEffect);

Android 系统修改 MainActivity.cs：

	var x = typeof(Xamarin.Forms.Themes.DarkThemeResources);
	x = typeof(Xamarin.Forms.Themes.LightThemeResources);
	x = typeof(Xamarin.Forms.Themes.Android.UnderlineEffect);


在 App.xaml 中合并主题样式设置：

	<Application xmlns="http://xamarin.com/schemas/2014/forms"
	  xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	  xmlns:mytheme="clr-namespace:Xamarin.Forms.Themes;assembly=Xamarin.Forms.Theme.Light"
	  x:Class="DataPagesDemo.App">
	    <Application.Resources>
	        <ResourceDictionary MergedWith="mytheme:LightThemeResources" />
	    </Application.Resources>
	</Application>


编写视图类：

	namespace XamarinVS2019.Views
	{
		public partial class SessionDataPage : Xamarin.Forms.Pages.ListDataPage // was ContentPage
		{
			public SessionDataPage ()
			{
				InitializeComponent ();
			}
		}

	}

视图 xaml 文件，其中模板是可选的，通过指定模板 ListDataPage.DefaultItemTemplate 和使用数据源绑定，可以重写继承的样式。

	<?xml version="1.0" encoding="utf-8" ?>
	<p:ListDataPage
	    xmlns="http://xamarin.com/schemas/2014/forms"
	    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	    xmlns:pages="clr-namespace:Xamarin.Forms.Pages;assembly=Xamarin.Forms.Pages"
	    x:Class="XamarinVS2019.Views.SessionDataPage"
	    Title="Sessions" StyleClass="Events"
	    >
	    <p:ListDataPage.DataSource>
	        <p:JsonDataSource Source="http://192.168.0.109:5001/sessions.json" />
	    </p:ListDataPage.DataSource>

	    <p:ListDataPage.DefaultItemTemplate>
	        <DataTemplate>
	            <ViewCell>
	                <p:ListItemControl
	                    Title="{p:DataSourceBinding title}"
	                    Detail="{p:DataSourceBinding room}"
	                    ImageSource="{p:DataSourceBinding image}"
	                    DataSource="{Binding Value}"
	                    HeightRequest="90"
	                >
	                </p:ListItemControl>
	            </ViewCell>
	        </DataTemplate>
	    </p:ListDataPage.DefaultItemTemplate>

	    <!-- <p:ContentPage.Content> -->
	    
	    <!-- </p:ContentPage.Content> -->
	</p:ListDataPage>


sessions.json

	[{
	  "end": "2016-04-27T18:00:00Z",
	  "start": "2016-04-27T17:15:00Z",
	  "abstract": "The new Apple TV has been released, and YOU can be one of the first developers to write apps for it. To make things even better, you can build these apps in C#! This session will introduce the basics of how to create a tvOS app with Xamarin, including: differences between tvOS and iOS APIs, TV user interface best practices, responding to user input, as well as the capabilities and limitations of building apps for a television. Grab some popcorn—this is going to be good!",
	  "title": "As Seen On TV … Bringing C# to the Living Room",
	  "presenter": "Matthew Soucoup",
	  "biography": "Matthew is a Xamarin MVP and Certified Xamarin Developer from Madison, WI. He founded his company Code Mill Technologies and started the Madison Mobile .Net Developers Group.  Matt regularly speaks on .Net and Xamarin development at user groups, code camps and conferences throughout the Midwest. Matt gardens hot peppers, rides bikes, and loves Wisconsin micro-brews and cheese.",
	  "image": "http://i.imgur.com/ASj60DP.jpg",
	  "avatar": "http://i.imgur.com/ASj60DP.jpg",
	  "room": "Crick"
	}]


### Alert Prompt ActionSheet
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/pop-ups

显示警报，要求用户进行选择或显示提示是常见的 UI 任务。 Xamarin.Forms在类上有三种方法 Page ，可通过弹出窗口与用户进行交互： DisplayAlert 、 DisplayActionSheet 和 DisplayPromptAsync 。 在每个平台上使用相应的本机控件呈现。


所有 Xamarin.Forms 受支持的平台都有一个模式弹出窗口，用于向用户发出警报，或向他们询问简单的问题。 若要在中显示这些警报 Xamarin.Forms ，请 DisplayAlert 在任何上使用方法 Page 。 以下代码行向用户显示一个简单的消息：

	await DisplayAlert ("Alert", "You have been alerted", "OK");

DisplayAlert 方法还可用于通过呈现两个按钮并返回来捕获用户的响应 boolean 。 要从警报中获得响应，请为两个按钮和 await 方法提供文本。 在用户选择其中一个选项后，答案将返回到你的代码。 注意下面示例代码中的 async 和 await 关键字：

	async void OnAlertYesNoClicked (object sender, EventArgs e)
	{
	  bool answer = await DisplayAlert ("Question?", "Would you like to play a game", "Yes", "No");
	  Debug.WriteLine ("Answer: " + answer);
	}

UIActionSheet 是 iOS 中的常见 UI 元素。 Xamarin.Forms DisplayActionSheet 方法允许将此控件包含在跨平台应用程序中，从而在 ANDROID 和 UWP 中呈现本机替代项。
要显示操作表（任何 Page 中的 await DisplayActionSheet），请将消息和按钮标签作为字符串传递。 该方法返回供用户单击的按钮的字符串标签。 下面是简单示例：

	async void OnActionSheetSimpleClicked (object sender, EventArgs e)
	{
	  string action = await DisplayActionSheet ("ActionSheet: Send to?", "Cancel", null, "Email", "Twitter", "Facebook");
	  Debug.WriteLine ("Action: " + action);
	}

destroy 按钮的呈现方式与其他按钮不同，可以保留 null 或指定为第三个字符串参数。 下面的示例使用 destroy 按钮：

	async void OnActionSheetCancelDeleteClicked (object sender, EventArgs e)
	{
	  string action = await DisplayActionSheet ("ActionSheet: SavePhoto?", "Cancel", "Delete", "Photo Roll", "Email");
	  Debug.WriteLine ("Action: " + action);
	}

若要显示提示，请调用 DisplayPromptAsync in any Page ，同时传递标题和消息作为 string 参数：

	string result = await DisplayPromptAsync("Question 1", "What's your name?");

如果点击 "确定" 按钮，则输入的响应将返回为 string 。 如果点击 "取消" 按钮， null 则返回。

该方法的完整参数列表 DisplayPromptAsync 为：

- `title` 类型为 string 它是要在提示中显示的标题。
- `message` 类型为 string 是要在提示中显示的消息。
- `accept` 类型为 string 它是 "接受" 按钮的文本。 这是一个可选参数，其默认值为 "正常"。
- `cancel` 类型为 string 它是 "取消" 按钮的文本。 这是一个可选参数，其默认值为 "取消"。
- `placeholder` 类型为 string 它是要在提示中显示的占位符文本。 这是一个可选参数，其默认值为 null 。
- `maxLength` 类型为int 最大长度为用户响应的最大长度。 这是一个可选参数，其默认值为 -1。
- `keyboard` 类型为 Keyboard 用于设置用户响应的键盘类型。 这是一个可选参数，其默认值为 Keyboard.Default 。
- `initialValue` 类型为 string 预定义响应将显示，并且可以编辑。 这是一个可选参数，其默认值为空字符串。

下面的示例演示如何设置一些可选参数：

	string result = await DisplayPromptAsync("Question 2", "What's 5 + 5?", initialValue: "10", maxLength: 2, keyboard: Keyboard.Numeric);




### Label & FormattedString
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/text/label

Label视图用于显示文本，同时为单行和多行。 除了通用的 Padding 和 Margin，标签可以具有文本修饰、彩色文本和使用自定义字体（系列、大小和选项）。

	<Label Text="Welcome to Xamarin.Forms!"
	       TextColor="Blue"
	       FontAttributes="Italic"
	       CharacterSpacing="10"
	       FontSize="22"
	       TextDecorations="Underline"
	       HorizontalOptions="Center" >
	    <Label.FormattedText>
	        <FormattedString>
	            <Span Text="This sentence contains " />
	            <Span Text="words that are emphasized, " FontAttributes="Italic" />
	            <Span Text="and underlined." TextDecorations="Underline" />
	        </FormattedString>
	    </Label.FormattedText>
	</Label>

可以将 Label.TextDecorations 属性设置为一个或多个枚举成员，将下划线和删除线文本修饰应用到实例：

| 成员		| 值	| 意义	| 
| :------	| :------	| :------	|
| None		| 0	| 无文本效果。 |
| Strikethrough	| 2	| 单行删除线。 |
| Underline	| 1	| 文本下划线。 |

FontAttributes 枚举：

| 成员		| 值	| 意义	| 
| :------	| :------	| :------	|
| Bold		| 1	| 字体为粗体。 |
| Italic	| 2	| 字体为斜体。 |
| None		| 0	| 字体为未修改。 |

XAML 中的文本强制插入新行可以使用 unicode 换行符，即 `&#10;` 或使用属性元素语法指定文本。

下面的代码演示了这两种方法的示例：

	<!-- Unicode line feed character -->
	<Label Text="First line &#10; Second line" />

	<!-- Property element syntax -->
	<Label>
	    <Label.Text>
	        First line
	        Second line
	    </Label.Text>
	</Label>

在 C# 中，可以使用 "\n" 字符将文本强制到新行：

	Label label = new Label { Text = "First line\nSecond line" };

在一行上容纳不下的文本，设置 LineBreakMode 属性，LineBreakMode 枚举值：

- `HeadTruncation` 截断文本的开头，并显示结束。
- `CharacterWrap` 将文本换行到字符边界处的新行。
- `MiddleTruncation` 显示文本的开头和结尾，中间用省略号替换。
- `NoWrap` 不会自动换行，只显示一行中可容纳的最多文本。
- `TailTruncation` 显示文本的开头，截断结束。
- `WordWrap` 在字边界处环绕文本。

Label 可以将 MaxLines 属性设置指定要显示的行数：

- `MaxLines` 为 -1 默认值，则会考虑 LineBreakMode 设置仅显示一行（可能已截断）或包含所有文本。
- `MaxLines` 为 0，则 Label 不会显示。
- `MaxLines` 为 1，则结果与将 LineBreakMode 属性设置为 NoWrap、HeadTruncation、MiddleTruncation、TailTruncation 相同。 但是， Label 如果适用，将遵循 LineBreakMode 与省略号的位置有关的属性值。
- `MaxLines` 大于 1 时， Label 将显示多达指定的行数，同时遵从 LineBreakMode。如果将属性设置为 NoWrap 将不适用行数指定 。

TextType 属性指定设置枚举值显示纯文本或 HTML 文本：

- `Text` 指示 Label 将显示纯文本，并且为属性的默认值。
- `Html` 指示 Label 将显示 HTML 文本。

另外，为了提高可读性，可以在节中内联 HTML CDATA ：

	<Label TextType="Html">
	    <![CDATA[
	    This is <strong style="color:red">HTML</strong> text.
	    ]]>
	</Label>


FormattedText 属性的类型为 FormattedString ，它包含一个或多个 Span 实例，通过属性进行设置 Spans 。 

以下 Span 属性可用于设置视觉外观：

- `BackgroundColor` 跨距背景的颜色。
- `CharacterSpacing`，属于 double 类型，是 Span 文本字符之间的间距。
- `Font` Span 中的文本的字体。
- `FontAttributes` 范围中文本的字体特性。
- `FontFamily` 范围内的文本的字体所属的字体系列。
- `FontSize` 范围中文本的字体大小。
- `ForegroundColor` 范围中文本的颜色。 此属性已过时，并且已被属性替换 `TextColor` 。
- `LineHeight` 要应用于范围默认行高的乘数。 
- `Style` 应用于范围的样式。
- `Text` 范围的文本。
- `TextColor` 范围中文本的颜色。
- `TextDecorations` 要应用于范围中的文本的修饰。

BackgroundColor、 Text 和可 Text 绑定属性的默认绑定模式为 OneWay 。

超链接实现：

- 添加 TapGestureRecognizer 到 GestureRecognizers 集合属性，设置其 Command 属性绑定到一个 ICommand 对象，将 URL 绑定到 CommandParameter 属性。
- 定义 ICommand 执行 TapGestureRecognizer 事件响应 Tapped。
- 编写 ICommand 执行代码，通过 Launcher.OpenAsync(url) 打开超链接。

下面的代码示例摘自 Hyperlink 演示示例，它显示了 Label 其内容是从多个实例设置的 Span ：

	<Label>
	    <Label.FormattedText>
	        <FormattedString>
	            <Span Text="Alternatively, click " />
	            <Span Text="here"
	                  TextColor="Blue"
	                  TextDecorations="Underline">
	                <Span.GestureRecognizers>
	                    <TapGestureRecognizer Command="{Binding TapCommand}"
	                                          CommandParameter="https://docs.microsoft.com/xamarin/" />
	                </Span.GestureRecognizers>
	            </Span>
	            <Span Text=" to view Xamarin documentation." />
	        </FormattedString>
	    </Label.FormattedText>
	</Label>

XAML 页的 TapCommand 实现代码：

	public partial class MainPage : ContentPage
	{
	    // Launcher.OpenAsync is provided by Xamarin.Essentials.
	    public ICommand TapCommand => new Command<string>(async (url) => await Launcher.OpenAsync(url));

	    public MainPage()
	    {
	        InitializeComponent();
	        BindingContext = this;
	    }
	}

TapCommand 执行 Launcher.OpenAsync 方法，并将 TapGestureRecognizer.CommandParameter 属性值作为参数传递。 Launcher.OpenAsync 方法由提供 Xamarin.Essentials ，并在 web 浏览器中打开该 URL。 因此，整体效果是，当在页面上点击超链接时，将显示一个 web 浏览器，并导航到与该超链接关联的 URL。


### HyperlinkSpan 

为了重用超链接组件，创建可重用的超链接类。

Label 和 Span 类都可以创建子类来实现 HyperlinkLabel 和 HyperlinkSpan 类，并在其中添加了手势识别器和文本格式代码。

下面的 Hyperlink 演示通过创建可绑定属性 BindableProperty 实现一个 HyperlinkSpan 类，Url 成为可绑定字符串的属性：

	public class HyperlinkSpan : Span
	{
	    public static readonly BindableProperty UrlProperty =
	        BindableProperty.Create(nameof(Url), typeof(string), typeof(HyperlinkSpan), null);

	    public string Url
	    {
	        get { return (string)GetValue(UrlProperty); }
	        set { SetValue(UrlProperty, value); }
	    }

	    public HyperlinkSpan()
	    {
	        TextDecorations = TextDecorations.Underline;
	        TextColor = Color.Blue;
	        GestureRecognizers.Add(new TapGestureRecognizer
	        {
	            // Launcher.OpenAsync is provided by Xamarin.Essentials.
	            Command = new Command(async () => await Launcher.OpenAsync(Url))
	        });
	    }
	}

HyperlinkSpan 类定义 Url 属性和关联的 BindableProperty ，并且构造函数设置超链接的外观，以及在 TapGestureRecognizer 点击超链接时将做出响应。 点击时 HyperlinkSpan， TapGestureRecognizer 将通过执行方法来做出响应， Launcher.OpenAsync 以便 Url 在 web 浏览器中打开由属性指定的 URL。

HyperlinkSpan 可以通过将类的实例添加到 XAML 来使用类：

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             xmlns:local="clr-namespace:HyperlinkDemo"
	             x:Class="HyperlinkDemo.MainPage">
	    <StackLayout>
	        ...
	        <Label>
	            <Label.FormattedText>
	                <FormattedString>
	                    <Span Text="Alternatively, click " />
	                    <local:HyperlinkSpan Text="here"
	                                         Url="https://docs.microsoft.com/appcenter/" />
	                    <Span Text=" to view AppCenter documentation." />
	                </FormattedString>
	            </Label.FormattedText>
	        </Label>
	    </StackLayout>
	</ContentPage>



### Fonts
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/text/fonts

显示文本的任何控件都有三个与字体相关的属性：

- FontFamily 字体名称 string。
- FontSize 字体大小 double 。
- FontAttributes 一个字符串，指定样式信息，如斜体和粗体。

此代码演示如何创建标签，并指定要显示的字体大小和粗细：

	var about = new Label
	{
	    FontSize = Device.GetNamedSize (NamedSize.Medium, typeof(Label)),
	    FontAttributes = FontAttributes.Bold | FontAttributes.Italic,
	    Text = "Medium Bold Font"
	};


大小值以与设备无关的单位来度量，除了使用数值指定字体大小，Xamarin.Forms 定义 NamedSize 枚举字段。 下表显示了 NamedSize 成员以及它们在 iOS、Android 和通用 Windows 平台（UWP）上的默认大小：

| 成员		| iOS	| Android	| UWP |
| :------	| :------	| :------	| :------ 	
| Default	| 16	| 14	| 14 |
| Micro		| 11	| 10	| 15.667 |
| Small		| 13	| 14	| 18.667 |
| Medium	| 16	| 17	| 22.667 |
| Large		| 20	| 22	| 32 |
| Body		| 17	| 16	| 14 |
| Header	| 17	| 96	| 46 |
| Title		| 28	| 24	| 24 |
| Subtitle	| 22	| 16	| 20 |
| Caption	| 12	| 12	| 12 |

Device.RuntimePlatform 属性在 XAML 中用于指定每个平台上呈现不同的字体：

	<Label Text="Hello Forms with XAML">
	    <Label.FontFamily>
	        <OnPlatform x:TypeArguments="x:String">
	                <On Platform="iOS" Value="MarkerFelt-Thin" />
	                <On Platform="Android" Value="Lobster-Regular.ttf#Lobster-Regular" />
	                <On Platform="UWP" Value="Assets/Fonts/ArimaMadurai-Black.ttf#Arima Madurai" />
	        </OnPlatform>
	    </Label.FontFamily>
	</Label>

或者，以 C# 代码使用 Device.RuntimePlatform 在每个平台上设置不同的字体名称：

	label.FontFamily = Device.RuntimePlatform == Device.iOS ? "MarkerFelt-Thin" :
	   Device.RuntimePlatform == Device.Android ? "Lobster-Regular.ttf#Lobster-Regular" : "Assets/Fonts/ArimaMadurai-Black.ttf#Arima Madurai",
	label.FontSize = Device.RuntimePlatform == Device.iOS ? 24 :
	   Device.RuntimePlatform == Device.Android ? Device.GetNamedSize(NamedSize.Medium, label) : Device.GetNamedSize(NamedSize.Large, label);

使用 Xamarin.Forms 4.5.0.530 或更高版本，可以嵌入自定义字体到 Xamarin.Forms 的共享项目中，并可由平台项目使用，完成此目的的过程如下所示：

- 将字体 Xamarin.Forms 作为嵌入资源添加到共享项目，设置项目中文件属性的生成操作 Build Action 为 EmbeddedResource。
- 使用属性在文件（如AssemblyInfo.cs）中将字体文件注册到程序集 ExportFont 。

下面的示例显示了向程序集注册的 Lobster 常规字体以及别名：

	using Xamarin.Forms;

	[assembly: ExportFont("Lobster-Regular.ttf", Alias = "Lobster")]

该字体可以驻留在共享项目的任何文件夹中，而无需在向程序集注册字体时指定文件夹名称。

然后，可以在每个平台上使用该字体，只需引用其名称或别名，无需文件扩展名：

	<Label Text="Hello Xamarin.Forms" FontFamily="Lobster-Regular" />

	<Label Text="Hello Xamarin.Forms" FontFamily="Lobster" />

等效 C# 代码如下：

	Label label1 = new Label
	{
	    Text = "Hello Xamarin.Forms!",
	    FontFamily = "Lobster-Regular"
	};

	// Use font alias
	Label label2 = new Label
	{
	    Text = "Hello Xamarin.Forms!",
	    FontFamily = "Lobster"
	};

Xamarin.Forms 应用程序可以使用字体图标，FontImageSource 类派生自 ImageSource 类，具有以下属性：

- `Glyph` 指定为的字体图标的 unicode 字符值 string 。
- `Size`一个 double 值，指示字体图标的大小，以与设备无关的单位 dp，默认值为 30。可以设置为命名字体大小。
- `FontFamily` 表示字体图标所属的字体名称或别名。
- `Color` Color 显示字体图标时要使用的可选值。

此数据用于创建一个 PNG，可以通过任何可显示的视图来显示该 PNG ImageSource 。 此方法允许多个视图显示字体图标如表情符号，例如 Label 中的文字。

下面的 XAML 示例显示一个由视图显示的字体图标 Image ：

	<Image BackgroundColor="#D1D1D1">
	    <Image.Source>
	        <FontImageSource Glyph="&#xf30c;"
	                         FontFamily="{OnPlatform iOS=Ionicons, Android=ionicons.ttf#}"
	                         Size="44" />
	    </Image.Source>
	</Image>

此代码在视图中显示 Ionicons 字体系列的 XBox 图标 Image 。 请注意，虽然此图标的 unicode 字符是 \uf30c ，但它必须在 XAML 中进行转义 `&#xf30c;` 。 等效 C# 代码如下：

	Image image = new Image { BackgroundColor = Color.FromHex("#D1D1D1") };
	image.Source = new FontImageSource
	{
	    Glyph = "\uf30c",
	    FontFamily = Device.RuntimePlatform == Device.iOS ? "Ionicons" : "ionicons.ttf#",
	    Size = 44
	};


### Images
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/images

Xamarin.Forms使用 Image 视图在页面上显示图像。 它有两个重要属性：

- `Source` ImageSource 实例，文件、Uri 或资源，用于设置要显示的图像。
- `Aspect` 如何在它所显示的边界内调整图像大小（是伸展、裁剪还是黑边）。

`ImageSource` 对于每种类型的映像源，都可以使用静态方法获取实例：

- `FromFile` 需要可在每个平台上解析的文件名或文件路径。
- `FromUri` 需要 Uri 对象，例如。 new Uri("http://server.com/image.jpg") .
- `FromResource` 通过  EmbeddedResource 资源标识符从应用程序或 .NET Standard 库项目中读取嵌入的图像文件。
- `FromStream` 需要提供图像数据的流。

`Aspect` 属性确定如何缩放图像以适合显示区域：

- `Fill` 将图像拉伸到完全完全填充显示区域。 这可能会导致图像扭曲。
- `AspectFill` 剪辑图像，使其在保留该方位（即无扭曲）的情况下填充显示区域。
- `AspectFit` 框住图像（如有必要），以便将整个图像适应显示区域，并根据图像的宽度或高度增加空白区域。

可以从本地文件、嵌入资源、下载或从流中加载图像，可以省略扩展名。 此外，Image 通过在对象中指定字体图标数据，可通过视图显示字体图标 `FontImageSource`。

	<Image Source="waterfront.jpg" />
	<Image Source="drawable/waterfront" Aspect="Fill" HorizontalOptions="Center" />

	var image = new Image { Source = "waterfront.jpg" };

为了获得更大的灵活性 Device.RuntimePlatform ，此属性可用于为某些或所有平台选择不同的图像文件或路径，如以下代码示例所示：

	image.Source = Device.RuntimePlatform == Device.Android
                ? ImageSource.FromFile("waterfront.jpg")
                : ImageSource.FromFile("Images/waterfront.jpg");

若要在所有平台上使用相同的映像文件名，该名称必须在所有平台上都有效。 Android 绘图具有命名限制只允许使用小写字母、数字、下划线和句点，对于跨平台兼容性，还必须在所有其他平台上遵循这一点。 示例文件名 waterfront.png 遵循规则，无效文件名的示例包括 "water front.png"、"WaterFront.png"、"water-front.png" 和 "wåterfront.png"。

某些控件具有显示图像的属性，例如：

- Button 具有一个 ImageSource 属性，设置为要在上显示的位图。
- ImageButton 具有 Source 可设置为要显示的图像的属性。
- ToolbarItem 具有一个 IconImageSource 属性，该属性可设置为从文件、嵌入资源、URI 或流加载的图像。
- ImageCell 具有一个 ImageSource 属性，该属性可设置为从文件、嵌入资源、URI 或流中检索的图像。
- Page 派生自的任何页类型 Page 都具有 IconImageSource 和 BackgroundImageSource 属性，可以为其分配文件、嵌入资源、URI 或流。 NavigationPage ContentPage 显示图标，如果平台支持。

如果将嵌入的图像放入项目中的文件夹，则在资源 ID 中，文件夹名称还由句点分隔。 将 beach.jpg 图像移动到名为 MyImages 的文件夹中会导致资源 ID 为 WorkingWithImages.MyImages.beach.jpg，加载嵌入图像的代码只是将资源 ID 传递到方法，如下 ImageSource.FromResource 所示：

	var embeddedImage = new Image {
	      Source = ImageSource.FromResource(
	        "WorkingWithImages.beach.jpg",
	        typeof(EmbeddedImages).GetTypeInfo().Assembly
	      ) };

为图片添加事件处理：

	<Image Source="MonoMonkey.jpg">
	  <Image.GestureRecognizers>
	    <PanGestureRecognizer PanUpdated="OnPanUpdated" />
	  </Image.GestureRecognizers>
	</Image>

	void OnPanUpdated (object sender, PanUpdatedEventArgs e)
	{
	  // Handle the pan
	}

若要在项目中嵌入图像，请右键单击项目， "添加新项"，然后选择要添加的映像。 默认情况下，该映像将设置 Build Acition 生成操作 None，需要设置为 EmbeddedResource，那么在项目文件中就有相应的嵌入文件记录。

	<Project Sdk="Microsoft.NET.Sdk">

	  <PropertyGroup>
	    <TargetFramework>netstandard2.0</TargetFramework>
	    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
	  </PropertyGroup>

	  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
	    <DebugType>full</DebugType>
	  </PropertyGroup>

	  <ItemGroup>
	    <None Remove="Media\BananaMatte.png" />
	    <None Remove="Media\MonkeyFace.png" />
	    <None Remove="Media\StoneWallTile.jpg" />
	  </ItemGroup>

	  <ItemGroup>
	    <PackageReference Include="SkiaSharp" Version="1.60.0" />
	    <PackageReference Include="SkiaSharp.Views.Forms" Version="1.60.0" />
	    <PackageReference Include="Xamarin.Forms" Version="4.6.0.726" />
	  </ItemGroup>

	  <ItemGroup>
	    <EmbeddedResource Update="Bitmaps\BitmapRotatorPage.xaml">
	      <Generator>MSBuild:UpdateDesignTimeXaml</Generator>
	    </EmbeddedResource>
	  </ItemGroup>

	  <ItemGroup>
	    <EmbeddedResource Include="Media\monkey.png" />
	    <EmbeddedResource Include="Media\Banana.jpg" />
	  </ItemGroup>

	  <ItemGroup>
	    <Compile Update="Bitmaps\BitmapRotatorPage.xaml.cs">
	      <DependentUpon>BitmapRotatorPage.xaml</DependentUpon>
	    </Compile>
	  </ItemGroup>

	</Project>


如果将嵌入的图像放入项目中的文件夹，则在资源 ID 中，文件夹名称还由句点（.）分隔。 将 beach.jpg 图像移动到名为 MyImages 的文件夹中会导致资源 ID 为 WorkingWithImages.MyImages.beach.jpg。

加载嵌入图像的代码只是将资源 ID 传递到方法，如下 ImageSource.FromResource 所示：

	var embeddedImage = new Image {
	      Source = ImageSource.FromResource(
	        "WorkingWithImages.beach.jpg",
	        typeof(EmbeddedImages).GetTypeInfo().Assembly
	      ) };

使用 XAML 中指定的资源 ID来编写简单的自定义 XAML 标记扩展以加载图像：

	[ContentProperty (nameof(Source))]
	public class ImageResourceExtension : IMarkupExtension
	{
	 public string Source { get; set; }

	 public object ProvideValue (IServiceProvider serviceProvider)
	 {
	   if (Source == null)
	   {
	     return null;
	   }

	   // Do your translation lookup here, using whatever method you require
	   var imageSource = ImageSource.FromResource(Source, typeof(ImageResourceExtension).GetTypeInfo().Assembly);

	   return imageSource;
	 }
	}

若要使用此扩展 xmlns ，请使用项目的正确命名空间和程序集值将自定义添加到 XAML。 然后，可以使用以下语法设置图像源： {local:ImageResource WorkingWithImages.beach.jpg} 。 完整的 XAML 示例如下所示：

	<?xml version="1.0" encoding="UTF-8" ?>
	<ContentPage
	   xmlns="http://xamarin.com/schemas/2014/forms"
	   xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	   xmlns:local="clr-namespace:WorkingWithImages;assembly=WorkingWithImages"
	   x:Class="WorkingWithImages.EmbeddedImagesXaml">
	 <StackLayout VerticalOptions="Center" HorizontalOptions="Center">
	   <!-- use a custom Markup Extension -->
	   <Image Source="{local:ImageResource WorkingWithImages.beach.jpg}" />
	 </StackLayout>
	</ContentPage>

自动下载图像以进行显示，如下面的 XAML 所示：

	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	       x:Class="WorkingWithImages.DownloadImagesXaml">
	  <StackLayout VerticalOptions="Center" HorizontalOptions="Center">
	    <Label Text="Image UriSource Xaml" />
	    <Image Source="https://xamarin.com/content/images/pages/forms/example-app.png" />
	    <Label Text="example-app.png gets downloaded from xamarin.com" />
	  </StackLayout>
	</ContentPage>

等效的 c # 代码如下所示：

	var webImage = new Image {
	     Source = ImageSource.FromUri(
	        new Uri("https://xamarin.com/content/images/pages/forms/example-app.png")
	     ) };

ImageSource.FromUri方法需要一个 Uri 对象，并返回一个 UriImageSource 从中读取的新 Uri 。

还存在对 URI 字符串的隐式转换，因此下面的示例也适用：

	webImage.Source = "https://xamarin.com/content/images/pages/forms/example-app.png";

UriImageSource 还支持缓存下载的映像，这些映像通过以下属性进行配置：

- `CachingEnabled` 是否启用缓存（ true 默认值）。
- `CacheValidity` 一个 TimeSpan ，它定义将在本地存储图像的时间长度。

默认情况下，缓存处于启用状态，并将在本地存储该图像24小时。 若要为特定映像禁用缓存，请按如下所示实例化映像源：

	image.Source = new UriImageSource { CachingEnabled = false, Uri = new Uri("http://server.com/image") };

若要设置特定的缓存时间段（例如5天），请按如下所示实例化映像源：

	webImage.Source = new UriImageSource
	{
	    Uri = new Uri("https://xamarin.com/content/images/pages/forms/example-app.png"),
	    CachingEnabled = true,
	    CacheValidity = new TimeSpan(5,0,0,0)
	};

利用内置缓存，可以非常轻松地支持图像滚动列表等方案，在这些方案中，你可以在每个单元格中设置（或绑定）一个图像，并让内置缓存在单元格滚动回 "查看" 时，处理重新加载该图像。

默认情况下，加载动画 GIF 后，不会播放它。 这是因为， IsAnimationPlaying 用于控制动画 GIF 播放或停止的属性的默认值为 false 。 此属性的类型 bool 为，它是 BindableProperty 数据绑定属性。

此外， Image 通过在对象中指定字体图标数据，可通过视图显示字体图标 FontImageSource 。 有关详细信息，请参阅字体指南。


### BoxView
- [BoxView 装饰盒块](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/boxview)
- [康威生命游戏 Conway's Game of Life](https://docs.microsoft.com/zh-cn/samples/xamarin/xamarin-forms-samples/boxview-gameoflife/)

Xamarin.Forms.BoxView 显示特定颜色的矩形，呈现指定的宽度、高度和颜色的简单矩形。 你可以使用 BoxView 来装饰、基本图形以及通过它的触摸事件来与用户交互。

BoxView 要点：

- 设置 BoxView 颜色和大小 –设置 BoxView 属性。

	- Color 设置颜色。
	- CornerRadius 设置圆角半径。
	- WidthRequest 设置宽度，dp 设备无关的单位。
	- HeightRequest 设置高度，dp 设备无关的单位。

- 呈现文本修饰 – 使用 BoxView 绘制线条。
- 用 BoxView – 列出颜色显示中的所有系统颜色 ListView 。
- 通过对 BoxView – 进行分类来玩生活游戏实现著名的手机网络自动机。
- 创建数字时钟 – 模拟点矩阵显示。
- 创建模拟时钟 – 转换和动画处理 BoxView 元素。

因为没有 Xamarin.Forms 内置矢量图形系统，所以 BoxView 有助于进行补偿。在 Xamarin.Forms 使用 SkiaSharp 以获得更复杂的图形要求。

    <BoxView Color="CornflowerBlue"
             CornerRadius="10"
             WidthRequest="160"
             HeightRequest="160"
             VerticalOptions="Center"
             HorizontalOptions="Center" />

	<AbsoluteLayout>
	    <BoxView AbsoluteLayout.LayoutBounds="0, 10, 200, 5" />
	    <BoxView AbsoluteLayout.LayoutBounds="0, 20, 200, 5" />
	    <BoxView AbsoluteLayout.LayoutBounds="10, 0, 5, 65" />
	    <BoxView AbsoluteLayout.LayoutBounds="20, 0, 5, 65" />
	    <Label Text="Stylish Header"
	           FontSize="24"
	           AbsoluteLayout.LayoutBounds="30, 25, AutoSize, AutoSize"/>
	</AbsoluteLayout>

	<StackLayout Orientation="Horizontal">
        <BoxView WidthRequest="4" BackgroundColor="Aqua" Margin="0, 0, 10, 0" />
	    <Label>

	        给标签左侧加竖线或色块

	    </Label>
	</StackLayout>

如果 VerticalOptions 和 HorizontalOptions 属性缺省或者设置为 Fill ，则将 BoxView 被页大小约束，并扩展以填充页。

Game of Life 是 BoxView 使用的极好的示例。




### Checkbox
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/checkbox

CheckBox定义一个 bool 名为的属性 IsChecked ，指示是否 CheckBox 选中。 对象也支持此属性，这 BindableProperty 意味着它可以进行样式设计，并且是数据绑定的目标。IsChecked 绑定的属性的默认绑定模式为 BindingMode.TwoWay 。

定义一个 CheckedChanged 事件，该事件在用户操作或应用程序设置 IsChecked 属性时触发。 CheckedChangedEventArgs 事件附带的对象具有名为 Value 的属性，类型为 bool 。 触发事件时，属性的值 Value 设置为属性的新值 IsChecked 。

	<CheckBox Color="Red" />
	<CheckBox IsChecked="true" />
	<CheckBox CheckedChanged="OnCheckBoxCheckedChanged" />


代码文件包含 CheckedChanged 事件的处理程序：

	CheckBox checkBox = new CheckBox { IsChecked = true };

	checkBox.CheckedChanged += (sender, e) =>
	{
	    // Perform required operation after examining e.Value
	};

	void OnCheckBoxCheckedChanged(object sender, CheckedChangedEventArgs e)
	{
	    // Perform required operation after examining e.Value
	}

有时，应用程序会进入处于选中状态的状态，该状态 CheckBox 是无效操作。 在这种情况下， CheckBox 可以通过将其 IsEnabled 属性设置为 false 来禁用。

复选框包含一个可视状态 VisualState，它可用于在视觉上更改 CheckBox。

下面的 XAML 示例演示可视状态，IsChecked 勾选时，显示为绿色，Normal 状态为红色 ：

	<CheckBox ...>
	    <VisualStateManager.VisualStateGroups>
	        <VisualStateGroup x:Name="CommonStates">
	            <VisualState x:Name="Normal">
	                <VisualState.Setters>
	                    <Setter Property="Color" Value="Red" />
	                </VisualState.Setters>
	            </VisualState>

	            <VisualState x:Name="IsChecked">
	                <VisualState.Setters>
	                    <Setter Property="Color" Value="Green" />
	                </VisualState.Setters>
	            </VisualState>
	        </VisualStateGroup>
	    </VisualStateManager.VisualStateGroups>
	</CheckBox>






### Slider 滑块
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/slider

Slider 定义类型的三个 double 值属性：

- Minimum 范围的最小值，默认值为 0。
- Maximum 范围的最大值，默认值为 1。
- Value 滑块的值，默认值为 0。

所有三个属性都由 BindableProperty 对象支持。 Value 属性的默认绑定模式为 BindingMode.TwoWay ，这意味着它适用于 MVVM 体系结构的应用程序中的绑定源。

提供的 `ValueChanged` 事件在 Value 变更时通知用户在操作 Slider 或在程序设置属性时被触发。

ValueChangedEventArgs 事件参数附带的对象具有两个 double 属性参数，OldValue 和 NewValue，表示触发事件时的旧值和变更后的值。

定义了 `DragStarted` 和 `DragCompleted` 事件，这些事件在拖动操作的开始和结束时激发，事件仅通过用户操作触发 Slider 。 当 DragStarted 事件触发时，执行类型为的 ICommand 的 DragStartedCommand。 同样，当引发 DragCompleted 事件时，执行类型为的 ICommand 的 DragCompletedCommand。

Slider还定义了多个影响其外观的属性：

- `MinimumTrackColor` 是滚动块左侧的条形颜色。
- `MaximumTrackColor` 是滚动块右侧的条形颜色。
- `ThumbColor` 为滑块颜色。
- `ThumbImageSource` 用于类型的缩略图的图像 ImageSource 。

在代码中创建滑块示范：

	public class BasicSliderCodePage : ContentPage
	{
	    public BasicSliderCodePage()
	    {
	        Label rotationLabel = new Label
	        {
	            Text = "ROTATING TEXT",
	            FontSize = Device.GetNamedSize(NamedSize.Large, typeof(Label)),
	            HorizontalOptions = LayoutOptions.Center,
	            VerticalOptions = LayoutOptions.CenterAndExpand
	        };

	        Label displayLabel = new Label
	        {
	            Text = "(uninitialized)",
	            HorizontalOptions = LayoutOptions.Center,
	            VerticalOptions = LayoutOptions.CenterAndExpand
	        };

	        Slider slider = new Slider
	        {
	            Maximum = 360
	        };
	        slider.ValueChanged += (sender, args) =>
	        {
	            rotationLabel.Rotation = slider.Value;
	            displayLabel.Text = String.Format("The Slider value is {0}", args.NewValue);
	        };

	        Title = "Basic Slider Code";
	        Padding = new Thickness(10, 0);
	        Content = new StackLayout
	        {
	            Children =
	            {
	                rotationLabel,
	                slider,
	                displayLabel
	            }
	        };
	    }
	}

数据绑定滑块

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             x:Class="SliderDemos.BasicSliderBindingsPage"
	             Title="Basic Slider Bindings"
	             Padding="10, 0">
	    <StackLayout>
	        <Label Text="ROTATING TEXT"
	               Rotation="{Binding Source={x:Reference slider},
	                                  Path=Value}"
	               FontSize="Large"
	               HorizontalOptions="Center"
	               VerticalOptions="CenterAndExpand" />

	        <Slider x:Name="slider" Maximum="360" />

	        <Label x:Name="displayLabel"
	               Text="{Binding Source={x:Reference slider},
	                              Path=Value,
	                              StringFormat='The Slider value is {0:F0}'}"
	               HorizontalOptions="Center"
	               VerticalOptions="CenterAndExpand" />
	    </StackLayout>
	</ContentPage>



### Switch 开关组件
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/switch

Switch控件定义以下属性：

- IsToggled 类型 boolean，是指示 Switch 是否打开的值。
- OnColor 是一个 Color ，它会影响 Switch 在切换或开启状态下呈现的颜色。
- ThumbColor 是 Color 滑块颜色。

对象支持这些属性 BindableProperty ，这意味着可以对其进行 Switch 样式化并成为数据绑定的目标。

Switch 控件定义一个 Toggled 事件在 IsToggled 属性更改时，通过用户操作或应用程序设置属性时引发。 ToggledEventArgs 事件附带的单个属性 Value ，类型为 bool 表示触发事件时， IsToggled 属性的值。

	<Switch OnColor="Orange" ThumbColor="Green" Toggled="OnToggled" />

在代码中创建时，还可以设置属性 Switch ：

	Switch switch = new Switch { OnColor = Color.Orange, ThumbColor = Color.Green };

	switch.Toggled += (sender, e) =>
	{
	    // Perform an action after examining e.Value
	}

	void OnToggled(object sender, ToggledEventArgs e)
	{
	    // Perform an action after examining e.Value
	}


### Picker 选择组件
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/picker/

Picker 显示项的简短列表，用户可从该列表中选择项。 Picker 定义以下属性:

- `Title` 类型 string ，默认为 null 。
- `TitleColor` 类型 Color ，用于显示文本的颜色 Title 。
- `ItemsSource` 类型 IList 、要显示的项的源列表，默认为 null 。
- `SelectedIndex对于` 类型 int ，则为选定项的索引，默认值为 -1。
- `SelectedItem` 类型 object 选定项，默认为 null 。
- `TextColor` 类型 Color ，用于显示文本的颜色，默认值为 Color.Default 。
- `FontAttributes` 类型 FontAttributes ，默认为 FontAtributes.None 。
- `FontFamily` 类型 string ，默认为 null 。
- `FontSize` 类型 double ，默认值为-1.0。
- `CharacterSpacing` 类型， double 它是所显示的项的字符之间的间距 Picker 。

所有属性都是由对象支持的 BindableProperty。

Picker第一次显示时不显示任何数据。 相反，其属性的值 Title 在 iOS 和 Android 平台上显示为占位符。当 Picker 获得焦点时，将显示其数据，用户可以选择项。

x:Name 指令类似 x:Key，定义一个标识名字，供 C# 代码引用，参考 Data Binding。

示范 XAML：

        <Picker x:Name="stretchPicker"
                Grid.Row="1" Grid.Column="1"
                SelectedIndexChanged="OnPickerSelectedIndexChanged">
            <Picker.ItemsSource>
                <x:Array Type="{x:Type local:BitmapStretch}">
                    <x:Static Member="local:BitmapStretch.None" />
                    <x:Static Member="local:BitmapStretch.Fill" />
                    <x:Static Member="local:BitmapStretch.Uniform" />
                    <x:Static Member="local:BitmapStretch.UniformToFill" />
                </x:Array>
            </Picker.ItemsSource>

            <Picker.SelectedIndex>
                0
            </Picker.SelectedIndex>
        </Picker>

生成 g.cs 类似代码：

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Xamarin.Forms.Build.Tasks.XamlG", "2.0.0.0")]
        private global::Xamarin.Forms.Picker stretchPicker;
                
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Xamarin.Forms.Build.Tasks.XamlG", "2.0.0.0")]
        private void InitializeComponent() {
            global::Xamarin.Forms.Xaml.Extensions.LoadFromXaml(this, typeof(ScalingModesPage));
            stretchPicker = global::Xamarin.Forms.NameScopeExtensions.FindByName<global::Xamarin.Forms.Picker>(this, "stretchPicker");
        }
    }

配套 C# 代码：

        private void OnPickerSelectedIndexChanged(object sender, EventArgs args)
        {
            BitmapStretch stretch = (BitmapStretch)stretchPicker.SelectedItem;
        }

Picker 支持一次选择一个项，激发 SelectedIndexChanged 事件， SelectedIndex 属性更新为选定项的索引，并且 SelectedItem 属性将更新为 object 表示选定项的。 SelectedIndex 属性是一个从零开始的数字，指示用户选择的项。 

Xamarin.Forms 2.3.4 之前，填充到只读 Items 集合中的数据类型为 `IList<string>`。 集合中的每一项都必须为类型 string 。 通过使用项列表初始化属性，可在 XAML 中使用 x:String 添加项 Items：

	<Picker Title="Select a monkey"
	        TitleColor="Red">
	  <Picker.Items>
	    <x:String>Baboon</x:String>
	    <x:String>Capuchin Monkey</x:String>
	    <x:String>Blue Monkey</x:String>
	    <x:String>Squirrel Monkey</x:String>
	    <x:String>Golden Lion Tamarin</x:String>
	    <x:String>Howler Monkey</x:String>
	    <x:String>Japanese Macaque</x:String>
	  </Picker.Items>
	</Picker>

下面显示了等效的 c # 代码：

	var picker = new Picker { Title = "Select a monkey", TitleColor = Color.Red };
	picker.Items.Add("Baboon");
	picker.Items.Add("Capuchin Monkey");
	picker.Items.Add("Blue Monkey");
	picker.Items.Add("Squirrel Monkey");
	picker.Items.Add("Golden Lion Tamarin");
	picker.Items.Add("Howler Monkey");
	picker.Items.Add("Japanese Macaque");

除了使用方法添加数据外 Items.Add ，还可以使用方法将数据插入集合中 Items.Insert 。


### Stepper 分档器组件
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/stepper

Xamarin.Forms Stepper 包含标记有减号和加号的两个按钮。 用户可以操作这些按钮以增量方式 double 从一系列值中选择一个值。

- `Stepper` 定义类型属性 double ：
- `Increment` 选定值的更改量，默认值为 1。
- `Minimum` 范围的最小值，默认值为 0。
- `Maximum` 范围的最大值，默认值为 100。
- `Value` 是分档器的值，它的范围可以介于和之间，其默认值为0。

所有这些属性都是由对象支持的 BindableProperty 。 Value属性的默认绑定模式为 BindingMode.TwoWay 

将 Stepper 强制 Value 属性在 Minimum 和 Maximum （含）之间。 如果将 Minimum 属性设置为大于属性的值 Value ，则将 Stepper Value 属性设置为 Minimum 。 同样，如果 Maximum 将设置为小于的值 Value ，则 Stepper 将属性设置 Value 为 Maximum 。

Stepper 定义一个 `ValueChanged` 事件，该事件通过用户操作 Stepper 或在应用程序直接设置属性时被触发。

`ValueChangedEventArgs` 事件参数附带的两个 double 类型属性 OldValue 和 NewValue 。

纯代码使用示例：

	public class BasicStepperCodePage : ContentPage
	{
	    public BasicStepperCodePage()
	    {
	        Label rotationLabel = new Label
	        {
	            Text = "ROTATING TEXT",
	            FontSize = Device.GetNamedSize(NamedSize.Large, typeof(Label)),
	            HorizontalOptions = LayoutOptions.Center,
	            VerticalOptions = LayoutOptions.CenterAndExpand
	        };

	        Label displayLabel = new Label
	        {
	            Text = "(uninitialized)",
	            HorizontalOptions = LayoutOptions.Center,
	            VerticalOptions = LayoutOptions.CenterAndExpand
	        };

	        Stepper stepper = new Stepper
	        {
	            Maximum = 360,
	            Increment = 30,
	            HorizontalOptions = LayoutOptions.Center
	        };
	        stepper.ValueChanged += (sender, e) =>
	        {
	            rotationLabel.Rotation = stepper.Value;
	            displayLabel.Text = string.Format("The Stepper value is {0}", e.NewValue);
	        };

	        Title = "Basic Stepper Code";
	        Content = new StackLayout
	        {
	            Margin = new Thickness(20),
	            Children = { rotationLabel, stepper, displayLabel }
	        };
	    }
	}

示范：

	public partial class BasicStepperXAMLPage : ContentPage
	{
	    public BasicStepperXAMLPage()
	    {
	        InitializeComponent();
	    }

	    void OnStepperValueChanged(object sender, ValueChangedEventArgs e)
	    {
	        double value = e.NewValue;
	        _rotatingLabel.Rotation = value;
	        _displayLabel.Text = string.Format("The Stepper value is {0}", value);
	    }
	}

XAML 实现：

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             x:Class="StepperDemo.BasicStepperXAMLPage"
	             Title="Basic Stepper XAML">
	    <StackLayout Margin="20">
	        <Label x:Name="_rotatingLabel"
	               Text="ROTATING TEXT"
	               FontSize="Large"
	               HorizontalOptions="Center"
	               VerticalOptions="CenterAndExpand" />
	        <Stepper Maximum="360"
	                 Increment="30"
	                 HorizontalOptions="Center"
	                 ValueChanged="OnStepperValueChanged" />
	        <Label x:Name="_displayLabel"
	               Text="(uninitialized)"
	               HorizontalOptions="Center"
	               VerticalOptions="CenterAndExpand" />        
	    </StackLayout>
	</ContentPage>



### TimePicker 时间拾取组件
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/timepicker

TimePicker 调用平台的时间选取器控件，并允许用户选择时间。 

TimePicker 定义以下属性:

- `Time` 类型 TimeSpan ，为所选时间，默认值为 TimeSpan 0。 此 TimeSpan 类型指示自午夜后的持续时间。
- `Format` 类型为的 string 标准或自定义 .net 格式设置字符串，默认为 "t"，短时间模式。
- `TextColor` 类型的 Color ，用于显示选定时间的颜色，默认值为 Color.Default 。
- `FontAttributes` 类型 FontAttributes，默认为 FontAtributes.None 。
- `FontFamily` 类型 string ，默认为 null 。
- `FontSize` 类型 double，默认值为 -1.0。
- `CharacterSpacing` 属于 double 类型，是 TimePicker 文本字符之间的间距。

所有这些属性都是由对象支持的 BindableProperty ，这意味着它们可以采用样式，属性可以是数据绑定的目标。 Time属性的默认绑定模式为 BindingMode.TwoWay ，可用于 MVVM 体系结构的应用程序中数据绑定的目标。

TimePicker 不包括指示 Time 新选定值的事件。 如果需要得到通知，可以为 PropertyChanged 事件添加处理程序。

在代码中，可以将 Time 属性初始化为类型为的值 TimeSpan ：

	TimePicker timePicker = new TimePicker
	{
	  Time = new TimeSpan(4, 15, 26) // Time set to "04:15:26"
	};

当在 Time XAML 中指定属性时，该值将转换为并进行 TimeSpan 验证，以确保毫秒数大于或等于0，并且小时数小于24。 应该用冒号分隔时间组件：

	<TimePicker Time="4:15:26" />

将的 BindingContext 属性绑定到 ViewModel 实例的 SelectedTime，其类型为 TimeSpan：

		<TimePicker Time="{Binding SelectedTime}" />


示例：

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             xmlns:local="clr-namespace:SetTimer"
	             x:Class="SetTimer.MainPage">
	    <StackLayout>
	        ...
	        <Entry x:Name="_entry"
	               Placeholder="Enter event to be reminded of" />
	        <Label Text="Select the time below to be reminded at." />
	        <TimePicker x:Name="_timePicker"
	                    Time="11:00:00"
	                    Format="T"
	                    PropertyChanged="OnTimePickerPropertyChanged" />
	        <StackLayout Orientation="Horizontal">
	            <Label Text="Enable timer:" />
	            <Switch x:Name="_switch"
	                    HorizontalOptions="EndAndExpand"
	                    Toggled="OnSwitchToggled" />
	        </StackLayout>
	    </StackLayout>
	</ContentPage>

C# 代码：

	public partial class MainPage : ContentPage
	{
	    DateTime _triggerTime;

	    public MainPage()
	    {
	        InitializeComponent();

	        Device.StartTimer(TimeSpan.FromSeconds(1), OnTimerTick);
	    }

	    bool OnTimerTick()
	    {
	        if (_switch.IsToggled && DateTime.Now >= _triggerTime)
	        {
	            _switch.IsToggled = false;
	            DisplayAlert("Timer Alert", "The '" + _entry.Text + "' timer has elapsed", "OK");
	        }
	        return true;
	    }

	    void OnTimePickerPropertyChanged(object sender, PropertyChangedEventArgs args)
	    {
	        if (args.PropertyName == "Time")
	        {
	            SetTriggerTime();
	        }
	    }

	    void OnSwitchToggled(object sender, ToggledEventArgs args)
	    {
	        SetTriggerTime();
	    }

	    void SetTriggerTime()
	    {
	        if (_switch.IsToggled)
	        {
	            _triggerTime = DateTime.Today + _timePicker.Time;
	            if (_triggerTime < DateTime.Now)
	            {
	                _triggerTime += TimeSpan.FromDays(1);
	            }
	        }
	    }
	}



### DatePicker 日期拾取组件
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/datepicker




### MenuItem
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/menuitem

MenuItem 类定义菜单的菜单项 ListView ，如项上下文菜单 ContextActions 和 Shell 应用程序飞出菜单。

上下文菜单在每个平台上以不同的方式进行访问和显示。

- 在 Android 上，通过长时间按列表项激活上下文菜单。 上下文菜单替换标题和导航栏区域， MenuItem 选项显示为水平按钮。
- 在 iOS 上，通过在列表项上轻扫激活上下文菜单。 上下文菜单显示在列表项上，并 MenuItems 显示为水平按钮。
- 在 UWP 上，右键单击列表项即可激活上下文菜单。 上下文菜单将作为垂直列表显示在光标附近。

MenuItem类定义以下属性：

- `Command` 是一个 ICommand ，它允许将用户操作（如指指单击或单击）绑定到在 viewmodel 上定义的命令。
- `CommandParameterobject` 指定应传递到的参数的 Command 。
- `IconImageSourceImageSource` 定义显示图标的值。
- `IsDestructive` 一个 bool 值，该值指示是否 MenuItem 从列表中移除其关联的 UI 元素。
- `IsEnabled` 一个 bool 值，该值指示此对象是否响应用户输入。
- `Textstring` 指定显示文本的值。

图标是使用属性指定的 IconImageSource 。 如果指定了图标，则不会显示由属性指定的文本 Text 。

这些属性是由对象支持的 BindableProperty ，因此， MenuItem 实例可以是数据绑定的目标。

	<ListView>
	    <ListView.ItemTemplate>
	        <DataTemplate>
	            <ViewCell>
	                <ViewCell.ContextActions>
	                    <MenuItem Text="Context Menu Option" />
	                </ViewCell.ContextActions>
	                <Label Text="{Binding .}" />
	            </ViewCell>
	        </DataTemplate>
	    </ListView.ItemTemplate>
	</ListView>


MenuItem 类会公开 Clicked 事件。 可以将事件处理程序附加到此事件，以响应在 XAML 中的点击或单击 MenuItem 实例：

	<MenuItem Clicked="OnItemClicked" />

事件处理程序也可以在代码中附加：

	MenuItem item = new MenuItem { ... }
	item.Clicked += OnItemClicked;

前面的示例引用了 OnItemClicked 事件处理程序。 下面的代码演示实现示例：

	void OnItemClicked(object sender, EventArgs e)
	{
	    // Access the list item through the BindingContext
	    var menuItem = sender as MenuItem;
	    var contextItem = menuItem.BindingContext;
	}


MVVM 数据绑定菜单：

	<ContentPage.BindingContext>
	    <viewmodels:ListPageViewModel />
	</ContentPage.BindingContext>

	<StackLayout>
	    <Label Text="{Binding Message}" ... />
	    <ListView ItemsSource="{Binding Items}">
	        <ListView.ItemTemplate>
	            <DataTemplate>
	                <ViewCell>
	                    <ViewCell.ContextActions>
	                        <MenuItem Text="Edit"
	                                    IconImageSource="icon.png"
	                                    Command="{Binding Source={x:Reference contentPage}, Path=BindingContext.EditCommand}"
	                                    CommandParameter="{Binding .}"/>
	                        <MenuItem Text="Delete"
	                                    Command="{Binding Source={x:Reference contentPage}, Path=BindingContext.DeleteCommand}"
	                                    CommandParameter="{Binding .}"/>
	                    </ViewCell.ContextActions>
	                    <Label Text="{Binding .}" />
	                </ViewCell>
	            </DataTemplate>
	        </ListView.ItemTemplate>
	    </ListView>
	</StackLayout>

在前面的示例中，定义了两个 MenuItem 对象，并将其 `Command` 和 `CommandParameter` 属性绑定到 viewmodel 上的命令。 Viewmodel 包含 XAML 中引用的命令：

	public class ListPageViewModel : INotifyPropertyChanged
	{
	    ...

	    public ICommand EditCommand => new Command<string>((string item) =>
	    {
	        Message = $"Edit command was called on: {item}";
	    });

	    public ICommand DeleteCommand => new Command<string>((string item) =>
	    {
	        Message = $"Delete command was called on: {item}";
	    });
	}

示例应用程序包含一个 DataService 类，该类用于获取用于填充对象的项的列表 ListView 。 使用类中的项来实例化 viewmodel， DataService 并将其设置为 BindingContext 代码隐藏中的：

	public MenuItemXamlMvvmPage()
	{
	    InitializeComponent();
	    BindingContext = new ListPageViewModel(DataService.GetListItems());
	}




### ToolbarItems


使用 TapGestureRecognizer 为 ContentPage.ToolbarItems 或 StackLayout 布局对象添加手势事件处理：

<!-- ```xml -->
	<ContentPage.ToolbarItems>
		<ToolbarItem Text="Add" Clicked="AddItem_Clicked" />
	</ContentPage.ToolbarItems>

	<StackLayout Padding="10">
		<Label Text="{Binding Description}" 
				d:Text="Item descripton"
				LineBreakMode="NoWrap"
				Style="{DynamicResource ListItemDetailTextStyle}"
				FontSize="13" />
		<StackLayout.GestureRecognizers>
			<TapGes
			tureRecognizer NumberOfTapsRequired="1" Tapped="OnItemSelected"></TapGestureRecognizer>
		</StackLayout.GestureRecognizers>
	</StackLayout>
<!-- ``` -->

C# 实现：

<!-- ```C# -->
	async void OnItemSelected(object sender, EventArgs args)
	{
		var layout = (BindableObject)sender;
	}

	async void AddItem_Clicked(object sender, EventArgs e)
	{
		await Navigation.PushModalAsync(new NavigationPage(new NewItemPage()));
	}
<!-- ``` -->


## Styles & theming 样式主题 
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/styles/
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/theming/

Xamarin.Forms 通常通过使用 Style 类将属性值的集合分组到一个对象中，然后将其应用于多个视觉元素实例，实现应用的样式。 这有助于减少重复的标记，并允许更轻松地更改应用的外观。

Xamarin.Forms 支持使用级联样式表（CSS）对视觉元素进行样式设置。 样式表由规则列表组成，每个规则包含一个或多个选择器和一个声明块。

XAML 样式涉及以下概念：

- `显式样式` 通过设置控件的 `Style` 属性应用于控件的样式。
- `隐式样式` 所有相同的控件都自动引用的样式 `TargetType`。
- `全局样式` 将样式添加到应用程序的 ResourceDictionary 定义的全局样式资源，避免了跨页面样式的重复。
- `样式继承` 样式可以从其他样式继承，以减少重复并实现重复使用。
- `动态样式` 样式不会对属性更改做出响应，并在应用程序持续时间内保持不变。 使用 DynamicResource 在运行时动态响应样式更改。
- `设备样式` Xamarin.Forms 在类中包含六个动态样式，称为设备样式 Devices.Styles 。 所有六种样式只能应用于 Label 实例。
- `样式类型` Xamarin.Forms 样式类型 `StyleClass` 可以将多个样式应用于控件，而无需采用样式继承。

DynamicResource 和 StaticResource 中的标记扩展，这两个方法都使用字典键从 ResourceDictionary 中提取值。 但是 StaticResource 执行单次字典查找，而 DynamicResource 保留字典键的链接。 因此，如果替换与该键关联的字典条目，则更改将更新应用于该视觉对象。 这样就可以在应用程序中进行运行时样式更改。

无法使用属性从动态样式中派生样式 Style.BasedOn 。 但是，Style 类包含 BaseResourceKey 属性，可以设置为字典键，其值可能会动态更改。

Xamarin 在 Device 类中包含六种动态样式，称为设备样式：

- BodyStyle
- CaptionStyle
- ListItemDetailTextStyle
- ListItemTextStyle
- SubtitleStyle
- TitleStyle

所有六个样式只能应用于 Label 实例。 例如， Label 显示段落正文的可能会将其 Style 属性设置为 BodyStyle 。
下面的代码示例演示如何在 XAML 页中使用设备样式：

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms" 
			xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" 
			x:Class="Styles.DeviceStylesPage" Title="Device" IconImageSource="xaml.png">
	    <ContentPage.Resources>
	        <ResourceDictionary>
	            <Style x:Key="myBodyStyle" TargetType="Label"
	              BaseResourceKey="BodyStyle">
	                <Setter Property="TextColor" Value="Accent" />
	            </Style>
	        </ResourceDictionary>
	    </ContentPage.Resources>
	    <ContentPage.Content>
	        <StackLayout Padding="0,20,0,0">
	            <Label Text="Title style" Style="{DynamicResource TitleStyle}" />
	            <Label Text="Subtitle text style" Style="{DynamicResource SubtitleStyle}" />
	            <Label Text="Body style" Style="{DynamicResource BodyStyle}" />
	            <Label Text="Caption style" Style="{DynamicResource CaptionStyle}" />
	            <Label Text="List item detail text style" Style="{DynamicResource ListItemDetailTextStyle}" />
	            <Label Text="List item text style" Style="{DynamicResource ListItemTextStyle}" />
	            <Label Text="No style" /> 
	            <Label Text="My body style" Style="{StaticResource myBodyStyle}" />
	        </StackLayout>
	    </ContentPage.Content>
	</ContentPage>

使用 DynamicResource 标记扩展将设备样式绑定到组件，通过更改文本大小的辅助功能设置，可在 iOS 中查看样式的动态特性。 设备样式的外观在每个平台上效果不同。


在应用程序级别声明 Style ，请在应用程序对象的 XML 文件中 ResourceDictionary 定义样式： 

下面的代码示例演示如何在应用程序级别定义一个用于 Button 组件的显式样式 buttonStyle，当然全局样式可以是显式或隐式的：

<!-- ```xml -->
	<Application xmlns="http://xamarin.com/schemas/2014/forms" 
		xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" x:Class="Styles.App">
	    <Application.Resources>
	        <ResourceDictionary>
	            <Style x:Key="buttonStyle" TargetType="Button">
	                <Setter Property="HorizontalOptions" Value="Center" />
	                <Setter Property="VerticalOptions" Value="CenterAndExpand" />
	                <Setter Property="BorderColor" Value="Lime" />
	                <Setter Property="BorderRadius" Value="5" />
	                <Setter Property="BorderWidth" Value="5" />
	                <Setter Property="WidthRequest" Value="200" />
	                <Setter Property="TextColor" Value="Teal" />
	            </Style>
	        </ResourceDictionary>
	    </Application.Resources>
	</Application>
<!-- ``` -->

下面的代码示例演示了将应用 buttonStyle 于页面实例的页面 Button ：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms" 
		xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" 
		x:Class="Styles.ApplicationStylesPage" 
		Title="Application" 
		IconImageSource="xaml.png">
	    <ContentPage.Content>
	        <StackLayout Padding="0,20,0,0">
	            <Button Text="These buttons" Style="{StaticResource buttonStyle}" />
	            <Button Text="are demonstrating" Style="{StaticResource buttonStyle}" />
	            <Button Text="application style overrides" Style="{StaticResource buttonStyle}" />
	        </StackLayout>
	    </ContentPage.Content>
	</ContentPage>
<!-- ``` -->

在页面级别声明样式， ResourceDictionary 则必须添加到 ContentPage.Resources。通过为 Style 提供一个特性 x:Key 来使成为显式的样式，它会在 ResourceDictionary 中产生一个主键以供引用对应的样式 。 

视图层次结构中较低的样式优先于定义较高的样式，因此页面级别的样式会覆盖全局样式。

下面的代码演示在页的 ResourceDictionary 声明显式样式，并将其应用于页面实例的显式样式 Label ：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms" 
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" 
				 x:Class="Styles.ExplicitStylesPage" 
				 Title="Explicit" 
				 IconImageSource="xaml.png">
	    <ContentPage.Resources>
	        <ResourceDictionary>
	            <Style x:Key="labelRedStyle" TargetType="Label">
	                <Setter Property="HorizontalOptions"
	                        Value="Center" />
	                <Setter Property="VerticalOptions"
	                        Value="CenterAndExpand" />
	                <Setter Property="FontSize" Value="Large" />
	                <Setter Property="TextColor" Value="Red" />
	            </Style>
	            <Style x:Key="labelGreenStyle" TargetType="Label">
	                ...
	                <Setter Property="TextColor" Value="Green" />
	            </Style>
	            <Style x:Key="labelBlueStyle" TargetType="Label">
	                ...
	                <Setter Property="TextColor" Value="Blue" />
	            </Style>
	        </ResourceDictionary>
	    </ContentPage.Resources>
	    <ContentPage.Content>
	        <StackLayout Padding="0,20,0,0">
	            <Label Text="These labels"
	                   Style="{StaticResource labelRedStyle}" />
	            <Label Text="are demonstrating"
	                   Style="{StaticResource labelGreenStyle}" />
	            <Label Text="explicit styles,"
	                   Style="{StaticResource labelBlueStyle}" />
	            <Label Text="and an explicit style override"
	                   Style="{StaticResource labelBlueStyle}"
	                   TextColor="Teal" />
	        </StackLayout>
	    </ContentPage.Content>
	</ContentPage>
<!-- ``` -->


在页的 XAML 中声明的隐式样式 ResourceDictionary ，并将其应用于页面的 Entry 实例：

<!-- ```xml -->
    <ContentPage.Resources>
        <ResourceDictionary>
            <Style TargetType="Entry">
                <Setter Property="HorizontalOptions" Value="Fill" />
                <Setter Property="VerticalOptions" Value="CenterAndExpand" />
                <Setter Property="BackgroundColor" Value="Yellow" />
                <Setter Property="FontAttributes" Value="Italic" />
                <Setter Property="TextColor" Value="Blue" />
            </Style>
        </ResourceDictionary>
    </ContentPage.Resources>
    <ContentPage.Content>
        <StackLayout Padding="0,20,0,0">
            <Entry Text="These entries" />
            <Entry Text="are demonstrating" />
            <Entry Text="implicit styles," />
            <Entry Text="and an implicit style override" BackgroundColor="Lime" TextColor="Red" />
            <local:CustomEntry Text="Subclassed Entry is not receiving the style" />
        </StackLayout>
    </ContentPage.Content>
<!-- ``` -->


在控件级别创建样式，如下面的代码示例所示：

<!-- ```xml -->
	<StackLayout Padding="0,20,0,0">
	    <StackLayout.Resources>
	        <ResourceDictionary>
	            <Style TargetType="Entry">
	                <Setter Property="HorizontalOptions" Value="Fill" />
	                ...
	            </Style>
	        </ResourceDictionary>
	    </StackLayout.Resources>
	    <Entry Text="These entries" />
	    ...
	</StackLayout>
<!-- ``` -->

下面的示例演示了三个 BoxView 样式类和一个 VisualElement 样式类：

<!-- ```xml -->
    <ContentPage.Resources>
        <Style TargetType="BoxView" Class="Separator">
            <Setter Property="BackgroundColor" Value="#CCCCCC" />
            <Setter Property="HeightRequest" Value="1" />
        </Style>

        <Style TargetType="BoxView" Class="Rounded">
            <Setter Property="BackgroundColor" Value="#1FAECE" />
            <Setter Property="HorizontalOptions" Value="Start" />
            <Setter Property="CornerRadius" Value="10" />
        </Style>    

        <Style TargetType="BoxView" Class="Circle">
            <Setter Property="BackgroundColor" Value="#1FAECE" />
            <Setter Property="WidthRequest" Value="100" />
            <Setter Property="HeightRequest" Value="100" />
            <Setter Property="HorizontalOptions" Value="Start" />
            <Setter Property="CornerRadius" Value="50" />
        </Style>

        <Style TargetType="VisualElement" Class="Rotated"
               ApplyToDerivedTypes="true">
            <Setter Property="Rotation" Value="45" />
        </Style>        
    </ContentPage.Resources>
<!-- ``` -->

下面的示例演示三个 BoxView 实例，每个实例都设置为不同的样式类：

<!-- ```xml -->
	<ContentPage ...>
	    <ContentPage.Resources>
	        ...
	    </ContentPage.Resources>
	    <StackLayout Margin="20">
	        <BoxView StyleClass="Separator" />       
	        <BoxView WidthRequest="100"
	                 HeightRequest="100"
	                 HorizontalOptions="Center"
	                 StyleClass="Rounded, Rotated" />
	        <BoxView HorizontalOptions="Center"
	                 StyleClass="Circle" />
	    </StackLayout>
	</ContentPage>    
<!-- ``` -->

样式继承是通过将属性设置 Style.BasedOn 为现有来执行的 Style 。 在 XAML 中，这是通过将 BasedOn 属性设置为 StaticResource 引用前面创建的的标记扩展来 Style 实现的。 在 c# 中，通过将 BasedOn 属性设置为 Style 实例实现。

在视图层次结构中，style 只能从同一级别或更高级别的样式继承。 这表示：

- 应用程序级别资源只能从其他应用程序级别资源继承。
- 页面级别资源可从应用程序级别资源和其他页面级别资源继承。
- 控件级别资源可从应用程序级别资源、页级别资源和其他控件级别资源继承。


<!-- ```xml -->
    <ContentPage.Resources>
        <ResourceDictionary>
            <Style x:Key="baseStyle" TargetType="View">
                <Setter Property="HorizontalOptions" Value="Center" />
                <Setter Property="VerticalOptions" Value="CenterAndExpand" />
            </Style>
            <Style x:Key="labelStyle" TargetType="Label" BasedOn="{StaticResource baseStyle}">
                ...
                <Setter Property="TextColor" Value="Teal" />
            </Style>
            <Style x:Key="buttonStyle" TargetType="Button" BasedOn="{StaticResource baseStyle}">
                <Setter Property="BorderColor" Value="Lime" />
                ...
            </Style>
        </ResourceDictionary>
    </ContentPage.Resources>
<!-- ``` -->

### System Theming

Xamarin.Forms 应用程序可以使用 DynamicResource 标记扩展在运行时动态响应样式更改。 此标记扩展类似于 StaticResource 标记扩展，但是此标记不支动态更改从 ResourceDictionary 绑定的资源。 

实现 Xamarin.Forms 运行时主题的过程如下所示：

- 定义每个主题的资源对象 ResourceDictionary 。
- 使用 DynamicResource 标记扩展在应用程序中引用主题资源。
- 在应用程序的 app.config 文件中设置默认主题。
- 添加代码以在运行时加载主题。

在运行时更改主题需要使用 XAML 样式，当前无法使用 CSS。


下面的示例演示了 LightTheme 主题定义：

	<ResourceDictionary xmlns="http://xamarin.com/schemas/2014/forms"
	                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	                    x:Class="ThemingDemo.LightTheme">
	    <Color x:Key="PageBackgroundColor">White</Color>
	    <Color x:Key="NavigationBarColor">WhiteSmoke</Color>
	    <Color x:Key="PrimaryColor">WhiteSmoke</Color>
	    <Color x:Key="SecondaryColor">Black</Color>
	    <Color x:Key="PrimaryTextColor">Black</Color>
	    <Color x:Key="SecondaryTextColor">White</Color>
	    <Color x:Key="TertiaryTextColor">Gray</Color>
	    <Color x:Key="TransparentColor">Transparent</Color>
	</ResourceDictionary>

下面的示例演示了 DarkTheme 主题定义：

	<ResourceDictionary xmlns="http://xamarin.com/schemas/2014/forms"
	                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	                    x:Class="ThemingDemo.DarkTheme">
	    <Color x:Key="PageBackgroundColor">Black</Color>
	    <Color x:Key="NavigationBarColor">Teal</Color>
	    <Color x:Key="PrimaryColor">Teal</Color>
	    <Color x:Key="SecondaryColor">White</Color>
	    <Color x:Key="PrimaryTextColor">White</Color>
	    <Color x:Key="SecondaryTextColor">White</Color>
	    <Color x:Key="TertiaryTextColor">WhiteSmoke</Color>
	    <Color x:Key="TransparentColor">Transparent</Color>
	</ResourceDictionary>

每个都 ResourceDictionary 包含 Color 定义各自主题的资源，每个资源 ResourceDictionary 使用相同的键值。

应用程序需要默认主题，以便控件具有其使用的资源的值。 通过将 LightTheme 主题资源合并到程序资源定义中，以供应用程序级的页面来使用主题。

下面演示通过 TargetType 应用主题样式到 Label 对象：

	<Application xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             x:Class="ThemingDemo.App">
	    <Application.Resources>
	        <ResourceDictionary Source="Themes/LightTheme.xaml" />

	        <Style x:Key="LargeLabelStyle" TargetType="Label">
	            <Setter Property="TextColor" Value="{DynamicResource SecondaryTextColor}" />
	            <Setter Property="FontSize" Value="30" />
	        </Style>

	        <Style x:Key="MediumLabelStyle" TargetType="Label">
	            <Setter Property="TextColor" Value="{DynamicResource PrimaryTextColor}" />
	            <Setter Property="FontSize" Value="25" />
	        </Style>

	        <Style x:Key="SmallLabelStyle" TargetType="Label">
	            <Setter Property="TextColor" Value="{DynamicResource TertiaryTextColor}" />
	            <Setter Property="FontSize" Value="15" />
	        </Style>

	    </Application.Resources>
	</Application>

在应用程序级资源字典中定义这些样式，使其可供各页面使用：

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             xmlns:local="clr-namespace:ThemingDemo"
	             x:Class="ThemingDemo.UserSummaryPage"
	             Title="User Summary"
	             BackgroundColor="{DynamicResource PageBackgroundColor}">
	    ...
	    <ScrollView>
	        <Grid>
	            <Grid.RowDefinitions>
	                <RowDefinition Height="200" />
	                <RowDefinition Height="120" />
	                <RowDefinition Height="70" />
	            </Grid.RowDefinitions>
	            <Grid BackgroundColor="{DynamicResource PrimaryColor}">
	                <Label Text="Face-Palm Monkey"
	                       VerticalOptions="Center"
	                       Margin="15"
	                       Style="{StaticResource MediumLabelStyle}" />
	                ...
	            </Grid>
	            <StackLayout Grid.Row="1"
	                         Margin="10">
	                <Label Text="This monkey reacts appropriately to ridiculous assertions and actions."
	                       Style="{StaticResource SmallLabelStyle}" />
	                <Label Text="  &#x2022; Cynical but not unfriendly."
	                       Style="{StaticResource SmallLabelStyle}" />
	                <Label Text="  &#x2022; Seven varieties of grimaces."
	                       Style="{StaticResource SmallLabelStyle}" />
	                <Label Text="  &#x2022; Doesn't laugh at your jokes."
	                       Style="{StaticResource SmallLabelStyle}" />
	            </StackLayout>
	            ...
	        </Grid>
	    </ScrollView>
	</ContentPage>

当直接使用主题资源时，应使用标记扩展来使用该资源 DynamicResource。

当在运行时选择主题时，应用程序应执行以下操作：

- 从应用程序中删除当前主题。 
- 加载选定的主题。 这是通过将所选主题的实例添加到应用程序级 ResourceDictionary 的属性 MergedDictionaries 来实现的。

这是通过清除或添加主题到应用程序级别 ResourceDictionary 的属性 MergedDictionaries 来实现。

下面的代码演示 OnPickerSelectionChanged 方法设置主题的动态更改：

	void OnPickerSelectionChanged(object sender, EventArgs e)
	{
	    Picker picker = sender as Picker;
	    Theme theme = (Theme)picker.SelectedItem;

	    ICollection<ResourceDictionary> mergedDictionaries = Application.Current.Resources.MergedDictionaries;
	    if (mergedDictionaries != null)
	    {
	        mergedDictionaries.Clear();

	        switch (theme)
	        {
	            case Theme.Dark:
	                mergedDictionaries.Add(new DarkTheme());
	                break;
	            case Theme.Light:
	            default:
	                mergedDictionaries.Add(new LightTheme());
	                break;
	        }
	    }
	}


根据设备配置的不同原因，系统主题可能会发生变化。 这包括用户显式更改的系统主题，它因一天中的某个时间而变化，并因环境因素（如低亮度）而变化。

Xamarin.Forms应用程序可以通过使用 AppThemeColor 类、 OnAppTheme<T> 类和标记扩展来定义资源来响应系统主题更改 OnAppTheme 。 然后，应使用标记扩展来使用这些资源 DynamicResource 。

Xamarin.Forms 响应系统主题前提要求：

- Xamarin.Forms4.6 或更高版本。
- iOS 13 或更高版本。
- Android 10 （API 29）或更高版本。
- UWP 版本14393或更高版本。



## Animation 动画效果
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/animation/

Xamarin 包含自己的动画基础结构，它可以简单地创建简单的动画，同时也足以创建复杂的动画。

Xamarin.Forms 动画类以不同的视觉对象属性为目标，典型动画会在一段时间内逐渐将属性从一个值更改为另一个值。

请注意，动画类没有 XAML 接口，但是，动画类可以封装在 Behavior 行为中，然后从 XAML 进行引用。

- 简单动画由 ViewExtensions 类提供扩展方法，用于构造 VisualElement 组件的旋转、缩放、平移和淡化实例的简单动画。
- 缓动函数由 Xamarin.Forms 的 Easing 类实现，指定缓动函数控制动画在运行时的速度及加减速。 
- 自定义动画通过继承 Animation 类实现，ViewExtensions 的扩展方法可以创建一个或多个 Animation 对象。

ViewExtensions 提供以下方法创建 VisualElement 组件的简单动画：

- `TranslateTo` 创建 TranslationX/TranslationY 属性平移动画效果
- `ScaleTo` 创建 Scale 属性缩放动画效果
- `ScaleXTo` 创建 ScaleX 属性缩放动画效果
- `ScaleYTo` 创建 ScaleY 属性缩放动画效果
- `RelScaleTo` 创建 Scale 属性增减缩放动画效果
- `RotateTo` 创建 Rotation 属性旋转动画效果
- `RelRotateTo` 创建 Rotation 属性增减旋转动画效果
- `RotateXTo` 创建 RotationX 属性旋转动画效果
- `RotateYTo` 创建 RotationY 属性旋转动画效果
- `FadeTo` 创建 Opacity 属性渐隐渐现动画效果

CancelAnimations 方法，可用于取消任何动画。 默认情况下，每个动画将需要250毫秒。 但是，可以在创建动画时指定每个动画的持续时间。

	ViewExtensions.CancelAnimations(image);

这会立即取消当前正在实例上运行的所有动画 Image 。

如果已将 Image 放置到布局的中心，下面的代码示例演示了如何通过设置其 AnchorY 锚点属性来围绕布局中心旋转图像：

	<Image Focused="OnClick" Source="avatar.jpg">
	    <Image.GestureRecognizers>
	        <TapGestureRecognizer Tapped="OnClick" />
	    </Image.GestureRecognizers>
	</Image>

	async void OnClick(object sender, EventArgs args)
	{
		double radius = Math.Min(Width, Height) / 2;
		var avatar = sender as VisualElement;
		avatar.Rotation = 0;
		avatar.AnchorY = radius / avatar.Height;
		await avatar.RotateTo(360, 2000);
	}

AnchorX 和 AnchorY 属性设置缩放或旋转中心，原点 (0,0) 表示图像的左上角，右下角是 (1, 1)。

缓动 Easing 类定义了多个缓动函数：

| 缓动函数	| 缓动效果 |
| :-------	| :------- |
| BounceIn	| 缓动函数开始时，会弹跳动画。 |
| BounceOut	| 缓动函数在末尾弹跳动画。 |
| CubicIn	| 缓动函数会慢慢加快动画的速度。 |
| CubicInOut| 缓动函数在开始时加快动画的速度，并减速动画的结尾。 |
| CubicOut	| 缓动函数快速减速动画。 |
| Linear	| 缓动函数使用恒定速度，并且是默认缓动函数。 |
| SinIn		| 缓动函数能平稳地加速动画。 |
| SinInOut	| 缓动函数会在一开始就平稳地加速动画，并平稳地减速动画结束。 |
| SinOut	| 缓动函数会平稳地减速动画。 |
| SpringIn	| 缓动函数使动画的速度非常快。 |
| SpringOut	| 缓动函数使动画快速减速。 |

In 和 Out 后缀指示缓动函数所提供的效果在动画的开头、结尾还是同时非常明显。


 ViewExtensions 类中的动画扩展方法允许最后一个方法参数指定为缓动函数，如以下代码示例所示：

	await image.TranslateTo(0, 200, 2000, Easing.BounceIn);
	await image.ScaleTo(2, 2000, Easing.CubicIn);
	await image.RotateTo(360, 2000, Easing.SinInOut);
	await image.ScaleTo(1, 2000, Easing.CubicOut);
	await image.TranslateTo(0, -200, 2000, Easing.BounceOut);

缓动函数背后就是时间函数关系，随着时间变化产生相应的输出量，这个输出量设置到属性上，就表现为动态效果。自定义缓动方法或缓动函数，就是通过设置自己的时间函数来实现定制的动态效果。

有三种主要方法可用于创建自定义缓动函数：

- 创建一个方法，该方法采用 double 参数并返回 double 结果。
- 创建 Func<double, double>。
- 将缓动函数指定为 Easing 构造函数的参数。

三种情况自定义缓动函数，当时间参数 t 为 0 应返回 0，参数为 1，则返回 1，它们代表了起止值。 但是，可以在参数值 0 和 1 之间返回任何值。

自定义缓动函数可定义为方法，该方法采用 double 参数并返回 double 结果，如以下代码示例所示：

	double CustomEase (double t)
	{
	  return t == 0 || t == 1 ? t : (int)(5 * t) / 5.0;
	}

	await image.TranslateTo(0, 200, 2000, (Easing)CustomEase);

CustomEase 方法将传入值截断到值 0、0.2、0.4、0.6、0.8 和 1。 因此， Image 实例在 TranslateY 上离散跳变进行转换，而不是平滑。

自定义缓动函数也可以定义为 Func<double, double> ，如下面的代码示例所示：

	Func<double, double> CustomEaseFunc = t => 9 * t * t * t - 13.5 * t * t + 5.5 * t;
	await image.TranslateTo(0, 200, 2000, CustomEaseFunc);

CustomEaseFunc表示一个缓动函数，该函数可快速启动、减缓并反转课程，然后再次反转课程以快速加速。 因此，虽然实例的总体移动 Image 朝下，但它也会暂时反转动画的一半。

自定义缓动构造函数也可定义 Easing ，如以下代码示例所示：

	await image.TranslateTo (0, 200, 2000, new Easing (t => 1 - Math.Cos (10 * Math.PI * t) * Math.Exp (-5 * t)));
	
自定义缓动函数指定为构造函数的 lambda 函数参数 Easing ，并使用 Math.Cos 方法来创建由方法阻碍的慢速删除效果 Math.Exp 。 因此， Image 实例将被转换，以使其显示在其最终的静止位置。


创建对象时 Animation ，通常需要至少三个参数，如以下代码示例所示：

	var animation = new Animation (v => image.Scale = v, 1, 2);

此代码定义 Scale 实例的属性 Image 从值 1 到值 2 的动画。 派生的动画值 Xamarin.Forms 被传递给指定为第一个参数的回调，该回调用于更改属性的值 Scale。

	animation.Commit (this, "SimpleAnimation", 16, 2000, Easing.Linear, (v, c) => image.Scale = 1, () => true);

动画对象通过 Commit 启动，函数签名如下：

	Commit (IAnimatable owner, string name, uint rate = 16, uint length = 250, Easing easing = null, Action<double,bool> finished = null, Func<bool> repeat = null);

| 参数	| 类型	| 作用	| 
| :-------	| :------- | :------- |
| owner	| IAnimatable	| 指定应用动画的对象	| 
| name	| String	| 名称和句柄用来追踪动画状态，可用来取消动画 |
| rate	| UInt32	| 帧时间，毫秒数 |
| length	| UInt32	| 时间长度 milliseconds |
| easing	| Easing	| 缓动函数 |
| finished	| Action<Double,Boolean>	| 动画终结动作 |
| repeat	| Func<Boolean>	| 动画循环指示回调 |

总体效果是使用缓动函数创建动画，将的 Scale 属性 Image 以线性从 1 增加到 2，时间为 2000 毫秒即 2 秒。 每次动画完成后，其 Scale 属性将重置为 1，然后重复。

子动画涉及到创建 Animation 其他对象要添加到的对象 Animation 。 这样，便可以运行和同步一系列动画。 下面的代码示例演示如何创建和运行子动画：

	var parentAnimation = new Animation ();
	var scaleUpAnimation = new Animation (v => image.Scale = v, 1, 2, Easing.SpringIn);
	var rotateAnimation = new Animation (v => image.Rotation = v, 0, 360);
	var scaleDownAnimation = new Animation (v => image.Scale = v, 2, 1, Easing.SpringOut);

	parentAnimation.Add (0, 0.5, scaleUpAnimation);
	parentAnimation.Add (0, 1, rotateAnimation);
	parentAnimation.Add (0.5, 1, scaleDownAnimation);

	parentAnimation.Commit (this, "ChildAnimations", 16, 4000, null, (v, c) => SetIsEnabledButtonState (true, false));

或者，可以更简洁地编写代码示例，如下面的代码示例所示：

	new Animation {
	    { 0, 0.5, new Animation (v => image.Scale = v, 1, 2) },
	    { 0, 1, new Animation (v => image.Rotation = v, 0, 360) },
	    { 0.5, 1, new Animation (v => image.Scale = v, 2, 1) }
	    }.Commit (this, "ChildAnimations", 16, 4000, null, (v, c) => SetIsEnabledButtonState (true, false));

Animation 使用子动画的对象与不使用子动画的对象有很多差异：

- 使用子动画时，子动画上完成的回调 finished 将指示子动画完成的时间，指示整个动画完成的时间。
- 使用子动画时，从 Commit 方法的重复回调 repeat 中返回 true 不会导致动画重复，但动画将继续运行，而不会产生新值。
- 如果在 Commit 方法包含缓动函数返回一个大于 1 的值，则将终止动画。 如果缓动函数返回小于 0 的值，则将值限制为 0。 若要使用返回小于 0 或大于 1 的值的缓动函数，则必须在其中一个子动画中指定该值，而不是 Commit 方法。


应用程序可以通过调用 [ AbortAnimation ] （x：）取消动画 Xamarin.Forms 。AnimationExtensions. AbortAnimation （ Xamarin.Forms 。System.windows.media.animation.ianimatable>，System.string）扩展方法，如以下代码示例所示：

	this.AbortAnimation ("SimpleAnimation");

请注意，动画由动画所有者和动画名称的组合唯一标识。 因此，在运行动画时指定的所有者和名称必须指定为取消动画。 因此，该代码示例将立即取消 SimpleAnimation 由页面拥有的名为的动画。

创建自定义动画：

	new Animation (
		callback: v => BackgroundColor = Color.FromHsla (v, 1, 0.5),
		start: 0,
		end: 1).Commit (this, "Animation", 16, 4000, Easing.Linear, (v, c) => BackgroundColor = Color.Default);

创建扩展动画方法 AnimationExtensions：

	public static class ViewExtensions
	{
		public static Task<bool> ColorTo(
			this VisualElement self, 
			Color fromColor, 
			Color toColor, 
			Action<Color> callback, 
			uint length = 250, 
			Easing easing = null)
		{
			Func<double, Color> transform = (t) =>
				Color.FromRgba(fromColor.R + t * (toColor.R - fromColor.R),
											 fromColor.G + t * (toColor.G - fromColor.G),
											 fromColor.B + t * (toColor.B - fromColor.B),
											 fromColor.A + t * (toColor.A - fromColor.A));
			return ColorAnimation(self, "ColorTo", transform, callback, length, easing);
		}

		public static void CancelAnimation(this VisualElement self)
		{
			self.AbortAnimation("ColorTo");
		}

		static Task<bool> ColorAnimation(VisualElement element, string name, Func<double, Color> transform, Action<Color> callback, uint length, Easing easing)
		{
			easing = easing ?? Easing.Linear;
			var taskCompletionSource = new TaskCompletionSource<bool>();

			element.Animate<Color>(name, transform, callback, 16, length, easing, (v, c) => taskCompletionSource.SetResult(c));
			return taskCompletionSource.Task;
		}
	}

使用扩展动画方法：

	await Task.WhenAll(
		label.ColorTo(Color.Red, Color.Blue, c => label.TextColor = c, 5000),
		label.ColorTo(Color.Blue, Color.Red, c => label.BackgroundColor = c, 5000));
	await this.ColorTo(Color.FromRgb(0, 0, 0), Color.FromRgb(255, 255, 255), c => BackgroundColor = c, 5000);
	await boxView.ColorTo(Color.Blue, Color.Red, c => boxView.Color = c, 4000);



## Bindable Properties 可绑定属性
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/xaml/bindable-properties

可绑定属性通过使用类型来支持属性来扩展 CLR 属性功能 BindableProperty ，而不是使用字段来支持属性。 可绑定属性的用途是提供支持通过父子关系设置数据绑定、样式、模板和值的属性系统。 此外，可绑定属性可提供默认值、属性值验证和监视属性更改的回调。

可绑定属性的一个最佳列子就是 HyperlinkSpan 实现超链接组件。

属性应作为可绑定属性实现，以支持下列一项或多项功能：

- 用作数据绑定的有效目标属性。
- 通过样式设置属性。
- 提供不同于属性类型默认值的默认属性值。
- 验证属性的值。
- 监视属性更改。

提供可绑定的属性组件如 Xamarin.Forms、 Label.Text 、 Button.BorderRadius 和 StackLayout.Orientation 等。 每个可绑定属性都具有一个对应的 public static readonly BindableProperty 类型字段，该字段在同一类上公开，这是可绑定属性的标识符。 

例如， Label.Text 属性对应的可绑定属性标识符是 Label.TextProperty 。

创建可绑定属性的过程如下所示：

- 使用 BindableProperty.Create 其中一个方法重载创建 BindableProperty 实例。
- 定义 BindableProperty 实例的属性访问器。

所有 BindableProperty 实例都必须在 UI 线程上创建。 这意味着，只有在 UI 线程上运行的代码才能获取或设置可绑定属性的值。 但是， BindableProperty 可通过使用方法封送到 UI 线程，从其他线程访问实例 Device.BeginInvokeOnMainThread 。

创建 BindableProperty 时，必须至少指定标识符以及以下参数：

- BindableProperty 的名称。
- 属性类型。
- 所属对象的类型。
- 属性的默认值。 这可确保属性在未设置时始终返回特定的默认值，并且它可以与属性类型的默认值不同。 

下面的代码演示一个可绑定属性，包含四个必需参数的标识符和值，属性访问器是必需提供的，而且需要使用属性语法来访问可绑定属性：

	public static readonly BindableProperty EventNameProperty =
		BindableProperty.Create (
		"EventName", // BindableProperty Name
		typeof(string), 
		typeof(EventToCommandBehavior),
		null, // Default value
		);

	public string EventName
	{
		get { return (string)GetValue (EventNameProperty); }
		set { SetValue (EventNameProperty, value); }
	}


	public static readonly BindableProperty AngleProperty = BindableProperty.Create (
	  "Angle", typeof(double), typeof(HomePage), 0.0, coerceValue: CoerceAngle, validateValue: IsValidValue);
	public static readonly BindableProperty MaximumAngleProperty = BindableProperty.Create (
	  "MaximumAngle", typeof(double), typeof(HomePage), 360.0, propertyChanged: ForceCoerceValue);
	...

	static bool IsValidValue (BindableObject view, object value)
	{
		double result;
		bool isDouble = double.TryParse (value.ToString (), out result);
		return (result >= 0 && result <= 360);
	}
		

	static object CoerceAngle (BindableObject bindable, object value)
	{
		var homePage = bindable as HomePage;
		double input = (double)value;

		if (input > homePage.MaximumAngle)
		{
			input = homePage.MaximumAngle;
		}
		return input;
	}

	static void ForceCoerceValue(BindableObject bindable, object oldValue, object newValue)
	{
		bindable.CoerceValue(AngleProperty);
	}

	public static readonly BindableProperty SizeProperty =
		BindableProperty.Create ("Size", typeof(double), typeof(HomePage), 0.0,
		defaultValueCreator: bindable => Device.GetNamedSize (NamedSize.Large, (Label)bindable));


创建 BindableProperty 实例时，可以指定以下可选参数：

- 绑定模式。 此值用于指定属性值更改将传播到的方向。 在默认绑定模式下，数据更改将从源传播到目标。
- 指定 validateValue 回调委托，当设置属性值时调用以验证属性。 
- 指定 propertyChanged 回调委托，属性值更改后将调用以验证属性。
- 设置一个属性更改事件委托，该委托将在属性值更改时调用。
- 当属性值发生更改时将调用的强制值回调委托 Coerce value callbacks。
- 使用 Func 回调初始化属性值的默认值。 


创建可绑定属性后，可以从 XAML 或代码中使用它。 在 XAML 中使用前缀来声明声明 CLR 命名空间名称，也可以是程序集名称。

下面的代码示例演示从一个自定义类型的 XAML 命名空间引用一个可绑定属性，该属性与引用自定义类型的应用程序代码定义在相同的程序集中：

	<ContentPage ... xmlns:local="clr-namespace:EventToCommandBehavior" ...>
	  ...
	</ContentPage>

设置可绑定属性时，将使用命名空间声明 EventName ，如下面的 XAML 代码示例所示：

	<ListView ...>
	  <ListView.Behaviors>
	    <local:EventToCommandBehavior EventName="ItemSelected" ... />
	  </ListView.Behaviors>
	</ListView>

以下代码示例显示相应的 C# 代码：

	var listView = new ListView ();
	listView.Behaviors.Add (new EventToCommandBehavior
	{
	  EventName = "ItemSelected",
	  ...
	});


## Attached Properties 附加属性
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/xaml/attached-properties
- https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/attached-properties-overview
- https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.BindableProperty


附加属性是由 XAML 定义的概念。 附加属性旨在用作可在任何对象上设置的一类全局属性。 在 WPF 中，附加属性通常定义为没有常规属性包装器的依赖性属性的专用形式。

附加属性使对象可以为其自己的类未定义的属性分配值。 例如，子元素可以使用附加属性来通知其父元素在用户界面中的显示方式。 Grid 控件允许通过设置附加属性 Grid.Row 和 Grid.Column 来指定子项的行和列。它们是针对的元素设置的附加属性，而不在 Grid 自身设置。

在以下情况下，应将可绑定属性作为附加属性实现：

- 需要为定义类之外的类提供属性设置机制时。
- 当类表示需要轻松地与其他类集成的服务时。

在 XAML 中，可以使用语法 AttachedPropertyProvider.PropertyName 来设置附加属性。

以下是如何在 XAML 中设置 DockPanel.Dock 的示例：

	<DockPanel>
	  <CheckBox DockPanel.Dock="Top">Hello</CheckBox>
	</DockPanel>

创建附加属性的过程如下所示：

- 使用 CreateAttached 重载方法其中一个创建 BindableProperty 实例。
- 提供 static Geter 和 Setter 方法作为附加属性的访问器。


演示附加属性的创建：

<!-- ```C# -->
	public static readonly BindableProperty HasShadowProperty =
		BindableProperty.CreateAttached ("HasShadow", typeof(bool), typeof(ShadowEffect), false);

	public static bool GetHasShadow (BindableObject view)
	{
		return (bool)view.GetValue (HasShadowProperty);
	}

	public static void SetHasShadow (BindableObject view, bool value)
	{
		view.SetValue (HasShadowProperty, value);
	}
<!-- ``` -->

这创建一个名为 HasShadow 的附加属性，类型为 bool 。 此附加属性由 ShadowEffect 类拥有，其默认值为 false 。 

命名约定，附加属性标识符必须与 CreateAttached 方法中指定的属性名称匹配，并后缀 `Property`。 因此，在上面的示例中，附加的属性标识符是 `HasShadowProperty` 。

静态 Get 和 Set 方法是附加属性的访问器所必需的，否则属性系统将无法使用附加属性。

访问器应符合以下签名：

	public static valueType GetPropertyName(BindableObject target)
	public static void SetPropertyName(BindableObject target, valueType value)



创建附加属性后，可以从 XAML 或代码中使用它。 使用前缀的命名空间来声明，命名空间声明指示公共语言运行时（CLR）命名空间名称，也可以是程序集名称。 

下面的代码演示包含附加属性的自定义类型的 XAML 命名空间，该属性在与引用自定义类型的应用程序代码相同的程序集中进行定义：

	<ContentPage ... xmlns:local="clr-namespace:EffectsDemo" ...>
	  ...
	</ContentPage>

然后，在对特定控件设置附加属性时使用命名空间声明，如下面的 XAML 代码示例所示：

	<Label Text="Label Shadow Effect" local:ShadowEffect.HasShadow="true" />

以下代码示例显示相应的 C# 代码：

	var label = new Label { Text = "Label Shadow Effect" };
	ShadowEffect.SetHasShadow (label, true);


附加属性还可以通过样式添加到控件。

下面的 XAML 代码示例演示了一个使用附加属性的显式样式 HasShadow ，该样式可应用于 Label 控件：

	<Style x:Key="ShadowEffectStyle" TargetType="Label">
	  <Style.Setters>
	    <Setter Property="local:ShadowEffect.HasShadow" Value="true" />
	  </Style.Setters>
	</Style>

Style 可通过使用 StaticResource 标记扩展将 Style 属性设置为 Style 实例来应用于 Label，如以下代码示例所示：

	<Label Text="Label Shadow Effect" Style="{StaticResource ShadowEffectStyle}" />


## ResourceDictionary 资源字典
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/xaml/resource-dictionaries

ResourceDictionary 是 Xamarin.Forms 应用程序使用的资源存储库，典型资源包括样式、控件模板、数据模板、颜色和转换器。

在 XAML 中， ResourceDictionary 可以使用 StaticResource 或 DynamicResource 标记扩展引用存储在中的资源，并将其应用于元素。 在 C# 中还可以定义资源，然后使用基于字符串的索引器对其进行引用并将其应用于元素。在 C# 中使用是非常有利的，因为 ResourceDictionary 可以将共享对象存储为字段或属性并直接访问，而无需首先从字典中检索它们。

每个 VisualElement 派生的对象都有一个 Resources 属性用来包含 ResourceDictionary 字典资源，Application 对象也是。
从 VisualElement 派生的 Xamarin.Forms 应用程序仅包含 Application 类型，但通常使用其它派生自 VisualElement 的许多类，包括 Page、Layout 和其它控件。 这些对象都可以在 Resources 属性设置 ResourceDictionary 包含资源。 

选择在何处 ResourceDictionary 应对可使用资源的特定影响：

- 视图的中的资源，如 Button 或 Label 等，只能应用于该特定对象。
- 附加到布局的中的资源，如 StackLayout 或 Grid 可应用于布局和该布局的所有子级。
- 在页面级别定义的中的资源可以应用于页面及其所有子项。
- 在应用程序中定义的资源可用在整个应用程序级别的对象。

除了隐式样式以外，资源字典中的每个资源都必须具有 x:Key 特性定义的唯一字符串键。

以下 XAML 显示了 App.xaml 文件在应用程序级别中定义的资源 ResourceDictionary ：

	<Application xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             x:Class="ResourceDictionaryDemo.App">
	    <Application.Resources>

	        <Thickness x:Key="PageMargin">20</Thickness>

	        <!-- Colors -->
	        <Color x:Key="AppBackgroundColor">AliceBlue</Color>
	        <Color x:Key="NavigationBarColor">#1976D2</Color>
	        <Color x:Key="NavigationBarTextColor">White</Color>
	        <Color x:Key="NormalTextColor">Black</Color>

	        <!-- Implicit styles -->
	        <Style TargetType="{x:Type NavigationPage}">
	            <Setter Property="BarBackgroundColor"
	                    Value="{StaticResource NavigationBarColor}" />
	            <Setter Property="BarTextColor"
	                    Value="{StaticResource NavigationBarTextColor}" />
	        </Style>

	        <Style TargetType="{x:Type ContentPage}"
	               ApplyToDerivedTypes="True">
	            <Setter Property="BackgroundColor"
	                    Value="{StaticResource AppBackgroundColor}" />
	        </Style>

	    </Application.Resources>
	</Application>

在此示例中，资源字典定义一个 Thickness 资源、多个 Color 资源和两个隐式 Style 资源。


使用标记扩展 DynamicResource 或 StaticResource，指定资源中 x:Key 指定的键值就可以获取资源数据。

下面的 XAML 示例演示如何使用资源，并在中定义其他资源 StackLayout ：

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             x:Class="ResourceDictionaryDemo.HomePage"
	             Title="Home Page">
	    <StackLayout Margin="{StaticResource PageMargin}">
	        <StackLayout.Resources>
	            <!-- Implicit style -->
	            <Style TargetType="Button">
	                <Setter Property="FontSize" Value="Medium" />
	                <Setter Property="BackgroundColor" Value="#1976D2" />
	                <Setter Property="TextColor" Value="White" />
	                <Setter Property="CornerRadius" Value="5" />
	            </Style>
	        </StackLayout.Resources>

	        <Label Text="This app demonstrates consuming resources that have been defined in resource dictionaries." />
	        <Button Text="Navigate"
	                Clicked="OnNavigateButtonClicked" />
	    </StackLayout>
	</ContentPage>

在此示例中， ContentPage 对象使用在应用程序级别资源字典中定义的隐式样式。 StackLayout对象使用 PageMargin 在应用程序级别资源字典中定义的资源，而 Button 对象使用资源字典中定义的隐式样式 StackLayout 。

当使用 StaticResource 或 DynamicResource 标记扩展引用资源时，发生以下查找过程：

- 对于用于设置属性的元素，在资源字典中检查所请求的主键，如果找到，则返回其关联的值，并且查找进程将终止。
- 如果找不到匹配项，查找过程会向上搜索可视化树，检查每个父元素的资源字典。 如果找到则返回其值，并且查找进程将终止。
- 如果搜索到达根元素，也找不到匹配项，则检查应用程序级别资源字典。
- 如果仍未找到匹配项， XamlParseException 则会引发。

StaticResource 和 DynamicResource 是类似的标记扩展，因为这两种方法都使用字典键来引用资源字典中的值。 

但，当 StaticResource 标记扩展执行单次字典查找， DynamicResource 标记扩展将保留指向字典键的链接。 因此，如果替换与该键关联的字典条目，则更改将应用于该视觉对象。 这样就可以在应用程序中进行运行时资源更改。 


ResourceDictionary 也可以在单独的独立文件中，可以在应用程序之间共享。

若要创建此类文件，请向项目中添加一个新的内容视图或内容页项，但不包含有 C# 代码文件的内容视图或内容页。 删除 code-behind 代码文件，在 XAML 文件基类的名称从 ContentView 或 ContentPage 更改为 ResourceDictionary 即可。 此外，请将 x:Class 从文件的根标记中删除。

下面的 XAML 示例显示了一个 MyResourceDictionary.xaml 资源文件：

	<ResourceDictionary xmlns="http://xamarin.com/schemas/2014/forms"
	                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">
	    <DataTemplate x:Key="PersonDataTemplate">
	        <ViewCell>
	            <Grid>
	                <Grid.ColumnDefinitions>
	                    <ColumnDefinition Width="0.5*" />
	                    <ColumnDefinition Width="0.2*" />
	                    <ColumnDefinition Width="0.3*" />
	                </Grid.ColumnDefinitions>
	                <Label Text="{Binding Name}"
	                       TextColor="{StaticResource NormalTextColor}"
	                       FontAttributes="Bold" />
	                <Label Grid.Column="1"
	                       Text="{Binding Age}"
	                       TextColor="{StaticResource NormalTextColor}" />
	                <Label Grid.Column="2"
	                       Text="{Binding Location}"
	                       TextColor="{StaticResource NormalTextColor}"
	                       HorizontalTextAlignment="End" />
	            </Grid>
	        </ViewCell>
	    </DataTemplate>
	</ResourceDictionary>

可以 ResourceDictionary 对象的 Source 属性设置为 XAML 文件的文件名，并将另一个文件中 ResourceDictionary 合并：

	<ContentPage ...>
	    <ContentPage.Resources>
	        <!-- Add more resources here -->
	        <ResourceDictionary Source="MyResourceDictionary.xaml" />
	        <!-- Add more resources here -->
	    </ContentPage.Resources>
	    ...
	</ContentPage>


还可以通过 MergedDictionaries 附加属性合并其它程序集的资源， 此方法允许合并资源字典，而不考虑它们所在的程序集。 如果从外部程序集合并资源字典，则需要生成资源时，设置编译设置为 EmbeddedResource，以创建代码隐藏文件，并在文件的根标记 x:Class 中定义。

下面的代码示例演示了 MergedDictionaries 向页面级别的集合中添加了两个资源字典：

	<ContentPage ...
	             xmlns:local="clr-namespace:ResourceDictionaryDemo"
	             xmlns:theme="clr-namespace:MyThemes;assembly=MyThemes">
	    <ContentPage.Resources>
	        <ResourceDictionary>
	            <!-- Add more resources here -->
	            <ResourceDictionary.MergedDictionaries>
	                <!-- Add more resource dictionaries here -->
	                <local:MyResourceDictionary />
	                <theme:LightTheme />
	                <!-- Add more resource dictionaries here -->
	            </ResourceDictionary.MergedDictionaries>
	            <!-- Add more resources here -->
	        </ResourceDictionary>
	    </ContentPage.Resources>
	    ...
	</ContentPage>


当合并 ResourceDictionary 的资源共享相同 x:Key 的属性值时， Xamarin.Forms 将使用以下资源优先级：

- 本地资源字典的资源。
- 资源字典中包含的资源已通过 MergedDictionaries 集合合并，并以相反的顺序在属性中列出 MergedDictionaries 。



## Passing Arguments 标签传入参数
https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/passing-arguments

默认命名空间 x 下的其它扩展标记，构造函数传参扩展如下 Passing Arguments in XAML

- {x:Null} 可以给属性设置一个 Null 值；
- {x:Array Type=sys:String} 设置一个数组。
- {x:Array}
- {x:Boolean}
- {x:Byte}
- {x:Char}
- {x:DateTime}
- {x:Decimal}
- {x:Double}
- {x:Int16}
- {x:Int32}
- {x:Int64}
- {x:Object}
- {x:Single}
- {x:String}
- {x:TimeSpan}

使用方法

<!-- ```xml -->
	<BoxView HeightRequest="150" WidthRequest="150" HorizontalOptions="Center">
	  <BoxView.Color>
	    <Color>
	      <x:Arguments>
	        <x:Double>0.8</x:Double>
	        <x:Double>0.5</x:Double>
	        <x:Double>0.2</x:Double>
	        <x:Double>0.5</x:Double>
	      </x:Arguments>
	    </Color>
	  </BoxView.Color>
	</BoxView>
<!-- ``` -->

Calling Factory Methods 执行方法扩展 x:FactoryMethod

<!-- ```xml -->
	<Color x:FactoryMethod="FromHsla">
	  <x:Arguments>
		<x:Double>0.23</x:Double>
		<x:Double>0.42</x:Double>
		<x:Double>0.69</x:Double>
		<x:Double>0.7</x:Double>
	  </x:Arguments>
	</Color>
<!-- ``` -->


设置泛型参数 OnPlatform 组件支持泛型，可以使用 x:TypeArguments 传入泛型参数：

<!-- ```xml -->
	<OnPlatform x:TypeArguments="Thickness">
		<On Platform="iOS" Value="0,20,0,0" />
		<On Platform="Android" Value="5, 10" />
		<On Platform="UWP" Value="10" />
	</OnPlatform>
<!-- ``` -->

访问修饰符 XAML Field Modifiers in Xamarin.Forms

<!-- ```xml -->
	<Label x:Name="privateLabel" />
	<Label x:Name="internalLabel" x:FieldModifier="internal" />
	<Label x:Name="publicLabel" x:FieldModifier="public" />
<!-- ``` -->



## Behaviors 行为类型
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/behaviors/
- https://docs.microsoft.com/zh-cn/dotnet/api/xamarin.forms.behavior-1?view=xamarin-forms


将行为对象 Behavior 添加到用户界面控件，可在多个应用程序中重复使用，无需将其子类化，就可以实现由代码实现的行为功能，并以 XAML 或代码的形式添加到控件中。

行为使开发人员可以实现那些通常必须以代码隐藏形式编写的代码，因为它直接与控件的 API 进行交互，这样便可简洁地将其附加到控件。 

行为是一种非常有用的方法，例如，用于向控件添加效果、从代码隐藏文件中删除冗余重复的效果处理代码。

可实现功能如：

- 向 Entry 添加电子邮件验证程序。
- 使用点击手势识别器创建评分控件。
- 控制动画。
- 向控件添加效果。

在命令的上下文中，行为是一种很有用的方法，能将控件与命令连接起来。 此外，它们还可用于将命令与非旨在与命令交互的控件相关联。 例如，可以使用它们调用命令来响应事件触发。

Xamarin.Forms 支持以下两种不同风格的行为：

- Behavior 或 Behavior<T> 类派生的行为类，其中 T 是应用该行为的控件的类型。 
- Attach-Behavior 附加行为，具有一个或多个附加属性的 static 类。 

创建 Xamarin.Forms 行为的基本步骤：

- 创建一个继承自 Behavior 或 Behavior<T> 类的类，其中 T 是施加该行为的控件类型。
- 重写 OnAttachedTo 方法以执行任何所需的设置。
- 重写 OnDetachingFrom 方法以执行任何所需的清理。
- 实现行为的核心功能。


示例应用程序演示一个 NumericValidationBehavior，并用红色突出显示用户输入到 Entry 控件的值，如果不是 double 类型：

<!-- ```C# -->
	public class NumericValidationBehavior : Behavior<Entry>
	{
	    protected override void OnAttachedTo(Entry entry)
	    {
	        entry.TextChanged += OnEntryTextChanged;
	        base.OnAttachedTo(entry);
	    }

	    protected override void OnDetachingFrom(Entry entry)
	    {
	        entry.TextChanged -= OnEntryTextChanged;
	        base.OnDetachingFrom(entry);
	    }

	    void OnEntryTextChanged(object sender, TextChangedEventArgs args)
	    {
	        double result;
	        bool isValid = double.TryParse (args.NewTextValue, out result);
	        ((Entry)sender).TextColor = isValid ? Color.Default : Color.Red;
	    }
	}
<!-- ``` -->

`OnAttachedTo` 方法在行为附加到控件后立即触发。 此方法接收对其附加的控件的引用，并可用于注册事件处理程序或执行支持行为功能所需的其他设置。 例如，你可以订阅控件上的事件。 然后，行为功能将在事件的事件处理程序中实现。

`OnDetachingFrom` 方法在从控件中删除行为时触发。 此方法接收对其附加的控件的引用，并用于执行任何所需的清理。 例如，可以取消订阅控件上的事件，以防止内存泄漏。

使用 Xamarin.Forms 行为，控件都有一个 Behaviors 集合，可以添加任意个行为，如以下 XAML 代码示例所示：

	<Entry Placeholder="Enter a System.Double">
	    <Entry.Behaviors>
	        <local:NumericValidationBehavior />
	    </Entry.Behaviors>
	</Entry>

下面的代码示例介绍了 C# 中的等效 Entry：

	var entry = new Entry { Placeholder = "Enter a System.Double" };
	entry.Behaviors.Add (new NumericValidationBehavior ());


使用具有样式的 Xamarin.Forms 行为，行为也可以通过显式或隐式样式使用。 

但是，不能创建设置控件的 Behaviors 属性的样式，因为该属性只读。 解决方案是向行为类添加附加属性，以控制添加和删除行为。

样式化行为定义流程如下：

- 将附加属性添加到行为类中，以实现为目标控件添加和删除行为。 确保附加属性注册 propertyChanged 委托，以在属性值更改时执行。
- 为附加属性创建 static getter 和 setter。
- 在 propertyChanged 委托中实现逻辑以添加和删除行为。

下面的代码示例显示了一个附加属性，用于控制添加和删除 NumericValidationBehavior：

<!-- ```C# -->
	public class NumericValidationBehavior : Behavior<Entry>
	{
	    public static readonly BindableProperty AttachBehaviorProperty =
	        BindableProperty.CreateAttached (
	        	"AttachBehavior", 
	        	typeof(bool), 
	        	typeof(NumericValidationBehavior), 
	        	false, 
	        	propertyChanged: OnAttachBehaviorChanged);

	    public static bool GetAttachBehavior (BindableObject view)
	    {
	        return (bool)view.GetValue (AttachBehaviorProperty);
	    }

	    public static void SetAttachBehavior (BindableObject view, bool value)
	    {
	        view.SetValue (AttachBehaviorProperty, value);
	    }

	    static void OnAttachBehaviorChanged (BindableObject view, object oldValue, object newValue)
	    {
	        var entry = view as Entry;
	        if (entry == null) {
	            return;
	        }

	        bool attachBehavior = (bool)newValue;
	        if (attachBehavior) {
	            entry.Behaviors.Add (new NumericValidationBehavior ());
	        } else {
	            var toRemove = entry.Behaviors.FirstOrDefault (b => b is NumericValidationBehavior);
	            if (toRemove != null) {
	                entry.Behaviors.Remove (toRemove);
	            }
	        }
	    }
	    ...
	}
<!-- ``` -->


该类包含带有 static getter 和 setter 且名为 `AttachBehavior` 的附加属性，该属性控制控件的附加行为添加和删除。 具体由属性注册的 `OnAttachBehaviorChanged` 方法根据 AttachBehavior 附加属性的值向控件添加或移除行为。

下面的代码示例显示使用 AttachBehavior 附加属性的 NumericValidationBehavior 的显式样式，该样式可应用于 Entry 控件：

	<Style x:Key="NumericValidationStyle" TargetType="Entry">
	    <Style.Setters>
	        <Setter Property="local:NumericValidationBehavior.AttachBehavior" Value="true" />
	    </Style.Setters>
	</Style>

Style 通过使用 StaticResource 标记扩展将其 Style 属性设置为 Style 实例使其可应用于 Entry 控件，如以下代码示例所示：

	<Entry Placeholder="Enter a System.Double" Style="{StaticResource NumericValidationStyle}">


在 OnDetachingFrom 执行时，行为对象从目标组件卸下，需要在此移除行为对象，或清除控件的 Behaviors 集合。此外，请注意，当从导航堆栈中弹出页面时，行为不会从控件中隐式删除。 相反，必须在页面超出范围之前显式删除它们。

	var toRemove = entry.Behaviors.FirstOrDefault (b => b is NumericValidationBehavior);
	if (toRemove != null) {
	    entry.Behaviors.Remove (toRemove);
		// entry.Behaviors.Clear();
	}

旧式的附加行为存在一个问题，即它们使用 static 属性和方法在 static 类中进行定义。 这使得创建具有状态的附加行为变得困难。 此外，Xamarin.Forms 行为已替代附加行为，成为了行为构造的首选方法。

附加行为的使用方式，可通过向 Entry 控件添加 AttachBehavior 附加属性来使用 NumericValidationBehavior 类，如下面的 XAML 代码示例所示：

	<ContentPage ... xmlns:local="clr-namespace:WorkingWithBehaviors;assembly=WorkingWithBehaviors" ...>
	    ...
	    <Entry Placeholder="Enter a System.Double" local:NumericValidationBehavior.AttachBehavior="true" />
	    ...
	</ContentPage>

等价 C# 写法：

	var entry = new Entry { Placeholder = "Enter a System.Double" };
	NumericValidationBehavior.SetAttachBehavior (entry, true);



### EffectBehavior 效果行为示范

这里实现一个 EffectBehavior 行为类，用来为组件添加文字阴影效果。

使用方法，可以附加到控件的 Behaviors 集合，如以下 XAML 代码示例所示：

	<Label Text="Label Shadow Effect" ...>
	  <Label.Behaviors>
	    <local:EffectBehavior Group="Xamarin" Name="LabelShadowEffect" />
	  </Label.Behaviors>
	</Label>

以下代码示例显示相应的 C# 代码：

	var label = new Label {
	  Text = "Label Shadow Effect",
	  ...
	};
	label.Behaviors.Add (new EffectBehavior {
	  Group = "Xamarin",
	  Name = "LabelShadowEffect"
	});

行为的 Group 和 Name 属性被设置为每个平台特定项目的效果类的 ResolutionGroupName 和 ExportEffect 特性的值。
在运行时，当行为附加到 Label 控件时，Xamarin.LabelShadowEffect 将添加到控件的 Effects 集合中。 这就使阴影被添加到 Label 控件显示的文本中





# Xamarin Cross Platform
- [Xamarin.Forms Platforms](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/platform/)
- [Microsoft .NET Portable Library Reference Assemblies 4.6](https://www.microsoft.com/en-us/download/details.aspx?id=40727)
- [Preparing an Application for Release](https://docs.microsoft.com/en-us/xamarin/android/deploy-test/release-prep)
- [Application Package Size](https://docs.microsoft.com/en-us/xamarin/android/deploy-test/app-package-size)
- [Android SDK 支持库安装](https://docs.microsoft.com/zh-cn/xamarin/android/troubleshooting/resolving-library-installation-errors)
- [Hardware Acceleration - Hpyer-V & HAXM](https://docs.microsoft.com/en-us/xamarin/android/get-started/installation/android-emulator/)
- [Quick Start Single Page App](https://docs.microsoft.com/zh-cn/xamarin/get-started/quickstarts/single-page)
- [Creating Mobile Apps with Xamarin.Forms book](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/creating-mobile-apps-xamarin-forms/)
- [Visual Studio Key Tricks](https://docs.microsoft.com/zh-cn/visualstudio/ide/tips-and-tricks-for-visual-studio)
- []()

Xmarin 提供了在 Windows 和 macOS 上的 Visual Studio 中使用 C# 和 .NET 构建跨平台 Android 和 iOS 应用程序的能力。

Xamarin.Forms 是一个开放源代码跨平台的 UI 框架。 Xamarin.Forms 使开发人员可以从单个共享基本代码生成 Android、iOS 和 Windows 应用程序。Xamarin.Forms 提供了一个公共 API，它可跨平台呈现本机控件，但特定平台的功能可能在其他平台上不存在。 例如，Android 平台具有用于在 ListView 中快速滚动的本机功能，但 iOS 却没有。 通过 Xamarin.Forms 平台特定内容可以使用仅在特定平台上提供的功能。

和 Cordova Ionic 这类结合 HTML 5 开发的 HyperApp 不同，Xamarin 以接近移动平台原生的方式运行，效率不可相比。

Xamarin 和 Flutter 更为相似，关键的技术是 Xamarin.Forms 把 iOS、Android、UWP 等平台的 GUI 统一抽象成同一个 UI 框架，开发者只需要写一套代码，编译器会在编译时将界面映射到原先控件上，从而获得原生平台的外观和性能。损耗小并不代表没有，官方也表示，Xamarin.Forms 不适合用于开发图形界面操作特别复杂且频繁的应用，像大型的 3D 游戏。在一些平台差异化的实现中，Xamarin.iOS、Xamarin.Android 就提供解决问题的实施方案。

Xamarin.Forms 提供的功能的一些示例包括：

- XAML 用户界面语言
- 数据绑定
- 笔势
- 效果
- 样式

通过 Visual Studio 2019 创建的 Xamarin 工程，在提供 Xamarin.Forms 基础通用 UI 框架项目外，它生成一个共享库，供 Xamarin.Android 和 Xamarin.iOS 等平台使用，生成平台差异化的应用。

Xamarin.iOS 为 .NET 开发人员提供了完整的 iOS SDK。 在 Visual Studio 中使用 C# 或 F# 生成完全本机的 iOS 应用。

Xamarin.Android 为 .NET 开发人员提供了完整的 Android SDK。 在 Visual Studio 中使用 C# 或 F# 生成完全本机的 Android 应用。

Xamarin.Essentials 是一个库，可为本机设备功能提供跨平台 API。 与 Xamarin 本身一样，Xamarin.Essentials 是一种简化本机功能访问过程的抽象。 

Xamarin.Essentials 提供的功能的一些示例包括：

- 设备信息
- 文件系统
- 加速计
- 电话拨号程序
- 文本到语音转换
- 屏幕锁定

Xamarin 是一个开放源代码平台，用于通过 .NET 构建适用于 iOS、Android 和 Windows 的新式高性能应用程序。 Xamarin 是一个抽象层，可管理共享代码与基础平台代码的通信。 Xamarin 在提供便利（如内存分配和垃圾回收）的托管环境中运行。

Xamarin 使开发人员可以跨平台共享其应用程序（平均 90%）。 此模式允许开发人员以一种语言编写所有业务逻辑（或重复使用现有应用程序代码），但在每个平台上实现本机性能和外观。
Xamarin 应用程序可以在电脑或 Mac 上进行编写并编译为本机应用程序包，如 Android 上的 .apk 文件，或 iOS 上的 .ipa 文件。

Xamarin.Android 应用程序从 C# 编译为中间语言 (IL)，随后在启动应用程序时，再实时 (JIT) 编译为本机程序集。 Xamarin.Android 应用程序在 Mono 执行环境中与 Android 运行时 (ART) 虚拟机并行运行。 Xamarin 向 Android.* 和 Java.* 命名空间提供 .NET 绑定。 Mono 执行环境通过托管可调用包装器 (MCW) 调入这些命名空间，并向 ART 提供 Android 可调用包装器 (ACW)，这使两种环境可以相互调用代码。

在 Android 上大多数系统功能 (如音频、图形、OpenGL 和电话服务) 都不能直接用于本机应用程序, 它们只能通过驻留在某个 Java.* 命名空间或 Android.* 命名空间的运行时 Java API 公开。

可以使用 System、 System.IO、 System.Net 和 .net 类库的其余部分来访问基础 Linux 操作系统设备。

对比一下 Xamarin 和 JAVA 开发的 Android 应用程序编译执行过程：

	*.java ---> JavaC ----> .class ---> JVM load class

	*.cs ---> C# complier ---> IL  --->  MonoVM + JIT execute 

根据其类型和复杂性，Xamarin 应用程序通常比本地应用程序大，一个 HelloWorld 大小可能需要 16 MB 组成：

- Mono Runtime 1.2 MB
- BCL - Base Class Library
	- mscorlib runtime 2.6 MB
	- System 1.0 MB
	- XML Model 1.2 MB
	- System.Core 370 KB
	- Mono.Security 280 KB
	- Mono.Android 9.4 MB
- HelloWorld 6 KB

Xamarin 项目被编译成 DLL 程序集，打包成 apk 文件，可以通过像 DotPeek 反射很容易被逆向工程破解，可以考虑增加混淆加密 Obfuscation 或 AOT - Ahead of Time 编译技术。

ProGuard 是一个用于链接和混淆 Java 代码的 Android SDK 工具，通常用于减少 APK 中的大型库（如Google Play服务）的占用量，以此创建较小的应用。ProGuard 可以删除未使用的 Java 字节码，以此来减小最终的应用大小。在 Xamarin.Android 应用中通常可以减小大约 24% 的大小，在含有多个库依赖的大型应用中，会有更加明显的缩减。


安装完 Xamarin 后，编译 Android 项目时卡死好长时间进度都不动，可能是因在 Android 项目在第一次编译时要去 google 网站上下一个 Andorid SDK ，国内连接不上就卡住，解决办法就是自已到国内的一些镜像网站上下载 Android SDK。还有，最好连接手机，打开开发者选项进行调试。根据已经安装的 SDK 版本，和连接手机设备，设置项目的最低 Android API 版本和目标 Android API 版本。

使用模拟器需要启用 Windows 功能：

- Hyper-V 
- Windows Hypervisor Platform 虚拟机监控平台

使用 Hyper-V 会和 Virtual-Box 等虚拟机冲突，可以使用命令关闭：

	bcdedit /set hypervisorlaunchtype off
	bcdedit /set hypervisorlaunchtype auto

早在 Virtual Box 6.0.0 就添加了对 Hyper-V 的支持，但是这个特性是隐藏的，并不默认开启，需要通过命令开启：

	VBoxManage setextradata global "VBoxInternal/NEM/UseRing0Runloop" 0


检查以下 Xamarin 安装程序会用到的服务器：

- xamarin.com   安装程序清单
- dl.xamarin.com    包下载位置
- dl.google.com 用于下载 Android SDK
- download.oracle.com (JDK)
- visualstudio.com  安装包下载位置
- go.microsoft.com  安装程序 URL 解析
- aka.ms    安装程序 URL 解析
- www.nuget.org 用于访问 NuGet
- globalcdn.nuget.org   NuGet 下载
- dl-ssl.google.com 适用于 Android 和 Xamarin.Forms 的 Google 组件
- software.xamarin.com  更新程序服务
- download.visualstudio.microsoft.com
- dl.xamarin.com


将下载的文件解压到对应目录下，或者解压到任意目录后，再用 mklink 命令建立 content 链接到 android_m2repository：

	android_m2repository_r29.zip
	C:\Users\{username}\AppData\Local\Xamarin\Android.Support.v4\23.3.0.0\content
	
	android_m2repository_r16.zip
	C:\Users\{username}\AppData\Local\Xamarin\Android.Support.v4\22.2.1\content

链接 ：

	md Android.Support.v4\23.3.0.0\
	mklink /j Android.Support.v4\23.3.0.0\content path_to_android_m2repository_r29

	md Android.Support.v4\22.2.1\
	mklink /j Android.Support.v4\22.2.1\content path_to_android_m2repository_r29

	md Android.Support.v4\22.2.1\
	mklink /j Android.Support.v4\22.2.1\content C:\android\sdk\extras\android\m2repository

Maven Repository  存储库是一个存储 JAR 文件的仓库，Maven 根据项目中 pom.xml 文件中提供的 jar 包依赖信息，从存储库中查找并获取需要的 jar 包。

Maven Repository有3种类型:

- Local Repository - 本地库
- Central Repository - 中央库
- Remote Repository - 远程库

m2repository 是 Maven 管理项目依赖包 .jar 文件的仓库目录，在 Maven 之前通常需要拷贝到 /lib 目录，项目多拷贝的文件副本就多，占用磁盘空间更多，且难于管理。Maven 使用一个称之为仓库的目录，根据构件的坐标统一存储这些构件的唯一副本，在项目中通过依赖声明，可以方便的引用构件。项目只需通过 Maven 本地仓库或服务器仓库找依赖包即可。


## Visual Studio Keys 隐匿的快捷键：

- Ctrl-1-S  符号跳转，工程级符号查找
- Ctrl-1-R  转到最近文件，定位，打开工程文件
- Ctrl-Shift-T  转到文件，定位，打开工程文件
- Ctrl-K-K  在当前语句上添加书签，方便定位
- Shift-F2  导航到上一个书签
- Shift-F7  转到设计器
- Ctrl-Alt-0    转到代码
- Ctrl-Q    Studio 查找文件、变量、类等等 
- F2    导航到下一个书签 
- Ctrl-Tab  已打开文档列表 
- F12   转到定义
- Ctrl-F4   关闭活动文档
- Ctrl-Alt-Down 显示打开的文件列表


- Shift-Alt-.   多点编辑
- Shift-Alt-;   所有相似内容多点编辑
- Shift-Alt-,   丢弃最后一个编辑点
- Ctrl-D    复制行
- Ctrl-L    剪切行
- Alt-UP/Dn 加方向键上下移动行内容
- Alt-Left  Ctrl-J 提示上下文内容
- Ctrl-Enter    前插入行
- Shift-Enter   后插入行
- Ctrl-Alt  点击设置多个编辑位置
- Ctrl-U    转换为小写
- Ctrl-Shift-U  转换为大写
- Ctrl-Shift-/  切换块内容注解
- Ctrl-K-/  切换行注解
- Ctrl-K-C  行内容注解
- Ctrl-K-U  解除内容注解
- Ctrl-}    匹配花括号
- Ctrl-Shift-}  选择匹配花括号内容
- Shift-End 选择直到行尾
- Shift-Home    选择直到行首
- Ctrl-Delete   删除光标右侧词汇
- F10   逐过程执行
- F11   逐语句执行
- F9    设置或删除断点
- F5    开始调试
- Shift-F5  停止调试
- Ctrl-Alt-P    附加到进程
- Ctrl-Shift-F9 删除所有断点
- Ctrl- 

## Conditional Compilation 条件编译
- https://docs.microsoft.com/en-us/xamarin/cross-platform/app-fundamentals/building-cross-platform-applications/platform-divergence-abstraction-divergent-implementation

Xamarin 作为共享代码的开发工具 Shared Asset Projects，条件编译可以在需要使用特定平台特性时派上用场。

Xamarin 工程总是提供 `__MOBILE__` 符号定义， iOS 和 Android 应用都如此。

<!-- ```C# -->
	#if __MOBILE__
	// Xamarin iOS or Android-specific code
	#endif

	#if __IOS__
	// iOS-specific code
	#endif

	#if __TVOS__
	// tv-specific stuff
	#endif

	#if __WATCHOS__
	// watch-specific stuff
	#endif

	#if __ANDROID__
	// Android-specific code
	#endif

	#if __ANDROID_11__
	// code that should only run on Android 3.0 Honeycomb or newer
	#endif

	#if __MACOS__
	// macOS-specific code
	#endif

	#if WINDOWS_UWP
	// UWP-specific code
	#endif
<!-- ``` -->

示例：

<!-- ```C# -->
	public static string DatabaseFilePath
	{
		get
		{
			var filename = "TodoDatabase.db3";
	#if SILVERLIGHT
			// Windows Phone 8
			var path = filename;
	#else

	#if __ANDROID__
			string libraryPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal);
	#else
	#if __IOS__
			// we need to put in /Library/ on iOS5.1 to meet Apple's iCloud terms
			// (they don't want non-user-generated data in Documents)
			string documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
			string libraryPath = Path.Combine (documentsPath, "..", "Library");
	#else
			// UWP
			string libraryPath = Windows.Storage.ApplicationData.Current.LocalFolder.Path;
	#endif
	#endif
			var path = Path.Combine(libraryPath, filename);
	#endif
			return path;
		}
	}
<!-- ``` -->



## Xamarin.Forms Navigation
- [Xamarin.Forms Navigation](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/app-fundamentals/navigation/)
- [Xamarin.Forms 页面导航](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/navigation/)
- [Xamarin.Forms Shell](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/shell/)

Xamarin.Forms 的 NavigationElement 是提供导航能力的基类，子类 Page 或 View 都具有导航能力，在页面中通常使用继承自 Page 类的 NavigationPage 来管理其他页面堆栈的导航。 

NavigationPage 提供的分层导航基于 LIFO 堆栈实现，Last-In First-Out 即后进先出，后面推送的页面显示在最顶层，弹出后就显示最后那一个页面。 


NavigationPage 的布局取决于平台：

- iOS 中，页面顶部有一个显示标题的导航栏，其上有一个 Back 按钮，可以返回前一页。
- Android 中，页面顶部有一个显示标题、图标的导航栏，其上有一个 Back 按钮，可以返回前一页。 在 [Activity] 属性中定义图标，该属性修饰特定于 Android 平台的项目中的 MainActivity 类。
- Windows 平台上，显示标题的页面顶部有一个导航栏。

在所有平台上，Page.Title 属性的值显示为页面标题，IconColor 属性设置导航栏中的图标的颜色。


在推送页面到导航堆栈时，建议只使用 ContentPage 实例填充 NavigationPage：

<!-- ```C# -->
	public App ()
	{
	  MainPage = new NavigationPage (new Page1Xaml ());
	}
<!-- ``` -->

在导航期间，传送数据最简单的方法，是通过页面构造函数参数传递到：

<!-- ```C# -->
	public App ()
	{
	  MainPage = new NavigationPage (new MainPage (DateTime.Now.ToString ("u")));
	}
<!-- ``` -->

此代码创建一个 MainPage 实例，传入一个 ISO8601 格式日期和时间，该值包装在 NavigationPage 实例中。MainPage 实例通过构造函数参数接收数据，如以下代码示例所示：

<!-- ```C# -->
	public MainPage (string date)
	{
	  InitializeComponent ();
	  dateLabel.Text = date;
	}
<!-- ``` -->

另一种将数据传递方法，是使用新页面的 `BindingContext` 传送数据，如以下代码示例所示：

<!-- ```C# -->
	async void OnNavigateButtonClicked (object sender, EventArgs e)
	{
		var contact = new Contact {
			Name = "Jane Doe",
			Age = 30,
			Occupation = "Developer",
			Country = "USA"
		};

		var secondPage = new SecondPage ();
		secondPage.BindingContext = contact;
		await Navigation.PushAsync (secondPage);
	}
<!-- ``` -->

然后在 SecondPage 使用数据绑定来显示 Contact 实例数据，如以下 XAML 代码示例所示：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 x:Class="PassingData.SecondPage"
				 Title="Second Page">
		<ContentPage.Content>
			<StackLayout HorizontalOptions="Center" VerticalOptions="Center">
				<StackLayout Orientation="Horizontal">
					<Label Text="Name:" HorizontalOptions="FillAndExpand" />
					<Label Text="{Binding Name}" FontSize="Medium" FontAttributes="Bold" />
				</StackLayout>
				...
				<Button x:Name="navigateButton" Text="Previous Page" Clicked="OnNavigateButtonClicked" />
			</StackLayout>
		</ContentPage.Content>
	</ContentPage>
<!-- ``` -->


<!-- ```C# -->
	async void OnNextPageButtonClicked (object sender, EventArgs e)
	{
	  await Navigation.PushAsync (new Page2Xaml ());
	}
<!-- ``` -->

调用 PushAsync 方法推送页面会发生以下事件：

- 当前页面调用 PushAsync 替代其 OnDisappearing 事件处理函数。
- 导航目的页面的 OnAppearing 被替代。
- PushAsync 任务完成。

异步将页面弹出堆栈，回退到前一页面：

<!-- ``` -->
	async void OnPreviousPageButtonClicked (object sender, EventArgs e)
	{
	  await Navigation.PopAsync ();
	}
<!-- ``` -->

- 当前页面调用 PopAsync 替代其 OnDisappearing 事件处理函数。
- 前一页面的 OnAppearing 被替代。
- PopAsync 任务完成。

但是，异步这些事件发生的确切顺序取决于平台，请参考老专家 Charles Petzold 所著的 Creating Mobile Apps with Xamarin.Forms book 第 24 章，2016 出版的电子版网上共享，内容没更新有些过时。

每个页面的 Navigation 属性还提供了 PopToRootAsync 方法，该方法将清空导航堆栈的 Page 只保留最底的一层，如下面的代码示例所示：

<!-- ```C# -->
	async void OnRootPageButtonClicked (object sender, EventArgs e)
	{
		await Navigation.PopToRootAsync ();
	}
<!-- ``` -->

页面 Navigation 属还提供 boolean 参数，用于控制是否在导航期间显示页面动画：

<!-- ```C# -->
		// Page appearance not animated
		await Navigation.PushAsync (new Page2Xaml (), false);

		// Page appearance not animated
		await Navigation.PopAsync (false);

		// Page appearance not animated
<!-- ``` -->
		await Navigation.PopToRootAsync (false);

可使用 Navigation 属性公开 NavigationStack 属性，并从中获得导航堆栈中的页面。 当 Xamarin.Forms 维护对导航堆栈的访问时，Navigation 属性提供 InsertPageBefore 和 RemovePage 方法用于通过插入页面或将其删除来操作堆栈。

<!-- ```C# -->
	async void OnLoginButtonClicked (object sender, EventArgs e)
	{
		...
		var isValid = AreCredentialsCorrect (user);
		if (isValid) {
			App.IsUserLoggedIn = true;
			Navigation.InsertPageBefore (new MainPage (), this);
			await Navigation.PopAsync ();
		} else {
			// Login failed
		}
	}
<!-- ``` -->

这些方法支持自定义导航体验，例如在成功登录后将登录页面替换为新页面。 


通过将 NavigationPage.TitleView 来设置导航栏的内容，所有 Xamarin.FormsView 都可以显示在 NavigationPage 的导航栏中。 此附加属性可以在任何 Page 类型上设置，当 Page 被推送到 NavigationPage 堆栈上，页面导航条就显示 TitleView 的视图。

标题视图示例，演示如何从 XAML 中设置 NavigationPage.TitleView ：

<!-- ```xml -->
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 x:Class="NavigationPageTitleView.TitleViewPage">
		<NavigationPage.TitleView>
			<Slider HeightRequest="44" WidthRequest="300" />
		</NavigationPage.TitleView>
		...
	</ContentPage>
<!-- ``` -->

下面是等效 C# 代码：

<!-- ```C# -->
	public class TitleViewPage : ContentPage
	{
		public TitleViewPage()
		{
			var titleView = new Slider { HeightRequest = 44, WidthRequest = 300 };
			NavigationPage.SetTitleView(this, titleView);
			...
		}
	}
<!-- ``` -->

这导致 Slider 显示在 NavigationPage 的导航栏中

很多视图不会出现在导航栏中，除非使用 WidthRequest 和 HeightRequest 属性指定视图的大小。 或者，可以将视图包装在 StackLayout 中，并将 HorizontalOptions 和 VerticalOptions 属性设置为适当的值。

注意，因为 Layout 类派生自 View 类，所以可以设置 TitleView 来显示包含多个视图的布局类。 在 iOS 和 UWP - Universal Windows Platform 程序上，导航条的高度是不能更改的，所以如果导航条中显示的视图大于导航条的默认大小，就会发生剪裁。 但是，在 Android 上，可以通过将 NavigationPage.BarHeight 可绑定属性设置为表示新高度的 double 值来更改导航条的高度。

在 iOS 中，导航栏底部的分隔线和阴影可以通过将 NavigationPage.HideNavigationBarSeparator 可绑定属性设置为 true 来移除。

BackButtonTitle/Title/TitleIcon 和 TitleView 视图都占用导航栏空间的值，导航栏大小因平台和屏幕大小而异，设置所有这些属性可能导致冲突。与其尝试使用这些属性的组合，不如仅通过设置 TitleView 属性来更好地实现所需的导航栏设计。

当在 NavigationPage 的导航栏中显示 View 时，需要注意一些限制：

- 在 iOS 中，放置在导航栏中的视图会根据是否启用大标题显示在不同的位置。
- 在 Android 上只有在使用 app-compat 的应用程序中，才能在的导航栏中放置视图。
- 不建议在导航条中放置大而复杂的视图，如 ListView 和 TableView。


典型的多页面程序结构中会使用以下几种继承了导航能力的页面容器组件：

- TabbedPage

	TabbedPage 页面以 Children 属性作为容纳 ContentPage 对象的集合，Page.Title 文字和 Page.IconImageSource 图像作为 Tab 选项卡按钮，点击时显示对应的 Page 组件。AXML 和等价 C# 如下：

<!-- ```xml -->
		<TabbedPage xmlns="http://xamarin.com/schemas/2014/forms"
					xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
					xmlns:local="clr-namespace:TabbedPageWithNavigationPage;assembly=TabbedPageWithNavigationPage"
					x:Class="TabbedPageWithNavigationPage.MainPage">
			<local:TodayPage />
			<NavigationPage Title="Schedule" IconImageSource="schedule.png">
				<x:Arguments>
					<local:SchedulePage />
				</x:Arguments>
			</NavigationPage>
		</TabbedPage>
<!-- ``` -->

	

<!-- ```C# -->
		public class MainPageCS : TabbedPage
		{
			public MainPageCS ()
			{
				NavigationPage navigationPage = new NavigationPage (new SchedulePageCS ());
				navigationPage.IconImageSource = "schedule.png";
				navigationPage.Title = "Schedule";

				Children.Add (new TodayPageCS ());
				Children.Add (navigationPage);
			}
		}
<!-- ``` -->

导航到页面：

	await Navigation.PushAsync (new UpcomingAppointmentsPage ());

- CarouselPage

	CarouselPage  提供一个侧滑容器，页面通过侧滑动作导航跳转。

- MasterDetailPage

	MasterDetailPage，这是一种母版/详细信息页，通过 Master 和 Detail 属性设置两个子页，以对应显示条目列表和条目详情。在模板工程中，利用它们分别显示菜单和数据列表。


Xamarin.Forms 提供的模态页面对象 Modal Pages 主要是鼓励开发者，自行创建自己的页面，以适应在处理任务中，或直到任务完成、取消前，不能导航的状态。

将页面推送到模态堆栈，禁用后退按钮并对页面过渡效果进行动画处理。从模态堆栈中弹出后页面后，再进行导航，传递数据侧通过页面构造函数和 BindingContext 传递。

可以由任何 Page 派生类型上的 Navigation 属性公开模式导航方法。 可通过这些方法将模式页面推送到模式堆栈中，还可从模式堆栈中弹出模式页面。

Navigation 属性也可公开 ModalStack 属性，并从中获得模式堆栈中的模式页面。 但是，在模式导航中没有执行模式堆栈操作或弹出到根页的概念。 这是因为基础平台普遍都不支持这些操作。

若要导航到 ModalPage，必须调用当前页的 Navigation 属性上的 PushModalAsync 方法，如以下代码示例所示：

<!-- ```C# -->
	async void OnItemSelected (object sender, SelectedItemChangedEventArgs e)
	{
	  if (listView.SelectedItem != null) {
		var detailPage = new DetailPage ();
		...
		await Navigation.PushModalAsync (detailPage);
	  }
	}
<!-- ``` -->

通过设备上的后退按钮，无论是设备上的物理按钮还是屏幕按钮，都可以从模式堆栈中弹出活动页面。 若要以编程方式返回原始页， ModalPage 实例必须调用 PopModalAsync 方法，如以下代码示例所示：

<!-- ```C# -->
	async void OnDismissButtonClicked (object sender, EventArgs args)
	{
	  await Navigation.PopModalAsync ();
	}
<!-- ``` -->

在 Android 上，只要按设备上的标准“后退”按钮，用户就可返回到上一页。 如果模式页面要求用户在离开页面之前完成独立任务，则应用程序必须禁用“后退”按钮。 可通过替代模式页面上的 Page.OnBackButtonPressed 方法来完成此操作。

禁止页面过渡效果进行动画处理：

<!-- ```C# -->
	// Page appearance not animated
	await Navigation.PushModalAsync (new DetailPage (), false);

	// Page appearance not animated
	await Navigation.PopModalAsync (false);
<!-- ``` -->



## Sparrows QuickStart - Multi-Page Project
- [Perform Navigation in a Multi-Page Xamarin.Forms Application](https://docs.microsoft.com/en-us/xamarin/get-started/quickstarts/multi-page)
- [Quickstarts Deep Dive](https://docs.microsoft.com/en-us/xamarin/get-started/quickstarts/deepdive)
- []()

一个多页面的 Multi-Page 起步项算是一个完整的 Xamarin 项目骨架，通过这个项目达成以下技能学习目标：

- 往 Xamarin.Forms 项目添加页面对象；
- 实现页面间的导航跳转；
- 使用数据绑定在 UI 组件间同步数据；

Visual Studio 2019 提供的 Xamarin.Forms 工程模板就是很好的学习案例：

	└───XamarinVS2019   项目根目录
	  ├─── App.xaml     程序对象视图实现
	  ├─── App.xaml.cs  负责程序对象的初始化，配置数据依赖服务等
	  ├─── AssemblyInfo.cs  程序集信息，Company、 FileVersion、 Product、 Title 等
	  ├─── XamarinVS2019.csproj C# 工程配置文件，SDK、Framework、引用库、程序类型配置等
	  │ 
	  ├─── Models   数据模型文件夹
	  │ ├─── HomeMenuItem.cs    
	  │ └─── Item.cs    
	  │ 
	  ├─── Services     服务文件夹，存放各种服务类实现
	  │ ├─── AzureDataStore.cs  
	  │ ├─── IDataStore.cs  
	  │ └─── MockDataStore.cs   
	  │ 
	  ├─── ViewModels   MVVM 视图模型文件夹
	  │ ├─── AboutViewModel.cs  
	  │ ├─── BaseViewModel.cs   
	  │ ├─── ItemDetailViewModel.cs 
	  │ └─── ItemsViewModel.cs  
	  │ 
	  └─── Views    MVVM 视图文件夹
		├─── AboutPage.xaml 
		├─── AboutPage.xaml.cs  
		├─── ItemDetailPage.xaml    
		├─── ItemDetailPage.xaml.cs 
		├─── ItemsPage.xaml 
		├─── ItemsPage.xaml.cs  
		├─── MainPage.xaml  
		├─── MainPage.xaml.cs   
		├─── MenuPage.xaml  
		├─── MenuPage.xaml.cs   
		├─── NewItemPage.xaml   
		└─── NewItemPage.xaml.cs    

默认工程可以选择 Xamarin.Android、Xamarin.iOS 还有配套的 Web 数据服务接口，它以 MVC API 方式实现，具体参考 .Net Core MVC 的开发，和 ApiController 类的使用。

接下来，对程序进行运行流程的分析，并在分析过程中说明涉及到的 Xamarin 技术点。

### Application & MainPage
- [Xamarin.Forms Navigation](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/app-fundamentals/navigation/)
- [Xamarin.Forms 页面导航](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/navigation/)
- [Xamarin.Forms Shell](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/shell/)
- [Dual-Screen 双屏设计](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/dual-screen/design-patterns)
- [Application Class](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/application-class)

Application 和 MainPge 的首要任务：

- 设置程序初始化信息，包括使用什么数据服务；
- 装入初始页面，即 Application.MainPage 属性设置的页面；
- 由 MainPage 设置版面风格，模板工程使用的是 MasterDetailPage，用于显示一个侧栏菜单和内容，设置 MasterBehavior.Popover ；
- 装入 MenuPage 到 MainPage.Master 生成菜单上视图；

Application 视图对象是整个程序的入口，可以配置全局的资源等：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<Application xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.App">

		<Application.Resources>
			<ResourceDictionary>
				<!--Global Styles-->
				<Color x:Key="NavigationPrimary">#2196F3</Color>
				<Style TargetType="NavigationPage">
					<Setter Property="BarBackgroundColor" Value="{StaticResource NavigationPrimary}" />
					<Setter Property="BarTextColor" Value="White" />
				</Style>
			</ResourceDictionary>
		</Application.Resources>
		
	</Application>
<!-- ``` -->


根据不同的平台，程序运行有各种状态，对应 Application 的事件处理 OnStart、 OnSleep、 OnResume。程序实例化时，设置数据接口服务，默认提供演示用的 Mock 数据，即在程序内部生成模拟数据。

<!-- ```C# -->
	using System;
	using Xamarin.Essentials;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;
	using XamarinVS2019.Services;
	using XamarinVS2019.Views;

	namespace XamarinVS2019
	{
		public partial class App : Application
		{
			//TODO: Replace with *.azurewebsites.net url after deploying backend to Azure
			//To debug on Android emulators run the web backend against .NET Core not IIS
			//If using other emulators besides stock Google images you may need to adjust the IP address
			public static string AzureBackendUrl = 
				DeviceInfo.Platform == DevicePlatform.Android ? 
				"http://192.168.0.109:5001" : "http://localhost:5000";
			public static bool UseMockDataStore = true;

			public App()
			{
				InitializeComponent();

				if (UseMockDataStore)
					DependencyService.Register<MockDataStore>();
				else
					DependencyService.Register<AzureDataStore>();
				MainPage = new MainPage();
			}

			protected override void OnStart()
			{
			}

			protected override void OnSleep()
			{
			}

			protected override void OnResume()
			{
			}
		}
	}
<!-- ``` -->

App 对象在整个工程中作为入口点，它首先加载的就是 MainPage：

	MainPage = new MainPage();

MainPage 在整个程序中，担任着页面的导航任务，在用户与 UI 交互过程中，各页面根据用户操作进行导航切换。

Xamarin.Forms 的 NavigationElement 是提供导航能力的基类，子类 Page 或 View 都具有导航能力，在页面中通常使用继承自 Page 类的 NavigationPage 来管理其他页面堆栈的导航。 

NavigationPage 提供的分层导航基于 LIFO 堆栈实现，Last-In First-Out 即后进先出，后面推送的页面显示在最顶层，弹出后就显示最后那一个页面。 

在工程中，通常推送 ContentPage 页面实例到导航堆栈，这也是建议使用的页面类型，实例填充 NavigationPage。


MainPage 继承自 MasterDetailPage，这是一种大纲/详细信息页面，和 NavigationPage 一样继承自 
Page 类型。MasterDetailPage 通过 Master 和 Detail 属性设置两个子页，以对应显示条目列表和条目详情。在模板工程中，利用它们分别显示菜单和数据列表。

MasterDetailPage 通过 MasterBehavior 属性指定 Master 页的呈现方式：

| 方式      | 值 		| Master 页面呈现方式 |
| :-------	| :-------	| :-------	|
| Default   | 0 | 默认值，按平台默认方式呈现 |
| Popover   | 3 | 显示 Detail 页面，通过按钮弹出 Master 页面 |
| Split     | 2 | 页面总是分割屏幕显示 Detail |
| SplitOnLandscape  | 1 | Details are displayed in a split screen when the device is in landscape orientation.
| SplitOnPortrait   | 4 | Details are displayed in a split screen when the device is in portrait orientation.

MasterBehavior 属性对手机端无效，在页面呈现处理分割状态时，不能通过 IsPresented 来设置 Master 的状态。在平板测试中，分割显示的 Master 有时会隐藏不显示，菜单按钮也丢失。

可以设置是不可以通过侧滑手势打开大纲页面，也可以设置大纲页面的背景色，但是不能设置宽度高度等，因为页面对象的宽高只读：

	IsGestureEnabled = true;
	Master.BackgroundColor = Color.AliceBlue

除 MasterDetailPage 这种页面布局窗口外，还有选项卡 TabbedPage 和 CarouselPage 侧滑等页面布局容器。


MainPage 视图类在 XAML 文件中载入 MenuPage 页面到大纲视图，在构造函数中初始化一个字典页面字典 MenuPages 来关联现有的页面。

在 MainPage.xaml 文件中，通过 `<x:Arguments>` 方式传入 ItemsPage 作为 MasterDetailPage 构造函数的参数，即向大纲视图填充了一个 ItemsPage 页面对象，它会在页面 MainPage 构造构造函数中的组件初始化方法中设置好，同时构造函数也相应添加 Detail 页面的关联数据到字典中：

	InitializeComponent();
	...
	MenuPages.Add((int)MenuItemType.Browse, (NavigationPage)Detail);

MainPage 实现 `NavigateFromMenu` 方法应菜单的点击，每次执行时判断字典中是否已经已经有相应页面的实例，有且当前没有显示出来就直接加载到 Detail 视图。

菜单页面 MenuPage 在其构造函数中设置绑定的菜单数据，如页面标题信息供视图文件 MenuPage.xaml 中的 ListView 组件使用。并且，在 MenuPage 函数中绑定了菜单点击处理函数，用户点击菜单上的条目时，执行 MainPage 上定义的 `NavigateFromMenu` 方法加载字典对应的条目。

<!-- ```C# -->
	ListViewMenu.SelectedItem = menuItems[0];
	ListViewMenu.ItemSelected += async (sender, e) =>
	{
		if (e.SelectedItem == null)
			return;

		var id = (int)((HomeMenuItem)e.SelectedItem).Id;
		await RootPage.NavigateFromMenu(id);
	};
<!-- ``` -->

默认的菜单条目类型定义了只有 Title 和 Id 两个属性，定义 MenuItemType 枚举值作为 Id 类型，只有 Broswer 和 About 对应两个页面。


菜单的数据在 MenuPage 类型的构造函数中填充，MenuPage.xaml 中以 `d:` 命名空间的组件是为 Visual Studio 设计器所使用，像 `<d:ListView.ItemsSource>` 可以不要管它。

	xmlns:d="http://xamarin.com/schemas/2014/forms/design"

但从数据绑定的功能上，是同样的原理，就是通过 x:Array 标记扩展向 ListView.ItemsSource 传入一个数组作为数据源，数组的元素是字符串：

<!-- ```xml -->
	<d:ListView.ItemsSource>
		<x:Array Type="{x:Type x:String}">
			<x:String>Item 1</x:String>
			<x:String>Item 2</x:String>
		</x:Array>
	</d:ListView.ItemsSource>
<!-- ``` -->

以上是顶层页面和导航菜单逻辑的实现，说实话，个人感觉菜单这部分代码处理的很糟糕，错综复杂，使用很不方便，添加一个页面就要改动几个地方：

- HomeMenuItem 数据模型中增加枚举值；
- MenuPage 菜单页面中增加页面的标题等信息；
- MainPage 顶层页面中修改 NavigateFromMenu 方法，增加 switch 的选择；


如果我要修改菜单逻辑会这样做，使用了反射好像太浮夸，But，能节省关联修改的技术都是极好：

- 给菜单条目设置一个 Tag 属性，通过 Tag 比较是什么页面：

		public Type Tag { get; set; }

- 定义一个 MenuPagesTag 字典保存字符串映射：

		Dictionary<Type, NavigationPage> MenuPagesTag = new Dictionary<Type, NavigationPage>();

- 再重载一个 NavigateFromMenu 方法接收页面类型在 MenuPagesTag 比较，并通过反射方法实例化：

<!-- ```C# -->
	public async Task NavigateFromMenu(Type tag)
		if (!MenuPagesTag.ContainsKey(tag))
		{
			var page = System.Activator.CreateInstance(tag) as Page;
			MenuPagesTag.Add(tag, new NavigationPage(page));
		}
<!-- ``` -->

- 改写菜单页面 ItemSelected 的事件处理逻辑，根据 Tag 是不设置来执行导航方法，如果要判断 Id 可以设置枚举起始值 Browse = 1，用 0 表示没有设置 Id：

<!-- ```C# -->
	var item = (HomeMenuItem)e.SelectedItem;
	if (item.Tag == null)
	{
		await RootPage.NavigateFromMenu(item.Id);
	}else{
		await RootPage.NavigateFromMenu(item.Tag);
	}
<!-- ``` -->

- 然后在 MenuPage 中注册新页面，只需要添加一行代码：

		new HomeMenuItem {Tag = typeof(NamedColor), Title="Named Color" },


MenuItemType.cs：

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.Text;

	namespace XamarinVS2019.Models
	{
		public enum MenuItemType
		{
			Browse,
			About
		}
		public class HomeMenuItem
		{
			public MenuItemType Id { get; set; }
			public string Title { get; set; }
		}
	}
<!-- ``` -->

MenuPage.xaml：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.Views.MenuPage"
				 Title="Menu">
				 
		<StackLayout VerticalOptions="FillAndExpand">
			<ListView x:Name="ListViewMenu"
						HasUnevenRows="True">
				<d:ListView.ItemsSource>
					<x:Array Type="{x:Type x:String}">
						<x:String>Item 1</x:String>
						<x:String>Item 2</x:String>
					</x:Array>
				</d:ListView.ItemsSource>
				<ListView.ItemTemplate>
					<DataTemplate>
						<ViewCell>
							<Grid Padding="10">
								<Label Text="{Binding Title}" d:Text="{Binding .}" FontSize="20"/>
							</Grid>
						</ViewCell>
					</DataTemplate>
				</ListView.ItemTemplate>
			</ListView>
		</StackLayout>

	</ContentPage>
<!-- ``` -->

MenuPage.xaml.cs：

<!-- ```C# -->
	using XamarinVS2019.Models;
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;

	namespace XamarinVS2019.Views
	{
		[DesignTimeVisible(false)]
		public partial class MenuPage : ContentPage
		{
			MainPage RootPage { get => Application.Current.MainPage as MainPage; }
			List<HomeMenuItem> menuItems;
			public MenuPage()
			{
				InitializeComponent();

				menuItems = new List<HomeMenuItem>
				{
					new HomeMenuItem {Id = MenuItemType.Browse, Title="Browse" },
					new HomeMenuItem {Id = MenuItemType.About, Title="About" }
				};

				ListViewMenu.ItemsSource = menuItems;

				ListViewMenu.SelectedItem = menuItems[0];
				ListViewMenu.ItemSelected += async (sender, e) =>
				{
					if (e.SelectedItem == null)
						return;

					var id = (int)((HomeMenuItem)e.SelectedItem).Id;
					await RootPage.NavigateFromMenu(id);
				};
			}
		}
	}
<!-- ``` -->


MainPage.xaml：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<MasterDetailPage xmlns="http://xamarin.com/schemas/2014/forms"
				xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				mc:Ignorable="d"
				xmlns:views="clr-namespace:XamarinVS2019.Views"
				x:Class="XamarinVS2019.Views.MainPage">

		<MasterDetailPage.Master>
			<views:MenuPage />
		</MasterDetailPage.Master>


		<MasterDetailPage.Detail>
			<NavigationPage>
				<x:Arguments>
					<views:ItemsPage />
				</x:Arguments>
				<NavigationPage.Icon>
					<OnPlatform x:TypeArguments="FileImageSource">
						<On Platform="iOS" Value="tab_feed.png"/>
					</OnPlatform>
				</NavigationPage.Icon>
			</NavigationPage>
		</MasterDetailPage.Detail>
		
	</MasterDetailPage>
<!-- ``` -->


MainPage.xaml.cs：

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Threading.Tasks;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;

	using XamarinVS2019.Models;

	namespace XamarinVS2019.Views
	{
		[DesignTimeVisible(false)]
		public partial class MainPage : MasterDetailPage
		{
			Dictionary<int, NavigationPage> MenuPages = new Dictionary<int, NavigationPage>();
			public MainPage()
			{
				InitializeComponent();

				MasterBehavior = MasterBehavior.Popover;

				MenuPages.Add((int)MenuItemType.Browse, (NavigationPage)Detail);
			}

			public async Task NavigateFromMenu(int id)
			{
				if (!MenuPages.ContainsKey(id))
				{
					switch (id)
					{
						case (int)MenuItemType.Browse:
							MenuPages.Add(id, new NavigationPage(new ItemsPage()));
							break;
						case (int)MenuItemType.About:
							MenuPages.Add(id, new NavigationPage(new AboutPage()));
							break;
					}
				}

				var newPage = MenuPages[id];

				if (newPage != null && Detail != newPage)
				{
					Detail = newPage;

					if (Device.RuntimePlatform == Device.Android)
						await Task.Delay(100);

					if (MasterBehavior==MasterBehavior.Popover){
						IsPresented = false;
					}
				}
			}
		}
	}
<!-- ``` -->


MenuPage.xaml：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.Views.MenuPage"
				 Title="Menu">
				 
		<StackLayout VerticalOptions="FillAndExpand">
			<ListView x:Name="ListViewMenu"
						HasUnevenRows="True">
				<d:ListView.ItemsSource>
					<x:Array Type="{x:Type x:String}">
						<x:String>Item 1</x:String>
						<x:String>Item 2</x:String>
					</x:Array>
				</d:ListView.ItemsSource>
				<ListView.ItemTemplate>
					<DataTemplate>
						<ViewCell>
							<Grid Padding="10">
								<Label Text="{Binding Title}" d:Text="{Binding .}" FontSize="20"/>
							</Grid>
						</ViewCell>
					</DataTemplate>
				</ListView.ItemTemplate>
			</ListView>
		</StackLayout>

	</ContentPage>
<!-- ``` -->


MenuPage.xaml.cs：

<!-- ```C# -->
	using XamarinVS2019.Models;
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;

	namespace XamarinVS2019.Views
	{
		[DesignTimeVisible(false)]
		public partial class MenuPage : ContentPage
		{
			MainPage RootPage { get => Application.Current.MainPage as MainPage; }
			List<HomeMenuItem> menuItems;
			public MenuPage()
			{
				InitializeComponent();

				menuItems = new List<HomeMenuItem>
				{
					new HomeMenuItem {Id = MenuItemType.Browse, Title="Browse" },
					new HomeMenuItem {Id = MenuItemType.About, Title="About" }
				};

				ListViewMenu.ItemsSource = menuItems;

				ListViewMenu.SelectedItem = menuItems[0];
				ListViewMenu.ItemSelected += async (sender, e) =>
				{
					if (e.SelectedItem == null)
						return;

					var id = (int)((HomeMenuItem)e.SelectedItem).Id;
					await RootPage.NavigateFromMenu(id);
				};
			}
		}
	}
<!-- ``` -->


### Services & DI
https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/dependency-service/

数据服务是通过 DependencyInjection 模块实现依赖注入的，这是随处可见的编程模式，用于各个模块关系的解耦，参考 .Net Core 的依赖注入内容。

在 App 类的代码中使用了 Xamarin.Forms.DependencyService 的静态方法在服务容器中注册数据服务类，然后，在程序其它需要使用数据服务的地方，再从服务窗口中获取数据服务类。

工程模板的视图模型 ItemsViewModel 和 ItemDetialViewModel 都需要数据服务，它们继承 BaseViewModel 从它那里获取到了数据服务：

	public IDataStore<Item> DataStore => DependencyService.Get<IDataStore<Item>>();


数据服务是根据 IDataStore 接口实现的，它定义了基本的 CURD 操作：

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.Threading.Tasks;

	namespace XamarinVS2019.Services
	{
		public interface IDataStore<T>
		{
			Task<bool> AddItemAsync(T item);
			Task<bool> UpdateItemAsync(T item);
			Task<bool> DeleteItemAsync(string id);
			Task<T> GetItemAsync(string id);
			Task<IEnumerable<T>> GetItemsAsync(bool forceRefresh = false);
		}
	}
<!-- ``` -->

和接口配套的数据模型是 Item 模型类，只定义了三个属性：

<!-- ```C# -->
	using System;

	namespace XamarinVS2019.Models
	{
		public class Item
		{
			public string Id { get; set; }
			public string Text { get; set; }
			public string Description { get; set; }
		}
	}
<!-- ``` -->

数据服务重点在 AzureDataStore 的实现，它负责从服务器上获取和传送数据，通过 System.Net.Http.HttpClient 与数据服务器通信。

在使用 Xamarin 开发 Android 应用时，可能会遇到不允许明文 HTTP 请求异常，因为，从 Android 9.0 开始，出于完全因素考虑，默认不再支持 HTTP 网络请求，需要使用 HTTPS。

临时解决办法，修改 AndroidManifest.xml 以许可明文 HTTP，降低 android:targetSandboxVersion 版本降价安全要求：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<manifest android:targetSandboxVersion="1">
		<uses-permission android:name="android.permission.INTERNET" />
		<application
			...
			android:usesCleartextTraffic="true"
<!-- ``` -->

使用 HTTPS 就需要配置好服务器的证书。

数据服务类中，使用静态类 Xamarin.Essentials.Connectivity 的属性进行网络状态的判断：

	bool IsConnected => Connectivity.NetworkAccess == NetworkAccess.Internet;

它有一个 ConnectivityChanged 事件可以用来监视网络连接的变化，还有 ConnectionProfiles 提供当前系统存在的各种网络配置：

	public static event EventHandler<ConnectivityChangedEventArgs> ConnectivityChanged;

	public static IEnumerable<ConnectionProfile> ConnectionProfiles { get; }

网络连接状态枚举定义：

| 网络类型  | 枚举值   | 含义    |
| :------   | :------   | :------ |
| Bluetooth | 1 | 系统提供蓝牙数据连接 |
| Cellular  | 2 | 移动电话/蜂窝网络数据连接 |
| Ethernet  | 3 | 以太网数据连接 |
| Unknown   | 0 | 未知连接 |
| WiFi      | 4 | WiFI 数据连接 |

然后通过 HttpClient 的各种方法和 Web 服务器进行数据通信：

- GetAsync(...)
- GetByteArrayAsync(String or Uri)
- GetStreamAsync(String or Uri)
- GetStringAsyncnc
- PostAsync
- PutAsync
- DeleteAsync

通信前，给 HttpClient.BaseAddress 设定了一个根地址，各种方法获取。

可以通过 HttpCompletionOption 枚举指定请求如何完成处理，`ResponseContentRead` 表示从服务器中完全获取数据后才完成，`ResponseHeadersRead` 表示获取 HTTP 响应头信息后就当作完成请求。

异步请求中，可在创建 Task 时传入一个 CancellationToken 令牌对象，以控制如何结束请求，如果 CancellationToken 在 Task 调度前取消，那么 Task 就会被取消永远都不执行。

除 Get 指定内容类型，其它 HTTP 方法还会返回 HttpContent 内容，可以使用以下方法对数据进行处理：

<!-- ```C# -->
	Task<byte[]> ReadAsByteArrayAsync ();
	Task<Stream> ReadAsStreamAsync ();
	Task<string> ReadAsStringAsync ();
	Task SerializeToStreamAsync (Stream stream, TransportContext context);
<!-- ``` -->

相比 XML 数据格式，现在的 JSON 更为流行，它结构更简洁，更方便于程序的处理。工程模板使用的是 Newtonsoft.Json 库，其提供的 SerializeObject
和 DeserializeObject 是配对的方法，序列化将对象转化成 JSON 字符串，反序列化将字符串转化为对象：

<!-- ```C# -->
	items = await Task.Run(() => JsonConvert.DeserializeObject<IEnumerable<Item>>(json));

	JsonConvert.SerializeObject(item);
	JsonConvert.DeserializeObject(item);
<!-- ``` -->

服务器的代码中，ApiController 默认就是输出 JSON 数据，客户端获取后通过 System.Text.Json.Serialization 包下的工具进行处理。

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.Net.Http;
	using System.Text;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Xamarin.Essentials;
	using XamarinVS2019.Models;

	namespace XamarinVS2019.Services
	{
		public class AzureDataStore : IDataStore<Item>
		{
			HttpClient client;
			IEnumerable<Item> items;

			public AzureDataStore()
			{
				client = new HttpClient();
				client.BaseAddress = new Uri($"{App.AzureBackendUrl}/");

				items = new List<Item>();
			}

			bool IsConnected => Connectivity.NetworkAccess == NetworkAccess.Internet;
			public async Task<IEnumerable<Item>> GetItemsAsync(bool forceRefresh = false)
			{
				Console.WriteLine("GetItemsAsync.. " + App.AzureBackendUrl + "/api/item");
				if (forceRefresh && IsConnected)
				{
					var json = await client.GetStringAsync($"api/item");
					items = await Task.Run(() => JsonConvert.DeserializeObject<IEnumerable<Item>>(json));
				}

				return items;
			}

			public async Task<Item> GetItemAsync(string id)
			{
				if (id != null && IsConnected)
				{
					var json = await client.GetStringAsync($"api/item/{id}");
					return await Task.Run(() => JsonConvert.DeserializeObject<Item>(json));
				}

				return null;
			}

			public async Task<bool> AddItemAsync(Item item)
			{
				if (item == null || !IsConnected)
					return false;

				var serializedItem = JsonConvert.SerializeObject(item);

				var response = await client.PostAsync($"api/item", new StringContent(serializedItem, Encoding.UTF8, "application/json"));

				return response.IsSuccessStatusCode;
			}

			public async Task<bool> UpdateItemAsync(Item item)
			{
				if (item == null || item.Id == null || !IsConnected)
					return false;

				var serializedItem = JsonConvert.SerializeObject(item);
				var buffer = Encoding.UTF8.GetBytes(serializedItem);
				var byteContent = new ByteArrayContent(buffer);

				var response = await client.PutAsync(new Uri($"api/item/{item.Id}"), byteContent);

				return response.IsSuccessStatusCode;
			}

			public async Task<bool> DeleteItemAsync(string id)
			{
				if (string.IsNullOrEmpty(id) && !IsConnected)
					return false;

				var response = await client.DeleteAsync($"api/item/{id}");

				return response.IsSuccessStatusCode;
			}
		}
	}
<!-- ``` -->



### MVVM ViewModel
https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/messaging-center

在 MVVM 编程模式中，页面视图始终和 ViewModel 如影相随，基本每个页面都会需要通过 BindingContext 绑定一个 ViewModel。

视图类与模型产生关系是通过 BindingContext 属性上绑定模型实例：

<!-- ```xml -->
	<ContentPage.BindingContext>
		<vm:AboutViewModel />
	</ContentPage.BindingContext>
<!-- ``` -->

在模板项目中，视图模型从 BaseViewModel 继承，主要是继承 PropertyChanged 的属性变更通知事件的能力，同时获取数据接口服务以同 Web 服务器进行数据通信。

MVVM 框架会自动对实现 System.ComponentModel.INotifyPropertyChanged 接口的类型进行属性跟踪，通过它发现绑定到视图中的属性变动时，就更新视图，这就是 MVVM 的基本原理。

其中 SetProperty 和 OnPropertyChanged 方法的实现是比较值得参考的，使用了 C# 5.0 的成员名称特性 [CallerMemberName] 自动获取成员的名字字符串，这是编译期完成的：

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Runtime.CompilerServices;

	using Xamarin.Forms;

	using XamarinVS2019.Models;
	using XamarinVS2019.Services;

	namespace XamarinVS2019.ViewModels
	{
		public class BaseViewModel : INotifyPropertyChanged
		{
			public IDataStore<Item> DataStore => DependencyService.Get<IDataStore<Item>>();

			bool isBusy = false;
			public bool IsBusy
			{
				get { return isBusy; }
				set { SetProperty(ref isBusy, value); }
			}

			string title = string.Empty;
			public string Title
			{
				get { return title; }
				set { SetProperty(ref title, value); }
			}

			protected bool SetProperty<T>(ref T backingStore, T value,
				[CallerMemberName] string propertyName = "",
				Action onChanged = null)
			{
				if (EqualityComparer<T>.Default.Equals(backingStore, value))
					return false;

				backingStore = value;
				onChanged?.Invoke();
				OnPropertyChanged(propertyName);
				return true;
			}

			#region INotifyPropertyChanged
			public event PropertyChangedEventHandler PropertyChanged;
			protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
			{
				var changed = PropertyChanged;
				if (changed == null)
					return;

				changed.Invoke(this, new PropertyChangedEventArgs(propertyName));
			}
			#endregion
		}
	}
<!-- ``` -->

有了基础视图模型，其它页面的视图模型实现就可以简化结构，只需要通过数据服务接口获取需要的数据，或传送数据到服务器上。

ItemsViewModel 视图模型就只使用了数据服务接口的其中之一，从服务器上获取数据条目列表。考虑到 ItemsPage 页面会有 RefreshView 组件实现的下拉刷新功能，所以将数据获取的功能封装成 Command 形式，这样即使用是点击按钮，也可以通过 Command 来获取数据列表。

ItemsViewModel 视图模型中使用到了 Xamarin.Forms.MessagingCenter 消息中心，它是按订阅者编程模式编写的一个消息管理对象。消息提供方通过 Send 方发送消息广播，消息消费方通过 Subscirbe 订阅感兴趣的消息。当不再需要获取消息时，通过 Unsubscribe 取消订阅，这些静态方法原形如下，TSender 代表类型：

<!-- ```C# -->
	void Send<TSender> (TSender sender, string message);
	void Send<TSender,TArgs> (TSender sender, string message, TArgs args);

	void Subscribe<TSender,TArgs> (object subscriber, string message, Action<TSender,TArgs> callback, TSender source = null);
	void Subscribe<TSender> (object subscriber, string message, Action<TSender> callback, TSender source = null);

	void Unsubscribe<TSender> (object subscriber, string message);
	void Unsubscribe<TSender,TArgs> (object subscriber, string message);
<!-- ``` -->

使用方法：

<!-- ```C# -->
	public class SubscriberThing 
	{
		public int IntProperty { get; set; }
	}
		
	var subscriber = new SubscriberThing();
	MessagingCenter.Subscribe<MyPage, int> (subscriber, "IntPropertyMessage", 
		(sender, eventArg) => {
			subscriber.IntProperty = eventArg; 
		});
		
	//...later...
		
	MessagingCenter.Send<MyPage, int>(this, "IntPropertyMessage", 2);
	Assert.AreEqual(2, subscriber.IntProperty);
<!-- ``` -->

需要注意，Send 和 Subscirbe 两者第二个参数必须一样，双方才能实现消息连接。订阅者模式的好处是可以解耦模块的关系，不局限在同一个的功能模块，也可以通过消息中心与其他目标模块进行消息通信，实现数据传递的同时又不增加耦合关系，用完即走。

ItemsViewModel 视图模型订阅了一条 AddItem 消息，这条消息会在 NewItemPage 页面中广播，表明它在添加一条数据记录。ItemsViewModel 接收到消息后就通过数据服务接口将数据发往 Web 服务器。

<!-- ```C# -->
	using System;
	using System.Collections.ObjectModel;
	using System.Diagnostics;
	using System.Threading.Tasks;

	using Xamarin.Forms;

	using XamarinVS2019.Models;
	using XamarinVS2019.Views;

	namespace XamarinVS2019.ViewModels
	{
		public class ItemsViewModel : BaseViewModel
		{
			public ObservableCollection<Item> Items { get; set; }
			public Command LoadItemsCommand { get; set; }

			public ItemsViewModel()
			{
				Title = "BROWSE";
				Items = new ObservableCollection<Item>();
				LoadItemsCommand = new Command(async () => await ExecuteLoadItemsCommand());

				MessagingCenter.Subscribe<NewItemPage, Item>(this, "AddItem", async (obj, item) =>
				{
					var newItem = item as Item;
					Items.Add(newItem);
					await DataStore.AddItemAsync(newItem);
				});
			}

			async Task ExecuteLoadItemsCommand()
			{
				IsBusy = true;

				try
				{
					Items.Clear();
					var items = await DataStore.GetItemsAsync(true);
					foreach (var item in items)
					{
						Items.Add(item);
					}
				}
				catch (Exception ex)
				{
					Debug.WriteLine(ex);
				}
				finally
				{
					IsBusy = false;
				}
			}
		}
	}
<!-- ``` -->




### About Page 页面功能分解

About 页面的演示了图片和文字的处理，以及在按钮组件上使用 Command 对象来打开网页链接。

注意，在 MVVM 编程模式下，每个页面的结构基本由三个文件组件，一个实现 Model 模型，另外两个实现页面视图类，cs 文件也叫 code-behind 代码文件。

- AboutViewModel.cs 页面模型类定义;
- AboutPage.xaml 页面视图 XAML 定义;
- AboutPage.xaml.cs 页面视图类定义;

实现页面视图的两个文件是一体的，因为 AboutPage.xaml 文件编译后形成 AboutPage.xaml.g.cs 就是 partical 类，两者合一才是完整个的 View 视图类：

<!-- ```C# -->
	[assembly: global::Xamarin.Forms.Xaml.XamlResourceIdAttribute("XamarinVS2019.Views.AboutPage.xaml", "Views/AboutPage.xaml", typeof(global::XamarinVS2019.Views.AboutPage))]

	namespace XamarinVS2019.Views {
		
		
		[global::Xamarin.Forms.Xaml.XamlFilePathAttribute("Views\\AboutPage.xaml")]
		public partial class AboutPage : global::Xamarin.Forms.ContentPage {
			
			[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Xamarin.Forms.Build.Tasks.XamlG", "2.0.0.0")]
			private void InitializeComponent() {
				global::Xamarin.Forms.Xaml.Extensions.LoadFromXaml(this, typeof(AboutPage));
			}
		}
	}
<!-- ``` -->

视图类与模型产生关系是通过数据绑定，即 BindingContext 属性上绑定模型实例：

	<ContentPage.BindingContext>
		<vm:AboutViewModel />
	</ContentPage.BindingContext>

其中 `vm:` 这个 XML 命名空间需要在 XAML 顶级节点定义：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.Views.AboutPage"
				 xmlns:vm="clr-namespace:XamarinVS2019.ViewModels"
				 Title="{Binding Title}">
<!-- ``` -->

数据绑定是 MVVM 模式 View 视图中常用的数据访问方式，事件处理是 UI 组件的常用工具，另一种是通过 Command 命令的方式和模型进行交互： 

<!-- ```xml -->
	<Button Margin="0,10,0,0" Text="Learn more"
			Command="{Binding OpenWebCommand}"
			BackgroundColor="{StaticResource Primary}"
			TextColor="White" />
<!-- ``` -->


视图文字部分，使用了 FormattedString 组件，这个组件可以内嵌任意 Span 字符组件。

注意图片组件，Source 属性，对于 Android 应用可以设置一个以 drawable 目录为起点的路径，位于 Resource 资源目录下：

	<Image Source="xamarin_logo.png" VerticalOptions="Center" HeightRequest="64" />

Source 是 ImageSource 类型，可以给它指定字符串，是因为 XAML 解析器会对其进行 ImageSourceConverter 做类型转换：

	[Xamarin.Forms.TypeConverter(typeof(Xamarin.Forms.ImageSourceConverter))]
	public Xamarin.Forms.ImageSource Source { get; set; }

又如：

<!-- ```xml -->
	<Button>
		<Button.Background>
			<ImageBrush ImageSource="bg.jpg"/>
		</Button.Background>
	</Button>
<!-- ``` -->

在没有 ImageSourceConverter 转换器的条件上下，对应的的 C# 代码为

<!-- ```C# -->
	ImageBrush imageBrush = new ImageBrush();
	imageBrush.ImageSource = new BitmapImage(new Uri("bg.jpg", UriKind.Relative));
	button.Background = imageBrush;
<!-- ``` -->



AboutViewModel.cs 页面模型类定义：

<!-- ```C# -->
	using System;
	using System.Windows.Input;
	using Xamarin.Essentials;
	using Xamarin.Forms;

	namespace XamarinVS2019.ViewModels
	{
		public class AboutViewModel : BaseViewModel
		{
			public AboutViewModel()
			{
				Title = "AbOut";
				OpenWebCommand = new Command(async () => await Browser.OpenAsync("https://xamarin.com"));
			}

			public ICommand OpenWebCommand { get; }
		}
	}
<!-- ``` -->

AboutPage.xaml.cs 页面类定义：

<!-- ```C# -->
	using System;
	using System.ComponentModel;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;

	namespace XamarinVS2019.Views
	{
		[DesignTimeVisible(false)]
		public partial class AboutPage : ContentPage
		{
			public AboutPage()
			{
				InitializeComponent();
			}
		}
	}
<!-- ``` -->

AboutPage.xaml 页面视图定义：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.Views.AboutPage"
				 xmlns:vm="clr-namespace:XamarinVS2019.ViewModels"
				 Title="{Binding Title}">
		
		<ContentPage.BindingContext>
			<vm:AboutViewModel />
		</ContentPage.BindingContext>
		
		<ContentPage.Resources>
			<ResourceDictionary>
				<Color x:Key="Primary">#2196F3</Color>
				<Color x:Key="Accent">#96d1ff</Color>
				<Color x:Key="LightTextColor">#999999</Color>
			</ResourceDictionary>
		</ContentPage.Resources>

		<Grid>
			<Grid.RowDefinitions>
				<RowDefinition Height="Auto" />
				<RowDefinition Height="*" />
			</Grid.RowDefinitions>
			<StackLayout BackgroundColor="{StaticResource Accent}" VerticalOptions="FillAndExpand" HorizontalOptions="Fill">
				<StackLayout Orientation="Horizontal" HorizontalOptions="Center" VerticalOptions="Center">
					<ContentView Padding="0,40,0,40" VerticalOptions="FillAndExpand">
						<Image Source="xamarin_logo.png" VerticalOptions="Center" HeightRequest="64" />
					</ContentView>
				</StackLayout>
			</StackLayout>
			<ScrollView Grid.Row="1">
				<StackLayout Orientation="Vertical" Padding="16,40,16,40" Spacing="10">
					<Label FontSize="22">
						<Label.FormattedText>
							<FormattedString>
								<FormattedString.Spans>
									<Span Text="AppName" FontAttributes="Bold" FontSize="22" />
									<Span Text=" " />
									<Span Text="1.0" ForegroundColor="{StaticResource LightTextColor}" />
								</FormattedString.Spans>
							</FormattedString>
						</Label.FormattedText>
					</Label>
					<Label>
						<Label.FormattedText>
							<FormattedString>
								<FormattedString.Spans>
									<Span Text="This app is written in C# and native APIs using the" />
									<Span Text=" " />
									<Span Text="Xamarin Platform" FontAttributes="Bold" />
									<Span Text="." />
								</FormattedString.Spans>
							</FormattedString>
						</Label.FormattedText>
					</Label>
					<Label>
						<Label.FormattedText>
							<FormattedString>
								<FormattedString.Spans>
									<Span Text="It shares code with its" />
									<Span Text=" " />
									<Span Text="iOS, Android, and Windows" FontAttributes="Bold" />
									<Span Text=" " />
									<Span Text="versions." />
								</FormattedString.Spans>
							</FormattedString>
						</Label.FormattedText>
					</Label>
					<Button Margin="0,10,0,0" Text="Learn more"
							Command="{Binding OpenWebCommand}"
							BackgroundColor="{StaticResource Primary}"
							TextColor="White" />
				</StackLayout>
			</ScrollView>
		</Grid>
		
	</ContentPage>
<!-- ``` -->



### ItemsPage 页面功能分解
- [数据绑定基础知识](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/xaml/xaml-basics/data-binding-basics)
- [Xamarin.Forms 数据绑定](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/data-binding/)
- [From Data Bindings to MVVM](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/xaml-basics/data-bindings-to-mvvm)
- [Passing Constructor Arguments](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/passing-arguments)
- [Bindable Properties](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/xaml/bindable-properties)
- [AXML x: Namespace Features](https://docs.microsoft.com/en-us/dotnet/desktop-wpf/xaml-services/namespace-language-features)
- [Type Converters and Markup Extensions for XAML](https://docs.microsoft.com/en-us/dotnet/desktop-wpf/xaml-services/type-converters-and-markup-extensions)
- [WPF XAML Extensions](https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/wpf-xaml-extensions)

ItemsPage 是数据条目列表页面，也是由 MainPage 加载到 Detial 视图中的第一个细节页面。

在 MainPage.xaml 文件中，通过 `<x:Arguments>` 方式传入 ItemsPage 作为 MasterDetailPage 构造函数的参数，即向大纲视图填充了一个 ItemsPage 页面对象，它会在页面 MainPage 构造构造函数中的组件初始化方法 InitializeComponent 中设置好：

<!-- ```xml -->
	<MasterDetailPage.Detail>
		<NavigationPage>
			<x:Arguments>
				<views:ItemsPage />
			</x:Arguments>
			<NavigationPage.Icon>
				<OnPlatform x:TypeArguments="FileImageSource">
					<On Platform="iOS" Value="tab_feed.png"/>
				</OnPlatform>
			</NavigationPage.Icon>
		</NavigationPage>
	</MasterDetailPage.Detail>
<!-- ``` -->

同时还使用了 `x:TypeArguments` 这个泛型标记扩展， 即往 OnPlatform 组件传入一个泛型参数，类型为 FileImageSource，也就是显示在 Xamarin.iOS 项目目录下的图片。

ItemsPage 的构造函数中，会实例化 ItemsViewModel 视图模型对象，它在实例化时就会从数据库上获取数据列表，然后通过 BindingContext 属性绑定到 ItemsPage 上。

可以和 AboutPage 中 axml 绑定方式比较一下差别，它们作用是等价的，绑定后就可以在 xaml 中通过类似 Binding 这样的标记扩展访问模型上的数据：

<!-- ```C# -->
	BindingContext = viewModel = new ItemsViewModel();
<!-- ``` -->

<!-- ```xml -->
	<ContentPage.BindingContext>
		<vm:AboutViewModel />
	</ContentPage.BindingContext>
<!-- ``` -->


同菜单页面一样，数据列表页面也使用了 `d:` 这个专为 Visual
Studio 设计器准备的命名空间，`<d:CollectionView.ItemsSource>` 表示为设计器中的视图填充数据，实现运行不起作用。还有 `[DesignTimeVisible(false)]` 也是设计器使用的特性，直接路过。

比较重要是数据绑定用到的标记扩展，Data Binding & Markup Extension，这里只使用了其中两个标记扩展用于数据绑定：

| 扩展标记  | 用法要点 |
| :------   | :------ |
| Binding   | 绑定标记扩展将属性值延迟为数据绑定值，创建中间表达式对象并解释在运行时应用于元素及其绑定的数据上下文。 |
| DynamicResource   | 使用推迟资源绑定到属性，该资源的查找行为类似于运行时查找。 |

在 AboutPage 中已经使用过 `BindingContext` 属性进行数据绑定的方法，但 Xamarin MVVM 数据绑定不仅局限这里用到的几种途径。

在 XAML 中定义数据绑定时，有多种方式设置 BindingContext 目标对象的。 有时，从代码隐藏文件，有时使用 StaticResource 或 x:Static 标记扩展设置，有时是 BindingContext 属性元素标记的内容。

绑定视图模型中的标题数据到 xaml 视图就最简单的一种用法 `{Binding Title}`：

<!-- ```xml -->
	<ContentPage.ToolbarItems>
		<ToolbarItem Text="Add" Clicked="AddItem_Clicked" />
	</ContentPage.ToolbarItems>
	<Label Text="{Binding Title}" />
<!-- ``` -->

代码片断中，还设置页面的 ToolbarItems 属性，在标题栏上设置了一个 Add 按钮，用来添加数据条目。点击这个按钮就会执行页面导航，显示 NewItemPage 页面，并且以模态页面的方式呈现：

	await Navigation.PushModalAsync(new NavigationPage(new NewItemPage()));

模态页面和 MainPage 中的导航方式是显示的页面差别在于，模态页面没有后退功能，需要开发者提供模态页面的退出操作 UI 组件。

点击数据列表条目时，触发 CollectionView 列表下的 ItemSelected 事件，通过 StackLayout 堆叠布局组件下放置的 TapGestureRecognizer 组件设置，它可以识别屏幕上的触碰事件。事件触发的主体是 StackLayout，而绑定数据的主体是 CollectionView，这个列表组件会将每个数据条目绑定到 StackLayout 的 BindingContext 属性上，事件处理器中通过它来获取绑定的数据。再通过 ItemDetailPage 的构造函数传递到新的页面上显示出来：

<!-- ```C# -->
	async void OnItemSelected(object sender, EventArgs args)
	{
		var layout = (BindableObject)sender;
		var item = (Item)layout.BindingContext;
		await Navigation.PushAsync(new ItemDetailPage(new ItemDetailViewModel(item)));
	}
<!-- ``` -->

剩下 ItemDetailPage 和 NewItemPage 的页面逻辑就较简单多了，加载绑定的数据到视图中，用到的知识就是通过设置页面的 ToolbarItems 属性，在标题栏上添加页面按钮。其中创建数据条目的页面，还使用 MessagingCenter 和 ItemsViewModel 进行通信，以传送新数据到后端服务器，前面讲数据服务接口已经细说过。

ItemsPage.axml：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.Views.ItemsPage"
				 Title="{Binding Title}"
				 x:Name="BrowseItemsPage">

		<ContentPage.ToolbarItems>
			<ToolbarItem Text="Add" Clicked="AddItem_Clicked" />
		</ContentPage.ToolbarItems>
		<Label Text="{Binding Title}" />

		<RefreshView IsRefreshing="{Binding IsBusy, Mode=TwoWay}" Command="{Binding LoadItemsCommand}">
			<CollectionView x:Name="ItemsCollectionView"
					ItemsSource="{Binding Items}">
				<d:CollectionView.ItemsSource>
					<x:Array Type="{x:Type x:String}">
						<x:String>First Item.</x:String>
						<x:String>Second Item.</x:String>
						<x:String>Third Item.</x:String>
						<x:String>Fourth Item.</x:String>
						<x:String>Fifth Item.</x:String>
						<x:String>Sixth Item.</x:String>
					</x:Array>
				</d:CollectionView.ItemsSource>
				<CollectionView.ItemTemplate>
					<DataTemplate>
						<StackLayout Padding="10">
							<Label Text="{Binding Text}" 
									d:Text="{Binding .}"
									LineBreakMode="NoWrap" 
									Style="{DynamicResource ListItemTextStyle}" 
									FontSize="16" />
							<Label Text="{Binding Description}" 
									d:Text="Item descripton"
									LineBreakMode="NoWrap"
									Style="{DynamicResource ListItemDetailTextStyle}"
									FontSize="13" />
							<StackLayout.GestureRecognizers>
								<TapGestureRecognizer NumberOfTapsRequired="1" Tapped="OnItemSelected"></TapGestureRecognizer>
							</StackLayout.GestureRecognizers>
						</StackLayout>
					</DataTemplate>
				</CollectionView.ItemTemplate>
			</CollectionView>
		</RefreshView>
	</ContentPage>
<!-- ``` -->

ItemsPage.axml.cs：

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Linq;
	using System.Text;
	using System.Threading.Tasks;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;

	using XamarinVS2019.Models;
	using XamarinVS2019.Views;
	using XamarinVS2019.ViewModels;

	namespace XamarinVS2019.Views
	{
		[DesignTimeVisible(false)]
		public partial class ItemsPage : ContentPage
		{
			ItemsViewModel viewModel;

			public ItemsPage()
			{
				InitializeComponent();

				BindingContext = viewModel = new ItemsViewModel();
			}

			async void OnItemSelected(object sender, EventArgs args)
			{
				var layout = (BindableObject)sender;
				var item = (Item)layout.BindingContext;
				await Navigation.PushAsync(new ItemDetailPage(new ItemDetailViewModel(item)));
			}

			async void AddItem_Clicked(object sender, EventArgs e)
			{
				await Navigation.PushModalAsync(new NavigationPage(new NewItemPage()));
			}

			protected override void OnAppearing()
			{
				base.OnAppearing();

				if (viewModel.Items.Count == 0)
					viewModel.IsBusy = true;
			}
		}
	}
<!-- ``` -->

NewItemPage.xaml：

<!-- ```xml -->
	<?xml version="1.0" encoding="UTF-8"?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.Views.NewItemPage"
				 Title="New Item">
		
		<ContentPage.ToolbarItems>
			<ToolbarItem Text="Cancel" Clicked="Cancel_Clicked" />
			<ToolbarItem Text="Save" Clicked="Save_Clicked" />
			<ToolbarItem Text="Send" Clicked="Send_Clicked" />
		</ContentPage.ToolbarItems>
		
		<ContentPage.Content>
			<StackLayout Spacing="20" Padding="15">
				<Label Text="Text" FontSize="Medium" />
				<Entry Text="{Binding Item.Text}" d:Text="Item name" FontSize="Small" />
				<Label Text="Description" FontSize="Medium" />
				<Editor Text="{Binding Item.Description}" d:Text="Item description" FontSize="Small" Margin="0" />
			</StackLayout>
		</ContentPage.Content>
		
	</ContentPage>
<!-- ``` -->

NewItemPage.xaml.cs：

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;

	using XamarinVS2019.Models;

	namespace XamarinVS2019.Views
	{
		public partial class NewItemPage : ContentPage
		{
			public Item Item { get; set; }

			public NewItemPage()
			{
				InitializeComponent();

				Item = new Item
				{
					Text = "Item name",
					Description = "This is an item description."
				};

				MessagingCenter.Subscribe<string, DateTime>(this, "TryExit", async (sender, args) =>
				{
					Console.WriteLine($"sender {sender} args {args}");
					await Navigation.PopModalAsync();
				});

				BindingContext = this;
			}

			void Send_Clicked(object sender, EventArgs e)
			{
				MessagingCenter.Send("DateTime", "TryExit", DateTime.Now);
			}

			async void Save_Clicked(object sender, EventArgs e)
			{
				MessagingCenter.Send(this, "AddItem", Item);
				await Navigation.PopModalAsync();
			}

			async void Cancel_Clicked(object sender, EventArgs e)
			{
				await Navigation.PopModalAsync();
			}
		}
	}
<!-- ``` -->


ItemDetailPage.xaml：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
				 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
				 xmlns:d="http://xamarin.com/schemas/2014/forms/design"
				 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				 mc:Ignorable="d"
				 x:Class="XamarinVS2019.Views.ItemDetailPage"
				 Title="{Binding Title}">

		<StackLayout Spacing="20" Padding="15">
			<Label Text="Text:" FontSize="Medium" />
			<Label Text="{Binding Item.Text}" d:Text="Item name" FontSize="Small"/>
			<Label Text="Description:" FontSize="Medium" />
			<Label Text="{Binding Item.Description}" d:Text="Item description" FontSize="Small"/>
		</StackLayout>
		
	</ContentPage>
<!-- ``` -->


ItemDetailPage.xaml.cs：

<!-- ```C# -->
	using System;
	using System.ComponentModel;
	using Xamarin.Forms;
	using Xamarin.Forms.Xaml;

	using XamarinVS2019.Models;
	using XamarinVS2019.ViewModels;

	namespace XamarinVS2019.Views
	{
		public partial class ItemDetailPage : ContentPage
		{
			ItemDetailViewModel viewModel;

			public ItemDetailPage(ItemDetailViewModel viewModel)
			{
				InitializeComponent();

				BindingContext = this.viewModel = viewModel;
			}

			public ItemDetailPage()
			{
				InitializeComponent();

				var item = new Item
				{
					Text = "Item 1",
					Description = "This is an item description."
				};

				viewModel = new ItemDetailViewModel(item);
				BindingContext = viewModel;
			}
		}
	}
<!-- ``` -->




### AssemblyInfo.cs

程序集特性 [assembly] 不限于在 AssemblyInfo.cs 文件中使用，而是可以在任何的 .cs 文件中使用。 AssemblyInfo.cs 文件一般由系统自动处理。

```C#
	//------------------------------------------------------------------------------
	// <auto-generated>
	//     This code was generated by a tool.
	//
	//     Changes to this file may cause incorrect behavior and will be lost if
	//     the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	using System;
	using System.Reflection;

	[assembly: System.Reflection.AssemblyCompanyAttribute("WebApp")]
	[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
	[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
	[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
	[assembly: System.Reflection.AssemblyProductAttribute("WebApp")]
	[assembly: System.Reflection.AssemblyTitleAttribute("WebApp")]
	[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

	// 由 MSBuild WriteCodeFragment 类生成。
```

程序集的版本信息由下面四个值组成:

- Major Version Number 主版本号
- Minor Version Number 次版本号 
- Build Version Number 内部版本号
- Revision Version Number 修订版本号

可以指定所有这些值，也可以使用内部版本号和修订号的默认值，方法是使用 `*` 替代具体数值:

```C#
	[assembly:AssemblyTitle("程序集标题")]
	[assembly:AssemblyDescription("程序集描述")]
	[assembly:AssemblyProduct("产品名称")]
	[assembly:AssemblyCompany("公司名称")]
	[assembly:AssemblyTrademark("合法商标")]
	[assembly:AssemblyCulture("区域性")]
	[assembly:AssemblyCopyright("Copyright 2014")]

	// 配置文件，如零售、发布、调试等信息。程序集在运行时不会使用该信息
	[assembly:AssemblyConfiguration("")]
	[assembly:AssemblyVersion("1.0.*.0")]

	// 控制程序集中所有类型对COM的可访问性
	[assembly:ComVisible(false)]
	// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
	[assembly: Guid("77bf07c6-941f-4ba7-b95d-6a5c18401f74")]
```

对于同一个特性，程序集中仅能设置一次，否则编译时将报错。

```C#
	[assembly:AssemblyProduct("DemoProduct")]
	namespace Company.App {
	  public class Demo{
	  }
	}
```

要读取程序集的信息，通过反射技术实现：

```C#
	// Type t = obj.GetType();
	Type t = typeof(Program);
	AssemblyProductAttribute pd = t.Assembly.GetCustomAttributes(
		typeof(AssemblyProductAttribute), true)[0] as AssemblyProductAttribute;
	Console.WriteLine(pd.Product);
```



## self signed certificates
https://stackoverflow.com/questions/36393717/android-xamarin-c-https-with-servicestack-and-self-signed-certificates
ServicePointManager.ServerCertificateValidationCallback https://www.it1352.com/19268.html
https://docs.microsoft.com/zh-cn/dotnet/api/system.net.servicepointmanager?redirectedfrom=MSDN&view=netframework-4.7.2
https://docs.microsoft.com/zh-cn/dotnet/api/system.net.servicepoint?view=netframework-4.7.2

ServicePointManager 是一个静态类，用来创建、维护和删除 ServicePoint 类的实例。

当应用程序通过 ServicePointManager 对象请求与 Internet 资源统一资源标识符（URI）的连接时，ServicePointManager 将返回一个 ServicePoint 对象，其中包含由 URI 标识的主机和方案的连接信息。 如果该主机和方案存在现有 ServicePoint 对象，则 ServicePointManager 对象返回现有 ServicePoint 对象;否则，ServicePointManager 对象会创建一个新的 ServicePoint 对象。

4.6 .NET Framework 包括一项新的安全功能，用于阻止连接的不安全密码和哈希算法。 默认情况下，通过 Api （例如 HttpClient、HttpWebRequest、FtpWebRequest、SmtpClient、4.6 SslStream等）使用 TLS/SSL 的应用程序将获得更安全的行为。

开发人员可能需要选择退出此行为，以便与现有的 SSL3 服务或具有 RC4 服务的 TLS 保持互操作性。 本文介绍如何修改代码，以便禁用新行为。

下面的代码示例创建 ServicePoint 对象以连接到 URI www.contoso.com。

	Uri myUri = new Uri("http://www.contoso.com/");
	ServicePoint mySP = ServicePointManager.FindServicePoint(myUri);

ServicePoint 类提供 HTTP 连接的连接管理，根据在资源的统一资源标识符（URI）中传递的主机信息来处理与 Internet 资源的连接。 与资源的初始连接将确定 ServicePoint 对象维护的信息，该信息随后由对该资源的所有后续请求共享。

ServicePoint 对象由 ServicePointManager 类管理，不直接创建 ServicePoint 对象始终由 ServicePointManager 类创建和管理，根据需要由 FindServicePoint 方法创建。  MaxServicePoints 属性设置可以创建的最大数量。

每个 ServicePoint 对象保持与 Internet 资源的连接，直到其空闲时间超过 MaxIdleTime 属性中指定的时间。 当 ServicePoint 超出 MaxIdleTime 值时，可以将其回收到其他连接。 MaxIdleTime 的默认值由 ServicePointManager.MaxServicePointIdleTime 属性设置。

如果将 ConnectionLeaseTimeout 属性设置为-1 以外的值，并且在指定的时间过后，则会在服务下一个请求后关闭活动的 ServicePoint 连接。 这对于不需要无限期打开的活动连接的应用程序非常有用，因为这些应用程序默认为。


<!-- ```C# -->
	byte[] certificate;
	using (var streamReader = new StreamReader(Assets.Open("ScoutTestCert.crt")))
	{
		using (var byteStream = new MemoryStream())
		{
			streamReader.BaseStream.CopyTo(byteStream);
			certificate = byteStream.ToArray();
		}
	}

	var installCertificate = KeyChain.CreateInstallIntent();
	installCertificate.PutExtra(KeyChain.ExtraCertificate, certificate);
	StartActivity(installCertificate);
<!-- ``` -->

ServiceStack's .NET Service Clients uses .NET's BCL's built-in HttpWebRequest in order to have the self-signed certificates work with .NET HTTP Clients you need to register a custom Certificate Validation Callback, e.g. the callback below would enable all certificates to succeed:

ServicePointManager.ServerCertificateValidationCallback += 
	(sender, certificate, chain, sslPolicyErrors) => true;
But you would want to limit the validation down to work with your self-signed certificate.

An alternative to using ServiceStack's HttpWebRequest based Service Client is to use the PCL HttpClient-based JsonHttpClient instead which has the benefit where it can be configured to use ModernHttpClient with:

JsonHttpClient.GlobalHttpMessageHandlerFactory = () => 
	new NativeMessageHandler()
Which instead of using the .NET HTTP Client stack uses the native HTTP libraries available on the underlying iOS and Android platforms. This should then let you use any certificates registered with Android.

In order to use untrusted self-signed certificates registered in .NET with ModernHttpClient you would need to use the pro version of ModernHttpClient as mentioned on this thread.

Android Xamarin C#: Https with ServiceStack and self signed certificates

<!-- ```C# -->
	var clientCertificate = new X509Certificate2(data, pwd);
	var result = await ExecuteRequest("https://server/user.aspx", clientCertificate);

	public static async Task<string> ExecuteRequest(Uri uri, X509Certificate2 clientCertificate)
	{
		var hwr = (HttpWebRequest)HttpWebRequest.Create(uri);
		if (clientCertificate != null)
		{
			hwr.ClientCertificates.Add(clientCertificate);
		}
		hwr.Method = "GET";
		try
		{
			var resWebResonse = await hwr.GetResponseAsync();
			var stream = resWebResonse.GetResponseStream(); 
			var sr = new StreamReader (stream);   
			return sr.ReadToEnd();
		}
		catch (Exception ex)
		{
			Debug.WriteLine($"Error executing Webrequest to {uri}: {ex}");
		}
		return null;
	}
<!-- ``` -->

服务器：user.aspx

<!-- ```C# -->
	<%@ Page Language="C#" %>
	<%@ Import Namespace="System.Security.Cryptography.X509Certificates" %>
	<%@ Import Namespace="System.Security.Principal" %>
	<script runat="server">

			public void Page_Load(object sender, EventArgs e)
			{
				try
				{
					Regex userRegEx = new Regex("CN=(.*)@", RegexOptions.IgnoreCase | RegexOptions.Compiled);
					if (Request.ClientCertificate.IsPresent)
					{
						var cert = new X509Certificate2(Request.ClientCertificate.Certificate);
						var identity = new GenericIdentity(cert.Subject, "ClientCertificate");
						var principal = new GenericPrincipal(identity, null);
						var m = userRegEx.Match (principal.Identity.Name);
						Response.Write (m.Groups[1].Value);
					}
					else
						Response.Write("No Client-Certificate");
					Response.End();
				}
				catch (Exception ex)
				{
					if (!(ex is System.Threading.ThreadAbortException))
						Response.Write(ex.ToString());
				}
			}    
	</script>
<!-- ``` -->




## Touch & Low Layer
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/graphics/skiasharp/
- https://github.com/xamarin/xamarin-forms-samples/tree/master/SkiaSharpForms/Demos/Demos/

参考 SkiaSharpForm 示例代码，里面有几个关于平台底层触摸事件的处理代类：

- Demos/SkiaSharpFormsDemos.Droid/TouchEffect.cs
- Demos/SkiaSharpFormsDemos.UWP/TouchEffect.cs
- Demos/SkiaSharpFormsDemos.iOS/TouchEffect.cs
- Demos/SkiaSharpFormsDemos/TouchEffect.cs
- Demos/SkiaSharpFormsDemos/TouchActionEventArgs.cs
- Demos/SkiaSharpFormsDemos/TouchActionEventHandler.cs



Xamarin 可以开发用于不同移动操作系统的移动应用程序，但是它不具备任何触摸屏设备所需的基本功能，并不能执行不同的触摸手势。触摸手势识别也没有触点坐标数据，平移手势动作也不流畅，感觉效果是烂的！

由于触摸功能缺失，第三方的 MR.Gestures 得以做成收费的功能模块，它处理 Xamarin.Forms 移动应用中的所有触摸手势，MR 手势在页面上添加低，高，轻敲，双击，长按，慢跑，旋转等事件。

底层扩展：

	using Android.Views;
	using System;

	namespace SimpleCustomGesureFrame.Android
	{
		public class CustomGestureListener : GestureDetector.SimpleOnGestureListener
		{
			private static int SWIPE_THRESHOLD = 100;
			private static int SWIPE_VELOCITY_THRESHOLD = 100;

			public event EventHandler OnSwipeDown;
			public event EventHandler OnSwipeTop;
			public event EventHandler OnSwipeLeft;
			public event EventHandler OnSwipeRight;

			public override bool OnFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)
			{
				Console.WriteLine ("OnFling");

				float diffY = e2.GetY() - e1.GetY();
				float diffX = e2.GetX() - e1.GetX();

				if (Math.Abs(diffX) > Math.Abs(diffY))
				{
					if (Math.Abs(diffX) > SWIPE_THRESHOLD && Math.Abs(velocityX) > SWIPE_VELOCITY_THRESHOLD)
					{
						if (diffX > 0)
						{
							if (OnSwipeRight != null)
								OnSwipeRight(this, null);
						}
						else
						{
							if (OnSwipeLeft != null)
								OnSwipeLeft(this, null);
						}
					}
				}
				else if (Math.Abs(diffY) > SWIPE_THRESHOLD && Math.Abs(velocityY) > SWIPE_VELOCITY_THRESHOLD)
				{
					if (diffY > 0)
					{
						if (OnSwipeDown != null)
							OnSwipeDown(this, null);
					}
					else
					{
						if (OnSwipeTop != null)
							OnSwipeTop(this, null);
					}
				}
				return base.OnFling (e1, e2, velocityX, velocityY);
			}
		}
	}


## GestureRecognizer 手势 
- https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.gesturerecognizer
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/gestures/
- https://docs.microsoft.com/en-us/dotnet/api/android.views.gesturedetector.simpleongesturelistener
- https://www.icode9.com/content-4-504532.html
- https://forums.xamarin.com/discussion/17767/touch-coordinates-in-tapgesturerecognizer
- https://github.com/MichaelRumpler/GestureSample
- https://www.mrgestures.com/
- https://www.cnblogs.com/IWings/p/9300172.html


Xamarin.Forms GestureRecognizer 类支持在 View 实例上使用点击、收缩、平移和轻扫手势。


所有继承 View 的视图组件都提供了 GestureRecognizers 集合属性，来添加任意个手势识别组件来与用户进行交互。

Xamarin.Forms 提供四个手势识别组件：

- ClickGestureRecognizer

	触发 `Clicked` 事件，使用 EventHandler 事件委托；

- PanGestureRecognizer

	平移手势，手指在屏幕上的移动触发 `PanUpdated` 事件，使用 EventHandler<PanUpdatedEventArgs> 事件委托；
	`PanUpdatedEventArgs` 参数提供 GestureId，StatusType 为 GestureStatus 类型。TotalX 和 TotalY 表示移动的坐标差值，XY 坐标往右下角为正，左上角为负。

	TouchPoints 获取或设置手势中的触摸点数，默认是一个，整形数值。

- PinchGestureRecognizer

	双手指捏屏幕区域触发 `PinchUpdated` 事件，使用 EventHandler<PinchGestureUpdatedEventArgs> 事件委托；
	`PinchGestureUpdatedEventArgs` 参数提供 Scale 绽放值以 1 为初始值，ScaleOrigin 为初始点坐标，Status 提供状态，GestureStatus 类型。可以结合用户元素的 TranslationX、TranslationY 和 Scale 属性产生响应效果。

- SwipeGestureRecognizer

	手指划过屏幕触发 `Swiped` 事件，使用 EventHandler<SwipedEventArgs> 事件委托；
	`SwipedEventArgs` 参数提供 SwipeDirection 枚举类型的 Direction 参数，还有 Object 类型的 Parameter 参数，创建时注意在 Direction 属性上设置识别方向，否则不进行手势识别。


	每个 Swipe 手势组件指定一个识别方向或同一轴向，可以添加多个组件处理多方向滑动，也可以通过将 Direction 属性设置为 Up 和 Down 来识别垂直轴上的轻扫手势。其只有默认构造函数，创建实例后可以设置 Direction 属性，也可以通过匿名对象的方式构建对象：

		<SwipeGestureRecognizer Direction="Left,Right" Swiped="OnSwiped"/>

		var swipeGesture = new SwipeGestureRecognizer { Direction = SwipeDirection.Up | SwipeDirection.Down };

- TapGestureRecognizer

	触碰，触发 `Tapped` 事件，使用 EventHandler 事件委托；
	NumberOfTapsRequired 指定触碰次数，指定 2 表示双击事件，达到就触发 TappedCallback 回调。


Grid 组件下设置 SwipeGesture 和 ScrollView，ScrollView 滑动工作正常，但是 SwipeGesture 仅在 iOS 上工作，Android 下有问题。Android.Views.GestureDetector 及其子类 GestureDetector.SimpleOnGestureListener 可以提供更底层的定制，OnFling 事件提供了手指在两次移动产生的数据：


手势使用到的状态枚举类型如下。

SwipeDirection 枚举值：

| 状态		| 值	| 意义	|
| :-------- | :-------- | :-------- |
| Down		| 8	| 指示向下滑动 |
| Left		| 2	| 指示向左滑动 |
| Right		| 1	| 指示向右滑动 |
| Up		| 4	| 指示向上滑动 |

GestureStatus 枚举值：

| 状态		| 值	| 意义	|
| :-------- | :-------- | :-------- |
| Canceled	| 3	| 手势取消 |
| Completed	| 2	| 手势完成 |
| Running	| 1	| 手势持续 |
| Started	| 0	| 手势开始 |

SwipeDirection 枚举：

| 方向		| 值	| 意义	|
| :-------- | :-------- | :-------- |
| Down	| 8	| 指示向下轻扫。 |
| Left	| 2	| 指示向左轻扫。 |
| Right	| 1	| 指示右移轻扫。 |
| Up	| 4	| 指示向上轻扫。 |


使用示例，通过向 View 视图组件的 GestureRecognizers 属性添加手势识别组件：


    public event EventHandler Tapped;
    public event EventHandler<SwipedEventArgs> Swiped;
    public event EventHandler<PinchGestureUpdatedEventArgs> PinchUpdated;

	var panGesture = new PanGestureRecognizer();
	panGesture.PanUpdated += (s, e) => {
	  // Handle the pan
	};
	GestureRecognizers.Add(panGesture);

    var swipeGesture = new SwipeGestureRecognizer{ Direction = SwipeDirection.Left | SwipeDirection.Right};
    swipeGesture.Swiped += (sender, args) =>
    {
        Swiped?.Invoke(this, args);
    };
    GestureRecognizers.Add(swipeGesture);

    PinchGestureRecognizer pinchGesture = new PinchGestureRecognizer();
    pinchGesture.PinchUpdated += (sender, args) =>
    {
        PinchUpdated?.Invoke(this, args);
    };
    GestureRecognizers.Add(pinchGesture);

    TapGestureRecognizer tapGesture = new TapGestureRecognizer();
    tapGesture.Tapped += (sender, args) =>
    {
        Tapped?.Invoke(this, EventArgs.Empty);
    };
    GestureRecognizers.Add(tapGesture);


或者 XAML 中使用标签定义：

    <Label Text="https://en.wikipedia.org/wiki/Conway's_Game_of_Life"
           TextColor="Blue"
           FontAttributes="Italic"
           HorizontalTextAlignment="Center">
        <Label.GestureRecognizers>
             <TapGestureRecognizer NumberOfTapsRequired="2" Tapped="OnHyperlinkTapped" /> 
        </Label.GestureRecognizers>
    </Label>

    <AbsoluteLayout x:Name="absoluteLayout"
                    BackgroundColor="Gray"
                    SizeChanged="OnLayoutSizeChanged" >
        <AbsoluteLayout.GestureRecognizers>
            <SwipeGestureRecognizer Swiped="OnSwiped" />
        </AbsoluteLayout.GestureRecognizers>
    </AbsoluteLayout>

	<BoxView Color="Teal" ...>
	    <BoxView.GestureRecognizers>
	        <SwipeGestureRecognizer Direction="Left" Swiped="OnSwiped"/>
	    </BoxView.GestureRecognizers>
	</BoxView>

	<Image Source="MonoMonkey.jpg">
	  <Image.GestureRecognizers>
	    <PanGestureRecognizer PanUpdated="OnPanUpdated" />
	  </Image.GestureRecognizers>
	</Image>

	void OnPanUpdated (object sender, PanUpdatedEventArgs e)
	{
	  // Handle the pan
	}


结合 Command 方式使用：

	<Image Source="tapped.jpg">
	    <Image.GestureRecognizers>
	        <TapGestureRecognizer
	            Command="{Binding TapCommand}"
	            CommandParameter="Image1" />
	    </Image.GestureRecognizers>
	</Image>

	public class TapViewModel : INotifyPropertyChanged
	{
	    int taps = 0;
	    ICommand tapCommand;
	    public TapViewModel () {
	        // configure the TapCommand with a method
	        tapCommand = new Command (OnTapped);
	    }
	    public ICommand TapCommand {
	        get { return tapCommand; }
	    }
	    void OnTapped (object s)  {
	        taps++;
	        Debug.WriteLine ("parameter: " + s);
	    }
	    //region INotifyPropertyChanged code omitted
	}




## Xamarin.Forms Layout 布局
https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/layouts/



### StackLayout

StackLayout 维堆栈中的元素是水平或垂直的，Orientation 属性指定元素的方向，默认方向为 Vertical 。 StackLayout 通常用于在页面上排列 UI 的子节。

下面的 XAML 演示如何创建 StackLayout 包含三个对象的垂直 Label ：

	<StackLayout Margin="20,35,20,25">
		<Label Text="The StackLayout has its Margin property set, to control the rendering position of the StackLayout." />
		<Label Text="The Padding property can be set to specify the distance between the StackLayout and its children." />
		<Label Text="The Spacing property can be set to specify the distance between views in the StackLayout." />
	</StackLayout>

在中 StackLayout ，如果未显式设置元素的大小，则它将展开以填充可用宽度或高度（如果 Orientation 属性设置为） Horizontal 。

StackLayout 通常用作父布局，其中包含其他子布局。 但是，StackLayout 不应模拟 Grid 对象组合来重现网格布局，这比较浪费，因为会执行不需要的布局计算。 相反，网格布局可以使用更好实现 Grid 布局。 

StackLayout 可以通过 Spacing/ Margin 属性设置子视图之间的间距和边距。 

布局中的子视图大小和位置取决于 HeightRequest 属性以及 WidthRequest， HorizontalOptions 和 VerticalOptions 的设置，布局对齐方式有 Start/ Center/ End/ Fill，或带扩展的  StartAndExpand/ CenterAndExpand/ EndAndExpand/ FillAndExpand。


### Grid Layout


Grid 用于显示行和列中的元素，这些元素的大小可以是比例的也可以是绝对的。 网格的行和列使用 RowDefinitions 和 ColumnDefinitions 属性指定。

若要定位特定 Grid 单元中的元素，请使用 Grid.Column 和 Grid.Row 附加属性。 若要使元素跨多个行和列，请使用 Grid.RowSpan 和 Grid.ColumnSpan 附加属性。

Grid 布局不应与表混淆，并且不会显示表格数据。 与 HTML 表不同，用于 Grid 布局内容。 若要显示表格数据，请考虑使用 ListView、 CollectionView 或 TableView。

下面的 XAML 演示如何创建 Grid 包含两个行和两个列的：

<!-- ```xml -->
	<Grid>
		<Grid.RowDefinitions>
			<RowDefinition Height="50" />
			<RowDefinition Height="50" />
		</Grid.RowDefinitions>
		<Grid.ColumnDefinitions>
			<ColumnDefinition Width="Auto" />
			<ColumnDefinition />
		</Grid.ColumnDefinitions>

		<Label Text="Column 0, Row 0"
			   WidthRequest="200" />
		<Label Grid.Column="1"
			   Text="Column 1, Row 0" />
		<Label Grid.Row="1"
			   Text="Column 0, Row 1" />
		<Label Grid.Column="1"
			   Grid.Row="1"
			   Text="Column 1, Row 1" />
	</Grid>
<!-- ``` -->

在此示例中，调整大小的方式如下：

- 每一行都具有与设备无关的 50 单元的显式高度。
- 第一列的宽度设置为 Auto ，因此，其宽度为其子级所需的宽度。 

在这种情况下，指定 200 是与设备无关的单位宽，以容纳第一个的宽度 Label 。

可以通过使用自动调整大小在列或行内分布空间，从而使列和行大小适合其内容。 这可通过将的高度 RowDefinition 或的宽度 ColumnDefinition  设置为来实现 Auto 。 还可以使用比例大小调整，按加权比例在网格行和列之间分配可用空间。 这可在设置值后跟 * 号来实现 。

尝试确保尽可能少的行和列设置为 Auto 大小。 每个自动调整大小的行或列都会导致布局引擎执行额外布局计算。 而是应在可能时使用固定大小的行和列。 另外，还可以设置行和列，使其与枚举值占用比例的空间 GridUnitType.Star 。

Grid 类定义以下属性：

| 属性        | 类型        | 功能        |
| :-------- | :-------- | :-------- |
| Column    | int | 附加属性，用于指示父视图中的列对齐，默认值为 0。 |
| ColumnDefinitions | ColumnDefinitionCollection | 列表， ColumnDefinition 对象定义网格列的宽度。 |
| ColumnSpacing | double | 指示网格列之间的距离。 此属性的默认值为 6 与设备无关的单位。 |
| ColumnSpan    | int   | 附加属性，用于指示视图在父级中跨越的总列数，此属性的默认值为 1。|| Row   | int | 附加属性，用于指示父视图中的行对齐，此属性的默认值为 0。 |
| RowDefinitions    | RowDefinitionCollection | 行表， RowDefintion 对象定义网格行的高度。 |
| RowSpacing    | double | 指示网格行之间的距离。 此属性的默认值为 6 与设备无关的单位。 |
| RowSpan   | int | 它是一个附加属性，指示视图在父级中跨越的总行数，默认值为 1。 |

代码方式使用 Grid 布局：

	Grid grid = new Grid
	{
	    Margin = new Thickness(5)
	};
	grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
	grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Star });

	Grid.SetRow(label, row);
	Grid.SetColumn(label, col);
	grid.Children.Add(label);


### FlexLayout

FlexLayout 类似于 StackLayout 堆栈中水平或垂直显示子元素。 但是， FlexLayout 如果在单个行或列中容纳太多项，还可以转折换行或换列，可以更精细地控制其子元素的大小、方向和对齐方式。

FlexLayout 布局有两条轴线，Direction 指定的方向为主轴，垂直它的为侧轴，也叫交叉轴 Cross Axis。布局分容器和子项，应用不同的属性进行弹性布局。

下面的 XAML 演示如何创建一个 FlexLayout ，它在单个列中显示其视图：

<!-- ```xml -->
	<FlexLayout Direction="Column"
				AlignItems="Center"
				JustifyContent="SpaceEvenly">
		<Label Text="FlexLayout in Action" />
		<Button Text="Button" />
		<Label Text="Another Label" />
	</FlexLayout>
<!-- ``` -->

FlexLayout 布局的工作方式如下：

- Direction 

	属性为 FlexDirection 枚举值，设置主轴方向， Row 为水平方向，Column 为垂直方向。
	- Column 则按列排列。
	- ColumnReverse 列反向排列。
	- Row 默认值，按行排列子级。
	- RowReverse 行反向排列。

- JustifyContent

	属性的类型为 FlexJustify ，其中包含六个成员的枚举：
	- Start 主轴方向起点
	- Center 主轴方向剧中
	- End 主轴方向结束位置
	- SpaceBetween 空间分配到元素之间
	- SpaceAround  空间分配到元素周边
	- SpaceEvenly 将剩余空间均匀分布到子项周边。

- AlignItems 

	属性的类型为 FlexAlignItems 枚举值，指定如何在交叉轴上对齐子项。使用 AlignSelf 绑定属性可覆盖 AlignItems。
	- Stretch 默认值，延申子级
	- Center 居中子级
	- Start 
	- End（或 XAML 中的 "flex end"）

- AlignContent 属性

	类型为 FlexAlignContent 枚举，设置侧轴上的对齐：
	- Stretch 默认值，延申
	- Center 侧轴居中
	- Start 侧轴起点
	- End 侧轴末端
	- SpaceBetween 侧轴空间分配到元素之间
	- SpaceAround 侧轴空间分配到元素周边
	- SpaceEvenly 侧轴空间均匀分配

- Wrap 属性

	FlexWrap ，具有三个成员的枚举：
	- NoWrap（默认值）
	- Wrap 转折换行或换列
	- Reverse 反转换行或换列

弹性布局的子项设置

- AlignSelf 属性

	类型为 FlexAlignSelf，设置子项的主轴对齐。
	- Auto 默认值
	- Stretch 延申
	- Center 居中
	- Start 主轴起点
	- End 主轴尾部

- Basis 属性指示分配给 FlexLayout 主轴上的子级的空间量。

- Grow 

	当 Wrap 属性设置为 NoWrap 并且子级的行的总宽度小于的宽度时，或子级的列的高度小于 FlexLayout 容器空间。 Grow 属性指示如何分配子级之间的遗留空间。 类型为 int 。 默认值为 0，值必须大于或等于0。

- Shrink 可压缩性，1 表示可以压缩

- Order 属性设置子项先后顺序，类型为 int 默认值为 0


### RelativeLayout

RelativeLayout 相对布局或以同级元素的属性来定位元素和调整其大小。 默认情况下，元素位于布局的左上角。 RelativeLayout 可用于创建跨设备大小按比例缩放的 UI。
RelativeLayout 中的位置和大小可以指定约束，使用 ConstraintExpression 约束标记扩展设置约束系数 Factor 和 Constant 常量，常量可以为负数，这些属性用于确定子元素的位置和大小。

RelativeLayout 支持将元素放在其自身的边界之外。

以下 XAML 演示了如何在 RelativeLayout 中设置 HeightConstraint 和 WidthConstraint， XConstraint 和 YConstraint 约束排列元素：

<!-- ```xml -->
	<RelativeLayout>
		<BoxView Color="Blue"
				 HeightRequest="50"
				 WidthRequest="50"
				 RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=0}"
				 RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0}" />
		<BoxView Color="Red"
				 HeightRequest="50"
				 WidthRequest="50"
				 RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=.85}"
				 RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0}" />
		<BoxView x:Name="pole"
				 Color="Gray"
				 WidthRequest="15"
				 RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=.75}"
				 RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=.45}"
				 RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=.25}" />
		<BoxView Color="Green"
				 RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=.10, Constant=10}"
				 RelativeLayout.WidthConstraint="{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=.2, Constant=20}"
				 RelativeLayout.XConstraint="{ConstraintExpression Type=RelativeToView, ElementName=pole, Property=X, Constant=15}"
				 RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToView, ElementName=pole, Property=Y, Constant=0}" />
	</RelativeLayout>
<!-- ``` -->

在此示例中，布局的工作方式如下：

- 向蓝色 BoxView 提供与设备无关的 50x50 单元的显式大小。 它置于布局的左上角，这是默认位置。
- 红色的 BoxView 给定大小为 50x50 与设备无关的单位。 它置于布局的右上角。
- 为灰色 BoxView 指定 15 个与设备无关的单位，并将其 height 设置为其父级高度的 75%。
- 绿色 BoxView 不明确指定大小，其位置设置为相对于指定的 pole 即灰色 BoxView。

尽可能避免使用 RelativeLayout。 它会显著消耗 CPU 时间。


### AbsoluteLayout

AbsoluteLayout 用于使用显式值或相对于布局大小的值对元素进行定位和调整大小。 位置由子级的左上角指定，相对于的左上角 AbsoluteLayout 。

AbsoluteLayout 应只在您可以对子级设置大小或元素的大小不会影响其他子级的位置时使用的特殊用途的布局。 此布局的标准用途是创建覆盖层，其中包含具有其他控件的页面，可能是为了防止用户与页面上的普通控件交互。

HorizontalOptions 和 VerticalOptions 属性对的子级不起作用 AbsoluteLayout 。

AbsoluteLayout.LayoutBounds 属性用于指定元素的水平位置、垂直位置、宽度和高度。 此外， AbsoluteLayout.LayoutFlags 属性指定将如何解释布局边界。

以下 XAML 演示了如何在中排列元素 AbsoluteLayout ：

<!-- ```xml -->
	<AbsoluteLayout Margin="40">
		<BoxView Color="Red"
				 AbsoluteLayout.LayoutFlags="PositionProportional"
				 AbsoluteLayout.LayoutBounds="0.5, 0, 100, 100"
				 Rotation="30" />
		<BoxView Color="Green"
				 AbsoluteLayout.LayoutFlags="PositionProportional"
				 AbsoluteLayout.LayoutBounds="0.5, 0, 100, 100"
				 Rotation="60" />
		<BoxView Color="Blue"
				 AbsoluteLayout.LayoutFlags="PositionProportional"
				 AbsoluteLayout.LayoutBounds="0.5, 0, 100, 100" />
	</AbsoluteLayout>
<!-- ``` -->

在此示例中，布局的工作方式如下：

- 每个 BoxView 都给定显式大小的 100x100，并在水平居中的位置显示在同一位置。
- 红色 BoxView 旋转 30 度，绿色 BoxView 旋转 60 度。
- 在每个上 BoxView 的 LayoutFlags 附加的属性都设置为 PositionProportional 表示位置与宽高比的剩余空间成正比。

请尽可能避免使用 AbsoluteLayout.AutoSize 属性，因为这会导致布局引擎执行更多布局计算。


每个可视元素都有一个输入透明度属性 InputTransparent 用于定义元素是否接收输入，其默认值为 false 元素接收输入。

在布局类上设置此属性时，其值将传递到子元素。 因此 InputTransparent 为 true 将导致布局中的所有元素都不接收输入。


### Others Layout

ContentView 类布局包含一个子元素，通常用于创建自定义的可重用控件，类继承自 TemplatedView 。

ContentView 类定义单个属性 Content，是一个 View 对象。 ControlTemplate 可定义或重写控件外观的，以创建自定义控件。


ScrollView 是能够滚动其内容的布局。 ScrollView 只能有一个子级，可以是其他布局。StackLayout 通常是的子级，ScrollView 高度等于其子级 StackLayout 高度之和。 

ScrollView 对象不应嵌套其它可供滚动的控件，例如 CollectionView 、 ListView 和 WebView 。

ScrollView 定义以下属性：

- Content 类型为 View ，表示要在中显示的内容 ScrollView 。
- ContentSize 类型为的 Size 表示内容的大小。 这是只读属性。
- HorizontalScrollBarVisibility 类型为的 ScrollBarVisibility 表示水平滚动条可见的时间。
- Orientation 类型为 ScrollOrientation 表示的滚动方向 ScrollView 。 此属性的默认值为 Vertical。
- ScrollX 类型为的 double 指示当前 X 滚动位置。 此只读属性，默认值为 0。
- ScrollY 类型为的 double 指示当前的 Y 滚动位置。 此只读属性，默认值为 0。
- VerticalScrollBarVisibility 类型为 ScrollBarVisibility 表示垂直滚动条可见。

这些属性是 BindableProperty ，但 Content 属性除外，这意味着它们可 以是数据绑定的目标和样式。

Frame 类是一种布局包装视图，用于配置颜色、阴影和其他选项的边框。 通常用于在控件周围创建边框，但可用于创建更复杂的 UI。

Frame类定义以下属性：

- BorderColorColor 确定边框颜色的值 Frame 。
- CornerRadiusfloat 确定角的圆角半径的值。
- HasShadowbool 用于确定帧是否有投影的值。

这些属性是 BindableProperty 可以是数据绑定的目标。

<!-- ```xml -->
	<Frame BorderColor="Gray"
		   CornerRadius="5"
		   Padding="8">
	  <StackLayout>
		<Label Text="Card Example"
			   FontSize="Medium"
			   FontAttributes="Bold" />
		<BoxView Color="Gray"
				 HeightRequest="2"
				 HorizontalOptions="Fill" />
		<Label Text="Frames can wrap more complex layouts to create more complex UI components, such as this card!"/>
	  </StackLayout>
	</Frame>
<!-- ``` -->

还可以在代码中创建卡片：

<!-- ```C# -->
	Frame cardFrame = new Frame
	{
		BorderColor = Color.Gray,
		CornerRadius = 5,
		Padding = 8,
		Content = new StackLayout
		{
			Children =
			{
				new Label
				{
					Text = "Card Example",
					FontSize = Device.GetNamedSize(NamedSize.Medium, typeof(Label)),
					FontAttributes = FontAttributes.Bold
				},
				new BoxView
				{
					Color = Color.Gray,
					HeightRequest = 2,
					HorizontalOptions = LayoutOptions.Fill
				},
				new Label
				{
					Text = "Frames can wrap more complex layouts to create more complex UI components, such as this card!"
				}
			}
		}
	};
<!-- ``` -->


## Application 程序对象
- [Application Class](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/application-class)

Application 基类提供以下功能，这些功能在项目的默认 App 子类中公开：

- `MainPage` 属性，可在其中设置应用的初始页面。
- 持久 Properties 字典，用于跨生命周期状态更改存储简单值。
- 静态 Current 属性，其中包含对当前应用程序对象的引用。
- 三个生命周期方法

	- `OnStart` - 在启动应用程序时调用它。
	- `OnSleep` - 每当应用程序转入后台时调用它。
	- `OnResume` - 应用程序发送到后台后恢复时调用。

	没有终止应用程序的方法。 在正常情况下（即不崩溃），应用程序终止将从 OnSleep 状态发生，并且没有对代码的其他任何通知。
	
	在 Android 上，若主活动的 [Activity()] 属性缺少 ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation，旋转时及首次启动应用程序时，将调用 OnStart 方法。

- 两个页面导航事件：

	- `PageAppearing` - 页面即将在屏幕上显示时引发。
	- `PageDisappearing` - 页面即将从屏幕上消失时引发。

- 有四个模态导航事件

	每个都有其自己的参数，ModalPopping 事件的 `ModalPoppingEventArgs` 类型参数包含 Cancel 属性，设置为 true，取消弹出页面动作。

	- `ModalPushing` - 按模式推送页面时将引发它。
	- `ModalPushed` - 按模式推送页面后将引发它。
	- `ModalPopping` - 按模式弹出页面时将引发它。
	- `ModalPopped` - 按模式弹出页面后将引发它。


Application 静态字典 Properties 可用于存储数据，特别是用于生命周期 OnStart、OnSleep 和 OnResume 方法。 可以使用 Application.Current.Properties 从 Xamarin.Forms 代码中的任何位置对此进行访问。

Properties 字典使用 string 主键存储 object 值，如下所示：

	Application.Current.Properties ["id"] = someClass.ID;

Properties 字典会自动保存到设备中。 当应用程序从后台返回，甚或在其重启后，添加到字典中的数据保持可用。

Xamarin.Forms 1.4 在 Application 类上引入了其他方法，如 SavePropertiesAsync()，可调用该方法来主动保存 Properties 字典。 这是为了让用户能够在重要更新后保存属性，而不用冒因崩溃或被 OS 终止而无法将这些属性序列化的风险。


根据选择的模板，可以通过 C# 或 XAML 两种方式之一定义 App 类。若要使用 XAML 创建 App 类，必须使用 XAML App 类和关联的代码换默认的 App 类。

如以下代码示例所示  App.xaml：

	<Application xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             x:Class="Photos.App">

	</Application>

以下代码示例展示了关联的 Code-Behind 代码 App.xaml.cs：

	public partial class App : Application
	{
	    public App ()
	    {
	        InitializeComponent ();
	        MainPage = new HomePage ();
	    }
	    ...
	}

除了设置 MainPage 属性外，代码隐藏还必须调用 InitializeComponent 方法来加载和分析相关的 XAML。

Application 类上的 MainPage 属性可设置应用程序的根页面。应在 App 构造函数中设置 MainPage 属性。 例如，可在 App 类中创建逻辑，以便根据用户的登录状态来显示不同的页面。

完整的 Application 类实现如下所示，以供参考：

	public class App : Xamarin.Forms.Application
	{
	    public App ()
	    {
	        MainPage = new ContentPage { Title = "App Lifecycle Sample" }; // your page here
	    }

	    protected override void OnStart()
	    {
	        // Handle when your app starts
	        Debug.WriteLine ("OnStart");
	    }

	    protected override void OnSleep()
	    {
	        // Handle when your app sleeps
	        Debug.WriteLine ("OnSleep");
	    }

	    protected override void OnResume()
	    {
	        // Handle when your app resumes
	        Debug.WriteLine ("OnResume");
	    }
	}

此类随后在每个特定于平台的项目中实例化并传递到 LoadApplication 方法，该方法可供加载 MainPage 并向用户显示。 

以下各部分展示了每个平台的代码。 最新的 XXamarin.Forms 解决方案模板已包含所有这些为应用预先配置的代码。

- Xamarin.Android

	Android MainActivity 继承自 FormsAppCompatActivity。 在 OnCreate 重写方法中，调用 LoadApplication 方法传入 App 类的实例。

		[Activity (Label = "App Lifecycle Sample", Icon = "@drawable/icon", Theme = "@style/MainTheme", MainLauncher = true,
		    ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)]
		public class MainActivity : FormsAppCompatActivity
		{
		    protected override void OnCreate (Bundle bundle)
		    {
		        base.OnCreate (bundle);

		        global::Xamarin.Forms.Forms.Init (this, bundle);

		        LoadApplication (new App ()); // method is new in 1.3
		    }
		}

- Xamarin.iOS

	iOS AppDelegate 类继承自 FormsApplicationDelegate。 它应该：

	- 使用 App 类的实例调用 LoadApplication。
	- 始终返回 base.FinishedLaunching(app, options);

		[Register ("AppDelegate")]
		public partial class AppDelegate :
		    global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate // superclass new in 1.3
		{
		    public override bool FinishedLaunching (UIApplication app, NSDictionary options)
		    {
		        global::Xamarin.Forms.Forms.Init ();

		        LoadApplication (new App ());  // method is new in 1.3

		        return base.FinishedLaunching (app, options);
		    }
		}

- Xamarin.UWP

	适用于 Windows 10 的 UWP 项目中的主页应继承自 WindowsPage：

		<forms:WindowsPage
		   ...
		   xmlns:forms="using:Xamarin.Forms.Platform.UWP"
		   ...>
		</forms:WindowsPage>

	C# 代码中构造函数必须调用 LoadApplication 来创建 Xamarin.Forms App 的实例。 请注意，最好显式使用应用程序命名空间来限定 App，因为 UWP 应用程序还有自己的 App 类。

		public sealed partial class MainPage
		{
		    public MainPage()
		    {
		        InitializeComponent();

		        LoadApplication(new YOUR_NAMESPACE.App());
		    }
		 }

	请注意，必须从 UWP 项目中的 App.xaml.cs 调用 Forms.Init()。



## File Sytem
- https://docs.microsoft.com/zh-cn/xamarin/ios/app-fundamentals/file-system	

## MessagingCenter
－ https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/messaging-center


## Device 设备对象
- https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.device?view=xamarin-forms
- [Xamarin.Forms Device类介绍](https://www.jianshu.com/p/7804e6cec595)

提供一个 OS 属性，返回目前运行的平台枚举值。最新的 API 提供 RuntimePlatform 属性获取运行平台的字符串：

TargetPlatform 枚举值：

| 字段		| 值	| 意义	|
| :-------- | :-------- | :-------- |
| Android	| 2	| 表示 Xamarin.Forms 运行于 Google Android OS |
| iOS		| 1	| 表示 Xamarin.Forms 运行于 Apple iOS OS |
| Other		| 0	| 表示 Xamarin.Forms 运行于未知平台 (Unused) |
| Windows	| 4	| 表示 Xamarin.forms 运行于 Windows platform |
| WinPhone	| 3	| 表示 Xamarin.Forms 运行于 Microsoft WinPhone OS |

提供各平台字段定义，可以和：

| 字段		| 值	和意义	|
| :-------- | :-------- |
| Android	| 返回 "Android" 表示 Android 系统 |
| GTK	| 返回 "GTK" 表示 Linux 系统 |
| iOS	| 返回 "iOS" 表示 iOS 系统 |
| macOS	| 返回 "macOS" 表示 macOS 系统 |
| Tizen	| 返回 "Tizen" 表示 Tizen 系统 |
| UWP	| 返回 "UWP" 表示 UWP 系统 |
| WPF	| 返回 "WPF" 表示 Windows Presentation Foundation 框架 |


根据不同平台返回值、Action：

	OnPlatform<T>(T, T, T) // iOS, Android, WinPhone
	OnPlatform(Action, Action, Action, Action) // iOS, Android, WinPhone, Default

	button.HeightRequest = Device.OnPlatform (20,30,30);

打开 URL 页面：

	OpenUri(Uri)


设置定时器任务，回调返回 false 停止：

	Device.StartTimer(TimeSpan, Func<Boolean>)


### OnPlatform & OnIdiom 标记扩展


除了条件编译外，可以通过代码判断来决定平台相关的功能：

	if (Device.RuntimePlatform == Device.iOS)
	{
		Padding = new Thickness(0, 20, 0, 0);
	}

对应 XAML 标记扩展代码：

<!-- ```xml -->
	<Label.Padding>
		<OnPlatform x:TypeArguments="Thickness">
			<OnPlatform.Platforms>
				<On Platform="iOS" Value="0, 20, 0, 0" />
				<On Platform="Android" Value="0, 0, 0, 0" />
				<On Platform="UWP" Value="0, 0, 0, 0" />
			</OnPlatform.Platforms>
		</OnPlatform>
	</Label.Padding>
<!-- ``` -->

或者以内嵌标签的吸附属性设置：

<!-- ```xml -->
	<Label.Padding>
		<OnPlatform x:TypeArguments="Thickness">
			<On Platform="iOS">
				<On.Value>
					0, 20, 0, 0
				</On.Value>
			</On>
		</OnPlatform>
	</Label.Padding>
<!-- ``` -->


OnIdiom 也是用于平台差异处理的标记扩展，{x:OnIdiom Phone="1", Tablet="2"} 根据不同设备，如 Desktop/TV/Watch 进行设置，对应 Device.Idiom 用法。


通过 OnPlatform 标记扩展来为不同平台设置 UI 样式：

<!-- ```xml -->
	<Application.Resources>
		...
		<Color x:Key="iOSNavigationBarColor">WhiteSmoke</Color>
		<Color x:Key="AndroidNavigationBarColor">#2196F3</Color>
		<Color x:Key="iOSNavigationBarTextColor">Black</Color>
		<Color x:Key="AndroidNavigationBarTextColor">White</Color>

		<Style TargetType="{x:Type NavigationPage}">
			<Setter Property="BarBackgroundColor"
					Value="{OnPlatform iOS={StaticResource iOSNavigationBarColor},
									   Android={StaticResource AndroidNavigationBarColor}}" />
			 <Setter Property="BarTextColor"
					Value="{OnPlatform iOS={StaticResource iOSNavigationBarTextColor},
									   Android={StaticResource AndroidNavigationBarTextColor}}" />           
		</Style>
		...
	</Application.Resources>
<!-- ``` -->

OnPlatform 支持泛型参数

<!-- ```xml -->
	<ContentPage.Resources>
		<ResourceDictionary>
			<OnPlatform x:Key="boxSize"
						x:TypeArguments="x:Double">
				<On Platform="iOS, Android, UWP" Value="50" />
			</OnPlatform>

			<OnPlatform x:Key="rowHeight"
						x:TypeArguments="x:Int32">
				<On Platform="iOS, Android, UWP" Value="60" />
			</OnPlatform>

			<local:DoubleToIntConverter x:Key="intConverter" />

		</ResourceDictionary>
	</ContentPage.Resources>
<!-- ``` -->

使用平台差异资源：

	<BoxView WidthRequest="{StaticResource boxSize}"
			 HeightRequest="{StaticResource boxSize}"
			 Color="{Binding Color}" />




# SkiaSharp 绘图 GDI
- https://www.cnblogs.com/peterYong/p/12767465.html
- https://github.com/xamarin/xamarin-forms-samples/blob/master/SkiaSharpForms
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/graphics/skiasharp/
- https://docs.microsoft.com/zh-cn/dotnet/api/skiasharp?view=skiasharp-1.68.1
- https://docs.microsoft.com/en-us/dotnet/api/skiasharp
- https://docs.microsoft.com/en-us/dotnet/api/skiasharp.skcanvas

.Net Core 官方没有可以支持跨平台的 Drawing 类库，Common.Drawing 只能在 Windows 下使用。

Google 的 Skia 是个 2D 向量图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现。不仅用于 Google Chrome 浏览器，新兴的 Android 开放手机平台也采用作为绘图处理，搭配 OpenGL/ES 与特定的硬件特征，强化显示的效果。

SkiaSharp 是 .Net 平台的移植版本，适用于 .NET 和 C# 的 2D 图形系统，由在 Google 产品中广泛使用的开源 Skia 图形引擎提供支持。 可以在 Xamarin.Forms 应用程序中使用 SkiaSharp 来绘制 2D 矢量图形、位图和文本。

- .NET Standard 1.3
- .NET Core
- Tizen
- Xamarin.Android
- Xamarin.iOS
- Xamarin.tvOS
- Xamarin.watchOS
- Xamarin.Mac
- Windows Classic Desktop (Windows.Forms / WPF)
- Windows UWP (Desktop / Mobile / Xbox / HoloLens)

的 SkiaSharp Xamarin.Forms 打包为 NuGet 包。 Xamarin.Forms在 Visual Studio 或 Visual Studio for Mac 中创建解决方案后，可以使用 NuGet 包管理器搜索SkiaSharp包，并将其添加到解决方案中。 如果在添加 SkiaSharp 之后检查每个项目的 "引用" 部分，可以看到已将各种SkiaSharp库添加到了解决方案中的每个项目。

如果你的 Xamarin.Forms 应用程序面向 ios，则使用 "项目属性" 页将最低部署目标更改为 ios 8.0。

在任何使用 SkiaSharp 的 c # 页面中，你都需要为 using 命名空间包含一个指令 SkiaSharp ，其中包含你将在图形编程中使用的所有 SkiaSharp 类、结构和枚举。 还需要一个 using 用于 SkiaSharp.Views.Forms 特定于的类的命名空间的指令 Xamarin.Forms 。 这是一个很小的命名空间，最重要的类是 SKCanvasView 。 此类派生自 Xamarin.Forms View 类，并托管你的 SkiaSharp 图形输出。

- SkiaSharp 绘制基础知识

	您可以用 SkiaSharp 绘制的一些最简单的图形图是圆、椭圆和矩形。 在显示这些图表时，您将了解 SkiaSharp 坐标、大小和颜色。 文本和位图的显示更复杂，但这些文章还介绍了这些技术。

- SkiaSharp Lines & Path

	图形路径是一系列连接的直线和曲线。 可以对路径进行描边和/或填充。 本文包含直线绘图的许多方面，包括笔划端和联接，以及虚线和虚线，但会停止短的曲线几何图形。

- SkiaSharp Transforms 变换

	变换允许对图形对象进行统一变换、缩放、旋转或倾斜。 本文还介绍了如何使用标准的 3 x 3 变换矩阵创建非仿射变换，并将变换应用于路径。

- SkiaSharp Curves & Paths 曲线和路径

	探索路径将继续向路径对象添加曲线，并利用其他强大的路径功能。 你将了解如何在简洁文本字符串中指定整个路径，如何使用路径效果，以及如何深入了解路径内部。

- SkiaSharp Bitmaps 位图

	位图是与显示设备的像素相对应的位的矩形数组。 这一系列文章演示了如何加载、保存、显示、创建、绘制、绘制 SkiaSharp 位图，以及如何对其进行动画处理。

- SkiaSharp Effects 效果

	效果是指改变图形的正常显示的属性，包括线性和圆形渐变、位图平铺、blend 模式、模糊等等。


安装最新版本 SkiaSharp 1.68.3，NuGet 包接近 100 MB，最好一并下载官方的示例：

	dotnet add package SkiaSharp --version 1.68.3
	dotnet add package SkiaSharp.Views --version 1.68.3
	dotnet add package SkiaSharp.Views.forms --version 1.68.3

	https://github.com/xamarin/xamarin-forms-samples/archive/master.zip

使用官方 TapToggleFillPage 测试一下，点击划圈圈：


	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             xmlns:skia="clr-namespace:SkiaSharp.Views.Forms;assembly=SkiaSharp.Views.Forms"
	             x:Class="SkiaSharpFormsDemos.Basics.TapToggleFillPage"
	             Title="Tap Toggle Fill">

	    <skia:SKCanvasView PaintSurface="OnCanvasViewPaintSurface">
	        <skia:SKCanvasView.GestureRecognizers>
	            <TapGestureRecognizer Tapped="OnCanvasViewTapped" />
	        </skia:SKCanvasView.GestureRecognizers>
	    </skia:SKCanvasView>
	</ContentPage>

注意几点：

- 引入 `SkiaSharp.Views.Forms` 命名空间；
- 使用 `SKCanvasView` 画布视图对象，承载图形和事件处理；
- 使用 `SKPaint` 对象指定颜色和其他绘制属性，`PaintSurface` 指定绘制事件处理函数。
- 使用 TapGestureRecognizer 触碰事件切换圈圈的显示状态； 
- 使用 InvalidateSurface 方法触发图形重绘；

真正绘图的实现在 OnCanvasViewPaintSurface 方法，事件参数传入 SKPaintSurfaceEventArgs：

- `Info` 用于获取 SKImageInfo 位图信息，如宽度高度；
- `Surface` 用于获取 SKSurface  代表绘图层的数据，和画板 SKCanvas，通过它重载的 Create 方法创建指定位图格式；

SKPaint 的 Style 属性指示线条填充及描边样式，`StrokeWidth` 指定描边粗细，SKPaintStyle 枚举成员如下：

- `Fill` 填充，默认值
- `Stroke` 描边
- `StrokeAndFill` 填充加描边

而具体怎么画，用 SKPaint 对象作画的结果，由 SKCanvas 画板提供的方法决定：

- SKCanvas `Clear` 方法清空画板的内容；
- SKCanvas `DrawCircle` 方法在画板画圈圈；
- SKCanvas `DrawColor` 填充色块；
- SKCanvas `DrawText` 画文字；

Clear() 方法用透明黑色像素替换画布的所有像素，等效于使用 new SKColor(0, 0, 0, 0) 或整数 0x00000000。 所有像素的所有字节都初始化为零。

SKCanvas 还提供了 Save、Restore、Flush 等方法。

在 SkiaSharp 命名空间，定义了许多基本类型，还有扩展方法，ToSKColor() 就是其中一个扩展方法。

C# 代码：

	using System;

	using Xamarin.Forms;

	using SkiaSharp;
	using SkiaSharp.Views.Forms;

	namespace SkiaSharpFormsDemos.Basics
	{
	    public partial class TapToggleFillPage : ContentPage
	    {
	        bool showFill = true;

	        public TapToggleFillPage()
	        {
	            InitializeComponent();
	        }

	        void OnCanvasViewTapped(object sender, EventArgs args)
	        {
	            showFill ^= true;
	            (sender as SKCanvasView).InvalidateSurface();
	        }

	        void OnCanvasViewPaintSurface(object sender, SKPaintSurfaceEventArgs args)
	        {
	            SKImageInfo info = args.Info;
	            SKSurface surface = args.Surface;
	            SKCanvas canvas = surface.Canvas;

	            canvas.Clear();

	            SKPaint paint = new SKPaint
	            {
	                Style = SKPaintStyle.Stroke,
	                Color = Color.Red.ToSKColor(),
	                StrokeWidth = 50
	            };
	            canvas.DrawCircle(info.Width / 2, info.Height / 2, 100, paint);

	            if (showFill)
	            {
	                paint.Style = SKPaintStyle.Fill;
	                paint.Color = SKColors.Blue;
	                canvas.DrawCircle(info.Width / 2, info.Height / 2, 100, paint);
	            }
	        }
	    }
	}


## SkiaSharp Basic 


SKPointMode 枚举：

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| Lines		| 1	| Interpret the data as coordinates for lines. |
| Points	| 0	| Interpret the data as coordinates for points. |
| Polygon	| 2	| Interpret the data as coordinates for polygons.  |


笔触终结处或转折处理方式 `SKStrokeCap` 枚举:

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| `Butt`	| 0	| 截面	|
| `Round`	| 1	| 圆角	|
| `Square`	| 2	| 方块	|

笔触连接位处理 `SKStrokeJoin` 枚举：

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| `Miter`	| 0	| 直角转折 |
| `Round`	| 1	| 圆角转折 |
| `Bevel`	| 2	| 倒角转折 |

SKTextAlign 枚举：

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| Left		| 0	| Left align the text. |
| Center	| 1	| Center the text. |
| Right		| 2	| Right align the text. |

SKVertexMode 枚举：

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| TriangleFan	| 2	| The vertices are a triangle fan. |
| Triangles	| 0	| The vertices are a triangle list. |
| TriangleStrip	| 1	| The vertices are a triangle strip. |


SKTypefaceStyle 枚举：

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| Bold		| 1	| Bold |
| BoldItalic| 3	| Bold and Italic, convenience definition. |
| Italic	| 2	| Italic |
| Normal	| 0	| Normal |

SKShaderTileMode 枚举：

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| Clamp		| 0	| 重复边缘 |
| Mirror	| 2	| 镜像重复 |
| Repeat	| 1	| 重复 |


方法原型参考，都是 public 无返回参数：

```C#
	Clear ();
	Clear (SKColor color);

	DrawPoint (SKPoint p, SKColor color);
	DrawPoint (SKPoint p, SKPaint paint);
	DrawPoint (float x, float y, SKColor color);
	DrawPoint (float x, float y, SKPaint paint);

	DrawPoints (SKPointMode mode, SKPoint[] points, SKPaint paint);

	DrawColor (SKColor color, SKBlendMode mode = SKBlendMode.Src);

	DrawLine (float x0, float y0, float x1, float y1, SKPaint paint);
	DrawLine (SKPoint p0, SKPoint p1, SKPaint paint);

	DrawRoundRect (SKRoundRect rect, SKPaint paint);
	DrawRoundRect (SKRect rect, SKSize r, SKPaint paint);
	DrawRoundRect (SKRect rect, float rx, float ry, SKPaint paint);
	DrawRoundRect (float x, float y, float w, float h, float rx, float ry, SKPaint paint);

	DrawOval (SKRect rect, SKPaint paint);
	DrawOval (float cx, float cy, float rx, float ry, SKPaint paint);
	DrawOval (SKPoint c, SKSize r, SKPaint paint);

	DrawCircle (float cx, float cy, float radius, SKPaint paint);
	DrawCircle (SKPoint c, float radius, SKPaint paint);

	DrawDrawable (SKDrawable drawable, float x, float y);
	DrawDrawable (SKDrawable drawable, ref SKMatrix matrix);
	DrawDrawable (SKDrawable drawable, SKPoint p);

	DrawBitmap (SKBitmap bitmap, SKPoint p, SKPaint paint = null);
	DrawBitmap (SKBitmap bitmap, SKRect dest, SKPaint paint = null);
	DrawBitmap (SKBitmap bitmap, SKRect source, SKRect dest, SKPaint paint = null);
	DrawBitmap (SKBitmap bitmap, float x, float y, SKPaint paint = null);

	DrawPicture (SKPicture picture, SKPaint paint = null);
	DrawPicture (SKPicture picture, SKPoint p, SKPaint paint = null);
	DrawPicture (SKPicture picture, float x, float y, SKPaint paint = null);
	DrawPicture (SKPicture picture, ref SKMatrix matrix, SKPaint paint = null);

	DrawText (IntPtr buffer, int length, float x, float y, SKPaint paint);
	DrawText (string text, float x, float y, SKPaint paint);
	DrawText (IntPtr buffer, int length, SKPoint p, SKPaint paint);
	DrawText (byte[] text, float x, float y, SKPaint paint);
	DrawText (SKTextBlob text, float x, float y, SKPaint paint);
	DrawText (string text, SKPoint p, SKPaint paint);
	DrawText (byte[] text, SKPoint p, SKPaint paint);

	DrawVertices (SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, SKBlendMode mode, ushort[] indices, SKPaint paint);
	DrawVertices (SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, SKPaint paint);
	DrawVertices (SKVertexMode vmode, SKPoint[] vertices, SKColor[] colors, SKPaint paint);
	DrawVertices (SKVertices vertices, SKBlendMode mode, SKPaint paint);
```

SKVertexMode 枚举：

| Fields | Vlues | 意义 |
| :-------- | :-------- | :-------- |
| TriangleFan	| 2	| The vertices are a triangle fan. |
| Triangles	| 0	| The vertices are a triangle list. |
| TriangleStrip	| 1	| The vertices are a triangle strip. |


## DrawText String to Image
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/graphics/skiasharp/basics/text

SKPaint 提供 MeasureText 计算文字占用空间大小，注意 `TextSize` 表达字号，SKCanvas  提供 DrawText 方法将文字绘制到位图上：

	public byte[] Create()
	{
	    String name = imageName + ".jpg";
	    SKBitmap bmp = new SKBitmap(128, 128);
	    String str = imageName;

	    using (SKCanvas canvas = new SKCanvas(bmp))
	    {

	        Random r = new Random();
	        int num = r.Next(0, 9);
	        // colors 是图片背景颜色集合
	        canvas.DrawColor(colors[num]); 
	        using (SKPaint sKPaint = new SKPaint())
	        {
	            sKPaint.Color = SKColors.White;
	            sKPaint.TextSize = 39;
	            sKPaint.IsAntialias = true;
	            sKPaint.Typeface = SkiaSharp.SKTypeface.FromFamilyName("微软雅黑", SKTypefaceStyle.Bold);
	            SKRect rectangle = new SKRect();
	            sKPaint.MeasureText(str, ref rectangle);

	            float cx = (128 - rectangle.Size.Width) / 2;
	            float cy = (128 - rectangle.Size.Height) / 2;
	            canvas.DrawText(str, cx, cy - rectangle.Top, sKPaint);
	        }
	        using (SKImage img = SKImage.FromBitmap(bmp))
	        {
	            using (SKData p = img.Encode(SKEncodedImageFormat.Jpeg, 100))
	            {
	                return p.ToArray();
	                //using (var stream = File.Create(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "photoImage", name)))
	                //{
	                //    stream.Write(p.ToArray(), 0, p.ToArray().Length);
	                //    return stream;
	                //}
	            }
	        }
	    }
	}

若要基于 URL 加载位图，可以使用 HttpClient 类，只应实例化一个实例并重复使用它，因此使用全局变量 httpClient。现代 iOS 和 Android 系统使用 HttpClient 应用程序时，需要符合传输层安全性 TLS 1.2，默认支持 HTTPS 方式而非传统 HTTP 明文方式。

为了防止网络出错，以下代码应该加 try-catch 处理错误：

    // Load web bitmap.
    string url = "https://developer.xamarin.com/demo/IMG_3256.JPG?width=480";

    using (Stream stream = await httpClient.GetStreamAsync(url))
    using (MemoryStream memStream = new MemoryStream())
    {
        await stream.CopyToAsync(memStream);
        memStream.Seek(0, SeekOrigin.Begin);

        webBitmap = SKBitmap.Decode(memStream);
        canvasView.InvalidateSurface();
    };


每个嵌入资源都有一个资源 ID ，其中包含项目名称、文件夹和文件名，所有这些都按句点进行连接： SkiaSharpFormsDemos.Media.monkey.png。 可以通过指定资源 ID 作为类的方法的参数来获取对此资源的访问权限 GetManifestResourceStream Assembly ：

	string resourceID = "SkiaSharpFormsDemos.Media.monkey.png";
	Assembly assembly = GetType().GetTypeInfo().Assembly;

	using (Stream stream = assembly.GetManifestResourceStream(resourceID))
	{
	    resourceBitmap = SKBitmap.Decode(stream);
	}


用户还可以从设备的图片库中加载照片。 此功能本身不提供此功能 Xamarin.Forms 。 该作业需要一个依赖项服务，例如从图片库中选取照片一文中所述的服务。

SkiaSharpFormsDemos 项目中的 IPhotoLibrary.cs 文件和相应平台项目文件已进行了修改，并且已向 iOS 项目授予访问照片库的权限，并在 info.plist 文件的底部有两行内容。

- iOS 通过 UIImagePickerController 打开相册文件；
- Android 通过 Intent 指定 MainActivity.PickImageId 信号打开相册文件；
- UWP 通过 FileOpenPicker 指定 PickerLocationId.PicturesLibrary 位置打开相册文件；

BasicBitmapsPage 构造函数将添加 TapGestureRecognizer 到 SKCanvasView 以在点击时获得通知。 收到点击后， Tapped 处理程序将获取对图片选取器依赖项服务的访问权限，并调用 `PickPhotoAsync` 。 如果 Stream 返回对象，则会将该对象传递给 SKBitmap.Decode 方法：

	// Add tap gesture recognizer
	TapGestureRecognizer tapRecognizer = new TapGestureRecognizer();
	tapRecognizer.Tapped += async (sender, args) =>
	{
	    // Load bitmap from photo library
	    IPhotoLibrary photoLibrary = DependencyService.Get<IPhotoLibrary>();

	    using (Stream stream = await photoLibrary.PickPhotoAsync())
	    {
	        if (stream != null)
	        {
	            libraryBitmap = SKBitmap.Decode(stream);
	            canvasView.InvalidateSurface();
	        }
	    }
	};
	canvasView.GestureRecognizers.Add(tapRecognizer);

请注意， Tapped 处理程序还将调用 InvalidateSurface 对象的方法 SKCanvasView 。 这会生成对处理程序的新调用 PaintSurface 。

程序可以使用和属性获取位图的像素尺寸 Width Height 。 这些属性允许程序计算坐标，以将位图置于画布的三分之一的中心：

	void OnCanvasViewPaintSurface(object sender, SKPaintSurfaceEventArgs args)
	{
	    SKImageInfo info = args.Info;
	    SKSurface surface = args.Surface;
	    SKCanvas canvas = surface.Canvas;

	    canvas.Clear();

	    if (webBitmap != null)
	    {
	        float x = (info.Width - webBitmap.Width) / 2;
	        float y = (info.Height / 3 - webBitmap.Height) / 2;
	        canvas.DrawBitmap(webBitmap, x, y);
	    }
	    ...
	}

## Alpha & Blend 混合与透明度
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/

SkiaSharp SKPaint 类定义了六个属性，透明度其实也算是一种基础效果。 效果是以某种方式更改图形的正常显示方式的属性。 

- Paths Effects 路径效果

	将 SKPaint 的 `PathEffect` 属性设置为 `SKPathEffect` 类型的对象可以显示虚线，或使用从路径创建的模式来描边或填充区域。 

- Shader Effects 着色器

	将 SKPaint 的 `Shader` 属性设置为 SKShader 类型的对象，以显示线性或圆形渐变、平铺位图和 Perlin 噪声模式。

- Blend Effects 混合模式

	将 SKPaint 的 BlendMode 属性设置为 `SKBlendMode` 枚举的成员，以控制两个图形叠加时所发生的情况。 SkiaSharp 支持所有 CSS 组合和混合模式，包括 Porter 模式、分离混合模式和非分离混合模式。

- Mask Filters 遮罩筛选器

	将 SKPaint 的 MaskFilter 属性设置为 `SKMaskFilter` 类型的对象，以提供模糊和其他 alpha 效果。

- Image Filters 图像筛选器

	将 SKPaint 的 ImageFilter 属性设置为 `SKImageFilter` 类型的对象，以对位图进行模糊处理并创建投影、浮雕或 engraving 效果。

- Color Filters 颜色筛选器

	使用表或矩阵转换将 SKPaint 的属性 ColorFilter 设置为 `SKColorFilter` 类型的对象，从而更改颜色。

所有示例代码都位于 SkiaSharpFormsDemos 中。


SkiaSharp 提供显示各种透明度的位图，SKPaint 该类包含一个 Color 类型为的属性 SKColor 。 `SKColor` 包含 `Alpha` 通道，因此，使用值的任何颜色都 SKColor 可能是部分透明的。

在 SkiaSharp 基本动画中演示了一些透明度。 本文稍微深入地探讨了如何将多个对象组合到一个场景中，这种方法有时也称为 "混合"。 SkiaSharp 着色器部分的文章中介绍了更高级的混合技术。

使用四参数构造函数或 WithAlpha 方法创建颜色时，可以设置透明度级别 SKColor，Alpha 值 0 是完全透明的，值 255 为完全不透明 ：

	SKColor (byte red, byte green, byte blue, byte alpha);

	SKColor halfTransparentBlue = SKColors.Blue.WithAlpha(0x80);


位图溶解在位图溶解页中进行了演示。 XAML 文件实例化 SKCanvasView 和 Slider ：

	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             xmlns:skia="clr-namespace:SkiaSharp.Views.Forms;assembly=SkiaSharp.Views.Forms"
	             x:Class="SkiaSharpFormsDemos.Effects.BitmapDissolvePage"
	             Title="Bitmap Dissolve">
	    <StackLayout>
	        <skia:SKCanvasView x:Name="canvasView"
	                           VerticalOptions="FillAndExpand"
	                           PaintSurface="OnCanvasViewPaintSurface" />

	        <Slider x:Name="progressSlider"
	                Margin="10"
	                ValueChanged="OnSliderValueChanged" />
	    </StackLayout>
	</ContentPage>

代码隐藏文件加载两个位图资源。 这些位图的大小不相同，但纵横比相同：

	public partial class BitmapDissolvePage : ContentPage
	{
	    SKBitmap bitmap1;
	    SKBitmap bitmap2;

	    public BitmapDissolvePage()
	    {
	        InitializeComponent();

	        // Load two bitmaps
	        Assembly assembly = GetType().GetTypeInfo().Assembly;

	        using (Stream stream = assembly.GetManifestResourceStream(
	                                "SkiaSharpFormsDemos.Media.SeatedMonkey.jpg"))
	        {
	            bitmap1 = SKBitmap.Decode(stream);
	        }
	        using (Stream stream = assembly.GetManifestResourceStream(
	                                "SkiaSharpFormsDemos.Media.FacePalm.jpg"))
	        {
	            bitmap2 = SKBitmap.Decode(stream);
	        }
	    }

	    void OnSliderValueChanged(object sender, ValueChangedEventArgs args)
	    {
	        canvasView.InvalidateSurface();
	    }

	    void OnCanvasViewPaintSurface(object sender, SKPaintSurfaceEventArgs args)
	    {
	        SKImageInfo info = args.Info;
	        SKSurface surface = args.Surface;
	        SKCanvas canvas = surface.Canvas;

	        canvas.Clear();

	        // Find rectangle to fit bitmap
	        float scale = Math.Min((float)info.Width / bitmap1.Width,
	                                (float)info.Height / bitmap1.Height);
	        SKRect rect = SKRect.Create(scale * bitmap1.Width,
	                                    scale * bitmap1.Height);
	        float x = (info.Width - rect.Width) / 2;
	        float y = (info.Height - rect.Height) / 2;
	        rect.Offset(x, y);

	        // Get progress value from Slider
	        float progress = (float)progressSlider.Value;

	        // Display two bitmaps with transparency
	        using (SKPaint paint = new SKPaint())
	        {
	            paint.Color = paint.Color.WithAlpha((byte)(0xFF * (1 - progress)));
	            canvas.DrawBitmap(bitmap1, rect, paint);

	            paint.Color = paint.Color.WithAlpha((byte)(0xFF * progress));
	            canvas.DrawBitmap(bitmap2, rect, paint);
	        }
	    }
	}

Color对象的属性 SKPaint 设置为两个位图的两个互补 alpha 级别。 使用 SKPaint 位图时，值的其余部分并不重要 Color 。 重要的是 alpha 通道。 此处的代码只是对 WithAlpha 属性的默认值调用方法 Color 。

SkiaSharp blend 模式与 W3C合成和 Blend Level 1规范中所述的模式密切相关。 Skia SkBlendMode 概述还提供了有用的背景信息。 对于混合模式的一般介绍，维基百科中的混合模式一文是一个不错的开端。 Adobe Photoshop 支持混合模式，因此，在该上下文中有其他有关 blend 模式的在线信息。

在绘制操作混合两个图像对象时，涉及背景 Backdrop 或者叫 Destination，还有前景 Source，混合模式决定结果。从历史上看，混合是与 alpha 通道的概念一起发展起来的。 Duff 混合模式是在 Thomas Porter 和 Tom Duff 之后命名的，他们在处理 Lucasfilm 时开发了合成方法。

混合模式 SKBlendMode 的 29 个枚举成员可以分为三个类别：

12 个 Porter-Duff 混合模式，In/Out/Over/Top 成对出现：

| Fields	| Vlues | 意义 |
| :-------- | :-------- | :-------- |
| Clear		|  0	| 清除绘图数据，纯白填充 |
| Dst		|  2	| Backdrop 优先，透明部分可以显示 Source |
| DstATop	| 10	| 显示 Source，但相交部分由 Destination 覆盖 |
| DstIn		|  6	| Destination 覆盖 source，仅显示目标和源相交的区域 |
| DstOut	|  8	| Destination 覆盖 source，仅显示目标和源不相交的区域 |
| DstOver	|  4	| Destination 覆盖 source |
| Src		|  1	| 优先，透明部分可以显示 Destination |
| SrcATop	|  9	| 显示 Destination，但相交部分由 Source 覆盖 |
| SrcIn		|  5	| Source 覆盖 Destination，仅显示目标和源相交的区域  |
| SrcOut	|  7	| Source 覆盖 Destination，仅显示目标和源不相交的区域 |
| SrcOver	|  3	| Source 覆盖 destination. |
| Xor		| 11	| 显示两个区域不重叠的部分 |


13 个可分离混合模式 Separable Blend Modes：

| Fields	| Vlues | 意义 |
| :-------- | :-------- | :-------- |
| Modulate	| 13	| 非常类似于 Plus 但目标颜色和源颜色相乘，点积，是附加 Porter-Duff 混合模式。 |
| Plus		| 12	| Source 和 destination 相加 |
| ColorBurn	| 19	| 加深 backdrop 衬托 source |
| ColorDodge| 18	| 加亮 backdrop 衬托 source |
| Darken	| 16	| 选出 backdrop & source 更暗的部分，即 min(src, des) |
| Difference| 22	| 亮色减暗色 |
| Exclusion	| 23	| 类似于 Difference 但对比度更低 |
| HardLight	| 20	| 类似于恶劣聚光灯的效果，根据 Source 颜色执行 Multiply 或 Screen |
| Lighten	| 17	| 取 backdrop 或 source 的亮者，即 max(src, des) |
| Multiply	| 24	| 相乘加深颜色 Sc·Dc |
| Overlay	| 15	| 根据 Backdrop 进行 Multiply 或 Screens，是 HardLight 反操作 |
| Screen	| 14	| 互补色相乘，再取结果的补色，Sc + Dc – Sc·Dc |
| SoftLight	| 21	| 类似于软聚光灯的效果，加深或减淡 Source 颜色 |


4 个不可分离混合模式 Non-Separable Blend Modes：

| Fields	| Vlues | 意义 |
| :-------- | :-------- | :-------- |
| Color		| 27	| 使用 Source 的色彩和 Backdrop 的明度 |
| Hue		| 25	| 取 source 的色调，结合 backdrop 的饱和度和亮度 |
| Luminosity| 28	| 取 source 的亮度，结合 backdrop 的色调与饱和度 |
| Saturation| 26	| 取 source 饱和度，结合 backdrop 的色调与亮度 |

Porter-Duff blend 模式通常执行剪辑操作。 分离混合模式不同，分离模式改变图像的各个红色、绿色和蓝色成分，即根据图像各个部分颜色差异进行分离处理。分离混合模式分别对红色、绿色和蓝色通道执行操作。不可分离混合模式以有趣的方式改变颜色，通过在颜色的色调、饱和度和发光度上操作。

示例 BlueBananaPage 中演示了，如何用遮罩将香蕉从图形中分离，使用 SKBlendMode.SrcIn 混合模式改变香蕉为蓝色颜色，再使用  SKBlendMode.Color 修改屏幕图案中的香蕉，显示其 Hue 色调为蓝色。

![PorterDuffCanvasView 示例](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/graphics/skiasharp/effects/blend-modes/porter-duff-images/porterduffgrid-large.png)

官方例程 PorterDuffCanvasView 演示了各种混合模式：

	using System;

	using SkiaSharp;
	using SkiaSharp.Views.Forms;

	namespace SkiaSharpFormsDemos.Effects
	{
	    class PorterDuffCanvasView : SKCanvasView
	    {
	        static SKBitmap srcBitmap, dstBitmap;

	        static PorterDuffCanvasView()
	        {
	            dstBitmap = new SKBitmap(300, 300);
	            srcBitmap = new SKBitmap(300, 300);

	            using (SKPaint paint = new SKPaint())
	            {
	                using (SKCanvas canvas = new SKCanvas(dstBitmap))
	                {
	                    canvas.Clear();
	                    paint.Color = new SKColor(0xC0, 0x80, 0x00);
	                    canvas.DrawRect(new SKRect(0, 0, 200, 200), paint);
	                }
	                using (SKCanvas canvas = new SKCanvas(srcBitmap))
	                {
	                    canvas.Clear();
	                    paint.Color = new SKColor(0x00, 0x80, 0xC0);
	                    canvas.DrawRect(new SKRect(100, 100, 300, 300), paint);
	                }
	            }
	        }

	        SKBlendMode blendMode;

	        public PorterDuffCanvasView(SKBlendMode blendMode)
	        {
	            this.blendMode = blendMode;
	        }

	        protected override void OnPaintSurface(SKPaintSurfaceEventArgs args)
	        {
	            SKImageInfo info = args.Info;
	            SKSurface surface = args.Surface;
	            SKCanvas canvas = surface.Canvas;

	            canvas.Clear();

	            // Find largest square that fits
	            float rectSize = Math.Min(info.Width, info.Height);
	            float x = (info.Width - rectSize) / 2;
	            float y = (info.Height - rectSize) / 2;
	            SKRect rect = new SKRect(x, y, x + rectSize, y + rectSize);

	            // Draw destination bitmap
	            canvas.DrawBitmap(dstBitmap, rect);

	            // Draw source bitmap
	            using (SKPaint paint = new SKPaint())
	            {
	                paint.BlendMode = blendMode;
	                canvas.DrawBitmap(srcBitmap, rect, paint);
	            }

	            // Draw outline
	            using (SKPaint paint = new SKPaint())
	            {
	                paint.Style = SKPaintStyle.Stroke;
	                paint.Color = SKColors.Black;
	                paint.StrokeWidth = 2;
	                rect.Inflate(-1, -1);
	                canvas.DrawRect(rect, paint);
	            }
	        }
	    }
	}

配套页面由 C# 代码编写：

	using System;

	using Xamarin.Forms;

	using SkiaSharp;

	namespace SkiaSharpFormsDemos.Effects
	{
		public class PorterDuffGridPage : ContentPage
		{
	        public PorterDuffGridPage()
	        {
	            Title = "Porter-Duff Grid";

	            SKBlendMode[] blendModes =
	            {
	                SKBlendMode.Src, SKBlendMode.Dst, SKBlendMode.SrcOver, SKBlendMode.DstOver,
	                SKBlendMode.SrcIn, SKBlendMode.DstIn, SKBlendMode.SrcOut, SKBlendMode.DstOut,
	                SKBlendMode.SrcATop, SKBlendMode.DstATop, SKBlendMode.Xor, SKBlendMode.Plus,
	                SKBlendMode.Modulate, SKBlendMode.Clear
	            };

	            Grid grid = new Grid
	            {
	                Margin = new Thickness(5)
	            };

	            for (int row = 0; row < 4; row++)
	            {
	                grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
	                grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Star });
	            }

	            for (int col = 0; col < 3; col++)
	            {
	                grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Star });
	            }

	            for (int i = 0; i < blendModes.Length; i++)
	            {
	                SKBlendMode blendMode = blendModes[i];
	                int row = 2 * (i / 4);
	                int col = i % 4;

	                Label label = new Label
	                {
	                    Text = blendMode.ToString(),
	                    HorizontalTextAlignment = TextAlignment.Center
	                };
	                Grid.SetRow(label, row);
	                Grid.SetColumn(label, col);
	                grid.Children.Add(label);

	                PorterDuffCanvasView canvasView = new PorterDuffCanvasView(blendMode);

	                Grid.SetRow(canvasView, row + 1);
	                Grid.SetColumn(canvasView, col);
	                grid.Children.Add(canvasView);
	            }

	            Content = grid;
	        }
	    }
	}


## Paths Effects 路径效果
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/graphics/skiasharp/curves/effects

路径效果是 SKPathEffect 类的一个实例，该类是使用类定义的8个静态创建方法中的一种创建的。 然后，将 SKPaint 对象的 PathEffect 属性设置为 `SKPathEffect` 对象，以获得各种有趣的效果。

PathEffect.CreateDash 方法签名：

	public static SKPathEffect CreateDash (Single[] intervals, Single phase)

路径效果允许：

- 使用圆点和短划线绘制线条
- 使用任意填充路径为线条描边
- 使用影线线条填充区域
- 使用平铺路径填充区域
- 使尖角圆角
- 向直线和曲线添加随机 "抖动"
- 此外，您可以将两个或多个路径效果组合在一起。


## Shader Effects 着色器

## Mask Filters 遮罩筛选器

遮罩筛选器是操作图形对象的几何和 alpha 通道的效果。 若要使用遮罩筛选器，请将 SKPaint 的 `MaskFilter` 属性设置为 `SKMaskFilter`，通过调用静态方法之一创建的类型的对象 SKMaskFilter 。

静态 SKMaskFilter.CreateBlur 方法具有以下语法：

	public static SKMaskFilter CreateBlur (SKBlurStyle blurStyle, float sigma);

SKBlurStyle 枚举：

| Fields	| Vlues	| 意义 |
| :-------- | :-------- | :-------- |
| Inner		| 3	| Fuzzy inside, nothing outside |
| Normal	| 0	| Fuzzy inside and outside |
| Outer		| 2	| Nothing inside, fuzzy outside |
| Solid		| 1	| Solid inside, fuzzy outside |

利用模糊，可以制作出类似倒影的效果，参考 BlurryReflectionPage 示例。


## Image Filters 图像筛选器
- https://docs.microsoft.com/zh-cn/dotnet/api/skiasharp.imagefilter

图像筛选器是对构成图像的所有颜色位进行操作的效果，这些筛选器比只在 alpha 通道上操作的遮罩筛选器更通用。 若要使用图像筛选器，请将 SKPaint 的 ImageFilter 属性设置为 `SKImageFilter`。

与模糊效果 SKMaskFilter 相比，SKImageFilter.CreateBlur 具有明显的优势：图像筛选器可以对整个位图进行模糊。 

	public static SkiaSharp.SKImageFilter CreateBlur (float sigmaX, float sigmaY,
	                                                  SKImageFilter input = null,
	                                                  SKImageFilter.CropRect cropRect = null);

此方法具有两个西格玛值，一个用于水平方向的模糊范围，第二个值用于垂直方向。 第三个参数来层叠其它图像筛选器。 还可以指定裁剪矩形。参考 `ImageBlurExperimentPage` 示例。

SKImageFilter.CreateDropShadow 静态方法创建一个投影对象：

	public static SKImageFilter CreateDropShadow (float dx, float dy,
	                                              float sigmaX, float sigmaY,
	                                              SKColor color,
	                                              SKDropShadowImageFilterShadowMode shadowMode,
	                                              SKImageFilter input = null,
	                                              SKImageFilter.CropRect cropRect = null);

将此对象设置为 SKPaint 对象的 ImageFilter 属性，将在其后面放置一个阴影。参考 `DropShadowExperimentPage` 示例。

dx 和 dy 参数指示阴影的水平和垂直偏移量（以像素为单位）。 2D 图形中的约定是假设从左上方开始的光源，这表示这两个参数都应为正值，以将阴影放置在图形对象的下方和右侧。

sigmaX 和 sigmaY 参数是投影的模糊因数。

color 参数是投影的颜色。 此 SKColor 值可以包含透明度。 一种可能的颜色值是将 SKColors.Black.WithAlpha(0x80) 任何颜色背景变暗。

此外，`SKImageFilter` 类定义了六个具有相似名称和参数的方法，创建照明效果，这些方法在此处按递增复杂度的顺序列出：

- `CreateDistantLitDiffuse` 
- `CreateDistantLitSpecular` 
- `CreatePointLitDiffuse` 
- `CreatePointLitSpecular` 
- `CreateSpotLitDiffuse` 
- `CreateSpotLitSpecular` 

这些方法创建的图像筛选器模拟三维表面上不同种类的光的效果。 生成的图像筛选器会将二维对象视为3D 空间中存在的对象，这可能会导致这些对象显示为升高或凹陷，或具有镜面突出显示。

Distant 灯光方法假设光源来自远处。 用于照亮对象的情况下，光源被认为是三维空间中的一个一致方向，非常类似于地球上的一个小区域。 

Point 灯光方法模拟三维空间中放置光线的灯泡。

Spot光源具有位置和方向，与闪光灯非常类似。

三维空间中的位置和方向都是用结构的值指定的 SKPoint3 ，它类似于 SKPoint 但具有三个名为 X 、和的属性 Y Z 。
这些方法的参数的数量和复杂性使得它们的试验非常困难。


	public static SKImageFilter CreateDistantLitDiffuse (SKPoint3 direction,
	                                                 SKColor lightColor,
	                                                 float surfaceScale,
	                                                 float kd,
	                                                 SKImageFilter input = null,
	                                                 SKImageFilter.CropRect cropRect = null);

参考 SkiaLightExperiment 示例。

	<?xml version="1.0" encoding="utf-8" ?>
	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	             xmlns:skia="clr-namespace:SkiaSharp.Views.Forms;assembly=SkiaSharp.Views.Forms"
	             x:Class="SkiaSharpFormsDemos.Effects.DistantLightExperimentPage"
	             Title="Distant Light Experiment">

	    <StackLayout>

	        <skia:SKCanvasView x:Name="canvasView"
	                           PaintSurface="OnCanvasViewPaintSurface"
	                           VerticalOptions="FillAndExpand" />

	        <Slider x:Name="zSlider" 
	                Minimum="-10"
	                Maximum="10"
	                Margin="10, 0"
	                ValueChanged="OnSliderValueChanged" />

	        <Label Text="{Binding Source={x:Reference zSlider},
	                              Path=Value,
	                              StringFormat='Z = {0:F0}'}"
	               HorizontalTextAlignment="Center" />

	        <Slider x:Name="surfaceScaleSlider" 
	                Minimum="-1"
	                Maximum="1"
	                Margin="10, 0"
	                ValueChanged="OnSliderValueChanged" />

	        <Label Text="{Binding Source={x:Reference surfaceScaleSlider},
	                              Path=Value,
	                              StringFormat='Surface Scale = {0:F1}'}"
	               HorizontalTextAlignment="Center" />

	        <Slider x:Name="lightConstantSlider" 
	                Minimum="-1"
	                Maximum="1"
	                Margin="10, 0"
	                ValueChanged="OnSliderValueChanged" />

	        <Label Text="{Binding Source={x:Reference lightConstantSlider},
	                              Path=Value,
	                              StringFormat='Light Constant = {0:F1}'}"
	               HorizontalTextAlignment="Center" />
	    </StackLayout>
	</ContentPage>

C# 代码：

	using System;

	using Xamarin.Forms;

	using SkiaSharp;
	using SkiaSharp.Views.Forms;

	namespace SkiaSharpFormsDemos.Effects
	{
	    public partial class DistantLightExperimentPage : ContentPage
	    {
	        const string TEXT = "Lighting";

	        public DistantLightExperimentPage()
	        {
	            InitializeComponent();
	        }

	        void OnSliderValueChanged(object sender, ValueChangedEventArgs args)
	        {
	            canvasView.InvalidateSurface();
	        }

	        void OnCanvasViewPaintSurface(object sender, SKPaintSurfaceEventArgs args)
	        {
	            SKImageInfo info = args.Info;
	            SKSurface surface = args.Surface;
	            SKCanvas canvas = surface.Canvas;

	            canvas.Clear();

	            float z = (float)zSlider.Value;
	            float surfaceScale = (float)surfaceScaleSlider.Value;
	            float lightConstant = (float)lightConstantSlider.Value;

	            using (SKPaint paint = new SKPaint())
	            {
	                paint.IsAntialias = true;

	                // Size text to 90% of canvas width
	                paint.TextSize = 100;
	                float textWidth = paint.MeasureText(TEXT);
	                paint.TextSize *= 0.9f * info.Width / textWidth;

	                // Find coordinates to center text
	                SKRect textBounds = new SKRect();
	                paint.MeasureText(TEXT, ref textBounds);

	                float xText = info.Rect.MidX - textBounds.MidX;
	                float yText = info.Rect.MidY - textBounds.MidY;

	                // Create distant light image filter
	                paint.ImageFilter = SKImageFilter.CreateDistantLitDiffuse(
	                                        new SKPoint3(2, 3, z),
	                                        SKColors.White,
	                                        surfaceScale,
	                                        lightConstant);

	                canvas.DrawText(TEXT, xText, yText, paint);
	            }
	        }
	    }
	}



## Color Filters 颜色筛选器
- [矩阵乘法运算的本质](https://www.zhihu.com/question/21351965)
- [图形学中的基本变换 Basic Transforms](https://zhuanlan.zhihu.com/p/96717729)
- [线性代数的本质](https://www.bilibili.com/video/av79299868)

颜色筛选器可以将位图中的颜色（或其他图像）转换为其他颜色，如色调分离 posterization 。

若要使用颜色筛选器，请将 SKPaint 的 ColorFilter 属性设置为 SKColorFilter。

- 使用静态方法创建颜色转换 CreateColorMatrix 。
- 使用静态方法创建颜色表 CreateTable 。

图像处理中，颜色转换涉及使用矩阵来修改颜色，与大多数 2D 图形系统一样，SkiaSharp 使用最多的矩阵转换坐标点，如 Matrix Transforms in SkiaSharp 所论。 SKColorFilter 支持矩阵转换，但矩阵转换 RGB 颜色。 

若要理解这些颜色转换，一定要熟悉矩阵概念。矩阵就是一种数据格式，由于它具有统一的加减乘除等丰富的运算规则，非常方便处理线性代数问题，而广泛应用于计算机图形学上。

在向量系统中，基底 Basis 是特别重要的单位，二维空间中的任何向量都是可以通过缩放 i、j 这两个向量基底再将它们相加的值表示出来。譬如向量 (3, 2) 就是沿着 i 的方向拉伸 3 倍, 再沿着 j 方向拉伸 2 倍的向量。

例如，二维空间中，当两个向量相加，几何图形上就是按基底前的系数进行比例缩放，和轴线方向绽放值再相加。


线性变换是一种保留向量加法和标量乘法的运算，向量中的数值系数称为标题 Scalars，在向量的运算过程中也只是放大缩小的作用，所以可以等价 Scale。旋转变换是另一种线性变换。缩放变换和旋转变换，事实上所有的对于 3D 向量的线性变换，都可以表示成一个 [3 x 3] 的矩阵。

在计算机图形学中，我们时常想要把各种变换结合起来，如先把一个物体缩小一半，再绕某个轴旋转 90 度，再平移到某个位置。但这种结合无法只用一个简单的 3D 矩阵实现。

为了结合线性变换和平移变换可以使用仿射变换 Affine Transform，通常存储在一个 [4 x 4] 的矩阵中。仿射变换是一种变换，即先完成线性变换，然后再完成平移变换。

列如最常见的灰度化处理，对于使用标准红色绿色蓝色 sRGB 色域的视频，此公式为：

	gray-shade = 0.2126·R + 0.7152·G + 0.0722·B

直接使用公式也是可以计算得到灰度图形的，但是实际应用中，不仅只有这一条公式，就以仿射变换为例，它有平移、旋转、缩放、切变等等。使用矩阵的好处就是，通过定义矩阵的系数就可以通过矩阵的运行法则来得到不同公式的结果，这真的很方便！更重要的是，图形处理中，常常是以图片中一组像素数据作为输入，输出另一组变换后的像素数据，这也使得直接应用公式的方法受到极大的束缚。而使用矩阵，只需要选择特定的数字，就可以得到平移、旋转、缩放、切变等等的运算，并且它们的复合计算也可以表达在矩阵内。

列如，二维平面上的点进行仿射变换 Affine Transform，只需要一个 2 x 2 矩阵，如下式子，左乘两个矩阵具有连续几何变换作用，这里是 Shear 和 Rotation 两种几何变换：

	| 1 1 |     | 0 -1 |     | x |     | 1 -1 |     | x |
	| 0 1 |  x  | 1  0 |  x  | y |  =  | 1  0 |  x  | y |
	 Shear      Rotation              Composition

上面的写法中两个独立的变换等价于一个复合变换，可以计算 [x, y] 旋转后 [-x, y]，也就是 180 度翻转，再沿 x 轴切变为 [-x + y, y]。但是这两个变换的矩阵运算顺序会影响结果。利用几何变换的意义去替代实际的运算，即通过跟踪向量基底的运动方向来理解矩阵运算产生的几何意义，这样更有助于理解线性变换的意义。


灰度颜色矩阵是最常见的用途之一，这涉及到红色、绿色和蓝色值的加权平均值的公式。 若要将颜色位图转换为灰色缩放位图，R'、G' 和 B' 结果必须等于相同的值。 矩阵为：

	| 0.21 0.72 0.07 0 0 |    | R |   | 0.2126·R + 0.7152·G + 0.0722·B |
	| 0.21 0.72 0.07 0 0 |    | G |   | 0.2126·R + 0.7152·G + 0.0722·B |
	| 0.21 0.72 0.07 0 0 |  × | B | = | 0.2126·R + 0.7152·G + 0.0722·B |
	| 0    0    0    1 0 |    | A |   | A |
	                          | 1 |

没有与此矩阵相对应的 SkiaSharp 数据类型。 相反，您必须将矩阵表示为 float 按行顺序排列的 20 个值的数组：第一行、第二行，依此类推。

静态 SKColorFilter.CreateColorMatrix 方法具有以下语法：

	public static SKColorFilter CreateColorMatrix (float[] matrix);

其中 matrix ，为 20 个 float 值的数组，在 C# 中创建数组时，可以轻松地设置数字的格式，使其类似于 4×5 矩阵。

又以平移为例，假设三维平移向量 t = (tx, ty, tz)，那么平移矩阵如下：

	| 1 0 0 0 tx|
	| 0 1 0 0 ty|
	| 0 0 1 0 tz|
	| 0 0 0 1 0 |

输入一个点 P 的三维坐标，[px, py, pz, 1] ，对其施加平移矩阵，得到新的点 [px + tx, py + ty, pz + tz, 1] ，明显是由 P 平移得到的。这些知识点可以参考 Real-Time Rendering 4th 4.1 Basic Transforms。


颜色转换矩阵具有 4 行 5 列的维度，对应像素的 RGBA 四分量，和一个附加参数值：

	| M11 M12 M13 M14 M15 |
	| M21 M22 M23 M24 M25 |
	| M31 M32 M33 M34 M35 |
	| M41 M42 M43 M44 M45 |

它将 RGB 源颜色（R、G、B、A）转换为目标颜色（R'、G'、B'、A'）。

为了做矩阵乘法，源颜色转换为 5×1 矩阵：

	| R |
	| G |
	| B |
	| A |
	| 1 |

这些 R、G、B 和 A 值是介于 0 到 255 之间的原始字节。

位移转换系数需要额外的单元格，这类似于使用 3×3 矩阵转换二维坐标点，参考有关使用矩阵转换坐标点。

4×5 矩阵乘以 5×1 矩阵，点积是具有转换后的颜色的 4×1 矩阵：

	| M11 M12 M13 M14 M15 |    | R |   | R' |
	| M21 M22 M23 M24 M25 |    | G |   | G' |
	| M31 M32 M33 M34 M35 |  × | B | = | B' |
	| M41 M42 M43 M44 M45 |    | A |   | A' |
	                           | 1 |

以下是 R'、G'、B' 和 A 的单独公式：

	R' = M11·R + M12·G + M13·B + M14·A + M15
	G' = M21·R + M22·G + M23·B + M24·A + M25
	B' = M31·R + M32·G + M33·B + M34·A + M35
	A' = M41·R + M42·G + M43·B + M44·A + M45

其中的大多数矩阵都包含介于 0 到 2 范围内的乘法系数。 但是，最后一列（M15 到 M45）包含在公式中添加的值。 这些值通常介于 0 到 255 之间的限制。

标识矩阵为：

	| 1 0 0 0 0 |
	| 0 1 0 0 0 |
	| 0 0 1 0 0 |
	| 0 0 0 1 0 |

这不会对颜色进行任何更改。 转换公式为：

	R' = R
	G' = G
	B' = B
	A' = A

M44 单元格非常重要，因为它保留不透明度。 通常情况下，M41、M42 和 M43 均为零，因为您可能不希望不透明度基于红色、绿色和蓝色值。 但如果 M44 为零，则 "将为零，而不会显示任何内容。


`PastelMatrixPage` 蜡笔示例矩阵通过源红色像素来计算目标红像素，并稍微强调红色和绿色像素。

	using (SKPaint paint = new SKPaint())
	{
	    paint.ColorFilter =
	        SKColorFilter.CreateColorMatrix(new float[]
	        {
	            0.75f, 0.25f, 0.25f, 0, 0,
	            0.25f, 0.75f, 0.25f, 0, 0,
	            0.25f, 0.25f, 0.75f, 0, 0,
	            0, 0, 0, 1, 0
	        });

	    canvas.DrawBitmap(bitmap, info.Rect, BitmapStretch.Uniform, paint: paint);
	}

参考 `GrayScaleMatrixPage` 示例。

	using System;

	using Xamarin.Forms;

	using SkiaSharp;
	using SkiaSharp.Views.Forms;

	namespace SkiaSharpFormsDemos.Effects
	{
		public class GrayScaleMatrixPage : ContentPage
		{
	        SKBitmap bitmap = BitmapExtensions.LoadBitmapResource(
	                            typeof(GrayScaleMatrixPage),
	                            "SkiaSharpFormsDemos.Media.Banana.jpg");

	        public GrayScaleMatrixPage()
	        {
	            Title = "Gray-Scale Matrix";

	            SKCanvasView canvasView = new SKCanvasView();
	            canvasView.PaintSurface += OnCanvasViewPaintSurface;
	            Content = canvasView;
	        }

	        void OnCanvasViewPaintSurface(object sender, SKPaintSurfaceEventArgs args)
	        {
	            SKImageInfo info = args.Info;
	            SKSurface surface = args.Surface;
	            SKCanvas canvas = surface.Canvas;

	            canvas.Clear();

	            using (SKPaint paint = new SKPaint())
	            {
	                paint.ColorFilter =
	                    SKColorFilter.CreateColorMatrix(new float[]
	                    {
	                        0.21f, 0.72f, 0.07f, 0, 0,
	                        0.21f, 0.72f, 0.07f, 0, 0,
	                        0.21f, 0.72f, 0.07f, 0, 0,
	                        0,     0,     0,     1, 0
	                    });

	                canvas.DrawBitmap(bitmap, info.Rect, BitmapStretch.Uniform, paint: paint);
	            }
	        }
	    }
	}


## Transforms 转换
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/graphics/skiasharp/transforms/

从数学上来说，转换会按 SKCanvas 对象在绘图函数中指定的坐标和大小改变图形，转换通常非常适合用于绘制重复的图形或动画。 在旋转图形或文字，不使用转换的情况下是不现实的。

SkiaSharp 转换支持以下操作：

- 从一个位置转换到另一个位置的移位坐标
- 缩放坐标以增大或减小和大小
- 旋转坐标以围绕某个点旋转
- 倾斜以水平或垂直变换坐标，使矩形成为平行四边形

这些转换称为仿射转换 Affine Transforms。 仿射转换始终会保留平行线，而永远不会使坐标或大小变为无限大。 正方形永远不会转换为平行四边形以外的任何内容，一个圆圈永远不会转换为椭圆以外的任何内容。

仿射变换中集合中的一些性质保持不变：

- 凸性
- 共线性：若几个点变换前在一条线上，则仿射变换后仍然在一条线上
- 平行性：若两条线变换前平行，则变换后仍然平行
- 共线比例不变性：变换前一条线上两条线段的比例，在变换后比例仍然步

SkiaSharp 还支持基于标准的 3 x 3 变换矩阵的非仿射转换，也称为 Projective 或透视转换。 非仿射转换允许将正方形转换为任意凸四边形，这是一个四面，其所有内部角度小于180度。 非仿射转换可能会导致坐标或大小变为无限大，但对于三维效果至关重要。

Xamarin.Forms 支持类似于 SkiaSharp 中的转换，VisualElement 类定义下列转换属性：

- TranslationX 和 TranslationY
- Scale
- Rotation、RotationX 和 RotationY

SkiaSharp 和  Xamarin.Forms 的转换有几个重要的区别：

- SKCanvasView 派生自 VisualElement，在 SkiaSharp 将 SKCanvas 转换应用于单个派生对象，Xamarin.Forms 转换将应用到整个对象 VisualElement。

- SkiaSharp 变换相对于 SKCanvas 的左上角，而 Xamarin.Forms 变换相对 VisualElement 于其所应用到的的左上角。 当应用缩放和旋转转换时，这一区别非常重要，因为这些转换始终是相对于特定点的。

- 相当大的差别在于 SKiaSharp 转换是方法，而 Xamarin.Forms 转换是属性。

SkiaSharp 转换分解成以下几个部分：

- The Translate Transform 平移转换
- The Scale Transform 缩放转换
- The Rotate Transform 旋转转换
- The Skew Transform 倾斜转换
- Matrix Transforms 矩阵转换
- Touch Manipulations 触摸操作 使用矩阵变换实现触控操作，以便进行拖动、缩放和旋转。
- Non-Affine Transforms 非仿射转换
- 3D Rotation 三维旋转 使用非仿射转换在三维空间中旋转 2D 对象。


# Xamarin.Android 移动端特性


## Project Folder 目录结构

在资源目录下知类资源存放特定目录下：

- Properties 项目属性目录

	存放项目配置文件，其中 AndroidManifest.xml 是 Android 应用最重要的入口配置文件。

- Assets 用户资源目录

	使用里面的用户资源：

<!-- ```C# -->
	Typeface tf = Typeface.CreateFromAsset (Context.Assets, "fonts/samplefont.ttf");

	public class ReadAsset : Activity
	{
		protected override void OnCreate (Bundle bundle)
		{
			base.OnCreate (bundle);
			InputStream input = Assets.Open ("my_asset.txt");
		}
	}
<!-- ``` -->

-- Resources 基础资源文件夹

	存放工程资源，应用默认的资源目录，所有资源都会自动生成记录保存 Resource.designer.cs 文件中的 Resource 资源类定义中。

<!-- ```C# -->
	public partial class Resource {
		static Resource()
		{
			global::Android.Runtime.ResourceIdManager.UpdateIdValues();
		}
		public partial class Animation { ... }
		public partial class Animator { ... }
		public partial class Attribute { ... }
		public partial class Boolean { ... }
		public partial class Color { ... }
		public partial class Dimension { ... }
		public partial class Drawable { ... }
		public partial class Id { ... }
		public partial class Integer { ... }
		public partial class Interpolator { ... }
		public partial class Layout { ... }
		public partial class Mipmap { ... }
		public partial class String { ... }
		public partial class Style { ... }
		public partial class Styleable { ... }
		public partial class Xml { ... }
	 }
<!-- ``` -->

-- drawable 存放图片或矢量图等可以绘制的资源，如 SVG、PNG 图片，也可以存放 xml 定义的图片，如 splash.xml：
<!-- ``` -->

		<?xml version="1.0" encoding="utf-8" ?>
		<bitmap 
			android:gravity="fill" 
			android:layout_gravity="center" 
			android:src="@drawable/xamarin_logo" 
			xmlns:android="http://schemas.android.com/apk/res/android">
		</bitmap>
<!-- ``` -->

-- layout 存放视图配置;

--- 如 Toolbar.xml 工具条配置

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<android.support.v7.widget.Toolbar
		xmlns:android="http://schemas.android.com/apk/res/android"
		android:id="@+id/toolbar"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:background="?attr/colorPrimary"
		android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
		android:popupTheme="@style/ThemeOverlay.AppCompat.Light" />
<!-- ``` -->

--- 如 Tabbar.xml 选项卡配置

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<android.support.design.widget.TabLayout 
		xmlns:android="http://schemas.android.com/apk/res/android"
		xmlns:app="http://schemas.android.com/apk/res-auto"
		android:id="@+id/sliding_tabs"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:background="?attr/colorPrimary"
		android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
		app:tabIndicatorColor="@android:color/white"
		app:tabGravity="fill"
		app:tabMode="fixed" />
<!-- ``` -->


-- values 存放预定义值配置;

--- 如 colors.xml 定义颜色值：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<resources>
		<color name="launcher_background">#FFFFFF</color>
		<color name="colorPrimary">#3F51B5</color>
		<color name="colorPrimaryDark">#303F9F</color>
		<color name="colorAccent">#FF4081</color>
	</resources>
<!-- ``` -->

--- 如 styles.xml 定义主题样式：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<resources>
		<style name="MainTheme" parent="MainTheme.Base">
		</style>
		<!-- Base theme applied no matter what API -->
		<style name="MainTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar">
			<item name="windowNoTitle">true</item>
			<item name="windowActionBar">false</item>
			<!-- Set theme colors from https://aka.ms/material-colors -->
			<item name="colorPrimary">#2196F3</item>
			<item name="colorPrimaryDark">#1976D2</item>
			<item name="colorAccent">#FF4081</item>

			<item name="colorControlNormal">#282828</item>
			<item name="colorControlActivated">#E0E0E0</item>
			<item name="colorControlHighlight">#E0E080</item>
			<item name="colorSwitchThumbNormal">#808080</item>

			<item name="windowActionModeOverlay">true</item>

			<item name="android:datePickerDialogTheme">@style/AppCompatDialogStyle</item>
		</style>
		<style name="AppCompatDialogStyle" parent="Theme.AppCompat.Light.Dialog">
			<item name="colorAccent">#FF4081</item>
		</style>
		<style name="Theme.Splash" parent="android:Theme.Holo.Light">
			<item name="android:windowBackground">@drawable/splash</item>
			<item name="android:windowNoTitle">true</item>
			<item name="android:windowIsTranslucent">false</item>
			<item name="android:windowIsFloating">false</item>
			<item name="android:backgroundDimEnabled">true</item>
		</style>
	</resources>
<!-- ``` -->

- xml 存放其它 xml 配置文件;


此外，位图资源按分辨适配分成不同目录，优先查找 dpi 匹配资源，其次更高 dpi，再找更低 dpi：

- mipmap-anydpi-v26 Android 8.0 应用图标适配任意 DPI；
- mipmap-ldpi	QVGA 120dpi 参考分辨率 240x320
- mipmap-mdpi	HVGA 160dpi 参考分辨率 320x480
- mipmap-hdpi	WVGA 240dpi 参考分辨率 480x800、480x854 (FWVGA 480×854)
- mipmap-xhdpi	720P 320dpi 参考分辨率 960x720 以上 1280×720
- mipmap-xxhdpi	1080P 480dpi 参考分辨率 (HD 1920x1080)
- mipmap-xxxhdpi 4K 640dpi 参考分辨率 3840×2160

字母简写 l - Low, m - Middle, h - Hight, x - Extra。以 mdpi 为基准 Baseline，它的设备像素密度 density = 1，1px = 1dp，hdpi 密度 1.5，1px = 1.5 如此。

设备像素密度单位点密度 DPI - dots per inch，也用像素密度单位 PPI - pixels per inch。每英寸的像素点数越高显示越细腻，假如一块屏幕大小是 5 英寸，分辨率 1080×1920，按勾股定理两直角边长平方为对角线平方，得出对角线的像素数大约是 2203，那么用 2203 除以 5 计算结果是 440dpi，这样的屏幕已经算相当细腻。

DP - density-independent pixel 是物理度量单位，与设备像素的关系依据是 DPI。设备 DPI 超高，同样 DP 覆盖的区域像素点就越多，即一个 DP 对应的像素数量和 DPI 成正比，在 mdpi 设备中，定义 1dp = 1px，在 xhdpi 设备中 1dp = 2px。

有个 9-patch 工具，可以用来绽放位图，它通过九宫格划分位图，用周边的黑色标记线段定义可以拉伸的区域，保持四角和中心不缩放，文件名以 9.png 后缀。

AndroidManifest.xml 文件 Menifest 中添加子元素设置：

- `android:anyDensity="true"` 在不同密度的终端，程序会加载各个 dpi 文件夹中的资源。
- `android:anyDensity="false"`不去各种 dpi 文件夹下寻找资源。

在 Android 8 即 API SDK 26 中引入应用图标适配，会为您的应用程序创建一个自适应图标。应用程序的图标被分为了前景层和背景层。在设计应用图标的时候，需要将前景和背景分离，前景用来展示应用图标的 Logo，背景用来衬托应用图标的Logo。需要注意的是，背景层在设计的时候只允许定义颜色和纹理，但是不能定义形状。

Android 8.0 系统自适应应用图标的标准写法如下，先在 AndroidManifest.xml 清单文件设置 icon，另外 roundIcon 是适用在 Android 7.1 系统上的过渡属性，不管它：

<!-- ```xml -->
	<manifest xmlns:android="http://schemas.android.com/apk/res/android"
		package="com.example.icontest">

		<application
			android:allowBackup="true"
			android:icon="@mipmap/ic_launcher"
			android:roundIcon="@mipmap/ic_launcher_round"
			android:label="@string/app_name"
			android:supportsRtl="true"
			android:theme="@style/AppTheme">
			<activity android:name=".MainActivity">
				<intent-filter>
					<action android:name="android.intent.action.MAIN" />
					<category android:name="android.intent.category.LAUNCHER" />
				</intent-filter>
			</activity>
		</application>
	</manifest>
<!-- ``` -->

添加一个 res/mipmap-anydpi-v26/ic_launcher.xml 文件，为 API 26+ 设备设置自适应图标，一般 ic_launcher_foreground 可以使用 SVG 矢量图案：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
		<background android:drawable="@drawable/ic_launcher_background"/>
		<foreground android:drawable="@mipmap/ic_launcher_foreground"/>
	</adaptive-icon>
<!-- ``` -->


@ 在 Android 里面是引用资源的意思，设置属性时各以上这些目录产生关联。


## Component Attributes

组件属性设置基础：

<!-- ```xml -->
	<TextView
		android:text="@string/tv_phone"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:textColor="@color/yellow"
		android:autoLink="phone"
		android:textSize="48px"
		android:id="@+id/tv_Color"
		android:gravity="center" />

	<EditText
		android:id="@+id/et_txt"
		android:layout_width="fill_parent"
		android:layout_height="wrap_content"
		android:inputType="phone"
		android:hint="@string/et_txt" />

	<ImageView
		android:src="@drawable/administrator"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:id="@+id/iv_change_url" />

	<Button
		android:id="@+id/btn_Call"
		android:layout_width="fill_parent"
		android:layout_height="wrap_content"
		android:text="@string/btn_ChangColor" />
<!-- ``` -->

`id="@+id/btn_Call"` 设置组件 ID 自动生成记录在 Resource.Id 类定义中，保存在 Resource.designer.cs 文件中，使用如下，当前类要实现 View.IOnClickListener 这个接口：

<!-- ```C# -->
	Button btn = FindViewById<Button>(Resource.Id.btn_Call);
	btn.SetOnClickListener(this);

	btn.Click += new EventHandler(OnButtonClick);

	public voi OnButtonClick(object sender, EventArgs args) ...

	public voi OnClick(View view)
	{
		Button btn = view as Button;
		btn.SetTextColor(Android.Graphics.Color.Brown);
	}
<!-- ``` -->

`text="@string/tv_phone"` 这里的意思就是引用在 Resources/Strings.xml 文件中定义的 name="tv_phone" 的资源。

`textColor="@color/yellow"` 属性的写法，表示引用 values/colors.xml 文件中定义 name="yellow" 的颜色。

`autoLink="phone"` 这个属性设置表示文字是电话号码就可以直接拨打。

`src="@android:drawable/ic_menu_gallery"` 指定 drawable 目录下的图片，不写扩展名，默认使用 png 文件。


## App on HTTPS
- https://stackoverflow.com/questions/45940861/android-8-cleartext-http-traffic-not-permitted
- https://koz.io/android-m-and-the-war-on-cleartext-traffic/
- https://www.jianshu.com/p/79f573bd0938#Android_9_cleartext-http
- [性能与安全](https://docs.microsoft.com/zh-cn/xamarin/cross-platform/deploy-test/performance)
- [传输层安全](https://docs.microsoft.com/zh-cn/xamarin/cross-platform/app-fundamentals/transport-layer-security)
- [ATS - App Transport Security 应用传输安全](https://docs.microsoft.com/zh-cn/xamarin/ios/app-fundamentals/ats)

ATS - App Transport Security 是从 iOS 9 开始引入的安全项，目的是普及使用 HTTPS，禁用 HTTP。

iOS 9 中默认强制使用 HTTPS，可以在 Info.plist 文件中加入以下节点关闭这个安全项，允许 App 使用 HTTP。

	<key>NSAppTransportSecurity</key>
	<dict>
	    <key>NSAllowsArbitraryLoads</key>
	    <true/>
	<dict>

iOS 10 中，苹果更加坚定地推行了ATS安全项，不允许开发者全局关闭ATS安全项，但是可以添加不受ATS限制的域名。下面配置项就是允许qq.com域名使用http，这样的配置比iOS9一刀切的方法更安全一些。

	<key>NSAppTransportSecurity</key>
	<dict>
	    <key>NSAllowsArbitraryLoads</key>
	    <true/>
	    <key>NSExceptionDomains</key>
	    <dict>
	        <key>qq.com</key>
	        <dict>
	            <key>NSExceptionAllowsInsecureHTTPLoads</key>
	            <false/>
	        </dict>
	    </dict>
	</dict>


使用 Xamarin 开发 Android 应用时，可能会遇到不允许明文 HTTP 请求异常，因为，从 Android 9.0 开始，出于完全因素考虑，默认不再支持 HTTP 网络请求，需要使用 HTTPS。

	java.io.IOException: Cleartext HTTP traffic to XXX not permitted

临时解决办法，修改 AndroidManifest.xml 以许可明文 HTTP，降低 android:targetSandboxVersion 版本降价安全要求：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<manifest android:targetSandboxVersion="1">
		<uses-permission android:name="android.permission.INTERNET" />
		<application
			...
			android:usesCleartextTraffic="true"
			android:networkSecurityConfig="@xml/network_security_config"
			...>
			...
		</application>
	</manifest>
<!-- ``` -->

或者创建网络安全配置文件 res/xml/network_security_config.xml 再由 AndroidManifest.xml 引入：

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8"?>
	<network-security-config>

		<domain-config cleartextTrafficPermitted="true">
			<domain includeSubdomains="true">127.0.0.1</domain>
			<domain includeSubdomains="true">192.168.0.101</domain>
		</domain-config>

		<base-config cleartextTrafficPermitted="true">
			<trust-anchors>
				<certificates src="system" overridePins="true" />
				<certificates src="user" overridePins="true" />
			</trust-anchors>
		</base-config>

	</network-security-config>
<!-- ``` -->


要为不同的链接提供更多配置，则必须提供 networkSecurityConfig 文件，例如，允许或者不允许某些域的 HTTP。

Android 7 系统默认不信任用户导入 CA 发放的证书，使用 Fiddler 抓取 HTTPS 请求包需要配置网络安全配置文件，信任用户导入的证书，再将服务提供的证书导入 Android 系统。

注意， android:networkSecurityConfig 配置中不能加 XML 扩展名。对于 Xamarin 项目来说 res 目录就是工程目录下的 `Resources` 目录，并添加到项目中。


从 Android 源代码可以清楚配置节点有三种名字：

<!-- ```C# -->
	private static final String getConfigString(int configType) {
		switch (configType) {
			case CONFIG_BASE:
				return "base-config";
			case CONFIG_DOMAIN:
				return "domain-config";
			case CONFIG_DEBUG:
				return "debug-overrides";
			default:
				throw new IllegalArgumentException("Unknown config type: " + configType);
		}
	}
<!-- ``` -->




在 Xamarin.Android 项目中，可以使用 Microsoft.Net.Http 包的 HTTPClient 对话 HTTPS 服务器。


All our service calls are HTTPS. Just use HTTPClient like you normally would (our app currently consumes 2 restful endpoints, both are HTTPS). The app runs on Android, iOS & UWP

https://www.nuget.org/packages/Microsoft.Net.Http

Just be careful if the HTTPS service supports TLS 1.1 or 1.2, there is more info on that here
https://developer.xamarin.com/guides/cross-platform/transport-layer-security/


## HTTPS Client & Server 双向认证
- https://www.cnblogs.com/axzxs2001/p/10070562.html

.Net Core 下用 HttpClient 和 ASP.Net Core Web 服务实现 HTTPS 的双向认证。

双向认证实现准备工作：

- 准备客户端证书 client.crt 用于在服务器验证客户身份；
- 准备服务端证书 server.crt 用于客户端验证服务器身份；
- 为了验证是否同一个根证书的验证，这两个证书可以共用一个根证书 root.crt。

首先，使用 OpenSSL 生成这些证书，这里采用了自签证书方式：

一、创建根证书

生成key文件，输入密码：

	openssl genrsa -des3 -out root.key 

生成请求证书文件，可以通过在下面命令后面添加 -config openssl.cfg 来指明配置文件路径

	openssl req -new -key root.key -out root.csr 

生成一个10年期根证书 root.crt:

	openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.csr -out root.crt 

分别在客户端或服务端安装根证书，Windows 上安装证书时，证书存储可选择“受信任的根证书颁发机构”


二、创建服务端证书

生成key文件，输入密码

	openssl genrsa -des3 -out server.key 2048 

生成请求证书文件

	openssl req -new -key server.key -out server.csr 

用根证书生成一个 10 年期证书 server.crt:

	openssl x509 -req -days 3650 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in server.csr -out server.crt 

生成个人信息交换格式证书文件 server.pfx

	openssl pkcs12 -export -in server.crt -inkey server.key -out server.pfx 

三、创建客户端证书

生成key文件，输入密码

	openssl genrsa -des3 -out client.key 2048 

生成请求证书文件

	openssl req -new -key client.key -out client.csr 

用根证书生成一个10年期证书 client.crt:

	openssl x509 -req -days 3650 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in client.csr -out client.crt 

生成.net core识别的证书文件client.pfx

	openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx 

接下来创建 ASP.Net Core web API 项目，并把 server.pfx 添加到项目中，并设置属性为“始终复制”，接着修改 Program.cs 下的 CreateWebHostBuilder 方法就可以：

	public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
	WebHost.CreateDefaultBuilder(args)
	  .UseKestrel(options =>
	  {
	      options.Listen(IPAddress.Any, 80);
	      //启用https，443端口
	      options.Listen(IPAddress.Any, 443, listenOptions =>
	      {
	          var serverCertificate = new X509Certificate2("server.pfx", "ssssss");
	          var httpsConnectionAdapterOptions = new HttpsConnectionAdapterOptions()
	          {
	              ClientCertificateMode = ClientCertificateMode.AllowCertificate,
	              SslProtocols = System.Security.Authentication.SslProtocols.Tls12,
	              //用chain.Build验证客户端证书
	              ClientCertificateValidation = (cer, chain, error) =>
	               {   
	                   return chain.Build(cer); 
	               },
	              ServerCertificate = signingCertificate
	          };
	          listenOptions.UseHttps(httpsConnectionAdapterOptions);
	      });
	  })
	  .UseStartup<Startup>();

为了区分 HTTP 和 HTTPS 请求，在 HomeController 中写如下代码：

	[HttpGet]
	public ActionResult<IEnumerable<string>> Get()
	{
	    var cer = HttpContext.Connection.ClientCertificate;  
	    if (cer == null)
	    {
	        return BadRequest();
	    }
	    else
	    {
	        return new string[] { "value1", "value2" };
	    }
	}

创建客户端控制台项目，把 client.pfx 添加到项目中，并设置属性为“始终复制”，然后代码如下

	static void Main(string[] args)
	{
	 Console.WriteLine("enter start");
	 while (true)
	 {
	     try
	     {
	         Console.WriteLine("1、Https   2、Http");
	         switch (Console.ReadLine())
	         {
	             case "1":
	                 HttpsMethod();
	                 break;
	             case "2":
	                 HttpMethod();
	                 break;
	         }
	         void HttpsMethod()
	         {
	             var handler = new HttpClientHandler();
	             handler.ClientCertificateOptions = ClientCertificateOption.Manual;
	             handler.SslProtocols = SslProtocols.Tls12 | SslProtocols.Tls | SslProtocols.None | SslProtocols.Tls11;
	             try
	             {
	                //加载客户端证书
	                 var crt = new X509Certificate2(Directory.GetCurrentDirectory() + "/client.pfx", "cccccc"); 
	                 handler.ClientCertificates.Add(crt);
	             }
	             catch (Exception e)
	             {
	                 Console.WriteLine(e.Message);
	             }
	             //用chain.Build验证服务器证书
	             handler.ServerCertificateCustomValidationCallback = (message, cer, chain, errors) =>
	             {                           
	                 return  chain.Build(cer);                           
	             };
	             var client = new HttpClient(handler);
	             var url = "https://192.168.252.41 /api/values";
	             var response = client.GetAsync(url).Result;
	             Console.WriteLine(response.IsSuccessStatusCode);
	             var back = response.Content.ReadAsStringAsync().Result;
	             Console.WriteLine(back);
	         }
	         void HttpMethod()
	         {
	             var client = new HttpClient();
	             var url = "http://192.168.252.41/api/values";
	             var response = client.GetAsync(url).Result;
	             Console.WriteLine(response.IsSuccessStatusCode);
	             var back = response.Content.ReadAsStringAsync().Result;
	             Console.WriteLine(back);
	         }
	     }
	     catch (Exception exc)
	     {
	         Console.WriteLine(exc.InnerException?.InnerException?.Message);
	     }
	 }
	}



## Splash Screen
- https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/splashscreen
- https://docs.microsoft.com/zh-cn/xamarin/android/user-interface/splash-screen
- https://www.cnblogs.com/swjian/p/9993806.html
- https://blog.csdn.net/aa464971/article/details/86692198
- https://docs.microsoft.com/zh-cn/xamarin/ios/app-fundamentals/images-icons/launch-screens?tabs=windows

打开软件的时候相当慢，会有白屏显示，这样的用户体验效果不好，以下按步骤增加一个启动页。

在本机启动序列完成后，会在每个平台上初始化 Xamarin：

- Android 上 MainActivity 类的 OnCreate 方法。
- 在 iOS 上 AppDelegate 类的 FinishedLaunching 方法中。
- 在 UWP 上 App 类的 OnLaunched 方法中。

第一步

创建一个 SplashScreen.cs 类替代 MainActivity 作为程序开启第一个装载的类，再由它装入 Activity。修改 Xamarin.Android 项目中 MainActivity.cs 类，去掉其 `MainLauncher = true` 即取消其作为启动时首先载入的类。

<!-- ```C# -->
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;

	using Android.App;
	using Android.Content;
	using Android.OS;
	using Android.Runtime;
	using Android.Views;
	using Android.Widget;
	using Android.Content.PM;

	namespace XamarinVS2019.Droid
	{
		[Activity(MainLauncher = true, NoHistory = true, Theme = "@style/Theme.Splash", ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)]
		public class SplashScreen : Activity
		{
			protected override void OnCreate(Bundle bundle)
			{
				base.OnCreate(bundle);
				var intent = new Intent(this, typeof(MainActivity));
				StartActivity(intent);
				Finish();
			}
		}
	}
<!-- ``` -->


第二步

根据自己需求准备一张 slogan.png 图片，用于启动展示加载示例图案，放在 Drawable 文件夹下并添加到工程中。

并在 Drawable 文件夹下创建 splashscreen.xml，用于展示 slogan.png 图片，注意指定 android:src 属性不需要扩展名。

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
		<bitmap 
			android:gravity="fill" 
			android:layout_gravity="center" 
			android:src="@drawable/slogan" 
			xmlns:android="http://schemas.android.com/apk/res/android">
	</bitmap>
<!-- ``` -->


第三步

在 values 文件夹下的 styles.xml 添加 `Theme.Splash` 自定义显示主题定义。

<!-- ```xml -->
	<?xml version="1.0" encoding="utf-8" ?>
	<resources>
	  <style name="Theme.Splash"
		parent="android:Theme.Holo.Light">
		<item name="android:windowBackground">@drawable/loadingscreen</item>
		<item name="android:windowNoTitle">true</item>
		<item name="android:windowIsTranslucent">false</item>
		<item name="android:windowIsFloating">false</item>
		<item name="android:backgroundDimEnabled">true</item>
	  </style>
	</resources>
<!-- ``` -->



如果放一张尺寸的图在某些屏幕上就会出现拉伸，并且 windowBackground 不能设置 ImageView 的属性 android:scaleType centerCrop，就算通过资源限定符也不能完美的适配。

禁止横竖屏变换：

<!-- ```C# -->
	this.RequestedOrientation = Android.Content.PM.ScreenOrientation.Portrait;
	this.RequestedOrientation = Android.Content.PM.ScreenOrientation.Nosensor;

	if (getResources().getConfiguration().orientation==Configuration.ORIENTATION_LANDSCAPE) 
	p_w_picpathView.setBackgroundDrawable(getResources().getDrawable(R.drawable.p_w_picpath_land)); 
	else 
	p_w_picpathView.setBackgroundDrawable(getResources().getDrawable(R.drawable.p_w_picpath)); 
<!-- ``` -->


还可以，通过 values-land 目录设置资源用在横屏状态。


通过 layer-list 来实现图片居中 gravity="center" 或置底 gravity="bottom" ，修改 drawable 下的 splashscreen.xml：

	<?xml version="1.0" encoding="utf-8"?>
	<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
		<item>
			<shape android:shape="rectangle">
				<solid android:color="@android:color/white" />
			</shape>
		</item>
		
		<item android:bottom="@dimen/margin_vertical_splash">
			<bitmap
				android:gravity="bottom"
		        android:tileMode="disabled"
				android:src="@drawable/loading" />
		</item>
	</layer-list>


新建一个 Splash 主题，windowBackground 设置成刚刚建的 splashscreen.xml

	<style name="AppTheme.Splash" parent="Theme.AppCompat.Light.NoActionBar">
		<item name="android:windowFullscreen">true</item>
		<item name="android:windowBackground">@drawable/splash</item>
	</style>

将 SplashScreen 设成 Splash 主题

	<activity
		android:name=".SplashScreen"
		android:theme="@style/AppTheme.Splash">
		<intent-filter>
			<action android:name="android.intent.action.MAIN" />
			<category android:name="android.intent.category.LAUNCHER" />
		</intent-filter>
	</activity>

在 Androidd 5.0 后增加了一个 windowDrawsSystemBarBackgrounds 属性，用来标志此窗口是否负责绘制系统栏背景，把它设成 false 绘制 windowBackground 的时候，内容就会在 NavigationBar 之上。

因为这个属性是 5.0 以后才有的，所以需要新建 values-v21 文件夹，以便 5.0 以上的机器使用 v21 的 Splash 主题。

	<style name="AppTheme.Splash" parent="Theme.AppCompat.Light.NoActionBar">
		<item name="android:windowFullscreen">true</item>
		<item name="android:windowBackground">@drawable/splash</item>
		<item name="android:windowDrawsSystemBarBackgrounds">false</item>
	</style>

因为主题中设置的 windowBackground，可以不需要在  Activity 中再放 slogan 图片了，只需要放一个广告图片，设置 marginBottom 给 slogan 留出位置就可以

	<?xml version="1.0" encoding="utf-8"?>
	<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
		android:layout_width="match_parent"
		android:layout_height="match_parent">

		<ImageView
			android:layout_width="match_parent"
			android:layout_height="match_parent"
			android:layout_marginBottom="120dp"
			android:scaleType="centerCrop"
			android:src="@drawable/ad" />
	</RelativeLayout>




## Reboot Run App 开机自动运行
https://www.jb51.net/article/88649.htm

修改 AndroidManifest.xml 文件，增加接收 RECEIVE_BOOT_COMPLETED 广播消息的权限，增加接收器注册，指定接收器的类名，当前命名空间注意需要在前面加点：

	<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
	<application android:allowBackup="true" android:label="@string/app_name">
		<receiver android:enabled="true" android:name=".BootReceiver">
			<intent-filter>
				<action android:name="android.intent.action.ACTION_BOOT_COMPLETED" />
			</intent-filter>
		</receiver>
	</application>

接收器实现，一定要使用前两行特性，否则程序一直意外关闭：

	[BroadcastReceiver]
	[IntentFilter(new[] { Intent.ActionBootCompleted })]
	public class BootReceiver:BroadcastReceiver
	{
		public override void OnReceive(Context context, Intent intent)
		{
			//throw new System.NotImplementedException();
			//Toast.MakeText(context, "test", ToastLength.Short).Show();
			Intent _intent = new Intent();
			_intent.SetClass(context, typeof(MainActivity));
			_intent.SetFlags(ActivityFlags.NewTask);
			context.StartActivity(_intent);
		}
	}


跟原生的做法一样，继承 BroadcastReceiver 类，在 OnReceive 中做开机自启动(或者其他事情)。

	namespace Test.Droid
	{
	 public class BootReceiver:BroadcastReceiver
		{
		   public override void OnReceive(Context context, Intent intent)
		   {
			   //Toast.MakeText(context, "接收到开机广播", ToastLength.Long).Show();
			   Intent _intent = context.PackageManager.GetLaunchIntentForPackage(包名);          
			   context.StartService(_intent);    
		   }
		}
	}

添加权限和配置，AndroidManifest 文件配置如下：

	<application>
		<receiver android:enabled="true" android:name="test.droid.BootReceiver">
		  <intent-filter>
			<action android:name="android.intent.action.BOOT_COMPLETED" />
			<category android:name="android.intent.category.LAUNCHER" />
		  </intent-filter>
		</receiver>
	</application>
	<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>


## Retry to Quit 再按一次退出

通过按键事件 OnKeyDown 处理 Keycode.Back 来实现二次返回按钮即出程序。

<!-- ```C# -->
	using System;
	 
	using Android.App;
	using Android.Content;
	using Android.Runtime;
	using Android.Views;
	using Android.Widget;
	using Android.OS;
	 
	namespace MyXamarinApp
	{
		[Activity(Label = "MyXamarinApp", MainLauncher = true, Icon = "@drawable/icon")]
		public class Activity1 : Activity
		{
			protected override void OnCreate(Bundle bundle)
			{
				base.OnCreate(bundle);
	 
				// Set our view from the "main" layout resource
				SetContentView(Resource.Layout.Main);
			}
	 
			DateTime? lastBackKeyDownTime;
	 
			public override bool OnKeyDown(Keycode keyCode, KeyEvent e)
			{
				if (keyCode == Keycode.Back && e.Action == KeyEventActions.Down)
				{
					if (!lastBackKeyDownTime.HasValue || DateTime.Now - lastBackKeyDownTime.Value > new TimeSpan(0, 0, 2))
					{
						Toast.MakeText(this.ApplicationContext, "再按一次退出程序", ToastLength.Short).Show();
						lastBackKeyDownTime = DateTime.Now;
					}
					else
					{
						Finish();
					}
					return true;
				}
				return base.OnKeyDown(keyCode, e);
			}
		}
	}
<!-- ``` -->


## Notification & Dialogs 对话框
- [Xamarin.Forms 中的本地通知](https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/local-notifications#consume-the-interface-in-xamarinforms)

数据组件、意图INTENT、控制器、广播 https://www.cnblogs.com/xtxk110/p/12156321.html
VS/Xamarin Android入门（服务、数据存储）五 - 天心~ - 博客园 https://www.cnblogs.com/xtxk110/p/12156348.html
生命周期管理 https://www.cnblogs.com/xtxk110/p/12174657.html
服务的生命周期 https://www.cnblogs.com/xtxk110/p/12174727.html
NotificationManager服务 https://www.cnblogs.com/xtxk110/p/12174756.html
广播接收器与绑定服务 https://www.cnblogs.com/xtxk110/p/12174783.html
ActionBar与菜单 https://www.cnblogs.com/xtxk110/p/12174896.html
SQLiteOpenHelper https://www.cnblogs.com/xtxk110/p/12174952.html
ContentProvider https://www.cnblogs.com/xtxk110/p/12174978.html
百度地图集成 https://www.cnblogs.com/xtxk110/p/12174963.html
ListView和Adapter https://www.cnblogs.com/xtxk110/p/12175059.html
PreferenceManager https://www.cnblogs.com/xtxk110/p/12175074.html
Fragment Walkthrough https://www.cnblogs.com/xtxk110/p/12175094.html
GPS Locate https://www.cnblogs.com/xtxk110/p/12175104.html
SlidingMenu https://www.cnblogs.com/xtxk110/p/12175130.html



# Game - Picross DS
- [Picross DS](https://www.nintendo.co.jp/ds/axpj/)

- 类似扫雷+数独，每个谜题都是包含一张隐藏图片的方块图阵；
- 在逻辑方块游戏中，系统会在方块的左边和顶部提供数字提示，表示该行或列应该连续标记的方块数量；
- 如果有多个数字提示，比如 2 3，表示该行或列需连续标记 2 个方块，然后空出N个格子，接着连续标记3个方块；

Nonogram 是 1987 年由日本人西尾彻也发明的。在日本，Nonogram 的名称是“お絵かきロジック”，意思是以数绘画。Nonogram 初见于日本的谜题杂志，玩家用纸和笔来玩。随后，任天堂以 Mario’s Picross 为名推出了两款 Game Boy 和九款超级任天堂游戏。现时 NDS 上亦有名为 Picross DS 的同款游戏。

# Game of Life
- [生命游戏 Game of Life](https://playgameoflife.com/)
- [Gunstar - Game of Life/](https://copy.sh/life/)
- [A CLOCK CREATED WITH CONWAY’S LIFE by Adam Fabio](https://hackaday.com/2017/03/11/a-clock-created-with-conways-life/)

康威生命游戏 Conway's Game of Life 是一种多联骨牌游戏，是数学家 John Conway 在 1970 发明的数学游戏，并在美国科学界流行。

生命游戏并不是通常意义上的游戏, 它没有游戏玩家各方之间的竞争, 也谈不上输赢。因为它模拟和显示的图象，看起来颇似生命的出生和繁衍过程而得名为生命游戏。界面在一个类似于围棋棋盘一样的，可以无限延伸的二维方格网中进行。例如，设想每个方格中都可放置一个生命细胞，生命细胞只有生或死两种状态。用黑色的方格表示该细胞为生, 白色表示该细胞为死。游戏开始前设置生的细胞，点击开始运行，根据某种生存定律计算下一代每个细胞的状态。

生存定律示范：

- 九宫格上中心点细胞由周围八个细胞的状态所决定；
- 细胞周围有 3 个活细胞则生，否则为死；
- 如果一个细胞周围有 2 个活细胞，则该细胞的生死状态保持不变；
- 在其它情况下，该细胞为死，即该细胞若原先为生，则转为死，若原先为死，则保持不变。

演变的结果：一类是最终会走向死亡，完全消失的图案；另一类是永远不定变化的情形。死的速度有快有慢，有的昙花一现，有的繁荣昌盛几百上千代。有趣的是，老不死的图案，如四方块 Block，或三连，这两个分图案如果单独存在，都会长生不死，纠集在一块儿后可能就繁衍几代就死了，这揭示的也许不是聚散存亡的道理。

我试了一个 T 形图案的演变，很意思演变有时心形有时像脸，后来了解到别人叫这个为多联骨牌 Polyomino，即各个方块至少有一边联接而成的图案，俄罗斯方块游戏就是四联骨牌。骨牌的对称变换、镜像看作同一种，那么一联、二联各有 1 种，三联 2 种，四联 5 种，五联 12 种。最著名的 R-五联骨牌，Conway 用纸笔调查 12 个 5 联骨牌的命运，特意给它们按照形象，用英语字母 O 到 Z 起了 12 个名字。只有 R-五联骨牌演变最有意思，可活 1103 代，当年 Conway 在发表游戏的时候，只用纸笔验算到 400 多代，实在验算不下去了，称之为 unknown pentomino，其他的五联骨牌都只用几步就稳定下来了。


实现这个数学游戏，需要以下三个部分：

- 通过继承 BoxView 组件扩展出 LifeCell

	封装了单个单元的逻辑，提供 IsAlive 方法设置相应状态的色彩。并为 BoxView 的 GestureRecognizers 属性设置一个手势识别组件实现用户交互界面。游戏逻辑组件负责处理交互事件的效果，根据结果来决定活动单元的生存状态。

- 实现一个 LifeGrid 类来管理生命方块

	这个类的游戏的逻辑实现，负责接收用户交互的结果响应和运行时的各单元状态演变。 提供 IsAlive 方法按规则断定单元的生存状态，。

- 实现一个视图页面来加载以上两组件

	提供交互界面，如运行、暂停等按钮，方块的交互事件发生后，进行逻辑上的状态处理，调用 LifeGrid 的 SetStatus 更改方块状态。

	运行按钮启动设备的定时器执行任务，执行 LifeGrid 的 Tick 方法和 IsAlive 执行演变：

        Device.StartTimer(TimeSpan.FromMilliseconds(250), OnTimerTick);

	提供一个信息获取按钮，点击后打开 URL 页面：

        await Launcher.OpenAsync(label.Text);



LifeCell.cs：

<!-- ```C# -->
	using System;
	using Xamarin.Forms;

	class LifeCell : BoxView
	{
	    bool isAlive;

	    public event EventHandler Tapped;

	    public LifeCell()
	    {
	        BackgroundColor = Color.White;

	        TapGestureRecognizer tapGesture = new TapGestureRecognizer();
	        tapGesture.Tapped += (sender, args) =>
	        {
	            Tapped?.Invoke(this, EventArgs.Empty);
	        };
	        GestureRecognizers.Add(tapGesture);
	    }

	    public int Col { set; get; }

	    public int Row { set; get; }

	    public bool IsAlive
	    {
	        set
	        {
	            if (isAlive != value)
	            {
	                isAlive = value;
	                BackgroundColor = isAlive ? Color.Black : Color.White;
	            }
	        }
	        get
	        {
	            return isAlive;
	        }
	    }
	}
<!-- ``` -->


<!-- ```C# -->
	using System;
	using System.Collections.Generic;

	namespace GameOfLife
	{
	    class LifeGrid
	    {
	        // Changed to true for grid-wrapping logic
	        const bool Wrap = false;

	        // Internal structure for encapsulting integer cell coordinates
	        // Keep this a structure for automatic equality comparison!
	        struct Coordinate
	        {
	            public Coordinate(int x, int y)
	            {
	                X = x;
	                Y = y;
	            }

	            public int X { private set; get; }

	            public int Y { private set; get; }
	        }

	        // The current population is stored in two ways, 
	        //  both of which are valid and consistent after every method call.

	        // This is a List of the coordinates of living cells:
	        List<Coordinate> coordinates = new List<Coordinate>();

	        // This is an array for for performing the Tick algorithm efficiently:
	        int cols = 10;
	        int rows = 10;
	        bool[,] grid = new bool[10, 10];

	        public void SetSize(int cols, int rows)
	        {
	            if (cols <= 0 || rows <= 0)
	                throw new ArgumentException("LifeGrid.SetSize: Arguments must be greater than zero");

	            // If !Wrap, remove items from coordinates if X or Y greater than new cols and rows
	            if (!Wrap)
	            {
	                List<Coordinate> removeList = new List<Coordinate>();
	                foreach (Coordinate coordinate in coordinates)
	                {
	                    if (coordinate.X < 0 || coordinate.X >= cols ||
	                        coordinate.Y < 0 || coordinate.Y >= rows)
	                    {
	                        removeList.Add(coordinate);
	                    }
	                }
	                foreach (Coordinate coordinate in removeList)
	                {
	                    coordinates.Remove(coordinate);
	                }
	            }


	            this.cols = cols;
	            this.rows = rows;
	            CreateGridArray();
	        }

	        public void SetStatus(int x, int y, bool isAlive)
	        {
	            Coordinate coordinate = new Coordinate(x, y);

	            if (isAlive && !coordinates.Contains(coordinate))
	            {
	                coordinates.Add(coordinate);
	            }
	            if (!isAlive && coordinates.Contains(coordinate))
	            {
	                coordinates.Remove(coordinate);
	            }

	            CreateGridArray();
	        }

	        public bool IsAlive(int x, int y)
	        {
	            return grid[x, y];
	        }

	        public void Clear()
	        {
	            coordinates.Clear();
	            CreateGridArray();
	        }

	        public bool Tick()
	        {
	            coordinates.Clear();

	            if (grid == null)
	                return false;

	            for (int x = 0; x < cols; x++)
	            for (int y = 0; y < rows; y++)
	            {
	                int count = 0;

	                for (int xi = x - 1; xi <= x + 1; xi++)
	                for (int yi = y - 1; yi <= y + 1; yi++)
	                {
	                    if (Wrap)
	                    {
	                        count += grid[(xi + cols) % cols, (yi + rows) % rows] ? 1 : 0;
	                    }
	                    else
	                    {
	                        if (xi >= 0 && yi >= 0 && xi < cols && yi < rows)
	                        {
	                            count += grid[xi, yi] ? 1 : 0;
	                        }
	                    }
	                }

	                if (count == 3 || (count == 4 && grid[x, y]))
	                {
	                        // Modulo arithmetic is necessary when Wrap is true
	                        coordinates.Add(new Coordinate(x % cols, y % rows));
	                }
	            }

	            CreateGridArray();

	            return coordinates.Count > 0;
	        }

	        void CreateGridArray()
	        {
	            if (rows <= 0 || cols <= 0)
	            {
	                grid = null;
	                return;
	            }

	            grid = new bool[cols, rows];

	            foreach (Coordinate coordinate in coordinates)
	            {
	                // Modulo arithmetic is necessary when Wrap is true
	                grid[coordinate.X % cols, coordinate.Y % rows] = true;
	            }
	        }
	    }
	}
<!-- ``` -->

<!-- ```C# -->
<!-- ``` -->

