#!/usr/bin/env bash

manual='/C/Program Files/ImageMagick-7.1.1-Q16-HDRI/www/index.html'
docdir="$(dirname "$manual")"

html2md()
{
    while read manual; do
        cat "$docdir/$manual" | /c/opendocs/html2md.ts >> $0
    done <<EOF
    links.html
    sitemap.html
EOF
    pushd "$(dirname "$manual")" >/dev/null
}

manual_page()
{
    while read file; do
        echo $file
        cat "$file" | grep '<(Title\|title)>'
    done <<<$(ls *.html)
}
curl -L "https://imagemagick.org/Usage/" | /od/html2md.ts | clip


exit
=============================================================================

    \((?!http)[^)]+\)

```sh
if ! [[ -d  /od/pictures ]]; then
    mkdir /od/pictures
fi
pushd /od/pictures


magick -size 320x420 xc:lightblue -pointsize 70 -font SimHei \
      -fill red -stroke none                 -draw 'text 30,80  "Stroke -"' \
      -fill red -stroke black -strokewidth 0 -draw 'text 30,160 "Stroke 0"' \
      -fill red -stroke black -strokewidth 1 -draw 'text 30,240 "Stroke 1"' \
      -fill red -stroke black -strokewidth 2 -draw 'text 30,320 "Stroke 2"' \
      -fill red -stroke black -strokewidth 3 -draw 'text 30,400 "Stroke 3"' \
      stroke_table.svg
# subl $0 
ls -la /od/pictures
sleep 6
```



/TOC
=====
0. https://github.com/imagemagick/imagemagick
0. ImageMagick Doc https://imagemagick.org/script/index.php
1. Examples of ImageMagick Usage https://www.imagemagick.org/Usage/
2. Fred's ImageMagick Scripts http://www.fmwconcepts.com/imagemagick/index.php
3. MIT 6.869 Advances in Computer Vision http://6.869.csail.mit.edu/sp22
3. 计算机视觉图像处理 https://www.bilibili.com/video/BV1Kk4y1W7aU/
4. Szeliski, Computer Vision: Algorithms and Applications
5. Microsoft Research Asia (MSRA) Kaiming He(何恺明) Deep Residual Learning for Image Recognition


- Installation
    - [Download]: download.html
    - [Install from Source]: install-source.html
    - [Advanced Linux Source Installation]: advanced-linux-installation.html
    - [Advanced Unix Source Installation]: advanced-unix-installation.html
    - [Advanced Windows Source Installation]: advanced-windows-installation.html
- Examples of ImageMagick Usage https://imagemagick.org/Usage/
    - ----    **Practical Examples**    -----
    *  [Basic Usage]  Basic command and image handling
    *  [Image File Handling]  Reading and writing images
    *  [Common Image Formats]  Handling GIF, JPEG, and PNG images
    *  [Text to Image Handling]  Converting text into images
    *  [Compound Font Effects]  Font drawing styles and techniques
    *  [Annotating Images]  Labeling and overlaying images
    *  [Thumbnails and Framing]  Small reference images of large photos
    *  [Photo Handling]  Modifying photographs
    *  [Lens Correction]  Correcting photo distortions
    *  [Montage, Arrays of Images]  Image indexes and arrays
    *  [Layers of Multiple Images]  Combining multiple images together
    *  [Animation Basics]  Creation and study of animations
    *  [Animation Optimization]  Making GIF animations smaller
    *  [Animation Modifications]  Changing and merging animations
    *  [Video Handling]  Handling real life video images
    *  [Image Comparing]  Comparing two or more images
    *  [Advanced Techniques]  Complex manipulations of images
    *  [Background Examples]  Examples of creating random backgrounds
    *  [Repositories Links]  Links to other IM scripts and info
    *  [Reference Index]  Quick index for specific options
    *  [Support Scripts]  Shell scripts used by examples
    - ----  **Basic Techniques**  -----
    *  [Canvas Creation]  Creating canvas and background images
    *  [Color Basics and Channels]  Low level color handling
    *  [Color Modifications]  General color changes
    *  [Masking and Background Removal]  Alpha channel, and transparency handling
    *  [Color Quantization and Dithering]  Reducing the number of colors
    *  [Cutting and Bordering]  Slicing, dicing, framing, trimming
    *  [Resizing or Scaling]  Enlarging and shrinking images
    *  [Resampling Filters]  Controlling image resizing
    *  [Compositing Images]  Overlaying and merging two images
    *  [Drawing on Images]  Vector graphics, MVG and SVG images
    *  [Simple Image Warping]  Flipping, rotating, twisting
    *  [Distorting Images]  Carnival house of mirrors
    *  [Image Transformations]  Drastic changes to the look of an image
    *  [Image Mapping Effects]  Lens, glass and ripple effects
    *  [Blurring and Sharpening Images]  Blurring, sharpening and shadows
    *  [Morphology of Shapes]  Using pixel neighbourhoods
    *  [Convolution of Images]  Weighted averaged neighbourhoods
    *  [Fourier Transforms]  Modifying images in the frequency domain
    *  [Anti-Aliasing]  Anti-aliasing effects and problems
    *  [Miscellaneous]  Bits and pieces
    *  [APIs, Scripting, Building]  Usage in other environments
    *  [Usage under Windows]  IM on Windows PC
    *  [Development and Bugs]  Development proposals and bugs, new and old
- Image Processing
    - [Architecture]: architecture.html
    - [Examples of ImageMagick Usage]: examples.html
    - [Defines]: defines.html
    - [The FX Special Effects Image Operator]: fx.html
    - [Image Gradients]: gradient.html
    - [Image Formats]: formats.html
    - [Motion Picture Digital Images]: motion-picture.html
    - [WebP Encoding Options]: webp.html
    - [JP2 Encoding Options]: jp2.html
    - [Magick Image File Format]: miff.html
    - [Magick Vector Graphics]: magick-vector-graphics.html
    - [High Dynamic-Range Images]: high-dynamic-range.html
    - [Encipher or Decipher an Image]: cipher.html
    - [Color Management]: color-management.html
    - [Color Thresholding]: color-thresholding.html
    - [Color Names]: color.html
    - [Alpha Compositing]: compose.html
    - [Contrast Limited Adaptive Histogram Equalization]: clahe.html
    - [Color Reduction Utilizing Adaptive Spatial Subdivision]: quantize.html
    - [Connected Components Labeling]: connected-components.html
    - [Convex Hull]: convex-hull.html
- CLI - Command-line Interface
    - [Command-line Tools]: command-line-tools.html
    - [Format and Print Image Properties]: escape.html
    - [Exceptions]: exception.html
    - [Command-line Options]: command-line-options.html
    - [Command-line Processing]: command-line-processing.html
    - [Command-line Tools: Magick-script]: magick-script.html
    - [Command-line Tools: Animate]: animate.html
    - [Command-line Tools: Compare]: compare.html
    - [Command-line Tools: Composite]: composite.html
    - [Command-line Tools: Conjure]: conjure.html
    - [Command-line Tools: Convert]: convert.html
    - [Command-line Tools: Display]: display.html
    - [Command-line Tools: Identify]: identify.html
    - [Command-line Tools: Import]: import.html
    - [Command-line Tools: Magick]: https://imagemagick.org/script/magick.php
    - [Command-line Tools: Mogrify]: mogrify.html
    - [Command-line Tools: Montage]: montage.html
    - [Command-line Tools: Stream]: stream.html
    - [MagickCache: an Efficient Image Cache]: magick-cache.html
- Development Interface
    - [Develop]: develop.html
    - [MagickCore, Low-level C API]: magick-core.html
    - [PerlMagick, Perl API]: perl-magick.html
    - [Magick++, C++ API]: magick++.html
    - [Porting to ImageMagick Version 7]: porting.html
    - [MagickWand, C API]: magick-wand.html
    - [Parallel Execution with OpenCL]: opencl.html
    - [Parallel Execution with OpenMP]: openmp.html
- Misc
    - [Export Classification]: export.html
    - [Distributed Pixel Cache]: distribute-pixel-cache.html
    - [Mirror]: mirror.html
    - [Resources]: resources.html
    - [Voluntary Product Accessibility Template]: vpat.html
    - [History]: history.html
    - [Changelog]: https://github.com/ImageMagick/Website/blob/main/ChangeLog.md
    - [Security Policy]: security-policy.html
    - [News]: https://imagemagick.org/script/news.php
    - [Related Web Sites]: links.html
    - [Sitemap]: sitemap.html
    - [Support ImageMagick Development]: https://imagemagick.org/script/support.php
    - [How to Cite]: https://imagemagick.org/script/cite.php
    - [Public Key: http://pgp.mit.edu/pks/lookup?op=get&search=0x89AB63D48277377A
    - [Contact the: Development Team]: https://imagemagick.org/script/contact.php
    - [GitHub]: https://github.com/imagemagick/imagemagick
    - [Twitter]: https://twitter.com/imagemagick
    - [License]: https://imagemagick.org/script/license.php

/ImageMagick
=============

  ImageMagick – Convert, Edit, or Compose Digital Images

[ImageMagick_ICON]: https://www.imagemagick.org/Usage/images/logo.gif
[ImageMagick_ICON]: https://imagemagick.org/image/wizard.png
[ImageMagick®]: http://tarr.uspto.gov/servlet/tarr?regser=serial&entry=78333969

![And Now a Touch of Magick][ImageMagick_ICON] [ImageMagick®] is a free, [open-source] software suite, used for editing and manipulating digital images. It can be used to create, edit, compose, or convert bitmap images, and supports a wide range of file [formats], including JPEG, PNG, GIF, TIFF, and PDF.

ImageMagick is widely used in industries such as web development, graphic design, and video editing, as well as in scientific research, medical imaging, and astronomy. Its versatile and customizable nature, along with its robust image processing capabilities, make it a popular choice for a wide range of image-related tasks.

ImageMagick includes a command-line interface for executing complex image processing tasks, as well as APIs for integrating its features into software applications. It is written in C and can be used on a variety of operating systems, including Linux, Windows, and macOS.

The main website for ImageMagick can be found at [https://imagemagick.org]. The most recent version available is [ImageMagick 7.1.0-62]. The source code for this software can be accessed through a [repository](https://github.com/ImageMagick/ImageMagick). In addition, we maintain a legacy version of ImageMagick, [version 6](https://legacy.imagemagick.org).

It is strongly recommended to establish a [security policy] suitable for your local environment before utilizing ImageMagick.

Features and Capabilities
-------------------------

One of the key features of ImageMagick is its support for scripting and automation. This allows users to create complex image manipulation pipelines that can be run automatically, without the need for manual intervention. This can be especially useful for tasks that require the processing of large numbers of images, or for tasks that need to be performed on a regular basis.

In addition to its core image manipulation capabilities, ImageMagick also includes a number of other features, such as support for animation, color management, and image rendering. These features make it a versatile tool for a wide range of image-related tasks, including graphic design, scientific visualization, and digital art.

Overall, ImageMagick is a powerful and versatile software suite for displaying, converting, and editing image files. Its support for scripting and automation, along with its other features, make it a valuable tool for a wide range of image-related tasks.

Here are just a few [examples] of what ImageMagick can do for you:

*   [Animation] create a GIF animation sequence from a group of images.

*   [Bilateral blur] non-linear, edge-preserving, and noise-reducing smoothing filter.

*   [Color management] accurate color management with color profiles or in 
    lieu of-- built-in gamma compression or expansion as demanded by the colorspace.

*   [Color thresholding] force all pixels in the color range to white otherwise black.

*   [Command-line processing] utilize ImageMagick from the command-line.

*   [Complex text layout](https://en.wikipedia.org/wiki/Complex_text_layout)
     bidirectional text support and shaping.

*   [Composite] overlap one image over another.

*   [Connected component labeling] uniquely label connected regions in an image.

*   [Convex hull] smallest area convex polygon containing the image foreground objects. 
    In addition, the minimum bounding box and unrotate angle are also generated.

*   [Decorate] add a border or frame to an image.

*   [Delineate image features] 
*   [Canny edge detection], [Hough lines]. 
*   [Discrete Fourier transform] implements the forward and inverse [DFT](https://en.wikipedia.org/wiki/Discrete_Fourier_transform).

*   [Distributed pixel cache] offload intermediate pixel storage to one or more remote servers.

*   [Draw] add shapes or text to an image.

*   [Encipher or decipher an image] convert ordinary images into unintelligible gibberish and back again.

*   [Format conversion] convert an image from one [format] to another (e.g. PNG to JPEG). 

*   [Generalized pixel distortion] correct for, or induce image distortions including perspective.

*   [Heterogeneous distributed processing] 
    certain algorithms are [OpenCL]-enabled to take advantage of speed-ups offered by executing in concert across het   erogeneous platforms consisting of CPUs, GPUs, and other processors. 

*   [High dynamic-range images] accurately represent the wide range of intensity levels found 
    in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows.

*   [Histogram equalization] use adaptive histogram equalization to improve contrast in images.

*   [Image cache] secure methods and tools to cache images, image sequences, video, 
    audio or metadata in a local folder..

*   [Image calculator] apply a mathematical expression to an image, image sequence, or image channels.

*   [Image gradients] create a gradual blend of two colors 
    whose shape is horizontal, vertical, circular, or elliptical.

*   [Image identification] describe the format and attributes of an image.

*   [ImageMagick on the iPhone] convert, edit, or compose images 
    on your [iOS](https://www.apple.com/ios/) device such as the iPhone or iPad.

*   [Large image support] read, process, or write mega-, giga-, or tera-pixel image sizes.

*   [Montage] juxtapose image thumbnails on an image canvas.

*   [Morphology of shapes] extract features, describe shapes, and recognize patterns in images.

*   [Motion picture support] read and write the common image formats used in digital film work.

*   [Multispectral imagery] support multispectral imagery up to 64 bands.

*   [Noise and color reduction] [Kuwahara Filter](https://legacy.imagemagick.org/discourse-server/viewtopic.html?t=26480), [mean-shift](https://legacy.imagemagick.org/discourse-server/viewtopic.html?t=25504).

    [Perceptual hash](http://www.fmwconcepts.com/misc_tests/perceptual_hash_test_results_510/index.html)
    map visually identical images to the same or similar hash-- useful in image retrieval, authentication, indexing, or copy detection as well as digital watermarking.

*   [Special effects] blur, sharpen, threshold, or tint an image.

*   [Text & comments] insert descriptive or artistic text in an image.

*   [Threads of execution support] 
    ImageMagick is thread safe and most internal algorithms execute in [parallel] to take advantage of speed-ups off ered by multicore processor chips. 

*   [Transform] resize, rotate, deskew, crop, flip or trim an image.

*   [Transparency] render portions of an image invisible.

*   [Virtual pixel support] convenient access to pixels outside the image boundaries.

  

[Examples of ImageMagick Usage] demonstrates how to use the software from the [command line] to achieve various effects. There are also several scripts available on the website called [Fred's ImageMagick Scripts](http://www.fmwconcepts.com/imagemagick/), which can be used to apply geometric transforms, blur and sharpen images, remove noise, and perform other operations. Additionally, there is a tool called [Magick.NET](https://github.com/dlemstra/Magick.NET) that allows users to access the functionality of ImageMagick without having to install the software on their own systems. Finally, the website also includes a [Cookbook](http://im.snibgo.com/) with tips and examples for using ImageMagick on Windows systems.

#### Community

Join the ImageMagick community by participating in the [discussion](https://github.com/ImageMagick/ImageMagick/discussions) service. Here, you can find answers to questions asked by other ImageMagick users or ask your own questions. If you have a technical question, a suggestion for an improvement, or a fix for a bug, you can also open an [issue](https://github.com/ImageMagick/ImageMagick/issues) to get help from the community.


Copyright © 1999 ImageMagick Studio LLC


/Download
==========

[Linux Binary Release] • [Mac OS X Binary Release] • [iOS Binary Release] • [Windows Binary Release]

You can install ImageMagick from [source]. However, if you don't have a proper development environment or if you're anxious to get started, download a ready-to-run [Linux] or [Windows] executable. Before you download, you may want to review recent [changes](https://github.com/ImageMagick/Website/blob/main/ChangeLog.md) to the ImageMagick distribution.

ImageMagick source and binary distributions are available from a variety of FTP and Web [mirrors] around the world.

It is strongly recommended to establish a [security policy] suitable for your local environment before utilizing ImageMagick.

Linux Binary Release
--------------------

These are the Linux variations that we support. If your system is not on the list, try installing from [source]. Although ImageMagick runs fine on a single core computer, it automagically runs in parallel on multi-core systems reducing run times considerably.

 

[magick](https://imagemagick.org/archive/binaries/magick)

Complete portable application on Linux, no installation required. Just download and run. This [AppImage](https://appimage.org/) has an open security policy. ImageMagick recommended practices **strongly** encourage you to configure a [security policy] that suits your local environment. Simply add a custom security policy in your local path, .e.g., ~/.config/ImageMagick/policy.xml and verify with this command: 

    ./magick -list policy.


*   Redhat / CentOS 8.3 x86_64 RPM
    [ImageMagick-7.1.0-62.x86_64.rpm](https://imagemagick.org/archive/linux/CentOS/x86_64/ImageMagick-7.1.0-62.x86_64.rpm)


*   Redhat / CentOS 8.3 x86_64 RPM
    [ImageMagick-libs-7.1.0-62.x86_64.rpm](https://imagemagick.org/archive/linux/CentOS/x86_64/ImageMagick-libs-7.1.0-62.x86_64.rpm)


*   Development, Perl, C++, and documentation RPM's.
    [ImageMagick RPM's](https://imagemagick.org/archive/linux/CentOS)


*   Solaris Sparc 2.11
    [ImageMagick-i386-pc-solaris2.11.tar.gz](https://imagemagick.org/archive/binaries/ImageMagick-i386-pc-solaris2.11.tar.gz)


*   Cygwin
    [ImageMagick-i686-pc-cygwin.tar.gz](https://imagemagick.org/archive/binaries/ImageMagick-i686-pc-cygwin.tar.gz)


*   MinGW
    [ImageMagick-i686-pc-mingw32.tar.gz](https://imagemagick.org/archive/binaries/ImageMagick-i686-pc-mingw32.tar.gz)

Verify its [message digest](https://imagemagick.org/archive/binaries/digest.rdf).

ImageMagick RPM's are self-installing. Simply type the following command and you're ready to start using ImageMagick:

    $ rpm -Uvh ImageMagick-7.1.0-62.x86_64.rpm

You'll need the libraries as well:

    $ rpm -Uvh ImageMagick-libs-7.1.0-62.x86_64.rpm

Note, if there are missing dependencies, install them from the [EPEL](https://fedoraproject.org/wiki/EPEL) repo.

For other systems, create (or choose) a directory to install the package into and change to that directory, for example:

    cd $HOME

Next, extract the contents of the package. For example:

    tar xvzf ImageMagick.tar.gz

Set the MAGICK_HOME environment variable to the path where you extracted the ImageMagick files. For example:

    $ export MAGICK_HOME="$HOME/ImageMagick-7.1.0"

If the bin subdirectory of the extracted package is not already in your executable search path, add it to your PATH environment variable. For example:

    export PATH="$MAGICK_HOME/bin:$PATH

On Linux and Solaris machines add $MAGICK_HOME/lib to the LD_LIBRARY_PATH environment variable:

    LD_LIBRARY_PATH="${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}$MAGICK_HOME/lib
    export LD_LIBRARY_PATH

Finally, to verify ImageMagick is working properly, type the following on the command line:

    magick logo: logo.gif
    identify logo.gif
    display logo.gif

Congratulations, you have a working ImageMagick distribution under Linux or Linux and you are ready to use ImageMagick to [convert, compose, or edit] your images or perhaps you'll want to use one of the [Application Program Interfaces] for C, C++, Perl, and others.

Mac OS X Binary Release
-----------------------

We recommend [Homebrew](https://brew.sh) which provides pre-built binaries for Mac (some users prefer [MacPorts](https://macports.org)). Download HomeBrew and type:

    brew install imagemagick

ImageMagick depends on Ghostscript fonts. To install them, type:

    brew install ghostscript

The brew command downloads and installs ImageMagick with many of its delegate libraries (e.g. JPEG, PNG, Freetype, etc). Homebrew [no longer allows](https://github.com/Homebrew/homebrew-core/issues/31510) configurable builds; if you need different compile options (e.g. librsvg support), you can download the ImageMagick Mac OS X distribution we provide:

 

Version

Description

[ImageMagick-x86_64-apple-darwin20.1.0.tar.gz](https://imagemagick.org/archive/binaries/ImageMagick-x86_64-apple-darwin20.1.0.tar.gz)

    macOS High Sierra

Verify its [message digest](https://imagemagick.org/archive/binaries/digest.rdf).

Create (or choose) a directory to install the package into and change to that directory, for example:

    cd $HOME

Next, extract the contents of the package. For example:

    tar xvzf ImageMagick-x86_64-apple-darwin20.1.0.tar.gz

Set the MAGICK_HOME environment variable to the path where you extracted the ImageMagick files. For example:

    $ export MAGICK_HOME="$HOME/ImageMagick-7.1.0"

If the bin subdirectory of the extracted package is not already in your executable search path, add it to your PATH environment variable. For example:

    export PATH="$MAGICK_HOME/bin:$PATH"

    Set the DYLD_LIBRARY_PATH environment variable:

    export DYLD_LIBRARY_PATH="$MAGICK_HOME/lib/"

Finally, to verify ImageMagick is working properly, type the following on the command line:

    magick logo: logo.gif
    identify logo.gif
    display logo.gif

**Note**, the [display] program requires the X11 server available on your Mac OS X installation DVD. Once that is installed, you will also need to set export DISPLAY=:0.

The best way to deal with all the exports is to put them at the end of your .profile file

Congratulations, you have a working ImageMagick distribution under Mac OS X and you are ready to use ImageMagick to [convert, compose, or edit] your images or perhaps you'll want to use one of the [Application Program Interfaces] for C, C++, Perl, and others.

iOS Binary Release
------------------

[~Claudio](http://www.cloudgoessocial.net/2011/03/21/im-xcode4-ios4-3/) provides iOS builds of ImageMagick.

#### Download iOS Distribution

You can download the iOS distribution directly from ImageMagick's [repository](https://imagemagick.org/archive/iOS).

There are always 2 packages for the compiled ImageMagick:

*   iOSMagick-VERSION-libs.zip
*   iOSMagick-VERSION.zip

The first one includes headers and compiled libraries that have been used to compile ImageMagick. Most users would need this one.

#### ImageMagick compiling script for iOS OS and iOS Simulator

To run the script:

    ./imagemagick_compile.sh VERSION

where VERSION is the version of ImageMagick you want to compile (i.e.: 7.1.0-62, svn, ...)

This script compiles ImageMagick as a static library to be included in iOS projects and adds support for

*   png
*   jpeg
*   tiff

Upon successful compilation a folder called IMPORT_ME is created on your ~/Desktop. You can import it into your Xcode project.

#### Xcode project settings

After including everything into Xcode please also make sure to have these settings (Build tab of the project information):

*   Other Linker Flags: -lMagickCore-Q16 -lMagickWand-Q16 -ljpeg -lpng -lbz2 -lz
*   Header Search Paths: $(SRCROOT) - make it Recursive
*   Library Search Paths: $(SRCROOT) - make it Recursive

On the lower left click on the small-wheel and select: Add User-Defined Setting

*   Key: OTHER_CFLAGS
*   Value: -Dmacintosh=1

#### Sample project

A [sample project](http://www.cloudgoessocial.net/im_iphone/IM_Test.zip) is available for download. It is not updated too often, but it does give an idea of all the settings and some ways to play around with ImageMagick in an iOS application.

Windows Binary Release
----------------------

ImageMagick runs on Windows 7 (x86 , x64 & arm64) or newer, Windows Server 2012 or newer, Windows Vista (x86 & x64) with Service Pack 2, Windows Server 2008 (x86 & x64) with Service Pack 2, and Windows Server 2008 R2 (x64).

The amount of memory can be an important factor, especially if you intend to work on large images. A minimum of 512 MB of RAM is recommended, but the more RAM the better. Although ImageMagick runs well on a single core computer, it automagically runs in parallel on multi-core systems reducing run times considerably.

The Windows version of ImageMagick is self-installing. Simply click on the appropriate version below and it will launch itself and ask you a few installation questions. Versions with Q8 in the name are 8 bits-per-pixel component (e.g. 8-bit red, 8-bit green, etc.), whereas, Q16 in the filename are 16 bits-per-pixel component. A Q16 version permits you to read or write 16-bit images without losing precision but requires twice as much resources as the Q8 version. Versions with dll in the filename include ImageMagick libraries as [dynamic link libraries](http://www.answers.com/topic/dll). 

Unless you have a Windows 32-bit OS, we recommend this version of ImageMagick for 64-bit Windows:

*   Win64 dynamic at 16 bits-per-pixel component with High-dynamic-range imaging enabled
    [ImageMagick-7.1.0-62-Q16-HDRI-x64-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-HDRI-x64-dll.exe)


Or choose from these alternate Windows binary distributions:

*   Win64 dynamic at 16 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q16-x64-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-x64-dll.exe)


*   Win64 static at 16 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q16-x64-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-x64-static.exe)


*   Win64 dynamic at 8 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q8-x64-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q8-x64-dll.exe)


*   Win64 static at 8 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q8-x64-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q8-x64-static.exe)


*   Win64 static at 16 bits-per-pixel component with [high dynamic-range imaging] enabled
    [ImageMagick-7.1.0-62-Q16-HDRI-x64-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-HDRI-x64-static.exe)


*   ARM64 dynamic at 8 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q8-arm64-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q8-arm64-dll.exe)


*   ARM64 static at 8 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q8-arm64-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q8-arm64-static.exe)


*   ARM64 dynamic at 16 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q16-arm64-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-arm64-dll.exe)


*   ARM64 dynamic at 16 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q16-arm64-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-arm64-static.exe)


*   ARM64 dynamic at 16 bits-per-pixel component with [high dynamic-range imaging] enabled
    [ImageMagick-7.1.0-62-Q16-HDRI-arm64-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-HDRI-arm64-dll.exe)


*   ARM64 static at 16 bits-per-pixel component with [high dynamic-range imaging] enabled
    [ImageMagick-7.1.0-62-Q16-HDRI-arm64-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-HDRI-arm64-static.exe)


*   Win32 dynamic at 16 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q16-x86-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-x86-dll.exe)


*   Win32 static at 16 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q16-x86-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-x86-static.exe)


*   Win32 dynamic at 8 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q8-x86-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q8-x86-dll.exe)


*   Win32 static at 8 bits-per-pixel component
    [ImageMagick-7.1.0-62-Q8-x86-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q8-x86-static.exe)


*   Win32 dynamic at 16 bits-per-pixel component with [high dynamic-range imaging] enabled
    [ImageMagick-7.1.0-62-Q16-HDRI-x86-dll.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-HDRI-x86-dll.exe)


*   Win32 static at 16 bits-per-pixel component with [high dynamic-range imaging] enabled
    [ImageMagick-7.1.0-62-Q16-HDRI-x86-static.exe](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-Q16-HDRI-x86-static.exe)


*   Portable Win64 static at 16 bits-per-pixel component. Just copy to your host and run 
    (no installer, no Windows registry entries).
    [ImageMagick-7.1.0-62-portable-Q16-x64.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q16-x64.zip)


*   Portable ARM64 static at 16 bits-per-pixel component. Just copy to your host and run 
    (no installer, no Windows registry entries).
    [ImageMagick-7.1.0-62-portable-Q16-arm64.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q16-arm64.zip)


*   Portable Win32 static at 16 bits-per-pixel component. Just copy to your host and run 
    (no installer, no Windows registry entries).
    [ImageMagick-7.1.0-62-portable-Q16-x86.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q16-x86.zip)


*   Portable Win64 static at 8 bits-per-pixel component. Just copy to your host and run 
    (no installer, no  registry entries).
    [ImageMagick-7.1.0-62-portable-Q8-x64.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q8-x64.zip)


*   Portable ARM64 static at 8 bits-per-pixel component. Just copy to your host and run 
    (no installer, no  registry entries).
    [ImageMagick-7.1.0-62-portable-Q8-arm64.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q8-arm64.zip)


*   Portable Win32 static at 8 bits-per-pixel component. Just copy to your host and run 
    (no installer, no  registry entries).
    [ImageMagick-7.1.0-62-portable-Q8-x86.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q8-x86.zip)


*   Portable Win64 static at 16 bits-per-pixel component with [high dynamic-range imaging]
     enabled. Just copy  your host and run (no installer, no Windows registry entries).
    [ImageMagick-7.1.0-62-portable-Q16-HDRI-x64.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q16-HDRI-x64.zip)


*   Portable ARM64 static at 16 bits-per-pixel component with [high dynamic-range imaging]
     enabled. Just copy  your host and run (no installer, no Windows registry entries).
    [ImageMagick-7.1.0-62-portable-Q16-HDRI-arm64.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q16-HDRI-arm64.zip)


*   Portable Win32 static at 16 bits-per-pixel component with [high dynamic-range imaging]
     enabled. Just copy  your host and run (no installer, no Windows registry entries).
    [ImageMagick-7.1.0-62-portable-Q16-HDRI-x86.zip](https://imagemagick.org/archive/binaries/ImageMagick-7.1.0-62-portable-Q16-HDRI-x86.zip)


*   To verify ImageMagick is working properly, type the following in a Command Prompt window:
    Verify its [message digest](https://imagemagick.org/archive/binaries/digest.rdf).

```sh
magick logo: logo.gif
magick identify logo.gif
magick logo.gif win:
```

If you have any problems, you likely need vcomp120.dll. To install it, download [Visual C++ Redistributable Package](https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads).

Note, use a double quote (") rather than a single quote (') for the ImageMagick command line under Windows:

    magick "e:/myimages/image.png" "e:/myimages/image.jpg"

Use two double quotes for VBScript scripts:

    Set objShell = wscript.createobject("wscript.shell")
    objShell.Exec("magick ""e:/myimages/image.png"" ""e:/myimages/image.jpg""")

It is strongly recommended to establish a [security policy] suitable for your local environment before utilizing ImageMagick.

Congratulations, you have a working ImageMagick distribution under Windows and you are ready to use ImageMagick to [convert, compose, or edit] your images or perhaps you'll want to use one of the [Application Program Interfaces] for C, C++, Perl, and others.


/Install from Source
=====================


Chances are, ImageMagick is already installed on your computer if you are using some flavor of Linux, and its likely not installed if you are using some form of Windows. In either case, you can type the following to find out:

magick identify -version

If the [identify] program executes and identifies itself as ImageMagick, you may not need to install ImageMagick from source unless you want to add support for additional image formats or upgrade to a newer version. You also have the option of installing a pre-compiled [binary release]. However, if you still want to install from source, choose a platform, [Linux] or [Windows]. Before installing from source, you may want to review recent [changes](https://github.com/ImageMagick/Website/blob/main/ChangeLog.md) to the ImageMagick distribution.

The authoritative source code repository is [https://github.com/ImageMagick](https://github.com/ImageMagick).

Install from Linux Source
-------------------------

ImageMagick builds on a variety of Linux and Linux-like operating systems including Linux, Solaris, FreeBSD, Mac OS X, and others. A compiler is required and fortunately almost all modern Linux systems have one. Clone the source repository:

    $ git clone https://github.com/ImageMagick/ImageMagick.git ImageMagick-7.1.0

Or download [ImageMagick.tar.gz](https://imagemagick.org/archive/ImageMagick.tar.gz) from [imagemagick.org](https://imagemagick.org/archive) or a [mirror] and verify the distribution against its [message digest](https://imagemagick.org/archive/digest.rdf).

Next configure and compile ImageMagick. Note the [pkg-config](https://en.wikipedia.org/wiki/Pkg-config) script is required so that ImageMagick can find certain optional delegate libraries on your system. To configure, type:

    $ cd ImageMagick-7.1.0$ ./configure$ make

If build fails, try gmake instead.

For advanced users, we recommend a modules build:

    $ ./configure --with-modules

If ImageMagick configured and compiled without complaint, you are ready to install it on your system. Administrator privileges are required to install. To install, type

    sudo make install

You may need to configure the dynamic linker run-time bindings:

    sudo ldconfig /usr/local/lib

Finally, verify the ImageMagick install worked properly, type

    /usr/local/bin/convert logo: logo.gif

For a more comprehensive test, run the ImageMagick validation suite. Ghostscript and Freetype are prerequisites, otherwise expect the EPS, PS, PDF and text annotations tests to fail.

    make check

Congratulations, you have a working ImageMagick distribution and you are ready to use ImageMagick to [convert, compose, or edit] your images or perhaps you'll want to use one of the [Application Program Interfaces] for C, C++, Perl, and others.

The above instructions will satisfy a great number of ImageMagick users, but we suspect a few will have additional questions or problems to consider. For example, what does one do if ImageMagick fails to configure or compile? Or what if you don't have administrator privileges and what if you don't want to install ImageMagick in the default /../usr/local folder? You will find the answer to these questions, and more, in [Advanced Linux Source Installation].

Install from Windows Source
---------------------------

We recommend you first uninstall an existing ImageMagick, else you might be surprised that your magick/convert commands go to the old version.

Building ImageMagick source for Windows can be done with a modern version of Microsoft Visual Studio IDE. Users have reported success with the Borland C++ compiler as well. If you don't have a compiler you can still install a self-installing [binary release].

Clone the Github repo:

    git clone https://github.com/ImageMagick/ImageMagick-Windows.git ImageMagick-Windows-7

and run CloneRepositories.cmd. Or download [ImageMagick-Windows.zip](https://imagemagick.org/archive/windows) from [imagemagick.org](https://imagemagick.org/archive/windows) or a [mirror] and verify the distribution against its [message digest](https://imagemagick.org/archive/digest.rdf).

    unzip ImageMagick-windows.zip

Unzip in a folder that does not need Admin permissions, otherwise Visual Studio will not be able to build the solution.

Next, launch your Visual Studio IDE and choose Open->Project. Select the configure workspace from the ImageMagick-7.1.0/VisualMagick/configure folder and open configure.sln. Choose Build->Build Solution to compile the program and on completion run the program.

![configure](https://imagemagick.org/image/configure.jpg)

Press Next and click on the multi-threaded static build. Now press, on Next twice and finally Finish. The configuration utility just created a workspace required to build ImageMagick from source. Choose Open->Project and select the VisualStaticMT workspace from the ImageMagick-7.1.0/VisualMagick/ folder. Finally, choose Build->Build Solution to compile and build the ImageMagick distribution.

The configure.exe utility can also be run on the command line instead of through the GUI wizard. You can see an example in [our GitHub actions build](https://github.com/ImageMagick/ImageMagick/blob/18e15da2dc6ceae05e95077f85e9d67dac31c5d8/.github/workflows/release.yml#L212).

To verify ImageMagick is working properly, launch a MS-DOS Command Prompt window and type

    $ cd ImageMagick-7.1.0$ convert logo: image.jpg

You may want to add the full path to VisualMagick\bin for your environment PATH variable, so you can call Magick/convert from any directory.

For a more comprehensive test, run the ImageMagick validation suite:

    validate

Congratulations, you have a working ImageMagick distribution under Windows and you are ready to use ImageMagick to [convert, compose, or edit] your images or perhaps you'll want to use one of the [Application Program Interfaces] for C, C++, Perl, and others.

The above instructions will satisfy a great number of ImageMagick users, but we suspect a few will have additional questions or problems to consider. For example, what does one do if ImageMagick fails to configure or compile? Or what if you want to install ImageMagick in a place other than the ImageMagick-7.1.0/VisualMagick/bin folder? You will find the answer to these questions, and more, in [Advanced Windows Source Installation].


/Advanced Linux Installation
=============================

[Download & Unpack] • [Configure] • [Build] • [Install] • [Linux-specific Build Instructions] • [Mac OS X-specific Build Instructions] • [MinGW-specific Build Instructions] • [Dealing with Unexpected Problems]

It's possible you don't want to concern yourself with advanced installation under Linux or Linux systems. If so, you also have the option of installing a pre-compiled [binary release] or if you still want to install from source without all the fuss see the simple [Install From Source] instructions. However, if you want to customize the configuration and installation of ImageMagick under Linux or Linux systems, lets begin.

Download & Unpack
-----------------

ImageMagick builds on a variety of Linux and Linux-like operating systems including Linux, Solaris, FreeBSD, Mac OS X, and others. A compiler is required and fortunately almost all modern Linux systems have one. Download [ImageMagick.tar.gz](https://imagemagick.org/archive/ImageMagick.tar.gz) from [imagemagick.org](https://imagemagick.org/archive) or a [mirror] and verify the distribution against its [message digest](https://imagemagick.org/archive/digest.rdf).

Unpack the distribution it with this command:

    tar xvzf ImageMagick.tar.gz

Now that you have the ImageMagick Linux/Linux source distribution unpacked, let's configure it.

Configure
---------

The configure script looks at your environment and decides what it can cobble together to get ImageMagick compiled and installed on your system. This includes finding a compiler, where your compiler header files are located (e.g. stdlib.h), and if any delegate libraries are available for ImageMagick to use (e.g. JPEG, PNG, TIFF, etc.). If you are willing to accept configure's default options, and build from within the source directory, you can simply type:

    $ cd ImageMagick-7.1.0-62$ ./configure

Watch the configure script output to verify that it finds everything that you think it should. Pay particular attention to the last lines of the script output. For example, here is a recent report from our system:

ImageMagick is configured as follows. Please verify that this configuration
matches your expectations.

    Host system type: x86_64-unknown-linux-gnu
    Build system type: x86_64-unknown-linux-gnu

                      Option                     Value
    -------------------------------------------------------------------------------
    Shared libraries  --enable-shared=yes		yes
    Static libraries  --enable-static=yes		yes
    Module support    --with-modules=yes		yes
    GNU ld            --with-gnu-ld=yes		yes
    Quantum depth     --with-quantum-depth=16	16
    High Dynamic Range Imagery
                      --enable-hdri=no		no

    Delegate Configuration:
    BZLIB             --with-bzlib=yes		yes
    Autotrace         --with-autotrace=yes	yes
    DJVU              --with-djvu=yes		no
    DPS               --with-dps=yes		no
    FlashPIX          --with-fpx=yes		no
    FontConfig        --with-fontconfig=yes	yes
    FreeType          --with-freetype=yes		yes
    GhostPCL          None			pcl6 (unknown)
    GhostXPS          None			gxps (unknown)
    Ghostscript       None			gs (8.63)
    result_ghostscript_font_dir='none'
    Ghostscript fonts --with-gs-font-dir=default
    Ghostscript lib   --with-gslib=yes		no (failed tests)
    Graphviz          --with-gvc=yes		yes
    JBIG              --with-jbig=		no
    JPEG v1           --with-jpeg=yes		yes
    JPEG-2000         --with-jp2=yes		yes
    LCMS              --with-lcms=yes		yes
    LQR               --with-lqr=yes		no
    Magick++          --with-magick-plus-plus=yes	yes
    OpenEXR           --with-openexr=yes		yes
    PERL              --with-perl=yes		/usr/bin/perl
    PNG               --with-png=yes		yes
    RSVG              --with-rsvg=yes		yes
    TIFF              --with-tiff=yes		yes
    result_windows_font_dir='none'
    Windows fonts     --with-windows-font-dir=
    WMF               --with-wmf=yes		yes
    X11               --with-x=			yes
    XML               --with-xml=yes		yes
    ZLIB              --with-zlib=yes		yes

    X11 Configuration:
          X_CFLAGS        =
          X_PRE_LIBS      = -lSM -lICE
          X_LIBS          =
          X_EXTRA_LIBS    =

    Options used to compile and link:
      PREFIX          = /usr/local
      EXEC-PREFIX     = /usr/local
      VERSION         = 6.4.8
      CC              = gcc -std=gnu99
      CFLAGS          = -fopenmp -g -O2 -Wall -W -pthread
      MAGICK_CFLAGS   = -fopenmp -g -O2 -Wall -W -pthread
      CPPFLAGS        = -I/usr/local/include/ImageMagick
      PCFLAGS         = -fopenmp
      DEFS            = -DHAVE_CONFIG_H
      LDFLAGS         = -lfreetype
      MAGICK_LDFLAGS  = -L/usr/local/lib -lfreetype
      LIBS            = -lMagickCore-Q16 -llcms -ltiff -lfreetype -ljpeg -lfontconfig -lXext
                        -lSM -lICE -lX11 -lXt -lbz2 -lz -lm -lgomp -lpthread -lltdl
      CXX             = g++
      CXXFLAGS        = -g -O2 -Wall -W -pthread

You can influence choice of compiler, compilation flags, or libraries of the configure script by setting initial values for variables in the configure command line. These include, among others:

*   `CC` Name of C compiler (e.g. cc -Xa) to use.
*   `CXX` Name of C++ compiler to use (e.g. CC).
*   `CFLAGS` Compiler flags (e.g. -g -O2) to compile C code.
*   `CXXFLAGS` Compiler flags (e.g. -g -O2) to compile C++ code.
*   `CPPFLAGS` Include paths (.e.g. -I/usr/local) to look for header files.
*   `LIBS` Extra libraries (.e.g. -l/usr/local/lib) required to link.

*   `LDFLAGS`

    Library paths (.e.g. -L/usr/local) to look for libraries systems that support the notion of a library run-path may require an additional argument in order to find shared libraries at run time. For example, the Solaris linker requires an argument of the form -R/path. Some Linux systems will work with -rpath /usr/local/lib, while some other Linux systems who's gcc does not pass -rpath to the linker, require an argument of the form -Wl,-rpath,/usr/local/lib.

Here is an example of setting configure variables from the command line:

    configure CC=c99 CFLAGS=-O2 LDFLAGS='-L/usr/local/lib -R/usr/local/lib' LIBS=-lposix

Any variable (e.g. CPPFLAGS or LDFLAGS) which requires a directory path must specify an absolute path rather than a relative path.

Configure can usually find the X include and library files automagically, but if it doesn't, you can use the --x-includes=path and --x-libraries=path options to specify their locations.

The configure script provides a number of ImageMagick specific options. When disabling an option --disable-something is equivalent to specifying --enable-something=no and --without-something is equivalent to --with-something=no. The configure options are as follows (execute configure --help to see all options).

ImageMagick options represent either features to be enabled, disabled, or packages to be included in the build. When a feature is enabled (via --enable-something), it enables code already present in ImageMagick. When a package is enabled (via --with-something), the configure script will search for it, and if is properly installed and ready to use (headers and built libraries are found by compiler) it will be included in the build. The configure script is delivered with all features disabled and all packages enabled. In general, the only reason to disable a package is if a package exists but it is unsuitable for the build (perhaps an old version or not compiled with the right compilation flags).

Here are the optional features you can configure:

*   `--enable-shared`

    build the shared libraries and support for loading coder and process modules. Shared libraries are preferred because they allow programs to share common code, making the individual programs much smaller. In addition shared libraries are required in order for PerlMagick to be dynamically loaded by an installed PERL (otherwise an additional PERL (PerlMagick) must be installed.  
      
    ImageMagick built with delegates (see MAGICK PLUG-INS below) can pose additional challenges. If ImageMagick is built using static libraries (the default without --enable-shared) then delegate libraries may be built as either static libraries or shared libraries. However, if ImageMagick is built using shared libraries, then all delegate libraries must also be built as shared libraries. Static libraries usually have the extension .a, while shared libraries typically have extensions like .so, .sa, or .dll. Code in shared libraries normally must compiled using a special compiler option to produce Position Independent Code (PIC). The only time this not necessary is if the platform compiles code as PIC by default.  
      
    PIC compilation flags differ from vendor to vendor (gcc's is -fPIC). However, you must compile all shared library source with the same flag (for gcc use -fPIC rather than -fpic). While static libraries are normally created using an archive tool like ar, shared libraries are built using special linker or compiler options (e.g. -shared for gcc).  
      
    If --enable-shared is not specified, a new PERL interpreter (PerlMagick) is built which is statically linked against the PerlMagick extension. This new interpreter is installed into the same directory as the ImageMagick utilities. If --enable-shared is specified, the PerlMagick extension is built as a dynamically loadable object which is loaded into your current PERL interpreter at run-time. Use of dynamically-loaded extensions is preferable over statically linked extensions so use --enable-shared if possible (note that all libraries used with ImageMagick must be shared libraries!).

*   `--disable-static`

    static archive libraries (with extension .a) are not built. If you are building shared libraries, there is little value to building static libraries. Reasons to build static libraries include: 1) they can be easier to debug; 2) clients do not have external dependencies (i.e. libMagick.so); 3) building PIC versions of the delegate libraries may take additional expertise and effort; 4) you are unable to build shared libraries.

*   `--disable-installed`

    disable building an installed ImageMagick (default enabled).  
      
    By default the ImageMagick build is configured to formally install into a directory tree. This the most secure and reliable way to install ImageMagick. Use this option to configure ImageMagick so that it doesn't use hard-coded paths and locates support files by computing an offset path from the executable (or from the location specified by the MAGICK_HOME environment variable. The uninstalled configuration is ideal for binary distributions which are expected to extract and run in any location.

*   `--enable-ccmalloc` enable 'ccmalloc' memory debug support (default disabled).
*   `--enable-prof` enable 'prof' profiling support (default disabled).
*   `--enable-gprof` enable 'gprof' profiling support (default disabled).
*   `--enable-gcov` enable 'gcov' profiling support (default disabled).

*   `--disable-openmp` disable OpenMP (default enabled).
      
    Certain ImageMagick algorithms, for example convolution, can achieve a significant speed-up with the assistance of the OpenMP API when running on modern dual and quad-core processors.

*   `--disable-largefile` disable support for large (64 bit) file offsets.
      
    By default, ImageMagick is compiled with support for large files (> 2GB on a 32-bit CPU) if the operating system supports large files. Some applications which use the ImageMagick library may also require support for large files. By disabling support for large files via --disable-largefile, dependent applications do not require special compilation options for large files in order to use the library. Here are the optional packages you can configure:

*   `--with-quantum-depth` number of bits in a pixel quantum (default 16).
      
    Use this option to specify the number of bits to use per pixel quantum (the size of the red, green, blue, and alpha pixel components). For example, --with-quantum-depth=8 builds ImageMagick using 8-bit quantums. Most computer display adapters use 8-bit quantums. Currently supported arguments are 8, 16, or 32. We recommend the default of 16 because some image formats support 16 bits-per-pixel. However, this option is important in determining the overall run-time performance of ImageMagick.  
      
    The number of bits in a quantum determines how many values it may contain. Each quantum level supports 256 times as many values as the previous level. The following table shows the range available for various quantum sizes.  
      

        Quantum Depth     Valid Range (Decimal)   Valid Range (Hex)
            8             0-255                   00-FF
           16             0-65535                 0000-FFFF
           32             0-4294967295            00000000-FFFFFFFF

      
      
    Larger pixel quantums can cause ImageMagick to run more slowly and to require more memory. For example, using sixteen-bit pixel quantums can cause ImageMagick to run 15% to 50% slower (and take twice as much memory) than when it is built to support eight-bit pixel quantums.  
      
    The amount of virtual memory consumed by an image can be computed by the equation (5 * Quantum Depth * Rows * Columns) / 8. This an important consideration when resources are limited, particularly since processing an image may require several images to be in memory at one time. The following table shows memory consumption values for a 1024x768 image:  
      

        Quantum Depth   Virtual Memory
             8               3MB
            16               8MB
            32              15MB

*   `--enable-hdri` accurately represent the wide range of intensity levels.
*   `--enable-osx-universal-binary` build a universal binary on OS X.
*   `--without-modules` disable support for dynamically loadable modules.
      
    Image coders and process modules are built as loadable modules which are installed under the directory [prefix]/lib/ImageMagick-X.X.X/modules-QN (where 'N' equals 8, 16, or 32 depending on the quantum depth) in the subdirectories coders and filters respectively. The modules build option is only available in conjunction with --enable-shared. If --enable-shared is not also specified, support for building modules is disabled. Note that if --enable-shared and --disable-modules are specified, the module loader is active (allowing extending an installed ImageMagick by simply copying a module into place) but ImageMagick itself is not built using modules.

*   `--with-cache` set pixel cache threshold (defaults to available memory).
      
    Specify a different image pixel cache threshold with this option. This sets the maximum amount of heap memory that ImageMagick is allowed to consume before switching to using memory-mapped temporary files to store raw pixel data.

*   `--without-threads` disable threads support.
      
    By default, the ImageMagick library is compiled with multi-thread support. If this undesirable, specify --without-threads.

*   `--with-frozenpaths` enable frozen delegate paths.
      
    Normally, external program names are substituted into the delegates.xml configuration file without full paths. Specify this option to enable saving full paths to programs using locations determined by configure. This useful for environments where programs are stored under multiple paths, and users may use different PATH settings than the person who builds ImageMagick.

*   `--without-magick-plus-plus` disable build/install of Magick++.
      
    Disable building Magick++, the C++ application programming interface to ImageMagick. A suitable C++ compiler is required in order to build Magick++. Specify the CXX configure variable to select the C++ compiler to use (default g++), and CXXFLAGS to select the desired compiler optimization and debug flags (default -g -O2). Antique C++ compilers will normally be rejected by configure tests so specifying this option should only be necessary if Magick++ fails to compile.

*   `--without-perl` disable build/install of PerlMagick, or
      
    By default, PerlMagick is conveniently compiled and installed as part of ImageMagick's normal configure, make, sudo make install process. When --without-perl is specified, you must first install ImageMagick, change to the PerlMagick subdirectory, build, and finally install PerlMagick. Note, PerlMagick is configured even if --without-perl is specified. If the argument --with-perl=/path/to/perl is supplied, /../path/to/perl is be taken as the PERL interpreter to use. This important in case the perl executable in your PATH is not PERL5, or is not the PERL you want to use.

*   `--with-perl=PERL` use specified Perl binary to configure PerlMagick.

*   `--with-perl-options=OPTIONS`

    options to pass on command-line when generating PerlMagick's Makefile from Makefile.PL.  
      
    The PerlMagick module is normally installed using the Perl interpreter's installation PREFIX, rather than ImageMagick's. If ImageMagick's installation prefix is not the same as PERL's PREFIX, then you may find that PerlMagick's sudo make install step tries to install into a directory tree that you don't have write permissions to. This common when PERL is delivered with the operating system or on Internet Service Provider (ISP) web servers. If you want PerlMagick to install elsewhere, then provide a PREFIX option to PERL's configuration step via "--with-perl-options=PREFIX=/some/place". Other options accepted by MakeMaker are 'LIB', 'LIBPERL_A', 'LINKTYPE', and 'OPTIMIZE'. See the ExtUtils::MakeMaker(3) manual page for more information on configuring PERL extensions.

*   `--without-bzlib` disable BZLIB support.
*   `--without-dps` disable Display Postscript support.
*   `--with-fpx` enable FlashPIX support.
*   `--without-freetype` disable TrueType support.
*   `--with-gslib` enable Ghostscript library support.
*   `--without-jbig` disable JBIG support.
*   `--without-jpeg` disable JPEG support.
*   `--without-jp2` disable JPEG v2 support.
*   `--without-lcms` disable LCMS support.
*   `--without-lzma` disable LZMA support.
*   `--without-png` disable PNG support.
*   `--without-tiff` disable TIFF support.
*   `--without-wmf` disable WMF support.
*   `--with-fontpath` prepend to default font search path.

*   `--with-gs-font-dir` directory containing Ghostscript fonts.
      
    Specify the directory containing the Ghostscript Postscript Type 1 font files (e.g. n022003l.pfb) so that they can be rendered using the FreeType library. If the font files are installed using the default Ghostscript installation paths (${prefix}/share/ghostwww/fonts), they should be discovered automagically by configure and specifying this option is not necessary. Specify this option if the Ghostscript fonts fail to be located automagically, or the location needs to be overridden.

*   `--with-windows-font-dir` directory containing MS-Windows fonts.
      
    Specify the directory containing MS-Windows-compatible fonts. This not necessary when ImageMagick is running under MS-Windows.

*   `--without-xml` disable XML support.
*   `--without-zlib` disable ZLIB support.
*   `--without-x` don't use the X Window System.
      
    By default, ImageMagick uses the X11 delegate libraries if they are available. When --without-x is specified, use of X11 is disabled. The display, animate, and import sub-commands are not included. The remaining sub-commands have reduced functionality such as no access to X11 fonts (consider using Postscript or TrueType fonts instead).

*   `--with-share-path=DIR`

    Alternate path to share directory (default share/ImageMagick).

*   `--with-libstdc=DIR` use libstdc++ in DIR (for GNU C++).

While configure is designed to ease installation of ImageMagick, it often discovers problems that would otherwise be encountered later when compiling ImageMagick. The configure script tests for headers and libraries by executing the compiler (CC) with the specified compilation flags (CFLAGS), pre-processor flags (CPPFLAGS), and linker flags (LDFLAGS). Any errors are logged to the file config.log. If configure fails to discover a header or library please review this log file to determine why, however, please be aware that *errors in the config.log are normal* because configure works by trying something and seeing if it fails. An error in config.log is only a problem if the test should have passed on your system.

Common causes of configure failures are: 1) a delegate header is not in the header include path (CPPFLAGS -I option); 2) a delegate library is not in the linker search/run path (LDFLAGS -L/-R option); 3) a delegate library is missing a function (old version?); or 4) compilation environment is faulty.

If all reasonable corrective actions have been tried and the problem appears be due to a flaw in the configure script, please send a bug report to the [ImageMagick Defect Support Forum](https://github.com/ImageMagick/ImageMagick/issues). All bug reports should contain the operating system type (as reported by uname -a) and the compiler/compiler-version. A copy of the configure script output and/or the relevant portion of config.log file may be valuable in order to find the problem. If you post portions of config.log, please also send a script of the configure output and a description of what you expected to see (and why) so the failure you are observing can be identified and resolved.

ImageMagick is now configured and ready to build

Build
-----

Once ImageMagick is configured, these standard build targets are available from the generated make files:

    make

Build ImageMagick.

    sudo make install

Install ImageMagick.

    make check

Run tests using the installed ImageMagick (sudo make install must be done first). Ghostscript and Freetype are prerequisites, otherwise certain unit tests that render text and the EPS, PS, and PDF formats will likely fail.

    make clean

Remove everything in the build directory created by make.

    make distclean

remove everything in the build directory created by configure and make. This useful if you want to start over from scratch.

    make uninstall

Remove all files from the system which are (or would be) installed by sudo make install using the current configuration. Note that this target is imperfect for PerlMagick since Perl no longer supports an uninstall target.

In most cases you will simply want to compile ImageMagick with this command:

    make 

Once built, you can optionally install ImageMagick on your system as discussed below.

Install
-------

Now that ImageMagick is configured and built, type:

    make install 

to install it.

By default, ImageMagick is installs binaries in /../usr/local/bin, libraries in /../usr/local/lib, header files in /../usr/local/include and documentation in /../usr/local/share. You can specify an alternative installation prefix other than /../usr/local by giving configure the option --prefix=PATH. This valuable in case you don't have privileges to install under the default paths or if you want to install in the system directories instead.

To confirm your installation of the ImageMagick distribution was successful, ensure that the installation directory is in your executable search path and type:

    magick logo: logo.gif
    identify logo.gif

The ImageMagick logo is displayed on your X11 display.

To verify the ImageMagick build configuration, type:

    magick identify -list configure

To list which image formats are supported , type:

    magick identify -list format 

For a more comprehensive test, you run the ImageMagick test suite by typing:

    make check

Ghostscript is a prerequisite, otherwise the EPS, PS, and PDF tests will fail. Note that due to differences between the developer's environment and your own it is possible that a few tests may fail even though the results are ok. Differences between the developer's environment and your own may include the compiler, the CPU type, and the library versions used. The ImageMagick developers use the current release of all dependent libraries.

Linux-specific Build instructions
---------------------------------

Download [ImageMagick.src.rpm](https://imagemagick.org/archive/linux/SRPMS/ImageMagick.src.rpm) from [imagemagick.org](https://imagemagick.org/archive) or its [mirrors] and verify the distribution against its [message digest](https://imagemagick.org/archive/linux/SRPMS/digest.rdf).

Build ImageMagick with this command:

    rpmbuild --rebuild ImageMagick.src.rpm

After the build you, locate the RPMS folder and install the ImageMagick binary RPM distribution:

    $ rpm -ivh ImageMagick-7.1.0-?.*.rpm

Mac OS X-specific Build instructions
------------------------------------

Perform these steps as an administrator or with the sudo command:

Install [MacPorts](http://www.macports.org). Download and install MacPorts and type the following commands:

    sudo port -v install freetype +bytecode
    sudo port -v install librsvg
    sudo port -v install graphviz +gs +wmf +jbig +jpeg2 +lcms 

This installs many of the delegate libraries ImageMagick will utilize such as JPEG and FreeType.

Install the latest [Xcode](http://developer.apple.com/tools/download/) from Apple.

Use the port command to install any delegate libraries you require, for example:

    sudo port install jpeg 

Now lets build ImageMagick:

[Download] the ImageMagick source distribution and verify the distribution against its [message digest](https://imagemagick.org/archive/digest.rdf).

Unpack and change into the top-level ImageMagick directory:

    $ tar xvzf ImageMagick-7.1.0-62.tar.gz$ cd ImageMagick-7.1.0-62

Configure ImageMagick:

    ./configure --prefix=/opt --with-quantum-depth=16 \
      --disable-dependency-tracking --with-x=yes \
      --x-includes=/usr/X11R6/include --x-libraries=/usr/X11R6/lib/ \
      --without-perl" 

Build ImageMagick:

    make 

Install ImageMagick:

    sudo make install 

To verify your install, type

    /opt/local/bin/identify -list font 

to list all the fonts ImageMagick knows about.

To test the ImageMagick GUI, in a new shell, type:

    display -display :0 

MinGW-specific Build instructions
---------------------------------

Although you can download and install delegate libraries yourself, many are already available in the [GnuWin32](http://gnuwin32.sourceforge.net/) distribution. Download and install whichever delegate libraries you require such as JPEG, PNG, TIFF, etc. Make sure you specify the development headers when you install a package. Next type,

    $ tar jxvf ImageMagick-7.1.0-?.tar.bz2$ cd ImageMagick-7.1.0-62$ export CPPFLAGS="-Ic:/Progra~1/GnuWin32/include"$ export LDFLAGS="-Lc:/Progra~1/GnuWin32/lib"$ ./configure --without-perl$ make$ sudo make install

Dealing with Unexpected Problems
--------------------------------

Chances are the download, configure, build, and install of ImageMagick went flawlessly as it is intended, however, certain systems and environments may cause one or more steps to fail. We discuss a few problems we've run across and how to take corrective action to ensure you have a working release of ImageMagick

#### Build Problems

If the build complains about missing dependencies (e.g. .deps/source.PLO), add --disable-dependency-tracking to your configure command line.

Some systems may fail to link at build time due to unresolved symbols. Try adding the LDFLAGS to the configure command line:

    configure LDFLAGS='-L/usr/local/lib -R/usr/local/lib' 

#### Dynamic Linker Run-time Bindings

On some systems, ImageMagick may not find its shared library, libMagick.so. Try running the ldconfig with the library path:

    /sbin/ldconfig /usr/local/lib 

Solaris and Linux systems have the ldd command which is useful to track which libraries ImageMagick depends on:

    ldd `which convert` 

#### Delegate Libraries

On occasion you may receive these warnings:

    no decode delegate for this image format
    no encode delegate for this image format 

This exception indicates that an external delegate library or its headers were not available when ImageMagick was built. To add support for the image format, download and install the requisite delegate library and its header files and reconfigure, rebuild, and reinstall ImageMagick. As an example, lets add support for the JPEG image format. First we install the JPEG RPMS:

    yum install libjpeg libjpeg-devel 

Now reconfigure, rebuild, and reinstall ImageMagick. To verify JPEG is now properly supported within ImageMagick, use this command:

    magick identify -list format 

You should see a mode of rw- associated with the JPEG tag. This mode means the image can be read or written and can only support one image per image file.

#### PerlMagick

If PerlMagick fails to link with a message similar to libperl.a is not found, rerun configure with the --enable-shared or --enable-shared --with-modules options.


/Advanced Unix Installation
============================

It's possible you don't want to concern yourself with advanced installation under Unix or Linux systems. If so, you also have the option of installing a pre-compiled [binary release] or if you still want to install from source without all the fuss see the simple [Install From Source] instructions. However, if you want to customize the configuration and installation of ImageMagick under Unix or Linux systems, lets begin.

Download & Unpack
-----------------

ImageMagick builds on a variety of Unix and Unix-like operating systems including Linux, Solaris, FreeBSD, Mac OS X, and others. A compiler is required and fortunately almost all modern Unix systems have one. Download [ImageMagick.tar.gz](https://download.imagemagick.org/ImageMagick/download/ImageMagick.tar.gz) from [imagemagick.org] or a [mirror] and verify the distribution against its [message digest](https://download.imagemagick.org/ImageMagick/download/digest.rdf).

Unpack the distribution it with this command:

    tar xvzf ImageMagick.tar.gz
    

Now that you have the ImageMagick Unix/Linux source distribution unpacked, let's configure it.

Configure
---------

The configure script looks at your environment and decides what it can cobble together to get ImageMagick compiled and installed on your system. This includes finding a compiler, where your compiler header files are located (e.g. stdlib.h), and if any delegate libraries are available for ImageMagick to use (e.g. JPEG, PNG, TIFF, etc.). If you are willing to accept configure's default options, and build from within the source directory, you can simply type:

    $ cd ImageMagick-7.0.10-62$ ./configure

Watch the configure script output to verify that it finds everything that you think it should. Pay particular attention to the last lines of the script output. For example, here is a recent report from our system:

    ImageMagick is configured as follows. Please verify that this configuration
    matches your expectations.
    
    Host system type: x86_64-unknown-linux-gnu
    Build system type: x86_64-unknown-linux-gnu
    
                      Option                     Value
    -------------------------------------------------------------------------------
    Shared libraries  --enable-shared=yes		yes
    Static libraries  --enable-static=yes		yes
    Module support    --with-modules=yes		yes
    GNU ld            --with-gnu-ld=yes		yes
    Quantum depth     --with-quantum-depth=16	16
    High Dynamic Range Imagery
                      --enable-hdri=no		no
    
    Delegate Configuration:
    BZLIB             --with-bzlib=yes		yes
    Autotrace         --with-autotrace=yes	yes
    DJVU              --with-djvu=yes		no
    DPS               --with-dps=yes		no
    FlashPIX          --with-fpx=yes		no
    FontConfig        --with-fontconfig=yes	yes
    FreeType          --with-freetype=yes		yes
    GhostPCL          None			pcl6 (unknown)
    GhostXPS          None			gxps (unknown)
    Ghostscript       None			gs (8.63)
    result_ghostscript_font_dir='none'
    Ghostscript fonts --with-gs-font-dir=default
    Ghostscript lib   --with-gslib=yes		no (failed tests)
    Graphviz          --with-gvc=yes		yes
    JBIG              --with-jbig=		no
    JPEG v1           --with-jpeg=yes		yes
    JPEG-2000         --with-jp2=yes		yes
    LCMS              --with-lcms=yes		yes
    LQR               --with-lqr=yes		no
    Magick++          --with-magick-plus-plus=yes	yes
    OpenEXR           --with-openexr=yes		yes
    PERL              --with-perl=yes		/usr/bin/perl
    PNG               --with-png=yes		yes
    RSVG              --with-rsvg=yes		yes
    TIFF              --with-tiff=yes		yes
    result_windows_font_dir='none'
    Windows fonts     --with-windows-font-dir=
    WMF               --with-wmf=yes		yes
    X11               --with-x=			yes
    XML               --with-xml=yes		yes
    ZLIB              --with-zlib=yes		yes
    
    X11 Configuration:
          X_CFLAGS        =
          X_PRE_LIBS      = -lSM -lICE
          X_LIBS          =
          X_EXTRA_LIBS    =
    
    Options used to compile and link:
      PREFIX          = /usr/local
      EXEC-PREFIX     = /usr/local
      VERSION         = 6.4.8
      CC              = gcc -std=gnu99
      CFLAGS          = -fopenmp -g -O2 -Wall -W -pthread
      MAGICK_CFLAGS   = -fopenmp -g -O2 -Wall -W -pthread
      CPPFLAGS        = -I/usr/local/include/ImageMagick
      PCFLAGS         = -fopenmp
      DEFS            = -DHAVE_CONFIG_H
      LDFLAGS         = -lfreetype
      MAGICK_LDFLAGS  = -L/usr/local/lib -lfreetype
      LIBS            = -lMagickCore-Q16 -llcms -ltiff -lfreetype -ljpeg -lfontconfig -lXext
                        -lSM -lICE -lX11 -lXt -lbz2 -lz -lm -lgomp -lpthread -lltdl
      CXX             = g++
      CXXFLAGS        = -g -O2 -Wall -W -pthread
    

You can influence choice of compiler, compilation flags, or libraries of the configure script by setting initial values for variables in the configure command line. These include, among others:

*   `CC`  Name of C compiler (e.g. `cc -Xa`) to use.
*   `CXX`  Name of C++ compiler to use (e.g. `CC`).
*   `CFLAGS`  Compiler flags (e.g. `-g -O2`) to compile C code.
*   `CXXFLAGS`  Compiler flags (e.g. `-g -O2`) to compile C++ code.
*   `CPPFLAGS`  Include paths (.e.g. `-I/usr/local`) to look for header files.

*   `LDFLAGS`

    Library paths (.e.g. `-L/usr/local`) to look for libraries systems that support the notion of a library run-path may require an additional argument in order to find shared libraries at run time. For example, the Solaris linker requires an argument of the form -R/path. Some Linux systems will work with `-rpath /usr/local/lib`, while some other Linux systems who's gcc does not pass `-rpath` to the linker, require an argument of the form `-Wl,-rpath,/usr/local/lib`.

*   `LIBS`  Extra libraries (.e.g. `-l/usr/local/lib`) required to link.

Here is an example of setting configure variables from the command line:

    configure CC=c99 CFLAGS=-O2 LDFLAGS='-L/usr/local/lib -R/usr/local/lib' LIBS=-lposix
    

Any variable (e.g. CPPFLAGS or LDFLAGS) which requires a directory path must specify an absolute path rather than a relative path.

Configure can usually find the X include and library files automagically, but if it doesn't, you can use the --x-includes=path and --x-libraries=path options to specify their locations.

The configure script provides a number of ImageMagick specific options. When disabling an option --disable-something is equivalent to specifying --enable-something=no and --without-something is equivalent to --with-something=no. The configure options are as follows (execute `configure --help` to see all options).

ImageMagick options represent either features to be enabled, disabled, or packages to be included in the build. When a feature is enabled (via --enable-something), it enables code already present in ImageMagick. When a package is enabled (via --with-something), the configure script will search for it, and if is properly installed and ready to use (headers and built libraries are found by compiler) it will be included in the build. The configure script is delivered with all features disabled and all packages enabled. In general, the only reason to disable a package is if a package exists but it is unsuitable for the build (perhaps an old version or not compiled with the right compilation flags).

Here are the optional features you can configure:

*   `--enable-shared`

    build the shared libraries and support for loading coder and process modules. Shared libraries are preferred because they allow programs to share common code, making the individual programs much smaller. In addition shared libraries are required in order for PerlMagick to be dynamically loaded by an installed PERL (otherwise an additional PERL (PerlMagick) must be installed.  
      
    ImageMagick built with delegates (see MAGICK PLUG-INS below) can pose additional challenges. If ImageMagick is built using static libraries (the default without `--enable-shared`) then delegate libraries may be built as either static libraries or shared libraries. However, if ImageMagick is built using shared libraries, then all delegate libraries must also be built as shared libraries. Static libraries usually have the extension `.a`, while shared libraries typically have extensions like `.so`, `.sa`, or `.dll`. Code in shared libraries normally must compiled using a special compiler option to produce Position Independent Code (PIC). The only time this not necessary is if the platform compiles code as PIC by default.  
      
    PIC compilation flags differ from vendor to vendor (gcc's is `-fPIC`). However, you must compile all shared library source with the same flag (for gcc use `-fPIC` rather than `-fpic`). While static libraries are normally created using an archive tool like `ar`, shared libraries are built using special linker or compiler options (e.g. `-shared` for gcc).  
      
    If `--enable-shared` is not specified, a new PERL interpreter (PerlMagick) is built which is statically linked against the PerlMagick extension. This new interpreter is installed into the same directory as the ImageMagick utilities. If `--enable-shared` is specified, the PerlMagick extension is built as a dynamically loadable object which is loaded into your current PERL interpreter at run-time. Use of dynamically-loaded extensions is preferable over statically linked extensions so use `--enable-shared` if possible (note that all libraries used with ImageMagick must be shared libraries!).

*   `--disable-static`

    static archive libraries (with extension `.a`) are not built. If you are building shared libraries, there is little value to building static libraries. Reasons to build static libraries include: 1) they can be easier to debug; 2) clients do not have external dependencies (i.e. libMagick.so); 3) building PIC versions of the delegate libraries may take additional expertise and effort; 4) you are unable to build shared libraries.

*   `--disable-installed`

    disable building an installed ImageMagick (default enabled).  
      
    By default the ImageMagick build is configured to formally install into a directory tree. This the most secure and reliable way to install ImageMagick. Use this option to configure ImageMagick so that it doesn't use hard-coded paths and locates support files by computing an offset path from the executable (or from the location specified by the MAGICK_HOME environment variable. The uninstalled configuration is ideal for binary distributions which are expected to extract and run in any location.

*   `--enable-ccmalloc` enable 'ccmalloc' memory debug support (default disabled).
*   `--enable-prof` enable 'prof' profiling support (default disabled).
*   `--enable-gprof` enable 'gprof' profiling support (default disabled).
*   `--enable-gcov` enable 'gcov' profiling support (default disabled).
*   `--disable-openmp` disable OpenMP (default enabled).
      
    Certain ImageMagick algorithms, for example convolution, can achieve a significant speed-up with the assistance of the OpenMP API when running on modern dual and quad-core processors.

*   `--disable-largefile` disable support for large (64 bit) file offsets.
      
    By default, ImageMagick is compiled with support for large files (> 2GB on a 32-bit CPU) if the operating system supports large files. Some applications which use the ImageMagick library may also require support for large files. By disabling support for large files via `--disable-largefile`, dependent applications do not require special compilation options for large files in order to use the library. Here are the optional packages you can configure:

*   `--with-quantum-depth` number of bits in a pixel quantum (default 16).
      
    Use this option to specify the number of bits to use per pixel quantum (the size of the red, green, blue, and alpha pixel components). For example, `--with-quantum-depth=8` builds ImageMagick using 8-bit quantums. Most computer display adapters use 8-bit quantums. Currently supported arguments are 8, 16, or 32. We recommend the default of 16 because some image formats support 16 bits-per-pixel. However, this option is important in determining the overall run-time performance of ImageMagick.  
      
    The number of bits in a quantum determines how many values it may contain. Each quantum level supports 256 times as many values as the previous level. The following table shows the range available for various quantum sizes.  
      

        Quantum Depth     Valid Range (Decimal)   Valid Range (Hex)
            8             0-255                   00-FF
           16             0-65535                 0000-FFFF
           32             0-4294967295            00000000-FFFFFFFF
        

      
      
    Larger pixel quantums can cause ImageMagick to run more slowly and to require more memory. For example, using sixteen-bit pixel quantums can cause ImageMagick to run 15% to 50% slower (and take twice as much memory) than when it is built to support eight-bit pixel quantums.  
      
    The amount of virtual memory consumed by an image can be computed by the equation (5 * Quantum Depth * Rows * Columns) / 8. This an important consideration when resources are limited, particularly since processing an image may require several images to be in memory at one time. The following table shows memory consumption values for a 1024x768 image:  
      

        Quantum Depth   Virtual Memory
             8               3MB
            16               8MB
            32              15MB
        

*   `--enable-hdri` accurately represent the wide range of intensity levels.
*   `--enable-osx-universal-binary` build a universal binary on OS X.
*   `--without-modules` disable support for dynamically loadable modules.
      
    Image coders and process modules are built as loadable modules which are installed under the directory [prefix]/lib/ImageMagick-X.X.X/modules-QN (where 'N' equals 8, 16, or 32 depending on the quantum depth) in the subdirectories `coders` and `filters` respectively. The modules build option is only available in conjunction with `--enable-shared`. If `--enable-shared` is not also specified, support for building modules is disabled. Note that if `--enable-shared` and `--disable-modules` are specified, the module loader is active (allowing extending an installed ImageMagick by simply copying a module into place) but ImageMagick itself is not built using modules.

*   `--with-cache` set pixel cache threshold (defaults to available memory).
      
    Specify a different image pixel cache threshold with this option. This sets the maximum amount of heap memory that ImageMagick is allowed to consume before switching to using memory-mapped temporary files to store raw pixel data.

*   `--without-threads` disable threads support.
      
    By default, the ImageMagick library is compiled with multi-thread support. If this undesirable, specify `--without-threads`.

*   `--with-frozenpaths` enable frozen delegate paths.
      
    Normally, external program names are substituted into the `delegates.xml` configuration file without full paths. Specify this option to enable saving full paths to programs using locations determined by configure. This useful for environments where programs are stored under multiple paths, and users may use different PATH settings than the person who builds ImageMagick.

*   `--without-magick-plus-plus` disable build/install of Magick++.
      
    Disable building Magick++, the C++ application programming interface to ImageMagick. A suitable C++ compiler is required in order to build Magick++. Specify the CXX configure variable to select the C++ compiler to use (default `g++`), and CXXFLAGS to select the desired compiler optimization and debug flags (default `-g -O2`). Antique C++ compilers will normally be rejected by configure tests so specifying this option should only be necessary if Magick++ fails to compile.

*   `--without-perl` disable build/install of PerlMagick, or
      
    By default, PerlMagick is conveniently compiled and installed as part of ImageMagick's normal `configure`, `make`, `sudo make install` process. When `--without-perl` is specified, you must first install ImageMagick, change to the PerlMagick subdirectory, build, and finally install PerlMagick. Note, PerlMagick is configured even if `--without-perl` is specified. If the argument --with-perl=/path/to/perl is supplied, /../path/to/perl is be taken as the PERL interpreter to use. This important in case the `perl` executable in your PATH is not PERL5, or is not the PERL you want to use.

*   `--with-perl=PERL` use specified Perl binary to configure PerlMagick.
*   `--with-perl-options=OPTIONS`

    options to pass on command-line when generating PerlMagick's Makefile from Makefile.PL.  
      
    The PerlMagick module is normally installed using the Perl interpreter's installation PREFIX, rather than ImageMagick's. If ImageMagick's installation prefix is not the same as PERL's PREFIX, then you may find that PerlMagick's `sudo make install` step tries to install into a directory tree that you don't have write permissions to. This common when PERL is delivered with the operating system or on Internet Service Provider (ISP) web servers. If you want PerlMagick to install elsewhere, then provide a PREFIX option to PERL's configuration step via "--with-perl-options=PREFIX=/some/place". Other options accepted by MakeMaker are 'LIB', 'LIBPERL_A', 'LINKTYPE', and 'OPTIMIZE'. See the ExtUtils::MakeMaker(3) manual page for more information on configuring PERL extensions.

*   `--without-bzlib` disable BZLIB support.
*   `--without-dps` disable Display Postscript support.
*   `--with-fpx` enable FlashPIX support.
*   `--without-freetype` disable TrueType support.
*   `--with-gslib` enable Ghostscript library support.
*   `--without-jbig` disable JBIG support.
*   `--without-jpeg` disable JPEG support.
*   `--without-jp2` disable JPEG v2 support.
*   `--without-lcms` disable LCMS support.
*   `--without-lzma` disable LZMA support.
*   `--without-png` disable PNG support.
*   `--without-tiff` disable TIFF support.
*   `--without-wmf` disable WMF support.
*   `--with-fontpath` prepend to default font search path.
*   `--with-gs-font-dir` directory containing Ghostscript fonts.
      
    Specify the directory containing the Ghostscript Postscript Type 1 font files (e.g. `n022003l.pfb`) so that they can be rendered using the FreeType library. If the font files are installed using the default Ghostscript installation paths (${prefix}/share/ghostwww/fonts), they should be discovered automagically by configure and specifying this option is not necessary. Specify this option if the Ghostscript fonts fail to be located automagically, or the location needs to be overridden.

*   `--with-windows-font-dir` directory containing MS-Windows fonts.
      
    Specify the directory containing MS-Windows-compatible fonts. This not necessary when ImageMagick is running under MS-Windows.

*   `--without-xml` disable XML support.
*   `--without-zlib` disable ZLIB support.
*   `--without-x` don't use the X Window System.
      
    By default, ImageMagick uses the X11 delegate libraries if they are available. When --without-x is specified, use of X11 is disabled. The display, animate, and import sub-commands are not included. The remaining sub-commands have reduced functionality such as no access to X11 fonts (consider using Postscript or TrueType fonts instead).

*   `--with-share-path=DIR`

    Alternate path to share directory (default share/ImageMagick).

*   `--with-libstdc=DIR` use libstdc++ in DIR (for GNU C++).

While `configure` is designed to ease installation of ImageMagick, it often discovers problems that would otherwise be encountered later when compiling ImageMagick. The configure script tests for headers and libraries by executing the compiler (CC) with the specified compilation flags (CFLAGS), pre-processor flags (CPPFLAGS), and linker flags (LDFLAGS). Any errors are logged to the file `config.log`. If configure fails to discover a header or library please review this log file to determine why, however, please be aware that *errors in the `config.log` are normal* because configure works by trying something and seeing if it fails. An error in `config.log` is only a problem if the test should have passed on your system.

Common causes of configure failures are: 1) a delegate header is not in the header include path (CPPFLAGS -I option); 2) a delegate library is not in the linker search/run path (LDFLAGS -L/-R option); 3) a delegate library is missing a function (old version?); or 4) compilation environment is faulty.

If all reasonable corrective actions have been tried and the problem appears be due to a flaw in the configure script, please send a bug report to the [ImageMagick Defect Support Forum](https://github.com/ImageMagick/ImageMagick/issues). All bug reports should contain the operating system type (as reported by `uname -a`) and the compiler/compiler-version. A copy of the configure script output and/or the relevant portion of `config.log` file may be valuable in order to find the problem. If you post portions of `config.log`, please also send a script of the configure output and a description of what you expected to see (and why) so the failure you are observing can be identified and resolved.

ImageMagick is now configured and ready to build

Build
-----

Once ImageMagick is configured, these standard build targets are available from the generated `make` files:

    make

Build ImageMagick.

    sudo make install

Install ImageMagick.

    make check

Run tests using the installed ImageMagick (`sudo make install` must be done first). Ghostscript and Freetype are prerequisites, otherwise certain unit tests that render text and the EPS, PS, and PDF formats will likely fail.

    make clean

Remove everything in the build directory created by `make`.

    make distclean

remove everything in the build directory created by `configure` and `make`. This useful if you want to start over from scratch.

    make uninstall

Remove all files from the system which are (or would be) installed by `sudo make install` using the current configuration. Note that this target is imperfect for PerlMagick since Perl no longer supports an uninstall target.

In most cases you will simply want to compile ImageMagick with this command:

    make
    

Once built, you can optionally install ImageMagick on your system as discussed below.

Install
-------

Now that ImageMagick is configured and built, type:

    make install
    

to install it.

By default, ImageMagick is installs binaries in `/../usr/local/bin`, libraries in `/../usr/local/lib`, header files in `/../usr/local/include` and documentation in `/../usr/local/share`. You can specify an alternative installation prefix other than `/../usr/local` by giving `configure` the option --prefix=PATH. This valuable in case you don't have privileges to install under the default paths or if you want to install in the system directories instead.

To confirm your installation of the ImageMagick distribution was successful, ensure that the installation directory is in your executable search path and type:

    magick logo: logo.gif
    identify logo.gif
    

The ImageMagick logo is displayed on your X11 display.

To verify the ImageMagick build configuration, type:

    magick identify -list configure
    

To list which image formats are supported , type:

    magick identify -list format
    

For a more comprehensive test, you run the ImageMagick test suite by typing:

    make check
    

Ghostscript is a prerequisite, otherwise the EPS, PS, and PDF tests will fail. Note that due to differences between the developer's environment and your own it is possible that a few tests may fail even though the results are ok. Differences between the developer's environment and your own may include the compiler, the CPU type, and the library versions used. The ImageMagick developers use the current release of all dependent libraries.

Linux-specific Build instructions
---------------------------------

Download [ImageMagick.src.rpm](https://download.imagemagick.org/ImageMagick/download/linux/SRPMS/ImageMagick.src.rpm) from [ftp.imagemagick.org] or its [mirrors] and verify the distribution against its [message digest](https://download.imagemagick.org/ImageMagick/download/linux/SRPMS/digest.rdf).

Build ImageMagick with this command:

    rpmbuild --rebuild ImageMagick.src.rpm
    

After the build you, locate the RPMS folder and install the ImageMagick binary RPM distribution:

    $ rpm -ivh ImageMagick-7.0.10-?.*.rpm

Mac OS X-specific Build instructions
------------------------------------

Perform these steps as an administrator or with the sudo command:

Install [MacPorts](http://www.macports.org). Download and install MacPorts and type the following commands:

    sudo port -v install freetype +bytecode
    sudo port -v install librsvg
    sudo port -v install graphviz +gs +wmf +jbig +jpeg2 +lcms
    

This installs many of the delegate libraries ImageMagick will utilize such as JPEG and FreeType.

Install the latest [Xcode](http://developer.apple.com/tools/download/) from Apple.

Use the port command to install any delegate libraries you require, for example:

    sudo port install jpeg
    

Now lets build ImageMagick:

[Download] the ImageMagick source distribution and verify the distribution against its [message digest](https://download.imagemagick.org/ImageMagick/download/digest.rdf).

Unpack and change into the top-level ImageMagick directory:

$ tar xvzf ImageMagick-7.0.10-62.tar.gz$ cd ImageMagick-7.0.10-62

Configure ImageMagick:

    ./configure --prefix=/opt --with-quantum-depth=16 \
      --disable-dependency-tracking --with-x=yes \
      --x-includes=/usr/X11R6/include --x-libraries=/usr/X11R6/lib/ \
      --without-perl"
    

Build ImageMagick:

    make
    

Install ImageMagick:

    sudo make install
    

To verify your install, type

    /opt/local/bin/identify -list font
    

to list all the fonts ImageMagick knows about.

To test the ImageMagick GUI, in a new shell, type:

    display -display :0
    

MinGW-specific Build instructions
---------------------------------

Although you can download and install delegate libraries yourself, many are already available in the [GnuWin32](http://gnuwin32.sourceforge.net/) distribution. Download and install whichever delegate libraries you require such as JPEG, PNG, TIFF, etc. Make sure you specify the development headers when you install a package. Next type,

    $ tar jxvf ImageMagick-7.0.10-?.tar.bz2  
    $ cd ImageMagick-7.0.10-62  
    $ export CPPFLAGS="-Ic:/Progra~1/GnuWin32/include"  
    $ export LDFLAGS="-Lc:/Progra~1/GnuWin32/lib"  
    $ ./configure --without-perl  
    $ make  
    $ sudo make install

Dealing with Unexpected Problems
--------------------------------

Chances are the download, configure, build, and install of ImageMagick went flawlessly as it is intended, however, certain systems and environments may cause one or more steps to fail. We discuss a few problems we've run across and how to take corrective action to ensure you have a working release of ImageMagick

##### Build Problems

If the build complains about missing dependencies (e.g. .deps/source.PLO), add `--disable-dependency-tracking` to your `configure` command line.

Some systems may fail to link at build time due to unresolved symbols. Try adding the LDFLAGS to the `configure` command line:

    configure LDFLAGS='-L/usr/local/lib -R/usr/local/lib'
    

##### Dynamic Linker Run-time Bindings

On some systems, ImageMagick may not find its shared library, libMagick.so. Try running the `ldconfig` with the library path:

    /sbin/ldconfig /usr/local/lib
    

Solaris and Linux systems have the `ldd` command which is useful to track which libraries ImageMagick depends on:

    ldd `which convert`
    

##### Delegate Libraries

On occasion you may receive these warnings:

    no decode delegate for this image format
    no encode delegate for this image format
    

This exception indicates that an external delegate library or its headers were not available when ImageMagick was built. To add support for the image format, download and install the requisite delegate library and its header files and reconfigure, rebuild, and reinstall ImageMagick. As an example, lets add support for the JPEG image format. First we install the JPEG RPMS:

    yum install libjpeg libjpeg-devel
    

Now reconfigure, rebuild, and reinstall ImageMagick. To verify JPEG is now properly supported within ImageMagick, use this command:

    magick identify -list format
    

You should see a mode of rw- associated with the JPEG tag. This mode means the image can be read or written and can only support one image per image file.

##### PerlMagick

If PerlMagick fails to link with a message similar to libperl.a is not found, rerun `configure` with the `--enable-shared` or `--enable-shared --with-modules` options.


/Advanced Windows Installation
===============================

This document describes the requirements and instructions to build ImageMagick for Windows on your own machine.

Requirements
------------

*   Visual Studio 2013 (or newer)
*   Git for Windows
*   AMD APP SDK (optional for OpenCL support)

Install Visual Studio dependencies
----------------------------------

To build ImageMagick with Visual Studio the following components should be installed:

*   Desktop development with C++ (workload)
*   Visual C++ ATL for x86 and x64
*   Visual C++ MFC for x86 and x64

Naming of these components might differ between version of Visual Studio. The example above use the Visual Studio 2017 names.

Clone the dependencies
----------------------

The ImageMagick library is build with a number of third party libraries. Run CloneRepositories.cmd to clone these libraries and the ImageMagick library.

Build configure.exe
-------------------

One of the folders that was created in the previous step is called VisualMagick and this folder contains a folder called configure. This folder contains a solution configure.sln. Open this solution with Visual Studio and start a Release build of the project. This will create a file called configure.exe in the folder. Running this program will start a Wizard that allows configuration of ImageMagick and its individual components.

Build ImageMagick
-----------------

Depending on which options where chosen when running configure.exe one of the following solutions will be created in the VisualMagick folder:

*   VisualDynamicMT.sln (Dynamic Multi-threaded DLL runtimes)
*   VisualStaticMTD.sln (Static Multi-threaded DLL runtimes)
*   VisualStaticMT.sln (Static Multi-threaded runtimes)

Open the solution to start building ImageMagick. The binaries will be created in the VisualMagick\bin folder.


/Examples of ImageMagick Usage
==============================

ImageMagick Version 7

These web pages presents a set of examples using [ImageMagick](https://imagemagick.org/) ("IM," for short), version 7, from the command line. However, they often have direct analogs in the legacy release of ImageMagick, [version 6](https://imagemagick.org). They also illustrate what can be done using the ImageMagick Application Programming Interface (API). As such, these pages should be the first stop for IM users after reading the terse [Command Line (CLI) Option manuals](https://imagemagick.org/script/command-line-options.php).

Often, the same questions of "_How do I..._" gets asked, over and over again on the network. The examples in these web pages, I hope, will answer most of the common "how-to" questions that arise.

![[IM Logo]](https://imagemagick.org/Usage/images/logo.gif)


[Download Page](https://imagemagick.org/script/download.php), 
[CentOS RPM](https://imagemagick.org/download/linux/CentOS/x86_64/),  
[Linux SRPM](https://imagemagick.org/download/linux/SRPMS/), 
[Beta Release](https://imagemagick.org/download/beta/)  
[Discussion Server](https://github.com/ImageMagick/ImageMagick/discussions)

Other related sites...


[Fred's ImageMagick Scripts](http://www.fmwconcepts.com/imagemagick/)  
[RubbleWebs, PHP using IM CLI](http://www.rubblewebs.co.uk/imagemagick/imagemagick.php)  
[Snibgo's ImageMagick pages](https://im.snibgo.com/)

Main ImageMagick Web Site](https://imagemagick.org/)

-----    Practical Examples    -----

*  [Basic Usage]  Basic command and image handling
*  [Image File Handling]  Reading and writing images
*  [Common Image Formats]  Handling GIF, JPEG, and PNG images
*  [Text to Image Handling]  Converting text into images
*  [Compound Font Effects]  Font drawing styles and techniques
*  [Annotating Images]  Labeling and overlaying images
*  [Thumbnails and Framing]  Small reference images of large photos
*  [Photo Handling]  Modifying photographs
*  [Lens Correction]  Correcting photo distortions
*  [Montage, Arrays of Images]  Image indexes and arrays
*  [Layers of Multiple Images]  Combining multiple images together
*  [Animation Basics]  Creation and study of animations
*  [Animation Optimization]  Making GIF animations smaller
*  [Animation Modifications]  Changing and merging animations
*  [Video Handling]  Handling real life video images
*  [Image Comparing]  Comparing two or more images
*  [Advanced Techniques]  Complex manipulations of images
*  [Background Examples]  Examples of creating random backgrounds
*  [Repositories Links]  Links to other IM scripts and info
*  [Reference Index]  Quick index for specific options
*  [Support Scripts]  Shell scripts used by examples

-----  **Basic Techniques**  -----

*  [Canvas Creation]  Creating canvas and background images
*  [Color Basics and Channels]  Low level color handling
*  [Color Modifications]  General color changes
*  [Masking and Background Removal]  Alpha channel, and transparency handling
*  [Color Quantization and Dithering]  Reducing the number of colors
*  [Cutting and Bordering]  Slicing, dicing, framing, trimming
*  [Resizing or Scaling]  Enlarging and shrinking images
*  [Resampling Filters]  Controlling image resizing
*  [Compositing Images]  Overlaying and merging two images
*  [Drawing on Images]  Vector graphics, MVG and SVG images
*  [Simple Image Warping]  Flipping, rotating, twisting
*  [Distorting Images]  Carnival house of mirrors
*  [Image Transformations]  Drastic changes to the look of an image
*  [Image Mapping Effects]  Lens, glass and ripple effects
*  [Blurring and Sharpening Images]  Blurring, sharpening and shadows
*  [Morphology of Shapes]  Using pixel neighbourhoods
*  [Convolution of Images]  Weighted averaged neighbourhoods
*  [Fourier Transforms]  Modifying images in the frequency domain
*  [Anti-Aliasing]  Anti-aliasing effects and problems
*  [Miscellaneous]  Bits and pieces
*  [APIs, Scripting, Building]  Usage in other environments
*  [Usage under Windows]  IM on Windows PC
*  [Development and Bugs]  Development proposals and bugs, new and old

**Legend for symbols used within example pages...**

> [!TIP]
>  🟢 Hint, tips or extra info

> [!NOTE]
>  💬 For more advanced users

> [!CAUTION]
>  ⚠ Older version warnings

**Test Image Storage Directories...**  
[Small Images](https://imagemagick.org/Usage/images/) 
([image display](https://imagemagick.org/Usage/images/INDEX.html)),  
[Photographs](https://imagemagick.org/Usage/img_photos/) 
([fancy index](https://imagemagick.org/Usage/img_photos/INDEX.html)).

[Basic Usage]: https://imagemagick.org/Usage/basics/
[Image File Handling]: https://imagemagick.org/Usage/files/
[Common Image Formats]: https://imagemagick.org/Usage/formats/
[Text to Image Handling]: https://imagemagick.org/Usage/text/
[Compound Font Effects]: https://imagemagick.org/Usage/fonts/
[Annotating Images]: https://imagemagick.org/Usage/annotating/
[Thumbnails and Framing]: https://imagemagick.org/Usage/thumbnails/
[Photo Handling]: https://imagemagick.org/Usage/photos/
[Lens Correction]: https://imagemagick.org/Usage/lens/
[Montage, Arrays of Images]: https://imagemagick.org/Usage/montage/
[Layers of Multiple Images]: https://imagemagick.org/Usage/layers/
[Animation Basics]: https://imagemagick.org/Usage/anim_basics/
[Animation Optimization]: https://imagemagick.org/Usage/anim_opt/
[Animation Modifications]: https://imagemagick.org/Usage/anim_mods/
[Video Handling]: https://imagemagick.org/Usage/video/
[Image Comparing]: https://imagemagick.org/Usage/compare/
[Advanced Techniques]: https://imagemagick.org/Usage/advanced/
[Background Examples]: https://imagemagick.org/Usage/backgrounds/
[Repositories Links]: https://imagemagick.org/Usage/repositories.html
[Reference Index]: https://imagemagick.org/Usage/reference.html
[Support Scripts]: https://imagemagick.org/Usage/scripts/
[Canvas Creation]: https://imagemagick.org/Usage/canvas/
[Color Basics and Channels]: https://imagemagick.org/Usage/color_basics/
[Color Modifications]: https://imagemagick.org/Usage/color_mods/
[Masking and Background Removal]: https://imagemagick.org/Usage/masking/
[Color Quantization and Dithering]: https://imagemagick.org/Usage/quantize/
[Cutting and Bordering]: https://imagemagick.org/Usage/crop/
[Resizing or Scaling]: https://imagemagick.org/Usage/resize/
[Resampling Filters]: https://imagemagick.org/Usage/filter/
[Compositing Images]: https://imagemagick.org/Usage/compose/
[Drawing on Images]: https://imagemagick.org/Usage/draw/
[Simple Image Warping]: https://imagemagick.org/Usage/warping/
[Distorting Images]: https://imagemagick.org/Usage/distorts/
[Image Transformations]: https://imagemagick.org/Usage/transform/
[Image Mapping Effects]: https://imagemagick.org/Usage/mapping/
[Blurring and Sharpening Images]: https://imagemagick.org/Usage/blur/
[Morphology of Shapes]: https://imagemagick.org/Usage/morphology/
[Convolution of Images]: https://imagemagick.org/Usage/convolve/
[Fourier Transforms]: https://imagemagick.org/Usage/fourier/
[Anti-Aliasing]: https://imagemagick.org/Usage/antialiasing/
[Miscellaneous]: https://imagemagick.org/Usage/misc/
[APIs, Scripting, Building]: https://imagemagick.org/Usage/api/
[Usage under Windows]: https://imagemagick.org/Usage/windows/
[Development and Bugs]: https://imagemagick.org/Usage/bugs/

* * *

ImageMagick Examples - Introductory Notes
-----------------------------------------

### What is ImageMagick? A No-Holds-Barred Summary

[ImageMagick](https://imagemagick.org/script/index.php) is designed for batch processing of images. That is, it allows you to combine image processing operations in a script (shell, DOS, Perl, PHP, etc.) so the operations can be applied to many images, or as a sub-system of some other tool, such as a Web application, video processing tool, panorama generator, etc. _It is not a GUI image editor_.

ImageMagick is, first of all, an image-to-image converter. That is what it was originally designed to do. That is, it will convert an image in just about any image format (tell us if it can't) to any other image format.

But it is also a library of _image processing algorithms_. These can be access via the command line and shell/DOS scripts (which these example pages demonstrate), or via a large number of programming languages, such as C, C++, Perl, Ruby, PHP, etc. See: [ImageMagick APIs](https://imagemagick.org/script/develop.php).

Speed was never a major feature of IM, which places more emphasis on the quality of the images it generates. That is not to say that it can't transform images in a reasonable amount of time. It's just not blindingly fast. Because of this, IM can be slow to perform certain processing operations, especially when attempting to compress images into image formats that have limited capabilities.

ImageMagick concerns itself mainly with images in the form of a _rectangular array of pixels_, commonly called a "raster." It will handle "vector" image formats like Postscript or PDF, but at the cost of converting those images into a raster when loading them, and generating a vector image wrapper around the raster when saving it. As a result, vector images are often processed badly when using the default settings. However, specific options can be used to improve this situation. See: [A word about vector image formats].

### About These Examples of ImageMagick Usage

These pages were developed from, and are a continuation of, my [Collection of ImageMagick Hints and Tips](https://antofthy.gitlab.io/info/graphics/imagemagick.txt) page I first started in 1993, and placed on the new fangled world-wide-web making its appearance around the same time. Information on many aspects of IM, and notes not included in these pages, are still present in that document. However, while the present pages were designed for you to look at, the hints and tips document was only for my own edification. So, it may be vague or chaotic in places. You are welcome to look at it, learn, and make comments on it.

Other examples were grabbed or developed from answers to users' questions on he [IM Forums](https://imagemagick.org/Usage/forum_link.cgi?f=1), or contributed to me as solutions to various problems.

I look forward to suggestions and e-mail from other IM users. Such e-mail generally results in improvements and expansions to these example pages.

### Command Line Environments

All examples are written for use on UNIX, and specifically GNU/Linux systems, using BASH scripting. As a consequence, some examples use shell 'for-do' loops. Most examples use a backslash '`\`' at the end of a line to continue that command on the next line. The longer commands are broken into separate lines to try to further highlight the steps being applied.

However, you can still use these examples from **PC Windows batch scripts**, with some changes to the handling of certain characters. With some slight adaptation, the examples can also be run directly from '`system`' calls in **PHP scripts**.

See [Windows Usage] and [APIs and Scripting] for more information on using the ImageMagick commands in these alternative environments. Contributions and test examples are welcome.

### PerlMagick, and Other APIs

It should also be possible to adapt any of these examples to use the IM API from languages such as Perl, C, C++, Ruby, PHP, and so on. I recommend trying things out on the command line first, until you get them right, and then converting the operations to the specific API you are using.

Although the situation has improved enormously with IM version 6, the command line really only deals with a single image sequence at any one time. However, APIs do not have this limitation, and allow you to manipulate multiple image sequences, separately or together, to perform more complex operations. This ability makes it simpler to implement these examples using the IM API, and removes the need to save images as temporary files, as many of the command line examples require. When using an API, only permanent and semi-permanent images need be saved to disk.

Basically, let the example pages give you a start, to let you see what is possible with ImageMagick. Then, formulate what you want to do on the command line, before coding the operations in scripts and API code, where it is harder to make extensive changes.

I also recommend that you comment your API code, **heavily**, adding the command line equivalents to what you are trying to do, if possible. That way, you can check and compare the results against those using the command line. This lets you debug problems that you may come across later, especially as improvements are made to image processing in the Core ImageMagick Library.

### Downloading Input Images and Results

As much as possible, I try to use images built-into IM (such as "`logo:`" or "`rose:`") as input images for IM example commands, or to generate input images using IM commands. I also often re-use the output of previous commands in later examples. Because of this, you usually don't need to download any 'test' images in order to try out the examples yourself.

However, such generated or built-in images are not always convenient. So, when I do use an external image, I tend to re-use that input image, or the results of previous examples, for later examples in that section.

Sometimes the original source image will be displayed or for larger images a link to the source image is provided. More commonly only the final resulting image will be shown, as the input is well known or obvious.

Almost all the IM example commands shown are executed in the same web directory in which they appear. That is, the command you see is the command that was actually used to generate the image. Because of this you can modify the page's URL to download or view the input image(s) used by an example. Extra copies of the external source images have also been placed in the "[images]" and "[img_photos]" sub-directories. See also the example of a [Fancy Photo Index] of those images.

If text output or image information is produced by an example, it is saved to a text file, and an image of it is generated for display on the Web page. Selecting the text output image will link you to a copy of the actual text output by the command.

In all these examples, selecting the output image should let you download the image which was actually created by the example command. But be warned, not all browsers understand all image formats used.

### External Image Sources

By the way, most of the source images used in these examples come from [Anthony's Icon Library](https://antofthy.gitlab.io/icons/), particularly the [background tiles](https://antofthy.gitlab.io/icons/desc/cl-bgnd/Icons.html), [large clip-art](https://antofthy.gitlab.io/icons/large/Icons.html), and [dragons](https://antofthy.gitlab.io/icons/dragons/Icons.html) sections of the library. (I like dragons!). ASIDE: these pages may be offline as the web site slowly moves to a new server.

This library actually predates the WWW. I created it in 1991, due to the lack of good, clean iconic images for use on the X Window System. The advent of the WWW has of course changed this, but my original library still exists and remains available as a source of images, even though it is not actively growing.

Some specific images, and larger images, are contributed by the authors of specific examples. The authors of such examples are listed in the contributed section, or at the bottom of the page.

If you are looking for a specific image, I recommend using [Google Image Search](http://images.google.com/imghp) (or similar) to find something appropriate. You can, of course, convert or resize such images using IM for your own purposes. However, you should be careful about copyright if you plan to use such images commercially.

### PNG Images on Web Pages

![IM Output](https://imagemagick.org/Usage/images/test.png)

In many examples, I use an image in PNG format, such as that shown to the right of this text. The PNG image format supports images with semi-transparent pixels, a feature few other image formats provide. It is also a very well-understood image format and, as such, is usable by most of today's image programs and Web browsers.

Some Web browsers, however, do NOT handle transparent PNG images correctly (most notably Microsoft Internet Explorer v6). Because of this, I generally use the JPEG and GIF formats for images on the Web, and only use the PNG format when generating images with semi-transparent pixels, or when exact colors are needed for later examples.

To allow IE v6 browsers to display PNG images, I use a special 'style sheet' using complex JavaScript. For information on this, see [PNG with transparency for IE](http://www.ict.griffith.edu.au/anthony/wwwlab/pngtest/). Technically, this is only problem with IE, not ImageMagick.

### Displaying Images on Your Screen

Display problems can also occur when displaying images on-screen. Because of this, I recommend using a command like the following to tile a '`checkerboard`' pattern underneath the image, to highlight any transparent or semi-transparent pixels in it.

```sh
pushd /od/pictures
# magick composite -compose Dst_Over -tile pattern:checkerboard image.png x:
magick composite -compose Src_Over -tile pattern:checkerboard cvaa-cover.jpg out.jpg
```

![IM Output](https://imagemagick.org/Usage/test_undertile.jpg)

The image displayed in the above example is a special PNG-format [test image], which was generated using the shell script "`[generate_test]`". Normally, the command would output the results to your display, not onto a Web page like this.

If you look carefully, you can see the checkerboard pattern though the semi-transparent colors. However, the image, as a whole, is fully opaque. So, this technique should work on all displays, Web browsers, and image viewers.

As of IM v6.0.2, the "`magick display`" program performs something like this automatically. However, it does not seem to handle images using color tables (i.e., GIF) in this way. Using the "`x:`" output image format (as above) causes an image to be displayed directly to the screen, without having to save it. See [Show Output Display] for more information.

### Font Usage

The fonts I use in these examples are from a small collection of TrueType fonts I have found over the years, and saved for my own use. Some of these are under copyright, so I cannot publish them online.

You are, however, welcome to substitute other fonts that you have available. The examples should work (perhaps with some changes to image size) with any appropriate font you have available on your system. Microsoft "Arial" font, or even "Times-BoldItalic", should work on most systems.

To see what fonts are currently available to your version of IM, run the following command...

   magick -list font

WARNING: If the font requested is not found, ImageMagick used to silently substitute a default font, typically Arial or Times. It still does this, but a warning is now given. So, test the font beforehand, to make sure that it is the one you want, and not the default font.

On my Linux system, I use a special Perl script, "`[imagick_type_gen]`", to generate a file, "`type.xml`", saved in the "`.magick`" sub-directory of my home directory. ImageMagick uses that file, which contains a font list in XML format, to find fonts. The script "`locate`"s (run "`updatedb`" first, if you have just added new fonts), and describes all the fonts available on my system. With this setup, I only need to specify the name of the font I want to use, and not the full path to a specific font file.

For example...

       # Instead of using the command...
       magick -font $HOME/lib/font/truetype/favorite/candice.ttf \
               -pointsize 72 label:Anthony  anthony.gif
    
       # I can use the simpler font label...
       magick -font Candice -pointsize 72 label:Anthony  anthony.gif
    

> ![WARNING]
> _Before IM v6.1.2-3, the "`type.xml`" file was named "`type.mgk`". If you are using an earlier version of IM._

The fonts used in these IM examples are listed in a [Montage of Example Fonts Example]. My personal favorite is Candice, so it gets used quite a bit.

> ![TIP]
> _If you also like the '`Candice`' font, or any of the other fonts I use, grab them from [Free Fonts](http://www.webpagepublicity.com/free-fonts.html) or [1001 Fonts .com](http://www.1001fonts.com/)._


### Example Page Updates

These example pages are in an on-going cycle of improvement. Generally, I find I stop adding to these pages for long periods of time, when my interests become focused on other things.

Often these examples are re-built using the latest beta release of IM, allowing me to see changes and bugs that may appear in each version of IM, before it is generally released. However, the example images shown are what the given IM command produces on **my** system. If you get something different, your IM is probably a much older version (with old bugs), or is not correctly installed.

Note that e-mailing me, or discussing some aspect of ImageMagick on the [discussions forum](https://github.com/ImageMagick/ImageMagick/discussions) will generally result in new examples, or whole new sections, being added to these examples. The more discussion there is, the better the examples become.

If you are doing anything interesting with IM, please share, and allow me to provide examples of your technique to the rest of the IM community. Some of the biggest advances in IM usage have come from users just like you.

### Special Thanks

A special thank you goes to Cristy, who has tirelessly spent months, upgrading, bug-fixing, and putting up with my off-the-wall suggestions... especially with regards to my major suggestions for the command line processing, parenthesis, image sequence operators, and GIF animation processing.

He has done a marvelous job making Version 7 the best and most advanced command line image processing program available. While most users will not show appreciation for that, I certainly do appreciate the effort he has put into IM.

I also want to thank Gabe Schaffer, who has been most helpful in discussions involving the JPEG format and library, affine matrix operators, and [Magick Vector Graphics](https://imagemagick.org/script/magick-vector-graphics.php) in general.

And to Glenn Randers-Pehrson, who wrote the PNG coder module and had an interest in Color Quantization and Dithering. He was the first to add 'halftone' dithering to IM, which I later revised and extended further, to added new dithers to the ordered dither configuration file.

And finally, I want to thank the huge number of people with problems, suggestions, and solutions, who generally lurk on the [IM User Forum]. Many now have their names as contributors of ideas and suggestions throughout IM Examples.

I also want to thank the people who regularly answer questions on the forums, such as '[Bonzo]', and his web site [RubbleWebs](http://www.rubblewebs.co.uk/imagemagick/imagemagick.php), detailing use of IM commands from PHP scripts. Also '[scri8e]' and his Web site, [Moons Stars](http://www.scri8e.com/stars/), for glitter and star handling. Also a thank you goes to Pete '[el_supremo]'

A special thanks goes to [Fred Weinhaus](http://www.fmwconcepts.com/fmw/fmw.html), a researcher from the early days of image processing, who was a major help in the initial implementation of the [General Image Distortion Operator]. You can see Fred's ImageMagick scripts on [Fred's ImageMagick Site](http://www.fmwconcepts.com/imagemagick/), often as a proof of concept for future IM additions.

Also to Nicolas Robidoux, an expert in digital image processing, for reworking the [Elliptical Weighted Average Resampling], which vastly improves the output of [General Image Distortion].

And finally to the many users of ImageMagick who, had allowed others to see the IM commands they use as part of some project, either on the forums, or on the web. You are all to be commended on your willingness and openness to share your findings.

  
  

Well enough "Yadda, yadda, yadda."  Go look at some of the examples.

* * *

Created: 7 November 2003  
Updated: 30 November 2012  
Author: [Anthony Thyssen](https://antofthy.gitlab.io/anthony.html), <Anthony.Thyssen@gmail.com>  
License: IM Examples follows the same [License as ImageMagick](https://imagemagick.org/script/license.php)  



/Architecture
=============

[The Pixel Cache] • [Image Properties and Profiles] • [Multispectral Imagery] • [Large Image Support] • [Streaming Pixels] • [Threads of Execution] • [Heterogeneous Distributed Processing] • [Custom Image Coders] • [Custom Image Filters]

The citizens of Oz were quite content with their benefactor, the all-powerful Wizard. They accepted his wisdom and benevolence without ever questioning the who, why, and where of his power. Like the citizens of Oz, if you feel comfortable that ImageMagick can help you convert, edit, or compose your images without knowing what goes on behind the curtain, feel free to skip this section. However, if you want to know more about the software and algorithms behind ImageMagick, read on. To fully benefit from this discussion, you should be comfortable with image nomenclature and be familiar with computer programming.

Architecture Overview
---------------------

An image typically consists of a rectangular region of pixels and metadata. To convert, edit, or compose an image in an efficient manner, we need convenient access to any pixel anywhere within the region (and sometimes outside the region). And in the case of an image sequence, we need access to any pixel of any region of any image in the sequence. However, there are hundreds of image formats such JPEG, TIFF, PNG, GIF, etc., that makes it difficult to access pixels on demand. Within these formats we find differences in:

*   colorspace (e.g sRGB, linear RGB, linear GRAY, CMYK, YUV, Lab, etc.)
*   bit depth (.e.g 1, 4, 8, 12, 16, etc.)
*   storage format (e.g. unsigned, signed, float, double, etc.)
*   compression (e.g. uncompressed, RLE, Zip, BZip, etc.)
*   orientation (i.e. top-to-bottom, right-to-left, etc.),
*   layout (.e.g. raw, interspersed with opcodes, etc.)

In addition, some image pixels may require attenuation, some formats permit more than one frame, and some formats contain vector graphics that must first be rasterized (converted from vector to pixels).

An efficient implementation of an image processing algorithm may require we get or set:

*   one pixel a time (e.g. pixel at location 10,3)
*   a single scanline (e.g. all pixels from row 4)
*   a few scanlines at once (e.g. pixel rows 4-7)
*   a single column or columns of pixels (e.g. all pixels from column 11)
*   an arbitrary region of pixels from the image (e.g. pixels defined at 10,7 to 10,19)
*   a pixel in random order (e.g. pixel at 14,15 and 640,480)
*   pixels from two different images (e.g. pixel at 5,1 from image 1 and pixel at 5,1 from image 2)
*   pixels outside the boundaries of the image (e.g. pixel at -1,-3)
*   a pixel component that is unsigned (65311) or in a floating-point representation (e.g. 0.17836)
*   a high-dynamic range pixel that can include negative values (e.g. -0.0072973525628) as well as values that exceed the quantum depth (e.g. 65931)
*   one or more pixels simultaneously in different threads of execution
*   all the pixels in memory to take advantage of speed-ups offered by executing in concert across heterogeneous platforms consisting of CPUs, GPUs, and other processors
*   traits associated with each channel to specify whether the pixel channel is copied, updated, or blended
*   masks that define which pixels are eligible to be updated
*   extra channels that benefits the user but otherwise remain untouched by ImageMagick image processing algorithms

Given the varied image formats and image processing requirements, we implemented the ImageMagick [pixel cache] to provide convenient sequential or parallel access to any pixel on demand anywhere inside the image region (i.e. [authentic pixels]) and from any image in a sequence. In addition, the pixel cache permits access to pixels outside the boundaries defined by the image (i.e. [virtual pixels]).

In addition to pixels, images have a plethora of [image properties and profiles]. Properties include the well known attributes such as width, height, depth, and colorspace. An image may have optional properties which might include the image author, a comment, a create date, and others. Some images also include profiles for color management, or EXIF, IPTC, 8BIM, or XMP informational profiles. ImageMagick provides command line options and programming methods to get, set, or view image properties or profiles or apply profiles.

ImageMagick consists of nearly a half million lines of C code and optionally depends on several million lines of code in dependent libraries (e.g. JPEG, PNG, TIFF libraries). Given that, one might expect a huge architecture document. However, a great majority of image processing is simply accessing pixels and its metadata and our simple, elegant, and efficient implementation makes this easy for the ImageMagick developer. We discuss the implementation of the pixel cache and getting and setting image properties and profiles in the next few sections. Next, we discuss using ImageMagick within a [thread] of execution. In the final sections, we discuss [image coders] to read or write a particular image format followed by a few words on creating a [filter] to access or update pixels based on your custom requirements.

The Pixel Cache
---------------

The ImageMagick pixel cache is a repository for image pixels with up to 32 channels. The channels are stored contiguously at the depth specified when ImageMagick was built. The channel depths are 8 bits-per-pixel component for the Q8 version of ImageMagick, 16 bits-per-pixel component for the Q16 version, and 32 bits-per-pixel component for the Q32 version. By default pixel components are 32-bit floating-bit [high dynamic-range] quantities. The channels can hold any value but typically contain red, green, blue, and alpha intensities or cyan, magenta, yellow, black and alpha intensities. A channel might contain the colormap indexes for colormapped images or the black channel for CMYK images. The pixel cache storage may be heap memory, disk-backed memory mapped, or on disk. The pixel cache is reference-counted. Only the cache properties are copied when the cache is cloned. The cache pixels are subsequently copied only when you signal your intention to update any of the pixels.

Create the Pixel Cache
----------------------

The pixel cache is associated with an image when it is created and it is initialized when you try to get or put pixels. Here are three common methods to associate a pixel cache with an image:

Create an image canvas initialized to the background color:

  
```cpp
image=AllocateImage(image_info);
if (SetImageExtent(image,640,480) == MagickFalse)
  { /* an exception was thrown */ }
(void) QueryMagickColor("red",&image->background_color,&image->exception);
SetImageBackgroundColor(image);
```


Create an image from a JPEG image on disk:

  
```cpp
(void) strcpy(image_info->filename,"image.jpg"):
image=ReadImage(image_info,exception);
if (image == (Image *) NULL)
  { /* an exception was thrown */ }
```


Create an image from a memory based image:

  
```cpp
image=BlobToImage(blob_info,blob,extent,exception);
if (image == (Image *) NULL)
  { /* an exception was thrown */ }
```


In our discussion of the pixel cache, we use the [MagickCore API] to illustrate our points, however, the principles are the same for other program interfaces to ImageMagick.

When the pixel cache is initialized, pixels are scaled from whatever bit depth they originated from to that required by the pixel cache. For example, a 1-channel 1-bit monochrome PBM image is scaled to 8-bit gray image, if you are using the Q8 version of ImageMagick, and 16-bit RGBA for the Q16 version. You can determine which version you have with the [-version] option:

    $ identify -version$ Version: ImageMagick 7.1.0-62 2023-02-05 Q16 https://imagemagick.org

As you can see, the convenience of the pixel cache sometimes comes with a trade-off in storage (e.g. storing a 1-bit monochrome image as 16-bit is wasteful) and speed (i.e. storing the entire image in memory is generally slower than accessing one scanline of pixels at a time). In most cases, the benefits of the pixel cache typically outweigh any disadvantages.

Access the Pixel Cache
----------------------

Once the pixel cache is associated with an image, you typically want to get, update, or put pixels into it. We refer to pixels inside the image region as [authentic pixels] and outside the region as [virtual pixels]. Use these methods to access the pixels in the cache:

*   [GetVirtualPixels()]: gets pixels that you do not intend to modify or pixels that lie outside the image region (e.g. pixel @ -1,-3)
*   [GetAuthenticPixels()]: gets pixels that you intend to modify
*   [QueueAuthenticPixels()]: queue pixels that you intend to set
*   [SyncAuthenticPixels()]: update the pixel cache with any modified pixels

Here is a typical [MagickCore] code snippet for manipulating pixels in the pixel cache. In our example, we copy pixels from the input image to the output image and decrease the intensity by 10%:

```cpp
const Quantum
  *p;

Quantum
  *q;

ssize_t
  x,
  y;

destination=CloneImage(source,source->columns,source->rows,MagickTrue,exception);
if (destination == (Image *) NULL)
  { /* an exception was thrown */ }
for (y=0; y < (ssize_t) source->rows; y++)
{
  p=GetVirtualPixels(source,0,y,source->columns,1,exception);
  q=GetAuthenticPixels(destination,0,y,destination->columns,1,exception);
  if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)
    break;
  for (x=0; x < (ssize_t) source->columns; x++)
  {
    SetPixelRed(image,90*p->red/100,q);
    SetPixelGreen(image,90*p->green/100,q);
    SetPixelBlue(image,90*p->blue/100,q);
    SetPixelAlpha(image,90*p->opacity/100,q);
    p+=GetPixelChannels(source);
    q+=GetPixelChannels(destination);
  }
  if (SyncAuthenticPixels(destination,exception) == MagickFalse)
    break;
}
if (y < (ssize_t) source->rows)
  { /* an exception was thrown */ }
```

When we first create the destination image by cloning the source image, the pixel cache pixels are not copied. They are only copied when you signal your intentions to modify or set the pixel cache by calling [GetAuthenticPixels()] or [QueueAuthenticPixels()]. Use [QueueAuthenticPixels()] if you want to set new pixel values rather than update existing ones. You could use GetAuthenticPixels() to set pixel values but it is slightly more efficient to use QueueAuthenticPixels() instead. Finally, use [SyncAuthenticPixels()] to ensure any updated pixels are pushed to the pixel cache.

You can associate arbitrary content with each pixel, called _meta_ content. Use [GetVirtualMetacontent()] (to read the content) or [GetAuthenticMetacontent()] (to update the content) to gain access to this content. For example, to print the metacontent, use:

```cpp
const void
  *metacontent;

for (y=0; y < (ssize_t) source->rows; y++)
{
  p=GetVirtualPixels(source,0,y,source->columns,1);
  if (p == (const Quantum *) NULL)
    break;
  metacontent=GetVirtualMetacontent(source);
  /* print meta content here */
}
if (y < (ssize_t) source->rows)
  /* an exception was thrown */

```
The pixel cache manager decides whether to give you direct or indirect access to the image pixels. In some cases the pixels are staged to an intermediate buffer-- and that is why you must call SyncAuthenticPixels() to ensure this buffer is pushed out to the pixel cache to guarantee the corresponding pixels in the cache are updated. For this reason we recommend that you only read or update a scanline or a few scanlines of pixels at a time. However, you can get any rectangular region of pixels you want. GetAuthenticPixels() requires that the region you request is within the bounds of the image area. For a 640 by 480 image, you can get a scanline of 640 pixels at row 479 but if you ask for a scanline at row 480, an exception is returned (rows are numbered starting at 0). GetVirtualPixels() does not have this constraint. For example,

p=GetVirtualPixels(source,-3,-3,source->columns+3,6,exception);

gives you the pixels you asked for without complaint, even though some are not within the confines of the image region.

Virtual Pixels
--------------

There are a plethora of image processing algorithms that require a neighborhood of pixels about a pixel of interest. The algorithm typically includes a caveat concerning how to handle pixels around the image boundaries, known as edge pixels. With virtual pixels, you do not need to concern yourself about special edge processing other than choosing which virtual pixel method is most appropriate for your algorithm.

Access to the virtual pixels are controlled by the [SetImageVirtualPixelMethod()] method from the MagickCore API or the [-virtual-pixel] option from the command line. The methods include:

*   `background` the area surrounding the image is the background color
*   `black` the area surrounding the image is black
*   `checker-tile` alternate squares with image and background color
*   `dither` non-random 32x32 dithered pattern
*   `edge` extend the edge pixel toward infinity (default)
*   `gray` the area surrounding the image is gray
*   `horizontal-tile` horizontally tile the image, background color above/below
*   `horizontal-tile-edge` horizontally tile the image and replicate the side edge pixels
*   `mirror` mirror tile the image
*   `random` choose a random pixel from the image
*   `tile` tile the image
*   `transparent` the area surrounding the image is transparent blackness
*   `vertical-tile` vertically tile the image, sides are background color
*   `vertical-tile-edge` vertically tile the image and replicate the side edge pixels
*   `white` the area surrounding the image is white


Cache Storage and Resource Requirements
---------------------------------------

Recall that this simple and elegant design of the ImageMagick pixel cache comes at a cost in terms of storage and processing speed. The pixel cache storage requirements scales with the area of the image and the bit depth of the pixel components. For example, if we have a 640 by 480 image and we are using the non-HDRI Q16 version of ImageMagick, the pixel cache consumes image width * height * bit-depth / 8 * channels bytes or approximately 2.3 mebibytes (i.e. 640 * 480 * 2 * 4). Not too bad, but what if your image is 25000 by 25000 pixels? The pixel cache requires approximately 4.7 gibibytes of storage. Ouch. ImageMagick accounts for possible huge storage requirements by caching large images to disk rather than memory. Typically the pixel cache is stored in memory using heap memory. If heap memory is exhausted, we create the pixel cache on disk and attempt to memory-map it. If memory-map memory is exhausted, we simply use standard disk I/O. Disk storage is plentiful and cheap, but it is also very slow-- upwards of 1000 times slower than accessing pixels in memory. We can get some speed improvements, up to 5 times, if we memory-map the disk-based cache. These decisions about storage are made automagically by the pixel cache manager negotiating with the operating system. However, you can influence how the pixel cache manager allocates the pixel cache with cache resource limits. The limits include:

*   `width`

    maximum width of an image. Exceed this limit and an exception is thrown and the operation discontinues.

*   `height`

    maximum height of an image. Exceed this limit and an exception is thrown and the operation discontinues.

*   `area`

    maximum area in bytes of any one image that can reside in the pixel cache memory. If this limit is exceeded, the image is automagically cached to disk and optionally memory-mapped.

*   `memory`

    maximum amount of memory in bytes to allocate for the pixel cache from the heap.

*   `map`

    maximum amount of memory map in bytes to allocate for the pixel cache.

*   `disk`

    maximum amount of disk space in bytes permitted for use by the pixel cache. If this limit is exceeded, a fatal exception is thrown, and all processing stops.

*   `files`

    maximum number of open pixel cache files. When this limit is exceeded, any subsequent pixels cached to disk are closed and reopened on demand. This behavior permits a large number of images to be accessed simultaneously on disk without a speed penalty by reducing the number of pixel cache open/close system calls.

*   `thread`

    maximum number of threads that are permitted to run in parallel. Your system may choose a number of threads that is less that this value. ImageMagick chooses an optimum number of threads by default, which is usually the number of cores on your host. Set this value to 1 and all parallel regions are executed by one thread.

*   `time`

    maximum number of seconds that the process is permitted to execute. Exceed this limit and an exception is thrown and processing stops.

  

Note, these limits pertain to the ImageMagick pixel cache. Certain algorithms within ImageMagick do not respect these limits nor does any of the external delegate libraries (e.g. JPEG, TIFF, etc.).

To determine the current setting of these limits, use this command:

    -> identify -list resource
    Resource limits:
      Width: 100MP
      Height: 100MP
      Area: 25.181GB
      Memory: 11.726GiB
      Map: 23.452GiB
      Disk: unlimited
      File: 768
      Thread: 12
      Throttle: 0
      Time: unlimited

You can set these limits either as a [security policy] (see [policy.xml](https://imagemagick.org/source/policy.xml)), with an [environment variable], with the [-limit] command line option, or with the [SetMagickResourceLimit()] MagickCore API method. As an example, our online web interface to ImageMagick, [ImageMagick Studio], includes these policy limits to help prevent a denial-of-service:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE policymap [
<!ELEMENT policymap (policy)+>
<!ELEMENT policy (#PCDATA)>
<!ATTLIST policy domain (delegate|coder|filter|path|resource) #IMPLIED>
<!ATTLIST policy name CDATA #IMPLIED>
<!ATTLIST policy rights CDATA #IMPLIED>
<!ATTLIST policy pattern CDATA #IMPLIED>
<!ATTLIST policy value CDATA #IMPLIED>
]>
<!--
  Configure ImageMagick policies.

  Domains include system, delegate, coder, filter, path, or resource.

  Rights include none, read, write, and execute.  Use | to combine them,
  for example: "read | write" to permit read from, or write to, a path.

  Use a glob expression as a pattern.

  Suppose we do not want users to process MPEG video images:

    <policy domain="delegate" rights="none" pattern="mpeg:decode" />

  Here we do not want users reading images from HTTP:

    <policy domain="coder" rights="none" pattern="HTTP" />

  Lets prevent users from executing any image filters:

    <policy domain="filter" rights="none" pattern="*" />

  The /repository file system is restricted to read only.  We use a glob
  expression to match all paths that start with /repository:
  
    <policy domain="path" rights="read" pattern="/repository/*" />

  Any large image is cached to disk rather than memory:

    <policy domain="resource" name="area" value="1GB"/>

  Define arguments for the memory, map, area, and disk resources with
  SI prefixes (.e.g 100MB).  In addition, resource policies are maximums for
  each instance of ImageMagick (e.g. policy memory limit 1GB, -limit 2GB
  exceeds policy maximum so memory limit is 1GB).
-->
<policymap>
  <policy domain="resource" name="temporary-path" value="/opt/tmp"/> 
  <policy domain="resource" name="memory" value="256MiB"/> 
  <policy domain="resource" name="list-length" value="32"/> 
  <policy domain="resource" name="width" value="8KP"/> 
  <policy domain="resource" name="height" value="8KP"/> 
  <policy domain="resource" name="map" value="512MiB"/> 
  <policy domain="resource" name="area" value="16KP"/>
  <policy domain="resource" name="disk" value="1GiB"/> 
  <policy domain="resource" name="file" value="768"/> 
  <policy domain="resource" name="thread" value="2"/>
  <policy domain="resource" name="time" value="120"/> 
  <policy domain="system" name="precision" value="6"/>
  <policy domain="cache" name="memory-map" value="anonymous"/>
  <policy domain="cache" name="synchronize" value="true"/>
  <policy domain="cache" stealth="true" name="shared-secret" value="replace with your secret phrase"/>
  <policy domain="coder" rights="none" pattern="URL" />
  <policy domain="coder" rights="write" pattern="{HTTP,HTTPS,MVG}" />
  <policy domain="filter" rights="none" pattern="*" />
  <policy domain="path" rights="none" pattern="@*"/>
  <policy domain="system" name="font" value="/my-system-fonts/arial-unicode.ttf"/>
</policymap>
```

Since we process multiple simultaneous sessions, we don't want any one session consuming all the available memory. With this policy, large images are cached to disk. If the image is too large and exceeds the pixel cache disk limit, the program exits. In addition, we place a time limit to prevent any run-away processing tasks. If any one image has a width or height that exceeds 8192 pixels, an exception is thrown and processing stops. As of ImageMagick 7.0.1-8, you can prevent the use of any delegate or all delegates (set the pattern to * ). Note, prior to this release, use a domain of "coder" to prevent delegate usage (e.g. domain="coder" rights="none" pattern="HTTPS"). The policy also prevents indirect reads. If you want to, for example, read text from a file (e.g. caption:@myCaption.txt), you'll need to remove this policy.

Note, the cache limits are global to each invocation of ImageMagick, meaning if you create several images, the combined resource requirements are compared to the limit to determine the pixel cache storage disposition.

To determine which type and how much resources are consumed by the pixel cache, add the [-debug cache] option to the command-line:

    $ magick -debug cache logo: -sharpen 3x2 null:
    2016-12-17T13:33:42-05:00 0:00.000 0.000u 7.0.0 Cache magick: cache.c/DestroyPixelCache/1275/Cache
      destroy 
    2016-12-17T13:33:42-05:00 0:00.000 0.000u 7.0.0 Cache magick: cache.c/OpenPixelCache/3834/Cache
      open LOGO[0] (Heap Memory, 640x480x4 4.688MiB)
    2016-12-17T13:33:42-05:00 0:00.010 0.000u 7.0.0 Cache magick: cache.c/OpenPixelCache/3834/Cache
      open LOGO[0] (Heap Memory, 640x480x3 3.516MiB)
    2016-12-17T13:33:42-05:00 0:00.010 0.000u 7.0.0 Cache magick: cache.c/ClonePixelCachePixels/1044/Cache
      Memory => Memory
    2016-12-17T13:33:42-05:00 0:00.020 0.010u 7.0.0 Cache magick: cache.c/ClonePixelCachePixels/1044/Cache
      Memory => Memory
    2016-12-17T13:33:42-05:00 0:00.020 0.010u 7.0.0 Cache magick: cache.c/OpenPixelCache/3834/Cache
      open LOGO[0] (Heap Memory, 640x480x3 3.516MiB)
    2016-12-17T13:33:42-05:00 0:00.050 0.100u 7.0.0 Cache magick: cache.c/DestroyPixelCache/1275/Cache
      destroy LOGO[0]
    2016-12-17T13:33:42-05:00 0:00.050 0.100u 7.0.0 Cache magick: cache.c/DestroyPixelCache/1275/Cache
      destroy LOGO[0]

This command utilizes a pixel cache in memory. The logo consumed 4.688MiB and after it was sharpened, 3.516MiB.

Distributed Pixel Cache
-----------------------

A distributed pixel cache is an extension of the traditional pixel cache available on a single host. The distributed pixel cache may span multiple servers so that it can grow in size and transactional capacity to support very large images. Start up the pixel cache server on one or more machines. When you read or operate on an image and the local pixel cache resources are exhausted, ImageMagick contacts one or more of these remote pixel servers to store or retrieve pixels. The distributed pixel cache relies on network bandwidth to marshal pixels to and from the remote server. As such, it will likely be significantly slower than a pixel cache utilizing local storage (e.g. memory, disk, etc.).

    magick -distribute-cache 6668 &  // start on 192.168.100.50
    magick -define registry:cache:hosts=192.168.100.50:6668 myimage.jpg -sharpen 5x2 mimage.png

Cache Views
-----------

GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels(), and SyncAuthenticPixels(), from the MagickCore API, can only deal with one pixel cache area per image at a time. Suppose you want to access the first and last scanline from the same image at the same time? The solution is to use a cache view. A cache view permits you to access as many areas simultaneously in the pixel cache as you require. The cache view [methods] are analogous to the previous methods except you must first open a view and close it when you are finished with it. Here is a snippet of MagickCore code that permits us to access the first and last pixel row of the image simultaneously:

```cpp
CacheView
  *first_row,
  *last_row;

first_row=AcquireVirtualCacheView(source,exception);
last_row=AcquireVirtualCacheView(source,exception);
for (y=0; y < (ssize_t) source->rows; y++)
{
  const Quantum
    *p,
    *q;

  p=GetCacheViewVirtualPixels(first_row,0,y,source->columns,1,exception);
  q=GetCacheViewVirtualPixels(last_row,0,source->rows-y-1,source->columns,1,exception);
  if ((p == (const Quantum *) NULL) || (q == (const Quantum *) NULL))
    break;
  for (x=0; x < (ssize_t) source->columns; x++)
  {
    /* do something with p & q here */
  }
}
last_row=DestroyCacheView(last_row);
first_row=DestroyCacheView(first_row);
if (y < (ssize_t) source->rows)
  { /* an exception was thrown */ }

```
Magick Pixel Cache Format
-------------------------

Recall that each image format is decoded by ImageMagick and the pixels are deposited in the pixel cache. If you write an image, the pixels are read from the pixel cache and encoded as required by the format you are writing (e.g. GIF, PNG, etc.). The Magick Pixel Cache (MPC) format is designed to eliminate the overhead of decoding and encoding pixels to and from an image format. MPC writes two files. One, with the extension .mpc, retains all the properties associated with the image or image sequence (e.g. width, height, colorspace, etc.) and the second, with the extension .cache, is the pixel cache in the native raw format. When reading an MPC image file, ImageMagick reads the image properties and memory maps the pixel cache on disk eliminating the need for decoding the image pixels. The trade-off is in disk space. MPC is generally larger in file size than most other image formats.

The most efficient use of MPC image files is a write-once, read-many-times pattern. For example, your workflow requires extracting random blocks of pixels from the source image. Rather than re-reading and possibly decompressing the source image each time, we use MPC and map the image directly to memory.

Best Practices
--------------

Although you can request any pixel from the pixel cache, any block of pixels, any scanline, multiple scanlines, any row, or multiple rows with the GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels, GetCacheViewVirtualPixels(), GetCacheViewAuthenticPixels(), and QueueCacheViewAuthenticPixels() methods, ImageMagick is optimized to return a few pixels or a few pixels rows at time. There are additional optimizations if you request a single scanline or a few scanlines at a time. These methods also permit random access to the pixel cache, however, ImageMagick is optimized for sequential access. Although you can access scanlines of pixels sequentially from the last row of the image to the first, you may get a performance boost if you access scanlines from the first row of the image to the last, in sequential order.

You can get, modify, or set pixels in row or column order. However, it is more efficient to access the pixels by row rather than by column.

If you update pixels returned from GetAuthenticPixels() or GetCacheViewAuthenticPixels(), don't forget to call SyncAuthenticPixels() or SyncCacheViewAuthenticPixels() respectively to ensure your changes are synchronized with the pixel cache.

Use QueueAuthenticPixels() or QueueCacheViewAuthenticPixels() if you are setting an initial pixel value. The GetAuthenticPixels() or GetCacheViewAuthenticPixels() method reads pixels from the cache and if you are setting an initial pixel value, this read is unnecessary. Don't forget to call SyncAuthenticPixels() or SyncCacheViewAuthenticPixels() respectively to push any pixel changes to the pixel cache.

GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels(), and SyncAuthenticPixels() are slightly more efficient than their cache view counter-parts. However, cache views are required if you need access to more than one region of the image simultaneously or if more than one [thread of execution] is accessing the image.

You can request pixels outside the bounds of the image with GetVirtualPixels() or GetCacheViewVirtualPixels(), however, it is more efficient to request pixels within the confines of the image region.

Although you can force the pixel cache to disk using appropriate resource limits, disk access can be upwards of 1000 times slower than memory access. For fast, efficient, access to the pixel cache, try to keep the pixel cache in heap memory.

The ImageMagick Q16 version of ImageMagick permits you to read and write 16 bit images without scaling but the pixel cache consumes twice as many resources as the Q8 version. If your system has constrained memory or disk resources, consider the Q8 version of ImageMagick. In addition, the Q8 version typically executes faster than the Q16 version.

A great majority of image formats and algorithms restrict themselves to a fixed range of pixel values from 0 to some maximum value, for example, the Q16 version of ImageMagick permit intensities from 0 to 65535. High dynamic-range imaging (HDRI), however, permits a far greater dynamic range of exposures (i.e. a large difference between light and dark areas) than standard digital imaging techniques. HDRI accurately represents the wide range of intensity levels found in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows. Enable [HDRI] at ImageMagick build time to deal with high dynamic-range images, but be mindful that each pixel component is a 32-bit floating point value. In addition, pixel values are not clamped by default so some algorithms may have unexpected results due to out-of-band pixel values than the non-HDRI version.

If you are dealing with large images, make sure the pixel cache is written to a disk area with plenty of free space. Under Linux, this is typically /tmp and for Windows, c:/temp. You can tell ImageMagick to write the pixel cache to an alternate location and conserve memory with these options:

magick -limit memory 2GB -limit map 4GB -define registry:temporary-path=/data/tmp ...

Set global resource limits for your environment in the policy.xml configuration file.

If you plan on processing the same image many times, consider the MPC format. Reading a MPC image has near-zero overhead because its in the native pixel cache format eliminating the need for decoding the image pixels. Here is an example:

    magick image.tif image.mpc
    magick image.mpc -crop 100x100+0+0 +repage 1.png
    magick image.mpc -crop 100x100+100+0 +repage 2.png
    magick image.mpc -crop 100x100+200+0 +repage 3.png

MPC is ideal for web sites. It reduces the overhead of reading and writing an image. We use it exclusively at our [online image studio].

Image Properties and Profiles
-----------------------------

Images have metadata associated with them in the form of properties (e.g. width, height, description, etc.) and profiles (e.g. EXIF, IPTC, color management). ImageMagick provides convenient methods to get, set, or update image properties and get, set, update, or apply profiles. Some of the more popular image properties are associated with the Image structure in the MagickCore API. For example:

(void) printf("image width: %lu, height: %lu\n",image->columns,image->rows);

For a great majority of image properties, such as an image comment or description, we use the [GetImageProperty()] and [SetImageProperty()] methods. Here we set a property and fetch it right back:

```cpp
const char
  *comment;

(void) SetImageProperty(image,"comment","This space for rent");
comment=GetImageProperty(image,"comment");
if (comment == (const char *) NULL)
  (void) printf("Image comment: %s\n",comment);
```

ImageMagick supports artifacts with the GetImageArtifact() and SetImageArtifact() methods. Artifacts are stealth properties that are not exported to image formats (e.g. PNG).

Image profiles are handled with [GetImageProfile()], [SetImageProfile()], and [ProfileImage()] methods. Here we set a profile and fetch it right back:

```cpp
StringInfo
  *profile;

profile=AcquireStringInfo(length);
SetStringInfoDatum(profile,my_exif_profile);
(void) SetImageProfile(image,"EXIF",profile);
DestroyStringInfo(profile);
profile=GetImageProfile(image,"EXIF");
if (profile != (StringInfo *) NULL)
  (void) PrintStringInfo(stdout,"EXIF",profile);
```

Multispectral Imagery
---------------------

ImageMagick supports multispectral images where all channels have the same dimensions and number of pixels as the original image. However, not all image formats support multispectral images. PSD, TIFF, MIFF, MPC, and FTXT have full support for multispectral images up to 64 bands. If you have a use case that is not currently supported by an image format, post it to the [discussion forum](https://github.com/ImageMagick/ImageMagick/discussions). There is a good chance, we can support your use case in a future release of ImageMagick.

Streaming Pixels
----------------

ImageMagick provides for streaming pixels as they are read from or written to an image. This has several advantages over the pixel cache. The time and resources consumed by the pixel cache scale with the area of an image, whereas the pixel stream resources scale with the width of an image. The disadvantage is the pixels must be consumed as they are streamed so there is no persistence.

Use [ReadStream()] or [WriteStream()] with an appropriate callback method in your MagickCore program to consume the pixels as they are streaming. Here's an abbreviated example of using ReadStream:

```cpp
static size_t StreamPixels(const Image *image,const void *pixels,const size_t columns)
{
  register const Quantum
    *p;

  MyData
    *my_data;

  my_data=(MyData *) image->client_data;
  p=(Quantum *) pixels;
  if (p != (const Quantum *) NULL)
    {
      /* process pixels here */
    }
  return(columns);
}

...

/* invoke the pixel stream here */
image_info->client_data=(void *) MyData;
image=ReadStream(image_info,&StreamPixels,exception);
```

We also provide a lightweight tool, [stream], to stream one or more pixel components of the image or portion of the image to your choice of storage formats. It writes the pixel components as they are read from the input image a row at a time making [stream] desirable when working with large images or when you require raw pixel components. A majority of the image formats stream pixels (red, green, and blue) from left to right and top to bottom. However, a few formats do not support this common ordering (e.g. the PSD format).

Large Image Support
-------------------

ImageMagick can read, process, or write mega-, giga-, or tera-pixel image sizes. An image width or height can range from 1 to 2 giga-pixels on a 32 bit OS (up to 2147483647 rows/columns) and up to 9 exa-pixels on a 64-bit OS (up to 9223372036854775807 rows/columns). Note, that some image formats have restrictions on image size. For example, Photoshop images are limited to 300,000 pixels for width or height. Here we resize an image to a quarter million pixels square:

    magick logo: -resize 250000x250000 logo.miff

For large images, memory resources will likely be exhausted and ImageMagick will instead create a pixel cache on disk. Make sure you have plenty of temporary disk space. If your default temporary disk partition is too small, tell ImageMagick to use another partition with plenty of free space. For example:

    magick -define registry:temporary-path=/data/tmp logo:  \   
         -resize 250000x250000 logo.miff

To ensure large images do not consume all the memory on your system, force the image pixels to memory-mapped disk with resource limits:

    magick -define registry:temporary-path=/data/tmp -limit memory 16mb \
      logo: -resize 250000x250000 logo.miff

Here we force all image pixels to disk:

    magick -define registry:temporary-path=/data/tmp -limit area 0 \
      logo: -resize 250000x250000 logo.miff

Caching pixels to disk is about 1000 times slower than memory. Expect long run times when processing large images on disk with ImageMagick. You can monitor progress with this command:

    magick -monitor -limit memory 2GiB -limit map 4GiB -define registry:temporary-path=/data/tmp \
      logo: -resize 250000x250000 logo.miff

For really large images, or if there is limited resources on your host, you can utilize a distributed pixel cache on one or more remote hosts:

    magick -distribute-cache 6668 &  // start on 192.168.100.50
    magick -distribute-cache 6668 &  // start on 192.168.100.51
    magick -limit memory 2mb -limit map 2mb -limit disk 2gb \
      -define registry:cache:hosts=192.168.100.50:6668,192.168.100.51:6668 \
      myhugeimage.jpg -sharpen 5x2 myhugeimage.png

Due to network latency, expect a substantial slow-down in processing your workflow.

Threads of Execution
--------------------

Many of ImageMagick's internal algorithms are threaded to take advantage of speed-ups offered by the multicore processor chips. However, you are welcome to use ImageMagick algorithms in your threads of execution with the exception of the MagickCore's GetVirtualPixels(), GetAuthenticPixels(), QueueAuthenticPixels(), or SyncAuthenticPixels() pixel cache methods. These methods are intended for one thread of execution only with the exception of an OpenMP parallel section. To access the pixel cache with more than one thread of execution, use a cache view. We do this for the [CompositeImage()] method, for example. Suppose we want to composite a single source image over a different destination image in each thread of execution. If we use GetVirtualPixels(), the results are unpredictable because multiple threads would likely be asking for different areas of the pixel cache simultaneously. Instead we use GetCacheViewVirtualPixels() which creates a unique view for each thread of execution ensuring our program behaves properly regardless of how many threads are invoked. The other program interfaces, such as the [MagickWand API], are completely thread safe so there are no special precautions for threads of execution.

Here is an MagickCore code snippet that takes advantage of threads of execution with the [OpenMP] programming paradigm:

```cpp
CacheView
  *image_view;

MagickBooleanType
  status;

ssize_t
  y;

/*
  Acquire a cache view to enable parallelism.
*/
status=MagickTrue;
image_view=AcquireVirtualCacheView(image,exception);
#pragma omp parallel for schedule(static,4) shared(status)
for (y=0; y < (ssize_t) image->rows; y++)
{
  register Quantum
    *q;

  register ssize_t
    x;

  register void
    *metacontent;

  if (status == MagickFalse)
    continue;
  /*
    Get a row of pixels.
  */
  q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    {
      status=MagickFalse;
      continue;
    }
  metacontent=GetCacheViewAuthenticMetacontent(image_view);
  for (x=0; x < (ssize_t) image->columns; x++)
  {
    /*
      Set the pixel color.
    */
    SetPixelRed(image,...,q);
    SetPixelGreen(image,...,q);
    SetPixelBlue(image,...,q);
    SetPixelAlpha(image,...,q);
    if (metacontent != NULL)
      metacontent[indexes+x]=...;
    q+=GetPixelChannels(image);
  }
  /*
    Sync the updated pixels to the pixel cache.
  */
  if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
    status=MagickFalse;
}
/*
  Destroy the cache view.
*/
image_view=DestroyCacheView(image_view);
if (status == MagickFalse)
  perror("something went wrong");

This code snippet converts an uncompressed Windows bitmap to a Magick++ image:

#include "Magick++.h"
#include <assert.h>
#include "omp.h"

void ConvertBMPToImage(const BITMAPINFOHEADER *bmp_info,
  const unsigned char *restrict pixels,Magick::Image *image)
{
  /*
    Prepare the image so that we can modify the pixels directly.
  */
  assert(bmp_info->biCompression == BI_RGB);
  assert(bmp_info->biWidth == image->columns());
  assert(abs(bmp_info->biHeight) == image->rows());
  image->modifyImage();
  if (bmp_info->biBitCount == 24)
    image->type(MagickCore::TrueColorType);
  else
    image->type(MagickCore::TrueColorMatteType);
  register unsigned int bytes_per_row=bmp_info->biWidth*bmp_info->biBitCount/8;
  if (bytes_per_row % 4 != 0) {
    bytes_per_row=bytes_per_row+(4-bytes_per_row % 4);  // divisible by 4.
  }
  /*
    Copy all pixel data, row by row.
  */
  #pragma omp parallel for
  for (int y=0; y < int(image->rows()); y++)
  {
    int
      row;

    register const unsigned char
      *restrict p;

    register MagickCore::Quantum
      *restrict q;

    row=(bmp_info->biHeight > 0) ? (image->rows()-y-1) : y;
    p=pixels+row*bytes_per_row;
    q=image->setPixels(0,y,image->columns(),1);
    for (int x=0; x < int(image->columns()); x++)
    {
      SetPixelBlue(image,p[0],q);
      SetPixelGreen(image,p[1],q);
      SetPixelRed(image,p[2],q);
      if (bmp_info->biBitCount == 32) {
        SetPixelAlpha(image,p[3],q);
      }
      q+=GetPixelChannels(image);
      p+=bmp_info->biBitCount/8;
    }
    image->syncPixels();  // sync pixels to pixel cache.
  }
  return;
}

```
If you call the ImageMagick API from your OpenMP-enabled application and you intend to dynamically increase the number of threads available in subsequent parallel regions, be sure to perform the increase before you call the API otherwise ImageMagick may fault.

[MagickWand] supports wand views. A view iterates over the entire, or portion, of the image in parallel and for each row of pixels, it invokes a callback method you provide. This limits most of your parallel programming activity to just that one module. There are similar methods in [MagickCore]. For an example, see the same sigmoidal contrast algorithm implemented in both [MagickWand] and [MagickCore].

In most circumstances, the default number of threads is set to the number of processor cores on your system for optimal performance. However, if your system is hyperthreaded or if you are running on a virtual host and only a subset of the processors are available to your server instance, you might get an increase in performance by setting the thread [policy] or the [MAGICK_THREAD_LIMIT] environment variable. For example, your virtual host has 8 processors but only 2 are assigned to your server instance. The default of 8 threads can cause severe performance problems. One solution is to limit the number of threads to the available processors in your [policy.xml](https://imagemagick.org/source/policy.xml) configuration file:

<policy domain="resource" name="thread" value="2"/>

Or suppose your 12 core hyperthreaded computer defaults to 24 threads. Set the MAGICK_THREAD_LIMIT environment variable and you will likely get improved performance:

    export MAGICK_THREAD_LIMIT=12

The OpenMP committee has not defined the behavior of mixing OpenMP with other threading models such as Posix threads. However, using modern releases of Linux, OpenMP and Posix threads appear to interoperate without complaint. If you want to use Posix threads from a program module that calls one of the ImageMagick application programming interfaces (e.g. MagickCore, MagickWand, Magick++, etc.) from Mac OS X or an older Linux release, you may need to disable OpenMP support within ImageMagick. Add the --disable-openmp option to the configure script command line and rebuild and reinstall ImageMagick.

You can further increase performance by reducing lock contention with the [tcmalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html) memory allocation library. To enable, add --with-tcmalloc to the configure command-line when you build ImageMagick.

#### Threading Performance

It can be difficult to predict behavior in a parallel environment. Performance might depend on a number of factors including the compiler, the version of the OpenMP library, the processor type, the number of cores, the amount of memory, whether hyperthreading is enabled, the mix of applications that are executing concurrently with ImageMagick, or the particular image-processing algorithm you utilize. The only way to be certain of optimal performance, in terms of the number of threads, is to benchmark. ImageMagick includes progressive threading when benchmarking a command and returns the elapsed time and efficiency for one or more threads. This can help you identify how many threads is the most efficient in your environment. For this benchmark we sharpen a 1920x1080 image of a model 10 times with 1 to 12 threads:

    $ magick -bench 10 model.png -sharpen 5x2 null:
    Performance[1]: 10i 1.135ips 1.000e 8.760u 0:08.810
    Performance[2]: 10i 2.020ips 0.640e 9.190u 0:04.950
    Performance[3]: 10i 2.786ips 0.710e 9.400u 0:03.590
    Performance[4]: 10i 3.378ips 0.749e 9.580u 0:02.960
    Performance[5]: 10i 4.032ips 0.780e 9.580u 0:02.480
    Performance[6]: 10i 4.566ips 0.801e 9.640u 0:02.190
    Performance[7]: 10i 3.788ips 0.769e 10.980u 0:02.640
    Performance[8]: 10i 4.115ips 0.784e 12.030u 0:02.430
    Performance[9]: 10i 4.484ips 0.798e 12.860u 0:02.230
    Performance[10]: 10i 4.274ips 0.790e 14.830u 0:02.340
    Performance[11]: 10i 4.348ips 0.793e 16.500u 0:02.300
    Performance[12]: 10i 4.525ips 0.799e 18.320u 0:02.210

The sweet spot for this example is 6 threads. This makes sense since there are 6 physical cores. The other 6 are hyperthreads. It appears that sharpening does not benefit from hyperthreading.

In certain cases, it might be optimal to set the number of threads to 1 or to disable OpenMP completely with the [MAGICK_THREAD_LIMIT] environment variable, [-limit] command line option, or the [policy.xml] configuration file.

Heterogeneous Distributed Processing
------------------------------------

ImageMagick includes support for heterogeneous distributed processing with the [OpenCL](http://en.wikipedia.org/wiki/OpenCL) framework. OpenCL kernels within ImageMagick permit image processing algorithms to execute across heterogeneous platforms consisting of CPUs, GPUs, and other processors. Depending on your platform, speed-ups can be an order of magnitude faster than the traditional single CPU.

First verify that your version of ImageMagick includes support for the OpenCL feature:

    magick identify -version
    Features: DPC Cipher Modules OpenCL OpenMP(4.5)

If so, run this command to realize a significant speed-up for image convolution:

    magick image.png -convolve '-1, -1, -1, -1, 9, -1, -1, -1, -1' convolve.png

If an accelerator is not available or if the accelerator fails to respond, ImageMagick reverts to the non-accelerated convolution algorithm.

Here is an example OpenCL kernel that convolves an image:

```cpp
static inline long ClampToCanvas(const long offset,const ulong range)
{
  if (offset < 0L)
    return(0L);
  if (offset >= range)
    return((long) (range-1L));
  return(offset);
}

static inline CLQuantum ClampToQuantum(const float value)
{
  if (value < 0.0)
    return((CLQuantum) 0);
  if (value >= (float) QuantumRange)
    return((CLQuantum) QuantumRange);
  return((CLQuantum) (value+0.5));
}

__kernel void Convolve(const __global CLPixelType *source,__constant float *filter,
  const ulong width,const ulong height,__global CLPixelType *destination)
{
  const ulong columns = get_global_size(0);
  const ulong rows = get_global_size(1);

  const long x = get_global_id(0);
  const long y = get_global_id(1);

  const float scale = (1.0/QuantumRange);
  const long mid_width = (width-1)/2;
  const long mid_height = (height-1)/2;
  float4 sum = { 0.0, 0.0, 0.0, 0.0 };
  float gamma = 0.0;
  register ulong i = 0;

  for (long v=(-mid_height); v <= mid_height; v++)
  {
    for (long u=(-mid_width); u <= mid_width; u++)
    {
      register const ulong index=ClampToCanvas(y+v,rows)*columns+ClampToCanvas(x+u,
        columns);
      const float alpha=scale*(QuantumRange-source[index].w);
      sum.x+=alpha*filter[i]*source[index].x;
      sum.y+=alpha*filter[i]*source[index].y;
      sum.z+=alpha*filter[i]*source[index].z;
      sum.w+=filter[i]*source[index].w;
      gamma+=alpha*filter[i];
      i++;
    }
  }

  gamma=1.0/(fabs(gamma) <= MagickEpsilon ? 1.0 : gamma);
  const ulong index=y*columns+x;
  destination[index].x=ClampToQuantum(gamma*sum.x);
  destination[index].y=ClampToQuantum(gamma*sum.y);
  destination[index].z=ClampToQuantum(gamma*sum.z);
  destination[index].w=ClampToQuantum(sum.w);
};
```

See [MagickCore/accelerate.c](https://github.com/ImageMagick/ImageMagick/blob/main/MagickCore/accelerate.c) for a complete implementation of image convolution with an OpenCL kernel.

Note, that under Windows, you might have an issue with TDR (Timeout Detection and Recovery of GPUs). Its purpose is to detect runaway tasks hanging the GPU by using an execution time threshold. For some older low-end GPUs running the OpenCL filters in ImageMagick, longer execution times might trigger the TDR mechanism and pre-empt the GPU image filter. When this happens, ImageMagick automatically falls back to the CPU code path and returns the expected results. To avoid pre-emption, increase the [TdrDelay](http://msdn.microsoft.com/en-us/library/windows/hardware/gg487368.aspx) registry key.

Custom Image Coders
-------------------

An image coder (i.e. encoder / decoder) is responsible for registering, optionally classifying, optionally reading, optionally writing, and unregistering one image format (e.g. PNG, GIF, JPEG, etc.). Registering an image coder alerts ImageMagick a particular format is available to read or write. While unregistering tells ImageMagick the format is no longer available. The classifying method looks at the first few bytes of an image and determines if the image is in the expected format. The reader sets the image size, colorspace, and other properties and loads the pixel cache with the pixels. The reader returns a single image or an image sequence (if the format supports multiple images per file), or if an error occurs, an exception and a null image. The writer does the reverse. It takes the image properties and unloads the pixel cache and writes them as required by the image format.

Here is a listing of a sample [custom coder](https://imagemagick.org/source/mgk.c). It reads and writes images in the MGK image format which is simply an ID followed by the image width and height followed by the RGB pixel values.

```cpp
#include <MagickCore/studio.h>
#include <MagickCore/blob.h>
#include <MagickCore/cache.h>
#include <MagickCore/colorspace.h>
#include <MagickCore/exception.h>
#include <MagickCore/image.h>
#include <MagickCore/list.h>
#include <MagickCore/magick.h>
#include <MagickCore/memory_.h>
#include <MagickCore/monitor.h>
#include <MagickCore/pixel-accessor.h>
#include <MagickCore/string_.h>
#include <MagickCore/module.h>
#include "filter/blob-private.h"
#include "filter/exception-private.h"
#include "filter/image-private.h"
#include "filter/monitor-private.h"
#include "filter/quantum-private.h"

/*
  Forward declarations.
*/
static MagickBooleanType
  WriteMGKImage(const ImageInfo *,Image *,ExceptionInfo *);

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   I s M G K                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  IsMGK() returns MagickTrue if the image format type, identified by the
%  magick string, is MGK.
%
%  The format of the IsMGK method is:
%
%      MagickBooleanType IsMGK(const unsigned char *magick,const size_t length)
%
%  A description of each parameter follows:
%
%    o magick: This string is generally the first few bytes of an image file
%      or blob.
%
%    o length: Specifies the length of the magick string.
%
*/
static MagickBooleanType IsMGK(const unsigned char *magick,const size_t length)
{
  if (length < 7)
    return(MagickFalse);
  if (LocaleNCompare((char *) magick,"id=mgk",7) == 0)
    return(MagickTrue);
  return(MagickFalse);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   R e a d M G K I m a g e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  ReadMGKImage() reads a MGK image file and returns it.  It allocates the
%  memory necessary for the new Image structure and returns a pointer to the
%  new image.
%
%  The format of the ReadMGKImage method is:
%
%      Image *ReadMGKImage(const ImageInfo *image_info,
%        ExceptionInfo *exception)
%
%  A description of each parameter follows:
%
%    o image_info: the image info.
%
%    o exception: return any errors or warnings in this structure.
%
*/
static Image *ReadMGKImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    buffer[MaxTextExtent];

  Image
    *image;

  long
    y;

  MagickBooleanType
    status;

  register long
    x;

  register Quantum
    *q;

  register unsigned char
    *p;

  ssize_t
    count;

  unsigned char
    *pixels;

  unsigned long
    columns,
    rows;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read MGK image.
  */
  (void) ReadBlobString(image,buffer);  /* read magic number */
  if (IsMGK(buffer,7) == MagickFalse)
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  (void) ReadBlobString(image,buffer);
  count=(ssize_t) sscanf(buffer,"%lu %lu\n",&columns,&rows);
  if (count <= 0)
    ThrowReaderException(CorruptImageError,"ImproperImageHeader");
  do
  {
    /*
      Initialize image structure.
    */
    image->columns=columns;
    image->rows=rows;
    image->depth=8;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    /*
      Convert MGK raster image to pixel packets.
    */
    if (SetImageExtent(image,image->columns,image->rows,exception) == MagickFalse)
      return(DestroyImageList(image));
    pixels=(unsigned char *) AcquireQuantumMemory((size_t) image->columns,
      3UL*sizeof(*pixels));
    if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y < (long) image->rows; y++)
    {
      count=(ssize_t) ReadBlob(image,(size_t) (3*image->columns),pixels);
      if (count != (ssize_t) (3*image->columns))
        ThrowReaderException(CorruptImageError,"UnableToReadImageData");
      p=pixels;
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (long) image->columns; x++)
      {
        SetPixelRed(image,ScaleCharToQuantum(*p++),q);
        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
        q+=GetPixelChannels(image);
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&
            (QuantumTick(y,image->rows) != MagickFalse))
          {
            status=image->progress_monitor(LoadImageTag,y,image->rows,
              image->client_data);
            if (status == MagickFalse)
              break;
          }
    }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    *buffer='\0';
    (void) ReadBlobString(image,buffer);
    count=(ssize_t) sscanf(buffer,"%lu %lu\n",&columns,&rows);
    if (count > 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        if (image->progress_monitor != (MagickProgressMonitor) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,TellBlob(image),
              GetBlobSize(image));
            if (status == MagickFalse)
              break;
          }
      }
  } while (count > 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   R e g i s t e r M G K I m a g e                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  RegisterMGKImage() adds attributes for the MGK image format to
%  the list of supported formats.  The attributes include the image format
%  tag, a method to read and/or write the format, whether the format
%  supports the saving of more than one frame to the same file or blob,
%  whether the format supports native in-memory I/O, and a brief
%  description of the format.
%
%  The format of the RegisterMGKImage method is:
%
%      unsigned long RegisterMGKImage(void)
%
*/
ModuleExport unsigned long RegisterMGKImage(void)
{
  MagickInfo
    *entry;

  entry=AcquireMagickInfo("MGK","MGK","MGK image");
  entry->decoder=(DecodeImageHandler *) ReadMGKImage;
  entry->encoder=(EncodeImageHandler *) WriteMGKImage;
  entry->magick=(IsImageFormatHandler *) IsMGK;
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U n r e g i s t e r M G K I m a g e                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  UnregisterMGKImage() removes format registrations made by the
%  MGK module from the list of supported formats.
%
%  The format of the UnregisterMGKImage method is:
%
%      UnregisterMGKImage(void)
%
*/
ModuleExport void UnregisterMGKImage(void)
{
  (void) UnregisterMagickInfo("MGK");
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e M G K I m a g e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  WriteMGKImage() writes an image to a file in red, green, and blue MGK
%  rasterfile format.
%
%  The format of the WriteMGKImage method is:
%
%      MagickBooleanType WriteMGKImage(const ImageInfo *image_info,
%        Image *image)
%
%  A description of each parameter follows.
%
%    o image_info: the image info.
%
%    o image:  The image.
%
%    o exception:  return any errors or warnings in this structure.
%
*/
static MagickBooleanType WriteMGKImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  char
    buffer[MaxTextExtent];

  long
    y;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const Quantum
    *p;

  register long
    x;

  register unsigned char
    *q;

  unsigned char
    *pixels;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  scene=0;
  do
  {
    /*
      Allocate memory for pixels.
    */
    if (image->colorspace != RGBColorspace)
      (void) SetImageColorspace(image,RGBColorspace,exception);
    pixels=(unsigned char *) AcquireQuantumMemory((size_t) image->columns,
      3UL*sizeof(*pixels));
    if (pixels == (unsigned char *) NULL)
      ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
    /*
      Initialize raster file header.
    */
    (void) WriteBlobString(image,"id=mgk\n");
    (void) FormatLocaleString(buffer,MaxTextExtent,"%lu %lu\n",image->columns,
       image->rows);
    (void) WriteBlobString(image,buffer);
    for (y=0; y < (long) image->rows; y++)
    {
      p=GetVirtualPixels(image,0,y,image->columns,1,exception);
      if (p == (const Quantum *) NULL)
        break;
      q=pixels;
      for (x=0; x < (long) image->columns; x++)
      {
        *q++=ScaleQuantumToChar(GetPixelRed(image,p));
        *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
        *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
        p+=GetPixelChannels(image);
      }
      (void) WriteBlob(image,(size_t) (q-pixels),pixels);
      if (image->previous == (Image *) NULL)
        if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&
            (QuantumTick(y,image->rows) != MagickFalse))
          {
            status=image->progress_monitor(SaveImageTag,y,image->rows,
              image->client_data);
            if (status == MagickFalse)
              break;
          }
    }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
    scene++;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}
```

To invoke the custom coder from the command line, use these commands:

    magick logo: logo.mgk
    display logo.mgk

We provide the [Magick Coder Kit](https://imagemagick.org/archive/kits/) to help you get started writing your own custom coder.

Before you build, set the PKG_CONFIG_PATH environment variable if ImageMagick is not in your default system path:

    export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig 

Custom Image Filters
--------------------

ImageMagick provides a convenient mechanism for adding your own custom image processing algorithms. We call these image filters and they are invoked from the command line with the [-process] option or from the MagickCore API method [ExecuteModuleProcess()].

Here is a listing of a sample [custom image filter](https://imagemagick.org/source/analyze.c). It computes a few statistics such as the pixel brightness and saturation mean and standard-deviation.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <assert.h>
#include <math.h>
#include "MagickCore/studio.h"
#include "MagickCore/MagickCore.h"

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   a n a l y z e I m a g e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  analyzeImage() computes the brightness and saturation mean,  standard
%  deviation, kurtosis and skewness and stores these values as attributes 
%  of the image.
%
%  The format of the analyzeImage method is:
%
%      size_t analyzeImage(Image *images,const int argc,char **argv,
%        ExceptionInfo *exception)
%
%  A description of each parameter follows:
%
%    o image: the address of a structure of type Image.
%
%    o argc: Specifies a pointer to an integer describing the number of
%      elements in the argument vector.
%
%    o argv: Specifies a pointer to a text array containing the command line
%      arguments.
%
%    o exception: return any errors or warnings in this structure.
%
*/

typedef struct _StatisticsInfo
{
  double
    area,
    brightness,
    mean,
    standard_deviation,
    sum[5],
    kurtosis,
    skewness;
} StatisticsInfo;

static inline int GetMagickNumberThreads(const Image *source,
  const Image *destination,const size_t chunk,int multithreaded)
{
#define MagickMax(x,y)  (((x) > (y)) ? (x) : (y))
#define MagickMin(x,y)  (((x) < (y)) ? (x) : (y))

  /*
    Number of threads bounded by the amount of work and any thread resource
    limit.  The limit is 2 if the pixel cache type is not memory or
    memory-mapped.
  */
  if (multithreaded == 0)
    return(1);
  if (((GetImagePixelCacheType(source) != MemoryCache) &&
       (GetImagePixelCacheType(source) != MapCache)) ||
      ((GetImagePixelCacheType(destination) != MemoryCache) &&
       (GetImagePixelCacheType(destination) != MapCache)))
    return(MagickMax(MagickMin(GetMagickResourceLimit(ThreadResource),2),1));
  return(MagickMax(MagickMin((ssize_t) GetMagickResourceLimit(ThreadResource),
    (ssize_t) (chunk)/64),1));
}

ModuleExport size_t analyzeImage(Image **images,const int argc,
  const char **argv,ExceptionInfo *exception)
{
#define AnalyzeImageFilterTag  "Filter/Analyze"
#define magick_number_threads(source,destination,chunk,multithreaded) \
  num_threads(GetMagickNumberThreads(source,destination,chunk,multithreaded))

  char
    text[MagickPathExtent];

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    progress;

  assert(images != (Image **) NULL);
  assert(*images != (Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  (void) argc;
  (void) argv;
  status=MagickTrue;
  progress=0;
  for (image=(*images); image != (Image *) NULL; image=GetNextImageInList(image))
  {
    CacheView
      *image_view;

    double
      area;

    ssize_t
      y;

    StatisticsInfo
      brightness,
      saturation;

    if (status == MagickFalse)
      continue;
    (void) memset(&brightness,0,sizeof(brightness));
    (void) memset(&saturation,0,sizeof(saturation));
    status=MagickTrue;
    image_view=AcquireVirtualCacheView(image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
  #pragma omp parallel for schedule(static) \
    shared(progress,status,brightness,saturation) \
    magick_number_threads(image,image,image->rows,1)
#endif
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      const Quantum
        *p;

      ssize_t
        i,
        x;

      StatisticsInfo
        local_brightness,
        local_saturation;

      if (status == MagickFalse)
        continue;
      p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
      if (p == (const Quantum *) NULL)
        {
          status=MagickFalse;
          continue;
        }
      (void) memset(&local_brightness,0,sizeof(local_brightness));
      (void) memset(&local_saturation,0,sizeof(local_saturation));
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        double
          b,
          h,
          s;

        ConvertRGBToHSL(GetPixelRed(image,p),GetPixelGreen(image,p),
          GetPixelBlue(image,p),&h,&s,&b);
        b*=QuantumRange;
        for (i=1; i <= 4; i++)
          local_brightness.sum[i]+=pow(b,(double) i);
        s*=QuantumRange;
        for (i=1; i <= 4; i++)
          local_saturation.sum[i]+=pow(s,(double) i);
        p+=GetPixelChannels(image);
      }
#if defined(MAGICKCORE_OPENMP_SUPPORT)
      #pragma omp critical (analyzeImage)
#endif
      for (i=1; i <= 4; i++)
      {
        brightness.sum[i]+=local_brightness.sum[i];
        saturation.sum[i]+=local_saturation.sum[i];
      }
    }
    image_view=DestroyCacheView(image_view);
    area=(double) image->columns*image->rows;
    brightness.mean=brightness.sum[1]/area;
    (void) FormatLocaleString(text,MagickPathExtent,"%g",brightness.mean);
    (void) SetImageProperty(image,"filter:brightness:mean",text,exception);
    brightness.standard_deviation=sqrt(brightness.sum[2]/area-
      (brightness.sum[1]/area*brightness.sum[1]/area));
    (void) FormatLocaleString(text,MagickPathExtent,"%g",
      brightness.standard_deviation);
    (void) SetImageProperty(image,"filter:brightness:standard-deviation",text,
      exception);
    if (fabs(brightness.standard_deviation) >= MagickEpsilon)
      brightness.kurtosis=(brightness.sum[4]/area-4.0*brightness.mean*
        brightness.sum[3]/area+6.0*brightness.mean*brightness.mean*
        brightness.sum[2]/area-3.0*brightness.mean*brightness.mean*
        brightness.mean*brightness.mean)/(brightness.standard_deviation*
        brightness.standard_deviation*brightness.standard_deviation*
        brightness.standard_deviation)-3.0;
    (void) FormatLocaleString(text,MagickPathExtent,"%g",brightness.kurtosis);
    (void) SetImageProperty(image,"filter:brightness:kurtosis",text,exception);
    if (brightness.standard_deviation != 0)
      brightness.skewness=(brightness.sum[3]/area-3.0*brightness.mean*
        brightness.sum[2]/area+2.0*brightness.mean*brightness.mean*
        brightness.mean)/(brightness.standard_deviation*
        brightness.standard_deviation*brightness.standard_deviation);
    (void) FormatLocaleString(text,MagickPathExtent,"%g",brightness.skewness);
    (void) SetImageProperty(image,"filter:brightness:skewness",text,exception);
    saturation.mean=saturation.sum[1]/area;
    (void) FormatLocaleString(text,MagickPathExtent,"%g",saturation.mean);
    (void) SetImageProperty(image,"filter:saturation:mean",text,exception);
    saturation.standard_deviation=sqrt(saturation.sum[2]/area-
      (saturation.sum[1]/area*saturation.sum[1]/area));
    (void) FormatLocaleString(text,MagickPathExtent,"%g",
      saturation.standard_deviation);
    (void) SetImageProperty(image,"filter:saturation:standard-deviation",text,
      exception);
    if (fabs(saturation.standard_deviation) >= MagickEpsilon)
      saturation.kurtosis=(saturation.sum[4]/area-4.0*saturation.mean*
        saturation.sum[3]/area+6.0*saturation.mean*saturation.mean*
        saturation.sum[2]/area-3.0*saturation.mean*saturation.mean*
        saturation.mean*saturation.mean)/(saturation.standard_deviation*
        saturation.standard_deviation*saturation.standard_deviation*
        saturation.standard_deviation)-3.0;
    (void) FormatLocaleString(text,MagickPathExtent,"%g",saturation.kurtosis);
    (void) SetImageProperty(image,"filter:saturation:kurtosis",text,exception);
    if (fabs(saturation.standard_deviation) >= MagickEpsilon)
      saturation.skewness=(saturation.sum[3]/area-3.0*saturation.mean*
        saturation.sum[2]/area+2.0*saturation.mean*saturation.mean*
        saturation.mean)/(saturation.standard_deviation*
        saturation.standard_deviation*saturation.standard_deviation);
    (void) FormatLocaleString(text,MagickPathExtent,"%g",saturation.skewness);
    (void) SetImageProperty(image,"filter:saturation:skewness",text,exception);
    if (image->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          proceed;

#if defined(MAGICKCORE_OPENMP_SUPPORT)
        #pragma omp atomic
#endif
        progress++;
        proceed=SetImageProgress(image,AnalyzeImageFilterTag,progress,
          GetImageListLength(image));
        if (proceed == MagickFalse)
          status=MagickFalse;
      }
  }
  return(MagickImageFilterSignature);
}
```

To invoke the custom filter from the command line, use this command:

    magick logo: -process \"analyze\" -verbose info:
    Image: logo:
      Format: LOGO (ImageMagick Logo)
      Class: PseudoClass
      Geometry: 640x480
      ...
      filter:brightness:kurtosis: 3.97886
      filter:brightness:mean: 58901.3
      filter:brightness:skewness: -2.30827
      filter:brightness:standard-deviation: 16179.8
      filter:saturation:kurtosis: 6.59719
      filter:saturation:mean: 5321.05
      filter:saturation:skewness: 2.75679
      filter:saturation:standard-deviation: 14484.7

We provide the [Magick Filter Kit](https://imagemagick.org/archive/kits/) to help you get started writing your own custom image filter.

Before you build, set the PKG_CONFIG_PATH environment variable if ImageMagick is not in your default system path:

    export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig 


/Showcase - Examples of ImageMagick Usage
=========================================

These examples of ImageMagick usage illustrate what you can do with an image from the command line, a program interface, or script. You can generate this image yourself with this [PerlMagick] script, [examples.pl](https://imagemagick.org/source/examples.pl).

![ImageMagick Examples](https://imagemagick.org/image/examples.jpg)


/Defines
========


The [-define] command-line option adds specific global settings generally used to control coders and image processing operations.

This option creates one or more definitions for coders and decoders to use while reading and writing image data. Definitions are generally used to control image file format coder modules, and image processing operations, beyond what is provided by normal means. Defined settings are listed in [-verbose] information ("info:" output format) as "Artifacts".

If value is missing for a definition, an empty-valued definition of a flag is created with that name. This used to control on/off options. Use [-define keys] to remove definitions previously created. Use `+define "*"` to remove all existing definitions.

The same 'artifact' settings can also be defined using the [-set "option:key" "value"] option, which also allows the use of [Format and Print Image Properties] in the defined value.

The option and key are case-independent (they are converted to lowercase for use within the decoders) while the value is case-dependent.

Such settings are global in scope, and affect all images and operations.

    magick bilevel.tif -define ps:imagemask eps3:stencil.ps 

Set attributes of the image registry by prefixing the value with registry:. For example, to set a temporary path to put work files, use:

    -define registry:temporary-path=/data/tmp 

Here is a list of recognized defines:

### Command-line Defines

*   `ashlar:best-fit`

    align tiles on both the left and right edges.

*   `ashlar:tiles`

    set the maximum number of image tiles to render per canvas.

*   `auto-threshold:verbose`

    return derived threshold as the auto-threshold:threshold image property.

*   `color:illuminant`

    reference illuminant, defaults to D65.

*   `colorspace:auto-grayscale=on|off`

    Prevent automatic conversion to grayscale inside coders that support grayscale. This should be accompanied by -type truecolor. PNG and TIF do not need this define. With PNG, just use PNG24:image. With TIF, just use -type truecolor. JPG and PSD will need this define.

*   `compare:ssim-radius=value`

    Set the structural similarity index radius.

*   `compare:ssim-sigma=value`

    Set the structural similarity index sigma.

*   `compare:ssim-k1=value`

    Set the structural similarity index k1 argument.

*   `compare:ssim-k2=value`

    Set the structural similarity index k2 argument.

*   `complex:snr=value`

    Set the divide SNR constant [-complex].

*   `compose:args=arguments`

    Set certain compose argument values when using convert ... -compose ... -composite. See [Image Composition].

*   `compose:clip-to-self=true|false`

    Some [-compose] methods can modify the 'destination' image outside the overlay area. It is disabled by default.

*   `compose:clamp=on|off`

    Set each pixel whose value is below zero to zero and any the pixel whose value is above the quantum range to the quantum range (e.g. 65535) otherwise the pixel value remains unchanged. Define supported in ImageMagick 6.9.1-3 and above.

*   `compose:compose=on|off`

    This special usage allows you to perform true mathematics of the image channels, without alpha composition effects, becoming involved.

*   `connected-components:angle-threshold=value`

    Merges any region with equivalent ellipse angle smaller than value into its surrounding region or largest neighbor. Supported in Imagemagick 7.0.9.24.

*   `connected-components:area-threshold=value`

    Merges any region with area smaller than value into its surrounding region or largest neighbor. Thresholds can optionally include ranges, e.g. 410-1600.

*   `connected-components:background-id=object-id`

    Identify which object is to be the background object. Supported in Imagemagick 7.0.9.21.

*   `connected-components:circularity-threshold=value`

    Merge any region with circularity smaller than value into its surrounding region or largest neighbor. Circularity is computed as 4*pi*area/perimeter^2. Supported in Imagemagick 7.0.9.24.

*   `connected-components:diameter-threshold=value`

    Merge any region with diameter smaller than value into its surrounding region or largest neighbor. Diameter is computed as sqrt(4 * area/pi). Supported in Imagemagick 7.0.9.24.

*   `connected-components:eccentricity-threshold=value`

    Merge any region with equivalent ellipse eccentricity smaller than value into its surrounding region or largest neighbor. Supported in Imagemagick 7.0.9.24.

*   `connected-components:exclude-header=true`

    List the objects without the header. Supported in Imagemagick 7.0.9.21.

*   `connected-components:keep=list-of-ids`

    Comma and/or hyphenated list of id values to keep in the output. Supported in Imagemagick 6.9.3-0.

*   `connected-components:keep-colors=red;green;blue`

    Keeps objects identified by their color in a semicolon separated list. Supported in Imagemagick 6.9.3-0.

*   `connected-components:keep-top=number-of-objects`

    Keeps only the top number of objects by area. Supported in Imagemagick 7.0.9.21.

*   `connected-components:major-axis-threshold=value`

    Merge any region with equivalent ellipse major axis diameter smaller than value into its surrounding region or largest neighbor. Supported in Imagemagick 7.0.9.24.

*   `connected-components:mean-color=true`

    Change the output image from id values to mean color values. Supported in Imagemagick 6.9.2-8.

*   `connected-components:minor-axis-threshold=value`

    Merge any region with equivalent ellipse minor axis diameter smaller than value into its surrounding region or largest neighbor. Supported in Imagemagick 7.0.9.24.

*   `connected-components:perimeter-threshold=value`

    Merge any region with perimeter smaller than value into its surrounding region or largest neighbor. Supported in Imagemagick 7.0.9.24.

*   `connected-components:remove=list-of-ids`

    Comma and/or hyphenated list of id values to remove from the output. Supported in Imagemagick 6.9.2-9.

*   `connected-components:remove-colors=red;green;blue`

    Remove objects identified by their color in a semicolon separated list. Supported in Imagemagick 6.9.3-0.

*   `connected-components:verbose=true`

    Lists id, bounding box, centroid, area, mean color for each region.

*   `convolve:scale={kernel_scale}[!^] [,{origin_addition}] [%]`

    Define the kernel scaling. The special flag ! automatically scales to full dynamic range. The ! flag can be used in combination with a factor or percent. The factor or percent is then applied after the automatic scaling. An example is 50%!. This produces a result 50% darker than full dynamic range scaling. The ^ flag assures the kernel is 'zero-summing', for example when some values are positive and some are negative as in edge detection kernels. The origin addition adds that value to the center pixel of the kernel. This produces an effect that is like adding the image that many times to the result of the filtered image. The typical value is 1 so that the original image is added to the result of the convolution. The default is 0.

*   `deskew:auto-crop=true`

    auto crop the image after deskewing.

*   `delegate:bimodal=true`

    Specify direct conversion from Postscript to PDF.

*   `distort:scale=value`

    Set the output scaling factor for use with [-distort].

*   `distort:viewport=WxH+X+Y`

    Set the viewport for use with [-distort].

*   `dither:diffusion-amount=X%`

    Set the amount of diffusion to use with Floyd-Steinberg diffusion

*   `exif:sync-image=false`

    By default, the resolution of the image is synced with the EXIF profile. Use this define to ignore the EXIF profile.

*   `filename:literal=true`

    By default, an output filename can contain [embedded formatting characters]. Use this option to bypass interpretting embedded formatting characters and instead use the filename literally.

*   `filter:option=value`

    Set a filter option for use with [-resize]. See below for specific options.

*   `filter:b=value`

    Redefine the spline factor used for cubic filters such as Cubic, Catrom, Mitchel, and Hermite, as well as the Parzen cubic windowing function. If only one of the b or c values are defined, the other is set so as to generate a 'Cubic-Keys' filter. The meaning of the b and c values was defined in a research paper by Mitchell-Netravali.

*   `filter:blur=factor`

    Scale the X axis of the filter (and its window). Use > 1.0 for blurry or < 1.0 for sharp. This should only be used with Gaussian and Gaussian-like filters simple filters, or you may not get the expected results.

*   `filter:c=value`

    Redefine the Keys alpha factor used for cubic filters such as Cubic, Catrom, Mitchel, and Hermite, as well as the Parzen cubic windowing function. If only one of the b or c values are defined, the other is set so as to generate a 'Cubic-Keys' filter. The meaning of the b and c values was defined in a research paper by Mitchell-Netravali.

*   `filter:kaiser-alpha=value`

    Set the Kaiser window alpha value. When it is multiplied by 'PI', it is equivalent to "kaiser-beta" and will override that setting. It only affects the Kaiser windowing function and does not affect any other attributes.

*   `filter:kaiser-beta=value`

    Set the Kaiser window beta value. It only affects Kaiser windowing function and does not affect any other attributes. Before ImageMagick v6.7.6-10, this option was known as "filter:alpha" (an inheritance from the very old "zoom" program). It was changed to bring the function in line with more modern academic research usage and better assign it be more definitive. The default value is 6.5

*   `filter:lobes=count`

    Set the number of lobes to use for the Sinc/Bessel filter. This is an alternate way of specifying the 'support' range of the filter, that is designed to be more suited to windowed filters, especially when used for image distorts.

*   `filter:sigma=value`

    Set the 'sigma' value used to define the Gaussian filter. The default sigma value is '0.5'. It only affects the Gaussian filter, but does not shrink (but may enlarge) the filter's 'support'. It can be used to generate very small blurs, but without the filter 'missing' pixels due to using a small support setting. A larger value of '0.707' (a value of '1/sqrt(2)') is another common setting.

*   `filter:support=radius`

    Set the filter support radius. It defines how large the filter should be and thus directly defines how slow the filtered resampling process is. All filters have a default 'preferred' support size. Some filters like Lagrange and windowed filters adjust themselves depending on this value. With simple filters this value either does nothing (but slow the resampling), or will clip the filter function in a detrimental way.

*   `filter:verbose=true`

    Enable printing of information about the final internal filter selection to standard output. This includes a commented header on the filter settings being used and data allowing the filter weights to be easily graphed. Note however that some filters are internally defined in terms of other filters. The Lanczos filter, for example, is defined in terms of a SincFast windowed SincFast filter, while the Mitchell filter is defined as a general Cubic family filter with specific 'B' and 'C' settings.

*   `filter:window=filter_function`

    The IIR (infinite impulse response) filters Sinc and Jinc are windowed (brought down to zero over the defined support range) with the given filter. This allows you to specify a filter function to be used as a windowing function for these IIR filters. Many of the defined filters are actually windowing functions for these IIR filters. A typical choices is Box, (which effectively turns off the windowing function).

*   `filter:window-support=radius`

    Scale the windowing function to this size. This causes the windowing (or self-windowing Lagrange filter) to act is if the support window is larger than what is actually supplied to the calling operator. The filter, however, is still clipped to the true support size that is provided. If unset, this will equal the normal filter support size.

*   `h:format=value`

    Set the image encoding format use when writing a C-style header. format can be any output format supported by ImageMagick except for h and magick. If this option is omitted, the default is GIF for PseudoClass images and PNM for DirectClass images.

*   `fourier:normalize=inverse`

    Set the location for the FFT/IFT normalization as use by [+-fft] and [+-ift]. The default is forward.

*   `frames:step`

    When selecting image [frames], the default is to step one frame at a time through a list, e.g. [0-3], returns frames 0, 1, 2, and 3. Set the step to 2 in this example and we instead get frames 0 and 2.

*   `fx:debug=true`

    Debug -fx expression.

    hough-lines:accumulator=true

    Return the accumulator image in addition to the lines image.

*   `json:features`

    Include features in verbose information.

*   `json:limit`

*   `json:locate`

*   `json:moments`

    Include image moments in verbose information.

*   `kmeans:seed-colors=color-list`

    Initialize the colors, where color-list is a semicolon delimited list of seed colors (e.g. red;sRGB(19,167,254);#00ffff)

*   `magick:format=value`

    Set the image encoding format use when writing a C-style header. This is the same as "h:format=format" described above.

*   `magnify:method=value`

    Choose the method of pixel art magnification. The choices are: eagle2X, eagle3X, eagle3XB, epb2X, fish2X, hq2X, scale2X (default), scale3X, xbr2X

*   `modulate:colorspace=colorspace`

    Define the colorspace to use with [-modulate]. Any hue-based colorspace may be use. The default is HSL.

*   `morphology:compose=compose-method`

    Specify how to merge results generated by multiple[-morphology] kernel. The default is none. One typical value is 'lighten' as used, for example, with the sobel edge kernels.

*   `morphology:showKernel=1`

    Output (to 'standard error') all the information about a generated [-morphology] kernel.

*   `phash:colorspaces=colorspace,colorspace,...`

    The perceptual hash defaults to the sRGB and HCLp colorspaces. When using this define, you can specify up to six alternative colorspaces. (as of IM 7.0.3-8)

*   `phash:normalize=true`

    Normalize the phash metric

*   `profile:skip=name1,name2,...`

    Skip the named profile[s] when reading the image. Use skip="*" to skip all named profiles in the image. Many named profiles exist, including ICC, EXIF, APP1, IPTC, XMP, and others.

*   `precision:highres-transform=true`

    Increase the profile transform precision. Note, there is a slight performance penalty as the high-precision transform is floating point rather than unsigned. It is important to note that results may depend on whether or not the original image already has an included profile.

    preserve-timestamp=true|false

    Preserve file timestamp (mogrify only).

    q-table=quantization-table.xml

    Custom JPEG quantization tables.

*   `quantum:format=type`

    Set the type to floating-point to specify a floating-point format for raw files (e.g. GRAY:) or for MIFF and TIFF images in HDRI mode to preserve negative values. If [-depth] 16 is included, the result is a single precision floating point format. If [-depth] 32 is included, the result is double precision floating point format. For signed pixel data, use -define quantum:format=signed

*   `quantum:maximum=value`

    Maximum value for certain image types such as DCM. If not set, the the maximum value is QuantumRange.

*   `quantum:minimum=value`

    Minimum value for certain image types such as DCM. If not set, the the minimum value is zero.

*   `quantum:polarity=photometric-interpretation`

    Set the photometric-interpretation of an image (typically for TIFF image file format) to either min-is-black (default) or min-is-white.

*   `registry:attribute\=value`

    Set attributes of the image registry, for example, registry:temporary-path=/data/tmp.

*   `registry:date:precision=length`

    Set the maximum number of characters printed for any timestamp.

*   `registry:option:pedantic=true | false`

    By default, if a command-line option is also a filename (e.g., -quality), it is intrepetted as a filename. Set this option to true to interpret it as an option.

*   `registry:precision=value`

    Set the maximum number of significant digits to be printed.

*   `resample:verbose=true`

    Output the cylindrical filter lookup table created by the EWA (Elliptical Weighted Average) resampling algorithm. Note this table uses a squared radius lookup value. This is typically only used for debugging EWA resampling.

*   `sample:offset=geometry`

    Location of the sampling point within the sub-region being sampled, expressed as percentages (see [-sample]).

*   `shepards:power=value`

    Set the exponent in the Shepard's distortion. The default is 2.

*   `stream:buffer-size=value`

    Set the stream buffer size. Select 0 for unbuffered I/O.

*   `trim:percent-background=X%`

    Set the amount of background that is tolerated in an edge. It is specified as a percent. 0% means no background is tolerated. 50% means an edge can contain up to 50% pixels that are background per the fuzz-factor.

*   `trim:edges={north,east,south,west}`

    Only trim the specified edges of the image.

*   `trim:minSize=geometry`

    Limit the trim to the specified size.

*   `type:features=string`

    Add a font feature to be used by the RAQM delegate during complex text layout. This is usually used to turn on optional font features that are not enabled by default, but can be also used to turn off default font features. Features include those to control kerning, ligature and Arabic.

*   `type:hinting=false`

    Disable font hinting. Proper glyph rendering needs the scaled points to be aligned along the target device pixel grid, through an operation often called hinting. One of its main purposes is to ensure that important widths and heights are respected throughout the whole font. (For example, it is very often desirable that the ‘I’ and the ‘T’ glyphs have their central vertical line of the same pixel width. Hinting also manages features like stems and overshoots, which can cause problems at small pixel sizes.

    white-balance:vibrance=value{%}

    Change in color vibrance of the a & b channels.

*   `x:screen=true`

    Obtain the image from the root window.

*   `x:silent=true`

    Turn off the beep when importing an image.

    IMAGE FORMATS

*   `bmp3:alpha=true|false`

    Include any alpha channel when writing in the BMP image format.

*   `bmp:format=value`

    Valid values are bmp2, bmp3, and bmp4. This option can be useful when the method of prepending "BMP2:" to the output filename is inconvenient or is not available, such as when using the [mogrify] utility.

*   `bmp:subtype=value`

    BMP channel depth subtypes. The choices are: RGB555, RGB565, ARGB4444, ARGB1555. Only support in BMP (BMP4). BMP3 and BMP2 do not contain header fields to support these options.

    {caption,label}:{max,start}-pointsize=value

    This sets the bounding pointsize to use when searching for the maximum pointsize where the text annotation still fits within the image boundaries.

*   `dcm:display-range=reset`

    Set the display range to the minimum and maximum pixel values for the DCM image format.

*   `dcm:rescale=true`

    Enable interpretation of the rescale slope and intercept settings in the file.

*   `dcm:rescale=true`

    Enable interpretation of the rescale slope and intercept settings in the file.

*   `dcm:window=CxW`

    Specify the dcm window center and width.

*   `dds:cluster-fit=true|false`

    Enable the DDS cluster-fit.

*   `dds:compression=dxt1|dxt5|none`

    Set the dds compression.

*   `dds:mipmaps=value`

    Set the dds number of mipmaps.

*   `dds:weight-by-alpha=true|false`

    Enable the DDS alpha weighting.

*   `dng:no-auto-bright=true`

    Disable the histogram-based white level.

*   `dng:output-color=value`

    Select the output colorspace. The choices are: 0 - Raw color (unique to each camera), 1 - sRGB D65 (default), 2 - Adobe RGB (1998) D65, 3 - Wide Gamut RGB D65, 4 - Kodak ProPhoto RGB D65, 5 - XYZ, 6 - ACES

*   `dng:read-thumbnail=true`

    Read the embedded thumbnail and store it as a profile called 'dng:thumbnail'.

*   `dng:use-auto-wb=true`

    Compute the white balance by averaging the entire image.

*   `dng:use-camera-wb=true`

    Uses the white balance specified by the camera.

*   `dot:layout-engine=value`

    Specify the layout engine for the DOT image format (e.g. neato).

*   `eps:use-cropbox=true`

    Force Imagemagick to respect the crop box.

*   `exr:color-type=value`

    Specify the color type for the EXR format: RGB, RGBA, YC, YCA, Y, YA, R, G, B, A).

*   `fpx:view=value`

    Specify the FlashPix viewing object, which contains the specification of a viewing transform. The viewing transform enables applications to represent a set of simple edits as a list of "commands" which are applied to the image in real time without altering the original image.

*   `ftxt:chsep=value`

    A single text character that separates channel values for reading and writing. Default: "," (Comma).

*   `ftxt:format=value`

    The format string for writing and reading. Default: "\x,\y:\c". For escapes \x etc, see [ftxt: formatted text](http://im.snibgo.com/fmttxt.htm).

*   `ftxt:hasalpha=value`

    Whether the text has an alpha channel, for reading only. Default: false.

*   `ftxt:nummeta=value`

    The number of meta channels, for reading only. Default 0 (Zero).

*   `heic:chroma=value`

    set the HEIC chroma parameter. Possible values are: "420", "422", "444". Default is "420".

*   `heic:depth-image=true`

    extract the depth image if the container has one.

*   `heic:speed=value`

    set the HEIC speed parameter. Integer value from 0-9. Default is 5.

*   `heic:preserve-orientation=true`

    Preserve the original EXIF orientation during HEIC decoding and rotate the pixels accordingly. By default, EXIF orientation is reset to "1" to match the actual orientation of pixels in HEIC.

*   `icon:auto-resize`

    Automatically stores multiple sizes when writing an ico image (requires a 256x256 input image).

*   `jp2:layer-number=value`

    Set the maximum number of quality layers to decode. Same for JPT, JC2, and J2K.

*   `jp2:number-resolutions=value`

    Set the number of resolutions to encode.Same for JPT, JC2, and J2K.

*   `jp2:progression-order=value`

    Choose from LRCP, RLCP, RPCL, PCRL or CPRL. Same for JPT, JC2, and J2K.

*   `jp2:quality=value,value...`

    Set the quality layer PSNR, given in dB. The order is from left to right in ascending order. The default is a single lossless quality layer. Same for JPT, JC2, and J2K.

*   `jp2:rate=value`

    Specify the compression factor to use while writing JPEG-2000 files. The compression factor is the reciprocal of the compression ratio. The valid range is 0.0 to 1.0, with 1.0 indicating lossless compression. If defined, this value overrides the -quality setting. A quality setting of 75 results in a rate value of 0.06641. Same for JPT, JC2, and J2K.

*   `jp2:reduce-factor=value`

    Set the number of highest resolution levels to be discarded.Same for JPT, JC2, and J2K.

*   `jpeg:arithmetic-coding=on|off`

    enable/disable Huffman optimization.

*   `jpeg:block-smoothing=on|off`

*   `jpeg:colors=value`

    Set the desired number of colors and let the JPEG encoder do the quantizing.

*   `jpeg:dct-method=value`

    Choose from default, fastest, float, ifast, and islow.

*   `jpeg:extent=value`

    Restrict the maximum JPEG file size, for example -define jpeg:extent=400KB. The JPEG encoder will search for the highest compression quality level that results in an output file that does not exceed the value. The -quality option also will be respected starting with version 6.9.2-5. Between 6.9.1-0 and 6.9.2-4, add -quality 100 in order for the jpeg:extent to work properly. Prior to 6.9.1-0, the -quality setting was ignored.

*   `jpeg:fancy-upsampling=on|off`

*   `jpeg:optimize-coding=on|off`

*   `jpeg:q-table=table`

*   `jpeg:sampling-factor=sampling-factor-string`

*   `jpeg:size=geometry`

    Set the size hint of a JPEG image, for example, -define jpeg:size=128x128. It is most useful for increasing performance and reducing the memory requirements when reducing the size of a large JPEG image.

*   `jxl:effort=value`

    Set the jpeg-xl encoding effort. Valid values are in the range of 3 (falcon) to 9 (tortois).

*   `mng:need-cacheoff`

    turn playback caching off for streaming MNG.

*   `pcl:fit-to-page=true`

*   `pdf:author=author`

    Sets the author of the document

*   `pdf:create-epoch=seconds`

    Sets the creation time of the document

*   `pdf:creator=creator`

    Sets the creator of the document

*   `pdf:fit-page=geometry`

    Geometry specifies the scaling dimensions for resizing when the PDF is being read. The geometry is either WxH{%} or page size. No offsets are allowed. (introduced in IM 6.8.8-8)

*   `pdf:fit-to-page=true`

*   `pdf:hide-annotations=true`

    hide annotations associated with the page Annots key.

*   `pdf:interpolate=true`

    enable interpolation while rendering

*   `pdf:keywords=keywords`

    Sets the keywords of the document

*   `pdf:modify-epoch=seconds`

    Sets the modification time of the document

*   `pdf:page-direction=right-to-left`

*   `pdf:producer=producer`

    Sets the producer of the document

*   `pdf:subject=subject`

    Sets the subject of the document

*   `pdf:stop-on-error=true`

*   `pdf:thumbnail=false`

    Skip writing a thumbnail when saving a PDF file.

*   `pdf:title=title`

    Sets the title of the document

*   `pdf:use-cropbox=true`

*   `pdf:use-trimbox=true`

*   `pixel:compliance={none|undefined|svg|mvg|x11|xpm}`

    In combination with [-depth], this define allows color values to be presented in one or combination of: percent, names, 8-bit components, or hex values. 16-bit depth values are generally shown as percents and 8-bit depth values generally are shown as a combination of color names and 8-bit component values.

*   `png:bit-depth=value`

*   `png:color-type=value`

    Desired bit-depth and color-type for PNG output. You can force the PNG encoder to use a different bit-depth and color-type than it would have normally selected, but only if this does not cause any loss of image quality. Any attempt to reduce image quality is treated as an error and no PNG file is written. E.g., if you have a 1-bit black-and-white image, you can use these "defines" to cause it to be written as an 8-bit grayscale, indexed, or even a 64-bit RGBA. But if you have a 16-million color image, you cannot force it to be written as a grayscale or indexed PNG. If you wish to do this, you must use the appropriate [-depth], [-colors], or [-type] directives to reduce the image quality prior to using the PNG encoder. Note that in indexed PNG files, "bit-depth" refers to the number of bits per index, which can be 1, 2, 4, or 8. In such files, the color samples always have 8-bit depth.

*   `png:compression-filter=value`

    Valid values are 0 through 9. 0-4 are the corresponding PNG filters, 5 means adaptive filtering except for images with a colormap, 6 means adaptive filtering for all images, 7 means MNG "loco" compression, 8 means Z_RLE strategy with adaptive filtering, and 9 means Z_RLE strategy with no filtering.

*   `png:compression-level=value`

    Valid values are 0 through 9, with 0 providing the least, but fastest compression and 9 usually providing the best and always the slowest.

*   `png:compression-strategy=value`

    Valid values are 0 through 4, meaning default, filtered, huffman_only, rle, and fixed ZLIB compression strategy. If you are using an old zlib that does not support Z_RLE (before 1.2.0) or Z_FIXED (before 1.2.2.2), values 3 and 4, respectively, will use the zlib default strategy instead.

*   `png:format=value`

    valid values are png8, png24, png32, png48, png64, and png00. This property is useful for specifying the specific PNG format to be used, when the usual method of prepending the format name to the output filename is inconvenient, such as when writing a PNG-encoded ICO file or when using [mogrify]. Value = png8 reduces the number of colors to 256, only one of which may be fully transparent, if necessary. The other values do not force any reduction of quality; it is an error to request a format that cannot represent the image data without loss (except that it is allowed to reduce the bit-depth from 16 to 8 for all formats). Value = png24 and png48 allow transparency, only if a single color is fully transparent and that color does not also appear in an opaque pixel; such transparency is written in a PNG tRNS chunk. Value = png00 causes the image to inherit its color-type and bit-depth from the input image, if the input was also a PNG.

*   `png:exclude-chunk=value`

*   `png:include-chunk=value`

    ancillary chunks to be excluded from or included in PNG output.

    The value can be the name of a PNG chunk-type such as bKGD, a comma-separated list of chunk-names (which can include the word date, the word all, or the word none). Although PNG chunk-names are case-dependent, you can use all lowercase names if you prefer.

    The "include-chunk" and "exclude-chunk" lists only affect the behavior of the PNG encoder and have no effect on the PNG decoder.

    As a special case, if the sRGB chunk is excluded and the gAMA chunk is included, the gAMA chunk will only be written if gamma is not 1/2.2, since most decoders do not assume sRGB for gAMA=0.45455 when no colorspace information is included in the PNG file. Because the list is processed from left to right, you can achieve this with a single define:

        -define png:include-chunk=none,gAMA
            

    As a special case, if the sRGB chunk is not excluded and the PNG encoder recognizes that the image contains the sRGB ICC profile, the PNG encoder will write the sRGB chunk instead of the entire ICC profile. To force the PNG encoder to write the sRGB profile as an iCCP chunk in the output PNG instead of the sRGB chunk, exclude the sRGB chunk.

    The critical PNG chunks IHDR, PLTE, IDAT, and IEND cannot be excluded. Any such entries appearing in the list will be ignored.

    If the ancillary PNG tRNS chunk is excluded and the image has transparency, the PNG colortype is forced to be 4 or 6 (GRAY_ALPHA or RGBA). If the image is not transparent, then the tRNS chunk isn't written anyhow, and there is no effect on the PNG colortype of the output image.

    The [-strip] option does the equivalent of the following for PNG output:

        -define png:exclude-chunk=EXIF,iCCP,iTXt,sRGB,tEXt,zCCP,zTXt,date

    The default behavior is to include all known PNG ancillary chunks plus ImageMagick's private vpAg ("virtual page") chunk, and to exclude all PNG chunks that are unknown to ImageMagick, regardless of their PNG "copy-safe" status as described in the PNG specification.

    Any chunk names that are not known to ImageMagick are ignored if they appear in either the "include-chunk" or "exclude-chunk" list. The ancillary chunks currently known to ImageMagick are bKGD, cHRM, gAMA, iCCP, oFFs, orNT, pHYs, sRGB, tEXt, tRNS, vpAg, and zTXt.

    You can also put date in the list to include or exclude the "Date:create" and "Date:modify" text chunks that ImageMagick normally inserts in the output PNG.

*   `png:ignore-crc[=true]`

    When you know your image has no CRC or ADLER32 errors, this can speed up decoding. It is also helpful in debugging bug reports from "fuzzers".

*   `png:preserve-colormap[=true]`

    Use the existing image->colormap. Normally the PNG encoder will try to optimize the palette, eliminating unused entries and putting the transparent colors first. If this flag is set, that behavior is suppressed.

*   `png:preserve-iCCP[=true]`

    By default, the PNG decoder and encoder examine any ICC profile that is present, either from an iCCP chunk in the PNG input or supplied via an option, and if the profile is recognized to be the sRGB profile, converts it to the sRGB chunk. You can use -define png:preserve-iCCP to prevent this from happening; in such cases the iCCP chunk will be read or written and no sRGB chunk will be written. There are some ICC profiles that claim to be sRGB but have various errors that cause them to be rejected by libpng16; such profiles are recognized anyhow and converted to the sRGB chunk, but are rejected if the -define png:preserve-iCCP is present. Note that not all "sRGB" ICC profiles are recognized yet; we will add them to the list as we encounter them.

*   `png:swap-bytes[=true]`

    The PNG specification requires that any multi-byte integers be stored in network byte order (MSB-LSB endian). This option allows you to fix any invalid PNG files that have 16-bit samples stored incorrectly in little-endian order (LSB-MSB). The "-define png:swap-bytes" option must appear before the input filename on the commandline. The swapping is done during the libpng decoding operation.

*   `ps:imagemask`

    If the ps:imagemask flag is defined, the PS3 and EPS3 coders will create Postscript files that render bilevel images with the Postscript imagemask operator instead of the image operator.

*   `psd:additional-info=all|selective`

    This option should only be used when converting from a PSD file to another PSD file. This should be placed after the image is read. The two options are 'all' and 'selective'. The 'selective' option will preserve all additional information that is not related to the geometry of the image. The 'all' option should only be used when the geometry of the image has not been changed. This option is helpful when transferring non-simple layers, such as adjustment layers from the input PSD file to the output PSD file. If this option is not used, the additional information will not be preserved. This define is available as of Imagemagick version 6.9.5-8.

*   `psd:alpha-unblend=off`

    Disable new automatic un-blending of transparency with the base image for the flattened layer 0 before adding the alpha channel to the output image. This define must be placed before the input psd image. (Available as of IM 6.9.2.5). The automatic un-blending is new to IM 6.9.2.5 and prevents the transparency from being applied twice in the output image. This option should be set before reading the image.

*   `psd:preserve-opacity-mask=true`

    This option should only be used when converting from a PSD file to another PSD file. It will preserve the opacity mask of a layer and add it back to the layer when the image is saved. Setting this to 'true' will enable this feature. This define is available as of Imagemagick version 6.9.5-10.

*   `psd:write-layers=false`

    This option can be used to disable writing the layers of a PSD file.

*   `psd:replicate-profile=true`

    This option can be used to copy the image profile to all the images instead of only the first image that is returned.

*   `svg:xml-parse-huge=true`

    Enable rendering of a very large SVG for which you trust the source

*   `tga:preserve-orientation=true`

    Preserve the image orientation.

*   `tiff:alpha=associated|unassociated|unspecified`

    Specify the alpha extra samples as associated, unassociated or unspecified.

*   `tiff:endian=msb|lsb`

*   `tiff:exif-properties=false`

    Disable reading the EXIF properties.

*   `tiff:fill-order=msb|lsb`

*   `tiff:gps-properties=false`

    Disable reading the GPS properties.

*   `tiff:ignore-layers=true`

    Ignore the Photoshop layers.

*   `tiff:ignore-tags=comma-separate-list-of-tag-IDs`

    Allow one or more tag ID values to be ignored.

*   `tiff:predictor=[1, 2 or 3]`

    A mathematical operator that is applied to the image data before an encoding scheme is applied. The general idea is that subsequent pixels of an image resemble each other. Thus, substracting the information from a pixel that is already contained in previous one is likely to reduce its information density considerably and aid subsequent compression. 1 = No prediction scheme used before coding. 2 = Horizontal differencing. 3 = Floating point horizontal differencing.

*   `tiff:preserve-compression=true`

    Preserve compression of the source image.

*   `tiff:rows-per-strip=value`

    Set the number of rows per strip.

*   `tiff:tile-geometry=WxH`

    Set the tile size for pyramid tiffs. Requires the suffix PTIF: before the outputname.

*   `video:intermediate-format={pam,webp}`

    Set the video intermediate format option of ffmpeg.

*   `video:pixel-format=value`

    Set the pixel format option of ffmpeg.

*   `video:vsync=value`

    Set the vsync option of ffmpeg.


### PSEUDO-IMAGE FORMATS

*   `caption:max-pointsize=pointsize`

    Limit the maximum point size

*   `caption:split=boolean`

    split text if required to fit caption on canvas

*   `gradient:angle=angle (in degrees)`

    For a linear gradient, this specifies the direction of the gradient going from color1 to color2 in a clockwise positive manner relative to north (up). For a radial gradient, this specifies the rotation of the gradient in a clockwise positive manner from its normal X-Y orientation. Supported in Imagemagick 6.9.2-5.

*   `gradient:bounding-box=WxH+X+Y`

    Limit the gradient to a larger or smaller region than the image dimensions. If the region defined by the bounding box is smaller than the image, then color1 will be the color of the background. Supported in Imagemagick 6.9.2-5.

*   `gradient:center=x,y`

    Specify the coordinates of the center point for the radial gradient. The default is the center of the image. Supported in Imagemagick 6.9.2-5.

*   `gradient:direction=value`

    Specify the direction of the linear gradient towards the top/bottom/left/right or diagonal corners. The choices are: NorthWest, North, Northeast, West, East, SouthWest, South, SouthEast. Supported in Imagemagick 6.9.2-5.

*   `gradient:extent=value`

    Specify the shape of an image centered radial gradient. The choices are: Circle, Diagonal, Ellipse, Maximum, Minimum. Circle and Maximum draw a circular radial gradient even for rectangular shaped images of radius equal to the larger of the half-width and half-height of the image. The Circle and Maximum options are both equivalent to the default radial gradient. The Minimum option draws a circular radial gradient even for rectangular shaped images of radius equal to the smaller of the half-width and half-height of the image. The Diagonal option draws a circular radial gradient even for rectangular shaped images of radius equal to the half-diagonal of the image. The Ellipse options draws an elliptical radial gradient for rectangular shaped images of radii equal to half the width and half the height of the image. Supported in Imagemagick 6.9.2-5.

*   `gradient:radii=x,y`

    Specify the x and y radii of the gradient. If the x radius and the y radius are equal, the shape of the radial gradient will be a circle. If they differ, then the shape will be an ellipse. The default values are the maximum of the half width and half height of the image. Supported in Imagemagick 6.9.2-5.

*   `gradient:vector=x1,y1,x2,y2`

    Specify the direction of the linear gradient going from vector1 (x1,y1) to vector2 (x2,y2). Color1 (fromColor) will be located at vector position x1,y1 and color2 (toColor) will be located at vector position x2,y2. Supported in Imagemagick 6.9.2-5.

*   `histogram:unique-colors=false`

    Suppress the textual listing of the image's unique colors.

*   `pango:align=left|center|right`
*   `pango:auto-dir=true|false`
*   `pango:ellipsize=start|middle|end`
*   `pango:gravity-hint=natural|strong|line`
*   `pango:hinting=none|auto|full`
*   `pango:indent=points`
*   `pango:justify=true|false`
*   `pango:language=en_US|others`
*   `pango:markup=true|false`
*   `pango:single-paragraph=true|false`
*   `pango:wrap=word|char|word-char`
*   `pixel:compliance=value`

    Set the "pixel:" output format according to several standards. The choices are SVG, None, Undefined, MVG, X11, XPM. The default list values for (s)RGB colors in the form of (s)rgb(r,g,b) or (s)rgba(r,g,b,a). Color names will no longer be presented. For sRGB or RGB colors, the SVG, X11, XPM and None options lists color names, if they exist. The MVG and Undefined options list hex values. When colors are presented or converted to hue-based colorspaces, the values listed will be integers for hue and percents for the other two components. For other colorspaces, values may be listed as either percents or fractional value. Setting the depth to 8 will limit values to the 8-bit range, except for hue-based colors.

*   `txt:compliance=value`

    Set the "txt:" format for the values in parentheses according to several standards. The choices are svg, none, undefined, mvg, x11, xpm. The default will list values for (s)RGB colors in the quantum range. The SVG, X11, XPM, MVG and None options lists values in the 8-bit range for all Q-level compiles. The undefined option also lists values in the quantum range. When colors are presented or converted to hue-based colorspaces, the values listed will be integers for hue and percents for the other two components. For other colorspaces, values may be listed as either percents or fractional value. Setting the depth to 8 will limit values to the 8-bit range, except for hue-based colors.

### Identify Defines

*   `identify:locate=minimum|maximum`

    Locate the coordinates of one or more image minimum or maximum.

*   `identify:limit=number`

    Locate the coordinates for the number of minima or maxima specified.


/FX Special Effects Image Operator
==================================

[The FX Special Effects Image Operator] • [The Anatomy of an FX Expression]

The [FX special effects image operator](http://im.snibgo.com/fxnew.htm) applies a mathematical expression to each pixel channel of an image. The FX expression language provides a powerful and flexible way to manipulate images, allowing you to perform a wide range of operations and transformations on your images. Use FX to:

*   create canvases, gradients, mathematical colormaps
*   move color values between images and channels
*   translate, flip, mirror, rotate, scale, shear and generally distort images
*   merge or composite multiple images together
*   convolve or merge neighboring pixels together
*   generate image metrics or 'fingerprints'

The operator loops through all the pixels of an image and all the channels of each pixel and returns a new image with the results. The expression can reference any image in the image sequence, but only a copy of the first image is returned with suitable updates per your expression.

The expression can be simple:

magick -size 64x64 canvas:black -channel blue -fx "1/2" fx_navy.png

Here, we convert a black to a navy blue image:

![black](https://imagemagick.org/image/black.png) ![==>](https://imagemagick.org/image/right.gif) ![navy](https://imagemagick.org/image/navy.png)

Or the expression can be complex:

magick rose: \
  -fx "(1.0/(1.0+exp(10.0*(0.5-u)))-0.006693)*1.0092503" \
  rose-sigmoidal.png

This expression results in a high contrast version of the source image:

![rose](https://imagemagick.org/image/rose.jpg) ![==>](https://imagemagick.org/image/right.gif) ![rose-sigmoidal](https://imagemagick.org/image/rose-sigmoidal.png)

The expression can include variable assignments. Assignments, in most cases, reduce the complexity of an expression and permit some operations that might not be possible any other way. For example, lets create a radial gradient:

magick -size 70x70 canvas: \
  -fx "Xi=i-w/2; Yj=j-h/2; 1.2*(0.5-hypot(Xi,Yj)/70.0)+0.5" \
  radial-gradient.png

The command above returns this image:

![radial-gradient](https://imagemagick.org/image/radial-gradient.png)

This FX expression adds random noise to an image:

magick photo.jpg -fx 'iso=32; rone=rand(); rtwo=rand(); \
  myn=sqrt(-2*ln(rone))*cos(2*Pi*rtwo); myntwo=sqrt(-2*ln(rtwo))* \
  cos(2*Pi*rone); pnoise=sqrt(p)*myn*sqrt(iso)* \
  channel(4.28,3.86,6.68)/255; max(0,p+pnoise)' noisy.png

This FX script utilizes a loop to create a [Julia set](https://en.wikipedia.org/wiki/Julia_set):

magick -size 400x400 xc:gray -fx " \
  Xi=2.4*i/w-1.2; \
  Yj=2.4*j/h-1.2; \
  for (pixel=0.0, (hypot(Xi,Yj) < 2.0) && (pixel < 1.0), \
    delta=Xi^2-Yj^2; \
    Yj=2.0*Xi*Yj+0.2; \
    Xi=delta+0.4; \
    pixel+=0.00390625 \
  ); \
  pixel == 1.0 ? 0.0 : pixel" \
  ( -size 1x1 xc:white xc:red xc:orange xc:yellow xc:green1 xc:cyan xc:blue \
     xc:blueviolet xc:white -reverse +append -filter Cubic -resize 1024x1! ) \
  -clut -rotate -90 julia-set.png

![Julia Fractals](https://imagemagick.org/image/julia-set.png)

This FX script prints the first 10 prime numbers:

magick xc:gray -fx " \
  for (prime=2, prime < 30, composite=0; \
    for (nn=2, nn < (prime/2+1), if ((prime % nn) == 0, composite++, ); nn++); \
      if (composite <= 0, debug(prime), ); prime++)" null:

See [Using FX, The Special Effects Image Operator] for more examples.

The -fx option replaces any image sequence with a clone of the first image updated with the results of the expression. If you prefer to apply the expression to each image in the sequence, use +fx instead.

The FX expression is interpretted in a single-thread, however, it is executed in multiple threads unless the expression includes the `debug()` function.

The next section discusses the FX expression language.

The Anatomy of an FX Expression
-------------------------------

#### The FX Expression Language

The formal FX expression language is defined here:

numbers:

integer, floating point, scientific notation (+/- required, e.g. 3.81469e-06), International System number postfixes (.e.g KB, Mib, GB, etc.)

constants:

E (Euler's number), Epsilon, Opaque, Phi (golden ratio), Pi, QuantumRange, QuantumScale, Transparent

FX operators (in order of precedence):

^ (power), unary -, *, /, % (modulo), +, -, <<, >>, <, <=, >, >=, +=, -=, *=, /=, %=, <<= , >>=, &=, |=, ++, --, ==, !=, & (bitwise AND), | (bitwise OR), && (logical AND), || (logical OR), ~ (logical NOT), ?: (ternary conditional)

array:

an image offers array storage (e.g. p[-1,-1].r) bounded by its width and height. An image sequence represents multiple arrays (e.g. u.p[0,0].r, v.p[0,0].r). Storage is limited to Quantum values, e.g. [0..65535] for Q16 builds and floating point for HDRI-enabled builds.

math functions:

abs(), acos(), acosh(), airy(), alt(), asin(), asinh(), atan(), atanh(), atan2(), ceil(), clamp(), cos(), cosh(), debug(), drc(), erf(), exp(), floor(), gauss(), gcd(), hypot(), int(), isnan(), j0(), j1(), jinc(), ln(), log(), logtwo(), max(), min(), mod(), not(), pow(), rand(), round(), sign(), sin(), sinc(), sinh(), sqrt(), squish(), tan(), tanh(), trunc()

channel functions:

define up to 5 pixel channels

color names:

red, cyan, black, etc.

color functions:

srgb(), srgba(), rgb(), rgba(), cmyk(), cmyka(), hsl(), hsla(), etc.

color hex values:

#ccc, #cbfed0, #b9e1cc00, etc.

symbols:

u: first image in list

v: second image in list

s: current image in list (for %[fx:] otherwise = u)

t: index of current image (s) in list

n: number of images in list

i: column offset

j: row offset

p: pixel to use (absolute or relative to current pixel)

w: width of this image

h: height of this image

z: channel depth

r: red value (from RGBA), of a specific or current pixel

g: green

b: blue

a: alpha

o: opacity

c: cyan value of CMYK color of pixel

y: yellow

m: magenta

k: black

all: all channels

this: this channel

intensity: pixel intensity

hue: pixel hue

saturation: pixel saturation

lightness: pixel lightness

luma: pixel luma

page.width: page width

page.height: page height

page.x: page x offset

page.y: page y offset

printsize.x: x printsize

printsize.y: y printsize

resolution.x: x resolution

resolution.y: y resolution

depth: image depth

extent: image extent

minima: image minima

maxima: image maxima

mean: image mean

median: image median

standard_deviation: image standard deviation

kurtosis: image kurtosis

skewness: image skewness (add a channel specifier to compute a statistic for that channel, e.g. depth.r)

iterators:

do(), for(), while()

image attributes:

s.depth, s.kurtosis, s.maxima, s.mean, s.minima, s.resolution.x, s.resolution.y, s.skewness, s.standard_deviation

user settings:

define Fx symbols as user settings, e.g.

magick ... -set option:wd1 "%[fx:w/2]" -resize "%[fx:wd1-5]" ...

#### The FX Expression

An FX expression may include any combination of the following:

x ^ y

exponentiation (xy)

( ... )

grouping

x * y

multiplication

x / y

division

x % y

modulo

x + y

addition

x - y

subtraction

x << y

left shift

x \>> y

right shift

x < y

boolean relation, return value 1.0 if x < y, otherwise 0.0

x <= y

boolean relation, return value 1.0 if x <= y, otherwise 0.0

x > y

boolean relation, return value 1.0 if x > y, otherwise 0.0

x \>= y

boolean relation, return value 1.0 if x >= y, otherwise 0.0

x \== y

boolean relation, return value 1.0 if x \== y, otherwise 0.0

x != y

boolean relation, return value 1.0 if x != y, otherwise 0.0

x & y

binary AND

x | y

binary OR

x && y

logical AND connective, return value 1.0 if x > 0 and y > 0, otherwise 0.0

x || y

logical OR connective (inclusive), return value 1.0 if x > 0 or y > 0 (or both), otherwise 0.0

~x

logical NOT operator, return value 1.0 if not x > 0, otherwise 0.0

+x

unary plus, return 1.0*value

-x

unary minus, return -1.0*value

condition ? true-statements : false-statements

ternary conditional expression, return value true-statements if condition != 0, otherwise false-statements

x \= y

assignment; single character variables are reserved, instead use 2 or more characters, letter combinations only (e.g. Xi not X1)

x ; y

statement separator

phi

constant (1.618034...)

pi

constant (3.14159265359...)

e

constant (2.71828...)

QuantumRange

constant maximum pixel value (255 for Q8, 65535 for Q16)

QuantumScale

constant 1.0/QuantumRange

intensity

pixel intensity whose value respects the [-intensity] option.

hue

pixel hue

saturation

pixel saturation

lightness

pixel lightness; equivalent to 0.5*max(red,green,blue) + 0.5*min(red,green,blue)

luminance

pixel luminance; equivalent to 0.212656*red + 0.715158*green + 0.072186*blue

red, green, blue, etc.

color names

#ccc, #cbfed0, #b9e1cc00, etc.

color hex values

rgb(), rgba(), cmyk(), cmyka(), hsl(), hsla()

color functions

s, t, u, v, n, i, j, w, h, z, r, g, b, a, o, c, y, m, k

symbols

abs(x)

absolute value function

acos(x)

arc cosine function

acosh(x)

inverse hyperbolic cosine function

airy(x)

Airy function (max=1, min=0); airy(x)=[jinc(x)]2\=[2*j1(pi*x)/(pi*x)]2

alt(x)

sign alternation function (return 1.0 if int(x) is even, -1.0 if int(x) is odd)

asin(x)

arc sine function

asinh(x)

inverse hyperbolic sine function

atan(x)

arc tangent function

atanh(x)

inverse hyperbolic tangent function

atan2(y,x)

arc tangent function of two variables

ceil(x)

smallest integral value not less than argument

channel(...)

supports from zero to five arguments, e.g., channel(0.1) sets the first channel to 0.1 and zero's the other channels.

clamp(x)

clamp value

cos(x)

cosine function

cosh(x)

hyperbolic cosine function

debug(x)

print x (useful for debugging your expression)

do(statements, condition)

iterate while the condition is not equal to 0

drc(x,y)

dynamic range compression (knee curve); drc(x,y)=(x)/(y*(x-1)+1); -1<y<1

erf(x)

error function

exp(x)

natural exponential function (ex)

floor(x)

largest integral value not greater than argument

for(initialize, condition, statements)

iterate while the condition is not equal to 0

gauss(x)

gaussian function; gauss(x)=exp(-x*x/2)/sqrt(2*pi)

gcd(x,y)

greatest common denominator

hypot(x,y)

the square root of x2+y2

if(condition, nonzero-statements, zero-statements)

interpret expression depending on condition

int(x)

greatest integer function (return greatest integer less than or equal to x)

isnan(x)

return 1.0 if x is NAN, 0.0 otherwise

j0(x)

Bessel functions of x of the first kind of order 0

j1(x)

Bessel functions of x of the first kind of order 1

jinc(x)

jinc function (max=1, min=-0.1323); jinc(x)=2*j1(pi*x)/(pi**x)

ln(x)

natural logarithm function

log(x)

logarithm base 10

logtwo(x)

logarithm base 2

ln(x)

natural logarithm

max(x, y)

maximum of x and y

min(x, y)

minimum of x and y

mod(x, y)

floating-point remainder function

not(x)

return 1.0 if x is zero, 0.0 otherwise

pow(x,y)

power function (xy)

rand()

value uniformly distributed over the interval [0.0, 1.0) with a 2 to the 128th-1 period

round()

round to integral value, regardless of rounding direction

sign(x)

return -1.0 if x is less than 0.0 otherwise 1.0

sin(x)

sine function

sinc(x)

sinc function (max=1, min=-0.21); sinc(x)=sin(pi*x)/(pi*x)

squish(x)

squish function; squish(x)=1.0/(1.0+exp(-x))

sinh(x)

hyperbolic sine function

sqrt(x)

square root function

tan(x)

tangent function

tanh(x)

hyperbolic tangent function

trunc(x)

round to integer, towards zero

while(condition, statements)

iterate while the condition is not equal to 0

image.depth, image.kurtosis, image.maxima, image.mean, image.median, image.minima, image.resolution.x, image.resolution.y, image.skewness, image.standard_deviation

image attributes

The expression semantics include these rules:

*   symbols are case insensitive
*   only one ternary conditional (e.g. x ? y : z) per statement
*   statements are assignments or the final expression to return
*   an assignment starts a statement, it is not an operator
*   single character variables are reserved. Assignments to reserved built-ins throw an exception; e.g. r=3.0; r returns _Attempted assignment to non-UserSymbol 'r' at '3.0'_.
*   unary operators have a lower priority than binary operators, that is, the unary minus (negation) has lower precedence than exponentiation, so -3^2 is interpreted as -(3^2) = -9. Use parentheses to clarify your intent (e.g. (-3)^2 = 9).
*   care must be exercised when using the slash ('/') symbol. The string of characters 1/2x is interpreted as (1/2)x. The contrary interpretation should be written explicitly as 1/(2x). Again, the use of parentheses helps clarify the meaning and should be used whenever there is any chance of misinterpretation.

  

#### Source Images

The symbols u and v refer to the first and second images, respectively, in the current image sequence. Refer to a particular image in a sequence by appending its index to any image reference (usually u), with a zero index for the beginning of the sequence. A negative index counts from the end. For example, u[0] is the first image in the sequence, u[2] is the third, u[-1] is the last image, and u[t] is the current image. The current image can also be referenced by s. If the sequence number exceeds the length of the sequence, the count is wrapped. Thus in a 3-image sequence, u[-1], u[2], and u[5] all refer to the same (third) image.

As an example, we form an image by averaging the first image and third images (the second (index 1) image is ignored and just junked):

magick image1.jpg image2.jpg image3.jpg -fx "(u+u[2])/2" image.jpg

By default, the image to which p, r, g, b, a, etc., are applied is the current image s in the image list. This is equivalent to u except when used in an escape sequence %[fx:...].

It is important to note the special role played by the first image. This is the only image in the image sequence that is modified, other images are used only for their data. As an illustrative example, consider the following, and note that the setting [-channel red] instructs [-fx] to modify only the green channel; nothing in the red or blue channels will change. It is instructive to ponder why the result is not symmetric.

magick logo: -flop logo: -resize "20%" -channel green -fx "(u+v)/2" image.jpg

![logo-sm-flop.png](https://imagemagick.org/image/logo-sm-flop.png) ![logo-sm.png](https://imagemagick.org/image/logo-sm.png) ![==>](https://imagemagick.org/image/right.gif) ![logo-sm-fx.png](https://imagemagick.org/image/logo-sm-fx.png)

  

#### Accessing Pixels

All color values are normalized to the range of 0.0 to 1.0. The alpha channel ranges from 0.0 (fully transparent) to 1.0 (fully opaque).

The pixels are processed one at a time, but a different pixel of an image can be specified using a pixel index represented by p. For example,

p[-1].g      green value of pixel to the immediate left of the current pixel
p[-1,-1].r   red value of the pixel diagonally left and up from current pixel

To specify an absolute position, use braces, rather than brackets.

p{0,0}.r     red value of the pixel in the upper left corner of the image
p{12,34}.b   blue pixel value at column number 12, row 34 of the image

Integer values of the position retrieve the color of the pixel referenced, while non-integer position values return a blended color according to the current [-interpolate] setting.

A position outside the boundary of the image retrieves a value dictated by the [-virtual-pixel] option setting.

Specify u.r to specify the red channel of the current image. If you don't specify a channel qualifier, you get the current channel. Use mean.this to set the output channel to the mean of just the input channel. Use mean.all to set the overall mean of the input channels.

#### Apply an Expression to Select Image Channels

Use the [-channel] setting to specify the output channel of the result. If no output channel is given, the result is set over all channels except the opacity channel. For example, to replace the red channel of alpha.png with the average of the green channels from the images alpha.png and beta.png, use:

magick alpha.png beta.png -channel red -fx "(u.g+v.g)/2" gamma.png

#### Results

The [-fx] operator evaluates the given expression for each channel (set by [-channel]) of each pixel in the first image (u) in the sequence. The computed values are temporarily stored in a copy (clone) of that first image until all the pixels have been processed, after which this single new image replaces the list of images in the current image sequence. As such, in the previous example the updated version of alpha.png replaces both of the original images, alpha.png and beta.png, before being saved as gamma.png.

The current image s is set to the first image in the sequence (u), and t to its index, 0. The symbols i and j reference the current pixel being processed.

For use with [-format], the value-escape %[fx:] is evaluated just once for each image in the current image sequence. As each image in the sequence is being evaluated, s and t successively refer to the current image and its index, while i and j are set to zero, and the current channel set to red ([-channel] is ignored). An example:

$ magick canvas:'rgb(25%,50%,75%)' rose: -colorspace gray  \
  -format 'Red channel of NW corner of image #%[fx:t] is %[fx:s]\n' info:
Red channel of NW corner of image #0 is 0.464883
Red channel of NW corner of image #1 is 0.184582

Here we use the image indexes to rotate each image differently, and use -set with the image index to set a different pause delay on the first image in the animation:

magick rose: -duplicate 29 -virtual-pixel Gray -distort SRT '%[fx:360.0*t/n]' \
  -set delay '%[fx:t == 0 ? 240 : 10]' -loop 0 rose.gif

This example tests the difference between two images, measured by RMSE. If the difference is greater than 0.1 it returns 1; otherwise it returns 0:

magick water.png reference.png -metric RMSE -compare -format "%[fx:%[distortion]>0.1]" info:

The color-escape %[pixel:] or %[hex:] is evaluated once per image and per color channel in that image ([-channel] is ignored), The values generated are then converted into a color string (a named color or hex color value). The symbols i and j are set to zero, and s and t refer to each successively current image and index.


/Create a Gradual Blend of Two Colors
=====================================

An image gradient creates a gradual blend between two colors formed into a shape that is linear, circular, or ellipical.

For a linear gradient, the operator is either:

gradient:
gradient:_fromColor_
gradient:_fromColor_-_toColor_

The default _fromcolor_ is white and the _toColor_ is black unless overridden, e.g., gradient:gray returns a gradient from gray to black.

The for a radial gradient, the operator is either:

radial-gradient:
radial-gradient:_fromColor_-_toColor_ 

The default for a linear gradient has _fromColor_ at the top of the image and _toColor_ at the bottom of the image. Similarly, the default for a radial gradient has _fromColor_ at the center of the image and _toColor_ at the boundary of the image.

Gradient colors may be any valid color defined per [../www/color.html]. The named colors of black/white/grayXX and gray(XX[%]) are non-linear gray. For Linux systems, enclose rgb(a) and hex colors in quotes. Use double quotes, if using variables for the values.

Here is an example linear (as opposed to radial) gradient:

magick -size 256x256 gradient: linear_gradient.png
magick -size 256x256 gradient:white-black linear_gradient.png

![](https://imagemagick.org/image/gradients/linear_gradient.png)

If you want a radial gradient, try:

magick -size 256x256 radial-gradient: radial_gradient.png
magick -size 256x256 radial-gradient:white-black radial_gradient.png 

![](https://imagemagick.org/image/gradients/radial_gradient.png)

If you want non-linear grayscale gradients, then add -colorspace RGB -colorspace gray before saving the output. For example:

magick -size 256x256 gradient: linear_gradient.png
magick -size 256x256 gradient:white-black -colorspace RGB -colorspace gray linear_linear_gradient.png 

magick -size 256x256 radial-gradient: radial_gradient.png
magick -size 256x256 radial-gradient:white-black -colorspace RGB -colorspace gray linea_radial_gradient.png 

Gradients are affected by these defines:

-define gradient:vector=x1,y1, x2,y2

Specifies the direction of the linear gradient going from vector1 (x1,y1) to vector2 (x2,y2). _fromColor_ is located at vector position x1,y1 and _toColor_ is located at vector position x2,y2.

-define gradient:center=x,y

Specifies the coordinates of the center point for the radial gradient. The default is the center of the image.

-define gradient:radii=x,y

Specifies the x and y radii of the gradient. If the x radius and the y radius are equal, the shape of the radial gradient will be a circle. If they differ, then the shape will be an ellipse. The default values are the maximum of the half width and half height of the image.

-define gradient:angle=angle in degrees

For a linear gradient, this specifies the direction of the gradient going from _fromColor_ to _toColor_ in a clockwise positive manner relative to north (up). For a radial gradient, this specifies the rotation of the gradient in a clockwise positive manner from its normal X-Y orientation.

-define gradient:bounding-box=widthxheight+x+y

Limits the gradient to a larger or smaller region than the image dimensions. If the region defined by the bounding box is smaller than the image, _fromColor_ is the color of the background.

We also support two convenience defines for setting the linear gradient direction and the radial gradient shape.

-define gradient:direction=_{NorthWest, North, Northeast, West, East, SouthWest, South, SouthEast}_

Specifies the direction of the linear gradient towards the top/bottom/left/right or diagonal corners.

-define gradient:extent=_{Circle, Diagonal, Ellipse, Maximum, Minimum}_

Specifies the shape of an image centered radial gradient. Circle and Maximum draw a circular radial gradient even for rectangular shaped images of radius equal to the larger of the half-width and half-height of the image. The Circle and Maximum options are both equivalent to the default radial gradient. The Minimum option draws a circular radial gradient even for rectangular shaped images of radius equal to the smaller of the half-width and half-height of the image. The Diagonal option draws a circular radial gradient even for rectangular shaped images of radius equal to the half-diagonal of the image. The Ellipse options draws an elliptical radial gradient for rectangular shaped images of radii equal to half the width and half the height of the image.

Examples

The default linear gradient may also be generated in any of the following ways (or by reversing the direction and swapping _fromColor_ and _toColor_):

magick -size 256x128 -define gradient:direction=north gradient:black-white linear_gradient_default.png
magick -size 256x128 -define gradient:angle=0 gradient:black-white linear_gradient_default.png 

![](https://imagemagick.org/image/gradients/linear_gradient_default.png)

The equivalent of

magick -size 128x256 gradient: -rotate 90 linear_gradient_east.png 

can be generate by either of the following (or by reversing the direction and swapping _fromColor_ and _toColor_):

magick -size 256x128 -define gradient:direction=east gradient:black-white linear_gradient_east.png
magick -size 256x128 -define gradient:angle=90 gradient:black-white linear_gradient_east.png 

![](https://imagemagick.org/image/gradients/linear_gradient_east.png)

Examples of radial gradients going from black in the center to white at the boundary for the cases of "maximum/circle/default", "minimum", "diagonal", "ellipse" and 45 degree rotated ellipse, respectively, follow below.

magick -size 256x128 radial-gradient:black-white radial_gradient_maximum.png
magick -size 256x128 -define gradient:radii=128,128 radial-gradient:black-white radial_gradient_maximum.png 

![](https://imagemagick.org/image/gradients/radial_gradient_maximum.png)

magick -size 256x128 -define gradient:extent=minimum radial-gradient:black-white radial_gradient_minimum.png
magick -size 256x128 -define gradient:radii=64,64 radial-gradient:black-white radial_gradient_minimum.png 

![](https://imagemagick.org/image/gradients/radial_gradient_minimum.png)

magick -size 256x128 -define gradient:extent=diagonal radial-gradient:black-white radial_gradient_diagonal.png 

![](https://imagemagick.org/image/gradients/radial_gradient_diagonal.png)

magick -size 256x128 -define gradient:extent=ellipse radial-gradient:black-white radial_gradient_ellipse.png
magick -size 256x128 -define gradient:radii=128,64 radial-gradient:black-white radial_gradient_ellipse.png 

![](https://imagemagick.org/image/gradients/radial_gradient_ellipse.png)

magick -size 256x256 -define gradient:radii=128,64 -define gradient:angle=45 radial-gradient:black-white radial_gradient_ellipse_angle45.png 

![](https://imagemagick.org/image/gradients/radial_gradient_ellipse_angle45.png)



/Image Formats
==============

[A Word about Colorspaces] • [Supported Formats] • [Pseudo Formats] • [Built-in Images] • [Built-in Patterns] • [Embedded Profiles]

ImageMagick uses an ASCII string known as magick (e.g. GIF) to identify file formats, algorithms acting as formats, built-in patterns, and embedded profile types. Support for some of the formats are delegated to libraries or external programs. The Installation Guide describes where to find these distributions and any special configuration options required.

To get a complete listing of which image formats are supported on your system, type

    magick identify -list format 

On some platforms, ImageMagick automagically processes these extensions: .gz for Zip compression, .Z for Linux compression, .bz2 for block compression, and .pgp for PGP encryption. For example, a PNM image called image.pnm.gz is automagically uncompressed.

A Word about Colorspaces
------------------------

A majority of the image formats assume an sRGB colorspace (e.g. JPEG, PNG, etc.). A few support only linear RGB (e.g. EXR, DPX, CIN, HDR) or only linear GRAY (e.g. PGM). A few formats support CMYK. Then there is the occasional format that also supports LAB (that is CieLAB) (e.g. TIFF, PSD, JPG, JP2). To determine the colorspace of your image, use this command:

    $ magick identify -verbose image.jpg
    Image: image.jpg
    Format: JPEG (Joint Photographic Experts Group JFIF format)
    ...
    Colorspace: sRGB 

OR use the appropriate percent escape

    $ magick image.jpg -print "%[colorspace]\n" null:
    sRGB 

When processing an image, be aware of the colorspace. Many image processing algorithms assume a linear RGB colorspace. Although you may get satisfactory results processing in the sRGB colorspace, you may get improved results in linear RGB (essentially sRGB with the gamma function removed). For example,

    magick image.jpg -colorspace RGB -resize 50% -colorspace sRGB resize.jpg 

As of IM 6.7.8-2 one can properly work in LAB colorspace whether or not Imagemagick is [HDRI]-enabled. Essentially the A and B channels are stored with a 50% gray bias, to allow it to handle the negatives required by the format.

    magick lab.tif -resize 50% resize.jpg 

Again, it may not make sense for some image processing operators to work directly in LAB space, but ImageMagick permits it and generally returns reasonable results.

Supported Image Formats
-----------------------

ImageMagick supports reading over 100 major file formats (not including sub-formats). The following table provides a summary of the supported image formats.

Tag Mode Description Notes

*   AAI: RW ==> AAI Dune image

*   [APNG](https://en.wikipedia.org/wiki/APNG): RW ==> Animated Portable Network Graphics

    Note, you must use an explicit image format specifier to read an APNG (apng:myImage.apng) image sequence, otherwise it assumes a PNG image and only reads the first frame.

*   ART: RW ==> PFS: 1st Publisher

    Format originally used on the Macintosh (MacPaint?) and later used for PFS: 1st Publisher clip art.

*   ARW: R ==> Sony Digital Camera Alpha Raw Image Format

    Set -define dng:use-camera-wb=true to use the RAW-embedded color profile for Sony cameras. You can also set these options: use-auto-wb, use-auto-bright, and output-color.

*   [AVI](http://www.jmcgowan.com/avi.html): R ==> Microsoft Audio/Visual Interleaved

*   [AVIF](https://en.wikipedia.org/wiki/AV1#AV1_Image_File_Format_(AVIF)): 
    RW ==> Format derived from the keyframes of AV1 video

*   AVS: RW ==> AVS X image

*   BAYER: RW ==> Raw mosaiced samples

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision. For signed pixel data, use -define quantum:format=signed.

*   [BPG](http://bellard.org/bpg/): RW ==> Better Portable Graphics

    Use [-quality] to specify the image compression quality. To meet the requirements of BPG, the quality argument divided by 2 (e.g. -quality 92 assigns 46 as the BPG compression.

*   [BMP, BMP2, BMP3](http://www.fileformat.info/format/bmp/egff.htm): 
    RW ==> Microsoft Windows bitmap

    By default the BMP format is version 4. Use BMP3 and BMP2 to write versions 3 and 2 respectively. Use -define bmp:ignore-filesize to ignore the filesize check.

*   [BRF](http://en.wikipedia.org/wiki/Braille_ASCII): W ==> Braille Ready Format

    Uses juxtaposition of 6-dot braille patterns (thus 6x2 dot matrices) to reproduce images, using the BRF ASCII Braille encoding.

*   [CALS](http://www.fileformat.info/format/cals/egff.htm): 
    R ==> Continuous Acquisition and Life-cycle Support Type 1 image

    Specified in MIL-R-28002 and MIL-PRF-28002. Standard blueprint archive format as used by the US military to replace microfiche.

*   [CIN](http://www.cineon.com/ff_draft.html): RW ==> Kodak Cineon Image Format

    Use [-set] to specify the image gamma or black and white points (e.g. -set gamma 1.7, -set reference-black 95, -set reference-white 685). Properties include cin:file.create_date, cin:file.create_time, cin:file.filename, cin:file.version, cin:film.count, cin:film.format, cin:film.frame_id, cin:film.frame_position, cin:film.frame_rate, cin:film.id, cin:film.offset, cin:film.prefix, cin:film.slate_info, cin:film.type, cin:image.label, cin:origination.create_date, cin:origination.create_time, cin:origination.device, cin:origination.filename, cin:origination.model, cin:origination.serial, cin:origination.x_offset, cin:origination.x_pitch, cin:origination.y_offset, cin:origination.y_pitch, cin:user.data.

*   CIP: W ==> Cisco IP phone image format

*   CMYK: RW ==> Raw cyan, magenta, yellow, and black samples 

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision.

*   CMYKA: RW ==>  Raw cyan, magenta, yellow, black, and alpha samples

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision.

*   CR2: R ==> Canon Digital Camera Raw Image Format

    Requires an explicit image format otherwise the image is interpreted as a TIFF image (e.g. cr2:image.cr2).

*   CRW: R ==> Canon Digital Camera Raw Image Format

*   [CUBE](https://wwwimages2.adobe.com/content/dam/acom/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf): 
    R ==> Cube Color lookup table converted to a HALD image

    Select levels like this: cube:Vibrant.cube[8] for level 8

*   CUR: R ==> Microsoft Cursor Icon
*   CUT: R ==> DR Halo
*   DCM: R ==> Digital Imaging and Communications in Medicine (DICOM) image

    Used by the medical community for images like X-rays. ImageMagick sets the initial display range based on the Window Center (0028,1050) and Window Width (0028,1051) tags. Use [-define dcm:display-range=reset] to set the display range to the minimum and maximum pixel values. Use [-define dcm:rescale=true] to enable interpretation of the rescale slope and intercept settings in the file. Use [-define dcm:window=centerXwidth] to override the center and width settings in the file with your own values.

*   DCR: R ==> Kodak Digital Camera Raw Image File

*   DCX: RW ==> ZSoft IBM PC multi-page Paintbrush image

*   [DDS](http://en.wikipedia.org/wiki/DirectDraw_Surface): 
    RW ==> Microsoft Direct Draw Surface

    Use [-define] to specify the compression (e.g. -define dds:compression={dxt1, dxt5, none}). Other defines include dds:cluster-fit={true,false}, dds:weight-by-alpha={true,false}, dds:fast-mipmaps={true,false}, and use dds:mipmaps to set the number of mipmaps (use fromlist to use the image list).

*   DEBUG: W ==> Raw pixel debug file, likely only useful to the developers 
*   DIB: RW ==> Microsoft Windows Device Independent Bitmap

    DIB is a [BMP] file without the [BMP] header. Used to support embedded images in compound formats like WMF.

*   [DJVU](http://www.djvu.org/)

*   [DNG](http://www.adobe.com/products/dng/main.html): 
    R ==> Digital Negative: Requires an explicit image format otherwise the image is interpreted as a TIFF image (e.g. dng:image.dng). 

*   [DOT](http://www.graphviz.org): R ==> Graph Visualization

    Use [-define] to specify the layout engine (e.g. -define dot:layout-engine=twopi).

*   DPX: RW ==> SMPTE Digital Moving Picture Exchange 2.0 (SMPTE 268M-2003)

    Use [-set] to specify the image gamma or black and white points (e.g. -set gamma 1.7, -set reference-black 95, -set reference-white 685).

*   EMF: R ==> Microsoft Enhanced Metafile (32-bit)

    Only available under Microsoft Windows. Use [-size] command line option to specify the maximum width and height.

*   EPDF: RW ==> Encapsulated Portable Document Format

*   EPI: RW ==> Adobe Encapsulated PostScript Interchange format

    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. 

*   EPS: RW ==> Adobe Encapsulated PostScript

    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. 

*   EPS2: W ==> Adobe Level II Encapsulated PostScript: 
    
    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. 

*   EPS3: W ==> Adobe Level III Encapsulated PostScript
    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. 

*   EPSF: RW ==> Adobe Encapsulated PostScript: 
    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. 

*   EPSI: RW ==> Adobe Encapsulated PostScript Interchange format: 
    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. 

*   EPT: RW ==> Adobe Encapsulated PostScript Interchange format with [TIFF] preview
    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. 

*   EXR: RW ==> High dynamic-range (HDR) file format developed by Industrial Light & Magic

    See [High Dynamic-Range Images] for details on this image format. To specify the output color type, use -define exr:color-type={RGB,RGBA,YC,YCA,Y,YA,R,G,B,A}. Use [-sampling-factor] to specify the sampling rate for YC(A) (e.g. 2x2 or 4:2:0). Requires the [OpenEXR](http://www.openexr.org/) delegate library.

*   FARBFELD: RW ==> Farbfeld lossless image format

    sRGB 16-bit RGBA lossless image format

*   FAX: RW ==> Group 3 TIFF

    This format is a fixed width of 1728 as required by the standard. See [TIFF] format. Note that FAX machines use non-square pixels which are 1.5 times wider than they are tall but computer displays use square pixels so FAX images may appear to be narrow unless they are explicitly resized using a resize specification of 100x150%.

*   [FITS](http://www.cv.nrao.edu/fits/): RW ==> Flexible Image Transport System

    To specify a single-precision floating-point format, use -define quantum:format=floating-point. Set the depth to 64 for a double-precision floating-point format.

*   FL32: RW ==> FilmLight floating point image format

*   [FLIF](https://flif.info/): RW ==> Free Lossless Image Format

*   FPX: RW ==> FlashPix Format

    FlashPix has the option to store mega- and giga-pixel images at various resolutions in a single file which permits conservative bandwidth and fast reveal times when displayed within a Web browser. Requires the [FlashPix SDK](https://imagemagick.org/archive/delegates). Specify the FlashPix viewing parameters with the [-define fpx:view].

*   [FTXT](http://im.snibgo.com/fmttxt.htm): RW: Read and write multispectral channels as formatted text

*   [GIF](http://www.fileformat.info/format/gif/egff.htm): RW ==> CompuServe Graphics Interchange Format

    8-bit RGB PseudoColor with up to 256 palette entries. Specify the format GIF87 to write the older version 87a of the format. Use [-transparent-color] to specify the GIF transparent color (e.g. -transparent-color wheat).

*   PLT: R ==> Gnuplot plot files: Requires [gnuplot4.0.tar.Z](http://www.gnuplot.info/) or later. 

*   GRAY: RW: Raw gray samples 

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision. For signed pixel data, use -define quantum:format=signed.

*   GRAYA: RW: Raw gray and alpha samples 

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision.

*   [HDR](http://en.wikipedia.org/wiki/RGBE_image_format): RW: Radiance RGBE image format 

*   [HEIC](https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format): 
    RW ==> Apple High efficiency Image Format

    Set the quality to 100 to produce lossless HEIC images. Requires the [libheif](https://github.com/strukturag/libheif) delegate library. Recognized defines include heic:preserve-orientation={true,false}, depth-image={true,false}, heic:speed, and heic:chroma.

*   PGL: R ==> HP-GL plotter language: Requires 
    [hp2xx-3.4.4.tar.gz](http://ftp.gnu.org/gnu/hp2xx) 

*   HRZ: RW ==> Slow Scan TeleVision

*   HTML: RW ==> Hypertext Markup Language with a client-side image map

    Also known as HTM. Requires [html2ps](http://user.it.uu.se/%7Ejan/html2ps.html) to read. Note, the \\xff character is not permitted in any filename when exporting client-side image maps.

*   ICO: R ==> Microsoft icon

    Also known as ICON.

*   INFO: W ==> Format and characteristics of the image

*   [ISOBRL](https://www.iso.org/obp/ui/#iso:std:iso:tr:11548:-1): 
    W ==> ISO/TR 11548-1 BRaiLle

    Uses juxtaposition of 8-dot braille patterns (thus 8x2 dot matrices) to reproduce images, using the ISO/TR 11548-1 Braille encoding.

*   [ISOBRL6](https://www.iso.org/obp/ui/#iso:std:iso:tr:11548:-1): 
    W ==> ISO/TR 11548-1 BRaiLle 6 dots

    Uses juxtaposition of 6-dot braille patterns (thus 6x2 dot matrices) to reproduce images, using the ISO/TR 11548-1 Braille encoding.

*   JBIG: RW ==> Joint Bi-level Image experts Group file interchange format

    Also known as BIE and JBG. Requires [jbigkit-1.6.tar.gz](http://www.cl.cam.ac.uk/~mgk25/jbigkit/).

*   [JNG](http://www.libmng.com/): RW ==> Multiple-image Network Graphics

    JPEG in a PNG-style wrapper with transparency. Requires libjpeg and libpng-1.0.11 or later, [libpng-1.2.5](http://www.libpng.org/pub/png/libpng.html) or later recommended.

*   [JP2](http://www.openjpeg.org/): RW ==> JPEG-2000 JP2 File Format Syntax

    Specify the encoding options with the [-define] option. See [JP2 Encoding Options] for more details.

*   [JPT](http://www.openjpeg.org/): RW ==> JPEG-2000 Code Stream Syntax

    Specify the encoding options with the [-define] option See [JP2 Encoding Options] for more details.

*   [J2C](http://www.openjpeg.org/): RW ==> JPEG-2000 Code Stream Syntax

    Specify the encoding options with the [-define] option See [JP2 Encoding Options] for more details.

*   [J2K](http://www.openjpeg.org/): RW ==> JPEG-2000 Code Stream Syntax

    Specify the encoding options with the [-define] option See [JP2 Encoding Options] for more details.

*   [JPEG](http://www.jpeg.org/): RW ==> Joint Photographic Experts Group JFIF format

    Note, JPEG is a lossy compression. In addition, you cannot create black and white images with JPEG nor can you save transparency.  

    Requires [jpegsrc.v8c.tar.gz](http://www.ijg.org/files/). You can set quality scaling for luminance and chrominance separately (e.g. [-quality] 90,70). You can optionally define the DCT method, for example to specify the float method, use [-define jpeg:dct-method=float]. By default we compute optimal Huffman coding tables. Specify [-define jpeg:optimize-coding=false] to use the default Huffman tables. Specify [-define jpeg:arithmetic-coding=true] to enable Huffman optimization. 

    Two other options include [-define jpeg:block-smoothing] and [-define jpeg:fancy-upsampling]. Set the sampling factor with [-define jpeg:sampling-factor]. You can size the image with jpeg:size, for example [-define jpeg:size=128x128]. To restrict the maximum file size, use jpeg:extent, for example [-define jpeg:extent=400KB]. 

    To define one or more custom quantization tables, use [-define jpeg:q-table=_filename_]. These values are multiplied by [-quality] argument divided by 100.0. To avoid reading a particular associated image profile, use [-define profile:skip=_name_] (e.g. profile:skip=ICC). 

*   [JXR](https://en.wikipedia.org/wiki/JPEG_XR): RW ==> JPEG extended range

    Requires the [jxrlib](https://jxrlib.codeplex.com/) delegate library. Put the JxrDecApp and JxrEncApp applications in your execution path. 

*   [JSON](http://www.json.org): W ==> JavaScript Object Notation

    A lightweight data-interchange format

    Include additional attributes about the image with these defines: [-define json:locate], [-define json:limit], [-define json:moments], or [-define json:features]. Specify the JSON model schema version with [-define json:version]. The current version is 1.0. Any version less than 1.0, returns the original JSON output which included misspelled labels.

*   [JXL](https://jpeg.org/jpegxl): RW ==> JPEG XL image coding system

    Requires the [JPEG XL](https://gitlab.com/wg1/jpeg-xl.git) delegate library. Use -define jxl:effort=_integer_ to set the effort and -define jxl:decoding-speed=_integer_ to set the decoding speed. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats and 16 for half-precision. 

*   KERNEL: W ==> Morphology kernel format

    format suitable for a morphology kernel

*   MAN: R ==> Linux reference manual pages
    Requires that GNU groff and Ghostcript are installed.

*   MAT: R ==> MATLAB image format

*   MIFF: RW ==> Magick multispectral image file format

    This format persists all image attributes known to ImageMagick. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision.

*   MONO: RW ==> Bi-level bitmap in least-significant-byte first order

*   [MNG](http://www.libpng.org/pub/mng/): RW ==> Multiple-image Network Graphics

    A PNG-like Image Format Supporting Multiple Images, Animation and Transparent JPEG. Requires libpng-1.0.11 or later, [libpng-1.2.5](http://www.libpng.org/pub/png/libpng.html) or later recommended. An interframe delay of 0 generates one frame with each additional layer composited on top. For motion, be sure to specify a non-zero delay.

*   [M2V](http://www.ffmpeg.org/): RW ==> Motion Picture Experts Group file interchange format (version 2)

    Requires [ffmpeg](http://www.ffmpeg.org/download.html). 

*   [MPEG](http://www.ffmpeg.org/): RW ==> Motion Picture Experts Group file interchange format (version 1)

    Requires [ffmpeg](http://www.ffmpeg.org/download.html). 

*   MPC: RW ==> Magick Pixel Cache image file format

    The most efficient data processing pattern is a write-once, read-many-times pattern. The image is generated or copied from source, then various analyses are performed on the image pixels over time. MPC supports this pattern. MPC is the native in-memory ImageMagick uncompressed file format. This file format is identical to that used by ImageMagick to represent images in memory and is read by mapping the file directly into memory. The MPC format is not portable and is not suitable as an archive format. It is suitable as an intermediate format for high-performance image processing. The MPC format requires two files to support one image. Image attributes are written to a file with the extension .mpc, whereas, image pixels are written to a file with the extension .cache.

*   MPR: RW ==> Magick Persistent Registry

    This format permits you to write to and read images from memory. The filename is the registry key. The image persists until you explicity delete it or the program exits. For example, let's use the MPR to create a checkerboard:

        magick ( -size 15x15 canvas:black canvas:white -append ) \
          ( +clone -flip ) +append -write mpr:checkers +delete \
          -size 240x240 tile:mpr:checkers -delete registry:checkers board.png 

*   MRW: R ==> Sony (Minolta) Raw Image File

    Set -define dng:use-camera-wb=true to use the RAW-embedded color profile for Sony cameras.

*   MSL: RW ==> Magick Scripting Language

    MSL is the XML-based scripting language supported by the [conjure] utility. MSL requires the [libxml2](http://xmlsoft.org/) delegate library.

*   [MTV](http://www.fileformat.info/format/mtv/egff.htm): RW ==> MTV Raytracing image format

*   [MVG]: RW ==> Magick Vector Graphics.

    The native ImageMagick vector metafile format. A text file containing vector drawing commands accepted by [magick]'s [-draw] option.

*   NEF: R ==> Nikon Digital SLR Camera Raw Image File

*   ORF: R ==> Olympus Digital Camera Raw Image File

*   [ORA](https://www.freedesktop.org/wiki/Specifications/OpenRaster/): 
    R ==> open exchange format for layered raster based graphics

*   OTB: RW ==> On-the-air Bitmap

*   P7: RW ==> Xv's Visual Schnauzer thumbnail format

*   PALM: RW ==> Palm pixmap

*   [PAM](http://netpbm.sourceforge.net/doc/pam.html): 
    W ==> Common 2-dimensional bitmap format

*   CLIPBOARD: RW: Windows Clipboard ==> Only available under Microsoft Windows.

*   [PBM](http://netpbm.sourceforge.net/doc/pbm.html): 
    RW ==> Portable bitmap format (black and white)

*   PCD: RW ==> Photo CD

    The maximum resolution written is 768x512 pixels since larger images require huffman compression (which is not supported). Use [-bordercolor] to specify the border color (e.g. -bordercolor black).

*   PCDS: RW ==> Photo CD

    Decode with the sRGB color tables.

*   PCL: W ==> HP Page Control Language

    Use [-define] to specify fit to page option (e.g. -define pcl:fit-to-page=true).

*   [PCX](http://www.fileformat.info/format/pcx/egff.htm): RW ==> ZSoft IBM PC Paintbrush file

*   PDB: RW ==> Palm Database ImageViewer Format

*   PDF: RW ==> Portable Document Format

    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. By default, ImageMagick sets the page size to the MediaBox. Some PDF files, however, have a CropBox or TrimBox that is smaller than the MediaBox and may include white space, registration or cutting marks outside the CropBox or TrimBox. 

    To force ImageMagick to use the CropBox or TrimBox rather than the MediaBox, use [-define] (e.g. -define pdf:use-cropbox=true or -define pdf:use-trimbox=true). Use [-density] to improve the appearance of your PDF rendering (e.g. -density 300x300). 

    To specify direct conversion from Postscript to PDF, use -define delegate:bimodel=true. Use -define pdf:fit-page=true to scale to the page size. To immediately stop processing upon an error, set -define pdf:stop-on-error to true. To set the page direction preferences to right-to-left, try -define pdf:page-direction=right-to-left. 

    Use [-alpha remove] to remove transparency. When writing to a PDF, thumbnails are included by default. To skip generating thumbnails, -define pdf:thumbnail=false. To enable interpolation when rendering, use -define pdf:interpolate=true. 

*   PEF: R  => Pentax Electronic File

    Requires an explicit image format otherwise the image is interpreted as a TIFF image (e.g. pef:image.pef).

*   PES: R  => Embrid Embroidery Format

*   PFA: R  => Postscript Type 1 font (ASCII)

    Opening as file returns a preview image.

*   PFB: R  => Postscript Type 1 font (binary)

    Opening as file returns a preview image.

*   [PFM](http://netpbm.sourceforge.net/doc/pfm.html): 
    RW  => Portable float map format

*   [PGM](http://netpbm.sourceforge.net/doc/pgm.html): 
    RW  => Portable graymap format (gray scale)

*   [PHM](http://netpbm.sourceforge.net/doc/pfm.html): 
    RW  => Portable float map format 16-bit half

*   PICON: RW  => Personal Icon

*   PICT: RW  => Apple Macintosh QuickDraw/PICT file

*   PIX: R  => Alias/Wavefront RLE image format

*   [PNG](http://www.libpng.org/pub/png/): 
    RW  => Portable Network Graphics

    Requires libpng-1.0.11 or later, [libpng-1.2.5](http://www.libpng.org/pub/png/libpng.html) or later recommended. The PNG specification does not support pixels-per-inch units, only pixels-per-centimeter. To avoid reading a particular associated image profile, use [-define profile:skip=_name_] (e.g. profile:skip=ICC).

*   [PNG8](http://www.libpng.org/pub/png/): 
    RW  => Portable Network Graphics

    8-bit indexed with optional binary transparency

*   [PNG00](http://www.libpng.org/pub/png/): 
    RW  => Portable Network Graphics

    PNG inheriting subformat from original if possible

*   [PNG24](http://www.libpng.org/pub/png/): 
    RW  => Portable Network Graphics

    opaque or binary transparent 24-bit RGB

*   [PNG32](http://www.libpng.org/pub/png/): 
    RW  => Portable Network Graphics

    opaque or transparent 32-bit RGBA

*   [PNG48](http://www.libpng.org/pub/png/): 
    RW  => Portable Network Graphics

    opaque or binary transparent 48-bit RGB

*   [PNG64](http://www.libpng.org/pub/png/): 
    RW  => Portable Network Graphics

    opaque or transparent 64-bit RGB

*   [PNM](http://netpbm.sourceforge.net/doc/pnm.html): 
    RW  => Portable anymap

    PNM is a family of formats supporting portable bitmaps (PBM) , graymaps (PGM), and pixmaps (PPM). There is no file format associated with pnm itself. If PNM is used as the output format specifier, then ImageMagick automagically selects the most appropriate format to represent the image. The default is to write the binary version of the formats. Use [-compress none] to write the ASCII version of the formats.

*   POCKETMOD: RW  => Pocketmod personal organizer format

    Example usage: magick -density 300 pages?.pdf pocketmod:organize.pdf

*   [PPM](http://netpbm.sourceforge.net/doc/ppm.html): 
    RW  => Portable pixmap format (color)

*   PS: RW  => Adobe PostScript file

    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read. To force ImageMagick to respect the crop box, use [-define] (e.g. -define eps:use-cropbox=true). Use [-density] to improve the appearance of your Postscript rendering (e.g. -density 300x300). Use [-alpha remove] to remove transparency. To specify direct conversion from PDF to Postscript, use -define delegate:bimodel=true.

*   PS2: RW  => Adobe Level II PostScript file

    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read.

*   PS3: RW  => Adobe Level III PostScript file

    Requires [Ghostscript](https://www.ghostscript.com/download.html) to read.

*   [PSB](http://www.adobe.com/devnet-apps/photoshop/fileformatashtml/): 
    RW  => Adobe Large Document Format

*   [PSD](http://www.adobe.com/devnet-apps/photoshop/fileformatashtml/): 
    RW  => Adobe Photoshop multispectral bitmap file

    Use [-define psd:alpha-unblend=off] to disable alpha blenning in the merged image. Use [-define psd:additional-info=all|selective] to transfer additional information from the input PSD file to output PSD file. The 'selective' option will preserve all additional information that is not related to the geometry of the image. The 'all' option should only be used when the geometry of the image has not been changed. This option is helpful when transferring non-simple layers, such as adjustment layers from the input PSD file to the output PSD file. This define is available as of Imagemagick version 6.9.5-8. Use [-define psd:preserve-opacity-mask=true] to preserve the opacity mask of a layer and add it back to the layer when the image is saved.

*   PTIF: RW  => Pyramid encoded [TIFF]

    Multi-resolution [TIFF] containing successively smaller versions of the image down to the size of an icon.

*   [PWP](http://www.photoworks.com/): 
    R  => Seattle File Works multi-image file

*   [QOI](https://qoiformat.org/): 
    RW  => Quite OK Image Forma

    Fast, lossless image compression.

*   RAD: R  => Radiance image file

    Requires that _ra_ppm_ from the Radiance software package be installed.

*   RAF: R  => Fuji CCD-RAW Graphic File

*   RAW: RW  => Raw gray samples

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision. For signed pixel data, use -define quantum:format=signed.

*   RGB: RW  => Raw red, green, and blue samples

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision.

*   RGB565: R  => Raw red, green, blue pixels in the 5-6-5 format

    Use [-size] to specify the image width and height.

*   RGBA: RW  => Raw red, green, blue, and alpha samples

    Use [-size] and [-depth] to specify the image width, height, and depth. To specify a single precision floating-point format, use -define quantum:format=floating-point. Set the depth to 32 for single precision floats, 64 for double precision, and 16 for half-precision.

*   RGF: RW  => LEGO Mindstorms EV3 Robot Graphics File

*   RLA: R  => Alias/Wavefront image file

*   RLE: R  => Utah Run length encoded image file

*   [SCT](http://www.oreilly.com/www/centers/gff/formats/scitex/): 
    R  => Scitex Continuous Tone Picture

*   [SFW](http://www.photoworks.com/): 
    R  => Seattle File Works image

*   SGI: RW  => Irix RGB image

*   SHTML: W  => Hypertext Markup Language client-side image map

    Used to write HTML clickable image maps based on a the output of [montage] or a format which supports tiled images such as [MIFF].

*   SID, MrSID: R  => Multiresolution seamless image

    Requires the [mrsidgeodecode](http://www.lizardtech.com/downloads/downloads.html?dl=/download/files/lin/geoexpress_commandlineutils_linux.tgz) command line utility that decompresses MG2 or MG3 SID image files.

*   SPARSE-COLOR: W  => Raw text file

    Format compatible with the [-sparse-color] option. Lists only non-fully-transparent pixels.

*   STRIMG: RW  => String to images and back

*   SUN: RW  => SUN Rasterfile

*   [SVG](http://www.w3.org/Graphics/SVG): 
    RW  => Scalable Vector Graphics

    ImageMagick utilizes [inkscape](http://www.inkscape.org/) if its in your execution path otherwise [RSVG](http://developer.gnome.org/rsvg/). If neither are available, ImageMagick reverts to its internal SVG renderer. The default resolution is 96 DPI. Use [-size] command line option to specify the maximum width and height. If you want to render a very large SVG and you trust the source, enable this option: -define svg:xml-parse-huge=true.

*   TEXT: R  => text file

    Requires an explicit format specifier to read, e.g. text:README.txt.

*   TGA: RW  => Truevision Targa image

    Also known as formats ICB, VDA, and VST. Use -define tga:preserve-orientation=true to preserve the image orientation.

*   [TIFF](http://www.libtiff.org/): 
    RW  => Tagged image file multispectral format

    Also known as TIF. Requires [tiff-v3.6.1.tar.gz](http://www.libtiff.org/) or later. 

    Use [-define] to specify the rows per strip (e.g. -define tiff:rows-per-strip=8). To define the tile geometry, use for example, -define tiff:tile-geometry=128x128. To specify a signed format, use -define quantum:format=signed. 

    To specify a single-precision floating-point format, use -define quantum:format=floating-point. Set the depth to 64 for a double-precision floating-point format. Use -define quantum:polarity=min-is-black or -define quantum:polarity=min-is-white toggle the photometric interpretation for a bilevel image. Specify the extra samples as associated or unassociated alpha with, for example, -define tiff:alpha=unassociated. Set the fill order with -define tiff:fill-order=msb|lsb. 

    Set the TIFF endianness with -define tiff:endian=msb|lsb. Use -define tiff:exif-properties=false to skip reading the EXIF properties. 

    Use -define tiff:gps-properties=false to skip reading the GPS properties. 

    You can set a number of TIFF software attributes including document name, host computer, artist, timestamp, make, model, software, and copyright. For example, [-set tiff:software "My Company"]. If you want to ignore certain TIFF tags, use this option: -define tiff:ignore-tags=comma-separated-list-of-tag-IDs. 

    Since version 6.9.1-4 there is support for reading photoshop layers in TIFF files, this can be disabled with -define tiff:ignore-layers=true. To preserve compression of the source image, use: -define tiff:preserve-compression=true.

*   TIM: R  => PSX TIM file

*   [TTF](http://www.freetype.org/): 
    R  => TrueType font file

    Requires [freetype 2](http://www.freetype.org/). Opening as file returns a preview image. Use [-set] if you do not want to hint glyph outlines after their scaling to device pixels (e.g. -set type:hinting off).

*   TXT: RW  => Multispectral raw text file

    Use [-define] to specify the color compliance (e.g. -define txt:compliance=css).

*   [UBRL](http://www.unicode.org/charts/PDF/U2800.pdf): 
    W  => Unicode BRaiLle

    Uses juxtaposition of 8-dot braille patterns (thus 8x2 dot matrices) to reproduce images, using the Unicode Braille encoding.

*   [UBRL6](http://www.unicode.org/charts/PDF/U2800.pdf): 
    W  => Unicode BRaiLle 6 dots

    Uses juxtaposition of 6-dot braille patterns (thus 6x2 dot matrices) to reproduce images, using the Unicode Braille encoding.

*   UIL: W  => X-Motif UIL table

*   UYVY: RW  => Interleaved YUV raw image

    Use [-size] and [-depth] command line options to specify width and height. Use [-sampling-factor] to set the desired subsampling (e.g. -sampling-factor 4:2:2).

*   VICAR: RW  => VICAR rasterfile format

*   VIDEO: RW  => Various video formats such as APNG, AVI, MP4, WEBM, etc. 

    Refer to [defines] for a description of these defines: video:intermediate-format, video:pixel-format, and video:vsync defines, that can affect the operation on these video formats.

*   [VIFF](http://www.fileformat.info/format/viff/egff.htm): 
    RW  => Khoros Visualization Image File Format

*   [WBMP](http://www.openmobilealliance.org/Technical/wapindex.aspx): 
    RW  => Wireless bitmap

    Support for uncompressed monochrome only.

*   [WDP](https://en.wikipedia.org/wiki/JPEG_XR): 
    RW  => JPEG extended range

    Requires the [jxrlib](https://jxrlib.codeplex.com/) delegate library. Put the JxrDecApp and JxrEncApp applications in your execution path.

*   [WEBP](http://en.wikipedia.org/wiki/WebP): 
    RW  => Weppy image format

    Requires the [WEBP](https://developers.google.com/speed/webp/download) delegate library. Specify the encoding options with the [-define] option See [WebP Encoding Options] for more details.

*   [WMF](http://www.fileformat.info/format/wmf/egff.htm): 
    R  => Windows Metafile

    Requires [libwmf](http://sourceforge.net/projects/wvware/). By default, renders WMF files using the dimensions specified by the metafile header. Use the -density option to adjust the output resolution, and thereby adjust the output size. The default output resolution is 72DPI so -density 144 results in an image twice as large as the default. Use -background color to specify the WMF background color (default white) or -texture filename to specify a background texture image.

*   [WPG](http://www.fileformat.info/format/wpg/egff.htm): 
    R  => Word Perfect Graphics File

*   X: RW  => display or import an image to or from an X11 server

    Use [-define] to obtain the image from the root window (e.g. -define x:screen=true). Set x:silent=true to turn off the beep when importing an image.

*   [XBM](http://www.fileformat.info/format/xbm/egff.htm): 
    RW  => X Windows system bitmap, black and white only

    Used by the X Windows System to store monochrome icons.

*   XCF: R  => GIMP image

*   [XPM](http://www.fileformat.info/format/xpm/egff.htm): 
    RW  => X Windows system pixmap

    Also known as PM. Used by the X Windows System to store color icons.

*   [XWD](http://www.fileformat.info/format/xwd/egff.htm): 
    RW  => X Windows system window dump

    Used by the X Windows System to save/display screen dumps.

*   X3F: R  => Sigma Camera RAW Picture File

*   [YAML](https://yaml.org/): 
    W  => human-readable data-serialization language

    Include additional attributes about the image with these defines: [-define yaml:locate], [-define yaml:limit], [-define yaml:moments], or [-define yaml:features]. Specify the JSON model schema version with [-define yaml:version]. The current version is 1.0.

*   YCbCr: RW  => Raw Y, Cb, and Cr samples

    Use [-size] and [-depth] to specify the image width, height, and depth.

*   YCbCrA: RW  => Raw Y, Cb, Cr, and alpha samples

    Use [-size] and [-depth] to specify the image width, height, and depth.

*   YUV: RW  => CCIR 601 4:1:1

    Use [-size] and [-depth] command line options to specify width, height, and depth. Use [-sampling-factor] to set the desired subsampling (e.g. -sampling-factor 4:2:2).

      

Pseudo-image Formats
--------------------

ImageMagick supports a number of image format specifications which refer to images prepared via an algorithm, or input/output targets. The following table lists these pseudo-image formats:

Tag Mode Description Notes

*   **ASHLAR** : W -  Image sequence laid out in continuous irregular courses

    By default, a reasonable canvas size and border width is determined relative to the image collection you provide. You can explicitedly set the canvas size and border width by appending to the filename, e.g. ashlar:canvas.png[1024x768+4+4]. By default, alignment is along the left edge. Use -define ashlar:best-fit=true to align on both the left and right edges. You can label the image tiles with, for example, -label %f. By default, all image tiles are rendered on a single canvas. Use -define ashlar:tiles=50, for example, to render at most 50 tiles per canvas.

*   **CANVAS** : R -  Canvas image of specified color

    Useful to create solid color canvas images. Use [-size] and [-depth] to specify the image width, height, and depth. Example canvas color specifications include canvas:red and canvas:#FF0000.  
    If no color is specified a 'white' canvas image is generated. If no [-size] is specified a single pixel image of the specified color is generated.

*   **CAPTION** : R -  Image caption

    Use -define caption:split=true to split text if required to fit caption on the canvas

*   **CLIP** : RW -  Clip path of image

*   **CLIPBOARD** : RW -  Windows Clipboard

    Only available under Microsoft Windows.

*   **FRACTAL** : R -  Plasma fractal image

*   **GRADIENT** : R -  Gradual passing from one shade to another

    Returns a rendered linear or radial top-to-bottom [gradient image] using the specified image size.

*   **HALD** : R -  Identity Hald CLUT Image

    Select levels like this: hald:[8] for level 8.

*   **HISTOGRAM** : W -  Histogram of the image

    The histogram includes the unique colors of the image as an image comment. If you have no need for the unique color list, use -define histogram:unique-colors=false to forego this expensive operation.

*   **INLINE** : RW -  Base64-encoded inline image

    The inline image look similar to inline:data:;base64,/9j/4AAQSk...knrn//2Q==. If the inline image exceeds 5000 characters, reference it from a file (e.g. inline:inline.txt). You can also write a base64-encoded image. Embed the mime type in the filename, for example, magick myimage inline:jpeg:myimage.txt.

*   **LABEL** : R -  Text image format

    Specify the desired text as the filename (e.g. label:"This a label").

*   MAP : RW ==> Colormap intensities and indices
    Set -depth to set the sample size of the intensities; indices are 16-bit if colors > 256.

*   MASK : RW ==> Grayscale image mask. 
    A sequence is emitted if the source image has more than one mask. 

    MAPRW Colormap intensities and indices Set -depth to set the sample size of the intensities; indices are 16-bit if colors > 256. MASK RW Grayscale image mask. A sequence is emitted if the source image has more than one mask. 

*   MATTE :W ==> MATTE format Write only. 

*   NULL :RW ==> NULL image 
    Useful for creating blank tiles with [montage] (use NULL:). Also useful as an output format when evaluating image read performance. 

*   PANGO : R ==>  Image caption 
    You can configure the caption layout with these defines: 

        -define pango:auto-dir=true/false, 
        -define pango:ellipsize=start/middle/end, 
        -define pango:gravity-hint=natural/strong/line, 
        -define pango:hinting=none/auto/full, 
        -define pango:indent=points, 
        -define pango:justify=true/false, 
        -define pango:language=en_US/etc, 
        -define pango:markup=true/false, 
        -define pango:single-paragraph=true/false, 
        -define pango:wrap=word/char/word-char and 
        -define pango:align=left/center/right. 

*   PLASMA : R ==>  Plasma fractal image 

*   PREVIEW : W ==>  Show a preview an image enhancement, effect, or f/x 
    Creates a preview montage of images prepared over a parametric range in order to assist with parameter selection. Specify the desired preview type via the -preview option). 

*   PRINT : W ==>  Send image to your computer printer 
    Linux users may set the PRINTER (for 'lpr') or LPDEST (for 'lp') environment variables to select the desired printer. 

*   SCAN : R ==>  Import image from a scanner device 
    Requires [SANE](http://www.sane-project.org/) Specify the device name and path as the filename (e.g. scan:'hpaio:/usb/Officejet_6200_series?serial=CN4ATCE3G20453'). 

*   RADIAL_GRADIENT: R ==> Gradual radial passing from one shade to another 
    Returns a rendered radial top-to-bottom [gradient image] using the specified image size.

*   SCANX : R ==>  Import image from the default scanner device 

*   SCREENSHOT : R ==>  an image that shows the contents of a computer display. 
    Under Windows, if you have multiple monitors, it returns a screenshot for each monitor. 

*   STEGANO : R ==>  Steganographic image 

    Use [-size] command line option to specify width, height, and offset of the steganographic image 

*   TILE : R ==>  Tiled image 
    Create a tiled version of an image at by tiling a image. Use [-size] to specify the tiled image size. Tiles are composited on an image background and therefore is responsive to the [-compose] option. The image is specified similar to TILE:image.miff. 

*   UNIQUE : W ==>  Write only unique pixels to the image file. 

*   VID : RW ==>  Visual Image Directory 
    Used to create a thumbnailed directory (tiled thumbnails) of a set of images which may be used to select images to view via the [display] program, or saved to a [MIFF] or [SHTML] file. 

*   WIN : RW ==>  Select image from or display image to your computer screen 
    Only supported under Microsoft Windows. 

*   X : RW ==>  Select image from or display image to your 
*   X : server ==>  screen Also see the [import] and [display] programs. 

*   XC : R ==>  Canvas image of specified color 
    An backward compatible alias for the 'canvas:' psuedo-file format, used to create a solid color canvas image.  

Built-in Images
---------------

ImageMagick includes a number of built-in (embedded) images which may be referenced as if they were an image file. The magick: format tag may be used via the syntax magick:name to request an embedded image (e.g. magick:logo). For backwards compatibility, the image specifications GRANITE:, LOGO:, NETSCAPE:, and ROSE: may also be used to request images with those names.

Tag Mode Description Notes

*   GRANITE: R ==> 128x128 granite texture pattern
    ![GRANITE](https://imagemagick.org/image/granite.png)

*    LOGO: R ==> ImageMagick Logo, 640x480
    ![Logo](https://imagemagick.org/image/logo.jpg)

*   NETSCAPE: R ==> image using colors in Netscape 216 (6x6x6 ) color cube, 216x144
    Most commonly used with the [magick] and [magick mogrify] programs with the [-map] option to create web safe images.

*   ROSE: R ==> Picture of a rose, 70x46
    ![ROSE](https://imagemagick.org/image/rose.png)

*   WIZARD: R ==> ImageMagick Wizard, 480x640
    ![WIZARD](https://imagemagick.org/image/wizard.jpg)

  

Built-in Patterns
-----------------

ImageMagick includes a number of built-in (embedded) patterns which may be referenced as if they were an image file. The pattern: format tag may be used via the syntax pattern:name to request an embedded pattern (e.g. pattern:checkerboard). The pattern size is controlled with the [-size] command line option.

|         Tag          | Mode |                      Description                       |                                          Notes                                           |
|----------------------|------|--------------------------------------------------------|------------------------------------------------------------------------------------------|
| BRICKS               | :R   | brick pattern, 16x16                                   | ![BRICKS](https://imagemagick.org/image/patterns/bricks.png)                             |
| CHECKERBOARD         | :R   | checkerboard pattern, 30x30                            | ![CHECKERBOARD](https://imagemagick.org/image/patterns/checkerboard.png)                 |
| CIRCLES              | :R   | circles pattern, 16x16                                 | ![CIRCLES](https://imagemagick.org/image/patterns/circles.png)                           |
| CROSSHATCH           | :R   | crosshatch pattern, 8x4                                | ![CROSSHATCH](https://imagemagick.org/image/patterns/crosshatch.png)                     |
| CROSSHATCH30         | :R   | crosshatch pattern with lines at 30 degrees, 8x4       | ![CROSSHATCH30](https://imagemagick.org/image/patterns/crosshatch30.png)                 |
| CROSSHATCH45         | :R   | crosshatch pattern with lines at 45 degrees, 8x4       | ![CROSSHATCH45](https://imagemagick.org/image/patterns/crosshatch45.png)                 |
| FISHSCALES           | :R   | fish scales pattern, 16x8                              | ![FISHSCALES](https://imagemagick.org/image/patterns/fishscales.png)                     |
| GRAY0                | :R   | 0% intensity gray, 32x32                               | ![GRAY0](https://imagemagick.org/image/patterns/gray0.png)                               |
| GRAY5                | :R   | 5% intensity gray, 32x32                               | ![GRAY5](https://imagemagick.org/image/patterns/gray5.png)                               |
| GRAY10               | :R   | 10% intensity gray, 32x32                              | ![GRAY10](https://imagemagick.org/image/patterns/gray10.png)                             |
| GRAY15               | :R   | 15% intensity gray, 32x32                              | ![GRAY15](https://imagemagick.org/image/patterns/gray15.png)                             |
| GRAY20               | :R   | 20% intensity gray, 32x32                              | ![GRAY20](https://imagemagick.org/image/patterns/gray20.png)                             |
| GRAY25               | :R   | 25% intensity gray, 32x32                              | ![GRAY25](https://imagemagick.org/image/patterns/gray25.png)                             |
| GRAY30               | :R   | 30% intensity gray, 32x32                              | ![GRAY30](https://imagemagick.org/image/patterns/gray30.png)                             |
| GRAY35               | :R   | 35% intensity gray, 32x32                              | ![GRAY35](https://imagemagick.org/image/patterns/gray35.png)                             |
| GRAY40               | :R   | 40% intensity gray, 32x32                              | ![GRAY40](https://imagemagick.org/image/patterns/gray40.png)                             |
| GRAY45               | :R   | 45% intensity gray, 32x32                              | ![GRAY45](https://imagemagick.org/image/patterns/gray45.png)                             |
| GRAY50               | :R   | 50% intensity gray, 32x32                              | ![GRAY50](https://imagemagick.org/image/patterns/gray50.png)                             |
| GRAY55               | :R   | 55% intensity gray, 32x32                              | ![GRAY55](https://imagemagick.org/image/patterns/gray55.png)                             |
| GRAY60               | :R   | 60% intensity gray, 32x32                              | ![GRAY60](https://imagemagick.org/image/patterns/gray60.png)                             |
| GRAY65               | :R   | 65% intensity gray, 32x32                              | ![GRAY65](https://imagemagick.org/image/patterns/gray65.png)                             |
| GRAY70               | :R   | 70% intensity gray, 32x32                              | ![GRAY70](https://imagemagick.org/image/patterns/gray70.png)                             |
| GRAY75               | :R   | 75% intensity gray, 32x32                              | ![GRAY75](https://imagemagick.org/image/patterns/gray75.png)                             |
| GRAY80               | :R   | 80% intensity gray, 32x32                              | ![GRAY80](https://imagemagick.org/image/patterns/gray80.png)                             |
| GRAY85               | :R   | 85% intensity gray, 32x32                              | ![GRAY85](https://imagemagick.org/image/patterns/gray85.png)                             |
| GRAY90               | :R   | 90% intensity gray, 32x32                              | ![GRAY90](https://imagemagick.org/image/patterns/gray90.png)                             |
| GRAY95               | :R   | 95% intensity gray, 32x32                              | ![GRAY95](https://imagemagick.org/image/patterns/gray95.png)                             |
| GRAY100              | :R   | 100% intensity gray, 32x32                             | ![GRAY100](https://imagemagick.org/image/patterns/gray100.png)                           |
| HEXAGONS             | :R   | hexagon pattern, 30x18                                 | ![HEXAGONS](https://imagemagick.org/image/patterns/hexagons.png)                         |
| HORIZONTAL           | :R   | horizontal line pattern, 8x4                           | ![HORIZONTAL](https://imagemagick.org/image/patterns/horizontal.png)                     |
| HORIZONTAL2          | :R   | horizontal line pattern, 8x8                           | ![HORIZONTAL2](https://imagemagick.org/image/patterns/horizontal2.png)                   |
| HORIZONTAL3          | :R   | horizontal line pattern, 9x9                           | ![HORIZONTAL3](https://imagemagick.org/image/patterns/horizontal3.png)                   |
| HORIZONTALSAW        | :R   | horizontal saw-tooth pattern, 16x8                     | ![HORIZONTALSAW](https://imagemagick.org/image/patterns/horizontalsaw.png)               |
| HS_BDIAGONAL         | :R   | backward diagonal line pattern (45 degrees slope), 8x8 | ![HS_BDIAGONAL](https://imagemagick.org/image/patterns/hs_bdiagonal.png)                 |
| HS_CROSS             | :R   | cross line pattern, 8x8                                | ![HS_CROSS](https://imagemagick.org/image/patterns/hs_cross.png)                         |
| HS_DIAGCROSS         | :R   | diagonal line cross pattern (45 degrees slope), 8x8    | ![HS_DIAGCROSS](https://imagemagick.org/image/patterns/hs_diagcross.png)                 |
| HS_FDIAGONAL         | :R   | forward diagonal line pattern (45 degrees slope), 8x8  | ![HS_FDIAGONAL](https://imagemagick.org/image/patterns/hs_fdiagonal.png)                 |
| HS_HORIZONTAL        | :R   | horizontal line pattern, 8x8                           | ![HS_HORIZONTAL](https://imagemagick.org/image/patterns/hs_horizontal.png)               |
| HS_VERTICAL          | :R   | vertical line pattern, 8x8                             | ![HS_VERTICAL](https://imagemagick.org/image/patterns/hs_vertical.png)                   |
| LEFT30               | :R   | forward diagonal pattern (30 degrees slope), 8x4       | ![LEFT0](https://imagemagick.org/image/patterns/left30.png)                              |
| LEFT45               | :R   | forward diagonal line pattern (45 degrees slope), 8x8  | ![LEFT45](https://imagemagick.org/image/patterns/left45.png)                             |
| LEFTSHINGLE          | :R   | left shingle pattern, 24x24                            | ![LEFTSHINGLE](https://imagemagick.org/image/patterns/leftshingle.png)                   |
| OCTAGONS             | :R   | octagons pattern, 16x16                                | ![OCTAGONS](https://imagemagick.org/image/patterns/octagons.png)                         |
| RIGHT30              | :R   | backward diagonal line pattern (30 degrees) 8x4        | ![RIGHT30](https://imagemagick.org/image/patterns/right30.png)                           |
| RIGHT45              | :R   | backward diagonal line pattern (30 degrees), 8x8       | ![RIGHT45](https://imagemagick.org/image/patterns/right45.png)                           |
| RIGHTSHINGLE         | :R   | right shingle pattern, 24x24                           | ![RIGHTSHINGLE](https://imagemagick.org/image/patterns/rightshingle.png)                 |
| SMALLFISHSCALES      | :R   | small fish scales pattern, 8x8                         | ![SMALLFISHSCALES](https://imagemagick.org/image/patterns/smallfishscales.png)           |
| VERTICAL             | :R   | vertical line pattern, 8x8                             | ![VERTICAL](https://imagemagick.org/image/patterns/vertical.png)                         |
| VERTICAL2            | :R   | vertical line pattern, 8x8                             | ![VERTICAL2](https://imagemagick.org/image/patterns/vertical2.png)                       |
| VERTICAL3            | :R   | vertical line pattern, 9x9                             | ![VERTICAL3](https://imagemagick.org/image/patterns/vertical3.png)                       |
| VERTICALBRICKS       | :R   | vertical brick pattern, 16x16                          | ![VERTICALBRICKS](https://imagemagick.org/image/patterns/verticalbricks.png)             |
| VERTICALLEFTSHINGLE  | :R   | vertical left shingle pattern, 24x24                   | ![VERTICALLEFTSHINGLE](https://imagemagick.org/image/patterns/verticalleftshingle.png)   |
| VERTICALRIGHTSHINGLE | :R   | vertical right shingle pattern, 24x24                  | ![VERTICALRIGHTSHINGLE](https://imagemagick.org/image/patterns/verticalrightshingle.png) |
| VERTICALSAW          | :R   | vertical saw-tooth pattern, 8x16                       | ![VERTICALSAW](https://imagemagick.org/image/patterns/verticalsaw.png)                   |
  

Embedded Image Profiles
-----------------------

ImageMagick provides a number of format identifiers which are used to add, remove, and save embedded profiles for images which can support embedded profiles. Image types which may contain embedded profiles are TIFF, JPEG, and PDF.

|   Tag    | Mode |                 Description                  |                           Notes                           |    |                                   |                                             |
|----------|------|----------------------------------------------|-----------------------------------------------------------|----|-----------------------------------|---------------------------------------------|
| 8BIM     | RW   | Photoshop resource format (binary)           | 8BIMTEXT                                                  | RW | Photoshop resource format (ASCII) | An ASCII representation of the 8BIM format. |
| APP1     | RW   | Raw application information                  | APP1JPEG                                                  | RW | Raw JPEG binary data              | Profile in JPEG wrapper.                    |
| ICC      | RW   | International Color Consortium color profile | Also known as ICM. To read, use [-profile] with [magick]. |    |                                   |                                             |
| IPTC     | RW   | IPTC Newsphoto (binary)                      | To read, use [-profile] with [magick]                     |    |                                   |                                             |
| IPTCTEXT | RW   | IPTC Newsphoto (ASCII)                       | An ASCII representation of the IPTC format.               |    |                                   |                                             |


/Motion Picture and Effects
===========================

[Log Format] • [DPX Properties] • [DPX Settings]

DPX (SMPTE 268M-2003) - This format is used in Motion Picture and Effects industry that makes particular use of the extensive header information and the format's flexibility in being able to handle high dynamic range and logarithmic color values at a variety of bit depths using RGB or YCbCr pixel descriptions. It is based on, but largely supersedes, Kodak's Cineon format that has a more film specific header.

One example of it's use includes scanning film for use in post production. Each frame is stored as an individual DPX file ranging from 2k (2048 pixels wide) to 8k (8192 pixels wide - for IMAX frames) at anything between 8 to 64 bits per color component. A sequence of these might then be processed using compositing software, altering the color or adding visual effects. Once complete they might then be recorded digitally to tape or projected back on to film.

The color values for each pixel are often stored logarithmically (particularly if the sequence is destined to be transferred back on to film) which more naturally reflects the density of how color information is stored in the emulsion on the original film. When viewed without alteration, logarithmic files appear to have very low contrast and requires a 'look up table' to translate the logarithmic image to something that resembles what you might see if the image was transferred back to film and projected in a cinema. Apart from making the image linear (like most typical computer images) and adjusting the gamma level this table sets where the black and white point lies.

For a 10 bit logarithmic image where each color component value ranges from 0 to 1023 the black and white points are normally set at 95 for black and 685 for white. What this means is that the logarithmic file stores color values that are lighter than what the linear version will display as pure white and darker than what it will display as pure black. This extra information therefore remains available for an effects artists who might wish to alter the brightness of the image after it has been stored as a DPX file.

As an example, had this information been lost, reducing the brightness of an image uniformly would result in highlights becoming darker, whereas with this extra information the highlights instead reduce in size and start showing details that were previously too bright to be seen. The latter is far closer to what happens in the real world.

The header can contain Film and/or Television specific data related to a production. For example the television header can contain a SMPTE time code so that shots exported as a DPX sequence from a production's edit can be easily replaced once any effects have been added. The film header holds information about the reel of film the frames originated from and various camera settings that were used while filming. All these details usually stay with the images as they are passed between post-production companies.

Log Format
----------

The color values for each pixel are often stored logarithmically (particularly if the sequence is destined to be transferred back on to film) which more naturally reflects the density of how color information is stored in the emulsion on the original film. When viewed without alteration logarithmic files appear to have very low contrast (leftmost image), and so require a 'look up table' to translate the logarithmic image to something that resembles what you might see if the image was transferred back to film and projected in a cinema (rightmost image). Apart from making the image linear (like most typical computer images) and adjusting the gamma level this table sets where the black and white point lies.

![bluebells-log](https://imagemagick.org/image/bluebells_log.jpg) ![bluebells-linear](https://imagemagick.org/image/bluebells_lin.jpg)

For a 10 bit logarithmic image where each color component value ranges from 0 to 1023 the black and white points are normally set at 95 for black and 685 for white. What this means is that the logarithmic file stores color values that are lighter than what the linear version will display as pure white and darker than what it will display as pure black. This extra information therefore remains available for an effects artists who might wish to alter the brightness of the image after it has been stored as a DPX file.

As an example, had this information been lost, reducing the brightness of a linear image uniformly would result in highlights becoming darker (leftmost image), whereas with this extra information the highlights instead reduce in size and start showing details that were previously too bright to be seen (rightmost image). The latter is far closer to what happens in the real world.

![bluebells-clipped](https://imagemagick.org/image/bluebells_clipped.jpg) ![bluebells-darker](https://imagemagick.org/image/bluebells_darker.jpg)

DPX Properties
--------------

ImageMagick supports these DPX properties:

    dpx:file.copyright             dpx:orientation.x_center
    dpx:file.creator               dpx:orientation.x_offset
    dpx:file.filename              dpx:orientation.x_size
    dpx:file.project               dpx:orientation.y_center
    dpx:file.version               dpx:orientation.y_offset
    dpx:film.count                 dpx:orientation.y_size
    dpx:film.format                dpx:television.black_gain
    dpx:film.frame_id              dpx:television.black_level
    dpx:film.frame_position        dpx:television.break_point
    dpx:film.frame_rate            dpx:television.field_number
    dpx:film.held_count            dpx:television.frame_rate
    dpx:film.id                    dpx:television.gamma
    dpx:film.offset                dpx:television.integration_times
    dpx:film.prefix                dpx:television.interlace
    dpx:film.sequence_length       dpx:television.padding
    dpx:film.shutter_angle         dpx:television.time.code
    dpx:film.slate                 dpx:television.time_offset
    dpx:film.type                  dpx:television.user.bits
    dpx:orientation.aspect_ratio   dpx:television.vertical_sample_rate
    dpx:orientation.border         dpx:television.video_signal
    dpx:orientation.device         dpx:television.white_level
    dpx:orientation.filename       dpx:user.id
    dpx:orientation.serial         dpx:user.data

Look for any user data as the dpx:user-data image profile.

To determine which properties are associated with your DPX image, use this command for example:

magick identify -verbose bluebells.dpx

To identify a particular property, try this:

magick identify -format "%[dpx:television.time.code]" bluebells.dpx

Finally, to set a property:

magick bluebells.dpx -define dpx:television.time.code=10:00:02:15 bluebells-001.dpx

DPX Settings
------------

Use [-set] to specify the image or film gamma or black and white points. For example use:

    -set gamma 1.7
    -set film-gamma 0.6
    -set reference-black 95
    -set reference-white 685
    -set profile dpx:user.data


/WebP Encoding Options
======================

ImageMagick's WebP image format accepts a plethora of encoding options as detailed below. As an example, suppose you are interested in these options:

*   quality of 50
*   lossless compression

Use this command:

    magick wizard.png -quality 50 -define webp:lossless=true wizard.webp

Here is a complete list of WebP encoding options:

Option Description

*   `  alpha-compression  ` = value

    encode the alpha plane: 0 = none, 1 = compressed.

*   `  alpha-filtering  ` = value

    predictive filtering method for alpha plane: 0=none, 1=fast, 2=best.

*   `  alpha-quality  ` = value

    the compression value for alpha compression between 0 and 100. Lossless compression of alpha is achieved using a value of 100, while the lower values result in a lossy compression. The default is 100.

*   `  exact  ` = true, false

    preserve RGB values in transparent area. It's disabled by default to help compressibility.

*   `  auto-filter  ` = true, false

    when enabled, the algorithm spends additional time optimizing the filtering strength to reach a well-balanced quality.

*   `  emulate-jpeg-size  ` = true, false

    return a similar compression to that of JPEG but with less degradation.

*   `  filter-sharpness  ` = value

    filter sharpness.

*   `  filter-strength  ` = value

    the strength of the deblocking filter, between 0 (no filtering) and 100 (maximum filtering). A value of 0 turns off any filtering. Higher values increase the strength of the filtering process applied after decoding the image. The higher the value, the smoother the image appears. Typical values are usually in the range of 20 to 50.

*   `  filter-type  ` = value

    filter type: 0 = simple, 1 = strong

*   `  image-hint  ` = default, photo, picture, graph

    the hint about the image type.

*   `  lossless  ` = true, false

    encode the image without any loss.

*   `  low-memory  ` = true, false

    reduce memory usage.

*   `  method  ` = value

    the compression method to use. It controls the trade off between encoding speed and the compressed file size and quality. Possible values range from 0 to 6. Default value is 4. When higher values are utilized, the encoder spends more time inspecting additional encoding possibilities and decide on the quality gain. Lower value might result in faster processing time at the expense of larger file size and lower compression quality.

*   `  near-lossless  ` = value

    the near lossless encoding, between 0 (max-loss) and 100 (off).

*   `  preprocessing  ` = value

    Choose from: 0=none, 1=segment-smooth, 2=pseudo-random dithering.

*   `  partitions  ` = value

    progressive decoding: choose 0 to 3.

*   `  partition-limit  ` = value

    Choose 0 for no quality degradation and 100 for maximum degradation.

*   `  pass  ` = value

    maximum number of passes to target compression size or PSNR.

*   `  segment  ` = value

    Choose from 1 to 4, the maximum number of segments to use.

*   `  show-compressed  ` = true, false

*   `  sns-strength  ` = value

    the amplitude of the spatial noise shaping. Spatial noise shaping (SNS) refers to a general collection of built-in algorithms used to decide which area of the picture should use relatively less bits, and where else to better transfer these bits. The possible range goes from 0 (algorithm is off) to 100 (the maximal effect). The default value is 80.

*   `  target-size  ` = value

    a target size (in bytes) to try and reach for the compressed output. The compressor makes several passes of partial encoding in order to get as close as possible to this target.

*   `  target-psnr  ` = value

    desired minimal distortion.

*   `  thread-level  ` = value

    enable multi-threaded encoding: 0 = disabled, 1 = enabled.

*   `  use-sharp-yuv  ` = value

    if needed, use sharp (and slow) RGB->YUV conversion.


/JP2 Encoding Options
=====================


ImageMagick's JPEG-2000 image formats, JP2 and JPC, accept a plethora of encoding options as detailed below. As an example, suppose you are interested in these options:

*   code blocks are 64 samples in width and 32 samples in height
*   no multicomponent transform
*   4 resolution levels for each component
*   compression is lossy at 64:1

Use this command to convert a JPEG-2000 image to the PNG image format:

    magick wizard.jp2 wizard.png 

Let's convert a JPEG image to a lossless JPEG-2000 image:

    magick wizard.jpg -quality 0 wizard.jp2 

Here we extract an area from the image:

    magick 'wizard.jp2[640x480+0+0]' wizard.png 

Extract a particular tile from the image:

    magick 'wizard.jp2[2]' wizard.png 

Specify a subsampling factor:

    magick wizard.png -colorspace YUV -sampling-factor 2,2 wizard.jp2 

Save a tiled JPEG-2000 image:

    magick wizard.png 'wizard.png[512x512]' 

Write a digital Cinema 4K profile compliant codestream:

    magick wizard.png -resize 4096x2160! -depth 12 wizard.jp2 

Here is a complete list of JPEG-2000 decoding options:

    jp2:quality-layers=x

set the maximum number of quality layers to decode.

    jp2:reduce-factor=x

set the number of highest resolution levels to be discarded.

Here is a complete list of JPEG-2000 encoding options:

*   `  jp2:number-resolutions  `  = x

    number of resolutions to encode.

*   `  jp2:quality  `  = x,x,...

    set the quality layer PSNR, given in dB. The order is from left to right in ascending order. The default is a single lossless quality layer.

*   `  jp2:rate  `  = x,x,...

    the compression ratio values. Each value is a factor of compression, thus 20 means 20 times compressed. The order is from left to right in descending order. A final lossless quality layer is signified by the value 1. The default is a single lossless quality layer.

*   `  jp2:progression-order  `  = x

    choose from LRCP, RLCP, RPCL, PCRL or CPRL.


/Magick Image File Format
=========================

[MIFF Header] • [MIFF Binary Data]

The Magick Image File Format (MIFF) is ImageMagick's own platform-independent format for storing bitmap images. It has an advantage over other image formats in that it stores all metadata known to ImageMagick (e.g. image color profiles, comments, author, copyright, etc.), whereas, other formats may only support a small portion of available metadata or none at all. A MIFF image file consist of two sections. The first section is a header composed of keys describing the image in text form. The next section is the binary image data. We discuss these sections in detail below.

MIFF Header
-----------

The MIFF header is composed entirely of ISO-8859-1 characters. The fields in the header are key and value combination in the key = value format, with each key and value separated by an equal sign (\=). Each key = value combination is delimited by at least one control or whitespace character. Comments may appear in the header section and are always delimited by braces. The MIFF header always ends with a colon (:) character, followed by a ctrl-Z character. It is also common to proceed the colon with a formfeed and a newline character. The formfeed prevents the listing of binary data when using the more Linux program, whereas, the ctrl-Z has the same effect with the type command on the Windows command line.

The following is a partial list of key = value combinations that are typically be found in a MIFF file:

*   `  background-color ` = color
*   `  border-color ` = color
*   `  matte-color ` = color

    these optional keys reflect the image background, border, and matte colors respectively. A [color] can be a name (e.g. white) or a hex value (e.g. #ccc).

*   `  class ` = { DirectClass, PseudoClass }

    the type of binary pixel data stored in the MIFF file. If this key is not present, DirectClass pixel data is assumed.

*   `  colors ` = value

    the number of colors in a DirectClass image. For a PseudoClass image, this key specifies the number of entries in the colormap. If this key is not present in the header, and the image is PseudoClass, a linear 256 color grayscale colormap is assumed. The maximum number of colormap entries is 65536.

*   `  colorspace ` = { RGB, CMYK, ... }

    the colorspace of the pixel data. The default is RGB.

*   `  columns ` = value

    the width of the image in pixels. This a required key and has no default value.

*   `  compression ` = {BZip, None, Zip, ... }

    the type of algorithm used to compress the image data. If this key is not present, the pixel data is assumed to be uncompressed.

*   `  delay ` = microseconds

    the interframe delay in an image sequence in microseconds.

*   `  depth ` = { 8, 16, 32 }

    the depth of a single color value representing values from 0 to 255 (depth 8), 0 - 65535 (depth 16), or 0 - 4294967295 (depth 32). If this key is absent, a depth of 8 is assumed.

*   `  dispose ` = value

    layer disposal method. Here are the valid values:

    0. No disposal specified.
    1. Do not dispose between frames.
    2. Overwrite frame with background color from header.
    3. Overwrite with previous frame.

*   `  gamma ` = value

    the gamma of the image. If it is not specified, a gamma of 1.0 (linear brightness response) is assumed.

*   `  id` =ImageMagick

    identifies the file as a MIFF-format image file. This key is required, must be the first key-value pair, can only appear once, and has no default. Although this key can appear anywhere in the header, it should start as the first key of the header in column 1. This will allow programs like file(1) to easily identify the file as MIFF.

*   `  iterations ` = value

    the number of times an image sequence loops before stopping.

*   `  label ` = { string ]

    defines a short title or caption for the image. If any whitespace appears in the label, it must be enclosed within braces.

*   `  matte ` = { True, False }

    specifies whether a the image has matte data. Matte data is generally useful for image compositing.

*   `  montage ` = <width>x<height>[+-]<x offset>[+-]<y offset>

    size and location of the individual tiles of a composite image. Use this key when the image is a composite of a number of different tiles. A tile consists of an image and optionally a border and a label. Width is the size in pixels of each individual tile in the horizontal direction and height is the size in the vertical direction. Each tile must have an equal number of pixels in width and equal in height. However, the width can differ from the height. X offset is the offset in number of pixels from the vertical edge of the composite image where the first tile of a row begins and y offset is the offset from the horizontal edge where the first tile of a column begins. If this key is specified, a directory of tile names must follow the image header. The format of the directory is explained below.

*   `  page ` = value

    preferred size and location of an image canvas.

*   `  profile-icc ` = value

    the number of bytes in the International Color Consortium color profile. The profile is defined by the ICC profile specification located at [http://www.color.org/icc_specs2.html](http://www.color.org/icc_specs2.html).

*   `  red-primary ` = x,y
*   `  green-primary ` = x,y
*   `  blue-primary ` = x,y
*   `  white-point ` = x,y

    this optional key reflects the chromaticity primaries and white point.

*   `  rendering-intent ` = { saturation, perceptual, absolute, relative }

    Rendering intent is the CSS-1 property that has been defined by the International Color Consortium ([http://www.color.org](http://www.color.org)).

*   `  resolution ` = <x-resolution>x<y-resolution>

    vertical and horizontal resolution of the image. See units for the specific resolution units (e.g. pixels per inch).

*   `  rows ` = value

    the height of the image in pixels. This a required key and has no default value.

*   `  scene ` = value

    the sequence number for this MIFF image file. This optional key is useful when a MIFF image file is one in a sequence of files used in an animation.

*   `  signature ` = value

    this optional key contains a string that uniquely identifies the image pixel contents. NIST's SHA-256 message digest algorithm is recommended.

*   `  units ` = { pixels-per-inch, pixels-per-centimeter }

    image resolution units.

Other key value pairs are permitted. If a value contains whitespace it must be enclosed with braces as illustrated here:

    id=ImageMagick
    class=PseudoClass  colors=256  matte=False
    columns=1280  rows=1024  depth=8
    compression=RLE
    colorspace=RGB
    copyright={© 1999-2017 ImageMagick Studio LLC}
    ⋮

Note that key = value combinations may be separated by newlines or spaces and may occur in any order within the header. Comments (within braces) may appear anywhere before the colon.

If you specify the montage key in the header, follow the header with a directory of image tiles. This directory consists of a name for each tile of the composite image separated by a newline character. The list is terminated with a NULL character.

If you specify the color-profile key in the header, follow the header (or montage directory if the montage key is in the header) with the binary color profile.

The header is separated from the image data by a : character immediately followed by a newline.

MIFF Binary Data
----------------

Next comes the binary image data itself. How the image data is formatted depends upon the class of the image as specified (or not specified) by the value of the class key in the header.

DirectClass images are continuous-tone, images stored as RGB (red, green, blue), RGBA (red, green, blue, alpha), CMYK (cyan, yellow, magenta, black), or CMYKA (cyan, yellow, magenta, black, alpha) intensity values as defined by the colorspace key. Each intensity value is one byte in length for images of depth 8 (0..255), two bytes for a depth of 16 (0..65535), and images of depth 32 (0..4294967295) require four bytes in most significant byte first order.

PseudoClass images are colormapped RGB images. The colormap is stored as a series of red, green, and blue pixel values, each value being a byte in size. If the image depth is 16, each colormap entry consumes two bytes with the most significant byte being first. The number of colormap entries is defined by the colors key. The colormap data occurs immediately following the header (or image directory if the montage key is in the header). PseudoClass image data is an array of index values into the color map. If there are 256 or fewer colors in the image, each byte of image data contains an index value. If the image contains more than 256 colors or the image depth is 16, the index value is stored as two contiguous bytes with the most significant byte being first. If matte is true, each colormap index is followed by a 1 or 2-byte alpha value.

The image pixel data in a MIFF file may be uncompressed, runlength encoded, Zip compressed, or BZip compressed. The compression key in the header defines how the image data is compressed. Uncompressed pixels are stored one scanline at a time in row order. Runlength-encoded compression counts runs of identical adjacent pixels and stores the pixels followed by a length byte (the number of identical pixels minus 1). Zip and BZip compression compresses each row of an image and precedes the compressed row with the length of compressed pixel bytes as a word in most significant byte first order.

MIFF files may contain more than one image. Simply concatenate each individual image (composed of a header and image data) into one file.


/Magick Vector Graphics
=======================

[MVG Overview] • [Drawing Primitives]

This specification defines the features and syntax for Magick Vector Graphics (MVG), a modularized language for describing two-dimensional vector and mixed vector/raster graphics in ImageMagick. You can use the language to draw from the command line, from an MVG file, from an [SVG -- Scalable Vector Graphics](http://www.w3.org/TR/SVG/) file or from one of the ImageMagick [program interfaces]. Use this command, for example, to render an arc:

```sh
magick -size 100x60 canvas:skyblue -fill white -stroke black \
  -draw "path 'M 30,40  A 30,20  20  0,0 70,20 A 30,20  20  1,0 30,40 Z '" \
  arc.png
```

and here is the result:

![arc](https://imagemagick.org/image/arc.png)

When the drawing gets sufficiently complex, we recommend you assemble the graphic primitives into a MVG file. For our example, we use [piechart.mvg](https://imagemagick.org/source/piechart.mvg):

```sh
push graphic-context
  viewbox 0 0 624 369
  affine 0.283636 0 0 0.283846 -0 -0
  push graphic-context
    push graphic-context
      fill 'darkslateblue'
      stroke 'blue'
      stroke-width 1
      rectangle 1,1 2199,1299
    pop graphic-context
    push graphic-context
      font-size 40
      fill 'white'
      stroke-width 1
      text 600,1100 'Average: 20.0'
    pop graphic-context
    push graphic-context
      fill 'red'
      stroke 'black'
      stroke-width 5
      path 'M700.0,600.0 L340.0,600.0 A360.0,360.0 0 0,1 408.1452123287954,389.2376150414973 z'
    pop graphic-context
    push graphic-context
      font-size 40
      fill 'white'
      stroke-width 1
      text 1400,140 'MagickWand for PHP'
    pop graphic-context
    push graphic-context
      font-size 30
      fill 'white'
      stroke-width 1
      text 1800,140 '(10.0%)'
    pop graphic-context
    push graphic-context
      fill 'red'
      stroke 'black'
      stroke-width 4
      rectangle 1330,100 1370,140
    pop graphic-context
    push graphic-context
      fill 'yellow'
      stroke 'black'
      stroke-width 5
      path 'M700.0,600.0 L408.1452123287954,389.2376150414973 A360.0,360.0 0 0,1 976.5894480359858,369.56936567559273 z'
    pop graphic-context
    push graphic-context
      font-size 40
      fill 'white'
      stroke-width 1
      text 1400,220 'MagickCore'
    pop graphic-context
    push graphic-context
      font-size 30
      fill 'white'
      stroke-width 1
      text 1800,220 '(29.0%)'
    pop graphic-context
    push graphic-context
      fill 'yellow'
      stroke 'black'
      stroke-width 4
      rectangle 1330,180 1370,220
    pop graphic-context
    push graphic-context
      fill 'fuchsia'
      stroke 'black'
      stroke-width 5
      path 'M700.0,600.0 L976.5894480359858,369.56936567559273 A360.0,360.0 0 0,1 964.2680466142854,844.4634932636567 z'
    pop graphic-context
    push graphic-context
      font-size 40
      fill 'white'
      stroke-width 1
      text 1400,300 'MagickWand'
    pop graphic-context
    push graphic-context
      font-size 30
      fill 'white'
      stroke-width 1
      text 1800,300 '(22.9%)'
    pop graphic-context
    push graphic-context
      fill 'fuchsia'
      stroke 'black'
      stroke-width 4
      rectangle 1330,260 1370,300
    pop graphic-context
    push graphic-context
      fill 'blue'
      stroke 'black'
      stroke-width 5
      path 'M700.0,600.0 L964.2680466142854,844.4634932636567 A360.0,360.0 0 0,1 757.853099990584,955.3210081341651 z'
    pop graphic-context
    push graphic-context
      font-size 40
      fill 'white'
      stroke-width 1
      text 1400,380 'JMagick'
    pop graphic-context
    push graphic-context
      font-size 30
      fill 'white'
      stroke-width 1
      text 1800,380 '(10.6%)'
    pop graphic-context
    push graphic-context
      fill 'blue'
      stroke 'black'
      stroke-width 4
      rectangle 1330,340 1370,380
    pop graphic-context
    push graphic-context
      fill 'lime'
      stroke 'black'
      stroke-width 5
      path 'M700.0,600.0 L757.853099990584,955.3210081341651 A360.0,360.0 0 0,1 340.0,600.0 z'
    pop graphic-context
    push graphic-context
      font-size 40
      fill 'white'
      stroke-width 1
      text 1400,460 'Magick++'
    pop graphic-context
    push graphic-context
      font-size 30
      fill 'white'
      stroke-width 1
      text 1800,460 '(27.5%)'
    pop graphic-context
    push graphic-context
      fill 'lime'
      stroke 'black'
      stroke-width 4
      rectangle 1330,420 1370,460
    pop graphic-context
    push graphic-context
      font-size 100
      fill 'white'
      stroke-width 1
      text 100,150 'ImageMagick'
    pop graphic-context
    push graphic-context
      fill 'none'
      stroke 'black'
      stroke-width 5
      circle 700,600 700,960
    pop graphic-context
  pop graphic-context
pop graphic-context
```

to render a pie chart with this command:

    magick mvg:piechart.mvg piechart.png

which produces this rendering:

![piechart](https://imagemagick.org/image/piechart.png)

However, in general, MVG is sufficiently difficult to work with that you probably want to use a program to generate your graphics in the SVG format. ImageMagick automagically converts SVG to MVG and renders your image, for example, we render [piechart.svg](https://imagemagick.org/source/piechart.svg) with this command:

    magick mvg:piechart.svg piechart.jpg

to produce the same pie chart we created with the MVG language.

Drawing is available from many of the ImageMagick [program interfaces] as well. ImageMagick converts the drawing API calls to MVG and renders it. Here is example code written in the [MagickWand] language:

```sh
(void) PushDrawingWand(draw_wand);
{
  const PointInfo points[6] =
  {
    { 180,504 },
    { 282.7,578.6 },
    { 243.5,699.4 },
    { 116.5,699.4 },
    { 77.26,578.6 },
    { 180,504 }
  };

  DrawSetStrokeAntialias(draw_wand,True);
  DrawSetStrokeWidth(draw_wand,9);
  DrawSetStrokeLineCap(draw_wand,RoundCap);
  DrawSetStrokeLineJoin(draw_wand,RoundJoin);
  (void) DrawSetStrokeDashArray(draw_wand,0,(const double *)NULL);
  (void) PixelSetColor(color,"#4000c2");
  DrawSetStrokeColor(draw_wand,color);
  DrawSetFillRule(draw_wand,EvenOddRule);
  (void) PixelSetColor(color,"#800000");
  DrawSetFillColor(draw_wand,color);
  DrawPolygon(draw_wand,6,points);
}
(void) PopDrawingWand(draw_wand);
```

MVG Overview
------------

MVG ignores all white-space between commands. This allows multiple MVG commands per line. It is common convention to terminate each MVG command with a newline to make MVG easier to edit and read. This syntax description uses indentation in MVG sequences to aid with understanding. Indentation is supported but is not required.

Metafile wrapper syntax (to support stand-alone MVG files):

```sh
push graphic-context
  viewbox 0 0 width height
  [ any other MVG commands ]
pop graphic-context

Pattern syntax (saving and restoring context):

push pattern id x,y width,height
 push graphic-context
  [ drawing commands ]
 pop graphic-context
pop pattern

an example is (%s is a identifier string):

push defs
 push pattern %s 10,10 20,20
  push graphic-context
   fill red
   rectangle 5,5 15,15
  pop graphic-context
  push graphic-context
   fill green
   rectangle 10,10 20,20
  pop graphic-context
 pop pattern
pop defs
```

For image tiling use:

    push pattern id x,y width,height
     image Copy ...
    pop pattern

Note you can use the pattern for either the fill or stroke like:

    stroke url(#%s)

or

    fill url(#%s)

The clip path defines a clipping area, where only the contained area to be drawn upon. Areas outside of the clipping areare masked.

```sh
push defs
 push clip-path "myClipPath"
  push graphic-context
   rectangle 10,10 20,20
  pop graphic-context
 pop clip-path
pop defs
clip-path url(#myClipPath)
```

Drawing Primitives
------------------

Here is a complete description of the MVG drawing primitives:

Primitive Description

*    affine sx,rx,ry,sy,tx,ty
*    arc x0,y0 x1,y1 a0,a1
*    bezier x0,y0 ... xn,yn

    Bezier (spline) requires three or more x,y coordinates to define its shape. The first and last points are the knots (preserved coordinates) and any intermediate coordinates are the control points. If two control points are specified, the line between each end knot and its sequentially respective control point determines the tangent direction of the curve at that end. If one control point is specified, the lines from the end knots to the one control point determines the tangent directions of the curve at each end. If more than two control points are specified, then the additional control points act in combination to determine the intermediate shape of the curve. In order to draw complex curves, it is highly recommended either to use the Path primitive or to draw multiple four-point bezier segments with the start and end knots of each successive segment repeated.

*    border-color color
*    circle originx,originy perimeterx,perimetery
*    clip-path url(name)
*    clip-rule rule

    Choose from these rule types:

        evenodd
        nonzero

*    clip-units units

    Choose from these unit types:

        userSpace
        userSpaceOnUse
        objectBoundingBox

*    color x,y method

    Choose from these method types:

        point
        replace
        floodfill
        filltoborder
        reset

*    compliance type

    Choose from these compliance types: MVG or SVG

*    decorate type

    Choose from these types of decorations:

        none
        line-through
        overline
        underline

*    ellipse centerx,centery 
*    radiusx,radiusy 
*    arcstart,arcstop

*    fill color

    Choose from any of these [colors].

*    fill-opacity opacity

    The opacity ranges from 0.0 (fully transparent) to 1.0 (fully opaque) or as a percentage (e.g. 50%).

*    fill-rule rule

    Choose from these rule types:

    evenodd
    nonzero

*    font name

*    font-family family

*    font-size point-size

*    font-stretch type

    Choose from these stretch types:

        all
        normal
        ultra-condensed
        extra-condensed
        condensed
        semi-condensed
        semi-expanded
        expanded
        extra-expanded
        ultra-expanded

*    font-style style

    Choose from these styles:

        all
        normal
        italic
        oblique

*    font-weight weight

    Choose from these weights:

        all normal bold 100 200 300 400 500 600 700 800 900

*    gradient-units units

    Choose from these units:

        userSpace
        userSpaceOnUse
        objectBoundingBox

*    gravity type

    Choose from these gravity types:

    NorthWest North NorthEast West Center East SouthWest South SouthEast

*    image compose x,y width,height 'filename'

    Choose from these compose operations:

    Method Description

    *   **clear**

        Both the color and the alpha of the destination are cleared. Neither the source nor the destination are used as input.

    *   **src**

        The source is copied to the destination. The destination is not used as input.

    *   **dst**

        The destination is left untouched.

    *   **src-over**

        The source is composited over the destination.

    *   **dst-over**

        The destination is composited over the source and the result replaces the destination.

    *   **src-in**

        The part of the source lying inside of the destination replaces the destination.

    *   **dst-in**

        The part of the destination lying inside of the source replaces the destination.

    *   **src-out**

        The part of the source lying outside of the destination replaces the destination.

    *   **dst-out**

        The part of the destination lying outside of the source replaces the destination.

    *   **src-atop**

        The part of the source lying inside of the destination is composited onto the destination.

    *   **dst-atop**

        The part of the destination lying inside of the source is composited over the source and replaces the destination.

    *   **multiply**

        The source is multiplied by the destination and replaces the destination. The resultant color is always at least as dark as either of the two constituent colors. Multiplying any color with black produces black. Multiplying any color with white leaves the original color unchanged.

    *   **screen**

        The source and destination are complemented and then multiplied and then replace the destination. The resultant color is always at least as light as either of the two constituent colors. Screening any color with white produces white. Screening any color with black leaves the original color unchanged.

    *   **overlay**

        Multiplies or screens the colors, dependent on the destination color. Source colors overlay the destination whilst preserving its highlights and shadows. The destination color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the destination.

    *   **darken**

        Selects the darker of the destination and source colors. The destination is replaced with the source when the source is darker, otherwise it is left unchanged.

    *   **lighten**

        Selects the lighter of the destination and source colors. The destination is replaced with the source when the source is lighter, otherwise it is left unchanged.

    *   **linear-light**

        Increase contrast slightly with an impact on the foreground's tonal values.

    *   **color-dodge**

        Brightens the destination color to reflect the source color. Painting with black produces no change.

    *   **color-burn**

        Darkens the destination color to reflect the source color. Painting with white produces no change.

    *   **hard-light**

        Multiplies or screens the colors, dependent on the source color value. If the source color is lighter than 0.5, the destination is lightened as if it were screened. If the source color is darker than 0.5, the destination is darkened, as if it were multiplied. The degree of lightening or darkening is proportional to the difference between the source color and 0.5. If it is equal to 0.5 the destination is unchanged. Painting with pure black or white produces black or white.

    *   **soft-light**

        Darkens or lightens the colors, dependent on the source color value. If the source color is lighter than 0.5, the destination is lightened. If the source color is darker than 0.5, the destination is darkened, as if it were burned in. The degree of darkening or lightening is proportional to the difference between the source color and 0.5. If it is equal to 0.5, the destination is unchanged. Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white.

    *   **plus**

        The source is added to the destination and replaces the destination. This operator is useful for animating a dissolve between two images.

    *   **add**

        As per 'plus' but transparency data is treated as matte values. As such any transparent areas in either image remain transparent.

    *   **minus**

        Subtract the colors in the source image from the destination image. When transparency is involved, Opaque areas will be subtracted from any destination opaque areas.

    *   **subtract**

        Subtract the colors in the source image from the destination image. When transparency is involved transparent areas are subtracted, so only the opaque areas in the source remain opaque in the destination image.

    *   **difference**

        Subtracts the darker of the two constituent colors from the lighter. Painting with white inverts the destination color. Painting with black produces no change.

    *   **exclusion**

        Produces an effect similar to that of 'difference', but appears as lower contrast. Painting with white inverts the destination color. Painting with black produces no change.

    *   **xor**

        The part of the source that lies outside of the destination is combined with the part of the destination that lies outside of the source.

    *   **copy-**

        Copy the specified channel in the source image to the same channel in the destination image. If the channel specified in the source image does not exist, (which can only happen for methods, 'copy-opacity' or 'copy-black') then it is assumed that the source image is a special grayscale channel image of the values to be copied.

    *   **change-mask**

        Replace any destination pixel that is the similar to the source images pixel (as defined by the current [-fuzz] factor), with transparency.

*    interline-spacing pixels
*    interword-spacing pixels
*    kerning pixels
*    line x,y x1,y1
*    matte x,y method

    Choose from these methods:

        point replace floodfill filltoborder reset

*    offset offset
*    opacity opacity

    Use percent (e.g. 50%).

*    path path
*    point x,y
*    polygon x,y x1,y1, ..., xn,yn
*    polyline x,y x1,y1, ..., xn,yn
*    pop clip-path
*    pop defs
*    pop gradient
*    pop graphic-context
*    pop pattern
*    push clip-path "name"
*    push defs
*    push gradient id linear x,y x1,y1
*    push gradient id radial xc,cy xf,yf radius
*    push graphic-context { "id" }
*    the _id_ is optional
*    push pattern id radial x,y width,height
*    rectangle x,y x1,y1
*    rotate angle
*    roundrectangle x,y x1,y1 width,height
*    scale x,y
*    skewX angle
*    skewX angle
*    stop-color color offset
*    stroke color
*    stroke-antialias 0 • 1
*    stroke-dasharray none • numeric-list
*    stroke-dashoffset offset
*    stroke-linecap type
    Choose from these cap types:

        butt round square

*    stroke-linejoin type

    Choose from these join types:

        bevel miter round
*    stroke-miterlimit limit
*    stroke-opacity opacity

    The opacity ranges from 0.0 (fully transparent) to 1.0 (fully opaque) or as a percentage (e.g. 50%).

*    stroke-width width
*    text "text"
*    text-antialias 0 • 1
*    text-undercolor color
*    translate x,y
*    use "url(#id)"
*    viewbox x,y x1,y1


/High Dynamic-range Imaging
===========================

High dynamic-range imaging (HDRI) permits a far greater dynamic range of exposures (i.e. a large difference between light and dark areas) than standard digital imaging techniques. HDRI accurately represents the wide range of intensity levels found in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows. The HDR imaging approach includes:

*   render/capture floating-point color space
*   encompass the entire perceivable gamut (extend values outside [0,1] range)
*   post-process in extended color space
*   apply tone-mapping for specific display

ImageMagick supports the Jzazbc colorspace, for applications that require wide color gamut and high dynamic range.

Enabling HDRI in ImageMagick
----------------------------

By default, image pixels in ImageMagick version 7 are stored in a floating-point representation that range from 0 to the quantum depth, which is typically 16-bits (Q16). With HDRI enabled, the pixels can include negative values as well as values that exceed the quantum depth. A majority of digital image formats do not support HDRI, and for those images any pixels outside the quantum range are clamped before they are stored.

The most promising HDR image format is EXR. You must have the [OpenEXR](http://www.openexr.org) delegate library installed to read or write this format. Other HDR formats include TIFF 48-bit integer and 96-bit float formats, HDR, PFM, and ImageMagick's own MIFF format.

To disable the HDRI version of ImageMagick, use this Linux/Linux command:

./configure --disable-hdri

Under Windows, follow the instructions (straightforward for a non-programmer) in a one hour process to build and configure your own executables: [Install from Windows Source].

To verify HDRI is properly configured, look for "HDRI" as a feature:

magick identify -version
Features: HDRI


/Encipher or Decipher an Image
==============================

[Encipher an Image] • [Decipher an Image] • [Encipher and Decipher Caveats]

Most images, by design, are made to be viewed often and by many people. Web images, for example, may be viewed hundreds of times a day by a multitude of visitors. However, in some cases, you may want to keep a particular image private so that only you or perhaps a select group of your friends or web visitors can view it. ImageMagick permits you to scramble your images such that unless someone knows your passphrase, they will be unable to view the original content.

You could use an [enciphering](https://github.com/ImageMagick/WizardsToolkit) utility to scramble your image but they typically scramble the entire file making it unrecognizable as an image format. With ImageMagick, only the pixels are scrambled. The scrambled image continues to be recognized as an image and will even display in your web page. However, the content appears as gibberish, nothing like the original content.

Encipher an Image
-----------------

Use the [-encipher] option to scramble your image so that it is unrecognizable. The option requires a filename that contains your passphrase. In this example we scramble an image and save it in the PNG format:

magick rose.jpg -encipher passphrase.txt rose.png 

Here we encipher an image using another image as the passphrase:

magick rose.jpg -encipher smiley.gif rose.png 

Decipher an Image
-----------------

Use the [-decipher] option to unscramble your image so that it is recognizable once again. The option requires a filename that contains your passphrase. In this example we unscramble an image and save it in the JPEG format:

magick rose.png -decipher passphrase.txt rose.jpg 

Encipher and Decipher Caveats
-----------------------------

Some formats do not support enciphered pixels-- the JPEG or GIF format, for example. To ensure your image format is supported, encipher a test image and verify you can restore its original content before you encipher any additional images in that format.

The image format may only support 8-bit and RGB (TrueColor). As such you may like to include the options "-depth 8 -type TrueColor" before the output filename.

The passphrase can be any combinations of letters and symbols. It should be a minimum of 12 character combinations to help ensure your image remains private. Also make sure your passphrase file permissions prevent others from reading it otherwise unintended users may be able to view the original image content.

You can only restore the original image content if you know your passphrase. If you lose or forget it, your original image content is lost forever.

ImageMagick only scrambles the image pixels. The image metadata remains untouched and readable by anyone with access to the image file.

ImageMagick uses the [AES](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) cipher in Counter mode. We use the first half of your passphrase to derive the nonce. The second half is the cipher key. When used correctly, AES-CTR provides a high level of confidentiality. To avoid information leaks, you must use a fresh passphrase for each image your encrypt.

Currently only ImageMagick can restore your enciphered image content. We use a standard cipher and mode so other vendors could support enciphered image content.

Some small practical examples of image enciphering can be found in IM Examples [Encrypting Image Data].


/Accurate Color Management
==========================

Due to the standardization of sRGB on the Internet, most image formats use SRGB as the default working color space. If the color space of an image is unknown and it is an 8- to 16-bit image format, assuming it is in the sRGB color space is a safe choice. This extends to grayscale as well. We assume non-linear grayscale. These assumptions are overridden if a particular image format includes color space and / or gamma metadata. ImageMagick assumes linear color if the color space is RGB instead of sRGB. You can also override the default color space assumptions with color profiles or the [-set] option.

ImageMagick supports color profiles, however, for images without a profile or a declaration of colorspace, ImageMagick assumes non-linear sRGB. Most image processing algorithms assume a linear colorspace, therefore it might be prudent to convert to linear color or remove the gamma function before certain image processing algorithms are applied. For example,

magick myimage.jpg -colorspace RGB -resize 200% -colorspace sRGB mybigimage.jpg

To declare that an image is linear RGB rather than sRGB, you can use the set option:

magick myimage.png -set colorspace RGB myRGBimage.png

Note that declaring an image as linear is not the same as converting the image to linear. Declaring it is linear only sets the meta data and does not change the pixel data. Whereas converting to linear actually changes the pixel data as described in more detail below.

Afterwards, the verbose information for the output file lists the colorspace as RGB. This only works on image types containing meta data that distinguishes between linear RGB and non-linear sRGB, such as PNG and GIF. Therefore, if the above command is run with a JPG or TIF output format, the verbose information for the colorspace still shows sRGB. In order to properly have the JPG output know that it is linear RGB, include an appropriate color profile.

By default, converting color images to grayscale returns non-linear gray. To instead convert to linear gray, use the [-set] or [-intensity] or [-grayscale] options:

convert myimage.png -colorspace LinearGray myRGBimage.png
convert myimage.png -colorspace RGB -colorspace Gray myRGBimage.png
convert myimage.png -intensity Rec709luminance -colorspace gray myRGBimage.png
convert myimage.png -grayscale Rec709luminance myRGBimage.png

Note that LinearGray is new as of Imagemagick 6.9.9-29 and 7.0.7-17.

The same concept is needed when separating channels. Normally, the conversion to separate each channel of an sRGB color image produces separate non-linear grayscale images. However the same concept can be applied, if it is desired to keep the separate channels as linear grayscale. For example, the following produces linear grayscale channels.

magick myimage.png -colorspace RGB -separate myimage_channels_%d.png

When separating and recombining channels, with potential intermediate processing, it is important to identify the colorspace used, especially during the recombination. For example,

magick myimage.png -separate myimage_channels_%d.png
magick myimage_channels_*.png -combine myimage2.png

In the above example, the separated channels are non-linear and the default for -combine is to assume non-linear channels. So the result is the same as the input.

If one desires to separate to linear grayscale channels, recombine them later back to non-linear color, perhaps after some processing, then use the same concept as above for maintaining linear grayscale:

magick myimage.png -set colorspace RGB -separate myimage_channels_%d.png
magick myimage_channels_*.png -set colorspace RGB -combine -colorspace sRGB myimage2.png

When converting to another colorspace and back, such as between sRGB and HSL, the following two commands handle the first case of non-linear channels and the second case of linear channels:

magick myimage.png -colorspace HSL -separate myimage_channels_%d.png
magick myimage_channels_*.png -set colorspace HSL -combine -colorspace sRGB myimage2.png

magick myimage.png -set colorspace RGB -colorspace HSL -separate myimage_channels_%d.png
magick myimage_channels_*.png -set colorspace HSL -combine -colorspace RGB -set colorspace sRGB myimage2.png

A majority of the image formats assume an sRGB colorspace (e.g. JPEG, PNG, etc.). A few support only linear RGB (e.g. EXR, DPX, CIN, HDR) or only linear GRAY. A few formats support CMYK. For example JPG does, but PNG does not. Then there is the occasional format that also supports LAB (that is CieLAB) (e.g. TIFF, PSD, JPG, JP2). For additional information, see the [Colorspace] and [Supported Formats] pages.

When specifying individual colors as rgb(...) or hex, these colors will still be interpreted as non-linear, that is, as sRGB colors. However if one wants to create linear colors, use icc-color(rgb,r,g,b)", where r, g, and b are in the range 0 to 1. See the [Color] page.


/Color Thresholding
===================

Use color thresholding to specify a color range and return a black and white image. All colors between the start and stop colors (inclusively) become white and the rest of the image pixels become black. The two colors are separated with a hyphen between them. Thresholding, by default, take place in the sRGB colorspace. Use the -colorspace to perform the thresholding in an alternative colorspaces (currently limited to sRGB, Gray, HSV, HSL, HCL, HSB, and HSW). Start and stop colors can be specified in any colorspace (recognized by ImageMagick), but in general, we advise you specify them in the colorspace corresponding to the -colorspace option. For colorspace Gray, be sure to use a start value lower than the stop value. Note that Hue is cyclical -- 0 and 360 are the same. However, a range of colors that spans hue = 0 may still be useful, if the start hue value is higher than the stop hue value.

Caution is advised when mixing the colorspace of the start and stop colors and that of the image. A large range in one colorspace may map to only a narrow range in another colorspace. For example, one might naively think that sRGB(0,0,0) to sRGB(255,255,255) would produce a white image, catching all colors, even when using -colorspace HSV. But these two colors are black and white and so map only to a range of grayscale as hsv(0,0%,0%) and hsv(0,0%,100%). For a color image, you would likely not find too many gray pixels.

To illustrate how color thresholding performs, use this image:

convert input-image -colorspace XXX -color-threshold "start - stop" output-image

The following are some typical examples of use:

![Color Thresholding](https://imagemagick.org/image/color-thresholding.jpg)

Start by choosing one sRGB color (somewhere on the image -- in this case the yellow of the flowers) and offset it low and high to form two sRGB colors. The lower values form the start color and the higher values form the stop color. Begin with sRGB(183,132,20). Offset its values by +-20 to identify the start color (-) and the stop color (+); namely, R=183+-20, G=132+-20, and B=40+-20:

magick monet.jpg -color-threshold 'sRGB(163,112,0)-sRGB(203,152,40)' monet.gif

this returns the outline of the yellow flower petals:

![Color Thresholding](https://imagemagick.org/image/color-thresholding-hsv.gif)

Now, pick two RGB colors: sRGB(159,150,0) and sRGB(205,100,45):

magick monet.jpg -color-threshold 'sRGB(159,150,0)-sRGB(205,100,45)' monet.gif

![Color Thresholding](https://imagemagick.org/image/color-thresholding-rgb.gif)

Next, select one sRGB color and convert it to HSV and offset its values low and high to generate the start and stop HSV colors. Use -colorspace HSV to convert the image to HSV. For our HSV example, we pick sRGB(183,132,20) and convert to HSV:

magick xc:"srgb(183,132,20)" -colorspace HSV txt:
# ImageMagick pixel enumeration: 1,1,65535,hsv
0,0: (41.227,89.071%,71.7647%) #1D51E405B7B7 hsv(41.227,89.071%,71.7647%)

Now, offset its HSV values as H=41+-20, S=89+-10, and V=72+-10, to create the start color (-) and stop color (+):

magick monet.jpg -colorspace HSV -color-threshold 'hsv(21,79%,62%)-hsv(61,99%,85%)' monet.gif

![Color Thresholding](https://imagemagick.org/image/color-thresholding-rgb.gif)

Next, pick two RGB colors. Use -colorspace HSV to convert the image to HSV, and apply the RGB start and stop colors.  Choose sRGB(158,77,33) and sRGB(213,217,2):

magick monet.jpg -colorspace HSV -color-threshold "sRGB(158,77,33)-sRGB(213,217,2)" monet.gif

Here is the expected results:

![Color Thresholding](https://imagemagick.org/image/color-thresholding-hsv-rgb.gif)

Next, choose two sRGB colors and convert them to gray. Now convert the image to gray and use the gray thresholding colors.

    magick xc:"sRGB(159,150,0)" -colorspace gray txt:
    # ImageMagick pixel enumeration: 1,1,65535,gray
    0,0: (36259.1) #8DA38DA38DA3 gray(55.3278%)

    magick xc:"sRGB(205,100,45)" -colorspace gray txt:
    # ImageMagick pixel enumeration: 1,1,65535,gray
    0,0: (30418.2) #76D276D276D2 gray(46.4152%)

Notice that the start intensity must be smaller than stop intensity:

magick monet.jpg -colorspace gray -color-threshold 'gray(46.4152%)-gray(55.3278%)' monet.gif

Here is the results of the color thresholding operation:

![Color Thresholding](https://imagemagick.org/image/color-thresholding-gray.gif)


/Color Names
============

A number of ImageMagick options and methods take a color as an argument. The color can then be given as a color name (there is a limited but large set of these; see below) or it can be given as a set of numbers (in decimal or hexadecimal), each corresponding to a channel in an RGB or RGBA color model. HSL, HSLA, HSB, HSBA, CMYK, or CMYKA color models may also be specified. These topics are briefly described in the sections below.

Use the [Color Converter] to supply any valid ImageMagick color specification as described below to see a color swatch of that color and to convert to all the other color models.

Example Usage
-------------

Each of the following commands produces the same lime border around the image. (Use "double quotes" for Windows.)

    magick -bordercolor lime -border 10 image.jpg image.png
    magick -bordercolor '#0f0' -border 10 image.jpg image.png
    magick -bordercolor '#00ff00' -border 10 image.jpg image.png
    magick -bordercolor 'rgb(0,255,0)' -border 10 image.jpg image.png
    magick -bordercolor 'rgb(0,100%,0)' -border 10 image.jpg image.png

The list of recognized color names (for example, aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow, and others) is shown in a table further below.

Color Model Specification
-------------------------

The sRGB, CMYK, HSL and HSB color models are used in numerical color specifications. These examples all specify the same red sRGB color:

    #f00                      #rgb
    #ff0000                   #rrggbb
    #ff0000ff                 #rrggbbaa
    #ffff00000000             #rrrrggggbbbb
    #ffff00000000ffff         #rrrrggggbbbbaaaa
    rgb(255, 0, 0)            an integer in the range 0—255 for each component
    rgb(100.0%, 0.0%, 0.0%)   a float in the range 0—100% for each component

The format of an sRGB value in hexadecimal notation is a '#' immediately followed by either three, six, or twelve hexadecimal characters. The three-digit sRGB notation (#rgb) is converted into six-digit form (#rrggbb) by replicating digits, not by adding zeros. For example, #fb0 expands to #ffbb00. This ensures that white (#ffffff) can be specified with the short notation (#fff) and removes any dependencies on the color depth of the image. Use the hexadecimal notation whenever performance is an issue. ImageMagick does not need to load the expansive color table to interpret a hexadecimal color, e.g., #000000, but it does if black is used instead.

The format of an sRGB value in the functional notation is 'rgb(r,g,b)', where r, g, and b are either three integer or float values in the range 0—255 or three integer or float percentage values in the range 0—100%. The value 255 corresponds to 100%, and to #F or #FF in the hexadecimal notation: rgb(255, 255, 255) = rgb(100%, 100%, 100%) = #FFF = #FFFFFF. Note, as of ImageMagick 7.0.10-53, the commas are no longer necessary and the slash can proceed the alpha value, e.g. rgb(255 128 0 / 50%).

White space characters are allowed around the numerical values, at least if the entire color argument is enclosed in quotes ('single quotes' for Linux-like systems, "double quotes" for Windows).

The sRGB color model is extended in this specification to include alpha to allow specification of the transparency of a color. These examples all specify the same color:

    rgb(255, 0, 0)                 range 0 - 255
    rgba(255, 0, 0, 1.0)           the same, with an explicit alpha value
    rgb(100%, 0%, 0%)              range 0.0% - 100.0%
    rgba(100%, 0%, 0%, 1.0)        the same, with an explicit alpha value

The format of an RGBA value in the functional notation is 'rgba(r,g,b,a)', where r, g, and b are as described above for the RGB functional notation, and where the alpha value a ranges from 0.0 (fully transparent) to 1.0 (fully opaque).

There is also a color called 'none' that is fully transparent. This color is shorthand for rgba(0, 0, 0, 0.0).

Non-linear gray values are conveniently defined with a name, single intensity value or an intensity value and an alpha value:

    gray50            near mid gray
    gray(127)         near mid gray
    gray(50%)         mid gray
    graya(50%, 0.5)   semi-transparent mid gray

For linear gray values add -colorspace RGB -colorspace Gray or -colorspace LinearGray when creating gray colors. The latter is new as of Imagemagick 6.9.9-29 and 7.0.7-17.

The ImageMagick color model also supports hue-saturation-lightness (HSL) and hue-saturation-brightness (HSB) colors as a complement to numerical sRGB colors. HSL colors are encoding as a triple (hue, saturation, lightness). Likewise HSB colors are encoding as a triple (hue, saturation, brightness). HSL or HSB triples are either direct values (hue 0—360, saturation 0—255, lightness or brightness 0—255) or with S,L,B as percentage values relative to these ranges.

The HSB color system is geometrically represented as a cone with its apex pointing downward. Hue is measured around the perimeter. Saturation is measured from the axis outward. Brightness is measured from the apex upward.

The HSL color system is geometrically represented as a stacked double cone with one apex pointing downward and the other pointing upward. The widest ends of both cones are stacked together one on top of the other. Hue is measured around the perimeter. Saturation is measured from the axis outward. Lightness is measured from the bottom apex upward.

See [http://en.wikipedia.org/wiki/HSL_and_HSV](http://en.wikipedia.org/wiki/HSL_and_HSV) for more details on HSL and HSB color systems.

Hue is represented as an angle of the color around the circular perimeter of the cone(s) (i.e. the rainbow represented in a circle). Hue values are integers or floats in the range 0—360. By definition red=0=360, and the other colors are spread around the circle, so green=120, blue=240, etc. As an angle, it implicitly wraps around such that -120=240 and 480=120, for instance. (Students of trigonometry would say that "coterminal angles are equivalent" here; an angle θ can be standardized by computing the equivalent angle, θ mod 360.)

Saturation is measure outward from the central axis of the cone(s) toward the perimeter of the cone(s). Saturation may be expressed as an integer or float in the range 0—255 or as an integer or float percentage in the range 0—100. Saturation may be thought of as the absence of any "white" mixed with the base color. Thus 255 or 100% is full saturation and corresponds to a point on the outside surface of the cone (HSB) or double cone (HSL). It will be the most "colorful" region. 0 or 0% is no saturation which results in some shade of gray. It occurs along the central axis of the cone or double cone with black at the bottom apex and white at the top.

Brightness and Lightness also may be represented as integers or floats in the range 0—255 or as integer or float percentages in the range 0—100%. Brightness and Lightness are measured from the bottom apex upward to the top of the cone or double cone along the cone(s) central axis. 0 or 0% corresponds to the bottom apex and 255 or 100% corresponds to the top center of the cone for Brightness and to the top apex of the double cone for Lightness.

The HSB color system is a little easier to understand than the HSL color system. In the HSB color system, black is at the bottom apex and white is at the top center of the cone on the central axis. The most colorful or saturated colors will then be at the outer edge of the top of the cone at the widest part. Thus at Saturation=100% and Brightness=100%

    hsb(0,   100%,  100%)    or    hsb(0,   255,   255)       full red
    hsb(120, 100%,  100%)    or    hsb(120, 255,   255)       full green
    hsb(120, 100%,  75%)     or    hsb(120, 255,   191.25)    medium green
    hsb(120, 100%,  50%)     or    hsb(120, 255,   127.5)     dark green
    hsb(120, 100%,  25%)     or    hsb(120, 255,   63.75)     very dark green
    hsb(120, 50%,   50%)     or    hsb(120, 127.5, 127.5)     pastel green

In the HSL color system, black is at the bottom apex and white is at the top apex. However, saturation is largest at the middle of the double cone on its outer perimeter and thus at a lightness value of 50%. The most colorful or saturated colors will then be at the outer edge of the double cone at its widest part. Thus at Saturation=100% and Brightness=50%

    hsl(0,   100%,  50%)     or    hsl(0,   255,   127.5)     full red
    hsl(120, 100%,  100%)    or    hsl(120, 255,   255)       white
    hsl(120, 100%,  75%)     or    hsl(120, 255,   191.25)    pastel green
    hsl(120, 100%,  50%)     or    hsl(120, 255,   127.5)     full green
    hsl(120, 100%,  25%)     or    hsl(120, 255,   63.75)     dark green
    hsl(120, 50%,   50%)     or    hsl(120, 127.5, 127.5)     medium green

One advantage of HSB or HSL over RGB is that it can be more intuitive: you can guess at the colors you want, and then tweak. It is also easier to create sets of matching colors (by keeping the hue the same and varying the brightness or lightness and saturation, for example).

Just as the 'rgb()' functional notation has the 'rgba()' alpha counterpart, the 'hsl()' and 'hsb()' functional notations have their 'hsla()' 'hsba()' alpha counterparts. These examples specify the same color:

    hsb(120, 100%,  100%)              full green in hsb
    hsba(120, 100%,  100%,  1.0)       the same, with an alpha value of 1.0
    hsb(120, 255,  255)                full green in hsb
    hsba(120, 255,  255,  1.0)         the same, with an alpha value of 1.0

    hsl(120, 100%,  50%)               full green in hsl
    hsla(120, 100%,  50%,  1.0)        the same, with an alpha value of 1.0
    hsl(120, 255,  127.5)              full green in hsl
    hsla(120, 255,  127.5,  1.0)       the same, with an alpha value of 1.0

For ImageMagick between 6.5.6-6 and 6.9.2-0, HSL (HSB) could only be specified with Hue as percent in range 0—100%, when Saturation and Lightness (Brightness) were also specified as percent in range 0—100%.

Specify the Lab colors like this:

    cielab(62.253188, 23.950124, 48.410653)

Note, the a and b components of any Lab color you specify are biased internally by 50% to ensure it fits in the quantum range (typically 0 to 65535). The bias is retained when writing to the TIFF and MIFF image formats. However, the TXT format supports negative pixel values so the bias is removed when writing to this format:

```sh
$ magick xc:cyan -colorspace LAB txt:
# ImageMagick pixel enumeration: 1,1,65535,cielab
0,0: (59711,20409.5,-3632.9)  #E93F4FBA71CF  cielab(91.1132,-48.0855,-14.1358)

$ magick -size 100x100 xc:"cielab(91.1132,-48.0855,-14.1358)" -colorspace sRGB cyan.png
```

Or specify colors generically with the icc-color keyword, for example:

    icc-color(cmyk, 0.11, 0.48, 0.83, 0.00)  cymk
    icc-color(rgb, 1, 0, 0)                  linear rgb
    icc-color(rgb, red)                      linear rgb
    icc-color(lineargray, 0.5)               linear gray
    icc-color(srgb, 1, 0, 0)                 non-linear rgb
    icc-color(srgb, red)                     non-linear rgb
    icc-color(gray, 0.5)                     non-linear gray

Or specify uncalibrated device colors with the device- keyword, for example:

    device-gray(0.5)
    device-rgb(0.5, 1.0, 0.0)
    device-cmyk(0.11, 0.48, 0.83, 0.00)

ImageMagick also supports wide-gamut color such as Lab, LCH, and Display-P3.

List of Color Names
-------------------

The table below provides a list of named colors recognized by ImageMagick:

|         Name         |          Color          |         RGB         |    Hex    |
|----------------------|-------------------------|---------------------|-----------|
| snow                 | snow                    | rgb(255, 250, 250)  | #FFFAFA   |
| snow1                | snow1                   | rgb(255, 250, 250)  | #FFFAFA   |
| snow2                | snow2                   | rgb(238, 233, 233)  | #EEE9E9   |
| RosyBrown1           | RosyBrown1              | rgb(255, 193, 193)  | #FFC1C1   |
| RosyBrown2           | RosyBrown2              | rgb(238, 180, 180)  | #EEB4B4   |
| snow3                | snow3                   | rgb(205, 201, 201)  | #CDC9C9   |
| LightCoral           | LightCoral              | rgb(240, 128, 128)  | #F08080   |
| IndianRed1           | IndianRed1              | rgb(255, 106, 106)  | #FF6A6A   |
| RosyBrown3           | RosyBrown3              | rgb(205, 155, 155)  | #CD9B9B   |
| IndianRed2           | IndianRed2              | rgb(238, 99, 99)    | #EE6363   |
| RosyBrown            | RosyBrown               | rgb(188, 143, 143)  | #BC8F8F   |
| brown1               | brown1                  | rgb(255, 64, 64)    | #FF4040   |
| firebrick1           | firebrick1              | rgb(255, 48, 48)    | #FF3030   |
| brown2               | brown2                  | rgb(238, 59, 59)    | #EE3B3B   |
| IndianRed            | IndianRed               | rgb(205, 92, 92)    | #CD5C5C   |
| IndianRed3           | IndianRed3              | rgb(205, 85, 85)    | #CD5555   |
| firebrick2           | firebrick2              | rgb(238, 44, 44)    | #EE2C2C   |
| snow4                | snow4                   | rgb(139, 137, 137)  | #8B8989   |
| brown3               | brown3                  | rgb(205, 51, 51)    | #CD3333   |
| red                  | red                     | rgb(255, 0, 0)      | #FF0000   |
| red1                 | red1                    | rgb(255, 0, 0)      | #FF0000   |
| RosyBrown4           | RosyBrown4              | rgb(139, 105, 105)  | #8B6969   |
| firebrick3           | firebrick3              | rgb(205, 38, 38)    | #CD2626   |
| red2                 | red2                    | rgb(238, 0, 0)      | #EE0000   |
| firebrick            | firebrick               | rgb(178, 34, 34)    | #B22222   |
| brown                | brown                   | rgb(165, 42, 42)    | #A52A2A   |
| red3                 | red3                    | rgb(205, 0, 0)      | #CD0000   |
| IndianRed4           | IndianRed4              | rgb(139, 58, 58)    | #8B3A3A   |
| brown4               | brown4                  | rgb(139, 35, 35)    | #8B2323   |
| firebrick4           | firebrick4              | rgb(139, 26, 26)    | #8B1A1A   |
| DarkRed              | DarkRed                 | rgb(139, 0, 0)      | #8B0000   |
| red4                 | red4                    | rgb(139, 0, 0)      | #8B0000   |
| maroon               | maroon (SVG compliance) | rgb(128, 0, 0)      | #800000   |
| LightPink1           | LightPink1              | rgb(255, 174, 185)  | #FFAEB9   |
| LightPink3           | LightPink3              | rgb(205, 140, 149)  | #CD8C95   |
| LightPink4           | LightPink4              | rgb(139, 95, 101)   | #8B5F65   |
| LightPink2           | LightPink2              | rgb(238, 162, 173)  | #EEA2AD   |
| LightPink            | LightPink               | rgb(255, 182, 193)  | #FFB6C1   |
| pink                 | pink                    | rgb(255, 192, 203)  | #FFC0CB   |
| crimson              | crimson                 | rgb(220, 20, 60)    | #DC143C   |
| pink1                | pink1                   | rgb(255, 181, 197)  | #FFB5C5   |
| pink2                | pink2                   | rgb(238, 169, 184)  | #EEA9B8   |
| pink3                | pink3                   | rgb(205, 145, 158)  | #CD919E   |
| pink4                | pink4                   | rgb(139, 99, 108)   | #8B636C   |
| PaleVioletRed4       | PaleVioletRed4          | rgb(139, 71, 93)    | #8B475D   |
| PaleVioletRed        | PaleVioletRed           | rgb(219, 112, 147)  | #DB7093   |
| PaleVioletRed2       | PaleVioletRed2          | rgb(238, 121, 159)  | #EE799F   |
| PaleVioletRed1       | PaleVioletRed1          | rgb(255, 130, 171)  | #FF82AB   |
| PaleVioletRed3       | PaleVioletRed3          | rgb(205, 104, 137)  | #CD6889   |
| LavenderBlush        | LavenderBlush           | rgb(255, 240, 245)  | #FFF0F5   |
| LavenderBlush1       | LavenderBlush1          | rgb(255, 240, 245)  | #FFF0F5   |
| LavenderBlush3       | LavenderBlush3          | rgb(205, 193, 197)  | #CDC1C5   |
| LavenderBlush2       | LavenderBlush2          | rgb(238, 224, 229)  | #EEE0E5   |
| LavenderBlush4       | LavenderBlush4          | rgb(139, 131, 134)  | #8B8386   |
| maroon               | maroon (X11 compliance) | rgb(176, 48, 96)    | #B03060   |
| HotPink3             | HotPink3                | rgb(205, 96, 144)   | #CD6090   |
| VioletRed3           | VioletRed3              | rgb(205, 50, 120)   | #CD3278   |
| VioletRed1           | VioletRed1              | rgb(255, 62, 150)   | #FF3E96   |
| VioletRed2           | VioletRed2              | rgb(238, 58, 140)   | #EE3A8C   |
| VioletRed4           | VioletRed4              | rgb(139, 34, 82)    | #8B2252   |
| HotPink2             | HotPink2                | rgb(238, 106, 167)  | #EE6AA7   |
| HotPink1             | HotPink1                | rgb(255, 110, 180)  | #FF6EB4   |
| HotPink4             | HotPink4                | rgb(139, 58, 98)    | #8B3A62   |
| HotPink              | HotPink                 | rgb(255, 105, 180)  | #FF69B4   |
| DeepPink             | DeepPink                | rgb(255, 20, 147)   | #FF1493   |
| DeepPink1            | DeepPink1               | rgb(255, 20, 147)   | #FF1493   |
| DeepPink2            | DeepPink2               | rgb(238, 18, 137)   | #EE1289   |
| DeepPink3            | DeepPink3               | rgb(205, 16, 118)   | #CD1076   |
| DeepPink4            | DeepPink4               | rgb(139, 10, 80)    | #8B0A50   |
| maroon1              | maroon1                 | rgb(255, 52, 179)   | #FF34B3   |
| maroon2              | maroon2                 | rgb(238, 48, 167)   | #EE30A7   |
| maroon3              | maroon3                 | rgb(205, 41, 144)   | #CD2990   |
| maroon4              | maroon4                 | rgb(139, 28, 98)    | #8B1C62   |
| MediumVioletRed      | MediumVioletRed         | rgb(199, 21, 133)   | #C71585   |
| VioletRed            | VioletRed               | rgb(208, 32, 144)   | #D02090   |
| orchid2              | orchid2                 | rgb(238, 122, 233)  | #EE7AE9   |
| orchid               | orchid                  | rgb(218, 112, 214)  | #DA70D6   |
| orchid1              | orchid1                 | rgb(255, 131, 250)  | #FF83FA   |
| orchid3              | orchid3                 | rgb(205, 105, 201)  | #CD69C9   |
| orchid4              | orchid4                 | rgb(139, 71, 137)   | #8B4789   |
| thistle1             | thistle1                | rgb(255, 225, 255)  | #FFE1FF   |
| thistle2             | thistle2                | rgb(238, 210, 238)  | #EED2EE   |
| plum1                | plum1                   | rgb(255, 187, 255)  | #FFBBFF   |
| plum2                | plum2                   | rgb(238, 174, 238)  | #EEAEEE   |
| thistle              | thistle                 | rgb(216, 191, 216)  | #D8BFD8   |
| thistle3             | thistle3                | rgb(205, 181, 205)  | #CDB5CD   |
| plum                 | plum                    | rgb(221, 160, 221)  | #DDA0DD   |
| violet               | violet                  | rgb(238, 130, 238)  | #EE82EE   |
| plum3                | plum3                   | rgb(205, 150, 205)  | #CD96CD   |
| thistle4             | thistle4                | rgb(139, 123, 139)  | #8B7B8B   |
| fuchsia              | fuchsia                 | rgb(255, 0, 255)    | #FF00FF   |
| magenta              | magenta                 | rgb(255, 0, 255)    | #FF00FF   |
| magenta1             | magenta1                | rgb(255, 0, 255)    | #FF00FF   |
| plum4                | plum4                   | rgb(139, 102, 139)  | #8B668B   |
| magenta2             | magenta2                | rgb(238, 0, 238)    | #EE00EE   |
| magenta3             | magenta3                | rgb(205, 0, 205)    | #CD00CD   |
| DarkMagenta          | DarkMagenta             | rgb(139, 0, 139)    | #8B008B   |
| magenta4             | magenta4                | rgb(139, 0, 139)    | #8B008B   |
| purple               | purple (SVG compliance) | rgb(128, 0, 128)    | #800080   |
| MediumOrchid         | MediumOrchid            | rgb(186, 85, 211)   | #BA55D3   |
| MediumOrchid1        | MediumOrchid1           | rgb(224, 102, 255)  | #E066FF   |
| MediumOrchid2        | MediumOrchid2           | rgb(209, 95, 238)   | #D15FEE   |
| MediumOrchid3        | MediumOrchid3           | rgb(180, 82, 205)   | #B452CD   |
| MediumOrchid4        | MediumOrchid4           | rgb(122, 55, 139)   | #7A378B   |
| DarkViolet           | DarkViolet              | rgb(148, 0, 211)    | #9400D3   |
| DarkOrchid           | DarkOrchid              | rgb(153, 50, 204)   | #9932CC   |
| DarkOrchid1          | DarkOrchid1             | rgb(191, 62, 255)   | #BF3EFF   |
| DarkOrchid3          | DarkOrchid3             | rgb(154, 50, 205)   | #9A32CD   |
| DarkOrchid2          | DarkOrchid2             | rgb(178, 58, 238)   | #B23AEE   |
| DarkOrchid4          | DarkOrchid4             | rgb(104, 34, 139)   | #68228B   |
| purple               | purple (X11 compliance) | rgb(160, 32, 240)   | #A020F0   |
| indigo               | indigo                  | rgb( 75, 0, 130)    | #4B0082   |
| BlueViolet           | BlueViolet              | rgb(138, 43, 226)   | #8A2BE2   |
| purple2              | purple2                 | rgb(145, 44, 238)   | #912CEE   |
| purple3              | purple3                 | rgb(125, 38, 205)   | #7D26CD   |
| purple4              | purple4                 | rgb( 85, 26, 139)   | #551A8B   |
| purple1              | purple1                 | rgb(155, 48, 255)   | #9B30FF   |
| MediumPurple         | MediumPurple            | rgb(147, 112, 219)  | #9370DB   |
| MediumPurple1        | MediumPurple1           | rgb(171, 130, 255)  | #AB82FF   |
| MediumPurple2        | MediumPurple2           | rgb(159, 121, 238)  | #9F79EE   |
| MediumPurple3        | MediumPurple3           | rgb(137, 104, 205)  | #8968CD   |
| MediumPurple4        | MediumPurple4           | rgb( 93, 71, 139)   | #5D478B   |
| DarkSlateBlue        | DarkSlateBlue           | rgb( 72, 61, 139)   | #483D8B   |
| LightSlateBlue       | LightSlateBlue          | rgb(132, 112, 255)  | #8470FF   |
| MediumSlateBlue      | MediumSlateBlue         | rgb(123, 104, 238)  | #7B68EE   |
| SlateBlue            | SlateBlue               | rgb(106, 90, 205)   | #6A5ACD   |
| SlateBlue1           | SlateBlue1              | rgb(131, 111, 255)  | #836FFF   |
| SlateBlue2           | SlateBlue2              | rgb(122, 103, 238)  | #7A67EE   |
| SlateBlue3           | SlateBlue3              | rgb(105, 89, 205)   | #6959CD   |
| SlateBlue4           | SlateBlue4              | rgb( 71, 60, 139)   | #473C8B   |
| GhostWhite           | GhostWhite              | rgb(248, 248, 255)  | #F8F8FF   |
| lavender             | lavender                | rgb(230, 230, 250)  | #E6E6FA   |
| blue                 | blue                    | rgb( 0, 0, 255)     | #0000FF   |
| blue1                | blue1                   | rgb( 0, 0, 255)     | #0000FF   |
| blue2                | blue2                   | rgb( 0, 0, 238)     | #0000EE   |
| blue3                | blue3                   | rgb( 0, 0, 205)     | #0000CD   |
| MediumBlue           | MediumBlue              | rgb( 0, 0, 205)     | #0000CD   |
| blue4                | blue4                   | rgb( 0, 0, 139)     | #00008B   |
| DarkBlue             | DarkBlue                | rgb( 0, 0, 139)     | #00008B   |
| MidnightBlue         | MidnightBlue            | rgb( 25, 25, 112)   | #191970   |
| navy                 | navy                    | rgb( 0, 0, 128)     | #000080   |
| NavyBlue             | NavyBlue                | rgb( 0, 0, 128)     | #000080   |
| RoyalBlue            | RoyalBlue               | rgb( 65, 105, 225)  | #4169E1   |
| RoyalBlue1           | RoyalBlue1              | rgb( 72, 118, 255)  | #4876FF   |
| RoyalBlue2           | RoyalBlue2              | rgb( 67, 110, 238)  | #436EEE   |
| RoyalBlue3           | RoyalBlue3              | rgb( 58, 95, 205)   | #3A5FCD   |
| RoyalBlue4           | RoyalBlue4              | rgb( 39, 64, 139)   | #27408B   |
| CornflowerBlue       | CornflowerBlue          | rgb(100, 149, 237)  | #6495ED   |
| LightSteelBlue       | LightSteelBlue          | rgb(176, 196, 222)  | #B0C4DE   |
| LightSteelBlue1      | LightSteelBlue1         | rgb(202, 225, 255)  | #CAE1FF   |
| LightSteelBlue2      | LightSteelBlue2         | rgb(188, 210, 238)  | #BCD2EE   |
| LightSteelBlue3      | LightSteelBlue3         | rgb(162, 181, 205)  | #A2B5CD   |
| LightSteelBlue4      | LightSteelBlue4         | rgb(110, 123, 139)  | #6E7B8B   |
| SlateGray4           | SlateGray4              | rgb(108, 123, 139)  | #6C7B8B   |
| SlateGray1           | SlateGray1              | rgb(198, 226, 255)  | #C6E2FF   |
| SlateGray2           | SlateGray2              | rgb(185, 211, 238)  | #B9D3EE   |
| SlateGray3           | SlateGray3              | rgb(159, 182, 205)  | #9FB6CD   |
| LightSlateGray       | LightSlateGray          | rgb(119, 136, 153)  | #778899   |
| LightSlateGrey       | LightSlateGrey          | rgb(119, 136, 153)  | #778899   |
| SlateGray            | SlateGray               | rgb(112, 128, 144)  | #708090   |
| SlateGrey            | SlateGrey               | rgb(112, 128, 144)  | #708090   |
| DodgerBlue           | DodgerBlue              | rgb( 30, 144, 255)  | #1E90FF   |
| DodgerBlue1          | DodgerBlue1             | rgb( 30, 144, 255)  | #1E90FF   |
| DodgerBlue2          | DodgerBlue2             | rgb( 28, 134, 238)  | #1C86EE   |
| DodgerBlue4          | DodgerBlue4             | rgb( 16, 78, 139)   | #104E8B   |
| DodgerBlue3          | DodgerBlue3             | rgb( 24, 116, 205)  | #1874CD   |
| AliceBlue            | AliceBlue               | rgb(240, 248, 255)  | #F0F8FF   |
| SteelBlue4           | SteelBlue4              | rgb( 54, 100, 139)  | #36648B   |
| SteelBlue            | SteelBlue               | rgb( 70, 130, 180)  | #4682B4   |
| SteelBlue1           | SteelBlue1              | rgb( 99, 184, 255)  | #63B8FF   |
| SteelBlue2           | SteelBlue2              | rgb( 92, 172, 238)  | #5CACEE   |
| SteelBlue3           | SteelBlue3              | rgb( 79, 148, 205)  | #4F94CD   |
| SkyBlue4             | SkyBlue4                | rgb( 74, 112, 139)  | #4A708B   |
| SkyBlue1             | SkyBlue1                | rgb(135, 206, 255)  | #87CEFF   |
| SkyBlue2             | SkyBlue2                | rgb(126, 192, 238)  | #7EC0EE   |
| SkyBlue3             | SkyBlue3                | rgb(108, 166, 205)  | #6CA6CD   |
| LightSkyBlue         | LightSkyBlue            | rgb(135, 206, 250)  | #87CEFA   |
| LightSkyBlue4        | LightSkyBlue4           | rgb( 96, 123, 139)  | #607B8B   |
| LightSkyBlue1        | LightSkyBlue1           | rgb(176, 226, 255)  | #B0E2FF   |
| LightSkyBlue2        | LightSkyBlue2           | rgb(164, 211, 238)  | #A4D3EE   |
| LightSkyBlue3        | LightSkyBlue3           | rgb(141, 182, 205)  | #8DB6CD   |
| SkyBlue              | SkyBlue                 | rgb(135, 206, 235)  | #87CEEB   |
| LightBlue3           | LightBlue3              | rgb(154, 192, 205)  | #9AC0CD   |
| DeepSkyBlue          | DeepSkyBlue             | rgb( 0, 191, 255)   | #00BFFF   |
| DeepSkyBlue1         | DeepSkyBlue1            | rgb( 0, 191, 255)   | #00BFFF   |
| DeepSkyBlue2         | DeepSkyBlue2            | rgb( 0, 178, 238)   | #00B2EE   |
| DeepSkyBlue4         | DeepSkyBlue4            | rgb( 0, 104, 139)   | #00688B   |
| DeepSkyBlue3         | DeepSkyBlue3            | rgb( 0, 154, 205)   | #009ACD   |
| LightBlue1           | LightBlue1              | rgb(191, 239, 255)  | #BFEFFF   |
| LightBlue2           | LightBlue2              | rgb(178, 223, 238)  | #B2DFEE   |
| LightBlue            | LightBlue               | rgb(173, 216, 230)  | #ADD8E6   |
| LightBlue4           | LightBlue4              | rgb(104, 131, 139)  | #68838B   |
| PowderBlue           | PowderBlue              | rgb(176, 224, 230)  | #B0E0E6   |
| CadetBlue1           | CadetBlue1              | rgb(152, 245, 255)  | #98F5FF   |
| CadetBlue2           | CadetBlue2              | rgb(142, 229, 238)  | #8EE5EE   |
| CadetBlue3           | CadetBlue3              | rgb(122, 197, 205)  | #7AC5CD   |
| CadetBlue4           | CadetBlue4              | rgb( 83, 134, 139)  | #53868B   |
| turquoise1           | turquoise1              | rgb( 0, 245, 255)   | #00F5FF   |
| turquoise2           | turquoise2              | rgb( 0, 229, 238)   | #00E5EE   |
| turquoise3           | turquoise3              | rgb( 0, 197, 205)   | #00C5CD   |
| turquoise4           | turquoise4              | rgb( 0, 134, 139)   | #00868B   |
| cadet blue           | cadet blue              | rgb( 95, 158, 160)  | #5F9EA0   |
| CadetBlue            | CadetBlue               | rgb( 95, 158, 160)  | #5F9EA0   |
| DarkTurquoise        | DarkTurquoise           | rgb( 0, 206, 209)   | #00CED1   |
| azure                | azure                   | rgb(240, 255, 255)  | #F0FFFF   |
| azure1               | azure1                  | rgb(240, 255, 255)  | #F0FFFF   |
| LightCyan            | LightCyan               | rgb(224, 255, 255)  | #E0FFFF   |
| LightCyan1           | LightCyan1              | rgb(224, 255, 255)  | #E0FFFF   |
| azure2               | azure2                  | rgb(224, 238, 238)  | #E0EEEE   |
| LightCyan2           | LightCyan2              | rgb(209, 238, 238)  | #D1EEEE   |
| PaleTurquoise1       | PaleTurquoise1          | rgb(187, 255, 255)  | #BBFFFF   |
| PaleTurquoise        | PaleTurquoise           | rgb(175, 238, 238)  | #AFEEEE   |
| PaleTurquoise2       | PaleTurquoise2          | rgb(174, 238, 238)  | #AEEEEE   |
| DarkSlateGray1       | DarkSlateGray1          | rgb(151, 255, 255)  | #97FFFF   |
| azure3               | azure3                  | rgb(193, 205, 205)  | #C1CDCD   |
| LightCyan3           | LightCyan3              | rgb(180, 205, 205)  | #B4CDCD   |
| DarkSlateGray2       | DarkSlateGray2          | rgb(141, 238, 238)  | #8DEEEE   |
| PaleTurquoise3       | PaleTurquoise3          | rgb(150, 205, 205)  | #96CDCD   |
| DarkSlateGray3       | DarkSlateGray3          | rgb(121, 205, 205)  | #79CDCD   |
| azure4               | azure4                  | rgb(131, 139, 139)  | #838B8B   |
| LightCyan4           | LightCyan4              | rgb(122, 139, 139)  | #7A8B8B   |
| aqua                 | aqua                    | rgb( 0, 255, 255)   | #00FFFF   |
| cyan                 | cyan                    | rgb( 0, 255, 255)   | #00FFFF   |
| cyan1                | cyan1                   | rgb( 0, 255, 255)   | #00FFFF   |
| PaleTurquoise4       | PaleTurquoise4          | rgb(102, 139, 139)  | #668B8B   |
| cyan2                | cyan2                   | rgb( 0, 238, 238)   | #00EEEE   |
| DarkSlateGray4       | DarkSlateGray4          | rgb( 82, 139, 139)  | #528B8B   |
| cyan3                | cyan3                   | rgb( 0, 205, 205)   | #00CDCD   |
| cyan4                | cyan4                   | rgb( 0, 139, 139)   | #008B8B   |
| DarkCyan             | DarkCyan                | rgb( 0, 139, 139)   | #008B8B   |
| teal                 | teal                    | rgb( 0, 128, 128)   | #008080   |
| DarkSlateGray        | DarkSlateGray           | rgb( 47, 79, 79)    | #2F4F4F   |
| DarkSlateGrey        | DarkSlateGrey           | rgb( 47, 79, 79)    | #2F4F4F   |
| MediumTurquoise      | MediumTurquoise         | rgb( 72, 209, 204)  | #48D1CC   |
| LightSeaGreen        | LightSeaGreen           | rgb( 32, 178, 170)  | #20B2AA   |
| turquoise            | turquoise               | rgb( 64, 224, 208)  | #40E0D0   |
| aquamarine4          | aquamarine4             | rgb( 69, 139, 116)  | #458B74   |
| aquamarine           | aquamarine              | rgb(127, 255, 212)  | #7FFFD4   |
| aquamarine1          | aquamarine1             | rgb(127, 255, 212)  | #7FFFD4   |
| aquamarine2          | aquamarine2             | rgb(118, 238, 198)  | #76EEC6   |
| aquamarine3          | aquamarine3             | rgb(102, 205, 170)  | #66CDAA   |
| MediumAquamarine     | MediumAquamarine        | rgb(102, 205, 170)  | #66CDAA   |
| MediumSpringGreen    | MediumSpringGreen       | rgb( 0, 250, 154)   | #00FA9A   |
| MintCream            | MintCream               | rgb(245, 255, 250)  | #F5FFFA   |
| SpringGreen          | SpringGreen             | rgb( 0, 255, 127)   | #00FF7F   |
| SpringGreen1         | SpringGreen1            | rgb( 0, 255, 127)   | #00FF7F   |
| SpringGreen2         | SpringGreen2            | rgb( 0, 238, 118)   | #00EE76   |
| SpringGreen3         | SpringGreen3            | rgb( 0, 205, 102)   | #00CD66   |
| SpringGreen4         | SpringGreen4            | rgb( 0, 139, 69)    | #008B45   |
| MediumSeaGreen       | MediumSeaGreen          | rgb( 60, 179, 113)  | #3CB371   |
| SeaGreen             | SeaGreen                | rgb( 46, 139, 87)   | #2E8B57   |
| SeaGreen3            | SeaGreen3               | rgb( 67, 205, 128)  | #43CD80   |
| SeaGreen1            | SeaGreen1               | rgb( 84, 255, 159)  | #54FF9F   |
| SeaGreen4            | SeaGreen4               | rgb( 46, 139, 87)   | #2E8B57   |
| SeaGreen2            | SeaGreen2               | rgb( 78, 238, 148)  | #4EEE94   |
| MediumForestGreen    | MediumForestGreen       | rgb( 50, 129, 75)   | #32814B   |
| honeydew             | honeydew                | rgb(240, 255, 240)  | #F0FFF0   |
| honeydew1            | honeydew1               | rgb(240, 255, 240)  | #F0FFF0   |
| honeydew2            | honeydew2               | rgb(224, 238, 224)  | #E0EEE0   |
| DarkSeaGreen1        | DarkSeaGreen1           | rgb(193, 255, 193)  | #C1FFC1   |
| DarkSeaGreen2        | DarkSeaGreen2           | rgb(180, 238, 180)  | #B4EEB4   |
| PaleGreen1           | PaleGreen1              | rgb(154, 255, 154)  | #9AFF9A   |
| PaleGreen            | PaleGreen               | rgb(152, 251, 152)  | #98FB98   |
| honeydew3            | honeydew3               | rgb(193, 205, 193)  | #C1CDC1   |
| LightGreen           | LightGreen              | rgb(144, 238, 144)  | #90EE90   |
| PaleGreen2           | PaleGreen2              | rgb(144, 238, 144)  | #90EE90   |
| DarkSeaGreen3        | DarkSeaGreen3           | rgb(155, 205, 155)  | #9BCD9B   |
| DarkSeaGreen         | DarkSeaGreen            | rgb(143, 188, 143)  | #8FBC8F   |
| PaleGreen3           | PaleGreen3              | rgb(124, 205, 124)  | #7CCD7C   |
| honeydew4            | honeydew4               | rgb(131, 139, 131)  | #838B83   |
| green1               | green1                  | rgb( 0, 255, 0)     | #00FF00   |
| lime                 | lime                    | rgb( 0, 255, 0)     | #00FF00   |
| LimeGreen            | LimeGreen               | rgb( 50, 205, 50)   | #32CD32   |
| DarkSeaGreen4        | DarkSeaGreen4           | rgb(105, 139, 105)  | #698B69   |
| green2               | green2                  | rgb( 0, 238, 0)     | #00EE00   |
| PaleGreen4           | PaleGreen4              | rgb( 84, 139, 84)   | #548B54   |
| green3               | green3                  | rgb( 0, 205, 0)     | #00CD00   |
| ForestGreen          | ForestGreen             | rgb( 34, 139, 34)   | #228B22   |
| green4               | green4                  | rgb( 0, 139, 0)     | #008B00   |
| green                | green                   | rgb( 0, 128, 0)     | #008000   |
| DarkGreen            | DarkGreen               | rgb( 0, 100, 0)     | #006400   |
| LawnGreen            | LawnGreen               | rgb(124, 252, 0)    | #7CFC00   |
| chartreuse           | chartreuse              | rgb(127, 255, 0)    | #7FFF00   |
| chartreuse1          | chartreuse1             | rgb(127, 255, 0)    | #7FFF00   |
| chartreuse2          | chartreuse2             | rgb(118, 238, 0)    | #76EE00   |
| chartreuse3          | chartreuse3             | rgb(102, 205, 0)    | #66CD00   |
| chartreuse4          | chartreuse4             | rgb( 69, 139, 0)    | #458B00   |
| GreenYellow          | GreenYellow             | rgb(173, 255, 47)   | #ADFF2F   |
| DarkOliveGreen3      | DarkOliveGreen3         | rgb(162, 205, 90)   | #A2CD5A   |
| DarkOliveGreen1      | DarkOliveGreen1         | rgb(202, 255, 112)  | #CAFF70   |
| DarkOliveGreen2      | DarkOliveGreen2         | rgb(188, 238, 104)  | #BCEE68   |
| DarkOliveGreen4      | DarkOliveGreen4         | rgb(110, 139, 61)   | #6E8B3D   |
| DarkOliveGreen       | DarkOliveGreen          | rgb( 85, 107, 47)   | #556B2F   |
| OliveDrab            | OliveDrab               | rgb(107, 142, 35)   | #6B8E23   |
| OliveDrab1           | OliveDrab1              | rgb(192, 255, 62)   | #C0FF3E   |
| OliveDrab2           | OliveDrab2              | rgb(179, 238, 58)   | #B3EE3A   |
| OliveDrab3           | OliveDrab3              | rgb(154, 205, 50)   | #9ACD32   |
| YellowGreen          | YellowGreen             | rgb(154, 205, 50)   | #9ACD32   |
| OliveDrab4           | OliveDrab4              | rgb(105, 139, 34)   | #698B22   |
| ivory                | ivory                   | rgb(255, 255, 240)  | #FFFFF0   |
| ivory1               | ivory1                  | rgb(255, 255, 240)  | #FFFFF0   |
| LightYellow          | LightYellow             | rgb(255, 255, 224)  | #FFFFE0   |
| LightYellow1         | LightYellow1            | rgb(255, 255, 224)  | #FFFFE0   |
| beige                | beige                   | rgb(245, 245, 220)  | #F5F5DC   |
| ivory2               | ivory2                  | rgb(238, 238, 224)  | #EEEEE0   |
| LightGoldenrodYellow | LightGoldenrodYellow    | rgb(250, 250, 210)  | #FAFAD2   |
| LightYellow2         | LightYellow2            | rgb(238, 238, 209)  | #EEEED1   |
| ivory3               | ivory3                  | rgb(205, 205, 193)  | #CDCDC1   |
| LightYellow3         | LightYellow3            | rgb(205, 205, 180)  | #CDCDB4   |
| ivory4               | ivory4                  | rgb(139, 139, 131)  | #8B8B83   |
| LightYellow4         | LightYellow4            | rgb(139, 139, 122)  | #8B8B7A   |
| yellow               | yellow                  | rgb(255, 255, 0)    | #FFFF00   |
| yellow1              | yellow1                 | rgb(255, 255, 0)    | #FFFF00   |
| yellow2              | yellow2                 | rgb(238, 238, 0)    | #EEEE00   |
| yellow3              | yellow3                 | rgb(205, 205, 0)    | #CDCD00   |
| yellow4              | yellow4                 | rgb(139, 139, 0)    | #8B8B00   |
| olive                | olive                   | rgb(128, 128, 0)    | #808000   |
| DarkKhaki            | DarkKhaki               | rgb(189, 183, 107)  | #BDB76B   |
| khaki2               | khaki2                  | rgb(238, 230, 133)  | #EEE685   |
| LemonChiffon4        | LemonChiffon4           | rgb(139, 137, 112)  | #8B8970   |
| khaki1               | khaki1                  | rgb(255, 246, 143)  | #FFF68F   |
| khaki3               | khaki3                  | rgb(205, 198, 115)  | #CDC673   |
| khaki4               | khaki4                  | rgb(139, 134, 78)   | #8B864E   |
| PaleGoldenrod        | PaleGoldenrod           | rgb(238, 232, 170)  | #EEE8AA   |
| LemonChiffon         | LemonChiffon            | rgb(255, 250, 205)  | #FFFACD   |
| LemonChiffon1        | LemonChiffon1           | rgb(255, 250, 205)  | #FFFACD   |
| khaki                | khaki                   | rgb(240, 230, 140)  | #F0E68C   |
| LemonChiffon3        | LemonChiffon3           | rgb(205, 201, 165)  | #CDC9A5   |
| LemonChiffon2        | LemonChiffon2           | rgb(238, 233, 191)  | #EEE9BF   |
| MediumGoldenRod      | MediumGoldenRod         | rgb(209, 193, 102)  | #D1C166   |
| cornsilk4            | cornsilk4               | rgb(139, 136, 120)  | #8B8878   |
| gold                 | gold                    | rgb(255, 215, 0)    | #FFD700   |
| gold1                | gold1                   | rgb(255, 215, 0)    | #FFD700   |
| gold2                | gold2                   | rgb(238, 201, 0)    | #EEC900   |
| gold3                | gold3                   | rgb(205, 173, 0)    | #CDAD00   |
| gold4                | gold4                   | rgb(139, 117, 0)    | #8B7500   |
| LightGoldenrod       | LightGoldenrod          | rgb(238, 221, 130)  | #EEDD82   |
| LightGoldenrod4      | LightGoldenrod4         | rgb(139, 129, 76)   | #8B814C   |
| LightGoldenrod1      | LightGoldenrod1         | rgb(255, 236, 139)  | #FFEC8B   |
| LightGoldenrod3      | LightGoldenrod3         | rgb(205, 190, 112)  | #CDBE70   |
| LightGoldenrod2      | LightGoldenrod2         | rgb(238, 220, 130)  | #EEDC82   |
| cornsilk3            | cornsilk3               | rgb(205, 200, 177)  | #CDC8B1   |
| cornsilk2            | cornsilk2               | rgb(238, 232, 205)  | #EEE8CD   |
| cornsilk             | cornsilk                | rgb(255, 248, 220)  | #FFF8DC   |
| cornsilk1            | cornsilk1               | rgb(255, 248, 220)  | #FFF8DC   |
| goldenrod            | goldenrod               | rgb(218, 165, 32)   | #DAA520   |
| goldenrod1           | goldenrod1              | rgb(255, 193, 37)   | #FFC125   |
| goldenrod2           | goldenrod2              | rgb(238, 180, 34)   | #EEB422   |
| goldenrod3           | goldenrod3              | rgb(205, 155, 29)   | #CD9B1D   |
| goldenrod4           | goldenrod4              | rgb(139, 105, 20)   | #8B6914   |
| DarkGoldenrod        | DarkGoldenrod           | rgb(184, 134, 11)   | #B8860B   |
| DarkGoldenrod1       | DarkGoldenrod1          | rgb(255, 185, 15)   | #FFB90F   |
| DarkGoldenrod2       | DarkGoldenrod2          | rgb(238, 173, 14)   | #EEAD0E   |
| DarkGoldenrod3       | DarkGoldenrod3          | rgb(205, 149, 12)   | #CD950C   |
| DarkGoldenrod4       | DarkGoldenrod4          | rgb(139, 101, 8)    | #8B6508   |
| FloralWhite          | FloralWhite             | rgb(255, 250, 240)  | #FFFAF0   |
| wheat2               | wheat2                  | rgb(238, 216, 174)  | #EED8AE   |
| OldLace              | OldLace                 | rgb(253, 245, 230)  | #FDF5E6   |
| wheat                | wheat                   | rgb(245, 222, 179)  | #F5DEB3   |
| wheat1               | wheat1                  | rgb(255, 231, 186)  | #FFE7BA   |
| wheat3               | wheat3                  | rgb(205, 186, 150)  | #CDBA96   |
| orange               | orange                  | rgb(255, 165, 0)    | #FFA500   |
| orange1              | orange1                 | rgb(255, 165, 0)    | #FFA500   |
| orange2              | orange2                 | rgb(238, 154, 0)    | #EE9A00   |
| orange3              | orange3                 | rgb(205, 133, 0)    | #CD8500   |
| orange4              | orange4                 | rgb(139, 90, 0)     | #8B5A00   |
| wheat4               | wheat4                  | rgb(139, 126, 102)  | #8B7E66   |
| moccasin             | moccasin                | rgb(255, 228, 181)  | #FFE4B5   |
| PapayaWhip           | PapayaWhip              | rgb(255, 239, 213)  | #FFEFD5   |
| NavajoWhite3         | NavajoWhite3            | rgb(205, 179, 139)  | #CDB38B   |
| BlanchedAlmond       | BlanchedAlmond          | rgb(255, 235, 205)  | #FFEBCD   |
| NavajoWhite          | NavajoWhite             | rgb(255, 222, 173)  | #FFDEAD   |
| NavajoWhite1         | NavajoWhite1            | rgb(255, 222, 173)  | #FFDEAD   |
| NavajoWhite2         | NavajoWhite2            | rgb(238, 207, 161)  | #EECFA1   |
| NavajoWhite4         | NavajoWhite4            | rgb(139, 121, 94)   | #8B795E   |
| AntiqueWhite4        | AntiqueWhite4           | rgb(139, 131, 120)  | #8B8378   |
| AntiqueWhite         | AntiqueWhite            | rgb(250, 235, 215)  | #FAEBD7   |
| tan                  | tan                     | rgb(210, 180, 140)  | #D2B48C   |
| bisque4              | bisque4                 | rgb(139, 125, 107)  | #8B7D6B   |
| burlywood            | burlywood               | rgb(222, 184, 135)  | #DEB887   |
| AntiqueWhite2        | AntiqueWhite2           | rgb(238, 223, 204)  | #EEDFCC   |
| burlywood1           | burlywood1              | rgb(255, 211, 155)  | #FFD39B   |
| burlywood3           | burlywood3              | rgb(205, 170, 125)  | #CDAA7D   |
| burlywood2           | burlywood2              | rgb(238, 197, 145)  | #EEC591   |
| AntiqueWhite1        | AntiqueWhite1           | rgb(255, 239, 219)  | #FFEFDB   |
| burlywood4           | burlywood4              | rgb(139, 115, 85)   | #8B7355   |
| AntiqueWhite3        | AntiqueWhite3           | rgb(205, 192, 176)  | #CDC0B0   |
| DarkOrange           | DarkOrange              | rgb(255, 140, 0)    | #FF8C00   |
| bisque2              | bisque2                 | rgb(238, 213, 183)  | #EED5B7   |
| bisque               | bisque                  | rgb(255, 228, 196)  | #FFE4C4   |
| bisque1              | bisque1                 | rgb(255, 228, 196)  | #FFE4C4   |
| bisque3              | bisque3                 | rgb(205, 183, 158)  | #CDB79E   |
| DarkOrange1          | DarkOrange1             | rgb(255, 127, 0)    | #FF7F00   |
| linen                | linen                   | rgb(250, 240, 230)  | #FAF0E6   |
| DarkOrange2          | DarkOrange2             | rgb(238, 118, 0)    | #EE7600   |
| DarkOrange3          | DarkOrange3             | rgb(205, 102, 0)    | #CD6600   |
| DarkOrange4          | DarkOrange4             | rgb(139, 69, 0)     | #8B4500   |
| peru                 | peru                    | rgb(205, 133, 63)   | #CD853F   |
| tan1                 | tan1                    | rgb(255, 165, 79)   | #FFA54F   |
| tan2                 | tan2                    | rgb(238, 154, 73)   | #EE9A49   |
| tan3                 | tan3                    | rgb(205, 133, 63)   | #CD853F   |
| tan4                 | tan4                    | rgb(139, 90, 43)    | #8B5A2B   |
| PeachPuff            | PeachPuff               | rgb(255, 218, 185)  | #FFDAB9   |
| PeachPuff1           | PeachPuff1              | rgb(255, 218, 185)  | #FFDAB9   |
| PeachPuff4           | PeachPuff4              | rgb(139, 119, 101)  | #8B7765   |
| PeachPuff2           | PeachPuff2              | rgb(238, 203, 173)  | #EECBAD   |
| PeachPuff3           | PeachPuff3              | rgb(205, 175, 149)  | #CDAF95   |
| SandyBrown           | SandyBrown              | rgb(244, 164, 96)   | #F4A460   |
| seashell4            | seashell4               | rgb(139, 134, 130)  | #8B8682   |
| seashell2            | seashell2               | rgb(238, 229, 222)  | #EEE5DE   |
| seashell3            | seashell3               | rgb(205, 197, 191)  | #CDC5BF   |
| chocolate            | chocolate               | rgb(210, 105, 30)   | #D2691E   |
| chocolate1           | chocolate1              | rgb(255, 127, 36)   | #FF7F24   |
| chocolate2           | chocolate2              | rgb(238, 118, 33)   | #EE7621   |
| chocolate3           | chocolate3              | rgb(205, 102, 29)   | #CD661D   |
| chocolate4           | chocolate4              | rgb(139, 69, 19)    | #8B4513   |
| SaddleBrown          | SaddleBrown             | rgb(139, 69, 19)    | #8B4513   |
| seashell             | seashell                | rgb(255, 245, 238)  | #FFF5EE   |
| seashell1            | seashell1               | rgb(255, 245, 238)  | #FFF5EE   |
| sienna4              | sienna4                 | rgb(139, 71, 38)    | #8B4726   |
| sienna               | sienna                  | rgb(160, 82, 45)    | #A0522D   |
| sienna1              | sienna1                 | rgb(255, 130, 71)   | #FF8247   |
| sienna2              | sienna2                 | rgb(238, 121, 66)   | #EE7942   |
| sienna3              | sienna3                 | rgb(205, 104, 57)   | #CD6839   |
| LightSalmon3         | LightSalmon3            | rgb(205, 129, 98)   | #CD8162   |
| LightSalmon          | LightSalmon             | rgb(255, 160, 122)  | #FFA07A   |
| LightSalmon1         | LightSalmon1            | rgb(255, 160, 122)  | #FFA07A   |
| LightSalmon4         | LightSalmon4            | rgb(139, 87, 66)    | #8B5742   |
| LightSalmon2         | LightSalmon2            | rgb(238, 149, 114)  | #EE9572   |
| coral                | coral                   | rgb(255, 127, 80)   | #FF7F50   |
| OrangeRed            | OrangeRed               | rgb(255, 69, 0)     | #FF4500   |
| OrangeRed1           | OrangeRed1              | rgb(255, 69, 0)     | #FF4500   |
| OrangeRed2           | OrangeRed2              | rgb(238, 64, 0)     | #EE4000   |
| OrangeRed3           | OrangeRed3              | rgb(205, 55, 0)     | #CD3700   |
| OrangeRed4           | OrangeRed4              | rgb(139, 37, 0)     | #8B2500   |
| DarkSalmon           | DarkSalmon              | rgb(233, 150, 122)  | #E9967A   |
| salmon1              | salmon1                 | rgb(255, 140, 105)  | #FF8C69   |
| salmon2              | salmon2                 | rgb(238, 130, 98)   | #EE8262   |
| salmon3              | salmon3                 | rgb(205, 112, 84)   | #CD7054   |
| salmon4              | salmon4                 | rgb(139, 76, 57)    | #8B4C39   |
| coral1               | coral1                  | rgb(255, 114, 86)   | #FF7256   |
| coral2               | coral2                  | rgb(238, 106, 80)   | #EE6A50   |
| coral3               | coral3                  | rgb(205, 91, 69)    | #CD5B45   |
| coral4               | coral4                  | rgb(139, 62, 47)    | #8B3E2F   |
| tomato4              | tomato4                 | rgb(139, 54, 38)    | #8B3626   |
| tomato               | tomato                  | rgb(255, 99, 71)    | #FF6347   |
| tomato1              | tomato1                 | rgb(255, 99, 71)    | #FF6347   |
| tomato2              | tomato2                 | rgb(238, 92, 66)    | #EE5C42   |
| tomato3              | tomato3                 | rgb(205, 79, 57)    | #CD4F39   |
| MistyRose4           | MistyRose4              | rgb(139, 125, 123)  | #8B7D7B   |
| MistyRose2           | MistyRose2              | rgb(238, 213, 210)  | #EED5D2   |
| MistyRose            | MistyRose               | rgb(255, 228, 225)  | #FFE4E1   |
| MistyRose1           | MistyRose1              | rgb(255, 228, 225)  | #FFE4E1   |
| salmon               | salmon                  | rgb(250, 128, 114)  | #FA8072   |
| MistyRose3           | MistyRose3              | rgb(205, 183, 181)  | #CDB7B5   |
| white                | white                   | rgb(255, 255, 255)  | #FFFFFF   |
| gray100              | gray100                 | rgb(255, 255, 255)  | #FFFFFF   |
| grey100              | grey100                 | rgb(255, 255, 255)  | #FFFFFF   |
| grey100              | grey100                 | rgb(255, 255, 255)  | #FFFFFF   |
| gray99               | gray99                  | rgb(252, 252, 252)  | #FCFCFC   |
| grey99               | grey99                  | rgb(252, 252, 252)  | #FCFCFC   |
| gray98               | gray98                  | rgb(250, 250, 250)  | #FAFAFA   |
| grey98               | grey98                  | rgb(250, 250, 250)  | #FAFAFA   |
| gray97               | gray97                  | rgb(247, 247, 247)  | #F7F7F7   |
| grey97               | grey97                  | rgb(247, 247, 247)  | #F7F7F7   |
| gray96               | gray96                  | rgb(245, 245, 245)  | #F5F5F5   |
| grey96               | grey96                  | rgb(245, 245, 245)  | #F5F5F5   |
| WhiteSmoke           | WhiteSmoke              | rgb(245, 245, 245)  | #F5F5F5   |
| gray95               | gray95                  | rgb(242, 242, 242)  | #F2F2F2   |
| grey95               | grey95                  | rgb(242, 242, 242)  | #F2F2F2   |
| gray94               | gray94                  | rgb(240, 240, 240)  | #F0F0F0   |
| grey94               | grey94                  | rgb(240, 240, 240)  | #F0F0F0   |
| gray93               | gray93                  | rgb(237, 237, 237)  | #EDEDED   |
| grey93               | grey93                  | rgb(237, 237, 237)  | #EDEDED   |
| gray92               | gray92                  | rgb(235, 235, 235)  | #EBEBEB   |
| grey92               | grey92                  | rgb(235, 235, 235)  | #EBEBEB   |
| gray91               | gray91                  | rgb(232, 232, 232)  | #E8E8E8   |
| grey91               | grey91                  | rgb(232, 232, 232)  | #E8E8E8   |
| gray90               | gray90                  | rgb(229, 229, 229)  | #E5E5E5   |
| grey90               | grey90                  | rgb(229, 229, 229)  | #E5E5E5   |
| gray89               | gray89                  | rgb(227, 227, 227)  | #E3E3E3   |
| grey89               | grey89                  | rgb(227, 227, 227)  | #E3E3E3   |
| gray88               | gray88                  | rgb(224, 224, 224)  | #E0E0E0   |
| grey88               | grey88                  | rgb(224, 224, 224)  | #E0E0E0   |
| gray87               | gray87                  | rgb(222, 222, 222)  | #DEDEDE   |
| grey87               | grey87                  | rgb(222, 222, 222)  | #DEDEDE   |
| gainsboro            | gainsboro               | rgb(220, 220, 220)  | #DCDCDC   |
| gray86               | gray86                  | rgb(219, 219, 219)  | #DBDBDB   |
| grey86               | grey86                  | rgb(219, 219, 219)  | #DBDBDB   |
| gray85               | gray85                  | rgb(217, 217, 217)  | #D9D9D9   |
| grey85               | grey85                  | rgb(217, 217, 217)  | #D9D9D9   |
| gray84               | gray84                  | rgb(214, 214, 214)  | #D6D6D6   |
| grey84               | grey84                  | rgb(214, 214, 214)  | #D6D6D6   |
| gray83               | gray83                  | rgb(212, 212, 212)  | #D4D4D4   |
| grey83               | grey83                  | rgb(212, 212, 212)  | #D4D4D4   |
| LightGray            | LightGray               | rgb(211, 211, 211)  | #D3D3D3   |
| LightGrey            | LightGrey               | rgb(211, 211, 211)  | #D3D3D3   |
| gray82               | gray82                  | rgb(209, 209, 209)  | #D1D1D1   |
| grey82               | grey82                  | rgb(209, 209, 209)  | #D1D1D1   |
| gray81               | gray81                  | rgb(207, 207, 207)  | #CFCFCF   |
| grey81               | grey81                  | rgb(207, 207, 207)  | #CFCFCF   |
| gray80               | gray80                  | rgb(204, 204, 204)  | #CCCCCC   |
| grey80               | grey80                  | rgb(204, 204, 204)  | #CCCCCC   |
| gray79               | gray79                  | rgb(201, 201, 201)  | #C9C9C9   |
| grey79               | grey79                  | rgb(201, 201, 201)  | #C9C9C9   |
| gray78               | gray78                  | rgb(199, 199, 199)  | #C7C7C7   |
| grey78               | grey78                  | rgb(199, 199, 199)  | #C7C7C7   |
| gray77               | gray77                  | rgb(196, 196, 196)  | #C4C4C4   |
| grey77               | grey77                  | rgb(196, 196, 196)  | #C4C4C4   |
| gray76               | gray76                  | rgb(194, 194, 194)  | #C2C2C2   |
| grey76               | grey76                  | rgb(194, 194, 194)  | #C2C2C2   |
| silver               | silver                  | rgb(192, 192, 192)  | #C0C0C0   |
| gray75               | gray75                  | rgb(191, 191, 191)  | #BFBFBF   |
| grey75               | grey75                  | rgb(191, 191, 191)  | #BFBFBF   |
| gray74               | gray74                  | rgb(189, 189, 189)  | #BDBDBD   |
| grey74               | grey74                  | rgb(189, 189, 189)  | #BDBDBD   |
| gray73               | gray73                  | rgb(186, 186, 186)  | #BABABA   |
| grey73               | grey73                  | rgb(186, 186, 186)  | #BABABA   |
| gray72               | gray72                  | rgb(184, 184, 184)  | #B8B8B8   |
| grey72               | grey72                  | rgb(184, 184, 184)  | #B8B8B8   |
| gray71               | gray71                  | rgb(181, 181, 181)  | #B5B5B5   |
| grey71               | grey71                  | rgb(181, 181, 181)  | #B5B5B5   |
| gray70               | gray70                  | rgb(179, 179, 179)  | #B3B3B3   |
| grey70               | grey70                  | rgb(179, 179, 179)  | #B3B3B3   |
| gray69               | gray69                  | rgb(176, 176, 176)  | #B0B0B0   |
| grey69               | grey69                  | rgb(176, 176, 176)  | #B0B0B0   |
| gray68               | gray68                  | rgb(173, 173, 173)  | #ADADAD   |
| grey68               | grey68                  | rgb(173, 173, 173)  | #ADADAD   |
| gray67               | gray67                  | rgb(171, 171, 171)  | #ABABAB   |
| grey67               | grey67                  | rgb(171, 171, 171)  | #ABABAB   |
| DarkGray             | DarkGray                | rgb(169, 169, 169)  | #A9A9A9   |
| DarkGrey             | DarkGrey                | rgb(169, 169, 169)  | #A9A9A9   |
| gray66               | gray66                  | rgb(168, 168, 168)  | #A8A8A8   |
| grey66               | grey66                  | rgb(168, 168, 168)  | #A8A8A8   |
| gray65               | gray65                  | rgb(166, 166, 166)  | #A6A6A6   |
| grey65               | grey65                  | rgb(166, 166, 166)  | #A6A6A6   |
| gray64               | gray64                  | rgb(163, 163, 163)  | #A3A3A3   |
| grey64               | grey64                  | rgb(163, 163, 163)  | #A3A3A3   |
| gray63               | gray63                  | rgb(161, 161, 161)  | #A1A1A1   |
| grey63               | grey63                  | rgb(161, 161, 161)  | #A1A1A1   |
| gray62               | gray62                  | rgb(158, 158, 158)  | #9E9E9E   |
| grey62               | grey62                  | rgb(158, 158, 158)  | #9E9E9E   |
| gray61               | gray61                  | rgb(156, 156, 156)  | #9C9C9C   |
| grey61               | grey61                  | rgb(156, 156, 156)  | #9C9C9C   |
| gray60               | gray60                  | rgb(153, 153, 153)  | #999999   |
| grey60               | grey60                  | rgb(153, 153, 153)  | #999999   |
| gray59               | gray59                  | rgb(150, 150, 150)  | #969696   |
| grey59               | grey59                  | rgb(150, 150, 150)  | #969696   |
| gray58               | gray58                  | rgb(148, 148, 148)  | #949494   |
| grey58               | grey58                  | rgb(148, 148, 148)  | #949494   |
| gray57               | gray57                  | rgb(145, 145, 145)  | #919191   |
| grey57               | grey57                  | rgb(145, 145, 145)  | #919191   |
| gray56               | gray56                  | rgb(143, 143, 143)  | #8F8F8F   |
| grey56               | grey56                  | rgb(143, 143, 143)  | #8F8F8F   |
| gray55               | gray55                  | rgb(140, 140, 140)  | #8C8C8C   |
| grey55               | grey55                  | rgb(140, 140, 140)  | #8C8C8C   |
| gray54               | gray54                  | rgb(138, 138, 138)  | #8A8A8A   |
| grey54               | grey54                  | rgb(138, 138, 138)  | #8A8A8A   |
| gray53               | gray53                  | rgb(135, 135, 135)  | #878787   |
| grey53               | grey53                  | rgb(135, 135, 135)  | #878787   |
| gray52               | gray52                  | rgb(133, 133, 133)  | #858585   |
| grey52               | grey52                  | rgb(133, 133, 133)  | #858585   |
| gray51               | gray51                  | rgb(130, 130, 130)  | #828282   |
| grey51               | grey51                  | rgb(130, 130, 130)  | #828282   |
| fractal              | fractal                 | rgb(128, 128, 128)  | #808080   |
| gray50               | gray50                  | rgb(127, 127, 127)  | #7F7F7F   |
| grey50               | grey50                  | rgb(127, 127, 127)  | #7F7F7F   |
| gray                 | gray                    | rgb(126, 126, 126)  | #7E7E7E   |
| gray49               | gray49                  | rgb(125, 125, 125)  | #7D7D7D   |
| grey49               | grey49                  | rgb(125, 125, 125)  | #7D7D7D   |
| gray48               | gray48                  | rgb(122, 122, 122)  | #7A7A7A   |
| grey48               | grey48                  | rgb(122, 122, 122)  | #7A7A7A   |
| gray47               | gray47                  | rgb(120, 120, 120)  | #787878   |
| grey47               | grey47                  | rgb(120, 120, 120)  | #787878   |
| gray46               | gray46                  | rgb(117, 117, 117)  | #757575   |
| grey46               | grey46                  | rgb(117, 117, 117)  | #757575   |
| gray45               | gray45                  | rgb(115, 115, 115)  | #737373   |
| grey45               | grey45                  | rgb(115, 115, 115)  | #737373   |
| gray44               | gray44                  | rgb(112, 112, 112)  | #707070   |
| grey44               | grey44                  | rgb(112, 112, 112)  | #707070   |
| gray43               | gray43                  | rgb(110, 110, 110)  | #6E6E6E   |
| grey43               | grey43                  | rgb(110, 110, 110)  | #6E6E6E   |
| gray42               | gray42                  | rgb(107, 107, 107)  | #6B6B6B   |
| grey42               | grey42                  | rgb(107, 107, 107)  | #6B6B6B   |
| DimGray              | DimGray                 | rgb(105, 105, 105)  | #696969   |
| DimGrey              | DimGrey                 | rgb(105, 105, 105)  | #696969   |
| gray41               | gray41                  | rgb(105, 105, 105)  | #696969   |
| grey41               | grey41                  | rgb(105, 105, 105)  | #696969   |
| gray40               | gray40                  | rgb(102, 102, 102)  | #666666   |
| grey40               | grey40                  | rgb(102, 102, 102)  | #666666   |
| gray39               | gray39                  | rgb( 99, 99, 99)    | #636363   |
| grey39               | grey39                  | rgb( 99, 99, 99)    | #636363   |
| gray38               | gray38                  | rgb( 97, 97, 97)    | #616161   |
| grey38               | grey38                  | rgb( 97, 97, 97)    | #616161   |
| gray37               | gray37                  | rgb( 94, 94, 94)    | #5E5E5E   |
| grey37               | grey37                  | rgb( 94, 94, 94)    | #5E5E5E   |
| gray36               | gray36                  | rgb( 92, 92, 92)    | #5C5C5C   |
| grey36               | grey36                  | rgb( 92, 92, 92)    | #5C5C5C   |
| gray35               | gray35                  | rgb( 89, 89, 89)    | #595959   |
| grey35               | grey35                  | rgb( 89, 89, 89)    | #595959   |
| gray34               | gray34                  | rgb( 87, 87, 87)    | #575757   |
| grey34               | grey34                  | rgb( 87, 87, 87)    | #575757   |
| gray33               | gray33                  | rgb( 84, 84, 84)    | #545454   |
| grey33               | grey33                  | rgb( 84, 84, 84)    | #545454   |
| gray32               | gray32                  | rgb( 82, 82, 82)    | #525252   |
| grey32               | grey32                  | rgb( 82, 82, 82)    | #525252   |
| gray31               | gray31                  | rgb( 79, 79, 79)    | #4F4F4F   |
| grey31               | grey31                  | rgb( 79, 79, 79)    | #4F4F4F   |
| gray30               | gray30                  | rgb( 77, 77, 77)    | #4D4D4D   |
| grey30               | grey30                  | rgb( 77, 77, 77)    | #4D4D4D   |
| gray29               | gray29                  | rgb( 74, 74, 74)    | #4A4A4A   |
| grey29               | grey29                  | rgb( 74, 74, 74)    | #4A4A4A   |
| gray28               | gray28                  | rgb( 71, 71, 71)    | #474747   |
| grey28               | grey28                  | rgb( 71, 71, 71)    | #474747   |
| gray27               | gray27                  | rgb( 69, 69, 69)    | #454545   |
| grey27               | grey27                  | rgb( 69, 69, 69)    | #454545   |
| gray26               | gray26                  | rgb( 66, 66, 66)    | #424242   |
| grey26               | grey26                  | rgb( 66, 66, 66)    | #424242   |
| gray25               | gray25                  | rgb( 64, 64, 64)    | #404040   |
| grey25               | grey25                  | rgb( 64, 64, 64)    | #404040   |
| gray24               | gray24                  | rgb( 61, 61, 61)    | #3D3D3D   |
| grey24               | grey24                  | rgb( 61, 61, 61)    | #3D3D3D   |
| gray23               | gray23                  | rgb( 59, 59, 59)    | #3B3B3B   |
| grey23               | grey23                  | rgb( 59, 59, 59)    | #3B3B3B   |
| gray22               | gray22                  | rgb( 56, 56, 56)    | #383838   |
| grey22               | grey22                  | rgb( 56, 56, 56)    | #383838   |
| gray21               | gray21                  | rgb( 54, 54, 54)    | #363636   |
| grey21               | grey21                  | rgb( 54, 54, 54)    | #363636   |
| gray20               | gray20                  | rgb( 51, 51, 51)    | #333333   |
| grey20               | grey20                  | rgb( 51, 51, 51)    | #333333   |
| gray19               | gray19                  | rgb( 48, 48, 48)    | #303030   |
| grey19               | grey19                  | rgb( 48, 48, 48)    | #303030   |
| gray18               | gray18                  | rgb( 46, 46, 46)    | #2E2E2E   |
| grey18               | grey18                  | rgb( 46, 46, 46)    | #2E2E2E   |
| gray17               | gray17                  | rgb( 43, 43, 43)    | #2B2B2B   |
| grey17               | grey17                  | rgb( 43, 43, 43)    | #2B2B2B   |
| gray16               | gray16                  | rgb( 41, 41, 41)    | #292929   |
| grey16               | grey16                  | rgb( 41, 41, 41)    | #292929   |
| gray15               | gray15                  | rgb( 38, 38, 38)    | #262626   |
| grey15               | grey15                  | rgb( 38, 38, 38)    | #262626   |
| gray14               | gray14                  | rgb( 36, 36, 36)    | #242424   |
| grey14               | grey14                  | rgb( 36, 36, 36)    | #242424   |
| gray13               | gray13                  | rgb( 33, 33, 33)    | #212121   |
| grey13               | grey13                  | rgb( 33, 33, 33)    | #212121   |
| gray12               | gray12                  | rgb( 31, 31, 31)    | #1F1F1F   |
| grey12               | grey12                  | rgb( 31, 31, 31)    | #1F1F1F   |
| gray11               | gray11                  | rgb( 28, 28, 28)    | #1C1C1C   |
| grey11               | grey11                  | rgb( 28, 28, 28)    | #1C1C1C   |
| gray10               | gray10                  | rgb( 26, 26, 26)    | #1A1A1A   |
| grey10               | grey10                  | rgb( 26, 26, 26)    | #1A1A1A   |
| gray9                | gray9                   | rgb( 23, 23, 23)    | #171717   |
| grey9                | grey9                   | rgb( 23, 23, 23)    | #171717   |
| gray8                | gray8                   | rgb( 20, 20, 20)    | #141414   |
| grey8                | grey8                   | rgb( 20, 20, 20)    | #141414   |
| gray7                | gray7                   | rgb( 18, 18, 18)    | #121212   |
| grey7                | grey7                   | rgb( 18, 18, 18)    | #121212   |
| gray6                | gray6                   | rgb( 15, 15, 15)    | #0F0F0F   |
| grey6                | grey6                   | rgb( 15, 15, 15)    | #0F0F0F   |
| gray5                | gray5                   | rgb( 13, 13, 13)    | #0D0D0D   |
| grey5                | grey5                   | rgb( 13, 13, 13)    | #0D0D0D   |
| gray4                | gray4                   | rgb( 10, 10, 10)    | #0A0A0A   |
| grey4                | grey4                   | rgb( 10, 10, 10)    | #0A0A0A   |
| gray3                | gray3                   | rgb( 8, 8, 8)       | #080808   |
| grey3                | grey3                   | rgb( 8, 8, 8)       | #080808   |
| gray2                | gray2                   | rgb( 5, 5, 5)       | #050505   |
| grey2                | grey2                   | rgb( 5, 5, 5)       | #050505   |
| gray1                | gray1                   | rgb( 3, 3, 3)       | #030303   |
| grey1                | grey1                   | rgb( 3, 3, 3)       | #030303   |
| black                | black                   | rgb( 0, 0, 0)       | #000000   |
| gray0                | gray0                   | rgb( 0, 0, 0)       | #000000   |
| grey0                | grey0                   | rgb( 0, 0, 0)       | #000000   |
| opaque               | opaque                  | rgb( 0, 0, 0)       | #000000   |
| none                 | none                    | rgba( 0, 0, 0, 0.0) | #00000000 |
| transparent          | transparent             | rgba( 0, 0, 0, 0.0) | #00000000 |


/Alpha Compositing
==================

This page descibed the Image composition methods that is used to define how two images should be merged together in various image operations. For the Command Line API it is typically set using the [-compose] setting option.

The description of composition uses abstract terminology in order to allow the description to be more precise, while avoiding constant values which are specific to a particular build configuration. Each image pixel is represented by red, green, and blue levels (which are equal for a gray pixel). The build-dependent value QuantumRange is the maximum integral value which may be stored, per pixel, in the red, green, or blue channels of the image. Each image pixel may also optionally (if the image matte channel is enabled) have an associated level of opacity, ranging from opaque to transparent, which may be used to determine the influence of the pixel color when compositing the pixel with another image pixel. If the image matte channel is disabled, then all pixels in the image are treated as opaque. The color of an opaque pixel is fully visible while the color of a transparent pixel color is entirely absent (pixel color is ignored).

By definition, raster images have a rectangular shape. All image rows are of equal length, as are all image columns. By treating the alpha channel as a visual "mask" the rectangular image may be given a "shape" by treating the alpha channel as a cookie-cutter for the image. This is done by setting the pixels within the shape to be opaque, with pixels outside the shape set as transparent. Pixels on the boundary of the shape may be between opaque and transparent in order to provide antialiasing (visually smooth edges). The description of the composition operators use this concept of image "shape" in order to make the description of the operators easier to understand. While it is convenient to describe the operators in terms of "shapes" they are by no means limited to mask-style operations since they are based on continuous floating-point mathematics rather than simple boolean operations.

The following alpha blending (Duff-Porter) compose methods are available:

Method Description

*   ` clear  `

    Both the color and the alpha of the destination are cleared. Neither the source nor the destination are used (except for destinations size and other meta-data which is always preserved.

*   ` src  `

    The source is copied to the destination. The destination is not used as input, though it is cleared.

*   ` dst  `

    The destination is left untouched. The source image is completely ignored.

*   ` src-over  `

    The source is composited over the destination. this is the default alpha blending compose method, when neither the compose setting is set, nor is set in the image meta-data.

*   ` dst-over  `

    The destination is composited over the source and the result replaces the destination.

*   ` src-in  `

    The part of the source lying inside of the destination replaces the destination.

*   ` dst-in  `

    The part of the destination lying inside of the source replaces the destination. Areas not overlaid are cleared.

*   ` src-out  `

    The part of the source lying outside of the destination replaces the destination.

*   ` dst-out  `

    The part of the destination lying outside of the source replaces the destination.

*   ` src-atop  `

    The part of the source lying inside of the destination is composited onto the destination.

*   ` dst-atop  `

    The part of the destination lying inside of the source is composited over the source and replaces the destination. Areas not overlaid are cleared.

*   ` xor  `

    The part of the source that lies outside of the destination is combined with the part of the destination that lies outside of the source. Source or Destination, but not both.

Any of the 'Src-' methods can also be specified without the 'Src-' part. For example the default compose method can be specified as just 'Over'.

Many of these compose methods will clear the destination image which was not overlaid by the source image. This is to be expected as part of that specific composition methods defintion. You can disable this by setting the special [-define] 'compose:outside-overlay' to a value of 'false' will turn off this behavior.

On top of the above 12 Duff-Porter Alpha Composition methods, one special related method 'Copy' has been provided. This is equivalent to using the 'Src' with the special [-define] option 'compose:outside-overlay' set to 'false', so as to only modify the overlaid area, without clearing the rest of the image outside the overlaid area.

The following mathematical composition methods are also available.

Method Description

*   `  multiply  `

    The source is multiplied by the destination and replaces the destination. The resultant color is always at least as dark as either of the two constituent colors. Multiplying any color with black produces black. Multiplying any color with white leaves the original color unchanged.

*   `  screen  `

    The source and destination are complemented and then multiplied and then replace the destination. The resultant color is always at least as light as either of the two constituent colors. Screening any color with white produces white. Screening any color with black leaves the original color unchanged.

*   `  plus  `

    The source is added to the destination and replaces the destination. This operator is useful for averaging or a controlled merger of two images, rather than a direct overlay.

*   `  add  `

    As per 'plus' but transparency data is treated as matte values. As such any transparent areas in either image remain transparent.

*   `  minus  `

    Subtract the colors in the source image from the destination image. When transparency is involved, opaque areas is subtracted from any destination opaque areas.

*   `  subtract  `

    Subtract the colors in the source image from the destination image. When transparency is involved transparent areas are subtracted, so only the opaque areas in the source remain opaque in the destination image.

*   `  difference  `

    Subtracts the darker of the two constituent colors from the lighter. Painting with white inverts the destination color. Painting with black produces no change.

*   `  exclusion  `

    Produces an effect similar to that of 'difference', but appears as lower contrast. Painting with white inverts the destination color. Painting with black produces no change.

*   `  darken  `

    Selects the darker of the destination and source colors. The destination is replaced with the source when the source is darker, otherwise it is left unchanged.

*   `  lighten  `

    Selects the lighter of the destination and source colors. The destination is replaced with the source when the source is lighter, otherwise it is left unchanged.

*   `  negate  `

    The "opposite" of difference mode. Note that it is not difference mode inverted, because black and white return the same result, but colors between become brighter instead of darker.

*   `  reflect  `

    This mode is useful when adding shining objects or light zones to images. The formula is similar to color dodge, but the result is not that bright in most cases. The result looks a bit like soft light.

*   `  freeze  `

    Another variation of reflect mode (base and blend color inverted, the result inverted again).

*   `  stamp  `

    This mode somehow is similar to average mode. It is helpful when applying relief or bump textures to images.

*   `  interpolate  `

    This mode somehow combines multiply and screen mode (looks very similar for very dark or bright colors).

Typically these use the default 'Over' alpha blending when transparencies are also involved, except for 'Plus' which uses a 'plus' alpha blending. This means the alpha channel of both images will only be used to ensure that any visible input remains visible even in parts not overlaid. It also means that any values are weighted by the alpha channel of the input and output images. This 'Over' alpha blending is also applied to the lighting composition methods below.

The math composition is applied on an individual channel basis as defined by the [-channel]. This includes the alpha channel. This special usage allows you to perform true mathematics of the image channels, without alpha composition effects, becoming involved.

Use -define compose:sync=false and the above mathematical compositions will no longer synchronise its actions with the alpha channel. Instead the math composition is applied on an individual channel basis as defined by the [-channel]. This includes the alpha channel. This special usage allows you to perform true mathematics of the image channels, without alpha composition effects, becoming involved.

This define is not applied to the lighting composition methods (see below) even though they are closely related to mathematical composition methods.

The following lighting composition methods are also available.

Method Description

*   `  linear-dodge  `

    This is equivalent to 'Plus' in that the color channels are simply added, however it does not 'Plus' the alpha channel, but uses the normal 'Over' alpha blending, which transparencies are involved. Produces a sort of additive multiply-like result.

*   `  linear-burn  `

    As 'Linear-Dodge', but also subtract one from the result. Sort of a additive 'Screen' of the images.

*   `  color-dodge  `

    Brightens the destination color to reflect the source color. Painting with black produces no change.

*   `  color-burn  `

    Darkens the destination color to reflect the source color. Painting with white produces no change.

*   `  overlay  `

    Multiplies or screens the colors, dependent on the destination color. Source colors overlay the destination whilst preserving its highlights and shadows. The destination color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the destination.

*   `  hard-light  `

    Multiplies or screens the colors, dependent on the source color value. If the source color is lighter than 0.5, the destination is lightened as if it were screened. If the source color is darker than 0.5, the destination is darkened, as if it were multiplied. The degree of lightening or darkening is proportional to the difference between the source color and 0.5. If it is equal to 0.5 the destination is unchanged. Painting with pure black or white produces black or white.

*   `  linear-light  `

    Like 'Hard-Light' but using linear-dodge and linear-burn instead. Increases contrast slightly with an impact on the foreground's tonal values.

*   `  soft-burn  `

    A combination of color burn and inverse color dodge mode, but a lot smoother than both of them. The base image is lightened a bit, but very dark blend colors are "burned" in.

*   `  soft-dodge  `

    Combination of color dodge and inverse color burn mode, but a lot smoother than both of them. The base image is darkened a bit, but very bright blend colors are "dodged" in.

*   `  soft-light  `

    Darkens or lightens the colors, dependent on the source color value. If the source color is lighter than 0.5, the destination is lightened. If the source color is darker than 0.5, the destination is darkened, as if it were burned in. The degree of darkening or lightening is proportional to the difference between the source color and 0.5. If it is equal to 0.5, the destination is unchanged. Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white.

*   `  pegtop-light  `

    Almost equivalent to 'Soft-Light', but using a continuous mathematical formula rather than two conditionally selected formulae.

*   `  vivid-light  `

    A modified 'Linear-Light' designed to preserve very stong primary and secondary colors in the image.

*   `  pin-light  `

    Similar to 'Hard-Light', but using sharp linear shadings, to simulate the effects of a strong 'pinhole' light source.

Also included are these special purpose compose methods:

Method Description

*   `  copy  `

    This is equivalent to the Duff-Porter composition method 'Src,' but without clearing the parts of the destination image that is not overlaid.

    copy-*

    Copy the specified channel (Red, Green, Blue, Cyan, Magenta, Yellow, Black, or Opacity) in the source image to the same channel in the destination image. If the channel specified does not exist in the source image, (which can only happen for methods, 'copy-opacity' or 'copy-black') then it is assumed that the source image is a special grayscale channel image of the values that is to be copied.

*   `  change-mask  `

    Replace any destination pixel that is the similar to the source images pixel (as defined by the current [-fuzz] factor), with transparency.

*   `  stereo  `

*   `  create a stereo anaglyph  `

    On top of these composed methods are a few special ones that not only require the two images that are being merged or overlaid, but have some extra numerical arguments, which are tabled below.

In the "composite" command these composition methods are selected using special options with the arguments needed. They are usually, but not always, the same name as the composite 'method' they use, and replaces the normal use of the [-compose] setting in the "composite" command. For example...

    composite ... -blend 50x50 ...  

The "magick" command can accept these extra arguments to its [-composite] operator, using the special [-define] attribute of compose:args. This means you can now make use of these special augmented [-compose] methods, those the argument and the method both need to be set separately. For example...

    magick ... -compose blend  -define compose:args=50,50 -composite ...  

The following is a table of these special 'argumented' compose methods, with a brief summary of what they do. For more details see the equivalent "composite" command option name.

Method Description

*   `  dissolve  `

    Arguments: src_percent[xdst_percent]  
    Equivalent to "composite" [-dissolve]. Dissolve the 'source' image by the percentage given before overlaying 'over' the 'destination' image. If src_percent is greater than 100, it starts dissolving the main image so it will become transparent at a value of 200. If both percentages are given, each image are dissolved to the percentages given.

*   `  blend  `

    Arguments: src_percent[xdst_percent]  
    Equivalent to "composite" [-blend]. Average the images together ('plus') according to the percentages given and each pixels transparency. If only a single percentage value is given it sets the weight of the composite or 'source' image, while the background image is weighted by the exact opposite amount. That is a -blend 30 merges 30% of the 'source' image with 70% of the 'destination' image. Thus it is equivalent to -blend 30x70.

*   `  mathematics  `

    Arguments: A, B, C, D  
    Not available in "composite" at this time. Merge the source and destination images according to the formula

    A*Sc*Dc + B*Sc + C*Dc + D

    Can be used to generate a custom composition method that would otherwise need to be implemented using the slow [-fx] DIY image operator.

*   `  modulate  `

    Arguments: brightness[xsaturation]  
    Equivalent to "composite" [-watermark]. Take a grayscale image (with alpha mask) and modify the destination image's brightness according to watermark image's grayscale value and the brightness percentage. The destinations color saturation attribute is just direct modified by the saturation percentage, which defaults to 100 percent (no color change).

*   `  displace  `

    Arguments: X-scale[xY-scale][!][%]  
    Equivalent to "composite" [-displace]. With this option, the 'overlay' image, and optionally the 'mask' image, is used as a relative displacement map, which is used to displace the lookup of what part of the destination image is seen at each point of the overlaid area. Much like the displacement map is a 'lens' that distorts the original 'background' image behind it.  
      
    The X-scale is modulated by the 'red' channel of the overlay image while the Y-scale is modulated by the green channel, (the mask image if given is rolled into green channel of the overlay image. This separation allows you to modulate the X and Y lookup displacement separately allowing you to do 2-dimensional displacements, rather than 1-dimensional vectored displacements (using grayscale image).  
      
    If the overlay image contains transparency this is used as a mask of the resulting image to remove 'invalid' pixels.  
      
    The '%' flag makes the displacement scale relative to the size of the overlay image (100% = half width/height of image). Using '!' switches percentage arguments to refer to the destination image size instead.  
      

*   `  distort  `

    Arguments: X-scale[xY-scale[+X-center+Y-center]][!][%]  
    Not available in "composite" at this time. Exactly as per 'Displace' (above), but using absolute coordinates, relative to the center of the overlay (or that given). Basically allows you to generate absolute distortion maps where 'black' will look up the left/top edge, and 'white' looks up the bottom/right edge of the destination image, according to the scale given.  
      
    The '!' flag not only switches percentage scaling, to use the destination image, but also the image the center offset of the lookup. This means the overlay can lookup a completely different region of the destination image.  
      

*   `  blur  `

    Arguments: Width[xHeight[+Angle][+Angle2]]  
    Equivalent to "composite" [-blur]. A Variable Blur Mapping Composition method, where each pixel in the overlaid region is replaced with an Elliptical Weighted Average (EWA), with an ellipse (typically a circle) of the given sigma size, scaled according to overlay (source image) grayscale mapping.  
      
    As per 'Displace' and 'Distort', the red channel will modulate the width of the ellipse, while the green channel will modulate the height of the ellipse. If a single Angle value is given in the arguments, then the ellipse will then be rotated by the angle specified.  
      
    Normally the blue channel of the mapping overlay image is ignored. However if a second ellipse angle is given, then it is assumed that the blue channel defines a variable angle for the ellipse ranging from the first angle to the second angle given. This allows to generate radial blurs, or a rough approximation for rotational blur. Or any mix of the two.  
      

*   `  seamless-blend  `

    Arguments: max-iterationsxdistortion

    Seamlessly inserts the overlay image onto the background image. This operator requires a mask. Set the maximum iterations and distortion when seamlessly blending a foreground object onto a background image. The distortion is the RMSE between each iteration, a good start might be 300x0.0001. Note, seamless blending works most effectively when the HDRI feature is enabled.

*   `  saliency-blend  `

    Arguments: max-iterationsxdistortion

    Merges the overlay image with the background image such that the image that is most salient (has the most detail) at a given pixel will show in the result. This operator requires a mask. Set the maximum iterations and distortion when seamlessly blending a foreground object onto a background image. The distortion is the RMSE between each iteration, a good start might be 300x0.0001. Note, seamless blending works most effectively when the HDRI feature is enabled. Saliency-blending will be a bit slower than seamless blending.

To print a complete list of all the available compose operators, use [-list compose].


/Adaptive Histogram Equalization
================================

Use contrast limited adaptive histogram equalization (AHE) to improve contrast in images. Ordinary histogram equalization computes a global equalization whereas an adaptive method computes several histograms, each corresponding to a distinct section of the image, and uses them to redistribute the lightness values of the image. It is suitable for improving the local contrast and enhancing the definitions of edges in each region of an image. A variant of adaptive histogram equalization, contrast limited adaptive histogram equalization (CLAHE) limits AHE's tendency to overamplify noise in relatively homogeneous regions of an image.

CLAHE is supported as of ImageMagick 7.0.8-24 with the [-clahe] option:

##### -clahe widthxheight{%}{+}number-bins{+}clip-limit{!}

The image is divided into tiles of width and height pixels. Append % to define the width and height as percentages of the image's dimensions. The tile size should be larger than the size of features to be preserved and respects the aspect ratio of the image. Add ! to force an exact tile width and height. number-bins is the number of histogram bins per tile (min 2, max 65536). The number of histogram bins should be smaller than the number of pixels in a single tile. clip-limit is the contrast limit for localized changes in contrast. A clip-limit of 2 to 3 is a good starting place (e.g. -clahe 50x50%+128+3). Very large values will let the histogram equalization do whatever it wants to do, that is result in maximal local contrast. The value 1 will result in the original image. Note, if the number of bins and the clip-limit are omitted, they default to 128 and no clipping respectively.

To visualize the benefits of CLAHE, we have a low contrast image of mountains:

![label](https://imagemagick.org/image/mountains.jpg)

We can improve the image with global histogram equalization:

![label](https://imagemagick.org/image/mountains-equalize.jpg)

We can further improve the image with the contrast limited adaptive histogram equalization image processing technique:

![label](https://imagemagick.org/image/mountains-clahe.jpg)

The latter image was produced with this command:

    magick mountains.jpg -clahe 25x25%+128+3 mountains-clahe.jpg

The 25x25% argument divides the image into 16 tiles to perform local contrast enhancement. The image dimensions are 1500x1000 so the tiles are exactly 375x250 pixels each. Rather than a percentage, you can specify the tile dimensions directly with 375x250.

For tile sizes that do not divide evenly into the image dimensions, CLAHE utilizes virtual pixels, as such the results can vary slightly based on your chosen virtual pixel method. For example,

magick mountains.jpg -virtual-pixel mirror -clahe 300x300+128+3! mountains-clahe.jpg

Notice the !. That forces the tile size to exactly 300x300 pixels, whereas without the !, the tile size respects the aspect ratio of the image and results in tile dimensions of 300x200.


/Color Reduction Utilizing Adaptive Spatial Subdivision
=======================================================

This document describes how ImageMagick performs color reduction on an image. To fully understand what follows, you should have a knowledge of basic imaging techniques and the tree data structure and terminology.

Algorithm Description
---------------------

For purposes of color allocation, an image is a set of n pixels, where each pixel is a point in RGB space. RGB space is a 3-dimensional vector space, and each pixel, p(i), is defined by an ordered triple of red, green, and blue coordinates, (r(i), g(i), b(i)).

Each primary color component (red, green, or blue) represents an intensity which varies linearly from 0 to a maximum value, Cmax, which corresponds to full saturation of that color. Color allocation is defined over a domain consisting of the cube in RGB space with opposite vertices at (0, 0, 0) and (Cmax, Cmax, Cmax). ImageMagick requires Cmax\= 255.

The algorithm maps this domain onto a tree in which each node represents a cube within that domain. In the following discussion, these cubes are defined by the coordinate of two opposite vertices: The vertex nearest the origin in RGB space and the vertex farthest from the origin.

The tree's root node represents the entire domain, (0,0,0) through (Cmax, Cmax, Cmax). Each lower level in the tree is generated by subdividing one node's cube into eight smaller cubes of equal size. This corresponds to bisecting the parent cube with planes passing through the midpoints of each edge.

The basic algorithm operates in three phases:

1.  Classification
2.  Reduction
3.  Assignment

**Classification**

Classification builds a color description tree for the image. Reduction collapses the tree until the number it represents, at most, is the number of colors desired in the output image. Assignment defines the output image's color map and sets each pixel's color by reclassification in the reduced tree. Our goal is to minimize the numerical discrepancies between the original colors and quantized colors. To learn more about quantization error, see [Measuring Color Reduction Error].

Classification begins by initializing a color description tree of sufficient depth to represent each possible input color in a leaf. However, it is impractical to generate a fully-formed color description tree in the classification phase for realistic values of Cmax. If color components in the input image are quantized to k-bit precision, so that Cmax = 2^k-1, the tree would need k levels below the root node to allow representing each possible input color in a leaf. This becomes prohibitive because the tree's total number of nodes:

total nodes = 1+Sum(8^i), i=1,k

For k=8,
nodes = 1 + (8^1+8^2+....+8^8)
      = 1 + 8(8^8 - 1)/(8 - 1)
      = 19,173,961 

Therefore, to avoid building a fully populated tree, ImageMagick:

1.  initializes data structures for nodes only as they are needed;
2.  chooses a maximum depth for the tree as a function of the desired number of colors in the output image (currently the base-two logarithm of Cmax).

For Cmax=255,
maximum tree depth = log2(256)
                   = 8 

A tree of this depth generally allows the best representation of the source image with the fastest computational speed and the least amount of memory. However, the default depth is inappropriate for some images. Therefore, the caller can request a specific tree depth.

For each pixel in the input image, classification scans downward from the root of the color description tree. At each level of the tree, it identifies the single node which represents a cube in RGB space containing the pixels' color. It updates the following data for each such node:

n1

number of pixels whose color is contained in the RGB cube which this node represents;

n2

number of pixels whose color is not represented in a node at lower depth in the tree; initially, n2=0 for all nodes except leaves of the tree.

Sr,Sg,Sb

sums of the red, green, and blue component values for all pixels not classified at a lower depth. The combination of these sums and n2 will ultimately characterize the mean color of a set of pixels represented by this node.

E

the distance squared in RGB space between each pixel contained within a node and the nodes' center. This represents the quantization error for a node.

**Reduction**

Reduction repeatedly prunes the tree until the number of nodes with n2 > 0 is less than or equal to the maximum number of colors allowed in the output image. On any given iteration over the tree, it selects those nodes whose E value is minimal for pruning and merges their color statistics upward. It uses a pruning threshold, Ep, to govern node selection as follows:

Ep = 0
while number of nodes with (n2 > 0) > required maximum number of colors
   prune all nodes such that E <= Ep
   Set Ep  to minimum E in remaining nodes 

This has the effect of minimizing any quantization error when merging two nodes together.

When a node to be pruned has offspring, the pruning procedure invokes itself recursively in order to prune the tree from the leaves upward. The values of n2, Sr, Sg, and Sb in a node being pruned are always added to the corresponding data in that node's parent. This retains the pruned node's color characteristics for later averaging.

For each node, n2 pixels exist for which that node represents the smallest volume in RGB space containing those pixel's colors. When n2 > 0 the node will uniquely define a color in the output image. At the beginning of reduction, n2 = 0 for all nodes except the leaves of the tree which represent colors present in the input image.

The other pixel count, n1, indicates the total number of colors within the cubic volume which the node represents. This includes n1 - n2 pixels whose colors should be defined by nodes at a lower level in the tree.

**Assignment**

Assignment generates the output image from the pruned tree. The output image consists of two parts:

1.  A color map, which is an array of color descriptions (RGB triples) for each color present in the output image.
2.  A pixel array, which represents each pixel as an index into the color map array.

First, the assignment phase makes one pass over the pruned color description tree to establish the image's color map. For each node with n2 > 0, it divides Sr, Sg, and Sb by n2. This produces the mean color of all pixels that classify no lower than this node. Each of these colors becomes an entry in the color map.

Finally, the assignment phase reclassifies each pixel in the pruned tree to identify the deepest node containing the pixel's color. The pixel's value in the pixel array becomes the index of this node's mean color in the color map.

Empirical evidence suggests that the distances in color spaces such as YUV, or YIQ correspond to perceptual color differences more closely than do distances in RGB space. These color spaces may give better results when color reducing an image. Here the algorithm is as described except each pixel is a point in the alternate color space. For convenience, the color components are normalized to the range 0 to a maximum value, Cmax. The color reduction can then proceed as described.

Measuring Color Reduction Error
-------------------------------

Depending on the image, the color reduction error may be obvious or invisible. Images with high spatial frequencies (such as hair or grass) will show error much less than pictures with large smoothly shaded areas (such as faces). This because the high-frequency contour edges introduced by the color reduction process are masked by the high frequencies in the image.

To measure the difference between the original and color reduced images (the total color reduction error), ImageMagick sums over all pixels in an image the distance squared in RGB space between each original pixel value and its color reduced value. ImageMagick prints several error measurements including the mean error per pixel, the normalized mean error, and the normalized maximum error.

The normalized error measurement can be used to compare images. In general, the closer the mean error is to zero the more the quantized image resembles the source image. Ideally, the error should be perceptually-based, since the human eye is the final judge of quantization quality.

These errors are measured and printed when the [-colors] and [-verbose] options are specified on the [magick] command line:

mean error per pixel

is the mean error for any single pixel in the image.

normalized mean square error

is the normalized mean square quantization error for any single pixel in the image. This distance measure is normalized to a range between 0 and 1. It is independent of the range of red, green, and blue values in the image.

normalized maximum square error

is the largest normalized square quantization error for any single pixel in the image. This distance measure is normalized to a range between of red, green, and blue values in the image.


/Connected Components Labeling
=================================

## Uniquely Label Connected Regions

Connected-component labeling (alternatively connected-component analysis, blob extraction, region labeling, blob discovery, or region extraction) uniquely labels connected components in an image. The labeling process scans the image, pixel-by-pixel from top-left to bottom-right, in order to identify connected pixel regions, i.e. regions of adjacent pixels which share the same set of intensity values. For example, let's find the objects in this image:

![purse](https://imagemagick.org/image/objects.gif)

To identify the objects in this image, use this command:

magick objects.gif -connected-components 4 -auto-level -depth 8 objects.png

The detected objects are uniquely labeled. Use auto leveling to visualize the detected objects:

![Objects](https://imagemagick.org/image/objects.png)

Object statistics is useful to review. To display them, use this command:

magick objects.gif -define connected-components:verbose=true -connected-components 4 objects.png

Five objects were detected in the source image with these statistics:

Objects (id: bounding-box centroid area mean-color):
  0: 256x171+0+0 119.2,80.8 33117 srgb(0,0,0)
  2: 120x135+104+18 159.5,106.5 8690 srgb(255,255,255)
  3: 50x36+129+44 154.2,63.4 1529 srgb(0,0,0)
  4: 21x23+0+45 8.8,55.9 409 srgb(255,255,255)
  1: 4x10+252+0 253.9,4.1 31 srgb(255,255,255)

Add -define connected-components:exclude-header=true to show the objects without the header-line. Add -define connected-components:exclude-ids=true. Use -define connected-components:sort=area | width | height | x | y to sort the verbose connected components objects. By default, the objects are listed in decreasing area. Add -define connected-components:sort-order=increasing | decreasing to specify the sort order.

Use -connected-components 8 to visit 8 neighbors rather than 4. By default, neighbor colors must be exact to be part of a unique object. Use the [-fuzz] option to include pixels as part of an object that are close in color.

You might want to eliminate small objects by merging them with their larger neighbors. If so, use this command:

magick objects.gif -define connected-components:area-threshold=410 -connected-components 4 \
  -auto-level objects.jpg

Here are the expected results. Notice, how the small objects are now merged with the background.

![Objects](https://imagemagick.org/image/objects.jpg)

Notice how two of the objects were merged leaving three remaining objects:

Objects (id: bounding-box centroid area mean-color):
  0: 256x171+0+0 118.0,80.4 33557 srgb(0,0,0)
  2: 120x135+104+18 159.5,106.5 8690 srgb(255,255,255)
  3: 50x36+129+44 154.2,63.4 1529 srgb(0,0,0)

By default, the labeled image is grayscale. You can instead replace the object color in the labeled image with the mean-color from the source image. Simply add this setting, -define connected-components:mean-color=true, to your command line.

Thresholds can optionally include ranges, e.g. -define connected-components:area-threshold=410-1600. To keep the background object, identify it with -define connected-components:background-id=object-id. The default background object is the object with the largest area.

In addition to area, there is support for these thresholding metrics:

*   connected-components:angle-threshold (from equivalent ellipse)
*   connected-components:circularity-threshold (4*pi*area/perimeter^2)
*   connected-components:diameter-threshold (sqrt(4*area/pi))
*   connected-components:eccentricity-threshold (from equivalent ellipse)
*   connected-components:major-axis-threshold (diameter from equivalent ellipse)
*   connected-components:minor-axis-threshold (diameter from equivalent ellipse)
*   connected-components:perimeter-threshold

You may want to remove certain objects. Use -define connected-components:remove-ids=_list-of-ids_ (e.g. -define connected-components:remove-ids=2,4-5). Or use -define connected-components:keep-ids=_list-of-ids_ to keep these objects and merge all others. For convenience, you can keep the top objects with this option: -define connected-components:keep-top=_number-of-objects_. Rather than object ids, you can instead remove or keep objects identified by there color, e.g. -define connected-components:keep-colors=_red;green;blue_.

Objects in your image may look homogeneous but have slightly different color values. By default, only pixels that match exactly are considered as part of a particular object. For slight variations of color in an object, use -fuzz. For example,

magick star-map.png -fuzz 5% -define connected-components:verbose=true \
  -define connected-components:mean-color=true -connected-components 4 stars.gif

#### Connected Components

The algorithm walks through the pixels of a component, in the usual row-column order, looking for a component above or to the left. For the component at top-left, there are no components above or to the left to merge into. As a result, there are special cases where you need to rotate, repeat the connected components, then rotate back. For example

     magick  \
      objects.gif  \
      -define connected-components:verbose=true \
      -define connected-components:area-threshold=6000 \
      -virtual-pixel None \
      -connected-components 4 -rotate 180 \
      -connected-components 4 -rotate -180 \
      objects.png


/Identify Image Foreground Objects
==================================

[Convex Hull] • [Minimum Bounding Box] • [Unrotate an Image]

The convex hull is the is the smallest area convex polygon containing the set of points inside it. The convex hull may be visualized as the shape enclosed by a rubber band stretched around the set of points.

The convex-hull string format returns a list of x,y coordinates of the vertices of the convex-hull polygon containing all the non-black pixels within it.

magick [-fuzz value%] [-background background-color] -format "%[convex-hull]" info:

Use %[convex-hull:extreme-points] to only return the top, right, bottom, and left extreme points.

where the string format is sensitive to an optional -fuzz value and to an optional background color specified by the define. The command above will find the background color automatically according to the fuzz value unless the background color is defined. The fuzz value defaults to 0 when not specified.

For example, consider the following white rectangle on a black background:

![Convex Hull](https://imagemagick.org/image/convex-hull.png)

The convex hull set of points may be computed as:

magick rect.png -format "%[convex-hull]" info:
190,121 193,122 281,154 377,189 378,190 377,193 345,281 310,377 309,378 306,377 218,345 122,310 121,309 122,306 154,218 189,122 190,121

The convex hull may also be drawn as a polygon (filled or unfilled) using -draw as follows:

magick rect.png -set option:hull "%[convex-hull]" -fill none -stroke red -strokewidth 1 -draw "polygon %[hull]" blocks_hull.png

Here is an example using a non-convex shaped image on a black background:

![Convex Hull Blocks](https://imagemagick.org/image/convex-hull-blocks.png)

magick blocks_black.png -set option:hull "%[convex-hull]" -fill none -stroke red -strokewidth 1 -draw "polygon %[hull]" blocks_hull.png

![Convex Hull Blocks Closure](https://imagemagick.org/image/convex-hull-blocks-closure.png)

Finally, here is an example with a non-constant, non-black background using -fuzz to determine the background color:

![Convex Hull Barn](https://imagemagick.org/image/convex-hull-barn.jpg)

Now let's highlight the convex hull of the image foreground object:

magick barn_rot20.png -fuzz 10% -set hull "%[convex-hull]" -fill none -stroke red -strokewidth 1 -draw "polygon %[hull]" barn_rot20_hull.png

![Convex Hull Barn Closure](https://imagemagick.org/image/convex-hull-barn-closure.jpg)

Minimum Bounding Box
--------------------

Similar to the convex hull of the image foreground object(s), is the minimum bounding box. Use %[minimum-bounding-box] to return the points that make up the bounding box. In addition, these properties are set: minimum-bounding-box:area, minimum-bounding-box:width, minimum-bounding-box:height, and minimum-bounding-box:angle.

magick barn_rot20.png -fuzz 10% -background gray25 -set MBR "%[minimum-bounding-box]" -fill none -stroke red -strokewidth 1 -draw "polygon %[MBR]" barn-mbr.png

Unrotate an Image
-----------------

Use %[minimum-bounding-box:unrotate] to correct for any rotation the image may exhibit. Unless you specify the image orientation, the unrotate angle should properly align the image to the correct coordinate axis for angles <= 45. For angles > 45, the image will align with the wrong coordinate axis. Set the correct image orientation to ensure the proper unrotate angle is returned. Use -define minimum-bounding-box:orientation=_{landscape,portrait}_ to set the image orientation. Note, that like convex-hull, the string format is sensitive to an optional [-fuzz] value and an optional [-background] color.

The barn image above is rotated by 20 degrees. Here is how we can automatically correct for the rotation and return it to its original landscape orientation:

magick barn_rotate20.jpg -fuzz 15% -set option:angle "%[minimum-bounding-box:unrotate]" -background gray -rotate "%[angle]" -trim barn_unrotate.jpg



/Command-line Tools
===================

ImageMagick is a collection of command-line tools that can be used to modify and manipulate images. While many people are used to using graphical user interfaces (GUIs) like Gimp or Photoshop to edit images individually, these tools may not always be practical. For instance, if you need to process an image dynamically from a web script or apply the same operations to multiple images, or if you need to repeat a specific operation on the same or different images at different times, using a command-line utility like ImageMagick may be more efficient.

The ImageMagick [command-line] tools exit with a status of 0 if the command line arguments have a proper syntax and no problems are encountered. Expect a descriptive message and an exit status of 1 if any exception occurs such as improper syntax, a problem reading or writing an image, or any other problem that prevents the command from completing successfully.

Here is a short description for each command-line tool. Click on the program name to get details about the program usage and a list of command-line options that alters how the program behaves. If you are just getting acquainted with ImageMagick, start with the [magick] program. Be sure to peruse Anthony Thyssen's tutorial on how to use ImageMagick utilities to [create, edit, compose, or convert] images from the command-line.

[magick]

convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more.

[magick-script]

use this scripting language interpreter to convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more.

We also support sub-commands for compatibility with ImageMagick [version 6](http://legacy.imagemagick.org):

[magick animate]

animate an image sequence on any X server.

[magick compare]

mathematically and visually annotate the difference between an image and its reconstruction.

[magick composite]

overlap one image over another.

[magick conjure]

interpret and execute scripts written in the Magick Scripting Language (MSL).

[magick convert]

convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more.

[magick display]

display an image or image sequence on any X server.

[magick identify]

describe the format and characteristics of one or more image files.

[magick import]

save any visible window on an X server and outputs it as an image file. You can capture a single window, the entire screen, or any rectangular portion of the screen.

[magick mogrify]

resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more. Mogrify overwrites the original image file, whereas, [magick] writes to a different image file.

[magick montage]

create a composite image by combining several separate images. The images are tiled on the composite image optionally adorned with a border, frame, image name, and more.

[magick stream]

a lightweight tool to stream one or more pixel components of the image or portion of the image to your choice of storage formats. It writes the pixel components as they are read from the input image a row at a time making stream desirable when working with large images or when you require raw pixel components.

Your installation may have direct ImageMagick version 6 compatibility links. If so, you can access the tools directly by referring to them by name. For example,

magick identify -verbose myImage.png

/Format and Print Image Properties
==================================

There are copious amounts of extra data associated with images (metadata), beyond the actual image pixels. This metadata can be useful, either for display, or for various calculations, or in modifying the behavior of later image processing operations. You can utilize percent escapes in a number of options, for example in [-format] or in montage [-label], to print various properties and other settings associated with an image.

*   **Profile Data**

    Such as EXIF: data, containing focal lengths, exposures, dates, and in some cases GPS locations.

*   **Attributes**

    These are directly involved with image data, and more commonly modified as part of normal image processing. These include width, height, depth, image type (colorspace), timing delays, and background color. Most specific percent escapes is to access this information.

*   **Properties**

    These are stored as a table of free form strings, and are (if possible) saved with the image (especially in MIFF and PNG image file formats). These include: Labels, Captions, Comments.

*   **Artifacts**

    These are various operational (expert) settings that are saved for use by various operators, or by the user for future use. It is just a table of free-form strings. They are not saved with the image when written. See Artifacts and Options below for details.

*   **Options**

    Also operational (expert) settings that are saved for use by various operators, but are set globally for use by a whole image list (also not saved). See Artifacts and Options below.

Percent Escape Handling
-----------------------

If you request a percent escape such as %[key] the setting is looked for in the following order until the first match has been found...

1.  Handle special prefixes such as 'artifact:' 'option:' 'exif:', or 'fx:'. This includes and calculations and or globs of those prefixes such as 'exif:*' or 'artifact:*' (see below).
2.  If key contains a glob pattern (but no known prefix) search free-form properties table.
3.  If key is a special image 'attribute' name (see list above) return the associated or calculated image attribute.
4.  Search for setting as a free-form 'property'
5.  Search for setting as a free-form 'artifact'
6.  Search for setting as a free-form 'option'
7.  Replace escape with empty string, and perhaps produce a warning.

Remember, all long name forms of percent escapes are handled in a is case insensitive manner.

You can now access the Artifact and Option free-form string tables directly, allowing you to override the above sequence, and avoid accessing an attribute or property of the same name.

    %[artifact:setting]
    %[option:setting] 

Escape handling requires access to an image container. If none are available, a blank image is created to ensure the expression can be processed and a value returned. For example: 

    magick -print "%[fx:.8765/3.14]" null: null:

Single Letter Attribute Percent Escapes
---------------------------------------

Here are common single letter escapes (short form) is used to report the most common attributes and properties of an image, such as: the image filename filename, type, width, height.

*   `   \   ` backslash, the next character is literal and not subject to interpretation
*   `   \n  ` newline
*   `   \r  ` carriage return
*   `   <   ` less-than character.
*   `   >  ` greater-than character.
*   `   &   ` ampersand character.
*   `   %%  ` a percent sign
*   `   %b  ` file size of image read in (use [-precision] 16 to force results in B)
*   `   %c  ` comment meta-data property
*   `   %d  ` directory component of path
*   `   %e  ` filename extension or suffix
*   `   %f  ` filename (including suffix)
*   `   %g  ` layer canvas page geometry (equivalent to "%Wx%H%X%Y")
*   `   %h  ` current image height in pixels
*   `   %i  ` image filename (note: becomes output filename for "info:")
*   `   %k  ` CALCULATED: number of unique colors
*   `   %l  ` label meta-data property
*   `   %m  ` image file format (file magic)
*   `   %n  ` number of images in current image sequence, report once per frame
*   `   %o  ` output filename (used for delegates)
*   `   %p  ` index of image in current image list
*   `   %q  ` quantum depth (compile-time constant)
*   `   %r  ` image class and colorspace
*   `   %s  ` scene number (from input unless re-assigned)
*   `   %t  ` filename without directory or extension (suffix)
*   `   %u  ` unique temporary filename (used for delegates)
*   `   %w  ` current width in pixels
*   `   %x  ` x resolution (density)
*   `   %y  ` y resolution (density)
*   `   %z  ` image depth (as read in unless modified, image save depth)
*   `   %A  ` image transparency channel. Values include Undefined (no transparency channel), Blend, Copy, or Update.
*   `   %B  ` file size of image read in bytes
*   `   %C  ` image compression type
*   `   %D  ` image GIF dispose method
*   `   %G  ` original image size (%wx%h; before any resizes)
*   `   %H  ` page (canvas) height
*   `   %M  ` Magick filename (original file exactly as given, including read mods)
*   `   %N  ` number of images in current image sequence, report once per image sequence
*   `   %O  ` page (canvas) offset ( = %X%Y )
*   `   %P  ` page (canvas) size ( = %Wx%H )
*   `   %Q  ` image compression quality ( 0 = default )
*   `   %S  ` ?? scenes ??
*   `   %T  ` image time delay (in centi-seconds)
*   `   %U  ` image resolution units
*   `   %W  ` page (canvas) width
*   `   %X  ` page (canvas) x offset (including sign)
*   `   %Y  ` page (canvas) y offset (including sign)
*   `   %Z  ` unique filename (used for delegates)
*   `   %@  ` CALCULATED: trim bounding box (without actually trimming)
*   `   %#  ` CALCULATED: 'signature' hash of image values

Here is a sample command and its output for an image with filename bird.miff and whose width is 512 and height is 480.

    -> identify -format "%m:%f %wx%h" bird.miff
    MIFF:bird.miff 512x480 

Note that all single letter percent escapes can also be used using long form (from IM version 6.7.6-9, see next). For example %[f] is equivalent to the %f short form.

**WARNING**: short form percent escapes are NOT performed when the percent is after a number. For example, 10%x10 does not expand the %x as a percent escape. If you specifically want to expand the 'x', use the long form which overrides this special case. EG: 10%[x]10.

Also be warned that calculated attributes can take some time to generate, especially for large images.

Long Form Attribute Percent Escapes
-----------------------------------

In addition to the above specific and calculated attributes are recognized when enclosed in braces (long form):

*   `   %[basename]    ` base filename, no suffixes (as %t)
*   `   %[bit-depth]   ` Actual bit-depth of the pixel data
*   `   %[bounding-box]    ` upper left and lower right corners of the image bounding box
*   `   %[caption]     ` caption meta-data property
*   `   %[caption:lines]   ` returns the number lines generated when wrapping the caption
*   `   %[caption:pointsize]   ` returns the pointsize computed during caption: processing
*   `   %[channels]    ` colorspace neumonic followed by total number of channels and meta channets, e.g., `cmyka 8.3` indicates a CMYK image with alpha channel for a total of 8 channels and 3 meta channels.
*   `   %[colors]  ` Number of unique colors in the image (as of IM 7.0.3.8)
*   `   %[colorspace]  ` colorspace of Image Data (excluding transparency)
*   `   %[compose]     ` 
*   `   %[compression]     ` image compression type
    [%[convex-hull]]

    points that form a convex hull around the foreground object. Use [-define] convex-hull:background-color=_color_ to identify the image background color. Use [-fuzz] to allow for a non-uniform background color.

    [%[convex-hull:extreme-points]]

    return the top, right, bottom, and left extreme points of the convex hull.

*   `   %[copyright]   ` ImageMagick Copyright String
*   `   %[depth]   ` depth of image for write (as input unless changed)
*   `   %[deskew:angle]    ` The deskew angle in degrees of rotation
*   `   %[directory]   ` directory part of filename (as %d)
*   `   %[distortion]  ` how well an image resembles a reference image ([-compare])
*   `   %[dominant-color]  ` return the dominate image color in hex. Preceed usage with [-kmeans].
*   `   %[entropy]     ` CALCULATED: entropy of the image
*   `   %[extension]   ` extension part of filename (as %e)
*   `   %[gamma]   ` value of image gamma
*   `   %[group]   ` ??? window group ???
*   `   %[height]  ` original height of image (when it was read in)
*   `   %[histogram:contrast-stretch]  ` computed min and max contrast stretch percentage
*   `   %[histogram:linear-stretch]    ` computed min and max linear stretch percentage
*   `   %[input]   ` 
*   `   %[interlace]   ` Image interlace mode (as of IM 7.0.3.8)
*   `   %[kurtosis]    ` CALCULATED: kurtosis statistic of image
*   `   %[label]   ` label meta-data property
*   `   %[label:pointsize]     ` returns the pointsize computed during label: processing
*   `   %[magick]  ` coder used to read image (not the file suffix)
*   `   %[max]     ` CALCULATED: maximum value statistic of image
*   `   %[mean]    ` CALCULATED: average value statistic of image
*   `   %[median]  ` CALCULATED: median value statistic of image
*   `   %[min]     ` CALCULATED: minimum value statistic of image

    [%[minimum-bounding-box]]

    Use [-define] convex-hull:background-color=_color_ to identify the image background color. Use [-fuzz] to allow for a non-uniform background color. In addition to the bounding box points, these properties are set: minimum-bounding-box:area, minimum-bounding-box:width, minimum-bounding-box:height, minimum-bounding-box:angle, and minimum-bounding-box:unrotate.

*   `   %[opaque]  ` CALCULATED: is image fully-opaque?
*   `   %[orientation]     ` image orientation
*   `   %[page]    ` Virtual canvas (page) geometry
*   `   %[papersize:_name_]    ` paper size for _name_ in pixels at 72DPI (e.g. papersize:A4)
*   `   %[printsize.x]     ` X printsize
*   `   %[printsize.y]     ` Y printsize
*   `   %[profile:icc]     ` ICC profile info
*   `   %[profile:icm]     ` ICM profile info
*   `   %[profiles]    ` list of any embedded profiles
*   `   %[quality]     ` Image quality value (as of IM 7.0.3.8)
*   `   %[rendering-intent]    ` Image rendering intent (as of IM 7.0.3.8)
*   `   %[resolution.x]    ` X density (resolution) without units
*   `   %[resolution.y]    ` Y density (resolution) without units
*   `   %[scene]   ` original scene number of image in input file
*   `   %[size]    ` original size of image (when it was read in)
*   `   %[skewness]    ` CALCULATED: skewness statistic of image
*   `   %[standard-deviation]  ` CALCULATED: standard deviation statistic of image
*   `   %[type]    ` CALCULATED: image type
*   `   %[unique]  ` unique temporary filename ???
*   `   %[units]   ` image resolution units
*   `   %[version]     ` Version Information of this running ImageMagick
*   `   %[width]   ` original width of image (when it was read in)
*   `   %[zero]    ` zero (unique filename for delegate use)


Properties
----------

All other long forms of percent escapes (not single letter long form) are handled in a case insensitive manner. Such escapes will attempt to look up that name specific data sources.

The primary search space (if not a specific attribute listed above) is a free-form property string. Such strings are associated and saved with images, and are typically set using either the [-set] CLI option (or API equivalent), or from special convenience options (such as [-label], [-comment], [-caption]).

These convenience options are globally saved (as 'global options' so thay can be set before images are read), and later are transferred to the property of individual images, only when they are read in. At that time any internal percent escape present is then handled.

To change a property of an image already in memory, you need to use [-set].

Note that properties, like attributes (and profiles), are saved with images when write, if the image file format allows.

Artifacts and Options
---------------------

The previous percent escapes are associated with the primary Attributes and Properties. Which is the original and primary focus of such percent escapes.

However there are many operational settings that are used by various ImageMagick operators that can be useful to set and later access. These consist of per-image Artifacts, and Global options (associated with a list of images, typically the current image list).

Note that the major difference between an artifact and a property is that artifacts, being an internal operational setting, is not saved with images (if such is possible).

For example when you use -define 'distort:viewport=100x100' you are in fact generating a global option, which the [-distort] operator will use to modify its behavior (distorted output image 'view').

An Option is essentially an Artifact that has been stored globally as part of a list of images (specifically a 'Wand' of images). As such they are identical, in that a Option, is simply a global Artifact for all the associated images.

As such you can use -set 'option:distort:viewport' '100x100' to achieve the same result of setting a Artifact for the disort operation to use.

**Internal Handling of a Global Option...**

The Core library ('MagickCore') does not generally directly understand Global Options. As such, continuing the previous example, the DistortImages() function only looks up an artifact to discover if a 'viewport' has been provided to it.

How Global Options are used when a library function requests an Artifact is one of the key differences between IMv6 and IMv7.

Sets a link back to the global options data, so that if a specific per-image Artifact is not found , then it will look for a equivalent global Option for that image list. directly. This saves coping these free-form options into artifacts repeatedly, and means you can now separately define a global option for a list, and a individual overriding artifact for a specific image in that list.

Note that many API's that do not use Wands (PerlMagick for example using arrays of images rather than a Wand). In these API's you will not have Global Options, only per-image Artifacts.

In summery a Global Option, if available, is equivalent to a per-image Artifact.

Glob-Pattern Listing of Properties, Artifacts and Options
---------------------------------------------------------

The setting can contain a glob pattern. As such you can now list all free-form string properties, artifacts, and options, (but not specific image attributes) using...

    magick ... \
       -print "__Properties__\n%[*]" \
       -print "__Artifacts__\n%[artifact:*]" \
       -print "__Options__\n%[option:*]" \
       ...  

The format of glob patterns are very specific and as such is generally only used to list specific settings, such as when debugging, rather than being used for image processing use.

Calculated Percent Escape Prefixes
----------------------------------

There are some special prefixes (before the first ':') which performs calculations based on the user provided string that follows that prefix. For example you can do a numerical calculation use %[fx:...] to evaluate the given [FX] expressions:

    %[fx:expression] 

Use pixel: or hex: to evaluate a pixel color as defined by the [FX] expression:

    %[pixel:expression] 

Use [-define] to specify the color compliance (e.g. -define pixel:compliance=css)

.

Specific Profile Percent Escape Prefixes
----------------------------------------

You can also use the following special formatting syntax to print EXIF mage meta-data that was included in the image read in:

    %[EXIF:tag] 

Choose tag from the following:

    *  (print all EXIF tags, in keyword=data format)
    !  (print all EXIF tags, in tag_number data format)
    #hhhh (print data for EXIF tag #hhhh)
    ImageWidth                            InterColorProfile
    ImageLength                           ExposureProgram
    BitsPerSample                         SpectralSensitivity
    Compression                           GPSInfo
    PhotometricInterpretation             ISOSpeedRatings
    FillOrder                             OECF
    DocumentName                          EXIFVersion
    ImageDescription                      DateTimeOriginal
    Make                                  DateTimeDigitized
    Model                                 ComponentsConfiguration
    StripOffsets                          CompressedBitsPerPixel
    Orientation                           ShutterSpeedValue
    SamplesPerPixel                       ApertureValue
    RowsPerStrip                          BrightnessValue
    StripByteCounts                       ExposureBiasValue
    XResolution                           MaxApertureValue
    YResolution                           SubjectDistance
    PlanarConfiguration                   MeteringMode
    ResolutionUnit                        LightSource
    TransferFunction                      Flash
    Software                              FocalLength
    DateTime                              MakerNote
    Artist                                UserComment
    WhitePoint                            SubSecTime
    PrimaryChromaticities                 SubSecTimeOriginal
    TransferRange                         SubSecTimeDigitized
    JPEGProc                              FlashPixVersion
    JPEGInterchangeFormat                 ColorSpace
    JPEGInterchangeFormatLength           EXIFImageWidth
    YCbCrCoefficients                     EXIFImageLength
    YCbCrSubSampling                      InteroperabilityOffset
    YCbCrPositioning                      FlashEnergy
    ReferenceBlackWhite                   SpatialFrequencyResponse
    CFARepeatPatternDim                   FocalPlaneXResolution
    CFAPattern                            FocalPlaneYResolution
    BatteryLevel                          FocalPlaneResolutionUnit
    Copyright                             SubjectLocation
    ExposureTime                          ExposureIndex
    FNumber                               SensingMethod
    IPTC/NAA                              FileSource
    EXIFOffset                            SceneType
                                                   

  

Surround the format specification with quotation marks to prevent your shell from misinterpreting any spaces and square brackets.

The following special formatting syntax can be used to print IPTC information contained in the file:

    %[IPTC:dataset:record] 

Select dataset and record from the following:

    Envelope Record
      1:00  Model Version
      1:05  Destination
      1:20  File Format
      1:22  File Format Version
      1:30  Service Identifier
      1:40  Envelope Number
      1:50  Product ID
      1:60  Envelope Priority
      1:70  Date Sent
      1:80  Time Sent
      1:90  Coded Character Set
      1:100  UNO (Unique Name of Object)
      1:120  ARM Identifier
      1:122  ARM Version

    Application Record
      2:00  Record Version
      2:03  Object Type Reference
      2:05  Object Name (Title)
      2:07  Edit Status
      2:08  Editorial Update
      2:10  Urgency
      2:12  Subject Reference
      2:15  Category
      2:20  Supplemental Category
      2:22  Fixture Identifier
      2:25  Keywords
      2:26  Content Location Code
      2:27  Content Location Name
      2:30  Release Date
      2:35  Release Time
      2:37  Expiration Date
      2:38  Expiration Time
      2:40  Special Instructions
      2:42  Action Advised
      2:45  Reference Service
      2:47  Reference Date
      2:50  Reference Number
      2:55  Date Created
      2:60  Time Created
      2:62  Digital Creation Date
      2:63  Digital Creation Time
      2:65  Originating Program
      2:70  Program Version
      2:75  Object Cycle
      2:80  By-Line (Author)
      2:85  By-Line Title (Author Position) [Not used in Photoshop 7]
      2:90  City
      2:92  Sub-Location
      2:95  Province/State
      2:100  Country/Primary Location Code
      2:101  Country/Primary Location Name
      2:103  Original Transmission Reference
      2:105  Headline
      2:110  Credit
      2:115  Source
      2:116  Copyright Notice
      2:118  Contact
      2:120  Caption/Abstract
      2:122  Caption Writer/Editor
      2:125  Rasterized Caption
      2:130  Image Type
      2:131  Image Orientation
      2:135  Language Identifier
      2:150  Audio Type
      2:151  Audio Sampling Rate
      2:152  Audio Sampling Resolution
      2:153  Audio Duration
      2:154  Audio Outcue
      2:200  ObjectData Preview File Format
      2:201  ObjectData Preview File Format Version
      2:202  ObjectData Preview Data

    Pre-ObjectData Descriptor Record
      7:10   Size Mode
      7:20   Max Subfile Size
      7:90   ObjectData Size Announced
      7:95   Maximum ObjectData Size

    ObjectData Record
      8:10   Subfile

    Post ObjectData Descriptor Record
      9:10   Confirmed ObjectData Size


/Exceptions
===========

ImageMagick returns a status of 0 whenever a command or algorithm successfully complete without complaint. A warning code generally is typically just a notice that something unusual occurred but the command or algorithm still completed and most likely the results are still usable. An error means the command or algorithm could not complete as expected and any results are unreliable. A fatal error means the command or algorithm could not complete and the process exits prematurely and no results are returned.

ImageMagick Error and Warning Codes

|      Domain      | Warning | Error | Fatal |                                       Description                                       |
|------------------|---------|-------|-------|-----------------------------------------------------------------------------------------|
| Success          |       0 |     0 |     0 | the command or algorithm completed successfully without complaint                       |
| Resource Limit   |     300 |   400 |   700 | a program resource is exhausted (e.g. not enough memory)                                |
| Type             |     305 |   405 |   705 | A font is unavailable; a substitution may have occurred                                 |
| Option           |     310 |   410 |   710 | a command-line option was malformed                                                     |
| Delegate         |     315 |   415 |   715 | an ImageMagick _delegate_ failed to complete                                            |
| Missing Delegate |     320 |   420 |   720 | the image type can not be read or written because the appropriate _Delegate_ is missing |
| Corrupt Image    |     325 |   425 |   725 | the image file may be corrupt                                                           |
| FileOpen         |     330 |   430 |   730 | the image file could not be opened for reading or writing                               |
| Blob             |     335 |   435 |   735 | a binary large object could not be allocated, read, or written                          |
| Stream           |     340 |   440 |   740 | there was a problem reading or writing from a stream                                    |
| Cache            |     345 |   445 |   745 | pixels could not be read or written to the pixel cache                                  |
| Coder            |     350 |   450 |   750 | there was a problem with an image coder                                                 |
| Module           |     355 |   455 |   755 | there was a problem with an image module                                                |
| Draw             |     360 |   460 |   760 | a drawing operation failed                                                              |
| Image            |     365 |   465 |   765 | the operation could not complete due to an incompatible image                           |
| Wand             |     370 |   470 |   770 | there was a problem specific to the MagickWand API                                      |
| Random           |     375 |   475 |   775 | there is a problem generating a true or pseudo-random number                            |
| XServer          |     380 |   480 |   780 | an X resource is unavailable                                                            |
| Monitor          |     385 |   485 |   785 | there was a problem activating the progress monitor                                     |
| Registry         |     390 |   490 |   790 | there was a problem getting or setting the registry                                     |
| Configure        |     395 |   495 |   795 | there was a problem getting a configuration file                                        |
| Policy           |     399 |   499 |   799 | a policy denies access to a delegate, coder, filter, path, or resource.                 |

/Annotated List of Command-line Options
=======================================

  

Select CLI Option

*   [**A**]
    *   [adaptive-blur]
    *   [adaptive-resize]
    *   [adaptive-sharpen]
    *   [adjoin]
    *   [affine]
    *   [alpha]
    *   [annotate]
    *   [antialias]
    *   [append]
    *   [attenuate]
    *   [authenticate]
    *   [auto-gamma]
    *   [auto-level]
    *   [auto-orient]
    *   [auto-threshold]
*   [**B**]
    *   [backdrop]
    *   [background]
    *   [bench]
    *   [bias]
    *   [bilateral-blur]
    *   [black-point-compensation]
    *   [black-threshold]
    *   [blend]
    *   [blue-primary]
    *   [blue-shift]
    *   [blur]
    *   [border]
    *   [bordercolor]
    *   [borderwidth]
    *   [brightness-contrast]
*   [**C**]
    *   [cache]
    *   [canny]
    *   [caption]
    *   [cdl]
    *   [channel]
    *   [channel-fx]
    *   [charcoal]
    *   [chop]
    *   [clahe]
    *   [clamp]
    *   [clip]
    *   [clip-mask]
    *   [clip-path]
    *   [clone]
    *   [clut]
    *   [coalesce]
    *   [colorize]
    *   [colormap]
    *   [color-matrix]
    *   [colors]
    *   [colorspace]
    *   [color-threshold]
    *   [combine]
    *   [comment]
    *   [compare]
    *   [complex]
    *   [compose]
    *   [composite]
    *   [compress]
    *   [connected-components]
    *   [contrast]
    *   [contrast-stretch]
    *   [convolve]
    *   [copy]
    *   [crop]
    *   [cycle]
*   [**D**]
    *   [debug]
    *   [decipher]
    *   [deconstruct]
    *   [define]
    *   [delay]
    *   [delete]
    *   [density]
    *   [depth]
    *   [descend]
    *   [deskew]
    *   [despeckle]
    *   [direction]
    *   [displace]
    *   [display]
    *   [dispose]
    *   [dissimilarity-threshold]
    *   [dissolve]
    *   [distort]
    *   [distribute-cache]
    *   [dither]
    *   [draw]
    *   [duplicate]
*   [**E**]
    *   [edge]
    *   [emboss]
    *   [encipher]
    *   [encoding]
    *   [endian]
    *   [enhance]
    *   [equalize]
    *   [evaluate]
    *   [evaluate-sequence]
    *   [exit]
    *   [extent]
    *   [extract]
*   [**F**]
    *   [family]
    *   [features]
    *   [fft]
    *   [fill]
    *   [filter]
    *   [flatten]
    *   [flip]
    *   [floodfill]
    *   [flop]
    *   [font]
    *   [foreground]
    *   [format]
    *   [format[identify]]
    *   [frame]
    *   [frame[import]]
    *   [function]
    *   [fuzz]
    *   [fx]
*   [**G**]
    *   [gamma]
    *   [gaussian-blur]
    *   [geometry]
    *   [gravity]
    *   [grayscale]
    *   [green-primary]
*   [**H**]
    *   [hald-clut]
    *   [help]
    *   [highlight-color]
    *   [hough-lines]
*   [**I**]
    *   [iconGeometry]
    *   [iconic]
    *   [identify]
    *   [ift]
    *   [illuminant]
    *   [immutable]
    *   [implode]
    *   [insert]
    *   [intensity]
    *   [intent]
    *   [interlace]
    *   [interline-spacing]
    *   [interpolate]
    *   [interpolative-resize]
    *   [interword-spacing]
    *   [integral]
*   [**K**]
    *   [kerning]
    *   [kmeans]
    *   [kuwahara]
*   [**L**]
    *   [label]
    *   [lat]
    *   [layers]
    *   [level]
    *   [level-colors]
    *   [limit]
    *   [linear-stretch]
    *   [linewidth]
    *   [liquid-rescale]
    *   [list]
    *   [log]
    *   [loop]
    *   [lowlight-color]
*   [**M**]
    *   [magnify]
    *   [map]
    *   [map[stream]]
    *   [mattecolor]
    *   [median]
    *   [mean-shift]
    *   [metric]
    *   [mode]
    *   [modulate]
    *   [moments]
    *   [monitor]
    *   [monochrome]
    *   [morph]
    *   [morphology]
    *   [mosaic]
    *   [motion-blur]
*   [**N**]
    *   [name]
    *   [negate]
    *   [noise]
    *   [normalize]
*   [**O**]
    *   [opaque]
    *   [ordered-dither]
    *   [orient]
*   [**P**]
    *   [page]
    *   [paint]
    *   [path]
    *   [pause[animate]]
    *   [pause[import]]
    *   [perceptible]
    *   [ping]
    *   [pointsize]
    *   [polaroid]
    *   [poly]
    *   [posterize]
    *   [precision]
    *   [preview]
    *   [print]
    *   [process]
    *   [profile]
*   [**Q**]
    *   [quality]
    *   [quantize]
    *   [quiet]
*   [**R**]
    *   [raise]
    *   [random-threshold]
    *   [range-threshold]
    *   [read]
    *   [read-mask]
    *   [red-primary]
    *   [regard-warnings]
    *   [region]
    *   [remap]
    *   [remote]
    *   [render]
    *   [repage]
    *   [resample]
    *   [resize]
    *   [respect-parentheses]
    *   [reverse]
    *   [roll]
    *   [rotate]
    *   [rotational-blur]
*   [**S**]
    *   [sample]
    *   [sampling-factor]
    *   [scale]
    *   [scene]
    *   [screen]
    *   [seed]
    *   [segment]
    *   [selective-blur]
    *   [separate]
    *   [sepia-tone]
    *   [set]
    *   [shade]
    *   [shadow]
    *   [shared-memory]
    *   [sharpen]
    *   [shave]
    *   [shear]
    *   [sigmoidal-contrast]
    *   [silent]
    *   [similarity-threshold]
    *   [size]
    *   [sketch]
    *   [smush]
    *   [snaps]
    *   [solarize]
    *   [sort-pixels]
    *   [sparse-color]
    *   [splice]
    *   [spread]
    *   [statistic]
    *   [stegano]
    *   [stereo]
    *   [storage-type]
    *   [stretch]
    *   [strip]
    *   [stroke]
    *   [strokewidth]
    *   [style]
    *   [subimage-search]
    *   [swap]
    *   [swirl]
    *   [synchronize]
*   [**T**]
    *   [taint]
    *   [text-font]
    *   [texture]
    *   [threshold]
    *   [thumbnail]
    *   [tile]
    *   [tile-offset]
    *   [tint]
    *   [title]
    *   [transform]
    *   [transparent]
    *   [transparent-color]
    *   [transpose]
    *   [transverse]
    *   [treedepth]
    *   [trim]
    *   [type]
*   [**U**]
    *   [undercolor]
    *   [unique-colors]
    *   [units]
    *   [unsharp]
    *   [update]
*   [**V**]
    *   [verbose]
    *   [version]
    *   [view]
    *   [vignette]
    *   [virtual-pixel]
    *   [visual]
*   [**W**]
    *   [watermark]
    *   [wave]
    *   [wavelet-denoise]
    *   [weight]
    *   [white-balance]
    *   [white-point]
    *   [white-threshold]
    *   [window]
    *   [window-group]
    *   [word-break]
    *   [write]
    *   [write-mask]

Below is list of command-line options recognized by the ImageMagick [command-line tools]. If you want a description of a particular option, click on the option name in the navigation bar above and you will go right to it. Unless otherwise noted, each option is recognized by the commands: [convert] and [mogrify].

-adaptive-blur radius[xsigma]
--------------------------------

Adaptively blur pixels, with decreasing effect near edges.

A Gaussian operator of the given radius and standard deviation (sigma) is used. If sigma is not given it defaults to 1.

The sigma value is the important argument, and determines the actual amount of blurring that will take place.

The radius is only used to determine the size of the array which holds the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

-adaptive-resize geometry
--------------------------

Resize the image using data-dependent triangulation.

See [Image Geometry] for complete details about the _geometry_ argument. The [-adaptive-resize] option defaults to data-dependent triangulation. Use the [-filter] to choose a different resampling algorithm. Offsets, if present in the geometry string, are ignored, and the [-gravity] option has no effect.

-adaptive-sharpen radius[xsigma]
-----------------------------------

Adaptively sharpen pixels, with increasing effect near edges.

A Gaussian operator of the given radius and standard deviation (sigma) is used. If sigma is not given it defaults to 1.

The sigma value is the important argument, and determines the actual amount of blurring that will take place.

The radius is only used to determine the size of the array which holds the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

-adjoin
--------

Join images into a single multi-image file.

This option is enabled by default. An attempt is made to save all images of an image sequence into the given output file. However, some formats, such as JPEG and PNG, do not support more than one image per file, and in that case ImageMagick is forced to write each image as a separate file. As such, if more than one image needs to be written, the filename given is modified by adding a [-scene] number before the suffix, in order to make distinct names for each image.

Use [+adjoin] to force each image to be written to separate files, whether or not the file format allows multiple images per file (for example, GIF, MIFF, and TIFF).

Including a C-style integer format string in the output filename will automagically enable [+adjoin] and are used to specify where the [-scene] number is placed in the filenames. These strings, such as '%d' or '%03d', are familiar to those who have used the standard printf()' C-library function. As an example, the command

magick logo: rose: -morph 15 my%02dmorph.jpg

will create a sequence of 17 images (the two given plus 15 more created by [-morph]), named: my00morph.jpg, my01morph.jpg, my02morph.jpg, ..., my16morph.jpg.

In summary, ImageMagick tries to write all images to one file, but will save to multiple files, if any of the following conditions exist...

1.  the output image's file format does not allow multi-image files,
2.  the [+adjoin] option is given, or
3.  a printf() integer format string (eg: "%d") is present in the output filename.

-affine sx,rx,ry,sy[,tx,ty]
------------------------------

Set the drawing transformation matrix for combined rotating and scaling.

This option sets a transformation matrix, for use by subsequent [-draw] or [-transform] options.

The matrix entries are entered as comma-separated numeric values either in quotes or without spaces.

Internally, the transformation matrix has 3x3 elements, but three of them are omitted from the input because they are constant. The new (transformed) coordinates (x', y') of a pixel at position (x, y) in the original image are calculated using the following matrix equation.

![affine transformation](https://imagemagick.org/image/affine.png)

The size of the resulting image is that of the smallest rectangle that contains the transformed source image. The parameters tx and ty subsequently shift the image pixels so that those that are moved out of the image area are cut off.

The transformation matrix complies with the left-handed pixel coordinate system: positive x and y directions are rightward and downward, resp.; positive rotation is clockwise.

If the translation coefficients tx and ty are omitted they default to 0,0. Therefore, four parameters suffice for rotation and scaling without translation.

Scaling by the factors sx and sy in the x and y directions, respectively, is accomplished with the following.

See [-transform], and the [-distort] method 'Affineprojection for more information

-affine sx,0,0,sy

Translation by a displacement (tx, ty) is accomplished like so:

-affine 1,0,0,1,tx,ty

Rotate clockwise about the origin (the upper left-hand corner) by an angle a by letting c = cos(a), s = sin(a), and using the following.

-affine c,s,-s,c

The cumulative effect of a sequence of [-affine] transformations can be accomplished by instead by a single [-affine] operation using the matrix equal to the product of the matrices of the individual transformations.

An attempt is made to detect near-singular transformation matrices. If the matrix determinant has a sufficiently small absolute value it is rejected.

-alpha type
------------

Gives control of the alpha/matte channel of an image.

Used to set a flag on an image indicating whether or not to use existing alpha channel data, to create an alpha channel, or to perform other operations on the alpha channel. Choose the argument type from the list below.

Activate

Enable the image's transparency channel. Note normally Set should be used instead of this, unless you specifically need to preserve existing (but specifically turned Off) transparency channel.

Associate

associate the alpha channel with the image.

Deactivate

Disables the image's transparency channel. Does not delete or change the existing data, just turns off the use of that data.

Disassociate

disassociate the alpha channel from the image.

Set

Activates the alpha/matte channel. If it was previously turned off then it also resets the channel to opaque. If the image already had the alpha channel turned on, it will have no effect.

Opaque

Enables the alpha/matte channel and forces it to be fully opaque.

Transparent

Activates the alpha/matte channel and forces it to be fully transparent. This effectively creates a fully transparent image the same size as the original and with all its original RGB data still intact, but fully transparent.

Extract

Copies the alpha channel values into all the color channels and turns 'Off' the image's transparency, so as to generate a grayscale mask of the image's shape. The alpha channel data is left intact just deactivated. This is the inverse of 'Copy'.

Copy

Turns 'On' the alpha/matte channel, then copies the grayscale intensity of the image, into the alpha channel, converting a grayscale mask into a transparent shaped mask ready to be colored appropriately. The color channels are not modified.

Shape

As per 'Copy' but also colors the resulting shape mask with the current background color. That is the RGB color channels is replaced, with appropriate alpha shape.

Remove

Composite the image over the background color.

Background

Set any fully-transparent pixel to the background color, while leaving it fully-transparent. This can make some image file formats, such as PNG, smaller as the RGB values of transparent pixels are more uniform, and thus can compress better.

  

Note that while the obsolete +matte operation was the same as "[-alpha] Off", the \>-matte operation was the same as "[-alpha] Set" and not "[-alpha] On".

-annotate degrees text  
-annotate XdegreesxYdegrees text  
-annotate XdegreesxYdegrees{+-}tx{+-}ty text  
-annotate {+-}tx{+-}ty text
------------------------------------------------------------------------------------------------------------------------------------------

Annotate an image with text

This is a convenience for annotating an image with text. For more precise control over text annotations, use [-draw].

The values Xdegrees and Ydegrees control the shears applied to the text, while tx and ty are offsets that give the location of the text relative any [-gravity] setting and defaults to the upper left corner of the image.

Using [-annotate] degrees or [-annotate] degreesxdegrees produces an unsheared rotation of the text. The direction of the rotation is positive, which means a clockwise rotation if degrees is positive. (This conforms to the usual mathematical convention once it is realized that the positive y–direction is conventionally considered to be downward for images.)

The new (transformed) coordinates (x', y') of a pixel at position (x, y) in the image are calculated using the following matrix equation.

![annotate transformation](https://imagemagick.org/image/annotate.png)

If tx and ty are omitted, they default to 0. This makes the bottom-left of the text becomes the upper-left corner of the image, which is probably undesirable. Adding a [-gravity] option in this case leads to nice results.

Text is any UTF-8 encoded character sequence. If text is of the form '@mytext.txt', the text is read from the file mytext.txt. Text in a file is taken literally; no embedded formatting characters are recognized.

-antialias
-----------

Enable/Disable of the rendering of anti-aliasing pixels when drawing fonts and lines.

By default, objects (e.g. text, lines, polygons, etc.) are antialiased when drawn. Use [+antialias] to disable the addition of antialiasing edge pixels. This will then reduce the number of colors added to an image to just the colors being directly drawn. That is, no mixed colors are added when drawing such objects.

-append
--------

Join current images vertically or horizontally.

This option creates a single longer image, by joining all the current images in sequence top-to-bottom. Use [+append] to stack images left-to-right.

If they are not of the same width, narrower images are padded with the current [-background] color setting, and their position relative to each other can be controlled by the current [-gravity] setting.

For more flexible options, including the ability to add space between images, use [-smush].

-attenuate value
-----------------

Lessen (or intensify) when adding noise to an image.

If unset the value is equivalent to 1.0, or a maximum noise addition

-authenticate password
-----------------------

Decrypt a PDF with a password.

Use this option to supply a password for decrypting a PDF that has been encrypted using Microsoft Crypto API (MSC API). The encrypting using the MSC API is not supported.

For a different encryption method, see [-encipher] and [-decipher].

-auto-gamma
------------

Automagically adjust gamma level of image.

This calculates the mean values of an image, then applies a calculated [-gamma] adjustment so that the mean color in the image will get a value of 50%.

This means that any solid 'gray' image becomes 50% gray.

This works well for real-life images with little or no extreme dark and light areas, but tend to fail for images with large amounts of bright sky or dark shadows. It also does not work well for diagrams or cartoon like images.

It uses the [-channel] setting, (including the 'sync' flag for channel synchronization), to determine which color values is used and modified. As the default [-channel] setting is 'RGB,sync', channels are modified together by the same gamma value, preserving colors.

-auto-level
------------

Automagically adjust color levels of image.

This is a 'perfect' image normalization operator. It finds the exact minimum and maximum color values in the image and then applies a [-level] operator to stretch the values to the full range of values.

The operator is not typically used for real-life images, image scans, or JPEG format images, as a single 'out-rider' pixel can set a bad min/max values for the [-level] operation. On the other hand it is the right operator to use for color stretching gradient images being used to generate Color lookup tables, distortion maps, or other 'mathematically' defined images.

The operator is very similar to the [-normalize], [-contrast-stretch], and [-linear-stretch] operators, but without 'histogram binning' or 'clipping' problems that these operators may have. That is [-auto-level] is the perfect or ideal version these operators.

It uses the [-channel] setting, (including the special 'sync' flag for channel synchronization), to determine which color values are used and modified. As the default [+channel] setting is 'RGB,sync', the 'sync' ensures that the color channels will are modified together by the same gamma value, preserving colors, and ignoring transparency.

-auto-orient
-------------

Adjusts an image so that its orientation is suitable for viewing (i.e. top-left orientation).

This operator reads and resets the EXIF image profile setting 'Orientation' and then performs the appropriate 90 degree rotation on the image to orient the image, for correct viewing.

This EXIF profile setting is usually set using a gravity sensor in digital camera, however photos taken directly downward or upward may not have an appropriate value. Also images that have been orientation 'corrected' without reseting this setting, may be 'corrected' again resulting in a incorrect result. If the EXIF profile was previously stripped, the [-auto-orient] operator will do nothing.

-auto-threshold method
-----------------------

Automatically perform image thresholding.

Here are the valid methods:

Undefined

0: No method specified (equivalent to 'OTSU').

Kapur

maximum entropy thresholding.

OTSU

cluster-based image thresholding.

Triangle

a geometric thresholding method.

The computed threshold is returned as the auto-threshold:verbose image property. To instead print to your device, use -define auto-threshold:verbose=true.

-average
---------

Average a set of images.

An error results if the images are not identically sized.

-backdrop
----------

Display the image centered on a backdrop.

This backdrop covers the entire workstation screen and is useful for hiding other X window activity while viewing the image. The color of the backdrop is specified as the background color. The color is specified using the format described under the [-fill] option.

-background color
------------------

Set the background color.

The color is specified using the format described under the [-fill] option. The default background color (if none is specified or found in the image) is white.

-bench iterations
------------------

Measure performance.

Repeat the entire command for the given number of iterations and report the user-time and elapsed time. For instance, consider the following command and its output. Modify the benchmark with the -duration to run the benchmark for a fixed number of seconds and -concurrent to run the benchmark in parallel (requires the OpenMP feature).

$ magick logo: -resize 200% -bench 5 logo.png
Performance[1]: 5i 1.344ips 1.000e 3.710u 0:03.720
Performance[2]: 5i 1.634ips 0.549e 3.890u 0:03.060
Performance[3]: 5i 2.174ips 0.618e 3.190u 0:02.300
Performance[4]: 5i 1.678ips 0.555e 3.810u 0:02.980
Performance[4]: 5i 0.875657ips 6.880u 0:05.710

In this example, 5 iterations were completed at 2.174 iterations per second, using 3 threads and 3.190 seconds of the user allotted time, for a total elapsed time of 2.300 seconds.

-bias value{%}
---------------

Add bias when convolving an image.

This option shifts the output of [-convolve] so that positive and negative results are relative to the specified bias value.

This is important for non-HDRI compilations of ImageMagick when dealing with convolutions that contain negative as well as positive values. This is especially the case with convolutions involving high pass filters or edge detection. Without an output bias, the negative values are clipped at zero.

When using an ImageMagick with the HDRI compile-time setting, [-bias] is not needed, as ImageMagick is able to store/handle any negative results without clipping to the color value range (0..QuantumRange).

See the discussion on HDRI implementations of ImageMagick on the page [High Dynamic-Range Images]. For more about HDRI go the ImageMagick [Usage] pages or this [Wikipedia](http://en.wikipedia.org/wiki/High_dynamic_range_imaging) entry.

-bilateral-blur width{xheight}{+intensity-sigma}{+spatial-sigma}
-----------------------------------------------------------------

A non-linear, edge-preserving, and noise-reducing smoothing filter for images. It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels. This weight is based on a Gaussian distribution. The weights depend not only on Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such as color intensity, depth distance, etc.). This preserves sharp edges.

The intensity sigma is in the intensity space. A larger value means that farther colors within the pixel neighborhood (see spatial-sigma) will be mixed together, resulting in larger areas of semi-equal color.

The spatial sigma is in the coordinate space. A larger value means that farther pixels influence each other as long as their colors are close enough (see intensity-sigma ). When the neigborhood diameter is greater than zero, it specifies the neighborhood size regardless of spatial-sigma. Otherwise, the neigborhood diameter is proportional to spatial-sigma.

The default value for the intensity and spatial sigmas are 0.75*diameter and 0.25*diameter respectively.

-black-point-compensation
--------------------------

Use black point compensation.

-black-threshold value{%}
--------------------------

Force to black all pixels below the threshold while leaving all pixels at or above the threshold unchanged.

The threshold value can be given as a percentage or as an absolute integer value within [0, QuantumRange] corresponding to the desired [-channel] value. See [-threshold] for more details on thresholds and resulting values.

-blend geometry
----------------

Blend an image into another by the given absolute value or percent.

Blend will average the images together ('plus') according to the percentages given and each pixels transparency. If only a single percentage value is given it sets the weight of the composite or 'source' image, while the background image is weighted by the exact opposite amount. That is a -blend 30% merges 30% of the 'source' image with 70% of the 'destination' image. Thus it is equivalent to -blend 30x70%.

-blue-primary x,y
------------------

Set the blue chromaticity primary point.

-blue-shift factor
-------------------

Simulate a scene at nighttime in the moonlight. Start with a factor of 1.5

-blur radius  
-blur radius{xsigma}
-------------------------------------

Reduce image noise and reduce detail levels.

Convolve the image with a Gaussian or normal distribution using the given Sigma value. The formula is:

![gaussian distribution](https://imagemagick.org/image/gaussian-blur.png)

The sigma value is the important argument, and determines the actual amount of blurring that will take place.

The radius is only used to determine the size of the array which holds the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

The larger the Radius the slower the operation is. However too small a Radius, and severe aliasing effects may result. As a guideline, Radius should be at least twice the Sigma value, though three times will produce a more accurate result.

This option differs from [-gaussian-blur] simply by taking advantage of the separability properties of the distribution. Here we apply a single-dimensional Gaussian matrix in the horizontal direction, then repeat the process in the vertical direction.

The [-virtual-pixel] setting will determine how pixels which are outside the image proper are blurred into the final result.

-border geometry
-----------------

Surround the image with a border of color.

Set the width and height using the size portion of the geometry argument. See [Image Geometry] for complete details about the _geometry_ argument. Offsets are ignored.

As of IM 6.7.8-8, the geometry arguments behave asfollows:

value

value is added to both left/right and top/bottom

value-xx

value-x is added only to left/right and top/bottom are unchanged

xvalue-y

value-y is added only to top/bottom and left/right are unchanged

value-xxvalue-y

value-x is added to left/right and value-y added to top/bottom

value-xx0

value-x is added only to left/right and top/bottom are unchanged

0xvalue-y

value-y is added only to top/bottom and left/right are unchanged

value%

value % of width is added to left/right and value % of height is added to top/bottom

value-xx%

value-x % of width is added to left/right and to top/bottom

xvalue-y%

value-y % of height is added to top/bottom and to left/right

value-x%xvalue-y%

value-x % of width is added to left/right and value-y % of height is added to top/bottom

value-x%x0%

value-x % of width is added to left/right and top/bottom are unchanged

0%xvalue-y%

value-y % of height is added to top/bottom and left/right are unchanged

Set the border color by preceding with the [-bordercolor] setting.

The [-border] operation is affected by the current [-compose] setting and assumes that this is using the default 'Over' composition method. It generates an image of the appropriate size colors by the current [-bordercolor] before overlaying the original image in the center of this net image. This means that with the default compose method of 'Over' any transparent parts may be replaced by the current [-bordercolor] setting.

See also the [-frame] option, which has more functionality.

-bordercolor color
-------------------

Set the border color.

The color is specified using the format described under the [-fill] option.

The default border color is #DFDFDF, this shade of gray.

-borderwidth geometry
----------------------

Set the border width.

-brightness-contrast brightness  
-brightness-contrast brightness{xcontrast}{%}
---------------------------------------------------------------------------------

Adjust the brightness and/or contrast of the image.

Brightness and Contrast values apply changes to the input image. They are not absolute settings. A brightness or contrast value of zero means no change. The range of values is -100 to +100 on each. Positive values increase the brightness or contrast and negative values decrease the brightness or contrast. To control only contrast, set the brightness=0. To control only brightness, set contrast=0 or just leave it off.

You may also use [-channel] to control which channels to apply the brightness and/or contrast change. The default is to apply the same transformation to all channels.

Brightness and Contrast arguments are converted to offset and slope of a linear transform and applied using [-function polynomial "slope,offset"].

The slope varies from 0 at contrast=-100 to almost vertical at contrast=+100. For brightness=0 and contrast=-100, the result are totally midgray. For brightness=0 and contrast=+100, the result will approach but not quite reach a threshold at midgray; that is the linear transformation is a very steep vertical line at mid gray.

Negative slopes, i.e. negating the image, are not possible with this function. All achievable slopes are zero or positive.

The offset varies from -0.5 at brightness=-100 to 0 at brightness=0 to +0.5 at brightness=+100. Thus, when contrast=0 and brightness=100, the result is totally white. Similarly, when contrast=0 and brightness=-100, the result is totally black.

As the range of values for the arguments are -100 to +100, adding the '%' symbol is no different than leaving it off.

-cache threshold
-----------------

(This option has been replaced by the [-limit] option).

-canny radius  
-canny radius{xsigma}{+lower-percent}{+upper-percent}
-----------------------------------------------------------------------

Canny edge detector uses a multi-stage algorithm to detect a wide range of edges in the image.

The thresholds range from 0 to 100% (e.g. -canny 0x1+10%+30%) with {+lower-percent} < {+upper-percent}. If {+upper-percent} is increased but {+lower-percent} remains the same, lesser edge components will be detected, but their lengths will be the same. If {+lower-percent} is increased but {+upper-percent} is the same, the same number of edge components will be detected but their lengths will be shorter. The default thresholds are shown.

The radius{xsigma} controls a gaussian blur applied to the input image to reduce noise and smooth the edges.

The sigma value is the important argument, and determines the actual amount of blurring that will take place.

The radius is only used to determine the size of the array which holds the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

-caption string
----------------

Assign a caption to an image.

This option sets the caption meta-data of an image read in after this option has been given. To modify a caption of images already in memory use "[-set] caption".

The caption can contain special format characters listed in the [Format and Print Image Properties]. These attributes are expanded when the caption is finally assigned to the individual images.

If the first character of string is @, the image caption is read from a file titled by the remaining characters in the string. Comments read in from a file are literal; no embedded formatting characters are recognized.

Caption meta-data is not visible on the image itself. To do that use the [-annotate] or [-draw] options instead.

For example,

-caption "%m:%f %wx%h"  bird.miff

produces an image caption of MIFF:bird.miff 512x480 (assuming that the image bird.miff has a width of 512 and a height of 480.

-cdl filename
--------------

Color correct with a color decision list.

Here is an example color correction collection:

<?xml version="1.0" encoding="UTF-8"?>
<ColorCorrectionCollection xmlns="urn:ASC:CDL:v1.2">
  <ColorCorrection id="cc06668">
    <SOPNode>
      <Slope> 0.9 1.2 0.5 </Slope>
      <Offset> 0.4 -0.5 0.6 </Offset>
      <Power> 1.0 0.8 1.5 </Power>
    </SOPNode>
    <SATNode>
      <Saturation> 0.85 </Saturation>
    </SATNode>
  </ColorCorrection>
</ColorCorrectionCollection>

-channel type
--------------

Specify those image color channels to which subsequent operators are limited.

Choose from: Red, Green, Blue, Alpha, Gray, Cyan, Magenta, Yellow, Black, Opacity, Index, RGB, RGBA, CMYK, or CMYKA.

The channels above can also be specified as a comma-separated list or can be abbreviated as a concatenation of the letters 'R', 'G', 'B', 'A', 'O', 'C', 'M', 'Y', 'K'.

The numerals 0 to 31 may also be used to specify channels, where 0 to 5 are:  

'0' equals Red or Cyan  
'1' equals Green or Magenta  
'2' equals Blue or Yellow  
'3' equals Black  
'4' equals Alpha or Opacity  
'5' equals Index

For example, to only select the Red and Blue channels you can use any of the following:

-channel Red,Blue
-channel R,B
-channel RB
-channel 0,2

All the channels that are present in an image can be specified using the special channel type All. Not all operators are 'channel capable', but generally any operators that are generally 'grey-scale' image operators, will understand this setting. See individual operator documentation.

On top of the normal channel selection an extra flag can be specified, 'Sync'. This is turned on by default and if set means that operators that understand this flag should perform: cross-channel synchronization of the channels. If not specified, then most grey-scale operators will apply their image processing operations to each individual channel (as specified by the rest of the [-channel] setting) completely independently from each other.

For example for operators such as [-auto-level] and [-auto-gamma] the color channels are modified together in exactly the same way so that colors will remain in-sync. Without it being set, then each channel is modified separately and independently, which may produce color distortion.

The [-morphology] 'Convolve' method and the [-compose] mathematical methods, also understands the 'Sync' flag to modify the behavior of pixel colors according to the alpha channel (if present). That is to say it will modify the image processing with the understanding that fully-transparent colors should not contribute to the final result.

Basically, by default, operators work with color channels in synchronous, and treats transparency as special, unless the [-channel] setting is modified so as to remove the effect of the 'Sync' flag. How each operator does this depends on that operators current implementation. Not all operators understands this flag at this time, but that is changing.

To print a complete list of channel types, use [-list channel].

By default, ImageMagick sets [-channel] to the value 'RGBK,sync', which specifies that operators act on all color channels except the transparency channel, and that all the color channels are to be modified in exactly the same way, with an understanding of transparency (depending on the operation being applied). The 'plus' form [+channel] will reset the value back to this default.

Options that are affected by the [-channel] setting include the following. [-auto-gamma], [-auto-level], [-black-threshold], [-blur], [-clamp], [-clut], [-combine], [-composite] (Mathematical compose methods only), [-convolve], [-contrast-stretch], [-evaluate], [-function], [-fx], [-gaussian-blur], [-hald-clut], [-motion-blur], [-morphology], [-negate], [-normalize], [-ordered-dither], [-rotational-blur], [-random-threshold], [-range-threshold], [-separate], [-threshold], and [-white-threshold].

Warning, some operators behave differently when the [+channel] default setting is in effect, versus ANY user defined [-channel] setting (including the equivalent of the default). These operators have yet to be made to understand the newer 'Sync' flag.

For example [-threshold] will by default grayscale the image before thresholding, if no [-channel] setting has been defined. This is not 'Sync flag controlled, yet.

Also some operators such as [-blur], [-gaussian-blur], will modify their handling of the color channels if the 'alpha' channel is also enabled by [-channel]. Generally this done to ensure that fully-transparent colors are treated as being fully-transparent, and thus any underlying 'hidden' color has no effect on the final results. Typically resulting in 'halo' effects. The newer [-morphology] convolution equivalents however does have a understanding of the 'Sync' flag and will thus handle transparency correctly by default.

As an alpha channel is optional within images, some operators will read the color channels of an image as a greyscale alpha mask, when the image has no alpha channel present, and the [-channel] setting tells the operator to apply the operation using alpha channels. The [-clut] operator is a good example of this.

-channel-fx expression
-----------------------

Exchange, extract, or copy one or more image channels.

The expression consists of one or more channels, either mnemonic or numeric (e.g. red or 0, green or 1, etc.), separated by certain operation symbols as follows:

<=>  exchange two channels (e.g. red<=>blue)
=>   copy one channel to another channel (e.g. red=>green)
=    assign a constant value to a channel (e.g. red=50%)
,    write new image with channels in the specified order (e.g. red, green)
;    add a new output image for the next set of channel operations (e.g. red; green; blue)
|    move to the next input image for the source of channel data (e.g. | gray=>alpha)

For example, to create 3 grayscale images from the red, green, and blue channels of an image, use:

-channel-fx "red; green; blue"

A channel without an operation symbol implies separate (i.e, semicolon).

Here we take an sRGB image and a grayscale image and inject the grayscale image into the alpha channel:

magick wizard.png mask.pgm -channel-fx '| gray=>alpha' wizard-alpha.png

Use a similar command to define a read mask:

magick wizard.png mask.pgm -channel-fx '| gray=>read-mask' wizard-mask.png

In this example, we compute the mean RGB value for all opaque pixels of an image:

magick wizard-alpha.png -channel-fx "alpha=>read-mask" -channel rgb -format "%[fx:mean]\n" info:

Add -debug pixel prior to the -channel-fx option to track the channel morphology.

-charcoal factor
-----------------

Simulate a charcoal drawing.

-chop geometry
---------------

Remove pixels from the interior of an image.

See [Image Geometry] for complete details about the _geometry_ argument. The width and height given in the of the size portion of the geometry argument give the number of columns and rows to remove. The offset portion of the geometry argument is influenced by a [-gravity] setting, if present.

The [-chop] option removes entire rows and columns, and moves the remaining corner blocks leftward and upward to close the gaps.

While it can remove internal rows and columns of pixels, it is more typically used with as [-gravity] setting and zero offsets so as to remove a single edge from an image. Compare this to [-shave] which removes equal numbers of pixels from opposite sides of the image.

Using [-chop] effectively undoes the results of a [-splice] that was given the same geometry and [-gravity] settings.

-clahe widthxheight{%}{+}number-bins{+}clip-limit{!}
-----------------------------------------------------

Contrast limited adaptive histogram equalization.

The image is divided into tiles of width and height pixels. Append % to define the width and height as percentages of the image's dimensions. The tile size should be larger than the size of features to be preserved and respects the aspect ratio of the image. Add ! to force an exact tile width and height. number-bins is the number of histogram bins per tile (min 2, max 65536). The number of histogram bins should be smaller than the number of pixels in a single tile. clip-limit is the contrast limit for localized changes in contrast. A clip-limit of 2 to 3 is a good starting place (e.g. -clahe 50x50%+128+3). Very large values will let the histogram equalization do whatever it wants to do, that is result in maximal local contrast. The value 1 will result in the original image. Note, if the number of bins and the clip-limit are ommitted, they default to 128 and no clipping respectively.

-clamp
-------

Set each pixel whose value is below zero to zero and any the pixel whose value is above the quantum range to the quantum range (e.g. 65535) otherwise the pixel value remains unchanged.

-clip
------

Apply the clipping path if one is present.

If a clipping path is present, it is applied to subsequent operations.

For example, in the command

magick cockatoo.tif -clip -negate negated.tif

only the pixels within the clipping path are negated.

The [-clip] feature requires SVG support. If the SVG delegate library is not present, the option is ignored.

Use [+clip] to disable clipping for subsequent operations.

-clip-mask
-----------

Clip the image as defined by this mask.

Use the alpha channel of the current image as a mask. Any areas that is white is not modified by any of the 'image processing operators' that follow, until the mask is removed. Pixels in the black areas of the clip mask are modified per the requirements of the operator.

In some ways this is similar to (though not the same) as defining a rectangular [-region], or using the negative of the mask (third) image in a three image [-composite], operation.

Use [+clip-mask] to disable clipping for subsequent operations.

-clip-path id
--------------

Clip along a named path from the 8BIM profile.

This is identical to [-clip] except choose a specific clip path in the event the image has more than one path available. ImageMagick supports UTF-8 encoding. If your named path is in a different encoding, use `iconv` to convert the clip path name to that encoding otherwise the path name will not match.

Use [+clip-path] to disable clipping for subsequent operations.

-clone index(s)
----------------

Make a clone of an image (or images).

Inside parenthesis (where the operator is normally used) it will make a clone of the images from the last 'pushed' image sequence, and adds them to the end of the current image sequence. Outside parenthesis (not recommended) it clones the images from the current image sequence.

Specify the image by its index in the sequence. The first image is index 0. Negative indexes are relative to the end of the sequence; for example, −1 represents the last image of the sequence. Specify a range of images with a dash (e.g. 0−4). Separate multiple indexes with commas but no spaces (e.g. 0,2,5). A value of '0−−1 will effectively clone all the images.

The [+clone] will simply make a copy of the last image in the image sequence, and is thus equivalent to using an argument of '−1'.

-clut
------

Replace the channel values in the first image using each corresponding channel in the second image as a **c**olor **l**ook**u**p **t**able.

The second (LUT) image is ordinarily a gradient image containing the histogram mapping of how each channel should be modified. Typically it is a either a single row or column image of replacement color values. If larger than a single row or column, values are taken from a diagonal line from top-left to bottom-right corners.

The lookup is further controlled by the [-interpolate] setting, which is especially handy for an LUT which is not the full length needed by the ImageMagick installed Quality (Q) level. Good settings for this are 'bilinear' and 'catrom'. Catom can return a useful second-order continuity.

This operator is especially suited to replacing a grayscale image with a specific color gradient from the CLUT image.

Only the channel values defined by the [-channel] setting will have their values replaced. In particular, since the default [-channel] setting is RGB, this means that transparency (alpha/matte channel) is not affected, unless the [-channel] setting is modified. When the alpha channel is set, it is treated by the [-clut] operator in the same way as the other channels, implying that alpha/matte values are replaced using the alpha/matte values of the original image.

If either the image being modified, or the lookup image, contains no transparency (i.e. [-alpha] is turned 'off') but the [-channel] setting includes alpha replacement, then it is assumed that image represents a grayscale gradient which is used for the replacement alpha values. That is you can use a grayscale CLUT image to adjust a existing images alpha channel, or you can color a grayscale image using colors form CLUT containing the desired colors, including transparency.

See also [-hald-clut] which replaces colors according to the lookup of the full color RGB value from a 2D representation of a 3D color cube.

-coalesce
----------

Fully define the look of each frame of an GIF animation sequence, to form a 'film strip' animation.

Overlay each image in an image sequence according to its [-dispose] meta-data, to reproduce the look of an animation at each point in the animation sequence. All images should be the same size, and are assigned appropriate GIF disposal settings for the animation to continue working as expected as a GIF animation. Such frames are more easily viewed and processed than the highly optimized GIF overlay images.

The animation can be re-optimized after processing using the [-layers] method 'optimize', although there is no guarantee that the restored GIF animation optimization is better than the original.

-colorize value
----------------

Colorize the image by an amount specified by value using the color specified by the most recent [-fill] setting.

Specify the amount of colorization as a percentage. Separate colorization values can be applied to the red, green, and blue channels of the image with a comma-delimited list of colorization values (e.g., -colorize 0,0,50).

-colormap type
---------------

Define the colormap type.

The type can be shared or private.

This option only applies when the default X server visual is PseudoColor or GrayScale. Refer to [-visual] for more details. By default, a shared colormap is allocated. The image shares colors with other X clients. Some image colors could be approximated, therefore your image may look very different than intended. If private is chosen, the image colors appear exactly as they are defined. However, other clients may go technicolor when the image colormap is installed.

-colors value
--------------

Set the preferred number of colors in the image.

The actual number of colors in the image may be less than your request, but never more. Note that this a color reduction option. Images with fewer unique colors than specified by value will have any duplicate or unused colors removed. The ordering of an existing color palette may be altered. When converting an image from color to grayscale, it is more efficient to convert the image to the gray colorspace before reducing the number of colors. Refer to the [color reduction algorithm] for more details.

-color-matrix matrix
---------------------

Apply color correction to the image.

This option permits saturation changes, hue rotation, luminance to alpha, and various other effects. Although variable-sized transformation matrices can be used, typically one uses a 5x5 matrix for an RGBA image and a 6x6 for CMYKA (or RGBA with offsets). The matrix is similar to those used by Adobe Flash except offsets are in column 6 rather than 5 (in support of CMYKA images) and offsets are normalized (divide Flash offset by 255).

As an example, to add contrast to an image with offsets, try this command:

magick kittens.jpg -color-matrix \
  " 1.5 0.0 0.0 0.0, 0.0, -0.157 \
    0.0 1.5 0.0 0.0, 0.0, -0.157 \
    0.0 0.0 1.5 0.0, 0.0, -0.157 \
    0.0 0.0 0.0 1.0, 0.0,  0.0 \
    0.0 0.0 0.0 0.0, 1.0,  0.0 \
    0.0 0.0 0.0 0.0, 0.0,  1.0" kittens.png

-colorspace value
------------------

Set the image colorspace.

Choices are:

CMY          CMYK         Gray         HCL
HCLp         HSB          HSI          HSL
HSV          HWB          Jzazbz       Lab
LCHab        LCHuv        LMS          Log
Luv          OHTA         Rec601YCbCr  Rec709YCbCr
RGB          scRGB        sRGB         Transparent
xyY          XYZ          YCbCr        YCC
YDbDr        YIQ          YPbPr        YUV
Undefined

To print a complete list of colorspaces, use [-list colorspace].

For a more accurate color conversion to or from the linear RGB, CMYK, or grayscale colorspaces, use the [-profile] option. Note, ImageMagick assumes the sRGB colorspace if the image format does not indicate otherwise. For colorspace conversion, the gamma function is first removed to produce linear RGB.

Conversion of RGB to Other Color Spaces

CMY

C=QuantumRange−R

M=QuantumRange−G

Y=QuantumRange−B

CMYK — starts with CMY from above

K=min(C,Y,M)

C=QuantumRange*(C−K)/(QuantumRange−K)

M=QuantumRange*(M−K)/(QuantumRange−K)

Y=QuantumRange*(Y−K)/(QuantumRange−K)

Gray

Gray = 0.212656*R+0.715158*G+0.072186*B

HSB — Hue, Saturation, Brightness; like a cone peak downward

H=angle around perimeter (0 to 360 deg); H=0 is red; increasing angles toward green

S=distance from axis outward

B=distance along axis from bottom upward; B=max(R,G,B); intensity-like

HSL — Hue, Saturation, Lightness; like a double cone end-to-end with peaks at very top and bottom

H=angle around perimeter (0 to 360 deg); H=0 is red; increasing angles toward green

S=distance from axis outward

L=distance along axis from bottom upward; L=0.5*max(R,G,B) + 0.5*min(R,G,B); intensity-like

HWB — Hue, Whiteness, Blackness

Hue (complicated equation)

Whiteness (complicated equation)

Blackness (complicated equation)

LAB

L (complicated equation relating X,Y,Z)

A (complicated equation relating X,Y,Z)

B (complicated equation relating X,Y,Z)

LinearGray

LinearGray = 0.298839*R+0.586811*G+0.114350*B

LOG

I1 (complicated equation involving logarithm of R)

I2 (complicated equation involving logarithm of G)

I3 (complicated equation involving logarithm of B)

OHTA — approximates principal components transformation

I1=0.33333*R+0.33334*G+0.33333*B; intensity-like

I2=(0.50000*R+0.00000*G−0.50000*B)*(QuantumRange+1)/2

I3=(−0.25000*R+0.50000*G−0.25000*B)*(QuantumRange+1)/2

Rec601Luma

Gray = 0.298839*R+0.586811*G+0.114350*B

Rec601YCbCr

Y=0.2988390*R+0.5868110*G+0.1143500*B; intensity-like

Cb=(−0.168736*R-0.331264*G+0.500000*B)*(QuantumRange+1)/2

Cr=(0.500000*R−0.418688*G−0.081312*B)*(QuantumRange+1)/2

Rec709Luma

Gray=0.212656*R+0.715158*G+0.072186*B

Rec709YCbCr

Y=0.212656*R+0.715158*G+0.072186*B; intensity-like

Cb=(−0.114572*R−0.385428*G+0.500000*B)+(QuantumRange+1)/2

Cr=(0.500000*R−0.454153*G−0.045847*B)+(QuantumRange+1)/2

sRGB

if R ≤ .0.0031308 then Rs=R/12.92 else Rs=1.055 R ^ (1.0 / 2.4) - 0.055

if G ≤ .0.0031308 then Gs=B/12.92 else Gs=1.055 R ^ (1.0 / 2.4) - 0.055

if B ≤ .0.0031308 then Bs=B/12.92 else Bs=1.055 R ^ (1.0 / 2.4) - 0.055

XYZ

X=0.4124564*R+0.3575761*G+0.1804375*B

Y=0.2126729*R+0.7151522*G+0.0721750*B

Z=0.0193339*R+0.1191920*G+0.9503041*B

YCC

Y=(0.298839*R+0.586811*G+0.114350*B) (with complicated scaling); intensity-like

C1=(−0.298839*R−0.586811*G+0.88600*B) (with complicated scaling)

C2=(0.70100*R−0.586811*G−0.114350*B) (with complicated scaling)

YCbCr

Y=0.2988390*R+0.5868110*G+0.1143500*B; intensity-like

Cb=(−0.168736*R−0.331264*G+0.500000*B)*(QuantumRange+1)/2

Cr=(0.500000*R−0.418688*G−0.081312*B)*(QuantumRange+1)/2

YIQ

Y=0.298839*R+0.586811*G+0.114350*B; intensity-like

I=(0.59600*R−0.27400*G−0.32200*B)*(QuantumRange+1)/2

Q=(0.21100*R−0.52300*G+0.31200*B)*(QuantumRange+1)/2

YPbPr

Y=0.2988390*R+0.5868110*G+0.1143500*B; intensity-like

Pb=(−0.168736*R−0.331264*G+0.500000*B)*(QuantumRange+1)/2

Pr=(0.500000*R−0.418688*G−0.081312*B)*(QuantumRange+1)/2

YUV

Y=0.298839*R+0.586811*G+0.114350*B; intensity-like

U=(−0.14740*R−0.28950*G+0.43690*B)*(QuantumRange+1)/2

V=(0.61500*R−0.51500*G−0.10000*B)*(QuantumRange+1)/2

Note the scRGB colorspace requires HDRI support otherwise it behaves just like linear RGB.

Use the Undefined colorspace to identify multi-spectral images.

-color-threshold start-color-stop-color
-----------------------------------------

Return a binary image where all colors within the specified range are changed to white. All other colors are changed to black.

-combine
---------

+combine colorspace
-------------------

Combine one or more images into a single image.

The channels (previously set by [-channel]) of the combined image are taken from the grayscale values of each image in the sequence, in order. For the default -channel setting of RGB, this means the first image is assigned to the Red channel, the second to the Green channel, the third to the Blue.

This option can be thought of as the inverse to [-separate], so long as the channel settings are the same. Thus, in the following example, the final image should be a copy of the original.

magick original.png -channel RGB -separate sepimage.png
convert sepimage-0.png sepimage-1.png sepimage-2.png -channel RGB \
  -combine imagecopy.png

-comment string
----------------

Embed a comment in an image.

This option sets the comment meta-data of an image read in after this option has been given. To modify a comment of images already in memory use "[-set] comment".

The comment can contain special format characters listed in the [Format and Print Image Properties]. These attributes are expanded when the comment is finally assigned to the individual images.

If the first character of string is @, the image comment is read from a file titled by the remaining characters in the string. Comments read in from a file are literal; no embedded formatting characters are recognized.

Comment meta-data are not visible on the image itself. To do that use the [-annotate] or [-draw] options instead.

For example,

-comment "%m:%f %wx%h"  bird.miff

produces an image comment of MIFF:bird.miff 512x480 (assuming that the image bird.miff has a width of 512 and a height of 480.

-compare
---------

Mathematically and visually annotate the difference between an image and its reconstruction

This is a convert version of "compare" for two same sized images. The syntax is as follows, but other metrics are allowed.

magick image.png reference.png -metric RMSE -compare \   
 difference.png

To get the metric value use the string format "%[distortion]".

magick image.png reference.png -metric RMSE -compare -format \
   "%[distortion]" info:

-complex operator
------------------

Perform complex mathematics on an image sequence

Choose from these operators:

add
conjugate
divide
magnitude-phase
multiply
real-imaginary
subtract

Optionally specify the divide operator SNR with [-define] complex:snr=float.

-compose operator
------------------

Set the type of image composition.

See [Alpha Compositing] for a detailed discussion of alpha compositing.

This setting affects image processing operators that merge two (or more) images together in some way. This includes the operators, [-compare], [-composite], [-layers] composite, [-flatten], [-mosaic], [-layers] merge, [-border], [-frame], and [-extent].

It is also one of the primary options for the "composite" command.

-composite
-----------

Perform alpha composition on two images and an optional mask

Take the first image 'destination' and overlay the second 'source' image according to the current [-compose] setting. The location of the 'source' or 'overlay' image is controlled according to [-gravity], and [-geometry] settings.

If a third image is given this is treated as a grayscale blending 'mask' image relative to the first 'destination' image. This mask is blended with the source image. However for the 'displace' compose method, the mask is used to provide a separate Y-displacement image instead.

If a [-compose] method requires extra numerical arguments or flags these can be provided by setting the [-set] 'option:compose:args' appropriately for the compose method.

Some [-compose] methods can modify the 'destination' image outside the overlay area. It is disabled by default. You can enable this by setting the define: [-define] 'compose:clip-to-self=true'.

The SVG compositing specification requires that color and opacity values range between zero and QuantumRange inclusive. You can permit values outside this range with this option: [-set] 'option:compose:clamp=false

-compress type
---------------

Use pixel compression specified by type when writing the image.

Choices are: None, BZip, Fax, Group4, JPEG, JPEG2000, Lossless, LZW, RLE or Zip.

To print a complete list of compression types, use [-list compress].

Specify [+compress] to store the binary image in an uncompressed format. The default is the compression type of the specified image file.

If LZW compression is specified but LZW compression has not been enabled, the image data is written in an uncompressed LZW format that can be read by LZW decoders. This may result in larger-than-expected GIF files.

Lossless refers to lossless JPEG, which is only available if the JPEG library has been patched to support it. Use of lossless JPEG is generally not recommended.

When writing an ICO file, you may request that the images be encoded in PNG format, by specifying Zip compression.

When writing a JNG file, specify Zip compression to request that the alpha channel be encoded in PNG "IDAT" format, or JPEG to request that it be encoded in JPG "JDAA" format.

Use the [-quality] option to set the compression level to be used by JPEG, PNG, MIFF, and MPEG encoders. Use the [-sampling-factor] option to set the sampling factor to be used by JPEG, MPEG, and YUV encoders for down-sampling the chroma channels.

-connected-components connectivity
-----------------------------------

[connected-components] labeling detects connected regions in an image, choose from 4 or 8 way connectivity.

Use [-define] connected-components:verbose=true to output statistics associated with each unique label.

-contrast
----------

Enhance or reduce the image contrast.

This option enhances the intensity differences between the lighter and darker elements of the image. Use [-contrast] to enhance the image or [+contrast] to reduce the image contrast.

For a more pronounced effect you can repeat the option:

magick rose: -contrast -contrast rose_c2.png

-contrast-stretch black-point  
-contrast-stretch black-point{xwhite-point}{%}
--------------------------------------------------------------------------------

Increase the contrast in an image by stretching the range of intensity values.

While performing the stretch, black-out at most black-point pixels and white-out at most white-point pixels. Or, if percent is used, black-out at most black-point % pixels and white-out at most white-point % pixels.

Prior to ImageMagick 6.4.7-0, [-contrast-stretch] will black-out at most black-point pixels and white-out at most total pixels minus white-point pixels. Or, if percent is used, black-out at most black-point % pixels and white-out at most 100% minus white-point % pixels.

Note that -contrast-stretch 0 will modify the image such that the image's min and max values are stretched to 0 and QuantumRange, respectively, without any loss of data due to burn-out or clipping at either end. This is not the same as [-normalize], which is equivalent to -contrast-stretch 0.15x0.05% (or prior to ImageMagick 6.4.7-0, -contrast-stretch 2%x99%).

Internally operator works by creating a histogram bin, and then uses that bin to modify the image. As such some colors may be merged together when they originally fell into the same 'bin'.

All the channels are normalized in concert by the same amount so as to preserve color integrity, when the default [+channel] setting is in use. Specifying any other [-channel] setting will normalize the RGB channels independently.

See also [-auto-level] for a 'perfect' normalization of mathematical images.

This operator is under review for re-development.

-convolve kernel
-----------------

Convolve an image with a user-supplied convolution kernel.

The kernel is a matrix specified as a comma-separated list of integers (with no spaces), ordered left-to right, starting with the top row. Presently, only odd-dimensioned kernels are supported, and therefore the number of entries in the specified kernel must be 32\=9, 52\=25, 72\=49, etc.

Note that the [-convolve] operator supports the [-bias] setting. This option shifts the convolution so that positive and negative results are relative to a user-specified bias value. This is important for non-HDRI compilations of ImageMagick when dealing with convolutions that contain negative as well as positive values. This is especially the case with convolutions involving high pass filters or edge detection. Without an output bias, the negative values is clipped at zero.

When using an ImageMagick with the HDRI compile-time setting, [-bias] is not needed, as ImageMagick is able to store/handle any negative results without clipping to the color value range (0..QuantumRange). See the discussion on HDRI implementations of ImageMagick on the page [High Dynamic-Range Images]. For more about HDRI go the ImageMagick [Usage] pages or this [Wikipedia](http://en.wikipedia.org/wiki/High_dynamic_range_imaging) entry.

-copy geometry offset
----------------------

Copy pixels from one area of an image to another.

-crop geometry{@}{!}
---------------------

Cut out one or more rectangular regions of the image.

See [Image Geometry] for complete details about the _geometry_ argument.

The width and height of the geometry argument give the size of the image that remains after cropping, and x and y in the offset (if present) gives the location of the top left corner of the cropped image with respect to the original image. To specify the amount to be removed, use [-shave] instead.

If the x and y offsets are present, a single image is generated, consisting of the pixels from the cropping region. The offsets specify the location of the upper left corner of the cropping region measured downward and rightward with respect to the upper left corner of the image. If the [-gravity] option is present with NorthEast, East, or SouthEast gravity, it gives the distance leftward from the right edge of the image to the right edge of the cropping region. Similarly, if the [-gravity] option is present with SouthWest, South, or SouthEast gravity, the distance is measured upward between the bottom edges.

If the x and y offsets are omitted, a set of tiles of the specified geometry, covering the entire input image, is generated. The rightmost tiles and the bottom tiles are smaller if the specified geometry extends beyond the dimensions of the input image.

You can add the @ to the geometry argument to equally divide the image into the number of tiles generated.

By adding a exclamation character flag to the geometry argument, the cropped images virtual canvas page size and offset is set as if the geometry argument was a viewport or window. This means the canvas page size is set to exactly the same size you specified, the image offset set relative top left corner of the region cropped.

If the cropped image 'missed' the actual image on its virtual canvas, a special single pixel transparent 'missed' image is returned, and a 'crop missed' warning given.

It might be necessary to [+repage] the image prior to cropping the image to ensure the crop coordinate frame is relocated to the upper-left corner of the visible image. Similarly you may want to use [+repage] after cropping to remove the page offset that will be left behind. This is especially true when you are going to write to an image format such as PNG that supports an image offset.

-cycle amount
--------------

Displace image colormap by amount.

Amount defines the number of positions each colormap entry is shifted.

-debug events
--------------

Enable debug printout.

The events parameter specifies which events are to be logged. It can be either None, All, Trace, or a comma-separated list consisting of one or more of the following domains: Accelerate, Annotate, Blob, Cache, Coder, Configure, Deprecate, Exception, Locale, Render, Resource, Security, TemporaryFile, Transform, X11, or User.

For example, to log cache and blob events, use.

magick -debug "Cache,Blob" rose: rose.png

The User domain is normally empty, but developers can log user events in their private copy of ImageMagick.

To print the complete list of debug methods, use [-list debug].

Use the [-log] option to specify the format for debugging output.

Use [+debug] to turn off all logging.

Debugging may also be set using the MAGICK_DEBUG [environment variable]. The allowed values for the MAGICK_DEBUG environment variable are the same as for the [-debug] option.

-decipher filename
-------------------

Decipher and restore pixels that were previously transformed by [-encipher].

Get the passphrase from the file specified by filename.

For more information, see the webpage, [ImageMagick: Encipher or Decipher an Image].

-deconstruct
-------------

Find areas that has changed between images

Given a sequence of images all the same size, such as produced by [-coalesce], replace the second and later images, with a smaller image of just the area that changed relative to the previous image.

The resulting sequence of images can be used to optimize an animation sequence, though will not work correctly for GIF animations when parts of the animation can go from opaque to transparent.

This option is actually equivalent to the [-layers] method 'compare-any'.

-define key{\=value}...
------------------------

Add specific global settings generally used to control coders and image processing operations.

This option creates one or more definitions for coders and decoders to use while reading and writing image data. Definitions are generally used to control image file format coder modules, and image processing operations, beyond what is provided by normal means. Defined settings are listed in [-verbose] information ("info:" output format) as "Artifacts".

If value is missing for a definition, an empty-valued definition of a flag is created with that name. This used to control on/off options. Use [+define key] to remove definitions previously created. Use `+define "*"` to remove all existing definitions.

The same 'artifact' settings can also be defined using the [-set "option:key" "value"] option, which also allows the use of [Format and Print Image Properties] in the defined value.

The option and key are case-independent (they are converted to lowercase for use within the decoders) while the value is case-dependent.

Such settings are global in scope, and affect all images and operations.

See [ImageMagick Defines] for a list of recognized defines. For example:

magick bilevel.tif -define ps:imagemask eps3:stencil.ps

Set attributes of the image registry by prefixing the value with registry:. For example, to set a temporary path to put work files, use:

-define registry:temporary-path=/data/tmp

-delay ticks  
-delay ticksxticks-per-second {<} {\>}
-------------------------------------------------------

Display the next image after pausing.

This option is useful for regulating the animation of image sequences ticks/ticks-per-second seconds must expire before the display of the next image. The default is no delay between each showing of the image sequence. The default ticks-per-second is 100.

Use > to change the image delay only if its current value exceeds the given delay. < changes the image delay only if current value is less than the given delay. For example, if you specify 30> and the image delay is 20, the image delay does not change. However, if the image delay is 40 or 50, the delay it is changed to 30. Enclose the given delay in quotation marks to prevent the < or > from being interpreted by your shell as a file redirection.

-delete indexes
----------------

Delete the images specified by index, from the image sequence.

Specify the image by its index in the sequence. The first image is index 0. Negative indexes are relative tothe end of the sequence, for example, -1 represents the last image of the sequence. Specify a range of images with a dash (e.g. 0-4). Separate indexes with a comma (e.g. 0,2). Use +delete to delete the last image in the current image sequence. Use -delete 0--1 to delete the entire image sequence.

You can also delete images from the persistent registry, e.g., -delete registry:checkers

-density width  
-density widthxheight
----------------------------------------

Set the horizontal and vertical resolution of an image for rendering to devices.

This option specifies the image resolution to store while encoding a raster image or the canvas resolution while rendering (reading) vector formats such as Postscript, PDF, WMF, and SVG into a raster image. Image resolution provides the unit of measure to apply when rendering to an output device or raster image. The default unit of measure is in dots per inch (DPI). The [-units] option may be used to select dots per centimeter instead.

The default resolution is 72 dots per inch, which is equivalent to one point per pixel (Macintosh and Postscript standard). Computer screens are normally 72 or 96 dots per inch, while printers typically support 150, 300, 600, or 1200 dots per inch. To determine the resolution of your display, use a ruler to measure the width of your screen in inches, and divide by the number of horizontal pixels (1024 on a 1024x768 display).

If the file format supports it, this option may be used to update the stored image resolution. Note that Photoshop stores and obtains image resolution from a proprietary embedded profile. If this profile is not stripped from the image, then Photoshop will continue to treat the image using its former resolution, ignoring the image resolution specified in the standard file header.

The [-density] option sets an attribute and does not alter the underlying raster image. It may be used to adjust the rendered size for desktop publishing purposes by adjusting the scale applied to the pixels. To resize the image so that it is the same size at a different resolution, use the [-resample] option.

-depth value
-------------

Depth of the image.

Color depth is the number of bits per channel for each pixel. For example, for a depth of 16 using RGB, each channel of Red, Green, and Blue can range from 0 to 2^16-1 (65535). Use this option to specify the depth of raw images formats whose depth is unknown such as GRAY, RGB, or CMYK, or to change the depth of any image after it has been read.

Use [+depth] to return depth to its default value.

-descend
---------

Obtain image by descending window hierarchy.

-deskew threshold{%}
---------------------

Straighten an image. A threshold of 40% works for most images.

Use [-set] `option:deskew:auto-crop true | false` to auto crop the image.

-despeckle
-----------

Reduce the speckles within an image.

-direction type
----------------

Render text right-to-left or left-to-right. Requires the [RAQM](https://github.com/HOST-Oman/libraqm) delegate library and [complex text layout](https://en.wikipedia.org/wiki/Complex_text_layout).

-displace horizontal-scale{%}{!}  
-displace horizontal-scalexvertical-scale{%}{!}
------------------------------------------------------------------------------------

Shift image pixels as defined by a displacement map.

With this option, the 'overlay' image, and optionally the 'mask' image, is used as a displacement map, which is used to displace the lookup of what part of the 'background' image is seen at each point of the overlaid area. Much like the displacement map is a 'lens' that redirects light shining through it so as to present a distorted view the original 'background' image behind it.

Any perfect grey areas of the displacement map produce a zero displacement of the image. Black areas produce the given maximum negative displacement of the lookup point, while white produce a maximum positive displacement of the lookup.

Note that it is the lookup of the 'background' that is displaced, not a displacement of the image itself. As such an area of the displacement map containing 'white' will have the lookup point 'shifted' by a positive amount, and thus generating a copy of the destination image to the right/downward from the correct position. That is the image will look like it may have been 'shifted' in a negative left/upward direction. Understanding this is a very important in understanding how displacement maps work.

The given arguments define the maximum amount of displacement in pixels that a particular map can produce. If the displacement scale is large enough it is also possible to lookup parts of the 'background' image that lie well outside the bounds of the displacement map itself. That is you could very easily copy a section of the original image from outside the overlay area into the overlay area.

The '%' flag makes the displacement scale relative to the size of the overlay image (100% = half width/height of image). Using '!' switches percentage arguments to refer to the destination image size instead. these flags were added as of IM v6.5.3-5.

Normally a single grayscale displacement map is provided, which with the given scaling values will determine a single direction (vector) in which displacements can occur (positively or negatively). However, if you also specify a third image which is normally used as a mask, the composite image is used for horizontal X displacement, while the mask image is used for vertical Y displacement. This allows you to define completely different displacement values for the X and Y directions, and allowing you to lookup any point within the scale bounds. In other words each pixel can lookup any other nearby pixel, producing complex 2 dimensional displacements, rather than a simple 1 dimensional vector displacements.

Alternatively rather than supplying two separate images, as of IM v6.4.4-0, you can use the 'red' channel of the overlay image to specify the horizontal or X displacement, and the 'green' channel for the vertical or Y displacement.

As of IM v6.5.3-5 any alpha channel in the overlay image is used as a mask the transparency of the destination image. However areas outside the overlaid areas will not be affected.

-display host:display[.screen]
---------------------------------

Specifies the X server to contact.

This option is used with convert for obtaining image or font from this X server. See X(1).

-dispose method
----------------

Define the GIF disposal image setting for images that are being created or read in.

The layer disposal method defines the way each the displayed image is to be modified after the current 'frame' of an animation has finished being displayed (after its 'delay' period), but before the next frame on an animation is to be overlaid onto the display.

Here are the valid methods:

    Undefined    0: No disposal specified (equivalent to 'none').
    None         1: Do not dispose, just overlay next frame image.
    Background   2: Clear the frame area with the background color.
    Previous     3: Clear to the image prior to this frames overlay.

You can also use the numbers given above, which is what the GIF format uses internally to represent the above settings.

To print a complete list of dispose methods, use [-list dispose].

Use [+dispose], turn off the setting and prevent resetting the layer disposal methods of images being read in.

Use [-set] 'dispose' method to set the image disposal method for images already in memory.

-dissimilarity-threshold value
-------------------------------

Maximum RMSE for subimage match (default 0.2).

-dissolve src_percent[xdst_percent]
----------------------------------------

Dissolve an image into another by the given percent.

The opacity of the composite image is multiplied by the given percent, then it is composited 'over' the main image. If src_percent is greater than 100, start dissolving the main image so it becomes transparent at a value of '200'. If both percentages are given, each image are dissolved to the percentages given.

Note that dissolve percentages do not add, two opaque images dissolved '50,50', produce a 75% transparency. For a 50% + 50% blending of the two images, you would need to use dissolve values of '50,100'.

-distort method arguments
--------------------------

Distort an image, using the given method and its required arguments.

The arguments is a single string containing a list of floating point numbers separated by commas or spaces. The number of and meaning of the floating point values depends on the distortion method being used.

Choose from these distortion types:

*   ScaleRotateTranslate (SRT)

    Distort image by first scaling and rotating about a given 'center', before translating that 'center' to the new location, in that order. It is an alternative method of specifying a 'Affine' type of distortion, but without shearing effects. It also provides a good way of rotating and displacing a smaller image for tiling onto a larger background (IE 2-dimensional animations).  

    The number of arguments determine the specific meaning of each argument for the scales, rotation, and translation operations.  

        2:     Scale Angle
        3:     X,Y Angle
        4:     X,Y Scale Angle
        5:     X,Y ScaleX,ScaleY Angle
        6:     X,Y Scale Angle NewX,NewY
        7:     X,Y ScaleX,ScaleY Angle NewX,NewY

    This is actually an alternative way of specifying a 2 dimensional linear 'Affine' or 'AffineProjection' distortion.

*   Affine

    Distort the image linearly by moving a list of at least 3 or more sets of control points (as defined below). Ideally 3 sets or 12 floating point values are given allowing the image to be linearly scaled, rotated, sheared, and translated, according to those three points. See also the related 'AffineProjection' and 'SRT' distortions.  
    More than 3 sets given control point pairs (12 numbers) is least squares fitted to best match a linear affine distortion. If only 2 control point pairs (8 numbers) are given a two point image translation rotation and scaling is performed, without any possible shearing, flipping or changes in aspect ratio to the resulting image. If only one control point pair is provides the image is only translated, (which may be a floating point non-integer translation).  
    This distortion does not include any form of perspective distortion.

*   RigidAffine

    A rigid affine (also known as a Euclidean transform), is similar to Affine but restricts the distortion to 4 arguments (S, R, Tx, Ty) with Sy = Sx and Ry = -Rx so that the distortion only has scale, rotation and translation. No skew. A minimum of two control point pairs is required.

*   AffineProjection

    Linearly distort an image using the given Affine Matrix of 6 pre-calculated coefficients forming a set of Affine Equations to map the source image to the destination image.

    sx, rx, ry, sy, tx, ty

    See [-affine] setting for more detail, and meanings of these coefficients.  
    The distortions 'Affine' and 'SRT' provide alternative methods of defining this distortion, with ImageMagick doing the calculations needed to generate the required coefficients. You can see the internally generated coefficients, by using a [-verbose] setting with those other variants.

*   BilinearForward BilinearReverse

    Bilinear Distortion, given a minimum of 4 sets of coordinate pairs, or 16 values (see below). Not that lines may not appear straight after distortion, though the distance between coordinates will remain consistent.  
    The 'BilinearForward' is used to map rectangles to any quadrilateral, while the 'BilinearReverse' form maps any quadrilateral to a rectangle, while preserving the straight line edges in each case.  
    Note that 'BilinearForward' can generate invalid pixels which will be colored using the [-mattecolor] color setting. Also if the quadrilateral becomes 'flipped' the image may disappear.  
    There are future plans to produce a true Bilinear distortion that will attempt to map any quadrilateral to any other quadrilateral, while preserving edges (and edge distance ratios).

*   Perspective

    Perspective distort the images, using a list of 4 or more sets of control points (as defined below). More that 4 sets (16 numbers) of control points provide least squares fitting for more accurate distortions (for the purposes of image registration and panorama effects). Less than 4 sets will fall back to a 'Affine' linear distortion.  
    Perspective Distorted images ensures that straight lines remain straight, but the scale of the distorted image will vary. The horizon is anti-aliased, and the 'sky' color may be set using the [-mattecolor] setting.

*   PerspectiveProjection

    Do a 'Perspective' distortion biased on a set of 8 pre-calculated coefficients. You can get these coefficients by looking at the [-verbose] output of a 'Perspective' distortion, or by calculating them yourself. If the last two perspective scaling coefficients are zero, the remaining 6 represents a transposed 'Affine Matrix'.

*   Polynomial

    Do an Nth order 2D 'Polynomial' distortion using a set of corresponding control points. The order of the polynomial dictates the minimum number of control points needed. Order 1 is the same as -distort Affine. Order 1.5 is the same as -distort BilinearReverse. Typical use is for a 2nd order distortion. There is no +distort polynomial.

*   Arc

    Arc the image (variation of polar mapping) over the angle given around a circle.

        arc_angle      The angle over which to arc the image side-to-side
        rotate_angle   Angle to rotate resulting image from vertical center
        top_radius     Set top edge of source image at this radius
        bottom_radius  Set bottom edge to this radius (radial scaling)

    The resulting image is always resized to best fit the resulting image, (as if using [+distort]) while attempting to preserve scale and aspect ratio of the original image as much as possible with the arguments given by the user. All four arguments will be needed to change the overall aspect ratio of an 'Arc'ed image.  
    This a variation of a polar distortion designed to try to preserve the aspect ratio of the image rather than direct Cartesian to Polar conversion.

*   Polar

    Like 'Arc' but do a complete Cartesian to Polar mapping of the image. that is the height of the input image is mapped to the radius limits, while the width is wrapped around between the angle limits.  

    Arguments: Rmax,Rmin CenterX,CenterY, start,end_angle  

    All arguments are optional. With Rmin defaulting to zero, the center to the center of the image, and the angles going from -180 (top) to +180 (top). If Rmax is given the special value of '0', the distance from the center to the nearest edge is used for the radius of the output image, which will ensure the whole image is visible (though scaled smaller). However a special value of '-1' will use the distance from the center to the furthest corner, This may 'clip' the corners from the input rectangular image, but will generate the exact reverse of a 'DePolar' with the same arguments.  
    If the plus form of distort ([+distort]) is used output image center will default to 0,0 of the virtual canvas, and the image size adjusted to ensure the whole input image is made visible in the output image on the virtual canvas.

*   DePolar

    Uses the same arguments and meanings as a 'Polar' distortion but generates the reverse Polar to Cartesian distortion.  

    The special Rmax setting of '0' may however clip the corners of the input image. However using the special Rmax setting of '-1' (maximum center to corner distance) will ensure the whole distorted image is preserved in the generated result, so that the same argument to 'Polar' will reverse the distortion re-producing the original. Note that as this distortion requires the area resampling of a circular arc, which can not be handled by the builtin EWA resampling function. As such the normal EWA filters are turned off. It is recommended some form of 'super-sampling' image processing technique be used to produce a high quality result.

*   Barrel

    Given the four coefficients (A,B,C,D) as defined by [Helmut Dersch](http://wiki.panotools.org/Lens_correction_model), perform a barrel or pin-cushion distortion appropriate to correct radial lens distortions. That is in photographs, make straight lines straight again.  

    Arguments: A B C [ D [ X , Y ] ]  
    or Ax Bx Cx Dx Ay By Cy Dy [ X , Y ]

    So that it forms the function

    Rsrc = r * ( A*r3 + B*r2 + C*r + D )

    Where X,Y is the optional center of the distortion (defaulting to the center of the image).  
    The second form is typically used to distort images, rather than correct lens distortions.  

*   BarrelInverse

    This is very similar to 'Barrel' with the same set of arguments, and argument handling. However it uses the inverse of the radial polynomial, so that it forms the function

    Rsrc = r / ( A*r3 + B*r2 + C*r + D )

    Note that this is not the reverse of the 'Barrel' distortion, just a different barrel-like radial distortion method.

*   Shepards

    Distort the given list control points (any number) using an Inverse Squared Distance Interpolation Method ([Shepards Method](http://en.wikipedia.org/wiki/Shepard%27s_method)). The control points in effect do 'localized' displacement of the image around the given control point (preserving the look and the rotation of the area near the control points. For best results extra control points should be added to 'lock' the positions of the corners, edges and other unchanging parts of the image, to prevent their movement.  
    The distortion has been likened to 'taffy pulling' using nails, or pins' stuck in a block of 'jelly' which is then moved to the new position, distorting the surface of the jelly.  
    Internally it is equivalent to generating a displacement map (see [-displace]) for source image color look-up using the [-sparse-color] method of the same name.

To print a complete list of distortion methods, use [-list distort].

Many of the above distortion methods such as 'Affine', 'Perspective', and 'Shepards' use a list control points defining how these points in the given image should be distorted in the destination image. Each set of four floating point values represent a source image coordinate, followed immediately by the destination image coordinate. This produces a list of values such as...

    U1,V1 X1,Y1 U2,V2 X2,Y2 U3,V3 X3,Y3 ... Un,Vn Xn,Yn

where U,V on the source image is mapped to X,Y on the destination image.

For example, to warp an image using 'perspective' distortion, needs a list of at least 4 sets of coordinates, or 16 numbers. Here is the perspective distortion of the built-in "rose:" image. Note how spaces were used to group the 4 sets of coordinate pairs, to make it easier to read and understand.

    magick rose:  -virtual-pixel black \
      -distort Perspective '0,0,0,0  0,45,0,45  69,0,60,10  69,45,60,35' \
       rose_3d_rotated.gif"

If more that the required number of coordinate pairs are given for a distortion, the distortion method is 'least squares' fitted to produce the best result for all the coordinate pairs given. If less than the ideal number of points are given, the distort will generally fall back to a simpler form of distortion that can handles the smaller number of coordinates (usually a linear 'Affine' distortion).

By using more coordinates you can make use of image registration tool to find matching coordinate pairs in overlapping images, so as to improve the 'fit' of the distortion. Of course a bad coordinate pair can also make the 'fit' worse. Caution is always advised.

Colors are acquired from the source image according to a cylindrical resampling [-filter], using a special technique known as EWA resampling. This produces very high quality results, especially when images become smaller (minified) in the output, which is very common when using 'perspective' distortion. For example here we view a infinitely tiled 'plane' all the way to the horizon.

    magick -size 90x90 pattern:checkerboard -normalize -virtual-pixel tile \
      -distort perspective  '0,0,5,45  89,0,45,46  0,89,0,89  89,89,89,89' \
       checks_tiled.jpg

Note that a infinitely tiled perspective images involving the horizon can be very slow, because of the number of pixels that are compressed to generate each individual pixel close to the 'horizon'. You can turn off EWA resampling, by specifying the special [-filter] setting of 'point' (recommended if you plan to use super-sampling instead).

If an image generates _invalid pixels_, such as the 'sky' in the last example, [-distort] will use the current [-mattecolor] setting for these pixels. If you do not what these pixels to be visible, set the color to match the rest of the ground.

The output image size will by default be the same as the input image. This means that if the part of the distorted image falls outside the viewed area of the 'distorted space', those parts is clipped and lost. However if you use the plus form of the operator ([+distort]) the operator will attempt (if possible) to show the whole of the distorted image, while retaining a correct 'virtual canvas' offset, for image layering. This offset may need to be removed using [+repage], to remove if it is unwanted.

Setting [-verbose] setting, will cause [-distort] to attempt to output the internal coefficients, and the [-fx] equivalent to the distortion, for expert study, and debugging purposes. This many not be available for all distorts.

You can alternatively specify a special "[-define] distort:viewport={geometry_string}" setting which will specify the size and the offset of the generated 'viewport' image of the distorted image space.

Setting a "[-define] distort:scale=scale_factor" will scale the output image (viewport or otherwise) by that factor without changing the viewed contents of the distorted image. This can be used either for 'super-sampling' the image for a higher quality result, or for panning and zooming around the image (with appropriate viewport changes, or post-distort cropping and resizing).

Setting "[-define] resample:verbose=1" will output the cylindrical filter lookup table created by the EWA (Elliptical Weighted Average) resampling algorithm. Note this table uses a squared radius lookup value. This is typically only used for debugging EWA resampling.

-distribute-cache port
-----------------------

Launch a distributed pixel cache server.

-dither method
---------------

Apply a Riemersma or Floyd-Steinberg error diffusion dither to images when general color reduction is applied via an option, or automagically when saving to specific formats. This enabled by default.

Dithering places two or more colors in neighboring pixels so that to the eye a closer approximation of the images original color is reproduced. This reduces the number of colors needed to reproduce the image but at the cost of a lower level pattern of colors. Error diffusion dithers can use any set of colors (generated or user defined) to an image.

Dithering is turned on by default, to turn it off use the plus form of the setting, [+dither]. This will also render PostScript without text or graphic aliasing. Disabling dithering often (but not always) leads to faster process, a smaller number of colors, but more cartoon like image coloring. Generally resulting in 'color banding' effects in areas with color gradients.

The color reduction operators [-colors], [-monochrome], [-remap], and [-posterize], apply dithering to images using the reduced color set they created. These operators are also used as part of automatic color reduction when saving images to formats with limited color support, such as GIF:, XBM:, and others, so dithering may also be used in these cases.

Alternatively you can use [-random-threshold] to generate purely random dither. Or use [-ordered-dither] to apply threshold mapped dither patterns, using uniform color maps, rather than specific color maps.

Use "[-define] dither:diffusion-amount=35%, for example, to control the amount of Floyd-Steinberg dither.

-draw string
-------------

Annotate an image with one or more graphic primitives.

Use this option to annotate or decorate an image with one or more graphic primitives. The primitives include shapes, text, transformations, and pixel operations.

The shape primitives:

    point           x,y
    line            x0,y0 x1,y1
    rectangle       x0,y0 x1,y1
    roundRectangle  x0,y0 x1,y1 wc,hc
    arc             x0,y0 x1,y1 a0,a1
    ellipse         x0,y0 rx,ry a0,a1
    circle          x0,y0 x1,y1
    polyline        x0,y0 ... xn,yn
    polygon         x0,y0 ... xn,yn
    bezier          x0,y0 ... xn,yn
    path            specification
    image           operator x0,y0 w,h filename

The text primitive:

    text            x0,y0 string

The text gravity primitive:

    gravity         NorthWest, North, NorthEast, West, Center, East, 
                    SouthWest, South, or SouthEast

The text gravity primitive only affects the placement of text and does not interact with the other primitives. It is equivalent to using the [-gravity] command-line option, except that it is limited in scope to the [-draw] option in which it appears.

The transformation primitives:

    rotate      degrees
    translate   dx,dy
    scale       sx,sy
    skewX       degrees
    skewY       degrees

The pixel operation primitives:

    color       x0,y0 method
    matte       x0,y0 method

The shape primitives are drawn in the color specified by the preceding [-fill] setting. For unfilled shapes, use [-fill none]. You can optionally control the stroke (the "outline" of a shape) with the [-stroke] and [-strokewidth] settings.

A point primitive is specified by a single point in the pixel plane, that is, by an ordered pair of integer coordinates, x,y. (As it involves only a single pixel, a point primitive is not affected by [-stroke] or [-strokewidth].)

A line primitive requires a start point and end point.

A rectangle primitive is specified by the pair of points at the upper left and lower right corners.

A roundRectangle primitive takes the same corner points as a rectangle followed by the width and height of the rounded corners to be removed.

The circle primitive makes a disk (filled) or circle (unfilled). Give the center and any point on the perimeter (boundary). Note, by using a translation, you can remove the need to calculate the circles edge coordinate, but can just give the radius directly:

magick -size 100x60 xc: -stroke SeaGreen  -fill PaleGreen -strokewidth 2 -draw 'translate 50,30 circle 0,0 25,0' circle.gif

The arc primitive is used to inscribe an elliptical segment in to a given rectangle. An arc requires the two corners used for rectangle (see above) followed by the start and end angles of the arc of the segment (e.g. 130,30 200,100 45,90). The start and end points produced are then joined with a line segment and the resulting segment of an ellipse is filled.

Use ellipse to draw a partial (or whole) ellipse. Give the center point, the horizontal and vertical "radii" (the semi-axes of the ellipse) and start and end angles in degrees (e.g. 100,100 100,150 0,360).

The polyline and polygon primitives require three or more points to define their perimeters. A polyline is simply a polygon in which the final point is not stroked to the start point. When unfilled, this is a polygonal line. If the [-stroke] setting is none (the default), then a polyline is identical to a polygon.

A coordinate is a pair of integers separated by a space or optional comma.

As an example, to define a circle centered at 100,100 that extends to 150,150 use:

    -draw 'circle 100,100 150,150'

The Bezier primitive creates a spline curve and requires three or points to define its shape. The first and last points are the knots and these points are attained by the curve, while any intermediate coordinates are control points. If two control points are specified, the line between each end knot and its sequentially respective control point determines the tangent direction of the curve at that end. If one control point is specified, the lines from the end knots to the one control point determines the tangent directions of the curve at each end. If more than two control points are specified, then the additional control points act in combination to determine the intermediate shape of the curve. In order to draw complex curves, it is highly recommended either to use the path primitive or to draw multiple four-point bezier segments with the start and end knots of each successive segment repeated. For example:

    -draw 'bezier 20,50 45,100 45,0 70,50'
    -draw 'bezier 70,50 95,100 95,0 120,50'

A path represents an outline of an object, defined in terms of moveto (set a new current point), lineto (draw a straight line), curveto (draw a Bezier curve), arc (elliptical or circular arc) and closepath (close the current shape by drawing a line to the last moveto) elements. Compound paths (i.e., a path with subpaths, each consisting of a single moveto followed by one or more line or curve operations) are possible to allow effects such as donut holes in objects. (See [Paths](http://www.w3.org/TR/SVG/paths.html).)

Use image to composite an image with another image. Follow the image keyword with the composite operator, image location, image size, and filename:

    -draw 'image SrcOver 100,100 225,225 image.jpg'

You can use 0,0 for the image size, which means to use the actual dimensions found in the image header. Otherwise, it is scaled to the given dimensions. See [Alpha Compositing] for a detailed discussion of alpha composition methods that are available.

The "special augmented compose operators" such as "dissolve" that require arguments cannot be used at present with the -draw image option.

Use text to annotate an image with text. Follow the text coordinates with a string. If the string has embedded spaces, enclose it in single or double quotes.

For example, the following annotates the image with Works like magick! for an image titled bird.miff.

    -draw "text 100,100 'Works like magick!'"

See the [-annotate] option for another convenient way to annotate an image with text.

The rotate primitive rotates subsequent shape primitives and text primitives about the origin of the main image:

    -draw "rotate 45 text 10,10 'Works like magick!'"

The translate primitive translates subsequent shape and text primitives.

The scale primitive scales them.

The skewX and skewY primitives skew them with respect to the origin of the main image or the region.

The transformations modify the current affine matrix, which is initialized from the initial affine matrix defined by the [-affine] option. Transformations are cumulative within the [-draw] option. The initial affine matrix is not affected; that matrix is only changed by the appearance of another [-affine] option. If another [-draw] option appears, the current affine matrix is reinitialized from the initial affine matrix.

Use the color primitive to change the color of a pixel to the fill color (see [-fill]). Follow the pixel coordinate with a method:

    point
    replace
    floodfill
    filltoborder
    reset

Consider the target pixel as that specified by your coordinate. The point method recolors the target pixel. The replace method recolors any pixel that matches the color of the target pixel. Floodfill recolors any pixel that matches the color of the target pixel and is a neighbor, whereas filltoborder recolors any neighbor pixel that is not the border color. Finally, reset recolors all pixels.

Use matte to the change the pixel matte value to transparent. Follow the pixel coordinate with a method (see the color primitive for a description of methods). The point method changes the matte value of the target pixel. The replace method changes the matte value of any pixel that matches the color of the target pixel. Floodfill changes the matte value of any pixel that matches the color of the target pixel and is a neighbor, whereas filltoborder changes the matte value of any neighbor pixel that is not the border color ([-bordercolor]). Finally reset changes the matte value of all pixels.

You can set the primitive color, font, and font bounding box color with [-fill], [-font], and [-box] respectively. Options are processed in command line order so be sure to use these options before the [-draw] option.

Strings that begin with a number must be quoted (e.g. use '1.png' rather than 1.png).

Drawing primitives conform to the [Magick Vector Graphics] format.

Note, drawing requires an alpha channel. If none is available, an all opaque alpha channel is implicitedly created.

-duplicate count,indexes
-------------------------

Duplicate an image one or more times.

Specify the count and the image to duplicate by its index in the sequence. The first image is index 0. Negative indexes are relative to the end of the sequence, for example, -1 represents the last image of the sequence. Specify a range of images with a dash (e.g. 0-4). Separate indexes with a comma (e.g. 0,2). Use +duplicate to duplicate the last image in the current image sequence.

-edge radius
-------------

Detect edges within an image.

-emboss radius{xsigma
----------------------

Emboss an image.

-encipher filename
-------------------

Encipher pixels for later deciphering by [-decipher].

Get the passphrase from the file specified by filename.

For more information, see the webpage, [ImageMagick: Encipher or Decipher an Image].

-encoding type
---------------

Specify the text encoding.

Choose from

    AdobeCustom     AdobeExpert
    AdobeStandard   AppleRoman
    BIG5            GB2312
    Latin 2         None
    SJIScode        Symbol
    Unicode         Wansung

-endian type
-------------

Specify endianness (MSB or LSB) of the image.

To print a complete list of endian types, use the [-list endian] option.

Use [+endian] to revert to unspecified endianness.

-enhance
---------

Apply a digital filter to enhance a noisy image.

-equalize
----------

Perform histogram equalization on the image channel-by-channel.

To perform histogram equalization on all channels in concert, transform the image into some other color space, such as HSL, OHTA, YIQ or YUV, then equalize the appropriate intensity-like channel, then convert back to RGB.

For example using HSL, we have: ... -colorspace HSL -channel lightness -equalize -colorspace sRGB ...

For YIQ, YUV and OHTA use the red channel. For example, OHTA is a principal components transformation that puts most of the information in the first channel. Here we have ... -colorspace OHTA -channel red -equalize -colorspace sRGB ...

-evaluate operator value
-------------------------

Alter channel pixels by evaluating an arithmetic, relational, or logical expression.

(See the [-function] operator for some multi-parameter functions. See the [-fx] operator if more elaborate calculations are needed.)

The behaviors of each operator are summarized in the following list. For brevity, the numerical value of a "pixel" referred to below is the value of the corresponding channel of that pixel, while a "normalized pixel" is that number divided by the maximum (installation-dependent) value QuantumRange. (If normalized pixels are used, they are restored, following the other calculations, to the full range by multiplying by QuantumRange.)

 

operator summary (see further below for details)

    Abs               Add value to pixels and return absolute value.
    Add               Add value to pixels.
    AddModulus        Add value to pixels modulo QuantumRange.
    And               Binary AND of pixels with value.
    Cos, Cosine       Apply cosine to pixels with frequency value with 50% bias added.
    Divide            Divide pixels by value.
    Exp               base-e exponential function
    Exponential       base-e exponential function
    InverseLog        Apply inverse scaled logarithm to normalized pixels.
    LeftShift         Shift the pixel values left by value bits 
                      (i.e., multiply pixels by 2value).
    Log               Apply scaled logarithm to normalized pixels.
    Max               Set pixels to maximum of value and current pixel value (i.e. set any pixels currently less than value to value).
    Mean              Add the value and divide by 2.
    Median            Choose the median value from an image sequence.
    Min               Set pixels to minimum of value and current pixel value (i.e. set any pixels currently greater than value to value).
    Multiply          Multiply pixels by value.
    Or                Binary OR of pixels with value.
    Pow               Raise normalized pixels to the power value.
    RightShift        Shift the pixel values right by value bits (i.e., divide pixels by 2value).
    RMS               Square the pixel and add the value.
    RootMeanSquare    Square the pixel and add the value.
    Set               Set pixel equal to value.
    Sin, Sine         Apply sine to pixels with frequency value with 50% bias added.
    Subtract          Subtract value from pixels.
    Xor               Binary XOR of pixels with value.

    Gaussian-noise
    Impulse-noise
    Laplacian-noise
    Multiplicative-noise    (These are equivalent to the corresponding [-noise] operators.)
    PoissonNoise
    Uniform-noise

    Threshold         Threshold pixels larger than value.
    ThresholdBlack    Threshold pixels to zero values equal to or below value.
    ThresholdWhite    Threshold pixels to maximum values above value.

The specified functions are applied only to each previously set [-channel] in the image. If necessary, the results of the calculations are truncated (clipped) to fit in the interval [0, QuantumRange]. The transparency channel of the image is represented as a 'alpha' values (0 = fully transparent), so, for example, a Divide by 2 of the alpha channel will make the image semi-transparent. Append the percent symbol '%' to specify a value as a percentage of the QuantumRange.

To print a complete list of [-evaluate] operators, use [-list evaluate].

The results of the Add, Subtract and Multiply methods can also be achieved using either the [-level] or the [+level] operator, with appropriate argument, to linearly modify the overall range of color values. Please note, however, that [-level] treats transparency as 'matte' values (0 = opaque), while [-evaluate] works with 'alpha' values.

AddModulus has been added as of ImageMagick 6.4.8-4 and provides addition modulo the QuantumRange. It is therefore equivalent to Add unless the resulting pixel value is outside the interval [0, QuantumRange].

Exp or Exponential has been added as of ImageMagick 6.6.5-1 and works on normalized pixel values. The value used with Exp should be negative so as to produce a decaying exponential function. Non-negative values will always produce results larger unity and thus outside the interval [0, QuantumRange]. The formula is expressed below.

    exp(value × u)

If the input image is squared, for example, using [-function polynomial "2 0 0"], then a decaying Gaussian function will be the result.

Log has been added as of ImageMagick 6.4.2-1 and works on normalized pixel values. This a scaled log function. The value used with Log provides a scaling factor that adjusts the curvature in the graph of the log function. The formula applied to a normalized value **u** is below.

    log(value × u + 1) / log(value + 1)

Pow has been added as of ImageMagick 6.4.1-9, and works on normalized pixel values. Note that Pow is related to the [-gamma] operator. For example, **-gamma 2** is equivalent to **-evaluate pow 0.5**, i.e., a 'square root' function. The value used with [-gamma] is simply the reciprocal of the value used with Pow.

Cosine and Sine was added as of IM v6.4.8-8 and converts the image values into a value according to a (co)sine wave function. The synonyms Cos and Sin may also be used. The output is biased 50% and normalized by 50% so as to fit in the respective color value range. The value scaling of the period of the function (its frequency), and thus determines the number of 'waves' that will be generated over the input color range. For example, if the value is 1, the effective period is simply the QuantumRange; but if the value is 2, then the effective period is the half the QuantumRange.

    0.5 + 0.5 × cos(2 π u × value).

Use [-set] 'option:evaluate:clamp=true to clamp the evaluation value.

See also the [-function] operator, which is a multi-value version of evaluate.

-evaluate-sequence operator
----------------------------

Alter channel pixels by evaluating an arithmetic, relational, or logical expression over a sequence of images. Ensure all the images in the sequence are in the same colorspace, otherwise you may get unexpected results, e.g. add [-colorspace sRGB] to your command-line.

To print a complete list of [-evaluate-sequence] operators, use [-list evaluate].

-exit
------

Stop processing at this point.

No further options are processed after this option. Useful in a script to force the magick command to exit without actually closing the pipeline that it is processing options from. You can also use the option as a _final_ option on the magick command line instead of an implicit output image, to completely prevent any image write. Note, even the NULL: coder requires at least one image, for it to 'not write'! This option does not require any images at all.

-extent geometry
-----------------

Set the image size and offset.

If the image is enlarged, unfilled areas are set to the background color. To position the image, use offsets in the geometry specification or precede with a [-gravity] setting. To specify how to compose the image with the background, use [-compose].

The following command reduces or expands a JPEG image to fit on an 800x600 display. If the aspect ratio of the input image isn't exactly 4:3, then the image is centered on an 800x600 black canvas:

magick input.jpg -resize 800x600 -background black -compose Copy \
  -gravity center -extent 800x600 -quality 92 output.jpg

The command can also be used with a ratio. If the image is not already at that ratio, it will be cropped to fit it. The [-gravity] setting has the expected effects.

The following command crops a JPEG image so that it has a 4:3 ratio:

magick input.jpg -extent 4:3 -quality 92 output.jpg

Append < to pad only if the image is smaller than the specified size _and_ not crop if the image is larger (i.e. no-op). Append > to crop only if the image is larger than the specified size _and_ not extend if the image is smaller. (i.e. no-op).

See [Image Geometry] for complete details about the _geometry_ argument.

-extract geometry
------------------

Extract the specified area from image.

This option is most useful for extracting a subregion of a very large raw image. Note that these two commands are equivalent:

magick -size 16000x16000 -depth 8 -extract 640x480+1280+960 \
  image.rgb image.png",
convert -size 16000x16000 -depth 8 'image.rgb[640x480+1280+960]' \
  image.rgb image.png"

If you omit the offsets, as in

magick -size 16000x16000 -depth 8 -extract 640x480 \
  image.rgb image.png

the image is resized to the specified dimensions instead, equivalent to:

magick -size 16000x16000 -depth 8 -resize 640x480 image.rgb image.png

See [Image Geometry] for complete details about the _geometry_ argument.

-family fontFamily
-------------------

Set a font family for text.

This setting suggests a font family that ImageMagick should try to use for rendering text. If the family can be found it is used; if not, a default font (e.g., "Arial") or a family known to be similar is substituted (e.g., "Courier" might be used if "System" is requested but not found). Note, the family can be a CSS-style font list.

For other settings that affect fonts, see the options [-font], [-pointsize], [-stretch], [-style], and [-weight].

-features distance
-------------------

Display (co-occurrence matrix) texture measure features for each channel in the image in each of four directions (horizontal, vertical, left and right diagonals) for the specified distance.

    Angular Second Moment       Sum Entropy
    Contrast                    Entropy
    Correlation                 Difference Variance
    Sum of Squares Variance     Difference Entropy
    Inverse Difference Moment   Information Measure of Correlation 1
    Sum Average                 Information Measure of Correlation 2
    Sum Variance                Maximum Correlation Coefficient

-fft
-----

Implements the forward discrete Fourier transform (DFT).

This option is new as of ImageMagick 6.5.4-3 (and now working for Windows users in ImageMagick 6.6.0-9). It transforms an image from the normal (spatial) domain to the frequency domain. In the frequency domain, an image is represented as a superposition of complex sinusoidal waves of varying amplitudes. The image x and y coordinates are the possible frequencies along the x and y directions, respectively, and the pixel intensity values are complex numbers that correspond to the sinusoidal wave amplitudes. See for example, [Fourier Transform](http://en.wikipedia.org/wiki/Fourier_transform), [Discrete Fourier Transform](http://en.wikipedia.org/wiki/DFT) and [Fast Fourier Transform](http://en.wikipedia.org/wiki/FFT).

A single image name is provided as output for this option. However, the output result will have two components. It is either a two-frame image or two separate images, depending upon whether the image format specified supports multi-frame images. The reason that we get a dual output result is because the frequency domain represents an image using complex numbers, which cannot be visualized directly. Therefore, the complex values are automagically separated into a two-component image representation. The first component is the magnitude of the complex number and the second is the phase of the complex number. See for example, [Complex Numbers](http://en.wikipedia.org/wiki/Complex_numbers).

The magnitude and phase component images must be specified using image formats that do not limit the color or compress the image. Thus, MIFF, TIF, PFM, EXR and PNG are the recommended image formats to use. All of these formats, except PNG support multi-frame images. So for example,

    magick image.png -fft fft_image.miff

generates a magnitude image as fft_image.miff[0] and a phase image as fft_image.miff[1]. Similarly,

    magick image.png -fft fft_image.png

generates a magnitude image as fft_image-0.png and a phase image as fft_image-1.png. If you prefer this representation, then you can force any of the other formats to produce two output images by including [+adjoin] following -fft in the command line.

The input image can be any size, but if not square and even-dimensioned, it is padded automagically to the larger of the width or height of the input image and to an even number of pixels. The padding will occur at the bottom and/or right sides of the input image. The resulting output magnitude and phase images is square at this size. The kind of padding relies on the [-virtual-pixel] setting.

Both output components will have dynamic ranges that fit within [0, QuantumRange], so that HDRI need not be enabled. Phase values nominally range from 0 to 2 * π, but is scaled to span the full dynamic range. (The first few releases had non-HDRI scaled but HDRI not scaled). The magnitude image is not scaled and thus generally will contain very small values. As such, the image normally will appear totally black. In order to view any detail, the magnitude image typically is enhanced with a log function into what is usually called the spectrum. A log function is used to enhance the darker values more in comparison to the lighter values. This can be done, for example, as follows:

    magick fft_image.miff[0] -contrast-stretch 0 \
      -evaluate log 1000 fft_image_spectrum.png"

where either [-contrast-stretch] 0 or [-auto-level] is used to scale the image to full dynamic range, first. The argument to the [-evaluate] log typically is specified between 100 and 10,000, depending upon the amount of detail that one wants to bring out in the spectrum. Larger values produce more visible detail. Too much detail, however, may hide the important features.

The [FFTW](http://www.fftw.org/) delegate library is required to use [-fft].

Use [+fft] to produce two output images that are the real and imaginary components of the complex valued Fourier transform.

However, as the real and imaginary components can contain negative values, this requires that IM be configured with HDRI enabled. In this case, you must use either MIFF, TIF, PFM or MPC formats for the real and imaginary component results, since they are formats that preserve both negative and fractional values without clipping them or truncating the fractional part. With either MIFF or TIF, one should add -define quantum:format=32, to allow those image types to work properly in HDRI mode without clipping.

The real and imaginary component images resulting from [+fft] are also square, even dimensioned images due to the same padding that was discussed above for the magnitude and phase component images.

See the discussion on HDRI implementations of ImageMagick on the page [High Dynamic-Range Images]. For more about HDRI go the ImageMagick [Usage] pages, [Fred's Fourier Processing With ImageMagick page](http://www.fmwconcepts.com/imagemagick/fourier_transforms/fourier.html) or this [Wikipedia](http://en.wikipedia.org/wiki/High_dynamic_range_imaging) entry.

By default the FFT is normalized (and the IFT is not). Use "[-define] fourier:normalize=forward to explicitly normalize the FFT and unnormalize the IFT.

-fill color
------------

Color to use when filling a graphic primitive.

This option accepts a color name, a hex color, or a numerical RGB, RGBA, HSL, HSLA, CMYK, or CMYKA specification. See [Color Names] for a description of how to properly specify the color argument.

Enclose the color specification in quotation marks to prevent the "#" or the parentheses from being interpreted by your shell.

For example,

    -fill blue
    -fill "#ddddff"
    -fill "rgb(255,255,255)"

See [-draw] for further details.

To print a complete list of color names, use the [-list color] option.

-filter type
-------------

Use this type of filter when resizing or distorting an image.

Use this option to affect the resizing operation of an image during operations such as [-resize] and [-distort]. For example you can use a simple resize filter such as:

    Point       Hermite       Cubic
    Box         Gaussian      Catrom
    Triangle    Quadratic     Mitchell
    CubicSpline

Use -define filter:lobes={2,3,4} to specify the support size for filtering for the CubicSpline filter.

The Bessel and Sinc filter is also provided (as well as a faster SincFast equivalent form). However these filters are generally useless on their own as they are infinite filters that are being clipped to the filters support size. Their direct use is not recommended except via expert settings (see below).

Instead these special filter functions are typically windowed by a windowing function that the [-filter] setting defines. That is using these functions will define a 'Windowed' filter, appropriate to the operator involved. Windowed filters include:

    Lanczos       Hamming       Parzen
    Blackman      Kaiser        Welsh
    Hanning       Bartlett      Bohman

Also one special self-windowing filter is also provided Lagrange, which will automagically re-adjust its function depending on the current 'support' or 'lobes' expert settings (see below).

If you do not select a filter with this option, the filter defaults to Mitchell for a colormapped image, an image with a matte channel, or if the image is enlarged. Otherwise the filter default to Lanczos.

To print a complete list of resize filters, use the [-list filter] option.

You can modify how the filter behaves as it scales your image through the use of these expert settings (see also [-define] and [-set]):-

*   -define filter:blur=factor

    Scale the X axis of the filter (and its window). Use > 1.0 for blurry or < 1.0 for sharp. This should only be used with Gaussian and Gaussian-like filters simple filters, or you may not get the expected results.

*   -define filter:support=radius

    Set the filter support radius. Defines how large the filter should be and thus directly defines how slow the filtered resampling process is. All filters have a default 'preferred' support size. Some filters like Lagrange and windowed filters adjust themselves depending on this value. With simple filters this value either does nothing (but slow the resampling), or will clip the filter function in a detrimental way.

*   -define filter:lobes=count

    Set the number of lobes to use for the Sinc/Bessel filter. This an alternative way of specifying the 'support' range of the filter, that is designed to be more suited to windowed filters, especially when used for image distorts.

*   -define filter:sigma=value

    The 'sigma' value used to define the Gaussian filter. Default sigma value is '0.5'. It only affects Gaussian but does not shrink (but may enlarge) the filter's 'support'. It can be used to generate very small blurs but without the filter 'missing' pixels due to using a small support setting. A larger value of '0.707' (a value of '1/sqrt(2)') is another common setting.

*   -define filter:b=b-spline_factor
*   -define filter:c=keys_alpha_factor

    Redefine the values used for cubic filters such as Cubic, Catrom, Mitchel, and Hermite, as well as the Parzen cubic windowing function. If only one of the values are defined, the other is set so as to generate a 'Cubic-Keys' filter. The values meaning was defined by a research paper by Mitchell-Netravali.

*   -define filter:kaiser-beta=value

    The 'alpha' value used to as part of the Kaiser Windowing function. Default value is '6.5'. It only affects Kaiser windowing function, and does not affect any other attributes. Before ImageMagick v6.7.6-10, this option was known as "filter:alpha", (an inheritance from the very old "zoom" program). It was changed to bring the function in line with more modern academic research usage, and better assign it be more definitive.

*   -define filter:kaiser-alpha=value

    This value when multiplied by 'PI' is equivalent to "kaiser-beta", and will override that setting. It only affects Kaiser windowing function, and does not affect any other attributes.

*   -define filter:filter=filter_function

    Use this function directly as the weighting filter. This will allow you to directly use a windowing function such as Blackman, as a resampling filter, rather than as its normal usage as a windowing function. If defined, no windowing function also defined, the window function is set to Box). Directly specifying Sinc or Jinc as a filter will also do this.

*   -define filter:window=filter_function

    The IIR (infinite impulse response) filters Sinc and Jinc are windowed (brought down to zero over the defined support range) with the given filter. This allows you to specify a filter function to be used as a windowing function for these IIR filters. Many of the defined filters are actually windowing functions for these IIR filters. A typical choices is Box, (which effectively turns off the windowing function).

*   -define filter:win-support=radius

    Scale windowing function to this size instead. This causes the windowing (or self-windowing Lagrange filter) to act is if the support window is larger than what is actually supplied to the calling operator. The filter however is still clipped to the real support size given. If unset this will equal the normal filter support size.

*   -define filter:verbose=1

    This causes IM to print information on the final internal filter selection to standard output. This includes a commented header on the filter settings being used, and data allowing the filter weights to be easily graphed. Note however that some filters are internally defined in terms of other filters. The Lanczos filter for example is defined in terms of a SincFast windowed SincFast filter, while Mitchell is defined as a general Cubic family filter with specific 'B' and 'C' settings.

For example, to get a 8 lobe jinc windowed sinc filter (Genseng filter?):

    magick image.png \
      -filter sinc \
      -set filter:window=jinc \
      -set filter:lobes=8 \
      -resize 150% image.jpg"

Or a raw un-windowed Sinc filter with 4 lobes:

    magick image.png \
      -set filter:filter=sinc \
      -set filter:lobes=4 \
      -resize 150% image.jpg"

To extract the data for a raw windowing function, combine it with a 'Box' filter. For example the 'Welch parabolic windowing function.

    magick null: -define filter:filter=Box \
      -define filter:window=Welch \
      -define filter:support=1.0 \
      -define filter:verbose=1 \
      -resize 2 null: > window_welch.dat
    gnuplot
      set grid
      plot \"window_welch.dat\" with lines

Note that the use of expert options is provided for image processing experts who have studied and understand how resize filters work. Without this knowledge, and an understanding of the definition of the actual filters involved, using expert settings are more likely to be detrimental to your image resizing.

-flatten
---------

This is a simple alias for the [-layers] method "flatten".

-flip
------

Create a mirror image

reflect the scanlines in the vertical direction. The image will be mirrored upside-down.

-floodfill {+-}x{+-}y color
----------------------------

Floodfill the image with color at the specified offset.

Flood fill starts from the given 'seed point' which is not gravity affected. Any color that matches within [-fuzz] color distance of the given color argument, connected to that 'seed point' will be replaced with the current [-fill] color.

Note that if the pixel at the 'seed point' does not itself match the given color (according to [-fuzz]), then no action will be taken.

This operator works more like the [-opaque] option, than a more general flood fill that reads the matching color directly at the 'seed point'. For this form of flood fill, look at [-draw] and its 'color floodfill' drawing method.

-flop
------

Create a mirror image.

Reflect the scanlines in the horizontal direction, just like the image in a vertical mirror.

-font name
-----------

Set the font to use when annotating images with text, or creating labels.

To print a complete list of fonts, use the [-list font] option (for versions prior to 6.3.6, use 'type' instead of 'font').

In addition to the fonts specified by the above pre-defined list, you can also specify a font from a specific source. For example Arial.ttf is a TrueType font file, ps:helvetica is PostScript font, and x:fixed is X11 font.

For other settings that affect fonts, see the options [-family], [-stretch], [-style], and [-weight].

To specify an explicit font filename or collection, specify the font path preceded with a @, e.g., @arial.ttf. You can specify the font face index for font collections, e.g., @msgothic.ttc[1].

-foreground color
------------------

Define the foreground color for menus.", "display

The color is specified using the format described under the [-fill] option.

The default foreground color is black.

-format type
-------------

The image format type.

When used with the mogrify utility, this option converts any image to the image [format] you specify. For a list of image format types supported by ImageMagick, use [-list format].

By default the file is written to its original name. However, if the filename extension matches a supported format, the extension is replaced with the image format type specified with [-format]. For example, if you specify tiff as the format type and the input image filename is image.gif, the output image filename becomes image.tiff.

-format expression
-------------------

Output formatted image characteristics.

See [Format and Print Image Properties] for an explanation on how to specify the argument to this option.

-frame geometry
----------------

Surround the image with a border or beveled frame.

The color of the border is specified with the [-mattecolor] command line option.

See [Image Geometry] for complete details about the _geometry_ argument. The size portion of the geometry argument indicates the amount of extra width and height that is added to the dimensions of the image. If no offsets are given in the geometry argument, then the border added is a solid color. Offsets x and y, if present, specify that the width and height of the border is partitioned to form an outer bevel of thickness x pixels and an inner bevel of thickness y pixels. Negative offsets make no sense as frame arguments.

The [-frame] option is affected by the current [-compose] setting and assumes that this is using the default 'Over' composition method. It generates an image of the appropriate size with the current [-bordercolor] setting, and then draws the frame of four distinct colors close to the current [-mattecolor]. The original image is then overlaid onto center of this image. This means that with the default compose method of 'Over' any transparent parts may be replaced by the current [-bordercolor] setting.

The image composition is not affected by the [-gravity] option.

-frame
-------

Include the X window frame in the imported image.

-function function parameters
------------------------------

Apply a function to channel values.

This operator performs calculations based on the given arguments to modify each of the color values for each previously set [-channel] in the image. See [-evaluate] for details concerning how the results of the calculations are handled.

This is can be considered a multi-argument version of the [-evaluate] operator. (Added in ImageMagick 6.4.8−8.)

Here, parameters is a comma-separated list of numerical values. The number of values varies depending on which function is selected. Choose the function from:

    Polynomial
    Sinusoid
    Arcsin
    Arctan

To print a complete list of [-function] operators, use [-list function]. Descriptions follow.

*    Polynomial

    The Polynomial function takes an arbitrary number of parameters, these being the coefficients of a polynomial, in decreasing order of degree. That is, entering

        -function Polynomial an,an-1,...a1,a0

    will invoke a polynomial function given by

    an **u**n + an-1 **u**n-1 + ··· a1 **u** + a0,

    where **u** is pixel's original normalized channel value.

    The Polynomial function can be used in place of Set (the constant polynomial) and Add, Divide, Multiply, and Subtract (some linear polynomials) of the [-evaluate] operator. The [-level] operator also affects channels linearly. Some correspondences follow.

        -evaluate Set value
        -function Polynomial value
                  (Constant functions; set value×100% gray when channels are RGB.)
        -evaluate Add value
        -function Polynomial 1,value
        -evaluate Subtract value
        -function Polynomial 1,−value
        -evaluate Multiply value
        -function Polynomial value,0
        +level black% x white%
        -function Polynomial A,B
                 (Reduce contrast. Here, A=(white-black)/100 and B=black/100.)

    The Polynomial function gives great versatility, since polynomials can be used to fit any continuous curve to any degree of accuracy desired.

*    Sinusoid

    The Sinusoid function can be used to vary the channel values sinusoidally by setting frequency, phase shift, amplitude, and a bias. These values are given as one to four parameters, as follows,

    -function Sinusoid freq,[phase,[amp,[bias]]]

    where phase is in degrees. (The domain [0,1] of the function corresponds to 0 through freq×360 degrees.) The result is that if a pixel's normalized channel value is originally **u**, its resulting normalized value is given by

    amp * sin(2*π* (freq * **u** + phase / 360)) + bias

    For example, the following generates a curve that starts and ends at 0.9 (when **u**\=0 and 1, resp.), oscillating three times between .7−.2=.5 and .7+.2=.9.

    -function Sinusoid 3,-90,.2,.7

    The default values of amp and bias are both .5. The default for phase is 0.

    The Sinusoid function generalizes Sin and Cos of the [-evaluate] operator by allowing varying amplitude, phase and bias. The correspondence is as follows.

        -evaluate Sin freq      -function Sinusoid freq,0
        -evaluate Cos freq      -function Sinusoid freq,90

*    ArcSin

    The ArcSin function generates the inverse curve of a Sinusoid, and can be used to generate cylindrical distortion and displacement maps. The curve can be adjusted relative to both the input values and output range of values.

    -function ArcSin width,[center,[range,[bias]]]

    with all values given in terms of normalized color values (0.0 for black, 1.0 for white). Defaulting to values covering the full range from 0.0 to 1.0 for bout input (width), and output (width) values. '1.0,0.5,1.0,0.5'

    range/π * asin( 2/width * ( **u** - center ) ) + bias

*    ArcTan

    The ArcTan function generates a curve that smooth crosses from limit values at infinities, though a center using the given slope value. All these values can be adjusted via the arguments.

        -function ArcTan slope,[center,[range,[bias]]]

    Defaulting to '1.0,0.5,1.0,0.5'.

        range/π * atan( slope * π * ( u - center ) ) + bias

-fuzz distance{%}
------------------

Colors within this distance are considered equal.

A number of algorithms search for a target color. By default the color must be exact. Use this option to match colors that are close to the target color in RGB space. For example, if you want to automagically trim the edges of an image with [-trim] but the image was scanned and the target background color may differ by a small amount. This option can account for these differences.

The distance can be in absolute intensity units or, by appending % as a percentage of the maximum possible intensity (255, 65535, or 4294967295).

Use [+fuzz] to reset the fuzz value to 0.

-fx expression
---------------

Apply a mathematical expression to an image or image channels.

If the first character of expression is @, the expression is read from a file titled by the remaining characters in the string.

See [FX, The Special Effects Image Operator] for a detailed discussion of this option.

-gamma value
-------------

Level of gamma correction.

The same color image displayed on two different workstations may look different due to differences in the display monitor. Use gamma correction to adjust for this color difference. Reasonable values extend from 0.8 to 2.3. Gamma less than 1.0 darkens the image and gamma greater than 1.0 lightens it. Large adjustments to image gamma may result in the loss of some image information if the pixel quantum size is only eight bits (quantum range 0 to 255).

Gamma adjusts the image's channel values pixel-by-pixel according to a power law, namely, pow(pixel,1/gamma) or pixel^(1/gamma), where pixel is the normalized or 0 to 1 color value. For example, using a value of gamma=2 is the same as taking the square root of the image.

Use [+gamma value] to set the image gamma level without actually adjusting the image pixels. This option is useful if the image is of a known gamma but not set as an image attribute (e.g. PNG images). Write the "file gamma" which is the reciprocal of the display gamma; e.g., if your image is sRGB and you want to write a PNG gAMA chunk, use

magick input.png +gamma .45455 output.png

(0.45455 is 1/2.2)

Note that gamma adjustments are also available via the [-level] operator.

-gaussian-blur radius  
-gaussian-blur radius{xsigma}
-------------------------------------------------------

Blur the image with a Gaussian operator.

Convolve the image with a Gaussian or normal distribution using the given Sigma value. The formula is:

![gaussian distribution](https://imagemagick.org/image/gaussian-blur.png)

The sigma value is the important argument, and determines the actual amount of blurring that will take place.

The radius is only used to determine the size of the array which will hold the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

The larger the Radius the radius the slower the operation is. However too small a Radius, and severe aliasing effects may result. As a guideline, Radius should be at least twice the Sigma value, though three times will produce a more accurate result.

This differs from the faster [-blur] operator in that a full 2-dimensional convolution is used to generate the weighted average of the neighboring pixels.

The [-virtual-pixel] setting will determine how pixels which are outside the image proper are blurred into the final result.

-geometry geometry
-------------------

Set the preferred size and location of the image.

See [Image Geometry] for complete details about the _geometry_ argument.

-gravity type
--------------

Sets the current gravity suggestion for various other settings and options.

Choices include: NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast. Use [-list gravity] to get a complete list of [-gravity] settings available in your ImageMagick installation.

The direction you choose specifies where to position text or subimages. For example, a gravity of Center forces the text to be centered within the image. By default, the image gravity is undefined. See [-draw] for more details about graphic primitives. Only the text primitive of [-draw] is affected by the [-gravity] option.

The [-gravity] option is also used in concert with the [-geometry] setting and other settings or options that take geometry as an argument, such as the [-crop] option.

If a [-gravity] setting occurs before another option or setting having a geometry argument that specifies an offset, the offset is usually applied to the point within the image suggested by the [-gravity] argument. Thus, in the following command, for example, suppose the file image.png has dimensions 200x100. The offset specified by the argument to [-region] is (−40,+20). The argument to [-gravity] is Center, which suggests the midpoint of the image, at the point (100,50). The offset (−40,20) is applied to that point, giving (100−40,50+20)=(60,70), so the specified 10x10 region is located at that point. (In addition, the [-gravity] affects the region itself, which is centered at the pixel coordinate (60,70). (See [Image Geometry] for complete details about the _geometry_ argument.)

magick image.png -gravity Center -region 10x10-40+20 \
  -negate output.png

When used as an option to [composite], [-gravity] gives the direction that the image gravitates within the composite.

When used as an option to [montage], [-gravity] gives the direction that an image gravitates within a tile. The default gravity is Center for this purpose.

Use [+gravity] to return gravity to its default value.

-grayscale method
------------------

Convert image to grayscale.

This will use one of the [-intensity] methods to convert the given image into a grayscale image.

For example, to convert an image to (linear) Rec709Luminance grayscale, type:

magick in.png -grayscale Rec709Luminance out.png

which is equivalent to:

magick in.png -colorspace LinearGray out.png

Similarly, to convert an image to (non-linear) Rec709Luma grayscale, type:

magick in.png -grayscale Rec709Luma out.png

which is equivalent to:

magick in.png -colorspace Gray out.png

Note that a 'colorspace' intensity method will produce the same result regardless of the current colorpsace of the image. But a 'mathematical' intensity method depends on the current colorspace the image is currently using.

While this operation uses an [-intensity] method, it does not use or set the [-intensity] setting, so will not affect other operations that may use that setting.

-green-primary x,y
-------------------

Green chromaticity primary point.

-hald-clut
-----------

Apply a Hald color lookup table to the image.

A Hald color lookup table is a 3-dimensional color cube mapped to 2 dimensions. Create it with the HALD: prefix (e.g. HALD:8). You can apply any color transformation to the Hald image and then use this option to apply the transform to the image.

magick image.png hald.png -hald-clut transform.png

This option provides a convenient method for you to use Gimp or Photoshop to make color corrections to the Hald CLUT image and subsequently apply them to multiple images using an ImageMagick script.

Note that the representation is only of the normal RGB color space and that the whole color value triplet is used for the interpolated lookup of the represented Hald color cube image. Because of this the operation is not [-channel] setting affected, nor can it adjust or modify an images transparency or alpha/matte channel.

See also [-clut] which provides color value replacement of the individual color channels, usually involving a simpler grayscale image. E.g: grayscale to color replacement, or modification by a histogram mapping.

-help
------

Print usage instructions.

-highlight-color color
-----------------------

When comparing images, emphasize pixel differences with this color.

-hough-lines widthxheight{+threshold}
--------------------------------------

Identify straight lines in the image (e.g. -hough-lines 9x9+195).

Use the Hough line detector with any binary edge extracted image to locate and draw any straight lines that it finds.

The process accumulates counts for every white pixel in the binary edge image for every possible orientation (for angles from 0 to 179 in 1 deg increments) and distance from the center of the image to the corners (in 1 px increments). It stores the counts in an accumulator matrix of angle vs distance. The size of the accumulator will be 180x(diagonal/2). Next it searches the accumulator for peaks in counts and converts the locations of the peaks to slope and intercept in the normal x,y input image space. The algorithm uses slope/intercepts to find the endpoints clipped to the bounds of the image. The lines are drawn from the given endpoints. The counts are a measure of the length of the lines.

.

The WxH arguments specify the filter size for locating the peaks in the Hough accumulator. The threshold excludes lines whose counts are less than the threshold value.

Use [-background] to specify the color of the background onto which the lines will be drawn. The default is black.

Use [-fill] to specify the color of the lines. The default is black.

Use [-stroke] and [-strokewidth] to specify the thickness of the lines. The default is black and no strokewidth.

A text file listing the endpoints and counts may be created by using the suffix, .mvg, for the output image.

Use [-define] hough-lines:accumulator=true to return the accumulator image in addition to the lines image.

-iconGeometry geometry
-----------------------

Specify the icon geometry.

Offsets, if present in the geometry specification, are handled in the same manner as the [-geometry] option, using X11 style to handle negative offsets.

See [Image Geometry] for complete details about the _geometry_ argument.

-iconic
--------

Start in icon mode in X Windows", 'animate', 'display

-identify
----------

Identify the format and characteristics of the image.

This information is printed: image scene number; image name; image size; the image class (DirectClass or PseudoClass); the total number of unique colors; and the number of seconds to read and transform the image. Refer to [MIFF] for a description of the image class.

If [-colors] is also specified, the total unique colors in the image and color reduction error values are printed. Refer to [color reduction algorithm] for a description of these values.

If [-verbose] precedes this option, copious amounts of image properties are displayed including image statistics, profiles, image histogram, and others.

-ift
-----

Implements the inverse discrete Fourier transform (DFT).

This option is new as of ImageMagick 6.5.4-3 (and now working for Windows users in ImageMagick 6.6.0-9). It transforms a pair of magnitude and phase images from the frequency domain to a single image in the normal or spatial domain. See for example, [Fourier Transform](http://en.wikipedia.org/wiki/Fourier_transform), [Discrete Fourier Transform](http://en.wikipedia.org/wiki/DFT) and [Fast Fourier Transform](http://en.wikipedia.org/wiki/FFT).

For example, depending upon the image format used to store the result of the [-fft], one would use either

magick fft_image.miff -ift fft_image_ift.png

or

magick fft_image-0.png fft_image-1.png -ift fft_image_ift.png

The resulting image may need to be cropped due to padding introduced when the original image, prior to the [-fft] or [+fft], was not square or even dimensioned. Any padding is at the right and/or bottom sides of the image.

The [FFTW](http://www.fftw.org/) delegate library is required to use [-ift].

Use [+ift] (with HDRI enabled) to transform a pair of real and imaginary images from the frequency domain to a single image in the normal (spatial) domain.

By default the IFT is not normalized (and the FFT is). Use "[-define] fourier:normalize=inverse to explicitly normalize the IFT and unnormalize the FFT.

-illuminant method
-------------------

reference illuminant. Choose from A, B, C, D50, D55, D65, E, F2, F7, or F11.

-immutable
-----------

Make image immutable.

-implode factor
----------------

Implode image pixels about the center.

-insert index
--------------

Insert the last image into the image sequence.

This option takes last image in the current image sequence and inserts it at the given index. If a negative index is used, the insert position is calculated before the last image is removed from the sequence. As such -insert -1 will result in no change to the image sequence.

The +insert option is equivalent to -insert -1. In other words, insert the last image, at the end of the current image sequence. Consequently this has no effect on the image sequence order.

-intensity method
------------------

Method to generate intensity value from pixel.

ImageMagick provides a number of methods used in situations where an operator needs to determine a single grayscale value for some purpose, from an image with red, green, and blue pixel components. Typically the Rec709Luma formula is used, which is the same formula used when converting images to -colorspace gray.

The following formulas are currently provided, and will first convert the pixel values to linear-RGB or non-linear sRGB colorspace before being applied to calculate the final greyscale value.

    Rec601Luma       0.298839R' + 0.586811G'+ 0.114350B'
    Rec601Luminance  0.298839R + 0.586811G + 0.114350B
    Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
    Rec709Luminance  0.212656R + 0.715158G + 0.072186B
    Brightness       max(R', G', B')
    Lightness        (min(R', G', B') + max(R', G', B')) / 2.0

Note that the above R,G,B values is the image's linear-RGB values, while R',G',B' are sRGB non-linear values.

These intensity methods are mathematical in nature and will use the current value in the images respective R,G,B channel regardless of what that is, or what colorspace the image is currently using.

    Average     (R' + G' + B') / 3.0
    MS          (R'^2 + G'^2 + B'^2) / 3.0
    RMS         sqrt( (R'^2 + G'^2 + B'^2) / 3.0 )

These methods are often used for other purposes, such as generating a grayscale difference image between two color images (using [-compose] 'Difference' composition.

For example The 'MS' (Mean Squared) setting is good for minimizing color error comparisions. While... The method 'RMS' (Root Mean Squared) for example is appropriate for calculating color vector distance, from a color difference image. This is equivalent to the color only component of the [-fuzz] factor color compare setting.

See also [-grayscale] which applies one of the above grayscaling formula directly to an image without setting the [-intensity] setting.

The [-colorspace gray] image conversion also uses the current intensity setting, but will always convert the image to the appropriate sRGB or linear-RGB colorspace before appling the above function.

To print a complete list of possible pixel intensity setting methods, use [-list intensity].

Operators affected by the [-intensity] setting include:

    -adaptive-blur
    -adaptive-sharpen
    -black-threshold
    -clut (when mapping greyscale CLUT image to alpha channel if set by -channels)
    -colors for gray colorspace
    -compose {LightenIntensity, DarkenIntensity, CopyOpacity, CopyBlack}
    -contrast-stretch
    -distort {ErodeIntensity, DilateIntensity}
    -normalize
    -random-threshold
    -range-threshold
    -selective-blur
    -shade
    -threshold
    -tint
    -white-threshold

-intent type
-------------

Use this type of rendering intent when managing the image color.

Use this option to affect the color management operation of an image (see [-profile]). Choose from these intents: Absolute, Perceptual, Relative, Saturation.

The default intent is Perceptual for the sRGB colorspace and undefined for the RGB and gray colorspaces.

To print a complete list of rendering intents, use [-list intent].

-interlace type
----------------

The type of interlacing scheme.

Choose from:

none
line
plane
partition
JPEG
GIF
PNG

This option is used to specify the type of interlacing scheme for raw image formats such as RGB or YUV.

None means do not interlace (RGBRGBRGBRGBRGBRGB...),

Line uses scanline interlacing (RRR...GGG...BBB...RRR...GGG...BBB...), and.

Plane uses plane interlacing (RRRRRR...GGGGGG...BBBBBB...).

Partition is like plane except the different planes are saved to individual files (e.g. image.R, image.G, and image.B).

Use Line or Plane to create an interlaced PNG or GIF or progressive JPEG image.

To print a complete list of interlacing schemes, use [-list interlace].

-interline-spacing value
-------------------------

The space between two text lines.

-interpolate type
------------------

Set the pixel color interpolation method to use when looking up a color based on a floating point or real value.

When looking up the color of a pixel using a non-integer floating point value, you typically fall in between the pixel colors defined by the source image. This setting determines how the color is determined from the colors of the pixels surrounding that point. That is how to determine the color of a point that falls between two, or even four different colored pixels.

average

The average color of the surrounding four pixels

average4

The average color of the surrounding four pixels

average9

The average color of the surrounding nine pixels

average16

The average color of the surrounding sixteen pixels

background

bilinear

A double linear interpolation of pixels (the default)

blend

catrom

Fitted bicubic-spines of surrounding 16 pixels

integer

The color of the top-left pixel (floor function)

mesh

Divide area into two flat triangular interpolations

nearest-neighbor

The nearest pixel to the lookup point (rounded function)

spline

Direct spline curves (colors are blurred)

This most important for distortion operators such as [-distort], [-implode], [-transform] and [-fx].

To print a complete list of interpolation methods, use [-list interpolate].

See also [-virtual-pixel], for control of the lookup for positions outside the boundaries of the image.

-interpolative-resize geometry
-------------------------------

Resize with interpolation. See the [-interpolate] setting.

-interword-spacing value
-------------------------

The space between two words.

-integral
----------

Calculate the sum of values (pixel values) in the image.

-kerning value
---------------

The space between two letters.

-kmeans colors{xiterations}{+tolerance}
----------------------------------------

Kmeans (iterative) color reduction (e.g. -kmeans 5x300+0.0001). Colors is the desired number of colors. Initial colors are found using color quantization. Iterations is the stopping number of iterations (default=300). Convergence is the stopping threshold on the color change between iterations (default=0.0001). Processing finishes, if either iterations or tolerance are reached. Use -define kmeans:seed-colors=color-list to initialize the colors, where color-list is a semicolon delimited list of seed colors (e.g. -define kmeans:seed-colors="red;sRGB(19,167,254);#00ffff). A color list overrides the color quantization. A non-empty list of colors overrides the number of colors. Any unassigned initial colors are assigned random colors from the image.

-kuwahara radius  
-kuwahara radius{xsigma}
---------------------------------------------

Edge preserving noise reduction filter.

The radius is more important than the sigma. If sigma is left off, it will be computed automatically from the radius as sigma\=radius-0.5. The sigma provides a bit of additional smoothing control.

-label name
------------

Assign a label to an image.

Use this option to assign a specific label to the image, as it is read in or created. You can use the [-set] operation to re-assign a the labels of images already read in. Image formats such as TIFF, PNG, MIFF, supports saving the label information with the image.

When saving an image to a PostScript file, any label assigned to an image is used as a header string to print above the postscript image.

You can include the image filename, type, width, height, or other image attribute by embedding special format character. See [Format and Print Image Properties] for details of the percent escape codes.

For example,

-label "%m:%f %wx%h"  bird.miff

assigns an image label of MIFF:bird.miff 512x480 to the "bird.miff" image and whose width is 512 and height is 480, as it is read in. If a [+label] option was used instead, any existing label present in the image would be used. You can remove all labels from an image by assigning the empty string.

A label is not drawn on the image, but is embedded in the image datastream via Label tag or similar mechanism. If you want the label to be visible on the image itself, use the [-draw] option, or during the final processing in the creation of an image montage.

If the first character of string is @, the image label is read from a file titled by the remaining characters in the string. Labels in a file are literal, no embedded formatting characters are recognized.

-lat width  
-lat widthxheight{+-}offset{%}
---------------------------------------------

Perform local adaptive threshold.

Adaptively threshold each pixel based on the value of pixels in a surrounding window. If the current pixel is lighter than this average plus the optional offset, then it is made white, otherwise it is made black. Small variations in pixel values such as found in scanned documents can be ignored if offset is positive. A negative offset will make it more sensitive to those small variations.

This is commonly used to threshold images with an uneven background. It is based on the assumption that average color of the small window is the the local background color, from which to separate the foreground color.

-layers method
---------------

Handle multiple images forming a set of image layers or animation frames.

Perform various image operation methods to a ordered sequence of images which may represent either a set of overlaid 'image layers', a GIF disposal animation, or a fully-'coalesced' animation sequence.

Method

Description

*   `  compare-any  `

    Crop the second and later frames to the smallest rectangle that contains all the differences between the two images. No GIF [-dispose] methods are taken into account.

    This exactly the same as the [-deconstruct] operator, and does not preserve animations normal working, especially when animation used layer disposal methods such as 'Previous' or 'Background'.

*   `  compare-clear  `

    As 'compare-any' but crop to the bounds of any opaque pixels which become transparent in the second frame. That is the smallest image needed to mask or erase pixels for the next frame.

*   `  compare-overlay  `

    As 'compare-any' but crop to pixels that add extra color to the next image, as a result of overlaying color pixels. That is the smallest single overlaid image to add or change colors.

    This can be used with the [-compose] alpha composition method 'change-mask', to reduce the image to just the pixels that need to be overlaid.

*   `  coalesce  `

    Equivalent to a call to the [-coalesce] operator. Apply the layer disposal methods set in the current image sequence to form a fully defined animation sequence, as it should be displayed. Effectively converting a GIF animation into a 'film strip'-like animation.

*   `  composite  `

    Alpha Composition of two image lists, separated by a "null:" image, with the destination image list first, and the source images last. An image from each list are composited together until one list is finished. The separator image and source image lists are removed.

    The [-geometry] offset is adjusted according to [-gravity] in accordance of the virtual canvas size of the first image in each list. Unlike a normal [-composite] operation, the canvas offset is also added to the final composite positioning of each image. If one of the image lists only contains one image, that image is applied to all the images in the other image list, regardless of which list it is. In this case it is the image meta-data of the list which preserved. 

*   `  dispose  `

    This like 'coalesce' but shows the look of the animation after the layer disposal method has been applied, before the next sub-frame image is overlaid. That is the 'dispose' image that results from the application of the GIF [-dispose] method. This allows you to check what is going wrong with a particular animation you may be developing. 

*   `  flatten  `

    Create a canvas the size of the first images virtual canvas using the current [-background] color, and [-compose] each image in turn onto that canvas. Images falling outside that canvas is clipped. Final image will have a zero virtual canvas offset. 

    This usually used as one of the final 'image layering' operations overlaying all the prepared image layers into a final image.

    For a single image this method can also be used to fillout a virtual canvas with real pixels, or to underlay an opaque color to remove transparency from an image.

*   `  merge  `

    As 'flatten' method but merging all the given image layers to create a new layer image just large enough to hold all the image without clipping or extra space. The new images virtual offset will preserve the position of the new layer, even if this offset is negative. The virtual canvas size of the first image is preserved.

    Caution is advised when handling image layers with negative offsets as few image file formats handle them correctly. Following this operation method with [+repage] will remove the layer offset, and create an image in which all the overlaid image positions relative to each other is preserved, though not necessarily exactly where you specified them.

    See also 'trim-bounds' below which is closely related but without doing the'flatten' to merge the images together.

*   `  mosaic  `

    As 'flatten' method but expanding the initial canvas size of the first image in a positive direction only so as to hold all the image layers. However as a virtual canvas is 'locked' to the origin, by its own definition, image layers with a negative offsets will still become clipped by the top and left edges. See 'merge' or 'trim-bounds' if this could be a problem. This method is commonly used to layout individual image using various offset but without knowing the final canvas size. The resulting image will, like 'flatten' not have any virtual offset, so can be saved to any image file format. optimize Optimize a coalesced animation, into GIF animation using a number of general techniques. This currently a short cut to apply both the 'optimize-frame', and 'optimize-transparency' methods but may be expanded to include other optimization methods as they are developed.

*   `  optimize-frame  `

    Optimize a coalesced animation, into GIF animation by reducing the number of pixels per frame as much as possible by attempting to pick the best layer disposal method to use, while ensuring the result will continue to animate properly.

    There is no guarantee that the best optimization is found. But then no reasonably fast GIF optimization algorithm can do this. However this does seem to do better than most other GIF frame optimizers seen.

*   `  optimize-plus  `

    As 'optimize-frame' but attempt to improve the overall optimization by adding extra frames to the animation, without changing the final look or timing of the animation. The frames are added to attempt to separate the clearing of pixels from the overlaying of new additional pixels from one animation frame to the next. If this does not improve the optimization (for the next frame only), it will fall back to the results of the previous normal 'optimize-frame' technique.

    There is the possibility that the change in the disposal style will result in a worsening in the optimization of later frames, though this is unlikely. In other words there no guarantee that it is better than the normal 'optimize-frame' technique. For some animations however you can get a vast improvement in the final animation size.

*   `  optimize-transparency  `

    Given a GIF animation, replace any pixel in the sub-frame overlay images with transparency, if it does not change the resulting animation by more than the current [-fuzz] factor. This should allow a existing frame optimized GIF animation to compress into a smaller file size due to larger areas of one (transparent) color rather than a pattern of multiple colors repeating the current disposed image of the last frame.

*   `  remove-dups  `

    Remove (and merge time delays) of duplicate consecutive images, so as to simplify layer overlays of coalesced animations. Usually this a result of using a constant time delay across the whole animation, or after a larger animation was split into smaller sub-animations. The duplicate frames could also have been used as part of some frame optimization methods. remove-zero Remove any image with a zero time delay, unless ALL the images have a zero time delay (and is not a proper timed animation, a warning is then issued). In a GIF animation, such images are usually frames which provide partial intermediary updates between the frames that are actually displayed to users. These frames are usually added for improved frame optimization in GIF animations.

*   `  trim-bounds  `

    Find the bounds of all the images in the current image sequence, then adjust the offsets so all images are contained on a minimal positive canvas. None of the image data is modified or merged, only the individual image virtual canvas size and offset. All the images is given the same canvas size, and will have a positive offset, but will remain in the same position relative to each other. As a result of the minimal canvas size at least one image will touch every edge of that canvas. The image data touching those edges however may be transparent. The result is much like if you used 'merge' followed by a [+repage] option, except that all the images have been kept separate. If 'flatten' is used after using 'trim-bounds' you will get the same result.

To print a complete list of layer types, use [-list layers].

The operators [-coalesce], [-deconstruct], [-flatten], and [-mosaic] are only aliases for the above methods and may be deprecated in the future. Also see [-page], [-repage] operators, the [-compose] setting, and the GIF [-dispose] and [-delay] settings.

-level black_point{,white_point}{%}{,gamma}
----------------------------------------------

Adjust the level of image channels.

Given one, two or three values delimited with commas: black-point, white-point, gamma (for example: 10,250,1.0 or 2%,98%,0.5). The black and white points range from 0 to QuantumRange, or from 0 to 100%; if the white point is omitted it is set to (QuantumRange - black_point), so as to center contrast changes. If a % sign is present anywhere in the string, both black and white points are percentages of the full color range. Gamma will do a [-gamma] adjustment of the values. If it is omitted, the default of 1.0 (no gamma correction) is assumed.

In normal usage (-level) the image values are stretched so that the given 'black_point' value in the original image is set to zero (or black), while the given 'white_point' value is set to QuantumRange (or white). This provides you with direct contrast adjustments to the image. The 'gamma' of the resulting image will then be adjusted.

From ImageMagick v6.4.1-9 using the plus form of the operator (+level) or adding the special '!' flag anywhere in the argument list, will cause the operator to do the reverse of the level adjustment. That is a zero, or QuantumRange value (black, and white, resp.) in the original image, is adjusted to the given level values, allowing you to de-contrast, or compress the channel values within the image. The 'gamma' is adjusted before the level adjustment to de-contrast the image is made.

Only the channels defined by the current [-channel] setting are adjusted (defaults to RGB color channels only), allowing you to limit the effect of this operator.

Please note that the transparency channel is treated as 'matte' values (0 is opaque) and not as 'alpha' values (0 is transparent).

-level-colors {black_color}{,}{white_color}
----------------------------------------------

Adjust the level of an image using the provided dash separated colors.

This function is exactly like [-level], except that the value for each color channel is determined by the 'black_color' and 'white_color' colors given (as described under the [-fill] option).

This effectively means the colors provided to -level-colors is mapped to become 'black' and 'white' respectively, with all the other colors linearly adjusted (or clipped) to match that change. Each channel is adjusted separately using the channel values of the colors specified.

On the other hand the plus form of the operator (+level-colors) will map the image color 'black' and 'white' to the given colors respectively, resulting in a gradient (de-contrasting) tint of the image to those colors. This can also be used to convert a plain grayscale image into a one using the gradient of colors specified.

By supplying a single color with a comma separator either before or after that color, will just replace the respective 'black' or 'white' point respectively. But if no comma separator is provided, the given color is used for both the black and white color points, making the operator either threshold the images around that color (- form) or set all colors to that color (+ form).

-limit type value
------------------

Set the pixel cache resource limit.

Choose from: width, height, area, memory, map, disk, file, thread, throttle, or time.

The value for file is in number of files. The other limits are in bytes. Define arguments for the memory, map, area, and disk resource limits with SI prefixes (.e.g 100MB).

By default the limits are 768 files, 3GB of image area, 1.5GiB memory, 3GiB memory map, and 18.45EB of disk. These limits are adjusted relative to the available resources on your computer if this information is available. When any limit is reached, ImageMagick fails in some fashion but attempts to take compensating actions, if possible. For example, the following limits memory:

    -limit memory 32MiB -limit map 64MiB

Use [-list resource] to list the current limits. For example, our system shows these limits:

    -> identify -list resource
    Resource limits:
      Width: 100MP
      Height: 100MP
      Area: 25.181GB
      Memory: 11.726GiB
      Map: 23.452GiB
      Disk: unlimited
      File: 768
      Thread: 12
      Throttle: 0
      Time: unlimited

Requests for pixel storage to keep intermediate images are satisfied by one of three resource categories: in-memory pool, memory-mapped files pool, and disk pool (in that order) depending on the [-limit] settings and whether the system honors a resource request. If the total size of allocated pixel storage in the given pool reaches the corresponding limit, the request is passed to the next pool. Additionally, requests that exceed the area limit automagically are allocated on disk.

To illustrate how ImageMagick utilizes resource limits, consider a typical image resource request. First, ImageMagick tries to allocate the pixels in memory. The request might be denied if the resource request exceeds the memory limit or if the system does not honor the request. If a memory request is not honored, the pixels are allocated to disk and the file is memory-mapped. However, if the allocation request exceeds the map limit, the resource allocation goes to disk. In all cases, if the resource request exceeds the area limit, the pixels are automagically cached to disk. If the disk has a hard limit, the program fails.

In most cases you simply do not need to concern yourself with resource limits. ImageMagick chooses reasonable defaults and most images do not tax your computer resources. Where limits do come in handy is when you process images that are large or on shared systems where ImageMagick can consume all or most of the available memory. In this case, the ImageMagick workflow slows other processes or, in extreme cases, brings the system to a halt. Under these circumstances, setting limits give some assurances that the ImageMagick workflow will not interfere with other concurrent uses of the computer. For example, assume you have a web interface that processes images uploaded from the Internet. To assure ImageMagick does not exceed 10MiB of memory you can simply set the area limit to 10MiB:

-limit area 10MB

Now whenever a large image is processed, the pixels are automagically cached to disk instead of memory. This of course implies that large images typically process very slowly, simply because pixel processing in memory can be an order of magnitude faster than on disk. Because your web site users might inadvertently upload a huge image to process, you should set a disk limit as well:

-limit area 10MB -limit disk 500MB

Here ImageMagick stops processing if an image requires more than 500MB of disk storage.

In addition to command-line resource limit option, resources can be set with [environment variables]. Set the environment variables MAGICK_AREA_LIMIT, MAGICK_DISK_LIMIT, MAGICK_FILE_LIMIT, MAGICK_MEMORY_LIMIT, MAGICK_MAP_LIMIT, MAGICK_THREAD_LIMIT, MAGICK_TIME_LIMIT for limits of image area, disk space, open files, heap memory, memory map, number of threads of execution, and maximum elapsed time in seconds respectively.

Note, you can restrict limits relative to any [security policies], but you cannot relax them.

Inquisitive users can try adding [-debug cache] to their commands and then scouring the generated output for references to the pixel cache, in order to determine how the pixel cache was allocated and how resources were consumed. Advanced Linux/Linux users can pipe that output through grep memory|open|destroy|disk for more readable sifting.

For more about ImageMagick's use of resources, see the section **Cache Storage and Resource Requirements** on the [Architecture] page.

-linear-stretch black-point  
-linear-stretch black-point{xwhite-point}{%}
----------------------------------------------------------------------------

Linear with saturation stretch.

This is very similar to [-contrast-stretch], and uses a 'histogram bin' to determine the range of color values that needs to be stretched. However it then stretches those colors using the [-level] operator.

As such while the initial determination may have 'binning' round off effects, the image colors are stretched mathematically, rather than using the histogram bins. This makes the operator more accurate.

note however that a [-linear-stretch] of '0' does nothing, while a value of '1' does a near perfect stretch of the color range.

See also [-auto-level] for a 'perfect' normalization of mathematical images.

This operator is under review for re-development.

-linewidth
-----------

The line width for subsequent draw operations.

-liquid-rescale geometry
-------------------------

Rescale image with seam-carving.

See [Image Geometry] for complete details about the _geometry_ argument.

-list type
-----------

Print a list of supported arguments for various options or settings. Choose from these list types:


    Align            Dispose             Locale              SparseColor
    Alpha            Distort             LogEvent            Statistic
    Boolean          Dither              Log                 Storage
    Cache            Endian              Magic               Stretch
    Channel          Evaluate            Method              Style
    Class            FillRule            Metric              Threshold
    ClipPath         Filter              Mime                Type
    Coder            Font                Mode                Units
    Color            Format              Morphology          Validate
    Colorspace       Function            Module              VirtualPixel
    Command          Gravity             Noise          
    Complex          Intensity           Orientation    
    Compose          Intent              PixelIntensity 
    Compress         Interlace           Policy         
    Configure        Interpolate         PolicyDomain   
    DataType         Kernel              PolicyRights   
    Debug            Layers              Preview        
    Decoration       LineCap             Primitive      
    Delegate         LineJoin            QuantumFormat  
    Direction        List                Resource       


These lists vary depending on your version of ImageMagick. Use "-list list" to get a complete listing of all the "-list" arguments available:

magick identify -list list

-log string
------------

Specify format for debug log.

This option specifies the format for the log printed when the [-debug] option is active.

You can display the following components by embedding special format characters:

    %d      domain
    %e      event
    %f      function
    %l      line
    %m      module
    %p      process ID
    %r      real CPU time
    %t      wall clock time
    %u      user CPU time
    %%      percent sign
    \n      newline
    \r      carriage return

For example:

magick -debug coder -log "%u %m:%l %e" in.gif out.png

The default behavior is to print all of the components.

-loop iterations
-----------------

Add Netscape loop extension to your GIF animation.

Set iterations to zero to repeat the animation an infinite number of times, otherwise the animation repeats itself up to iterations times.

-lowlight-color color
----------------------

When comparing images, de-emphasize pixel differences with this color.

-magnify
---------

Double or triple the size of the image with pixel art scaling. Specify an alternative scaling method with -define magnify:method=method Choose from these methods: eagle2X, eagle3X, eagle3XB, epb2X, fish2X, hq2X, scale2X, scale3X, xbr2X. The default is scale2X.

-map type
----------

Display image using this type.

Choose from these Standard Colormap types:

    best default gray red green blue

The X server must support the Standard Colormap you choose, otherwise an error occurs. Use list as the type and display searches the list of colormap types in top-to-bottom order until one is located. See xstdcmap(1) for one way of creating Standard Colormaps.

-map components
----------------

Pixel map.

Here are the valid components of a map:

    r       red pixel component
    g       green pixel component
    b       blue pixel component
    a       alpha pixel component (0 is transparent)
    o       opacity pixel component (0 is opaque)
    i       grayscale intensity pixel component
    c       cyan pixel component
    m       magenta pixel component
    y       yellow pixel component
    k       black pixel component
    p       pad component (always 0)

You can specify as many of these components as needed in any order (e.g. bgr). The components can repeat as well (e.g. rgbr).

-mattecolor color
------------------

Specify the color to be used with the [-frame] option.

The color is specified using the format described under the [-fill] option.

The default matte color is #BDBDBD, this shade of gray.

-maximum
---------

Return the maximum intensity of an image sequence.

Select the 'maximum' value from all the surrounding pixels.

This is legacy option from the [method] of the same name.

-median geometry
-----------------

Apply a median filter to the image.

Select the 'middle' value from all the surrounding pixels.

This is legacy option from the [method] of the same name.

-mean-shift widthxheight{+distance{%}
--------------------------------------

Image noise removal and color reduction/segmentation (e.g. -mean-shift 7x7+10%).

widthxheight is the window size and distance is the color distance measured in the range 0 to 1 or 0 to 100%

The mean shift algorithm is iterative and thus slower the larger the window size. For each pixel, it gets all the pixels in the window centered at the pixel and excludes those that are outside the radius=sqrt((width-1)(height-1)/4) surrounding the pixel. From those pixels, it finds which of them are within the specified squared color distance from the current mean. It then computes a new x,y centroid from those coordinates and a new mean. This new x,y centroid is used as the center for a new window. This process is iterated until it converges and the final mean is then used to replace the original pixel value. It repeats this process for the next pixel, etc, until it processes all pixels in the image. Results are better when using other colorspaces rather than RGB. Recommend YIQ, YUV or YCbCr, which seem to give equivalent results.

-metric type
-------------

Output to STDERR a measure of the differences between images according to the type given metric.

Choose from:

    AE          absolute error count, number of different pixels (-fuzz affected)
    DSSIM       structural dissimilarity index
    FUZZ        mean color distance
    MAE         mean absolute error (normalized), average channel error distance
    MEPP        mean error per pixel (normalized mean error, normalized peak error)
    MSE         mean error squared, average of the channel error squared
    NCC         normalized cross correlation
    PAE         peak absolute (normalized peak absolute)
    PHASH       perceptual hash for the sRGB and HCLp colorspaces. 
                Specify an alternative colorspace with -define phash:colorspaces=colorspace,colorspace,...
    PSNR        peak signal to noise ratio
    RMSE        root mean squared (normalized root mean squared)
    SSIM        structural similarity index

Control the 'AE', or absolute count of pixels that are different, with the [-fuzz] factor (ignore pixels which only changed by a small amount). Use 'PAE' to find the size of the [-fuzz] factor needed to make all pixels 'similar', while 'MAE' determines the factor needed for about half the pixels to be similar.

The MEPP metric returns three different metrics ('MAE', 'MAE' normalized, and 'PAE' normalized) from a single comparison run.

The SSIM and DSSIM metrics respect these defines: -define compare:ssim-radius, -define compare:ssim-sigma, -define compare:ssim-k1, and -define compare:ssim-k2.

To print a complete list of metrics, use the [-list metric] option.

-minimum
---------

Return the minimum intensity of an image sequence.

Select the 'minimal' value from all the surrounding pixels.

This is legacy option from the [method] of the same name.

-mode geometry
---------------

Make each pixel the 'predominant color' of the neighborhood.'

-mode value
------------

Mode of operation.

Choose the value from these styles: Frame, Unframe, or Concatenate

Use the [-list] option with a 'Mode' argument for a list of [-mode] arguments available in your ImageMagick installation.

-modulate brightness[,saturation,hue]
----------------------------------------

Vary the brightness, saturation, and hue of an image.

The arguments are given as a percentages of variation. A value of 100 means no change, and any missing values are taken to mean 100.

The brightness is a multiplier of the overall brightness of the image, so 0 means pure black, 50 is half as bright, 200 is twice as bright. To invert its meaning [-negate] the image before and after.

The saturation controls the amount of color in an image. For example, 0 produce a grayscale image, while a large value such as 200 produce a very colorful, 'cartoonish' color.

The hue argument causes a "rotation" of the colors within the image by the amount specified. For example, 50 results in a counter-clockwise rotation of 90, mapping red shades to purple, and so on. A value of either 0 or 200 results in a complete 180 degree rotation of the image. Using a value of 300 is a 360 degree rotation resulting in no change to the original image.

For example, to increase the color brightness by 20% and decrease the color saturation by 10% and leave the hue unchanged, use [-modulate 120,90].

Use [-set] attribute of 'option:modulate:colorspace' to specify which colorspace to modulate. Choose from HCL, HCLp, HSB, HSI, HSL (the default), HSV, HWB, or LCH (LCHab). For example,

magick image.png -set option:modulate:colorspace hsb -modulate 120,90 modulate.png

-moments
---------

Report image moments and perceptual hash.

-monitor
---------

Monitor progress.

-monochrome
------------

Transform the image to black and white.

-morph frames
--------------

Morphs an image sequence.

Both the image pixels and size are linearly interpolated to give the appearance of a metamorphosis from one image to the next, over all the images in the current image list. The added images are the equivalent of a [-blend] composition. The frames argument determine how many images to interpolate between each image.

-morphology
------------

-morphology method kernel
--------------------------

Apply a morphology method to the image.

See [IM Usage Examples, Morphology].

-mosaic
--------

An simple alias for the [-layers] method "mosaic"

-motion-blur radius  
-motion-blur radius{xsigma}+angle
---------------------------------------------------------

Simulate motion blur.

Blur with the given radius, standard deviation (sigma), and angle. The angle given is the angle toward which the image is blurred. That is the direction people would consider the object is coming from.

Note that the blur is not uniform distribution, giving the motion a definite sense of direction of movement.

The [-virtual-pixel] setting will determine how pixels which are outside the image proper are blurred into the final result.

-name
------

Name an image.

-negate
--------

Replace each pixel with its complementary color.

The red, green, and blue intensities of an image are negated. White becomes black, yellow becomes blue, etc. Use [+negate] to only negate the grayscale pixels of the image.

-noise geometry  
+noise type
------------------------------

Add or reduce noise in an image.

The principal function of noise peak elimination filter is to smooth the objects within an image without losing edge information and without creating undesired structures. The central idea of the algorithm is to replace a pixel with its next neighbor in value within a pixel window, if this pixel has been found to be noise. A pixel is defined as noise if and only if this pixel is a maximum or minimum within the pixel window.

Use [-noise] radius to specify the width of the neighborhood when reducing noise. This is equivalent to using a [-statistic] NonPeak operation, which should be used in preference.

Use [+noise] followed by a noise type to add noise to an image. Choose from these noise types:

    Gaussian Impulse Laplacian Multiplicative Poisson Random Uniform

The amount of noise added can be controlled by the [-attenuate] setting. If unset the value is equivalent to 1.0, or a maximum noise addition.

Note that Random will replace the image with noise rather than add noise to the image. Use Uniform, if you wish to add random noise to the image.

To print a complete list of noises, use the [-list noise] option.

Also see the [-evaluate] noise functions that allows the use of a controlling value to specify the amount of noise that should be added to an image.

-normalize
-----------

Increase the contrast in an image by stretching the range of intensity values.

The intensity values are stretched to cover the entire range of possible values. While doing so, black-out at most 2% of the pixels and white-out at most 1% of the pixels.

Note that as of ImageMagick 6.4.7-0, [-normalize] is equivalent to [-contrast-stretch 2%x1%]. (Before this version, it was equivalent to [-contrast-stretch 2%x99%]).

All the channels are normalized in concert by the same amount so as to preserve color integrity, when the default [+channel] setting is in use. Specifying any other [-channel] setting will normalize the RGB channels independently.

See [-contrast-stretch] for more details. Also see [-auto-level] for a 'perfect' normalization that is better suited to mathematically generated images.

This operator is under review for re-development.

-opaque color
--------------

Change this color to the fill color within the image.

The color argument is defined using the format described under the [-fill] option. The [-fuzz] setting can be used to match and replace colors similar to the one given.

Use [+opaque] to paint any pixel that does not match the target color.

The [-transparent] operator is exactly the same as [-opaque] but replaces the matching color with transparency rather than the current [-fill] color setting. To ensure that it can do this it also ensures that the image has an alpha channel enabled, as per "[-alpha] set", for the new transparent colors, and does not require you to modify the [-channel] to enable alpha channel handling.

-ordered-dither threshold_map{,level...}
------------------------------------------

Dither the image using a pre-defined ordered dither threshold map specified, and a uniform color map with the given number of levels per color channel.

You can choose from these standard threshold maps:

    threshold   1x1   Threshold 1x1 (non-dither)
    checks      2x1   Checkerboard 2x1 (dither)
    o2x2        2x2   Ordered 2x2 (dispersed)
    o3x3        3x3   Ordered 3x3 (dispersed)
    o4x4        4x4   Ordered 4x4 (dispersed)
    o8x8        8x8   Ordered 8x8 (dispersed)
    h4x4a       4x1   Halftone 4x4 (angled)
    h6x6a       6x1   Halftone 6x6 (angled)
    h8x8a       8x1   Halftone 8x8 (angled)
    h4x4o             Halftone 4x4 (orthogonal)
    h6x6o             Halftone 6x6 (orthogonal)
    h8x8o             Halftone 8x8 (orthogonal)
    h16x16o           Halftone 16x16 (orthogonal)
    c5x5b       c5x5  Circles 5x5 (black)
    c5x5w             Circles 5x5 (white)
    c6x6b       c6x6  Circles 6x6 (black)
    c6x6w             Circles 6x6 (white)
    c7x7b       c7x7  Circles 7x7 (black)
    c7x7w             Circles 7x7 (white)

The threshold generated a simple 50% threshold of the image. This could be used with level to do the equivalent of [-posterize] to reduce an image to basic primary colors.

The checks pattern produces a 3 level checkerboard dither pattern. That is a grayscale will become a pattern of solid black, solid white, and mid-tone colors into a checkerboard pattern of black and white.

You can define your own threshold map for ordered dithering and halftoning your images, in either personal or system thresholds.xml XML file. See [Resources] for more details of configuration files.

To print a complete list of the thresholds that have been defined, use the [-list threshold] option.

Note that at this time the same threshold dithering map is used for all color channels, no attempt is made to offset or rotate the map for different channels is made, to create an offset printing effect. Also as the maps are simple threshold levels, the halftone and circle maps will create incomplete circles along the edges of a colored area. Also all the effects are purely on/off boolean effects, without anti-aliasing to make the circles smooth looking. Large dots can be made to look better with a small amount of blurring after being created.

-orient image orientation
--------------------------

Specify orientation of a digital camera image.

Note, this is a setting. This merely sets the orientation metadata, and does not change the image.

Choose from these orientations:

    bottom-left    right-top
    bottom-right   top-left
    left-bottom    top-right
    left-top       undefined
    right-bottom

To print a complete list of orientations, use the [-list orientation] option.

-page geometry  
-page media[offset][{^!<>}]  
+page
----------------------------------------------------------

Set the size and location of an image on the larger virtual canvas.

See [Image Geometry] for complete details about the _geometry_ argument.

For convenience you can specify the page size using media (see below). Offsets can then be added as with other geometry arguments (e.g. [-page] Letter+43+43).

Use media as shorthand to specify the dimensions (widthxheight) of the PostScript page in dots per inch or a TEXT page in pixels. The choices for paper sizes are: 4x6, 5x7, 7x9, 8x10, 9x11, 9x12, 10x13, 10x14, 11x17, 4A0, 2A0, a0, a1, a2, a3, a4, a4small, a5, a6, a7, a8, a9, a10, archa, archb, archC, archd, arche, b0, b1, b10, b2, b3, b4, b5, b6, b7, b8, b9, c0, c1, c2, c3, c4, c5, c6, c7, csheet, dsheet, esheet, executive, flsa, flse, folio, halfletter, isob0, isob1, isob10, isob2, isob3, isob4, isob5, isob6, isob7, isob8, isob9, jisb0, jisb1, jisb2, jisb3, jisb4, jisb5, jisb6, ledger, legal, letter, lettersmall, monarch, quarto, statement, tabloid. To determine the cooresponding size in pixels at 72DPI, use this command for example:

magick xc: -format "%[papersize:a4]" info:

This option is also used to place subimages when writing to a multi-image format that supports offsets, such as GIF89 and MNG. When used for this purpose the offsets are always measured from the top left corner of the canvas and are not affected by the [-gravity] option. To position a GIF or MNG image, use [-page]{+-}x{+-}y (e.g. -page +100+200). When writing to a MNG file, a [-page] option appearing ahead of the first image in the sequence with nonzero width and height defines the width and height values that are written in the MHDR chunk. Otherwise, the MNG width and height are computed from the bounding box that contains all images in the sequence. When writing a GIF89 file, only the bounding box method is used to determine its dimensions.

For a PostScript page, the image is sized as in [-geometry] but positioned relative to the lower left-hand corner of the page by {+-}xoffset{+-}y offset. Use [-page 612x792], for example, to center the image within the page. If the image size exceeds the PostScript page, it is reduced to fit the page. The default gravity for the [-page] option is NorthWest, i.e., positive x and y offset are measured rightward and downward from the top left corner of the page, unless the [-gravity] option is present with a value other than NorthWest.

The default page dimensions for a TEXT image is 612x792.

This option is used in concert with [-density].

Use [+page] to remove the page settings for an image.

To print a complete list of pagesizes, use [-list pagesize] option.

-paint radius
--------------

Simulate an oil painting.

Each pixel is replaced by the most frequent color in a circular neighborhood whose width is specified with radius.

-path path
-----------

Write images to this path on disk.

-pause seconds
---------------

Pause between animation loops

Pause for the specified number of seconds before repeating the animation.

-pause seconds
---------------

Pause between snapshots.

Pause for the specified number of seconds before taking the next snapshot.

-perceptible epsilon
---------------------

Set each pixel whose value is less than absolute epsilon to -epsilon or epsilon (whichever is closer) otherwise the pixel value remains unchanged.

-ping
------

Efficiently determine these image characteristics: image number, the file name, the width and height of the image, whether the image is colormapped or not, the number of colors in the image, the number of bytes in the image, the format of the image (JPEG, PNM, etc.). Use +ping to ensure accurate image properties.

-pointsize value
-----------------

Pointsize of the PostScript, OPTION1, or TrueType font.

-polaroid angle
----------------

Simulate a Polaroid picture.

Use +polaroid to rotate the image at a random angle between -15 and +15 degrees.

-poly "wt,exp ..."
-------------------

Combines multiple images according to a weighted sum of polynomials; one floating point weight (coefficient) and one floating point polynomial exponent (power) for each image expressed as comma separated pairs.

The weights should typically be fractions between -1 and 1. But the sum of weights should be 1 or at least between 0 and 1 to avoid clamping in non-hdri mode at black and white.

The exponents may be positive, negative or zero. A negative exponent is equivalent to 1 divided by the image raised to the corresponding positive exponent. A zero exponent always produces 1 scaled by quantumrange to white, i.e. `wt*white`, no matter what the image.

The format is: 

    output = wt1*image1^exp1 + wt2*image2^exp2 ...

Some simple uses are:

*   A weighted sum of each image provided all weights add to unity and all exponents=1. If the weights are all equal to 1/(number of images), then this is equivalent to [-evaluate-sequence] mean.
*   The sum of squares of two or more images, provided the weights are equal (and sum to 1 to avoid clamping) and the exponents equal 2.

Note that one may add a constant color to the expression simply by using xc:somecolor for one of the images and specifying the desired weight and exponent equal to 0.

Similarly one may add white to the expression by simply using null: (or xc:white) for one of the images with the appropriate weight and exponent equal to 0.

-posterize levels
------------------

Reduce the image to a limited number of color levels per channel.

Very low values of levels, e.g., 2, 3, 4, have the most visible effect.

-precision value
-----------------

Set the maximum number of significant digits to be printed.

-preview type
--------------

Image preview type.

Use this option to affect the preview operation of an image (e.g. magick file.png -preview Gamma Preview:gamma.png). Choose from these previews:

    AddNoise       Raise
    Blur           ReduceNoise
    Brightness     Roll
    Charcoal       Rotate
    Despeckle      Saturation
    Dull           Segment
    EdgeDetect     Shade
    Gamma          Sharpen
    Grayscale      Shear
    Hue            Solarize
    Implode        Spiff
    JPEG           Spread
    OilPaint       Swirl
    Quantize       Threshold
    Wave

To print a complete list of previews, use the [-list preview] option.

The default preview is JPEG.

-print string
--------------

Interpret string and print to console.

-process command
-----------------

Process the image with a custom image filter.

The command arguments has the form "module arg1 arg2 arg3 ... argN" where module is the name of the module to invoke (e.g. "Analyze") and arg1 arg2 arg3 ... argN are an arbitrary number of arguments to pass to the process module.

-profile filename  
+profile profile_name
-------------------------------------------

Manage ICM, IPTC, or generic profiles in an image.

Using [-profile] filename adds an ICM (ICC color management), IPTC (newswire information), or a generic profile to the image.

Use [+profile profile_name] to remove the indicated profile. ImageMagick uses standard filename globbing, so wildcard expressions may be used to remove more than one profile. Here we remove all profiles from the image except for the XMP profile: 

    +profile "!xmp,*"

Use magick identify -verbose to find out which profiles are in the image file. Use [-strip] to remove all profiles (and comments).

To extract a profile, the [-profile] option is not used. Instead, simply write the file to an image format such as APP1, 8BIM, ICM, or IPTC.

For example, to extract the Exif data (which is stored in JPEG files in the APP1 profile), use.

Set -define precision:highres-transform=true to increase the transform precision. Note, there is a slight performance penalty as the high-precision transform is floating point rather than unsigned.

magick cockatoo.jpg profile.exif

It is important to note that results may depend on whether or not the original image already has an included profile. Also, keep in mind that [-profile] is an "operator" (as opposed to a "setting") and therefore a conversion is made each time it is encountered, in order, in the command-line. For instance, in the following example, if the original image is CMYK with profile, a CMYK-CMYK-RGB conversion results.

magick CMYK.tif -profile "CMYK.icc" -profile "RGB.icc" RGB.tiff

Furthermore, since ICC profiles are not necessarily symmetric, extra conversion steps can yield unwanted results. CMYK profiles are often very asymmetric since they involve 3−>4 and 4−>3 channel mapping.

-quality value
---------------

JPEG/MIFF/PNG compression level.

For the JPEG and MPEG image formats, quality is 1 (lowest image quality and highest compression) to 100 (best quality but least effective compression). The default is to use the estimated quality of your input image if it can be determined, otherwise 92. When the quality is greater than 90, then the chroma channels are not downsampled. Use the [-sampling-factor] option to specify the factors for chroma downsampling.

For the JPEG-2000 image format, quality is mapped using a non-linear equation to the compression ratio required by the Jasper library. This non-linear equation is intended to loosely approximate the quality provided by the JPEG v1 format. The default quality value 100, a request for non-lossy compression. A quality of 75 results in a request for 16:1 compression.

For the MNG and PNG image formats, the quality value sets the zlib compression level (quality / 10) and filter-type (quality % 10). The default PNG "quality" is 75, which means compression level 7 with adaptive PNG filtering, unless the image has a color map, in which case it means compression level 7 with no PNG filtering.

For compression level 0 (quality value less than 10), the Huffman-only strategy is used, which is fastest but not necessarily the worst compression.

If filter-type is 4 or less, the specified PNG filter-type is used for all scanlines:

    0       none
    1       sub
    2       up
    3       average
    4       Paeth

If filter-type is 5, adaptive filtering is used when quality is greater than 50 and the image does not have a color map, otherwise no filtering is used.

If filter-type is 6, adaptive filtering with minimum-sum-of-absolute-values is used.

Only if the output is MNG, if filter-type is 7, the LOCO color transformation (intrapixel differencing) and adaptive filtering with minimum-sum-of-absolute-values are used.

If the filter-type is 8 the zlib Z_RLE compression strategy (or the Z_HUFFMAN_ONLY strategy, when compression level is 0) is used with adaptive PNG filtering.

If the filter-type is 9 the zlib Z_RLE compression strategy (or the Z_HUFFMAN_ONLY strategy, when compression level is 0) is used with no PNG filtering.

The quality setting has no effect on the appearance or signature of PNG and MNG images, since the compression is always lossless.

Not all combinations of compression level, strategy, and PNG filter type can be obtained using the -quality option. For more precise control, you can use the PNG:compression-level=N, PNG:compression-strategy=N, and PNG:compression-filter=N defines, respectively, instead. See [-define]. Values from the defines take precedence over values from the -quality option.

For further information, see the [PNG](http://www.w3.org/pub/WWW/TR) specification.

For the MIFF and TIFF image formats, quality/10 is the [Zip/BZip] compression level, which is 0 (worst but fastest compression) to 9 (best but slowest). It has no effect on the image appearance, since the compression is always lossless.

For the BPG image format, quality/2 is the actual BPG compression level (range from 0 to 51).

-quantize colorspace
---------------------

Reduce colors using this colorspace.

This setting defines the colorspace used to sort out and reduce the number of colors needed by an image (for later dithering) by operators such as [-colors], Note that color reduction also happens automatically when saving images to color-limited image file formats, such as GIF, and PNG8.

-quiet
-------

Suppress all warning messages. Error messages are still reported.

The [-virtual-pixel] setting will determine how pixels which are outside the image proper are blurred into the final result.

-raise thickness
-----------------

Lighten or darken image edges.

This will create a 3-D effect. Use [-raise] to create a raised effect, otherwise use [+raise].

Unlike the similar [-frame] option, [-raise] does not alter the dimensions of the image.

-random-threshold lowxhigh
---------------------------

Apply a random threshold to the image.

-range-threshold low-black,low-white,high-white,high-black
-----------------------------------------------------------

Perform either hard or soft thresholding within some range of values in an image.

-read filename
---------------

Explicit read of an image rather than an implicit read.

This option allows you to read from filenames that start with an 'option' character, and which otherwise could be mistaken as an option (unknown or otherwise).

-read-mask filename
--------------------

Prevent updates to image pixels specified by the mask.

This the same as using a mask used for composite maskingoperations, with grayscale values causing blended updates of the image the mask is attached to.

Use [+read-mask] to remove the mask from images.

Also see [-clip-mask] which work in the same way, but with strict boolean masking.

-red-primary x,y
-----------------

Set the red chromaticity primary point.

-regard-warnings
-----------------

Pay attention to warning messages.

This option causes some warnings in some image formats to be treated as errors.

-remap filename
----------------

Reduce the number of colors in an image to the colors used by this image.

If the [-dither] setting is enabled (the default) then the given colors are dithered over the image as necessary, otherwise the closest color (in RGB colorspace) is selected to replace that pixel in the image.

As a side effect of applying a [-remap] of colors across all images in the current image sequence, all the images will have the same color table. That means that when saved to a file format such as GIF, it will use that color table as a single common or global color table, for all the images, without requiring extra local color tables.

Use [+remap] to reduce all images in the current image sequence to use a common color map over all the images. This equivalent to appending all the images together (without extra background colors) and color reducing those images using [-colors] with a 256 color limit, then [-remap] those colors over the original list of images. This ensures all the images follow a single color map.

If the number of colors over all the images is less than 256, then [+remap] should not perform any color reduction or dithering, as no color changes are needed. In that case, its only effect is to force the use of a global color table. This recommended after using either [-colors] or [-ordered-dither] to reduce the number of colors in an animated image sequence.

Note, the remap image colormap has at most 8-bits of precision. Deeper color maps are automagically coalesced with other colors to meet this requirement.

-region geometry
-----------------

Set a region in which subsequent operations apply.

The x and y offsets are treated in the same manner as in [-crop].

See [Image Geometry] for complete details about the _geometry_ argument.

Use +region to remove any previously set regions.

-remote
--------

Perform a remote operation.

The only command recognized is the name of an image file to load.

If you have more than one [display] application running simultaneously, use the [window] option to specify which application to control.

-render
--------

Render vector operations.

Use [+render] to turn off rendering vector operations. This useful when saving the result to vector formats such as MVG or SVG.

-repage geometry
-----------------

Adjust the canvas and offset information of the image.

This option is like [-page] but acts as an image operator rather than a setting. You can separately set the canvas size or the offset of the image on that canvas by only providing those components.

See [Image Geometry] for complete details about the _geometry_ argument.

If a ! flag is given the offset given is added to the existing offset to move the image relative to its previous position. This useful for animation sequences.

A given a canvas size of zero such as '0x0' forces it to recalculate the canvas size so the image (at its current offset) will appear completely on that canvas (unless it has a negative offset).

Use [+repage] to completely remove/reset the virtual canvas meta-data from the images.

The [-set] 'page' option can be used to directly assign virtual canvas meta-data.

-resample horizontalxvertical
------------------------------

Resample image to specified horizontal and vertical resolution.

Resize the image so that its rendered size remains the same as the original at the specified target resolution. For example, if a 300 DPI image renders at 3 inches by 2 inches on a 300 DPI device, when the image has been resampled to 72 DPI, it will render at 3 inches by 2 inches on a 72 DPI device. Note that only a small number of image formats (e.g. JPEG, PNG, and TIFF) are capable of storing the image resolution. For formats which do not support an image resolution, the original resolution of the image must be specified via [-density] on the command line prior to specifying the resample resolution.

Note that Photoshop stores and obtains image resolution from a proprietary embedded profile. If this profile exists in the image, then Photoshop will continue to treat the image using its former resolution, ignoring the image resolution specified in the standard file header.

-resize geometry
-----------------

Resize an image.

See [Image Geometry] for complete details about the _geometry_ argument. Offsets, if present in the geometry string, are ignored, and the [-gravity] option has no effect.

If the [-filter] option or -define filter:option=value precedes the [-resize] option, the image is resized with the specified orthogonal filter.

Many image processing algorithms assume your image is in a linear-light coding. If your image is gamma-corrected, you can remove the nonlinear gamma correction, apply the transform, then restore it like this:

magick portrait.jpg -gamma .45455 -resize 25% -gamma 2.2  \
  -quality 92 passport.jpg

Note, some resampling functions are damped oscillations in approximation of a Sinc function. As such, you may get negative lobes if your release of ImageMagick is HDRI-enabled. To eliminate them, add [-clamp] to your command-line.

-respect-parentheses
---------------------

Settings remain in effect until parenthesis boundary.

-reverse
---------

Reverse the order of images in the current image list.

-roll {+-}x{+-}y
-----------------

Roll an image vertically or horizontally by the amount given.

A negative x offset rolls the image right-to-left. A negative y offset rolls the image bottom-to-top.

-rotate degrees{<}{\>}
-----------------------

Apply Paeth image rotation (using shear operations) to the image.

Use > to rotate the image only if its width exceeds the height. < rotates the image only if its width is less than the height. For example, if you specify -rotate "-90>" and the image size is 480x640, the image is not rotated. However, if the image is 640x480, it is rotated by -90 degrees. If you use > or <, enclose it in quotation marks to prevent it from being misinterpreted as a file redirection.

Empty triangles in the corners, left over from rotating the image, are filled with the background color.

See also the [-distort] operator and specifically the 'ScaleRotateTranslate' distort method.

The page or virtual canvas information of the image is also rotated. Use a [+repage] to remove the virtual canvas page information if it is unwanted.

-rotational-blur angle
-----------------------

Blur around the center of the image.

This operation used to be called "-radial-blur".

-sample geometry
-----------------

Minify / magnify the image with pixel subsampling and pixel replication, respectively.

Change the image size simply by directly sampling the pixels original from the image. When magnifying, pixels are replicated in blocks. When minifying, pixels are sub-sampled (i.e., some rows and columns are skipped over).

The results are thus equivalent to using [-resize] with a [-filter] setting of point (nearest neighbor), though [-sample] is a lot faster, as it avoids all the filter processing of the image. As such it completely ignores the current [-filter] setting.

The key feature of the [-sample] is that no new colors will be added to the resulting image, though some colors may disappear.

See [Image Geometry] for complete details about the _geometry_ argument. Offsets, if present in the geometry string, are ignored, unlike [-resize].

The actual sampling point is the middle of the sub-region being sampled. As such a single pixel sampling of an image will take the middle pixel, (or top-left-middle if image has even dimensions). However the [-define] 'sample:offset' can be set to modify this position some other location within each sub-region being sampled, as a percentage offset.

By default this value is '50' for the midpoint, but could be set to '0' for top-left, '100' for bottom-right, or with separate X and Y offsets such as '0x50' for left-middle edge of sampling sub-region.

-sampling-factor horizontal-factorxvertical-factor
---------------------------------------------------

Sampling factors used by JPEG or MPEG-2 encoder and YUV decoder/encoder.

This option specifies the sampling factors to be used by the JPEG encoder for chroma downsampling. If this option is omitted, the JPEG library will use its own default values. When reading or writing the YUV format and when writing the M2V (MPEG-2) format, use [-sampling-factor 2x1] or [-sampling-factor 4:2:2] to specify the 4:2:2 downsampling method.

-scale geometry
----------------

Minify / magnify the image with pixel block averaging and pixel replication, respectively.

Change the image size simply by replacing pixels by averaging pixels together when minifying, or replacing pixels when magnifying.

The results are thus equivalent to using [-resize] with a [-filter] setting of box. Though it is a lot faster, as it avoids all the filter processing of the image. As such it completely ignores the current [-filter] setting.

If when shrinking (minifying) images the original image is some integer multiple of the new image size, the number of pixels averaged together to produce the new pixel color is the same across the whole image. This is a special case known as 'binning' and is often used as a method of reducing noise in image such as those generated by digital cameras, especially in low light conditions.

-scene value
-------------

Set scene number.

This option sets the scene number of an image or the first image in an image sequence.

-screen
--------

Specify the screen to capture.

This option indicates that the GetImage request used to obtain the image should be done on the root window, rather than directly on the specified window. In this way, you can obtain pieces of other windows that overlap the specified window, and more importantly, you can capture menus or other popups that are independent windows but appear over the specified window.

-seed
------

Seed a new sequence of pseudo-random numbers

-segment cluster-thresholdxsmoothing-threshold
-----------------------------------------------

Segment the colors of an image.

Segment an image by analyzing the histograms of the color components and identifying units that are homogeneous with the fuzzy c-means technique. This is part of the ImageMagick color quantization routines.

Specify cluster threshold as the number of pixels in each cluster that must exceed the cluster threshold to be considered valid. Smoothing threshold eliminates noise in the second derivative of the histogram. As the value is increased, you can expect a smoother second derivative. The default is 1.5.

If the [-verbose] setting is defined, a detailed report of the color clusters is returned.

-selective-blur radius  
-selective-blur radius{xsigma}{+threshold}
---------------------------------------------------------------------

Selectively blur pixels within a contrast threshold.

Blurs those pixels that are less than or equal to the threshold in contrast. The threshold may be expressed as a fraction of QuantumRange or as a percentage.

The sigma value is the important argument, and determines the actual amount of blurring that will take place.

The radius is only used to determine the size of the array which holds the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

-separate
----------

Separate an image channel into a grayscale image. Specify the channel with [-channel].

-sepia-tone percent-threshold
------------------------------

Simulate a sepia-toned photo.

Specify threshold as the percent threshold of the intensity (0 - 99.9%).

This option applies a special effect to the image, similar to the effect achieved in a photo darkroom by sepia toning. Threshold ranges from 0 to QuantumRange and is a measure of the extent of the sepia toning. A threshold of 80% is a good starting point for a reasonable tone.

-set key value
---------------

+set key
--------

Sets image attributes and properties for images in the current image sequence.

This will assign (or modify) specific settings attached to all the images in the current image sequence. Using the [+set] form of the option will either remove, or reset that setting to a default state, as appropriate.

For example, it will modify specific well known image meta-data 'attributes' such as those normally overridden by: the options [-delay], [-dispose], and [-page], [-colorspace]; generally assigned before the image is read in, by using a key of the same name.

If the given key does not match a specific known 'attribute ', such as shown above, the setting is stored as a free form 'property' string. Such settings are listed in [-verbose] information ("info:" output format) as "Properties".

This includes string 'properties' that are set by and assigned to images using the options [-comment], [-label], [-caption]. These options actually assign a global 'artifact' which are automatically assigned (and any [Format Percent Escapes] expanded) to images as they are read in. For example:

$ magick rose: -set comment 'Rose is a rose is a rose is a rose' rose.jpg
identify -format %c rose.jpg
Rose is a rose is a rose is a rose

The set value can also make use of [Format and Print Image Properties] in the defined value. For example:

$ magick rose: -set origsize '%wx%h' -resize 50% \
  -format 'Old size = %[origsize]  New size = %wx%h' info:
Old size = 70x46  New size = 35x23

Other well known 'properties' that are available include: date:timestamp, date:create, date:modify, and signature.

The [-repage] operator will also allow you to modify the 'page' attribute of an image for images already in memory (also see [-page]). However it is designed to provide a finer control of the sub-parts of this 'attribute'. The [-set page] option will only provide a direct, unmodified assignment of 'page' attribute.

This option can also associate a colorspace or profile with your image. For example,

magick image.psd -set profile ISOcoated_v2_eci.icc image-icc.psd

Some 'properties' must be defined in a specific way to be used. For example only 'properties' prefixed with "filename:" can be used to modify the output filename of an image. For example

magick rose: -set filename:mysize '%wx%h' 'rose_%[filename:mysize].png'

If the setting value is prefixed with "option:" the setting will be saved as a global "Artifact" exactly as if it was set using the [-define] option. As such settings are global in scope, they can be used to pass 'attributes' and 'properties' of one specific image, in a way that allows you to use them in a completely different image, even if the original image has long since been modified or destroyed. For example:

magick rose:  -set option:rosesize '%wx%h' -delete 0 \
  label:'%[rosesize]'   label_size_of_rose.gif"

Note that [Format Percent Escapes] will only match a 'artifact' if the given key does not match an existing 'attribute' or 'property'.

You can set the attributes of the image registry by prefixing the value with registry:.

The [-set profile] option can also be used to inject previously-formatted ancillary chunks into the output PNG file, using the commandline option as shown below or by setting the profile via a programming interface:

magick in.png -set profile PNG-chunk-x:<filename> out.png

where x is a location flag and filename is a file containing the chunk name in the first 4 bytes, then a colon (":"), followed by the chunk data. This encoder will compute the chunk length and CRC, so those must not be included in the file.

"x" can be "b" (before PLTE), "m" (middle, i.e., between PLTE and IDAT), or "e" (end, i.e., after IDAT). If you want to write multiple chunks of the same type, then add a short unique string after the "x" to prevent subsequent profiles from overwriting the preceding ones, e.g.,

magick in.png -set profile PNG-chunk-b01:file01 \
  -profile PNG-chunk-b02:file02 out.png

-shade azimuthxelevation
-------------------------

Shade the image using a distant light source.

Specify azimuth and elevation as the position of the light source. Use [+shade] to return the shading results as a grayscale image.

-shadow percent-opacity{xsigma}{+-}x{+-}y{%}
---------------------------------------------

Simulate an image shadow.

-shared-memory
---------------

Use shared memory.

This option specifies whether the utility should attempt to use shared memory for pixmaps. ImageMagick must be compiled with shared memory support, and the display must support the MIT-SHM extension. Otherwise, this option is ignored. The default is True.

-sharpen radius  
-sharpen radius{xsigma}
-------------------------------------------

Sharpen the image.

Use a Gaussian operator of the given radius and standard deviation (sigma).

The sigma value is the important argument, and determines the actual amount of sharpening that will take place.

The radius is only used to determine the size of the array which holds the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

-shave geometry
----------------

Shave pixels from the image edges.

The size portion of the geometry argument specifies the width of the region to be removed from both sides of the image and the height of the regions to be removed from top and bottom. Offsets are ignored.

See [Image Geometry] for complete details about the _geometry_ argument.

-shear Xdegrees[xYdegrees]
-----------------------------

Shear the image along the x-axis and/or y-axis.

The shear angles may be positive, negative, or zero. When Ydegrees is omitted it defaults to Xdegrees. When both angles are given, the horizontal component of the shear is performed before the vertical component.

Shearing slides one edge of an image along the x-axis or y-axis (i.e., horizontally or vertically, respectively),creating a parallelogram. The amount of each is controlled by the respective shear angle. For horizontal shears, Xdegrees is measured clockwise relative to "up" (the negative y-axis), sliding the top edge to the right when 0° < Xdegrees < 90° and to the left when 90° < Xdegrees < 180°. For vertical shears Ydegrees is measured clockwise relative to "right" (the positive x-axis), sliding the right edge down when 0° < Ydegrees < 90° and up when 90° < Ydegrees < 180°.

Empty triangles left over from shearing the image are filled with the color defined by the [-background] option. The color is specified using the format described under the [-fill] option.

The horizontal shear is performed before the vertical part. This is important to note, since horizontal and vertical shears do not commute, i.e., the order matters in a sequence of shears. For example, the following two commands are not equivalent.

magick logo: -shear 20x0 -shear 0x60 logo-sheared.png
convert logo: -shear 0x60 -shear 20x0 logo-sheared.png

The first of the two commands above is equivalent to the following, except for the amount of empty space created; the command that follows generates a smaller image, and so is a better choice in terms of time and space.

magick logo: -shear 20x60 logo-sheared.png

-sigmoidal-contrast contrastxmid-point
---------------------------------------

Increase the contrast without saturating highlights or shadows.

Increase the contrast of the image using a sigmoidal transfer function without saturating highlights or shadows. Contrast indicates how much to increase the contrast. For example, 0 is none, 3 is typical and 20 is a lot.

The mid-point indicates where the maximum change 'slope' in contrast should fall in the resultant image (0 is white; 50% is middle-gray; 100% is black).

By default the image contrast is increased, use +sigmoidal-contrast to decrease the contrast.

To achieve the equivalent of a sigmoidal brightness change (similar to a gamma adjustment), you would use -sigmoidal-contrast {brightness}x0% to increase brightness and +sigmoidal-contrast {brightness}x0% to decrease brightness. Note the use of '0' fo rthe mid-point of the sigmoidal curve.

Using a very high contrast will produce a sort of 'smoothed thresholding' of the image. Not as sharp (with high aliasing effects) of a true threshold, but with tapered gray-levels around the threshold mid-point.

-silent
--------

Operate silently. This option is only used by the [import] tool.

-similarity-threshold value
----------------------------

Minimum RMSE for subimage match.

If this setting is used, then the search will stop as soon as it finds a match whose metric is less than or equal to the value. A partially filled second output image will result. Using a value of zero, will cause the search to stop at the first perfect match it finds. If this setting is left off, then the search will proceed to completion or as limited by -dissimilarity-threshold.

-size width[xheight][+offset]
----------------------------------

Set the width and height of the image.

Use this option to specify the width and height of raw images whose dimensions are unknown such as GRAY, RGB, or CMYK. In addition to width and height, use [-size] with an offset to skip any header information in the image or tell the number of colors in a MAP image file, (e.g. -size 640x512+256).

For Photo CD images, choose from these sizes:

192x128
384x256
768x512
1536x1024
3072x2048

-sketch radius  
-sketch radius{xsigma}+angle
-----------------------------------------------

Simulate a pencil sketch.

Sketch with the given radius, standard deviation (sigma), and angle. The angle given is the angle toward which the image is sketched. That is the direction people would consider the object is coming from.

-smush offset
--------------

Appends an image sequence together ignoring transparency.

Smush is a more flexible version of [-append], joining the images in the sequence top-to-bottom ([-smush]) or left-to-right ([+smush]), with a gap between images according to the specified offset.

If the offset is negative, images will overlap by that amount.

[-smush] respects [-gravity]. Any empty space will be filled with the [-background] color.

For zero offset and transparent images, the non-transparent parts of the two images will be aligned as close as possible without overlapping.

-snaps value
-------------

Set the number of screen snapshots.

Use this option to grab more than one image from the X server screen, to create an animation sequence.

-solarize percent-threshold
----------------------------

Negate all pixels above the threshold level.

Specify factor as the percent threshold of the intensity (0 - 99.9%).

This option produces a solarization effect seen when exposing a photographic film to light during the development process.

-sort-pixels
-------------

sorts pixels within each scanline in ascending order of intensity.

-sparse-color method 'x,y color ...'
-------------------------------------

color the given image using the specified points of color, and filling the other intervening colors using the given methods.

barycentric

three point triangle of color given 3 points. Giving only 2 points will form a linear gradient between those points. The gradient generated extends beyond the triangle created by those 3 points.

bilinear

Like barycentric but for 4 points. Less than 4 points fall back to barycentric.

voronoi

Simply map each pixel to the to nearest color point given. The result are polygonal 'cells' of solid color.

manhattan

Like voronoi, but resulting polygonal 'cells' are mapped to a fixed coordinate system.

shepards

Colors points biased on the ratio of inverse distance squared. Generating spots of color in a sea of the average of colors.

inverse

Colors points biased on the ratio of inverse distance. This generates sharper points of color rather than rounded spots of 'shepards' Generating spots of color in a sea of the average of colors.

The points are placed according to the images location on the virtual canvas ([-page] or [-repage] offset), and do not actually have to exist on the given image, but may be some point beyond the edge of the image. All points are floating point values.

Only the color channels defined by the [-channel] are modified, which means that by default matte/alpha transparency channel is not affected. Typically transparency channel is turned off either before or after the operation.

Of course if some color points are transparent to generate a transparent gradient, then the image also requires transparency enabled to store the values.

All the above methods when given a single point of color will replace all the colors in the image with the color given, regardless of the point. This is logical, and provides an alternative technique to recolor an image to some default value.

-splice geometry
-----------------

Splice the current background color into the image.

This will add rows and columns of the current [-background] color into the given image according to the given [-gravity] geometry setting. See [Image Geometry] for complete details about the _geometry_ argument. Essentially [-splice] will divide the image into four quadrants, separating them by the inserted rows and columns.

If a dimension of geometry is zero no rows or columns will be added for that dimension. Similarly using a zero offset with the appropriate [-gravity] setting will add rows and columns to the edges of the image, padding the image only along that one edge. Edge padding is what [-splice] is most commonly used for.

If the exact same geometry and [-gravity] is later used with [-chop] the added all splices removed.

-spread amount
---------------

Displace image pixels by a random amount.

The argument amount defines the size of the neighborhood around each pixel from which to choose a candidate pixel to blend.

The lookup is controlled by the [-interpolate] setting.

-statistic type geometry
-------------------------

Replace each pixel with corresponding statistic from the neighborhood.

Choose from these statistic types:

*   **Contrast**

    maximum difference (max - min) divided by (max + min) value in neighborhood

*   **Maximum**

    maximum value per channel in neighborhood

*   **Gradient**

    maximum difference (max - min) value in neighborhood

*   **Maximum**

    maximum value per channel in neighborhood

*   **Minimum**

    minimum value per channel in neighborhood

*   **Mean**

    average value per channel in neighborhood

*   **Median**

    median value per channel in neighborhood

*   **Mode**

    mode (most frequent) value per channel in neighborhood

*   **Nonpeak**

    value just before or after the median value per channel in neighborhood

*   **RMS**

    root mean square value per channel in neighborhood

*   **StandardDeviation**

    standard deviation value per channel in neighborhood

-stegano offset
----------------

Hide watermark within an image.

Use an offset to start the image hiding some number of pixels from the beginning of the image. Note this offset and the image size. You will need this information to recover the steganographic image (e.g. display -size 320x256+35 stegano:image.png).

-stereo +x{+y}
---------------

Composite two images to create a red / cyan stereo anaglyph.

The left side of the stereo pair (second image) is saved as the red channel of the output image. The right side (first image) is saved as the green and blue channels. Red-green stereo glasses are required to properly view the stereo image.

-storage-type type
-------------------

Pixel storage type. Here are the valid types:

    char      unsigned characters
    double    doubles
    float     floats
    integer   integers
    long      longs
    quantum   pixels in the native depth of your ImageMagick distribution
    short     unsigned shorts

Float and double types are normalized from 0.0 to 1.0 otherwise the pixels values range from 0 to the maximum value the storage type can support.

-stretch fontStretch
---------------------

Set a type of stretch style for fonts.

This setting suggests a type of stretch that ImageMagick should try to apply to the currently selected font family. Select fontStretch from the following.

Any
Condensed
Expanded
ExtraCondensed
ExtraExpanded
Normal
SemiCondensed
SemiExpanded
UltraCondensed
UltraExpanded

To print a complete list of stretch types, use [-list stretch].

For other settings that affect fonts, see the options [-font], [-family], [-style], and [-weight].

-strip
-------

Strip the image of any profiles, comments or these PNG chunks: bKGD,cHRM,EXIF,gAMA,iCCP,iTXt,sRGB,tEXt,zCCP,zTXt,date. To remove the orientation chunk, orNT, set the orientation to undefined, e.g., -orient Undefined.

-stroke color
--------------

Color to use when stroking a graphic primitive.

The color is specified using the format described under the [-fill] option.

See [-draw] for further details.

-strokewidth value
-------------------

Set the stroke width.

See [-draw] for further details.

-style fontStyle
-----------------

Set a font style for text.

This setting suggests a font style that ImageMagick should try to apply to the currently selected font family. Select fontStyle from the following.

Any
Italic
Normal
Oblique

For other settings that affect fonts, see the options [-font], [-family], [-stretch], and [-weight].

-subimage-search
-----------------

Search for subimage.

This option is required to have compare search for the best match location of a small image within a larger image. This search will produce two images (or two frames). The first is the "difference" image and the second will be the "match score" image.

The "match-score" image is smaller containing a pixel for ever possible position of the top-left corner of the given sub-image. that is its size will be the size of the larger_image - sub_image + 1. The brightest location in this image is the location s the locate on the best match that is also reported. Note that this may or may not be a perfect match, and the actual brightness will reflect this. Other bright 'peaks' can be used to locate other possible matching locations.

Note that the search will try to compare the sub-image at every possible location in the larger image, as such it can be very slow. The smaller the sub-image the faster this search is.

-swap index,index
------------------

Swap the positions of two images in the image sequence.

For example, [-swap 0,2] swaps the first and the third images in the current image sequence. Use [+swap] to switch the last two images in the sequence.

-swirl degrees
---------------

Swirl image pixels about the center.

Degrees defines the tightness of the swirl.

-synchronize
-------------

Synchronize image to storage device.

Set to "true" to ensure all image data is fully flushed and synchronized to disk. There is a performance penalty, but the benefits include ensuring a valid image file in the event of a system crash and early reporting if there is not enough disk space for the image pixel cache.

-taint
-------

Mark the image as modified.

-text-font name
----------------

Font for writing fixed-width text.

Specifies the name of the preferred font to use in fixed (typewriter style) formatted text. The default is 14 point Courier.

You can tag a font to specify whether it is a PostScript, TrueType, or OPTION1 font. For example, Courier.ttf is a TrueType font and x:fixed is OPTION1.

-texture filename
------------------

Name of texture to tile onto the image background.

-threshold value{%}
--------------------

Apply simultaneous black/white threshold to the image.

Any pixel values (more specifically, those channels set using [-channel]) that exceed the specified threshold are reassigned the maximum channel value, while all other values are assigned the minimum.

The threshold value can be given as a percentage or as an absolute integer value corresponding to the desired channel value. When given as an integer, the minimum attainable value is 0 (corresponding to black when all channels are affected), but the maximum value (corresponding to white) is that of the quantum depth of the particular build of ImageMagick, and is therefore dependent on the installation. For that reason, a reasonable recommendation for most applications is to specify the threshold values as a percentage.

The following would force pixels with red values above 50% to have 100% red values, while those at or below 50% red would be set to 0 in the red channel. The green, blue, and alpha channels (if present) would be unchanged.

magick in.png -channel red -threshold 50% out.png

As (possibly) impractical but instructive examples, the following would generate an all-black and an all-white image with the same dimensions as the input image.

magick in.png -channel RGB -threshold 100% black.png
convert in.png -channel RGB -threshold -1 white.png

See also [-black-threshold] and [-white-threshold].

-thumbnail geometry
--------------------

Create a thumbnail of the image.

This is similar to [-resize], except it is optimized for performance. In addition, comments and color profiles are removed, and Thumb properties are set. This option respects [-filter], e.g., for additional performance but with a slight degradation in quality, use -filter box.

See [Image Geometry] for complete details about the _geometry_ argument.

-tile filename
---------------

Set the tile image used for filling a subsequent graphic primitive.

-tile geometry
---------------

Specify the layout of images.

See [Image Geometry] for complete details about the _geometry_ argument.

-tile
------

Specifies that a subsequent composite operation is repeated across and down image.

-tile-offset {+-}x{+-}y
------------------------

Specify the offset for tile images, relative to the background image it is tiled on.

This should be set before the tiling image is set by [-tile] or [-texture], or directly applied for creating a tiled canvas using TILE: or PATTERN: input formats.

Internally ImageMagick does a [-roll] of the tile image by the arguments given when the tile image is set.

-tint value
------------

Tint the image with the fill color.

Tint the image with the fill color.

Specify the amount of tinting as a percentage. Pure colors like black, white red, yellow, will not be affected by -tint. Only mid-range colors such as the various shades of grey.

-title string
--------------

Assign a title to displayed image.", "animate", "display", "montage

Use this option to assign a specific title to the image. This assigned to the image window and is typically displayed in the window title bar. Optionally you can include the image filename, type, width, height, Exif data, or other image attribute by embedding special format characters described under the [-format] option.

For example,

-title "%m:%f %wx%h"

produces an image title of MIFF:bird.miff 512x480 for an image titled bird.miff and whose width is 512 and height is 480.

-transform
-----------

Transform the image.

This option applies the transformation matrix from a previous [-affine] option.

magick -affine 2,2,-2,2,0,0 -transform bird.ppm bird.jpg

This operator has been now been superseded by the [-distort] 'AffineProjection' method.

-transparent color
-------------------

Make this color transparent within the image.

The color argument is defined using the format described under the [-fill] option. The [-fuzz] setting can be used to match and replace colors similar to the one given.

Use [+transparent] to invert the pixels matched. that is make all non-matching colors transparent.

The [-opaque] operator is exactly the same as [-transparent] but replaces the matching color with the current [-fill] color setting, rather than transparent. However the [-transparent] operator also ensures that the image has an alpha channel enabled, as per "[-alpha] set", and does not require you to modify the [-channel] to enable alpha channel handling.

Note that this does not define the color as being the 'transparency color' used for color-mapped image formats, such as GIF. For that use [-transparent-color]

-transparent-color color
-------------------------

Set the transparent color.

Sometimes this is used for saving to image formats such as GIF and PNG8 which uses this color to represent boolean transparency. This does not make a color transparent, it only defines what color the transparent color is in the color palette of the saved image. Use [-transparent] to make an opaque color transparent.

This option allows you to have both an opaque visible color, as well as a transparent color of the same color value without conflict. That is, you can use the same color for both the transparent and opaque color areas within an image. This, in turn, frees to you to select a transparent color that is appropriate when an image is displayed by an application that does not handle a transparent color index, while allowing ImageMagick to correctly handle images of this type.

The default transparent color is #00000000, which is fully transparent black.

-transpose
-----------

Mirror the image along the top-left to bottom-right diagonal.

This option mathematically transposes the pixel array. It is equivalent to the sequence -flip -rotate 90.

-transverse
------------

Mirror the image along the images bottom-left top-right diagonal. Equivalent to the operations -flop -rotate 90.

-treedepth value
-----------------

Tree depth for the color reduction algorithm.

Normally, this integer value is zero or one. A value of zero or one causes the use of an optimal tree depth for the color reduction algorithm.

An optimal depth generally allows the best representation of the source image with the fastest computational speed and the least amount of memory. However, the default depth is inappropriate for some images. To assure the best representation, try values between 2 and 8 for this parameter. Refer to the [color reduction algorithm] for more details.

The [-colors] or [-monochrome] option, or writing to an image format which requires color reduction, is required for this option to take effect.

-trim
------

Trim an image.

This option removes any edges that are exactly the same color as the corner pixels. Use [-fuzz] to make [-trim] remove edges that are nearly the same color as the corner pixels.

The page or virtual canvas information of the image is preserved allowing you to extract the result of the [-trim] operation from the image. Use a [+repage] to remove the virtual canvas page information if it is unwanted.

If the trimmed image 'disappears' a warning is produced, and a special single pixel transparent 'missed' image is returned, in the same way as when a [-crop] operation 'misses' the image proper.

Use [-define] trim:percent-background=0% to remove all the background from the image. The amount of background that is tolerated in an edge specified as a percent. 0% means no background is tolerated. 50% means an edge can contain up to 50% pixels that are background per the fuzz-factor.

Use [-define] trim:edges={north,east,south,west} separated by commas to only trim the specified edges of the image, e.g. -define trim:edges=north,south -fuzz 5% -trim.

Use [-define] trim:minSize=geometry limit the trim to the specified size.

Use [-background] _background-color_ to identify background color surrounding the region of interest.

-type type
-----------

The image type.

Choose from: Bilevel, Grayscale, GrayscaleAlpha, Palette, PaletteAlpha, TrueColor, TrueColorAlpha, ColorSeparation, or ColorSeparationAlpha.

Normally, when a format supports different subformats such as grayscale and truecolor, the encoder will try to choose an efficient subformat. The [-type] option can be used to override this behavior. For example, to prevent a JPEG from being written in grayscale format even though only gray pixels are present, use.

magick bird.png -type TrueColor bird.jpg

Similarly, use [-type TrueColorAlpha] to force the encoder to write an alpha channel even though the image is opaque, if the output format supports transparency.

Use [-type optimize] to ensure the image is written in the smallest possible file size.

-undercolor color
------------------

Set the color of the annotation bounding box.

The color is specified using the format described under the [-fill] option.

See [-draw] for further details.

-update seconds
----------------

Detect when image file is modified and redisplay.

Suppose that while you are displaying an image the file that is currently displayed is over-written. display will automagically detect that the input file has been changed and update the displayed image accordingly.

-unique-colors
---------------

Discard all but one of any pixel color.

-units type
------------

The units of image resolution.

Choose from: Undefined, PixelsPerInch, or PixelsPerCentimeter. This option is normally used in conjunction with the [-density] option.

-unsharp radius  
-unsharp radius{xsigma}{+gain}{+threshold}
--------------------------------------------------------------

Sharpen the image with an unsharp mask operator.

The [-unsharp] option sharpens an image. The image is convolved with a Gaussian operator of the given radius and standard deviation (sigma). For reasonable results, radius should be larger than sigma. Use a radius of 0 to have the method select a suitable radius.

The sigma value is the important argument, and determines the actual amount of sharpening that will take place.

The radius is only used to determine the size of the array which holds the calculated Gaussian distribution. It should be an integer. If not given, or set to zero, IM will calculate the largest possible radius that will provide meaningful results for the Gaussian distribution.

The parameters are:

radius

The radius of the Gaussian, in pixels, not counting the center pixel (default 0).

sigma

The standard deviation of the Gaussian, in pixels (default 1.0).

gain

The fraction of the difference between the original and the blur image that is added back into the original (default 1.0).

threshold

The threshold, as a fraction of QuantumRange, needed to apply the difference amount (default 0.05).

-verbose
---------

Print detailed information about the image when this option precedes the [-identify] option or info:.

-version
---------

Print ImageMagick version string and exit.

-view string
-------------

FlashPix viewing parameters.

-vignette radius{xsigma}{+-}x{+-}y{%}
--------------------------------------

Soften the edges of the image in vignette style.

The vignette effect rolloff is controlled by radiusxsigma. For nominal rolloff, this would be set to 0xsigma. A value of 0x0 will produce a circle/ellipse with no rolloff. The arguments x and y control the size of the circle. Larger values decrease the radii and smaller values increase the radii. Values of +0+0 will generate a circle/ellipse the same size as the image. The default values for x and y are 10% of the corresponding image dimension. Thus, the radii will be decreased by 10%, i.e., the diameters of the circle/ellipse will be 80% of the corresponding image dimension. Note, the percent symbol in a geometry affects x and y, whereas radius and sigma are absolute (e.g., -vignette "0x2+10%+10%").

-virtual-pixel method
----------------------

Specify contents of virtual pixels.

This option defines what color source should be used if and when a color lookup completely 'misses' the source image. The color(s) that appear to surround the source image. Generally this color is derived from the source image, but could also be set to a specify background color.

Choose from these methods:

    background              the area surrounding the image is the background color
    black                   the area surrounding the image is black
    checker-tile            alternate squares with image and background color
    dither                  non-random 32x32 dithered pattern
    edge                    extend the edge pixel toward infinity
    gray                    the area surrounding the image is gray
    horizontal-tile         horizontally tile the image, background color above/below
    horizontal-tile-edge    horizontally tile the image and replicate the side edge pixels
    mirror                  mirror tile the image
    random                  choose a random pixel from the image
    tile                    tile the image (default)
    transparent             the area surrounding the image is transparent blackness
    vertical-tile           vertically tile the image, sides are background color
    vertical-tile-edge      vertically tile the image and replicate the side edge pixels
    white                   the area surrounding the image is white

The default value is "edge".

This most important for distortion operators such as [-distort], [-implode], and [-fx]. However it also affects operations that may access pixels just outside the image proper, such as [-convolve], [-blur], and [-sharpen].

To print a complete list of virtual pixel types, use the [-list virtual-pixel] option.

-visual type
-------------

Animate images using this X visual type.", 'animate', 'display'

Choose from these visual classes:

    StaticGray    TrueColor
    GrayScale     DirectColor
    StaticColor   default
    PseudoColor   visual id

The X server must support the visual you choose, otherwise an error occurs. If a visual is not specified, the visual class that can display the most simultaneous colors on the default screen is chosen.

-watermark brightnessxsaturation
---------------------------------

Watermark an image using the given percentages of brightness and saturation.

Take a grayscale image (with alpha mask) and modify the destination image's brightness according to watermark image's grayscale value and the brightness percentage. The destinations color saturation attribute is just direct modified by the saturation percentage, which defaults to 100 percent (no color change).

-wave amplitude  
-wave amplitudexwavelength
----------------------------------------------

Shear the columns of an image into a sine wave.

-wavelet-denoise threshold  
-wavelet-denoise thresholdxsoftness
------------------------------------------------------------------

Removes noise from the image using a wavelet transform. The threshold is the value below which everything is considered noise and ranges from 0.0 (none) to QuantumRange or use percent (e.g. 5%). Softness attenuates the threshold and typically ranges from 0.0 (none, default) to 1.0. The higher the value, the more noise that remains in the image.

-weight fontWeight
-------------------

Set a font weight for text.

This setting suggests a font weight that ImageMagick should try to apply to the currently selected font family. Use a positive integer for fontWeight or select from the following.

    Thin           Same as fontWeight = 100.
    ExtraLight     Same as fontWeight = 200.
    Light          Same as fontWeight = 300.
    Normal         Same as fontWeight = 400.
    Medium         Same as fontWeight = 500.
    DemiBold       Same as fontWeight = 600.
    Bold           Same as fontWeight = 700.
    ExtraBold      Same as fontWeight = 800.
    Heavy          Same as fontWeight = 900.
  

To print a complete list of weight types, use [-list weight].

For other settings that affect fonts, see the options [-font], [-family], [-stretch], and [-style].

-white-balance
---------------

Applies white balancing to an image according to a grayworld assumption in the LAB colorspace.

Use -define white-balance:vibrance=_value{%}_ to change the color vibrance of the a & b channels.

-white-point x,y
-----------------

Chromaticity white point.

-white-threshold value{%}
--------------------------

Force to white all pixels above the threshold while leaving all pixels at or below the threshold unchanged.

The threshold value can be given as a percentage or as an absolute integer value within [0, QuantumRange] corresponding to the desired [-channel] value. See [-threshold]for more details on thresholds and resulting values.

-window id
-----------

Make the image the background of a window.", 'animate', 'display'

id can be a window id or name. Specify root to select X's root window as the target window.

By default the image is tiled onto the background of the target window. If backdrop or [-resize] are specified, the image is surrounded by the background color. Refer to X RESOURCES for details.

The image will not display on the root window if the image has more unique colors than the target window colormap allows. Use [-colors] to reduce the number of colors.

-window-group
--------------

Specify the window group.

-word-break type
-----------------

Sets whether line breaks appear wherever the text would otherwise overflow its content box. Choose from normal, the default, or break-word.

-write filename
----------------

Write an image sequence.

The image sequence preceding the [-write] filename option is written out, and processing continues with the same image in its current state if there are additional options. To restore the image to its original state after writing it, use the [+write] filename option.

Use [-compress] to specify the type of image compression.

-write-mask filename
---------------------

Prevent updates to image pixels specified by the mask.

This the same as using a mask used for composite masking operations, with grayscale values causing blended updates of the image the mask is attached to.

Use [+write-mask] to remove the mask from images.

Also see [-clip-mask] which work in the same way, but with strict boolean masking.


/Command-line Processing
========================

Anatomy of the Command-line

The ImageMagick command-line [tools] can be as simple as this:

magick image.jpg image.png 

Or it can be complex with a plethora of [options], as in the following:

    magick label.gif -alpha Set \
      ( +clone  -shade 110x90 -normalize -negate +clone  -compose Plus -composite ) \
      ( -clone 0 -shade 110x50 -normalize -channel BG -fx 0 +channel -alpha Off ) \
      -delete 0 +swap  -compose Multiply -composite  button.gif

This example command is long enough that the command must be written across several lines, so we formatted it for clarity by inserting backslashes (). The backslash is the Linux line-continuation character. In the Windows shell, use a carat character (^) for line-continuation. We use the Linux style on these web pages, as above. Sometimes, however, the lines are wrapped by your browser if the browser window is small enough, but the command-lines, shown in white, are still intended to be typed as one line. Line continuation characters need not be entered. The parentheses that are escaped above using the backslash are not escaped in Windows. There are some other differences between Windows and Linux (involving quotation marks, for instance), but we'll discuss some of those issues later, as they arise.

**For most command line examples on this site, if there is an equivalent translation to run on windows there will be a dropdown in the bottom right, letting you switch which operating system you are previewing the command for.**

Without knowing much about the ImageMagick command-line, you can probably surmise that the first command above converts an image in the JPEG format to one in the PNG format. However, very few may realize the second, more complex command, gives a flat two-dimensional label a three-dimensional look with rich textures and simulated depth:

![label](https://imagemagick.org/image/label.gif) ![==>](https://imagemagick.org/image/right.gif) ![button](https://imagemagick.org/image/button.gif)

Here we show percent completion of a task as a shaded cylinder:

![Shaded Cylinder](https://imagemagick.org/image/cylinder_shaded.png)

Given the complexity of the rendering, you might be surprised it is accomplished by a single command-line:

    magick -size 320x90 canvas:none -stroke snow4 -size 1x90 -tile gradient:white-snow4 \
      -draw 'roundrectangle 16, 5, 304, 85 20,40' +tile -fill snow \
      -draw 'roundrectangle 264, 5, 304, 85  20,40' -tile gradient:chartreuse-green \
      -draw 'roundrectangle 16,  5, 180, 85  20,40' -tile gradient:chartreuse1-chartreuse3 \
      -draw 'roundrectangle 140, 5, 180, 85  20,40' +tile -fill none \
      -draw 'roundrectangle 264, 5, 304, 85 20,40' -strokewidth 2 \
      -draw 'roundrectangle 16, 5, 304, 85 20,40' ( +clone -background snow4 \
      -shadow 80x3+3+3 ) +swap -background none -layers merge ( +size -pointsize 90 \
      -strokewidth 1 -fill red label:'50 %' -trim +repage ( +clone -background firebrick3 \
      -shadow 80x3+3+3 ) +swap -background none -layers merge ) -insert 0 -gravity center \
      -append -background white -gravity center -extent 320x200 cylinder_shaded.png

Run this script contributed by [Geemack](https://github.com/geemack). You'll get a glimpse of the power and versatility of the ImageMagick command-line:

    magick -background none -size 960x960 xc:black ( xc:darkred -duplicate 1 +append ) \
      xc:gold ( xc:teal -duplicate 2 +append ) -modulate 100,100,"%[fx:rand()*200]" \
      xc:white -scale x1 +append -write mpr:clut +delete radial-gradient: mpr:clut \
      -clut -scale 100x4% -wave "%[fx:rand()*24+24]"x"%[fx:w/ceil(rand()*4+1)]" -extent "%[w]x%[w]" \
      -roll +0+"%[fx:(rand()*w*0.05)+(w*0.51)]" ( +clone -blur 0x4 ) -insert 0 -composite \
      -duplicate "%[fx:floor(rand()*3+3)*2-1]" -set option:rot "%[fx:180/n]" -virtual-pixel tile \
      -virtual-pixel none -distort SRT "%[fx:t*360/n]" +repage -flatten -extent 100x50% \
      ( +clone -rotate 180 ) -append +channel -virtual-pixel none -distort SRT "0.96 %[fx:rand()*360]" \
      ( +clone -flop ) +repage -insert "%[fx:round(rand())]" -background black \
      -flatten -brightness-contrast 20,20 -normalize dragonFire.png

To ensure the script can run under Windows, change any backslash-parens (() to just parens, the backslash () to ^, and double-up the percent (%) signs.

In the next sections we dissect the anatomy of the ImageMagick command-line. Hopefully, after carefully reading and better understanding how the command-line works, you should be able to accomplish complex image-processing tasks without resorting to the sometimes daunting [program interfaces].

See [Examples of ImageMagick Usage] for additional help when using ImageMagick from the command-line.

The Anatomy of the Command-line
-------------------------------

The ImageMagick command-line consists of

1.  one or more required input filenames.
2.  zero, one, or more image settings.
3.  zero, one, or more image operators.
4.  zero, one, or more image sequence operators.
5.  zero, one, or more image stacks.
6.  zero or one output image filenames (required by [magick], [convert], [composite], [montage], [compare], [import], [conjure]).

You can find a detailed explanation of each of the constituent parts of the command-line in the sections that follow.

Input Filename
--------------

ImageMagick extends the concept of an input filename to include:

*   filename globbing
*   an explicit image format
*   using built-in images and patterns
*   STDIN, STDOUT, and file descriptors
*   selecting certain frames from an image
*   selecting a region of an image
*   forcing an inline image resize
*   forcing an inline image crop
*   using filename references

These extensions are explained in the next few paragraphs.

Note, by default, if a command-line option is also a filename (e.g., -quality), it is intrepetted as a filename. Use -define registry:option:pedantic=true to instead interpret it as an option.

#### Filename Globbing

In Linux shells, certain characters such as the asterisk (\*) and question mark (?) automagically cause lists of filenames to be generated based on pattern matches. This feature is known as globbing. ImageMagick supports filename globbing for systems, such as Windows, that does not natively support it. For example, suppose you want to convert 1.jpg, 2.jpg, 3.jpg, 4.jpg, and 5.jpg in your current directory to a GIF animation. You can conveniently refer to all of the JPEG files with this command:

    magick *.jpg images.gif

#### Explicit Image Format

Images are stored in a myriad of image formats including the better known JPEG, PNG, TIFF and others. ImageMagick must know the format of the image before it can be read and processed. Most formats have a signature within the image that uniquely identifies the format. Failing that, ImageMagick leverages the filename extension to determine the format. For example, image.jpg or image.JPG tells ImageMagick it is reading an image in the JPEG format.

In some cases the image may not contain a signature and/or the filename does not identify the image format. In these cases an explicit image format must be specified. For example, suppose our image is named image and contains raw red, green, and blue intensity values. ImageMagick has no way to automagically determine the image format so we explicitly set one:

    magick -size 640x480 -depth 8 rgb:image image.png

#### Built-in Images and Patterns

ImageMagick has a number of built-in [images] and [patterns]. To utilize the checkerboard pattern, for example, use:

    magick -size 640x480 pattern:checkerboard checkerboard.png

#### STDIN, STDOUT, and file descriptors

Linux and Windows permit the output of one command to be piped to the input of another. ImageMagick permits image data to be read and written from the [standard streams](http://en.wikipedia.org/wiki/Standard_streams) STDIN (standard in) and STDOUT (standard out), respectively, using a pseudo-filename of -. In this example we pipe the output of [magick] to the [display] program:

    magick logo: gif:- | magick display gif:-

The second explicit format "gif:" is optional in the preceding example. The GIF image format has a unique signature within the image so ImageMagick's [display] command can readily recognize the format as GIF. The [magick] program also accepts STDIN as input in this way:

    magick rose: gif:- | magick - -resize "200%" bigrose.jpg

Other pipes can be accessed via their file descriptors (as of version 6.4.9-3). The file descriptors 0, 1, and 2 are reserved for the standard streams STDIN, STDOUT, and STDERR, respectively, but a pipe associated with a file descriptor number N\>2 can be accessed using the pseudonym fd:N. (The pseudonyms fd:0 and fd:1 can be used for STDIN and STDOUT.) The next example shows how to append image data piped from files with descriptors 3 and 4 and direct the result to the file with descriptor number 5.

    magick fd:3 fd:4 -append fd:5

When needed, explicit image formats can be given as mentioned earlier, as in the following.

    magick gif:fd:3 jpg:fd:4 -append tif:fd:5

#### Selecting Frames

Some images formats contain more than one image frame. Perhaps you only want the first image, or the last, or some number of images in-between. You can specify which image frames to read by appending the image filename with the frame range enclosed in brackets. Here our image (an animated GIF) contains more than one frame but we only want the first:

    magick 'images.gif[0]' image.png

Linux shells generally interpret brackets so we enclosed the filename in quotes above. In a Windows command shell the brackets are not interpreted but using quotes doesn't hurt. However, in most cases the roles of single-quotes and double-quotes are reversed with respect to Linux and Windows, so Windows users should usually try double-quotes where we display single-quotes, and vice versa.

You can read more than one image from a sequence with a frame range. For example, you can extract the first four frames of an image sequence:

    magick 'images.gif[0-3]' images.mng

The default is to step one frame at a time so frames 0, 1, 2, and 3 are returned. Set the step to 2 with -define frames:step=2 and we instead get frames 0 and 2.

Finally, you can read more than one image from a sequence, out-of-order. The next command gets the fourth image in the sequence, followed by the third, and then the fifth:

    magick 'images.gif[3,2,4]' images.mng

Notice that in the last two commands, a single image is written. The output in this case, where the image type is MNG, is a multi-frame file because the MNG format supports multiple frames. Had the output format been JPG, which only supports single frames, the output would have consisted of separate frames. More about that below, in the section about the [Output Filename].

#### Selecting an Image Region

Raw images are a sequence of color intensities without additional meta information such as width, height, or image signature. With raw image formats, you must specify the image width and height but you can also specify a region of the image to read. In our example, the image is in the raw 8-bit RGB format and is 6000 pixels wide and 4000 pixels high. However, we only want a region of 600 by 400 near the center of the image:

    magick -size 6000x4000 -depth 8 'rgb:image[600x400+1900+2900]' image.jpg

You can get the same results with the [-extract] option:

    magick -size 6000x4000 -depth 8 -extract 600x400+1900+2900 rgb:image image.jpg

#### Inline Image Resize

It is sometimes convenient to resize an image as they are read. Suppose you have hundreds of large JPEG images you want to convert to a sequence of PNG thumbails:

    magick '*.jpg' -resize 120x120 thumbnail%03d.png

Here all the images are read and subsequently resized. It is faster and less resource intensive to resize each image as it is read:

    magick '*.jpg[120x120]' thumbnail%03d.png

#### Inline Image Crop

It is sometimes convenient to crop an image as they are read. Suppose you have hundreds of large JPEG images you want to convert to a sequence of PNG thumbails:

    magick '*.jpg' -crop 120x120+10+5 thumbnail%03d.png

Here all the images are read and subsequently cropped. It is faster and less resource-intensive to crop each image as it is read:

    magick '*.jpg[120x120+10+5]' thumbnail%03d.png

#### Filename References

There are two methods to use a filename to reference other image filenames. The first is with '@' which reads image filenames separated by white space from the specified file. Assume the file myimages.txt consists of a list of filenames, like so:

    frame001.jpg
    frame002.jpg
    frame003.jpg

We then expect this command:

    magick @myimages.txt mymovie.gif

to read the images frame001.jpg, frame002.jpg, and frame003.jpg and convert them to a GIF image sequence.

If the image path includes one or more spaces, enclose the path in quotes:

    'my title.jpg'

Some ImageMagick command-line [options] may exceed the capabilities of your command-line processor. Windows, for example, limits command-lines to 8192 characters. If, for example, you have a draw option with polygon points that exceed the command-line length limit, put the draw option instead in a file and reference the file with the @ (e.g. @mypoly.txt).

Another method of referring to other image files is by embedding a formatting character in the filename with a scene range. Consider the filename image-%d.jpg[1-5]. The command

    magick image-%d.jpg[1-5]

causes ImageMagick to attempt to read images with these filenames:

    image-1.jpg
    image-2.jpg
    image-3.jpg
    image-4.jpg
    image-5.jpg

#### Stream Buffering

By default, the input stream is buffered. To ensure information on the source file or terminal is read as soon as its available, set the buffer size to 0:

    magick logo: gif:- | magick display -define stream:buffer-size=0 gif:-

Command-line Options
--------------------

You can direct the behavior of ImageMagick utilities with these command-line [options]. The behavior of an option falls into one of these categories:

*   [Image Setting]
*   [Image Operator]
*   [Image Channel Operator]
*   [Image Sequence Operator]
*   [Image Geometry]
*   [Image Stack]

#### Image Setting

An image setting persists as it appears on the command-line and may affect subsequent processing such as reading an image, an image operator, or when writing an image as appropriate. An image setting stays in effect until it is reset or the command-line terminates. The image settings include:

    •[-adjoin]                     •[-label] 
    •[-affine]                     •[-limit] 
    •[-alpha]                      •[-linewidth] 
    •[-antialias]                  •[-log] 
    •[-authenticate]               •[-loop] 
    •[-background]                 •[-mattecolor] 
    •[-bias]                       •[-monitor] 
    •[-black-point-compensation]   •[-orient] 
    •[-blue-primary]               •[-page] 
    •[-bordercolor]                •[-pointsize] 
    •[-caption]                    •[-preview] 
    •[-channel]                    •[-quality] 
    •[-comment]                    •[-quiet] 
    •[-compress]                   •[-read-mask] 
    •[-debug]                      •[-red-primary] 
    •[-define]                     •[-region] 
    •[-delay]                      •[-render] 
    •[-density]                    •[-repage] 
    •[-depth]                      •[-sampling-factor] 
    •[-direction]                  •[-scene] 
    •[-display]                    •[-seed] 
    •[-dispose]                    •[-size] 
    •[-dither]                     •[-stretch] 
    •[-encoding]                   •[-stroke] 
    •[-endian]                     •[-strokewidth] 
    •[-extract]                    •[-style] 
    •[-family]                     •[-texture] 
    •[-fill]                       •[-tile] 
    •[-filter]                     •[-transparent-color] 
    •[-font]                       •[-treedepth] 
    •[-format]                     •[-type] 
    •[-fuzz]                       •[-undercolor] 
    •[-geometry]                   •[-units] 
    •[-gravity]                    •[-verbose] 
    •[-green-primary]              •[-virtual-pixel] 
    •[-interlace]                  •[-weight] 
    •[-intent]                     •[-write-mask]
    •[-interpolate]                

In this example, -channel applies to each of the images, since, as we mentioned, settings persist:

magick -channel RGB wand.png wizard.png images.png

#### Image Operator

An image operator differs from a setting in that it affects the image immediately as it appears on the command-line. An operator is any command-line [option] not listed as a [image setting] or [image sequence operator]. Unlike an image setting, which persists until the command-line terminates, an operator is applied to the current image set and forgotten. The image operators include:

    •[-annotate]          •[-floodfill]          •[-roll] 
    •[-black-threshold]   •[-frame]              •[-rotate] 
    •[-blur]              •[-fx]                 •[-rotational-blur] 
    •[-border]            •[-gamma]              •[-sample] 
    •[-charcoal]          •[-gaussian-blur]      •[-scale] 
    •[-chop]              •[-grayscale]          •[-sepia-tone] 
    •[-clip]              •[-implode]            •[-segment] 
    •[-clip-path]         •[-integral]           •[-shade] 
    •[-clip-mask]         •[-kmeans]             •[-shadow] 
    •[-colors]            •[-lat]                •[-sharpen] 
    •[-colorize]          •[-level]              •[-shave] 
    •[-colorspace]        •[-map]                •[-shear] 
    •[-color-threshold]   •[-median]             •[-sigmoidal-contrast] 
    •[-compose]           •[-modulate]           •[-solarize] 
    •[-contrast]          •[-monochrome]         •[-splice] 
    •[-convolve]          •[-negate]             •[-spread] 
    •[-crop]              •[-noise]              •[-strip] 
    •[-cycle]             •[-normalize]          •[-swirl] 
    •[-despeckle]         •[-opaque]             •[-threshold] 
    •[-draw]              •[-ordered-dither]     •[-transparent] 
    •[-edge]              •[-paint]              •[-thumbnail] 
    •[-emboss]            •[-posterize]          •[-tint] 
    •[-enhance]           •[-raise]              •[-transform] 
    •[-equalize]          •[-profile]            •[-trim] 
    •[-evaluate]          •[-raise]              •[-unsharp] 
    •[-extent]            •[-random-threshold]   •[-version] 
    •[-flip]              •[-resample]           •[-wave] 
    •[-flop]              •[-resize]             •[-white-balance] 
                                                 •[-white-point] 
                                                 •[-white-threshold]

In this example, -negate negates the wand image but not the wizard:

magick wand.png -negate wizard.png images.png

Note that an image operator will be applied to each images in an image sequence. For example, if you use [-resize] option to resize a GIF image, each frames will be resized to the given size. However, some frames may be smaller than the whole image and resizing all the frames into the same size may result in an unexpected output. In such a case, [-coalesce] should be used to prepare those frames.

#### Image Channel Operator

Operate directly on image channels:

[-channel-fx] •[-separate]

#### Image Sequence Operator

An image sequence operator differs from a setting in that it affects an image sequence immediately as it appears on the command-line. Choose from these image sequence operators:

    •[-append]                 •[-hald-clut] 
    •[-affinity]               •[-ift] 
    •[-average]                •[-identify] 
    •[-clut]                   •[-insert] 
    •[-coalesce]               •[-layers] 
    •[-combine]                •[-limit] 
    •[-compare]                •[-map] 
    •[-complex]                •[-maximum] 
    •[-composite]              •[-minimum] 
    •[-copy]                   •[-morph] 
    •[-crop]                   •[-mosaic] 
    •[-debug]                  •[-optimize] 
    •[-deconstruct]            •[-print] 
    •[-delete]                 •[-process] 
    •[-evaluate-sequence]      •[-quiet] 
    •[-fft]                    •[-read] 
    •[-flatten]                •[-swap] 
    •[-fx]                     •[-write]


In this example, -append appends three images into one:

magick mikayla.png picnic.png beach.png -append vacation.png

#### Image Geometry

Many command-line [options] take a geometry argument to specify such things as the desired width and height of an image and other dimensional quantities. Because users want so many variations on the resulting dimensions, sizes, and positions of images (and because ImageMagick wants to provide them), the geometry argument can take many forms. We describe many of these in this section.

The image options and settings that take some form of a geometry argument include the following. Keep in mind that some of these parse their arguments in slightly different ways. See the documentation for the individual option or setting for more specifics.

    •[-adaptive-resize]     •[-liquid-rescale] 
    •[-border]              •[-page] 
    •[-borderwidth]         •[-region] 
    •[-chop]                •[-repage] 
    •[-crop]                •[-resize] 
    •[-density]             •[-sample] 
    •[-extent]              •[-scale] 
    •[-extract]             •[-shave] 
    •[-frame]               •[-splice] 
    •[-geometry]            •[-thumbnail] 
    •[-iconGeometry]        •[-window]

The geometry argument might take any of the forms listed in the table below. These will described in more detail in the subsections following the table. The usual form is size[offset], meaning size is required and offset is optional. Occasionally, [size]offset is possible. In no cases are spaces permitted within the geometry argument.


*   `   size    `

    General description (actual behavior can vary for different options and settings)

*   `   scale%  `

    Height and width both scaled by specified percentage.

*   `   scale-x%xscale-y%   `

    Height and width individually scaled by specified percentages. (Only one % symbol needed.)

*   `   width   `

    Width given, height automagically selected to preserve aspect ratio.

*   `   xheight     `

    Height given, width automagically selected to preserve aspect ratio.

*   `   widthxheight    `

    Maximum values of height and width given, aspect ratio preserved.

*   `   widthxheight^   `

    Minimum values of width and height given, aspect ratio preserved.

*   `   widthxheight!   `

    Width and height emphatically given, original aspect ratio ignored.

*   `   widthxheight>   `

    Shrinks an image with dimension(s) **larger** than the corresponding width and/or height argument(s).

*   `   widthxheight<   `

    Enlarges an image with dimension(s) **smaller** than the corresponding width and/or height argument(s).

*   `   area@   `

    Resize image to have specified area in pixels. Aspect ratio is preserved.

*   `   x:y     `

    Here x and y denotes an aspect ratio (e.g. 3:2 = 1.5).

*   `   x:y^    `

    remove rows or columns to achieve the given aspect ratio.

*   `   x:y#    `

    add rows or columns to achieve the given aspect ratio.

*   `   {size}{offset}  `

    Specifying the offset (default is +0+0). Below, {size} refers to any of the forms above.

*   `   {size}{+-}x{+-}y    `

    Horizontal and vertical offsets x and y, specified in pixels. Signs are required for both. Offsets are affected by [-gravity] setting. Offsets are not affected by % or other size operators. Note that positive X and Y offsets are in the inward direction towards the center of the image for all [-gravity] options, except 'center'. For East, +X is left. For South, +Y is up. For SouthEast, +X is left and +Y is up. For center, the normal X and Y directional convention is used (+X is right and +Y is down).

#### Basic adjustments to width and height; the operators %, ^, and !

> [!NOTE]
> 注： -resize 使用 WxH 指定宽高值，默认按原图比例约束，先按宽度调整，再以比例调整高度的缩放。
> *  使用 ! 进行强制缩放，取消默认的比例约束。 使用 % 按百分比进行缩放，不使用此符号就按像素尺寸。
> *  使 ^ 操作符表示按 W 或者 H 之中最大的一个维度进行缩放，默认是先按宽度确定。
> *  使 > 操作符表示往缩小的方向进行处理，如果指定的尺寸大于原图就不缩放。
> *  使 < 操作符表示往放大的方向进行处理，如果指定的尺寸小于原图就不缩放。
> *  使 @ 操作符表示约束图像在指定的像素量，宽高相乘得到总像素。


Here, just below, are a few simple examples of geometry, showing how it might be used as an argument to the [-resize] option. We'll use the internal image logo: for our input image. [This fine image] is 640 pixels wide and 480 pixels high. We say its dimensions are 640x480. When we give dimensions of an image, the width (the horizontal dimension) always precedes the height (the vertical dimension). This will be true when we speak of coordinates or offsets into an image, which will always be x–value followed by y. Just think of your high school algebra classes and the xy–plane. (Well, almost: our y–axis will always go downward!)

    magick logo: -resize '200%' bigWiz.png
    magick logo: -resize '200x50%' longShortWiz.png
    magick logo: -resize '100x200' notThinWiz.png
    magick logo: -resize '100x200^' biggerNotThinWiz.png
    magick logo: -resize '100x200!' dochThinWiz.png

The first of the four commands is simple—it stretches both the width and height of the input image by 200% in each direction; it magnifies the whole thing by a factor of two. The second command specifies different percentages for each direction, stretching the width to 200% and squashing the height to 50%. The resulting image (in this example) has dimensions 1280x240. Notice that the percent symbol needn't be repeated; the following are equivalent: 200x50%, 200%x50, 200%x50%.

By default, the width and height given in a geometry argument are maximum values unless a percentage is specified. That is, the image is expanded or contracted to fit the specified width and height value while maintaining the aspect ratio (the ratio of its height to its width) of the image. For instance, the third command above "tries" to set the dimensions to 100x200. Imagine gradually shrinking the original image (which is 640x480), keeping is aspect ratio constant, until it just fits into a 100x200 rectangle. Since the image is longer than it is tall, it will fit when its width shrinks to 100 pixels. To preserve the aspect ratio, the height will therefore have to be (480/640)×100 pixels=75 pixels, so the final dimensions will be 100x75.

Notice that in the previous example, at least one of the specified dimensions will be attained (in this case, the width, 100 pixels). The resulting image fits snugly within the original. One can do just the opposite of this by invoking the ^ operator, as in the fourth example above. In that case, when 100x200^ is given as the argument, again at least one of the dimensions will be attained, but in this case the resulting image can snugly contain the original. Here the geometry argument gives minimum values. In our example, the height will become 200 and the width will be scaled to preserve the aspect ratio, becoming (640/480)×200 pixels=267 pixels. With the ^ operator, one of those dimensions will match the requested size, but the image will likely overflow the dimensions requested to preserve its aspect ratio. (The ^ feature is new as of IM 6.3.8-2.)

We see that ImageMagick is very good about preserving aspect ratios of images, to prevent distortion of your favorite photos and images. But you might really want the dimensions to be 100x200, thereby stretching the image. In this case just tell ImageMagick you really mean it (!) by appending an exclamation operator to the geometry. This will force the image size to exactly what you specify. So, for example, if you specify 100x200! the dimensions will become exactly 100x200 (giving a small, vertically elongated wizard).

#### Bounding the width, height, and area; the operators >, <, and @

Here are a few more examples:

```sh
    magick logo: -resize '100' wiz1.png
    magick logo: -resize 'x200' wiz2.png
    magick logo: -resize '100x200>' wiz3.png
    magick logo: -resize '100x200<' wiz4.png
```

If only one dimension is given it is taken to be the width. When only the width is specified, as in the first example above, the width is accepted as given and the height is chosen to maintain the aspect ratio of the input image. Similarly, if only the height is specified, as in the second example above, the height is accepted and the width is chosen to maintain the aspect ratio.

Use > to shrink an image only if its dimension(s) are **larger** than the corresponding width and/or height arguments. Use < to enlarge an image only if its dimension(s) are **smaller** than the corresponding width and/or height arguments. In either case, if a change is made, the result is as if the > or < operator was not present. So, in the third example above, we specified 100x200> and the original image size is 640x480, so the image size is reduced as if we had specified 100x200. However, in the fourth example above, there will be no change to its size.

Finally, use @ to specify the maximum area in pixels of an image, again while attempting to preserve aspect ratio. (Pixels take only integer values, so some approximation is always at work.) In the following example, an area of 10000 pixels is requested. The resulting file has dimensions 115x86, which has 9890 pixels.

    magick logo: -resize '10000@' wiz10000.png

In all the examples above and below, we have enclosed the geometry arguments within quotation marks. Doing so is optional in many cases, but not always. We must enclose the geometry specifications in quotation marks when using < or > to prevent these characters from being interpreted by the shell as file redirection. On Windows systems, the carat ^ needs to be within quotes, else it is ignored. To be safe, one should probably maintain a habit of enclosing all geometry arguments in quotes, as we have here.

#### Offsets in geometry

Here are some examples to illustrate the use of offsets in geometry arguments. One typical use of offsets is in conjunction with the [-region] option. This option allows many other options to modify the pixels within a specified rectangular subregion of an image. As such, it needs to be given the width and height of that region, and also an offset into the image, which is a pair of coordinates that indicate the location of the region within the larger image. Below, in the first example, we specify a region of size 100x200 to be located at the xy–coordinates x\=10, y\=20. Let's use the usual algebraic notation (x,y)=(10,20), for convenience.

    magick logo: -region '100x200+10+20' -negate wizNeg1.png
    magick logo: -region '100x200-10+20' -negate wizNeg2.png
    magick logo: -gravity center -region '100x200-10+20' -negate wizNeg3.png

Note that offsets always require +/− signs. The offset is not actually a true location within the image; its coordinates must be added to some other location. Let's refer to that as the current location. In the first two examples above, though, that location is the upper-left hand corner of the image, which has coordinates (0,0). (That is the default situation when there are no other directives given to change it.) The first example above puts the 100x200 rectangle's own upper-left corner at (10,20).

A negative offset can make sense in many cases. In the second example above, the offset is (-10,20), specified by -10+20. In that case, only the portion of the (virtual) rectangle obtained that lies within the image can be negated; here it is equivalent to specifying the geometry as 90x200+0+20.

In the third example above, the [-gravity] setting precedes the others and sets the current location within the image at the very center of the image. In this case that is at pixel (320,240), since the size of the image is 640x480. This means that the offsets apply to that location, which thereby gets moved, in this case, to (320-10,240+20)=(310,260). But the 100x200 region itself is affected by the [-gravity] setting, so instead of affecting its upper-left corner, the region's own center (at (+50,+100) within it) is determined. Therefore the center of the 100x200 rectangle is moved to (310,260). The negated rectangle's upper-left corner is now at (310-50,260-100)=(260,160).

#### Image Stack

In school, your teacher probably permitted you to work on problems on a scrap of paper and then copy the results to your test paper. An image stack is similar. It permits you to work on an image or image sequence in isolation and subsequently introduce the results back into the command-line. The image stack is delineated with parenthesis. Image operators only affect images in the current stack. For example, we can limit the image rotation to just the wizard image like this:

    magick wand.gif ( wizard.gif -rotate 30 ) +append images.gif

Notice again that the parentheses are escaped by preceding them with backslashes. This is required under Linux, where parentheses are special shell characters. The backslash tells the shell not to interpret these characters, but to pass them directly to the command being executed. Do not escape the parentheses under Windows. Each parenthesis (or escaped parenthesis) must have spaces on either side, as in the example shown above.

In addition to the image operators already discussed, the following image operators are most useful when processing images in an image stack:

[-clone] •[-delete] •[-insert] •[-swap]

The arguments to these operators are indexes into the image sequence by number, starting with zero, for the first image, and so on. However if you give a negative index, the images are indexed from the end (last image added). That is, an index of -1 is the last image in the current image sequence, -2 gives the second-to-last, and so on.

Output Filename
---------------

ImageMagick extends the concept of an output filename to include:

1.  an explicit image format
2.  write to standard out
3.  filename references

Each of these extensions are explained in the next few paragraphs.

Instead of an output filename, you use [-exit] to completely prevent any image write.

#### Explicit Image Format

Images can be stored in a myriad of image formats including the better known JPEG, PNG, TIFF and others. ImageMagick must know the desired format of the image before it is written. ImageMagick leverages the filename extension to determine the format. For example, image.jpg tells ImageMagick to write the image in the JPEG format. In some cases the filename does not identify the image format. In these cases, the image is written in the format it was originally read unless an explicit image format is specified. For example, suppose we want to write our image to a filename of image in the raw red, green, and blue intensity format:

    magick image.jpg rgb:image

#### Standard Out

Linux permits the output of one command to be piped to another. ImageMagick permits piping one command to another with a filename of -. In this example we pipe the output of [magick] to the [display] program:

magick logo: gif:- | magick display gif:-

Here the explicit format is optional. The GIF image format has a signature that uniquely identifies it so ImageMagick can readily recognize the format as GIF.

#### Filename References

Optionally, use an embedded formatting character to write a sequential image list. Suppose our output filename is image-%d.jpg and our image list includes 3 images. You can expect these images files to be written:

    image-0.jpg
    image-1.jpg
    image-2.jpg

Or retrieve image properties to modify the image filename. For example, the command

    magick rose: -set filename:area '%wx%h' 'rose-%[filename:area].png'

writes an image with this filename:

rose-70x46.png

Finally to convert multiple JPEG images to individual PDF pages, use:

    magick *.jpg +adjoin page-%d.pdf

Use -define filename:literal=true to bypass interpreting embedded formatting characters and instead use the filename literally.

#### Stream Buffering

By default, the output stream is buffered. To ensure information appears on the destination file or terminal as soon as written, set the buffer size to 0:

    magick -define stream:buffer-size=0 logo: gif:- | magick display gif:-

/Image Scripting Language
=========================

Use the magick-script scripting language to convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more. See [Command Line Processing] for advice on how to structure your magick command or see below for example usages of the command.

Here is an example script:

```sh
#!/bin/env magick-script
-size 100x100 xc:red ( rose: -rotate -90 ) +append  -write show:
```

Or use the magick utility with the scripting option like this:

```sh
#!/bin/magick -script
-size 100x100 xc:red ( rose: -rotate -90 ) +append  -write show:
```

You can find additional examples of using magick-script in [Examples of ImageMagick Usage].

> [!NOTE]
> 注：ImageMagick 程序本身可以作为脚本解释器使用，Linux 系统中有名为 Shebang 的脚本运行特性，
> 即使用首先首两个字符 #! 作为魔术符号用于系统检测脚本类型，并按其后面指定的命令作为此脚本文件的
> 解释程序，操作系统会执行脚本解释程序（magick）并将此脚本文件作为脚本解释程序的最后一个参数。
> 因此，以上两各种写法用于运行 ImageMagic 脚本，需要另外定义 magick-script 脚本用于调用 magick。

参考手册 [bash manual](../bash.5.1.md)，以下提供一个 magick-script 脚本参考：

```sh
#!/usr/bin/env -S magick -script

-size 100x100 xc:red ( rose: -rotate -90 ) +append  -write show:
```

Option Summary
--------------

The magick command recognizes these options. Click on an option to get more details about how that option works.

*   `[-adaptive-blur geometry]`  adaptively blur pixels; decrease effect near edges
*   `[-adaptive-resize geometry]`  adaptively resize image with data dependent triangulation.
*   `[-adaptive-sharpen geometry]`  adaptively sharpen pixels; increase effect near edges
*   `[-adjoin]`  join images into a single multi-image file
*   `[-affine matrix]`  affine transform matrix
*   `[-alpha]`

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   `[-annotate geometry text]`  annotate the image with text
*   `[-antialias]`  remove pixel-aliasing
*   `[-append]`  append an image sequence
*   `[-authenticate value]`  decipher image with this password
*   `[-auto-gamma]`  automagically adjust gamma level of image
*   `[-auto-level]`  automagically adjust color levels of image
*   `[-auto-orient]`  automagically orient image
*   `[-background color]`  background color
*   `[-bench iterations]`  measure performance
*   `[-bias value]`  add bias when convolving an image
*   `[-black-threshold value]`  force all pixels below the threshold into black
*   `[-blue-primary point]`  chromaticity blue primary point
*   `[-blue-shift factor]`  simulate a scene at nighttime in the moonlight
*   `[-blur geometry]`  reduce image noise and reduce detail levels
*   `[-border geometry]`  surround image with a border of color
*   `[-bordercolor color]`  border color
*   `[-brightness-contrast geometry]`  improve brightness / contrast of the image
*   `[-canny geometry]`

    use a multi-stage algorithm to detect a wide range of edges in the image

*   `[-caption string]`  assign a caption to an image
*   `[-cdl filename]`  color correct with a color decision list
*   `[-channel type]`  apply option to select image channels
*   `[-charcoal radius]`  simulate a charcoal drawing
*   `[-chop geometry]`  remove pixels from the image interior
*   `[-clamp]`

    set each pixel whose value is below zero to zero and any the pixel whose value is above the quantum range to the quantum range (e.g. 65535) otherwise the pixel value remains unchanged.

*   `[-clip]`  clip along the first path from the 8BIM profile
*   `[-clip-mask] filename`  associate clip mask with the image
*   `[-clip-path id]`  clip along a named path from the 8BIM profile
*   `[-clone index]`  clone an image
*   `[-clut]`  apply a color lookup table to the image
*   `[-connected-components connectivity]`

    connected-components uniquely labeled, choose from 4 or 8 way connectivity

*   `[-contrast-stretch geometry]`

    improve the contrast in an image by `stretching' the range of intensity value

*   `[-coalesce]`  merge a sequence of images
*   `[-colorize value]`  colorize the image with the fill color
*   `[-color-matrix matrix]`  apply color correction to the image.
*   `[-colors value]`  preferred number of colors in the image
*   `[-colorspace type]`  set image colorspace
*   `[-combine]`  combine a sequence of images
*   `[-comment string]`  annotate image with comment
*   `[-compare]`  compare image
*   `[-complexoperator]`  perform complex mathematics on an image sequence
*   `[-compose operator]`  set image composite operator
*   `[-composite]`  composite image
*   `[-compress type]`  image compression type
*   `[-contrast]`  enhance or reduce the image contrast
*   `[-convolve coefficients]`  apply a convolution kernel to the image
*   `[-copy geometry offset]`  copy pixels from one area of an image to another
*   `[-crop geometry]`  crop the image
*   `[-cycle amount]`  cycle the image colormap
*   `[-decipher filename]`  convert cipher pixels to plain
*   `[-debug events]`  display copious debugging information
*   `[-define format:option]`  define one or more image format options
*   `[-deconstruct]`  break down an image sequence into constituent parts
*   `[-delay centiseconds]`  display the next image after pausing
*   `[-delete index]`  delete the image from the image sequence
*   `[-density geometry]`  horizontal and vertical density of the image
*   `[-depth value]`  image depth
*   `[-despeckle]`  reduce the speckles within an image
*   `[-direction type]`  render text right-to-left or left-to-right
*   `[-display server]`  get image or font from this X server
*   `[-dispose method]`  layer disposal method
*   `[-distribute-cache port]`  launch a distributed pixel cache server
*   `[-distort type coefficients]`  distort image
*   `[-dither method]`  apply error diffusion to image
*   `[-draw string]`  annotate the image with a graphic primitive
*   `[-duplicate count,indexes]`  duplicate an image one or more times
*   `[-edge radius]`  apply a filter to detect edges in the image
*   `[-emboss radius]`  emboss an image
*   `[-encipher filename]`  convert plain pixels to cipher pixels
*   `[-encoding type]`  text encoding type
*   `[-endian type]`  endianness (MSB or LSB) of the image
*   `[-enhance]`  apply a digital filter to enhance a noisy image
*   `[-equalize]`  perform histogram equalization to an image
*   `[-evaluate operator value]`  evaluate an arithmetic, relational, or logical expression
*   `[-evaluate-sequence operator]`

    evaluate an arithmetic, relational, or logical expression for an image sequence

*   `[-extent geometry]`  set the image size
*   `[-extract geometry]`  extract area from image
*   `[-family name]`  render text with this font family
*   `[-features distance]`  analyze image features (e.g. contract, correlations, etc.).
*   `[-fft]`  implements the discrete Fourier transform (DFT)
*   `[-fill color]`  color to use when filling a graphic primitive
*   `[-filter type]`  use this filter when resizing an image
*   `[-flatten]`  flatten a sequence of images
*   `[-flip]`  flip image in the vertical direction
*   `[-floodfill geometry color]`  floodfill the image with color
*   `[-flop]`  flop image in the horizontal direction
*   `[-font name]`  render text with this font
*   `[-format string]`  output formatted image characteristics
*   `[-frame geometry]`  surround image with an ornamental border
*   `[-function name]`  apply a function to the image
*   `[-fuzz distance]`  colors within this distance are considered equal
*   `[-fx expression]`  apply mathematical expression to an image channel(s)
*   `[-gamma value]`  level of gamma correction
*   `[-gaussian-blur geometry]`  reduce image noise and reduce detail levels
*   `[-geometry geometry]`  preferred size or location of the image
*   `[-gravity type]`  horizontal and vertical text placement
*   `[-grayscale method]`  convert image to grayscale
*   `[-green-primary point]`  chromaticity green primary point
*   `[-help]`  print program options
*   `[-hough-lines geometry]`  identify lines in the image
*   `[-identify]`  identify the format and characteristics of the image
*   `[-ift]`  implements the inverse discrete Fourier transform (DFT)
*   `[-implode amount]`  implode image pixels about the center
*   `[-insert index]`  insert last image into the image sequence
*   `[-intensity method]`  method to generate an intensity value from a pixel
*   `[-intent type]`  type of rendering intent when managing the image color
*   `[-interlace type]`  type of image interlacing scheme
*   `[-interline-spacing value]`  the space between two text lines
*   `[-interpolate method]`  pixel color interpolation method
*   `[-interword-spacing value]`  the space between two words
*   `[-kerning value]`  the space between two characters
*   `[-kuwahara geometry]`  edge preserving noise reduction filter
*   `[-label string]`  assign a label to an image
*   `[-lat geometry]`  local adaptive thresholding
*   `[-layers method]`  optimize or compare image layers
*   `[-level value]`  adjust the level of image contrast
*   `[-limit type value]`  pixel cache resource limit
*   `[-linear-stretch geometry]`  linear with saturation histogram stretch
*   `[-liquid-rescale geometry]`  rescale image with seam-carving
*   `[-list type]`

    Color, Configure, Delegate, Format, Magic, Module, Resource, or Type

*   `[-log format]`  format of debugging information
*   `[-loop iterations]`  add Netscape loop extension to your GIF animation
*   `[-mask filename]`  associate a mask with the image
*   `[-mattecolor color]`  frame color
*   `[-median radius]`  apply a median filter to the image
*   `[-mean-shift geometry]`  delineate arbitrarily shaped clusters in the image
*   `[-metric type]`  measure differences between images with this metric
*   `[-mode radius]`  make each pixel the 'predominant color' of the neighborhood
*   `[-modulate value]`  vary the brightness, saturation, and hue
*   `[-moments]`  display image moments.
*   `[-monitor]`  monitor progress
*   `[-monochrome]`  transform image to black and white
*   `[-morph value]`  morph an image sequence
*   `[-morphology method] kernel`  apply a morphology method to the image
*   `[-motion-blur geometry]`  simulate motion blur
*   `[-negate]`  replace each pixel with its complementary color
*   `[-noise radius]`  add or reduce noise in an image
*   `[-normalize]`  transform image to span the full range of colors
*   `[-opaque color]`  change this color to the fill color
*   `[-ordered-dither NxN]`  ordered dither the image
*   `[-orient type]`  image orientation
*   `[-page geometry]`  size and location of an image canvas (setting)
*   `[-paint radius]`  simulate an oil painting
*   `[-perceptible]`

    set each pixel whose value is less than |epsilon| to -epsilon or epsilon (whichever is closer) otherwise the pixel value remains unchanged.

*   `[-ping]`  efficiently determine image attributes
*   `[-pointsize value]`  font point size
*   `[-polaroid angle]`  simulate a Polaroid picture
*   `[-poly terms]`

    build a polynomial from the image sequence and the corresponding terms (coefficients and degree pairs).

*   `[-posterize levels]`  reduce the image to a limited number of color levels
*   `[-precision value]`  set the maximum number of significant digits to be printed
*   `[-preview type]`  image preview type
*   `[-print string]`  interpret string and print to console
*   `[-process image-filter]`  process the image with a custom image filter
*   `[-profile filename]`  add, delete, or apply an image profile
*   `[-quality value]`  JPEG/MIFF/PNG compression level
*   `[-quantize colorspace]`  reduce image colors in this colorspace
*   `[-quiet]`  suppress all warning messages
*   `[-rotational-blur angle]`  radial blur the image
*   `[-raise value]`  lighten/darken image edges to create a 3-D effect
*   `[-random-threshold low,high]`  random threshold the image
*   `[-red-primary point]`  chromaticity red primary point
*   `[-regard-warnings]`  pay attention to warning messages.
*   `[-region geometry]`  apply options to a portion of the image
*   `[-remap filename]`  transform image colors to match this set of colors
*   `[-render]`  render vector graphics
*   `[-repage geometry]`  size and location of an image canvas
*   `[-resample geometry]`  change the resolution of an image
*   `[-resize geometry]`  resize the image
*   `[-respect-parentheses]`  settings remain in effect until parenthesis boundary.
*   `[-roll geometry]`  roll an image vertically or horizontally
*   `[-rotate degrees]`  apply Paeth rotation to the image
*   `[-sample geometry]`  scale image with pixel sampling
*   `[-sampling-factor geometry]`  horizontal and vertical sampling factor
*   `[-scale geometry]`  scale the image
*   `[-scene value]`  image scene number
*   `[-seed value]`  seed a new sequence of pseudo-random numbers
*   `[-segment values]`  segment an image
*   `[-selective-blur geometry]`  selectively blur pixels within a contrast threshold
*   `[-separate]`  separate an image channel into a grayscale image
*   `[-sepia-tone threshold]`  simulate a sepia-toned photo
*   `[-set attribute value]`  set an image attribute
*   `[-shade degrees]`  shade the image using a distant light source
*   `[-shadow geometry]`  simulate an image shadow
*   `[-sharpen geometry]`  sharpen the image
*   `[-shave geometry]`  shave pixels from the image edges
*   `[-shear geometry]`  slide one edge of the image along the X or Y axis
*   `[-sigmoidal-contrast geometry]`

    increase the contrast without saturating highlights or shadows

*   `[-smush offset]`  smush an image sequence together
*   `[-size geometry]`  width and height of image
*   `[-sketch geometry]`  simulate a pencil sketch
*   `[-solarize threshold]`  negate all pixels above the threshold level
*   `[-splice geometry]`  splice the background color into the image
*   `[-spread radius]`  displace image pixels by a random amount
*   `[-statistic type geometry]`

    replace each pixel with corresponding statistic from the neighborhood

*   `[-strip]`  strip image of all profiles and comments
*   `[-stroke color]`  graphic primitive stroke color
*   `[-strokewidth value]`  graphic primitive stroke width
*   `[-stretch type]`  render text with this font stretch
*   `[-style type]`  render text with this font style
*   `[-swap indexes]`  swap two images in the image sequence
*   `[-swirl degrees]`  swirl image pixels about the center
*   `[-synchronize]`  synchronize image to storage device
*   `[-taint]`  mark the image as modified
*   `[-texture filename]`  name of texture to tile onto the image background
*   `[-threshold value]`  threshold the image
*   `[-thumbnail geometry]`  create a thumbnail of the image
*   `[-tile filename]`  tile image when filling a graphic primitive
*   `[-tile-offset geometry]`  set the image tile offset
*   `[-tint value]`  tint the image with the fill color
*   `[-transform]`  affine transform image
*   `[-transparent color]`  make this color transparent within the image
*   `[-transparent-color color]`  transparent color
*   `[-transpose]`  flip image in the vertical direction and rotate 90 degrees
*   `[-transverse]`

    flop image in the horizontal direction and rotate 270 degrees

*   `[-treedepth value]`  color tree depth
*   `[-trim]`  trim image edges
*   `[-type type]`  image type
*   `[-undercolor color]`  annotation bounding box color
*   `[-unique-colors]`  discard all but one of any pixel color.
*   `[-units type]`  the units of image resolution
*   `[-unsharp geometry]`  sharpen the image
*   `[-verbose]`  print detailed information about the image
*   `[-version]`  print version information
*   `[-view]`  FlashPix viewing transforms
*   `[-vignette geometry]`  soften the edges of the image in vignette style
*   `[-virtual-pixel method]`  access method for pixels outside the boundaries of the image
*   `[-wave geometry]`  alter an image along a sine wave
*   `[-wavelet-denoise threshold]`  removes noise from the image using a wavelet transform
*   `[-weight type]`  render text with this font weight
*   `[-white-point point]`  chromaticity white point
*   `[-white-threshold value]`  force all pixels above the threshold into white
*   `[-write filename]`  write images to this file


/Animation Viewer
=================

[Example Usage] • [Option Summary]

Use the animate program to animate an image sequence on any X server. See [Command Line Processing] for advice on how to structure your animate command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the animate command here to illustrate its usefulness and ease of use. To get started, lets animate an image sequence in the GIF format:

    magick animate movie.gif 

To animate a directory of JPEG images, use:

    magick animate *.jpg 

You can find additional examples of using animate in [Examples of ImageMagick Usage].

Option Summary
--------------

The animate command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-alpha]     on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel
*   [-antialias]     remove pixel-aliasing
*   [-authenticate value]     decrypt image with this password
*   [-backdrop]     background color
*   [-background color]     background color
*   [-border geometry]     surround image with a border of color
*   [-bordercolor color]     border color
*   [-channel type]     apply option to select image channels
*   [-clip]     clip along the first path from the 8BIM profile
*   [-clip-path id]     clip along a named path from the 8BIM profile
*   [-coalesce]     merge a sequence of images
*   [-colormap type]     Shared or Private
*   [-colors value]     preferred number of colors in the image
*   [-colorspace type]     set image colorspace
*   [-comment string]     annotate image with comment
*   [-compress type]     image compression type
*   [-contrast]     enhance or reduce the image contrast
*   [-crop geometry]     preferred size and location of the cropped image
*   [-debug events]     animate copious debugging information
*   [-decipher filename]     convert cipher pixels to plain
*   [-define format:option]     define one or more image format options
*   [-delay centiseconds]     animate the next image after pausing
*   [-density geometry]     horizontal and vertical density of the image
*   [-depth value]     image depth
*   [-despeckle]     reduce the speckles within an image
*   [-display server]     get image or font from this X server
*   [-dispose method]     layer disposal method
*   [-dither method]     apply error diffusion to image
*   [-edge radius]     apply a filter to detect edges in the image
*   [-endian type]     endianness (MSB or LSB) of the image
*   [-enhance]     apply a digital filter to enhance a noisy image
*   [-extract geometry]     extract area from image
*   [-filter type]     use this filter when resizing an image
*   [-flatten]     flatten a sequence of images
*   [-flip]     flip image in the vertical direction
*   [-flop]     flop image in the horizontal direction
*   [-frame geometry]     surround image with an ornamental border
*   [-gamma value]     level of gamma correction
*   [-geometry geometry]     preferred size or location of the image
*   [-gravity geometry]     horizontal and vertical backdrop placement
*   [-help]     print program options
*   [-identify]     identify the format and characteristics of the image
*   [-immutable type]     prohibit image edits
*   [-interlace type]     type of image interlacing scheme
*   [-interpolate method]     pixel color interpolation method
*   [-label name]     assign a label to an image
*   [-limit type value]     pixel cache resource limit
*   [-log format]     format of debugging information
*   [-map filename]     transform image colors to match this set of colors
*   [-mattecolor color]     frame color
*   [-monitor]     monitor progress
*   [-monochrome]     transform image to black and white
*   [-negate]     replace each pixel with its complementary color
*   [-page geometry]     size and location of an image canvas (setting)
*   [-profile filename]     add, delete, or apply an image profile
*   [-quantize colorspace]     reduce image colors in this colorspace
*   [-quiet]     suppress all warning messages
*   [-raise value]     lighten/darken image edges to create a 3-D effect
*   [-regard-warnings]     pay attention to warning messages.
*   [-remote command]     execute a command in an remote animate process
*   [-resample geometry]     change the resolution of an image
*   [-resize geometry]     resize the image
*   [-respect-parentheses]     settings remain in effect until parenthesis boundary.
*   [-roll geometry]     roll an image vertically or horizontally
*   [-rotate degrees]     apply Paeth rotation to the image
*   [-sample geometry]     scale image with pixel sampling
*   [-sampling-factor geometry]     horizontal and vertical sampling factor
*   [-scene value]     image scene number
*   [-segment values]     segment an image
*   [-seed value]     seed a new sequence of pseudo-random numbers
*   [-set attribute value]     set an image attribute
*   [-sharpen geometry]     sharpen the image
*   [-size geometry]     width and height of image
*   [-strip]     strip image of all profiles and comments
*   [-thumbnail geometry]     create a thumbnail of the image
*   [-transparent-color color]     transparent color
*   [-trim]     trim image edges
*   [-update seconds]     detect when image file is modified and reanimate
*   [-verbose]     print detailed information about the image
*   [-version]     print version information
*   [-virtual-pixel method]     access method for pixels outside the boundaries of the image
*   [-visual]     animate image using this visual type
*   [-window id]     animate images to background of this window
*   [-window-group id]     exit program when this window id is destroyed

/Image Similarity Comparison
============================

[Example Usage] • [Option Summary]

Use the compare program to mathematically and visually annotate the difference between an image and its reconstruction. See [Command Line Processing] for advice on how to structure your compare command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the compare command here to illustrate its usefulness and ease of use. To get started, lets compare an image to one thats been sharpened:

```sh
magick rose.png -sharpen 0x1 reconstruct.jpg
magick compare rose.png reconstruct.jpg difference.png
magick compare -compose src rose.png reconstruct.jpg difference.png 
```

![rose](https://imagemagick.org/image/rose.jpg) ![rose](https://imagemagick.org/image/reconstruct.jpg) ![==>](https://imagemagick.org/image/right.gif) ![rose](https://imagemagick.org/image/difference.png)

The red areas of the difference image emphasizes (highlight) pixels that are affected by the image sharpening, whereas white de-emphasizes (lowlight) pixels that are untouched by the sharpening process.

In addition to the visual interpretation of the difference in an image and its reconstruction, we report a mathematical measure of the difference:

    $ magick compare -verbose -metric mae rose.jpg reconstruct.jpg difference.png
    Image: rose.jpg
     Channel distortion: MAE
      red: 2282.91 (0.034835)
      green: 1853.99 (0.0282901)
      blue: 2008.67 (0.0306503)
      all: 1536.39 (0.0234439) 

Or, if you just want the red channel distortion, use this command:

    $ magick compare -channel red -metric PSNR rose.jpg reconstruct.jpg difference.png
    19.63 

Or, if you just want the overall image distortion, use this command:

    $ magick compare -metric PSNR rose.jpg reconstruct.jpg difference.png
    28.31 

If the reconstructed image is a subimage of the image, the compare program returns the best match offset. In addition, it returns a similarity image such that an exact match location is completely white and if none of the pixels match, black, otherwise some gray level in-between:

    $ magick compare -metric NCC -subimage-search logo.png hat.png similarity.png
    0.99870222 @ 353,157 

You can find additional examples of using compare in [Examples of ImageMagick Usage].

Two images are considered similar if their difference according to the specified metric and fuzz value is 0, with the exception of the normalized cross correlation metric (NCC), where two images are considered similar when their normalized cross correlation is 1. The default metric is NCC.

The compare program returns 2 on error, 0 if the images are similar, or a value between 0 and 1 if they are not similar.

Option Summary
--------------

The compare command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-alpha]    

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   [-authenticate value]       decrypt image with this password
*   [-auto-orient]      automagically orient image
*   [-background color]     background color
*   [-brightness-contrast geometry]     improve brightness / contrast of the image
*   [-channel type]     apply option to select image channels
*   [-colorspace type]      set image colorspace
*   [-compose operator]     set image composite operator
*   [-crop geometry]        crop the image
*   [-decipher filename]        convert cipher pixels to plain
*   [-debug events]     display copious debugging information
*   [-define format:option]     define one or more image format options
*   [-density geometry]     horizontal and vertical density of the image
*   [-depth value]      image depth
*   [-dissimilarity-threshold value]

        maximum distortion for (sub)image match (default 0.2)

*   [-distort type coefficients]        distort image
*   [-encipher filename]        convert plain pixels to cipher pixels
*   [-extract geometry]     extract area from image
*   [-fuzz distance]        colors within this distance are considered equal
*   [-gravity type]     horizontal and vertical text placement
*   [-help]     print program options
*   [-highlight-color color]        emphasize pixel differences with this color
*   [-identify]     identify the format and characteristics of the image
*   [-interlace type]       type of image interlacing scheme
*   [-level value]      adjust the level of image contrast
*   [-limit type value]     pixel cache resource limit
*   [-log format]       format of debugging information
*   [-lowlight-color color]     de-emphasize pixel differences with this color
*   [-metric type]      measure differences between images with this metric
*   [-negate]       replace each pixel with its complementary color
*   [-profile filename]     add, delete, or apply an image profile
*   [-quality value]        JPEG/MIFF/PNG compression level
*   [-quantize colorspace]      reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-read-mask filename]       associate a read mask with the image
*   [-regard-warnings]      pay attention to warning messages.
*   [-repage geometry]      size and location of an image canvas
*   [-resize geometry]      resize the image
*   [-respect-parentheses]      settings remain in effect until parenthesis boundary.
*   [-rotate degrees]       apply Paeth rotation to the image
*   [-sampling-factor geometry]     horizontal and vertical sampling factor
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-separate]     separate an image channel into a grayscale image
*   [-set attribute value]      set an image attribute
*   [-sigmoidal-contrast geometry]

      increase the contrast without saturating highlights or shadows

*   [-similarity-threshold value]

       minimum distortion for (sub)image match (default 0.0)

*   [-size geometry]        width and height of image
*   [-subimage-search]      search for subimage
*   [-synchronize]      synchronize image to storage device
*   [-taint]        mark the image as modified
*   [-transparent-color color]      transparent color
*   [-trim]     trim image edges
*   [-verbose]      print detailed information about the image
*   [-version]      print version information
*   [-virtual-pixel method]

     access method for pixels outside the boundaries of the image

*   [-read-mask filename]       associate a write mask with the image

/Overlap One Image over Another
===============================

[Example Usage] • [Option Summary]

Use the composite program to overlap one image over another. See [Command Line Processing] for advice on how to structure your composite command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the composite command here to illustrate its usefulness and ease of use. To get started, lets overlay a smiley face over a rose:

magick composite -gravity center smile.gif  rose: rose-over.png 

![smile](https://imagemagick.org/image/smile.gif) ![over](https://imagemagick.org/image/over.gif) ![rose](https://imagemagick.org/image/rose.jpg) ![==>](https://imagemagick.org/image/right.gif) ![rose](https://imagemagick.org/image/rose-over.png)

You can create three-dimensional effect with the Atop:

    magick -size 70x70 canvas:none -fill red -draw 'circle 35,35 10,30' red-circle.png
    magick -size 70x70 canvas:none -draw 'circle 35,35 35,20' -negate \
      -channel A -gaussian-blur 0x8 white-highlight.png
    magick composite -compose atop -geometry -13-17 white-highlight.png red-circle.png red-ball.png 

![white highlight](https://imagemagick.org/image/white-highlight.png) ![atop](https://imagemagick.org/image/atop.gif) ![red circle](https://imagemagick.org/image/red-circle.png) ![==>](https://imagemagick.org/image/right.gif) ![red ball](https://imagemagick.org/image/red-ball.png)

Or suppose you want to blend a bear into a stream [seamlessly](https://github.com/ImageMagick/ImageMagick/discussions/4712). Try this command:

    magick -verbose stream.jpg bear.jpg bear_mask.png -define compose:args=400x0.0002+100 \
      -compose seamless-blend -geometry +30+30 -composite bear-in-stream.png 

The mask marks the area around the bear to blend. Seamless blending is an iterative process. Here, we limit the iterations to 400 or less if the blending converges (residual has an RMSE of less than 0.0002). The residual value (RMSE) is printed every 100 iterations. Note, seamless blending works most effectively when the HDRI feature is enabled.

    magick -verbose stream.jpg ( bear.jpg -read-mask only_bear.png ) bear_mask.png \
      -define compose:args=400x0.0002+100 -compose seamless-blend -geometry +30+30 -composite \
      bear-in-stream.png 

Here we create read mask that marks the foreground object from its background. No blending is applied to the foreground object, just its surroundings. The read-mask preserves the colors of the bear and prevents them from lightening as in the first example. Note that read-masks must be black on white background as opposed to normal masks, which are white on black background.

You can find additional examples of using composite in [Examples of ImageMagick Usage]. You can find out more about them and the mathematics by looking at [SVG Alpha Compositing](http://www.w3.org/TR/SVG12/rendering.html)

Option Summary
--------------

The composite command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-affine matrix]        affine transform matrix
*   [-alpha]

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   [-authenticate value]       decrypt image with this password
*   [-blend geometry]       blend images
*   [-blue-primary point]       chromaticity blue primary point
*   [-border geometry]          surround image with a border of color
*   [-bordercolor color]        border color
*   [-channel type]         apply option to select image channels
*   [-colors value]         preferred number of colors in the image
*   [-colorspace type]          set image colorspace
*   [-comment string]       annotate image with comment
*   [-compose operator]         set image composite operator
*   [-compress type]        image compression type
*   [-debug events]         display copious debugging information
*   [-decipher filename]        convert cipher pixels to plain
*   [-define format:option]         define one or more image format options
*   [-density geometry]         horizontal and vertical density of the image
*   [-depth value]          image depth
*   [-displace geometry]        shift image pixels defined by a displacement map
*   [-dissolve value]       dissolve the two images a given percent
*   [-dither method]        apply error diffusion to image
*   [-encipher filename]        convert plain pixels to cipher pixels
*   [-encoding type]        text encoding type
*   [-endian type]          endianness (MSB or LSB) of the image
*   [-extract geometry]         extract area from image
*   [-filter type]          use this filter when resizing an image
*   [-font name]        render text with this font
*   [-geometry geometry]        preferred size or location of the image
*   [-gravity type]         horizontal and vertical text placement
*   [-green-primary point]          chromaticity green primary point
*   [-help]         print program options
*   [-identify]         identify the format and characteristics of the image
*   [-interlace type]       type of image interlacing scheme
*   [-interpolate method]       pixel color interpolation method
*   [-label string]         assign a label to an image
*   [-level value]          adjust the level of image contrast
*   [-limit type value]         pixel cache resource limit
*   [-log format]       format of debugging information
*   [-monitor]          monitor progress
*   [-monochrome]       transform image to black and white
*   [-negate]       replace each pixel with its complementary color
*   [-page geometry]        size and location of an image canvas (setting)
*   [-pointsize value]          font point size
*   [-profile filename]         add, delete, or apply an image profile
*   [-quality value]        JPEG/MIFF/PNG compression level
*   [-quantize colorspace]          reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-red-primary point]        chromaticity red primary point
*   [-regard-warnings]          pay attention to warning messages.
*   [-respect-parentheses]

    settings remain in effect until parenthesis boundary.

*   [-rotate degrees]       apply Paeth rotation to the image
*   [-sampling-factor geometry]         horizontal and vertical sampling factor
*   [-scene value]          image scene number
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-set attribute value]          set an image attribute
*   [-sharpen geometry]         sharpen the image
*   [-shave geometry]       shave pixels from the image edges
*   [-size geometry]        width and height of image
*   [-stegano offset]       hide watermark within an image
*   [-stereo geometry]          combine two image to create a stereo anaglyph
*   [-strip]        strip image of all profiles and comments
*   [-swap indexes]         swap two images in the image sequence
*   [-synchronize]          synchronize image to storage device
*   [-taint]        mark the image as modified
*   [-thumbnail geometry]       create a thumbnail of the image
*   [-tile]         repeat composite operation across and down image
*   [-transform]        affine transform image
*   [-transparent-color color]          transparent color
*   [-treedepth value]          color tree depth
*   [-type type]        image type
*   [-units type]       the units of image resolution
*   [-unsharp geometry]         sharpen the image
*   [-verbose]          print detailed information about the image
*   [-version]          print version information
*   [-virtual-pixel method]

    access method for pixels outside the boundaries of the image

*   [-watermark geometry]       percent brightness and saturation of a watermark
*   [-white-point point]        chromaticity white point
*   [-white-threshold value]        force all pixels above the threshold into white
*   [-write filename]       write images to this file

/Conjure
========

[Example Usage] • [Option Summary] • [Magick Scripting Language (MSL)]

The conjure program gives you the ability to perform custom image processing tasks from a script written in the Magick Scripting Language (MSL). MSL is XML-based and consists of action statements with attributes. Actions include reading an image, processing an image, getting attributes from an image, writing an image, and more. An attribute is a key/value pair that modifies the behavior of an action. See [Command Line Processing] for advice on how to structure your conjure command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the conjure command here to illustrate its usefulness and ease of use. To get started, here is simple conjure command:

    magick conjure -dimensions 400x400 msl:incantation.msl

The MSL script [incantation.msl](https://imagemagick.org/source/incantation.msl) used above is here:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<image>
  <read filename="image.gif" />
  <get width="base-width" height="base-height" />
  <resize geometry="%[dimensions]" />
  <get width="resize-width" height="resize-height" />
  <print output="Image sized from %[base-width]x%[base-height] to %[resize-width]x%[resize-height].\n" />
  <write filename="image.png" />
</image>
```

In this example, a family stayed home for their vacation but as far as their friends are concerned they went to a beautiful beach in the Caribbean:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<group>
    <image id="family">
        <read filename="family.gif"/>
        <resize geometry="300x300"/>
    </image>
    <image id="palm-trees">
        <read filename="palm-trees.gif"/>
        <resize geometry="300x100"/>
    </image>
    <image>
        <read filename="beach.jpg"/>
        <composite image="family" geometry="+30+40"/>
        <composite image="palm-trees" geometry="+320+90"/>
    </image>
    <write filename="family-vacation.png"/>
</group>
```


Here we display the width in pixels of text for a particular font and pointsize.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<image>
  <query-font-metrics text="ImageMagick" font="helvetica" pointsize="48" />
  <print output="Text width is %[msl:font-metrics.width] pixels.\n" />
</image>
```

The query-font-metrics tag supports these properties:

    msl:font-metrics.pixels_per_em.x
    msl:font-metrics.pixels_per_em.y
    msl:font-metrics.ascent
    msl:font-metrics.descent
    msl:font-metrics.width
    msl:font-metrics.height
    msl:font-metrics.max_advance
    msl:font-metrics.bounds.x1
    msl:font-metrics.bounds.y1
    msl:font-metrics.bounds.x2
    msl:font-metrics.bounds.y2
    msl:font-metrics.origin.x
    msl:font-metrics.origin.y

MSL supports most methods and attributes discussed in the [Perl API for ImageMagick].

In addition, MSL supports the swap element with a single indexes element.

Option Summary
--------------

The conjure command recognizes these options. Click on an option to get more details about how that option works.

    Option                Description
    [-debug events]       display copious debugging information
    [-help]               print program options
    [-log format]         format of debugging information
    [-monitor]            monitor progress
    [-quiet]              suppress all warning messages
    [-regard-warnings]    pay attention to warning messages.
    [-seed value]         seed a new sequence of pseudo-random numbers
    [-verbose]            print detailed information about the image
    [-version]            print version information

Magick Scripting Language
-------------------------

The conjure command recognizes these MSL elements. Any element with a strike-thru or without angle bracket is not supported yet.

Magick Scripting Language (MSL)


*   `   adaptiveblur    `

    geometry="geometry", radius="double", sigma="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    adaptively blur the image with a Gaussian operator of the given radius and standard deviation (sigma). Decrease the effect near edges.

*   `   adaptiveresize  `

    geometry="geometry", width="integer", height="integer", filter="Point, Box, Triangle, Hermite, Hanning, Hamming, Blackman, Gaussian, Quadratic, Cubic, Catrom, Mitchell, Lanczos, Bessel, Sinc", support="double", blur="double"

    adaptively resize image using data dependant triangulation. Specify blur > 1 for blurry or < 1 for sharp

*   `   adaptivesharpen     `

    geometry="geometry", radius="double", sigma="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    adaptively sharpen the image with a Gaussian operator of the given radius and standard deviation (sigma). Increase the effect near edges.

*   `   adaptivethreshold   `

    geometry="geometry", width="integer", height="integer", offset="integer"

    local adaptive thresholding.

*   `   addnoise    `

    noise="Uniform, Gaussian, Multiplicative, Impulse, Laplacian, Poisson", attenuate="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    add noise to an image

*   `   affinetransform     `

    affine="array of float values", translate="float, float", scale= "float, float", rotate="float", skewX="float", skewY="float", interpolate="Average, Bicubic, Bilinear, Filter, Integer, Mesh, NearestNeighbor", background="color name"

    affine transform image

*   `   affinity    `

    image="image-handle", method="None, FloydSteinberg, Riemersma"

    choose a particular set of colors from this image

*   `   <annotate>  `

    text="string", font="string", family="string", style="Normal, Italic, Oblique, Any", stretch="Normal, UltraCondensed, ExtraCondensed, Condensed, SemiCondensed, SemiExpanded, Expanded, ExtraExpanded, UltraExpanded", weight="integer", pointsize="integer", density="geometry", stroke="color name", strokewidth="integer", fill="color name", undercolor="color name", kerning="float", geometry="geometry", gravity="NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast", antialias="true, false", x="integer", y="integer", affine="array of float values", translate="float, float", scale="float, float", rotate="float". skewX="float", skewY= "float", align="Left, Center, Right", encoding="UTF-8", interline-spacing="double", interword-spacing="double", direction="right-to-left, left-to-right"

    annotate an image with text. See QueryFontMetrics to get font metrics without rendering any text.

*   `   autogamma   `

    channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    automagically adjust gamma level of image

*   `   autolevel   `

    channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    automagically adjust color levels of image

*   `   autoorient  `

    adjusts an image so that its orientation is suitable for viewing (i.e. top-left orientation)

*   `   blackthreshold  `

    threshold="string", , channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    force all pixels below the threshold intensity into black

*   `   blueshift   `

    factor="double",

    simulate a scene at nighttime in the moonlight. Start with a factor of 1.5.

*   `   <blur>  `

    geometry="geometry", radius="double", sigma="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    reduce image noise and reduce detail levels with a Gaussian operator of the given radius and standard deviation (sigma).

*   `   <border>    `

    geometry="geometry", width="integer", height="integer", bordercolor="color name", compose="Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyOpacity, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor ",

    surround the image with a border of color

*   `   <charcoal>  `

    geometry="geometry", radius="double", sigma="double"

    simulate a charcoal drawing

*   `   <chop>  `

    geometry="geometry", width="integer", height="integer", x="integer", y="integer"

    chop an image

*   `   clamp   `

    channel="Red, RGB, All, etc."

    set each pixel whose value is below zero to zero and any the pixel whose value is above the quantum range to the quantum range (e.g. 65535) otherwise the pixel value remains unchanged.

*   `   clip    `

    id="name", inside=""true, false"",

    apply along a named path from the 8BIM profile.

*   `   clipmask    `

    mask="image-handle"

    clip image as defined by the image mask

*   `   clut    `

    image="image-handle", interpolate="Average, Bicubic, Bilinear, Filter, Integer, Mesh, NearestNeighbor", channel="Red, RGB, All, etc."

    apply a color lookup table to an image sequence

*   `   coalesce    `

    merge a sequence of images

*   `   color   `

    color="color name"

    set the entire image to this color.

*   `   colordecisionlist   `

    filename="string",

    color correct with a color decision list.

*   `   <colorize>  `

    fill="color name", blend="string"

    colorize the image with the fill color

*   `   colormatrix     `

    matrix="array of float values"

    apply color correction to the image. Although you can use variable sized matrices, typically you use a 5 x 5 for an RGBA image and a 6x6 for CMYKA. A 6x6 matrix is required for offsets (populate the last column with normalized values).

*   `   <comment>   `

    string

    add a comment to your image

*   `   comparelayers   `

    method="any, clear, overlay"

    compares each image with the next in a sequence and returns the minimum bounding region of any pixel differences it discovers. Images do not have to be the same size, though it is best that all the images are coalesced (images are all the same size, on a flattened canvas, so as to represent exactly how a specific frame should look).

*   `   <composite>     `

    image="image-handle", compose="Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyOpacity, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor ", mask="image-handle", geometry="geometry", x="integer", y="integer", gravity="NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast", opacity="integer", tile="True, False", rotate="double", color="color name", blend="geometry", interpolate="undefined, average, bicubic, bilinear, filter, integer, mesh, nearest-neighbor, spline"

    composite one image onto another. Use the rotate parameter in concert with the tile parameter.

*   `   <contrast>  `

    sharpen="True, False"

    enhance or reduce the image contrast

*   `   contraststretch     `

    levels="string", 'black-point'="double", 'white-point'="double", channel="Red, RGB, All, etc."

    improve the contrast in an image by `stretching' the range of intensity values

*   `   convolve    `

    coefficients="array of float values", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", bias="double"

    apply a convolution kernel to the image. Given a kernel "order" , you would supply "order*order" float values (e.g. 3x3 implies 9 values).

*   `   <crop>  `

    geometry="geometry", width="integer", height="integer", x="integer", y="integer", fuzz="double", gravity="NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast"

    crop an image

*   `   cyclecolormap   `

    amount="integer"

    displace image colormap by amount

*   `   decipher    `

    passphrase="string"

    convert cipher pixels to plain pixels

*   `   deconstruct     `

    break down an image sequence into constituent parts

*   `   deskew  `

    geometry="string",threshold="double"

    straighten the image

*   `   <despeckle>     `

    reduce the speckles within an image

*   `   difference  `

    image="image-handle"

    compute the difference metrics between two images

*   `   distort     `

    points="array of float values", method="Affine, AffineProjection, Bilinear, Perspective, Resize, ScaleRotateTranslate", virtual-pixel="Background Black Constant Dither Edge Gray Mirror Random Tile Transparent White", best-fit="True, False"

    distort image

*   `   <draw>  `

    primitive="point, line, rectangle, arc, ellipse, circle, path, polyline, polygon, bezier, color, matte, text, @"filename"", points="string" , method=""Point, Replace, Floodfill, FillToBorder, Reset"", stroke="color name", fill="color name", font="string", pointsize="integer", strokewidth="float", antialias="true, false", bordercolor="color name", x="float", y="float", dash-offset="float", dash-pattern="array of float values", affine="array of float values", translate="float, float", scale="float, float", rotate="float", skewX="float", skewY="float", interpolate="undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline", kerning="float", text="string", vector-graphics="string", interline-spacing="double", interword-spacing="double", direction="right-to-left, left-to-right"

    annotate an image with one or more graphic primitives.

*   `   encipher    `

    passphrase="string"

    convert plain pixels to cipher pixels

*   `   <edge>  `

    radius="double"

    enhance edges within the image with a convolution filter of the given radius.

*   `   <emboss>    `

    geometry="geometry", radius="double", sigma="double"

    emboss the image with a convolution filter of the given radius and standard deviation (sigma).

*   `   <enhance>   `

    apply a digital filter to enhance a noisy image

*   `   <equalize>  `

    channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    perform histogram equalization to the image

*   `   extent  `

    geometry="geometry", width="integer", height="integer", x="integer", y="integer", fuzz="double", background="color name", gravity="NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast"

    set the image size

*   `   evaluate    `

    value="double", operator=""Add, And, Divide, LeftShift, Max, Min, Multiply, Or, Rightshift, Subtract, Xor"", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    apply an arithmetic, relational, or logical expression to the image

*   `   filter  `

    kernel="string", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", bias="double"

    apply a convolution kernel to the image.

*   `   <flip>  `

    reflect the image scanlines in the vertical direction

*   `   <flop>  `

    reflect the image scanlines in the horizontal direction

*   `   floodfillpaint  `

    geometry="geometry", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", x="integer", y="integer" , fill="color name", bordercolor="color name", fuzz="double", invert="True, False"

    changes the color value of any pixel that matches the color of the target pixel and is a neighbor. If you specify a border color, the color value is changed for any neighbor pixel that is not that color.

*   `   forwardfouriertransform     `

    magnitude="True, False"

    implements the forward discrete Fourier transform (DFT)

*   `   <frame>     `

    geometry="geometry", width="integer", height="integer", inner="integer", outer="integer", fill="color name", compose="Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyOpacity, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor ",

    surround the image with an ornamental border

*   `   function    `

    parameters="array of float values", function="Sin", virtual-pixel="Background Black Constant Dither Edge Gray Mirror Random Tile Transparent White"

    apply a function to the image

*   `   <gamma>     `

    gamma="string", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    gamma correct the image

*   `   gaussianblur    `

    geometry="geometry", radius="double", sigma="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    reduce image noise and reduce detail levels with a Gaussian operator of the given radius and standard deviation (sigma).

*   `   getpixel    `

    geometry="geometry", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", normalize="true, false", x="integer", y="integer"

    get a single pixel. By default normalized pixel values are returned.

*   `   getpixels   `

    geometry="geometry", width="integer", height="integer", x="integer", y="integer", map="string", normalize="true, false"

    get image pixels as defined by the map (e.g. "RGB", "RGBA", etc.). By default non-normalized pixel values are returned.

*   `   grayscale   `

    channel="Average, Brightness, Lightness, Rec601Luma, Rec601Luminance, Rec709Luma, Rec709Luminance, RMS"

    convert image to grayscale

*   `   haldclut    `

    image="image-handle", channel="Red, RGB, All, etc."

    apply a Hald color lookup table to an image sequence

*   `   identify    `

    file="file", features="distance", unique="True, False"

    identify the attributes of an image

*   `   <implode>   `

    amount="double", interpolate="undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline"

    implode image pixels about the center

*   `   inversediscretefouriertransform     `

    magnitude="True, False"

    implements the inverse discrete Fourier transform (DFT)

*   `   <label>     `

    string

    assign a label to an image

*   `   layers  `

    method="coalesce, compare-any, compare-clear, compare-over, composite, dispose, flatten, merge, mosaic, optimize, optimize-image, optimize-plus, optimize-trans, remove-dups, remove-zero", compose="Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyOpacity, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, LinearLight, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor ", dither="true, false"

    compare each image the GIF disposed forms of the previous image in the sequence. From this, attempt to select the smallest cropped image to replace each frame, while preserving the results of the animation.

*   `   <level>     `

    levels="string", 'black-point'="double", 'gamma'="double", 'white-point'="double", channel="Red, RGB, All, etc."

    adjust the level of image contrast

*   `   levelcolors     `

    invert=>"True, False", 'black-point'="string", 'white-point'="string", channel="Red, RGB, All, etc."

    level image with the given colors

*   `   linearstretch   `

    levels="string", 'black-point'="double", 'white-point'="double"

    linear with saturation stretch

*   `   liquidresize    `

    geometry="geometry", width="integer", height="integer", delta-x="double", rigidity="double"

    rescale image with seam-carving.

*   `   <magnify>   `

    double the size of the image with pixel art scaling

*   `   mask    `

    mask="image-handle"

    composite image pixels as defined by the mask

*   `   mattefloodfill  `

    geometry="geometry", x="integer", y="integer" , matte="integer", bordercolor="color name", fuzz="double", invert="True, False"

    changes the matte value of any pixel that matches the color of the target pixel and is a neighbor. If you specify a border color, the matte value is changed for any neighbor pixel that is not that color.

*   `   medianfilter    `

    geometry="geometry", width="integer", height="integer", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    replace each pixel with the median intensity pixel of a neighborhood.

*   `   <minify>    `

    half the size of an image

*   `   mode    `

    geometry="geometry", width="integer", height="integer", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    make each pixel the "predominant color" of the neighborhood.

*   `   <modulate>  `

    factor="geometry", brightness="double", saturation="double", hue="double", lightness="double", whiteness="double", blackness="double"

    vary the brightness, saturation, and hue of an image by the specified percentage

*   `   morphology  `

    kernel="string", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", iterations="integer"

    apply a morphology method to the image.

*   `   motionblur  `

    geometry="geometry", radius="double", sigma="double", angle="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    reduce image noise and reduce detail levels with a Gaussian operator of the given radius and standard deviation (sigma) at the given angle to simulate the effect of motion

*   `   <negate>    `

    gray="True, False", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    replace each pixel with its complementary color (white becomes black, yellow becomes blue, etc.)

*   `   <normalize>     `

    channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    transform image to span the full range of color values

*   `   oilpaint    `

    radius="integer"

    simulate an oil painting

*   `   <opaque>    `

    color="color name", fill="color name", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", invert="True, False"

    change this color to the fill color within the image

*   `   ordereddither   `

    threshold="threshold, checks, o2x2, o3x3, o4x4, o8x8, h4x4a, h6x6a, h8x8a, h4x4o, h6x6o, h8x8o, h16x16o, hlines6x4", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    order dither image

*   `   perceptible     `

    epsilon="double", channel="Red, RGB, All, etc."

    set each pixel whose value is less than |"epsilon"| to "-epsilon" or "epsilon" (whichever is closer) otherwise the pixel value remains unchanged..

*   `   polaroid    `

    caption="string", angle="double", pointsize="double", font="string", stroke= "color name", strokewidth="integer", fill="color name", gravity="NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast", background="color name"

    simulate a Polaroid picture.

*   `   posterize   `

    levels="integer", dither="True, False"

    reduce the image to a limited number of color level

*   `   <profile>   `

    name="string", profile="blob", rendering-intent="Undefined, Saturation, Perceptual, Absolute, Relative", black-point-compensation="True, False"

    add or remove ICC or IPTC image profile; name is formal name (e.g. ICC or filename; set profile to '' to remove profile

*   `   <quantize>  `

    colors="integer", colorspace="RGB, Gray, Transparent, OHTA, XYZ, YCbCr, YIQ, YPbPr, YUV, CMYK, sRGB, HSL, HSB", treedepth= "integer", dither="True, False", dither-method="Riemersma, Floyd-Steinberg", measure_error="True, False", global_colormap="True, False", transparent-color="color"

    preferred number of colors in the image

*   `   radialblur  `

    geometry="geometry", angle="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    radial blur the image.

*   `   <raise>     `

    geometry="geometry", width="integer", height="integer", x="integer", y="integer", raise="True, False"

    lighten or darken image edges to create a 3-D effect

*   `   reducenoise     `

    geometry="geometry", width="integer", height="integer", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    reduce noise in the image with a noise peak elimination filter

*   `   remap   `

    image="image-handle", dither="true, false", dither-method="Riemersma, Floyd-Steinberg"

    replace the colors of an image with the closest color from a reference image.

*   `   <resample>  `

    density="geometry", x="double", y="double", filter="Point, Box, Triangle, Hermite, Hanning, Hamming, Blackman, Gaussian, Quadratic, Cubic, Catrom, Mitchell, Lanczos, Bessel, Sinc", support="double"

    resample image to desired resolution. Specify blur > 1 for blurry or < 1 for sharp

*   `   <resize>    `

    geometry="geometry", width="integer", height="integer", filter="Point, Box, Triangle, Hermite, Hanning, Hamming, Blackman, Gaussian, Quadratic, Cubic, Catrom, Mitchell, Lanczos, Bessel, Sinc", support="double", blur="double"

    scale image to desired size. Specify blur > 1 for blurry or < 1 for sharp

*   `   <roll>  `

    geometry="geometry", x="integer", y="integer"

    roll an image vertically or horizontally

*   `   <rotate>    `

    degrees="double", background="color name"

    rotate an image

*   `   <sample>    `

    geometry="geometry", width="integer", height="integer"

    scale image with pixel sampling.

*   `   <scale>     `

    geometry="geometry", width="integer", height="integer"

    scale image to desired size

*   `   <segment>   `

    colorspace="RGB, Gray, Transparent, OHTA, XYZ, YCbCr, YCC, YIQ, YPbPr, YUV, CMYK", verbose="True, False", cluster-threshold="double", smoothing-threshold="double"

    segment an image by analyzing the histograms of the color components and identifying units that are homogeneous

*   `   selectiveblur   `

    geometry="geometry", radius="double", sigma="double", threshold="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    selectively blur pixels within a contrast threshold.

*   `   separate    `

    channel="Red, RGB, All, etc."

    separate a channel from the image into a grayscale image

*   `   <shade>     `

    geometry="geometry", azimuth="double", elevation="double", gray="true, false"

    shade the image using a distant light source

*   `   setpixel    `

    geometry="geometry", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", color="array of float values", x="integer", y="integer", color="array of float values"

    set a single pixel. By default normalized pixel values are expected.

*   `   <shadow>    `

    geometry="geometry", opacity="double", sigma="double", x="integer", y="integer"

    simulate an image shadow

*   `   <sharpen>   `

    geometry="geometry", radius="double", sigma="double", bias="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    sharpen the image with a Gaussian operator of the given radius and standard deviation (sigma).

*   `   <shave>     `

    geometry="geometry", width="integer", height="integer"

    shave pixels from the image edges

*   `   <shear>     `

    geometry="geometry", x="double", y="double" fill="color name"

    shear the image along the X or Y axis by a positive or negative shear angle

*   `   sigmoidalcontrast   `

    geometry="string", 'contrast'="double", 'mid-point'="double" channel="Red, RGB, All, etc.", sharpen="True, False"

    sigmoidal non-lineraity contrast control. Increase the contrast of the image using a sigmoidal transfer function without saturating highlights or shadows. Contrast" indicates how much to increase the contrast (0 is none; 3 is typical; 20 is a lot); mid-point" indicates where midtones fall in the resultant image (0 is white; 50% is middle-gray; 100% is black). To decrease contrast, set sharpen to False.

*   `   <signature>     `

    generate an SHA-256 message digest for the image pixel stream

*   `   sketch  `

    geometry="geometry", radius="double", sigma="double", angle="double"

    sketch the image with a Gaussian operator of the given radius and standard deviation (sigma) at the given angle

*   `   <solarize>  `

    geometry="string", threshold="double", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    negate all pixels above the threshold level

*   `   sparsecolor     `

    points="array of float values", method="Barycentric, Bilinear, Shepards, Voronoi", virtual-pixel="Background Black Constant Dither Edge Gray Mirror Random Tile Transparent White"

    interpolate the image colors around the supplied points

*   `   splice  `

    geometry="geometry", width="integer", height="integer", x="integer", y="integer", fuzz="double", background="color name", gravity="NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast"

    splice an image

*   `   <spread>    `

    radius="double", interpolate="undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline"

    displace image pixels by a random amount

*   `   statistic   `

    geometry="geometry", width="integer", height="integer", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow", type="Median, Mode, Mean, Maximum, Minimum, ReduceNoise"

    replace each pixel with corresponding statistic from the neighborhood.

*   `   <stegano>   `

    image="image-handle", offset="integer"

    hide a digital watermark within the image

*   `   <stereo>    `

    image="image-handle", x="integer", y="integer"

    composites two images and produces a single image that is the composite of a left and right image of a stereo pair

*   `   <strip>     `

    strip an image of all profiles and comments.

*   `   <swirl>     `

    degrees="double", interpolate="undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline"

    swirl image pixels about the center

*   `   texture     `

    texture="image-handle"

    name of texture to tile onto the image background

*   `   thumbnail   `

    geometry="geometry", width="integer", height="integer"

    changes the size of an image to the given dimensions and removes any associated profiles.

*   `   <threshold>     `

    threshold="string", channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    threshold the image

*   `   tint    `

    fill="color name", blend="string"

    tint the image with the fill color.

*   `   <transparent>   `

    color="color name", invert="True, False"

    make this color transparent within the image

*   `   transpose   `

    flip image in the vertical direction and rotate 90 degrees

*   `   transverse  `

    flop image in the horizontal direction and rotate 270 degrees

*   `   <trim>  `

    remove edges that are the background color from the image

*   `   unsharpmask     `

    geometry="geometry", radius="double", sigma="double", gain="double", threshold="double"

    sharpen the image with the unsharp mask algorithm.

*   `   vignette    `

    geometry="geometry", radius="double", sigma="double", x="integer", y="integer", background="color name"

    offset the edges of the image in vignette style

*   `   wave    `

    geometry="geometry", amplitude="double", wavelength="double", interpolate="undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline"

    alter an image along a sine wave

*   `   whitethreshold  `

    threshold="string", , channel="All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Opacity, Red, RGB, Yellow"

    force all pixels above the threshold intensity into white

/Convert Between Image Formats
==============================

Use the magick program to convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more. See [Command Line Processing] for advice on how to structure your magick command or see below for example usages of the command.

We list a few examples of the magick command here to illustrate its usefulness and ease of use. To get started, lets convert an image in the JPEG format to PNG:

    magick rose.jpg rose.png

Next, we reduce the image size before it is written to the PNG format:

    magick rose.jpg -resize 50% rose.png

 ![rose](https://imagemagick.org/image/rose.jpg)![==>](https://imagemagick.org/image/right.gif) ![rose](https://imagemagick.org/image/rose.png)

You can combine multiple image-processing operations to produce complex results:

    magick -size 320x85 canvas:none -font Bookman-DemiItalic -pointsize 72 \
      -draw "text 25,60 'Magick'" -channel RGBA -blur 0x6 -fill darkred -stroke magenta \
      -draw "text 20,55 'Magick'" fuzzy-magick.png

![fuzzy-magick](https://imagemagick.org/image/fuzzy-magick.png)

or here we resize an image with improved quality:

    magick input.png -colorspace RGB +sigmoidal-contrast 11.6933 \
      -define filter:filter=Sinc -define filter:window=Jinc -define filter:lobes=3 \
      -resize 400% -sigmoidal-contrast 11.6933 -colorspace sRGB output.png');

You can find additional examples of using magick in [Examples of ImageMagick Usage].

Option Summary
--------------

The magick command recognizes these options. Click on an option to get more details about how that option works.

*   [-adaptive-blur geometry]   

    adaptively blur pixels; decrease effect near edges

*   [-adaptive-resize geometry] 

    adaptively resize image with data dependent triangulation.

*   [-adaptive-sharpen geometry]    

    adaptively sharpen pixels; increase effect near edges

*   [-adjoin]       join images into a single multi-image file
*   [-affine matrix]        affine transform matrix
*   [-alpha]    

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   [-annotate geometry text]       annotate the image with text
*   [-antialias]        remove pixel-aliasing
*   [-append]       append an image sequence
*   [-authenticate value]       decipher image with this password
*   [-auto-gamma]       automagically adjust gamma level of image
*   [-auto-level]       automagically adjust color levels of image
*   [-auto-orient]      automagically orient image
*   [-auto-threshold method]        automatically perform image thresholding
*   [-background color]     background color
*   [-bench iterations]     measure performance
*   [-bias value]       add bias when convolving an image
*   [-bilateral-blur geometry]  

    non-linear, edge-preserving, and noise-reducing smoothing filter

*   [-black-threshold value]        force all pixels below the threshold into black
*   [-blue-primary point]       chromaticity blue primary point
*   [-blue-shift factor]        simulate a scene at nighttime in the moonlight
*   [-blur geometry]        reduce image noise and reduce detail levels
*   [-border geometry]      surround image with a border of color
*   [-bordercolor color]        border color
*   [-brightness-contrast geometry]     improve brightness / contrast of the image
*   [-canny geometry]   

    use a multi-stage algorithm to detect a wide range of edges in the image

*   [-caption string]       assign a caption to an image
*   [-cdl filename]     color correct with a color decision list
*   [-channel type]     apply option to select image channels
*   [-charcoal radius]      simulate a charcoal drawing
*   [-chop geometry]        remove pixels from the image interior
*   [-clahe geometry]       contrast limited adaptive histogram equalization
*   [-clamp]    

    set each pixel whose value is below zero to zero and any the pixel whose value is above the quantum range to the quantum range (e.g. 65535) otherwise the pixel value remains unchanged.

*   [-clip]     clip along the first path from the 8BIM profile
*   [-clip-mask] filename       associate clip mask with the image
*   [-clip-path id]     clip along a named path from the 8BIM profile
*   [-clone index]      clone an image
*   [-clut]     apply a color lookup table to the image
*   [-connected-components connectivity]    

    connected-components uniquely labeled, choose from 4 or 8 way connectivity

*   [-contrast-stretch geometry]    

    improve the contrast in an image by `stretching' the range of intensity value

*   [-coalesce]     merge a sequence of images
*   [-colorize value]       colorize the image with the fill color
*   [-color-matrix matrix]      apply color correction to the image.
*   [-colors value]     preferred number of colors in the image
*   [-colorspace type]      set image colorspace
*   [-color-threshold start-color-stop-color]   

    force all pixels in the color range to white otherwise black

*   [-combine]      combine a sequence of images
*   [-comment string]       annotate image with comment
*   [-compare]      compare image
*   [-complexoperator]      perform complex mathematics on an image sequence
*   [-compose operator]     set image composite operator
*   [-composite]        composite image
*   [-compress type]        image compression type
*   [-contrast]     enhance or reduce the image contrast
*   [-convolve coefficients]        apply a convolution kernel to the image
*   [-copy geometry offset]     copy pixels from one area of an image to another
*   [-crop geometry]        crop the image
*   [-cycle amount]     cycle the image colormap
*   [-decipher filename]        convert cipher pixels to plain
*   [-debug events]     display copious debugging information
*   [-define format:option]     define one or more image format options
*   [-deconstruct]      break down an image sequence into constituent parts
*   [-delay centiseconds]       display the next image after pausing
*   [-delete index]     delete the image from the image sequence
*   [-density geometry]     horizontal and vertical density of the image
*   [-depth value]      image depth
*   [-despeckle]        reduce the speckles within an image
*   [-direction type]       render text right-to-left or left-to-right
*   [-display server]       get image or font from this X server
*   [-dispose method]       layer disposal method
*   [-distribute-cache port]        launch a distributed pixel cache server
*   [-distort type coefficients]        distort image
*   [-dither method]        apply error diffusion to image
*   [-draw string]      annotate the image with a graphic primitive
*   [-duplicate count,indexes]      duplicate an image one or more times
*   [-edge radius]      apply a filter to detect edges in the image
*   [-emboss radius]        emboss an image
*   [-encipher filename]        convert plain pixels to cipher pixels
*   [-encoding type]        text encoding type
*   [-endian type]      endianness (MSB or LSB) of the image
*   [-enhance]      apply a digital filter to enhance a noisy image
*   [-equalize]     perform histogram equalization to an image
*   [-evaluate operator value]      evaluate an arithmetic, relational, or logical expression
*   [-evaluate-sequence operator]   

    evaluate an arithmetic, relational, or logical expression for an image sequence

*   [-extent geometry]      set the image size
*   [-extract geometry]     extract area from image
*   [-family name]      render text with this font family
*   [-features distance]        analyze image features (e.g. contract, correlations, etc.).
*   [-fft]      implements the discrete Fourier transform (DFT)
*   [-fill color]       color to use when filling a graphic primitive
*   [-filter type]      use this filter when resizing an image
*   [-flatten]      flatten a sequence of images
*   [-flip]     flip image in the vertical direction
*   [-floodfill geometry color]     floodfill the image with color
*   [-flop]     flop image in the horizontal direction
*   [-font name]        render text with this font
*   [-format string]        output formatted image characteristics
*   [-frame geometry]       surround image with an ornamental border
*   [-function name]        apply a function to the image
*   [-fuzz distance]        colors within this distance are considered equal
*   [-fx expression]        apply mathematical expression to an image channel(s)
*   [-gamma value]      level of gamma correction
*   [-gaussian-blur geometry]       reduce image noise and reduce detail levels
*   [-geometry geometry]        preferred size or location of the image
*   [-gravity type]     horizontal and vertical text placement
*   [-grayscale method]     convert image to grayscale
*   [-green-primary point]      chromaticity green primary point
*   [-help]     print program options
*   [-hough-lines geometry]     identify lines in the image
*   [-identify]     identify the format and characteristics of the image
*   [-ift]      implements the inverse discrete Fourier transform (DFT)
*   [-illuminant type]      reference illuminant
*   [-implode amount]       implode image pixels about the center
*   [-insert index]     insert last image into the image sequence
*   [-integral]     Calculate the sum of values (pixel values) in the image
*   [-intensity method]     method to generate an intensity value from a pixel
*   [-intent type]      type of rendering intent when managing the image color
*   [-interlace type]       type of image interlacing scheme
*   [-interline-spacing value]      the space between two text lines
*   [-interpolate method]       pixel color interpolation method
*   [-interword-spacing value]      the space between two words
*   [-kerning value]        the space between two characters
*   [-kmeans geometry]      K means color reduction
*   [-kuwahara geometry]        edge preserving noise reduction filter
*   [-label string]     assign a label to an image
*   [-lat geometry]     local adaptive thresholding
*   [-layers method]        optimize or compare image layers
*   [-level value]      adjust the level of image contrast
*   [-limit type value]     pixel cache resource limit
*   [-linear-stretch geometry]      linear with saturation histogram stretch
*   [-liquid-rescale geometry]      rescale image with seam-carving
*   [-list type]    

    Color, Configure, Delegate, Format, Magic, Module, Resource, or Type

*   [-log format]       format of debugging information
*   [-loop iterations]      add Netscape loop extension to your GIF animation
*   [-mattecolor color]     frame color
*   [-median radius]        apply a median filter to the image
*   [-mean-shift geometry]      delineate arbitrarily shaped clusters in the image
*   [-metric type]      measure differences between images with this metric
*   [-mode radius]      make each pixel the 'predominant color' of the neighborhood
*   [-modulate value]       vary the brightness, saturation, and hue
*   [-moments]      display image moments.
*   [-monitor]      monitor progress
*   [-monochrome]       transform image to black and white
*   [-morph value]      morph an image sequence
*   [-morphology method] kernel     apply a morphology method to the image
*   [-motion-blur geometry]     simulate motion blur
*   [-negate]       replace each pixel with its complementary color
*   [-noise radius]     add or reduce noise in an image
*   [-normalize]        transform image to span the full range of colors
*   [-opaque color]     change this color to the fill color
*   [-ordered-dither NxN]       ordered dither the image
*   [-orient type]      image orientation
*   [-page geometry]        size and location of an image canvas (setting)
*   [-paint radius]     simulate an oil painting
*   [-perceptible]  

    set each pixel whose value is less than |epsilon| to -epsilon or epsilon (whichever is closer) otherwise the pixel value remains unchanged.

*   [-ping]     efficiently determine image attributes
*   [-pointsize value]      font point size
*   [-polaroid angle]       simulate a Polaroid picture
*   [-poly terms]   

    build a polynomial from the image sequence and the corresponding terms (coefficients and degree pairs).

*   [-posterize levels]     reduce the image to a limited number of color levels
*   [-precision value]      set the maximum number of significant digits to be printed
*   [-preview type]     image preview type
*   [-print string]     interpret string and print to console
*   [-process image-filter]     process the image with a custom image filter
*   [-profile filename]     add, delete, or apply an image profile
*   [-quality value]        JPEG/MIFF/PNG compression level
*   [-quantize colorspace]      reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-rotational-blur angle]        radial blur the image
*   [-raise value]      lighten/darken image edges to create a 3-D effect
*   [-random-threshold low, high]       random threshold the image
*   [-range-threshold low-black, low-white, high-white, high-black] 

    perform either hard or soft thresholding within some range of values in an image

*   [-read-mask filename]       associate a read mask with the image
*   [-red-primary point]        chromaticity red primary point
*   [-regard-warnings]      pay attention to warning messages.
*   [-region geometry]      apply options to a portion of the image
*   [-remap filename]       transform image colors to match this set of colors
*   [-render]       render vector graphics
*   [-repage geometry]      size and location of an image canvas
*   [-resample geometry]        change the resolution of an image
*   [-resize geometry]      resize the image
*   [-respect-parentheses]      settings remain in effect until parenthesis boundary.
*   [-roll geometry]        roll an image vertically or horizontally
*   [-rotate degrees]       apply Paeth rotation to the image
*   [-sample geometry]      scale image with pixel sampling
*   [-sampling-factor geometry]     horizontal and vertical sampling factor
*   [-scale geometry]       scale the image
*   [-scene value]      image scene number
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-segment values]       segment an image
*   [-selective-blur geometry]      selectively blur pixels within a contrast threshold
*   [-separate]     separate an image channel into a grayscale image
*   [-sepia-tone threshold]     simulate a sepia-toned photo
*   [-set attribute value]      set an image attribute
*   [-shade degrees]        shade the image using a distant light source
*   [-shadow geometry]      simulate an image shadow
*   [-sharpen geometry]     sharpen the image
*   [-shave geometry]       shave pixels from the image edges
*   [-shear geometry]       slide one edge of the image along the X or Y axis
*   [-sigmoidal-contrast geometry]

      increase the contrast without saturating highlights or shadows

*   [-smush offset]     smush an image sequence together
*   [-size geometry]        width and height of image
*   [-sketch geometry]      simulate a pencil sketch
*   [-solarize threshold]       negate all pixels above the threshold level
*   [-sort-pixels]      sorts pixels within each scanline in ascending order of intensity
*   [-splice geometry]      splice the background color into the image
*   [-spread radius]        displace image pixels by a random amount
*   [-statistic type geometry]

      replace each pixel with corresponding statistic from the neighborhood

*   [-strip]        strip image of all profiles and comments
*   [-stroke color]     graphic primitive stroke color
*   [-strokewidth value]        graphic primitive stroke width
*   [-stretch type]     render text with this font stretch
*   [-style type]       render text with this font style
*   [-swap indexes]     swap two images in the image sequence
*   [-swirl degrees]        swirl image pixels about the center
*   [-synchronize]      synchronize image to storage device
*   [-taint]        mark the image as modified
*   [-texture filename]     name of texture to tile onto the image background
*   [-threshold value]      threshold the image
*   [-thumbnail geometry]       create a thumbnail of the image
*   [-tile filename]        tile image when filling a graphic primitive
*   [-tile-offset geometry]     set the image tile offset
*   [-tint value]       tint the image with the fill color
*   [-transform]        affine transform image
*   [-transparent color]        make this color transparent within the image
*   [-transparent-color color]      transparent color
*   [-transpose]        flip image in the vertical direction and rotate 90 degrees
*   [-transverse]       flop image in the horizontal direction and rotate 270 degrees
*   [-treedepth value]      color tree depth
*   [-trim]     trim image edges
*   [-type type]        image type
*   [-undercolor color]     annotation bounding box color
*   [-unique-colors]        discard all but one of any pixel color.
*   [-units type]       the units of image resolution
*   [-unsharp geometry]     sharpen the image
*   [-verbose]      print detailed information about the image
*   [-version]      print version information
*   [-view]     FlashPix viewing transforms
*   [-vignette geometry]        soften the edges of the image in vignette style
*   [-virtual-pixel method]     access method for pixels outside the boundaries of the image
*   [-wave geometry]        alter an image along a sine wave
*   [-wavelet-denoise threshold]        removes noise from the image using a wavelet transform
*   [-weight type]      render text with this font weight
*   [-white-point point]        chromaticity white point
*   [-white-threshold value]        force all pixels above the threshold into white
*   [-word-break type]  

    sets whether line breaks appear wherever the text would otherwise overflow its content box. Choose from normal, the default, or break-word.

*   [-write filename]       write images to this file
*   [-write-mask filename]      associate a write mask with the image

/Image Viewer
=============

[Example Usage] • [Option Summary]  

Use the display program to display an image or image sequence on any X server. See [Command     Line Processing] for advice on how to structure your display command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the display command here to illustrate its usefulness and ease of use. To get started, lets display an image in the JPEG format:

    magick display rose.jpg 

To tile a slate texture onto the root window, use:

    magick display -size 1280x1024 -window root slate.png 

To display a visual image directory of all your JPEG images, use:

    magick display 'vid:*.jpg' 

The display program defaults to the X screen resolution. To display vector formats at their intended size, override the default resolution:

    magick display -density 72 drawing.svg 

You can find additional examples of using display in [Examples of ImageMagick Usage].   

Option Summary
--------------

The display command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-alpha]    

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   [-antialias]        remove pixel-aliasing
*   [-authenticate value]       decrypt image with this password
*   [-backdrop]     display image centered on a backdrop
*   [-background color]     background color
*   [-border geometry]      surround image with a border of color
*   [-bordercolor color]        border color
*   [-channel type]     apply option to select image channels
*   [-clip]     clip along the first path from the 8BIM profile
*   [-clip-path id]     clip along a named path from the 8BIM profile
*   [-coalesce]     merge a sequence of images
*   [-colormap type]        Shared or Private
*   [-colors value]     preferred number of colors in the image
*   [-colorspace type]      set image colorspace
*   [-comment string]       annotate image with comment
*   [-compress type]        image compression type
*   [-contrast]     enhance or reduce the image contrast
*   [-crop geometry]        preferred size and location of the cropped image
*   [-debug events]     display copious debugging information
*   [-decipher filename]        convert cipher pixels to plain
*   [-define format:option]     define one or more image format options
*   [-delay centiseconds]       display the next image after pausing
*   [-density geometry]     horizontal and vertical density of the image
*   [-depth value]      image depth
*   [-despeckle]        reduce the speckles within an image
*   [-display server]       get image or font from this X server
*   [-dispose method]       layer disposal method
*   [-dither method]        apply error diffusion to image
*   [-edge radius]      apply a filter to detect edges in the image
*   [-endian type]      endianness (MSB or LSB) of the image
*   [-enhance]      apply a digital filter to enhance a noisy image
*   [-equalize]     perform histogram equalization to an image
*   [-extract geometry]     extract area from image
*   [-filter type]      use this filter when resizing an image
*   [-flatten]      flatten a sequence of images
*   [-flip]     flip image in the vertical direction
*   [-flop]     flop image in the horizontal direction
*   [-frame geometry]       surround image with an ornamental border
*   [-fuzz distance]        colors within this distance are considered equal
*   [-gamma value]      level of gamma correction
*   [-geometry geometry]        preferred size or location of the image
*   [-gravity geometry]     horizontal and vertical backdrop placement
*   [-help]     print program options
*   [-identify]     identify the format and characteristics of the image
*   [-immutable type]       prohibit image edits
*   [-interlace type]       type of image interlacing scheme
*   [-interpolate method]       pixel color interpolation method
*   [-label name]       assign a label to an image
*   [-limit type value]     pixel cache resource limit
*   [-log format]       format of debugging information
*   [-map filename]     transform image colors to match this set of colors
*   [-mattecolor color]     frame color
*   [-monitor]      monitor progress
*   [-monochrome]       transform image to black and white
*   [-negate]       replace each pixel with its complementary color
*   [-normalize]        transform image to span the full range of colors
*   [-page geometry]        size and location of an image canvas (setting)
*   [-profile filename]     add, delete, or apply an image profile
*   [-quantize colorspace]      reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-raise value]      lighten/darken image edges to create a 3-D effect
*   [-regard-warnings]      pay attention to warning messages.
*   [-remote command]       execute a command in an remote display process
*   [-resample geometry]        change the resolution of an image
*   [-resize geometry]      resize the image
*   [-respect-parentheses]      settings remain in effect until parenthesis boundary.
*   [-roll geometry]        roll an image vertically or horizontally
*   [-rotate degrees]       apply Paeth rotation to the image
*   [-sample geometry]      scale image with pixel sampling
*   [-sampling-factor geometry]     horizontal and vertical sampling factor
*   [-scene value]      image scene number
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-segment values]       segment an image
*   [-set attribute value]      set an image attribute
*   [-sharpen geometry]     sharpen the image
*   [-size geometry]        width and height of image
*   [-strip]        strip image of all profiles and comments
*   [-thumbnail geometry]       create a thumbnail of the image
*   [-transparent-color color]      transparent color
*   [-black-threshold value]        force all pixels below the threshold into black
*   [-trim]     trim image edges
*   [-update seconds]       detect when image file is modified and redisplay
*   [-verbose]      print detailed information about the image
*   [-version]      print version information
*   [-virtual-pixel method]     access method for pixels outside the boundaries of the image
*   [-visual]       display image using this visual type
*   [-window id]        display image to background of this window
*   [-window-group id]      exit program when this window id is destroyed
*   [-write filename]       write images to this file

/Image Format and Characteristics
=================================

[Example Usage] • [Option Summary]

The magick identify program describes the format and characteristics of one or more image files. It also reports if an image is incomplete or corrupt. The information returned includes the image number, the file name, the width and height of the image, whether the image is colormapped or not, the number of colors in the image, the number of bytes in the image, the format of the image (JPEG, PNM, etc.), and finally the number of seconds it took to read and process the image. Many more attributes are available with the verbose option. See [Command Line Processing] for advice on how to structure your magick identify command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the magick identify command here to illustrate its usefulness and ease of use. To get started, lets identify an image in the JPEG format:

    $ magick identify rose.jpg
    rose.jpg JPEG 70x46 70x46+0+0 8-bit sRGB 2.36KB 0.000u 0:00.000 

By default, magick identify provides the following output:

Filename[frame #] image-format widthxheight page-widthxpage-height+x-offset+y-offset colorspace user-time elapsed-time

Next, we look at the same image in greater detail:

    $ magick identify -verbose rose.jpg
    Image: rose.jpg
      Format: JPEG (Joint Photographic Experts Group JFIF format)
      Mime type: images/jpeg
      Class: DirectClass
      Geometry: 70x46+0+0
      Units: Undefined
      Type: TrueColor
      Endianness: Undefined
      Colorspace: sRGB
      Depth: 8-bit
      Channel depth:
        Red: 8-bit
        Green: 8-bit
        Blue: 8-bit
      Channel statistics:
        Pixels: 3220
        Red:
          min: 31 (0.121569)
          max: 255 (1)
          mean: 145.557 (0.570814)
          standard deviation: 69.1933 (0.271346)
          kurtosis: -1.38945
          skewness: 0.138955
          entropy: 0.970683
        Green:
          min: 27 (0.105882)
          max: 255 (1)
          mean: 89.246 (0.349984)
          standard deviation: 52.4608 (0.205729)
          kurtosis: 2.60139
          skewness: 1.80708
          entropy: 0.869711
        Blue:
          min: 21 (0.0823529)
          max: 255 (1)
          mean: 80.4196 (0.315371)
          standard deviation: 54.9377 (0.215442)
          kurtosis: 2.93417
          skewness: 1.95544
          entropy: 0.853176
      Image statistics:
        Overall:
          min: 21 (0.0823529)
          max: 255 (1)
          mean: 105.074 (0.412056)
          standard deviation: 58.8639 (0.230839)
          kurtosis: 1.37788
          skewness: 1.48073
          entropy: 0.897856
      Rendering intent: Perceptual
      Gamma: 0.454545
      Chromaticity:
        red primary: (0.64,0.33)
        green primary: (0.3,0.6)
        blue primary: (0.15,0.06)
        white point: (0.3127,0.329)
      Alpha color: grey74
      Background color: white
      Border color: srgb(223,223,223)
      Transparent color: none
      Interlace: None
      Intensity: Undefined
      Compose: Over
      Page geometry: 70x46+0+0
      Dispose: Undefined
      Iterations: 0
      Compression: JPEG
      Quality: 92
      Orientation: Undefined
      Properties:
        jpeg:colorspace: 2
        jpeg:sampling-factor: 1x1,1x1,1x1
        signature: aea65c9b557d779d142f26d04abe7008bab50f1e9647faae20afdcc6c15140d5
      Artifacts:
        verbose: true
      Tainted: False
      Filesize: 2.65KB
      Number pixels: 3.22K
      User time: 0.000u
      Elapsed time: 0:01.000
      Version: ImageMagick 7.0.4-8 Q16 x86_64 https://imagemagick.org 

Note, the image signature is generated from the pixel components, not the image metadata.

To get the print size in inches of an image at 72 DPI, use:

    $ magick identify -format "%[fx:w/72] by %[fx:h/72] inches" document.png
    8.5 x 11 inches 

The depth and dimensions of a raw image must be specified on the command line:

    $ magick identify -depth 8 -size 640x480 image.raw
    image.raw RGB 640x480 sRGB 9kb 0.000u 0:01 

Here we display the image texture features, moments, perceptual hash, and the number of unique colors in the image:

    $ magick identify -verbose -features 1 -moments -unique image.png

To display the convex hull and minimum bounding box attributes of the image, use:

    magick identify -define identify:convex-hull=true image.png

Here is a special define that outputs the location of the minimum or maximum pixel of the image:

magick identify -precision 5 -define identify:locate=maximum -define identify:limit=3 image.png

You can find additional examples of using magick identify in [Examples of ImageMagick Usage].

Option Summary
--------------

The magick identify command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-alpha]

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   [-antialias]       remove pixel-aliasing
*   [-authenticate value]      decrypt image with this password
*   [-auto-orient]     automagically orient image
*   [-channel type]    apply option to select image channels
*   [-clip]    clip along the first path from the 8BIM profile
*   [-clip-mask] filename      associate clip mask with the image
*   [-clip-path id]    clip along a named path from the 8BIM profile
*   [-colorspace type]     set image colorspace
*   [-crop geometry]       crop the image
*   [-debug events]    display copious debugging information
*   [-define format:option]    define one or more image format options
*   [-density geometry]    horizontal and vertical density of the image
*   [-depth value]     image depth
*   [-endian type]     endianness (MSB or LSB) of the image
*   [-extract geometry]    extract area from image
*   [-features distance]

    analyze image features (e.g. contract, correlations, etc.).

*   [-format string]       output formatted image characteristics
*   [-gamma value]     level of gamma correction
*   [-grayscale method]    convert image to grayscale
*   [-help]    print program options
*   [-interlace type]      type of image interlacing scheme
*   [-interpolate method]      pixel color interpolation method
*   [-limit type value]    pixel cache resource limit
*   [-list type]

    Color, Configure, Delegate, Format, Magic, Module, Resource, or Type

*   [-log format]      format of debugging information
*   [-mask filename]       associate a mask with the image
*   [-moments]     display image moments and perceptual hash.
*   [-monitor]     monitor progress
*   [-negate]      replace each pixel with its complementary color
*   [-ping]

    by default, efficiently determine certain image characteristics.

*   [-precision value]

    set the maximum number of significant digits to be printed

*   [-quiet]       suppress all warning messages
*   [-regard-warnings]     pay attention to warning messages.
*   [-respect-parentheses]

    settings remain in effect until parenthesis boundary.

*   [-sampling-factor geometry]    horizontal and vertical sampling factor
*   [-set attribute value]     set an image attribute
*   [-size geometry]       width and height of image
*   [-strip]       strip image of all profiles and comments
*   [-unique]

    display image the number of unique colors in the image.

*   [-units type]      the units of image resolution
*   [-verbose]     print detailed information about the image
*   [-version]     print version information
*   [-virtual-pixel method]

    access method for pixels outside the boundaries of the image

/Screenshot Utility
===================

[Example Usage] • [Option Summary]

Use the import program to capture some or all of an X server screen and save the image to a file. import captures the window selected by clicking or program argument. See [Command Line Processing] for advice on how to structure your import command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the import command here to illustrate its usefulness and ease of use. To get started, lets import an image of an X11 window in the JPEG format:

    magick import rose.jpg 

To capture the entire X server screen in the Postscript image format:

    magick import -window root screen.ps 

You can find additional examples of using import in [Examples of ImageMagick Usage].

Option Summary
--------------

The import command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-adjoin]       join images into a single multi-image file
*   [-annotate geometry text]       annotate the image with text
*   [-border]       include window border in the output image
*   [-channel type]         apply option to select image channels
*   [-colors value]         preferred number of colors in the image
*   [-colorspace type]      set image colorspace
*   [-comment string]       annotate image with comment
*   [-compress type]        image compression type
*   [-contrast]         enhance or reduce the image contrast
*   [-crop geometry]        preferred size and location of the cropped image
*   [-debug events]         import copious debugging information
*   [-define format:option]         define one or more image format options
*   [-delay centiseconds]       import the next image after pausing
*   [-density geometry]         horizontal and vertical density of the image
*   [-depth value]      image depth
*   [-descend]      obtain image by descending window hierarchy
*   [-display server]       get image or font from this X server
*   [-dispose method]       layer disposal method
*   [-dither method]        apply error diffusion to image
*   [-encipher filename]        convert plain pixels to cipher pixels
*   [-encoding type]        text encoding type
*   [-endian type]      endianness (MSB or LSB) of the image
*   [-filter type]      use this filter when resizing an image
*   [-frame]        include window manager frame
*   [-geometry geometry]        preferred size or location of the image
*   [-gravity type]         horizontal and vertical text placement
*   [-help]         print program options
*   [-identify]         identify the format and characteristics of the image
*   [-interlace type]       type of image interlacing scheme
*   [-interpolate method]       pixel color interpolation method
*   [-label name]       assign a label to an image
*   [-limit type value]         pixel cache resource limit
*   [-log format]       format of debugging information
*   [-monitor]      monitor progress
*   [-monochrome]       transform image to black and white
*   [-negate]       replace each pixel with its complementary color
*   [-page geometry]        size and location of an image canvas (setting)
*   [-pause seconds]        seconds delay between snapshots
*   [-quality value]        JPEG/MIFF/PNG compression level
*   [-quantize colorspace]      reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-quiet]        suppress all warning messages
*   [-regard-warnings]      pay attention to warning messages.
*   [-repage geometry]      size and location of an image canvas
*   [-resize geometry]      resize the image
*   [-respect-parentheses]      settings remain in effect until parenthesis boundary.
*   [-rotate degrees]       apply Paeth rotation to the image
*   [-sampling-factor geometry]         horizontal and vertical sampling factor
*   [-scene value]      image scene number
*   [-screen]       select image from root window
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-set attribute value]      set an image attribute
*   [-silent]       operate silently, i.e. don't ring any bells
*   [-strip]        strip image of all profiles and comments
*   [-synchronize]      synchronize image to storage device
*   [-taint]        mark the image as modified
*   [-transparent-color color]      transparent color
*   [-trim]         trim image edges
*   [-type type]        image type
*   [-verbose]      print detailed information about the image
*   [-version]      print version information
*   [-virtual-pixel method]         access method for pixels outside the boundaries of the image
*   [-window id]        select window with this id or name

/Inline Image Modification
==========================

[Example Usage] • [Option Summary]

Use the magick mogrify program to resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more. This tool is similar to [magick] except that the original image file is _overwritten_ (unless you change the file suffix with the [-format] option) with any changes you request. See [Command Line Processing] for advice on how to structure your mogrify command or see below for sample usages of the command.

Example Usage
-------------

We list a few examples of the mogrify command here to illustrate its usefulness and ease of use. To get started, let's reduce the size of our rose:

    magick mogrify -resize 50% rose.jpg

 ![rose](https://imagemagick.org/image/rose.jpg) [==>] ![rose](https://imagemagick.org/image/rose.png)

You can resize all your JPEG images in a folder to a maximum dimension of 256x256 with this command:

    magick mogrify -resize 256x256 *.jpg

Finally, we convert all our PNG images in a folder to the JPEG format:

    magick mogrify -format jpg *.png

Here image files 1.png, 2.png, etc., are left untouched and files 1.jpg, 2.jpg, etc., are created. They are copies of their respective PNG images except are stored in the JPEG image format.

You can find additional examples of using mogrify in [Examples of ImageMagick Usage].

Option Summary
--------------

The mogrify command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-adaptive-blur geometry]

    adaptively blur pixels; decrease effect near edges

*   [-adaptive-resize geometry]

    adaptively resize image with data dependent triangulation.

*   [-adaptive-sharpen geometry]

    adaptively sharpen pixels; increase effect near edges

*   [-adjoin]       join images into a single multi-image file
*   [-affine matrix]        affine transform matrix
*   [-alpha]

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   [-annotate geometry text]       annotate the image with text
*   [-antialias]        remove pixel-aliasing
*   [-append]       append an image sequence
*   [-authenticate value]       decipher image with this password
*   [-auto-gamma]       automagically adjust gamma level of image
*   [-auto-level]       automagically adjust color levels of image
*   [-auto-orient]      automagically orient image
*   [-auto-threshold method]        automatically perform image thresholding
*   [-background color]     background color
*   [-bench iterations]     measure performance
*   [-bias value]       add bias when convolving an image
*   [-bilateral-blur geometry]

    non-linear, edge-preserving, and noise-reducing smoothing filter

*   [-black-threshold value]

    force all pixels below the threshold into black

*   [-blue-primary point]       chromaticity blue primary point
*   [-blue-shift factor]        simulate a scene at nighttime in the moonlight
*   [-blur geometry]        reduce image noise and reduce detail levels
*   [-border geometry]      surround image with a border of color
*   [-bordercolor color]        border color
*   [-brightness-contrast geometry]     improve brightness / contrast of the image
*   [-canny geometry]

    use a multi-stage algorithm to detect a wide range of edges in the image

*   [-caption string]       assign a caption to an image
*   [-cdl filename]     color correct with a color decision list
*   [-channel type]     apply option to select image channels
*   [-charcoal radius]      simulate a charcoal drawing
*   [-chop geometry]        remove pixels from the image interior
*   [-clip]     clip along the first path from the 8BIM profile
*   [-clahe geometry]       contrast limited adaptive histogram equalization
*   [-clamp]

    set each pixel whose value is below zero to zero and any the pixel whose value is above the quantum range to the quantum range (e.g. 65535) otherwise the pixel value remains unchanged.

*   [-clip-mask] filename       associate clip mask with the image
*   [-clip-path id]     clip along a named path from the 8BIM profile
*   [-clut]     apply a color lookup table to the image
*   [-color-threshold start-color-stop-color]

    force all pixels in the color range to white otherwise black

*   [-complexoperator]

    perform complex mathematics on an image sequence

*   [-connected-components connectivity]

    connected-components uniquely labeled, choose from 4 or 8 way connectivity

*   [-contrast-stretch geometry]

    improve the contrast in an image by `stretching' the range of intensity value

*   [-coalesce]     merge a sequence of images
*   [-colorize value]       colorize the image with the fill color
*   [-color-matrix matrix]      apply color correction to the image.
*   [-colors value]     preferred number of colors in the image
*   [-colorspace type]      set image colorspace
*   [-combine]      combine a sequence of images
*   [-comment string]       annotate image with comment
*   [-compose operator]     set image composite operator
*   [-composite]        composite image
*   [-compress type]        image compression type
*   [-contrast]     enhance or reduce the image contrast
*   [-convolve coefficients]

    apply a convolution kernel to the image

*   [-copy geometry offset]

    copy pixels from one area of an image to another

*   [-crop geometry]        crop the image
*   [-cycle amount]     cycle the image colormap
*   [-decipher filename]        convert cipher pixels to plain
*   [-debug events]     display copious debugging information
*   [-define format:option]     define one or more image format options
*   [-deconstruct]

    break down an image sequence into constituent parts

*   [-delay centiseconds]       display the next image after pausing
*   [-delete index]     delete the image from the image sequence
*   [-density geometry]     horizontal and vertical density of the image
*   [-depth value]      image depth
*   [-despeckle]        reduce the speckles within an image
*   [-direction type]       render text right-to-left or left-to-right
*   [-display server]       get image or font from this X server
*   [-dispose method]       layer disposal method
*   [-distort type coefficients]        distort image
*   [-distribute-cache port]        launch a pixel cache server
*   [-dither method]        apply error diffusion to image
*   [-draw string]      annotate the image with a graphic primitive
*   [-duplicate count,indexes]      duplicate an image one or more times
*   [-edge radius]      apply a filter to detect edges in the image
*   [-emboss radius]        emboss an image
*   [-encipher filename]        convert plain pixels to cipher pixels
*   [-encoding type]        text encoding type
*   [-endian type]      endianness (MSB or LSB) of the image
*   [-enhance]      apply a digital filter to enhance a noisy image
*   [-equalize]     perform histogram equalization to an image
*   [-evaluate operator value]

    evaluate an arithmetic, relational, or logical expression

*   [-evaluate-sequence operator]

    evaluate an arithmetic, relational, or logical expression for an image sequence

*   [-extent geometry]      set the image size
*   [-extract geometry]     extract area from image
*   [-family name]      render text with this font family
*   [-features distance]

    analyze image features (e.g. contract, correlations, etc.).

*   [-fft]      implements the discrete Fourier transform (DFT)
*   [-fill color]       color to use when filling a graphic primitive
*   [-filter type]      use this filter when resizing an image
*   [-flatten]      flatten a sequence of images
*   [-flip]     flip image in the vertical direction
*   [-floodfill geometry color]     floodfill the image with color
*   [-flop]     flop image in the horizontal direction
*   [-font name]        render text with this font
*   [-format type]      output formatted image characteristics
*   [-frame geometry]       surround image with an ornamental border
*   [-function name]        apply a function to the image
*   [-fuzz distance]

    colors within this distance are considered equal

*   [-fx expression]

    apply mathematical expression to an image channel(s)

*   [-gamma value]      level of gamma correction
*   [-gaussian-blur geometry]       reduce image noise and reduce detail levels
*   [-geometry geometry]        preferred size or location of the image
*   [-gravity type]     horizontal and vertical text placement
*   [-grayscale method]     convert image to grayscale
*   [-green-primary point]      chromaticity green primary point
*   [-help]     print program options
*   [-hough-lines geometry]     identify lines in the image
*   [-identify]

    identify the format and characteristics of the image

*   [-ifft]

    implements the inverse discrete Fourier transform (DFT)

*   [-illuminant type]      reference illuminant
*   [-implode amount]       implode image pixels about the center
*   [-insert index]     insert last image into the image sequence
*   [-intensity method]

    method to generate an intensity value from a pixel

*   [-integral]

    Calculate the sum of values (pixel values) in the image

*   [-intent type]

    type of rendering intent when managing the image color

*   [-interlace type]       type of image interlacing scheme
*   [-interline-spacing value]      the space between two text lines
*   [-interpolate method]       pixel color interpolation method
*   [-interword-spacing value]      the space between two words
*   [-kerning value]        the space between two characters
*   [-kmeans geometry]      K means color reduction
*   [-kuwahara geometry]        edge preserving noise reduction filter
*   [-label string]     assign a label to an image
*   [-lat geometry]     local adaptive thresholding
*   [-layers method]        optimize or compare image layers
*   [-level value]      adjust the level of image contrast
*   [-limit type value]     pixel cache resource limit
*   [-linear-stretch geometry]      linear with saturation histogram stretch
*   [-liquid-rescale geometry]      rescale image with seam-carving
*   [-log format]       format of debugging information
*   [-loop iterations]

    add Netscape loop extension to your GIF animation

*   [-mattecolor color]     frame color
*   [-median radius]        apply a median filter to the image
*   [-mean-shift geometry]

    delineate arbitrarily shaped clusters in the image

*   [-metric type]

    measure differences between images with this metric

*   [-mode radius]

    make each pixel the 'predominant color' of the neighborhood

*   [-modulate value]       vary the brightness, saturation, and hue
*   [-monitor]      monitor progress
*   [-monochrome]       transform image to black and white
*   [-morph value]      morph an image sequence
*   [-morphology method] kernel     apply a morphology method to the image
*   [-motion-blur geometry]     simulate motion blur
*   [-negate]       replace each pixel with its complementary color
*   [-noise radius]     add or reduce noise in an image
*   [-normalize]        transform image to span the full range of colors
*   [-opaque color]     change this color to the fill color
*   [-ordered-dither NxN]       ordered dither the image
*   [-orient type]      image orientation
*   [-page geometry]        size and location of an image canvas (setting)
*   [-path path]        write images to this path on disk
*   [-paint radius]     simulate an oil painting
*   [-perceptible]

    set each pixel whose value is less than |epsilon| to -epsilon or epsilon (whichever is closer) otherwise the pixel value remains unchanged.

*   [-ping]     efficiently determine image attributes
*   [-pointsize value]      font point size
*   [-polaroid angle]       simulate a Polaroid picture
*   [-poly terms]

    build a polynomial from the image sequence and the corresponding terms (coefficients and degree pairs).

*   [-posterize levels]

    reduce the image to a limited number of color levels

*   [-precision value]

    set the maximum number of significant digits to be printed

*   [-preview type]     image preview type
*   [-print string]     interpret string and print to console
*   [-process image-filter]     process the image with a custom image filter
*   [-profile filename]     add, delete, or apply an image profile
*   [-quality value]        JPEG/MIFF/PNG compression level
*   [-quantize colorspace]      reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-rotational-blur angle]        radial blur the image
*   [-raise value]      lighten/darken image edges to create a 3-D effect
*   [-random-threshold low, high]       random threshold the image
*   [-range-threshold low-black, low-white, high-white, high-black]

    perform either hard or soft thresholding within some range of values in an image

*   [-read-mask filename]       associate a read mask with the image
*   [-red-primary point]        chromaticity red primary point
*   [-regard-warnings]      pay attention to warning messages.
*   [-region geometry]      apply options to a portion of the image
*   [-remap filename]

    transform image colors to match this set of colors

*   [-render]       render vector graphics
*   [-repage geometry]      size and location of an image canvas
*   [-resample geometry]        change the resolution of an image
*   [-resize geometry]      resize the image
*   [-respect-parentheses]

    settings remain in effect until parenthesis boundary.

*   [-roll geometry]        roll an image vertically or horizontally
*   [-rotate degrees]       apply Paeth rotation to the image
*   [-sample geometry]      scale image with pixel sampling
*   [-sampling-factor geometry]     horizontal and vertical sampling factor
*   [-scale geometry]       scale the image
*   [-scene value]      image scene number
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-segment values]       segment an image
*   [-selective-blur geometry]

    selectively blur pixels within a contrast threshold

*   [-separate]     separate an image channel into a grayscale image
*   [-sepia-tone threshold]     simulate a sepia-toned photo
*   [-set attribute value]      set an image attribute
*   [-shade degrees]        shade the image using a distant light source
*   [-shadow geometry]      simulate an image shadow
*   [-sharpen geometry]     sharpen the image
*   [-shave geometry]       shave pixels from the image edges
*   [-shear geometry]       slide one edge of the image along the X or Y axis
*   [-sigmoidal-contrast geometry]

    increase the contrast without saturating highlights or shadows

*   [-size geometry]        width and height of image
*   [-sketch geometry]      simulate a pencil sketch
*   [-smush offset]     smush an image sequence together
*   [-solarize threshold]       negate all pixels above the threshold level
*   [-sort-pixels]

    sorts pixels within each scanline in ascending order of intensity

*   [-splice geometry]      splice the background color into the image
*   [-spread radius]        displace image pixels by a random amount
*   [-statistic type geometry]

    replace each pixel with corresponding statistic from the neighborhood

*   [-strip]        strip image of all profiles and comments
*   [-stroke color]     graphic primitive stroke color
*   [-strokewidth value]        graphic primitive stroke width
*   [-stretch type]     render text with this font stretch
*   [-style type]       render text with this font style
*   [-swap indexes]     swap two images in the image sequence
*   [-swirl degrees]        swirl image pixels about the center
*   [-synchronize]      synchronize image to storage device
*   [-texture filename]     name of texture to tile onto the image background
*   [-threshold value]      threshold the image
*   [-thumbnail geometry]       create a thumbnail of the image
*   [-tile filename]        tile image when filling a graphic primitive
*   [-tile-offset geometry]     set the image tile offset
*   [-tint value]       tint the image with the fill color
*   [-transform]        affine transform image
*   [-transparent color]        make this color transparent within the image
*   [-transparent-color color]      transparent color
*   [-transpose]

    flip image in the vertical direction and rotate 90 degrees

*   [-transverse]

    flop image in the horizontal direction and rotate 270 degrees

*   [-treedepth value]      color tree depth
*   [-trim]     trim image edges
*   [-type type]        image type
*   [-undercolor color]     annotation bounding box color
*   [-unique-colors]        discard all but one of any pixel color.
*   [-units type]       the units of image resolution
*   [-unsharp geometry]     sharpen the image
*   [-verbose]      print detailed information about the image
*   [-version]      print version information
*   [-view]     FlashPix viewing transforms
*   [-vignette geometry]        soften the edges of the image in vignette style
*   [-virtual-pixel method]

    access method for pixels outside the boundaries of the image

*   [-wave geometry]        alter an image along a sine wave
*   [-wavelet-denoise threshold]        removes noise from the image using a wavelet transform
*   [-weight type]      render text with this font weight
*   [-white-point point]        chromaticity white point
*   [-white-threshold value]        force all pixels above the threshold into white
*   [-word-break type]

    sets whether line breaks appear wherever the text would otherwise overflow its content box. Choose from normal, the default, or break-word.

*   [-write filename]       write images to this file
*   [-write-mask filename]      associate a write mask with the image


/Juxtapose Image Thumbnails on a Canvas
=======================================

[Example Usage] • [Option Summary]

Use the montage program to create a composite image by combining several separate images. The images are tiled on the composite image optionally adorned with a border, frame, image name, and more. See [Command Line Processing] for advice on how to structure your montage command or see below for example usages of the command.

Example Usage
-------------

We list a few examples of the montage command here to illustrate its usefulness and ease of use. To get started, let's montage two images into a single composite:

    magick montage -background '#336699' -geometry +4+4 rose.jpg red-ball.png montage.jpg 

  ![rose](https://imagemagick.org/image/rose.jpg) ![red ball](https://imagemagick.org/image/red-ball.png) [==>]  ![montage](https://imagemagick.org/image/montage.jpg)

Ok, let's add some decorations:

    magick montage -label %f -frame 5 -background '#336699' -geometry +4+4 rose.jpg red-ball.png frame.jpg 

  ![rose.jpg](https://imagemagick.org/image/rose.jpg) ![red ball](https://imagemagick.org/image/red-ball.png) [==>]  ![frame](https://imagemagick.org/image/frame.jpg)

You can find additional examples of using montage at [Examples of ImageMagick Usage] and [Examples of ImageMagick Usage].

#### Ashlar Pseudo-image Format

Use the Ashlar pseudo-image format to lay out an image sequence in continuous irregular courses. By default, a reasonable canvas size and border width is determined relative to the image collection you provide. You can explicitedly set the canvas size and border width by appending to the filename, e.g. ashlar:canvas.png[1024x768+4+4]. By default, alignment is along the left edge. Use -define ashlar:best-fit=true to align on both the left and right edges. You can label the image tiles with, for example, -label %f. Here is an example command:

    magick '*.png' -resize 320x320 -label %f ashlar:ashlar.png

This is designed to quickly view a collection of images. To have more control over the layout of your image tiles, use the montage command instead.

Option Summary
--------------

The montage command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-adaptive-sharpen geometry]

    adaptively sharpen pixels; increase effect near edges

*   [-adjoin]       join images into a single multi-image file
*   [-affine matrix]        affine transform matrix
*   [-alpha]

    on, activate, off, deactivate, set, opaque, copy", transparent, extract, background, or shape the alpha channel

*   [-annotate geometry text]       annotate the image with text
*   [-authenticate value]       decrypt image with this password
*   [-auto-orient]      automagically orient image
*   [-background color]     background color
*   [-blue-primary point]       chromaticity blue primary point
*   [-blur geometry]        reduce image noise and reduce detail levels
*   [-border geometry]      surround image with a border of color
*   [-bordercolor color]        border color
*   [-caption string]       assign a caption to an image
*   [-channel type]     apply option to select image channels
*   [-clone index]      clone an image
*   [-coalesce]     merge a sequence of images
*   [-colors value]     preferred number of colors in the image
*   [-colorspace type]      set image colorspace
*   [-comment string]       annotate image with comment
*   [-compose operator]     set image composite operator
*   [-composite]        composite image
*   [-compress type]        image compression type
*   [-crop geometry]        preferred size and location of the cropped image
*   [-debug events]     display copious debugging information
*   [-define format:option]     define one or more image format options
*   [-delay centiseconds]       display the next image after pausing
*   [-density geometry]     horizontal and vertical density of the image
*   [-depth value]      image depth
*   [-display server]       get image or font from this X server
*   [-dispose method]       layer disposal method
*   [-distort type coefficients]        distort image
*   [-dither method]        apply error diffusion to image
*   [-draw string]      annotate the image with a graphic primitive
*   [-duplicate count,indexes]      duplicate an image one or more times
*   [-endian type]      endianness (MSB or LSB) of the image
*   [-extent geometry]      set the image size
*   [-extract geometry]     extract area from image
*   [-family name]      render text with this font family
*   [-fill color]       color to use when filling a graphic primitive
*   [-filter type]      use this filter when resizing an image
*   [-flatten]      flatten a sequence of images
*   [-flip]     flip image in the vertical direction
*   [-flop]     flop image in the horizontal direction
*   [-font name]        render text with this font
*   [-frame geometry]       surround image with an ornamental border
*   [-gamma value]      level of gamma correction
*   [-geometry geometry]        preferred size or location of the image
*   [-gravity type]     horizontal and vertical text placement
*   [-green-primary point]      chromaticity green primary point
*   [-help]     print program options
*   [-identify]     identify the format and characteristics of the image
*   [-interlace type]       type of image interlacing scheme
*   [-interpolate method]       pixel color interpolation method
*   [-kerning value]        the space between two characters
*   [-label string]     assign a label to an image
*   [-limit type value]     pixel cache resource limit
*   [-log format]       format of debugging information
*   [-mattecolor color]     frame color
*   [-mode type]        framing style
*   [-monitor]      monitor progress
*   [-monochrome]       transform image to black and white
*   [-origin geometry]      image origin
*   [-page geometry]        size and location of an image canvas (setting)
*   [-pointsize value]      font point size
*   [-polaroid angle]       simulate a Polaroid picture
*   [-profile filename]     add, delete, or apply an image profile
*   [-quality value]        JPEG/MIFF/PNG compression level
*   [-quantize colorspace]      reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-red-primary point]        chromaticity red primary point
*   [-regard-warnings]      pay attention to warning messages.
*   [-repage geometry]      size and location of an image canvas
*   [-resize geometry]      resize the image
*   [-respect-parentheses]      settings remain in effect until parenthesis boundary.
*   [-rotate degrees]       apply Paeth rotation to the image
*   [-sampling-factor geometry]     horizontal and vertical sampling factor
*   [-scale geometry]       scale the image
*   [-scenes range]     image scene range
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-shadow geometry]      simulate an image shadow
*   [-size geometry]        width and height of image
*   [-strip]        strip image of all profiles and comments
*   [-stroke color]     graphic primitive stroke color
*   [-synchronize]      synchronize image to storage device
*   [-taint]        mark the image as modified
*   [-texture filename]     name of texture to tile onto the image background
*   [-tile geometry]        number of tiles per row and column (e.g. -tile 8x)
*   [-tile-offset geometry]     set the image tile offset
*   [-title]        decorate the montage image with a title
*   [-transform]        affine transform image
*   [-transparent color]        make this color transparent within the image
*   [-transpose]

    flip image in the vertical direction and rotate 90 degrees

*   [-transparent-color color]      transparent color
*   [-treedepth value]      color tree depth
*   [-trim]     trim image edges
*   [-type type]        image type
*   [-units type]       the units of image resolution
*   [-unsharp geometry]     sharpen the image
*   [-verbose]      print detailed information about the image
*   [-version]      print version information
*   [-view]     FlashPix viewing transforms
*   [-virtual-pixel method]

    access method for pixels outside the boundaries of the image

*   [-white-point point]        chromaticity white point

/Streaming Interface
====================

[Example Usage] • [Option Summary]

Stream is a lightweight tool to stream one or more pixel components of the image or portion of the image to your choice of storage formats. It writes the pixel components as they are read from the input image a row at a time making stream desirable when working with large images or when you require raw pixel components.

Example Usage
-------------

We list a few examples of the stream command here to illustrate its usefulness and ease of use. To get started, lets stream the red, green, blue components of a 640x480 JPEG image to disk as unsigned characters:

    magick stream -map rgb -storage-type char image.jpg pixels.dat
    magick display -depth 8 -size 640x480 rgb:pixels.dat

Here we extract a 100x100 region from a TIFF image in the grayscale format as doubles:

    magick stream -map i -storage-type double -extract 100x100+30+40 image.tif gray.raw

You can also associate the region to extract with the image filename:

    magick stream -map i -storage-type double 'image.tif[100x100+30+40]' gray.raw

Streaming requires that the image coder read the image pixels in row order. Not all formats adhere to this requirement. Verify a particular image format first, before you utilize streaming in your workflow.

Option Summary
--------------

The stream command recognizes these options. Click on an option to get more details about how that option works.

Option Description

*   [-authenticate value]       decrypt image with this password
*   [-channel type]     apply option to select image channels
*   [-colorspace type]      set image colorspace
*   [-debug events]     display copious debugging information
*   [-define format:option]     define one or more image format options
*   [-density geometry]     horizontal and vertical density of the image
*   [-depth value]      image depth
*   [-extract geometry]     extract area from image
*   [-help]     print program options
*   [-interlace type]       type of image interlacing scheme
*   [-interpolate method]       pixel color interpolation method
*   [-limit type value]     pixel cache resource limit
*   [-list type]

    Color, Configure, Delegate, Format, Magic, Module, Resource, or Type

*   [-log format]       format of debugging information
*   [-map components]       store pixels in this format.
*   [-monitor]      monitor progress
*   [-quantize colorspace]      reduce image colors in this colorspace
*   [-quiet]        suppress all warning messages
*   [-regard-warnings]      pay attention to warning messages.
*   [-respect-parentheses]      settings remain in effect until parenthesis boundary.
*   [-sampling-factor geometry]     horizontal and vertical sampling factor
*   [-seed value]       seed a new sequence of pseudo-random numbers
*   [-set attribute value]      set an image attribute
*   [-size geometry]        width and height of image
*   [-storage-type type]        store pixels with this storage type.
*   [-synchronize]      synchronize image to storage device
*   [-taint]        mark the image as modified
*   [-transparent-color color]      transparent color
*   [-verbose]      print detailed information about the image
*   [-version]      print version information
*   [-virtual-pixel method]

    access method for pixels outside the boundaries of the image

/MagickCache: an Efficient Image Cache
======================================

The Magick cache is a work in progress. Do not use the cache in production services until version is at least 1.0.0. It is currently 0.9.2. The MagickCache requires ImageMagick version 7.1.0-0 or above.

The MagickCache provides secure methods and tools to cache images, image sequences, video, audio or metadata in a local folder. Any content is memory-mapped for efficient retrieval. Additional efficiencies are possible by retrieving a portion of an image. Content can persist or you can assign a time-to-live (TTL) to automatically expire content when the TTL is exceeded. MagickCache supports virtually unlimited content upwards of billions of images making it suitable as a web image service.

The MagickCache works in concert with [ImageMagick]. Download the [MagickCache](https://github.com/ImageMagick/MagickCache) and install. You will now want to create the cache and populate it with images, video, and associated metadata.

#### Create a MagickCache

You will require a place to store and retrieve your content. Let's create a cache on our local filesystem:

    $ magick-cache -passkey passkey.txt create /opt/magick-cache

Where `passkey.txt` contains your cache passkey. Don't lose your passkey. Without it, you will be unable to identify, expire, or delete content in your cache.

You only need to create a MagickCache once. You can, however, create more than one MagickCache with different paths.

Once the MagickCache is created, you will want to populate the cache with content that includes images, video, audio, or metadata.

#### Put content in the MagickCache

Let's add a movie cast image to our newly created cache:

    $ magick-cache put /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson 20210508-rebecca-ferguson.jpg

Note, the image identifier is an IRI composed of _project_/_type_/_resource-path_. In this example, the project is movies, type is image, and the resource path is mission-impossible/cast/rebecca-ferguson. The path uniquely identifies a cache resource. Two different images cannot be stored with the same resource path. Instead use something like mission-impossible/cast/20210508-rebecca-ferguson-1 and mission-impossible/cast/20210508-rebecca-ferguson-2.

Now, let's set a resource passkey and the time to live to 2 days. Anytime after the second day, the image is automatically deleted with the expire function. To get, expire, or delete the image, you will need to use the same resource passkey:

    $ magick-cache -passkey passkey.txt -ttl "2 days" put /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson 20210508-rebecca-ferguson.jpg

Where passkey.txt contains your resource passkey. Don't lose your passkey. Without it, you will be unable to get, identify, expire or delete resources you own.

The resource passkey ensures only you and the cache owner can access your image. To prevent the cache owner from viewing its content, scramble it with:

    $ magick-cache -passkey passkey.txt -passphrase passphrase.txt -ttl "2 days" put /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson 20210508-rebecca-ferguson.jpg

Note, blobs and metadata are stored in the cache in plaintext. To prevent snooping, scramble the content before you store it in the cache.

#### Get content from the MagickCache

Eventually you will want retrieve your content, let's get our original cast image from the cache:

    $ magick-cache -passkey passkey.txt get /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson rebecca-ferguson.png

Notice the original image was put in the cache in the JPEG format. Here we conveniently convert it to the PNG format as we extract the image.

The -extract option is useful when retrieving an image. To extract a portion of the image, specify tile width, height, and offset:

    $ magick-cache -passkey passkey.txt -extract 100x100+0+0 get /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson rebecca-ferguson.png

To resize instead, do not specify the offset:

    $ magick-cache -passkey passkey.txt -extract 100x100 get /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson rebecca-ferguson.png

If your image is scrambled, provide the passphrase to descramble it:

    $ magick-cache -passkey passkey.txt -passphrase passphrase.txt get /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson rebecca-ferguson.png

#### Delete content from the MagickCache

We can explicitly delete content:

    $ magick-cache -passkey passkey.txt delete /opt/magick-cache movies/images/mission-impossible/cast/rebecca-ferguson

or we can delete all cast images that have expired (exceeded their respective time to live), try this comand:

    $ magick-cache -passkey passkey.txt expire /opt/magick-cache movies/images/mission-impossible/cast

#### Identify the MagickCache content

Perhaps you want to identify all the content you own:

    $ magick-cache -passkey passkey.txt identify /opt/magick-cache movies/images/mission-impossible/cast
    movies/images/mission-impossible/cast/rebecca-ferguson[1368x912] 406B 1:0:0:0 2021-05-30T17:41:42Z
    identified 1 resources

Each entry includes the IRI, image dimensions for images, the content extent in bytes, time to live, whether the resource is expired (denoted with a `*`), and the creation date.

Others can store content in the cache along side your content. However, their content is unavailable to you. You cannot get, identify, expire or delete content that you do not own as determined by your secret passkey.

The MagickCache owner can get, identify, expire, or delete all the content, including content you own, with this command, for example:

    $ magick-cache -passkey passkey.txt identify /opt/magick-cache /

Note, expired reesources are annotated with an asterisks.

#### MagickCache is not just for Images

In addition to a type of image, you can store the image content in its original form, video, or audio as content type of blob or metadata with a content type of meta:

    $ magick-cache -passkey passkey.txt put /opt/magick-cache movies/blob/mission-impossible/cast/rebecca-ferguson 20210508-rebecca-ferguson.mp4

or

    $ magick-cache -passkey passkey.txt put /opt/magick-cache movies/meta/mission-impossible/cast/rebecca-ferguson 20210508-rebecca-ferguson.txt

Images must be in a format that ImageMagick understands. Metadata must be text. Blobs can be any content including images, video, audio, or binary files.

#### Delete a MagickCache

The MagickCache owner can completely delete all the content within a cache:

    $ magick-cache -passkey passkey.txt delete /opt/magick-cache /

Be careful, after this command, your cached content is irrevocably lost.

#### Security

MagickCache security is not crytographically strong. Instead it generates a unique hash for each resource ensuring the resource ID cannot be discovered. A resource is accessible to both the user of the cache and the cache owner provided they can present their respective passkeys. They are also accessible to anyone with sufficient privileges to access the MagickCache disk path.

/Develop
========

The functionality of ImageMagick is typically utilized from the [command-line] or you can use the features from programs written in your favorite language. Choose from these interfaces: [G2F] (Ada), [MagickCore] (C), [MagickWand] (C), [ChMagick] (Ch), [Magick++] (C++), [JMagick] (Java), [WASM-ImageMagick] (Javawww/Typescript), [JuliaIO] (Julia), [KMagick] (Kotlin), [L-Magick] (Lisp), [Lua] (LuaJIT), [NMagick] (Neko/haXe), [Magick.NET] (.NET), [PascalMagick] (Pascal), [PerlMagick] (Perl), [IMagick] (PHP), [PythonMagick] (Python), [magick] (R), [RMagick] (Ruby), [TclMagick] (Tcl/TK), or [WASM]. With a language interface, use ImageMagick to modify or create images dynamically and automagically.

Choose from these language interfaces:

C

Use the thread-safe [MagickWand] library to convert, compose, and edit images from the C language. There is also the low-level thread-safe [MagickCore] library for wizard-level developers. The [MagickCache API] is a development library to utilize an efficient [image cache](https://github.com/ImageMagick/MagickCache#readme).

Ch

[ChMagick] is a [Ch](http://www.softintegration.com/) binding to the MagickCore and MagickWand API. Ch is an embeddable C/C++ interpreter for cross-platform scripting.

C++

[Magick++] provides a thread-safe object-oriented C++ interface to ImageMagick. See [A Gentle Introduction to Magick++] for an introductory tutorial to Magick++. We include the [source] if you want to correct, enhance, or expand the tutorial.

GO

[GoImagick](https://github.com/gographics/imagick) is a set of Go bindings to ImageMagick's MagickWand and MagickCore C APIs.

Java

[JMagick](http://www.jmagick.org) provides an object-oriented Java interface to ImageMagick. [Im4java](http://im4java.sourceforge.net) is a pure-java interface to the ImageMagick command-line.

Javawww/TypeScript

[WASM-ImageMagick](https://github.com/KnicKnic/WASM-ImageMagick) Webassembly compiliation of ImageMagick that allows serverless clientside bindings for Typescript and Javascript. Works in Progressive Web Apps.

Julia

[JuliaIO](https://github.com/JuliaIO/ImageMagick.jl) provides an object-oriented Julia interface to ImageMagick.

KMagick

[KMagick](https://github.com/MolotovCherry/kmagick) provides Kotlin bindings to ImageMagick.

LabVIEW

[LVOOP ImageMagick](http://forums.lavag.org/downloads-file90.html) is an object-oriented LabVIEW interface to ImageMagick.

Lisp

[CL-Magick](http://common-lisp.net/project/cl-magick/) provides a Common Lisp interface to the ImageMagick library.

Lua

[Lua](https://github.com/leafo/magick) bindings to ImageMagick for LuaJIT using FFI.

[Lua](https://github.com/isage/lua-imagick) bindings to ImageMagick for Lua using pure-C.

Neko

[NMagick](http://code.google.com/p/nmagick) is a port of the ImageMagick library to the haXe and Neko platforms. It provides image manipulation capabilities to both web and desktop applications using Neko.

.NET

Use [Magick.NET](https://github.com/dlemstra/Magick.NET) to convert, compose, and edit images from Windows .NET.

[ImageMagickApp](http://sourceforge.net/projects/imagemagickapp/) is a .NET application written in C# that utilizes the ImageMagick command line to allow conversion of multiple image formats to different formats.

Pascal

[PascalMagick](http://wiki.freepascal.org/PascalMagick) a Pascal binding for the MagickWand API and also the low-level MagickCore library. It works with Free Pascal / Lazarus and Delphi.

Perl

Use [PerlMagick] to convert, compose, and edit images from the Perl language.

PHP

[IMagick](http://pecl.html.net/package/imagick) is a native PHP extension to create and modify images using the ImageMagick API. Documentation for the extension is available [here](http://php.net/imagick), and a site showing examples is available at [PHPImagick.com](https://phpimagick.com).

[phMagick](https://github.com/francodacosta/phmagick) is a wrapper class for ImageMagick, wrapping the most common web image manipulation actions in easy to use functions, but allowing full access to ImageMagick's power by issuing system calls to it's command-line programs.

Python

[Wand](http://wand-py.org/) is a ctypes-based ImagedMagick binding library for Python.

[PythonMagick](https://imagemagick.org/archive/python/) is an object-oriented Python interface to ImageMagick.

[PythonMagickWand](http://www.assembla.com/wiki/show/pythonmagickwand) is an object-oriented Python interface to MagickWand based on ctypes.

[Scilab Image Processing](http://siptoolbox.sourceforge.net/) toolbox utilizes ImageMagick to do imaging tasks such as filtering, blurring, edge detection, thresholding, histogram manipulation, segmentation, mathematical morphology, color image processing, etc..

REALbasic

The [MBS Realbasic ImageMagick](http://www.monkeybreadsoftware.de/realbasic/plugin-imagemagick.shtml) is a plugin that utilizes the power of ImageMagick from within the RealBasic environment.

R

The [magick](https://cran.r-project.org/package=magick) package wraps the Magick++ STL to provide vectorized image processing in R. Get started with using the package [vignette](https://cran.r-project.org/web/packages/magick/vignettes/intro.html).

Ruby

[RMagick](https://rmagick.github.io/) is an interface between the Ruby programming language and the [MagickCore] image processing libraries. Get started with RMagick by perusing the [documentation](https://rmagick.github.io/).

[MagickWand for Ruby](http://magickwand.rubyforge.org/) is an interface between the Ruby programming language and the [MagickWand] image processing libraries. Get started with MagickWand for PHP by perusing the [documentation](http://magickwand.rubyforge.org/).

[MiniMagick](https://github.com/minimagick) is a Ruby wrapper for ImageMagick command line. MiniMagick gives you convenient access to all the command line options ImageMagick supports.

[QuickMagick](http://quickmagick.rubyforge.org/quick_magick) is a gem for easily accessing ImageMagick command line tools from Ruby programs.

Rust

[MagickRust](https://github.com/nlfiedler/magick-rust) is a MagickWand bindings for the Rust language.

Tcl/Tk

[TclMagick](http://tclmagick.sourceforge.net/) a native Tcl-extension to the ImageMagick MagickWand API.

WebAssembly

[Magick.WASM](https://github.com/dlemstra/Magick.WASM) the WASM library for ImageMagick.

XML RPC

[RemoteMagick](http://code.google.com/p/remotemagick/) is an XML-RPC web service that creates image thumbnails.


/MagickCore Image API for C
===========================

The [MagickCore API] is a low-level interface between the C programming language and the ImageMagick image processing libraries and is recommended for wizard-level programmers only. Unlike the [MagickWand] C API which uses only a few opaque types and accessors, with MagickCore you almost exclusively access the structure members directly. A description of the MagickCore public methods are found here:

*   [Initialize or Destroy the ImageMagick Environment]
*   [Constitute an Image]
*   [Composite an Image]
*   [Image Methods]
*   [Image Channel Methods]
*   [Count the Colors in an Image]
*   [Colormap Methods]
*   [Colorspace Methods]
*   [Image Distortions]
*   [Dealing with Image Layers]
*   [Dealing with Image Profiles]
*   [Reduce the Number of Unique Colors in an Image]
*   [Image Histograms]
*   [Segment an Image with Thresholding Fuzzy c-Means]
*   [Resize an Image]
*   [Transform an Image]
*   [Shear or Rotate an Image by an Arbitrary Angle]
*   [Enhance an Image]
*   [Add an Effect]
*   [Morphological Erosions, Dilations, Openings, and Closings]
*   [Add a Special Effect]
*   [Decorate an Image]
*   [Get/Set an Image Attribute]
*   [Get/Set Image Properties]
*   [Get Image Statistics]
*   [Get Image Features]
*   [Annotate an Image]
*   [Paint on an Image]
*   [Draw on an Image]
*   [Create an Image Thumbnail]
*   [Compute the discrete Fourier transform (DFT)]
*   [Compare an Image to a Reconstructed Image]
*   [Computer Vision]
*   [Interactively Display and Edit an Image]
*   [Interactively Animate an Image Sequence]
*   [Convert to and from Cipher Pixels]
*   [Working with Image Lists]
*   [Image View Methods]
*   [Image Cache Methods]
*   [Get or Set Image Pixels]
*   [Working with Cache Views]
*   [The Pixel FIFO]
*   [Read or Write Binary Large OBjects]
*   [Loadable Modules]
*   [Compute a Message Digest for an Image]
*   [The Image Registry]
*   [Dealing with Exceptions]
*   [Memory Allocation]
*   [Monitor or Limit Resource Consumption]
*   [Monitor the Progress of an Image Operation]
*   [Get the Version and Copyrights]
*   [Mime Methods]
*   [Deprecated Methods]
*   [Error and Warning Codes]

After you write your MagickCore program, compile it like this:

    cc -o core core.c `pkg-config --cflags --libs MagickWand`

Set the PKG_CONFIG_PATH environment variable if ImageMagick is not in your default system path:

    export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig 

Here is a example program that utilizes the MagickCore API to get you started, [core.c](https://imagemagick.org/source/core.c). It reads a GIF image, creates a thumbnail, and writes it to disk in the PNG image format.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <MagickCore/MagickCore.h>

int main(int argc,char **argv)
{
  ExceptionInfo
    *exception;

  Image
    *image,
    *images,
    *resize_image,
    *thumbnails;

  ImageInfo
    *image_info;

  if (argc != 3)
    {
      (void) fprintf(stdout,"Usage: %s image thumbnail\n",argv[0]);
      exit(0);
    }
  /*
    Initialize the image info structure and read an image.
  */
  MagickCoreGenesis(*argv,MagickTrue);
  exception=AcquireExceptionInfo();
  image_info=CloneImageInfo((ImageInfo *) NULL);
  (void) strcpy(image_info->filename,argv[1]);
  images=ReadImage(image_info,exception);
  if (exception->severity != UndefinedException)
    CatchException(exception);
  if (images == (Image *) NULL)
    exit(1);
  /*
    Convert the image to a thumbnail.
  */
  thumbnails=NewImageList();
  while ((image=RemoveFirstImageFromList(&images)) != (Image *) NULL)
  {
    resize_image=ResizeImage(image,106,80,LanczosFilter,exception);
    if (resize_image == (Image *) NULL)
      MagickError(exception->severity,exception->reason,exception->description);
    (void) AppendImageToList(&thumbnails,resize_image);
    DestroyImage(image);
  }
  /*
    Write the image thumbnail.
  */
  (void) strcpy(thumbnails->filename,argv[2]);
  WriteImage(image_info,thumbnails,exception);
  /*
    Destroy the image thumbnail and exit.
  */
  thumbnails=DestroyImageList(thumbnails);
  image_info=DestroyImageInfo(image_info);
  exception=DestroyExceptionInfo(exception);
  MagickCoreTerminus();
  return(0);
}
```

Now lets perform the same contrast enhancement while taking advantage of our dual or quad-core processing system by running the algorithm in parallel utilizing wand views. The [sigmoidal-contrast.c](https://imagemagick.org/source/core/sigmoidal-contrast.c) module reads an image, applies sigmoidal non-linearity contrast control, and writes the result to disk just like the previous contrast enhancement program, but now it does its work in parallel (assumes ImageMagick is built with OpenMP support).

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <MagickCore/MagickCore.h>

static MagickBooleanType SigmoidalContrast(ImageView *contrast_view,
  const ssize_t y,const int id,void *context)
{
#define QuantumScale  ((MagickRealType) 1.0/(MagickRealType) QuantumRange)
#define SigmoidalContrast(x) \
  (QuantumRange*(1.0/(1+exp(10.0*(0.5-QuantumScale*x)))-0.0066928509)*1.0092503)

  RectangleInfo
    extent;

  register IndexPacket
    *indexes;

  register PixelPacket
    *pixels;

  register ssize_t
    x;

  extent=GetImageViewExtent(contrast_view);
  pixels=GetImageViewAuthenticPixels(contrast_view);
  for (x=0; x < (ssize_t) (extent.width-extent.x); x++)
  {
    SetPixelRed(pixels, RoundToQuantum(SigmoidalContrast(GetPixelRed(pixels))));
    SetPixelGreen(pixels, RoundToQuantum(SigmoidalContrast(GetPixelGreen(pixels))));
    SetPixelBlue(pixels, RoundToQuantum(SigmoidalContrast(GetPixelBlue(pixels))));
    SetPixelOpacity(pixels, RoundToQuantum(SigmoidalContrast(GetPixelOpacity(pixels))));
    pixels++;
  }
  indexes=GetImageViewAuthenticIndexes(contrast_view);
  if (indexes != (IndexPacket *) NULL)
    for (x=0; x < (ssize_t) (extent.width-extent.x); x++)
      SetPixelIndex(indexes+x,RoundToQuantum(SigmoidalContrast(GetPixelIndex(indexes+x))));
  return(MagickTrue);
}

int main(int argc,char **argv)
{
#define ThrowImageException(image) \
{ \
 \
  CatchException(exception); \
  if (contrast_image != (Image *) NULL) \
    contrast_image=DestroyImage(contrast_image); \
  exit(-1); \
}
#define ThrowViewException(view) \
{ \
  char \
    *description; \
 \
  ExceptionType \
    severity; \
 \
  description=GetImageViewException(view,&severity); \
  (void) fprintf(stderr,"%s %s %lu %s\n",GetMagickModule(),description); \
  description=DestroyString(description); \
  exit(-1); \
}

  ExceptionInfo
    *exception;

  Image
    *contrast_image;

  ImageInfo
    *image_info;

  ImageView
    *contrast_view;

  MagickBooleanType
    status;

  if (argc != 3)
    {
      (void) fprintf(stdout,"Usage: %s image sigmoidal-image\n",argv[0]);
      exit(0);
    }
  /*
    Read an image.
  */
  MagickCoreGenesis(*argv,MagickTrue);
  image_info=AcquireImageInfo();
  (void) CopyMagickString(image_info->filename,argv[1],MaxTextExtent);
  exception=AcquireExceptionInfo();
  contrast_image=ReadImage(image_info,exception);
  if (contrast_image == (Image *) NULL)
    ThrowImageException(contrast_image);
  /*
    Sigmoidal non-linearity contrast control.
  */
  contrast_view=NewImageView(contrast_image);
  if (contrast_view == (ImageView *) NULL)
    ThrowImageException(contrast_image);
  status=UpdateImageViewIterator(contrast_view,SigmoidalContrast,(void *) NULL);
  if (status == MagickFalse)
    ThrowImageException(contrast_image);
  contrast_view=DestroyImageView(contrast_view);
  /*
    Write the image then destroy it.
  */
  status=WriteImages(image_info,contrast_image,argv[2],exception);
  if (status == MagickFalse)
    ThrowImageException(contrast_image);
  contrast_image=DestroyImage(contrast_image);
  exception=DestroyExceptionInfo(exception);
  image_info=DestroyImageInfo(image_info);
  MagickCoreTerminus();
  return(0);
}
```

/PerlMagick Image API for Perl
==============================

[Installation] • [Overview] • [Example Script] • [Read or Write an Image] • [Manipulate an Image] • [Set an Image Attribute] • [Get an Image Attribute] • [Compare an Image to its Reconstruction] • [Create an Image Montage] • [Working with Blobs] • [Direct-access to Image Pixels] • [Miscellaneous Methods] • [Handling Exceptions]• [Constant]

[PerlMagick] is an objected-oriented [Perl](http://www.perl.com/perl/) interface to ImageMagick. Use the module to read, manipulate, or write an image or image sequence from within a Perl script. This makes it very suitable for Web CGI scripts. You must have ImageMagick 6.5.5 or above and Perl version 5.005_02 or greater installed on your system for PerlMagick to build properly.

There are a number of useful scripts available to show you the value of PerlMagick. You can do Web based image manipulation and conversion with [MagickStudio](https://imagemagick.org/archive/perl), or use [L-systems](https://github.com/ImageMagick/ImageMagick/tree/main/PerlMagick/demo/tree.pl) to create images of plants using mathematical constructs, and finally navigate through collections of thumbnail images and select the image to view with the [WebMagick Image Navigator](http://webmagick.sourceforge.net/).

You can try PerlMagick from your Web browser at the [ImageMagick Studio]. Or, you can see [examples] of select PerlMagick functions.

Installation
------------

**UNIX**

Is PerlMagick available from your system RPM repository? For example, on our CentOS system, we install PerlMagick thusly:

    yum install ImageMagick-perl

If not, you must install PerlMagick from the ImageMagick source distribution. Download the latest [source](https://imagemagick.org/archive/ImageMagick.tar.gz) release.

Unpack the distribution with this command:

    tar xvzf ImageMagick.tar.gz

Next configure and compile ImageMagick:

    $ cd ImageMagick-7.1.0$ ./configure -with-perl$ make

If ImageMagick / PerlMagick configured and compiled without complaint, you are ready to install it on your system. Administrator privileges are required to install. To install, type

    sudo make install

You may need to configure the dynamic linker run-time bindings:

    sudo ldconfig /usr/local/lib

Finally, verify the PerlMagick install worked properly, type

    perl -MImage::Magick -le 'print Image::Magick->QuantumDepth'

Congratulations, you have a working ImageMagick distribution and you are ready to use PerlMagick to [convert, compose, or edit] your images.

**Windows XP / Windows 2000**

ImageMagick must already be installed on your system. Also, the ImageMagick source distribution for [Windows 2000] is required. You must also have the nmake from the Visual C++ or J++ development environment. Copy \bin\IMagick.dll and \bin\X11.dll to a directory in your dynamic load path such as c:\perl\site\5.00502.

Next, type

    cd PerlMagick
    perl Makefile.nt
    nmake
    nmake install

**Running the Regression Tests**

To verify a correct installation, type

    make test

Use nmake test under Windows. There are a few demonstration scripts available to exercise many of the functions PerlMagick can perform. Type

    cd demo
    make

You are now ready to utilize the PerlMagick methods from within your Perl scripts.

Overview
--------

Any script that wants to use PerlMagick methods must first define the methods within its namespace and instantiate an image object. Do this with:

use Image::Magick;

    $image = Image::Magick->new;

PerlMagick is quantum aware. You can request a specific quantum depth when you instantiate an image object:

    use Image::Magick::Q16;

    $image = Image::Magick::Q16->new;

The new() method takes the same parameters as [SetAttribute] . For example,

    $image = Image::Magick->new(size=>'384x256');

Next you will want to read an image or image sequence, manipulate it, and then display or write it. The input and output methods for PerlMagick are defined in [Read or Write an Image]. See [Set an Image Attribute] for methods that affect the way an image is read or written. Refer to [Manipulate an Image] for a list of methods to transform an image. [Get an Image Attribute] describes how to retrieve an attribute for an image. Refer to [Create an Image Montage] for details about tiling your images as thumbnails on a background. Finally, some methods do not neatly fit into any of the categories just mentioned. Review [Miscellaneous Methods] for a list of these methods.

Once you are finished with a PerlMagick object you should consider destroying it. Each image in an image sequence is stored in virtual memory. This can potentially add up to mebibytes of memory. Upon destroying a PerlMagick object, the memory is returned for use by other Perl methods. The recommended way to destroy an object is with undef:

undef $image;

To delete all the images but retain the Image::Magick object use

    @$image = ();

and finally, to delete a single image from a multi-image sequence, use

    undef $image->[$x];

The next section illustrates how to use various PerlMagick methods to manipulate an image sequence.

Some of the PerlMagick methods require external programs such as [Ghostscript](http://www.cs.wisc.edu/~ghost/). This may require an explicit path in your PATH environment variable to work properly. For example (in Linux),

    $ENV{PATH}' . "='/../bin:/usr/bin:/usr/local/bin';

Example Script
--------------

Here is an example script to get you started:

```sh
#!/usr/local/bin/perl
use Image::Magick;  
my($image, $x);  
$image = Image::Magick->new;
$x = $image->Read('girl.png', 'logo.png', 'rose.png');
warn "$x" if "$x";  
$x = $image->Crop(geometry=>'100x100+100+100');
warn "$x" if "$x";  
$x = $image->Write('x.png');
warn "$x" if "$x";
```

The script reads three images, crops them, and writes a single image as a GIF animation sequence. In many cases you may want to access individual images of a sequence. The next example illustrates how this done:

```sh
#!/usr/local/bin/perl
use Image::Magick;  
my($image, $p, $q);  
$image = new Image::Magick;
$image->Read('x1.png');
$image->Read('j*.jpg');
$image->Read('k.miff[1, 5, 3]');
$image->Contrast();
for ($x = 0; $image->[$x]; $x++)
{
  $image->[$x]->Frame('100x200') if $image->[$x]->Get('magick') eq 'GIF';
  undef $image->[$x] if $image->[$x]->Get('columns') < 100;
}
$p = $image->[1];
$p->Draw(stroke=>'red', primitive=>'rectangle', points=>20,20 100,100');
$q = $p->Montage();
undef $image;
$q->Write('x.miff');
```

Suppose you want to start out with a 100 by 100 pixel white canvas with a red pixel in the center. Try

```sh
$image = Image::Magick->new;
$image->Set(size=>'100x100');
$image->ReadImage('canvas:white');
$image->Set('pixel[49,49]'=>'red');
```

Here we reduce the intensity of the red component at (1,1) by half:

```sh
@pixels = $image->GetPixel(x=>1,y=>1);
$pixels[0]*=0.5;
$image->SetPixel(x=>1,y=>1,color=>\@pixels);
```

Or suppose you want to convert your color image to grayscale:

    $image->Quantize(colorspace=>'gray');

Let's annotate an image with a Taipai TrueType font:

    $text = 'Works like magick!';
    $image->Annotate(font=>'kai.ttf', pointsize=>40, fill=>'green', text=>$text);

Perhaps you want to extract all the pixel intensities from an image and write them to STDOUT:

    @pixels = $image->GetPixels(map=>'I', height=>$height, width=>$width, normalize=>true);
    binmode STDOUT;
    print pack('B*',join('',@pixels));

Other clever things you can do with a PerlMagick objects include

```sh
$i = $#$p"+1";   # return the number of images associated with object p
push(@$q, @$p);  # push the images from object p onto object q
@$p = ();        # delete the images but not the object p
$p->Convolve([1, 2, 1, 2, 4, 2, 1, 2, 1]);   # 3x3 Gaussian kernel
```

Read or Write an Image
----------------------

Use the methods listed below to either read, write, or display an image or image sequence:

Read or Write Methods

   
    Method     Parameters             Return Value                   Description
    Read       one or more filenames  the number of images read      read an image or image sequence
    Write      filename               the number of images written   write an image or image sequence
    Display    server name            the number of images displayed display the image or image sequence to an X server
    Animate    server name            the number of images animated  animate image sequence to an X server

For convenience, methods Write(), Display(), and Animate() can take any parameter that [SetAttribute] knows about. For example,

    $image->Write(filename=>'image.png', compression=>'None');

Use - as the filename to method Read() to read from standard in or to method Write() to write to standard out:

    binmode STDOUT;
    $image->Write('png:-');

To read an image in the GIF format from a PERL filehandle, use:

    $image = Image::Magick->new;
    open(IMAGE, 'image.gif');
    $image->Read(file=>\*IMAGE);
    close(IMAGE);

To write an image in the PNG format to a PERL filehandle, use:

    $filename = "image.png";
    open(IMAGE, ">$filename");
    $image->Write(file=>\*IMAGE, filename=>$filename);
    close(IMAGE);

Note, reading from or writing to a Perl filehandle may fail under Windows due to different versions of the C-runtime libraries between ImageMagick and the ActiveState Perl distributions or if one of the DLL's is linked with the /MT option. See [Potential Errors Passing CRT Objects Across DLL Boundaries](http://msdn.microsoft.com/en-us/library/ms235460.aspx) for an explanation.

If %0Nd, %0No, or %0Nx appears in the filename, it is interpreted as a printf format specification and the specification is replaced with the specified decimal, octal, or hexadecimal encoding of the scene number. For example,

    image%03d.miff

converts files image000.miff, image001.miff, etc.

You can optionally add _Image_ to any method name. For example, ReadImage() is an alias for method Read().

Manipulate an Image
-------------------

Once you create an image with, for example, method ReadImage() you may want to operate on it. Below is a list of all the image manipulations methods available to you with PerlMagick. There are [examples] of select PerlMagick methods. Here is an example call to an image manipulation method:

    $image->Crop(geometry=>'100x100+10+20');
    $image->[$x]->Frame("100x200");

And here is a list of other image manipulation methods you can call:

Image Manipulation Methods

<!-- Method Parameters Description  -->

*   AdaptiveBlur
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    adaptively blur the image with a Gaussian operator of the given radius and standard deviation (sigma). Decrease the effect near edges.

*   AdaptiveResize
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, filter=>{Point, Box, Triangle, Hermite, Hanning, Hamming, Blackman, Gaussian, Quadratic, Cubic, Catrom, Mitchell, Lanczos, Bessel, Sinc}, support=>_double_, blur=>_double_

    adaptively resize image using data dependant triangulation. Specify blur > 1 for blurry or < 1 for sharp

*   AdaptiveSharpen
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    adaptively sharpen the image with a Gaussian operator of the given radius and standard deviation (sigma). Increase the effect near edges.

*   AdaptiveThreshold
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, bias=>_double_

    local adaptive thresholding.

*   AddNoise
    * * * * 

    noise=>{Uniform, Gaussian, Multiplicative, Impulse, Laplacian, Poisson}, attenuate=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    add noise to an image

*   AffineTransform
    * * * * 

    affine=>_array of float values_, translate=>_float, float_, scale=> _float, float_, rotate=>_float_, skewX=>_float_, skewY=>_float_, interpolate={Average, Bicubic, Bilinear, Filter, Integer, Mesh, NearestNeighbor}, background=>_[color name]_

    affine transform image

*   Affinity
    * * * * 

    image=>_image-handle_, method=>{None, FloydSteinberg, Riemersma}

    choose a particular set of colors from this image

*   Annotate
    * * * * 

    text=>_string_, font=>_string_, family=>_string_, style=>{Normal, Italic, Oblique, Any}, stretch=>{Normal, UltraCondensed, ExtraCondensed, Condensed, SemiCondensed, SemiExpanded, Expanded, ExtraExpanded, UltraExpanded}, weight=>_integer_, pointsize=>_integer_, density=>_geometry_, stroke=>_[color name]_, strokewidth=>_integer_, fill=>_[color name]_, undercolor=>_[color name]_, kerning=>_float_, geometry=>_geometry_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}, antialias=>{true, false}, x=>_integer_, y=>_integer_, affine=>_array of float values_, translate=>_float, float_, scale=>_float, float_, rotate=>_float_. skewX=>_float_, skewY=> _float_, align=>{Left, Center, Right}, encoding=>{UTF-8}, interline-spacing=>_double_, interword-spacing=>_double_, direction=>{right-to-left, left-to-right}, decorate=>{none, underline, overline, line-through}, word-break=>{normal, break-word}

    annotate an image with text. See [QueryFontMetrics] to get font metrics without rendering any text.

*   AutoGamma
    * * * * 

    channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    automagically adjust gamma level of image

*   AutoLevel
    * * * * 

    channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    automagically adjust color levels of image

*   AutoOrient
    * * * * 

      

    adjusts an image so that its orientation is suitable for viewing (i.e. top-left orientation)

*   AutoThreshold
    * * * * 

    method=>{Kapur, OTSU, Triangle}

    automatically perform image thresholding

*   BilateralSmoothing
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, intensity-sigma=>_double_, spatial-sigma=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    a non-linear, edge-preserving, and noise-reducing smoothing filter for images. It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels. This weight is based on a Gaussian distribution. The weights depend not only on Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such as color intensity, depth distance, etc.). This preserves sharp edges. The default value for the intensity and spatial sigmas are 2*diameter and 0.5*diameter respectively.

*   BlackThreshold
    * * * * 

    threshold=>_color_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    force all pixels below the threshold intensity into black

*   BlueShift
    * * * * 

    factor=>_double_,

    simulate a scene at nighttime in the moonlight. Start with a factor of 1.5.

*   Blur
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    reduce image noise and reduce detail levels with a Gaussian operator of the given radius and standard deviation (sigma).

*   Border
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, bordercolor=>_[color name]_, compose=>{Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyAlpha, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor },

    surround the image with a border of color

*   CannyEdge
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, 'lower-percent'=>_double_, 'upper-percent'=>_double_

    use a multi-stage algorithm to detect a wide range of edges in the image (e.g. CannyEdge('0x1+10%+40%')).

*   Charcoal
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_

    simulate a charcoal drawing

*   Chop
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}

    chop an image

*   CLAHE
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, number-bins=>_integer_, clip-limit=>_double_

    contrast limited adaptive histogram equalization. width, height divides the image into tiles. number-bins is the number of histogram bins per tile (min 2, max 256). clip-limit is the contrast limit for localised changes in contrast. A clip-limit of 2 to 3 is a good starting place.

*   Clamp
    * * * * 

    channel=>{Red, RGB, All, etc.}

    set each pixel whose value is below zero to zero and any the pixel whose value is above the quantum range to the quantum range (e.g. 65535) otherwise the pixel value remains unchanged.

*   Clip
    * * * * 

    id=>_name_, inside=>_{true, false}_,

    apply along a named path from the 8BIM profile.

*   ClipMask
    * * * * 

    mask=>_image-handle_

    clip image as defined by the image mask

*   Clut
    * * * * 

    image=>_image-handle_, interpolate={Average, Bicubic, Bilinear, Filter, Integer, Mesh, NearestNeighbor}, channel=>{Red, RGB, All, etc.}

    apply a color lookup table to an image sequence

*   Color
    * * * * 

    color=>_[color name]_

    set the entire image to this color.

*   ColorDecisionList
    * * * * 

    filename=>_string_,

    color correct with a color decision list.

*   Colorize
    * * * * 

    fill=>_[color name]_, blend=>_string_

    colorize the image with the fill color

*   ColorMatrix
    * * * * 

    matrix=>_array of float values_

    apply color correction to the image. Although you can use variable sized matrices, typically you use a 5 x 5 for an RGBA image and a 6x6 for CMYKA. A 6x6 matrix is required for offsets (populate the last column with normalized values).

*   Colorspace
    * * * * 

    colorspace=>{RGB, Gray, Transparent, OHTA, XYZ, YCbCr, YCC, YIQ, YPbPr, YUV, CMYK}

    set the image colorspace

*   Comment
    * * * * 

*   string
    * * * * 

    add a comment to your image

*   ColorThreshold
    * * * * 

    start-color=>_color_, stop-color=>_color_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    force all pixels below the threshold intensity into black

*   CompareLayers
    * * * * 

    method=>{any, clear, overlay}

    compares each image with the next in a sequence and returns the minimum bounding region of any pixel differences it discovers. Images do not have to be the same size, though it is best that all the images are coalesced (images are all the same size, on a flattened canvas, so as to represent exactly how a specific frame should look).

*   Composite
    * * * * 

    image=>_image-handle_, compose=>{Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyAlpha, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor }, mask=>_image-handle_, geometry=>_geometry_, x=>_integer_, y=>_integer_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}, opacity=>_integer_, tile=>{True, False}, rotate=>_double_, color=>_[color name]_, blend=>_geometry_, interpolate=>{undefined, average, bicubic, bilinear, filter, integer, mesh, nearest-neighbor, spline}, clip-to-self=>{True, False}

    composite one image onto another. Use the rotate parameter in concert with the tile parameter.

*   ConnectedComponents
    * * * * 

    connectivity=>_integer_,

    connected-components uniquely labeled, choose from 4 or 8 way connectivity.

*   Contrast
    * * * * 

    sharpen=>{True, False}

    enhance or reduce the image contrast

*   ContrastStretch
    * * * * 

    levels=>_string_, 'black-point'=>_double_, 'white-point'=>_double_, channel=>{Red, RGB, All, etc.}

    improve the contrast in an image by `stretching' the range of intensity values

*   Convolve
    * * * * 

    coefficients=>_array of float values_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, bias=>_double_

    apply a convolution kernel to the image. Given a kernel _order_ , you would supply _order*order_ float values (e.g. 3x3 implies 9 values).

*   CopyPixels
    * * * * 

    image=>_image-handle_, geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, offset=>_geometry_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}, dx=>_integer_, dy=>_integer_

    copy pixels from the image as defined by the widthxheight+x+y to image at offset +dx,+dy.

*   Crop
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, fuzz=>_double_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}

    crop an image

*   CycleColormap
    * * * * 

    amount=>_integer_

    displace image colormap by amount

*   Decipher
    * * * * 

    passphrase=>_string_

    convert cipher pixels to plain pixels

*   Deconstruct
    * * * * 

      

    break down an image sequence into constituent parts

*   Deskew
    * * * * 

    geometry=>_string_,threshold=>_double_

    straighten the image

*   Despeckle
    * * * * 

    reduce the speckles within an image

*   Difference
    * * * * 

    image=>_image-handle_

    compute the difference metrics between two images

*   Distort
    * * * * 

    points=>_array of float values_, method=>{Affine, AffineProjection, ScaleRotateTranslate, SRT, Perspective, PerspectiveProjection, BilinearForward, BilinearReverse, Polynomial, Arc, Polar, DePolar, Barrel, BarrelInverse, Shepards, Resize}, 'virtual-pixel'=>{Background Black Constant Dither Edge Gray Mirror Random Tile Transparent White}, 'best-fit'=>{True, False}

    distort image

*   Draw
    * * * * 

    primitive=>{point, line, rectangle, arc, ellipse, circle, path, polyline, polygon, bezier, color, matte, text, @_filename_}, points=>_string_ , method=>_{Point, Replace, Floodfill, FillToBorder, Reset}_, stroke=>_[color name]_, fill=>_[color name]_, font=>_string_, pointsize=>_integer_, strokewidth=>_float_, antialias=>{true, false}, bordercolor=>_[color name]_, x=>_float_, y=>_float_, dash-offset=>_float_, dash-pattern=>_array of float values_, affine=>_array of float values_, translate=>_float, float_, scale=>_float, float_, rotate=>_float_, skewX=>_float_, skewY=>_float_, interpolate=>{undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline}, kerning=>_float_, text=>_string_, vector-graphics=>_string_, interline-spacing=>_double_, interword-spacing=>_double_, direction=>{right-to-left, left-to-right}, word-break=>{normal, break-word}

    annotate an image with one or more graphic primitives.

*   Encipher
    * * * * 

    passphrase=>_string_

    convert plain pixels to cipher pixels

*   Edge
    * * * * 

    radius=>_double_

    enhance edges within the image with a convolution filter of the given radius.

*   Emboss
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_

    emboss the image with a convolution filter of the given radius and standard deviation (sigma).

*   Enhance
    * * * * 

      

    apply a digital filter to enhance a noisy image

*   Equalize
    * * * * 

    channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}  

    perform histogram equalization to the image

*   Extent
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, fuzz=>_double_, background=>_[color name]_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}

    set the image size

*   Evaluate
    * * * * 

    value=>_double_, operator=>_{Add, And, Divide, LeftShift, Max, Min, Multiply, Or, Rightshift, RMS, Subtract, Xor}_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    apply an arithmetic, relational, or logical expression to the image

*   Filter
    * * * * 

    kernel=>_string_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, bias=>_double_

    apply a convolution kernel to the image.

*   Flip
    * * * * 

      

    reflect the image scanlines in the vertical direction

*   Flop
    * * * * 

      

    reflect the image scanlines in the horizontal direction

*   FloodfillPaint
    * * * * 

    geometry=>_geometry_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, x=>_integer_, y=>_integer_ , fill=>_[color name]_, bordercolor=>_[color name]_, fuzz=>_double_, invert=>{True, False}

    changes the color value of any pixel that matches the color of the target pixel and is a neighbor. If you specify a border color, the color value is changed for any neighbor pixel that is not that color.

*   ForwardFourierTransform
    * * * * 

    magnitude=>{True, False}

    implements the forward discrete Fourier transform (DFT)

*   Frame
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, inner=>_integer_, outer=>_integer_, fill=>_[color name]_, compose=>{Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyAlpha, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor },

    surround the image with an ornamental border

*   Function
    * * * * 

    parameters=>_array of float values_, function=>{Sin}, 'virtual-pixel'=>{Background Black Constant Dither Edge Gray Mirror Random Tile Transparent White}

    apply a function to the image

*   Gamma
    * * * * 

    gamma=>_string_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    gamma correct the image

*   GaussianBlur
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    reduce image noise and reduce detail levels with a Gaussian operator of the given radius and standard deviation (sigma).

*   GetPixel
    * * * * 

    geometry=>_geometry_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, normalize=>{true, false}, x=>_integer_, y=>_integer_

    get a single pixel. By default normalized pixel values are returned.

*   GetPixels
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, map=>_string_, normalize=>{true, false}

    get image pixels as defined by the map (e.g. "RGB", "RGBA", etc.). By default non-normalized pixel values are returned.

*   Grayscale
    * * * * 

    channel=>{Average, Brightness, Lightness, Rec601Luma, Rec601Luminance, Rec709Luma, Rec709Luminance, RMS}

    convert image to grayscale

*   HaldClut
    * * * * 

    image=>_image-handle_, channel=>{Red, RGB, All, etc.}

    apply a Hald color lookup table to an image sequence

*   HoughLine
    * * * * 

    geometry=>_geometry_, width=>_double_, height=>_double_, threshold=>_double_

    identify lines in the image (e.g. HoughLine('9x9+195')).

*   Identify
    * * * * 

    file=>_file_, features=>_distance_, moments=>{True, False}, unique=>{True, False}

    identify the attributes of an image

*   Implode
    * * * * 

    amount=>_double_, interpolate=>{undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline}

    implode image pixels about the center

*   Integral
    * * * * 

    calculate the sum of values (pixel values) in the image.

*   InverseDiscreteFourierTransform
    * * * * 

    magnitude=>{True, False}

    implements the inverse discrete Fourier transform (DFT)

*   Kmeans
    * * * * 

    geometry=>_geometry_, 'colors'=>_double_, 'iterations'=>_double_, 'tolerance'=>_double_

    K means color reduction.

*   Kuwahara
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    edge preserving noise reduction filter

*   Label
    * * * * 

*   string
    * * * * 

    assign a label to an image

*   Layers
    * * * * 

    method=>{coalesce, compare-any, compare-clear, compare-over, composite, dispose, flatten, merge, mosaic, optimize, optimize-image, optimize-plus, optimize-trans, remove-dups, remove-zero}, compose=>{Undefined, Add, Atop, Blend, Bumpmap, Clear, ColorBurn, ColorDodge, Colorize, CopyBlack, CopyBlue, CopyCMYK, Cyan, CopyGreen, Copy, CopyMagenta, CopyAlpha, CopyRed, RGB, CopyYellow, Darken, Dst, Difference, Displace, Dissolve, DstAtop, DstIn, DstOut, DstOver, Dst, Exclusion, HardLight, Hue, In, Lighten, LinearLight, Luminize, Minus, Modulate, Multiply, None, Out, Overlay, Over, Plus, ReplaceCompositeOp, Saturate, Screen, SoftLight, Src, SrcAtop, SrcIn, SrcOut, SrcOver, Src, Subtract, Threshold, Xor }, dither=>{true, false}

    compare each image the GIF disposed forms of the previous image in the sequence. From this, attempt to select the smallest cropped image to replace each frame, while preserving the results of the animation.

*   Level
    * * * * 

    levels=>_string_, 'black-point'=>_double_, 'gamma'=>_double_, 'white-point'=>_double_, channel=>{Red, RGB, All, etc.}

    adjust the level of image contrast

*   LevelColors
    * * * * 

    invert=>>{True, False}, 'black-point'=>_string_, 'white-point'=>_string_, channel=>{Red, RGB, All, etc.}

    level image with the given colors

*   LinearStretch
    * * * * 

    levels=>_string_, 'black-point'=>_double_, 'white-point'=>_double_

    linear with saturation stretch

*   LiquidResize
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, delta-x=>_double_, rigidity=>_double_

    rescale image with seam-carving.

*   Magnify
    * * * * 

      

    double the size of the image with pixel art scaling

*   Mask
    * * * * 

    mask=>_image-handle_

    composite image pixels as defined by the mask

*   MatteFloodfill
    * * * * 

    geometry=>_geometry_, x=>_integer_, y=>_integer_ , matte=>_integer_, bordercolor=>_[color name]_, fuzz=>_double_, invert=>{True, False}

    changes the matte value of any pixel that matches the color of the target pixel and is a neighbor. If you specify a border color, the matte value is changed for any neighbor pixel that is not that color.

*   MeanShift
    * * * * 

    geometry=>_geometry_, width=>_double_, height=>_double_, distance=>_double_

    delineate arbitrarily shaped clusters in the image (e.g. MeanShift('7x7+10%')).

*   MedianFilter
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    replace each pixel with the median intensity pixel of a neighborhood.

*   Minify
    * * * * 

      

    half the size of an image

*   Mode
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    make each pixel the predominant color of the neighborhood.

*   Modulate
    * * * * 

    factor=>_geometry_, brightness=>_double_, saturation=>_double_, hue=>_double_, lightness=>_double_, whiteness=>_double_, blackness=>_double_

    vary the brightness, saturation, and hue of an image by the specified percentage

*   Morphology
    * * * * 

    kernel=>_string_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, iterations=>_integer_

    apply a morphology method to the image.

*   MotionBlur
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, angle=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    reduce image noise and reduce detail levels with a Gaussian operator of the given radius and standard deviation (sigma) at the given angle to simulate the effect of motion

*   Negate
    * * * * 

    gray=>{True, False}, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    replace each pixel with its complementary color (white becomes black, yellow becomes blue, etc.)

*   Normalize
    * * * * 

    channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}  

    transform image to span the full range of color values

*   OilPaint
    * * * * 

    radius=>_integer_

    simulate an oil painting

*   Opaque
    * * * * 

    color=>_[color name]_, fill=>_[color name]_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, invert=>{True, False}

    change this color to the fill color within the image

*   OrderedDither
    * * * * 

    threshold=>{threshold, checks, o2x2, o3x3, o4x4, o8x8, h4x4a, h6x6a, h8x8a, h4x4o, h6x6o, h8x8o, h16x16o, hlines6x4}, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    order dither image

*   Perceptible
    * * * * 

    epsilon=>_double_, channel=>{Red, RGB, All, etc.}

    set each pixel whose value is less than |epsilon| to -epsilon or epsilon (whichever is closer) otherwise the pixel value remains unchanged..

*   Polaroid
    * * * * 

    caption=>_string_, angle=>_double_, pointsize=>_double_, font=>_string_, stroke=> _[color name]_, strokewidth=>_integer_, fill=>_[color name]_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}, background=>_[color name]_

    simulate a Polaroid picture.

*   Posterize
    * * * * 

    levels=>_integer_, dither=>{True, False}

    reduce the image to a limited number of color level

*   Profile
    * * * * 

    name=>_string_, profile=>_blob_, rendering-intent=>{Undefined, Saturation, Perceptual, Absolute, Relative}, black-point-compensation=>{True, False}

    add or remove ICC or IPTC image profile; name is formal name (e.g. ICC or filename; set profile to '' to remove profile

*   Quantize
    * * * * 

    colors=>_integer_, colorspace=>{RGB, Gray, Transparent, OHTA, XYZ, YCbCr, YIQ, YPbPr, YUV, CMYK, sRGB, HSL, HSB}, treedepth=> _integer_, dither=>{True, False}, dither-method=>{Riemersma, Floyd-Steinberg}, measure_error=>{True, False}, global_colormap=>{True, False}, transparent-color=>_color_

    preferred number of colors in the image

*   Raise
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, raise=>{True, False}

    lighten or darken image edges to create a 3-D effect

*   RangeThreshold
    * * * * 

    geometry=>_geometry_, 'low-black'=>_double_, 'low-white'=>_double_, 'high-white'=>_double_, 'high-black'=>_double_

    combine soft and hard image thresholding.

*   ReduceNoise
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    reduce noise in the image with a noise peak elimination filter

*   Remap
    * * * * 

    image=>_image-handle_, dither=>{true, false}, dither-method=>{Riemersma, Floyd-Steinberg}

    replace the colors of an image with the closest color from a reference image.

*   Resample
    * * * * 

    density=>_geometry_, x=>_double_, y=>_double_, filter=>{Point, Box, Triangle, Hermite, Hanning, Hamming, Blackman, Gaussian, Quadratic, Cubic, Catrom, Mitchell, Lanczos, Bessel, Sinc}, support=>_double_

    resample image to desired resolution. Specify blur > 1 for blurry or < 1 for sharp

*   Resize
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, filter=>{Point, Box, Triangle, Hermite, Hanning, Hamming, Blackman, Gaussian, Quadratic, Cubic, Catrom, Mitchell, Lanczos, Bessel, Sinc}, support=>_double_, blur=>_double_

    scale image to desired size. Specify blur > 1 for blurry or < 1 for sharp

*   Roll
    * * * * 

    geometry=>_geometry_, x=>_integer_, y=>_integer_

    roll an image vertically or horizontally

*   Rotate
    * * * * 

    degrees=>_double_, background=>_[color name]_

    rotate an image

*   RotationalBlur
    * * * * 

    geometry=>_geometry_, angle=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    radial blur the image.

*   Sample
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_

    scale image with pixel sampling.

*   Scale
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_

    scale image to desired size

*   Segment
    * * * * 

    colorspace=>{RGB, Gray, Transparent, OHTA, XYZ, YCbCr, YCC, YIQ, YPbPr, YUV, CMYK}, verbose={True, False}, cluster-threshold=>_double_, smoothing-threshold=_double_

    segment an image by analyzing the histograms of the color components and identifying units that are homogeneous

*   SelectiveBlur
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, threshold=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    selectively blur pixels within a contrast threshold.

*   Separate
    * * * * 

    channel=>{Red, RGB, All, etc.}

    separate a channel from the image into a grayscale image

*   Shade
    * * * * 

    geometry=>_geometry_, azimuth=>_double_, elevation=>_double_, gray=>{true, false}

    shade the image using a distant light source

*   SetPixel
    * * * * 

    geometry=>_geometry_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, color=>_array of float values_, x=>_integer_, y=>_integer_, color=>_array of float values_

    set the value a single pixel. Normalized pixel values are expected.

*   SetPixels
    * * * * 

    geometry=>_geometry_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, color=>_array of float values_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, color=>_array of float values_

    set the value of one or more pixels. Normalized pixel values are expected.

*   Shadow
    * * * * 

    geometry=>_geometry_, opacity=>_double_, sigma=>_double_, x=>_integer_, y=>_integer_

    simulate an image shadow

*   Sharpen
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, bias=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    sharpen the image with a Gaussian operator of the given radius and standard deviation (sigma).

*   Shave
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_

    shave pixels from the image edges

*   Shear
    * * * * 

    geometry=>_geometry_, x=>_double_, y=>_double_ fill=>_[color name]_

    shear the image along the X or Y axis by a positive or negative shear angle

*   SigmoidalContrast
    * * * * 

    geometry=>_string_, 'contrast'=>_double_, 'mid-point'=>_double_ channel=>{Red, RGB, All, etc.}, sharpen=>{True, False}

    sigmoidal non-lineraity contrast control. Increase the contrast of the image using a sigmoidal transfer function without saturating highlights or shadows. Contrast indicates how much to increase the contrast (0 is none; 3 is typical; 20 is a lot); mid-point indicates where midtones fall in the resultant image (0 is white; 50% is middle-gray; 100% is black). To decrease contrast, set sharpen to False.

*   Signature
    * * * * 

      

    generate an SHA-256 message digest for the image pixel stream

*   Sketch
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, angle=>_double_

    sketch the image with a Gaussian operator of the given radius and standard deviation (sigma) at the given angle

*   Solarize
    * * * * 

    geometry=>_string_, threshold=>_double_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    negate all pixels above the threshold level

*   SortPixels
    * * * * 

      

    sorts pixels within each scanline in ascending order of intensity.

*   SparseColor
    * * * * 

    points=>_array of float values_, method=>{Barycentric, Bilinear, Shepards, Voronoi}, 'virtual-pixel'=>{Background Black Constant Dither Edge Gray Mirror Random Tile Transparent White}

    interpolate the image colors around the supplied points

*   Splice
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_, fuzz=>_double_, background=>_[color name]_, gravity=>{NorthWest, North, NorthEast, West, Center, East, SouthWest, South, SouthEast}

    splice an image

*   Spread
    * * * * 

    radius=>_double_, interpolate=>{undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline}

    displace image pixels by a random amount

*   Statistic
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}, type=>{Contrast, Median, Mode, Mean, Maximum, Minimum, ReduceNoise, RMS}

    replace each pixel with corresponding statistic from the neighborhood.

*   Stegano
    * * * * 

    image=>_image-handle_, offset=>_integer_

    hide a digital watermark within the image

*   Stereo
    * * * * 

    image=>_image-handle_, x=>_integer_, y=>_integer_

    composites two images and produces a single image that is the composite of a left and right image of a stereo pair

*   Strip
    * * * * 

      

    strip an image of all profiles and comments.

*   Swirl
    * * * * 

    degrees=>_double_, interpolate=>{undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline}

    swirl image pixels about the center

*   Texture
    * * * * 

    texture=>_image-handle_

    name of texture to tile onto the image background

*   Thumbnail
    * * * * 

    geometry=>_geometry_, width=>_integer_, height=>_integer_

    changes the size of an image to the given dimensions and removes any associated profiles.

*   Threshold
    * * * * 

    threshold=>_string_, channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    threshold the image

*   Tint
    * * * * 

    fill=>_[color name]_, blend=>_string_

    tint the image with the fill color.

*   Transparent
    * * * * 

    color=>_[color name]_, invert=>{True, False}

    make this color transparent within the image

*   Transpose
    * * * * 

      

    flip image in the vertical direction and rotate 90 degrees

*   Transverse
    * * * * 

      

    flop image in the horizontal direction and rotate 270 degrees

*   Trim
    * * * * 

      

    remove edges that are the background color from the image

*   UnsharpMask
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, gain=>_double_, threshold=>_double_

    sharpen the image with the unsharp mask algorithm.

*   Vignette
    * * * * 

    geometry=>_geometry_, radius=>_double_, sigma=>_double_, x=>_integer_, y=>_integer_, background=>_[color name]_

    offset the edges of the image in vignette style

*   Wave
    * * * * 

    geometry=>_geometry_, amplitude=>_double_, wavelength=>_double_, interpolate=>{undefined, average, bicubic, bilinear, mesh, nearest-neighbor, spline}

    alter an image along a sine wave

*   WaveDenoise
    * * * * 

    geometry=>_geometry_, threshold=>_double_, threshold=>_double_

    removes noise from the image using a wavelet transform

*   WhiteBalance
    * * * * 

    applies white balancing to an image according to a grayworld assumption in the LAB colorspace.

*   WhiteThreshold
    * * * * 

    threshold=>_string_, , channel=>{All, Default, Alpha, Black, Blue, CMYK, Cyan, Gray, Green, Index, Magenta, Alpha, Red, RGB, Yellow}

    force all pixels above the threshold intensity into white

Note, that the geometry parameter is a short cut for the width and height parameters (e.g. geometry=>'106x80' is equivalent to width=>106, height=>80 ).

You can specify @filename in both Annotate() and Draw(). This reads the text or graphic primitive instructions from a file on disk. For example,

    image->Draw(fill=>'red', primitive=>'rectangle',
     points=>'20,20 100,100  40,40 200,200  60,60 300,300');

Is equivalent to

    $image->Draw(fill=>'red', primitive=>'@draw.txt');

Where draw.txt is a file on disk that contains this:

    rectangle 20, 20 100, 100
    rectangle 40, 40 200, 200
    rectangle 60, 60 300, 300

The _text_ parameter for methods, Annotate(), Comment(), Draw(), and Label() can include the image filename, type, width, height, or other image attribute by embedding these special format characters:

    %b   file size                       %t   top of filename 
    %c   comment                         %u   unique temporary filename 
    %d   directory                       %w   width 
    %e   filenameextension               %x   x resolution 
    %f   filename                        %y   y resolution 
    %g   page geometry                   %z   image depth 
    %h   height                          %C   image compression type 
    %i   input filename                  %D   image dispose method 
    %k   number of unique colors         %H   page height 
    %l   label                           %Q   image compression quality 
    %m   magick                          %T   image delay 
    %n   number of scenes                %W   page width 
    %o   output filename                 %X   page x offset 
    %p   page number                     %Y   page y offset 
    %q   quantum depth                   %@   bounding box 
    %r   image class and colorspace      %#   signature 
    %s   scene number                    %%   a percent sign \n newline \r carriage return

For example,

    text=>"%m:%f %wx%h"

produces an annotation of **MIFF:bird.miff 512x480** for an image titled **bird.miff** and whose width is 512 and height is 480.

You can optionally add _Image_ to any method name. For example, TrimImage() is an alias for method Trim().

Most of the attributes listed above have an analog in [magick]. See the documentation for a more detailed description of these attributes.

Set an Image Attribute
----------------------

Use method Set() to set an image attribute. For example,

    $image->Set(dither=>'True');
    $image->[$x]->Set(delay=>3);

Where this example uses 'True' and this document says '{True, False}', you can use the case-insensitive strings 'True' and 'False', or you can use the integers 1 and 0.

When you call Get() on a Boolean attribute, Image::Magick returns 1 or 0, not a string.

And here is a list of all the image attributes you can set:

Image Attributes

|    Attribute    |                      Values                      |                              Description                              |
|-----------------|--------------------------------------------------|-----------------------------------------------------------------------|
| adjoin          | {True, False}                                    | join images into a single multi-image file                            |
| alpha           | {On, Off, Opaque, Transparent,                   |                                                                       |
|                 | Copy, Extract, Set}                              | control of and special operations involving the alpha/matte channel   |
| antialias       | {True, False}                                    | remove pixel aliasing                                                 |
| area-limit      | _integer_                                        | set pixel area resource limit.                                        |
| attenuate       | _double_                                         | lessen (or intensify) when adding noise to an image.                  |
| authenticate    | _string_                                         | decrypt image with this password.                                     |
| background      | _[color name]_                                   | image background color                                                |
| blue-primary    | _x-value_, _y-value_                             | chromaticity blue primary point (e.g. 0.15, 0.06)                     |
| bordercolor     | _[color name]_                                   | set the image border color                                            |
| clip-mask       | _image_                                          | associate a clip mask with the image.                                 |
| colormap[_i_]   | _[color name]_                                   | color name (e.g. red) or hex value (e.g. #ccc) at position _i_        |
| comment         | _string_                                         | set the image comment                                                 |
| compression     | {None, BZip, Fax, Group4, JPEG,                  |                                                                       |
|                 | JPEG2000, LosslessJPEG, LZW, RLE, Zip}           | type of image compression                                             |
| debug           | {All, Annotate, Blob, Cache, Coder,              |                                                                       |
|                 | Configure, Deprecate, Draw, Exception,           |                                                                       |
|                 | Locale, None, Resource, Transform, X11}          | display copious debugging information                                 |
| delay           | _integer_                                        | this many 1/100ths of a second must expire                            |
|                 |                                                  | before displaying the next image in a sequence                        |
| density         | _geometry_                                       | vertical and horizontal resolution in pixels of the image             |
| depth           | _integer_                                        | image depth                                                           |
| direction       | _{Undefined, right-to-left, left-to-right_       | render text right-to-left or left-to-right                            |
| disk-limit      | _integer_                                        | set disk resource limit                                               |
| dispose         | _{Undefined, None, Background, Previous}_        | layer disposal method                                                 |
| dither          | {True, False}                                    | apply error diffusion to the image                                    |
| display         | _string_                                         | specifies the X server to contact                                     |
| extract         | _geometry_                                       | extract area from image                                               |
| file            | _filehandle_                                     | set the image filehandle                                              |
| filename        | _string_                                         | set the image filename                                                |
| fill            | _color_                                          | The fill color paints any areas inside the outline of drawn shape.    |
| font            | _string_                                         | use this font when annotating the image with text                     |
| fuzz            | _integer_                                        | colors within this distance are considered equal                      |
| gamma           | _double_                                         | gamma level of the image                                              |
| Gravity         | {Forget, NorthWest, North, NorthEast,            |                                                                       |
|                 | West, Center, East, SouthWest, South,            |                                                                       |
|                 | SouthEast}                                       | type of image gravity                                                 |
| green-primary   | _x-value_, _y-value_                             | chromaticity green primary point (e.g. 0.3, 0.6)                      |
| index[_x_, _y_] | _string_                                         | colormap index at position (_x_, _y_)                                 |
| interlace       | {None, Line, Plane, Partition, JPEG, GIF, PNG}   | the type of interlacing scheme                                        |
| iterations      | _integer_                                        | add Netscape loop extension to your GIF animation                     |
| label           | _string_                                         | set the image label                                                   |
| loop            | _integer_                                        | add Netscape loop extension to your GIF animation                     |
| magick          | _string_                                         | set the image format                                                  |
| map-limit       | _integer_                                        | set map resource limit                                                |
| mask            | _image_                                          | associate a mask with the image.                                      |
| matte           | {True, False}                                    | enable the image matte channel                                        |
| mattecolor      | _[color name]_                                   | set the image matte color                                             |
| memory-limit    | _integer_                                        | set memory resource limit                                             |
| monochrome      | {True, False}                                    | transform the image to black and white                                |
| option          | _string_                                         | associate an option with an image format (e.g. option=>'ps:imagemask' |
| orientation     | {TopLeft, TopRight, BottomRight, BottomLeft,     |                                                                       |
|                 | LeftTop, RightTop, RightBottom, LeftBottom}      | image orientation                                                     |
| page            | { Letter, Tabloid, Ledger, Legal, Statement,     |                                                                       |
|                 | Executive, A3, A4, A5, B4, B5,                   |                                                                       |
|                 | Folio, Quarto, 10x14} or _geometry_              | preferred size and location of an image canvas                        |
| pixel[_x_, _y_] | _string_                                         | hex value (e.g. #ccc) at position (_x_, _y_)                          |
| pointsize       | _integer_                                        | pointsize of the Postscript or TrueType font                          |
| precision       | _integer_                                        | set the maximum number of significant digits to be printed            |
| quality         | _integer_                                        | JPEG/MIFF/PNG compression level                                       |
| red-primary     | _x-value_, _y-value_                             | chromaticity red primary point (e.g. 0.64, 0.33)                      |
| sampling-factor | _geometry_                                       | horizontal and vertical sampling factor                               |
| scene           | _integer_                                        | image scene number                                                    |
| server          | _string_                                         | specifies the X server to contact                                     |
| size            | _string_                                         | width and height of a raw image                                       |
| stroke          | _color_                                          | The stroke color paints along the outline of a shape.                 |
| texture         | _string_                                         | name of texture to tile onto the image background                     |
| tile-offset     | _geometry_                                       | image tile offset                                                     |
| time-limit      | _integer_                                        | set time resource limit in seconds                                    |
| type            | {Bilevel, Grayscale, GrayscaleMatte, Palette,    |                                                                       |
|                 | PaletteMatte, TrueColor, TrueColorMatte,         |                                                                       |
|                 | ColorSeparation, ColorSeparationMatte}           | image type                                                            |
| units           | { Undefined, PixelsPerInch, PixelsPerCentimeter} | units of image resolution                                             |
| verbose         | {True, False}                                    | print detailed information about the image                            |
| virtual-pixel   | {Background Black Constant Dither Edge Gray      |                                                                       |
|                 | Mirror Random Tile Transparent White}            | the virtual pixel method                                              |
| white-point     | _x-value_, _y-value_                             | chromaticity white point (e.g. 0.3127, 0.329)                         |

Note, that the geometry parameter is a short cut for the width and height parameters (e.g. geometry=>'106x80' is equivalent to width=>106, height=>80).

SetAttribute() is an alias for method Set().

Most of the attributes listed above have an analog in [magick]. See the documentation for a more detailed description of these attributes.

Get an Image Attribute
----------------------

Use method Get() to get an image attribute. For example,

    ($a, $b, $c) = $image->Get('colorspace', 'magick', 'adjoin');
    $width = $image->[3]->Get('columns');

In addition to all the attributes listed in [Set an Image Attribute] , you can get these additional attributes:

|  Image Attributes |    Attribute     |                                       Values                                      | Description |
|        area       |    _integer_     |                           current area resource consumed                          |             |
|-------------------|------------------|-----------------------------------------------------------------------------------|-------------|
| base-columns      | _integer_        | base image width (before transformations)                                         |             |
| base-filename     | _string_         | base image filename (before transformations)                                      |             |
| base-rows         | _integer_        | base image height (before transformations)                                        |             |
| class             | {Direct, Pseudo} | image class                                                                       |             |
| colors            | _integer_        | number of unique colors in the image                                              |             |
| columns           | _integer_        | image width                                                                       |             |
| copyright         | _string_         | get PerlMagick's copyright                                                        |             |
| directory         | _string_         | tile names from within an image montage                                           |             |
| elapsed-time      | _double_         | elapsed time in seconds since the image was created                               |             |
| error             | _double_         | the mean error per pixel computed with methods Compare() or Quantize()            |             |
| bounding-box      | _string_         | image bounding box                                                                |             |
| disk              | _integer_        | current disk resource consumed                                                    |             |
| filesize          | _integer_        | number of bytes of the image on disk                                              |             |
| format            | _string_         | get the descriptive image format                                                  |             |
| geometry          | _string_         | image geometry                                                                    |             |
| height            | _integer_        | the number of rows or height of an image                                          |             |
| icc               | _string_         | ICC profile                                                                       |             |
| icc               | _string_         | ICM profile                                                                       |             |
| id                | _integer_        | ImageMagick registry id                                                           |             |
| IPTC              | _string_         | IPTC profile                                                                      |             |
| mean-error        | _double_         | the normalized mean error per pixel computed with methods Compare() or Quantize() |             |
| map               | _integer_        | current memory-mapped resource consumed                                           |             |
| matte             | {True, False}    | whether or not the image has a matte channel                                      |             |
| maximum-error     | _double_         | the normalized max error per pixel computed with methods Compare() or Quantize()  |             |
| memory            | _integer_        | current memory resource consumed                                                  |             |
| mime              | _string_         | MIME of the image format                                                          |             |
| montage           | _geometry_       | tile size and offset within an image montage                                      |             |
| page.x            | _integer_        | x offset of image virtual canvas                                                  |             |
| page.y            | _integer_        | y offset of image virtual canvas                                                  |             |
| rows              | _integer_        | the number of rows or height of an image                                          |             |
| signature         | _string_         | SHA-256 message digest associated with the image pixel stream                     |             |
| taint             | {True, False}    | True if the image has been modified                                               |             |
| total-ink-density | _double_         | returns the total ink density for a CMYK image                                    |             |
| transparent-color | _[color name]_   | set the image transparent color                                                   |             |
| user-time         | _double_         | user time in seconds since the image was created                                  |             |
| version           | _string_         | get PerlMagick's version                                                          |             |
| width             | _integer_        | the number of columns or width of an image                                        |             |
| XMP               | _string_         | XMP profile                                                                       |             |
| x-resolution      | _integer_        | x resolution of the image                                                         |             |
| y-resolution      | _integer_        | y resolution of the image                                                         |             |

GetAttribute() is an alias for method Get().

Most of the attributes listed above have an analog in [magick]. See the documentation for a more detailed description of these attributes.

Compare an Image to its Reconstruction
--------------------------------------

Mathematically and visually annotate the difference between an image and its reconstruction with the Compare() method. The method supports these parameters:

Compare Parameters

| Parameter |        Values       |                           Description                            |
|-----------|---------------------|------------------------------------------------------------------|
| channel   | _double_            | select image channels, the default is all channels except alpha. |
| fuzz      | _double_            | colors within this distance are considered equal                 |
| image     | _image-reference_   | the image reconstruction                                         |
| metric    | AE, MAE, MEPP, MSE, |                                                                  |
|           | PAE, PSNR, RMSE     | measure differences between images with this metric              |

In this example, we compare the ImageMagick logo to a sharpened reconstruction:

    use Image::Magick;

    $logo=Image::Magick->New();
    $logo->Read('logo:');
    $sharp=Image::Magick->New();
    $sharp->Read('logo:');
    $sharp->Sharpen('0x1');
    $difference=$logo->Compare(image=>$sharp, metric=>'rmse');
    print $difference->Get('error'), "\n";
    $difference->Display();

In addition to the reported root mean squared error of around 0.024, a difference image is displayed so you can visually identify the difference between the images.

Create an Image Montage
-----------------------

Use method Montage() to create a composite image by combining several separate images. The images are tiled on the composite image with the name of the image optionally appearing just below the individual tile. For example,

    $image->Montage(geometry=>'160x160', tile=>'2x2', texture=>'granite:');

And here is a list of Montage() parameters you can set:

Montage Parameters 

|  Parameter  |             Values             |                                      Description                                       |
|-------------|--------------------------------|----------------------------------------------------------------------------------------|
| background  | _[color name]_                 | background color name                                                                  |
| border      | _integer_                      | image border width                                                                     |
| filename    | _string_                       | name of montage image                                                                  |
| fill        | [color name]                   | fill color for annotations                                                             |
| font        | _string_                       | X11 font name                                                                          |
| frame       | _geometry_                     | surround the image with an ornamental border                                           |
| geometry    | _geometry_                     | preferred tile and border size of each tile of the composite image (e.g. 120x120+4+3>) |
| gravity     | NorthWest, North, NorthEast,   |                                                                                        |
|             | West, Center, East, SouthWest, |                                                                                        |
|             | South, SouthEast               | direction image gravitates to within a tile                                            |
| label       | _string_                       | assign a label to an image                                                             |
| mode        | Frame, Unframe, Concatenate    | thumbnail framing options                                                              |
| pointsize   | _integer_                      | pointsize of the Postscript or TrueType font                                           |
| shadow      | {True, False}                  | add a shadow beneath a tile to simulate depth                                          |
| stroke      | [color name]                   | stroke color for annotations                                                           |
| texture     | _string_                       | name of texture to tile onto the image background                                      |
| tile        | _geometry_                     | the number of tiles per row and page (e.g. 6x4)                                        |
| title       | string                         | assign a title to the image montage                                                    |
| transparent | _string_                       | make this color transparent within the image                                           |

Note, that the geometry parameter is a short cut for the width and height parameters (e.g. geometry=>'106x80' is equivalent to width=>106, height=>80).

MontageImage() is an alias for method Montage().

Most of the attributes listed above have an analog in [montage]. See the documentation for a more detailed description of these attributes.

Working with Blobs
------------------

A blob contains data that directly represent a particular image format in memory instead of on disk. PerlMagick supports blobs in any of these image [formats] and provides methods to convert a blob to or from a particular image format.

Blob Methods 

|    Method   |       Parameters      |               Return Value and Description              |
|-------------|-----------------------|---------------------------------------------------------|
| ImageToBlob | any image [attribute] | an array of image data in the respective image format   |
|             |                       | convert an image or image sequence to an array of blobs |
| BlobToImage | one or more blobs     | the number of blobs converted to an image               |
|             |                       | convert one or more blobs to an image                   |
|             |                       |                                                         |

ImageToBlob() returns the image data in their respective formats. You can then print it, save it to an ODBC database, write it to a file, or pipe it to a display program:

    @blobs = $image->ImageToBlob();
    open(DISPLAY,"| display -") || die;
    binmode DISPLAY;
    print DISPLAY $blobs[0];
    close DISPLAY;

Method BlobToImage() returns an image or image sequence converted from the supplied blob:

    @blob=$db->GetImage();
    $image=Image::Magick->new(magick=>'jpg');
    $image->BlobToImage(@blob);

Direct-access to Image Pixels
-----------------------------

Use these methods to obtain direct access to the image pixels:

Direct-access to Image Pixels

<!--  Method  Parameters  Description  -->

*   GetAuthenticPixels

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_

    return authentic pixels as a C pointer

*   GetVirtualPixels

    geometry=>_geometry_, width=>_integer_, height=>_integer_, x=>_integer_, y=>_integer_

    return virtual pixels as a const C pointer

*   GetAuthenticIndexQueue

    return colormap indexes or black pixels as a C pointer

*   GetVirtualIndexQueue

    return colormap indexes or black pixels as a const C pointer

*   SyncAuthenticPixels

    sync authentic pixels to pixel cache

Miscellaneous Methods
---------------------

The Append() method append a set of images. For example,

    $p = $image->Append(stack=>{true,false});

appends all the images associated with object $image. By default, images are stacked left-to-right. Set stack to True to stack them top-to-bottom.

The Clone() method copies a set of images. For example,

    $q = $p->Clone();

copies all the images from object $p to $q. You can use this method for single or multi-image sequences.

Coalesce() composites a set of images while respecting any page offsets and disposal methods. GIF, MIFF, and MNG animation sequences typically start with an image background and each subsequent image varies in size and offset. A new image sequence is returned with all images the same size as the first images virtual canvas and composited with the next image in the sequence.. For example,

    $q = $p->Coalesce();

The ComplexImages() method performs complex mathematics on an image sequence. For example,

    $p = $image->ComplexImages('conjugate');

The EvaluateImages() method applies an arithmetic, logical or relational expression to a set of images. For example,

    $p = $image->EvaluateImages('mean');

averages all the images associated with object $image.

The Features() method returns features for each channel in the image in each of four directions (horizontal, vertical, left and right diagonals) for the specified distance. The features include the angular second momentum, contrast, correlation, sum of squares: variance, inverse difference moment, sum average, sum varience, sum entropy, entropy, difference variance, difference entropy, information measures of correlation 1, information measures of correlation 2, and maximum correlation coefficient. Values in RGB, CMYK, RGBA, or CMYKA order (depending on the image type).

@features = $image->Features(1);

The Flatten() method flattens a set of images and returns it. For example,

$p = $images->Flatten(background=>'none');
$p->Write('flatten.png');

The sequence of images is replaced by a single image created by composing each image after the first over the first image.

The Fx() method applies a mathematical expression to a set of images and returns the results. For example,

$p = $image->Fx(expression=>'(g+b)/2.0',channel=>'red');
$p->Write('fx.miff');

replaces the red channel with the average of the green and blue channels.

See [FX, The Special Effects Image Operator] for a detailed discussion of this method.

Histogram() returns the unique colors in the image and a count for each one. The returned values are an array of red, green, blue, opacity, and count values.

The Morph() method morphs a set of images. Both the image pixels and size are linearly interpolated to give the appearance of a meta-morphosis from one image to the next:

$p = $image->Morph(frames=>_integer_);

where _frames_ is the number of in-between images to generate. The default is 1.

Mosaic() creates an mosaic from an image sequence.

Method Mogrify() is a single entry point for the image manipulation methods ([Manipulate an Image]). The parameters are the name of a method followed by any parameters the method may require. For example, these calls are equivalent:

    $image->Crop('340x256+0+0');
    $image->Mogrify('crop', '340x256+0+0');

Method MogrifyRegion() applies a transform to a region of the image. It is similar to Mogrify() but begins with the region geometry. For example, suppose you want to brighten a 100x100 region of your image at location (40, 50):

$image->MogrifyRegion('100x100+40+50', 'modulate', brightness=>50);

PerceptualHash() maps visually identical images to the same or similar hash-- useful in image retrieval, authentication, indexing, or copy detection as well as digital watermarking. For each channel and for the sRGB and the HCLp colorspaces, 7 hash values are returned For an sRGB images, for example, expect 42 perceptual hashes.

@phash = $image->PerceptualHash();

Ping() is a convenience method that returns information about an image without having to read the image into memory. It returns the width, height, file size in bytes, and the file format of the image. You can specify more than one filename but only one filehandle:

    ($width, $height, $size, $format) = $image->Ping('logo.png');
    ($width, $height, $size, $format) = $image->Ping(file=>\*IMAGE);
    ($width, $height, $size, $format) = $image->Ping(blob=>$blob);

This a more efficient and less memory intensive way to query if an image exists and what its characteristics are.

Poly() builds a polynomial from the image sequence and the corresponding terms (coefficients and degree pairs):

$p = $image->Poly([0.5,1.0,0.25,2.0,1.0,1.0]);

PreviewImage() tiles 9 thumbnails of the specified image with an image processing operation applied at varying strengths. This may be helpful pin-pointing an appropriate parameter for a particular image processing operation. Choose from these operations: Rotate, Shear, Roll, Hue, Saturation, Brightness, Gamma, Spiff, Dull, Grayscale, Quantize, Despeckle, ReduceNoise, AddNoise, Sharpen, Blur, Threshold, EdgeDetect, Spread, Solarize, Shade, Raise, Segment, Swirl, Implode, Wave, OilPaint, CharcoalDrawing, JPEG. Here is an example:

    $preview = $image->Preview('Gamma');
    $preview->Display();

To have full control over text positioning you need font metric information. Use

($x_ppem, $y_ppem, $ascender, $descender, $width, $height, $max_advance) =
  $image->QueryFontMetrics(_parameters_);

Where _parameters_ is any parameter of the [Annotate] method. The return values are:

1.  character width
2.  character height
3.  ascender
4.  descender
5.  text width
6.  text height
7.  maximum horizontal advance
8.  bounds: x1
9.  bounds: y1
10.  bounds: x2
11.  bounds: y2
12.  origin: x
13.  origin: y

Use QueryMultilineFontMetrics() to get the maximum text width and height for multiple lines of text.

Call QueryColor() with no parameters to return a list of known colors names or specify one or more color names to get these attributes: red, green, blue, and opacity value.

    @colors = $image->QueryColor();
    ($red, $green, $blue) = $image->QueryColor('cyan');
    ($red, $green, $blue, $alpha) = $image->QueryColor('#716baeff');

QueryColorname() accepts a color value and returns its respective name or hex value;

$name = $image->QueryColorname('rgba(80,60,0,0)');

Call QueryFont() with no parameters to return a list of known fonts or specify one or more font names to get these attributes: font name, description, family, style, stretch, weight, encoding, foundry, format, metrics, and glyphs values.

    @fonts = $image->QueryFont();
    $weight = ($image->QueryFont('Helvetica'))[5];

Call QueryFormat() with no parameters to return a list of known image formats or specify one or more format names to get these attributes: adjoin, blob support, raw, decoder, encoder, description, and module.

    @formats = $image->QueryFormat();
    ($adjoin, $blob_support, $raw, $decoder, $encoder, $description, $module) =
      $image->QueryFormat('gif');

Call MagickToMime() with the image format name to get its MIME type such as images/tiff from tif.

$mime = $image->MagickToMime('tif');

Use RemoteCommand() to send a command to an already running [display] or [animate] application. The only parameter is the name of the image file to display or animate.

$image->RemoteCommand('image.jpg');

The Smush() method smushes a set of images together. For example,

$p = $image->Smush(stack=>{true,false},offset=>integer);

smushes together all the images associated with object $image. By default, images are smushed left-to-right. Set stack to True to smushed them top-to-bottom.

Statistics() returns the image statistics for each channel in the image. The returned values are an array of depth, minima, maxima, mean, standard deviation, kurtosis, skewness, and entropy values in RGB, CMYK, RGBA, or CMYKA order (depending on the image type).

@statistics = $image->Statistics();

Finally, the Transform() method accepts a fully-qualified geometry specification for cropping or resizing one or more images. For example,

$p = $image->Transform(crop=>'100x100+0+0');

You can optionally add _Image_ to any method name above. For example, PingImage() is an alias for method Ping().

Handling Exceptions
-------------------

All PerlMagick methods return an undefined string context upon success. If any problems occur, the error is returned as a string with an embedded numeric status code. A status code less than 400 is a warning. This means that the operation did not complete but was recoverable to some degree. A numeric code greater or equal to 400 is an error and indicates the operation failed completely. Here is how exceptions are returned for the different methods:

Methods which return a number (e.g. Read(), Write()):

    $x = $image->Read(...);
    warn "$x" if "$x";      # print the error message
    $x =~ /(\d+)/;
    print $1;               # print the error number
    print 0+$x;             # print the number of images read

Methods which operate on an image (e.g. Resize(), Crop()):

    $x = $image->Crop(...);
    warn "$x" if "$x";      # print the error message
    $x =~ /(\d+)/;
    print $1;               # print the error number

Methods which return images (EvaluateSequence(), Montage(), Clone()) should be checked for errors this way:

    $x = $image->Montage(...);
    warn "$x" if !ref($x);  # print the error message
    $x =~ /(\d+)/;
    print $1;               # print the error number

Here is an example error message:

Error 400: Memory allocation failed

Review the complete list of [error and warning codes].

The following illustrates how you can use a numeric status code:

    $x = $image->Read('rose.png');
    $x =~ /(\d+)/;
    die "unable to continue" if ($1 == ResourceLimitError);

Constants
---------

PerlMagick includes these constants:

    BlobError                  MissingDelegateWarning
    BlobWarning                ModuleError
    CacheError                 ModuleWarning
    CacheWarning               Opaque
    CoderError                 OptionError
    CoderWarning               OptionWarning
    ConfigureError             QuantumDepth
    ConfigureWarning           QuantumRange
    CorruptImageError          RegistryError
    CorruptImageWarning        RegistryWarning
    DelegateError              ResourceLimitError
    DelegateWarning            ResourceLimitWarning
    DrawError                  StreamError
    DrawWarning                StreamWarning
    ErrorException             Success
    FatalErrorException        Transparent
    FileOpenError              TypeError
    FileOpenWarning            TypeWarning
    ImageError                 WarningException
    ImageWarning               XServerError
    MissingDelegateError       XServerWarning

You can access them like this:

Image::Magick->QuantumDepth


/Magick++, C++ API
===============================

[Documentation] • [Obtaining Magick++] • [Installation] • [Reporting Bugs]

[Magick++ API] is the object-oriented C++ API to the [ImageMagick] image-processing library.

Magick++ supports an object model which is inspired by [PerlMagick]. Images support implicit reference counting so that copy constructors and assignment incur almost no cost. The cost of actually copying an image (if necessary) is done just before modification and this copy is managed automagically by Magick++. De-referenced copies are automagically deleted. The image objects support value (rather than pointer) semantics so it is trivial to support multiple generations of an image in memory at one time.

Magick++ provides integrated support for the [Standard Template Library](http://www.sgi.com/tech/stl/) (STL) so that the powerful containers available (e.g. [deque](http://www.sgi.com/tech/stl/Deque.html), [vector](http://www.sgi.com/tech/stl/Vector.html), [list](http://www.sgi.com/tech/stl/List.html), and [map](http://www.sgi.com/tech/stl/Map.html)) can be used to write programs similar to those possible with PERL & PerlMagick. STL-compatible template versions of ImageMagick's list-style operations are provided so that operations may be performed on multiple images stored in STL containers.

Documentation
-------------

Detailed [documentation] is provided for all Magick++ classes, class methods, and template functions which comprise the API. See a [Gentle Introduction to Magick++] for an introductory tutorial to Magick++. We include the [source] if you want to correct, enhance, or expand the tutorial.

Obtaining Magick++
------------------

Magick++ is included as part of [ImageMagick] source releases and may be retrieved via [HTTP] or [GitHub](https://github.com/ImageMagick/ImageMagick/tree/main/Magick%2B%2B).

Installation
------------

Once you have the Magick++ sources available, follow these detailed [installation instructions] for UNIX and Windows.

Usage
-----

A helper script named Magick++-config is installed under Linux which assists with recalling compilation options required to compile and link programs which use Magick++. For example, the following command compiles and links the source file demo.cpp to produce the executable demo (notice that quotes are backward quotes):

    c++ `Magick++-config --cxxflags --cppflags` -O2 -o demo demo.cpp \
      `Magick++-config --ldflags --libs` 

Set the PKG_CONFIG_PATH environment variable if ImageMagick is not in your default system path:

    export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig 

Windows users may get started by manually editing a project file for one of the Magick++ demo programs.

Note, under Windows (and possibly the Mac) it may be necessary to initialize the ImageMagick library prior to using the Magick++ library. This initialization is performed by passing the path to the ImageMagick DLLs (assumed to be in the same directory as your program) to the InitializeMagick() function call. This is commonly performed by providing the path to your program (argv[0]) as shown in the following example:

    int main( int argc, char ** argv) {
      InitializeMagick(*argv);
      ...  

This initialization step is not required under Linux, Linux, Cygwin, or any other operating environment that supports the notion of installing ImageMagick in a known location.

Here is a example program that utilizes the Magick++ API to get you started, [magick++.cpp](https://imagemagick.org/source/magick++.cpp). It reads an image, crops it, and writes it to disk in the PNG image format.

```cpp
#include <Magick++.h> 
#include <iostream> 

using namespace std; 
using namespace Magick; 

int main(int argc,char **argv) 
{ 
  InitializeMagick(*argv);

  // Construct the image object. Seperating image construction from the 
  // the read operation ensures that a failure to read the image file 
  // doesn't render the image object useless. 
  Image image;
  try { 
    // Read a file into image object 
    image.read( "logo:" );

    // Crop the image to specified size (width, height, xOffset, yOffset)
    image.crop( Geometry(100,100, 100, 100) );

    // Write the image to a file 
    image.write( "logo.png" ); 
  } 
  catch( Exception &error_ ) 
    { 
      cout << "Caught exception: " << error_.what() << endl; 
      return 1; 
    } 
  return 0; 
} 
```

Reporting Bugs
--------------

Questions regarding usage should be directed to or to report any bugs go to [Magick++ community forum](https://github.com/ImageMagick/ImageMagick/discussions).


/Porting Guide
==============

[ImageMagick Version 7] • [High Dynamic Range Imaging] • [Pixel Channels] • [Alpha] • [Grayscale] • [Masks] • [MagickCore API] • [Header Files] • [Deprecated Features Removed] • [Command-line Interface] • [Performance Improvements] • [Version 7 Change Summary]

The design of ImageMagick is an evolutionary process, with the design and implementation efforts serving to influence and guide further progress in the other. With ImageMagick version 7, we improved the design based on lessons learned from the version 6 implementation. ImageMagick was originally designed to display RGB images to an X Windows server. Over time we extended support to RGBA images and then to the CMYK and CMYKA image format. With ImageMagick version 7, we extend support to arbitrary colorspaces with an arbitrary number of pixel channels. In addition, ImageMagick 7 stores pixel channels as floats permitting out of band values (e.g. negative) and reduces rounding error. There are numerous other design enhancements described within.

To support variable pixel channels in the MagickCore API, pixel handling has changed when getting or setting the pixel channels. You can access channels as an array, pixel[i], or use an accessor method such as GetPixelRed() or SetPixelRed(). There are some modest changes to the MagickCore and MagickWand API's. The Magick++ and PerlMagick API's have not changed and matches that of the ImageMagick version 6.

The shell API (command line) of ImageMagick version 7 has undergone a major overhaul, with specific emphasis on the ability to read 'options' not only from the command line, but also from scripts, and file streams. This allows for the use of 'co-processing' programming techniques or performing image handling using 'daemon/server backends', and even multi-machine distributed processing.

With the shell API overhaul other improvements were made, including: better reporting of which option failed, the consolidation and deprecation of options, and more global use of 'image properties' (more commonly known as 'percent escapes' in option arguments.

ImageMagick version 7 is available now as a [production](https://imagemagick.org/archive) release.

Now that ImageMagick version 7 is released, we continue to support version 6 for a minimum of 10 years. Support for version 6 is limited primarily to bug fixes and security patches with few enhancements.

High Dynamic Range Imaging
--------------------------

ImageMagick version 7 enables [high dynamic range imaging] (HDRI) by default. HDRI accurately represents the wide range of intensity levels found in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows. In addition, image processing results are more accurate. The disadvantage is it requires more memory and may result in slower processing times. If you see differences in the results of your version 6 command-line with version 7, it is likely due to HDRI. You may need to add -clamp to your command-line to constrain pixels to the 0 .. QuantumRange range, or disable HDRI when you build ImageMagick version 7. To disable HDRI (recommended for smart phone builds such as iOS or production sites where performance is a premium), simply add --disable-hdri to the configure script command line when building ImageMagick.

Pixel Channels
--------------

A pixel is comprised of one or more color values, or channels (e.g. red pixel channel).

Prior versions of ImageMagick (4-6), support 4 to 5 pixel channels (RGBA or CMYKA). The first 4 channels are accessed with the PixelPacket data structure. The structure includes 4 members of type Quantum (typically 16-bits) of red, green, blue, and opacity. The black channel or colormap indexes are supported by a separate method and structure, IndexPacket. As an example, here is a code snippet from ImageMagick version 6 that negates the color components (but not the alpha component) of the image pixels:

```cpp
for (y=0; y < (ssize_t) image->rows; y++)
{
  IndexPacket
    *indexes;

  PixelPacket
    *q;

  q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
  if (q == (PixelPacket *) NULL)
    {
      status=MagickFalse;
      continue;
    }
  indexes=GetCacheViewAuthenticIndexQueue(image_view);
  for (x=0; x < (ssize_t) image->columns; x++)
  {
    if ((channel & RedChannel) != 0)
      q->red=(Quantum) QuantumRange-q->red;
    if ((channel & GreenChannel) != 0)
      q->green=(Quantum) QuantumRange-q->green;
    if ((channel & BlueChannel) != 0)
      q->blue=(Quantum) QuantumRange-q->blue;
    if (((channel & IndexChannel) != 0) &&
        (image->colorspace == CMYKColorspace))
      indexes[x]=(IndexPacket) QuantumRange-indexes[x];
    q++;
  }
  if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
    status=MagickFalse;
}
```

ImageMagick version 7 supports any number of channels from 1 to 64 (and beyond) and simplifies access with a single method that returns an array of pixel channels of type Quantum. Source code that compiles against prior versions of ImageMagick requires refactoring to work with ImageMagick version 7. We illustrate with an example. Let's naively refactor the version 6 code snippet from above so it works with the ImageMagick version 7 API:

```cpp
for (y=0; y < (ssize_t) image->rows; y++)
{
  Quantum
    *q;

  q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    {
      status=MagickFalse;
      continue;
    }
  for (x=0; x < (ssize_t) image->columns; x++)
  {
    if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
      SetPixelRed(image,QuantumRange-GetPixelRed(image,q),q);
    if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
      SetPixelGreen(image,QuantumRange-GetPixelGreen(image,q),q);
    if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
      SetPixelBlue(image,QuantumRange-GetPixelBlue(image,q),q);
    if ((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0)
      SetPixelBlack(image,QuantumRange-GetPixelBlack(image,q),q);
    if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
      SetPixelAlpha(image,QuantumRange-GetPixelAlpha(image,q),q);
    q+=GetPixelChannels(image);
  }
  if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
    status=MagickFalse;
}
```

Let's do that again but take full advantage of the new variable pixel channel support:

```cpp
for (y=0; y < (ssize_t) image->rows; y++)
{
  Quantum
    *q;

  q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    {
      status=MagickFalse;
      continue;
    }
  for (x = 0; x < (ssize_t) image->columns; x++)
  {
    ssize_t
      i;

    if (GetPixelWriteMask(image,q) <= (QuantumRange/2))
      {
        q+=GetPixelChannels(image);
        continue;
      }
    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
    {
      PixelChannel channel = GetPixelChannelChannel(image,i);
      PixelTrait traits = GetPixelChannelTraits(image,channel);
      if ((traits & UpdatePixelTrait) == 0)
        continue;
      q[i]=QuantumRange-q[i];
    }
    q+=GetPixelChannels(image);
  }
  if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
    status=MagickFalse;
}
```

Note, how we use GetPixelChannels() to advance to the next set of pixel channels.

The colormap indexes and black pixel channel (for the CMYK colorspace) are no longer stored in the index channel, previously accessed with GetAuthenticIndexQueue() and GetCacheViewAuthenticIndexQueue(). Instead they are now a first class pixel channel and accessed as a member of the pixel array (e.g. pixel[4]) or with the convenience pixel accessor methods GetPixelIndex(), SetPixelIndex(), GetPixelBlack(), and SetPixelBlack().

As a consequence of using an array structure for variable pixel channels, auto-vectorization compilers have additional opportunities to speed up pixel loops.

The `sync` channel in IMv6 was really a flag instead of a channel. In IMv7, we instead use a flag: -define compose:sync=false.

#### Pixel Accessors

You can access pixel channel as array elements (e.g. pixel[1]) or use convenience accessors to get or set pixel channels:

    GetPixela()                  SetPixela()
    GetPixelAlpha()              SetPixelAlpha()
    GetPixelb()                  SetPixelb()
    GetPixelBlack()              SetPixelBlack()
    GetPixelBlue()               SetPixelBlue()
    GetPixelCb()                 SetPixelCb()
    GetPixelCr()                 SetPixelCr()
    GetPixelCyan()               SetPixelCyan()
    GetPixelGray()               SetPixelGray()
    GetPixelGreen()              SetPixelGreen()
    GetPixelIndex()              SetPixelIndex()
    GetPixelL()                  SetPixelL()
    GetPixelMagenta()            SetPixelMagenta()
    GetPixelReadMask()           SetPixelReadMask()
    GetPixelWriteMask()          SetPixelWriteMask()
    GetPixelMetacontentExtent()  SetPixelMetacontentExtent()
    GetPixelOpacity()            SetPixelOpacity()
    GetPixelRed()                SetPixelRed()
    GetPixelYellow()             SetPixelYellow()
    GetPixelY()                  SetPixelY()
        
You can find these accessors defined in the header file, MagickCore/pixel-accessor.h

#### Pixel Traits

Each pixel channel includes one or more of these traits:

    Undefined   no traits associated with this pixel channel
    Copy        do not update this pixel channel, just copy it
    Update      update this pixel channel
    Blend       blend this pixel channel with the alpha mask if it's enabled

We provide these methods to set and get pixel traits:

    GetPixelAlphaTraits()       SetPixelAlphaTraits()
    GetPixelBlackTraits()       SetPixelBlackTraits()
    GetPixelBlueTraits()        SetPixelBlueTraits()
    GetPixelCbTraits()          SetPixelCbTraits()
    GetPixelChannelTraits()     SetPixelChannelTraits()
    GetPixelCrTraits()          SetPixelCrTraits()
    GetPixelGrayTraits()        SetPixelGrayTraits()
    GetPixelGreenTraits()       SetPixelGreenTraits()
    GetPixelIndexTraits()       SetPixelIndexTraits()
    GetPixelMagentaTraits()     SetPixelMagentaTraits()
    GetPixelRedTraits()         SetPixelRedTraits()
    GetPixelYellowTraits()      SetPixelYellowTraits()
    GetPixelYTraits()           SetPixelYTraits()

For convenience you can set the active trait for a set of pixel channels with a channel mask and this method:

SetImageChannelMask()

Previously MagickCore methods had channel analogs, for example, NegateImage() and NegateImageChannels(). The channel analog methods are no longer necessary because the pixel channel traits specify whether to act on a particular pixel channel or whether to blend with the alpha mask. For example, instead of

    NegateImageChannel(image,channel);

we use:

    channel_mask=SetImageChannelMask(image,channel);
    NegateImage(image,exception);
    (void) SetImageChannelMask(image,channel_mask);

#### Pixel User Channels

In version 7, we introduce pixel user channels. Traditionally we utilize 4 channels, red, green, blue, and alpha. For CMYK we also have a black channel. User channels are designed to contain whatever additional channel information that makes sense for your application. Some examples include extra channels in TIFF or PSD images or perhaps you require a channel with infrared information for the pixel. You can associate traits with the user channels so that when they are acted upon by an image processing algorithm (e.g. blur) the pixels are copied, acted upon by the algorithm, or even blended with the alpha channel if that makes sense.

#### Pixel Metacontent

In version 7, we introduce pixel metacontent. Metacontent is content about content. So rather than being the content itself, it's something that describes or is associated with the content. Here the content is a pixel. The pixel metacontent is for your exclusive use (internally the data is just copied, it is not modified) and is accessed with these MagickCore API methods:

    SetImageMetacontentExtent()
    GetImageMetacontentExtent()
    GetVirtualMetacontent()
    GetAuthenticMetacontent()
    GetCacheViewAuthenticMetacontent()
    GetCacheViewVirtualMetacontent()

Alpha
-----

We support alpha now, previously opacity. With alpha, a value of 0 means that the pixel does not have any coverage information and is transparent; i.e. there was no color contribution from any geometry because the geometry did not overlap this pixel. A value of QuantumRange means that the pixel is opaque because the geometry completely overlapped the pixel. As a consequence, in version 7, the PixelInfo structure member alpha has replaced the previous opacity member. Another consequence is the alpha part of an sRGB value in hexadecimal notation is now reversed (e.g. #0000 is fully transparent).

Colorspace
----------

The Rec601Luma and Rec709Luma colorspaces are no longer supported. Instead, specify the gray colorspace and choose from these intensity options:

    Rec601Luma
    Rec601Luminance
    Rec709Luma
    Rec709Luminance

For example,

magick myImage.png -intensity Rec709Luminance -colorspace gray myImage.jpg

Grayscale
---------

Previously, grayscale images were Rec601Luminance and consumed 4 channels: red, green, blue, and alpha. With version 7, grayscale consumes only 1 channel requiring far less resources as a result.

Masks
-----

Version 7 supports masks for most image operators. White pixels in a read mask ignores corresponding pixel in an image whereas white pixels in a write mask protects the corresponding pixel in the image. From the command-line, you can associate a mask with an image with the -read-mask and -write-mask options. This polarity matches the masks in version 6 of ImageMagick for ease of porting your workflow. For convenience, we continue to support the -mask option in version 7 to match the behavior of version 6.

In this example, we compute the distortion of a masked reconstructed image:

compare -metric rmse -read-mask hat_mask.png hat.png wizard.png difference.png

Here we protect certain pixels from change:

magick rose: -write-mask rose_bg_mask.png -modulate 110,100,33.3  +write-mask rose_blue.png

A mask associated with an image persists until it is modified or removed. This may produce unexpected results for complex command-lines. Here we only want to clip when applying the alpha option, not the resize:

convert -density 300 -colorspace srgb image.eps -alpha transparent -clip -alpha opaque +clip -resize 1000x1000 -strip image.png

MagickCore API
--------------

Here are a list of changes to the MagickCore API:

*   Almost all image processing algorithms are now channel aware.
*   The MagickCore API adds an ExceptionInfo argument to those methods that lacked it in version 6, e.g. NegateImage(image,MagickTrue,exception)
*   All method channel analogs have been removed (e.g. BlurImageChannel()), they are no longer necessary, use pixel traits instead.
*   Public and private API calls are now declared with the GCC visibility attribute. The MagickCore and MagickWand dynamic libraries now only export public struct and function declarations.
*   The InterpolatePixelMethod enum is now PixelInterpolateMethod.
*   The IntegerPixel storage type is removed (use LongPixel instead) and LongLongPixel is added
*   Image signatures have changed to account for variable pixel channels.
*   All color packet structures, PixelPacket, LongPacket, and DoublePacket, are consolidated to a single color structure, PixelInfo.
*   The ChannelMoments structure member I is now invariant. I conflicts with the complex.h header.
*   We added a length parameter to FormatMagickSize() to permit variable length buffers.

MagickWand API
--------------

Here are a list of changes to the MagickWand API:

*   Almost all image processing algorithms are now channel aware.
*   The DrawMatte() method is now called DrawAlpha().
*   The MagickSetImageBias() and MagickSetImageClipMask() methods are no longer supported.

Magick++ API
------------

Here are a list of changes to the Magick++ API:

*   Almost all image processing algorithms are now channel aware.
*   Use this construct, for example, to avoid operating on the alpha channel:
    
    image.negateChannel(Magick::ChannelType(Magick::CompositeChannels ^ Magick::AlphaChannel));
    

Header Files
------------

Prior versions of ImageMagick (4-6) reference the ImageMagick header files as magick/ and wand/. ImageMagick 7 instead uses MagickCore/ and MagickWand/ respectively. For example,

    #include <MagickCore/MagickCore.h>
    #include <MagickWand/MagickWand.h>

Deprecated Features Removed
---------------------------

All deprecated features from ImageMagick version 6 are removed in version 7. These include the Magick-config and Wand-config configuration utilities. Instead use:

    MagickCore-config
    MagickWand-config

The FilterImage() method has been removed. Use ConvolveImage() instead.

In addition, all deprecated [MagickCore](http://magick.imagemagick.org/api/deprecate.html) and [MagickWand](http://magick.imagemagick.org/api/magick-deprecate.html) methods are no longer available in version 7.

The Bessel filter was removed as it is an alias for Jinc. Use -filter Jinc instead.

Shell API or Command-line Interface
-----------------------------------

As mentioned the primary focus of the changes to the Shell API or Command Line Interface is the abstraction so that not only can options be read from command line arguments, but also from a file (script) or from a file stream (interactive commands, or co-processing).

To do this the CLI parser needed to be re-written, so as to always perform all options, in a strict, do-it-as-you-see it order. Previously in IMv6 options were performed in groups (known as 'FireOptions), this awkwardness is now gone. However the strict order means that you can no longer give operations before providing an image for the operations to work on. To do so will now produce an error.

Error reporting is now reporting exactly which option (by argument count on command line, or line,column in scripts) caused the 'exception'. This is not complete as yet but getting better. Also not complete is 'regard-warnings' handling or its replacement, which will allow you to ignore reported errors and continue processing (as appropriate due to error) in co-processes or interactive usage.

With the IMv7 parser, activated by the `magick` utility, settings are applied to each image in memory in turn (if any). While an option: only need to be applied once globally. Using the other utilities directly, or as an argument to the `magick` CLI (e.g. `magick`) utilizes the legacy parser.

The parenthesis options used to 'push' the current image list, and image settings (EG: '(' and ')' ) on to a stack now has a completely separate image settings stack. That is parenthesis 'push/pull' image lists, and curly braces (EG: '{' and '}' ) will 'push/pull' image settings.

Of course due to the previously reported changes to the underlying channel handling will result be many side effects to almost all options. Here are some specific

Most algorithms update the red, green, blue, black (for CMYK), and alpha channels. Most operators will blend alpha the other color channels, but other operators (and situations) may require this blending to be disabled, and is currently done by removing alpha from the active channels via -channel option. (e.g. magick castle.gif -channel RGB -negate castle.png).

Reading gray-scale images generate an image with only one channel. If that image is to then accept color the -colorspace setting needs to be applied to expand the one channel into separate RGB (or other) channels.

Previously, command-line arguments were limited to 4096 characters, with ImageMagick version 7 the limit has increased to 131072 characters.

Command Changes
---------------

Here are a list of changes to the ImageMagick commands:

magick

The "magick" command is the new primary command of the Shell API, replacing the old "magick" command. This allows you to create a 'magick script' of the form "#!/path/to/command/magick -script", or pipe options into a command "magick -script -, as a background process.

magick-script

This the same as "magick", (only command name is different) but which has an implicit "-script" option. This allows you to use it in an "env" style script form. That is a magick script starts with the 'she-bang' line of "#!/usr/bin/env magick-script" allowing the script interpreter to be found anywhere on the users command "PATH". This is required to get around a "one argument she-bang bug" that is common on most UNIX systems (including Linux, but not MacOSX).

animate, compare, composite, conjure, convert, display, identify, import, mogrify, montage, stream

To reduce the footprint of the command-line utilities, these utilities are symbolic links to the magick utility. You can also invoke them from the magick utility, for example, use magick logo: logo.png to invoke the magick utility.

Behavioral Changes
------------------

Image settings are applied to each image on the command line. To associate a setting with a particular image, use parenthesis to remove ambiguity. In this example we assign a unique page offset to each image:

    magick ( -page +10+20 first.png ) ( -page +100+200 second.png ) ...

By default, image operations such as convolution blends alpha with each channel. To convolve each channel independently, deactivate the alpha channel as follows:

    magick ... -alpha discrete -blur 0x1 ...

To remove the alpha values from your image, use -alpha off. If you want to instead persist the alpha channel but not blend the alpha pixels for certain image processing operations, use -alpha deactivate instead.

Some options have changed in ImageMagick version 7. These include:

*   -channel

    the default is to update the RGBA channels, previously, in IMv6, the default was RGB. If you get results that differ from IMv6, you may need to specify -channel RGB on your command line (e.g. -channel RGB -negate).

*   +combine

    This option now requires an argument, the image colorspace (e.g. +combine sRGB).

*   -format

    The %Z image property is no longer supported.

*   -gamma

    Multiple gamma arguments (e.g. -gamma 1,2,3) are no longer supported, instead use -channel (e.g. -channel blue -gamma 2).

*   -region

    This option sets a write mask for the region you define. In IMv6, a separate image was cloned instead, operated on, and the results were composited to the source image. In addition, the draw transformations are relative to the upper left corner of the image, previously in IMv6 they were relative to the region.

Use -define morphology:showKernel=1 to post the morphology or convolution kernel. Previously it was -define showKernel=1.

New Options
-----------

ImageMagick version 7 supports these new options, though most are limited to the "magick" command, or to use in "magick" scripts.

{ ... }

Save (and restore) the current image settings (internally known as the "image_info" structure). This is automatically done with parenthesis (EG: '(' and ')') is "-regard-parenthesis" has been set, just as in IMv6. Caution is advised to prevent un-balanced braces errors.

--

End of options, to be used in IMv7 "mogrify" command to explicitly separate the operations to be applied and the images that are to be processed 'in-place'. (not yet implemented). However if not provided, "-read" can still be used to differentiate secondary image reads (for use in things like alpha composition) from the 'in-place' image being processed. In other commands (such as "magick") it is equivalent to an explicit "-read" (see below) of the next option as an image (as it was in IMv6).

-alpha activate/deactivate

enables and disables the alpha channel, respectively, with persistence. This is like on/off in Imagemagick 6. In Imagemagick 7, -alpha off will remove the alpha channel permanently such that -alpha on will not re-enable it.

-alpha discrete

treat the alpha channel independently (do not blend).

-channel-fx expression

exchange, extract, or copy one or more image channels.

The expression consists of one or more channels, either mnemonic or numeric (e.g. red or 0, green or 1, etc.), separated by certain operation symbols as follows:

<=>  exchange two channels (e.g. red<=>blue)
=>   copy one channel to another channel (e.g. red=>green)
=    assign a constant value to a channel (e.g. red=50%)
,    write new image with channels in the specified order (e.g. red, green)
;    add a new output image for the next set of channel operations (e.g. red; green; blue)
|    move to the next input image for the source of channel data (e.g. | gray=>alpha)

For example, to create 3 grayscale images from the red, green, and blue channels of an image, use:

-channel-fx "red; green; blue"

A channel without an operation symbol implies separate (i.e, semicolon).

Here we take an sRGB image and a grayscale image and inject the grayscale image into the alpha channel:

magick wizard.png mask.pgm -channel-fx '| gray=>alpha' wizard-alpha.png

Use a similar command to define a read mask:

magick wizard.png mask.pgm -channel-fx '| gray=>read-mask' wizard-mask.png

Add -debug pixel prior to the -channel-fx option to track the channel morphology.

-exit

Stop processing at this point. No further options will be processed after this option. Can be used in a script to force the "magick" command to exit, without actually closing the pipeline that it is processing options from. May also be used as a 'final' option on the "magick" command line, instead of an implicit output image, to completely prevent any image write. ASIDE: even the "NULL:" coder requires at least one image, for it to 'not write'! This option does not require any images at all.

-read {image}

Explicit read of an image, rather than an implicit read. This allows you to read from filenames that start with an 'option' character, and which otherwise could be mistaken as an option (unknown or otherwise). This will eventually be used in "mogrify" to allow the reading of secondary images, and allow the use of image list operations within that command.

-read-mask

prevent updates to image pixels specified by the mask

-region

supported in ImageMagick 7.0.2-6 and above

-script {file}

In "magick", stop the processing of command line arguments as image operations, and read all further options from the given file or pipeline.

-write-mask

prevent pixels from being written.

Changed Options
---------------

These options are known to have changed, in some way.

*   -bias

    The option is no longer recognized. Use -define convolve:bias=value instead.

*   -draw

    The matte primitive is now alpha (e.g. -draw 'alpha 0,0 floodfill').

*   -negate

    currently negates all channels, including alpha if present. As such you may need to use the -channel option to prevent alpha negation (e.g. -channel RGB -negate).

*   -preview

    this option is now an image operator. The PREVIEW image format has been removed.

Deprecated warning given, but will work (for now)
-------------------------------------------------

    -affine        Replaced by -draw "affine ...". (see transform)
    -average       Replaced by -evaluate-sequence Mean.
    -box           eplaced by -undercolor.
    -deconstruct   Replaced by -layers CompareAny.
    -gaussian      Replaced by -gaussian-blur.
    -/+map         Replaced by -/+remap.
    -/+mask        Replaced by -/+read-mask, -/+write-mask.
    -/+matte       Replaced by -alpha Set/Off.
    -transform     Replaced by -distort Affine "...".

Deprecated warning given, and ignored (for now)
-----------------------------------------------

Almost 'plus' (+) option that did not do anything has been marked as deprecated, and does nothing. It does not even have associated code. For example "+annotate", "+resize", "+clut", and "+draw" .

    -affinity  Replaced by -remap.
    -maximum   Replaced by -evaluate-sequence Max.
    -median    Replaced by -evaluate-sequence Median.
    -minimum   Replaced by -evaluate-sequence Min.
    -recolor   Replaced by -color-matrix.

Removed / Replaced Options ("no such option" error and abort)
-------------------------------------------------------------

    -interpolate filter   remove slow and useless interpolation method
    -origin               old option, unknown meaning.
    -pen                  Replaced by -fill.
    -passphrase           old option, unknown meaning

Performance Improvements
------------------------

Operating on grayscale images is significantly improved as only one channel is required. Previously, grayscale required three channels.

The performance of [-fx] option has increased by one to two orders of magnitude.

Version 7 Change Summary
------------------------

Changes from ImageMagick version 6 to version 7 are summarized here:

#### High Dynamic Range Imaging

*   ImageMagick version 7 enables HDRI by default. Expect more accurate image processing results with higher memory requirements and possible slower processing times. You can disable this feature for resource constrained system such as a cell phone with a slight loss of accuracy for certain algorithms (e.g. resizing).

#### Pixels

*   Pixels are no longer addressed with PixelPacket structure members (e.g. red, green, blue, opacity) but as an array of channels (e.g. pixel[PixelRedChannel]).
*   Use convenience macros to access pixel channels (e.g. GetPixelRed(), SetPixelRed()).
*   The black channel for the CMYK colorspace is no longer stored in the index channel, previously accessed with GetAuthenticIndexQueue() and GetCacheViewAuthenticIndexQueue(). Instead it is now a pixel channel and accessed with the convenience pixel macros GetPixelBlack() and SetPixelBlack().
*   The index channel for colormapped images is no longer stored in the index channel, previously accessed with GetAuthenticIndexQueue() and GetCacheViewAuthenticIndexQueue(). Instead it is now a pixel channel and accessed with the convenience pixel macros GetPixelIndex() and SetPixelIndex().
*   Use GetPixelChannels() to advance to the next set of pixel channels.
*   Use the metacontent channel to associate metacontent with each pixel.
*   All color packet structures, PixelPacket, LongPacket, and DoublePacket, are consolidated to a single color structure, PixelInfo.

#### Alpha

*   We support alpha rather than opacity (0 transparent; QuantumRange opaque).
*   Use GetPixelAlpha() or SetPixelAlpha() to get or set the alpha pixel channel value.

#### Grayscale

*   Grayscale images consume one pixel channel in ImageMagick version 7. To process RGB, set the colorspace to RGB (e.g. -colorspace sRGB).

#### Masks

*   ImageMagick version 6 only supports read mask in limited circumstances. Version 7 supports both a read and write mask. The read mask is honored by most image-processing algorithms.

#### MagickCore API

*   Almost all image processing algorithms are now channel aware.
*   MagickCore, version 7, adds an ExceptionInfo argument to those methods that lacked it in version 6, e.g. NegateImage(image,MagickTrue,exception);
*   All method channel analogs have been removed (e.g. BlurImageChannel()), they are no longer necessary, use pixel traits instead.
*   Public and private API calls are now declared with the GCC visibility attribute. The MagickCore and MagickWand dynamic libraries now only export public struct and function declarations.
*   The InterpolatePixelMethod enum is now PixelInterpolateMethod.
*   To account for variable pixel channels, images may now return a different signature.

#### Deprecated Methods

*   All ImageMagick version 6 MagickCore and MagickWand deprecated methods are removed and no longer available in ImageMagick version 7.
*   All MagickCore channel method analogs are removed (e.g. NegateImageChannels()). For version 7, use pixel traits instead.
*   The FilterImage() method has been removed. Use ConvolveImage() instead.


/MagickWand Image API for C
===========================

The [MagickWand API] is the recommended interface between the C programming language and the ImageMagick image processing libraries. Unlike the [MagickCore] C API, MagickWand uses only a few opaque types. Accessors are available to set or get important wand properties. A description of the MagickWand public methods are found here:

*   [Magick Wand Methods]
*   [Set or Get Magick Wand Properties]
*   [Magick Wand Image Methods]
*   [Pixel Iterator Methods]
*   [Pixel Wand Methods]
*   [Image Vector Drawing]
*   [Command-line Interface]
*   [Wand View Methods]
*   [Deprecated Methods]
*   [Error and Warning Codes]

After you write your MagickWand program, compile it like this:

cc -o wand wand.c `pkg-config --cflags --libs MagickWand`

Set the PKG_CONFIG_PATH environment variable if ImageMagick is not in your default system path:

export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig

Here is a example program that utilizes the MagickWand API to get you started, [wand.c](https://imagemagick.org/source/wand.c). It reads an image, creates a thumbnail, and writes the result to disk.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <MagickWand/MagickWand.h>

int main(int argc,char **argv)
{
#define ThrowWandException(wand) \
{ \
  char \
    *description; \
 \
  ExceptionType \
    severity; \
 \
  description=MagickGetException(wand,&severity); \
  (void) fprintf(stderr,"%s %s %lu %s\n",GetMagickModule(),description); \
  description=(char *) MagickRelinquishMemory(description); \
  exit(-1); \
}

  MagickBooleanType
    status;

  MagickWand
    *magick_wand;

  if (argc != 3)
    {
      (void) fprintf(stdout,"Usage: %s image thumbnail\n",argv[0]);
      exit(0);
    }
  /*
    Read an image.
  */
  MagickWandGenesis();
  magick_wand=NewMagickWand();
  status=MagickReadImage(magick_wand,argv[1]);
  if (status == MagickFalse)
    ThrowWandException(magick_wand);
  /*
    Turn the images into a thumbnail sequence.
  */
  MagickResetIterator(magick_wand);
  while (MagickNextImage(magick_wand) != MagickFalse)
    MagickResizeImage(magick_wand,106,80,LanczosFilter,1.0);
  /*
    Write the image then destroy it.
  */
  status=MagickWriteImages(magick_wand,argv[2],MagickTrue);
  if (status == MagickFalse)
    ThrowWandException(magick_wand);
  magick_wand=DestroyMagickWand(magick_wand);
  MagickWandTerminus();
  return(0);
}
```

Here is another program that shows one way to get and set image pixels with the MagickWand API, [contrast.c](https://imagemagick.org/source/contrast.c). It reads an image, applies sigmoidal non-linearity contrast control, and writes the result to disk.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <MagickWand/MagickWand.h>

int main(int argc,char **argv)
{
#define SigmoidalContrast(x) \
  (QuantumRange*(1.0/(1+exp(10.0*(0.5-QuantumScale*x)))-0.0066928509)*1.0092503)
#define ThrowWandException(wand) \
{ \
  char \
    *description; \
 \
  ExceptionType \
    severity; \
 \
  description=MagickGetException(wand,&severity); \
  (void) fprintf(stderr,"%s %s %lu %s\n",GetMagickModule(),description); \
  description=(char *) MagickRelinquishMemory(description); \
  exit(-1); \
}

  long
    y;

  MagickBooleanType
    status;

  MagickWand
    *contrast_wand,
    *image_wand;

  PixelInfo
    pixel;

  PixelIterator
    *contrast_iterator,
    *iterator;

  PixelWand
    **contrast_pixels,
    **pixels;

  register long
    x;

  unsigned long
    width;

  if (argc != 3)
    {
      (void) fprintf(stdout,"Usage: %s image sigmoidal-image\n",argv[0]);
      exit(0);
    }
  /*
    Read an image.
  */
  MagickWandGenesis();
  image_wand=NewMagickWand();
  status=MagickReadImage(image_wand,argv[1]);
  if (status == MagickFalse)
    ThrowWandException(image_wand);
  contrast_wand=CloneMagickWand(image_wand);
  /*
    Sigmoidal non-linearity contrast control.
  */
  iterator=NewPixelIterator(image_wand);
  contrast_iterator=NewPixelIterator(contrast_wand);
  if ((iterator == (PixelIterator *) NULL) ||
      (contrast_iterator == (PixelIterator *) NULL))
    ThrowWandException(image_wand);
  for (y=0; y < (long) MagickGetImageHeight(image_wand); y++)
  {
    pixels=PixelGetNextIteratorRow(iterator,&width);
    contrast_pixels=PixelGetNextIteratorRow(contrast_iterator,&width);
    if ((pixels == (PixelWand **) NULL) ||
        (contrast_pixels == (PixelWand **) NULL))
      break;
    for (x=0; x < (long) width; x++)
    {
      PixelGetMagickColor(pixels[x],&pixel);
      pixel.red=SigmoidalContrast(pixel.red);
      pixel.green=SigmoidalContrast(pixel.green);
      pixel.blue=SigmoidalContrast(pixel.blue);
      pixel.index=SigmoidalContrast(pixel.index);
      PixelSetPixelColor(contrast_pixels[x],&pixel);
    }
    (void) PixelSyncIterator(contrast_iterator);
  }
  if (y < (long) MagickGetImageHeight(image_wand))
    ThrowWandException(image_wand);
  contrast_iterator=DestroyPixelIterator(contrast_iterator);
  iterator=DestroyPixelIterator(iterator);
  image_wand=DestroyMagickWand(image_wand);
  /*
    Write the image then destroy it.
  */
  status=MagickWriteImages(contrast_wand,argv[2],MagickTrue);
  if (status == MagickFalse)
    ThrowWandException(image_wand);
  contrast_wand=DestroyMagickWand(contrast_wand);
  MagickWandTerminus();
  return(0);
}
```

Now lets perform the same contrast enhancement while taking advantage of our dual or quad-core processing system by running the algorithm in parallel utilizing wand views. The [sigmoidal-contrast.c](https://imagemagick.org/source/wand/sigmoidal-contrast.c) module reads an image, applies sigmoidal non-linearity contrast control, and writes the result to disk just like the previous contrast enhancement program, but now it does its work in parallel (assumes ImageMagick is built with OpenMP support).

```cpp
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <MagickWand/MagickWand.h>

static MagickBooleanType SigmoidalContrast(WandView *contrast_view,
  const ssize_t y,const int thread_id,void *context)
{
#define SigmoidalContrast(x) \
  (QuantumRange*(1.0/(1+exp(10.0*(0.5-QuantumScale*x)))-0.0066928509)*1.0092503)

  PixelInfo
    pixel;

  PixelWand
    **pixels;

  RectangleInfo
    extent;

  register ssize_t
    x;

  extent=GetWandViewExtent(contrast_view);
  pixels=GetWandViewPixels(contrast_view);
  for (x=0; x < (ssize_t) extent.width; x++)
  {
    PixelGetMagickColor(pixels[x],&pixel);
    pixel.red=SigmoidalContrast(pixel.red);
    pixel.green=SigmoidalContrast(pixel.green);
    pixel.blue=SigmoidalContrast(pixel.blue);
    pixel.index=SigmoidalContrast(pixel.index);
    PixelSetPixelColor(pixels[x],&pixel);
  }
  return(MagickTrue);
}

int main(int argc,char **argv)
{
#define ThrowWandException(wand) \
{ \
  char \
    *description; \
 \
  ExceptionType \
    severity; \
 \
  description=MagickGetException(wand,&severity); \
  (void) fprintf(stderr,"%s %s %lu %s\n",GetMagickModule(),description); \
  description=(char *) MagickRelinquishMemory(description); \
  exit(-1); \
}

  MagickBooleanType
    status;

  MagickWand
    *contrast_wand;

  PixelInfo
    pixel;

  WandView
    *contrast_view;

  if (argc != 3)
    {
      (void) fprintf(stdout,"Usage: %s image sigmoidal-image\n",argv[0]);
      exit(0);
    }
  /*
    Read an image.
  */
  MagickWandGenesis();
  contrast_wand=NewMagickWand();
  status=MagickReadImage(contrast_wand,argv[1]);
  if (status == MagickFalse)
    ThrowWandException(contrast_wand);
  /*
    Sigmoidal non-linearity contrast control.
  */
  contrast_view=NewWandView(contrast_wand);
  if (contrast_view == (WandView *) NULL)
    ThrowWandException(contrast_wand);
  status=UpdateWandViewIterator(contrast_view,SigmoidalContrast,(void *) NULL);
  if (status == MagickFalse)
    ThrowWandException(contrast_wand);
  contrast_view=DestroyWandView(contrast_view);
  /*
    Write the image then destroy it.
  */
  status=MagickWriteImages(contrast_wand,argv[2],MagickTrue);
  if (status == MagickFalse)
    ThrowWandException(contrast_wand);
  contrast_wand=DestroyMagickWand(contrast_wand);
  MagickWandTerminus();
  return(0);
}
```

[MagickWand Examples in C] illustrates how to use the ImageMagick MagickWand API. Each example is presented as a C function, complete with headers, so that it can be copied to a file and then included in your own C project.


/Parallel Execution with OpenCL
===============================

ImageMagick has built-in support for some [OpenCL](http://en.wikipedia.org/wiki/OpenCL) accelerated operations. However, there are some conditions for its operation. These requirements are listed below.

1.  **GPU platform:** AMD or Intel GPUs are supported. NVIDIA support is not enabled at the moment.
2.  **OS and drivers:**
    *   **Mac OS X:** has built-in support for OpenCL. No other actions required.
    *   **Linux/Windows:** on supported platforms, install required drivers to enable OpenCL.
    *   **Mobile:** ImageMagick's OpenCL support is not available on mobile OSes (IOS/Android).
3.  **Compile-time flag:** ImageMagick's OpenCL must be explicitly enabled when compiling. This is done by running configure with --enable-opencl flag set.
4.  **Check runtime support:** to verify if OpenCL support is enabled, run magick --version. The command output should read Features: ... **OpenCL** ...
5.  **Runtime flag:** OpenCL is disabled by default in runtime. To enable it use the environment variable MAGICK_OCL_DEVICE=true, e.g. MAGICK_OCL_DEVICE=true magick <options>.
6.  **Command line utility:** for proper OpenCL support it's recommended to use magick utility over convert, mogrify and others.
7.  **Image type:** OpenCL acceleration only works on images without a color map. Use true color images instead.
8.  **Operators:** the following is a list of image operators that have been OpenCL accelerated.
        
          blur
          contrast
          charcoal
          function
          grayscale
          motion-blur
          resize
    
    The following operators are OpenCL accelerated as well, but they require alpha channel to be enabled, e.g. magick sample.jpg -alpha on -despeckle null:.
        
          despeckle
          equalize
          modulate
    

#### OpenCL Operation Notes

When some of the OpenCL accelerated operators are invoked for the first time and all the conditions above are met, ImageMagick conducts a series of tests to configure the OpenCL environment according to the system hardware; therefore, it is normal to experience a higher latency the first time you use an accelerated option. The OpenCL kernels are embedded inside ImageMagick in source format. During the initial setup, ImageMagick discovers all the available OpenCL devices and compiles the kernels for each of these targets. ImageMagick also runs several performance tests internally to determine the preferred device to use. The compiled kernel code and the performance test results are stored into the cache directory so that the data can be reused by subsequent invocations of the OpenCL path. By default, the OpenCL cached data is stored in $HOME/.cache/ImageMagick on Linux and on MacOSX or in %LOCALAPPDATA%\ImageMagick on Windows. To run these tests for the first time, use the command below:

MAGICK_OCL_DEVICE=true magick sample.jpg -blur 0x5 null:

On Windows the MAGICK_OCL_DEVICE=true part should be removed and the command set MAGICK_OCL_DEVICE=true should be executed before executing the command above to enable OpenCL operations.

To change the cache directory, set the MAGICK_OPENCL_CACHE_DIR environment variable. ImageMagick is able to detect hardware changes, driver updates, and new kernel sources and re-run the setup and the calibration test. You can also force ImageMagick to re-run the process by removing the content from the cache directory.

In addition to the environment variables mentioned above, ImageMagick provides a set of APIs that allow developers to gain more fine-grained control of the OpenCL acceleration. For example, use the InitializeOpenCL() function to initialize the OpenCL environment:

```cpp
clEnv=GetCurrentOpenCLEnv();
if (InitializeOpenCL(clEnv,exception) == MagickFalse)
  {
    /* looks like OpenCL is not supported  */
  }
```

/Threads of Execution
=====================

Many of ImageMagick's internal algorithms are threaded to take advantage of speed-ups offered by the multicore processor chips and [OpenMP](http://www.openmp.org). OpenMP, is an API specification for parallel programming. If your compiler supports OpenMP (e.g. gcc, Visual Studio 2005) directives, ImageMagick automatically includes support. To verify, look for the OpenMP feature of ImageMagick with this command:

$ magick identify -version
Version: ImageMagick 7.0.10-50 2021-01-04 Q16 https://imagemagick.org
Copyright: © 1999 ImageMagick Studio LLC
Features: OpenMP(4.5)

With OpenMP enabled, most ImageMagick algorithms execute on all the cores on your system in parallel. ImageMagick typically divides the work so that each thread processes 64 rows of pixels. As rows are completed, OpenMP assigns more chunks of pixel rows to each thread until the algorithm completes. For example, if you have a quad-core system, and attempt to resize an image, the resizing takes place on 4 cores (8 if hyperthreading is enabled).

You can further increase performance by reducing lock contention with the [tcmalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html) memory allocation library. To enable, add --with-tcmalloc to the configure command-line when you build ImageMagick.

#### The Perils of Parallel Execution

It can be difficult to predict behavior in a parallel environment. Performance might depend on a number of factors including the compiler, the version of the OpenMP library, the processor type, the number of cores, the amount of memory, whether hyperthreading is enabled, the mix of applications that are executing concurrently with ImageMagick, or the particular image-processing algorithm you utilize. The only way to be certain of the optimal performance, in terms of the number of threads, is to benchmark. ImageMagick includes progressive threading when benchmarking a command and returns the elapsed time and efficiency for one or more threads. This can help you identify how many threads are the most efficient in your environment. Here is an example benchmark for threads 1-8:

    $ magick -bench 40 model.png -sharpen 0x1 null:
    Performance[1]: 40i 0.712ips 1.000e 14.000u 0:14.040
    Performance[2]: 40i 1.362ips 0.657e 14.550u 0:07.340
    Performance[3]: 40i 2.033ips 0.741e 14.530u 0:04.920
    Performance[4]: 40i 2.667ips 0.789e 14.590u 0:03.750
    Performance[5]: 40i 3.236ips 0.820e 14.970u 0:03.090
    Performance[6]: 40i 3.802ips 0.842e 15.280u 0:02.630
    Performance[7]: 40i 4.274ips 0.857e 15.540u 0:02.340
    Performance[8]: 40i 4.831ips 0.872e 15.680u 0:02.070

Better performance correlates with higher values of IPS (iterations-per-second). In our example, 8 cores are optimal. However, in certain cases it might be optimal to set the number of threads to 1 (e.g. -limit thread 1) or to disable OpenMP completely. To disable this feature, add --disable-openmp to your configure script command line then rebuild and re-install ImageMagick.

/Export Classification
======================

ImageMagick Studio LLC is a limited liability corporation based in the United States of America. All of our products are developed via online collaboration in public forums and distributed from a central server within the U.S. Therefore, U.S. export laws and regulations apply to our distributions and remain in force as products and technology are re-exported to different parties and places around the world. Information on export control classifications and associated restrictions may be required for exporting, re-exporting, record keeping, bundling/embedding of ImageMagick products, encryption reporting, and shipping documentation. More information on U.S. Export Regulations can be found at the [U. S. Bureau of Industry and Security](http://www.bis.doc.gov/).

The [ImageMagick](https://github.com/ImageMagick/ImageMagick/tree/ImageMagick-7/) software distribution is classified as [ECCN 5D002](http://www.access.gpo.gov/bis/ear/txt/ccl5-pt2.txt). However, ImageMagick Studio LLC makes no warranty or representation that this classification is accurate, current, or complete. ImageMagick is exported under the [TSU exception in EAR 740.13(e)](http://www.access.gpo.gov/bis/ear/txt/740.txt) which applies to software containing or designed for use with encryption software that is publicly available as open source. TSU further provides that Posting encryption source code and corresponding object code on the Internet (e.g., FTP or World Wide Web site) where it may be downloaded by anyone neither establishes "knowledge" of a prohibited export or reexport for purposes of this paragraph, nor triggers any "red flags" necessitating the affirmative duty to inquire[...]. It is your obligation as the exporter to comply with the current applicable requirements of United States export rules and regulations.

/Distributed Pixel Cache
========================

A distributed pixel cache is an extension of the traditional pixel cache available on a single host. The distributed pixel cache may span multiple servers so that it can grow in size and transactional capacity to support very large images or large image sequences. Start up the pixel cache server on one or more hosts. When you read or operate on an image and the local pixel cache resources are exhausted, ImageMagick contacts one or more of these remote pixel servers to store or retrieve pixels.

For really large images or large image sequences, or if there is limited resources on your host, you can utilize a distributed pixel cache on one or more remote hosts. To get started, first set your shared secret in the policy.xml security policy configuration file:

    <policy domain="cache" name="shared-secret" value="_passhrase_" stealth="true"/> 

Here we create two distributed pixel caches and utilize them from our desktop:

    magick -distribute-cache 6668 &  # start on 192.168.100.50
    magick -distribute-cache 6668 &  # start on 192.168.100.51
    magick -limit memory 1GiB -limit map 2GiB -limit disk 4GiB \
      -define registry:cache:hosts=192.168.100.50:6668,192.168.100.51:6668 \
      myhugeimage.jpg -sharpen 5x2 myhugeimage.png 

For large image sequences, the servers are contacted in a round-robin fashion to distribute the load over multiple distributed pixel caches (assuming you have a host list rather than a single host). In our example, some modest resources are available on the desktop as defined by the -limit option. For smaller images, they are allocated on the desktop up to the specified limits.

Your image processing tasks are likely to perform slower when utilizing a distributed pixel cache due to shuffling pixels between the client and the server over a network. Algorithms that access virtual pixels (e.g. -sharpen) are noticeably slower, up to 3 times slower, than algorithms that only access authentic pixels (e.g. -negate) due to increased network traffic.

A client can only contact a compatible distributed pixel cache server. Compatibility requires the same ImageMagick library interface, quantum depth, HDRI status, OS word size, endianness, and passphrase. The distributed pixel cache checks these attributes and throws an exception if these requirements are not met.

/Mirrors
========

ImageMagick source and binary distributions are available from a variety of FTP and Web mirrors around the world listed below. ImageMagick stable and development source releases are also available from [Git](https://github.com/ImageMagick). Before you download, you may want to review recent [changes](https://github.com/ImageMagick/Website/blob/main/ChangeLog.md) to the ImageMagick distribution. The authoritative source code repository is [https://github.com/ImageMagick](https://github.com/ImageMagick/ImageMagick).

The latest release of ImageMagick is version 7.1.0-62.

Germany

[https://mirror.dogado.de/imagemagick/](https://mirror.dogado.de/imagemagick/)

[http://mirror.checkdomain.de/imagemagick/](https://mirror.checkdomain.de/imagemagick/)

[ftp://mirror.checkdomain.de/imagemagick/]

Poland

[https://ftp.icm.edu.pl/pub/unix/graphics/ImageMagick/](https://ftp.icm.edu.pl/pub/unix/graphics/ImageMagick/)

[rsync://ftp.icm.edu.pl/pub/unix/graphics/ImageMagick/]

Sweden

[https://ftp.acc.umu.se/mirror/imagemagick.org/ftp/](https://ftp.acc.umu.se/mirror/imagemagick.org/ftp/)

[rsync://ftp.acc.umu.se/mirror/imagemagick.org/ftp/]

Russia

[https://mirror.surf/imagemagick/](https://mirror.surf/imagemagick/ )

Switzerland

[https://mirror.metanet.ch/imagemagick/](https://mirror.metanet.ch/imagemagick/)

United States

[https://imagemagick.org/archive](https://imagemagick.org/archive)

[https://github.com/ImageMagick](https://github.com/ImageMagick) (Git)

Select Binaries

[http://www.macports.org/ports.html?by=name&substr=imagemagick](http://www.macports.org/ports.html?by=name&substr=imagemagick) (Mac OS X)

[http://hpux.connect.org.uk/hppd/hpux/X11/Viewers/](http://hpux.connect.org.uk/hppd/hpux/X11/Viewers/) (HP-UX 10.20 and 11.00)

Rsync Mirrors

[rsync://mirror.surf/imagemagick//]

[rsync://rsync.is.co.za/IS-Mirror/mirror.imagemagick.org/]

[rsync://mirror.imagemagick.org/magick_html/] (Web site mirror)

[rsync://mirror.imagemagick.org/magick_ftp/] (FTP mirror)

If you want to add a new mirror, please [contact us](https://imagemagick.org/script/contact.php).

/Resources
==========

[Configuration Files] • [Modules] • [Fonts] • [Environment Variables]

ImageMagick depends on a number of external resources including configuration files, loadable modules, fonts, and environment variables.

Configuration Files
-------------------

ImageMagick depends on a number of external configuration files detailed here:

[coder.xml](https://imagemagick.org/source/coder.xml)

Associate an image format with the specified coder module. ImageMagick has a number of coder modules to support the reading and/or writing of an image format (e.g. JPEG). Some coder modules support more than one associated image format and the mapping between an associated format and its respective coder module is defined in this configuration file. For example, the PNG coder module not only supports the PNG image format, but the JNG and MNG formats as well.

[colors.xml](https://imagemagick.org/source/colors.xml)

Associate a color name with its red, green, blue, and alpha intensities. A number of command line options require a [color parameter]. It is often convenient to refer to a color by name (e.g. white) rather than by hex value (e.g. #fff). This file maps a color name to its equivalent red, green, blue, and alpha intensities (e.g. for white, red = 255, green = 255, blue = 255, and alpha = 0).

[configure.xml](https://imagemagick.org/source/configure.xml)

Set ImageMagick build parameters and system-wide environment variables (e.g. MAGICK_TEMPORARY_PATH). As ImageMagick is built, a number of build parameters are saved to this configuration file. They include the version, release date, dependent delegate libraries, and quantum depth among others.

[delegates.xml](https://imagemagick.org/source/delegates.xml)

Associate delegate programs with certain image formats. ImageMagick relies on a number of delegate programs to support certain image formats such as [ufraw-batch](http://ufraw.sourceforge.net/) to read raw camera formats or [Ghostscript](http://www.cs.wisc.edu/~ghost/) to read Postscript images. Use this configuration file to map an input or output format to an external delegate program.

[english.xml](https://imagemagick.org/source/english.xml)

Associate message tags with English translations.

[francais.xml](https://imagemagick.org/source/francais.xml)

Associate message tags with French translations.

[locale.xml](https://imagemagick.org/source/locale.xml)

Associate message tags with a translation for your locale. ImageMagick has a number of informational, warning, and error messages that are represented as tags. Tags are short descriptions of a message such as FileNotFound or MemoryAllocationFailed. This configuration file lists locales that have a translation for each tag recognized by ImageMagick. Currently only English and French translations are available in the english.xml and francais.xml configuration files.

[log.xml](https://imagemagick.org/source/log.xml)

Configure logging parameters. ImageMagick is capable of spewing copious amounts of informational or debugging statements. Use this file to configure how the information will appear in a log message and where you want the logging messages posted.

[mime.xml](https://imagemagick.org/source/mime.xml)

Associate an internet media type with a unique identifier. Many files and data streams have identifiers that uniquely identify a particular internet media type. For example, files in the "Corel Draw drawing" format (mime type="application/vnd.corel-draw") are associated with the filename pattern *.cdr, and also have an initial string of the characters "CDRXvrsn". ImageMagick uses combinations of this information, when available, to attempt to quickly determine the internet media type of a file or data stream.

[policy.xml](https://imagemagick.org/source/policy.xml)

Configure ImageMagick [security policies]. By default any coder, delegate, filter, or file path is permitted. Use a policy to deny access to, for example, the MPEG video delegate, or permit reading images from a file system but deny writing to that same file system. Or use the resource policy to set resource limits. Policies are useful for multi-user servers that want to limit the overall impact ImageMagick has on the system. For example, to limit the maximum image size in memory to 100MP:

    <policy domain="resource" name="area" value="100MP"/>

Any image larger than this area limit is cached to disk rather than memory. Use width to limit the maximum width of an image in pixels. Exceed this limit and an exception is thrown and processing stops.

    <policy domain="resource" name="width" value="8KP"/>

To limit the elapsed time of any ImageMagick command to 5 minutes, use this policy:

    <policy domain="resource" name="time" value="300"/>

For convenience, define arguments for the memory, map, and disk resources with SI prefixes (.e.g 100MB). In addition, resource policies are maximums for each instance of ImageMagick (e.g. policy memory limit 1GB, the -limit 2GB option exceeds policy maximum so memory limit is 1GB).

[quantization-table.xml](https://imagemagick.org/source/quantization-table.xml)

Custom JPEG quantization tables. Activate with -define:q-table=quantization-table.xml.

[thresholds.xml](https://imagemagick.org/source/thresholds.xml)

Set threshold maps for ordered posterized dither.

[type.xml](https://imagemagick.org/source/type.xml)

Configure fonts. Define the font name, family, foundry, style, format, metrics, and glyphs for any font you want to use within ImageMagick.

[type-ghostscript.xml](https://imagemagick.org/source/type-ghostscript.xml)

Configure [Ghostscript](http://www.cs.wisc.edu/~ghost/) fonts. The Ghostscript package includes a number of [fonts](https://sourceforge.net/projects/gs-fonts/) that can be accessed with ImageMagick.

[type-windows.xml](https://imagemagick.org/source/type-windows.xml)

Associate names with Windows font glyphs.

Under Linux and Linux, ImageMagick searches for each of the configuration files listed above by looking in the locations given below, in order, and loads them if found:

    $MAGICK_CONFIGURE_PATH
    $PREFIX/etc/ImageMagick-7 
    $PREFIX/share/ImageMagick-7 
    $XDG_CACHE_HOME/ImageMagick
    $HOME/.config/ImageMagick
    <client path\>/etc/ImageMagick

The environmental variable $PREFIX is the default install path (e.g. /usr/local). The client path is the execution path of your ImageMagick client (e.g. /usr/local) .

For the Linux or Linux pre-compiled uninstalled binary distributions, the configuration load order is:

    $MAGICK_CONFIGURE_PATH
    $MAGICK_HOME/etc/ImageMagick-7 
    $MAGICK_HOME/share/ImageMagick-7 
    $PREFIX/share/ImageMagick-7 
    $XDG_CACHE_HOME/ImageMagick
    $HOME/.config/ImageMagick/
    <client path\>/etc/ImageMagick
    <current directory\>

Under Windows, ImageMagick searches for these configuration files in the following order, and loads them if found:

    $MAGICK_CONFIGURE_PATH
    <windows registry\>
    $PREFIX/config
    $USERPROFILE/.config/ImageMagick
    <client path\>

Above, $PREFIX is the default install path, typically c:\\Program Files\\ImageMagick-7.1.0.

For an uninstalled Windows installation, the configuration load order is:

    $MAGICK_CONFIGURE_PATH
    $MAGICK_HOME
    $USERPROFILE/.config/ImageMagick
    client path
    <current directory\>

If a configuration file cannot not be found, ImageMagick relies on built-in default values.

Modules
-------

#### Coders

An image coder (i.e. encoder / decoder) is responsible for registering, optionally classifying, optionally reading, optionally writing, and unregistering one image format (e.g. PNG, GIF, JPEG, etc.). ImageMagick searches for coders in the following order and it uses the first match found:

    $MAGICK_HOME/lib/ImageMagick-7.1.0/modules-Q16/coders
    <client path\>/../lib/ImageMagick-7.1.0/modules-Q16/coders
    $MAGICK_HOME/lib/ImageMagick-7.1.0/modules-Q16/coders
    $MAGICK_HOME/share/ImageMagick-7.1.0/modules-Q16/coders
    $XDG_CACHE_HOME/ImageMagick
    $HOME/.config/ImageMagick
    <client path\>/lib/ImageMagick-7.1.0/modules-Q16/coders

#### Filters

ImageMagick provides a convenient mechanism for adding your own custom image processing algorithms. ImageMagick searches for filters in the following order and it uses the first match found:

    $MAGICK_HOME/lib/ImageMagick-7.1.0/modules-Q16/filters
    <client path\>/../lib/ImageMagick-7.1.0/modules-Q16/filters
    $MAGICK_HOME/lib/ImageMagick-7.1.0/modules-Q16/filters
    $MAGICK_HOME/share/ImageMagick-7.1.0/modules-Q16/filters
    $XDG_CACHE_HOME/ImageMagick
    $HOME/.config/ImageMagick
    <client path\>/lib/ImageMagick-7.1.0/modules-Q16/filters

Fonts
-----

ImageMagick is able to load raw TrueType and Postscript font files. It searches for the font configuration file, [type.xml], in the following order, and loads them if found:

    $MAGICK_CONFIGURE_PATH
    $MAGICK_HOME/etc/ImageMagick/-7.1.0
    $MAGICK_HOME/share/ImageMagick-7.1.0
    $XDG_CACHE_HOME/ImageMagick
    $HOME/.config/ImageMagick
    <client path\>/etc/ImageMagick
    $MAGICK_FONT_PATH

Environment Variables
---------------------

Environment variables recognized by ImageMagick include:

*    `  HOME  `

    Set path to search for configuration files in $HOME/.config/ImageMagick if the directory exists.

*    `  LD_LIBRARY_PATH  `

    Set path to the ImageMagick shareable libraries and other dependent libraries.

*    `  MAGICK_AREA_LIMIT  `

    Set the maximum width * height of an image that can reside in the pixel cache memory. Images that exceed the area limit are cached to disk (see [MAGICK_DISK_LIMIT]) and optionally memory-mapped.

*    `  MAGICK_CODER_FILTER_PATH  `

    Set search path to use when searching for filter process modules (invoked via [-process]). This path permits the user to extend ImageMagick's image processing functionality by adding loadable modules to a preferred location rather than copying them into the ImageMagick installation directory. The formatting of the search path is similar to operating system search paths (i.e. colon delimited for Linux, and semi-colon delimited for Microsoft Windows). This user specified search path is searched before trying the [default search path].

*    `  MAGICK_CODER_MODULE_PATH  `

    Set path where ImageMagick can locate its coder modules. This path permits the user to arbitrarily extend the image formats supported by ImageMagick by adding loadable coder modules from an preferred location rather than copying them into the ImageMagick installation directory. The formatting of the search path is similar to operating system search paths (i.e. colon delimited for Linux, and semi-colon delimited for Microsoft Windows). This user specified search path is searched before trying the [default search path].

*    `  MAGICK_CONFIGURE_PATH  `

    Set path where ImageMagick can locate its configuration files. Use this search path to search for configuration (.xml) files. The formatting of the search path is similar to operating system search paths (i.e. colon delimited for Linux, and semi-colon delimited for Microsoft Windows). This user specified search path is searched before trying the [default search path].

*    `  MAGICK_DATE_PRECISION  `

    Set the maximum number of characters printed for any timestamp.

*    `  MAGICK_DEBUG  `

    Set debug options. See [-debug] for a description of debugging options.

*    `  MAGICK_DISK_LIMIT  `

    Set maximum amount of disk space in bytes permitted for use by the pixel cache. When this limit is exceeded, the pixel cache is not be created and an error message is returned.

*    `  MAGICK_ERRORMODE  `

    Set the process error mode (Windows only). A typical use might be a value of 1 to prevent error mode dialogs from displaying a message box and hanging the application.

*    `  MAGICK_FILE_LIMIT  `

    Set maximum number of open pixel cache files. When this limit is exceeded, any subsequent pixels cached to disk are closed and reopened on demand. This behavior permits a large number of images to be accessed simultaneously on disk, but with a speed penalty due to repeated open/close calls.

*    `  MAGICK_FONT_PATH  `

    Set path ImageMagick searches for TrueType and Postscript Type1 font files. This path is only consulted if a particular font file is not found in the current directory.

*    `  MAGICK_HEIGHT_LIMIT  `

    Set the maximum height of an image.

*    `  MAGICK_HOME  `

    Set the path at the top of ImageMagick installation directory. This path is consulted by uninstalled builds of ImageMagick which do not have their location hard-coded or set by an installer.

*    `  MAGICK_LIST_LENGTH_LIMIT  `

    Set the maximum length of an image sequence.

*    `  MAGICK_MAP_LIMIT  `

    Set maximum amount of memory map in bytes to allocate for the pixel cache. When this limit is exceeded, the image pixels are cached to disk (see MAGICK_DISK_LIMIT).

*    `  MAGICK_MEMORY_LIMIT  `

    Set maximum amount of memory in bytes to allocate for the pixel cache from the heap. When this limit is exceeded, the image pixels are cached to memory-mapped disk (see [MAGICK_MAP_LIMIT]).

*    `  MAGICK_OCL_DEVICE  `

    Set to off to disable hardware acceleration of certain accelerated algorithms (e.g. blur, convolve, etc.).

*    `  MAGICK_PRECISION  `

    Set the maximum number of significant digits to be printed.

*    `  MAGICK_SHRED_PASSES  `

    If you want to keep the temporary files ImageMagick creates private, overwrite them with zeros or random data before they are removed. On the first pass, the file is zeroed. For subsequent passes, random data is written.

*    `  MAGICK_SYNCHRONIZE  `

    Set to "true" to ensure all image data is fully flushed and synchronized to disk. There is a performance penalty, however, the benefits include ensuring a valid image file in the event of a system crash and early reporting if there is not enough disk space for the image pixel cache.

*    `  MAGICK_TEMPORARY_PATH  `

    Set path to store temporary files.

*    `  MAGICK_THREAD_LIMIT  `

    Set maximum parallel threads. Many ImageMagick algorithms run in parallel on multi-processor systems. Use this environment variable to set the maximum number of threads that are permitted to run in parallel.

*    `  MAGICK_THROTTLE_LIMIT  `

    Periodically yield the CPU for at least the time specified in milliseconds.

*    `  MAGICK_TIME_LIMIT  `

    Set maximum time in seconds. When this limit is exceeded, an exception is thrown and processing stops.

*    `  MAGICK_WIDTH_LIMIT  `

    Set the maximum width of an image.

*    `  SOURCE_DATE_EPOCH  `

    A UNIX timestamp, defined as the number of seconds, excluding leap seconds, since 01 Jan 1970 00:00:00 UTC.

Define arguments for the MAGICK_MEMORY_LIMIT, MAGICK_DISK_LIMIT, and MAGICK_MEMORY_LIMIT environment variables with SI prefixes (.e.g 100MB). MAGICK_WIDTH_LIMIT, MAGICK_HEIGHT_LIMIT and MAGICK_AREA_LIMIT accepts pixel suffixes such as MP for mega-pixels (e.g. 100MP). Note, you can restrict limits relative to any [security policies], but you cannot relax them.

/Voluntary Product Accessibility Template
=========================================

The Voluntary Product Accessibility Template (VPAT) is a document that describes how an information technology (IT) product, such as software, hardware, or web-based applications, meets the accessibility standards defined by Section 508 of the Rehabilitation Act. This VPAT describes the accessibility features of the ImageMagick open-source project.

*   Product Name: ImageMagick
*   Version: 7.1.0

##### Evaluation Methods Used

This VPAT is based on a review of the ImageMagick project documentation, including the project website and the software documentation.

###### Section 1194.21 - Software Applications and Operating Systems

ImageMagick is a command-line utility for creating, editing, and converting images. The software can be used with screen readers and other assistive technologies to access the command-line interface. However, the interface is not optimized for use with assistive technologies, and some users may find it difficult to use without significant customization.

###### Section 1194.22 - Web-based Intranet and Internet Information and Applications

ImageMagick does not have any web-based features, so this section does not apply.

###### Section 1194.23 - Telecommunications Products

ImageMagick does not include any telecommunications features, so this section does not apply.

###### Section 1194.24 - Video and Multimedia Products

ImageMagick does not include any video or multimedia features, so this section does not apply.

Section 1194.25 - Self-Contained, Closed Products

ImageMagick is an open-source command-line utility and does not meet the requirements of this section.

###### Section 1194.26 - Desktop and Portable Computers

ImageMagick is a command-line utility and does not include a graphical user interface (GUI) that could be used with assistive technologies. This section does not apply.

###### Section 1194.31 - Functional Performance Criteria

ImageMagick does not include any functional performance criteria.

###### Section 1194.41 - Information, Documentation, and Support

The ImageMagick project provides online documentation in HTML format, which is accessible using screen readers and other assistive technologies. The documentation includes installation instructions, command-line reference, and other resources. However, some of the documentation may be technical and difficult for non-technical users to understand. The project does not offer any support services for users with disabilities.

##### Conclusion

ImageMagick is an open-source command-line utility that provides basic accessibility features for users who rely on assistive technologies. However, the software is not optimized for use with assistive technologies and may require significant customization to be accessible to all users. The project provides accessible online documentation, but may not be suitable for non-technical users.

/Genesis - History
==================

> I swear by my life and my love of it that I will never live for the sake of another man, nor ask another man to live for mine. -- John Galt in "Atlas Shrugged", by Ayn Rand

ImageMagick started with a request from my DuPont supervisor, Dr. David Pensak, to display computer-generated images on a monitor only capable of showing 256 unique colors simultaneously.

In 1987, monitors that could display 24-bit true color images were rare and quite expensive. There were a plethora of chemists and biologists at DuPont, but very few were computer scientists to confer with. Instead, I turned to Usenet for help, and posted a request for an algorithm to reduce 24-bit images to 256 colors. Paul Raveling of the USC Information Sciences Institute responded, with not only a solution, but one that was already in source code and available from USC's FTP site. Over the course of the next few years, I had frequent opportunities to get help with other vexing computer science problems I encountered in the course of doing my job at DuPont. Eventually I felt compelled to give thanks for the help I received from the knowledgeable folks on Usenet. I decided to freely release the image processing tools I developed to the world so that others could benefit from my efforts.

In 1990 there were few freely available image processing tools so I expected an enthusiastic reception. Before a release was possible, Dr. Pensak had to convince upper management at DuPont to give away what they might perceive as valuable intellectual property. I suspect they agreed simply because ImageMagick was not chemically or biologically based, so they did not understand its value to the company. Either way, ImageMagick would not be available today without DuPont transferring the copyright to ImageMagick Studio LLC. ImageMagick was posted to Usenet's comp.archives group on August 1st, 1990.

After ImageMagick's release, I got the occasional request for an enhancement, a report of a bug, or a contribution to the source base. In the mid 90's, I released the culmination of these efforts as ImageMagick 4.2.9. At the time, I thought ImageMagick was complete. It was utilized by thousands of users world-wide, and it was even showing up as part of a new operating system distributed freely called "Linux".

The next generation of ImageMagick, version 5, started when Bob Friesenhahn contacted me and suggested I improve the application programming interface so users could leverage the image-processing algorithms from other languages or scripts. Bob also wrote a C++ wrapper for ImageMagick called Magick++, and began contributing enhancements such as the module loader facility, automatic file identification, and test suites. In the mean-time, the project picked up a few other notable contributors: Glenn Randers-Pehrson, William Radcliffe, and Leonard Rosenthol. By now, ImageMagick was utilized by tens of thousands of users, who reacted gruffly when a new release broke an existing API call or script. The other members of the group wanted to freeze the API and command line, but I felt ImageMagick was not quite what I had envisioned it could be. Bob and the others created a fork of ImageMagick while I continued to develop ImageMagick.

I did not work alone for long. Anthony Thyssen contacted me about deficiencies in the ImageMagick command line programs. He pointed out that the command line was confusing when dealing with more than one image. He suggested an orderly, well-defined method for dealing with the command line, and this became ImageMagick version 6. His efforts are detailed on his web pages, [Examples of ImageMagick Usage]. I highly recommend that you peruse his site. He has illustrated the power of ImageMagick in ways that even I did not know were possible.

Another notable contributor, Fred Weinhaus, makes available a plethora of command-line [scripts](http://www.fmwconcepts.com/imagemagick/) that perform geometric transforms, blurs, sharpens, edging, noise removal, and color manipulations. Glenn Randers-Pehrson is our PNG guru and makes other valuable contributions. Dirk Lemstra made, and continues to make, numerous improvements to make ImageMagick more robust under Windows and distributes a .NET wrapper, [Magick.NET](https://github.com/dlemstra/Magick.NET).

The design of ImageMagick is an evolutionary process, with the design and implementation efforts serving to influence and guide further progress in the other. With ImageMagick [version 7], we improved the design based on lessons learned from the version 6 implementation. ImageMagick was originally designed to display RGB images to an X Windows server. Over time we extended support to RGBA images and then to the CMYK and CMYKA image format. With ImageMagick version 7, we extend support to arbitrary colorspaces with an arbitrary number of pixel channels. In addition, ImageMagick 7 stores pixel channels as floats permitting out of band values (e.g. negative) and reduces rounding error.

Cristy  
Principal ImageMagick Architect


/Security Policy
================

[Security Policy] • [Pixel Cache Synchronize Policy] • [Zero Configuration Security Policy] • [Other Security Considerations]

It is strongly recommended to establish a security policy suitable for your local environment before utilizing ImageMagick.

The default policy is open, which is useful for ImageMagick installations running in a secure environment, such as in a Docker container or behind a firewall.

ImageMagick is a tool that allows you to manipulate images. While it offers a range of features and capabilities, there is often a trade-off between security and convenience. To ensure optimal security, you can restrict ImageMagick to only reading or writing web-safe image formats like GIF, JPEG, and PNG. Alternatively, you can customize the security policy to fit the needs of your local environment or organizational policies. This policy can include details such as memory usage limits, allowed paths for reading and writing, limits on the number of images in a sequence, maximum workflow runtime, allowed disk space for image pixels, a secret passphrase for remote connections, and which coders are permitted or denied. By customizing the security policy, you can help secure your environment and ensure that ImageMagick is a responsible member of your local system, such as by preventing overloading with large images.

It is important to set limits on ImageMagick's resource usage to prevent potentially harmful situations. For example, if you accidentally download an image from the internet that has been crafted to generate a very large image (e.g., 20000 by 20000 pixels), ImageMagick may try to allocate the necessary resources (such as memory and disk space) and your system may deny the request or cause the program to exit. Alternatively, your computer may become temporarily slow or unresponsive, or ImageMagick may be forced to abort. To avoid such situations, you can set limits in the [policy.xml](https://imagemagick.org/source/policy.xml) configuration file.

Keep in mind that what is considered reasonable for one environment may not be suitable for another. For example, you may have ImageMagick sandboxed in a secure environment, while someone else may use it to process images on a publicly accessible website. Or, ImageMagick may be running on a host with a lot of memory, while another instance is running on a device with limited resources. In the case of the host with large memory, it may make sense to allow large image processing, but not on the device with limited resources. If you are using ImageMagick on a public website, you may want to increase security by disabling certain coders such as MVG or HTTPS.

To help you get started, ImageMagick provides a default policy with reasonable limits, but it is recommended that you modify it to suit your local environment. For example, you may want to set limits on memory usage, allowable paths for reading and writing, the number of images allowed in a sequence, the maximum time a workflow can run, and the amount of disk space allowed for image pixels. Ultimately, it is up to you to decide what limits are appropriate based on your specific environment and needs.

```xml
<policymap>
  <!-- temporary path must be a preexisting writable directory -->
  <policy domain="resource" name="temporary-path" value="/data/magick"/>
  <policy domain="resource" name="memory" value="256MiB"/>
  <policy domain="resource" name="list-length" value="32"/>
  <policy domain="resource" name="width" value="8KP"/>
  <policy domain="resource" name="height" value="8KP"/>
  <policy domain="resource" name="map" value="512MiB"/>
  <policy domain="resource" name="area" value="16KP"/>
  <policy domain="resource" name="disk" value="1GiB"/>
  <policy domain="resource" name="file" value="768"/>
  <policy domain="resource" name="thread" value="2"/>
  <policy domain="resource" name="time" value="120"/>
  <policy domain="module" rights="none" pattern="URL" /> 
  <policy domain="coder" rights="write" pattern="{MSVG,MVG,PS,PDF,XPS}" />
  <policy domain="filter" rights="none" pattern="*" />
  <policy domain="path" rights="none" pattern="-"/>  <!-- don't read/write from/to stdin/stdout -->
  <policy domain="path" rights="none" pattern="/etc/*"/>  <!-- don't read sensitive paths -->
  <policy domain="path" rights="none" pattern="@*"/>  <!-- indirect reads not permitted -->
  <policy domain="cache" name="memory-map" value="anonymous"/>
  <policy domain="cache" name="synchronize" value="true"/>
  <policy domain="cache" name="shared-secret" value="_my-secret-passphrase_" stealth="True"/>
  <policy domain="system" name="shred" value="1"/>
</policymap>
```

To prevent one session from consuming all available memory when processing multiple sessions at the same time, large images are cached to disk with this policy. If an image exceeds the pixel cache disk limit, the program will exit. Additionally, a time limit has been set to prevent any processing tasks from running for too long. If an image has a width or height larger than 8192 pixels, or if an image sequence has more than 32 frames, processing will stop and an exception will be thrown.

Starting with ImageMagick 7.0.1-8, you can prevent the use of any delegate or all delegates (by setting the pattern to "\*"). Prior to these releases, you can use the domain of coder and set rights to none and the glob pattern to HTTPS to prevent delegate usage. Additionally, users are prevented from executing any image filters and from performing indirect reads. If you want to, for example, read text from a file (e.g. caption:@myCaption.txt), you'll need to disable this path policy.

Policy [glob patterns](https://en.wikipedia.org/wiki/Glob_(programming)) are _case sensitive_. To get expected behavior, coders and modules must be upper-case (e.g. "EPS" not "eps") or use a case-insensitive pattern such as [Pp][Nn][Gg].

Here is what you can expect when you restrict the HTTPS coder, for example:

    $ magick ../images/wizard.png wizard.jpg
    convert: attempt to perform an operation not allowed by the security policy `HTTPS'
    convert: no images defined `wizard.jpg'

As of ImageMagick version 7.0.4-7, you can conveniently deny access to all delegates and coders except for a small subset of proven web-safe image types. For example,

```xml
<policy domain="delegate" rights="none" pattern="*" />
<policy domain="module" rights="none" pattern="*" />
<policy domain="module" rights="read | write" pattern="{GIF,JPEG,PNG,WEBP}" />
```

The module policy enables or disables a complete module for both read or write. To just read or write an image format, use the coder policy instead. For example, we disable reading just a few Postscript related formats, however, you can still write them:

```xml
<policy domain="coder" rights="write" pattern="{PDF,PS,PS2,PS3,XPS}" />
```

As of ImageMagick 7.0.7-0, you can allocate the pixel cache and some internal buffers with anonymous memory mapping rather than from heap. As a consequence, the pixels are initialized to zero resulting in a minor performance penalty. You can also jumble the contents of certain memory buffers (requires version 7.1.0-38) and temporary files before they are freed or deleted. The shred value is the number of times to replace content with random data. For example,

```xml
<policy domain="system" name="memory-map" value="anonymous"/>
<policy domain="cache" name="memory-map" value="anonymous"/>
<policy domain="system" name="shred" value="1"/>
```

For performance reasons, the first pass is fast by repeating the random sequence as necessary to overwrite the contents of the buffer or file. Subsequent passes are an order of magnitude slower, but generate cryptographically strong random bytes for the length of the buffer or file.

Some image processing algorithms (e.g. wavelet transform) might consume a substantial amount of memory to complete. ImageMagick maintains a separate memory pool for these large resource requests and as of 7.0.6-1 permits you to set a maximum request limit. If the limit is exceeded, the allocation is instead memory-mapped on disk. Here we limit the maximum memory request by policy:

```xml
<policy domain="system" name="max-memory-request" value="256MiB"/> 
```

As of ImageMagick version 7.0.4-23, you can limit the maximum number of images in a sequence. For example, to limit an image sequence to at most 64 frames, use:

```xml
<policy domain="resource" name="list-length" value="64"/>
```

Note, numeric values in policies are floating-point with an optional SI prefix (e.g., 10MiB).

For additional details about resource limits and the policy configuration file, read [Resources] and [Architecture].

As of ImageMagick 7.0.6-0, you can programmatically set the ImageMagick security policy with SetMagickSecurityPolicy() (MagickCore) or MagickSetSecurityPolicy() (MagickWand).

As of ImageMagick version 7.0.8-11, you can set a module security policy. For example, to prevent Postscript or PDF interpretation, use:

```xml
<policy domain="module" rights="none" pattern="{ps,pdf,xps}/>
```

As of ImageMagick version 7.0-10-52, you can set a font policy. Specify a path to a Unicode font that ImageMagick defaults to whenever the user does not specify a font preference:

```xml
<policy domain="system" name="font" value="/usr/share/fonts/arial-unicode.ttf"/>
```

Note, in file path glob patterns, use the backslash character () to escape characters that would otherwise be interpreted as special characters. For example:

```xml
<policy domain="path" rights="none" pattern="c:\\\\*"/>
```

You can verify your policy changes are in effect with this command:

    $ magick identify -list policy
    Path: ImageMagick-7/policy.xml
      Policy: Cache
        name: memory-map
        value: anonymous
      Policy: Cache
        name: synchronize
        value: true
      Policy: Resource
        name: list-length
        value: 32
      Policy: Resource
        name: time
        value: 120
      Policy: Resource
        name: thread
        value: 2
      Policy: Resource
        name: file
        value: 768
      Policy: Resource
        name: disk
        value: 1GiB
      Policy: Resource
        name: map
        value: 512MiB
      Policy: Resource
        name: memory
        value: 256MiB
      Policy: Resource
        name: area
        value: 16KP
      Policy: Resource
        name: height
        value: 8KP
      Policy: Resource
        name: width
        value: 8KP
      Policy: Resource
        name: temporary-path
        value: /opt/tmp
      Policy: Coder
        rights: Write 
        pattern: {HTTP,HTTPS,MVG,PS,PDF}
      Policy: Filter
        rights: None 
        pattern: *
      Policy: Path
        rights: None 
        pattern: @*
      Policy: System
        name: font
        value: ImageMagick-7/arial-unicode.ttf

    Path: [built-in]
      Policy: Undefined
        rights: None

Notice the shared-secret policy is not listed due to the stealth property.

Doyensec provides a policy evaluator tool that can assist you in designing and auditing your security policy. The tool is found at [imagemagick-secevaluator.doyensec.com](https://imagemagick-secevaluator.doyensec.com/).

Pixel Cache Synchronize Policy
------------------------------

When writing image pixels to disk, ImageMagick first preallocates the disk file, which is faster than fully populating the file with zeros. To improve performance even further, the file is memory-mapped on disk. This can result in an increase in performance of up to 5 times, but there is a possibility that the disk file may run out of free space as it is populated, causing the operating system (OS) to throw a SIGBUS signal which prevents ImageMagick from continuing. To prevent a SIGBUS signal from occurring, use this security policy:

    <policy domain="cache" name="synchronize" value="True"/>

Set to True to ensure all image data is fully flushed and synchronized to disk. There is a performance penalty, however, the benefits include ensuring a valid image file in the event of a system crash and early reporting if there is not enough disk space for the image pixel cache.

Zero Configuration Security Policy
----------------------------------

A zero configuration build of ImageMagick does not permit external configuration files. To define your security policy, you must instead edit the MagickCore/policy-private.h source module, add your policy statements, and then build the ImageMagick distribution. Here is an example zero configuration security policy:

```cpp
static const char
  *ZeroConfigurationPolicy = \
"<policymap> \
  <policy domain=\"coder\" rights=\"none\" pattern=\"MVG\"/> \
</policymap>";
```

Other Security Considerations
-----------------------------

If you spot a security flaw in ImageMagick, post your concern as an issue to [GitHub](https://github.com/ImageMagick/ImageMagick/issues). Be sure to include how to reproduce the security flaw and a link to any images needed to reproduce the flaw. Alternatively, [contact us](https://imagemagick.org/script/contact.php) and select Security Issue as the issue.

There are several ways to keep ImageMagick safer:

1.  Use web-safe image formats: Limiting ImageMagick to only reading or writing web-safe image formats like GIF, JPEG, and PNG can help increase security.
2.  Customize the security policy: You can customize the security policy to fit the needs of your local environment or organizational policies. This policy can cover aspects such as memory usage, allowable paths for reading and writing, the number of images allowed in a sequence, the maximum time a workflow can run, the amount of disk space allowed for image pixels, a secret passphrase for remote connections, and which coders are permitted or denied.
3.  Set limits on resource usage: You can set limits on resources such as memory usage, disk space, and workflow runtime to prevent potentially harmful situations.
4.  Use sandboxing: Sandboxing is a security technique that allows you to run a program in a restricted environment to prevent it from accessing sensitive information or making changes to the system.
5.  Disable potentially dangerous coders: If you are using ImageMagick on a public website, you may want to increase security by disabling certain coders such as MVG or HTTPS.
6.  Prevent execution of image filters and indirect reads: You can prevent users from executing image filters and performing indirect reads to increase security.
7.  Use a current version of ImageMagick: It is important to use a current version of ImageMagick to take advantage of the latest security fixes and updates.


/Links
=======

[Command-line Tutorials] • [Program Interface Tutorials] • [ImageMagick Techniques] • [Installation Tutorials] • [ImageMagick Topics] • [ImageMagick Book Review] • [Web Site Mirrors] • [Image Bank] • [Other Projects]

Listed here are a number of external web sites that are related to ImageMagick. ImageMagick Studio does not maintain or endorse these sites, but we feel they are a helpfull adjunct to this web site.

Use ImageMagick Online
----------------------

[JqMagick](https://jqmagick.imagemagick.org/)

[Magick Online Studio](https://magickstudio.imagemagick.org/)

Command-line Tutorials
----------------------

[Examples of ImageMagick Usage]

[Efficient Image Resizing With ImageMagick](http://www.smashingmagazine.com/2015/06/25/efficient-image-resizing-with-imagemagick/)

[ImageMagick, Part One](http://www.jpeek.com/articles/linuxmag/0606.pdf)

[ImageMagick, Part Two](http://www.jpeek.com/articles/linuxmag/0607.pdf)

Program Interface Tutorials
---------------------------

[Create Dynamic Images with ImageMagick](http://www.sitepoint.com/article/dynamic-images-imagemagick)

[How to compile ImageMagick for PHP by hand](http://www.ioncannon.net/php/75/how-to-compile-imagemagick-for-php-by-hand/)

[MagickWand Examples in C](http://members.shaw.ca/el.supremo/MagickWand/)

[PHP Extensions: MagickWand for PHP](http://www.html-editors.com/contest/1/82-read.html)

[PHP ImageMagick MagickWand Examples](http://www.ioncannon.net/php/61/php-imagemagick-magickwand-examples/)

[RVG - Ruby Vector Graphics](https://rmagick.github.io/rvgtut.html)

[Security Images with PHP and ImageMagick](http://www.devshed.com/c/a/PHP/Security-Images-with-PHP-and-ImageMagick/)

[Basic Uses of ImageMagick With PHP](http://php.net/manual/en/imagick.examples-1.html)

Installation Tutorials
----------------------

[ImageMagick Installer for Mac OS X](http://cactuslab.com/imagemagick/)

[ImageMagick on iPhone](http://www.cloudgoessocial.net/2011/03/21/im-xcode4-ios4-3/)

[Scripts and Instructions to Compile ImageMagick as an iOS Static Library](https://github.com/juan-cardelino/imagemagick_lib_iphone/)

[Installing ImageMagick from Source on Ubuntu](http://www.digitalsanctum.com/2009/03/18/installing-imagemagick-from-source-on-ubuntu-804/)

ImageMagick Techniques
----------------------

[Accelerated Template Matching Using Local Statistics And Fourier Transforms]

[Digital Image Filtering](http://www.fmwconcepts.com/imagemagick/digital_image_filtering.pdf)

ImageMagick Topics
------------------

[FreeBSD port](https://svnweb.freebsd.org/ports/head/graphics/ImageMagick7/)

[Free Software Foundation](http://directory.fsf.org/project/ImageMagick/)

[Hyperscale Image Resizing](http://www.enterprisetech.com/2014/07/16/convey-dell-fpga-appliance-accelerates-hyperscale-image-resizing/)

[NetBSD](http://pkgsrc.se/graphics/ImageMagick/)

[SourceForge](http://sourceforge.net/projects/imagemagick/)

[Voluntary Product Accessibility Template]

[WikiPedia](http://en.wikipedia.org/wiki/ImageMagick)

ImageMagick Legacy Discussion
-----------------------------

[Examples of ImageMagick Usage]

[Legacy ImageMagick Discourse Server](http://legacy.imagemagick.org/discourse-server)

ImageMagick Web Site Mirrors
----------------------------

United States

[https://imagemagick.org]

Image Bank
----------

[Image Bank](https://imagemagick.org/archive/image-bank/): a small digital test image bank

Other Projects
--------------

[Wizard's Toolkit](https://urban-warrior.org/)

[ImageMagick API on the Android Platform](https://github.com/MolotovCherry/Android-ImageMagick7)

[ImageMagick API on the iOS / iPhone Platform](https://imagemagick.org/archive/iOS/)

[The Tao of the Spiritual Warrior](https://www.amazon.com/dp/B0BTQ59W3W)


/Sitemap
========

[Overview] • [Download ImageMagick] • [Install ImageMagick] • [Command-line Tools] • [Program Interfaces] • [Image Formats] • [Getting Help] • [Support ImageMagick] • [Miscellaneous Topics]

Use this ImageMagick sitemap to quickly jump to one of the areas of interest listed below. If you can't find what you want on this page, try our [site search].

Overview
--------

*   [Introduction]
     convert, edit, or compose images from the command-line or program interface.
*   [Examples of ImageMagick usage]
     a few examples that show what you can do with an image using ImageMagick.
*   [Anthony Thyssen's examples of ImageMagick usage]
     a comprehensive tutorial of using ImageMagick from the command line.
*   [Color names]
     how to specify a color name, a hex color, or a numerical RGB, RGBA, HSL, HSLA, CMYK, or CMYKA color.
*   [Color management]
     accurate color management with color profiles or in lieu of-- built-in gamma compression or expansion as demanded by the colorspace.
*   [Resources]
     ImageMagick depends on external resources including configuration files, loadable modules, fonts, and environment variables.
*   [Parallel execution]
     ImageMagick is threaded to take advantage of speed-ups offered by the multicore processor chips.
*   [Security policy]
     best practices strongly encourage you to configure a security policy that suits your local environment.
*   [Architecture]
     get to know more about the software and algorithms behind ImageMagick.
*   [License]
     the legally binding and authoritative terms and conditions for use, reproduction, and distribution of ImageMagick.
*   [Export classification]
     export control status of ImageMagick.
*   [ImageMagick version 7]
     learn how ImageMagick version 7 differs from previous versions.
*   [History]
     how ImageMagick was conceived and developed.

Download ImageMagick
--------------------

*   [Download ImageMagick]  ImageMagick source and binary distributions are available from a variety of FTP and Web mirrors.
*   [Linux source](https://imagemagick.org/archive): Linux source distributions.
*   [Windows source](https://imagemagick.org/archive/windows): Windows source distributions.
*   [Linux and Windows binaries](https://imagemagick.org/archive/binaries): Linux and Windows binary distributions.
*   [Git repository](https://github.com/ImageMagick/ImageMagick): stable and development source releases.
*   [Delegate libraries](https://imagemagick.org/archive/delegates): ImageMagick depends on a number of optional delegate libraries to extend its functionality.

Install ImageMagick
-------------------

You can install ImageMagick from source. However, if you don't have a proper development environment or if you're anxious to get started, download a ready-to-run Linux or Windows executable.

*   [Install from source]   ImageMagick builds under Windows, Mac OS X, and Linux.

Command-line Tools
------------------

*   [Command-line tools]    overview of the ImageMagick commands.
    *   [magick]    convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and more.
    *   [magick animate]    animates an image sequence on any X server.
    *   [magick compare]    mathematically and visually annotate the difference between an image and its reconstruction.
    *   [magick composite]  overlaps one image over another.
    *   [magick conjure]    interprets and executes scripts written in the Magick Scripting Language (MSL).
    *   [magick convert]    convert between image formats as well as resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and more.
    *   [magick display]    displays an image or image sequence on any X server.
    *   [identify]  describes the format and characteristics of one or more image files.
    *   [magick import]     saves any visible window on an X server and outputs it as an image file.
    *   [magick mogrify]    resize an image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and more.
    *   [magick montage]    create a composite image by combining several separate images.
    *   [magick stream]     a lightweight tool to stream one or more pixel components of the image or portion of the image to your choice of storage formats.
*   [Command line processing]   the anatomy of the command line.
*   [Command line options]  annotated list of all options that can appear on the command-line.
*   [Fx]    apply a mathematical expression to an image or image channels.
*   [Fred's ImageMagick Scripts](http://www.fmwconcepts.com/imagemagick/): a plethora of command-line scripts that perform geometric transforms, blurs, sharpens, edging, noise removal, and color manipulations.

Program Interfaces
------------------

*   [Program interfaces]    application programming interfaces.
    *   [CL-Magick](http://common-lisp.net/project/cl-magick/): provides a Common Lisp interface to the ImageMagick library.
    *   [Magick.NET](https://github.com/dlemstra/Magick.NET): Use Magick.NET to convert, compose, and edit images from Windows .NET.
    *   [Magick++]  provides an object-oriented C++ interface to ImageMagick.
    *   [IMagick](http://pecl.html.net/package/imagick): is a native PHP extension to create and modify images using the ImageMagick API.
    *   [JMagick](https://github.com/techblue/jmagick): provides an object-oriented Java interface to ImageMagick.
    *   [MagickCore]    C API, recommended for wizard-level developers.
    *   [MagickWand]    convert, compose, and edit images from the C language.
    *   [nMagick](http://code.google.com/p/nmagick): is a port of the ImageMagick library to the haXe and Neko platforms.
    *   [PascalMagick](http://wiki.freepascal.org/PascalMagick): a Pascal binding for the MagickWand API and also the low-level MagickCore library.
    *   [PerlMagick]    convert, compose, and edit images from the Perl language.
    *   [PythonMagick](https://imagemagick.org/archive/python/): an object-oriented Python interface to ImageMagick.
    *   [RMagick](http://rmagick.rubyforge.org/): is an interface between the Ruby programming language and ImageMagick.
    *   [TclMagick](http://tclmagick.sourceforge.net/): a native Tcl-extension to the ImageMagick MagickWand API.

Image Formats
-------------

*   [Supported image formats]   annotated list of all image formats that ImageMagick can read and/or write.
*   [Motion picture digital images] use SMPTE DPX Version 2.0 to process images used by the motion picture (film and high-definition) industry.
*   [High dynamic-range images] accurately represent the wide range of intensity levels found in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows.
*   [Magick Vector Graphics]    a modularized language for describing two-dimensional vector and mixed vector/raster graphics in ImageMagick.
*   [Magick Image File Format]  MIFF is ImageMagick's own platform-independent format for storing bitmap images.

Getting Help
------------

*   [Definitive Guide to ImageMagick](http://www.amazon.com/exec/obidos/redirect?link_code=ur2&camp=1789&tag=imagemagick-20&creative=9325&path=tg/detail/-/1590595904/qid=1123551819/sr=8-1/ref=pd_bbs_sbs_1?v=glance%26s=books%26n=507846): this book explains ImageMagick in a practical, learn-by-example fashion.

*   [ImageMagick Tricks](http://www.amazon.com/exec/obidos/redirect?link_code=ur2&camp=1789&tag=imagemagick-20&creative=9325&path=tg/detail/-/1904811868/qid=1123551819/sr=8-1/ref=pd_bbs_sbs_1?v=glance%26s=books%26n=507846): this book is packed with examples of photo manipulations, logo creation, animations, and complete web projects.

*   [Discussions](https://github.com/ImageMagick/ImageMagick/discussions) forums: to get help from fellow ImageMagick users and developers, post to these forums.

*   [Contact the Wizards](https://imagemagick.org/script/contact.php): for bug reports (only if you do not want to sign up to the [discussion](https://github.com/ImageMagick/ImageMagick/discussions)) service, a source or documentation patch, a security or license issue, or if you want to be a sponsor of the ImageMagick project.

Support ImageMagick
-------------------

*   [Report bugs and vulnerabilities](https://github.com/ImageMagick/ImageMagick/issues): our highest priority is to fix security defects and bug reports, usually within 48 hours of your report. The bug discussions service requires that you register. If you do not want to register, you can [contact the ImageMagick developers](https://imagemagick.org/script/contact.php) with a convenient web form.
*   [Sponsor ImageMagick]   contribute bug fixes, enhancements, hardware, funds, etc. to ensure the ImageMagick project thrives.

Miscellaneous Topics
--------------------

*  [Animation]     create a GIF animation sequence from a group of images.
*  [Bilateral blur]    non-linear, edge-preserving, and noise-reducing smoothing filter.
*  [Color management]  accurate color management with color profiles or in lieu of-- built-in gamma compression or expansion as demanded by the colorspace.
*  [Color thresholding]    force all pixels in the color range to white otherwise black.
*  [Command-line processing]   utilize ImageMagick from the command-line.
*  [Complex text layout](https://en.wikipedia.org/wiki/Complex_text_layout) bidirectional text support and shaping.
*  [Composite]     overlap one image over another.
*  [Connected component labeling]  uniquely label connected regions in an image.
*  [Convex hull]   smallest area convex polygon containing the image foreground objects. In addition, the minimum bounding box and unrotate angle are also generated.
*  [Decorate]  add a border or frame to an image.
*  [Delineate image features]  [Canny edge detection], [Hough lines].
*  [Discrete Fourier transform]    implements the forward and inverse [DFT](https://en.wikipedia.org/wiki/Discrete_Fourier_transform).
*  [Distributed pixel cache]   offload intermediate pixel storage to one or more remote servers.
*  [Draw]  add shapes or text to an image.
*  [Encipher or decipher an image]     convert ordinary images into unintelligible gibberish and back again.
*  [Format conversion]     convert an image from one [format] to another (e.g. PNG to JPEG).
*  [Generalized pixel distortion]  correct for, or induce image distortions including perspective.
*  [Heterogeneous distributed processing]  certain algorithms are [OpenCL]-enabled to take advantage of speed-ups offered by executing in concert across heterogeneous platforms consisting of CPUs, GPUs, and other processors.
*  [High dynamic-range images]     accurately represent the wide range of intensity levels found in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows.
*  [Histogram equalization]    use adaptive histogram equalization to improve contrast in images.
*  [Image cache]   secure methods and tools to cache images, image sequences, video, audio or metadata in a local folder..
*  [Image calculator]  apply a mathematical expression to an image, image sequence, or image channels.
*  [Image gradients]   create a gradual blend of two colors whose shape is horizontal, vertical, circular, or elliptical.
*  [Image identification]  describe the format and attributes of an image.
*  [ImageMagick on the iPhone]     convert, edit, or compose images on your [iOS](https://www.apple.com/ios/) device such as the iPhone or iPad.
*  [Large image support]   read, process, or write mega-, giga-, or tera-pixel image sizes.
*  [Montage]   juxtapose image thumbnails on an image canvas.
*  [Morphology of shapes]  extract features, describe shapes, and recognize patterns in images.
*  [Motion picture support]    read and write the common image formats used in digital film work.
*  [Multispectral imagery]     support multispectral imagery up to 64 bands.
*  [Noise and color reduction]

    [Kuwahara Filter](https://legacy.imagemagick.org/discourse-server/viewtopic.html?t=26480), [mean-shift](https://legacy.imagemagick.org/discourse-server/viewtopic.html?t=25504).

    [Perceptual hash](http://www.fmwconcepts.com/misc_tests/perceptual_hash_test_results_510/index.html)

    map visually identical images to the same or similar hash-- useful in image retrieval, authentication, indexing, or copy detection as well as digital watermarking.

*   [Special effects]   
    blur, sharpen, threshold, or tint an image.

*   [Text & comments]   
    insert descriptive or artistic text in an image.

*   [Threads of execution support]  
    ImageMagick is thread safe and most internal algorithms execute in [parallel] to take advantage of speed-ups offered by multicore processor chips.

*   [Transform]     
    resize, rotate, deskew, crop, flip or trim an image.

*   [Transparency]  
    render portions of an image invisible.

*   [Virtual pixel support]     
    convenient access to pixels outside the image boundaries.
  

ImageMagick Legacy
------------------

We continue to maintain the legacy release of ImageMagick, version 6, at [https://legacy.imagemagick.org](https://legacy.imagemagick.org/). We maintain an archive of [legacy ImageMagick discussions](https://legacy.imagemagick.org/discourse-server/).

