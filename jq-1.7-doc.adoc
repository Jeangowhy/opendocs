// AsciiDoc Document Header
:icons: font
:stem:
// AsciiDoc Document Header

[[toc]]
=== jq 1.7 Manual
:TOC: link:#toc[💨,role=right]
:ROLE: role="right clearfix jqplay"
:RUN: icon:flash[2x, role="red jqplay"],{ROLE},window="_blank"

//使用 chrome 打印 pdf 会自动通过 :after 添加链接地址让其打印出来。注意注解掉右方括号。
pass:[<style>@media print { a\[href\]:after { content:none !important;}}</style>]
pass:[<style>.jqplay {position:relative;top:-2em;}</style>]

_For other versions, see 
link:https://jqlang.github.io/jq/manual/v1.7/[1.7],
link:https://jqlang.github.io/jq/manual/v1.6/[1.6], 
link:https://jqlang.github.io/jq/manual/v1.5/[1.5],
link:https://jqlang.github.io/jq/manual/v1.4/[1.4], 
link:https://jqlang.github.io/jq/manual/v1.3/[1.3] or
link:https://jqlang.github.io/jq/manual/dev/[development version]._

TIP: Transform by +
    ``
    pandoc -tasciidoc -rhtml https://jqlang.github.io/jq/manual
    ``

* <<tutorial_4_jq>>
* <<download>>
* <<tutorial>>
* <<invoking-jq>>
* <<basic-filters>>
  ** <<identity>>
  ** <<object-identifier-index>>
  ** <<optional-object-identifier-index>>
  ** <<object-index>>
  ** <<array-index>>
  ** <<array-string-slice>>
  ** <<array-object-value-iterator>>
  ** <<array-object-value-iterator-optional>>
  ** <<comma>>
  ** <<pipe>>
  ** <<parenthesis>>
* <<types-and-values>>
  ** <<array-construction>>
  ** <<object-construction>>
  ** <<recursive-descent>>
* <<builtin-operators-and-functions>>

[title="Built-in operators and functions",cols="1,1,~"]
|===
|<<addition>>   |<<tonumber>>   |<<subtraction>>
|<<abs>>        |<<tostring>>   |<<multiplication-division-modulo>>
|<<length>>     |<<type>>       |<<utf8bytelength>>
|<<has>>        |<<group_by>>   |<<keys-keys_unsorted>>
|<<in>>         |<<reverse>>    |<<map-map_values>>
|<<pick>>       |<<contains>>   |<<to_entries-from_entries-with_entries>>
|<<path>>       |<<indices>>    |<<arrays-objects-iterables-booleans-numbers-normals-finites-strings-nulls-values-scalars>>
|<<del>>        |<<inside>>     |<<infinite-nan-isinfinite-isnan-isfinite-isnormal>>
|<<getpath>>    |<<startswith>> |<<sort-sort_by>>
|<<setpath>>    |<<endswith>>   |<<min-max-min_by-max_by>>
|<<delpaths>>   |<<ltrimstr>>   |<<unique-unique_by>>
|<<select>>     |<<rtrimstr>>   |<<index-rindex>>
|<<empty>>      |<<explode>>    |<<combinations>>
|<<error>>      |<<implode>>    |<<ascii_downcase-ascii_upcase>>
|<<halt>>       |<<split-1>>    |<<dollar_jq_build_configuration>>
|<<halt_error>> |<<join>>       |<<dollar_env-env>>
|<<dollar_loc>> |<<while>>      |<<string-interpolation>>
|<<paths>>      |<<repeat>>     |<<convert-to-from-json>>
|<<add>>        |<<until>>      |<<format-strings-and-escaping>>
|<<any>>        |<<recurse>>    |<<sql-style-operators>>
|<<all>>        |<<walk>>         
|<<flatten>>    |<<transpose>>    
|<<range>>      |<<bsearch>>      
|<<floor>>      |<<dates>>        
|<<sqrt>>       |<<builtins>>     
|===

* <<conditionals-and-comparisons>>
  ** <<eq-neq>>
  ** <<if-then-else-end>>
  ** <<gt-ge-le-lt>>
  ** <<and-or-not>>
  ** <<alternative-operator>>
  ** <<try-catch>>
  ** <<breaking-out-of-control-structures>>
  ** <<error-suppression-optional-operator>>
* <<regular-expressions>>
  ** <<test>>
  ** <<match>>
  ** <<capture>>
  ** <<scan>>
  ** <<split-2>>
  ** <<splits>>
  ** <<sub>>
  ** <<gsub>>
* <<advanced-features>>
  ** <<variable-symbolic-binding-operator>>
  ** <<destructuring-alternative-operator>>
  ** <<defining-functions>>
  ** <<scoping>>
  ** <<isempty>>
  ** <<limit>>
  ** <<first-last-nth-2>>
  ** <<first-last-nth-1>>
  ** <<reduce>>
  ** <<foreach>>
  ** <<recursion>>
  ** <<generators-and-iterators>>
* <<math>>
* <<io>>
  ** <<input>>
  ** <<inputs>>
  ** <<debug>>
  ** <<stderr>>
  ** <<input_filename>>
  ** <<input_line_number>>
  ** <<streaming>>
  ** <<truncate_stream>>
* <<streaming>>
  ** <<truncate_stream>>
  ** <<fromstream>>
  ** <<tostream>>
* <<assignment>>
  ** <<update-assignment>>
  ** <<arithmetic-update-assignment>>
  ** <<plain-assignment>>
  ** <<complex-assignments>>
* <<modules>>
  ** <<import-relativepathstring-as-name>>
  ** <<include-relativepathstring>>
  ** <<import-relativepathstring-as-dollar_name>>
  ** <<module-metadata>>
  ** <<modulemeta>>
* <<colors>>

A jq program is a "filter": it takes an input, and produces an output.
There are a lot of builtin filters for extracting a particular field of
an object, or converting a number to a string, or various other standard
tasks.

Filters can be combined in various ways - you can pipe the output of one
filter into another filter, or collect the output of a filter into an
array.

Some filters produce multiple results, for instance there's one that
produces all the elements of its input array. Piping that filter into a
second runs the second filter for each element of the array. Generally,
things that would be done with loops and iteration in other languages
are just done by gluing filters together in jq.

It's important to remember that every filter has an input and an output.
Even literals like "hello" or 42 are filters - they take an input but
always produce the same literal as output. Operations that combine two
filters, like addition, generally feed the same input to both and
combine the results. So, you can implement an averaging filter as
`+add / length+` - feeding the input array both to the `+add+` filter
and the `+length+` filter and then performing the division.

But that's getting ahead of ourselves. :) Let's start with something
simpler:

[[tutorial_4_jq]]
=== Tutorial for jq
:paper: link:https://arxiv.org/abs/2403.20132[ + \
A formal specification of the jq language by Michael Färber] 
:source: link:https://vscode.dev/github/jqlang/jq[jqlang source]
{TOC}


[NOTE]
=====
jq 全称 jq programming language，或者 JSON Query Language，由 Stephen Dolan 于
2013-05-23 发布。jqlang 代码仓库在此 {source}，其形式语言规范的作者为 Michael Färber，
论文在此 {paper}。

2001 年 4 月，Douglas Crockford 发布了 JSON 数据格式。他认为 JavaScript
已非常复杂，我们能做的最好的事情就是让它退役。Crockford 现任 PayPal 高级
JavaScript 架构师，他是是 Web 开发领域最知名的技术权威之一，ECMA JavaScript2.0
标准化委员会委员。JavaScript 之父 Brendan Eich 称为其为 JavaScript 的大宗师（Yoda）。

2006 年 1 月，John Resig 发布 Web 前端开发工具包 jQuery，简称 JQ。初始版本支持 CSS 
选择器、事件处理和 AJAX 交互，其独特的链式语法和简洁的多用途接口受到了广泛赞誉。John Resig, 
著有《Pro JavaScript Techniques》（即《精通JavaScript》）等经典JavaScript书籍。
在 Mozilla 担任 JavaScript 工具开发工程师。
=====

_____
A formal specification of the jq language

MICHAEL FÄRBER

Authors’ addresses: Michael Färber, michael.faerber@gedenkt.at.

This work is licensed under a Creative Commons Attribution 4.0 International License.
© 2024 Copyright held by the owner/author(s).

jq is a widely used tool that provides a programming language to manipulate JSON data. However, the jq
language is currently only specified by its implementation, making it difficult to reason about its behaviour.
To this end, we provide a formal syntax and denotational semantics for a large subset of the jq language. Our
most significant contribution is to provide a new way to interpret updates that allows for more predictable
and performant execution.

CCS Concepts: Software and its engineering → Semantics; Functional languages.
Additional Key Words and Phrases: jq, JSON, semantics
_____

jq 是一个处理 JSON 数据的命令行工具，或者说是一种拥有输出内容构造能力的 JSON 数据过滤器。
它具有一定的编程能力，还有一些内置的过滤器（filter）。从功能类型上看，jq、sed、awk 看作
是同一类工具。同类形工具中还有 Miller (mlr)，这是一个集数据询、整形、重构格式（包括制作）
的命令行工具，支持 CSV, TSV, JSON, 以及 JSON Lines (JSONL)。JSON Lines 通过将每个
JSON 对象放在独立的一行中，使得逐行读取和处理数据变得简单，易于处理大型数据集、容易与现有
工具集成，具有灵活性和可扩展性、易于阅读和维护等特点。大型的嵌套结构，使用 jq 处理更轻松。
更多结构化文本处理工具参考以下这个清单 <<structured_text_tools>> ：

*  link:https://miller.readthedocs.io/en/6.13.0/[Miller 6.13.0 Documentation]
*  link:https://vscode.dev/github/johnkerl/miller[Miller Source]
*  link:https://vscode.dev/github/dbohdan/structured-text-tools[Structured text tools]

Miller 代码仓库包含了示例数据文件，例如如下打印 CSV 数据表，使用 `--barred` 绘制表格线：

[source]
--------
$ mlr --icsv --opprint put '$[[3]] = "NEW"' docs/src/data/colored-shapes.csv
$ mlr --icsv --opprint filter '$color == "blue"' --barred docs/src/data/colored-shapes.csv | head -n 10
+-------+----------+------+--------+----------+----------+----------+----------+
| color | shape    | flag | i      | u        | v        | w        | x        |
+-------+----------+------+--------+----------+----------+----------+----------+
| blue  | circle   | 0    | 1075   | 0.780359 | 0.331467 | 0.042890 | 5.725366 |
| blue  | triangle | 0    | 1105   | 0.441773 | 0.445977 | 0.632936 | 4.306461 |
| blue  | circle   | 1    | 1410   | 0.410789 | 0.523766 | 0.043186 | 3.781430 |
| blue  | square   | 0    | 1604   | 0.656744 | 0.687258 | 0.312663 | 4.783385 |
| blue  | circle   | 1    | 1620   | 0.683139 | 0.516427 | 0.042795 | 6.430768 |
| blue  | square   | 1    | 1811   | 0.795653 | 0.652313 | 0.320033 | 4.072821 |
| blue  | triangle | 0    | 1985   | 0.919101 | 0.834472 | 0.624437 | 2.490138 |

$ mlr --icsv --opprint filter '$color == "blue"' --barred docs/src/data/colored-shapes.csv | sed -n '1,10p;$p'
+-------+----------+------+--------+----------+----------+----------+----------+
| color | shape    | flag | i      | u        | v        | w        | x        |
+-------+----------+------+--------+----------+----------+----------+----------+
| blue  | circle   | 0    | 1075   | 0.780359 | 0.331467 | 0.042890 | 5.725366 |
| blue  | triangle | 0    | 1105   | 0.441773 | 0.445977 | 0.632936 | 4.306461 |
| blue  | circle   | 1    | 1410   | 0.410789 | 0.523766 | 0.043186 | 3.781430 |
| blue  | square   | 0    | 1604   | 0.656744 | 0.687258 | 0.312663 | 4.783385 |
| blue  | circle   | 1    | 1620   | 0.683139 | 0.516427 | 0.042795 | 6.430768 |
| blue  | square   | 1    | 1811   | 0.795653 | 0.652313 | 0.320033 | 4.072821 |
| blue  | triangle | 0    | 1985   | 0.919101 | 0.834472 | 0.624437 | 2.490138 |
+-------+----------+------+--------+----------+----------+----------+----------+
--------

_____
Donald Knuth famously said: 
*Programs are meant to be read by humans and only incidentally for computers to execute.*
_____

image:https://www-cs-faculty.stanford.edu/~knuth/taocp-thumb.jpg[
(photo of TAOCP, 1968–2015, by Héctor García-Molina)]
https://www-cs-faculty.stanford.edu/~knuth/taocp.html[
The Art of Computer Programming (TAOCP) by Donald E. Knuth.]
https://vscode.dev/github/liujiming789/The-Art-of-Computer-Programming[(PDF)]



以下是 jq 程序数据处理流示意程图，实线表示数据流，虚线表示组件由另一组件定义。

pass:[<style>
    pre { color: rgba(0, 0, 0, .9);
      font-family: monospace,"Droid Sans Mono", "DejaVu Sans Mono";
      line-height: 1.15;
      text-rendering: optimizeSpeed; }
    .myrole { border: 3px solid #333333;}
  </style>]

.Figure 1: Evaluation of a jq program with an input value.
--------
                                      ┌──────────────────────────────────────┐
                                      │                                      │
  input value                         │  Semantics                           │
  ────────────────────────────────────┼────┐                                 │
                                      │    │             ┌───────────────────│
          ┌──────────────────────┐    │    │             │                   │
          │                      │    │    │    ┌·······►│ Update evaluation │
          │         Syntax       │    │    │    ·        │                   │
          │                      │    │    │    ·        └───────────────────│
          ├───────┐      ┌───────┤    ├────▼────▼───┐    ┌──────────────────┐│
          │       │      │       │    │             │    │                  ││
  ───────►│  HIR  ├─────►│  MIR  │───►│  Evaluation │···►│ Value operations ││
    jq    │       │      │       │    │             │    │                  ││
  program └───────┴──────┴───────┘    └───────┬─────┴────┴──────────────────┴┘
                                              │
                                              └────────► output values & errors  
  High-level Intermediate Representation (HIR) 
  Mid-level Intermediate Representation (MIR)
--------

核心工作流程图配合论文阅读（泛读），可以把握 jq 处理 JSON 数据的核心思维是：构建 JSON 数据
解释树，为每个数据节点构建出路径信息，通过它来实现数据的读写；过滤器（函数）是 jq 的数据操作
行为的定义；管道是 jq 默认工作模式，它的功能、主要是将默认的数据读写路径 <<idenfity>> 与
过滤器获取到的数据集绑定。

========
  3.1 HIR
  A filter 𝑓 is defined by
  𝑓 ≔ 𝑛 ‖ 𝑠 ‖ .
    ‖ (𝑓) ‖ 𝑓? ‖ [𝑓] ‖ {𝑓 : 𝑓, …, 𝑓 : 𝑓} ‖ 𝑓𝑝?…𝑝?
    ‖ 𝑓 ⋆ 𝑓 ‖ 𝑓 ⚬ 𝑓
    ‖ 𝑓 as $𝑥 | 𝑓 ‖ 𝜙 𝑓 as $𝑥(𝑓; 𝑓) ‖ $𝑥
    ‖ label $𝑥 | 𝑓 ‖ break $𝑥
    ‖ if 𝑓 then 𝑓 else 𝑓 ‖ try 𝑓 catch 𝑓
    ‖ 𝑥 ‖ 𝑥(𝑓; …; 𝑓)
  where 𝑝 is a path part of the shape
    𝑝 ≔ [] ‖ [𝑓] ‖ [𝑓 :] ‖ [: 𝑓] ‖ [𝑓 : 𝑓],

  3.2 MIR
  A MIR filter 𝑓 has the shape
  𝑓 ≔ 𝑛 ‖ 𝑠 ‖ .
    ‖ [𝑓] ‖ {} ‖ {𝑓 : 𝑓} ‖ .𝑝
    ‖ 𝑓 ⋆ 𝑓 ‖ $𝑥 ⚬ $𝑥
    ‖ 𝑓 as $𝑥 | 𝑓 ‖ 𝜙 𝑓 as $𝑥(.; 𝑓) ‖ $𝑥
    ‖ if $𝑥 then 𝑓 else 𝑓 ‖ try 𝑓 catch 𝑓
    ‖ label $𝑥 | 𝑓 ‖ break $𝑥
    ‖ 𝑥 ‖ 𝑥(𝑓; …; 𝑓)
  where 𝑝 is a path part of the shape
    𝑝 ≔ [] ‖ [$𝑥] ‖ [$𝑥 : $𝑥].
========

.Table 1: Binary operators, given in order of increasing precedence.
[cols="1,1,3",opts=autowidth]
|====
|Name       | Symbol  | Operators

|Complex    | ⋆       | “\|”, “,”, (“=”, “⊧”, “⊙=”, “⫽=”), “⫽”, “or”, “and”
|Cartesian  | ⚬       | (≟, ≠), (<, ≤, >, ≥), ⊙
|Arithmetic | ⊙      | (+, −), (×, ÷), %
|====

MICHAEL FÄRBER 在论文中开篇明义，明确了 UNIX 系统在管道工具方面提供的便利，并表明 jq 就是
参照这种管道数据流形式设计的工具或脚本编程语言。

______
UNIX has popularised the concept of filters and pipes [1]: A filter is a program that reads from an
input stream and writes to an output stream. Pipes are used to compose filters.

JSON (JavaScript Object Notation) is a widely used data serialisation format [2]. A JSON value
is either null, a boolean, a number, a string, an array of values, or an associative map from strings
to values.

jq is a tool that provides a language to define filters and an interpreter to execute them. Where
UNIX filters operate on streams of characters, jq filters operate on streams of JSON values. This
allows to manipulate JSON data with relatively compact filters. 
______

输入的 JSON 数据通过 jq 的逻辑（属性选择、判断、赋值、条件）生成具有特定格式数据输出，
不一定是输出 JSON 数据。jq 不仅可以用于处理 JSON 数据生成新的数据格式，也可以
格式化 JSON。以下由最基本的特性来说明 jq 的工作模式：

-   使用一个 `.` 句点表示的当前值（等价）选择器，<<identity>> ；
-   处理每个 JSON 节点的 `..` 递归下降（<<recursive-descent>>）。
-   使用管道操作符号 <<pipe>> （了是过滤器的一种）来串联过滤器或者内置函数的调用。
-   使用圆括号 <<parenthesis>> 对过滤器进行分组，<<pipe>> 优先于其它过滤器，需要分组处理。
-   jq 1.7 开始支持 <<if-then-else-end>> 条件语句，旧版不支持此种条件处理形式；
    jq 还支持 `foreach EXP as $var (INIT; UPDATE; EXTRACT)` 循环语法格式。

注意，jq 使用分号作为函数参数的分隔符号，而非语句终结符号（没有定义此符号），内置的递归函数
<<recurse>> 就需要在使用完整参数时用分号对参数进行分隔。使用逗号 <<comma>> 作为构建数据的
分隔符号，可以和圆括号、方括号 <<array-construction>>、花括号 <<object-construction>>
配合使用，用于构造数据输出。用逗号分隔的所有过滤都使用相同的输入，也就是 <<identity>> 指向
同一份数据。

jq 中的数据是通过管道过滤器进行传递，从左边传递到右边。但是有个例外，就是将数据与变量符号绑定后，
数据不会进入默认的管道数据流。要使用变量名绑定的数据，就必需使用另外的管道操作。并且，使用管道
分隔多个符号绑定，不能使用逗号，否则触发 *syntax error, unexpected ',', expecting '|'*。
绑定到变量符号的数据本身也是 JSON 数据，可以直接使用花括号构造 JSON 对象并输出。变量可以通过
其绑定的符号进行访问，像其它 JSON 数据的访问方式一样，后面跟着句点，其作用等于管道操作后使用的
<<identity>> 符号。对比以下脚本：

[source,bash]
-------------
jq -c -n '[1,2,3] as $var         | .'    # ==> null
jq -c -n '[1,2,3] as $var | $var  | .'    # ==> [1,2,3]
jq -c -n '[1,2,3]                 | .'    # ==> [1,2,3]
jq -c -n '[1,2,3].[] as $var      | $var' # ==> 1 2 3

jq -c -n '[1,2,3] as $var | $var.[1] as $two | $two        | .' # ==> 2
jq -c -n '[1,2,3] as $var | $var.[1] as $two | {$two,$var} | .' # ==> {"two":2,"var":[1,2,3]}
-------------

JSON 数据顶层对象或者数组元素是递归下降处理的首批数据，并按顺序逐层深入。
递归下降过滤器等价 `+recurse+` 内置函数，或者称为函数过滤器。
所谓递归（Recursive），即按顺序选择 JSON 中的每个属性数据。
所谓下降（Descent)，即逐层下探到 JSON 数据中的各个节点。
查看以下脚本的对比可以更直观看到递归、非递归处理的差别：

[source,bash]
-------------
jq -c -n '{a:1,b:2} | .'  # ==> {"a":1,"b":2}

jq -c -n '{a:1,b:2} | ..' # ==> {"a":1,"b":2} ==> 1 ==> 2
-------------

<<recursive-descent>> 主要用于模拟（resemble）XPath `+//+` 这个双斜杠运算符号。
注意，递归下降不能直接使用 `+..a+` 这样的方式来过滤 JSON 数据对象的属性，应该配合
竖杠运算符（过滤器）<<pipe>> 一起使用。比如 `+.. | .a+`。在过滤数据的时候，还可以
在属性名称后面使用 <<optional-object-identifier-index>> （或者称可选项过滤器）。
例如 `+.. | .a?+`，这样就可以在属性无效时避免输出异常报告（Error Suppression）。
递归下降处理与 `+path(EXP)+` 还有 <<error-suppression-optional-operator>> 
运算符号搭配时非常有用。

JSON 是默认的数据输入形式，jq 还提供流式数据处理 <<streaming>>，可以看作是零散的
JSON 数据形式，可以看作是 JSON Lines 格式，比如多个单独的数值或者多个数组、对象等。
使用命令选项 `--stream` 激活流处理模式，这样就可以“快速”地处理大数据，比如以 GB 为
单位的 JSON 数据，为了让数据连读取边输出，还可以配合 `--unbuffered` 参数一起使用。
流式数据处理并不轻松，因为它输出像 `+[<path>, <leaf-value>]+` 这样的包含路径和
叶值数组（标量和空数组或空对象）的数据结构。流式处理处理通过 `+[<path>, <leaf-value>]+` 
这样的数据结构来表示（定位）标量、数组、对象。使用以下脚本作演示，注意，流式数据需要从
外部输入，jq 内部的 JSON 数据不属于流数据：

[source,bash]
-------------
jq -c -n --stream '{a:[1,2,{c:3}]} | .' # ==> {"a":[1,2,{"c":3}]}

jq -c -n '{a:[1,2,{c:3}]}' | jq -c --stream '.'
# ==> [["a",0],1]
# ==> [["a",1],2]
# ==> [["a",2,"c"],3]
# ==> [["a",2,"c"]]
# ==> [["a",2]]
# ==> [["a"]]
-------------

[source,bash]
-------------
jq -c -n '[1,2,3].[]' | jq -c '.'           # ==> 1 ==> 2  ==> 3

jq -c -n '[1,2,3].[]' | jq -c --stream '.'  # ==> [[],1] ==> [[],2]  ==> [[],3]
jq -c -n '[1,2,3].[]' | jq -c --stream '.'  # ==> [[],1] ==> [[],2]  ==> [[],3]
-------------

另外，jq 提供的其它内置过滤器（函数）也非常有用，比如转换数据类型的 <<tonumber>>
以及 <<tostring>>。还有 <<length>> 和 <<keys-keys_unsorted>> 可以用来获取
（过滤）JSON 对象的数量，以及 JSON 对象的属性名（key），注意输出的属性名是无序的
（unsorted），与其在输入数据中的位置也不对应。因为键名是按字典序排序的，而带的无序
后缀的 `+keys_unsorted+` 则不进行排序处理（更快速）也不对应属性在输入 JSON 数据
中的顺序。

在不混淆的前提下，jq 中提供的所有功能都可以称为函数或过滤器，或者函数过滤器，它们的目标
就是过滤 JSON 数据。

这里需要对 jq 的语法有一个基本了角，`.|keys` 和 `'.keys'` 的差别在于，后者是过滤
当前数据对象的 keys 属性，而前者是通过 <<pipe>> 过滤器进一步调用了 <<keys>> 过滤器，
从数据传递这一点来说，<<pipe>> 操作符（过滤器）与 bash 脚本中的同名运算符具有相同功能。
内置函数就按照这个语法调用，比如 `..|tostring` 递归地将所有 JSON 属性值转换为字符串。

jq 作为一种脚本语言，也有 <<scoping>> 作用域概念，脚本符号绑定类型有两种形式，一是
变量符号，二是函数符号。二者都是词法作用域（lexical scope），即动态绑定，与之相对
的是 C/C++ 中使用的静态作用域。这是编译原理术语，可以参考编译器紫龙书的基础概念章节。
符号遵循先绑定后使用的原则，即右侧脚本使用左侧定义的符号。只有在定义函数时，为了实现
递归函数的定义，可以引用自身。如果使用圆括号包裹，这算是局部作用域，超出范围后就失效。
例如，以下定义和使用 `m3` 变量： `... | (.*3 as $m3 | [. + $m3]) | ...`。

需要完全从 jq 中构建一个 JSON 数据结构而不使用外部数据输入，那么就在执行 `jq -n 'scripts'`
命令，添加的 `-n` 参数表示不需要输入数据，等效 `+--null-input+`，命令行参数的具体用法参考
<<invoking-jq>>。如果没有使用 `-n` 参数，直接在 jq 命令脚本中编写 JSON 数据将被当作
jq 脚本处理，并且等等用户输入 JSON 数据，或者通过管道命令输入其它命令的输出数据。另一个
与控制台输入有关的方法是，使用 <<input>> 过滤器来读取控制台的 stdout 文件数据。

jq 命令行运行方式如下：

[source,bash]
-------------
Usage:  /usr/bin/jq.exe [options] <jq filter> [file...]
        /usr/bin/jq.exe [options] --args <jq filter> [strings...]
        /usr/bin/jq.exe [options] --jsonargs <jq filter> [JSON_TEXTS...]

      -f, --from-file file      load filter from the file;

      --arg name value      set $name to the string value;
      --argjson name value  set $name to the JSON value;
      --slurpfile name file set $name to an array of JSON values read
                            from the file;
      --rawfile name file   set $name to string contents of file;
      --args                consume remaining arguments as positional
                            string values;
      --jsonargs            consume remaining arguments as positional
                            JSON values;

      --                        terminates argument processing;


jq -n '2 * $mv'            --arg mv 9 # ==> 99 控制台传入参数为字符，字符串与数值乘法，加倍连接
jq -n '$mv | tonumber * 2' --arg mv 9 # ==> 18 将命令行字符串转换为数值再相乘
jq -n '$mv.[1] * 2'        --argjson mv '[7,9]' # ==> 18
jq -n '$ARGS|length,$ARGS.positional' --args -- abc 123 # 2 ["abc","123"]

jq -n '$mv|length' --rawfile mv /path/to/some_data.file # data length in bytes
jq -n '$mv|keys' --slurpfile mv /path/to/some.json

jq -n '$mv|length' --rawfile mv /c/tmp/adocbook/tmp.adoc
-------------

可以使用 `-f filename` 选项来来指定一个设置有过滤器的文件，而不必在命令行为输入过滤器。
使用 `--arg` 和 `--argjson` 参数分别可以在命令行设置 jq 变量值，并且前者是字符串，后者会
被转换为 JSON 对象供 jq 中的过滤器使用。如果是大量的数据，可以使用 `--rawfile` 选项将
原始字符串数据赋值给指定变量名。如对合规的 JSON 文件，就可以使用 `--slurpfile` 选项来
读取，jq 文档建议用。Slurp 在这里是指大口地吃下数据。使用它就像直接在命令行中输入 JSON
数据一样。需要注意的是，slurp 方式处理 JSON 文件时，相应设置的变量是一个数组，数组的首个
元素才是文件的数据。

控制台编程有一个传参约定，在 `--` 符号后，可以传递任意数据给命令。jq 文档中称这种方式为
Terminates argument processing，终结参数处理。这些数据的处理方式由 `--args` 或者
`--jsonargs` 选项决定。这些数据会转换为坑位参数（positional string/JSON），并且由
`$ARGS.positional[]` 全局变量进行访问。

可以使用 Shebang 脚本执行的方式运行 jq，比如，使用以下脚本来获取 AsciiDoc ASG 数据
摘要，假设脚本命令为 jq_schema.sh：

.AsciiDoc ASG link:{schema_json}[schema.json]
:schema_json: https://gitlab.eclipse.org/eclipse/asciidoc-lang/asciidoc-lang/-/raw/main/asg/schema.json?ref_type=heads&inline=false
[source,bash]
-------------
#!/usr/bin/env -S jq -n --slurpfile mv /pl/asciidoc-lang/asg/schema.json -f
pass:[{slurp:($mv|length), keys: ($mv.[0]|keys)}]
-------------

处理 schema.json 就可以得到以下数据：

[source,bash]
-------------
$ '/tmp/jq_schema.sh'
{
  "slurp": 1,
  "keys": [
    "$defs",
    "$id",
    "$schema",
    "additionalProperties",
    "defaults",
    "description",
    "if",
    "properties",
    "required",
    "then",
    "title",
    "type"
  ]
}
-------------

[TIP]
=====
要给 shebang 运行的脚本指定参数，可以使用 env -S 或者 xargs 工具：

1.  env -S 会将其命令行后面的参数按分隔符号切割后再传给 shebang 要运行的脚本；
2.  xargs 可以将 stdin 标准输入数据转换为参数去调用指定命令，例如：`echo 'Hi' | xargs echo`；

[source,bash]
-------------
#!/usr/bin/env -S python cli abc
import sys
print("Hello Python!", sys.argv)
-------------

运行以上脚本，可以发现 -S 后面的参数分割成 "python" "cli" "abc" 三分：

[source,bash]
=============
$ ./cli +
Hello Python! ['cli', 'abc', './cli']
=============
=====


以下脚本片段展示了使用 jq 编程能力、通过各种过滤器处理 JSON 对象同时构造输出：

[source,bash]
----
jq -c -n '[1,2,[3,4]]       |  .[0,2]' # ➊
jq -c -n '[0,12]            |  if .[0] == 0 then .[0]="zero" end' # ➋
jq -c -n '{"a":0}           |  .. | if . == 0 then "zero" end' # ➌
jq -cn '{pos:{x:12,y:34}} | .["pos"] | [(.x|tostring), (.y|tostring)]' # ➍
jq -cn '[1,2,3] as $data | {"1":"one","2":"two","3":"three"} as $names | $data | 
        .[] | {"\($names.[.])":.|tostring}' # ➍
----

[title=Result]
==============
  ➊-> 1 [3,4]
  ➋-> ["zero",12]
  ➌-> "zero"
  ➍-> [
        "12",
        "34"
      ]
==============

命令行的参数分别是: +
 `-c` 表示紧凑模式输出，如果省略就使用空格缩进方式格式化显示; +
 `-n` 表示没有输入文件，需要在 jq 中直接构造输出的数据或者需要处理的数据；
      以上每条命令首个管道（竖杠）前面的就是构造的 JSON 数据，然后通过管道
      传递给下一层过滤器进行处理。

以上四行脚本中使用 echo 命令向 jq 输送 JSON 数据，jq 通过设置的过滤器（filter）处理
数据的逻辑说明如下：

➊ 输入是一个二维数组，jq 命令中的语句使用句点 . 选择当前值，即这个二维数组，并且
使用一组过滤器，注意不是数组下标运算。准确地讲，jq 这里的方括号表示构造数组，数组内
设置多个数据过滤器以将过滤数据构造为 JSON 数组并输出。例如，此处在方括号设置的是索引
过滤器，获取数组中的首个元素、第 2 号元素 [3,4]。注意，JSON 数组以 0 为起点索引号。
这种语法也称为数组索引 <<array-index>>，对应的还数组切片 <<array-string-slice>>。

➋ 输入一个一维数组，使用条件判断首个元素是否是 0，如果是，就在构造数组中设置一个
值为 "zero"的数组元素。jq 构造列表中使用逗号分隔符 <<comma>> 将多个属性字段分隔开。

➌ 输入一个对象，使用递归下降处理，条件判断中的名句指的是对象的 a 属性（因为递归处理到这个值），
如果这个值为 0 那么就返回 "zero" 否则返回原值。

➍ 同样是使用递归下降处理输入数据，<<recursive-descent>>。输入的 JSON 对象或者数组
都可以使用 jq 构造数组或对象来重新组织数据。也可以使用属性名来输出对象的属性值。如果输入
的是 JSON 对象，就可以使用 <<object-index>> 来获取属性值，语法格式和数组索引一样，
但是提供了简写形式，可以省略方括号，直接使用属性名。`.property` 或者 `.["property"]`
两种形式都可以。第四条命令中，由于 <<pipe>> 优先于其它过滤器，需要分组处理。否则，使用
`[.x|tostring, .y|tostring]` 这种表达等价于将 `.x` 通过管道传送给 `tostring, .y`
再管道传递给 `tostring`。这就里就会导致异常，`.x` 获取的数据值并不包含 `.y` 属性，
因此出现不可索引的异常：Cannot index number with string "y"。

无论是输入 JSON 数组还是对象，都可以使用 <<array-object-value-iterator>> 来枚举
数组元素或对象属性。也可以使用 <<array-object-value-iterator-optional>> 这种
带有禁止报错的可选项枚举，就是后缀了一个 <<error-suppression-optional-operator>>。

从以上脚本语句可以看到，jq 具有一定的增、删（过滤）、改的能力。可以使用以下构造语法
构造新的 JSON 数据对象并按指定格式输出：

- `[]`: <<array-construction>>
- `{}`: <<object-construction>>
- `..`: <<recursive-descent>>

例如，以下脚本片段中，首条命令使用条件判断以及数组构造，只将那些 0 值替换成 "zero"
后保留下来，忽略其它值。<<empty>> 表示没有任何内容的空值，甚至不是 `null`，
这个过滤器可以在递归下降处理过程中过滤掉不需要的数据。注意，使用递归下降处理时，
如果没有使用 <<array-construction>> 或者 <<object-construction>> 构造器
包裹递归过滤器，那么输出的数据就是零散的片段。对比以下脚本片断的第二条命令，它使用
数组构造包裹了递归下降输出的数据。使用 <<empty>> 不恰当会导致过滤的数据对象为空，
也就是说当前数据实体包含 <<empty>> 就会从输出缓冲区中移除。利用好 <<empty>> 
可以用于过滤一些不需要的数据，而不必使用 <<delpath>> 来删除：

[source,bash]
-------------
jq -nc '[1,2,3]|map({k:(if .==2 then "Two" else empty end),v:empty})' # ==> []

jq -nc '[1,2,3]|map({k:(if .==2 then "Two" else empty end)})' # ==> [{"k":"Two"}]
jq -nc '[1,2,3]|map({
  k:(if .==2 then "Two" else empty end),
  v: (if .==1 then empty end)
  })' # ==> [{"k":"Two","v":2}]
-------------

JSON 数组与对象间的转换使用 `to_entries` 或者 `from_entries` 等内置函数，也可以
通过数组构造器、对象构造器实现转换。jq 本身将 JSON 数据作为流式数据进行处理，也就是读取
多少字节就处理多少，并随时更新 JSON 解释结果，这也使得 jq 可以对超大 JSON 数据集进行
处理，配合 `--unbuffered` 命令行选项使用时，可以随时以 JSON Lines 形式输出已经处理
好的 JSON 对象。使用空白符号分隔 JSON 对象的这种组织形式称为 `cat` 友好格式。

[source,bash]
-------------
jq -cn '[1,2,3] | to_entries'    # convert array to object
# [{"key":0,"value":1},{"key":1,"value":2},{"key":2,"value":3}]

jq -cn '[{a:1,b:2,c:3}.[]  | .]' # convert object to array
# [1,2,3]
-------------

数组转换 cat 友好格式很容易，有多种方式可以实现，包括使用 <<setpath>> 等函数。但是，在不使用
内置函数 <<add>> 的前提下，要将 JSON 数组转换为 top-level 的 JSON 对象就有点难度。因为不能
利用 <<setpath>> 函数对绑定的变量进行修改，不能将变量符号直接作为参数传递，设置的值也会在一个
新的临时 JSON 对象上保存：

[source,bash]
-------------
jq -cn '[1,2,3].[] |{"a": .}' # ==> {"a":1} ==> {"a":2} ==> {"a":3}
jq -cn '{"a": [1,2,3].[] |.}' # ==> {"a":1} ==> {"a":2} ==> {"a":3}

jq -cn '[[1,2,3].[] |{("k-"+(.|tostring)): .}]' # ==> [{"k-1":1},{"k-2":2},{"k-3":3}]
jq -cn '{"k-1":1} + {"k-2":2}'                  # ==> {"k-1":1,"k-2":2}
jq -cn '[{"k-1":1}, {"k-2":2}] | add'           # ==> {"k-1":1,"k-2":2}

jq -cn '[1,2,3] as $var | {} as $b | setpath(["a"];$var|.[])' # ==> {"a":1} ==> {"a":2} ==> {"a":3}
jq -cn '{a:[1,2,3]} as $v | $v | setpath(["b"];.) | $v' # ==> {"a":[1,2,3]}
jq -cn '{a:[1,2,3]} as $v | $v | setpath(["b"];.)'      # ==> {"a":[1,2,3],"b":{"a":[1,2,3]}}

jq -cn '{a:[1,2,3]} as $var | $var.a.[] as $val | $var |  setpath(["k-"+($val|tostring)];$val)'
# ==> {"a":[1,2,3],"k-1":1}
# ==> {"a":[1,2,3],"k-2":2}
# ==> {"a":[1,2,3],"k-3":3}
-------------

除了以上基础功能，从 jq 文档上的目录上也可以看到，它还提供了高级的编程功能：
<<conditionals-and-comparisons>>， <<regular-expressions>>，
<<advanced-features>>， <<math>>， <<io>>， <<streaming>>，
<<assignment>>， <<modules>>， <<colors>>（控制台输出内容的颜色控制）。

[cols=2]
|=======
  | Command                              | Output

2+| *Turth and falsity values*
  | jq -n '[0    \| not]'                | [ false ]
  | jq -n '[null \| not]'                | [ true ]
  | jq -n '[false and nill]'             | [ false ]

2+| *Relational Operators*
  | jq -n "[5,6] \| [.[] \| .==5]"       | [true, false]
  | jq -n "[5,6] \| [.[] \| .!=5]"       | [false, true]
  | jq -n "[5,6] \| [.[] \| .>5]"        | [false, true]
  | jq -n "[5,6] \| [.[] \| .<5]"        | [true, false]
  | jq -n "[5,6] \| [.[] \| .>=5]"       | [true, true]
  | jq -n "[5,6] \| [.[] \| .<=5]"       | [true, false]
  | jq -n '42 and "a string"'            | true

2+| *Logical Operators (Boolean operators)*
  | jq -n '[(true, false) or false]'     | [true, false]
  | jq -n '[(true, false) or (1, 0, 1)]' | [true, true, true, true]
  | jq -n '[(1,null,1) or (1, null, 1)]' | [true, true, false, true, true]

  | jq -n '[(1,0,1) and (1, 0, 1)]'      | 9 truth values
  | jq -n '[(1,null,0) and (1, null, 1)]'| [true,false,true,false,true,false,true]

  | jq -n '[true, false \| not]'         | [false, true]
  
  | jq -n 'true    // [1,2]'             | true
  | jq -n '[false] // [1,2]'             | [false]
  | jq -n 'false   // [1,2]'             | [ 1, 2 ]
|=======

双斜杠 <<alternative-operator>> 是短路运算符，当它左则是 true 值的数据，就直接
返回左侧的数据，否则返回右侧的数据。像 `[false]` 这样的值也是评估为真值，因为它是一
个数组，而不是单纯的 false 或者 null 值。布尔逻辑运算（Boolean operators）只将
`false` 和 `null` 以及它们的逻辑组合看作是 "false values"，其它值，包括数值 0
都看作 "true value"。

如果 `+and+`, `+or+`, `+not+` 三个运算符处理多输入的数据集时，会对每个数据进行
运算并产生相应的结果输出。其中，`+not+` 就是一个内置函数，你可以像其它函数一样通过
管道的方式调用 `+.foo and .bar | not+`。

由于以上所述的 jq 在多数据逻辑运算的这种规则存在，`and` 与 `or` 运算表现非常不一样。
逻辑或（`or`）表现更像 <<alternative-operator>> 短路运算，差别在于，短路运算并
不会对两边的数据进行逻辑运算，而 `or` 运算符会进行运算并按照其“优先”返回真值的规则
返回运算结果。如上表中的 `[(true, false) or (1, 0, 1)]`，它会返回以下值：

-   true or (1, 0, 1) => true
-   false or (1, 0, 1) => false or 1, false or 0, false or 1

最后返回三个 true 值，因为除了 `false` 和 `null`，数值 0 被 jq 当真值处理的。

而逻辑与（`and`）则会在两操作数都是真值的情况下，做一个类似笛卡尔积的运算，产生一组结果。
上表中的逻辑 `(1,0,1) and (1, 0, 1)` 运算中，因为都是真值，包括 0，就会按运算符号
两则的数据产生 stem:[3 \times 3 = 9] 数量的结果。另外 `(1,null,0) and (1, null, 1)`
这个例子，则按“优先”返回 falsity 值，它计算返回以下值：

-   `1 and (1, null, 1)` => `(true, false, true)`，因为 1 为真值，返回右部的运算结果。
-   `null and (1, null, 1)` => `(false)` 因为 `null` 评估为 false，直返反回。
-   `0 and (1, null, 1)` => `(true, false, true)`，因为 `0` 评估为 true。。


[cols=2]
|=======
  | Command                                                  | Output

2+|*<<addition>>*
  | jq -n '{"a": 7}                   \| .a + 1'             | 8
  | jq -n '{"a": [1,2], "b": [3,4]}   \| .a + .b'            | [1,2,3,4]
  | jq -n '{"a": [1,2], "b": [3,4]}   \| .a + .b'            | [1,2,3,4]
  | jq -n '{a: 1} + {b: 2} + {a: 42}'                        | {"a": 42, "b": 2}
  | jq -n '{a: "1"} + {a: "2"}'                              | {"a": "2"}

2+|*<<subtraction>>*
  | jq -n '{"a":3}                 \| 4 - .a'                | 1
  | jq -n '["xml", "yaml", "json"] \| . - ["xml", "yaml"]'   | ["json"]

2+|**<<multiplication-division-modulo>>**
  | jq -n '5              \| 10 / . * 3'                     | 6
  | jq -n '5              \| 10 % . * 3'                     | 0
  | jq -n '"a, b,c,d, e"  \| .  / ", "'                      | ["a","b,c,d","e"]
  | jq -n '[1,0,-1]       \| [.[] \| (1 / .)?]'              | [1, -1]
  | jq -n '{"k": {"a": 1, "b": 2}} * {"k": {"a": 0,"c": 3}}' | {"k": {"a": 0, "b": 2, "c": 3}}
|=======

对象数值属性相加等于集合的并集再叠加算法加法的功能，如果是字符串，则会用右侧值替换左侧的值。
对象数值属性相减等于集合的差集再叠加算法减法的功能，如果是字符串，则从左则的数据中移除。
`null` 可以与任何值相加，但结果不改变其原有值。

除法对于数值就是算术除法，上表中的除法展示，利用了 `(1 / 0)?` 来过滤 0 值数据。如果
在字符串上应用除法，相当 split 方法，就是将右部值作为字符分隔符号来切割字符串。使用
百分号求模，`+x % y+` 就是 x modulo y。

乘法可以作为数值之间的算法乘法，也可以用在数值与字符串做复制连接操作，与操作数的位置无关。
如果在对对象间运算，除了数值间的算法运算、数值与字符串间的复制连接，还需要叠加集合的并集
运算，将操作数的属性集合在一起。这种字符串乘法与编程语言的形式设计使用的概念基本一致，
`+"x" * 0+` 相当于是空字符 stem:[(\sum)^0 = \varepsilon]。

注意加法，以下脚本出现奇怪的结果，通过测试，发现它将管道后面的过滤器作为字符或码值连接在一起。
这里最后的对象访问有两种情况，一是字符串对应的 key，如果存在相应值则会将 "1" 前缀到这个值。
二是数值（仅限未使用括号索引的情况），这个数字会后缀到 99 这个数值的小数部分。这个问题应该
通过分析 jq 的语法逻辑来解答。这种问题的出现是在混合使用了 `+` 运算符号与 `as` 绑定变量
之后，这种语法组合出现了错误。由此推理，可能在运算符号的优秀级上出错，可以尝试给 + 运算符号
添加上圆括号进行分组。根据上档 <<addition>> 描述，加法过滤器用于连接两个过滤器，不仅仅
可用于数值计算。因此，有可能将以下的这些使用了 + 号的脚本表达式解释为 `1 as $a` 这样的错误
结果。通过通过圆括号就可以很好解决这种语法上的歧义：

[source,bash]
-------------
# jq -nc '{a:99, b:1} |.a+1 as $a | .a'       # ==> 198
# jq -nc '{a:99, b:1} |.a+1 as $a | .b'       # ==> 100
# jq -nc '{a:99, b:1} |.a+1 as $a | .["abc"]' # ==> 99
# jq -nc '{a:99, b:1} |.a+1 as $a | .321'     # ==> 99.321
jq -nc '{a:99, b:1} |(.a+1) as $a | $a'       # ==> 100
-------------

与运算符号相关的是 <<assignment>> 赋值操作，jq 中有以下几种赋值形式：

  * <<update-assignment>>：更新值赋值，`|=` 选择要过滤的数据值后再对其值进行赋值；
  * <<arithmetic-update-assignment>>：算术更新赋值，适用数学运算中赋值，例如 `.foo += 1`。
  * <<plain-assignment>>：直接赋值，等号两侧都使用路径，将右侧所指的值赋值给左侧，例如 `(.a,.b) = .c`。
  * <<complex-assignments>>：复合赋值，等号左侧可以使用复杂的 JSON 对象的成员路径。
    例如，`jq -n '{posts:[{title:{}}]} | .posts[0].title = "Examples"'`。

注意，变量只能绑定，而不能赋值。赋值运算的左侧不能使用绑定的变量作为路径信息，但是右侧可以使用
绑定的变量符号路径作为数据来源。更新赋值（`|=`）与其它赋值（`=`）的差别在于多一个管道过滤器：
更新赋值会将 <<identity>> 选择器与管道符号所以过滤的数据绑定。以下脚本可以对比它们的差别：

[source,bash]
-------------
jq -cn '{a:{b:1},b:2} | .a |= .b' # ==> {"a":1,"b":2}

jq -cn '{a:{b:1},b:2} | .a = .b'  # ==> {"a":2,"b":2}

jq -cn '(.a,.b) = range(3)'       # ==> {"a":0,"b":0} ==> {"a":1,"b":1} ==> {"a":2,"b":2}

jq -cn '(.a,.b) |= range(3)'      # ==> {"a":0,"b":0}
-------------

注意，赋值操作在变量符号的限制，文档提供了三个与赋值这方面相关的提示信息。

NOTE: Note that the LHS of assignment operators refers to a value in `+.+`.
Thus `+$var.foo = 1+` won't work as expected (`+$var.foo+` is not a
valid or useful path expression in `+.+`); use `+$var | .foo = 1+`
instead.

NOTE: Note too that `+.a,.b=0+` does not set `+.a+` and `+.b+`, but
`+(.a,.b)=0+` sets both.

NOTE: Note that the left-hand side of `+|=+` refers to a value in `+.+`. Thus
`+$var.foo |= . + 1+` won't work as expected (`+$var.foo+` is not a
valid or useful path expression in `+.+`); use `+$var | .foo |= . + 1+`
instead.

使用条件语句 <<if-then-else-end>>，可以用 <<identity>> 按完整的输入数据返回，也可以
获取属性。还可以使用 <<recursive-descent>> 递归或嵌套递归处理。也可以结合 <<pipe>>
将返回的数据传送到下一层过滤器处理。在使用递归处理时，需要注意递归过程可能出现的数据，
如果不能正确读取数据就会导致异常，比如 Cannot index number with string 这类。
为了避免报错，可以在访问数据的属性名后缀 <<error-suppression-optional-operator>>。

[source,bash]
-------------
jq -n '{a:12, b:0} |  ..' # => { "a": 12, "b": 0 }  => 12  => 0
jq -n '{a:12, b:0} |  .. | [ if . == 0 then "zero" else empty end]' # ➊
jq -n '{a:12, b:0} | [.. | [ if . == 0 then "zero" else empty end]]' # ➋
jq -n '{a:12, b:0} | [.. | if . == 0 then "zero" else . end | tostring]' # ➌

jq -n '{a:12, b:0} |  .. | if . != 0 then .|tostring end' # "12" 0
jq -n '{a:12, b:0} |  .. | if . != 0 then .a?|tostring end' #"12" 0
jq -n '{a:12, b:0} |  .. | if . != 0 then . end | [tostring]' #  ["{\"a\":12,\"b\":0}"] ["12"] ["0"]

jq -n '{a:12, b:0} |  .. | if . == 0 then "zero" else .|tostring end' # "12" "zero"
jq -n '{a:12, b:0} |  .. | if . == 0 then "zero" else .a?|tostring end' #"12" "zero"
jq -n '{a:12, b:0} |  .. | if . == 0 then "zero" else . end | [tostring]' # ["12"] ["zero"]
-------------

[title=Result]
==============
  ➊ [] [] [ "zero" ]
  ➋ [ [], [], [ "zero" ] ]
  ➌ [ "{\"a\":12,\"b\":0}", "12", "zero" ]
==============

过滤器的数据传递使用 <<pipe>> 串联，它的作用和 shell 脚本中的管道类似，用于过滤器之间的
数据传递。递归下降处理会递归地处理传入对象的每一个子级对象，这个过程可能会有很多不需要的数据，
可以使用 `empty` 过滤掉，也可能有遇到不符合特定类型的数据，可用 ? 号来做判断或抑制错误。
拼接字符串时，也可以使用字符串插值：`\(exp)`，字符串内插入引号使用 `\"` 转义符号。

- Error Suppression / Optional Operator: `?`
- Optional Object Identifier-Index: `.foo?`
- String interpolation: `\(exp)`

递归下降过滤器也和其它过滤器一样，可以重复或嵌套使用。在使用条件处理时，如果没有返回子层对象，
或者返回的对象不包含子层，递归过程就结束。类似功能的还有 `map` 过滤器，它可以枚举数组元素、
对象成员，并将数据传递给它的参数中指定的过滤器：

[source,bash]
-------------
jq -n '[{a:0}, {b:["banana"]}, {c:[1,2,3],d:4}] | map(has("a"))'
jq -n '[{a:0}, {b:["banana"]}, {c:[1,2,3],d:4}] | map(.[]?|tostring)'
-------------

[title=Result]
===========
  [
    true,
    false,
    false
  ]

  [
    "0",
    "[\"banana\"]",
    "[1,2,3]",
    "4"
  ]
===========

另外一较常用的过滤器 `length`，它计算输入值的长度，返回一个数值。但是这个过滤器有副作用，
它根据不同输入类型有不同的含义：

  - The length of a **string** is the number of Unicode
      codepoints it contains (which will be the same as its
      JSON-encoded length in bytes if it's pure ASCII).
  - The length of a **number** is its absolute value.
  - The length of an **array** is the number of elements.
  - The length of an **object** is the number of key-value pairs.
  - The length of **null** is zero.
  - It is an error to use `length` on a **boolean**.

另外，还有一组按对象类型进行处理的过滤器，可过滤特定类型的数据，但是不能作为类型判断函数使用：
<<arrays-objects-iterables-booleans-numbers-normals-finites-strings-nulls-values-scalars>>。
jq 提供 `type` 函数作为类型判断。

以上脚本中第二条，`arrays` 与条件语言一起使用，也可以正确过滤出目标数组。条件语句中的
管道也不用加圆括号，它比条件语言的优先级低。奇怪的是当使用 `not` 函数取反后，条件语句
没有使得 `else` 从句，但是数组还是漏了出来。不知道这算不算是 BUG。另一方面，"NA" 也
没有在期待的时机输出。似乎 `arrays` 转换对象地失败后直接截断了控制流程。使用 `type`
判断类型就没有这个问题。但是数据还是”漏“了出来。通过阅读文档，发现 jq 的条件语言还真
与一般编程不一样，在缺件 `+else+` 或者 `+elif+` 分支的情况下，等价于使用 `+.+`，
这就是条件语句会“漏”数据的理由。在不希望这种默认行为发生时，只能使用 <<empty>> 来阻止。

[source,bash]
-------------
jq -cn '{a:"ban", c:[1,2]} | .[] | arrays' # -> [1,2]
jq -cn '{a:"ban", c:[1,2]} | .[] | if (.|arrays) then .|tostring end' # -> "[1,2]"
jq -cn '{a:"ban", c:[1,2]} | .[] | if (.|arrays|not) then "NA" end' # -> [1,2]
jq -cn '{a:"ban", c:[1,2]} | .[] | if (.|arrays|not) then "NA" else "\(.)" end' # -> "[1,2]"
jq -cn '{a:"ban", c:[1,2]} | .[] | if (.|type != "array") then "NA" end' # --> "NA" [1,2]
-------------

内置的递归函数 <<recurse>> 就是可以传参版本的 <<recursive-descent>>，双句点这个
版本就是 zero-argument `+recurse+`，可传参的调用形式的递归函数使用如下：

- `+recurse(f; condition)+` 这是递归函数的完整形式，接受一个过滤器和一个布尔值条件。
  这是一个生成器，用来发射 `.` 然后依次发射 `.|f`, `.|f|f`, `.|f|f|f` 等等，直到
  条件满足。
- `+recurse(f)+` 等价 `+recurse(f; true)+`，不关心递归深度。
- `+recurse(.[]?)+` 等价 <<recursive-descent>>。

只要递归调用 `+recurse+` 时过滤器只产生一个结果（例如尾递归）就不会产生额外的内存消耗。
比如，使用 `+recurse(.+1; true)+` 可以递归生成自然数，直到用户停止它。也可以用来模拟
<<range>> 函数，比如 `[1 | recurse(.+1; .<3)]` 得到 `[1,2]`。

用户可以自定义函数，语法标记符号为 `def`，例如定义一个与内置 <<map>> 函数相同功能的函数，
`def map(f): [.[] | f];`，这个函数枚举输入的数据（`.[]`），并通过管道逐个传递给过滤器。

jq 在递归下降处理数据时有个痛点：如何解决提取部分数据后继续递归处理子层。比如 VS Code 开源
文档中有一个 API 目录数据，如何提取目录标题后，再递归处理目录下层的文档？

https://github.com/microsoft/vscode-docs/tree/main/docs/api/toc.json

这就需要定义递归函数去处理，<<recurse>>：

-   `+recurse(f)+`
-   `+recurse+`
-   `+recurse(f; condition)+`

[source,bash]
-------------
  sed -n 's| *//.*||;p' 'vscode-docs\api\toc.json' \
  | jq '
      def recurse(f): def r: (f | select(. != null) | r); r;
      .[] |
      if type == "array" then
          .[] | length
      elif .name? then
          .name, 
          (.name as $sep | $sep | split("") | map("=") | join("") ), 
          .topics.[].[] | recurse
      end
      '
-------------

作为一个数据处理脚本语言，jq 提供了一系列 SQL 风格的操作 <<sql-style-operators>>，
另外，还有一个内置的 <<group_by>> 函数用于数据分组（根据指定路径中的属性值来划分）：

* `INDEX(stream; index_expression)`: 指定一个用于建立索引的路径表达式，并给输入流的
  每个数据实体设置索引。当有多个实体出现相同的索引表达式，那么最后的数据实体会覆盖旧的实体。
* `JOIN($idx; stream; idx_expr; join_expr)`: 给定一个索引将输入流联结成一个对象。
  索引的 key 根据给定的索引表达式（`idx_expr`）计算得到，并且对 steam 中的数据实体应用
  此表达式，表达式所求得的值就成为联合后的数据一部分，并且根据此值来联合 `$idx` 路径中的数据、
  以及使用联结表达式（join_expr）进行联结。这个描述有点抽象，看英文文档也一样抽象，需要结合
  实例数据来说明。除了要联合的数据（$idx）和索引表达式（idx_expr），其它两个参数是可选项，
  省略它们对应简化为以下两种形式。
* `JOIN($idx; stream; idx_expr)`: 等价于 `JOIN($idx; stream; idx_expr; .)`。
* `JOIN($idx; idx_expr)`: 等价于 `JOIN($idx; .; idx_expr; .)`。
* `IN(s)`: 判断 s 数据流是否存在当前的数据流中，返回 `+true+` 或者 `+false+`。
* `IN(source; s)`: 判断 s 数据流是否存在指定的 source 数据流中。

link:https://qmacro.org/blog/posts/2022/06/23/understanding-jq's-sql-style-operators-join-and-index/[Understanding jq's SQL style operators JOIN and INDEX]

以下是 SQL 风格函数的使用示范：

[source,bash]
-------------
jq -n '[1,2,3].[] | IN(1)'            # ==> true ==> false ==> false
jq -n '{a:[1,2,3]}.[] | IN(1)'        # ==> false
jq -n '{a:[1,2,3]}.[] | IN([1,2,3])'  # ==> true

jq -n 'IN([1,2,3], {a:[1,2,3]}.[])'   # ==> false
jq -n 'IN({a:[1,2,3].[]}, [1,2,3])'   # ==> false

jq -cn '
{
  "weigths":
  [
    {"name":"apple","weigth":200},
    {"name":"tomato", "weigth":100}
  ],
  "categories":
  [
    {"name":"apple","category":"fruit"},
    {"name":"tomato","category":"vegetable"}
  ]
} |

# .categories | group_by(.name)
# [
#   [ { "name": "apple", "category": "fruit" } ],
#   [ { "name": "tomato", "category": "vegetable" } ]
# ]

# INDEX(.categories[]; .name)
# {
#   "apple": { "name": "apple", "category": "fruit" },
#   "tomato": { "name": "tomato", "category": "vegetable" }
# }

JOIN(INDEX(.categories[]; .name); .weigths[]; .name; add)
# { "name": "apple", "weigth": 200, "category": "fruit" }
# { "name": "tomato", "weigth": 100, "category": "vegetable" }
'
-------------

其它 jq 编程概念应用示范参考：

[cols=2]
|=======
  | Command                                               | Output

2+|*<<try-catch>>*
  | jq -n '{} \| try .a catch ". is not an object"'       | null
  | jq -n '[] \| try .a catch ". is not an object"'       | ". is not an object"
  | jq -n '{a:"ok"} \| try .a catch ". is not an object"' | "ok"

2+|*<<regular-expressions>>*
  | jq -n '"Regular language" \| test("(la).+?\\1"; "x")' | true
  | jq -n -c '"Regular language" \| split("(la)+"; "g")'  | ["Regu","r ","nguage"]
  | jq -n -c '"Regular language" \| splits("(la)+"; "g")' | "Regu" "r " "nguage"
  | jq -n -c '"Regular language" \| match("(la)+"; "g")'  |
    {"offset":4,"length":2,"string":"la","captures":[{"offset":4,"length":2,"string":"la","name":null}]}
    {"offset":8,"length":2,"string":"la","captures":[{"offset":8,"length":2,"string":"la","name":null}]}

2+|*<<variable-symbolic-binding-operator>>* and *<<destructuring-alternative-operator>>*
  |	jq -n '{"foo":10, "bar":200} \| .bar as $x \| .foo \| . + $x' |210
  |	jq -n '5 \| . as $i\|[(.*2\|. as $i\| $i), $i]'               |[10,5]
  |	jq -n '[2, {"c": 4}] \| . as [$a, {c: $c}] \| $a + $c'        |6
  |	jq -n '[[0], [0, 1]] \| .[] as [$a, $b] \| {a: $a, b: $b}'    |{"a":0,"b":null} {"a":0,"b":1}
  | jq -n -c '[[1],[1,2]] \| .[] as [$a, $b] \| {a: $a, b: $b}'   | {"a":1,"b":null} {"a":1,"b":2}
  | jq -n -c '{a:99, b:1} \|(.a + 1) as $a\|(.b-1)as $b\| {"a":$a, "b":$b}' | {"a":100,"b":0}

2+|*<<defining-functions>>* and, *<<assignment>>*
  | jq -n -c '[1,0,1,[true,false]] \| (..\|select(type=="boolean")) \|= if . then 1 else 0 end' | [1,0,1,[1,0]]
  | jq -n -c '{a:99, b:1} \|[.a += 1, .b -= 1]'           | [{"a":100,"b":1},{"a":99,"b":0}]
  | jq -n -c '(.a, .b) = range(1)'                        | {"a":0,"b":0}
  | jq -n -c '{"foo": 42} \| .foo += 1'                   | {"foo": 43}
  | jq -n -c '{"a": {"b": 10}, "b": 20} \| .a = .b'       | {"a":20,"b":20}
  | jq -n -c '{"a": {"b": 10}, "b": 20} \| .a \|= .b'     | {"a":10,"b":20}
  | jq -n -c '{"a": {"b": 10}, "b": 20} \| .a.b \|= .+1'  | {"a":{"b":11},"b":20}
  | jq -n -c 'def foo(f): f \| f;  5 \| foo(.*2)'         | 20
  | jq -n -c 'def map(f): [.[] \| f]; [1,2,3]\|map(.*2)'  | [2,4,6]
  | jq -n -c 'def inc($f): map(. + $f); [1,2,3] \| inc(1)'| [2,3,4]
  | jq -n -c 'def inc(f): f as $f \| map(. + $f); [1,2,3] \| inc(1)' | [2,3,4]

2+|*<<to_entries-from_entries-with_entries>>*
  | jq -n -c '{"a": 1, "b": 2} \| to_entries'             | [{"key":"a", "value":1}, {"key":"b", "value":2}]
  | jq -n -c '[{"key":"a", "value":1}, {"key":"b", "value":2}] \| from_entries' | {"a": 1, "b": 2}
  | jq -n -c '{"a": 1, "b": 2} \| with_entries(.key \|= "KEY_" + .)'             | {"KEY_a": 1, "KEY_b": 2}

2+|*<<generators-and-iterators>>*
  | jq -n -c '[range(1;3)]'                               | [1,2 ]
  | jq -n -c '[range(1;6;2)]'                             | [1,3,5]
  | jq -n -c '[range(1,6,2)]'                             | [0,0,1,2,3,4,5,0,1]
  | jq -n -c '[10 \| range(.)]\|[first, last, nth(5)]'    | [0,9,5]
  |	jq -n -c '[range(3)] \| [first(.), last(.), nth(0; .)?]' | [[0,1,2],[0,1,2],[0,1,2]]
  | jq -n -c '10 \| [first(range(.)), last(range(.)), nth(./2; range(.))]' | [0,9,5]
  | jq -n -c '[range(3)] \| [limit(2;.[])]'               | [0,1]

2+|*<<path>> and <<paths>>* +
  路径是用方括号包裹的元素有序的 key 序列，可以用于设置、删除指定 JSON 数据。
  | jq -n -c 'path(.a[0].b)'                              | ["a",0,"b"]
  | jq -n -c '{a:1,b:{c:"x"}}\|path(.b.c)'                | ["b","c"]
  | jq -n -c '{"a":[{"b":1}]}\|[path(..)]'                | [[],["a"],["a",0],["a",0,"b"]]
  | jq -n -c '[1,[[],{a:2}]] \|[paths]'                   | [[0],[1],[1,0],[1,1],[1,1,"a"]]
  | jq -n -c '[1,[[],{a:2}]] \|[paths(type == "number")]' | [[0],[1,1,"a"]]
  | jq -n -c '{"a":{"b":1},"x":{"y":2}} \| delpaths([["a","b"]])'  | {"a":{},"x":{"y":2}}
  | jq -n -c 'setpath([0,"a"]; 1)'                        | [{"a":1}]
  | jq -n -c 'setpath(["a","b"]; 1)'                      | {"a": {"b": 1}}
  | jq -n -c '{"a":{"b":0}} \| setpath(["a","b"]; 1)'     | {"a": {"b": 1}}
  | jq -n -c 'getpath(["a","b"])'                         | null
  | jq -n -c '{"a":{"b":0, "c":1}} \| [getpath(["a","b"], ["a","c"])]' | [0, 1]
  | jq -n -c '{"foo": 42, "bar": 9001, "baz": 42} \| del(.foo)'        | {"bar": 9001, "baz": 42}
  | jq -n -c '["foo", "bar", "baz"] \| del(.[1, 2])'                   | ["foo"]

2+|*More Advance Features*
  | jq -n -c '[1,2,3] \| map(select(. >= 2))'             | [2,3]
  | jq -c -n '{a:1,b:2} | map_values(.+1)'                | {"a":2,"b":3}
  | jq -n -c '[{id: "A", prop:{id: "B", "val": 1}}] \| .. \| select(.id == "B")?' | {"id": "B", "val": 1}
  | jq -n '"String" \| "\(.) interpolation"'              | "String interpolation"
  | jq -n '[0, false, [], {}, null, "hello"] \|map(type)' | ["number", "boolean", "array", "object", "null", "string"]
|=======

最后，以处理 AsciiDoc ASG 文件中的信息作为一个 jq 实践练习，目的是提取 schema.json 文件中的
类型信息。

.AsciiDoc link:{schema_json}[ASG schema.json].
:schema_json: https://gitlab.eclipse.org/eclipse/asciidoc-lang/asciidoc-lang/-/blob/main/asg/schema.json
[source,bash]
----
$ jq -c '.results[]|map(.key=.field)|from_entries|del(."@ptr")' /pl/asciidoc-lang/asg/schema.json |
jq -c '.|keys' /pl/asciidoc-lang/asg/schema.json |
   mlr --ijson --opprint --barred cat
----


[[download]]
=== Download jq

jq is written in C and has no runtime dependencies, so it should be
possible to build it for nearly any platform. Prebuilt binaries are
available for Linux, macOS and Windows.

The binaries should just run, but on macOS and Linux you may need to
make them executable first using `+chmod +x jq+`.

jq is licensed under the MIT license. For all of the gory details, read
the file `+COPYING+` in the source distribution.

jq uses a C library for decimal number support. This is an ICU 1.8.1
licensed code obtained from the ICU downloads archive. +
https://download.icu-project.org/files/decNumber/decNumber-icu-368.zip

==== Linux

*   jq is in the official https://packages.debian.org/jq[Debian] and
    https://packages.ubuntu.com/jq[Ubuntu] repositories. Install using
    `+sudo apt-get install jq+`.
*   jq is in the official https://src.fedoraproject.org/rpms/jq[Fedora]
    repository. Install using `+sudo dnf install jq+`.
*   jq is in the official
    https://software.opensuse.org/package/jq[openSUSE] repository. Install using `+sudo zypper install jq+`.
*   jq is in the official https://archlinux.org/packages/?q=jq[Arch]
    repository. Install using `+sudo pacman -S jq+`.
*   jq 1.7.1 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-arm64[ARM64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-i386[i386].
*   jq 1.7 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.7/jq-linux-amd64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7/jq-linux-arm64[ARM64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7/jq-linux-i386[i386].
*   jq 1.6 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.6/jq-linux64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.6/jq-linux32[i386].
*   jq 1.5 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.5/jq-linux64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.5/jq-linux32[i386].
*   jq 1.4 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.4/jq-linux-x86_64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.4/jq-linux-x86[i386].
*   jq 1.3 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.3/jq-linux-x86_64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.3/jq-linux-x86[i386].

==== macOS

*   Use https://brew.sh/[Homebrew] to install jq with `+brew install jq+`.
*   Use https://www.macports.org[MacPorts] to install jq with `+port install jq+`.
*   Use https://finkproject.org[Fink] to install jq with `+fink install jq+`.
*   jq 1.7.1 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-macos-amd64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-macos-arm64[ARM64].
*   jq 1.7 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.7/jq-macos-amd64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7/jq-macos-arm64[ARM64].
*   jq 1.6 binary for
    https://github.com/jqlang/jq/releases/download/jq-1.6/jq-osx-amd64[AMD64].
*   jq 1.5 binary for
    https://github.com/jqlang/jq/releases/download/jq-1.5/jq-osx-amd64[AMD64].
*   jq 1.4 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.4/jq-osx-x86_64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.4/jq-osx-x86[i386].
*   jq 1.3 binaries for
    https://github.com/jqlang/jq/releases/download/jq-1.3/jq-osx-x86_64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.3/jq-osx-x86[i386].

==== FreeBSD

*   `+pkg install jq+` as root installs a pre-built
    https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/pkgng-intro.html[binary
    package].
*   `+make -C /usr/ports/textproc/jq install clean+` as root installs the
    https://www.freshports.org/textproc/jq/[jq]
    https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/ports-using.html[port]
    from source.

==== Solaris

*   `+pkgutil -i jq+` in https://www.opencsw.org/p/jq[OpenCSW] for Solaris
    10+, Sparc and x86.
*   jq 1.4 binaries for Solaris 11
    https://github.com/jqlang/jq/releases/download/jq-1.4/jq-solaris11-64[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.4/jq-solaris11-32[i386].

==== Windows

*   Use
    https://learn.microsoft.com/en-us/windows/package-manager/winget/[winget]
    to install jq with `+winget install jqlang.jq+`.
*   Use https://scoop.sh/[scoop] to install jq with `+scoop install jq+`.
*   Use https://chocolatey.org/[Chocolatey NuGet] to install jq with
    `+choco install jq+`.
*   jq 1.7.1 executables for
    https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-windows-amd64.exe[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-windows-i386.exe[i386].
*   jq 1.7 executables for
    https://github.com/jqlang/jq/releases/download/jq-1.7/jq-windows-amd64.exe[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.7/jq-windows-i386.exe[i386].
*   jq 1.6 executables for
    https://github.com/jqlang/jq/releases/download/jq-1.6/jq-win64.exe[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.6/jq-win32.exe[i386].
*   jq 1.5 executables for
    https://github.com/jqlang/jq/releases/download/jq-1.5/jq-win64.exe[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.5/jq-win32.exe[i386].
*   jq 1.4 executables for
    https://github.com/jqlang/jq/releases/download/jq-1.4/jq-win64.exe[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.4/jq-win32.exe[i386].
*   jq 1.3 executables for
    https://github.com/jqlang/jq/releases/download/jq-1.3/jq-win64.exe[AMD64]
    or https://github.com/jqlang/jq/releases/download/jq-1.3/jq-win32.exe[i386].

==== Checksums and signatures

SHA-256 checksums are provided for all release and pre-release binaries.
They can be found under
https://github.com/jqlang/jq/tree/master/sig[sig/v1.x/sha256sum.txt].
The checksums for jq 1.7.1 are in
https://raw.githubusercontent.com/jqlang/jq/master/sig/v1.7.1/sha256sum.txt[sig/v1.7.1/sha256sum.txt].
The checksums for jq 1.7 are in
https://raw.githubusercontent.com/jqlang/jq/master/sig/v1.7/sha256sum.txt[sig/v1.7/sha256sum.txt].
The checksums for jq 1.6 are in
https://raw.githubusercontent.com/jqlang/jq/master/sig/v1.6/sha256sum.txt[sig/v1.6/sha256sum.txt].
The checksums for jq 1.5 are in
https://raw.githubusercontent.com/jqlang/jq/master/sig/v1.5/sha256sum.txt[sig/v1.5/sha256sum.txt].

Additionally, all release artifacts are signed by a jq release key. We
have two release keys,
https://raw.githubusercontent.com/jqlang/jq/master/sig/jq-release-old.key[one
for 1.6 and older releases], and
https://raw.githubusercontent.com/jqlang/jq/master/sig/jq-release-new.key[one
for 1.7 and newer releases]. Signatures can be found under
https://github.com/jqlang/jq/tree/master/sig[sig/v1.x/*.asc]. The
signatures for jq 1.7.1 are in
https://github.com/jqlang/jq/tree/master/sig/v1.7.1[sig/v1.7.1/*.asc].
The signatures for jq 1.7 are in
https://github.com/jqlang/jq/tree/master/sig/v1.7[sig/v1.7/*.asc]. The
signatures for jq 1.6 are in
https://github.com/jqlang/jq/tree/master/sig/v1.6[sig/v1.6/*.asc]. The
signatures for jq 1.5 are in
https://github.com/jqlang/jq/tree/master/sig/v1.5[sig/v1.5/*.asc]. You
can use https://gnupg.org/[GnuPG] to verify a signature by downloading
the signature and running `+gpg --verify signature.asc+`.

==== From source on Linux, macOS, Cygwin, and other POSIX-like operating systems

*   https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-1.7.1.tar.gz[Source
    tarball for jq 1.7.1]
*   https://github.com/jqlang/jq/releases/download/jq-1.7/jq-1.7.tar.gz[Source
    tarball for jq 1.7]
*   https://github.com/jqlang/jq/releases/download/jq-1.6/jq-1.6.tar.gz[Source
    tarball for jq 1.6]
*   https://github.com/jqlang/jq/releases/download/jq-1.5/jq-1.5.tar.gz[Source
    tarball for jq 1.5]

You can build it using the usual
`+./configure && make && sudo make install+` rigmarole.

If you're interested in using the latest development version, try:

....
git clone --recursive https://github.com/jqlang/jq.git
cd jq
autoreconf -i
./configure
make
sudo make install
....

To build it from a git clone, you'll need to install a few packages
first:

*   https://gcc.gnu.org[GCC]
*   https://www.gnu.org/software/make/[Make      
*   https://www.gnu.org/software/automake/[Autotools]

For Linux systems, these will all be in your system's package manager,
and if you do development on the machine they're most likely already
installed.

On macOS, these are all included in Apple's command line tools, which
can be installed from https://developer.apple.com/xcode/[Xcode].
However, you may find that you need a newer version of Bison than the
one provided by Apple. This can be found in https://brew.sh/[Homebrew]
or https://macports.org/[MacPorts].

If you want to generate the lexer and parser from source you can use the
`+--enable-maintainer-mode+` configure flag. This requires bison to be
installed. https://github.com/westes/flex[Flex] and
https://www.gnu.org/software/bison/[Bison].

==== Docker

Docker image is available from
https://github.com/jqlang/jq/pkgs/container/jq[GitHub Container
Registry].

....
docker run -i --rm ghcr.io/jqlang/jq -n 'range(3)'
....

===== Building the documentation

jq's documentation is compiled into static HTML using Python. To build
the docs, run `+pipenv run python3 build_website.py --root /output+` in
the `+docs/+` directory. To serve them locally, you can run
`+python3 -m http.server+`. You'll need a few Python dependencies, which
can be installed by following the instructions in `+docs/README.md+`.

The man page is built by `+make jq.1+`, or just `+make+`, also from the
YAML docs, and you'll still need the Python dependencies to build the
manpage.


[[tutorial]]
=== Tutorial

TIP: Transform by https://pandoc.org/[Pandoc]
    ``
    pandoc -tasciidoc -rhtml https://jqlang.github.io/jq/tutorial/ | code -
    ``

GitHub has a JSON API, so let's play with that. This URL gets us the
last 5 commits from the jq repo.

[source,bash]
-------------
curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5'
-------------

.Show result
[opts="collapsible"]
====================

[source,json]
-------------
  [
  {
    "sha": "cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
    "node_id": "C_kwDOAE3WVdoAKGNmZjUzMzZlYzcxYjZmZWUzOTZhOTViYjBlNGJlYTM2NWUwY2QxZTg",
    "commit": {
      "author": {
        "name": "Mattias Wadman",
        "email": "mattias.wadman@gmail.com",
        "date": "2021-06-09T14:02:22Z"
      },
      "committer": {
        "name": "Nico Williams",
        "email": "nico@cryptonector.com",
        "date": "2022-05-26T21:04:32Z"
      },
      "message": "docs: Document repeat(exp)",
      "tree": {
        "sha": "d67d5542df1f16d1a48e1fb75749f60482cd874b",
        "url": "https://api.github.com/repos/jqlang/jq/git/trees/d67d5542df1f16d1a48e1fb75749f60482cd874b"
      },
      "url": "https://api.github.com/repos/jqlang/jq/git/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/jqlang/jq/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
    "html_url": "https://github.com/jqlang/jq/commit/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
    "comments_url": "https://api.github.com/repos/jqlang/jq/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8/comments",
    "author": { ... }
    }
  ]
-------------
====================

GitHub returns nicely formatted JSON. For servers that don't, it can be
helpful to pipe the response through jq to pretty-print it. The simplest
jq program is the expression `+.+`, which takes the input and produces
it unchanged as output.

[source,bash]
-------------
curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | jq '.'
-------------

.Show result
[opts="collapsible"]
====================

[source,json]
-------------
  [
  {
    "sha": "cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
    "node_id": "C_kwDOAE3WVdoAKGNmZjUzMzZlYzcxYjZmZWUzOTZhOTViYjBlNGJlYTM2NWUwY2QxZTg",
    "commit": {
      "author": {
        "name": "Mattias Wadman",
        "email": "mattias.wadman@gmail.com",
        "date": "2021-06-09T14:02:22Z"
      },
      "committer": {
        "name": "Nico Williams",
        "email": "nico@cryptonector.com",
        "date": "2022-05-26T21:04:32Z"
      },
      "message": "docs: Document repeat(exp)",
      "tree": {
        "sha": "d67d5542df1f16d1a48e1fb75749f60482cd874b",
        "url": "https://api.github.com/repos/jqlang/jq/git/trees/d67d5542df1f16d1a48e1fb75749f60482cd874b"
      },
      "url": "https://api.github.com/repos/jqlang/jq/git/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/jqlang/jq/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
    "html_url": "https://github.com/jqlang/jq/commit/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
    "comments_url": "https://api.github.com/repos/jqlang/jq/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8/comments",
    "author": { ... }
    ...
    }
  ]
-------------
====================


We can use jq to extract just the first commit.

[source,bash]
-------------
curl 'https://api.github.com/repos/jqlang/jq/commits?per_page=5' | jq '.[0]'
-------------

.Show result
[opts="collapsible"]
====================

[source,json]
-------------
{
  "sha": "cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
  "node_id": "C_kwDOAE3WVdoAKGNmZjUzMzZlYzcxYjZmZWUzOTZhOTViYjBlNGJlYTM2NWUwY2QxZTg",
  "commit": {
    "author": {
      "name": "Mattias Wadman",
      "email": "mattias.wadman@gmail.com",
      "date": "2021-06-09T14:02:22Z"
    },
    "committer": {
      "name": "Nico Williams",
      "email": "nico@cryptonector.com",
      "date": "2022-05-26T21:04:32Z"
    },
    "message": "docs: Document repeat(exp)",
    "tree": {
      "sha": "d67d5542df1f16d1a48e1fb75749f60482cd874b",
      "url": "https://api.github.com/repos/jqlang/jq/git/trees/d67d5542df1f16d1a48e1fb75749f60482cd874b"
    },
    "url": "https://api.github.com/repos/jqlang/jq/git/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/jqlang/jq/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
  "html_url": "https://github.com/jqlang/jq/commit/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8",
  "comments_url": "https://api.github.com/repos/jqlang/jq/commits/cff5336ec71b6fee396a95bb0e4bea365e0cd1e8/comments",
  "author": {
    "login": "wader",
    "id": 185566,
    "node_id": "MDQ6VXNlcjE4NTU2Ng==",
    "avatar_url": "https://avatars.githubusercontent.com/u/185566?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wader",
    "html_url": "https://github.com/wader",
    "followers_url": "https://api.github.com/users/wader/followers",
    "following_url": "https://api.github.com/users/wader/following{/other_user}",
    "gists_url": "https://api.github.com/users/wader/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wader/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wader/subscriptions",
    "organizations_url": "https://api.github.com/users/wader/orgs",
    "repos_url": "https://api.github.com/users/wader/repos",
    "events_url": "https://api.github.com/users/wader/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wader/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nicowilliams",
    "id": 604851,
    "node_id": "MDQ6VXNlcjYwNDg1MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/604851?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nicowilliams",
    "html_url": "https://github.com/nicowilliams",
    "followers_url": "https://api.github.com/users/nicowilliams/followers",
    "following_url": "https://api.github.com/users/nicowilliams/following{/other_user}",
    "gists_url": "https://api.github.com/users/nicowilliams/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nicowilliams/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nicowilliams/subscriptions",
    "organizations_url": "https://api.github.com/users/nicowilliams/orgs",
    "repos_url": "https://api.github.com/users/nicowilliams/repos",
    "events_url": "https://api.github.com/users/nicowilliams/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nicowilliams/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f2ad9517c72f6267ae317639ab56bbfd4a8653d4",
      "url": "https://api.github.com/repos/jqlang/jq/commits/f2ad9517c72f6267ae317639ab56bbfd4a8653d4",
      "html_url": "https://github.com/jqlang/jq/commit/f2ad9517c72f6267ae317639ab56bbfd4a8653d4"
    }
  ]
}
-------------
====================

For the rest of the examples, I'll leave out the `+curl+` command - it's
not going to change.

There's a lot of info we don't care about there, so we'll restrict it
down to the most interesting fields.

[source,bash]
----
jq '.[0] | {message: .commit.message, name: .commit.committer.name}'
----

.Show result
[opts="collapsible"]
====================

[source,json]
----
{
  "message": "docs: Document repeat(exp)",
  "name": "Nico Williams"
}
----
====================

The `+|+` operator in jq feeds the output of one filter (`+.[0]+` which
gets the first element of the array in the response) into the input of
another (`+{...}+` which builds an object out of those fields). You can
access nested attributes, such as `+.commit.message+`.

Now let's get the rest of the commits.

[source,bash]
----
jq '.[] | {message: .commit.message, name: .commit.committer.name}'
----

.Show result
[opts="collapsible"]
====================

[source,json]
----
{
  "message": "docs: Document repeat(exp)",
  "name": "Nico Williams"
}
{
  "message": "Mention -n in IO-section and for input/inputs",
  "name": "Nico Williams"
}
{
  "message": "Fix iteration problem for non decimal string\n\nWhen the string transformation to number failed, all following\ntransformation failed too.\n\nThis happend because status in decNumberFromString function is\nupdated just in error case. Reusing the DEC_CONTEXT that failed\nbefore results into error even if the string is valid number.",
  "name": "Nico Williams"
}
{
  "message": "docs: point to Libera.Chat instead of Freenode",
  "name": "Nico Williams"
}
{
  "message": "Missing \"va_end\" call. This was found by running the cppcheck static analysis where it shows as error.",
  "name": "Nico Williams"
}
----
====================

`+.[]+` returns each element of the array returned in the response, one
at a time, which are all fed into
`+{message: .commit.message, name: .commit.committer.name}+`.

Data in jq is represented as streams of JSON values - every jq
expression runs for each value in its input stream, and can produce any
number of values to its output stream.

Streams are serialised by just separating JSON values with whitespace.
This is a `+cat+`-friendly format - you can just join two JSON streams
together and get a valid JSON stream.

If you want to get the output as a single array, you can tell jq to
"collect" all of the answers by wrapping the filter in square brackets:

[source,bash]
-------------
jq '[.[] | {message: .commit.message, name: .commit.committer.name}]'
-------------

.Show result
[opts="collapsible"]
====================

[source,json]
----
[
  {
    "message": "docs: Document repeat(exp)",
    "name": "Nico Williams"
  },
  {
    "message": "Mention -n in IO-section and for input/inputs",
    "name": "Nico Williams"
  },
  {
    "message": "Fix iteration problem for non decimal string\n\nWhen the string transformation to number failed, all following\ntransformation failed too.\n\nThis happend because status in decNumberFromString function is\nupdated just in error case. Reusing the DEC_CONTEXT that failed\nbefore results into error even if the string is valid number.",
    "name": "Nico Williams"
  },
  {
    "message": "docs: point to Libera.Chat instead of Freenode",
    "name": "Nico Williams"
  },
  {
    "message": "Missing \"va_end\" call. This was found by running the cppcheck static analysis where it shows as error.",
    "name": "Nico Williams"
  }
]
----
====================

'''''

Next, let's try getting the URLs of the parent commits out of the API
results as well. In each commit, the GitHub API includes information
about "parent" commits. There can be one or many.

....
"parents": [
  {
    "sha": "f2ad9517c72f6267ae317639ab56bbfd4a8653d4",
    "url": "https://api.github.com/repos/jqlang/jq/commits/f2ad9517c72f6267ae317639ab56bbfd4a8653d4",
    "html_url": "https://github.com/jqlang/jq/commit/f2ad9517c72f6267ae317639ab56bbfd4a8653d4"
  }
]
....

We want to pull out all of the "html_url" fields inside that array of
parent commits and make a simple list of strings to go along with the
"message" and "author" fields we already have.

[source,bash]
----
jq '[.[] | {message: .commit.message, name: .commit.committer.name, parents: [.parents[].html_url]}]'
----

.Show result
[opts="collapsible"]
====================

[source,json]
----
[
  {
    "message": "docs: Document repeat(exp)",
    "name": "Nico Williams",
    "parents": [
      "https://github.com/jqlang/jq/commit/f2ad9517c72f6267ae317639ab56bbfd4a8653d4"
    ]
  },
  {
    "message": "Mention -n in IO-section and for input/inputs",
    "name": "Nico Williams",
    "parents": [
      "https://github.com/jqlang/jq/commit/c4d39c4d22f2b12225ca1b311708f7e084ad9ff8"
    ]
  },
  {
    "message": "Fix iteration problem for non decimal string\n\nWhen the string transformation to number failed, all following\ntransformation failed too.\n\nThis happend because status in decNumberFromString function is\nupdated just in error case. Reusing the DEC_CONTEXT that failed\nbefore results into error even if the string is valid number.",
    "name": "Nico Williams",
    "parents": [
      "https://github.com/jqlang/jq/commit/174db0f93552bdb551ae1f3c5c64744df0ad8e2f"
    ]
  },
  {
    "message": "docs: point to Libera.Chat instead of Freenode",
    "name": "Nico Williams",
    "parents": [
      "https://github.com/jqlang/jq/commit/29cf77977ef52eec708982b19bf9d2ec17443337"
    ]
  },
  {
    "message": "Missing \"va_end\" call. This was found by running the cppcheck static analysis where it shows as error.",
    "name": "Nico Williams",
    "parents": [
      "https://github.com/jqlang/jq/commit/55e6e2c21829bd866bd4b18ee254b05c9020320a"
    ]
  }
]
----
====================

Here we're making an object as before, but this time the `+parents+`
field is being set to `+[.parents[].html_url]+`, which collects all of
the parent commit URLs defined in the parents object.

'''''

Here endeth the tutorial! There's lots more to play with. Go read
link:https://jqlang.github.io/jq/manual/[the manual] if you're interested, and
link:https://jqlang.github.io/jq/download/[download jq] if you haven't already.


[[invoking-jq]]
=== Invoking jq
{TOC}

jq filters run on a stream of JSON data. The input to jq is parsed as a
sequence of whitespace-separated JSON values which are passed through
the provided filter one at a time. The output(s) of the filter are
written to standard output, as a sequence of newline-separated JSON
data.

The simplest and most common filter (or jq program) is `+.+`, which is
the identity operator, copying the inputs of the jq processor to the
output stream. Because the default behavior of the jq processor is to
read JSON texts from the input stream, and to pretty-print outputs, the
`+.+` program's main use is to validate and pretty-print the inputs. The
jq programming language is quite rich and allows for much more than just
validation and pretty-printing.

Note: it is important to mind the shell's quoting rules. As a general
rule it's best to always quote (with single-quote characters on Unix
shells) the jq program, as too many characters with special meaning to
jq are also shell meta-characters. For example, `+jq "foo"+` will fail
on most Unix shells because that will be the same as `+jq foo+`, which
will generally fail because `+foo is not defined+`. When using the
Windows command shell (cmd.exe) it's best to use double quotes around
your jq program when given on the command-line (instead of the
`+-f program-file+` option), but then double-quotes in the jq program
need backslash escaping. When using the Powershell (`+powershell.exe+`)
or the Powershell Core (`+pwsh+`/`+pwsh.exe+`), use single-quote
characters around the jq program and backslash-escaped double-quotes
(`+\"+`) inside the jq program.

* Unix shells: `+jq '.["foo"]'+`
* Powershell: `+jq '.[\"foo\"]'+`
* Windows command shell: `+jq ".[\"foo\"]"+`

Note: jq allows user-defined functions, but every jq program must have a
top-level expression.

--------
$ jq --help
jq - commandline JSON processor [version 1.7.1]

Usage:  /usr/bin/jq.exe [options] <jq filter> [file...]
        /usr/bin/jq.exe [options] --args <jq filter> [strings...]
        /usr/bin/jq.exe [options] --jsonargs <jq filter> [JSON_TEXTS...]

jq --args '.|keys' /pl/asciidoc-lang/asg/schema.json

jq is a tool for processing JSON inputs, applying the given filter to
its JSON text inputs and producing the filter's results as JSON on
standard output.

The simplest filter is ., which copies jq's input to its output
unmodified except for formatting. For more advanced filters see
the jq(1) manpage ("man jq") and/or https://jqlang.github.io/jq/.

Example:

        $ echo '{"foo": 0}' | jq .
        {
          "foo": 0
        }

Command options:
  -n, --null-input          use `null` as the single input value;
  -R, --raw-input           read each line as string instead of JSON;
  -s, --slurp               read all inputs into an array and use it as
                            the single input value;
  -c, --compact-output      compact instead of pretty-printed output;
  -r, --raw-output          output strings without escapes and quotes;
      --raw-output0         implies -r and output NUL after each output;
  -j, --join-output         implies -r and output without newline after
                            each output;
  -a, --ascii-output        output strings by only ASCII characters
                            using escape sequences;
  -S, --sort-keys           sort keys of each object on output;
  -C, --color-output        colorize JSON output;
  -M, --monochrome-output   disable colored output;
      --tab                 use tabs for indentation;
      --indent n            use n spaces for indentation (max 7 spaces);
      --unbuffered          flush output stream after each output;
      --stream              parse the input value in streaming fashion;
      --stream-errors       implies --stream and report parse error as
                            an array;
      --seq                 parse input/output as application/json-seq;
  -f, --from-file file      load filter from the file;
  -L directory              search modules from the directory;
      --arg name value      set $name to the string value;
      --argjson name value  set $name to the JSON value;
      --slurpfile name file set $name to an array of JSON values read
                            from the file;
      --rawfile name file   set $name to string contents of file;
      --args                consume remaining arguments as positional
                            string values;
      --jsonargs            consume remaining arguments as positional
                            JSON values;
  -e, --exit-status         set exit status code based on the output;
  -b, --binary              open input/output streams in binary mode;
  -V, --version             show the version;
  --build-configuration     show jq's build configuration;
  -h, --help                show the help;
  --                        terminates argument processing;

Named arguments are also available as $ARGS.named[], while
positional arguments are available as $ARGS.positional[].
--------

You can affect how jq reads and writes its input and output using some
command-line options:

* `+--null-input+` / `+-n+`:

Don't read any input at all. Instead, the filter is run once using
`+null+` as the input. This is useful when using jq as a simple
calculator or to construct JSON data from scratch.

* `+--raw-input+` / `+-R+`:

Don't parse the input as JSON. Instead, each line of text is passed to
the filter as a string. If combined with `+--slurp+`, then the entire
input is passed to the filter as a single long string.

* `+--slurp+` / `+-s+`:

Instead of running the filter for each JSON object in the input, read
the entire input stream into a large array and run the filter just once.

* `+--compact-output+` / `+-c+`:

By default, jq pretty-prints JSON output. Using this option will result
in more compact output by instead putting each JSON object on a single
line.

* `+--raw-output+` / `+-r+`:

With this option, if the filter's result is a string then it will be
written directly to standard output rather than being formatted as a
JSON string with quotes. This can be useful for making jq filters talk
to non-JSON-based systems.

* `+--raw-output0+`:

Like `+-r+` but jq will print NUL instead of newline after each output.
This can be useful when the values being output can contain newlines.
When the output value contains NUL, jq exits with non-zero code.

* `+--join-output+` / `+-j+`:

Like `+-r+` but jq won't print a newline after each output.

* `+--ascii-output+` / `+-a+`:

jq usually outputs non-ASCII Unicode codepoints as UTF-8, even if the
input specified them as escape sequences (like "\u03bc"). Using this
option, you can force jq to produce pure ASCII output with every
non-ASCII character replaced with the equivalent escape sequence.

* `+--sort-keys+` / `+-S+`:

Output the fields of each object with the keys in sorted order.

* `+--color-output+` / `+-C+` and `+--monochrome-output+` / `+-M+`:

By default, jq outputs colored JSON if writing to a terminal. You can
force it to produce color even if writing to a pipe or a file using
`+-C+`, and disable color with `+-M+`. When the `+NO_COLOR+` environment
variable is not empty, jq disables colored output by default, but you
can enable it by `+-C+`.

Colors can be configured with the `+JQ_COLORS+` environment variable
(see below).

* `+--tab+`:

Use a tab for each indentation level instead of two spaces.

* `+--indent n+`:

Use the given number of spaces (no more than 7) for indentation.

* `+--unbuffered+`:

Flush the output after each JSON object is printed (useful if you're
piping a slow data source into jq and piping jq's output elsewhere).

* `+--stream+`:

Parse the input in streaming fashion, outputting arrays of path and leaf
values (scalars and empty arrays or empty objects). For example, `+"a"+`
becomes `+[[],"a"]+`, and `+[[],"a",["b"]]+` becomes `+[[0],[]]+`,
`+[[1],"a"]+`, and `+[[2,0],"b"]+`.

This is useful for processing very large inputs. Use this in conjunction
with filtering and the `+reduce+` and `+foreach+` syntax to reduce large
inputs incrementally.

* `+--stream-errors+`:

Like `+--stream+`, but invalid JSON inputs yield array values where the
first element is the error and the second is a path. For example,
`+["a",n]+` produces `+["Invalid literal at line 1, column 7",[1]]+`.

Implies `+--stream+`. Invalid JSON inputs produce no error values when
`+--stream+` without `+--stream-errors+`.

* `+--seq+`:

Use the `+application/json-seq+` MIME type scheme for separating JSON
texts in jq's input and output. This means that an ASCII RS (record
separator) character is printed before each value on output and an ASCII
LF (line feed) is printed after every output. Input JSON texts that fail
to parse are ignored (but warned about), discarding all subsequent input
until the next RS. This mode also parses the output of jq without the
`+--seq+` option.

* `+-f filename+` / `+--from-file filename+`:

Read filter from the file rather than from a command line, like awk's -f
option. You can also use '#' to make comments.

* `+-L directory+`:

Prepend `+directory+` to the search list for modules. If this option is
used then no builtin search list is used. See the section on modules
below.

* `+--arg name value+`:

This option passes a value to the jq program as a predefined variable.
If you run jq with `+--arg foo bar+`, then `+$foo+` is available in the
program and has the value `+"bar"+`. Note that `+value+` will be treated
as a string, so `+--arg foo 123+` will bind `+$foo+` to `+"123"+`.

Named arguments are also available to the jq program as `+$ARGS.named+`.

* `+--argjson name JSON-text+`:

This option passes a JSON-encoded value to the jq program as a
predefined variable. If you run jq with `+--argjson foo 123+`, then
`+$foo+` is available in the program and has the value `+123+`.

* `+--slurpfile variable-name filename+`:

This option reads all the JSON texts in the named file and binds an
array of the parsed JSON values to the given global variable. If you run
jq with `+--slurpfile foo bar+`, then `+$foo+` is available in the
program and has an array whose elements correspond to the texts in the
file named `+bar+`.

* `+--rawfile variable-name filename+`:

This option reads in the named file and binds its contents to the given
global variable. If you run jq with `+--rawfile foo bar+`, then `+$foo+`
is available in the program and has a string whose contents are to the
texts in the file named `+bar+`.

* `+--args+`:

Remaining arguments are positional string arguments. These are available
to the jq program as `+$ARGS.positional[]+`.

* `+--jsonargs+`:

Remaining arguments are positional JSON text arguments. These are
available to the jq program as `+$ARGS.positional[]+`.

* `+--exit-status+` / `+-e+`:

Sets the exit status of jq to 0 if the last output value was neither
`+false+` nor `+null+`, 1 if the last output value was either `+false+`
or `+null+`, or 4 if no valid result was ever produced. Normally jq
exits with 2 if there was any usage problem or system error, 3 if there
was a jq program compile error, or 0 if the jq program ran.

Another way to set the exit status is with the `+halt_error+` builtin
function.

* `+--binary+` / `+-b+`:

Windows users using WSL, MSYS2, or Cygwin, should use this option when
using a native jq.exe, otherwise jq will turn newlines (LFs) into
carriage-return-then-newline (CRLF).

* `+--version+` / `+-V+`:

Output the jq version and exit with zero.

* `+--build-configuration+`:

Output the build configuration of jq and exit with zero. This output has
no supported format or structure and may change without notice in future
releases.

* `+--help+` / `+-h+`:

Output the jq help and exit with zero.

* `+--+`:

Terminates argument processing. Remaining arguments are positional,
either strings, JSON texts, or input filenames, according to whether
`+--args+` or `+--jsonargs+` were given.

* `+--run-tests [filename]+`:

Runs the tests in the given file or standard input. This must be the
last option given and does not honor all preceding options. The input
consists of comment lines, empty lines, and program lines followed by
one input line, as many lines of output as are expected (one per
output), and a terminating empty line. Compilation failure tests start
with a line containing only `+%%FAIL+`, then a line containing the
program to compile, then a line containing an error message to compare
to the actual.

Be warned that this option can change backwards-incompatibly.

[[basic-filters]]
=== Basic filters
{TOC}

[[identity]]
[reftext="Identity: `.`"]
==== Identity: +.+

  ** <<identity>>
  ** <<object-identifier-index>>
  ** <<optional-object-identifier-index>>
  ** <<object-index>>
  ** <<array-index>>
  ** <<array-string-slice>>
  ** <<array-object-value-iterator>>
  ** <<array-object-value-iterator-optional>>
  ** <<comma>>
  ** <<pipe>>
  ** <<parenthesis>>

The absolute simplest filter is `+.+` . This filter takes its input and
produces the same value as output. That is, this is the identity
operator.

Since jq by default pretty-prints all output, a trivial program
consisting of nothing but `+.+` can be used to format JSON output from,
say, `+curl+`.

Although the identity filter never modifies the value of its input, jq
processing can sometimes make it appear as though it does. For example,
using the current implementation of jq, we would see that the
expression:

....
1E1234567890 | .
....

produces `+1.7976931348623157e+308+` on at least one platform. This is
because, in the process of parsing the number, this particular version
of jq has converted it to an IEEE754 double-precision representation,
losing precision.

The way in which jq handles numbers has changed over time and further
changes are likely within the parameters set by the relevant JSON
standards. The following remarks are therefore offered with the
understanding that they are intended to be descriptive of the current
version of jq and should not be interpreted as being prescriptive:

{empty}(1) Any arithmetic operation on a number that has not already
been converted to an IEEE754 double precision representation will
trigger a conversion to the IEEE754 representation.

{empty}(2) jq will attempt to maintain the original decimal precision of
number literals, but in expressions such `+1E1234567890+`, precision
will be lost if the exponent is too large.

{empty}(3) In jq programs, a leading minus sign will trigger the
conversion of the number to an IEEE754 representation.

{empty}(4) Comparisons are carried out using the untruncated big decimal
representation of numbers if available, as illustrated in one of the
following examples.

####Examples

[[example1]]
[cols=",",]
|===
|Command |jq '.'

|Input |"Hello, world!"

|Output |"Hello, world!"
|===
link:https://jqplay.org/?q=.&j=%22Hello%2C%20world%21%22[{Run}]


[cols=",",]
|===
|Command |jq '.'

|Input |0.12345678901234567890123456789

|Output |0.12345678901234567890123456789
|===
link:https://jqplay.org/?q=.&j=0.12345678901234567890123456789[{Run}]


[cols=",",]
|===
|Command |jq '[., tojson]'

|Input |12345678909876543212345

|Output |[12345678909876543212345,"12345678909876543212345"]
|===


[cols=",",]
|===
|Command |jq '. < 0.12345678901234567890123456788'

|Input |0.12345678901234567890123456789

|Output |false
|===
link:https://jqplay.org/?q=.%20%3C%200.12345678901234567890123456788&j=0.12345678901234567890123456789[{Run}]


[cols=",",]
|===
|Command |jq 'map([., . == 1]) \| tojson'

|Input |[1, 1.000, 1.0, 100e-2]

|Output |"[[1,true],[1.000,true],[1.0,true],[1.00,true]]"
|===
link:https://jqplay.org/?q=map%28%5B.%2C%20.%20%3D%3D%201%5D%29%20%7C%20tojson&j=%5B1%2C%201.000%2C%201.0%2C%20100e-2%5D[{Run}]


[cols=",",]
|===
|Command |jq '. as $big \| [$big, $big + 1] \| map(. >
10000000000000000000000000000000)'

|Input |10000000000000000000000000000001

|Output |[true, false]
|===
link:https://jqplay.org/?q=.%20as%20%24big%20%7C%20%5B%24big%2C%20%24big%20%2B%201%5D%20%7C%20map%28.%20%3E%2010000000000000000000000000000000%29&j=10000000000000000000000000000001[{Run}]


[[object-identifier-index]]
[reftext="Object Identifier-Index: `.foo`, `.foo.bar`"]
==== Object Identifier-Index: +.foo+, +.foo.bar+
{TOC}

The simplest _useful_ filter has the form `+.foo+`. When given a JSON
object (aka dictionary or hash) as input, `+.foo+` produces the value at
the key "foo" if the key is present, or null otherwise.

A filter of the form `+.foo.bar+` is equivalent to `+.foo | .bar+`.

The `+.foo+` syntax only works for simple, identifier-like keys, that
is, keys that are all made of alphanumeric characters and underscore,
and which do not start with a digit.

If the key contains special characters or starts with a digit, you need
to surround it with double quotes like this: `+."foo$"+`, or else
`+.["foo$"]+`.

For example `+.["foo::bar"]+` and `+.["foo.bar"]+` work while
`+.foo::bar+` does not.

####Examples

[[example2]]
[cols=",",]
|===
|Command |jq '.foo'

|Input |{"foo": 42, "bar": "less interesting data"}

|Output |42
|===
link:https://jqplay.org/?q=.foo&j=%7B%22foo%22%3A%2042%2C%20%22bar%22%3A%20%22less%20interesting%20data%22%7D[{Run}]


[cols=",",]
|===
|Command |jq '.foo'

|Input |{"notfoo": true, "alsonotfoo": false}

|Output |null
|===
link:https://jqplay.org/?q=.foo&j=%7B%22notfoo%22%3A%20true%2C%20%22alsonotfoo%22%3A%20false%7D[{Run}]


[cols=",",]
|===
|Command |jq '.["foo"]'

|Input |{"foo": 42}

|Output |42
|===


[[optional-object-identifier-index]]
[reftext="Optional Object Identifier-Index: `.foo?`"]
==== Optional Object Identifier-Index: +.foo?+
{TOC}

Just like `+.foo+`, but does not output an error when `+.+` is not an
object.

####Examples

[[example3]]
[cols=",",]
|===
|Command |jq '.foo?'

|Input |{"foo": 42, "bar": "less interesting data"}

|Output |42
|===
link:https://jqplay.org/?q=.foo%3F&j=%7B%22foo%22%3A%2042%2C%20%22bar%22%3A%20%22less%20interesting%20data%22%7D[{Run}]


[cols=",",]
|===
|Command |jq '.foo?'

|Input |{"notfoo": true, "alsonotfoo": false}

|Output |null
|===
link:https://jqplay.org/?q=.foo%3F&j=%7B%22notfoo%22%3A%20true%2C%20%22alsonotfoo%22%3A%20false%7D[{Run}]


[cols=",",]
|===
|Command |jq '.["foo"]?'

|Input |{"foo": 42}

|Output |42
|===


[cols=",",]
|===
|Command |jq '[.foo?]'

|Input |[1,2]

|Output |[]
|===
link:https://jqplay.org/?q=%5B.foo%3F%5D&j=%5B1%2C2%5D[{Run}]


[[object-index]]
[reftext="Object Index: `.[<string>]`"]
==== Object Index: +.[<string>]+
{TOC}

You can also look up fields of an object using syntax like `+.["foo"]+`
(`+.foo+` above is a shorthand version of this, but only for
identifier-like strings).

[[array-index]]
[reftext="Array Index: `.[<number>]`"]
==== Array Index: +.[<number>]+
{TOC}

When the index value is an integer, `+.[<number>]+` can index arrays.
Arrays are zero-based, so `+.[2]+` returns the third element.

Negative indices are allowed, with -1 referring to the last element, -2
referring to the next to last element, and so on.

####Examples

[[example4]]
[cols=",",]
|===
|Command |jq '.[0]'

|Input |[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]

|Output |{"name":"JSON", "good":true}
|===
link:https://jqplay.org/?q=.%5B0%5D&j=%5B%7B%22name%22%3A%22JSON%22%2C%20%22good%22%3Atrue%7D%2C%20%7B%22name%22%3A%22XML%22%2C%20%22good%22%3Afalse%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[2]'

|Input |[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]

|Output |null
|===
link:https://jqplay.org/?q=.%5B2%5D&j=%5B%7B%22name%22%3A%22JSON%22%2C%20%22good%22%3Atrue%7D%2C%20%7B%22name%22%3A%22XML%22%2C%20%22good%22%3Afalse%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[-2]'

|Input |[1,2,3]

|Output |2
|===
link:https://jqplay.org/?q=.%5B-2%5D&j=%5B1%2C2%2C3%5D[{Run}]


[[array-string-slice]]
[reftext="Array/String Slice: `.[<number>:<number>]`"]
==== Array/String Slice: +.[<number>:<number>]+
{TOC}

The `+.[<number>:<number>]+` syntax can be used to return a subarray of
an array or substring of a string. The array returned by `+.[10:15]+`
will be of length 5, containing the elements from index 10 (inclusive)
to index 15 (exclusive). Either index may be negative (in which case it
counts backwards from the end of the array), or omitted (in which case
it refers to the start or end of the array). Indices are zero-based.

####Examples

[[example5]]
[cols=",",]
|===
|Command |jq '.[2:4]'

|Input |["a","b","c","d","e"]

|Output |["c", "d"]
|===
link:https://jqplay.org/?q=.%5B2%3A4%5D&j=%5B%22a%22%2C%22b%22%2C%22c%22%2C%22d%22%2C%22e%22%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[2:4]'

|Input |"abcdefghi"

|Output |"cd"
|===
link:https://jqplay.org/?q=.%5B2%3A4%5D&j=%22abcdefghi%22[{Run}]


[cols=",",]
|===
|Command |jq '.[:3]'

|Input |["a","b","c","d","e"]

|Output |["a", "b", "c"]
|===
link:https://jqplay.org/?q=.%5B%3A3%5D&j=%5B%22a%22%2C%22b%22%2C%22c%22%2C%22d%22%2C%22e%22%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[-2:]'

|Input |["a","b","c","d","e"]

|Output |["d", "e"]
|===
link:https://jqplay.org/?q=.%5B-2%3A%5D&j=%5B%22a%22%2C%22b%22%2C%22c%22%2C%22d%22%2C%22e%22%5D[{Run}]


[[array-object-value-iterator]]
[reftext="Array/Object Value Iterator: `.[]`"]
==== Array/Object Value Iterator: +.[]+
{TOC}

If you use the `+.[index]+` syntax, but omit the index entirely, it will
return _all_ of the elements of an array. Running `+.[]+` with the input
`+[1,2,3]+` will produce the numbers as three separate results, rather
than as a single array. A filter of the form `+.foo[]+` is equivalent to
`+.foo | .[]+`.

You can also use this on an object, and it will return all the values of
the object.

Note that the iterator operator is a generator of values.

####Examples

[[example6]]
[cols=",",]
|===
|Command |jq '.[]'

|Input |[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]

|Output |{"name":"JSON", "good":true}

| |\{"name":"XML", "good":false}
|===
link:https://jqplay.org/?q=.%5B%5D&j=%5B%7B%22name%22%3A%22JSON%22%2C%20%22good%22%3Atrue%7D%2C%20%7B%22name%22%3A%22XML%22%2C%20%22good%22%3Afalse%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[]'

|Input |[]

|Output |none
|===
link:https://jqplay.org/?q=.%5B%5D&j=%5B%5D[{Run}]


[cols=",",]
|===
|Command |jq '.foo[]'

|Input |{"foo":[1,2,3]}

|Output |1

| |2

| |3
|===


[cols=",",]
|===
|Command |jq '.[]'

|Input |{"a": 1, "b": 1}

|Output |1

| |1
|===
link:https://jqplay.org/?q=.%5B%5D&j=%7B%22a%22%3A%201%2C%20%22b%22%3A%201%7D[{Run}]


[[array-object-value-iterator-optional]]
[reftext="`Optional Array/Object Value Iterator: +.[]?`"]
==== Optional Array/Object Value Iterator: +.[]?+
{TOC}

Like `+.[]+`, but no errors will be output if . is not an array or
object. A filter of the form `+.foo[]?+` is equivalent to
`+.foo | .[]?+`.

[[comma]]
[reftext="Comma: `,`"]
==== Comma: +,+
{TOC}

If two filters are separated by a comma, then the same input will be fed
into both and the two filters' output value streams will be concatenated
in order: first, all of the outputs produced by the left expression, and
then all of the outputs produced by the right. For instance, filter
`+.foo, .bar+`, produces both the "foo" fields and "bar" fields as
separate outputs.

The `+,+` operator is one way to construct generators.

####Examples

[[example7]]
[cols=",",]
|===
|Command |jq '.foo, .bar'

|Input |{"foo": 42, "bar": "something else", "baz": true}

|Output |42

| |"something else"
|===
link:https://jqplay.org/?q=.foo%2C%20.bar&j=%7B%22foo%22%3A%2042%2C%20%22bar%22%3A%20%22something%20else%22%2C%20%22baz%22%3A%20true%7D[{Run}]


[cols=",",]
|===
|Command |jq '.user, .projects[]'

|Input |{"user":"stedolan", "projects": ["jq", "wikiflow"]}

|Output |"stedolan"

| |"jq"

| |"wikiflow"
|===
link:https://jqplay.org/?q=.user%2C%20.projects%5B%5D&j=%7B%22user%22%3A%22stedolan%22%2C%20%22projects%22%3A%20%5B%22jq%22%2C%20%22wikiflow%22%5D%7D[{Run}]


[cols=",",]
|===
|Command |jq '.[4,2]'

|Input |["a","b","c","d","e"]

|Output |"e"

| |"c"
|===
link:https://jqplay.org/?q=.%5B4%2C2%5D&j=%5B%22a%22%2C%22b%22%2C%22c%22%2C%22d%22%2C%22e%22%5D[{Run}]


[[pipe]]
[reftext="Pipe: `|`"]
==== Pipe: +|+
{TOC}

The | operator combines two filters by feeding the output(s) of the one
on the left into the input of the one on the right. It's similar to the
Unix shell's pipe, if you're used to that.

If the one on the left produces multiple results, the one on the right
will be run for each of those results. So, the expression `+.[] | .foo+`
retrieves the "foo" field of each element of the input array. This is a
cartesian product, which can be surprising.

Note that `+.a.b.c+` is the same as `+.a | .b | .c+`.

Note too that `+.+` is the input value at the particular stage in a
"pipeline", specifically: where the `+.+` expression appears. Thus
`+.a | . | .b+` is the same as `+.a.b+`, as the `+.+` in the middle
refers to whatever value `+.a+` produced.

####Example

[[example8]]
[cols=",",]
|===
|Command |jq '.[] \| .name'

|Input |[{"name":"JSON", "good":true}, {"name":"XML", "good":false}]

|Output |"JSON"

| |"XML"
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20.name&j=%5B%7B%22name%22%3A%22JSON%22%2C%20%22good%22%3Atrue%7D%2C%20%7B%22name%22%3A%22XML%22%2C%20%22good%22%3Afalse%7D%5D[{Run}]


[[parenthesis]]
[reftext="Parenthesis `()`"]
==== Parenthesis ()
{TOC}

Parenthesis work as a grouping operator just as in any typical
programming language.

####Example

[[example9]]
[cols=",",]
|===
|Command |jq '(. + 2) * 5'

|Input |1

|Output |15
|===
link:https://jqplay.org/?q=%28.%20%2B%202%29%20%2A%205&j=1[{Run}]


[[types-and-values]]
=== Types and Values
{TOC}

  ** <<array-construction>>
  ** <<object-construction>>
  ** <<recursive-descent>>

jq supports the same set of datatypes as JSON - numbers, strings,
booleans, arrays, objects (which in JSON-speak are hashes with only
string keys), and "null".

Booleans, null, strings and numbers are written the same way as in JSON.
Just like everything else in jq, these simple values take an input and
produce an output - `+42+` is a valid jq expression that takes an input,
ignores it, and returns 42 instead.

Numbers in jq are internally represented by their IEEE754 double
precision approximation. Any arithmetic operation with numbers, whether
they are literals or results of previous filters, will produce a double
precision floating point result.

However, when parsing a literal jq will store the original literal
string. If no mutation is applied to this value then it will make to the
output in its original form, even if conversion to double would result
in a loss.

[[array-construction]]
[reftext="Array construction: `[]`"]
==== Array construction: +[]+
{TOC}

As in JSON, `+[]+` is used to construct arrays, as in `+[1,2,3]+`. The
elements of the arrays can be any jq expression, including a pipeline.
All of the results produced by all of the expressions are collected into
one big array. You can use it to construct an array out of a known
quantity of values (as in `+[.foo, .bar, .baz]+`) or to "collect" all
the results of a filter into an array (as in `+[.items[].name]+`)

Once you understand the "," operator, you can look at jq's array syntax
in a different light: the expression `+[1,2,3]+` is not using a built-in
syntax for comma-separated arrays, but is instead applying the `+[]+`
operator (collect results) to the expression 1,2,3 (which produces three
different results).

If you have a filter `+X+` that produces four results, then the
expression `+[X]+` will produce a single result, an array of four
elements.

####Examples

[[example10]]
[cols=",",]
|===
|Command |jq '[.user, .projects[]]'

|Input |{"user":"stedolan", "projects": ["jq", "wikiflow"]}

|Output |["stedolan", "jq", "wikiflow"]
|===
link:https://jqplay.org/?q=%5B.user%2C%20.projects%5B%5D%5D&j=%7B%22user%22%3A%22stedolan%22%2C%20%22projects%22%3A%20%5B%22jq%22%2C%20%22wikiflow%22%5D%7D[{Run}]


[cols=",",]
|===
|Command |jq '[ .[] \| . * 2]'

|Input |[1, 2, 3]

|Output |[2, 4, 6]
|===
link:https://jqplay.org/?q=%5B%20.%5B%5D%20%7C%20.%20%2A%202%5D&j=%5B1%2C%202%2C%203%5D[{Run}]


[[object-construction]]
[reftext="Object Construction: `{}`"]
==== Object Construction: +{}+
{TOC}

Like JSON, `+{}+` is for constructing objects (aka dictionaries or
hashes), as in: `+{"a": 42, "b": 17}+`.

If the keys are "identifier-like", then the quotes can be left off, as
in `+{a:42, b:17}+`. Variable references as key expressions use the
value of the variable as the key. Key expressions other than constant
literals, identifiers, or variable references, need to be parenthesized,
e.g., `+{("a"+"b"):59}+`.

The value can be any expression (although you may need to wrap it in
parentheses if, for example, it contains colons), which gets applied to
the \{} expression's input (remember, all filters have an input and an
output).

....
{foo: .bar}
....

will produce the JSON object `+{"foo": 42}+` if given the JSON object
`+{"bar":42, "baz":43}+` as its input. You can use this to select
particular fields of an object: if the input is an object with "user",
"title", "id", and "content" fields and you just want "user" and
"title", you can write

....
{user: .user, title: .title}
....

Because that is so common, there's a shortcut syntax for it:
`+{user, title}+`.

If one of the expressions produces multiple results, multiple
dictionaries will be produced. If the input's

....
{"user":"stedolan","titles":["JQ Primer", "More JQ"]}
....

then the expression

....
{user, title: .titles[]}
....

will produce two outputs:

....
{"user":"stedolan", "title": "JQ Primer"}
{"user":"stedolan", "title": "More JQ"}
....

Putting parentheses around the key means it will be evaluated as an
expression. With the same input as above,

....
{(.user): .titles}
....

produces

....
{"stedolan": ["JQ Primer", "More JQ"]}
....

Variable references as keys use the value of the variable as the key.
Without a value then the variable's name becomes the key and its value
becomes the value,

....
"f o o" as $foo | "b a r" as $bar | {$foo, $bar:$foo}
....

produces

....
{"foo":"f o o","b a r":"f o o"}
....

####Examples

[[example11]]
[cols=",",]
|===
|Command |jq '{user, title: .titles[]}'

|Input   |{"user":"stedolan","titles":["JQ Primer", "More JQ"]}

|Output  |{"user":"stedolan", "title": "JQ Primer"}

          {"user":"stedolan", "title": "More JQ"}
|===
link:https://jqplay.org/?q=%7Buser%2C%20title%3A%20.titles%5B%5D%7D&j=%7B%22user%22%3A%22stedolan%22%2C%22titles%22%3A%5B%22JQ%20Primer%22%2C%20%22More%20JQ%22%5D%7D[{Run}]


[cols=",",]
|===
|Command |jq '{(.user): .titles}'

|Input   |{"user":"stedolan","titles":["JQ Primer", "More JQ"]}

|Output  |{"stedolan": ["JQ Primer", "More JQ"]}
|===
link:https://jqplay.org/?q=%7B%28.user%29%3A%20.titles%7D&j=%7B%22user%22%3A%22stedolan%22%2C%22titles%22%3A%5B%22JQ%20Primer%22%2C%20%22More%20JQ%22%5D%7D[{Run}]


[[recursive-descent]]
[reftext="Recursive Descent: `..`"]
==== Recursive Descent: +..+
{TOC}

Recursively descends `+.+`, producing every value. This is the same as
the zero-argument `+recurse+` builtin (see below). This is intended to
resemble the XPath `+//+` operator. Note that `+..a+` does not work; use
`+.. | .a+` instead. In the example below we use `+.. | .a?+` to find
all the values of object keys "a" in any object found "below" `+.+`.

This is particularly useful in conjunction with `+path(EXP)+` (also see
below) and the `+?+` operator.

####Example

[[example12]]
[cols=",",]
|===
|Command |jq '.. \| .a?'

|Input   |[[{"a":1}]]

|Output  |1
|===


[[builtin-operators-and-functions]]
=== Builtin operators and functions
{TOC}

[title="Built-in operators and functions",cols="1,1,~"]
|===
|<<addition>>   |<<tonumber>>   |<<subtraction>>
|<<abs>>        |<<tostring>>   |<<multiplication-division-modulo>>
|<<length>>     |<<type>>       |<<utf8bytelength>>
|<<has>>        |<<group_by>>   |<<keys-keys_unsorted>>
|<<in>>         |<<reverse>>    |<<map-map_values>>
|<<pick>>       |<<contains>>   |<<to_entries-from_entries-with_entries>>
|<<path>>       |<<indices>>    |<<arrays-objects-iterables-booleans-numbers-normals-finites-strings-nulls-values-scalars>>
|<<del>>        |<<inside>>     |<<infinite-nan-isinfinite-isnan-isfinite-isnormal>>
|<<getpath>>    |<<startswith>> |<<sort-sort_by>>
|<<setpath>>    |<<endswith>>   |<<min-max-min_by-max_by>>
|<<delpaths>>   |<<ltrimstr>>   |<<unique-unique_by>>
|<<select>>     |<<rtrimstr>>   |<<index-rindex>>
|<<empty>>      |<<explode>>    |<<combinations>>
|<<error>>      |<<implode>>    |<<ascii_downcase-ascii_upcase>>
|<<halt>>       |<<split-1>>    |<<dollar_jq_build_configuration>>
|<<halt_error>> |<<join>>       |<<dollar_env-env>>
|<<dollar_loc>> |<<while>>      |<<string-interpolation>>
|<<paths>>      |<<repeat>>     |<<convert-to-from-json>>
|<<add>>        |<<until>>      |<<format-strings-and-escaping>>
|<<any>>        |<<recurse>>    |<<sql-style-operators>>
|<<all>>        |<<walk>>         
|<<flatten>>    |<<transpose>>    
|<<range>>      |<<bsearch>>      
|<<floor>>      |<<dates>>        
|<<sqrt>>       |<<builtins>>     
|===

Some jq operators (for instance, `+++`) do different things depending on
the type of their arguments (arrays, numbers, etc.). However, jq never
does implicit type conversions. If you try to add a string to an object
you'll get an error message and no result.

Please note that all numbers are converted to IEEE754 double precision
floating point representation. Arithmetic and logical operators are
working with these converted doubles. Results of all such operations are
also limited to the double precision.

The only exception to this behaviour of number is a snapshot of original
number literal. When a number which originally was provided as a literal
is never mutated until the end of the program then it is printed to the
output in its original literal form. This also includes cases when the
original literal would be truncated when converted to the IEEE754 double
precision floating point number.

[[addition]]
[reftext="Addition: `+`"]
==== Addition: +++
{TOC}

The operator `+++` takes two filters, applies them both to the same
input, and adds the results together. What "adding" means depends on the
types involved:

* *Numbers* are added by normal arithmetic.
* *Arrays* are added by being concatenated into a larger array.
* *Strings* are added by being joined into a larger string.
* *Objects* are added by merging, that is, inserting all the key-value
  pairs from both objects into a single combined object. If both objects
  contain a value for the same key, the object on the right of the `+++`
  wins. (For recursive merge use the `+*+` operator.)

`+null+` can be added to any value, and returns the other value
unchanged.

####Examples

[[example13]]
[cols=",",]
|===
|Command |jq '.a + 1'

|Input |{"a": 7}

|Output |8
|===
link:https://jqplay.org/?q=.a%20%2B%201&j=%7B%22a%22%3A%207%7D[{Run}]


[cols=",",]
|===
|Command |jq '.a + .b'

|Input |{"a": [1,2], "b": [3,4]}

|Output |[1,2,3,4]
|===
link:https://jqplay.org/?q=.a%20%2B%20.b&j=%7B%22a%22%3A%20%5B1%2C2%5D%2C%20%22b%22%3A%20%5B3%2C4%5D%7D[{Run}]


[cols=",",]
|===
|Command |jq '.a + null'

|Input |{"a": 1}

|Output |1
|===


[cols=",",]
|===
|Command |jq '.a + 1'

|Input |{}

|Output |1
|===
link:https://jqplay.org/?q=.a%20%2B%201&j=%7B%7D[{Run}]


[cols=",",]
|===
|Command |jq '{a: 1} + {b: 2} + {c: 3} + {a: 42}'

|Input |null

|Output |{"a": 42, "b": 2, "c": 3}
|===
link:https://jqplay.org/?q=%7Ba%3A%201%7D%20%2B%20%7Bb%3A%202%7D%20%2B%20%7Bc%3A%203%7D%20%2B%20%7Ba%3A%2042%7D&j=null[{Run}]


[[subtraction]]
[reftext="Subtraction: `-`"]
==== Subtraction: +-+
{TOC}

As well as normal arithmetic subtraction on numbers, the `+-+` operator
can be used on arrays to remove all occurrences of the second array's
elements from the first array.

####Examples

[[example14]]
[cols=",",]
|===
|Command |jq '4 - .a'

|Input |{"a":3}

|Output |1
|===
link:https://jqplay.org/?q=4%20-%20.a&j=%7B%22a%22%3A3%7D[{Run}]


[cols=",",]
|===
|Command |jq '. - ["xml", "yaml"]'

|Input |["xml", "yaml", "json"]

|Output |["json"]
|===
link:https://jqplay.org/?q=.%20-%20%5B%22xml%22%2C%20%22yaml%22%5D&j=%5B%22xml%22%2C%20%22yaml%22%2C%20%22json%22%5D[{Run}]


[[multiplication-division-modulo]]
[reftext="Multiplication, division, modulo: `*`, `/`, `%`"]
==== Multiplication, division, modulo: +*+, +/+, +%+
{TOC}

These infix operators behave as expected when given two numbers.
Division by zero raises an error. `+x % y+` computes x modulo y.

Multiplying a string by a number produces the concatenation of that
string that many times. `+"x" * 0+` produces `+""+`.

Dividing a string by another splits the first using the second as
separators.

Multiplying two objects will merge them recursively: this works like
addition but if both objects contain a value for the same key, and the
values are objects, the two are merged with the same strategy.

####Examples

[[example15]]
[cols=",",]
|===
|Command |jq '10 / . * 3'

|Input |5

|Output |6
|===
link:https://jqplay.org/?q=10%20/%20.%20%2A%203&j=5[{Run}]


[cols=",",]
|===
|Command |jq '. / ", "'

|Input |"a, b,c,d, e"

|Output |["a","b,c,d","e"]
|===
link:https://jqplay.org/?q=.%20/%20%22%2C%20%22&j=%22a%2C%20b%2Cc%2Cd%2C%20e%22[{Run}]


[cols=",",]
|===
|Command |jq '{"k": {"a": 1, "b": 2}} * {"k": {"a": 0,"c": 3}}'

|Input |null

|Output |{"k": {"a": 0, "b": 2, "c": 3}}
|===
link:https://jqplay.org/?q=%7B%22k%22%3A%20%7B%22a%22%3A%201%2C%20%22b%22%3A%202%7D%7D%20%2A%20%7B%22k%22%3A%20%7B%22a%22%3A%200%2C%22c%22%3A%203%7D%7D&j=null[{Run}]


[cols=",",]
|===
|Command |jq '.[] \| (1 / .)?'

|Input |[1,0,-1]

|Output |1    +
        -1
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20%281%20/%20.%29%3F&j=%5B1%2C0%2C-1%5D[{Run}]


[[abs]]
[reftext="`abs`"]
==== +abs+
{TOC}

The builtin function `+abs+` is defined naively as:
`+if . < 0 then - . else . end+`.

For numeric input, this is the absolute value. See the section on the
identity filter for the implications of this definition for numeric
input.

To compute the absolute value of a number as a floating point number,
you may wish use `+fabs+`.

####Example

[[example16]]
[cols=",",]
|===
|Command |jq 'map(abs)'

|Input |[-10, -1.1, -1e-1]

|Output |[10,1.1,1e-1]
|===


[[length]]
[reftext="`length`"]
==== +length+
{TOC}

The builtin function `+length+` gets the length of various different
types of value:

* The length of a *string* is the number of Unicode codepoints it
contains (which will be the same as its JSON-encoded length in bytes if
it's pure ASCII).
* The length of a *number* is its absolute value.
* The length of an *array* is the number of elements.
* The length of an *object* is the number of key-value pairs.
* The length of *null* is zero.
* It is an error to use `+length+` on a *boolean*.

####Example

[[example17]]
[cols=",",]
|===
|Command |jq '.[] \| length'

|Input |[[1,2], "string", {"a":2}, null, -5]

|Output |2

| |6

| |1

| |0

| |5
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20length&j=%5B%5B1%2C2%5D%2C%20%22string%22%2C%20%7B%22a%22%3A2%7D%2C%20null%2C%20-5%5D[{Run}]


[[utf8bytelength]]
[reftext="`utf8bytelength`"]
==== +utf8bytelength+
{TOC}

The builtin function `+utf8bytelength+` outputs the number of bytes used
to encode a string in UTF-8.

####Example

[[example18]]
[cols=",",]
|===
|Command |jq 'utf8bytelength'

|Input |"\u03bc"

|Output |2
|===
link:https://jqplay.org/?q=utf8bytelength&j=%22%5Cu03bc%22[{Run}]


[[keys-keys_unsorted]]
[reftext="`keys`, `keys_unsorted`"]
==== +keys+, +keys_unsorted+
{TOC}

The builtin function `+keys+`, when given an object, returns its keys in
an array.

The keys are sorted "alphabetically", by unicode codepoint order. This
is not an order that makes particular sense in any particular language,
but you can count on it being the same for any two objects with the same
set of keys, regardless of locale settings.

When `+keys+` is given an array, it returns the valid indices for that
array: the integers from 0 to length-1.

The `+keys_unsorted+` function is just like `+keys+`, but if the input
is an object then the keys will not be sorted, instead the keys will
roughly be in insertion order.

####Examples

[[example19]]
[cols=",",]
|===
|Command |jq 'keys'

|Input |{"abc": 1, "abcd": 2, "Foo": 3}

|Output |["Foo", "abc", "abcd"]
|===


[cols=",",]
|===
|Command |jq 'keys'

|Input |[42,3,35]

|Output |[0,1,2]
|===
link:https://jqplay.org/?q=keys&j=%5B42%2C3%2C35%5D[{Run}]


[[has]]
[reftext="`has(key)`"]
==== +has(key)+
{TOC}

The builtin function `+has+` returns whether the input object has the
given key, or the input array has an element at the given index.

`+has($key)+` has the same effect as checking whether `+$key+` is a
member of the array returned by `+keys+`, although `+has+` will be
faster.

####Examples

[[example20]]
[cols=",",]
|===
|Command |jq 'map(has("foo"))'

|Input |[{"foo": 42}, {}]

|Output |[true, false]
|===
link:https://jqplay.org/?q=map%28has%28%22foo%22%29%29&j=%5B%7B%22foo%22%3A%2042%7D%2C%20%7B%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'map(has(2))'

|Input |[[0,1], ["a","b","c"]]

|Output |[false, true]
|===
link:https://jqplay.org/?q=map%28has%282%29%29&j=%5B%5B0%2C1%5D%2C%20%5B%22a%22%2C%22b%22%2C%22c%22%5D%5D[{Run}]


[[in]]
[reftext="`in`"]
==== +in+
{TOC}

The builtin function `+in+` returns whether or not the input key is in
the given object, or the input index corresponds to an element in the
given array. It is, essentially, an inversed version of `+has+`.

####Examples

[[example21]]
[cols=",",]
|===
|Command |jq '.[] \| in({"foo": 42})'

|Input |["foo", "bar"]

|Output |true

| |false
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20in%28%7B%22foo%22%3A%2042%7D%29&j=%5B%22foo%22%2C%20%22bar%22%5D[{Run}]


[cols=",",]
|===
|Command |jq 'map(in([0,1]))'

|Input |[2, 0]

|Output |[false, true]
|===


[[map-map_values]]
[reftext="`map(f)`, `map_values(f)`"]
==== +map(f)+, +map_values(f)+
{TOC}

For any filter `+f+`, `+map(f)+` and `+map_values(f)+` apply `+f+` to
each of the values in the input array or object, that is, to the values
of `+.[]+`.

In the absence of errors, `+map(f)+` always outputs an array whereas
`+map_values(f)+` outputs an array if given an array, or an object if
given an object.

When the input to `+map_values(f)+` is an object, the output object has
the same keys as the input object except for those keys whose values
when piped to `+f+` produce no values at all.

The key difference between `+map(f)+` and `+map_values(f)+` is that the
former simply forms an array from all the values of `+($x|f)+` for each
value, $x, in the input array or object, but `+map_values(f)+` only uses
`+first($x|f)+`.

Specifically, for object inputs, `+map_values(f)+` constructs the output
object by examining in turn the value of `+first(.[$k]|f)+` for each
key, $k, of the input. If this expression produces no values, then the
corresponding key will be dropped; otherwise, the output object will
have that value at the key, $k.

Here are some examples to clarify the behavior of `+map+` and
`+map_values+` when applied to arrays. These examples assume the input
is `+[1]+` in all cases:

....
map(.+1)          #=>  [2]
map(., .)         #=>  [1,1]
map(empty)        #=>  []

map_values(.+1)   #=>  [2]
map_values(., .)  #=>  [1]
map_values(empty) #=>  []
....

`+map(f)+` is equivalent to `+[.[] | f]+` and `+map_values(f)+` is
equivalent to `+.[] |= f+`.

In fact, these are their implementations.

####Examples

[[example22]]
[cols=",",]
|===
|Command |jq 'map(.+1)'

|Input |[1,2,3]

|Output |[2,3,4]
|===
link:https://jqplay.org/?q=map%28.%2B1%29&j=%5B1%2C2%2C3%5D[{Run}]


[cols=",",]
|===
|Command |jq 'map_values(.+1)'

|Input |{"a": 1, "b": 2, "c": 3}

|Output |{"a": 2, "b": 3, "c": 4}
|===
link:https://jqplay.org/?q=map_values%28.%2B1%29&j=%7B%22a%22%3A%201%2C%20%22b%22%3A%202%2C%20%22c%22%3A%203%7D[{Run}]


[cols=",",]
|===
|Command |jq 'map(., .)'

|Input |[1,2]

|Output |[1,1,2,2]
|===
link:https://jqplay.org/?q=map%28.%2C%20.%29&j=%5B1%2C2%5D[{Run}]


[cols=",",]
|===
|Command |jq 'map_values(. // empty)'

|Input |{"a": null, "b": true, "c": false}

|Output |{"b":true}
|===


[[pick]]
[reftext="`pick(pathexps)`"]
==== +pick(pathexps)+
{TOC}

Emit the projection of the input object or array defined by the
specified sequence of path expressions, such that if `+p+` is any one of
these specifications, then `+(. | p)+` will evaluate to the same value
as `+(. | pick(pathexps) | p)+`. For arrays, negative indices and
`+.[m:n]+` specifications should not be used.

####Examples

[[example23]]
[cols=",",]
|===
|Command |jq 'pick(.a, .b.c, .x)'

|Input |{"a": 1, "b": {"c": 2, "d": 3}, "e": 4}

|Output |{"a":1,"b":{"c":2},"x":null}
|===
link:https://jqplay.org/?q=pick%28.a%2C%20.b.c%2C%20.x%29&j=%7B%22a%22%3A%201%2C%20%22b%22%3A%20%7B%22c%22%3A%202%2C%20%22d%22%3A%203%7D%2C%20%22e%22%3A%204%7D[{Run}]


[cols=",",]
|===
|Command |jq 'pick(.[2], .[0], .[0])'

|Input |[1,2,3,4]

|Output |[1,null,3]
|===
link:https://jqplay.org/?q=pick%28.%5B2%5D%2C%20.%5B0%5D%2C%20.%5B0%5D%29&j=%5B1%2C2%2C3%2C4%5D[{Run}]


[[path]]
[reftext="`path(path_expression)`"]
==== +path(path_expression)+
{TOC}

Outputs array representations of the given path expression in `+.+`. The
outputs are arrays of strings (object keys) and/or numbers (array
indices).

Path expressions are jq expressions like `+.a+`, but also `+.[]+`. There
are two types of path expressions: ones that can match exactly, and ones
that cannot. For example, `+.a.b.c+` is an exact match path expression,
while `+.a[].b+` is not.

`+path(exact_path_expression)+` will produce the array representation of
the path expression even if it does not exist in `+.+`, if `+.+` is
`+null+` or an array or an object.

`+path(pattern)+` will produce array representations of the paths
matching `+pattern+` if the paths exist in `+.+`.

Note that the path expressions are not different from normal
expressions. The expression `+path(..|select(type=="boolean"))+` outputs
all the paths to boolean values in `+.+`, and only those paths.

####Examples

[[example24]]
[cols=",",]
|===
|Command |jq 'path(.a[0].b)'

|Input |null

|Output |["a",0,"b"]
|===
link:https://jqplay.org/?q=path%28.a%5B0%5D.b%29&j=null[{RUN},role="right clearfix"]


[cols=",",]
|===
|Command |jq '[path(..)]'

|Input |{"a":[{"b":1}]}

|Output |[[],["a"],["a",0],["a",0,"b"]]
|===
link:https://jqplay.org/?q=%5Bpath%28..%29%5D&j=%7B%22a%22%3A%5B%7B%22b%22%3A1%7D%5D%7D[{Run}]


[[del]]
[reftext="`del(path_expression)`"]
==== +del(path_expression)+
{TOC}

The builtin function `+del+` removes a key and its corresponding value
from an object.

####Examples

[[example25]]
[cols=",",]
|===
|Command |jq 'del(.foo)'

|Input |{"foo": 42, "bar": 9001, "baz": 42}

|Output |{"bar": 9001, "baz": 42}
|===


[cols=",",]
|===
|Command |jq 'del(.[1, 2])'

|Input |["foo", "bar", "baz"]

|Output |["foo"]
|===
link:https://jqplay.org/?q=del%28.%5B1%2C%202%5D%29&j=%5B%22foo%22%2C%20%22bar%22%2C%20%22baz%22%5D[{Run}]


[[getpath]]
[reftext="`getpath(PATHS)`"]
==== +getpath(PATHS)+
{TOC}

The builtin function `+getpath+` outputs the values in `+.+` found at
each path in `+PATHS+`.

####Examples

[[example26]]
[cols=",",]
|===
|Command |jq 'getpath(["a","b"])'

|Input |null

|Output |null
|===


[cols=",",]
|===
|Command |jq '[getpath(["a","b"], ["a","c"])]'

|Input |{"a":{"b":0, "c":1}}

|Output |[0, 1]
|===
link:https://jqplay.org/?q=%5Bgetpath%28%5B%22a%22%2C%22b%22%5D%2C%20%5B%22a%22%2C%22c%22%5D%29%5D&j=%7B%22a%22%3A%7B%22b%22%3A0%2C%20%22c%22%3A1%7D%7D[{Run}]


[[setpath]]
[reftext="`setpath(PATHS; VALUE)`"]
==== +setpath(PATHS; VALUE)+
{TOC}

The builtin function `+setpath+` sets the `+PATHS+` in `+.+` to
`+VALUE+`.

####Examples

[[example27]]
[cols=",",]
|===
|Command |jq 'setpath(["a","b"]; 1)'

|Input |null

|Output |{"a": {"b": 1}}
|===
link:https://jqplay.org/?q=setpath%28%5B%22a%22%2C%22b%22%5D%3B%201%29&j=null[{Run}]


[cols=",",]
|===
|Command |jq 'setpath(["a","b"]; 1)'

|Input |{"a":{"b":0}}

|Output |{"a": {"b": 1}}
|===
link:https://jqplay.org/?q=setpath%28%5B%22a%22%2C%22b%22%5D%3B%201%29&j=%7B%22a%22%3A%7B%22b%22%3A0%7D%7D[{Run}]


[cols=",",]
|===
|Command |jq 'setpath([0,"a"]; 1)'

|Input |null

|Output |[{"a":1}]
|===


[[delpaths]]
[reftext="`delpaths(PATHS)`"]
==== +delpaths(PATHS)+
{TOC}

The builtin function `+delpaths+` deletes the `+PATHS+` in `+.+`.
`+PATHS+` must be an array of paths, where each path is an array of
strings and numbers.

####Example

[[example28]]
[cols=",",]
|===
|Command |jq 'delpaths([["a","b"]])'

|Input |{"a":{"b":1},"x":{"y":2}}

|Output |{"a":{},"x":{"y":2}}
|===


[[to_entries-from_entries-with_entries]]
[reftext="`to_entries`, `from_entries`, `with_entries(f)`"]
==== +to_entries+, +from_entries+, +with_entries(f)+
{TOC}

These functions convert between an object and an array of key-value
pairs. If `+to_entries+` is passed an object, then for each `+k: v+`
entry in the input, the output array includes
`+{"key": k, "value": v}+`.

`+from_entries+` does the opposite conversion, and `+with_entries(f)+`
is a shorthand for `+to_entries | map(f) | from_entries+`, useful for
doing some operation to all keys and values of an object.
`+from_entries+` accepts `+"key"+`, `+"Key"+`, `+"name"+`, `+"Name"+`,
`+"value"+`, and `+"Value"+` as keys.

####Examples

[[example29]]
[cols=",",]
|===
|Command |jq 'to_entries'

|Input |{"a": 1, "b": 2}

|Output |[{"key":"a", "value":1}, {"key":"b", "value":2}]
|===
link:https://jqplay.org/?q=to_entries&j=%7B%22a%22%3A%201%2C%20%22b%22%3A%202%7D[{Run}]


[cols=",",]
|===
|Command |jq 'from_entries'

|Input |[{"key":"a", "value":1}, {"key":"b", "value":2}]

|Output |{"a": 1, "b": 2}
|===
link:https://jqplay.org/?q=from_entries&j=%5B%7B%22key%22%3A%22a%22%2C%20%22value%22%3A1%7D%2C%20%7B%22key%22%3A%22b%22%2C%20%22value%22%3A2%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'with_entries(.key \|= "KEY_" + .)'

|Input |{"a": 1, "b": 2}

|Output |{"KEY_a": 1, "KEY_b": 2}
|===
link:https://jqplay.org/?q=with_entries%28.key%20%7C%3D%20%22KEY_%22%20%2B%20.%29&j=%7B%22a%22%3A%201%2C%20%22b%22%3A%202%7D[{Run}]


[[select]]
[reftext="`select(boolean_expression)`"]
==== +select(boolean_expression)+
{TOC}

The function `+select(f)+` produces its input unchanged if `+f+` returns
true for that input, and produces no output otherwise.

It's useful for filtering lists: `+[1,2,3] | map(select(. >= 2))+` will
give you `+[2,3]+`.

####Examples

[[example30]]
[cols=",",]
|===
|Command |jq 'map(select(. >= 2))'

|Input |[1,5,3,0,7]

|Output |[5,3,7]
|===
link:https://jqplay.org/?q=map%28select%28.%20%3E%3D%202%29%29&j=%5B1%2C5%2C3%2C0%2C7%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[] \| select(.id == "second")'

|Input |[{"id": "first", "val": 1}, {"id": "second", "val": 2}]

|Output |{"id": "second", "val": 2}
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20select%28.id%20%3D%3D%20%22second%22%29&j=%5B%7B%22id%22%3A%20%22first%22%2C%20%22val%22%3A%201%7D%2C%20%7B%22id%22%3A%20%22second%22%2C%20%22val%22%3A%202%7D%5D[{Run}]


[[arrays-objects-iterables-booleans-numbers-normals-finites-strings-nulls-values-scalars]]
[reftext="`arrays`, `objects`, `iterables`, `booleans`, `numbers`, `normals`, `finites`, `strings`, `nulls`, `values`, `scalars`"]
==== +arrays+, +objects+, +iterables+, +booleans+, +numbers+, +normals+, +finites+, +strings+, +nulls+, +values+, +scalars+
{TOC}

These built-ins select only inputs that are arrays, objects, iterables
(arrays or objects), booleans, numbers, normal numbers, finite numbers,
strings, null, non-null values, and non-iterables, respectively.

####Example

[[example31]]
[cols=",",]
|===
|Command |jq '.[]\|numbers'

|Input |[[],{},1,"foo",null,true,false]

|Output |1
|===
link:https://jqplay.org/?q=.%5B%5D%7Cnumbers&j=%5B%5B%5D%2C%7B%7D%2C1%2C%22foo%22%2Cnull%2Ctrue%2Cfalse%5D[{Run}]


[[empty]]
[reftext="`empty`"]
==== +empty+
{TOC}

`+empty+` returns no results. None at all. Not even `+null+`.

It's useful on occasion. You'll know if you need it :)

####Examples

[[example32]]
[cols=",",]
|===
|Command |jq '1, empty, 2'

|Input |null

|Output |1

| |2
|===
link:https://jqplay.org/?q=1%2C%20empty%2C%202&j=null[{Run}]


[cols=",",]
|===
|Command |jq '[1,2,empty,3]'

|Input |null

|Output |[1,2,3]
|===
link:https://jqplay.org/?q=%5B1%2C2%2Cempty%2C3%5D&j=null[{Run}]


[[error]]
[reftext="`error`, `error(message)`"]
==== +error+, +error(message)+
{TOC}

Produces an error with the input value, or with the message given as the
argument. Errors can be caught with try/catch; see below.

####Examples

[[example33]]
[cols=",",]
|===
|Command |jq 'try error catch .'

|Input |"error message"

|Output |"error message"
|===


[cols=",",]
|===
|Command |jq 'try error("invalid value: \(.)") catch .'

|Input |42

|Output |"invalid value: 42"
|===
link:https://jqplay.org/?q=try%20error%28%22invalid%20value%3A%20%5C%28.%29%22%29%20catch%20.&j=42[{Run}]


[[halt]]
[reftext="`halt`"]
==== +halt+
{TOC}

Stops the jq program with no further outputs. jq will exit with exit
status `+0+`.

[[halt_error]]
[reftext="`halt_error`, `halt_error(exit_code)`"]
==== +halt_error+, +halt_error(exit_code)+
{TOC}

Stops the jq program with no further outputs. The input will be printed
on `+stderr+` as raw output (i.e., strings will not have double quotes)
with no decoration, not even a newline.

The given `+exit_code+` (defaulting to `+5+`) will be jq's exit status.

For example, `+"Error: something went wrong\n"|halt_error(1)+`.

[[dollar_loc]]
[reftext="`$__loc__`"]
==== +$__loc__+
{TOC}

Produces an object with a "file" key and a "line" key, with the filename
and line number where `+$__loc__+` occurs, as values.

####Example

[[example34]]
[cols=",",]
|===
|Command |jq 'try error("\($__loc__)") catch .'

|Input |null

|Output |"{\"file\":\"<top-level>\",\"line\":1}"
|===
link:https://jqplay.org/?q=try%20error%28%22%5C%28%24__loc__%29%22%29%20catch%20.&j=null[{Run}]


[[paths]]
[reftext="`paths`, `paths(node_filter)`"]
==== +paths+, +paths(node_filter)+
{TOC}

`+paths+` outputs the paths to all the elements in its input (except it
does not output the empty list, representing . itself).

`+paths(f)+` outputs the paths to any values for which `+f+` is
`+true+`. That is, `+paths(type == "number")+` outputs the paths to all
numeric values.

####Examples

[[example35]]
[cols=",",]
|===
|Command |jq '[paths]'

|Input |[1,[[],{"a":2}]]

|Output |[[0],[1],[1,0],[1,1],[1,1,"a"]]
|===
link:https://jqplay.org/?q=%5Bpaths%5D&j=%5B1%2C%5B%5B%5D%2C%7B%22a%22%3A2%7D%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq '[paths(type == "number")]'

|Input |[1,[[],{"a":2}]]

|Output |[[0],[1,1,"a"]]
|===
link:https://jqplay.org/?q=%5Bpaths%28type%20%3D%3D%20%22number%22%29%5D&j=%5B1%2C%5B%5B%5D%2C%7B%22a%22%3A2%7D%5D%5D[{Run}]


[[add]]
[reftext="`add`"]
==== +add+
{TOC}

The filter `+add+` takes as input an array, and produces as output the
elements of the array added together. This might mean summed,
concatenated or merged depending on the types of the elements of the
input array - the rules are the same as those for the `+++` operator
(described above).

If the input is an empty array, `+add+` returns `+null+`.

####Examples

[[example36]]
[cols=",",]
|===
|Command |jq 'add'

|Input |["a","b","c"]

|Output |"abc"
|===


[cols=",",]
|===
|Command |jq 'add'

|Input |[1, 2, 3]

|Output |6
|===
link:https://jqplay.org/?q=add&j=%5B1%2C%202%2C%203%5D[{Run}]


[cols=",",]
|===
|Command |jq 'add'

|Input |[]

|Output |null
|===
link:https://jqplay.org/?q=add&j=%5B%5D[{Run}]


[[any]]
[reftext="`any`, `any(condition)`, `any(generator; condition)`"]
==== +any+, +any(condition)+, +any(generator; condition)+
{TOC}

The filter `+any+` takes as input an array of boolean values, and
produces `+true+` as output if any of the elements of the array are
`+true+`.

If the input is an empty array, `+any+` returns `+false+`.

The `+any(condition)+` form applies the given condition to the elements
of the input array.

The `+any(generator; condition)+` form applies the given condition to
all the outputs of the given generator.

####Examples

[[example37]]
[cols=",",]
|===
|Command |jq 'any'

|Input |[true, false]

|Output |true
|===
link:https://jqplay.org/?q=any&j=%5Btrue%2C%20false%5D[{Run}]


[cols=",",]
|===
|Command |jq 'any'

|Input |[false, false]

|Output |false
|===
link:https://jqplay.org/?q=any&j=%5Bfalse%2C%20false%5D[{Run}]


[cols=",",]
|===
|Command |jq 'any'

|Input |[]

|Output |false
|===
link:https://jqplay.org/?q=any&j=%5B%5D[{Run}]


[[all]]
[reftext="`all`, `all(condition)`, `all(generator; condition)`"]
==== +all+, +all(condition)+, +all(generator; condition)+
{TOC}

The filter `+all+` takes as input an array of boolean values, and
produces `+true+` as output if all of the elements of the array are
`+true+`.

The `+all(condition)+` form applies the given condition to the elements
of the input array.

The `+all(generator; condition)+` form applies the given condition to
all the outputs of the given generator.

If the input is an empty array, `+all+` returns `+true+`.

####Examples

[[example38]]
[cols=",",]
|===
|Command |jq 'all'

|Input |[true, false]

|Output |false
|===
link:https://jqplay.org/?q=all&j=%5Btrue%2C%20false%5D[{Run}]


[cols=",",]
|===
|Command |jq 'all'

|Input |[true, true]

|Output |true
|===
link:https://jqplay.org/?q=all&j=%5Btrue%2C%20true%5D[{Run}]


[cols=",",]
|===
|Command |jq 'all'

|Input |[]

|Output |true
|===
link:https://jqplay.org/?q=all&j=%5B%5D[{Run}]


[[flatten]]
[reftext="`flatten`, `flatten(depth)`"]
==== +flatten+, +flatten(depth)+
{TOC}

The filter `+flatten+` takes as input an array of nested arrays, and
produces a flat array in which all arrays inside the original array have
been recursively replaced by their values. You can pass an argument to
it to specify how many levels of nesting to flatten.

`+flatten(2)+` is like `+flatten+`, but going only up to two levels
deep.

####Examples

[[example39]]
[cols=",",]
|===
|Command |jq 'flatten'

|Input |[1, [2], [[3]]]

|Output |[1, 2, 3]
|===
link:https://jqplay.org/?q=flatten&j=%5B1%2C%20%5B2%5D%2C%20%5B%5B3%5D%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'flatten(1)'

|Input |[1, [2], [[3]]]

|Output |[1, 2, [3]]
|===
link:https://jqplay.org/?q=flatten%281%29&j=%5B1%2C%20%5B2%5D%2C%20%5B%5B3%5D%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'flatten'

|Input |[[]]

|Output |[]
|===
link:https://jqplay.org/?q=flatten&j=%5B%5B%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'flatten'

|Input |[{"foo": "bar"}, [{"foo": "baz"}]]

|Output |[{"foo": "bar"}, {"foo": "baz"}]
|===
link:https://jqplay.org/?q=flatten&j=%5B%7B%22foo%22%3A%20%22bar%22%7D%2C%20%5B%7B%22foo%22%3A%20%22baz%22%7D%5D%5D[{Run}]


[[range]]
[reftext="`range(upto)`, `range(from; upto)`, `range(from; upto; by)`"]
==== +range(upto)+, +range(from; upto)+, +range(from; upto; by)+
{TOC}

The `+range+` function produces a range of numbers. `+range(4; 10)+`
produces 6 numbers, from 4 (inclusive) to 10 (exclusive). The numbers
are produced as separate outputs. Use `+[range(4; 10)]+` to get a range
as an array.

The one argument form generates numbers from 0 to the given number, with
an increment of 1.

The two argument form generates numbers from `+from+` to `+upto+` with
an increment of 1.

The three argument form generates numbers `+from+` to `+upto+` with an
increment of `+by+`.

####Examples

[[example40]]
[cols=",",]
|===
|Command |jq 'range(2; 4)'

|Input |null

|Output |2

| |3
|===
link:https://jqplay.org/?q=range%282%3B%204%29&j=null[{Run}]


[cols=",",]
|===
|Command |jq '[range(2; 4)]'

|Input |null

|Output |[2,3]
|===
link:https://jqplay.org/?q=%5Brange%282%3B%204%29%5D&j=null[{Run}]


[cols=",",]
|===
|Command |jq '[range(4)]'

|Input |null

|Output |[0,1,2,3]
|===
link:https://jqplay.org/?q=%5Brange%284%29%5D&j=null[{Run}]


[cols=",",]
|===
|Command |jq '[range(0; 10; 3)]'

|Input |null

|Output |[0,3,6,9]
|===


[cols=",",]
|===
|Command |jq '[range(0; 10; -1)]'

|Input |null

|Output |[]
|===


[cols=",",]
|===
|Command |jq '[range(0; -5; -1)]'

|Input |null

|Output |[0,-1,-2,-3,-4]
|===


[[floor]]
[reftext="`floor`"]
==== +floor+
{TOC}

The `+floor+` function returns the floor of its numeric input.

####Example

[[example41]]
[cols=",",]
|===
|Command |jq 'floor'

|Input |3.14159

|Output |3
|===
link:https://jqplay.org/?q=floor&j=3.14159[{Run}]


[[sqrt]]
[reftext="`sqrt`"]
==== +sqrt+
{TOC}

The `+sqrt+` function returns the square root of its numeric input.

####Example

[[example42]]
[cols=",",]
|===
|Command |jq 'sqrt'

|Input |9

|Output |3
|===
link:https://jqplay.org/?q=sqrt&j=9[{Run}]


[[tonumber]]
[reftext="`tonumber`"]
==== +tonumber+
{TOC}

The `+tonumber+` function parses its input as a number. It will convert
correctly-formatted strings to their numeric equivalent, leave numbers
alone, and give an error on all other input.

####Example

[[example43]]
[cols=",",]
|===
|Command |jq '.[] \| tonumber'

|Input |[1, "1"]

|Output |1

| |1
|===


[[tostring]]
[reftext="`tostring`"]
==== +tostring+
{TOC}

The `+tostring+` function prints its input as a string. Strings are left
unchanged, and all other values are JSON-encoded.

####Example

[[example44]]
[cols=",",]
|===
|Command |jq '.[] \| tostring'

|Input |[1, "1", [1]]

|Output |"1"

| |"1"

| |"[1]"
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20tostring&j=%5B1%2C%20%221%22%2C%20%5B1%5D%5D[{Run}]


[[type]]
[reftext="`type`"]
==== +type+
{TOC}

The `+type+` function returns the type of its argument as a string,
which is one of null, boolean, number, string, array or object.

####Example

[[example45]]
[cols=",",]
|===
|Command |jq 'map(type)'

|Input   |[0, false, [], {}, null, "hello"]

|Output  |["number", "boolean", "array", "object", "null", "string"]
|===


[[infinite-nan-isinfinite-isnan-isfinite-isnormal]]
[reftext="`infinite`, `nan`, `isinfinite`, `isnan`, `isfinite`, `isnormal`"]
==== +infinite+, +nan+, +isinfinite+, +isnan+, +isfinite+, +isnormal+
{TOC}

Some arithmetic operations can yield infinities and "not a number" (NaN)
values. The `+isinfinite+` builtin returns `+true+` if its input is
infinite. The `+isnan+` builtin returns `+true+` if its input is a NaN.
The `+infinite+` builtin returns a positive infinite value. The `+nan+`
builtin returns a NaN. The `+isnormal+` builtin returns true if its
input is a normal number.

Note that division by zero raises an error.

Currently most arithmetic operations operating on infinities, NaNs, and
sub-normals do not raise errors.

####Examples

[[example46]]
[cols=",",]
|===
|Command |jq '.[] \| (infinite * .) < 0'

|Input |[-1, 1]

|Output |true

| |false
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20%28infinite%20%2A%20.%29%20%3C%200&j=%5B-1%2C%201%5D[{Run}]


[cols=",",]
|===
|Command |jq 'infinite, nan \| type'

|Input |null

|Output |"number"

| |"number"
|===


[[sort-sort_by]]
[reftext="`sort`, `sort_by(path_expression)`"]
==== +sort+, +sort_by(path_expression)+
{TOC}

The `+sort+` functions sorts its input, which must be an array. Values
are sorted in the following order:

* `+null+`
* `+false+`
* `+true+`
* numbers
* strings, in alphabetical order (by unicode codepoint value)
* arrays, in lexical order
* objects

The ordering for objects is a little complex: first they're compared by
comparing their sets of keys (as arrays in sorted order), and if their
keys are equal then the values are compared key by key.

`+sort_by+` may be used to sort by a particular field of an object, or
by applying any jq filter. `+sort_by(f)+` compares two elements by
comparing the result of `+f+` on each element. When `+f+` produces
multiple values, it firstly compares the first values, and the second
values if the first values are equal, and so on.

####Examples

[[example47]]
[cols=",",]
|===
|Command |jq 'sort'

|Input |[8,3,null,6]

|Output |[null,3,6,8]
|===
link:https://jqplay.org/?q=sort&j=%5B8%2C3%2Cnull%2C6%5D[{Run}]


[cols=",",]
|===
|Command |jq 'sort_by(.foo)'

|Input |[{"foo":4, "bar":10}, {"foo":3, "bar":10}, {"foo":2,
"bar":1}]

|Output |[{"foo":2, "bar":1}, {"foo":3, "bar":10}, {"foo":4,
"bar":10}]
|===
link:https://jqplay.org/?q=sort_by%28.foo%29&j=%5B%7B%22foo%22%3A4%2C%20%22bar%22%3A10%7D%2C%20%7B%22foo%22%3A3%2C%20%22bar%22%3A10%7D%2C%20%7B%22foo%22%3A2%2C%20%22bar%22%3A1%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'sort_by(.foo, .bar)'

|Input   |[{"foo":4, "bar":10}, {"foo":3, "bar":20}, {"foo":2,
          "bar":1}, {"foo":3, "bar":10}]

|Output  |[{"foo":2, "bar":1}, {"foo":3, "bar":10}, {"foo":3,
          "bar":20}, \{"foo":4, "bar":10}]
|===
link:https://jqplay.org/?q=sort_by%28.foo%2C%20.bar%29&j=%5B%7B%22foo%22%3A4%2C%20%22bar%22%3A10%7D%2C%20%7B%22foo%22%3A3%2C%20%22bar%22%3A20%7D%2C%20%7B%22foo%22%3A2%2C%20%22bar%22%3A1%7D%2C%20%7B%22foo%22%3A3%2C%20%22bar%22%3A10%7D%5D[{Run}]


[[group_by]]
[reftext="`group_by(path_expression)`"]
==== +group_by(path_expression)+
{TOC}

`+group_by(.foo)+` takes as input an array, groups the elements having
the same `+.foo+` field into separate arrays, and produces all of these
arrays as elements of a larger array, sorted by the value of the
`+.foo+` field.

Any jq expression, not just a field access, may be used in place of
`+.foo+`. The sorting order is the same as described in the `+sort+`
function above.

####Example

[[example48]]
[cols=",",]
|===
|Command |jq 'group_by(.foo)'

|Input |[{"foo":1, "bar":10}, {"foo":3, "bar":100}, {"foo":1, "bar":1}]

|Output |[[{"foo":1, "bar":10}, {"foo":1, "bar":1}], [{"foo":3, "bar":100}]]
|===
link:https://jqplay.org/?q=group_by%28.foo%29&j=%5B%7B%22foo%22%3A1%2C%20%22bar%22%3A10%7D%2C%20%7B%22foo%22%3A3%2C%20%22bar%22%3A100%7D%2C%20%7B%22foo%22%3A1%2C%20%22bar%22%3A1%7D%5D[{Run}]


[[min-max-min_by-max_by]]
[reftext="`min`, `max`, `min_by(path_exp)`, `max_by(path_exp)`"]
==== +min+, +max+, +min_by(path_exp)+, +max_by(path_exp)+
{TOC}

Find the minimum or maximum element of the input array.

The `+min_by(path_exp)+` and `+max_by(path_exp)+` functions allow you to
specify a particular field or property to examine, e.g. `+min_by(.foo)+`
finds the object with the smallest `+foo+` field.

####Examples

[[example49]]
[cols=",",]
|===
|Command |jq 'min'

|Input |[5,4,2,7]

|Output |2
|===
link:https://jqplay.org/?q=min&j=%5B5%2C4%2C2%2C7%5D[{Run}]


[cols=",",]
|===
|Command |jq 'max_by(.foo)'

|Input |[{"foo":1, "bar":14}, {"foo":2, "bar":3}]

|Output |{"foo":2, "bar":3}
|===
link:https://jqplay.org/?q=max_by%28.foo%29&j=%5B%7B%22foo%22%3A1%2C%20%22bar%22%3A14%7D%2C%20%7B%22foo%22%3A2%2C%20%22bar%22%3A3%7D%5D[{Run}]


[[unique-unique_by]]
[reftext="`unique`, `unique_by(path_exp)`"]
==== +unique+, +unique_by(path_exp)+
{TOC}

The `+unique+` function takes as input an array and produces an array of
the same elements, in sorted order, with duplicates removed.

The `+unique_by(path_exp)+` function will keep only one element for each
value obtained by applying the argument. Think of it as making an array
by taking one element out of every group produced by `+group+`.

####Examples

[[example50]]
[cols=",",]
|===
|Command |jq 'unique'

|Input |[1,2,5,3,5,3,1,3]

|Output |[1,2,3,5]
|===


[cols=",",]
|===
|Command |jq 'unique_by(.foo)'

|Input |[{"foo": 1, "bar": 2}, {"foo": 1, "bar": 3}, {"foo": 4,
"bar": 5}]

|Output |[{"foo": 1, "bar": 2}, {"foo": 4, "bar": 5}]
|===


[cols=",",]
|===
|Command |jq 'unique_by(length)'

|Input |["chunky", "bacon", "kitten", "cicada", "asparagus"]

|Output |["bacon", "chunky", "asparagus"]
|===
link:https://jqplay.org/?q=unique_by%28length%29&j=%5B%22chunky%22%2C%20%22bacon%22%2C%20%22kitten%22%2C%20%22cicada%22%2C%20%22asparagus%22%5D[{Run}]


[[reverse]]
[reftext="`reverse`"]
==== +reverse+
{TOC}

This function reverses an array.

####Example

[[example51]]
[cols=",",]
|===
|Command |jq 'reverse'

|Input |[1,2,3,4]

|Output |[4,3,2,1]
|===
link:https://jqplay.org/?q=reverse&j=%5B1%2C2%2C3%2C4%5D[{Run}]


[[contains]]
[reftext="`contains(element)`"]
==== +contains(element)+
{TOC}

The filter `+contains(b)+` will produce true if b is completely
contained within the input. A string B is contained in a string A if B
is a substring of A. An array B is contained in an array A if all
elements in B are contained in any element in A. An object B is
contained in object A if all of the values in B are contained in the
value in A with the same key. All other types are assumed to be
contained in each other if they are equal.

####Examples

[[example52]]
[cols=",",]
|===
|Command |jq 'contains("bar")'

|Input |"foobar"

|Output |true
|===


[cols=",",]
|===
|Command |jq 'contains(["baz", "bar"])'

|Input |["foobar", "foobaz", "blarp"]

|Output |true
|===
link:https://jqplay.org/?q=contains%28%5B%22baz%22%2C%20%22bar%22%5D%29&j=%5B%22foobar%22%2C%20%22foobaz%22%2C%20%22blarp%22%5D[{Run}]


[cols=",",]
|===
|Command |jq 'contains(["bazzzzz", "bar"])'

|Input |["foobar", "foobaz", "blarp"]

|Output |false
|===
link:https://jqplay.org/?q=contains%28%5B%22bazzzzz%22%2C%20%22bar%22%5D%29&j=%5B%22foobar%22%2C%20%22foobaz%22%2C%20%22blarp%22%5D[{Run}]


[cols=",",]
|===
|Command |jq 'contains({foo: 12, bar: [{barp: 12}]})'

|Input |{"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]}

|Output |true
|===
link:https://jqplay.org/?q=contains%28%7Bfoo%3A%2012%2C%20bar%3A%20%5B%7Bbarp%3A%2012%7D%5D%7D%29&j=%7B%22foo%22%3A%2012%2C%20%22bar%22%3A%5B1%2C2%2C%7B%22barp%22%3A12%2C%20%22blip%22%3A13%7D%5D%7D[{Run}]


[cols=",",]
|===
|Command |jq 'contains({foo: 12, bar: [{barp: 15}]})'

|Input |{"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]}

|Output |false
|===
link:https://jqplay.org/?q=contains%28%7Bfoo%3A%2012%2C%20bar%3A%20%5B%7Bbarp%3A%2015%7D%5D%7D%29&j=%7B%22foo%22%3A%2012%2C%20%22bar%22%3A%5B1%2C2%2C%7B%22barp%22%3A12%2C%20%22blip%22%3A13%7D%5D%7D[{Run}]


[[indices]]
[reftext="`indices(s)`"]
==== +indices(s)+
{TOC}

Outputs an array containing the indices in `+.+` where `+s+` occurs. The
input may be an array, in which case if `+s+` is an array then the
indices output will be those where all elements in `+.+` match those of
`+s+`.

####Examples

[[example53]]
[cols=",",]
|===
|Command |jq 'indices(", ")'

|Input |"a,b, cd, efg, hijk"

|Output |[3,7,12]
|===
link:https://jqplay.org/?q=indices%28%22%2C%20%22%29&j=%22a%2Cb%2C%20cd%2C%20efg%2C%20hijk%22[{Run}]


[cols=",",]
|===
|Command |jq 'indices(1)'

|Input |[0,1,2,1,3,1,4]

|Output |[1,3,5]
|===


[cols=",",]
|===
|Command |jq 'indices([1,2])'

|Input |[0,1,2,3,1,4,2,5,1,2,6,7]

|Output |[1,8]
|===
link:https://jqplay.org/?q=indices%28%5B1%2C2%5D%29&j=%5B0%2C1%2C2%2C3%2C1%2C4%2C2%2C5%2C1%2C2%2C6%2C7%5D[{Run}]


[[index-rindex]]
[reftext="`index(s)`, `rindex(s)`"]
==== +index(s)+, +rindex(s)+
{TOC}

Outputs the index of the first (`+index+`) or last (`+rindex+`)
occurrence of `+s+` in the input.

####Examples

[[example54]]
[cols=",",]
|===
|Command |jq 'index(", ")'

|Input |"a,b, cd, efg, hijk"

|Output |3
|===
link:https://jqplay.org/?q=index%28%22%2C%20%22%29&j=%22a%2Cb%2C%20cd%2C%20efg%2C%20hijk%22[{Run}]


[cols=",",]
|===
|Command |jq 'index(1)'

|Input |[0,1,2,1,3,1,4]

|Output |1
|===


[cols=",",]
|===
|Command |jq 'index([1,2])'

|Input |[0,1,2,3,1,4,2,5,1,2,6,7]

|Output |1
|===
link:https://jqplay.org/?q=index%28%5B1%2C2%5D%29&j=%5B0%2C1%2C2%2C3%2C1%2C4%2C2%2C5%2C1%2C2%2C6%2C7%5D[{Run}]


[cols=",",]
|===
|Command |jq 'rindex(", ")'

|Input |"a,b, cd, efg, hijk"

|Output |12
|===
link:https://jqplay.org/?q=rindex%28%22%2C%20%22%29&j=%22a%2Cb%2C%20cd%2C%20efg%2C%20hijk%22[{Run}]


[cols=",",]
|===
|Command |jq 'rindex(1)'

|Input |[0,1,2,1,3,1,4]

|Output |5
|===


[cols=",",]
|===
|Command |jq 'rindex([1,2])'

|Input |[0,1,2,3,1,4,2,5,1,2,6,7]

|Output |8
|===
link:https://jqplay.org/?q=rindex%28%5B1%2C2%5D%29&j=%5B0%2C1%2C2%2C3%2C1%2C4%2C2%2C5%2C1%2C2%2C6%2C7%5D[{Run}]


[[inside]]
[reftext="`inside`"]
==== +inside+
{TOC}

The filter `+inside(b)+` will produce true if the input is completely
contained within b. It is, essentially, an inversed version of
`+contains+`.

####Examples

[[example55]]
[cols=",",]
|===
|Command |jq 'inside("foobar")'

|Input |"bar"

|Output |true
|===
link:https://jqplay.org/?q=inside%28%22foobar%22%29&j=%22bar%22[{Run}]


[cols=",",]
|===
|Command |jq 'inside(["foobar", "foobaz", "blarp"])'

|Input |["baz", "bar"]

|Output |true
|===
link:https://jqplay.org/?q=inside%28%5B%22foobar%22%2C%20%22foobaz%22%2C%20%22blarp%22%5D%29&j=%5B%22baz%22%2C%20%22bar%22%5D[{Run}]


[cols=",",]
|===
|Command |jq 'inside(["foobar", "foobaz", "blarp"])'

|Input |["bazzzzz", "bar"]

|Output |false
|===
link:https://jqplay.org/?q=inside%28%5B%22foobar%22%2C%20%22foobaz%22%2C%20%22blarp%22%5D%29&j=%5B%22bazzzzz%22%2C%20%22bar%22%5D[{Run}]


[cols=",",]
|===
|Command |jq 'inside({"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]})'

|Input |{"foo": 12, "bar": [{"barp": 12}]}

|Output |true
|===
link:https://jqplay.org/?q=inside%28%7B%22foo%22%3A%2012%2C%20%22bar%22%3A%5B1%2C2%2C%7B%22barp%22%3A12%2C%20%22blip%22%3A13%7D%5D%7D%29&j=%7B%22foo%22%3A%2012%2C%20%22bar%22%3A%20%5B%7B%22barp%22%3A%2012%7D%5D%7D[{Run}]


[cols=",",]
|===
|Command |jq 'inside({"foo": 12, "bar":[1,2,{"barp":12, "blip":13}]})'

|Input |{"foo": 12, "bar": [{"barp": 15}]}

|Output |false
|===
link:https://jqplay.org/?q=inside%28%7B%22foo%22%3A%2012%2C%20%22bar%22%3A%5B1%2C2%2C%7B%22barp%22%3A12%2C%20%22blip%22%3A13%7D%5D%7D%29&j=%7B%22foo%22%3A%2012%2C%20%22bar%22%3A%20%5B%7B%22barp%22%3A%2015%7D%5D%7D[{Run}]


[[startswith]]
[reftext="`startswith(str)`"]
==== +startswith(str)+
{TOC}

Outputs `+true+` if . starts with the given string argument.

####Example

[[example56]]
[cols=",",]
|===
|Command |jq '[.[]\|startswith("foo")]'

|Input |["fo", "foo", "barfoo", "foobar", "barfoob"]

|Output |[false, true, false, true, false]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Cstartswith%28%22foo%22%29%5D&j=%5B%22fo%22%2C%20%22foo%22%2C%20%22barfoo%22%2C%20%22foobar%22%2C%20%22barfoob%22%5D[{Run}]


[[endswith]]
[reftext="`endswith(str)`"]
==== +endswith(str)+
{TOC}

Outputs `+true+` if . ends with the given string argument.

####Example

[[example57]]
[cols=",",]
|===
|Command |jq '[.[]\|endswith("foo")]'

|Input |["foobar", "barfoo"]

|Output |[false, true]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Cendswith%28%22foo%22%29%5D&j=%5B%22foobar%22%2C%20%22barfoo%22%5D[{Run}]


[[combinations]]
[reftext="`combinations`, `combinations(n)`"]
==== +combinations+, +combinations(n)+
{TOC}

Outputs all combinations of the elements of the arrays in the input
array. If given an argument `+n+`, it outputs all combinations of `+n+`
repetitions of the input array.

####Examples

[[example58]]
[cols=",",]
|===
|Command |jq 'combinations'

|Input |[[1,2], [3, 4]]

|Output |[1, 3]

| |[1, 4]

| |[2, 3]

| |[2, 4]
|===
link:https://jqplay.org/?q=combinations&j=%5B%5B1%2C2%5D%2C%20%5B3%2C%204%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'combinations(2)'

|Input |[0, 1]

|Output |[0, 0]

| |[0, 1]

| |[1, 0]

| |[1, 1]
|===
link:https://jqplay.org/?q=combinations%282%29&j=%5B0%2C%201%5D[{Run}]


[[ltrimstr]]
[reftext="`ltrimstr(str)`"]
==== +ltrimstr(str)+
{TOC}

Outputs its input with the given prefix string removed, if it starts
with it.

####Example

[[example59]]
[cols=",",]
|===
|Command |jq '[.[]\|ltrimstr("foo")]'

|Input |["fo", "foo", "barfoo", "foobar", "afoo"]

|Output |["fo","","barfoo","bar","afoo"]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Cltrimstr%28%22foo%22%29%5D&j=%5B%22fo%22%2C%20%22foo%22%2C%20%22barfoo%22%2C%20%22foobar%22%2C%20%22afoo%22%5D[{Run}]


[[rtrimstr]]
[reftext="`rtrimstr(str)`"]
==== +rtrimstr(str)+
{TOC}

Outputs its input with the given suffix string removed, if it ends with
it.

####Example

[[example60]]
[cols=",",]
|===
|Command |jq '[.[]\|rtrimstr("foo")]'

|Input |["fo", "foo", "barfoo", "foobar", "foob"]

|Output |["fo","","bar","foobar","foob"]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Crtrimstr%28%22foo%22%29%5D&j=%5B%22fo%22%2C%20%22foo%22%2C%20%22barfoo%22%2C%20%22foobar%22%2C%20%22foob%22%5D[{Run}]


[[explode]]
[reftext="`explode`"]
==== +explode+
{TOC}

Converts an input string into an array of the string's codepoint
numbers.

####Example

[[example61]]
[cols=",",]
|===
|Command |jq 'explode'

|Input |"foobar"

|Output |[102,111,111,98,97,114]
|===
link:https://jqplay.org/?q=explode&j=%22foobar%22[{Run}]


[[implode]]
[reftext="`implode`"]
==== +implode+
{TOC}

The inverse of explode.

####Example

[[example62]]
[cols=",",]
|===
|Command |jq 'implode'

|Input |[65, 66, 67]

|Output |"ABC"
|===
link:https://jqplay.org/?q=implode&j=%5B65%2C%2066%2C%2067%5D[{Run}]


[[split-1]]
[reftext="`split(str)`"]
==== +split(str)+
{TOC}

Splits an input string on the separator argument.

`+split+` can also split on regex matches when called with two arguments
(see the regular expressions section below).

####Example

[[example63]]
[cols=",",]
|===
|Command |jq 'split(", ")'

|Input |"a, b,c,d, e, "

|Output |["a","b,c,d","e",""]
|===
link:https://jqplay.org/?q=split%28%22%2C%20%22%29&j=%22a%2C%20b%2Cc%2Cd%2C%20e%2C%20%22[{Run}]


[[join]]
[reftext="`join(str)`"]
==== +join(str)+
{TOC}

Joins the array of elements given as input, using the argument as
separator. It is the inverse of `+split+`: that is, running
`+split("foo") | join("foo")+` over any input string returns said input
string.

Numbers and booleans in the input are converted to strings. Null values
are treated as empty strings. Arrays and objects in the input are not
supported.

####Examples

[[example64]]
[cols=",",]
|===
|Command |jq 'join(", ")'

|Input |["a","b,c,d","e"]

|Output |"a, b,c,d, e"
|===
link:https://jqplay.org/?q=join%28%22%2C%20%22%29&j=%5B%22a%22%2C%22b%2Cc%2Cd%22%2C%22e%22%5D[{Run}]


[cols=",",]
|===
|Command |jq 'join(" ")'

|Input |["a",1,2.3,true,null,false]

|Output |"a 1 2.3 true false"
|===
link:https://jqplay.org/?q=join%28%22%20%22%29&j=%5B%22a%22%2C1%2C2.3%2Ctrue%2Cnull%2Cfalse%5D[{Run}]


[[ascii_downcase-ascii_upcase]]
[reftext="`ascii_downcase`, `ascii_upcase`"]
==== +ascii_downcase+, +ascii_upcase+
{TOC}

Emit a copy of the input string with its alphabetic characters (a-z and
A-Z) converted to the specified case.

####Example

[[example65]]
[cols=",",]
|===
|Command |jq 'ascii_upcase'

|Input |"useful but not for 茅"

|Output |"USEFUL BUT NOT FOR 茅"
|===
link:https://jqplay.org/?q=ascii_upcase&j=%22useful%20but%20not%20for%20%C3%A9%22[{Run}]


[[while]]
[reftext="`while(cond; update)`"]
==== +while(cond; update)+
{TOC}

The `+while(cond; update)+` function allows you to repeatedly apply an
update to `+.+` until `+cond+` is false.

Note that `+while(cond; update)+` is internally defined as a recursive
jq function. Recursive calls within `+while+` will not consume
additional memory if `+update+` produces at most one output for each
input. See advanced topics below.

####Example

[[example66]]
[cols=",",]
|===
|Command |jq '[while(.<100; .*2)]'

|Input |1

|Output |[1,2,4,8,16,32,64]
|===


[[repeat]]
[reftext="`repeat(exp)`"]
==== +repeat(exp)+
{TOC}

The `+repeat(exp)+` function allows you to repeatedly apply expression
`+exp+` to `+.+` until an error is raised.

Note that `+repeat(exp)+` is internally defined as a recursive jq
function. Recursive calls within `+repeat+` will not consume additional
memory if `+exp+` produces at most one output for each input. See
advanced topics below.

####Example

[[example67]]
[cols=",",]
|===
|Command |jq '[repeat(.*2, error)?]'

|Input |1

|Output |[2]
|===


[[until]]
[reftext="`until(cond; next)`"]
==== +until(cond; next)+
{TOC}

The `+until(cond; next)+` function allows you to repeatedly apply the
expression `+next+`, initially to `+.+` then to its own output, until
`+cond+` is true. For example, this can be used to implement a factorial
function (see below).

Note that `+until(cond; next)+` is internally defined as a recursive jq
function. Recursive calls within `+until()+` will not consume additional
memory if `+next+` produces at most one output for each input. See
advanced topics below.

####Example

[[example68]]
[cols=",",]
|===
|Command |jq '[.,1]\|until(.[0] < 1; [.[0] - 1, .[1] * .[0]])\|.[1]'

|Input |4

|Output |24
|===


[[recurse]]
[reftext="`recurse(f)`, `recurse`, `recurse(f; condition)`"]
==== +recurse(f)+, +recurse+, +recurse(f; condition)+
{TOC}

The `+recurse(f)+` function allows you to search through a recursive
structure, and extract interesting data from all levels. Suppose your
input represents a filesystem:

....
{"name": "/", "children": [
  {"name": "/bin", "children": [
    {"name": "/bin/ls", "children": []},
    {"name": "/bin/sh", "children": []}]},
  {"name": "/home", "children": [
    {"name": "/home/stephen", "children": [
      {"name": "/home/stephen/jq", "children": []}]}]}]}
....

Now suppose you want to extract all of the filenames present. You need
to retrieve `+.name+`, `+.children[].name+`,
`+.children[].children[].name+`, and so on. You can do this with:

....
recurse(.children[]) | .name
....

When called without an argument, `+recurse+` is equivalent to
`+recurse(.[]?)+`.

`+recurse(f)+` is identical to `+recurse(f; true)+` and can be used
without concerns about recursion depth.

`+recurse(f; condition)+` is a generator which begins by emitting . and
then emits in turn .|f, .|f|f, .|f|f|f, ... so long as the computed
value satisfies the condition. For example, to generate all the
integers, at least in principle, one could write `+recurse(.+1; true)+`.

The recursive calls in `+recurse+` will not consume additional memory
whenever `+f+` produces at most a single output for each input.

####Examples

[[example69]]
[cols=",",]
|===
|Command |jq 'recurse(.foo[])'

|Input |{"foo":[{"foo": []}, {"foo":[{"foo":[]}]}]}

|Output |{"foo":[{"foo":[]},{"foo":[{"foo":[]}]}]} +
         {"foo":[]} +
         {"foo":[{"foo":[]}]} +
         {"foo":[]}
|===
link:https://jqplay.org/?q=recurse%28.foo%5B%5D%29&j=%7B%22foo%22%3A%5B%7B%22foo%22%3A%20%5B%5D%7D%2C%20%7B%22foo%22%3A%5B%7B%22foo%22%3A%5B%5D%7D%5D%7D%5D%7D[{Run}]


[cols=",",]
|===
|Command |jq 'recurse'

|Input  |{"a":0,"b":[1]}

|Output |{"a":0,"b":[1]} +
         0               +
         [1]             +
         1
|===


[cols=",",]
|===
|Command |jq 'recurse(. * .; . < 20)'

|Input  |2

|Output |2              +
         4              +
         16
|===


[[walk]]
[reftext="`walk(f)`"]
==== +walk(f)+
{TOC}

The `+walk(f)+` function applies f recursively to every component of the
input entity. When an array is encountered, f is first applied to its
elements and then to the array itself; when an object is encountered, f
is first applied to all the values and then to the object. In practice,
f will usually test the type of its input, as illustrated in the
following examples. The first example highlights the usefulness of
processing the elements of an array of arrays before processing the
array itself. The second example shows how all the keys of all the
objects within the input can be considered for alteration.

####Examples

[[example70]]
[cols=",",]
|===
|Command |jq 'walk(if type == "array" then sort else . end)'

|Input |[[4, 1, 7], [8, 5, 2], [3, 6, 9]]

|Output |[[1,4,7],[2,5,8],[3,6,9]]
|===
link:https://jqplay.org/?q=walk%28if%20type%20%3D%3D%20%22array%22%20then%20sort%20else%20.%20end%29&j=%5B%5B4%2C%201%2C%207%5D%2C%20%5B8%2C%205%2C%202%5D%2C%20%5B3%2C%206%2C%209%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'walk( if type == "object" then with_entries( .key \|= sub(
"^_+"; "") ) else . end )'

|Input |[ { "_a": { "__b": 2 } } ]

|Output |[{"a":{"b":2}}]
|===


[[dollar_jq_build_configuration]]
[reftext="`$JQ_BUILD_CONFIGURATION`"]
==== +$JQ_BUILD_CONFIGURATION+
{TOC}

This builtin binding shows the jq executable's build configuration. Its
value has no particular format, but it can be expected to be at least
the `+./configure+` command-line arguments, and may be enriched in the
future to include the version strings for the build tooling used.

Note that this can be overridden in the command-line with `+--arg+` and
related options.

[[dollar_env-env]]
[reftext="`$ENV`, `env`"]
==== +$ENV+, +env+
{TOC}

`+$ENV+` is an object representing the environment variables as set when
the jq program started.

`+env+` outputs an object representing jq's current environment.

At the moment there is no builtin for setting environment variables.

####Examples

[[example71]]
[cols=",",]
|===
|Command |jq '$ENV.PAGER'

|Input |null

|Output |"less"
|===
link:https://jqplay.org/?q=%24ENV.PAGER&j=null[{Run}]


[cols=",",]
|===
|Command |jq 'env.PAGER'

|Input |null

|Output |"less"
|===
link:https://jqplay.org/?q=env.PAGER&j=null[{Run}]


[[transpose]]
[reftext="`transpose`"]
==== +transpose+
{TOC}

Transpose a possibly jagged matrix (an array of arrays). Rows are padded
with nulls so the result is always rectangular.

####Example

[[example72]]
[cols=",",]
|===
|Command |jq 'transpose'

|Input |[[1], [2,3]]

|Output |[[1,2],[null,3]]
|===


[[bsearch]]
[reftext="`bsearch(x)`"]
==== +bsearch(x)+
{TOC}

`+bsearch(x)+` conducts a binary search for x in the input array. If the
input is sorted and contains x, then `+bsearch(x)+` will return its
index in the array; otherwise, if the array is sorted, it will return
(-1 - ix) where ix is an insertion point such that the array would still
be sorted after the insertion of x at ix. If the array is not sorted,
`+bsearch(x)+` will return an integer that is probably of no interest.

####Examples

[[example73]]
[cols=",",]
|===
|Command |jq 'bsearch(0)'

|Input |[0,1]

|Output |0
|===
link:https://jqplay.org/?q=bsearch%280%29&j=%5B0%2C1%5D[{Run}]


[cols=",",]
|===
|Command |jq 'bsearch(0)'

|Input |[1,2,3]

|Output |-1
|===
link:https://jqplay.org/?q=bsearch%280%29&j=%5B1%2C2%2C3%5D[{Run}]


[cols=",",]
|===
|Command |jq 'bsearch(4) as $ix \| if $ix < 0 then .[-(1+$ix)] = 4 else
. end'

|Input |[1,2,3]

|Output |[1,2,3,4]
|===


[[string-interpolation]]
[reftext="String interpolation: `\(exp)`"]
==== String interpolation: +\(exp)+
{TOC}

Inside a string, you can put an expression inside parens after a
backslash. Whatever the expression returns will be interpolated into the
string.

####Example

[[example74]]
[cols=",",]
|===
|Command |jq '"The input was \(.), which is one less than \(.+1)"'

|Input |42

|Output |"The input was 42, which is one less than 43"
|===

[[convert-to-from-json]]
==== Convert to/from JSON
{TOC}

The `+tojson+` and `+fromjson+` builtins dump values as JSON texts or
parse JSON texts into values, respectively. The `+tojson+` builtin
differs from `+tostring+` in that `+tostring+` returns strings
unmodified, while `+tojson+` encodes strings as JSON strings.

####Examples

[[example75]]
[cols=",",]
|===
|Command |jq '[.[]\|tostring]'

|Input |[1, "foo", ["foo"]]

|Output |["1","foo","[\"foo\"]"]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Ctostring%5D&j=%5B1%2C%20%22foo%22%2C%20%5B%22foo%22%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq '[.[]\|tojson]'

|Input |[1, "foo", ["foo"]]

|Output |["1","\"foo\"","[\"foo\"]"]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Ctojson%5D&j=%5B1%2C%20%22foo%22%2C%20%5B%22foo%22%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq '[.[]\|tojson\|fromjson]'

|Input |[1, "foo", ["foo"]]

|Output |[1,"foo",["foo"]]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Ctojson%7Cfromjson%5D&j=%5B1%2C%20%22foo%22%2C%20%5B%22foo%22%5D%5D[{Run}]


[[format-strings-and-escaping]]
==== Format strings and escaping
{TOC}

The `+@foo+` syntax is used to format and escape strings, which is
useful for building URLs, documents in a language like HTML or XML, and
so forth. `+@foo+` can be used as a filter on its own, the possible
escapings are:

* `+@text+`:

Calls `+tostring+`, see that function for details.

* `+@json+`:

Serializes the input as JSON.

* `+@html+`:

Applies HTML/XML escaping, by mapping the characters `+<>&'"+` to their
entity equivalents `+&lt;+`, `+&gt;+`, `+&amp;+`, `+&apos;+`,
`+&quot;+`.

* `+@uri+`:

Applies percent-encoding, by mapping all reserved URI characters to a
`+%XX+` sequence.

* `+@csv+`:

The input must be an array, and it is rendered as CSV with double quotes
for strings, and quotes escaped by repetition.

* `+@tsv+`:

The input must be an array, and it is rendered as TSV (tab-separated
values). Each input array will be printed as a single line. Fields are
separated by a single tab (ascii `+0x09+`). Input characters line-feed
(ascii `+0x0a+`), carriage-return (ascii `+0x0d+`), tab (ascii `+0x09+`)
and backslash (ascii `+0x5c+`) will be output as escape sequences
`+\n+`, `+\r+`, `+\t+`, `+\\+` respectively.

* `+@sh+`:

The input is escaped suitable for use in a command-line for a POSIX
shell. If the input is an array, the output will be a series of
space-separated strings.

* `+@base64+`:

The input is converted to base64 as specified by RFC 4648.

* `+@base64d+`:

The inverse of `+@base64+`, input is decoded as specified by RFC 4648.
Note\: If the decoded string is not UTF-8, the results are undefined.

This syntax can be combined with string interpolation in a useful way.
You can follow a `+@foo+` token with a string literal. The contents of
the string literal will _not_ be escaped. However, all interpolations
made inside that string literal will be escaped. For instance,

....
@uri "https://www.google.com/search?q=\(.search)"
....

will produce the following output for the input
`+{"search":"what is jq?"}+`:

....
"https://www.google.com/search?q=what%20is%20jq%3F"
....

Note that the slashes, question mark, etc. in the URL are not escaped,
as they were part of the string literal.

####Examples

[[example76]]
[cols=",",]
|===
|Command |jq '@html'

|Input |"This works if x < y"

|Output |"This works if x &lt; y"
|===


[cols=",",]
|===
|Command |jq '@sh "echo \(.)"'

|Input |"O'Hara's Ale"

|Output |"echo 'O'\\''Hara'\\''s Ale'"
|===
link:https://jqplay.org/?q=%40sh%20%22echo%20%5C%28.%29%22&j=%22O%27Hara%27s%20Ale%22[{Run}]


[cols=",",]
|===
|Command |jq '@base64'

|Input |"This is a message"

|Output |"VGhpcyBpcyBhIG1lc3NhZ2U="
|===


[cols=",",]
|===
|Command |jq '@base64d'

|Input |"VGhpcyBpcyBhIG1lc3NhZ2U="

|Output |"This is a message"
|===


[[dates]]
==== Dates
{TOC}

jq provides some basic date handling functionality, with some high-level
and low-level builtins. In all cases these builtins deal exclusively
with time in UTC.

The `+fromdateiso8601+` builtin parses datetimes in the ISO 8601 format
to a number of seconds since the Unix epoch (1970-01-01T00:00:00Z). The
`+todateiso8601+` builtin does the inverse.

The `+fromdate+` builtin parses datetime strings. Currently `+fromdate+`
only supports ISO 8601 datetime strings, but in the future it will
attempt to parse datetime strings in more formats.

The `+todate+` builtin is an alias for `+todateiso8601+`.

The `+now+` builtin outputs the current time, in seconds since the Unix
epoch.

Low-level jq interfaces to the C-library time functions are also
provided: `+strptime+`, `+strftime+`, `+strflocaltime+`, `+mktime+`,
`+gmtime+`, and `+localtime+`. Refer to your host operating system's
documentation for the format strings used by `+strptime+` and
`+strftime+`. Note: these are not necessarily stable interfaces in jq,
particularly as to their localization functionality.

The `+gmtime+` builtin consumes a number of seconds since the Unix epoch
and outputs a "broken down time" representation of Greenwich Mean Time
as an array of numbers representing (in this order): the year, the month
(zero-based), the day of the month (one-based), the hour of the day, the
minute of the hour, the second of the minute, the day of the week, and
the day of the year -- all one-based unless otherwise stated. The day of
the week number may be wrong on some systems for dates before March 1st
1900, or after December 31 2099.

The `+localtime+` builtin works like the `+gmtime+` builtin, but using
the local timezone setting.

The `+mktime+` builtin consumes "broken down time" representations of
time output by `+gmtime+` and `+strptime+`.

The `+strptime(fmt)+` builtin parses input strings matching the `+fmt+`
argument. The output is in the "broken down time" representation
consumed by `+mktime+` and output by `+gmtime+`.

The `+strftime(fmt)+` builtin formats a time (GMT) with the given
format. The `+strflocaltime+` does the same, but using the local
timezone setting.

The format strings for `+strptime+` and `+strftime+` are described in
typical C library documentation. The format string for ISO 8601 datetime
is `+"%Y-%m-%dT%H:%M:%SZ"+`.

jq may not support some or all of this date functionality on some
systems. In particular, the `+%u+` and `+%j+` specifiers for
`+strptime(fmt)+` are not supported on macOS.

####Examples

[[example77]]
[cols=",",]
|===
|Command |jq 'fromdate'

|Input |"2015-03-05T23:51:47Z"

|Output |1425599507
|===


[cols=",",]
|===
|Command |jq 'strptime("%Y-%m-%dT%H:%M:%SZ")'

|Input |"2015-03-05T23:51:47Z"

|Output |[2015,2,5,23,51,47,4,63]
|===
link:https://jqplay.org/?q=strptime%28%22%25Y-%25m-%25dT%25H%3A%25M%3A%25SZ%22%29&j=%222015-03-05T23%3A51%3A47Z%22[{Run}]


[cols=",",]
|===
|Command |jq 'strptime("%Y-%m-%dT%H:%M:%SZ")\|mktime'

|Input |"2015-03-05T23:51:47Z"

|Output |1425599507
|===
link:https://jqplay.org/?q=strptime%28%22%25Y-%25m-%25dT%25H%3A%25M%3A%25SZ%22%29%7Cmktime&j=%222015-03-05T23%3A51%3A47Z%22[{Run}]


[[sql-style-operators]]
==== SQL-Style Operators
{TOC}

jq provides a few SQL-style operators.

* INDEX(stream; index_expression):

This builtin produces an object whose keys are computed by the given
index expression applied to each value from the given stream.

* JOIN($idx; stream; idx_expr; join_expr):

This builtin joins the values from the given stream to the given index.
The index's keys are computed by applying the given index expression to
each value from the given stream. An array of the value in the stream
and the corresponding value from the index is fed to the given join
expression to produce each result.

* JOIN($idx; stream; idx_expr):

Same as `+JOIN($idx; stream; idx_expr; .)+`.

* JOIN($idx; idx_expr):

This builtin joins the input `+.+` to the given index, applying the
given index expression to `+.+` to compute the index key. The join
operation is as described above.

* IN(s):

This builtin outputs `+true+` if `+.+` appears in the given stream,
otherwise it outputs `+false+`.

* IN(source; s):

This builtin outputs `+true+` if any value in the source stream appears
in the second stream, otherwise it outputs `+false+`.

[[builtins]]
[reftext="`builtins`"]
==== +builtins+
{TOC}

Returns a list of all builtin functions in the format `+name/arity+`.
Since functions with the same name but different arities are considered
separate functions, `+all/0+`, `+all/1+`, and `+all/2+` would all be
present in the list.

[[conditionals-and-comparisons]]
=== Conditionals and Comparisons
{TOC}

  ** <<eq-neq>>
  ** <<if-then-else-end>>
  ** <<gt-ge-le-lt>>
  ** <<and-or-not>>
  ** <<alternative-operator>>
  ** <<try-catch>>
  ** <<breaking-out-of-control-structures>>
  ** <<error-suppression-optional-operator>>

[[eq-neq]]
[reftext="`==`, `!=`"]
==== +==+, +!=+

The expression 'a == b' will produce 'true' if the results of evaluating
a and b are equal (that is, if they represent equivalent JSON values)
and 'false' otherwise. In particular, strings are never considered equal
to numbers. In checking for the equality of JSON objects, the ordering
of keys is irrelevant. If you're coming from JavaScript, please note
that jq's `+==+` is like JavaScript's `+===+`, the "strict equality"
operator.

!= is "not equal", and 'a != b' returns the opposite value of 'a == b'

####Examples

[[example78]]
[cols=",",]
|===
|Command |jq '. == false'

|Input |null

|Output |false
|===
link:https://jqplay.org/?q=.%20%3D%3D%20false&j=null[{Run}]


[cols=",",]
|===
|Command |jq '. == {"b": {"d": (4 + 1e-20), "c": 3}, "a":1}'

|Input |{"a":1, "b": {"c": 3, "d": 4}}

|Output |true
|===
link:https://jqplay.org/?q=.%20%3D%3D%20%7B%22b%22%3A%20%7B%22d%22%3A%20%284%20%2B%201e-20%29%2C%20%22c%22%3A%203%7D%2C%20%22a%22%3A1%7D&j=%7B%22a%22%3A1%2C%20%22b%22%3A%20%7B%22c%22%3A%203%2C%20%22d%22%3A%204%7D%7D[{Run}]


[cols=",",]
|===
|Command |jq '.[] == 1'

|Input |[1, 1.0, "1", "banana"]

|Output |true

| |true

| |false

| |false
|===
link:https://jqplay.org/?q=.%5B%5D%20%3D%3D%201&j=%5B1%2C%201.0%2C%20%221%22%2C%20%22banana%22%5D[{Run}]


[[if-then-else-end]]
==== if-then-else-end
{TOC}

`+if A then B else C end+` will act the same as `+B+` if `+A+` produces
a value other than false or null, but act the same as `+C+` otherwise.

`+if A then B end+` is the same as `+if A then B else . end+`. That is,
the `+else+` branch is optional, and if absent is the same as `+.+`.
This also applies to `+elif+` with absent ending `+else+` branch.

Checking for false or null is a simpler notion of "truthiness" than is
found in JavaScript or Python, but it means that you'll sometimes have
to be more explicit about the condition you want. You can't test
whether, e.g. a string is empty using `+if .name then A else B end+`;
you'll need something like `+if .name == "" then A else B end+` instead.

If the condition `+A+` produces multiple results, then `+B+` is
evaluated once for each result that is not false or null, and `+C+` is
evaluated once for each false or null.

More cases can be added to an if using `+elif A then B+` syntax.

####Example

[[example79]]
[cols=",",]
|===
|Command |jq 'if . == 0 then "zero" elif . == 1 then "one" else "many"
end'

|Input |2

|Output |"many"
|===



[[gt-ge-le-lt]]
[reftext="`>`, `>=`, `<=`, `<`"]
==== +>+, +>=+, +<=+, +<+
{TOC}

The comparison operators `+>+`, `+>=+`, `+<=+`, `+<+` return whether
their left argument is greater than, greater than or equal to, less than
or equal to or less than their right argument (respectively).

The ordering is the same as that described for `+sort+`, above.

####Example

[[example80]]
[cols=",",]
|===
|Command |jq '. < 5'

|Input |2

|Output |true
|===
link:https://jqplay.org/?q=.%20%3C%205&j=2[{Run}]


[[and-or-not]]
[reftext="`and`, `or`, `not`"]
==== +and+, +or+, +not+
{TOC}

jq supports the normal Boolean operators `+and+`, `+or+`, `+not+`. They
have the same standard of truth as if expressions - `+false+` and
`+null+` are considered "false values", and anything else is a "true
value".

If an operand of one of these operators produces multiple results, the
operator itself will produce a result for each input.

`+not+` is in fact a builtin function rather than an operator, so it is
called as a filter to which things can be piped rather than with special
syntax, as in `+.foo and .bar | not+`.

These three only produce the values `+true+` and `+false+`, and so are
only useful for genuine Boolean operations, rather than the common
Perl/Python/Ruby idiom of "value_that_may_be_null or default". If you
want to use this form of "or", picking between two values rather than
evaluating a condition, see the `+//+` operator below.

####Examples

[[example81]]
[cols=",",]
|===
|Command |jq '42 and "a string"'

|Input |null

|Output |true
|===
link:https://jqplay.org/?q=42%20and%20%22a%20string%22&j=null[{Run}]


[cols=",",]
|===
|Command |jq '(true, false) or false'

|Input |null

|Output |true

| |false
|===


[cols=",",]
|===
|Command |jq '(true, true) and (true, false)'

|Input |null

|Output |true +
         false +
         true +
         false
|===
link:https://jqplay.org/?q=%28true%2C%20true%29%20and%20%28true%2C%20false%29&j=null[{Run}]


[cols=",",]
|===
|Command |jq '[true, false \| not]'

|Input |null

|Output |[false, true]
|===


[[alternative-operator]]
[reftext="Alternative operator: `//`"]
==== Alternative operator: +//+
{TOC}

The `+//+` operator produces all the values of its left-hand side that
are neither `+false+` nor `+null+`, or, if the left-hand side produces
no values other than `+false+` or `+null+`, then `+//+` produces all the
values of its right-hand side.

A filter of the form `+a // b+` produces all the results of `+a+` that
are not `+false+` or `+null+`. If `+a+` produces no results, or no
results other than `+false+` or `+null+`, then `+a // b+` produces the
results of `+b+`.

This is useful for providing defaults: `+.foo // 1+` will evaluate to
`+1+` if there's no `+.foo+` element in the input. It's similar to how
`+or+` is sometimes used in Python (jq's `+or+` operator is reserved for
strictly Boolean operations).

Note: `+some_generator // defaults_here+` is not the same as
`+some_generator | . // defaults_here+`. The latter will produce default
values for all non-`+false+`, non-`+null+` values of the left-hand side,
while the former will not. Precedence rules can make this confusing. For
example, in `+false, 1 // 2+` the left-hand side of `+//+` is `+1+`, not
`+false, 1+` -- `+false, 1 // 2+` parses the same way as
`+false, (1 // 2)+`. In `+(false, null, 1) | . // 42+` the left-hand
side of `+//+` is `+.+`, which always produces just one value, while in
`+(false, null, 1) // 42+` the left-hand side is a generator of three
values, and since it produces a value other `+false+` and `+null+`, the
default `+42+` is not produced.

####Examples

[[example82]]
[cols=",",]
|===
|Command |jq 'empty // 42'

|Input |null

|Output |42
|===
link:https://jqplay.org/?q=empty%20//%2042&j=null[{Run}]


[cols=",",]
|===
|Command |jq '.foo // 42'

|Input |{"foo": 19}

|Output |19
|===


[cols=",",]
|===
|Command |jq '.foo // 42'

|Input |{}

|Output |42
|===
link:https://jqplay.org/?q=.foo%20//%2042&j=%7B%7D[{Run}]


[cols=",",]
|===
|Command |jq '(false, null, 1) // 42'

|Input |null

|Output |1
|===


[cols=",",]
|===
|Command  |jq '(false, null, 1) \| . // 42'

|Input    |null

|Output   |42           +
           42           +
           1
|===
link:https://jqplay.org/?q=%28false%2C%20null%2C%201%29%20%7C%20.%20//%2042&j=null[{Run}]


[[try-catch]]
==== try-catch
{TOC}

Errors can be caught by using `+try EXP catch EXP+`. The first
expression is executed, and if it fails then the second is executed with
the error message. The output of the handler, if any, is output as if it
had been the output of the expression to try.

The `+try EXP+` form uses `+empty+` as the exception handler.

####Examples

[[example83]]
[cols=",",]
|===
|Command |jq 'try .a catch ". is not an object"'

|Input |true

|Output |". is not an object"
|===
link:https://jqplay.org/?q=try%20.a%20catch%20%22.%20is%20not%20an%20object%22&j=true[{Run}]


[cols=",",]
|===
|Command |jq '[.[]\|try .a]'

|Input |[{}, true, {"a":1}]

|Output |[null, 1]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%7Ctry%20.a%5D&j=%5B%7B%7D%2C%20true%2C%20%7B%22a%22%3A1%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'try error("some exception") catch .'

|Input |true

|Output |"some exception"
|===
link:https://jqplay.org/?q=try%20error%28%22some%20exception%22%29%20catch%20.&j=true[{Run}]


[[breaking-out-of-control-structures]]
==== Breaking out of control structures
{TOC}

A convenient use of try/catch is to break out of control structures like
`+reduce+`, `+foreach+`, `+while+`, and so on.

For example:

....
# Repeat an expression until it raises "break" as an
# error, then stop repeating without re-raising the error.
# But if the error caught is not "break" then re-raise it.
try repeat(exp) catch if .=="break" then empty else error
....

jq has a syntax for named lexical labels to "break" or "go (back) to":

....
label $out | ... break $out ...
....

The `+break $label_name+` expression will cause the program to act as
though the nearest (to the left) `+label $label_name+` produced
`+empty+`.

The relationship between the `+break+` and corresponding `+label+` is
lexical: the label has to be "visible" from the break.

To break out of a `+reduce+`, for example:

....
label $out | reduce .[] as $item (null; if .==false then break $out else ... end)
....

The following jq program produces a syntax error:

....
break $out
....

because no label `+$out+` is visible.

[[error-suppression-optional-operator]]
[reftext="Error Suppression / Optional Operator: `?`"]
==== Error Suppression / Optional Operator: +?+
{TOC}

The `+?+` operator, used as `+EXP?+`, is shorthand for `+try EXP+`.

####Examples

[[example84]]
[cols=",",]
|===
|Command |jq '[.[] \| .a?]'

|Input |[{}, true, {"a":1}]

|Output |[null, 1]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%20%7C%20.a%3F%5D&j=%5B%7B%7D%2C%20true%2C%20%7B%22a%22%3A1%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq '[.[] \| tonumber?]'

|Input |["1", "invalid", "3", 4]

|Output |[1, 3, 4]
|===
link:https://jqplay.org/?q=%5B.%5B%5D%20%7C%20tonumber%3F%5D&j=%5B%221%22%2C%20%22invalid%22%2C%20%223%22%2C%204%5D[{Run}]


[[regular-expressions]]
=== Regular expressions
{TOC}

  ** <<test>>
  ** <<match>>
  ** <<capture>>
  ** <<scan>>
  ** <<split-2>>
  ** <<splits>>
  ** <<sub>>
  ** <<gsub>>


jq uses the https://github.com/kkos/oniguruma/blob/master/doc/RE[Oniguruma]
regular expression library, as do PHP, TextMate, Sublime Text, etc, so the
description here will focus on jq specifics.

Oniguruma supports several flavors of regular expression, so it is
important to know that jq uses the
https://github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md["Perl NG"]
(Perl with named groups) flavor.

The jq regex filters are defined so that they can be used using one of
these patterns:

....
STRING | FILTER(REGEX)
STRING | FILTER(REGEX; FLAGS)
STRING | FILTER([REGEX])
STRING | FILTER([REGEX, FLAGS])
....

where:

* STRING, REGEX, and FLAGS are jq strings and subject to jq string
interpolation;
* REGEX, after string interpolation, should be a valid regular
expression;
* FILTER is one of `+test+`, `+match+`, or `+capture+`, as described
below.

Since REGEX must evaluate to a JSON string, some characters that are
needed to form a regular expression must be escaped. For example, the
regular expression `+\s+` signifying a whitespace character would be
written as `+"\\s"+`.

FLAGS is a string consisting of one of more of the supported flags:

* `+g+` - Global search (find all matches, not just the first)
* `+i+` - Case insensitive search
* `+m+` - Multi line mode (`+.+` will match newlines)
* `+n+` - Ignore empty matches
* `+p+` - Both s and m modes are enabled
* `+s+` - Single line mode (`+^+` -> `+\A+`, `+$+` -> `+\Z+`)
* `+l+` - Find longest possible matches
* `+x+` - Extended regex format (ignore whitespace and comments)

To match a whitespace with the `+x+` flag, use `+\s+`, e.g.

....
jq -n '"a b" | test("a\\sb"; "x")'
....

Note that certain flags may also be specified within REGEX, e.g.

....
jq -n '("test", "TEst", "teST", "TEST") | test("(?i)te(?-i)st")'
....

evaluates to: `+true+`, `+true+`, `+false+`, `+false+`.

[[test]]
[reftext="`test(val)`, `test(regex; flags)`"]
==== +test(val)+, +test(regex; flags)+
{TOC}

Like `+match+`, but does not return match objects, only `+true+` or
`+false+` for whether or not the regex matches the input.

####Examples

[[example85]]
[cols=",",]
|===
|Command |jq 'test("foo")'

|Input |"foo"

|Output |true
|===
link:https://jqplay.org/?q=test%28%22foo%22%29&j=%22foo%22[{Run}]


[cols=",",]
|===
|Command |jq '.[] \| test("a b c # spaces are ignored"; "ix")'

|Input |["xabcd", "ABC"]

|Output |true +
         true
|===
link:https://jqplay.org/?q=.%5B%5D%20%7C%20test%28%22a%20b%20c%20%23%20spaces%20are%20ignored%22%3B%20%22ix%22%29&j=%5B%22xabcd%22%2C%20%22ABC%22%5D[{Run}]


[[match]]
[reftext="`match(val)`, `match(regex; flags)`"]
==== +match(val)+, +match(regex; flags)+
{TOC}

*match* outputs an object for each match it finds. Matches have the
following fields:

* `+offset+` - offset in UTF-8 codepoints from the beginning of the
input
* `+length+` - length in UTF-8 codepoints of the match
* `+string+` - the string that it matched
* `+captures+` - an array of objects representing capturing groups.

Capturing group objects have the following fields:

* `+offset+` - offset in UTF-8 codepoints from the beginning of the
input
* `+length+` - length in UTF-8 codepoints of this capturing group
* `+string+` - the string that was captured
* `+name+` - the name of the capturing group (or `+null+` if it was
unnamed)

Capturing groups that did not match anything return an offset of -1

####Examples

[[example86]]
[cols=",",]
|===
|Command |jq 'match("(abc)+"; "g")'

|Input |"abc abc"

|Output |{"offset": 0, "length": 3, "string": "abc", "captures":
         [{"offset": 0, "length": 3, "string": "abc", "name": null}]}

         {"offset": 4, "length": 3, "string": "abc", "captures": [{"offset":
         4, "length": 3, "string": "abc", "name": null}]}
|===
link:https://jqplay.org/?q=match%28%22%28abc%29%2B%22%3B%20%22g%22%29&j=%22abc%20abc%22[{Run}]


[cols=",",]
|===
|Command |jq 'match("foo")'

|Input |"foo bar foo"

|Output |{"offset": 0, "length": 3, "string": "foo", "captures": []}
|===


[cols=",",]
|===
|Command |jq 'match(["foo", "ig"])'

|Input |"foo bar FOO"

|Output |{"offset": 0, "length": 3, "string": "foo", "captures": []}

        {"offset": 8, "length": 3, "string": "FOO", "captures": []}
|===
link:https://jqplay.org/?q=match%28%5B%22foo%22%2C%20%22ig%22%5D%29&j=%22foo%20bar%20FOO%22[{Run}]


[cols=",",]
|===
|Command |jq 'match("foo (?<bar123>bar)? foo"; "ig")'

|Input |"foo bar foo foo foo"

|Output |{"offset": 0, "length": 11, "string": "foo bar foo",
        "captures": [\{"offset": 4, "length": 3, "string": "bar", "name":
        "bar123"}]}

        {"offset": 12, "length": 8, "string": "foo foo", "captures":
        [{"offset": -1, "length": 0, "string": null, "name": "bar123"}]}
|===
link:https://jqplay.org/?q=match%28%22foo%20%28%3F%3Cbar123%3Ebar%29%3F%20foo%22%3B%20%22ig%22%29&j=%22foo%20bar%20foo%20foo%20%20foo%22[{Run}]


[cols=",",]
|===
|Command |jq '[ match("."; "g")] \| length'

|Input |"abc"

|Output |3
|===
link:https://jqplay.org/?q=%5B%20match%28%22.%22%3B%20%22g%22%29%5D%20%7C%20length&j=%22abc%22[{Run}]


[[capture]]
[reftext="`capture(val)`, `capture(regex; flags)`"]
==== +capture(val)+, +capture(regex; flags)+
{TOC}

Collects the named captures in a JSON object, with the name of each
capture as the key, and the matched string as the corresponding value.

####Example

[[example87]]
[cols=",",]
|===
|Command |jq 'capture("(?<a>[a-z]+)-(?<n>[0-9]+)")'

|Input |"xyzzy-14"

|Output |{ "a": "xyzzy", "n": "14" }
|===
link:https://jqplay.org/?q=capture%28%22%28%3F%3Ca%3E%5Ba-z%5D%2B%29-%28%3F%3Cn%3E%5B0-9%5D%2B%29%22%29&j=%22xyzzy-14%22[{Run}]


[[scan]]
[reftext="`scan(regex)`, `scan(regex; flags)`"]
==== +scan(regex)+, +scan(regex; flags)+
{TOC}

Emit a stream of the non-overlapping substrings of the input that match
the regex in accordance with the flags, if any have been specified. If
there is no match, the stream is empty. To capture all the matches for
each input string, use the idiom `+[ expr ]+`, e.g. `+[ scan(regex) ]+`.

####Example

[[example88]]
[cols=",",]
|===
|Command |jq 'scan("c")'

|Input |"abcdefabc"

|Output |"c" +
         "c"
|===
link:https://jqplay.org/?q=scan%28%22c%22%29&j=%22abcdefabc%22[{Run}]


[[split-2]]
[reftext="`split(regex; flags)`"]
==== +split(regex; flags)+
{TOC}

Splits an input string on each regex match.

For backwards compatibility, when called with a single argument,
`+split+` splits on a string, not a regex.

####Example

[[example89]]
[cols=",",]
|===
|Command |jq 'split(", *"; null)'

|Input |"ab,cd, ef"

|Output |["ab","cd","ef"]
|===
link:https://jqplay.org/?q=split%28%22%2C%20%2A%22%3B%20null%29&j=%22ab%2Ccd%2C%20ef%22[{Run}]


[[splits]]
[reftext="`splits(regex)`, `splits(regex; flags)`"]
==== +splits(regex)+, +splits(regex; flags)+
{TOC}

These provide the same results as their `+split+` counterparts, but as a
stream instead of an array.

####Example

[[example90]]
[cols=",",]
|===
|Command |jq 'splits(", *")'

|Input |"ab,cd, ef, gh"

|Output |"ab" +
         "cd" +
         "ef" +
         "gh"
|===
link:https://jqplay.org/?q=splits%28%22%2C%20%2A%22%29&j=%22ab%2Ccd%2C%20%20%20ef%2C%20gh%22[{Run}]


[[sub]]
[reftext="`sub(regex; tostring)`, `sub(regex; tostring; flags)`"]
==== +sub(regex; tostring)+, +sub(regex; tostring; flags)+
{TOC}

Emit the string obtained by replacing the first match of regex in the
input string with `+tostring+`, after interpolation. `+tostring+` should
be a jq string or a stream of such strings, each of which may contain
references to named captures. The named captures are, in effect,
presented as a JSON object (as constructed by `+capture+`) to
`+tostring+`, so a reference to a captured variable named "x" would take
the form: `+"\(.x)"+`.

####Examples

[[example91]]
[cols=",",]
|===
|Command |jq 'sub("[^a-z]*(?<x>[a-z]+)"; "Z\(.x)"; "g")'

|Input |"123abc456def"

|Output |"ZabcZdef"
|===
link:https://jqplay.org/?q=sub%28%22%5B%5Ea-z%5D%2A%28%3F%3Cx%3E%5Ba-z%5D%2B%29%22%3B%20%22Z%5C%28.x%29%22%3B%20%22g%22%29&j=%22123abc456def%22[{Run}]


[cols=",",]
|===
|Command |jq '[sub("(?<a>.)"; "\(.a\|ascii_upcase)",
"\(.a\|ascii_downcase)")]'

|Input |"aB"

|Output |["AB","aB"]
|===
link:https://jqplay.org/?q=%5Bsub%28%22%28%3F%3Ca%3E.%29%22%3B%20%22%5C%28.a%7Cascii_upcase%29%22%2C%20%22%5C%28.a%7Cascii_downcase%29%22%29%5D&j=%22aB%22[{Run}]


[[gsub]]
[reftext="`gsub(regex; tostring)`, `gsub(regex; tostring; flags)`"]
==== +gsub(regex; tostring)+, +gsub(regex; tostring; flags)+
{TOC}

`+gsub+` is like `+sub+` but all the non-overlapping occurrences of the
regex are replaced by `+tostring+`, after interpolation. If the second
argument is a stream of jq strings, then `+gsub+` will produce a
corresponding stream of JSON strings.

####Examples

[[example92]]
[cols=",",]
|===
|Command |jq 'gsub("(?<x>.)[^a]*"; "+\(.x)-")'

|Input |"Abcabc"

|Output |"+A-+a-"
|===


[cols=",",]
|===
|Command |jq '[gsub("p"; "a", "b")]'

|Input |"p"

|Output |["a","b"]
|===
link:https://jqplay.org/?q=%5Bgsub%28%22p%22%3B%20%22a%22%2C%20%22b%22%29%5D&j=%22p%22[{Run}]


[[advanced-features]]
=== Advanced features
{TOC}

  ** <<variable-symbolic-binding-operator>>
  ** <<destructuring-alternative-operator>>
  ** <<defining-functions>>
  ** <<scoping>>
  ** <<isempty>>
  ** <<limit>>
  ** <<first-last-nth-2>>
  ** <<first-last-nth-1>>
  ** <<reduce>>
  ** <<foreach>>
  ** <<recursion>>
  ** <<generators-and-iterators>>

Variables are an absolute necessity in most programming languages, but
they're relegated to an "advanced feature" in jq.

In most languages, variables are the only means of passing around data.
If you calculate a value, and you want to use it more than once, you'll
need to store it in a variable. To pass a value to another part of the
program, you'll need that part of the program to define a variable (as a
function parameter, object member, or whatever) in which to place the
data.

It is also possible to define functions in jq, although this is is a
feature whose biggest use is defining jq's standard library (many jq
functions such as `+map+` and `+select+` are in fact written in jq).

jq has reduction operators, which are very powerful but a bit tricky.
Again, these are mostly used internally, to define some useful bits of
jq's standard library.

It may not be obvious at first, but jq is all about generators (yes, as
often found in other languages). Some utilities are provided to help
deal with generators.

Some minimal I/O support (besides reading JSON from standard input, and
writing JSON to standard output) is available.

Finally, there is a module/library system.

[[variable-symbolic-binding-operator]]
[reftext="Variable / Symbolic Binding Operator: `... as $identifier | ...`"]
==== Variable / Symbolic Binding Operator: ... as $identifier | ...
{TOC}

In jq, all filters have an input and an output, so manual plumbing is
not necessary to pass a value from one part of a program to the next.
Many expressions, for instance `+a + b+`, pass their input to two
distinct subexpressions (here `+a+` and `+b+` are both passed the same
input), so variables aren't usually necessary in order to use a value
twice.

For instance, calculating the average value of an array of numbers
requires a few variables in most languages - at least one to hold the
array, perhaps one for each element or for a loop counter. In jq, it's
simply `+add / length+` - the `+add+` expression is given the array and
produces its sum, and the `+length+` expression is given the array and
produces its length.

So, there's generally a cleaner way to solve most problems in jq than
defining variables. Still, sometimes they do make things easier, so jq
lets you define variables using `+expression as $variable+`. All
variable names start with `+$+`. Here's a slightly uglier version of the
array-averaging example:

....
length as $array_length | add / $array_length
....

We'll need a more complicated problem to find a situation where using
variables actually makes our lives easier.

Suppose we have an array of blog posts, with "author" and "title"
fields, and another object which is used to map author usernames to real
names. Our input looks like:

....
{"posts": [{"title": "First post", "author": "anon"},
           {"title": "A well-written article", "author": "person1"}],
 "realnames": {"anon": "Anonymous Coward",
               "person1": "Person McPherson"}}
....

We want to produce the posts with the author field containing a real
name, as in:

....
{"title": "First post", "author": "Anonymous Coward"}
{"title": "A well-written article", "author": "Person McPherson"}
....

We use a variable, $names, to store the realnames object, so that we can
refer to it later when looking up author usernames:

....
.realnames as $names | .posts[] | {title, author: $names[.author]}
....

The expression `+exp as $x | ...+` means: for each value of expression
`+exp+`, run the rest of the pipeline with the entire original input,
and with `+$x+` set to that value. Thus `+as+` functions as something of
a foreach loop.

Just as `+{foo}+` is a handy way of writing `+{foo: .foo}+`, so
`+{$foo}+` is a handy way of writing `+{foo: $foo}+`.

Multiple variables may be declared using a single `+as+` expression by
providing a pattern that matches the structure of the input (this is
known as "destructuring"):

....
. as {realnames: $names, posts: [$first, $second]} | ...
....

The variable declarations in array patterns (e.g.,
`+. as [$first, $second]+`) bind to the elements of the array in from
the element at index zero on up, in order. When there is no value at the
index for an array pattern element, `+null+` is bound to that variable.

Variables are scoped over the rest of the expression that defines them,
so

....
.realnames as $names | (.posts[] | {title, author: $names[.author]})
....

will work, but

....
(.realnames as $names | .posts[]) | {title, author: $names[.author]}
....

won't.

For programming language theorists, it's more accurate to say that jq
variables are lexically-scoped bindings. In particular there's no way to
change the value of a binding; one can only setup a new binding with the
same name, but which will not be visible where the old one was.

####Examples

[[example93]]
[cols=",",]
|===
|Command |jq '.bar as $x \| .foo \| . + $x'

|Input |{"foo":10, "bar":200}

|Output |210
|===
link:https://jqplay.org/?q=.bar%20as%20%24x%20%7C%20.foo%20%7C%20.%20%2B%20%24x&j=%7B%22foo%22%3A10%2C%20%22bar%22%3A200%7D[{Run}]


[cols=",",]
|===
|Command |jq '. as $i\|[(.*2\|. as $i\| $i), $i]'

|Input |5

|Output |[10,5]
|===
link:https://jqplay.org/?q=.%20as%20%24i%7C%5B%28.%2A2%7C.%20as%20%24i%7C%20%24i%29%2C%20%24i%5D&j=5[{Run}]


[cols=",",]
|===
|Command |jq '. as [$a, $b, {c: $c}] \| $a + $b + $c'

|Input |[2, 3, {"c": 4, "d": 5}]

|Output |9
|===


[cols=",",]
|===
|Command |jq '.[] as [$a, $b] \| {a: $a, b: $b}'

|Input   |[[0], [0, 1], [2, 1, 0]]

|Output  |{"a":0,"b":null} +
          {"a":0,"b":1} +
          {"a":2,"b":1}
|===
link:https://jqplay.org/?q=.%5B%5D%20as%20%5B%24a%2C%20%24b%5D%20%7C%20%7Ba%3A%20%24a%2C%20b%3A%20%24b%7D&j=%5B%5B0%5D%2C%20%5B0%2C%201%5D%2C%20%5B2%2C%201%2C%200%5D%5D[{Run}]


[[destructuring-alternative-operator]]
[reftext="Destructuring Alternative Operator: `?//`"]
==== Destructuring Alternative Operator: +?//+
{TOC}

The destructuring alternative operator provides a concise mechanism for
destructuring an input that can take one of several forms.

Suppose we have an API that returns a list of resources and events
associated with them, and we want to get the user_id and timestamp of
the first event for each resource. The API (having been clumsily
converted from XML) will only wrap the events in an array if the
resource has multiple events:

....
{"resources": [{"id": 1, "kind": "widget", "events": {"action": "create", "user_id": 1, "ts": 13}},
               {"id": 2, "kind": "widget", "events": [{"action": "create", "user_id": 1, "ts": 14}, {"action": "destroy", "user_id": 1, "ts": 15}]}]}
....

We can use the destructuring alternative operator to handle this
structural change simply:

....
.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}
....

Or, if we aren't sure if the input is an array of values or an object:

....
.[] as [$id, $kind, $user_id, $ts] ?// {$id, $kind, $user_id, $ts} | ...
....

Each alternative need not define all of the same variables, but all
named variables will be available to the subsequent expression.
Variables not matched in the alternative that succeeded will be
`+null+`:

....
.resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$first_user_id, $first_ts}]} | {$user_id, $first_user_id, $kind, $id, $ts, $first_ts}
....

Additionally, if the subsequent expression returns an error, the
alternative operator will attempt to try the next binding. Errors that
occur during the final alternative are passed through.

....
[[3]] | .[] as [$a] ?// [$b] | if $a != null then error("err: \($a)") else {$a,$b} end
....

####Examples

[[example94]]
[cols=",",]
|===
|Command |jq '.[] as {$a, $b, c: {$d, $e}} ?// {$a, $b, c: [{$d,
          $e}]} \| {$a, $b, $d, $e}'

|Input   |[{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2,
          "c": [{"d": 3, "e": 4}]}]

|Output  |{"a":1,"b":2,"d":3,"e":4} +
          {"a":1,"b":2,"d":3,"e":4}
|===
link:https://jqplay.org/?q=.%5B%5D%20as%20%7B%24a%2C%20%24b%2C%20c%3A%20%7B%24d%2C%20%24e%7D%7D%20%3F//%20%7B%24a%2C%20%24b%2C%20c%3A%20%5B%7B%24d%2C%20%24e%7D%5D%7D%20%7C%20%7B%24a%2C%20%24b%2C%20%24d%2C%20%24e%7D&j=%5B%7B%22a%22%3A%201%2C%20%22b%22%3A%202%2C%20%22c%22%3A%20%7B%22d%22%3A%203%2C%20%22e%22%3A%204%7D%7D%2C%20%7B%22a%22%3A%201%2C%20%22b%22%3A%202%2C%20%22c%22%3A%20%5B%7B%22d%22%3A%203%2C%20%22e%22%3A%204%7D%5D%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[] as {$a, $b, c: {$d}} ?// {$a, $b, c: [{$e}]} \|
{$a, $b, $d, $e}'

|Input |[{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2,
"c": [{"d": 3, "e": 4}]}]

|Output |{"a":1,"b":2,"d":3,"e":null} + 
         {"a":1,"b":2,"d":null,"e":4}
|===
link:https://jqplay.org/?q=.%5B%5D%20as%20%7B%24a%2C%20%24b%2C%20c%3A%20%7B%24d%7D%7D%20%3F//%20%7B%24a%2C%20%24b%2C%20c%3A%20%5B%7B%24e%7D%5D%7D%20%7C%20%7B%24a%2C%20%24b%2C%20%24d%2C%20%24e%7D&j=%5B%7B%22a%22%3A%201%2C%20%22b%22%3A%202%2C%20%22c%22%3A%20%7B%22d%22%3A%203%2C%20%22e%22%3A%204%7D%7D%2C%20%7B%22a%22%3A%201%2C%20%22b%22%3A%202%2C%20%22c%22%3A%20%5B%7B%22d%22%3A%203%2C%20%22e%22%3A%204%7D%5D%7D%5D[{Run}]


[cols=",",]
|===
|Command |jq '.[] as [$a] ?// [$b] \| if $a != null then error("err:
          \($a)") else {$a,$b} end'

|Input |[[3]]

|Output |{"a":null,"b":3}
|===
link:https://jqplay.org/?q=.%5B%5D%20as%20%5B%24a%5D%20%3F//%20%5B%24b%5D%20%7C%20if%20%24a%20%21%3D%20null%20then%20error%28%22err%3A%20%5C%28%24a%29%22%29%20else%20%7B%24a%2C%24b%7D%20end&j=%5B%5B3%5D%5D[{Run}]


[[defining-functions]]
==== Defining Functions
{TOC}

You can give a filter a name using "def" syntax:

....
def increment: . + 1;
....

From then on, `+increment+` is usable as a filter just like a builtin
function (in fact, this is how many of the builtins are defined). A
function may take arguments:

....
def map(f): [.[] | f];
....

Arguments are passed as _filters_ (functions with no arguments), _not_
as values. The same argument may be referenced multiple times with
different inputs (here `+f+` is run for each element of the input
array). Arguments to a function work more like callbacks than like value
arguments. This is important to understand. Consider:

....
def foo(f): f|f;
5|foo(.*2)
....

The result will be 20 because `+f+` is `+.*2+`, and during the first
invocation of `+f+` `+.+` will be 5, and the second time it will be 10
(5 * 2), so the result will be 20. Function arguments are filters, and
filters expect an input when invoked.

If you want the value-argument behaviour for defining simple functions,
you can just use a variable:

....
def addvalue(f): f as $f | map(. + $f);
....

Or use the short-hand:

....
def addvalue($f): ...;
....

With either definition, `+addvalue(.foo)+` will add the current input's
`+.foo+` field to each element of the array. Do note that calling
`+addvalue(.[])+` will cause the `+map(. + $f)+` part to be evaluated
once per value in the value of `+.+` at the call site.

Multiple definitions using the same function name are allowed. Each
re-definition replaces the previous one for the same number of function
arguments, but only for references from functions (or main program)
subsequent to the re-definition. See also the section below on scoping.

####Examples

[[example95]]
[cols=",",]
|===
|Command |jq 'def addvalue(f): . + [f]; map(addvalue(.[0]))'

|Input |[[1,2],[10,20]]

|Output |[[1,2,1], [10,20,10]]
|===
link:https://jqplay.org/?q=def%20addvalue%28f%29%3A%20.%20%2B%20%5Bf%5D%3B%20map%28addvalue%28.%5B0%5D%29%29&j=%5B%5B1%2C2%5D%2C%5B10%2C20%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'def addvalue(f): f as $x \| map(. + $x); addvalue(.[0])'

|Input |[[1,2],[10,20]]

|Output |[[1,2,1,2], [10,20,1,2]]
|===
link:https://jqplay.org/?q=def%20addvalue%28f%29%3A%20f%20as%20%24x%20%7C%20map%28.%20%2B%20%24x%29%3B%20addvalue%28.%5B0%5D%29&j=%5B%5B1%2C2%5D%2C%5B10%2C20%5D%5D[{Run}]


[[scoping]]
==== Scoping
{TOC}

There are two types of symbols in jq: value bindings (a.k.a.,
"variables"), and functions. Both are scoped lexically, with expressions
being able to refer only to symbols that have been defined "to the left"
of them. The only exception to this rule is that functions can refer to
themselves so as to be able to create recursive functions.

For example, in the following expression there is a binding which is
visible "to the right" of it,
`+... | .*3 as $times_three | [. + $times_three] | ...+`, but not "to
the left". Consider this expression now,
`+... | (.*3 as $times_three | [. + $times_three]) | ...+`: here the
binding `+$times_three+` is _not_ visible past the closing parenthesis.

[[isempty]]
[reftext="`isempty(exp)`"]
==== +isempty(exp)+
{TOC}

Returns true if `+exp+` produces no outputs, false otherwise.

####Examples

[[example96]]
[cols=",",]
|===
|Command |jq 'isempty(empty)'

|Input |null

|Output |true
|===
link:https://jqplay.org/?q=isempty%28empty%29&j=null[{Run}]


[cols=",",]
|===
|Command |jq 'isempty(.[])'

|Input |[]

|Output |true
|===
link:https://jqplay.org/?q=isempty%28.%5B%5D%29&j=%5B%5D[{Run}]


[cols=",",]
|===
|Command |jq 'isempty(.[])'

|Input |[1,2,3]

|Output |false
|===


[[limit]]
[reftext="`limit(n; exp)`"]
==== +limit(n; exp)+
{TOC}

The `+limit+` function extracts up to `+n+` outputs from `+exp+`.

####Example

[[example97]]
[cols=",",]
|===
|Command |jq '[limit(3;.[])]'

|Input |[0,1,2,3,4,5,6,7,8,9]

|Output |[0,1,2]
|===
link:https://jqplay.org/?q=%5Blimit%283%3B.%5B%5D%29%5D&j=%5B0%2C1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%5D[{Run}]


[[first-last-nth-2]]
[reftext="`first(expr)`, `last(expr)`, `nth(n; expr)`"]
==== +first(expr)+, +last(expr)+, +nth(n; expr)+
{TOC}

The `+first(expr)+` and `+last(expr)+` functions extract the first and
last values from `+expr+`, respectively.

The `+nth(n; expr)+` function extracts the nth value output by `+expr+`.
Note that `+nth(n; expr)+` doesn't support negative values of `+n+`.

####Example

[[example98]]
[cols=",",]
|===
|Command |jq '[first(range(.)), last(range(.)), nth(./2; range(.))]'

|Input |10

|Output |[0,9,5]
|===
link:https://jqplay.org/?q=%5Bfirst%28range%28.%29%29%2C%20last%28range%28.%29%29%2C%20nth%28./2%3B%20range%28.%29%29%5D&j=10[{Run}]


[[first-last-nth-1]]
[reftext="`first`, `last`, `nth(n)`"]
==== +first+, +last+, +nth(n)+
{TOC}

The `+first+` and `+last+` functions extract the first and last values
from any array at `+.+`.

The `+nth(n)+` function extracts the nth value of any array at `+.+`.

####Example

[[example99]]
[cols=",",]
|===
|Command |jq '[range(.)]\|[first, last, nth(5)]'

|Input |10

|Output |[0,9,5]
|===
link:https://jqplay.org/?q=%5Brange%28.%29%5D%7C%5Bfirst%2C%20last%2C%20nth%285%29%5D&j=10[{Run}]


[[reduce]]
[reftext="`reduce`"]
==== +reduce+
{TOC}

The `+reduce+` syntax allows you to combine all of the results of an
expression by accumulating them into a single answer. The form is
`+reduce EXP as $var (INIT; UPDATE)+`. As an example, we'll pass
`+[1,2,3]+` to this expression:

....
reduce .[] as $item (0; . + $item)
....

For each result that `+.[]+` produces, `+. + $item+` is run to
accumulate a running total, starting from 0 as the input value. In this
example, `+.[]+` produces the results `+1+`, `+2+`, and `+3+`, so the
effect is similar to running something like this:

....
0 | 1 as $item | . + $item |
    2 as $item | . + $item |
    3 as $item | . + $item
....

####Examples

[[example100]]
[cols=",",]
|===
|Command |jq 'reduce .[] as $item (0; . + $item)'

|Input |[1,2,3,4,5]

|Output |15
|===
link:https://jqplay.org/?q=reduce%20.%5B%5D%20as%20%24item%20%280%3B%20.%20%2B%20%24item%29&j=%5B1%2C2%2C3%2C4%2C5%5D[{Run}]


[cols=",",]
|===
|Command |jq 'reduce .[] as [$i,$j] (0; . + $i * $j)'

|Input |[[1,2],[3,4],[5,6]]

|Output |44
|===
link:https://jqplay.org/?q=reduce%20.%5B%5D%20as%20%5B%24i%2C%24j%5D%20%280%3B%20.%20%2B%20%24i%20%2A%20%24j%29&j=%5B%5B1%2C2%5D%2C%5B3%2C4%5D%2C%5B5%2C6%5D%5D[{Run}]


[cols=",",]
|===
|Command |jq 'reduce .[] as {$x,$y} (null; .x += $x \| .y += [$y])'

|Input |[{"x":"a","y":1},{"x":"b","y":2},{"x":"c","y":3}]

|Output |{"x":"abc","y":[1,2,3]}
|===
link:https://jqplay.org/?q=reduce%20.%5B%5D%20as%20%7B%24x%2C%24y%7D%20%28null%3B%20.x%20%2B%3D%20%24x%20%7C%20.y%20%2B%3D%20%5B%24y%5D%29&j=%5B%7B%22x%22%3A%22a%22%2C%22y%22%3A1%7D%2C%7B%22x%22%3A%22b%22%2C%22y%22%3A2%7D%2C%7B%22x%22%3A%22c%22%2C%22y%22%3A3%7D%5D[{Run}]


[[foreach]]
[reftext="`foreach`"]
==== +foreach+
{TOC}

The `+foreach+` syntax is similar to `+reduce+`, but intended to allow
the construction of `+limit+` and reducers that produce intermediate
results.

The form is `+foreach EXP as $var (INIT; UPDATE; EXTRACT)+`. As an
example, we'll pass `+[1,2,3]+` to this expression:

....
foreach .[] as $item (0; . + $item; [$item, . * 2])
....

Like the `+reduce+` syntax, `+. + $item+` is run for each result that
`+.[]+` produces, but `+[$item, . * 2]+` is run for each intermediate
values. In this example, since the intermediate values are `+1+`, `+3+`,
and `+6+`, the `+foreach+` expression produces `+[1,2]+`, `+[2,6]+`, and
`+[3,12]+`. So the effect is similar to running something like this:

....
0 | 1 as $item | . + $item | [$item, . * 2],
    2 as $item | . + $item | [$item, . * 2],
    3 as $item | . + $item | [$item, . * 2]
....

When `+EXTRACT+` is omitted, the identity filter is used. That is, it
outputs the intermediate values as they are.

####Examples

[[example101]]
[cols=",",]
|===
|Command |jq 'foreach .[] as $item (0; . + $item)'

|Input |[1,2,3,4,5]

|Output |1        +
         3        +
         6        +
         10       +
         15
|===
link:https://jqplay.org/?q=foreach%20.%5B%5D%20as%20%24item%20%280%3B%20.%20%2B%20%24item%29&j=%5B1%2C2%2C3%2C4%2C5%5D[{Run}]


[cols=",",]
|===
|Command |jq 'foreach .[] as $item (0; . + $item; [$item, . * 2])'

|Input |[1,2,3,4,5]

|Output |[1,2]    +
         [2,6]    +
         [3,12]   +
         [4,20]   +
         [5,30]
|===
link:https://jqplay.org/?q=foreach%20.%5B%5D%20as%20%24item%20%280%3B%20.%20%2B%20%24item%3B%20%5B%24item%2C%20.%20%2A%202%5D%29&j=%5B1%2C2%2C3%2C4%2C5%5D[{Run}]


[cols=",",]
|===
|Command |jq 'foreach .[] as $item (0; . + 1; {index: ., $item})'

|Input |["foo", "bar", "baz"]

|Output |{"index":1,"item":"foo"} +
         {"index":2,"item":"bar"} +
         {"index":3,"item":"baz"}
|===
link:https://jqplay.org/?q=foreach%20.%5B%5D%20as%20%24item%20%280%3B%20.%20%2B%201%3B%20%7Bindex%3A%20.%2C%20%24item%7D%29&j=%5B%22foo%22%2C%20%22bar%22%2C%20%22baz%22%5D[{Run}]


[[recursion]]
==== Recursion
{TOC}

As described above, `+recurse+` uses recursion, and any jq function can
be recursive. The `+while+` builtin is also implemented in terms of
recursion.

Tail calls are optimized whenever the expression to the left of the
recursive call outputs its last value. In practice this means that the
expression to the left of the recursive call should not produce more
than one output for each input.

For example:

....
def recurse(f): def r: ., (f | select(. != null) | r); r;

def while(cond; update):
  def _while:
    if cond then ., (update | _while) else empty end;
  _while;

def repeat(exp):
  def _repeat:
    exp, _repeat;
  _repeat;
....

[[generators-and-iterators]]
==== Generators and iterators
{TOC}

Some jq operators and functions are actually generators in that they can
produce zero, one, or more values for each input, just as one might
expect in other programming languages that have generators. For example,
`+.[]+` generates all the values in its input (which must be an array or
an object), `+range(0; 10)+` generates the integers between 0 and 10,
and so on.

Even the comma operator is a generator, generating first the values
generated by the expression to the left of the comma, then the values
generated by the expression on the right of the comma.

The `+empty+` builtin is the generator that produces zero outputs. The
`+empty+` builtin backtracks to the preceding generator expression.

All jq functions can be generators just by using builtin generators. It
is also possible to construct new generators using only recursion and
the comma operator. If recursive calls are "in tail position" then the
generator will be efficient. In the example below the recursive call by
`+_range+` to itself is in tail position. The example shows off three
advanced topics: tail recursion, generator construction, and
sub-functions.

####Examples

[[example102]]
[cols=",",]
|===
|Command |jq 'def range(init; upto; by): def _range: if (by > 0 and . <
upto) or (by < 0 and . > upto) then ., ((.+by)\|_range) else . end; if
by == 0 then init else init\|_range end \| select((by > 0 and . < upto)
or (by < 0 and . > upto)); range(0; 10; 3)'

|Input |null

|Output |0      +
         3      +
         6      +
         9
|===
link:https://jqplay.org/?q=def%20range%28init%3B%20upto%3B%20by%29%3A%20def%20_range%3A%20if%20%28by%20%3E%200%20and%20.%20%3C%20upto%29%20or%20%28by%20%3C%200%20and%20.%20%3E%20upto%29%20then%20.%2C%20%28%28.%2Bby%29%7C_range%29%20else%20.%20end%3B%20if%20by%20%3D%3D%200%20then%20init%20else%20init%7C_range%20end%20%7C%20select%28%28by%20%3E%200%20and%20.%20%3C%20upto%29%20or%20%28by%20%3C%200%20and%20.%20%3E%20upto%29%29%3B%20range%280%3B%2010%3B%203%29&j=null[{Run}]


[cols=",",]
|===
|Command |jq 'def while(cond; update): def _while: if cond then .,
(update \| _while) else empty end; _while; [while(.<100; .*2)]'

|Input |1

|Output |[1,2,4,8,16,32,64]
|===
link:https://jqplay.org/?q=def%20while%28cond%3B%20update%29%3A%20def%20_while%3A%20if%20cond%20then%20.%2C%20%28update%20%7C%20_while%29%20else%20empty%20end%3B%20_while%3B%20%5Bwhile%28.%3C100%3B%20.%2A2%29%5D&j=1[{Run}]


[[math]]
=== Math
{TOC}

jq currently only has IEEE754 double-precision (64-bit) floating point
number support.

Besides simple arithmetic operators such as `+++`, jq also has most
standard math functions from the C math library. C math functions that
take a single input argument (e.g., `+sin()+`) are available as
zero-argument jq functions. C math functions that take two input
arguments (e.g., `+pow()+`) are available as two-argument jq functions
that ignore `+.+`. C math functions that take three input arguments are
available as three-argument jq functions that ignore `+.+`.

Availability of standard math functions depends on the availability of
the corresponding math functions in your operating system and C math
library. Unavailable math functions will be defined but will raise an
error.

One-input C math functions: `+acos+` `+acosh+` `+asin+` `+asinh+`
`+atan+` `+atanh+` `+cbrt+` `+ceil+` `+cos+` `+cosh+` `+erf+` `+erfc+`
`+exp+` `+exp10+` `+exp2+` `+expm1+` `+fabs+` `+floor+` `+gamma+` `+j0+`
`+j1+` `+lgamma+` `+log+` `+log10+` `+log1p+` `+log2+` `+logb+`
`+nearbyint+` `+pow10+` `+rint+` `+round+` `+significand+` `+sin+`
`+sinh+` `+sqrt+` `+tan+` `+tanh+` `+tgamma+` `+trunc+` `+y0+` `+y1+`.

Two-input C math functions: `+atan2+` `+copysign+` `+drem+` `+fdim+`
`+fmax+` `+fmin+` `+fmod+` `+frexp+` `+hypot+` `+jn+` `+ldexp+` `+modf+`
`+nextafter+` `+nexttoward+` `+pow+` `+remainder+` `+scalb+` `+scalbln+`
`+yn+`.

Three-input C math functions: `+fma+`.

See your system's manual for more information on each of these.

[[io]]
=== I/O
{TOC}

  ** <<input>>
  ** <<inputs>>
  ** <<debug>>
  ** <<stderr>>
  ** <<input_filename>>
  ** <<input_line_number>>

At this time jq has minimal support for I/O, mostly in the form of
control over when inputs are read. Two builtins functions are provided
for this, `+input+` and `+inputs+`, that read from the same sources
(e.g., `+stdin+`, files named on the command-line) as jq itself. These
two builtins, and jq's own reading actions, can be interleaved with each
other. They are commonly used in combination with the null input option
`+-n+` to prevent one input from being read implicitly.

Two builtins provide minimal output capabilities, `+debug+`, and
`+stderr+`. (Recall that a jq program's output values are always output
as JSON texts on `+stdout+`.) The `+debug+` builtin can have
application-specific behavior, such as for executables that use the
libjq C API but aren't the jq executable itself. The `+stderr+` builtin
outputs its input in raw mode to stder with no additional decoration,
not even a newline.

Most jq builtins are referentially transparent, and yield constant and
repeatable value streams when applied to constant inputs. This is not
true of I/O builtins.

[[input]]
[reftext="`input`"]
==== +input+
{TOC}

Outputs one new input.

WARNING: 文档原文这句话的 otherwise 比较费解。好像在说“`input` 通常需要和命令行参数
`-n` 一起使用，否则第一个实体数据会丢失。”。实事上，<<input>> 一般确实是需要 `-n` 选项。
如果使用它，表示使用 `null` 作为单一输入值，因此 jq 脚本中的第一个输入 <<identity>>
失去其输入的数据。但是 <<input>> 过滤器可以正常读取数据。

Note that when using `+input+` it is generally be necessary to invoke jq
with the `+-n+` command-line option, otherwise the first entity will be
lost.

....
echo 1 2 3 4 | jq '[., input]' # [1,2] [3,4]
echo 1 2 3 4 | jq -n -c '[., input]' # [1,2] [3,4] # [null,1]
....



[[inputs]]
[reftext="`inputs`"]
==== +inputs+
{TOC}

Outputs all remaining inputs, one by one.

This is primarily useful for reductions over a program's inputs. Note
that when using `+inputs+` it is generally necessary to invoke jq with
the `+-n+` command-line option, otherwise the first entity will be lost.

....
echo 1 2 3 | jq -n 'reduce inputs as $i (0; . + $i)' # 6
....

[[debug]]
[reftext="`debug`, `debug(msgs)`"]
==== +debug+, +debug(msgs)+
{TOC}

These two filters are like `+.+` but have as a side-effect the
production of one or more messages on stderr.

The message produced by the `+debug+` filter has the form

....
["DEBUG:",<input-value>]
....

where `+<input-value>+` is a compact rendition of the input value. This
format may change in the future.

The `+debug(msgs)+` filter is defined as `+(msgs | debug | empty), .+`
thus allowing great flexibility in the content of the message, while
also allowing multi-line debugging statements to be created.

For example, the expression:

....
1 as $x | 2 | debug("Entering function foo with $x == \($x)", .) | (.+1)
....

would produce the value 3 but with the following two lines being written
to stderr:

....
["DEBUG:","Entering function foo with $x == 1"]
["DEBUG:",2]
....

[[stderr]]
[reftext="`stderr`"]
==== +stderr+
{TOC}

Prints its input in raw and compact mode to stderr with no additional
decoration, not even a newline.

[[input_filename]]
[reftext="`input_filename`"]
==== +input_filename+
{TOC}

Returns the name of the file whose input is currently being filtered.
Note that this will not work well unless jq is running in a UTF-8
locale.

[[input_line_number]]
[reftext="`input_line_number`"]
==== +input_line_number+
{TOC}

Returns the line number of the input currently being filtered.

[[streaming]]
=== Streaming
{TOC}

  ** <<truncate_stream>>
  ** <<fromstream>>
  ** <<tostream>>

With the `+--stream+` option jq can parse input texts in a streaming
fashion, allowing jq programs to start processing large JSON texts
immediately rather than after the parse completes. If you have a single
JSON text that is 1GB in size, streaming it will allow you to process it
much more quickly.

However, streaming isn't easy to deal with as the jq program will have
`+[<path>, <leaf-value>]+` (and a few other forms) as inputs.

Several builtins are provided to make handling streams easier.

The examples below use the streamed form of `+[0,[1]]+`, which is
`+[[0],0],[[1,0],1],[[1,0]],[[1]]+`.

Streaming forms include `+[<path>, <leaf-value>]+` (to indicate any
scalar value, empty array, or empty object), and `+[<path>]+` (to
indicate the end of an array or object). Future versions of jq run with
`+--stream+` and `+--seq+` may output additional forms such as
`+["error message"]+` when an input text fails to parse.

[[truncate_stream]]
[reftext="`truncate_stream(stream_expression)`"]
==== +truncate_stream(stream_expression)+
{TOC}

Consumes a number as input and truncates the corresponding number of
path elements from the left of the outputs of the given streaming
expression.

####Example

[[example103]]
[cols=",",]
|===
|Command |jq 'truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]])'

|Input |1

|Output |[[0],2]    +
         [[0]]
|===
link:https://jqplay.org/?q=truncate_stream%28%5B%5B0%5D%2C1%5D%2C%5B%5B1%2C0%5D%2C2%5D%2C%5B%5B1%2C0%5D%5D%2C%5B%5B1%5D%5D%29&j=1[{Run}]


[[fromstream]]
[reftext="`fromstream(stream_expression)`"]
==== +fromstream(stream_expression)+
{TOC}

Outputs values corresponding to the stream expression's outputs.

####Example

[[example104]]
[cols=",",]
|===
|Command |jq
'fromstream(1\|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]]))'

|Input |null

|Output |[2]
|===
link:https://jqplay.org/?q=fromstream%281%7Ctruncate_stream%28%5B%5B0%5D%2C1%5D%2C%5B%5B1%2C0%5D%2C2%5D%2C%5B%5B1%2C0%5D%5D%2C%5B%5B1%5D%5D%29%29&j=null[{Run}]


[[tostream]]
[reftext="`tostream`"]
==== +tostream+
{TOC}

The `+tostream+` builtin outputs the streamed form of its input.

####Example

[[example105]]
[cols=",",]
|===
|Command |jq '. as $dot\|fromstream($dot\|tostream)\|.==$dot'

|Input |[0,[1,{"a":1},{"b":2}]]

|Output |true
|===


[[assignment]]
=== Assignment
{TOC}

  ** <<update-assignment>>
  ** <<arithmetic-update-assignment>>
  ** <<plain-assignment>>
  ** <<complex-assignments>>

Assignment works a little differently in jq than in most programming
languages. jq doesn't distinguish between references to and copies of
something - two objects or arrays are either equal or not equal, without
any further notion of being "the same object" or "not the same object".

If an object has two fields which are arrays, `+.foo+` and `+.bar+`, and
you append something to `+.foo+`, then `+.bar+` will not get bigger,
even if you've previously set `+.bar = .foo+`. If you're used to
programming in languages like Python, Java, Ruby, JavaScript, etc. then
you can think of it as though jq does a full deep copy of every object
before it does the assignment (for performance it doesn't actually do
that, but that's the general idea).

This means that it's impossible to build circular values in jq (such as
an array whose first element is itself). This is quite intentional, and
ensures that anything a jq program can produce can be represented in
JSON.

All the assignment operators in jq have path expressions on the
left-hand side (LHS). The right-hand side (RHS) provides values to set
to the paths named by the LHS path expressions.

Values in jq are always immutable. Internally, assignment works by using
a reduction to compute new, replacement values for `+.+` that have had
all the desired assignments applied to `+.+`, then outputting the
modified value. This might be made clear by this example:
`+{a:{b:{c:1}}} | (.a.b|=3), .+`. This will output `+{"a":{"b":3}}+` and
`+{"a":{"b":{"c":1}}}+` because the last sub-expression, `+.+`, sees the
original value, not the modified value.

Most users will want to use modification assignment operators, such as
`+|=+` or `++=+`, rather than `+=+`.

Note that the LHS of assignment operators refers to a value in `+.+`.
Thus `+$var.foo = 1+` won't work as expected (`+$var.foo+` is not a
valid or useful path expression in `+.+`); use `+$var | .foo = 1+`
instead.

Note too that `+.a,.b=0+` does not set `+.a+` and `+.b+`, but
`+(.a,.b)=0+` sets both.

[[update-assignment]]
[reftext="Update-assignment: `|=`"]
==== Update-assignment: +|=+
{TOC}

This is the "update" operator `+|=+`. It takes a filter on the
right-hand side and works out the new value for the property of `+.+`
being assigned to by running the old value through this expression. For
instance, `+(.foo, .bar) |= .+1+` will build an object with the `+foo+`
field set to the input's `+foo+` plus 1, and the `+bar+` field set to
the input's `+bar+` plus 1.

The left-hand side can be any general path expression; see `+path()+`.

Note that the left-hand side of `+|=+` refers to a value in `+.+`. Thus
`+$var.foo |= . + 1+` won't work as expected (`+$var.foo+` is not a
valid or useful path expression in `+.+`); use `+$var | .foo |= . + 1+`
instead.

If the right-hand side outputs no values (i.e., `+empty+`), then the
left-hand side path will be deleted, as with `+del(path)+`.

If the right-hand side outputs multiple values, only the first one will
be used (COMPATIBILITY NOTE: in jq 1.5 and earlier releases, it used to
be that only the last one was used).

####Example

[[example106]]
[cols=",",]
|===
|Command |jq '(..|select(type=="boolean")) |= if . then 1 else 0 end'

|Input |[true,false,[5,true,[true,[false]],false]]

|Output |[1,0,[5,1,[1,[0]],0]]
|===


[[arithmetic-update-assignment]]
[reftext="Arithmetic update-assignment: `+=`, `-=`, `*=`, `/=`, `%=`, `//=`"]
==== Arithmetic update-assignment: ++=+, +-=+, +*=+, +/=+, +%=+, +//=+
{TOC}

jq has a few operators of the form `+a op= b+`, which are all equivalent
to `+a |= . op b+`. So, `++= 1+` can be used to increment values, being
the same as `+|= . + 1+`.

####Example

[[example107]]
[cols=",",]
|===
|Command |jq '.foo += 1'

|Input |{"foo": 42}

|Output |{"foo": 43}
|===


[[plain-assignment]]
[reftext="Plain assignment: `=`"]
==== Plain assignment: +=+
{TOC}

This is the plain assignment operator. Unlike the others, the input to
the right-hand side (RHS) is the same as the input to the left-hand side
(LHS) rather than the value at the LHS path, and all values output by
the RHS will be used (as shown below).

If the RHS of `+=+` produces multiple values, then for each such value
jq will set the paths on the left-hand side to the value and then it
will output the modified `+.+`. For example, `+(.a,.b) = range(2)+`
outputs `+{"a":0,"b":0}+`, then `+{"a":1,"b":1}+`. The "update"
assignment forms (see above) do not do this.

This example should show the difference between `+=+` and `+|=+`:

Provide input `+{"a": {"b": 10}, "b": 20}+` to the programs

....
.a = .b
....

and

....
.a |= .b
....

The former will set the `+a+` field of the input to the `+b+` field of
the input, and produce the output `+{"a": 20, "b": 20}+`. The latter
will set the `+a+` field of the input to the `+a+` field's `+b+` field,
producing `+{"a": 10, "b": 20}+`.

####Examples

[[example108]]
[cols=",",]
|===
|Command |jq '.a = .b'

|Input |{"a": {"b": 10}, "b": 20}

|Output |{"a":20,"b":20}
|===
link:https://jqplay.org/?q=.a%20%3D%20.b&j=%7B%22a%22%3A%20%7B%22b%22%3A%2010%7D%2C%20%22b%22%3A%2020%7D[{Run}]


[cols=",",]
|===
|Command |jq '.a |= .b'

|Input |{"a": {"b": 10}, "b": 20}

|Output |{"a":10,"b":20}
|===
link:https://jqplay.org/?q=.a%20%7C%3D%20.b&j=%7B%22a%22%3A%20%7B%22b%22%3A%2010%7D%2C%20%22b%22%3A%2020%7D[{Run}]


[cols=",",]
|===
|Command |jq '(.a, .b) = range(3)'

|Input |null

|Output |{"a":0,"b":0}  +
         {"a":1,"b":1}  +
         {"a":2,"b":2}
|===


[cols=",",]
|===
|Command |jq '(.a, .b) \|= range(3)'

|Input |null

|Output |{"a":0,"b":0}
|===


[[complex-assignments]]
==== Complex assignments
{TOC}

Lots more things are allowed on the left-hand side of a jq assignment
than in most languages. We've already seen simple field accesses on the
left hand side, and it's no surprise that array accesses work just as
well:

....
.posts[0].title = "JQ Manual"
....

What may come as a surprise is that the expression on the left may
produce multiple results, referring to different points in the input
document:

....
.posts[].comments |= . + ["this is great"]
....

That example appends the string "this is great" to the "comments" array
of each post in the input (where the input is an object with a field
"posts" which is an array of posts).

When jq encounters an assignment like 'a = b', it records the "path"
taken to select a part of the input document while executing a. This
path is then used to find which part of the input to change while
executing the assignment. Any filter may be used on the left-hand side
of an equals - whichever paths it selects from the input will be where
the assignment is performed.

This is a very powerful operation. Suppose we wanted to add a comment to
blog posts, using the same "blog" input above. This time, we only want
to comment on the posts written by "stedolan". We can find those posts
using the "select" function described earlier:

....
.posts[] | select(.author == "stedolan")
....

The paths provided by this operation point to each of the posts that
"stedolan" wrote, and we can comment on each of them in the same way
that we did before:

....
(.posts[] | select(.author == "stedolan") | .comments) |=
    . + ["terrible."]
....



[[modules]]
=== Modules
{TOC}

  ** <<import-relativepathstring-as-name>>
  ** <<include-relativepathstring>>
  ** <<import-relativepathstring-as-dollar_name>>
  ** <<module-metadata>>
  ** <<modulemeta>>

jq has a library/module system. Modules are files whose names end in
`+.jq+`.

Modules imported by a program are searched for in a default search path
(see below). The `+import+` and `+include+` directives allow the
importer to alter this path.

Paths in the search path are subject to various substitutions.

For paths starting with `+~/+`, the user's home directory is substituted
for `+~+`.

For paths starting with `+$ORIGIN/+`, the directory where the jq
executable is located is substituted for `+$ORIGIN+`.

For paths starting with `+./+` or paths that are `+.+`, the path of the
including file is substituted for `+.+`. For top-level programs given on
the command-line, the current directory is used.

Import directives can optionally specify a search path to which the
default is appended.

The default search path is the search path given to the `+-L+`
command-line option, else
`+["~/.jq", "$ORIGIN/../lib/jq", "$ORIGIN/../lib"]+`.

Null and empty string path elements terminate search path processing.

A dependency with relative path `+foo/bar+` would be searched for in
`+foo/bar.jq+` and `+foo/bar/bar.jq+` in the given search path. This is
intended to allow modules to be placed in a directory along with, for
example, version control files, README files, and so on, but also to
allow for single-file modules.

Consecutive components with the same name are not allowed to avoid
ambiguities (e.g., `+foo/foo+`).

For example, with `+-L$HOME/.jq+` a module `+foo+` can be found in
`+$HOME/.jq/foo.jq+` and `+$HOME/.jq/foo/foo.jq+`.

If `+$HOME/.jq+` is a file, it is sourced into the main program.

[[import-relativepathstring-as-name]]
[reftext="`import RelativePathString as NAME [<metadata>];`"]
==== +import RelativePathString as NAME [<metadata>];+
{TOC}

Imports a module found at the given path relative to a directory in a
search path. A `+.jq+` suffix will be added to the relative path string.
The module's symbols are prefixed with `+NAME::+`.

The optional metadata must be a constant jq expression. It should be an
object with keys like `+homepage+` and so on. At this time jq only uses
the `+search+` key/value of the metadata. The metadata is also made
available to users via the `+modulemeta+` builtin.

The `+search+` key in the metadata, if present, should have a string or
array value (array of strings); this is the search path to be prefixed
to the top-level search path.

[[include-relativepathstring]]
[reftext="`include RelativePathString [<metadata>];`"]
==== +include RelativePathString [<metadata>];+
{TOC}

Imports a module found at the given path relative to a directory in a
search path as if it were included in place. A `+.jq+` suffix will be
added to the relative path string. The module's symbols are imported
into the caller's namespace as if the module's content had been included
directly.

The optional metadata must be a constant jq expression. It should be an
object with keys like `+homepage+` and so on. At this time jq only uses
the `+search+` key/value of the metadata. The metadata is also made
available to users via the `+modulemeta+` builtin.

[[import-relativepathstring-as-dollar_name]]
[reftext="`import RelativePathString as $NAME [<metadata>];`"]
==== +import RelativePathString as $NAME [<metadata>];+
{TOC}

Imports a JSON file found at the given path relative to a directory in a
search path. A `+.json+` suffix will be added to the relative path
string. The file's data will be available as `+$NAME::NAME+`.

The optional metadata must be a constant jq expression. It should be an
object with keys like `+homepage+` and so on. At this time jq only uses
the `+search+` key/value of the metadata. The metadata is also made
available to users via the `+modulemeta+` builtin.

The `+search+` key in the metadata, if present, should have a string or
array value (array of strings); this is the search path to be prefixed
to the top-level search path.

[[module-metadata]]
[reftext="`module <metadata>;`"]
==== +module <metadata>;+
{TOC}

This directive is entirely optional. It's not required for proper
operation. It serves only the purpose of providing metadata that can be
read with the `+modulemeta+` builtin.

The metadata must be a constant jq expression. It should be an object
with keys like `+homepage+`. At this time jq doesn't use this metadata,
but it is made available to users via the `+modulemeta+` builtin.

[[modulemeta]]
[reftext="`modulemeta`"]
==== +modulemeta+
{TOC}

Takes a module name as input and outputs the module's metadata as an
object, with the module's imports (including metadata) as an array value
for the `+deps+` key and the module's defined functions as an array
value for the `+defs+` key.

Programs can use this to query a module's metadata, which they could
then use to, for example, search for, download, and install missing
dependencies.

[[colors]]
=== Colors
{TOC}

To configure alternative colors just set the `+JQ_COLORS+` environment
variable to colon-delimited list of partial terminal escape sequences
like `+"1;31"+`, in this order:

* color for `+null+`
* color for `+false+`
* color for `+true+`
* color for numbers
* color for strings
* color for arrays
* color for objects
* color for object keys

The default color scheme is the same as setting
`+JQ_COLORS="0;90:0;37:0;37:0;37:0;32:1;37:1;37:1;34"+`.

This is not a manual for VT100/ANSI escapes. However, each of these
color specifications should consist of two numbers separated by a
semi-colon, where the first number is one of these:

* 1 (bright)
* 2 (dim)
* 4 (underscore)
* 5 (blink)
* 7 (reverse)
* 8 (hidden)

and the second is one of these:

* 30 (black)
* 31 (red)
* 32 (green)
* 33 (yellow)
* 34 (blue)
* 35 (magenta)
* 36 (cyan)
* 37 (white)

[[structured_text_tools]]
== Structured text tools
{TOC}

The following is a list of text-based file formats and command-line
tools for manipulating each.

=== Contents

* link:#awk-like[awk-like]
** link:#awk[awk]
** link:#posix-commands[POSIX commands]
** link:#sql-based-tools[SQL-based tools]
** link:#other-tools[Other tools]
* link:#csv[CSV]
* link:#html[HTML]
* link:#json[JSON]
* link:#toml[TOML]
* link:#xml[XML]
* link:#yaml[YAML]
* link:#configuration-files[Configuration files]
** link:#env[.env]
** link:#etchosts[/etc/hosts]
** link:#ini[INI]
** link:#multiple-formats[Multiple formats]
* link:#log-files[Log files]
* link:#multiformat-tools[Multiformat tools]
* link:#templating-for-structured-text[Templating for structured text]
* link:#extra-interactive-tuis[Extra: interactive TUIs]
* link:#extra-clis-for-single-file-databases[Extra: CLIs for single-file databases]
* link:#license[License]
* link:#disclosure[Disclosure]

=== awk-like

Tools that work with lines of fields separated by delimiters but do not
necessarily support
https://en.wikipedia.org/wiki/Comma-separated_values#Basic_rules[CSV
field quoting].

==== awk

AWK/awk is a programming language and a POSIX-standard command-line
tool. (You will sometimes see "`awk`" used for the tool and "`AWK`" for
the language. This document follows this convention. GNU Awk uses
"`Awk`".) If you run Linux, macOS, or a BSD, you almost certainly have
it installed. See below for Windows.

* If you already know how to program, the nawk
https://www.freebsd.org/cgi/man.cgi?query=nawk&sektion=1[man page] is a
great way to learn AWK quickly. What you learn from it will apply to
other implementations on different platforms. Read it first if you feel
overwhelmed by the sheer size of the
https://www.gnu.org/software/gawk/manual/gawk.html[GNU Awk manual].
* https://web.archive.org/web/20160505033644/http://awk.info/[awk.info
archive] *—* an extensive resource on Awk.
* https://www.thegeekstuff.com/2011/06/awk-nawk-gawk/["`AWK Vs NAWK Vs
GAWK`"] *—* a comparison of features present in different
implementations.
* https://frippery.org/busybox/[busybox-w32] includes a full
implementation of POSIX awk and other tools like `+sed+` in a single
Windows executable.
* https://github.com/ezrosent/frawk[frawk] is a Rust implementation of a
language partially compatible with AWK that supports
https://github.com/ezrosent/frawk/blob/master/info/parallelism.md[parallelism]
and CSV input and output.
* https://sourceforge.net/projects/ezwinports/files/[GNU Awk 5 binaries
for Windows] by
https://www.gnu.org/software/emacs/manual/html_node/efaq-w32/EZWinPorts.html[EZWinPorts].
* https://github.com/benhoyt/goawk[GoAWK] is a cross-platform
implementation of awk with added support for CSV. The project provides
binaries for many platforms, including Windows.

==== POSIX commands

* `+comm+` *—* Select the lines common to two sorted files or the lines
contained in only one of them. (Manual: `+man 1 comm+` on your system,
https://linux.die.net/man/1/comm[GNU],
https://www.freebsd.org/cgi/man.cgi?query=comm&sektion=1[FreeBSD].)
* `+cut+` *—* Select portions of each line in one or more files.
(Manual: `+man 1 cut+`, https://linux.die.net/man/1/cut[GNU],
https://www.freebsd.org/cgi/man.cgi?query=cut&sektion=1[FreeBSD].)
* `+grep+` *—* Select the lines that match or do not match a pattern
from one or more files. (Manual: `+man 1 grep+`,
https://linux.die.net/man/1/grep[GNU],
https://www.freebsd.org/cgi/man.cgi?query=grep&sektion=1[FreeBSD].)
* `+join+` *—* Take two files sorted by a common field and join their
lines on the value of that field. Lines with values that do not appear
in the other file are discarded. (Manual: `+man 1 join+`,
https://linux.die.net/man/1/join[GNU],
https://www.freebsd.org/cgi/man.cgi?query=join&sektion=1[FreeBSD].)
* `+paste+` *—* Combine several consecutive lines in a text file into
one. (Manual: `+man 1 paste+`, https://linux.die.net/man/1/paste[GNU],
https://www.freebsd.org/cgi/man.cgi?query=paste&sektion=1[FreeBSD].)
* `+sort+` *—* Sort lines by key fields. (Manual: `+man 1 sort+`,
https://linux.die.net/man/1/sort[GNU],
https://www.freebsd.org/cgi/man.cgi?query=sort&sektion=1[FreeBSD].)
* `+uniq+` *—* Find or remove repeated lines. (Manual: `+man 1 uniq+`,
https://linux.die.net/man/1/uniq[GNU],
https://www.freebsd.org/cgi/man.cgi?query=uniq&sektion=1[FreeBSD].)

==== Other tools

* https://github.com/dbro/csvquote[csvquote] *—* Transform CSV to and
from a format processable with link:#awk-like[awk-like] tools.
* https://www.gnu.org/software/datamash/[GNU datamash] *—* Perform
statistical operations on text input.
* https://github.com/gelisam/hawk[Hawk] *—* Transform text from the
command-line using Haskell expressions.
* https://github.com/hauntsaninja/pyp[pyp] *—* Transform input (as text
lines or as a whole) using Python code with automatic module imports.
Can generate a Python script equivalent to its invocation. In Python
3.11 or later supports TOML through
https://docs.python.org/3.11/library/tomllib.html[tomllib].
* https://github.com/dflemstr/rq[rq] *—* Convert between Apache Avro,
CBOR, CSV, JSON, MessagePack, Protocol Buffers, TOML, YAML, and
awk-style plain text.
* https://github.com/dkogan/vnlog/[vnlog] *—* Process labelled tabular
ASCII data using normal UNIX tools. Can plot data with gnuplot.

=== CSV

CSV, TSV, and other delimiter-separated value formats. Tools belong on
this list if they support
https://en.wikipedia.org/wiki/Comma-separated_values#Basic_rules[field
quoting].

* https://github.com/mslusarz/csv-nix-tools[csv-nix-tools] *—* List *nix
system information such as environment variables, files, processes,
network connections, users as CSV. Manipulate and pretty-print CSV.
Execute CSV rows as commands.
* https://github.com/dbohdan/csv2html[csv2html] *—* Convert CSV to HTML
tables.
* https://github.com/pstaender/csv2md[csv2md] *—* Convert CSV to
Markdown tables.
* https://github.com/pereorga/csvfaker[csvfaker] *—* Generate CSV files
with fake data. Supports different types of fake data in different
locales: names, cities, jobs, email addresses, and others.
* https://github.com/jheusser/csvfix[csvfix] *—* A multitool. Compare,
filter, normalize, split, and validate CSV files. Reorder, remove,
split, and merge fields. Convert data between fixed-width, multi-line,
XML, and DSV format. Generate SQL statements. (Unofficial mirror.)
* https://github.com/wireservice/csvkit[csvkit] *—* csvkit is a suite of
command-line tools for converting to and working with CSV: convert,
clean, cut, grep, join, sort, stack, format, render, query, analyze,
etc.
* https://github.com/dbro/csvquote[csvquote] *—* Transform CSV to and
from a format processable with link:#awk-like[awk-like] tools.
* https://github.com/shenwei356/csvtk[csvtk] *—* Search, sample, cut,
join, transpose, and sort CSV/TSV files. Rename columns. Replace fields
and generate new fiends from existing fields. Plot data as vector or
raster histograms and box, line, and scatter plots. Convert CSV to
Markdown. Convert XLSX to CSV. Split XLSX sheets.
* https://github.com/vividvilla/csvtotable[CSVtoTable] *—* Convert CSV
to a searchable and sortable HTML table.
* https://github.com/TomWright/dasel[dasel] *—* Query and update data
structures from the command line. Comparable to jq/yq but supports CSV,
JSON, TOML, YAML, and XML. Static binaries available for releases.
* https://github.com/eBay/tsv-utils[eBay’s TSV utilities] *—* Filtering,
statistics, sampling, joins and other operations on TSV files. High
performance, especially good for large datasets. Written in D.
* http://kantord.github.io/emuto/[emuto] *—* CLI tool similar to jq.
Create and manipulate CSV, TSV, and JSON. Can be compiled to JavaScript.
* https://github.com/ezrosent/frawk[frawk] *—* A Rust implementation of
a language partially compatible with AWK that supports
https://github.com/ezrosent/frawk/blob/master/info/parallelism.md[parallelism]
and CSV input and output. frawk is an awk-derived language with a CSV
mode for input and for output.
* https://github.com/benhoyt/goawk[GoAWK] *—* A cross-platform
implementation of awk with added support for CSV. The project provides
binaries for many platforms, including Windows. GoAWK is an awk
implementation that adds a CSV mode for input and for output.
* https://github.com/trailofbits/graphtage[Graphtage] *—* Compare and
merge tree-like structures semantically. Supports JSON, JSON5, XML,
HTML, YAML, and CSV. Can be used as a Python library.
* https://github.com/sgreben/jp[jp (sgreben)] *—* Plot JSON and CSV data
in the terminal. Supports different kinds of plots: bar charts, line
charts, scatter plots, histograms, and heatmaps.
* https://github.com/python-mario/mario[Mario] *—* Manipulate and
convert between CSV, JSON, YAML, TOML, and XML with Python code.
* https://github.com/nysol/mcmd[MCMD (M-Command)] *—* Select, sample,
cut, join, sort, reformat, and generate CSV files. Contains a large set
of commands.
* https://github.com/johnkerl/miller[Miller] *—* `+sed+`, `+awk+`,
`+cut+`, `+join+` and `+sort+` for name-indexed data such as CSV and
tabular JSON.
* https://github.com/nushell/nushell[Nushell] *—* A command shell. Can
natively https://www.nushell.sh/book/loading_data.html[load data] from
CSV, INI, JSON, TOML, TSV, XML, YAML, and other formats.
* https://github.com/alecthomas/pawk[pawk] *—* Process text with
AWK-like patterns, but Python code.
* https://github.com/jqnatividad/qsv[qsv] *—* Index, slice, analyze,
split, and join CSV files. A fork of xsv that adds subcommands and
features.
* https://github.com/WizardMac/ReadStat[ReadStat] *—* Convert statistics
package datasets between SAS (SAS7BDAT, XPORT), SPSS (POR, SAV, ZSAV),
and Stata (DTA). Convert those formats to CSV and XLSX. Can be used as a
C library with bindings for Julia, Python, and R.
* https://github.com/turicas/rows[rows] *—* A Python library with a
http://turicas.info/rows/cli/[CLI]. Convert between a number of
http://turicas.info/rows/plugins/[file formats] for tabular data: CSV,
XLS, XLSX, ODS, and others. Query the data (via SQLite). Combine tables.
Generate schemas.
* https://github.com/dflemstr/rq[rq] *—* Convert between Apache Avro,
CBOR, CSV, JSON, MessagePack, Protocol Buffers, TOML, YAML, and
awk-style plain text.
* https://github.com/faradayio/scrubcsv[scrubcsv] *—* Remove bad lines
from a CSV file and normalize the rest. Written in Rust.
* https://github.com/daq-tools/skeem[Skeem] *—* Infer SQL DDL statements
from tabular data. Supports CSV, JSON, JSON Lines, ODS, XLSX, and other
formats.
* http://tkatchev.bitbucket.io/tab/[tab] *—* A non-Turing-complete
statically typed programming language for data processing. An
alternative to awk.
* https://github.com/greymd/teip[teip] *—* Select fields, character
ranges, or regular expression matches from standard input. Replace them
with the output of a command.
* https://github.com/codechenx/tv[tv] *—* View delimited files in the
terminal.
* https://github.com/BurntSushi/xsv[xsv] *—* Index, slice, analyze,
split, and join CSV files.
* https://github.com/liquidaty/zsv[zsv] *—* Slice, combine, reformat,
flatten/unflatten CSV (TSV, DSV) files. Query them with SQL and jq
filters. Convert between them, JSON, and SQLite 3. Also a C library.

[[sql_based_tools]]
==== SQL-based tools

* https://github.com/agershun/alasql[AlaSQL CLI]
** *Documentation link:* https://github.com/agershun/alasql/wiki/AlaSQL-CLI
** *Programming language:* JavaScript
** *Database:* AlaSQL
** *Column names from header row:* yes, optional
** *Custom character encoding:* no
** *Custom input field separator:* yes, string
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes, JavaScript
** *Input formats:* lines, DSV, XLS, XLSX, HTML tables, JSON
** *Output formats:* lines, DSV, XLS, XLSX, HTML tables, JSON
** *Custom table names:* yes
** *Custom column names:* yes
** *Keep database file:* n/a
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* yes, can create custom table then import into it
** *SQL dump:* yes
** *Other:*
* https://github.com/mithrandie/csvq[csvq]
** *Documentation link:* https://mithrandie.github.io/csvq/reference
** *Programming language:* Go
** *Database:* custom SQL interpreter
** *Column names from header row:* yes, optional
** *Custom character encoding:* yes, input and output
** *Custom input field separator:* yes, character
** *Custom input record separator:* no
** *Custom output field separator:* yes
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes, Go
** *Input formats:* CSV, TSV, LTSV, fixed-width, JSON
** *Output formats:* CSV, TSV, LTSV, fixed-width, JSON, Markdown-style
table, Org-mode, ASCII table
** *Custom table names:* yes
** *Custom column names:* yes
** *Keep database file:* n/a
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* yes, ALTER TABLE
** *SQL dump:* no
** *Other:*
* https://github.com/wireservice/csvkit[csvsql]
** *Documentation link:* http://csvkit.readthedocs.io/en/latest/
** *Programming language:* Python
** *Database:* Firebird/MS SQL/MySQL/Oracle/PostgreSQL/SQLite 3/Sybase
** *Column names from header row:* yes, optional
** *Custom character encoding:* yes, input and output
** *Custom input field separator:* yes, string
** *Custom input record separator:* no
** *Custom output field separator:* yes
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes, Python
** *Input formats:* delimited without quotes, DSV, Excel, JSON, SQL,
fixed-width, DBF, and others (separate converters)
** *Output formats:* delimited without quotes, DSV, JSON, Markdown-style
table, SQL (separate converters)
** *Custom table names:* yes
** *Custom column names:* no
** *Keep database file:* yes
** *Skip input fields:* yes (separate tool)
** *Skip input records (lines):* no
** *Merge input fields:* no?
** *Database table customization:* yes, UNIQUE constraints, database
schema name, automatic column datatype or text
** *SQL dump:* yes
** *Other:*
* https://github.com/duckdb/duckdb[DuckDB]
** *Documentation link:* https://duckdb.org/docs/
** *Programming language:* C++
** *Database:* DuckDB
** *Column names from header row:* yes, optional
** *Custom character encoding:* no, only UTF-8
** *Custom input field separator:* yes, string
** *Custom input record separator:* no
** *Custom output field separator:* yes
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes, C, C++, JavaScript, Python, and other
languages
** *Input formats:* DSV, Excel, JSON, SQL, Parquet
** *Output formats:* DSV, Excel, JSON, SQL, Parquet
** *Custom table names:* yes
** *Custom column names:* yes
** *Keep database file:* yes
** *Skip input fields:* yes
** *Skip input records (lines):* yes
** *Merge input fields:* no
** *Database table customization:* yes, `+CREATE TABLE+`
** *SQL dump:* yes
** *Other:*
* https://metacpan.org/release/App-fsql[fsql]
** *Documentation link:*
https://metacpan.org/pod/distribution/App-fsql/bin/fsql
** *Programming language:* Perl
** *Database:* custom SQL interpreter
** *Column names from header row:* yes, always
** *Custom character encoding:* no
** *Custom input field separator:* no
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes, Perl
** *Input formats:* CSV, TSV, LTSV, Perl, JSON, YAML
** *Output formats:* CSV, TSV, LTSV, Perl, JSON, YAML
** *Custom table names:* yes
** *Custom column names:* no
** *Keep database file:* no
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* no
** *SQL dump:* no
** *Other:*
* https://github.com/harelba/q[q]
** *Documentation link:*
https://github.com/harelba/q/blob/master/doc/USAGE.markdown
** *Programming language:* Python
** *Database:* SQLite 3
** *Column names from header row:* yes, optional
** *Custom character encoding:* yes, input and output
** *Custom input field separator:* yes, string
** *Custom input record separator:* no
** *Custom output field separator:* yes
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes, Python
** *Input formats:* delimited without quotes, DSV
** *Output formats:* delimited without quotes, DSV, custom using Python
formatting string
** *Custom table names:* no
** *Custom column names:* no
** *Keep database file:* yes
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* yes, automatic column datatype or text
** *SQL dump:* no
** *Other:*
* https://github.com/mechatroner/RBQL[RBQL]
** *Documentation link:* https://rbql.org/
** *Programming language:* JavaScript, Python
** *Database:* custom SQL interpreter
** *Column names from header row:* yes, optional
** *Custom character encoding:* yes, input
** *Custom input field separator:* yes, string
** *Custom input record separator:* no
** *Custom output field separator:* yes
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes, JavaScript and Python
** *Input formats:* DSV
** *Output formats:* DSV
** *Custom table names:* no
** *Custom column names:* no
** *Keep database file:* n/a
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* no
** *SQL dump:* no
** *Other:*
* https://github.com/turicas/rows[rows]
** *Documentation link:*
http://turicas.info/rows/command-line-interface.html
** *Programming language:* Python
** *Database:* SQLite 3
** *Column names from header row:* yes, always?
** *Custom character encoding:* no
** *Custom input field separator:* no
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* no
** *Use as library:* yes, Python
** *Input formats:* CSV, JSON, XLS, XLSX, ODS, and others
** *Output formats:* CSV, JSON, XLS, XLSX, ODS, and others
** *Custom table names:* no
** *Custom column names:* no
** *Keep database file:* no
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* no
** *SQL dump:* no
** *Other:*
* https://github.com/dbohdan/sqawk[Sqawk]
** *Documentation link:* https://github.com/dbohdan/sqawk#options
** *Programming language:* Tcl
** *Database:* SQLite 3
** *Column names from header row:* yes, optional
** *Custom character encoding:* no
** *Custom input field separator:* yes, regexp, per-file
** *Custom input record separator:* yes, regexp, per-file
** *Custom output field separator:* yes
** *Custom output record separator:* yes
** *JOINs:* yes
** *Use as library:* yes, Tcl
** *Input formats:* delimited without quotes, DSV, Tcl
** *Output formats:* delimited without quotes, CSV, JSON, ASCII/Unicode
table, Tcl
** *Custom table names:* yes
** *Custom column names:* yes
** *Keep database file:* yes
** *Skip input fields:* yes, any
** *Skip input records (lines):* no
** *Merge input fields:* yes, any consecutive
** *Database table customization:* yes, column datatypes
** *SQL dump:* no
** *Other:*
* https://github.com/tjunier/sqawk[sqawk]
** *Documentation link:*
https://github.com/tjunier/sqawk/blob/master/sqawk.1
** *Programming language:* C
** *Database:* SQLite 3
** *Column names from header row:* yes, optional
** *Custom character encoding:* no
** *Custom input field separator:* yes, string, per-file
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* no
** *Input formats:* DSV
** *Output formats:* CSV
** *Custom table names:* yes
** *Custom column names:* no
** *Keep database file:* yes
** *Skip input fields:* no
** *Skip input records (lines):* yes, until regexp matches
** *Merge input fields:* no
** *Database table customization:* yes, primary key, indexes, foreign
key constraints, automatic column datatype or text
** *SQL dump:* yes
** *Other:* chunked mode (read and process only N lines at a time)
* https://github.com/samuel/squawk[Squawk]
** *Documentation link:* <>
** *Programming language:* Python
** *Database:* custom SQL interpreter
** *Column names from header row:* yes, always
** *Custom character encoding:* no
** *Custom input field separator:* no
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* no
** *Use as library:* yes, Python
** *Input formats:* CSV, Apache and Nginx log files
** *Output formats:* table, CSV, JSON
** *Custom table names:* no
** *Custom column names:* no
** *Keep database file:* no
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* no
** *SQL dump:* yes
** *Other:*
* https://github.com/tobimensch/termsql[termsql]
** *Documentation link:* http://tobimensch.github.io/termsql/
** *Programming language:* Python
** *Database:* SQLite 3
** *Column names from header row:* yes, optional
** *Custom character encoding:* no
** *Custom input field separator:* yes, regexp
** *Custom input record separator:* no
** *Custom output field separator:* yes
** *Custom output record separator:* no
** *JOINs:* no
** *Use as library:* no
** *Input formats:* DSV, "`vertical`" DSV (lines as columns)
** *Output formats:* delimited without quotes, CSV, TSV, HTML, SQL, Tcl
** *Custom table names:* yes
** *Custom column names:* yes
** *Keep database file:* yes
** *Skip input fields:* no
** *Skip input records (lines):* yes, N first and M last
** *Merge input fields:* yes, Nth to last
** *Database table customization:* yes, primary key
** *SQL dump:* yes
** *Other:*
* https://github.com/noborus/trdsql[trdsql]
** *Documentation link:* https://github.com/noborus/trdsql#usage
** *Programming language:* Go
** *Database:* MySQL/PostgreSQL/SQLite 3
** *Column names from header row:* yes, optional
** *Custom character encoding:* no
** *Custom input field separator:* yes, string
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* no
** *Input formats:* CSV, LTSV, JSON
** *Output formats:* delimited without quotes, CSV, LTSV, JSON, ASCII
table, Markdown
** *Custom table names:* no
** *Custom column names:* no
** *Keep database file:* yes
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* no
** *SQL dump:* no
** *Other:*
* https://github.com/dinedal/textql[textql]
** *Documentation link:* https://github.com/dinedal/textql#usage
** *Programming language:* Go
** *Database:* SQLite 3
** *Column names from header row:* yes, optional
** *Custom character encoding:* no
** *Custom input field separator:* yes, string
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* no
** *Use as library:* no
** *Input formats:* DSV
** *Output formats:* DSV
** *Custom table names:* no
** *Custom column names:* no
** *Keep database file:* yes
** *Skip input fields:* no
** *Skip input records (lines):* no
** *Merge input fields:* no
** *Database table customization:* no
** *SQL dump:* no
** *Other:*
* https://github.com/Puchaczov/Musoq[Musoq]
** *Documentation link:* https://github.com/Puchaczov/Musoq
** *Programming language:* C#
** *Database:* custom SQL interpreter
** *Column names from header row:* yes, optional
** *Custom character encoding:* no
** *Custom input field separator:* depends on the data source
** *Custom input record separator:* no
** *Custom output field separator:* no
** *Custom output record separator:* no
** *JOINs:* yes
** *Use as library:* yes
** *Input formats:* various
** *Output formats:* CSV, JSON
** *Custom table names:* no
** *Custom column names:* no
** *Keep database file:* no
** *Skip input fields:* yes
** *Skip input records (lines):* no
** *Merge input fields:* yes
** *Database table customization:* no
** *SQL dump:* no
** *Other:*


=== HTML

* https://github.com/trailofbits/graphtage[Graphtage] *—* Compare and
merge tree-like structures semantically. Supports JSON, JSON5, XML,
HTML, YAML, and CSV. Can be used as a Python library.
* https://github.com/danburzo/hred[hred] *—* Query XML and HTML with a
query language based on CSS selectors.
* https://www.w3.org/Tools/HTML-XML-utils/README[html-xml-utils] *—* A
number of simple utilities (like `+hxcopy+`, `+hxpipe+`, `+hxunent+`,
`+hxselect+`) for manipulating HTML and XML files from
https://www.w3.org/[W3C]. Written in C, quite old-fashioned, but still
relevant and maintained.
* https://github.com/mgdm/htmlq[htmlq] *—* Query HTML with CSS
selectors. Can remove elements in the output.
* https://github.com/EricChiang/pup[pup] *—* Query HTML pages with CSS
selectors. Static binaries available for releases. Inspired by
link:#json[jq].
* http://saxon.sourceforge.net/[Saxon] *—* Query XML and HTML data with
https://devhints.io/xpath[XPath].
http://www.saxonica.com/documentation/#!using-xsl[Documentation].
* https://github.com/shinima/temme[Temme] *—* Query HTML with CSS-like
selectors to extract JSON. Temme extends CSS selectors with value
capture patterns.
* http://www.html-tidy.org/[tidy-html5] *—* Validate, fix, and reformat
HTML(5), XHTML, and XML documents. Convert HTML to XHTML.
* https://github.com/plainas/tq[tq] *—* Query HTML with CSS selectors.
* http://www.videlibri.de/xidel.html[Xidel] *—* Query or modify XML and
HTML pages with XPath, XQuery 3, and CSS selectors.
* https://web.archive.org/web/20160719191401/http://ofb.net/~egnor/xml2/[xml2]
*—* Convert XML and HTML to and from flat, greppable lists of
"`path=value`" statements. https://github.com/clone/xml2[Source code
mirror].
* https://github.com/charmparticle/xpe[xpe] *—* Query HTML and XML with
XPath expressions.

=== JSON

* https://github.com/pacha/cels[Cels] *—* Patch JSON, TOML, and YAML
with patches in the same format with some special values. Can be used as
a Python library.
* https://github.com/pastdev/clconf[clconf] *—* Merge multiple config
files and extract values from them using path string. Supports JSON and
YAML. Can be used as a Go library.
* https://github.com/TomWright/dasel[dasel] *—* Query and update data
structures from the command line. Comparable to jq/yq but supports CSV,
JSON, TOML, YAML, and XML. Static binaries available for releases.
* http://kantord.github.io/emuto/[emuto] *—* CLI tool similar to jq.
Create and manipulate CSV, TSV, and JSON. Can be compiled to JavaScript.
* https://github.com/adamritter/fastgron[fastgron] *—* Convert JSON to
and from GRON, a flat, greppable list of `+path=value+` statements. Much
faster than the original gron on large files.
* https://github.com/mgree/ffs[ffs] *—* Mount JSON, TOML, and YAML as a
Unix filesystem.
* https://github.com/antonmedv/fx[fx] *—* Run arbitrary JavaScript on
JSON input. Standalone binaries available.
* https://github.com/itchyny/gojq[gojq] *—* A pure Go implementation of
jq. Supports YAML input and output.
* https://github.com/trailofbits/graphtage[Graphtage] *—* Compare and
merge tree-like structures semantically. Supports JSON, JSON5, XML,
HTML, YAML, and CSV. Can be used as a Python library.
* https://github.com/tomnomnom/gron[gron] *—* Convert JSON to and from
GRON, a flat, greppable list of `+path=value+` statements.
* https://github.com/01mf02/jaq[jaq] *—* A Rust implementation of jq
with minor changes to the language to make it more predictable.
* https://github.com/kellyjonbrazil/jc[JC] *—* Convert the output of
standard command-line tools to JSON.
* https://github.com/kellyjonbrazil/jello[jello] *—* Query JSON and
http://jsonlines.org/[JSON Lines] with Python code. Output the result in
a line-based format suitable for creating Bash arrays. Generate a
grep-able schema.
* https://github.com/borkdude/jet[jet] *—* Convert between JSON, YAML,
Clojure’s https://github.com/edn-format/edn[edn], and
https://github.com/cognitect/transit-format[Transit]. Transform them
with Clojure code.
* https://github.com/blgm/jfq[jfq] *—* Query and transform JSON with the
http://jsonata.org/[JSONata] language.
* https://github.com/tidwall/jj[jj] *—* Query and modify values in JSON
or JSON Lines with a key path.
* https://github.com/chrisdone/jl[jl] *—* Query and manipulate JSON
using a tiny functional language.
* https://github.com/jpmens/jo[jo] *—* Create JSON objects from the
shell.
* https://github.com/jmespath/jp[jp (jmespath)] *—* Query JSON with
http://jmespath.org/[JMESPath].
* https://github.com/sgreben/jp[jp (sgreben)] *—* Plot JSON and CSV data
in the terminal. Supports different kinds of plots: bar charts, line
charts, scatter plots, histograms, and heatmaps.
* https://github.com/rs/jplot[jplot] *—* Plot real-time JSON data in the
terminal (works with terminals supporting graphic rendering).
* http://stedolan.github.io/jq/manual/[jq] *—* Create and manipulate
JSON with a functional (as in "`functional programming`")
https://en.wikipedia.org/wiki/Domain-specific_language[DSL]. Can convert
JSON to other formats.
* https://github.com/cube2222/jql[jql] *—* Create and manipulate JSON
with a Lisp-syntax DSL.
* http://kmkeen.com/jshon/[jshon] *—* Create and manipulate JSON using
https://en.wikipedia.org/wiki/Getopt[getopt]-style command-line options.
* https://github.com/trentm/json[json] *—* Run arbitrary JavaScript on
JSON input.
* https://github.com/evanphx/json-patch[json-patch] *—* Apply
https://tools.ietf.org/html/rfc6902[RFC 6902] JSON Patches to JSON. The
CLI tool is secondary to a Go library that also creates and applies
https://tools.ietf.org/html/rfc7396[RFC 7386] JSON merge patches.
* https://github.com/micha/json-table[json-table] *—* Convert nested
JSON into CSV or TSV for processing in the shell.
* https://docs.python.org/2/library/json.html[json.tool] *—* Validate
and pretty-print JSON. This module is part of the standard library of
Python 2/3 and is likely to be available wherever Python is installed.
(https://docs.python.org/3/library/json.html[Python 3 docs].)
* https://github.com/vi/json2[json2] *—* Convert JSON to and from flat,
greppable lists of "`path=value`" statements. Modeled after
link:#xml[xml2].
* https://github.com/davvid/jsonaxe[jsonaxe] *—* Create and manipulate
JSON with a Python-based DSL. Inspired by jq.
* https://github.com/dbohdan/jsonwatch[jsonwatch] *—* Track changes in
JSON data from the command line. Works like `+watch -d+`.
* https://github.com/kellyjonbrazil/jtbl[jtbl] *—* Format JSON or JSON
Lines as a plain-text table.
* https://github.com/ldn-softdev/jtc[jtc] *—* Create, manipulate,
search, validate JSON with path expressions. Can be used as a C++14
library.
* https://github.com/sodiumjoe/lobar[lobar] *—* Process JSON and explore
it interactively with a wrapper for `+lodash.chain()+`. An alternative
to jq with JavaScript syntax.
* https://github.com/inosion/madato[madato] *—* Convert ODS and XLSX
spreadsheets to JSON, Markdown, and YAML.
* https://github.com/python-mario/mario[Mario] *—* Manipulate and
convert between CSV, JSON, YAML, TOML, and XML with Python code.
* https://github.com/nushell/nushell[Nushell] *—* A command shell. Can
natively https://www.nushell.sh/book/loading_data.html[load data] from
CSV, INI, JSON, TOML, TSV, XML, YAML, and other formats.
* https://github.com/hauntsaninja/pyp[pyp] *—* Transform input (as text
lines or as a whole) using Python code with automatic module imports.
Can generate a Python script equivalent to its invocation. In Python
3.11 or later supports TOML through
https://docs.python.org/3.11/library/tomllib.html[tomllib].
* https://github.com/mpkocher/qpyson[qpyson] *—* Query and manipulate
JSON with Python.
* https://github.com/davesnx/query-json[query-json] *—* A faster jq
implementation written in Reason Native (OCaml).
* https://github.com/quicktype/quicktype[quicktype] *—* Infer the
underlying model of the JSON and output as types for various programming
languages or JSON Schema. CLI and https://app.quicktype.io[Web UI].
* https://github.com/raine/ramda-cli[ramda-cli] *—* Manipulate JSON with
the https://ramdajs.com/[Ramda] functional library, and either
LiveScript or JavaScript syntax.
* https://github.com/benbernard/RecordStream[RecordStream] *—* Create,
manipulate, and output a stream of records, or JSON objects. Can
retrieve records from an SQL database, MongoDB, Atom feeds, XML, and
other sources.
* https://github.com/dbohdan/remarshal[Remarshal] *—* Convert between
CBOR, JSON, MessagePack, TOML, and YAML. Validate each of the formats.
Pretty-print JSON, TOML, and YAML.
* https://github.com/dflemstr/rq[rq] *—* Convert between Apache Avro,
CBOR, CSV, JSON, MessagePack, Protocol Buffers, TOML, YAML, and
awk-style plain text.
* https://github.com/daq-tools/skeem[Skeem] *—* Infer SQL DDL statements
from tabular data. Supports CSV, JSON, JSON Lines, ODS, XLSX, and other
formats.
* http://github.com/martinlindhe/validjson[validjson] *—* Validate or
pretty-print JSON.
* https://github.com/sinelaw/xml-to-json-fast[xml-to-json-fast] *—*
Convert XML to JSON. Can handle very large XML files.
* https://github.com/engali94/XMLJson[xmljson] *—* Convert multiple and
large XML files to JSON. Written in Swift.
* https://github.com/grantila/yaml-diff-patch[yaml-diff-patch] *—* Patch
YAML with https://datatracker.ietf.org/doc/html/rfc6902[RFC 6902] JSON
Patches. Generate a JSON Patch from two JSON documents or a YAML and a
JSON document. Preserves style. Can be used as a TypeScript library.
* https://github.com/wwkimball/yamlpath[yamlpath] *—* Query, modify,
diff, merge, and validate YAML and JSON with
https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path[YAML
Paths]. Also a Python library.

=== TOML

With a format converter like Remarshal you can use link:#json[JSON]
tools to process TOML and YAML, but make sure you do not lose data in
the conversion.

* https://github.com/pacha/cels[Cels] *—* Patch JSON, TOML, and YAML
with patches in the same format with some special values. Can be used as
a Python library.
* https://github.com/TomWright/dasel[dasel] *—* Query and update data
structures from the command line. Comparable to jq/yq but supports CSV,
JSON, TOML, YAML, and XML. Static binaries available for releases.
* https://github.com/mgree/ffs[ffs] *—* Mount JSON, TOML, and YAML as a
Unix filesystem.
* https://github.com/python-mario/mario[Mario] *—* Manipulate and
convert between CSV, JSON, YAML, TOML, and XML with Python code.
* https://github.com/nushell/nushell[Nushell] *—* A command shell. Can
natively https://www.nushell.sh/book/loading_data.html[load data] from
CSV, INI, JSON, TOML, TSV, XML, YAML, and other formats.
* https://github.com/hauntsaninja/pyp[pyp] *—* Transform input (as text
lines or as a whole) using Python code with automatic module imports.
Can generate a Python script equivalent to its invocation. In Python
3.11 or later supports TOML through
https://docs.python.org/3.11/library/tomllib.html[tomllib].
* https://github.com/dbohdan/remarshal[Remarshal] *—* Convert between
CBOR, JSON, MessagePack, TOML, and YAML. Validate each of the formats.
Pretty-print JSON, TOML, and YAML.
* https://github.com/dflemstr/rq[rq] *—* Convert between Apache Avro,
CBOR, CSV, JSON, MessagePack, Protocol Buffers, TOML, YAML, and
awk-style plain text.
* https://github.com/tamasfe/taplo[taplo-cli] *—* Query, format, and
validate (lint) TOML.
* http://github.com/martinlindhe/validtoml[validtoml] *—* Validate TOML.
* https://github.com/kislyuk/yq[yq (kislyuk)] *—* link:#json[jq] wrapper
for YAML, XML, and TOML.

=== XML

* https://github.com/jheusser/csvfix[csvfix] *—* A multitool. Compare,
filter, normalize, split, and validate CSV files. Reorder, remove,
split, and merge fields. Convert data between fixed-width, multi-line,
XML, and DSV format. Generate SQL statements. (Unofficial mirror.)
* https://github.com/TomWright/dasel[dasel] *—* Query and update data
structures from the command line. Comparable to jq/yq but supports CSV,
JSON, TOML, YAML, and XML. Static binaries available for releases.
* https://github.com/trailofbits/graphtage[Graphtage] *—* Compare and
merge tree-like structures semantically. Supports JSON, JSON5, XML,
HTML, YAML, and CSV. Can be used as a Python library.
* https://github.com/danburzo/hred[hred] *—* Query XML and HTML with a
query language based on CSS selectors.
* https://www.w3.org/Tools/HTML-XML-utils/README[html-xml-utils] *—* A
number of simple utilities (like `+hxcopy+`, `+hxpipe+`, `+hxunent+`,
`+hxselect+`) for manipulating HTML and XML files from
https://www.w3.org/[W3C]. Written in C, quite old-fashioned, but still
relevant and maintained.
* https://github.com/python-mario/mario[Mario] *—* Manipulate and
convert between CSV, JSON, YAML, TOML, and XML with Python code.
* https://github.com/nushell/nushell[Nushell] *—* A command shell. Can
natively https://www.nushell.sh/book/loading_data.html[load data] from
CSV, INI, JSON, TOML, TSV, XML, YAML, and other formats.
* http://saxon.sourceforge.net/[Saxon] *—* Query XML and HTML data with
https://devhints.io/xpath[XPath].
http://www.saxonica.com/documentation/#!using-xsl[Documentation].
* https://github.com/JFLarvoire/libxml2[sml2] *—* Convert between XML
and
https://htmlpreview.github.io/?https://github.com/JFLarvoire/libxml2/blob/master/SML_presentation.htm[SML],
a simplified XML representation.
* http://www.html-tidy.org/[tidy-html5] *—* Validate, fix, and reformat
HTML(5), XHTML, and XML documents. Convert HTML to XHTML.
* http://www.videlibri.de/xidel.html[Xidel] *—* Query or modify XML and
HTML pages with XPath, XQuery 3, and CSS selectors.
* https://github.com/sinelaw/xml-to-json-fast[xml-to-json-fast] *—*
Convert XML to JSON. Can handle very large XML files.
* https://web.archive.org/web/20160719191401/http://ofb.net/~egnor/xml2/[xml2]
*—* Convert XML and HTML to and from flat, greppable lists of
"`path=value`" statements. https://github.com/clone/xml2[Source code
mirror].
* https://github.com/engali94/XMLJson[xmljson] *—* Convert multiple and
large XML files to JSON. Written in Swift.
* http://xmlsoft.org/xmllint.html[XMLLint] *—* Query (including XSLT),
validate and reformat XML documents.
* http://xmlstar.sourceforge.net/overview.php[XMLStarlet] *—* Query,
modify, and validate XML documents.
* https://github.com/charmparticle/xpe[xpe] *—* Query HTML and XML with
XPath expressions.
* https://github.com/kislyuk/yq[xq] *—* link:#json[jq] wrapper for XML
documents.
* http://xmlsoft.org/XSLT/xsltproc2.html[xsltproc] *—* Transform XML
documents using https://www.w3.org/TR/xslt[XSLT] and
http://exslt.org[EXSLT].
* https://github.com/kislyuk/yq[yq (kislyuk)] *—* link:#json[jq] wrapper
for YAML, XML, and TOML.

==== See also

* http://stackoverflow.com/questions/91791/grep-and-sed-equivalent-for-xml-command-line-processing["`Grep
and Sed Equivalent for XML Command Line Processing`"] on Stack Overflow.

=== YAML

* https://github.com/pacha/cels[Cels] *—* Patch JSON, TOML, and YAML
with patches in the same format with some special values. Can be used as
a Python library.
* https://github.com/pastdev/clconf[clconf] *—* Merge multiple config
files and extract values from them using path string. Supports JSON and
YAML. Can be used as a Go library.
* https://github.com/TomWright/dasel[dasel] *—* Query and update data
structures from the command line. Comparable to jq/yq but supports CSV,
JSON, TOML, YAML, and XML. Static binaries available for releases.
* https://github.com/sampointer/dy[dy] *—* Construct YAML from a
directory tree.
* https://github.com/mgree/ffs[ffs] *—* Mount JSON, TOML, and YAML as a
Unix filesystem.
* https://github.com/itchyny/gojq[gojq] *—* A pure Go implementation of
jq. Supports YAML input and output.
* https://github.com/trailofbits/graphtage[Graphtage] *—* Compare and
merge tree-like structures semantically. Supports JSON, JSON5, XML,
HTML, YAML, and CSV. Can be used as a Python library.
* https://github.com/borkdude/jet[jet] *—* Convert between JSON, YAML,
Clojure’s https://github.com/edn-format/edn[edn], and
https://github.com/cognitect/transit-format[Transit]. Transform them
with Clojure code.
* https://github.com/inosion/madato[madato] *—* Convert ODS and XLSX
spreadsheets to JSON, Markdown, and YAML.
* https://github.com/python-mario/mario[Mario] *—* Manipulate and
convert between CSV, JSON, YAML, TOML, and XML with Python code.
* https://github.com/nushell/nushell[Nushell] *—* A command shell. Can
natively https://www.nushell.sh/book/loading_data.html[load data] from
CSV, INI, JSON, TOML, TSV, XML, YAML, and other formats.
* https://github.com/dbohdan/remarshal[Remarshal] *—* Convert between
CBOR, JSON, MessagePack, TOML, and YAML. Validate each of the formats.
Pretty-print JSON, TOML, and YAML.
* https://github.com/dflemstr/rq[rq] *—* Convert between Apache Avro,
CBOR, CSV, JSON, MessagePack, Protocol Buffers, TOML, YAML, and
awk-style plain text.
* https://github.com/0k/shyaml[shyaml] *—* Query YAML. Can output
null-terminated strings for use in shell scripts.
* http://github.com/martinlindhe/validyaml[validyaml] *—* Validate or
pretty-print YAML.
* https://github.com/grantila/yaml-diff-patch[yaml-diff-patch] *—* Patch
YAML with https://datatracker.ietf.org/doc/html/rfc6902[RFC 6902] JSON
Patches. Generate a JSON Patch from two JSON documents or a YAML and a
JSON document. Preserves style. Can be used as a TypeScript library.
* https://github.com/thecodingmachine/yaml-tools[yaml-tools] *—* A set
of CLI tools to manipulate YAML files (merge, delete, etc…) with comment
preservation, based on
http://yaml.readthedocs.io/en/latest/[ruamel.yaml].
* https://github.com/wwkimball/yamlpath[yamlpath] *—* Query, modify,
diff, merge, and validate YAML and JSON with
https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path[YAML
Paths]. Also a Python library.
* https://github.com/kislyuk/yq[yq (kislyuk)] *—* link:#json[jq] wrapper
for YAML, XML, and TOML.
* https://github.com/mikefarah/yq[yq (mikefarah)] *—* Query, modify, and
merge YAML. Convert to and from JSON.

=== Configuration files

==== .env

* https://github.com/dotenvx/dotenvx[dotenvx]
** *Platform:* POSIX, Windows
** *License:* BSD-3-Clause
** *Description:* A CLI tool to manipulate, parse, and inject `+.env+`
files as environment variables.

==== /etc/hosts

* https://github.com/guumaster/hostctl[hostctl] *—* Add and remove
entries in `+/etc/hosts+`. Disable (comment out) and enable (uncomment)
entries. Idempotent. Preserves arbitrary comments above its section of
the hosts file. Works with groups of entries called "`profiles`".
* https://github.com/cbednarski/hostess[hostess] *—* Add and remove
entries in `+/etc/hosts+`. Disable (comment out) and enable (uncomment)
entries. Check if a hostname exists. Reformat the hosts file. Convert
the entries to JSON. Idempotent. Removes arbitrary comments.
* https://gitlab.com/dbohdan/hosts[hosts] *—* Add and remove entries in
`+/etc/hosts+`. Change a hostname’s IP address. Idempotent. Preserves
arbitrary comments. Can be used as a Tcl library.

==== INI

* https://packages.debian.org/source/buster/cfget[cfget]
** *Platform:* Any with Python 2.6-2.7?
** *License:* GPL-2.0-or-later
** *Description:* Retrieve properties as shell script commands to set
the corresponding variables (with `+--dump exports+`). Retrieve
properties’ values as plain text. Substitute values from an INI file in
an Autoconf-style template. Supports plug-ins. Chokes on section names
and keys with spaces.
* https://devel.ringlet.net/textproc/confget/[confget]
** *Platform:* Free/Net/OpenBSD, Linux, likely others
** *License:* BSD-2-Clause
** *Description:* Retrieve properties and sections as shell script
commands to set the corresponding variables. Retrieve properties’ values
as plain text. Check for existence of properties. List sections. Find
values that match a pattern. Read-only. Has a C, Python, and Rust
implementation. The Rust implementation can be installed with
`+cargo install confget+`.
* https://github.com/pixelb/crudini/[crudini]
** *Platform:* Any with Python 2.6–2.7 or 3.x
** *License:* GPL-2.0
** *Description:* Retrieve properties and sections as INI fragments or
shell script commands to set the corresponding variables. Retrieve
properties’ values as plain text. Set properties. Remove properties and
sections. Create empty sections. Merge INI files. Changes files in
place.
* https://github.com/JFLarvoire/SysToolsLib/blob/HEAD/C/SRC/inicomp.c[inicomp]
** *Platform:* Windows, POSIX
** *License:* Apache-2.0
** *Description:* Compare INI (and also Windows .reg) files.
* http://www.horstmuc.de/wbat32.htm#inifile[IniFile]
** *Platform:* Windows (x86, x86-64),
http://www.horstmuc.de/div.htm#inifile[MS-DOS]
** *License:* Closed-source freeware
** *Description:* Retrieve properties and sections as batch file
commands to set the corresponding variables. Set properties. Remove
properties and sections. Changes files in place.
* https://github.com/dbohdan/initool[initool]
** *Platform:* FreeBSD, Linux, Windows
** *License:* MIT
** *Description:* Retrieve properties and sections as INI fragments.
Retrieve properties’ values as plain text. Set properties. Check for
existence of properties and sections. Remove properties and sections.
Outputs the updated INI file.
* https://github.com/nushell/nushell[Nushell (`+from ini+`)]
** *Platform:* Free/Net/OpenBSD, Linux, macOS, Windows
** *License:* MIT
** *Description:* Query and transform data with the Nushell language.

==== Multiple formats

* http://augeas.net[Augeas] *—* Query and modify
http://augeas.net/stock_lenses.html[a number of file formats]. Not all
of the formats are equally well supported by Augeas and for some only a
limited subset of all valid files can be parsed.
* http://libelektra.org[Elektra] *—* Query and modify
https://github.com/ElektraInitiative/libelektra/tree/master/src/plugins[configuration
files]. Shares Augeas’ limitations when it comes to application-specific
configuration files (it uses the same lenses), but has better support
for generic formats such as JSON and INI.

=== Log files

* https://lnav.org[lnav] *—* Query and watch log files. Has batch and
interactive mode. Supported formats include the Common Log Format, CUPS
page_log, syslog, strace, and generic timestamped messages. Can perform
SQL queries.
* https://github.com/samuel/squawk[Squawk] *—* Query Apache and Nginx
log files. See the link:sql-based.md[SQL-based tool comparison].

=== Multiformat tools

Tools that support multiple input formats. Programs that convert between
only two formats in both directions are excluded. We only count JSON
support that is separate from YAML.

* http://augeas.net[Augeas] *—* Query and modify
http://augeas.net/stock_lenses.html[a number of file formats]. Not all
of the formats are equally well supported by Augeas and for some only a
limited subset of all valid files can be parsed.
* https://github.com/pacha/cels[Cels] *—* Patch JSON, TOML, and YAML
with patches in the same format with some special values. Can be used as
a Python library.
* https://github.com/pastdev/clconf[clconf] *—* Merge multiple config
files and extract values from them using path string. Supports JSON and
YAML. Can be used as a Go library.
* https://github.com/jheusser/csvfix[csvfix] *—* A multitool. Compare,
filter, normalize, split, and validate CSV files. Reorder, remove,
split, and merge fields. Convert data between fixed-width, multi-line,
XML, and DSV format. Generate SQL statements. (Unofficial mirror.)
* https://github.com/shenwei356/csvtk[csvtk] *—* Search, sample, cut,
join, transpose, and sort CSV/TSV files. Rename columns. Replace fields
and generate new fiends from existing fields. Plot data as vector or
raster histograms and box, line, and scatter plots. Convert CSV to
Markdown. Convert XLSX to CSV. Split XLSX sheets.
* https://github.com/TomWright/dasel[dasel] *—* Query and update data
structures from the command line. Comparable to jq/yq but supports CSV,
JSON, TOML, YAML, and XML. Static binaries available for releases.
* http://libelektra.org[Elektra] *—* Query and modify
https://github.com/ElektraInitiative/libelektra/tree/master/src/plugins[configuration
files]. Shares Augeas’ limitations when it comes to application-specific
configuration files (it uses the same lenses), but has better support
for generic formats such as JSON and INI.
* http://kantord.github.io/emuto/[emuto] *—* CLI tool similar to jq.
Create and manipulate CSV, TSV, and JSON. Can be compiled to JavaScript.
* https://github.com/mgree/ffs[ffs] *—* Mount JSON, TOML, and YAML as a
Unix filesystem.
* https://github.com/ezrosent/frawk[frawk] *—* A Rust implementation of
a language partially compatible with AWK that supports
https://github.com/ezrosent/frawk/blob/master/info/parallelism.md[parallelism]
and CSV input and output. frawk is an awk-derived language with a CSV
mode for input and for output.
* https://github.com/benhoyt/goawk[GoAWK] *—* A cross-platform
implementation of awk with added support for CSV. The project provides
binaries for many platforms, including Windows. GoAWK is an awk
implementation that adds a CSV mode for input and for output.
* https://github.com/itchyny/gojq[gojq] *—* A pure Go implementation of
jq. Supports YAML input and output.
* https://github.com/trailofbits/graphtage[Graphtage] *—* Compare and
merge tree-like structures semantically. Supports JSON, JSON5, XML,
HTML, YAML, and CSV. Can be used as a Python library.
* https://github.com/danburzo/hred[hred] *—* Query XML and HTML with a
query language based on CSS selectors.
* https://www.w3.org/Tools/HTML-XML-utils/README[html-xml-utils] *—* A
number of simple utilities (like `+hxcopy+`, `+hxpipe+`, `+hxunent+`,
`+hxselect+`) for manipulating HTML and XML files from
https://www.w3.org/[W3C]. Written in C, quite old-fashioned, but still
relevant and maintained.
* https://github.com/borkdude/jet[jet] *—* Convert between JSON, YAML,
Clojure’s https://github.com/edn-format/edn[edn], and
https://github.com/cognitect/transit-format[Transit]. Transform them
with Clojure code.
* https://github.com/sgreben/jp[jp (sgreben)] *—* Plot JSON and CSV data
in the terminal. Supports different kinds of plots: bar charts, line
charts, scatter plots, histograms, and heatmaps.
* https://lnav.org[lnav] *—* Query and watch log files. Has batch and
interactive mode. Supported formats include the Common Log Format, CUPS
page_log, syslog, strace, and generic timestamped messages. Can perform
SQL queries.
* https://github.com/inosion/madato[madato] *—* Convert ODS and XLSX
spreadsheets to JSON, Markdown, and YAML.
* https://github.com/python-mario/mario[Mario] *—* Manipulate and
convert between CSV, JSON, YAML, TOML, and XML with Python code.
* https://github.com/nushell/nushell[Nushell] *—* A command shell. Can
natively https://www.nushell.sh/book/loading_data.html[load data] from
CSV, INI, JSON, TOML, TSV, XML, YAML, and other formats.
* https://github.com/hauntsaninja/pyp[pyp] *—* Transform input (as text
lines or as a whole) using Python code with automatic module imports.
Can generate a Python script equivalent to its invocation. In Python
3.11 or later supports TOML through
https://docs.python.org/3.11/library/tomllib.html[tomllib].
* https://github.com/benbernard/RecordStream[RecordStream] *—* Create,
manipulate, and output a stream of records, or JSON objects. Can
retrieve records from an SQL database, MongoDB, Atom feeds, XML, and
other sources.
* https://github.com/WizardMac/ReadStat[ReadStat] *—* Convert statistics
package datasets between SAS (SAS7BDAT, XPORT), SPSS (POR, SAV, ZSAV),
and Stata (DTA). Convert those formats to CSV and XLSX. Can be used as a
C library with bindings for Julia, Python, and R.
* https://github.com/dbohdan/remarshal[Remarshal] *—* Convert between
CBOR, JSON, MessagePack, TOML, and YAML. Validate each of the formats.
Pretty-print JSON, TOML, and YAML.
* https://github.com/turicas/rows[rows] *—* A Python library with a
http://turicas.info/rows/cli/[CLI]. Convert between a number of
http://turicas.info/rows/plugins/[file formats] for tabular data: CSV,
XLS, XLSX, ODS, and others. Query the data (via SQLite). Combine tables.
Generate schemas.
* https://github.com/dflemstr/rq[rq] *—* Convert between Apache Avro,
CBOR, CSV, JSON, MessagePack, Protocol Buffers, TOML, YAML, and
awk-style plain text.
* http://saxon.sourceforge.net/[Saxon] *—* Query XML and HTML data with
https://devhints.io/xpath[XPath].
http://www.saxonica.com/documentation/#!using-xsl[Documentation].
* https://github.com/daq-tools/skeem[Skeem] *—* Infer SQL DDL statements
from tabular data. Supports CSV, JSON, JSON Lines, ODS, XLSX, and other
formats.
* http://www.html-tidy.org/[tidy-html5] *—* Validate, fix, and reformat
HTML(5), XHTML, and XML documents. Convert HTML to XHTML.
* https://github.com/saulpw/visidata[VisiData] *—* Explore interactively
data in TSV, CSV, XLS, XLSX, HDF5, JSON, and
http://visidata.org/man/#loaders[other formats].
https://jsvine.github.io/intro-to-visidata/[Introduction].
* http://www.videlibri.de/xidel.html[Xidel] *—* Query or modify XML and
HTML pages with XPath, XQuery 3, and CSS selectors.
* https://web.archive.org/web/20160719191401/http://ofb.net/~egnor/xml2/[xml2]
*—* Convert XML and HTML to and from flat, greppable lists of
"`path=value`" statements. https://github.com/clone/xml2[Source code
mirror].
* https://github.com/engali94/XMLJson[xmljson] *—* Convert multiple and
large XML files to JSON. Written in Swift.
* https://github.com/charmparticle/xpe[xpe] *—* Query HTML and XML with
XPath expressions.
* https://github.com/grantila/yaml-diff-patch[yaml-diff-patch] *—* Patch
YAML with https://datatracker.ietf.org/doc/html/rfc6902[RFC 6902] JSON
Patches. Generate a JSON Patch from two JSON documents or a YAML and a
JSON document. Preserves style. Can be used as a TypeScript library.
* https://github.com/wwkimball/yamlpath[yamlpath] *—* Query, modify,
diff, merge, and validate YAML and JSON with
https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path[YAML
Paths]. Also a Python library.
* https://github.com/kislyuk/yq[yq (kislyuk)] *—* link:#json[jq] wrapper
for YAML, XML, and TOML.
* https://github.com/liquidaty/zsv[zsv] *—* Slice, combine, reformat,
flatten/unflatten CSV (TSV, DSV) files. Query them with SQL and jq
filters. Convert between them, JSON, and SQLite 3. Also a C library.

=== Templating for structured text

Listed below are restricted programming language interpreters and
templating tools that produce structured text output. They are generally
intended to remove repetition in configuration files. They are distinct
from unstructed templating tools like the `+jinja2+` CLI program, which
should not be added to this table.

* https://github.com/cuelang/cue[CUE]
** *Output format:* JSON
** *Turing-complete:* No
** *Syntax:* Extended JSON
** *I/O:* ?
** *Description:* A constraint language for JSON configuration data. Can
generate and validates JSON.
* https://dhall-lang.org/[Dhall]
** *Output format:* JSON, YAML
** *Turing-complete:* No
** *Syntax:* Haskell-inspired
** *I/O:* Limited to importing libraries from files and HTTP(S) URLs
(with protection against leaking your data to the server)
** *Description:* A statically-typed functional configuration language.
Has a standard formatting tool.
* https://github.com/jkcfg/jk[jk]
** *Output format:* JSON, YAML, plain text
** *Turing-complete:* Yes
** *Syntax:* JavaScript
** *I/O:* Disk I/O
** *Description:* Generate configuration files using JavaScript (V8 VM).
* https://jsonnet.org/[Jsonnet]
** *Output format:* JSON, INI, XML, YAML, plain text
** *Turing-complete:* Yes
** *Syntax:* Extended JSON
** *I/O:* None
** *Description:* A functional configuration language. Has a standard
formatting tool.
* https://nickel-lang.org/[Nickel]
** *Output format:* JSON, TOML, YAML
** *Turing-complete:* Yes
** *Syntax:* Inspired by ML and JSON
** *I/O:* Limited input is to be implemented
** *Description:* A gradually-typed functional configuration language
with contracts.
* https://pkl-lang.org/[Pkl]
** *Output format:* JSON, YAML, macOS property list, Java
`+.properties+`
** *Turing-complete:* Yes
** *Syntax:* Swift-inspired
** *I/O:* The CLI can read environment variables and files, `+GET+`
HTTP(S) URLs. It can import modules from files and HTTP(S) URLs.
** *Description:* A command-line tool, Java library, and build tool
plugin. Can generate code for Go, Java, Kotlin, and Swift.
https://pkl-lang.org/main/current/introduction/comparison.html#other-config-langs["`Pkl
vs. Other Config Languages`"].
* https://github.com/wryun/rjsone[rjsone]
** *Output format:* JSON, YAML
** *Turing-complete:* No?
** *Syntax:* Extended JSON
** *I/O:* None
** *Description:* A CLI tool for the
https://github.com/taskcluster/json-e[JSON-e] templating language.
* https://get-ytt.io/[ytt]
** *Output format:* YAML
** *Turing-complete:* No
** *Syntax:* YAML/Python hybrid
** *I/O:* None?
** *Description:* A templating tool for YAML built upon the
https://github.com/bazelbuild/starlark[Starlark] configuration language.

==== See also

* https://github.com/tweag/nickel/blob/master/RATIONALE.md#comparison-with-other-configuration-languages[A
comparison table of Nickel and other configuration languages].

=== Extra: interactive TUIs

* https://github.com/argrelay/argrelay[argrelay] *—* Implement tab
completion for commands in Bash based on search of indexed data through
a background server.
* https://github.com/simeji/jid[jid] *—* Explore JSON interactively with
filtering queries like jq.
* https://github.com/fiatjaf/jiq[jiq] *—* Explore JSON interactively
with jq. Requires jq.
* https://github.com/sodiumjoe/lobar[lobar] *—* Process JSON and explore
it interactively with a wrapper for `+lodash.chain()+`. An alternative
to jq with JavaScript syntax.
* https://github.com/andmarti1424/sc-im[sc-im] *—* A Vim-like
spreadsheet calculator for CSV and TSV files.
* https://github.com/saulpw/visidata[VisiData] *—* Explore interactively
data in TSV, CSV, XLS, XLSX, HDF5, JSON, and
http://visidata.org/man/#loaders[other formats].
https://jsvine.github.io/intro-to-visidata/[Introduction].

=== Extra: CLIs for single-file databases

* https://firebirdsql.org/[Firebird]
** *Description:* Firebird is a FOSS database that can be used from a
single file, like SQLite. "`isql is a program that allows the user to
issue arbitrary SQL commands`".
** *File format:* Binary
* https://www.isi.edu/~johnh/SOFTWARE/FSDB/perl-Fsdb-2.69_README.html[Fsdb]
** *Description:* A flat-file database for shell scripting.
** *File format:* Text-based, TSV with a header or "`key: value`"
* http://www.gnu.org/software/recutils/[GNU Recutils]
** *Description:* "`[A] set of tools and libraries to access
human-editable, plain text databases called recfiles.`"
** *File format:* Text-based, roughly "`key: value`"
* https://github.com/radare/sdb[SDB]
** *Description:* "`[A] simple string key/value database based on djb’s
cdb disk storage and supports JSON and arrays introspection.`"
** *File format:* Binary
* https://www.sqlite.org/cli.html[sqlite3(1)]
** *Description:* "`[A] simple command-line utility […] that allows the
user to manually enter and execute SQL statements against an SQLite
database.`"
** *File format:* Binary

=== License

The contents of this document is licensed under the
http://creativecommons.org/licenses/by/4.0/[Creative Commons Attribution
4.0 International License]. By contributing you agree to release your
contribution under this license.

=== Disclosure

https://github.com/dbohdan/csv2html[csv2html],
https://gitlab.com/dbohdan/hosts[hosts],
https://github.com/dbohdan/sqawk[Sqawk],
https://github.com/dbohdan/jsonwatch[jsonwatch],
https://github.com/remarshal-project/remarshal[Remarshal], and
https://github.com/dbohdan/initool[initool] are developed by the curator
of this document.

