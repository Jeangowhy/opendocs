
ECMAScript® 2025 Language Specification
=======================================

   **Draft ECMA-262 / November 8, 2024**

   .. figure:: https://tc39.es/ecma262/img/ecma-logo.svg

      Ecma International logo

Contents
========
::

   Introduction
   1. Scope
   2. Conformance
   3. Normative References
   4. Overview
   5. Notational Conventions
   6. ECMAScript Data Types and Values
   7. Abstract Operations
   8. Syntax-Directed Operations
   9. Executable Code and Execution Contexts
   10. Ordinary and Exotic Objects Behaviours
   11. ECMAScript Language: Source Text
   12. ECMAScript Language: Lexical Grammar
   13. ECMAScript Language: Expressions
   14. ECMAScript Language: Statements and Declarations
   15. ECMAScript Language: Functions and Classes
   16. ECMAScript Language: Scripts and Modules
   17. Error Handling and Language Extensions
   18. ECMAScript Standard Built-in Objects
   19. The Global Object
   20. Fundamental Objects
   21. Numbers and Dates
   22. Text Processing
   23. Indexed Collections
   24. Keyed Collections
   25. Structured Data
   26. Managing Memory
   27. Control Abstraction Objects
   28. Reflection
   29. Memory Model
   A Grammar Summary
   B Additional ECMAScript Features for Web Browsers
   C The Strict Mode of ECMAScript
   D Host Layering Points
   E Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact
   F Additions and Changes That Introduce Incompatibilities with Prior Editions
   G Colophon
   H Bibliography
   I Copyright & Software License


About this Specification
------------------------

   The document at https://tc39.es/ecma262/ is the most accurate and
   up-to-date ECMAScript specification. It contains the content of the
   most recent yearly snapshot plus any `finished proposals <https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md>`__
   (those that have reached Stage 4 in the `proposal process <https://tc39.es/process-document/>`__ 
   and thus are implemented in several implementations and will be in the next
   practical revision) since that snapshot was taken.

   This document is available as 
   `a single page <https://vscode.dev/github/tc39/ecma262/blob/main/spec.html>`__ 
   and as `multiple pages <https://tc39.es/ecma262/multipage/>`__.

Contributing to this Specification
----------------------------------

   This specification is developed on GitHub with the help of the
   ECMAScript community. There are a number of ways to contribute to the
   development of this specification:

   - GitHub Repository: https://github.com/tc39/ecma262
   - Issues: `All Issues <https://github.com/tc39/ecma262/issues>`__,
     `File a New Issue <https://github.com/tc39/ecma262/issues/new>`__
   - Pull Requests: 
     `All Pull Requests <https://github.com/tc39/ecma262/pulls>`__, 
     `Create a New Pull Request <https://github.com/tc39/ecma262/pulls/new>`__
   - Test Suite: `Test262 <https://github.com/tc39/test262>`__
   - Editors:

     - `Shu-yu Guo <mailto:syg%20at%20google%20dot%20com>`__
       (`@_shu <https://twitter.com/_shu>`__)
     - `Michael Ficarra <mailto:ecma262-editor-list%20at%20michael%20dot%20ficarra%20dot%20me>`__
       (`@smooshMap <https://twitter.com/smooshMap>`__)
     - `Kevin Gibbons <mailto:bakkot%20at%20gmail%20dot%20com>`__
       (`@bakkoting <https://twitter.com/bakkoting>`__)

   - Community:

     - Discourse:
       `https://es.discourse.group/ <https://es.discourse.group>`__
     - Chat:
       `Matrix <https://github.com/tc39/how-we-work/blob/HEAD/matrix-guide.md>`__
     - Mailing List Archives:
       `https://esdiscuss.org/ <https://esdiscuss.org>`__

   Refer to the colophon for more information on how this document is created.


Introduction
============

https://tc39.es/ecma262/multipage/

This Ecma Standard defines the ECMAScript 2025 Language. It is the
sixteenth edition of the ECMAScript Language Specification. Since
publication of the first edition in 1997, ECMAScript has grown to be one
of the world's most widely used general-purpose programming languages.
It is best known as the language embedded in web browsers but has also
been widely adopted for server and embedded applications.

ECMAScript is based on several originating technologies, the most
well-known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company's Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of the ECMAScript Language Specification started in
November 1996. The first edition of this Ecma Standard was adopted by
the Ecma General Assembly of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of future language growth. The
third edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

After publication of the third edition, ECMAScript achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
However, that work was not completed and not published as the fourth
edition of ECMAScript but some of it was incorporated into the
development of the sixth edition.

The fifth edition of ECMAScript (published as ECMA-262 5\ :sup:`th`
edition) codified de facto interpretations of the language specification
that have become common among browser implementations and added support
for new features that had emerged since the publication of the third
edition. Such features include accessor properties, reflective creation
and inspection of objects, program control of property attributes,
additional array manipulation functions, support for the JSON object
encoding format, and a strict mode that provides enhanced error checking
and program security. The fifth edition was adopted by the Ecma General
Assembly of December 2009.

The fifth edition was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262:2011. Edition 5.1 of the ECMAScript Standard incorporated minor
corrections and is the same text as ISO/IEC 16262:2011. The 5.1 Edition
was adopted by the Ecma General Assembly of June 2011.

Focused development of the sixth edition started in 2009, as the fifth
edition was being prepared for publication. However, this was preceded
by significant experimentation and language enhancement design efforts
dating to the publication of the third edition in 1999. In a very real
sense, the completion of the sixth edition is the culmination of a
fifteen year effort. The goals for this edition included providing
better support for large applications, library creation, and for use of
ECMAScript as a compilation target for other languages. Some of its
major enhancements included modules, class declarations, lexical block
scoping, iterators and generators, promises for asynchronous
programming, destructuring patterns, and proper tail calls. The
ECMAScript library of built-ins was expanded to support additional data
abstractions including maps, sets, and arrays of binary numeric values
as well as additional support for Unicode supplementary characters in
strings and regular expressions. The built-ins were also made extensible
via subclassing. The sixth edition provides the foundation for regular,
incremental language and library enhancements. The sixth edition was
adopted by the General Assembly of June 2015.

ECMAScript 2016 was the first ECMAScript edition released under Ecma
TC39's new yearly release cadence and open development process. A
plain-text source document was built from the ECMAScript 2015 source
document to serve as the base for further development entirely on
GitHub. Over the year of this standard's development, hundreds of pull
requests and issues were filed representing thousands of bug fixes,
editorial fixes and other improvements. Additionally, numerous software
tools were developed to aid in this effort including Ecmarkup,
Ecmarkdown, and Grammarkdown. ES2016 also included support for a new
exponentiation operator and adds a new method to `Array.prototype`
called `includes`.

ECMAScript 2017 introduced Async Functions, Shared Memory, and Atomics
along with smaller language and library enhancements, bug fixes, and
editorial updates. Async functions improve the asynchronous programming
experience by providing syntax for promise-returning functions. Shared
Memory and Atomics introduce a new memory model that allows multi-agent
programs to communicate using atomic operations that ensure a
well-defined execution order even on parallel CPUs. It also included new
static methods on Object: `Object.values`, `Object.entries`, and
`Object.getOwnPropertyDescriptors`.

ECMAScript 2018 introduced support for asynchronous iteration via the
async iterator protocol and async generators. It also included four new
regular expression features: the `dotAll` flag, named capture groups,
Unicode property escapes, and look-behind assertions. Lastly it included
object rest and spread properties.

ECMAScript 2019 introduced a few new built-in functions: `flat` and
`flatMap` on `Array.prototype` for flattening arrays,
`Object.fromEntries` for directly turning the return value of
`Object.entries` into a new Object, and `trimStart` and `trimEnd`
on `String.prototype` as better-named alternatives to the widely
implemented but non-standard `String.prototype.trimLeft` and
`trimRight` built-ins. In addition, it included a few minor updates to
syntax and semantics. Updated syntax included optional catch binding
parameters and allowing U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH
SEPARATOR) in string literals to align with JSON. Other updates included
requiring that `Array.prototype.sort` be a stable sort, requiring that
`JSON.stringify` return well-formed UTF-8 regardless of input, and
clarifying `Function.prototype.toString` by requiring that it either
return the corresponding original source text or a standard placeholder.

ECMAScript 2020, the 11\ :sup:`th` edition, introduced the `matchAll`
method for Strings, to produce an iterator for all match objects
generated by a global regular expression; `import()`, a syntax to
asynchronously import Modules with a dynamic specifier; `BigInt`, a
new number primitive for working with arbitrary precision integers;
`Promise.allSettled`, a new Promise combinator that does not
short-circuit; `globalThis`, a universal way to access the global
`this` value; dedicated `export ` as ns from 'module'` syntax for
use within modules; increased standardization of `for-in` enumeration
order; `import.meta`, a host-populated object available in Modules
that may contain contextual information about the Module; as well as
adding two new syntax features to improve working with “nullish” values
(**undefined** or **null**): nullish coalescing, a value selection
operator; and optional chaining, a property access and function
invocation operator that short-circuits if the value to access/invoke is
nullish.

ECMAScript 2021, the 12\ :sup:`th` edition, introduced the
`replaceAll` method for Strings; `Promise.any`, a Promise combinator
that short-circuits when an input value is fulfilled;
`AggregateError`, a new Error type to represent multiple errors at
once; logical assignment operators (`??=`, `&&=`, `||=`);
`WeakRef`, for referring to a target object without preserving it from
garbage collection, and `FinalizationRegistry`, to manage registration
and unregistration of cleanup operations performed when target objects
are garbage collected; separators for numeric literals (`1_000`); and
`Array.prototype.sort` was made more precise, reducing the amount of
cases that result in an implementation-defined sort order.

ECMAScript 2022, the 13\ :sup:`th` edition, introduced top-level
`await`, allowing the keyword to be used at the top level of modules;
new class elements: public and private instance fields, public and
private static fields, private instance methods and accessors, and
private static methods and accessors; static blocks inside classes, to
perform per-class evaluation initialization; the `#x in obj` syntax,
to test for presence of private fields on objects; regular expression
match indices via the `/d` flag, which provides start and end indices
for matched substrings; the `cause` property on `Error` objects,
which can be used to record a causation chain in errors; the `at`
method for Strings, Arrays, and TypedArrays, which allows relative
indexing; and `Object.hasOwn`, a convenient alternative to
`Object.prototype.hasOwnProperty`.

ECMAScript 2023, the 14\ :sup:`th` edition, introduced the `toSorted`,
`toReversed`, `with`, `findLast`, and `findLastIndex` methods on
`Array.prototype` and `TypedArray.prototype`, as well as the
`toSpliced` method on `Array.prototype`; added support for `#!`
comments at the beginning of files to better facilitate executable
ECMAScript files; and allowed the use of most Symbols as keys in weak
collections.

ECMAScript 2024, the 15\ :sup:`th` edition, added facilities for
resizing and transferring ArrayBuffers and SharedArrayBuffers; added a
new RegExp `/v` flag for creating RegExps with more advanced features
for working with sets of strings; and introduced the
`Promise.withResolvers` convenience method for constructing Promises,
the `Object.groupBy` and `Map.groupBy` methods for aggregating data,
the `Atomics.waitAsync` method for asynchronously waiting for a change
to shared memory, and the `String.prototype.isWellFormed` and
`String.prototype.toWellFormed` methods for checking and ensuring that
strings contain only well-formed Unicode.

Dozens of individuals representing many organizations have made very
significant contributions within Ecma TC39 to the development of this
edition and to the prior editions. In addition, a vibrant community has
emerged supporting TC39's ECMAScript efforts. This community has
reviewed numerous drafts, filed thousands of bug reports, performed
implementation experiments, contributed test suites, and educated the
world-wide developer community about ECMAScript. Unfortunately, it is
impossible to identify and acknowledge every person and organization who
has contributed to this effort.

| Allen Wirfs-Brock
| ECMA-262, Project Editor, 6\ :sup:`th` Edition

| Brian Terlson
| ECMA-262, Project Editor, 7\ :sup:`th` through 10\ :sup:`th` Editions

| Jordan Harband
| ECMA-262, Project Editor, 10\ :sup:`th` through 12\ :sup:`th` Editions

| Shu-yu Guo
| ECMA-262, Project Editor, 12\ :sup:`th` through 15\ :sup:`th` Editions

| Michael Ficarra
| ECMA-262, Project Editor, 12\ :sup:`th` through 15\ :sup:`th` Editions

| Kevin Gibbons
| ECMA-262, Project Editor, 12\ :sup:`th` through 15\ :sup:`th` Editions


1. Scope
========

https://tc39.es/ecma262/multipage/scope.html

This Standard defines the ECMAScript 2025 general-purpose programming
language.

2. Conformance
==============

https://tc39.es/ecma262/multipage/conformance.html
::

   2.1 Example Normative Optional Clause Heading
   2.2 Example Legacy Clause Heading
   2.3 Example Legacy Normative Optional Clause Heading

A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of ECMAScript must interpret source text
input in conformance with the latest version of the Unicode Standard and
ISO/IEC 10646.

A conforming implementation of ECMAScript that provides an application
programming interface (API) that supports programs that need to adapt to
the linguistic and cultural conventions used by different human
languages and countries must implement the interface defined by the most
recent edition of ECMA-402 that is compatible with this specification.

A conforming implementation of ECMAScript may provide additional types,
values, objects, properties, and functions beyond those described in
this specification. In particular, a conforming implementation of
ECMAScript may provide properties not described in this specification,
and values for those properties, for objects that are described in this
specification.

A conforming implementation of ECMAScript may support program and
regular expression syntax not described in this specification. In
particular, a conforming implementation of ECMAScript may support
program syntax that makes use of any “future reserved words” noted in
subclause of this specification.

A conforming implementation of ECMAScript must not implement any
extension that is listed as a Forbidden Extension in subclause .

A conforming implementation of ECMAScript must not redefine any
facilities that are not implementation-defined,
implementation-approximated, or host-defined.

A conforming implementation of ECMAScript may choose to implement or not
implement Normative Optional subclauses. If any Normative Optional
behaviour is implemented, all of the behaviour in the containing
Normative Optional clause must be implemented. A Normative Optional
clause is denoted in this specification with the words "Normative
Optional" in a coloured box, as shown below.

2.1 Example Normative Optional Clause Heading
---------------------------------------------

Example clause contents.

A conforming implementation of ECMAScript must implement Legacy
subclauses, unless they are also marked as Normative Optional. All of
the language features and behaviours specified within Legacy subclauses
have one or more undesirable characteristics. However, their continued
usage in existing applications prevents their removal from this
specification. These features are not considered part of the core
ECMAScript language. Programmers should not use or assume the existence
of these features and behaviours when writing new ECMAScript code.

2.2 Example Legacy Clause Heading
---------------------------------

Example clause contents.

2.3 Example Legacy Normative Optional Clause Heading
----------------------------------------------------

Example clause contents.

3. Normative References
=======================

https://tc39.es/ecma262/multipage/normative-references.html

The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

IEEE 754-2019, *IEEE Standard for Floating-Point Arithmetic*.

| The Unicode Standard.
| https://unicode.org/versions/latest

ISO/IEC 10646, *Information Technology — Universal Multiple-Octet Coded
Character Set (UCS)* plus Amendment 1:2005, Amendment 2:2006, Amendment
3:2008, Amendment 4:2008, and additional amendments and corrigenda, or
successor.

| ECMA-402, *ECMAScript Internationalization API Specification*,
  specifically the annual edition corresponding to this edition of this
  specification.
| https://www.ecma-international.org/publications-and-standards/standards/ecma-402/

| ECMA-404, *The JSON Data Interchange Format*.
| https://www.ecma-international.org/publications-and-standards/standards/ecma-404/

4. Overview
===========

https://tc39.es/ecma262/multipage/overview.html
::

   4.1 Web Scripting
   4.2 Hosts and Implementations
   4.3 ECMAScript Overview
   4.3.1 Objects
   4.3.2 The Strict Variant of ECMAScript
   4.4 Terms and Definitions
      4.4.1 implementation-approximated
      4.4.2 implementation-defined
      4.4.3 host-defined
      4.4.4 type
      4.4.5 primitive value
      4.4.6 object
      4.4.7 constructor
      4.4.8 prototype
      4.4.9 ordinary object
      4.4.10 exotic object
      4.4.11 standard object
      4.4.12 built-in object
      4.4.13 undefined value
      4.4.14 Undefined type
      4.4.15 null value
      4.4.16 Null type
      4.4.17 Boolean value
      4.4.18 Boolean type
      4.4.19 Boolean object
      4.4.20 String value
      4.4.21 String type
      4.4.22 String object
      4.4.23 Number value
      4.4.24 Number type
      4.4.25 Number object
      4.4.26 Infinity
      4.4.27 NaN
      4.4.28 BigInt value
      4.4.29 BigInt type
      4.4.30 BigInt object
      4.4.31 Symbol value
      4.4.32 Symbol type
      4.4.33 Symbol object
      4.4.34 function
      4.4.35 built-in function
      4.4.36 built-in constructor
      4.4.37 property
      4.4.38 method
      4.4.39 built-in method
      4.4.40 attribute
      4.4.41 own property
      4.4.42 inherited property
   4.5 Organization of This Specification


This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific objects, whose description and behaviour are beyond
the scope of this specification except to indicate that they may provide
certain properties that can be accessed and certain functions that can
be called from an ECMAScript program.

ECMAScript was originally designed to be used as a scripting language,
but has become widely used as a general-purpose programming language. A
*scripting language* is a programming language that is used to
manipulate, customize, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers.

ECMAScript was originally designed to be a *Web scripting language*,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript is now used to provide core scripting capabilities for a
variety of host environments. Therefore the core language is specified
in this document apart from any particular host environment.

ECMAScript usage has moved beyond simple scripting and it is now used
for the full spectrum of programming tasks in many different
environments and scales. As the usage of ECMAScript has expanded, so
have the features and facilities it provides. ECMAScript is now a fully
featured general-purpose programming language.

4.1 Web Scripting
-----------------

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction, and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customized user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.

4.2 Hosts and Implementations
-----------------------------

To aid integrating ECMAScript into host environments, this specification
defers the definition of certain facilities (e.g., abstract operations),
either in whole or in part, to a source outside of this specification.
Editorially, this specification distinguishes the following kinds of
deferrals.

An *implementation* is an external source that further defines
facilities enumerated in Annex or those that are marked as
implementation-defined or implementation-approximated. In informal use,
an implementation refers to a concrete artefact, such as a particular
web browser.

An implementation-defined facility is one that defers its definition to
an external source without further qualification. This specification
does not make any recommendations for particular behaviours, and
conforming implementations are free to choose any behaviour within the
constraints put forth by this specification.

An implementation-approximated facility is one that defers its
definition to an external source while recommending an ideal behaviour.
While conforming implementations are free to choose any behaviour within
the constraints put forth by this specification, they are encouraged to
strive to approximate the ideal. Some mathematical operations, such as
``Math.exp``, are implementation-approximated.

A host is an external source that further defines facilities listed in
Annex but does not further define other implementation-defined or
implementation-approximated facilities. In informal use, a host refers
to the set of all implementations, such as the set of all web browsers,
that interface with this specification in the same way via Annex . A
host is often an external specification, such as WHATWG HTML
(https://html.spec.whatwg.org/). In other words, facilities that are
host-defined are often further defined in external specifications.

A host hook is an abstract operation that is defined in whole or in part
by an external source. All host hooks must be listed in Annex . A host
hook must conform to at least the following requirements:

- It must return either a normal completion or a throw completion.

A host-defined facility is one that defers its definition to an external
source without further qualification and is listed in Annex .
Implementations that are not hosts may also provide definitions for
host-defined facilities.

A host environment is a particular choice of definition for all
host-defined facilities. A host environment typically includes objects
or functions which allow obtaining input and providing output as
host-defined properties of the global object.

This specification follows the editorial convention of always using the
most specific term. For example, if a facility is host-defined, it
should not be referred to as implementation-defined.

Both hosts and implementations may interface with this specification via
the language types, specification types, abstract operations, grammar
productions, intrinsic objects, and intrinsic symbols defined herein.

4.3 ECMAScript Overview
-----------------------

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. In ECMAScript, an *object* is a collection of
zero or more *properties* each with *attributes* that determine how each
property can be used—for example, when the Writable attribute for a
property is set to `false`, any attempt by executed ECMAScript code to
assign a different value to the property fails. Properties are
containers that hold other objects, *primitive values*, or *functions*.
A primitive value is a member of one of the following built-in types:
**Undefined**, **Null**, **Boolean**, **Number**, **BigInt**,
**String**, and **Symbol;** an object is a member of the built-in type
**Object**; and a function is a callable object. A function that is
associated with an object via a property is called a *method*.

ECMAScript defines a collection of *built-in objects* that round out the
definition of ECMAScript entities. These built-in objects include the
global object; objects that are fundamental to the runtime semantics of
the language including `Object`, `Function`, `Boolean`,
`Symbol`, and various `Error` objects; objects that represent and
manipulate numeric values including `Math`, `Number`, and `Date`;
the text processing objects `String` and `RegExp`; objects that are
indexed collections of values including `Array` and nine different
kinds of Typed Arrays whose elements all have a specific numeric data
representation; keyed collections including `Map` and `Set` objects;
objects supporting structured data including the `JSON` object,
`ArrayBuffer`, `SharedArrayBuffer`, and `DataView`; objects
supporting control abstractions including generator functions and
`Promise` objects; and reflection objects including `Proxy` and
`Reflect`.

ECMAScript also defines a set of built-in *operators*. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

Large ECMAScript programs are supported by *modules* which allow a
program to be divided into multiple sequences of statements and
declarations. Each module explicitly identifies declarations it uses
that need to be provided by other modules and which of its declarations
are available for use by other modules.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

4.3.1 Objects
'''''''''''''

Even though ECMAScript includes syntax for class definitions, ECMAScript
objects are not fundamentally class-based such as those in C++,
Smalltalk, or Java. Instead objects may be created in various ways
including via a literal notation or via *constructors* which create
objects and then execute code that initializes all or part of them by
assigning initial values to their properties. Each constructor is a
function that has a property named `"prototype"` that is used to
implement *prototype-based inheritance* and *shared properties*. Objects
are created by using constructors in **new** expressions; for example,
`new Date(2009, 11)` creates a new Date object. Invoking a constructor
without using **new** has consequences that depend on the constructor.
For example, `Date()` produces a string representation of the current
date and time rather than an object.

Every object created by a constructor has an implicit reference (called
the object's *prototype*) to the value of its constructor's
`"prototype"` property. Furthermore, a prototype may have a
non-`null` implicit reference to its prototype, and so on; this is
called the *prototype chain*. When a reference is made to a property in
an object, that reference is to the property of that name in the first
object in the prototype chain that contains a property of that name. In
other words, first the object mentioned directly is examined for such a
property; if that object contains the named property, that is the
property to which the reference refers; if that object does not contain
the named property, the prototype for that object is examined next; and
so on.

.. figure:: https://tc39.es/ecma262/img/figure-1.svg
   :width: 719px
   :height: 354px

   An image of lots of boxes and arrows.

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, while structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

**CF** is a constructor (and also an object). Five objects have been
created by using `new` expressions: :math:`cf_1`, :math:`cf_2`, :math:`cf_3`,
:math:`cf_4`, and :math:`cf_5`. Each of these objects contains properties
named `"q1"` and `"q2"`. The dashed lines represent the implicit
prototype relationship; so, for example, :math:`cf_3`'s prototype is
:math:`CF_p`. The constructor, **CF**, has two properties itself, named
`"P1"` and `"P2"`, which are not visible to :math:`CF_p`, :math:`cf_1`,
:math:`cf_2`, :math:`cf_3`, :math:`cf_4`, or :math:`cf_5`. The property named
`"CFP1"` in :math:`CF_p` is shared by :math:`cf_1`, :math:`cf_2`, :math:`cf_3`,
:math:`cf_4`, and :math:`cf_5` (but not by **CF**), as are any properties
found in :math:`CF_p`'s implicit prototype chain that are not named
`"q1"`, `"q2"`, or `"CFP1"`. Notice that there is no implicit
prototype link between **CF** and :math:`CF_p`.

Unlike most class-based object languages, properties can be added to
objects dynamically by assigning values to them. That is, constructors
are not required to name or assign values to all or any of the
constructed object's properties. In the above diagram, one could add a
new shared property for :math:`cf_1`, :math:`cf_2`, :math:`cf_3`, :math:`cf_4`, and
:math:`cf_5` by assigning a new value to the property in :math:`CF_p`.

Although ECMAScript objects are not inherently class-based, it is often
convenient to define class-like abstractions based upon a common pattern
of constructor functions, prototype objects, and methods. The ECMAScript
built-in objects themselves follow such a class-like pattern. Beginning
with ECMAScript 2015, the ECMAScript language includes syntactic class
definitions that permit programmers to concisely define objects that
conform to the same class-like abstraction pattern used by the built-in
objects.

4.3.2 The Strict Variant of ECMAScript
''''''''''''''''''''''''''''''''''''''

The ECMAScript Language recognizes the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the *strict
mode* of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript source text units as described in . Because strict
mode is selected at the level of a syntactic source text unit, strict
mode only imposes restrictions that have local effect within such a
source text unit. Strict mode does not restrict or modify any aspect of
the ECMAScript semantics that must operate consistently across multiple
source text units. A complete ECMAScript program may be composed of both
strict mode and non-strict mode ECMAScript source text units. In this
case, strict mode only applies when actually executing code that is
defined within a strict mode source text unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode source text units into a
single composite program.

4.4 Terms and Definitions
-------------------------

For the purposes of this document, the following terms and definitions
apply.

4.4.1 implementation-approximated
'''''''''''''''''''''''''''''''''

an implementation-approximated facility is defined in whole or in part
by an external source but has a recommended, ideal behaviour in this
specification

4.4.2 implementation-defined
''''''''''''''''''''''''''''

an implementation-defined facility is defined in whole or in part by an
external source to this specification

4.4.3 host-defined
''''''''''''''''''

same as implementation-defined

Editorially, see clause .

4.4.4 type
''''''''''

set of data values as defined in clause

4.4.5 primitive value
'''''''''''''''''''''

member of one of the types Undefined, Null, Boolean, Number, BigInt,
Symbol, or String as defined in clause

A primitive value is a datum that is represented directly at the lowest
level of the language implementation.

4.4.6 object
''''''''''''

member of the type Object

An object is a collection of properties and has a single prototype
object. The prototype may be `null`.

4.4.7 constructor
'''''''''''''''''

function object that creates and initializes objects

The value of a constructor's `"prototype"` property is a prototype
object that is used to implement inheritance and shared properties.

4.4.8 prototype
'''''''''''''''

object that provides shared properties for other objects

When a constructor creates an object, that object implicitly references
the constructor's `"prototype"` property for the purpose of resolving
property references. The constructor's `"prototype"` property can be
referenced by the program expression ``constructor``\ ``.prototype``,
and properties added to an object's prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the `Object.create` built-in function.

4.4.9 ordinary object
'''''''''''''''''''''

object that has the default behaviour for the essential internal methods
that must be supported by all objects

4.4.10 exotic object
''''''''''''''''''''

object that does not have the default behaviour for one or more of the
essential internal methods

Any object that is not an ordinary object is an exotic object.

4.4.11 standard object
''''''''''''''''''''''

object whose semantics are defined by this specification

4.4.12 built-in object
''''''''''''''''''''''

object specified and supplied by an ECMAScript implementation

Standard built-in objects are defined in this specification. An
ECMAScript implementation may specify and supply additional kinds of
built-in objects.

4.4.13 undefined value
''''''''''''''''''''''

primitive value used when a variable has not been assigned a value

4.4.14 Undefined type
'''''''''''''''''''''

type whose sole value is the `undefined` value

4.4.15 null value
'''''''''''''''''

primitive value that represents the intentional absence of any object
value

4.4.16 Null type
''''''''''''''''

type whose sole value is the `null` value

4.4.17 Boolean value
''''''''''''''''''''

member of the Boolean type

There are only two Boolean values, `true` and `false`.

4.4.18 Boolean type
'''''''''''''''''''

type consisting of the primitive values `true` and `false`

4.4.19 Boolean object
'''''''''''''''''''''

member of the Object type that is an instance of the standard built-in
Boolean constructor

A Boolean object is created by using the Boolean constructor in a
`new` expression, supplying a Boolean value as an argument. The
resulting object has an internal slot whose value is the Boolean value.
A Boolean object can be coerced to a Boolean value.

4.4.20 String value
'''''''''''''''''''

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer values

A String value is a member of the String type. Each integer value in the
sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.4.21 String type
''''''''''''''''''

set of all possible String values

4.4.22 String object
''''''''''''''''''''

member of the Object type that is an instance of the standard built-in
String constructor

A String object is created by using the String constructor in a `new`
expression, supplying a String value as an argument. The resulting
object has an internal slot whose value is the String value. A String
object can be coerced to a String value by calling the String
constructor as a function ().

4.4.23 Number value
'''''''''''''''''''

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754-2019 value

A Number value is a member of the Number type and is a direct
representation of a number.

4.4.24 Number type
''''''''''''''''''

set of all possible Number values including the special “Not-a-Number”
(NaN) value, positive infinity, and negative infinity

4.4.25 Number object
''''''''''''''''''''

member of the Object type that is an instance of the standard built-in
Number constructor

A Number object is created by using the Number constructor in a `new`
expression, supplying a Number value as an argument. The resulting
object has an internal slot whose value is the Number value. A Number
object can be coerced to a Number value by calling the Number
constructor as a function ().

4.4.26 Infinity
'''''''''''''''

Number value that is the positive infinite Number value

4.4.27 NaN
''''''''''

Number value that is an IEEE 754-2019 “Not-a-Number” value

4.4.28 BigInt value
'''''''''''''''''''

primitive value corresponding to an arbitrary-precision integer value

4.4.29 BigInt type
''''''''''''''''''

set of all possible BigInt values

4.4.30 BigInt object
''''''''''''''''''''

member of the Object type that is an instance of the standard built-in
BigInt constructor

4.4.31 Symbol value
'''''''''''''''''''

primitive value that represents a unique, non-String Object property key

4.4.32 Symbol type
''''''''''''''''''

set of all possible Symbol values

4.4.33 Symbol object
''''''''''''''''''''

member of the Object type that is an instance of the standard built-in
Symbol constructor

4.4.34 function
'''''''''''''''

member of the Object type that may be invoked as a subroutine

In addition to its properties, a function contains executable code and
state that determine how it behaves when invoked. A function's code may
or may not be written in ECMAScript.

4.4.35 built-in function
''''''''''''''''''''''''

built-in object that is a function

Examples of built-in functions include `parseInt` and `Math.exp`. A
host or implementation may provide additional built-in functions that
are not described in this specification.

4.4.36 built-in constructor
'''''''''''''''''''''''''''

built-in function that is a constructor

Examples of built-in constructors include `Object` and `Function`. A
host or implementation may provide additional built-in constructors that
are not described in this specification.

4.4.37 property
'''''''''''''''

part of an object that associates a key (either a String value or a
Symbol value) and a value

Depending upon the form of the property the value may be represented
either directly as a data value (a primitive value, an object, or a
function object) or indirectly by a pair of accessor functions.

4.4.38 method
'''''''''''''

function that is the value of a property

When a function is called as a method of an object, the object is passed
to the function as its `this` value.

4.4.39 built-in method
''''''''''''''''''''''

method that is a built-in function

Standard built-in methods are defined in this specification. A host or
implementation may provide additional built-in methods that are not
described in this specification.

4.4.40 attribute
''''''''''''''''

internal value that defines some characteristic of a property

4.4.41 own property
'''''''''''''''''''

property that is directly contained by its object

4.4.42 inherited property
'''''''''''''''''''''''''

property of an object that is not an own property but is a property
(either own or inherited) of the object's prototype

4.5 Organization of This Specification
--------------------------------------

The remainder of this specification is organized as follows:

Clause defines the notational conventions used throughout the
specification.

Clauses through define the execution environment within which ECMAScript
programs operate.

Clauses through define the actual ECMAScript programming language
including its syntactic encoding and the execution semantics of all
language features.

Clauses through define the ECMAScript standard library. They include the
definitions of all of the standard objects that are available for use by
ECMAScript programs as they execute.

Clause describes the memory consistency model of accesses on
SharedArrayBuffer-backed memory and methods of the Atomics object.

5. Notational Conventions
=========================

https://tc39.es/ecma262/multipage/notational-conventions.html
::

   5.1 Syntactic and Lexical Grammars
      5.1.1 Context-Free Grammars
      5.1.2 The Lexical and RegExp Grammars
      5.1.3 The Numeric String Grammar
      5.1.4 The Syntactic Grammar
      5.1.5 Grammar Notation
         5.1.5.1 Terminal Symbols
         5.1.5.2 Nonterminal Symbols and Productions
         5.1.5.3 Optional Symbols
         5.1.5.4 Grammatical Parameters
         5.1.5.5 one of
         5.1.5.6 [empty]
         5.1.5.7 Lookahead Restrictions
         5.1.5.8 [no LineTerminator here]
         5.1.5.9 but not
         5.1.5.10 Descriptive Phrases
   5.2 Algorithm Conventions
      5.2.1 Abstract Operations
      5.2.2 Syntax-Directed Operations
      5.2.3 Runtime Semantics
         5.2.3.1 Completion ( completionRecord )
         5.2.3.2 Throw an Exception
         5.2.3.3 ReturnIfAbrupt
         5.2.3.4 ReturnIfAbrupt Shorthands
         5.2.3.5 Implicit Normal Completion
      5.2.4 Static Semantics
      5.2.5 Mathematical Operations
      5.2.6 Value Notation
      5.2.7 Identity

5.1 Syntactic and Lexical Grammars
----------------------------------

5.1.1 Context-Free Grammars
'''''''''''''''''''''''''''

A *context-free grammar* consists of a number of *productions*. Each
production has an abstract symbol called a *nonterminal* as its
*left-hand side*, and a sequence of zero or more nonterminal and
*terminal* symbols as its *right-hand side*. For each grammar, the
terminal symbols are drawn from a specified alphabet.

A chain production is a production that has exactly one nonterminal
symbol on its right-hand side along with zero or more terminal symbols.

Starting from a sentence consisting of a single distinguished
nonterminal, called the goal symbol, a given context-free grammar
specifies a *language*, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

5.1.2 The Lexical and RegExp Grammars
'''''''''''''''''''''''''''''''''''''

A *lexical grammar* for ECMAScript is given in clause . This grammar has
as its terminal symbols Unicode code points that conform to the rules
for `SourceCharacter` defined in . It defines a set of productions,
starting from the goal symbol `InputElementDiv`,
`InputElementTemplateTail`, `InputElementRegExp`,
`InputElementRegExpOrTemplateTail`, or
`InputElementHashbangOrRegExp`, that describe how sequences of such
code points are translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript *tokens*. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (). Simple white space and single-line comments are
discarded and do not appear in the stream of input elements for the
syntactic grammar. A `MultiLineComment` (that is, a comment of the
form `/``…`*/` regardless of whether it spans more than one line)
is likewise simply discarded if it contains no line terminator; but if a
`MultiLineComment` contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A *RegExp grammar* for ECMAScript is given in . This grammar also has as
its terminal symbols the code points as defined by `SourceCharacter`.
It defines a set of productions, starting from the goal symbol
`Pattern`, that describe how sequences of code points are translated
into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “\ **::**\ ” as separating punctuation. The lexical
and RegExp grammars share some productions.

5.1.3 The Numeric String Grammar
''''''''''''''''''''''''''''''''

A *numeric string grammar* appears in . It has as its terminal symbols
`SourceCharacter`, and is used for translating Strings into numeric
values starting from the goal symbol `StringNumericLiteral` (which is
similar to but distinct from the lexical grammar for numeric literals).

Productions of the numeric string grammar are distinguished by having
three colons “\ **:::**\ ” as punctuation, and are never used for
parsing source text.

5.1.4 The Syntactic Grammar
'''''''''''''''''''''''''''

The *syntactic grammar* for ECMAScript is given in clauses through .
This grammar has ECMAScript tokens defined by the lexical grammar as its
terminal symbols (). It defines a set of productions, starting from two
alternative goal symbols `Script` and `Module`, that describe how
sequences of tokens form syntactically correct independent components of
ECMAScript programs.

When a stream of code points is to be parsed as an ECMAScript `Script`
or `Module`, it is first converted to a stream of input elements by
repeated application of the lexical grammar; this stream of input
elements is then parsed by a single application of the syntactic
grammar. The input stream is syntactically in error if the tokens in the
stream of input elements cannot be parsed as a single instance of the
goal nonterminal (`Script` or `Module`), with no tokens left over.

When a parse is successful, it constructs a *parse tree*, a rooted tree
structure in which each node is a Parse Node. Each Parse Node is an
*instance* of a symbol in the grammar; it represents a span of the
source text that can be derived from that symbol. The root node of the
parse tree, representing the whole of the source text, is an instance of
the parse's goal symbol. When a Parse Node is an instance of a
nonterminal, it is also an instance of some production that has that
nonterminal as its left-hand side. Moreover, it has zero or more
*children*, one for each symbol on the production's right-hand side:
each child is a Parse Node that is an instance of the corresponding
symbol.

New Parse Nodes are instantiated for each invocation of the parser and
never reused between parses even of identical source text. Parse Nodes
are considered the same Parse Node if and only if they represent the
same span of source text, are instances of the same grammar symbol, and
resulted from the same parser invocation.

Parsing the same String multiple times will lead to different Parse
Nodes. For example, consider:

.. code:: javascript

             let str = "1 + 1;";
             eval(str);
             eval(str);
           

Each call to `eval` converts the value of `str` into ECMAScript
source text and performs an independent parse that creates its own
separate tree of Parse Nodes. The trees are distinct even though each
parse operates upon a source text that was derived from the same String
value.

Parse Nodes are specification artefacts, and implementations are not
required to use an analogous data structure.

Productions of the syntactic grammar are distinguished by having just
one colon “\ **:**\ ” as punctuation.

The syntactic grammar as presented in clauses through is not a complete
account of which token sequences are accepted as a correct ECMAScript
`Script` or `Module`. Certain additional token sequences are also
accepted, namely, those that would be described by the grammar if only
semicolons were added to the sequence in certain places (such as before
line terminator characters). Furthermore, certain token sequences that
are described by the grammar are not considered acceptable if a line
terminator character appears in certain “awkward” places.

In certain cases, in order to avoid ambiguities, the syntactic grammar
uses generalized productions that permit token sequences that do not
form a valid ECMAScript `Script` or `Module`. For example, this
technique is used for object literals and object destructuring patterns.
In such cases a more restrictive *supplemental grammar* is provided that
further restricts the acceptable token sequences. Typically, an early
error rule will then state that, in certain contexts, "P must cover
an N", where P is a Parse Node (an instance of the generalized
production) and N is a nonterminal from the supplemental grammar.
This means:

#. The sequence of tokens originally matched by P is parsed again
   using N as the goal symbol. If N takes grammatical
   parameters, then they are set to the same values used when P was
   originally parsed.
#. If the sequence of tokens can be parsed as a single instance of
   N, with no tokens left over, then:

   #. We refer to that instance of N (a Parse Node, unique for a
      given P) as "the N that is covered by P".
   #. All Early Error rules for N and its derived productions also
      apply to the N that is covered by P.

#. Otherwise (if the parse fails), it is an early Syntax Error.


5.1.5 Grammar Notation
''''''''''''''''''''''


5.1.5.1 Terminal Symbols
""""""""""""""""""""""""

In the ECMAScript grammars, some terminal symbols are shown in
`fixed-width` font. These are to appear in a source text exactly as
written. All terminal symbol code points specified in this way are to be
understood as the appropriate Unicode code points from the Basic Latin
block, as opposed to any similar-looking code points from other Unicode
ranges. A code point in a terminal symbol cannot be expressed by a
`\\\\` `UnicodeEscapeSequence`.

In grammars whose terminal symbols are individual Unicode code points
(i.e., the lexical, RegExp, and numeric string grammars), a contiguous
run of multiple fixed-width code points appearing in a production is a
simple shorthand for the same sequence of code points, written as
standalone terminal symbols.

For example, the production:

   HexIntegerLiteral :: `0x` HexDigits

is a shorthand for:

   HexIntegerLiteral :: `0` `x` HexDigits

In contrast, in the syntactic grammar, a contiguous run of fixed-width
code points is a single terminal symbol.

Terminal symbols come in two other forms:

- In the lexical and RegExp grammars, Unicode code points without a
  conventional printed representation are instead shown in the form
  "<ABBREV>" where "ABBREV" is a mnemonic for the code point or set of
  code points. These forms are defined in , , and .
- In the syntactic grammar, certain terminal symbols (e.g.
  `IdentifierName` and `RegularExpressionLiteral`) are shown in
  italics, as they refer to the nonterminals of the same name in the
  lexical grammar.

5.1.5.2 Nonterminal Symbols and Productions
"""""""""""""""""""""""""""""""""""""""""""

Nonterminal symbols are shown in *italic* type. The definition of a
nonterminal (also called a “production”) is introduced by the name of
the nonterminal being defined followed by one or more colons. (The
number of colons indicates to which grammar the production belongs.) One
or more alternative right-hand sides for the nonterminal then follow on
succeeding lines. For example, the syntactic definition:

   WhileStatement : 
      | `while` `(` Expression `)` Statement

states that the nonterminal `WhileStatement` represents the token
`while`, followed by a left parenthesis token, followed by an
`Expression`, followed by a right parenthesis token, followed by a
`Statement`. The occurrences of `Expression` and `Statement` are
themselves nonterminals. As another example, the syntactic definition:

   ArgumentList : 
      | AssignmentExpression ArgumentList `,`
      | AssignmentExpression

states that an `ArgumentList` may represent either a single
`AssignmentExpression` or an `ArgumentList`, followed by a comma,
followed by an `AssignmentExpression`. This definition of
`ArgumentList` is recursive, that is, it is defined in terms of
itself. The result is that an `ArgumentList` may contain any positive
number of arguments, separated by commas, where each argument expression
is an `AssignmentExpression`. Such recursive definitions of
nonterminals are common.

5.1.5.3 Optional Symbols
""""""""""""""""""""""""

The subscripted suffix “\ :sub:`opt`\ ”, which may appear after a
terminal or nonterminal, indicates an optional symbol. The alternative
containing the optional symbol actually specifies two right-hand sides,
one that omits the optional element and one that includes it. This means
that:

   VariableDeclaration : 
      | BindingIdentifier Initializer\ :sub:`opt`

is a convenient abbreviation for:

   VariableDeclaration : 
      | BindingIdentifier BindingIdentifier Initializer

and that:

   ForStatement : 
      | `for` `(` LexicalDeclaration Expression\ :sub:`opt` `;` Expression\ :sub:`opt` `)` Statement

is a convenient abbreviation for:

   ForStatement : 
      | `for` `(` LexicalDeclaration `;` Expression\ :sub:`opt` `)` Statement 
      | `for` `(` LexicalDeclaration Expression `;` Expression\ :sub:`opt` `)` Statement

which in turn is an abbreviation for:

   ForStatement : 
      | `for` `(` LexicalDeclaration `;` `)` Statement
      | `for` `(` LexicalDeclaration `;` Expression `)` Statement
      | `for` `(` LexicalDeclaration Expression `;` `)` Statement
      | `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement

so, in this example, the nonterminal `ForStatement` actually has four
alternative right-hand sides.

5.1.5.4 Grammatical Parameters
""""""""""""""""""""""""""""""

A production may be parameterized by a subscripted annotation of the
form “\ :sub:`[parameters]`\ ”, which may appear as a suffix to the
nonterminal symbol defined by the production. “\ :sub:`parameters`\ ”
may be either a single name or a comma separated list of names. A
parameterized production is shorthand for a set of productions defining
all combinations of the parameter names, preceded by an underscore,
appended to the parameterized nonterminal symbol. This means that:

   StatementList[Return] : 
      | ReturnStatement 
      | ExpressionStatement

is a convenient abbreviation for:

   StatementList : 
      | ReturnStatement 
      | ExpressionStatement
   
   StatementList_Return : 
      | ReturnStatement 
      | ExpressionStatement

and that:

   StatementList[Return, In] : 
      | ReturnStatement 
      | ExpressionStatement

is an abbreviation for:

   StatementList : 
      | ReturnStatement 
      | ExpressionStatement 

   StatementList_Return : 
      | ReturnStatement
      | ExpressionStatement

   StatementList_In : 
      | ReturnStatement
      | ExpressionStatement 

   StatementList_Return_In : 
      | ReturnStatement
      | ExpressionStatement

Multiple parameters produce a combinatoric number of productions, not
all of which are necessarily referenced in a complete grammar.

References to nonterminals on the right-hand side of a production can
also be parameterized. For example:

   StatementList : 
      | ReturnStatement 
      | ExpressionStatement[+In]

is equivalent to saying:

   StatementList : 
      | ReturnStatement 
      | ExpressionStatement_In

and:

   StatementList : 
      | ReturnStatement 
      | ExpressionStatement[~In]

is equivalent to:

   StatementList : 
      | ReturnStatement 
      | ExpressionStatement

A nonterminal reference may have both a parameter list and an
“\ :sub:`opt`\ ” suffix. For example:

   VariableDeclaration : 
      | BindingIdentifier 
      | Initializer[+In] :sub:`opt`

is an abbreviation for:

   VariableDeclaration : 
      | BindingIdentifier 
      | BindingIdentifier Initializer_In

Prefixing a parameter name with “\ :sub:`?`\ ” on a right-hand side
nonterminal reference makes that parameter value dependent upon the
occurrence of the parameter name on the reference to the current
production's left-hand side symbol. For example:

   VariableDeclaration[In] : 
      | BindingIdentifier Initializer[?In]

is an abbreviation for:

   VariableDeclaration : 
      | BindingIdentifier Initializer

   VariableDeclaration_In : 
      | BindingIdentifier Initializer_In

If a right-hand side alternative is prefixed with “[+parameter]” that
alternative is only available if the named parameter was used in
referencing the production's nonterminal symbol. If a right-hand side
alternative is prefixed with “[\\~parameter]” that alternative is only
available if the named parameter was *not* used in referencing the
production's nonterminal symbol. This means that:

   StatementList[Return] : 
      | [+Return] ReturnStatement 
      | ExpressionStatement

is an abbreviation for:

   StatementList : 
      | ExpressionStatement 

   StatementList_Return :
      | ReturnStatement 
      | ExpressionStatement

and that:

   StatementList[Return] : 
      | [~Return] ReturnStatement 
      | ExpressionStatement

is an abbreviation for:

   StatementList : 
      | ReturnStatement 
      | ExpressionStatement 

   StatementList_Return : 
      | ExpressionStatement

5.1.5.5 one of
""""""""""""""

When the words “\ **one of**\ ” follow the colon(s) in a grammar
definition, they signify that each of the terminal symbols on the
following line or lines is an alternative definition. For example, the
lexical grammar for ECMAScript contains the production:

   NonZeroDigit :: one of 
      | `1` `2` `3` `4` `5` `6` `7` `8` `9`

which is merely a convenient abbreviation for:

   NonZeroDigit :: 
      | `1` 
      | `2` 
      | `3` 
      | `4` 
      | `5` 
      | `6` 
      | `7` 
      | `8` 
      | `9`

5.1.5.6 [empty]
"""""""""""""""

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

5.1.5.7 Lookahead Restrictions
""""""""""""""""""""""""""""""

If the phrase “[lookahead = seq]” appears in the right-hand side of
a production, it indicates that the production may only be used if the
token sequence seq is a prefix of the immediately following input
token sequence. Similarly, “[lookahead ∈ set]”, where set is a
finite non-empty set of token sequences, indicates that the production
may only be used if some element of set is a prefix of the
immediately following token sequence. For convenience, the set can also
be written as a nonterminal, in which case it represents the set of all
token sequences to which that nonterminal could expand. It is considered
an editorial error if the nonterminal could expand to infinitely many
distinct token sequences.

These conditions may be negated. “[lookahead ≠ seq]” indicates that
the containing production may only be used if seq is *not* a prefix
of the immediately following input token sequence, and “[lookahead ∉
set]” indicates that the production may only be used if *no* element
of set is a prefix of the immediately following token sequence.

As an example, given the definitions:

   DecimalDigit :: one of 
      | `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` 

   DecimalDigits :: 
      | DecimalDigit 
      | DecimalDigits DecimalDigit

the definition:

   LookaheadExample :: 
      | `n` [lookahead ∉ { `1`, `3`, `5`, `7`, `9` }] DecimalDigits 
      | DecimalDigit [lookahead ∉ DecimalDigit]

matches either the letter `n` followed by one or more decimal digits
the first of which is even, or a decimal digit not followed by another
decimal digit.

Note that when these phrases are used in the syntactic grammar, it may
not be possible to unambiguously identify the immediately following
token sequence because determining later tokens requires knowing which
lexical goal symbol to use at later positions. As such, when these are
used in the syntactic grammar, it is considered an editorial error for a
token sequence seq to appear in a lookahead restriction (including
as part of a set of sequences) if the choices of lexical goal symbols to
use could change whether or not seq would be a prefix of the
resulting token sequence.

5.1.5.8 [no LineTerminator here]
""""""""""""""""""""""""""""""""

If the phrase “[no `LineTerminator` here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is *a restricted production*: it may not be used if a
`LineTerminator` occurs in the input stream at the indicated position.
For example, the production:

   ThrowStatement : 
      | `throw` [no LineTerminator here] Expression `;`

indicates that the production may not be used if a `LineTerminator`
occurs in the script between the `throw` token and the `Expression`.

Unless the presence of a `LineTerminator` is forbidden by a restricted
production, any number of occurrences of `LineTerminator` may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the script.

5.1.5.9 but not
"""""""""""""""

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “\ **but not**\ ” and then
indicating the expansions to be excluded. For example, the production:

   Identifier :: 
      | IdentifierName but not ReservedWord

means that the nonterminal `Identifier` may be replaced by any
sequence of code points that could replace `IdentifierName` provided
that the same sequence of code points could not replace
`ReservedWord`.

5.1.5.10 Descriptive Phrases
""""""""""""""""""""""""""""

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

   SourceCharacter :: 
      | any Unicode code point

5.2 Algorithm Conventions
-------------------------

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

Algorithms may be explicitly parameterized with an ordered,
comma-separated sequence of alias names which may be used within the
algorithm steps to reference the argument passed in that position.
Optional parameters are denoted with surrounding brackets ([ , name
]) and are no different from required parameters within algorithm steps.
A rest parameter may appear at the end of a parameter list, denoted with
leading ellipsis (, ..._name). The rest parameter captures all of the
arguments provided following the required and optional parameters into a
List. If there are no such additional arguments, that List is empty.

Algorithm steps may be subdivided into sequential substeps. Substeps are
indented and may themselves be further divided into indented substeps.
Outline numbering conventions are used to identify substeps with the
first level of substeps labelled with lowercase alphabetic characters
and the second level of substeps labelled with lowercase roman numerals.
If more than three levels are required these rules repeat with the
fourth level using numeric labels. For example::

   1. Top-level step 
      a. Substep. 
      b. Substep. 
         i. Subsubstep. 
            1. Subsubsubstep 
               a. Subsubsubsubstep 
                  i. Subsubsubsubsubstep

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step that begins with “Assert:” asserts an invariant condition of its
algorithm. Such assertions are used to make explicit algorithmic
invariants that would otherwise be implicit. Such assertions add no
additional semantic requirements and hence need not be checked by an
implementation. They are used simply to clarify algorithms.

Algorithm steps may declare named aliases for any value using the form
“Let x be someValue”. These aliases are reference-like in that
both x and someValue refer to the same underlying data and
modifications to either are visible to both. Algorithm steps that want
to avoid this reference-like behaviour should explicitly make a copy of
the right-hand side: “Let x be a copy of someValue” creates a
shallow copy of someValue.

Once declared, an alias may be referenced in any subsequent steps and
must not be referenced from steps prior to the alias's declaration.
Aliases may be modified using the form “Set x to someOtherValue”.

5.2.1 Abstract Operations
'''''''''''''''''''''''''

In order to facilitate their use in multiple parts of this
specification, some algorithms, called abstract operations, are named
and written in parameterized functional form so that they may be
referenced by name from within other algorithms. Abstract operations are
typically referenced using a functional application style such as
`OperationName(arg1, arg2)`. Some abstract operations are treated
as polymorphically dispatched methods of class-like specification
abstractions. Such method-like abstract operations are typically
referenced using a method application style such as
`someValue.OperationName(arg1, arg2)`.

5.2.2 Syntax-Directed Operations
''''''''''''''''''''''''''''''''

A syntax-directed operation is a named operation whose definition
consists of algorithms, each of which is associated with one or more
productions from one of the ECMAScript grammars. A production that has
multiple alternative definitions will typically have a distinct
algorithm for each alternative. When an algorithm is associated with a
grammar production, it may reference the terminal and nonterminal
symbols of the production alternative as if they were parameters of the
algorithm. When used in this manner, nonterminal symbols refer to the
actual alternative definition that is matched when parsing the source
text. The source text matched by a grammar production or Parse Node
derived from it is the portion of the source text that starts at the
beginning of the first terminal that participated in the match and ends
at the end of the last terminal that participated in the match.

When an algorithm is associated with a production alternative, the
alternative is typically shown without any “[ ]” grammar annotations.
Such annotations should only affect the syntactic recognition of the
alternative and have no effect on the associated semantics for the
alternative.

Syntax-directed operations are invoked with a parse node and,
optionally, other parameters by using the conventions on steps , , and
in the following algorithm:

1. Let `status` be SyntaxDirectedOperation of `SomeNonTerminal`. 
2. Let `someParseNode` be the parse of some source text. 
3. Perform SyntaxDirectedOperation of `someParseNode`. 
4. Perform SyntaxDirectedOperation of `someParseNode` with argument `"value"`.

Unless explicitly specified otherwise, all chain productions have an
implicit definition for every operation that might be applied to that
production's left-hand side nonterminal. The implicit definition simply
reapplies the same operation with the same parameters, if any, to the
chain production's sole right-hand side nonterminal and then returns the
result. For example, assume that some algorithm has a step of the form:
“Return Evaluation of `Block`” and that there is a production:

   Block : 
      `{` StatementList `}`

but the Evaluation operation does not associate an algorithm with that
production. In that case, the Evaluation operation implicitly includes
an association of the form:

**Runtime Semantics: Evaluation**

   Block : `{` StatementList `}` 
      1. Return Evaluation of `StatementList`.

5.2.3 Runtime Semantics
'''''''''''''''''''''''

Algorithms which specify semantics that must be called at runtime are
called runtime semantics. Runtime semantics are defined by abstract
operations or syntax-directed operations.

5.2.3.1 Completion ( completionRecord )
"""""""""""""""""""""""""""""""""""""""

description
   It is used to emphasize that a Completion Record is being returned.

1. Assert: completionRecord is a Completion Record. 
2. Return completionRecord.

5.2.3.2 Throw an Exception
""""""""""""""""""""""""""

Algorithms steps that say to throw an exception, such as

1. Throw a `TypeError` exception.

mean the same things as:

1. Return ThrowCompletion(a newly created `TypeError` object).

5.2.3.3 ReturnIfAbrupt
""""""""""""""""""""""

Algorithms steps that say or are otherwise equivalent to:

1. ReturnIfAbrupt(argument).

mean the same thing as:

1. Assert: argument is a Completion Record. 
2. If argument is an abrupt completion, return Completion(argument). 
3. Else, set argument to argument.[[Value]].

Algorithms steps that say or are otherwise equivalent to:

1. ReturnIfAbrupt(AbstractOperation()).

mean the same thing as:

1. Let `hygienicTemp` be AbstractOperation(). 
2. Assert: `hygienicTemp` is a Completion Record. 
3. If `hygienicTemp` is an abrupt completion, return Completion(`hygienicTemp`). 
4. Else, set `hygienicTemp` to `hygienicTemp`.[[Value]].

Where `hygienicTemp` is ephemeral and visible only in the steps
pertaining to ReturnIfAbrupt.

Algorithms steps that say or are otherwise equivalent to:

1. Let result be AbstractOperation(ReturnIfAbrupt(argument)).

mean the same thing as:

1. Assert: argument is a Completion Record. 
2. If argument is an abrupt completion, return Completion(argument). 
3. Else, set argument to argument.[[Value]]. 
4. Let result be AbstractOperation(argument).

5.2.3.4 ReturnIfAbrupt Shorthands
"""""""""""""""""""""""""""""""""

Invocations of abstract operations and syntax-directed operations that
are prefixed by `?` indicate that ReturnIfAbrupt should be applied to
the resulting Completion Record. For example, the step:

   1. ? OperationName().

is equivalent to the following step:

   1. ReturnIfAbrupt(OperationName()).

Similarly, for method application style, the step:

   1. ? someValue.OperationName().

is equivalent to:

   1. ReturnIfAbrupt(someValue.OperationName()).

Similarly, prefix `!` is used to indicate that the following
invocation of an abstract or syntax-directed operation will never return
an abrupt completion and that the resulting Completion Record's
[[Value]] field should be used in place of the return value of the
operation. For example, the step:

   1. Let val be ! OperationName().

is equivalent to the following steps:

   1. Let val be OperationName(). 
   2. Assert: val is a normal completion. 
   3. Set val to val.[[Value]].

Syntax-directed operations for runtime semantics make use of this
shorthand by placing `!` or `?` before the invocation of the
operation:

   1. Perform ! SyntaxDirectedOperation of `NonTerminal`.

5.2.3.5 Implicit Normal Completion
""""""""""""""""""""""""""""""""""

In algorithms within abstract operations which are declared to return a
Completion Record, and within all built-in functions, the returned value
is first passed to NormalCompletion, and the result is used instead.
This rule does not apply within the Completion algorithm or when the
value being returned is clearly marked as a Completion Record in that
step; these cases are:

- when the result of applying Completion, NormalCompletion,
  ThrowCompletion, or ReturnCompletion is directly returned
- when the result of constructing a Completion Record is directly
  returned

It is an editorial error if a Completion Record is returned from such an
abstract operation through any other means. For example, within these
abstract operations,

   1. Return `true`.

means the same things as any of

   1. Return NormalCompletion(`true`).

or

   1. Let completion be NormalCompletion(`true`). 
   2. Return Completion(completion).

or

   1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: `true`,
   [[Target]]: ~empty~ }.

Note that, through the ReturnIfAbrupt expansion, the following example
is allowed, as within the expanded steps, the result of applying
Completion is returned directly in the abrupt case and the implicit
NormalCompletion application occurs after unwrapping in the normal case.

   1. Return ? completion.

The following example would be an editorial error because a Completion
Record is being returned without being annotated in that step.

   1. Let completion be NormalCompletion(`true`). 
   2. Return completion.

5.2.4 Static Semantics
''''''''''''''''''''''

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements form a valid
ECMAScript `Script` or `Module` that may be evaluated. In some
situations additional rules are needed that may be expressed using
either ECMAScript algorithm conventions or prose requirements. Such
rules are always associated with a production of a grammar and are
called the static semantics of the production.

Static Semantic Rules have names and typically are defined using an
algorithm. Named Static Semantic Rules are associated with grammar
productions and a production that has multiple alternative definitions
will typically have for each alternative a distinct algorithm for each
applicable named static semantic rule.

A special kind of static semantic rule is an Early Error Rule. Early
error rules define early error conditions (see clause ) that are
associated with specific grammar productions. Evaluation of most early
error rules are not explicitly invoked within the algorithms of this
specification. A conforming implementation must, prior to the first
evaluation of a `Script` or `Module`, validate all of the early
error rules of the productions used to parse that `Script` or
`Module`. If any of the early error rules are violated the `Script`
or `Module` is invalid and cannot be evaluated.

5.2.5 Mathematical Operations
'''''''''''''''''''''''''''''

This specification makes reference to these kinds of numeric values:

- Mathematical values: Arbitrary real numbers, used as the default numeric type.
- Extended mathematical values: Mathematical values together with +∞ and -∞.
- *Numbers*: IEEE 754-2019 binary64 (double-precision floating point) values.
- *BigInts*: ECMAScript language values representing arbitrary integers
  in a one-to-one correspondence.

In the language of this specification, numerical values are
distinguished among different numeric kinds using subscript suffixes.
The subscript :sub:`𝔽` refers to Numbers, and the subscript :sub:`ℤ`
refers to BigInts. Numeric values without a subscript suffix refer to
mathematical values. This specification denotes most numeric values in
base 10; it also uses numeric values of the form 0x followed by digits
0-9 or A-F as base-16 values.

In general, when this specification refers to a numerical value, such as
in the phrase, "the length of y" or "the integer represented by the
four hexadecimal digits ...", without explicitly specifying a numeric
kind, the phrase refers to a mathematical value. Phrases which refer to
a Number or a BigInt value are explicitly annotated as such; for
example, "the Number value for the number of code points in …" or "the
BigInt value for …".

When the term integer is used in this specification, it refers to a
mathematical value which is in the set of integers, unless otherwise
stated. When the term integral Number is used in this specification, it
refers to a finite Number value whose mathematical value is in the set
of integers.

Numeric operators such as +, ×, =, and ≥ refer to those operations as
determined by the type of the operands. When applied to mathematical
values, the operators refer to the usual mathematical operations. When
applied to extended mathematical values, the operators refer to the
usual mathematical operations over the extended real numbers;
indeterminate forms are not defined and their use in this specification
should be considered an editorial error. When applied to Numbers, the
operators refer to the relevant operations within IEEE 754-2019. When
applied to BigInts, the operators refer to the usual mathematical
operations applied to the mathematical value of the BigInt. Numeric
operators applied to mixed-type operands (such as a Number and a
mathematical value) are not defined and should be considered an
editorial error in this specification.

Conversions between mathematical values and Numbers or BigInts are
always explicit in this document. A conversion from a mathematical value
or extended mathematical value x to a Number is denoted as "the
Number value for x" or 𝔽(x), and is defined in . A conversion
from an integer x to a BigInt is denoted as "the BigInt value for
x" or ℤ(x). A conversion from a Number or BigInt x to a
mathematical value is denoted as "the mathematical value of x", or
ℝ(x). The mathematical value of `+0`\ :sub:`𝔽` and
`-0`\ :sub:`𝔽` is the mathematical value 0. The mathematical value of
non-finite values is not defined. The extended mathematical value of
x is the mathematical value of x for finite values, and is +∞
and -∞ for `+∞`\ :sub:`𝔽` and `-∞`\ :sub:`𝔽` respectively; it is not
defined for `NaN`.

The mathematical function abs(x) produces the absolute value of
x, which is -x if x < 0 and otherwise is x itself.

The mathematical function min(x1, x2, … , xN) produces the
mathematically smallest of x1 through xN. The mathematical
function max(x1, x2, ..., xN) produces the mathematically
largest of x1 through xN. The domain and range of these
mathematical functions are the extended mathematical values.

The notation “x modulo y” (y must be finite and non-zero)
computes a value k of the same sign as y (or zero) such that
abs(k) < abs(y) and x - k = q × y for some
integer q.

The phrase "the result of clamping x between lower and
upper" (where x is an extended mathematical value and lower
and upper are mathematical values such that lower ≤ upper)
produces lower if x < lower, produces upper if x >
upper, and otherwise produces x.

The mathematical function floor(x) produces the largest integer
(closest to +∞) that is not larger than x.

floor(x) = x - (x modulo 1).

The mathematical function truncate(x) removes the fractional part of
x by rounding towards zero, producing -floor(-x) if x < 0
and otherwise producing floor(x).

Mathematical functions min, max, abs, floor, and truncate are not
defined for Numbers and BigInts, and any usage of those methods that
have non-mathematical value arguments would be an editorial error in
this specification.

An interval from lower bound a to upper bound b is a
possibly-infinite, possibly-empty set of numeric values of the same
numeric type. Each bound will be described as either inclusive or
exclusive, but not both. There are four kinds of intervals, as follows:

- An interval from a (inclusive) to b (inclusive), also called
  an inclusive interval from a to b, includes all values x
  of the same numeric type such that a ≤ x ≤ b, and no
  others.

- An interval from a (inclusive) to b (exclusive) includes all
  values x of the same numeric type such that a ≤ x < b,
  and no others.

- An interval from a (exclusive) to b (inclusive) includes all
  values x of the same numeric type such that a < x ≤ b,
  and no others.

- An interval from a (exclusive) to b (exclusive) includes all
  values x of the same numeric type such that a < x < b,
  and no others.

For example, the interval from 1 (inclusive) to 2 (exclusive) consists
of all mathematical values between 1 and 2, including 1 and not
including 2. For the purpose of defining intervals, `-0`\ :sub:`𝔽` <
`+0`\ :sub:`𝔽`, so, for example, an inclusive interval with a lower
bound of `+0`\ :sub:`𝔽` includes `+0`\ :sub:`𝔽` but not
`-0`\ :sub:`𝔽`. `NaN` is never included in an interval.

5.2.6 Value Notation
''''''''''''''''''''

In this specification, ECMAScript language values are displayed in
`bold`. Examples include `null`, `true`, or `"hello"`. These are
distinguished from ECMAScript source text such as
`Function.prototype.apply` or `let n = 42;`.

5.2.7 Identity
''''''''''''''

In this specification, both specification values and ECMAScript language
values are compared for equality. When comparing for equality, values
fall into one of two categories. Values without identity are equal to
other values without identity if all of their innate characteristics are
the same — characteristics such as the magnitude of an integer or the
length of a sequence. Values without identity may be manifest without
prior reference by fully describing their characteristics. In contrast,
each value with identity is unique and therefore only equal to itself.
Values with identity are like values without identity but with an
additional unguessable, unchangeable, universally-unique characteristic
called *identity*. References to existing values with identity cannot be
manifest simply by describing them, as the identity itself is
indescribable; instead, references to these values must be explicitly
passed from one place to another. Some values with identity are mutable
and therefore can have their characteristics (except their identity)
changed in-place, causing all holders of the value to observe the new
characteristics. A value without identity is never equal to a value with
identity.

From the perspective of this specification, the word “is” is used to
compare two values for equality, as in “If bool is `true`, then
...”, and the word “contains” is used to search for a value inside lists
using equality comparisons, as in "If list contains a Record r
such that r.[[Foo]] is `true`, then ...". The *specification
identity* of values determines the result of these comparisons and is
axiomatic in this specification.

From the perspective of the ECMAScript language, language values are
compared for equality using the SameValue abstract operation and the
abstract operations it transitively calls. The algorithms of these
comparison abstract operations determine *language identity* of
ECMAScript language values.

For specification values, examples of values without specification
identity include, but are not limited to: mathematical values and
extended mathematical values; ECMAScript source text, surrogate pairs,
Directive Prologues, etc; UTF-16 code units; Unicode code points; enums;
abstract operations, including syntax-directed operations, host hooks,
etc; and ordered pairs. Examples of specification values with
specification identity include, but are not limited to: any kind of
Records, including Property Descriptors, PrivateElements, etc; Parse
Nodes; Lists; Sets and Relations; Abstract Closures; Data Blocks;
Private Names; execution contexts and execution context stacks; agent
signifiers; and WaiterList Records.

Specification identity agrees with language identity for all ECMAScript
language values except Symbol values produced by Symbol.for. The
ECMAScript language values without specification identity and without
language identity are `undefined`, `null`, Booleans, Strings,
Numbers, and BigInts. The ECMAScript language values with specification
identity and language identity are Symbols not produced by Symbol.for
and Objects. Symbol values produced by Symbol.for have specification
identity, but not language identity.

6. ECMAScript Data Types and Values
===================================

https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html
::

   6.1 ECMAScript Language Types
      6.1.1 The Undefined Type
      6.1.2 The Null Type
      6.1.3 The Boolean Type
      6.1.4 The String Type
         6.1.4.1 StringIndexOf ( string, searchValue, fromIndex )
         6.1.4.2 StringLastIndexOf ( string, searchValue, fromIndex )
      6.1.5 The Symbol Type
         6.1.5.1 Well-Known Symbols
      6.1.6 Numeric Types
         6.1.6.1 The Number Type
            6.1.6.1.1 Number::unaryMinus ( x )
            6.1.6.1.2 Number::bitwiseNOT ( x )
            6.1.6.1.3 Number::exponentiate ( base, exponent )
            6.1.6.1.4 Number::multiply ( x, y )
            6.1.6.1.5 Number::divide ( x, y )
            6.1.6.1.6 Number::remainder ( n, d )
            6.1.6.1.7 Number::add ( x, y )
            6.1.6.1.8 Number::subtract ( x, y )
            6.1.6.1.9 Number::leftShift ( x, y )
            6.1.6.1.10 Number::signedRightShift ( x, y )
            6.1.6.1.11 Number::unsignedRightShift ( x, y )
            6.1.6.1.12 Number::lessThan ( x, y )
            6.1.6.1.13 Number::equal ( x, y )
            6.1.6.1.14 Number::sameValue ( x, y )
            6.1.6.1.15 Number::sameValueZero ( x, y )
            6.1.6.1.16 NumberBitwiseOp ( op, x, y )
            6.1.6.1.17 Number::bitwiseAND ( x, y )
            6.1.6.1.18 Number::bitwiseXOR ( x, y )
            6.1.6.1.19 Number::bitwiseOR ( x, y )
            6.1.6.1.20 Number::toString ( x, radix )
         6.1.6.2 The BigInt Type
            6.1.6.2.1 BigInt::unaryMinus ( x )
            6.1.6.2.2 BigInt::bitwiseNOT ( x )
            6.1.6.2.3 BigInt::exponentiate ( base, exponent )
            6.1.6.2.4 BigInt::multiply ( x, y )
            6.1.6.2.5 BigInt::divide ( x, y )
            6.1.6.2.6 BigInt::remainder ( n, d )
            6.1.6.2.7 BigInt::add ( x, y )
            6.1.6.2.8 BigInt::subtract ( x, y )
            6.1.6.2.9 BigInt::leftShift ( x, y )
            6.1.6.2.10 BigInt::signedRightShift ( x, y )
            6.1.6.2.11 BigInt::unsignedRightShift ( x, y )
            6.1.6.2.12 BigInt::lessThan ( x, y )
            6.1.6.2.13 BigInt::equal ( x, y )
            6.1.6.2.14 BinaryAnd ( x, y )
            6.1.6.2.15 BinaryOr ( x, y )
            6.1.6.2.16 BinaryXor ( x, y )
            6.1.6.2.17 BigIntBitwiseOp ( op, x, y )
            6.1.6.2.18 BigInt::bitwiseAND ( x, y )
            6.1.6.2.19 BigInt::bitwiseXOR ( x, y )
            6.1.6.2.20 BigInt::bitwiseOR ( x, y )
            6.1.6.2.21 BigInt::toString ( x, radix )
      6.1.7 The Object Type
         6.1.7.1 Property Attributes
         6.1.7.2 Object Internal Methods and Internal Slots
         6.1.7.3 Invariants of the Essential Internal Methods
         6.1.7.4 Well-Known Intrinsic Objects
   6.2 ECMAScript Specification Types
      6.2.1 The Enum Specification Type
      6.2.2 The List and Record Specification Types
      6.2.3 The Set and Relation Specification Types
      6.2.4 The Completion Record Specification Type
         6.2.4.1 NormalCompletion ( value )
         6.2.4.2 ThrowCompletion ( value )
         6.2.4.3 ReturnCompletion ( value )
         6.2.4.4 UpdateEmpty ( completionRecord, value )
      6.2.5 The Reference Record Specification Type
         6.2.5.1 IsPropertyReference ( V )
         6.2.5.2 IsUnresolvableReference ( V )
         6.2.5.3 IsSuperReference ( V )
         6.2.5.4 IsPrivateReference ( V )
         6.2.5.5 GetValue ( V )
         6.2.5.6 PutValue ( V, W )
         6.2.5.7 GetThisValue ( V )
         6.2.5.8 InitializeReferencedBinding ( V, W )
         6.2.5.9 MakePrivateReference ( baseValue, privateIdentifier )
      6.2.6 The Property Descriptor Specification Type
      6.2.7 The Environment Record Specification Type
      6.2.8 The Abstract Closure Specification Type
      6.2.9 Data Blocks
      6.2.10 The PrivateElement Specification Type
      6.2.11 The ClassFieldDefinition Record Specification Type
      6.2.12 Private Names
      6.2.13 The ClassStaticBlockDefinition Record Specification Type


Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further classified into ECMAScript language
types and specification types.

6.1 ECMAScript Language Types
-----------------------------

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Symbol, Number, BigInt, and Object. An ECMAScript language value is a
value that is characterized by an ECMAScript language type.

6.1.1 The Undefined Type
''''''''''''''''''''''''

The Undefined type has exactly one value, called `undefined`. Any
variable that has not been assigned a value has the value `undefined`.

6.1.2 The Null Type
'''''''''''''''''''

The Null type has exactly one value, called `null`.

6.1.3 The Boolean Type
''''''''''''''''''''''

The Boolean type represents a logical entity having two values, called
`true` and `false`.

6.1.4 The String Type
'''''''''''''''''''''

The String type is the set of all ordered sequences of zero or more
16-bit unsigned integer values (“elements”) up to a maximum length of
2\ :sup:`53` - 1 elements. The String type is generally used to
represent textual data in a running ECMAScript program, in which case
each element in the String is treated as a UTF-16 code unit value. Each
element is regarded as occupying a position within the sequence. These
positions are indexed with non-negative integers. The first element (if
any) is at index 0, the next element (if any) at index 1, and so on. The
length of a String is the number of elements (i.e., 16-bit values)
within it. The empty String has length zero and therefore contains no
elements.

ECMAScript operations that do not interpret String contents apply no
further semantics. Operations that do interpret String values treat each
element as a single UTF-16 code unit. However, ECMAScript does not
restrict the value of or relationships between these code units, so
operations that further interpret String contents as sequences of
Unicode code points encoded in UTF-16 must account for ill-formed
subsequences. Such operations apply special treatment to every code unit
with a numeric value in the inclusive interval from 0xD800 to 0xDBFF
(defined by the Unicode Standard as a leading surrogate, or more
formally as a high-surrogate code unit) and every code unit with a
numeric value in the inclusive interval from 0xDC00 to 0xDFFF (defined
as a trailing surrogate, or more formally as a low-surrogate code unit)
using the following rules:

- A code unit that is not a leading surrogate and not a trailing
  surrogate is interpreted as a code point with the same value.
- A sequence of two code units, where the first code unit c1 is a
  leading surrogate and the second code unit c2 a trailing
  surrogate, is a surrogate pair and is interpreted as a code point with
  the value (c1 - 0xD800) × 0x400 + (c2 - 0xDC00) + 0x10000.
  (See )
- A code unit that is a leading surrogate or trailing surrogate, but is
  not part of a surrogate pair, is interpreted as a code point with the
  same value.

The function `String.prototype.normalize` (see ) can be used to
explicitly normalize a String value. `String.prototype.localeCompare`
(see ) internally normalizes String values, but no other operations
implicitly normalize the strings upon which they operate. Operation
results are not language- and/or locale-sensitive unless stated
otherwise.

The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. If ECMAScript source
text is in Normalized Form C, string literals are guaranteed to also be
normalized, as long as they do not contain any Unicode escape sequences.

In this specification, the phrase "the string-concatenation of A,
B, ..." (where each argument is a String value, a code unit, or a
sequence of code units) denotes the String value whose sequence of code
units is the concatenation of the code units (in order) of each of the
arguments (in order).

The phrase "the substring of S from inclusiveStart to
exclusiveEnd" (where S is a String value or a sequence of code
units and inclusiveStart and exclusiveEnd are integers) denotes
the String value consisting of the consecutive code units of S
beginning at index inclusiveStart and ending immediately before
index exclusiveEnd (which is the empty String when
inclusiveStart = exclusiveEnd). If the "to" suffix is omitted,
the length of S is used as the value of exclusiveEnd.

| The phrase "the ASCII word characters" denotes the following String
  value, which consists solely of every letter and number in the Unicode
  Basic Latin block along with U+005F (LOW LINE):
| `"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"`.
| For historical reasons, it has significance to various algorithms.

6.1.4.1 StringIndexOf ( string, searchValue, fromIndex )
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

   StringIndexOf ( string: a String, searchValue: a String, fromIndex: a non-negative integer, ): 
   a non-negative integer or ~not-found~

1. Let len be the length of string. 1. If searchValue is the
empty String and fromIndex ≤ len, return fromIndex. 1. Let
searchLen be the length of searchValue. 1. For each integer
i such that fromIndex ≤ i ≤ len - searchLen, in
ascending order, do 1. Let candidate be the substring of string
from i to i + searchLen. 1. If candidate is
searchValue, return i. 1. Return ~not-found~.

If searchValue is the empty String and fromIndex ≤ the length of
string, this algorithm returns fromIndex. The empty String is
effectively found at every position within a string, including after the
last code unit.

This algorithm always returns ~not-found~ if fromIndex + the length
of searchValue > the length of string.

6.1.4.2 StringLastIndexOf ( string, searchValue, fromIndex )
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

   StringLastIndexOf ( string: a String, searchValue: a String, fromIndex: a non-negative integer, ): 
   a non-negative integer or ~not-found~

1. Let len be the length of string. 1. Let searchLen be the
length of searchValue. 1. Assert: fromIndex + searchLen ≤
len. 1. For each integer i such that 0 ≤ i ≤ fromIndex,
in descending order, do 1. Let candidate be the substring of
string from i to i + searchLen. 1. If candidate is
searchValue, return i. 1. Return ~not-found~.

If searchValue is the empty String, this algorithm returns
fromIndex. The empty String is effectively found at every position
within a string, including after the last code unit.

6.1.5 The Symbol Type
'''''''''''''''''''''


The Symbol type is the set of all non-String values that may be used as
the key of an Object property ().

Each possible Symbol value is unique and immutable.

Each Symbol value immutably holds an associated value called
[[Description]] that is either `undefined` or a String value.

6.1.5.1 Well-Known Symbols
""""""""""""""""""""""""""


Well-known symbols are built-in Symbol values that are explicitly
referenced by algorithms of this specification. They are typically used
as the keys of properties whose values serve as extension points of a
specification algorithm. Unless otherwise specified, well-known symbols
values are shared by all realms ().

Within this specification a well-known symbol is referred to using the
standard intrinsic notation where the intrinsic is one of the values
listed in .

.. Note::

   Previous editions of this specification used a notation of the form
   @@name, where the current edition would use `%Symbol.name%`. In
   particular, the following names were used: @@asyncIterator,
   @@hasInstance, @@isConcatSpreadable, @@iterator, @@match, @@matchAll,
   @@replace, @@search, @@species, @@split, @@toPrimitive, @@toStringTag,
   and @@unscopables.

=========================== =========================== ======================
Specification Name          [[Description]]             Value and Purpose
=========================== =========================== ======================
%Symbol.asyncIterator%      "Symbol.asyncIterator"      A method that returns the default async iterator for an object. 
                                                        Called by the semantics of the `fo r`-`await`-`of` statement. 
%Symbol.hasInstance%        "Symbol.hasInstance"        A method that determines if a constructor object recognizes an 
                                                        object as one of the constructor's instances. Called by the 
                                                        semantics of the `instanceof` operator. 
%Symbol.isConcatSpreadable% "Symbol.isConcatSpreadable" A Boolean valued property that if true indicates that an object 
                                                        should be flattened to its array elements by `Array .prototype.concat`. 
%Symbol.iterator%           "Symbol.iterator"           A method that returns the default iterator for an object. Called 
                                                        by the semantics of the for-of statement. 
%Symbol.match%              "Symbol.match"`             regular expression method that matches the regular expression 
                                                        against a string. Called by the `Stri ng.prototype.match` method. 
%Symbol.matchAll%           "Symbol.matchAll"           A regular expression method that returns an iterator that yields 
                                                        matches of the regular expression against a string. Called by the 
                                                        `String. prototype.matchAll` method. 
%Symbol.replace%            "Symbol.replace"            regular expression method that replaces matched substrings of a 
                                                        string. Called by the `String .prototype.replace` method. 
%Symbol.search%             "Symbol.search"             regular expression method that returns the index within a string 
                                                        that matches the regular expression. Called by the `Strin g.prototype.search` method. 
%Symbol.species%            "Symbol.species"            function valued property that is the constructor function that is 
                                                        used to create derived objects. 
%Symbol.split%              "Symbol.split"              regular expression method that splits a string at the indices that 
                                                        match the regular expression. Called by the `Stri ng.prototype.split` method. 
%Symbol.toPrimitive%        "Symbol.toPrimitive"        A method that converts an object to a corresponding primitive value. 
                                                        Called by the ToPrimitive abstract operation. 
%Symbol.toStringTag%        "Symbol.toStringTag"        A String valued property that is used in the creation of the 
                                                        default string description of an object. Accessed by the built-in 
                                                        method `Object.p rototype.toString`. 
%Symbol.unscopables%        "Symbol.unscopables"        An object valued property whose own and inherited property names 
                                                        are property names that are excluded from the `with` environment 
                                                        bindings of the associated object.
=========================== =========================== ======================

6.1.6 Numeric Types
'''''''''''''''''''


ECMAScript has two built-in numeric types: Number and BigInt. The
following abstract operations are defined over these numeric types. The
"Result" column shows the return type, along with an indication if it is
possible for some invocations of the operation to return an abrupt
completion.

.. |Invokedby| replace:: Invoked by the Evaluation semantics of ...

+============================+=================+===================================+=======================================+
|         Operation          | Example source  |         |Invokedby|               |            Result                     |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::unaryMinus         | `-x`            | Unary - Operator                  | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::unaryMinus         |                 |                                   | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::bitwiseNOT         | `~x`            | Bitwise NOT Operator ( ~ )        | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::bitwiseNOT         |                 |                                   | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::exponentiate       | `x ** y`        | Exponentiation Operator and       | Number                                |
+----------------------------+                 | Math.pow ( base, exponent )       +---------------------------------------+
| BigInt::exponentiate       |                 |                                   | either a normal completion containing |
|                            |                 |                                   | a BigInt or a throw completion        |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::multiply           | `x * y`         | Multiplicative Operators          | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::multiply           |                 |                                   | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::divide             | `x / y`         | Multiplicative Operators          | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::divide             |                 |                                   | either a normal completion containing |
|                            |                 |                                   |  a BigInt or a throw completion       |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::remainder          | `x % y`         | Multiplicative Operators          | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::remainder          |                 |                                   | either a normal completion containing |
|                            |                 |                                   | a BigInt or a throw completion        |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::add                | `x ++`          | Postfix Increment Operator,       | Number                                |
+----------------------------+ `++ x`          | Prefix Increment Operator,        +---------------------------------------+
| BigInt::add                | `x + y`         | and The Addition Operator ( + )   | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::subtract           | `x --`          | Postfix Decrement Operator,       | Number                                |
+----------------------------+ `-- x`          | Prefix Decrement Operator, and    +---------------------------------------+
| BigInt::subtract           | `x - y`         | The Subtraction Operator ( - )    | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::leftShift          | `x << y`        | The Left Shift Operator ( << )    | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::leftShift          |                 |                                   | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::signedRightShift   | `x >> y`        | The Signed Right Shift Operator   | Number                                |
+----------------------------+                 |  ( >> )                           +---------------------------------------+
| BigInt::signedRightShift   |                 |                                   | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::unsignedRightShift | `x >>> y`       | The Unsigned Right Shift Operator | Number                                |
+----------------------------+                 | ( >>> )                           +---------------------------------------+
| BigInt::unsignedRightShift |                 |                                   | a throw  completion                   |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::lessThan           | `x < y`         | Relational Operators, via         | Boolean or `undefined`                |
|                            | `x > y`         | IsLessThan ( x, y, LeftFirst )    | (for unordered inputs)                |
+----------------------------+ `x <= y`        |                                   +---------------------------------------+
| BigInt::lessThan           | `x >= y`        |                                   | Boolean                               |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::equal              | `x == y`        | Equality Operators,               | Boolean                               |
|                            | `x != y`        | via IsStrictlyEqual ( x, y )      |                                       |
+----------------------------+ `x === y`       |                                   |                                       |
| BigInt::equal              | `x !== y`       |                                   |                                       |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::sameValue          | Object.is(x,y)  | Object internal methods, via ,    | Boolean                               |
|                            |                 | to test exact value equality      |                                       |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::sameValueZero      | [x].includes(y) | Array, Map, and Set methods,      | Boolean                               |
|                            |                 | via , to test value equality,     |                                       |
|                            |                 | ignoring the difference between   |                                       |
|                            |                 | +0\ :sub:`𝔽` and *-0`\ :sub:`𝔽`   |                                       |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::bitwiseAND         | `x & y`         | 	Binary Bitwise Operators        | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::bitwiseAND         |                 |                                   | BigInt                                |
+----------------------------+-----------------+                                   +---------------------------------------+
| Number::bitwiseXOR         | `x ^ y`         |                                   | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::bitwiseXOR         |                 |                                   | BigInt                                |
+----------------------------+-----------------+                                   +---------------------------------------+
| Number::bitwiseOR          | `x | y`         |                                   | Number                                |
+----------------------------+                 |                                   +---------------------------------------+
| BigInt::bitwiseOR          |                 |                                   | BigInt                                |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+
| Number::toString           | `String(x)`     | Many expressions and built-in     | String                                |
+----------------------------+                 | functions, via ToString(argument) |                                       |
| BigInt::toString           |                 |                                   |                                       |
+----------------------------+-----------------+-----------------------------------+---------------------------------------+

Because the numeric types are in general not convertible without loss of
precision or truncation, the ECMAScript language provides no implicit
conversion among these types. Programmers must explicitly call
`Number` and `BigInt` functions to convert among types when calling
a function which requires another type.

The first and subsequent editions of ECMAScript have provided, for
certain operators, implicit numeric conversions that could lose
precision or truncate. These legacy implicit conversions are maintained
for backward compatibility, but not provided for BigInt in order to
minimize opportunity for programmer error, and to leave open the option
of generalized *value types* in a future edition.


6.1.6.1 The Number Type
"""""""""""""""""""""""

The Number type has exactly 18,437,736,874,454,810,627 (that is,
2\ :sup:`64` - 2\ :sup:`53` + 3) values, representing the
double-precision floating point IEEE 754-2019 binary64 values as
specified in the IEEE Standard for Binary Floating-Point Arithmetic,
except that the 9,007,199,254,740,990 (that is, 2\ :sup:`53` - 2)
distinct “Not-a-Number” values of the IEEE Standard are represented in
ECMAScript as a single special `NaN` value. (Note that the `NaN`
value is produced by the program expression `NaN`.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-defined; to ECMAScript code, all `NaN` values are
indistinguishable from each other.

The bit pattern that might be observed in an ArrayBuffer (see ) or a
SharedArrayBuffer (see ) after a Number value has been stored into it is
not necessarily the same as the internal representation of that Number
value used by the ECMAScript implementation.

There are two other special values, called `positive Infinity` and
`negative Infinity`. For brevity, these values are also referred to
for expository purposes by the symbols `+∞`\ :sub:`𝔽` and
`-∞`\ :sub:`𝔽`, respectively. (Note that these two infinite Number
values are produced by the program expressions `+Infinity` (or simply
`Infinity`) and `-Infinity`.)

The other 18,437,736,874,454,810,624 (that is, 2\ :sup:`64` -
2\ :sup:`53`) values are called the finite numbers. Half of these are
positive numbers and half are negative numbers; for every finite
positive Number value there is a corresponding negative value having the
same magnitude.

Note that there is both a `positive zero` and a `negative zero`. For
brevity, these values are also referred to for expository purposes by
the symbols `+0`\ :sub:`𝔽` and `-0`\ :sub:`𝔽`, respectively. (Note
that these two different zero Number values are produced by the program
expressions `+0` (or simply `0`) and `-0`.)

The 18,437,736,874,454,810,622 (that is, 2\ :sup:`64` - 2\ :sup:`53` -
2) finite non-zero values are of two kinds:

18,428,729,675,200,069,632 (that is, 2\ :sup:`64` - 2\ :sup:`54`) of
them are normalized, having the form

   s × m × 2\ :sup:`e`

where s is 1 or -1, m is an integer in the interval from
2\ :sup:`52` (inclusive) to 2\ :sup:`53` (exclusive), and e is an
integer in the inclusive interval from -1074 to 971.

The remaining 9,007,199,254,740,990 (that is, 2\ :sup:`53` - 2) values
are denormalized, having the form

   s × m × 2\ :sup:`e`

where s is 1 or -1, m is an integer in the interval from 0
(exclusive) to 2\ :sup:`52` (exclusive), and e is -1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2\ :sup:`53` are representable in the Number type. The
integer 0 has two representations in the Number type: `+0`\ :sub:`𝔽`
and `-0`\ :sub:`𝔽`.

A finite number has an *odd significand* if it is non-zero and the
integer m used to express it (in one of the two forms shown above)
is odd. Otherwise, it has an *even significand*.

In this specification, the phrase “the Number value for x” where
x represents an exact real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with `-0`\ :sub:`𝔽` removed and with two additional values added
to it that are not representable in the Number type, namely
2\ :sup:`1024` (which is +1 × 2\ :sup:`53` × 2\ :sup:`971`) and
-2\ :sup:`1024` (which is -1 × 2\ :sup:`53` × 2\ :sup:`971`). Choose the
member of this set that is closest in value to x. If two values of
the set are equally close, then the one with an even significand is
chosen; for this purpose, the two extra values 2\ :sup:`1024` and
-2\ :sup:`1024` are considered to have even significands. Finally, if
2\ :sup:`1024` was chosen, replace it with `+∞`\ :sub:`𝔽`; if
-2\ :sup:`1024` was chosen, replace it with `-∞`\ :sub:`𝔽`; if
`+0`\ :sub:`𝔽` was chosen, replace it with `-0`\ :sub:`𝔽` if and
only if x < 0; any other chosen value is used unchanged. The result
is the Number value for x. (This procedure corresponds exactly to
the behaviour of the IEEE 754-2019 roundTiesToEven mode.)

The Number value for +∞ is `+∞`\ :sub:`𝔽`, and the Number value for -∞
is `-∞`\ :sub:`𝔽`.

Some ECMAScript operators deal only with integers in specific ranges
such as the inclusive interval from -2\ :sup:`31` to 2\ :sup:`31` - 1 or
the inclusive interval from 0 to 2\ :sup:`16` - 1. These operators
accept any value of the Number type but first convert each such value to
an integer value in the expected range. See the descriptions of the
numeric conversion operations in .

6.1.6.1.1 Number::unaryMinus ( x )
++++++++++++++++++++++++++++++++++

   Number::unaryMinus ( x: a Number, ): a Number


1. If x is `NaN`, return `NaN`. 
2. Return the negation of x; that is, compute a Number with the same
   magnitude but opposite sign.

6.1.6.1.2 Number::bitwiseNOT ( x )
++++++++++++++++++++++++++++++++++

   Number::bitwiseNOT ( x: a Number, ): an integral Number


1. Let oldValue be ! ToInt32(x). 
2. Return the bitwise complement of oldValue. The mathematical value of the 
   result is exactly representable as a 32-bit two's complement bit string.

6.1.6.1.3 Number::exponentiate ( base, exponent )
+++++++++++++++++++++++++++++++++++++++++++++++++

   Number::exponentiate ( base: a Number, exponent: a Number, ): a Number


description
   It returns an implementation-approximated value representing the
   result of raising base to the exponent power.

1. If exponent is `NaN`, return `NaN`. 
2. If exponent is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return `1`\ :sub:`𝔽`. 
3. If base is `NaN`, return `NaN`. 
4. If base is `+∞`\ :sub:`𝔽`, then 

   a. If exponent > `+0`\ :sub:`𝔽`, return `+∞`\ :sub:`𝔽`. Otherwise, return `+0`\ :sub:`𝔽`. 

5. If base is `-∞`\ :sub:`𝔽`, then 

   a. If exponent > `+0`\ :sub:`𝔽`, then 

      i. If exponent is an odd integral Number, return `-∞`\ :sub:`𝔽`. Otherwise, return `+∞`\ :sub:`𝔽`. 

   b. Else, 

      i. If exponent is an odd integral Number, return `-0`\ :sub:`𝔽`. Otherwise, return `+0`\ :sub:`𝔽`. 

6. If base is `+0`\ :sub:`𝔽`, then 

   a. If exponent > `+0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. Otherwise, return `+∞`\ :sub:`𝔽`. 

7. If base is `-0`\ :sub:`𝔽`, then 

   a. If exponent > `+0`\ :sub:`𝔽`, then 

      i. If exponent is an odd integral Number, return `-0`\ :sub:`𝔽`. Otherwise, return `+0`\ :sub:`𝔽`. 

   b. Else, 

      i. If exponent is an odd integral Number, return `-∞`\ :sub:`𝔽`. Otherwise, return `+∞`\ :sub:`𝔽`. 

8. Assert: base is finite and is neither `+0`\ :sub:`𝔽` nor `-0`\ :sub:`𝔽`.

9. If exponent is `+∞`\ :sub:`𝔽`, then 

   a. If abs(ℝ(base)) > 1, return `+∞`\ :sub:`𝔽`. 
   b. If abs(ℝ(base)) = 1, return `NaN`. 
   c. If abs(ℝ(base)) < 1, return `+0`\ :sub:`𝔽`. 

10. If exponent is `-∞`\ :sub:`𝔽`, then 

   a. If abs(ℝ(base)) > 1, return `+0`\ :sub:`𝔽`. 
   b. If abs(ℝ(base)) = 1, return `NaN`. 
   c. If abs(ℝ(base)) < 1, return `+∞`\ :sub:`𝔽`. 

11. Assert: exponent is finite and is neither `+0`\ :sub:`𝔽` nor `-0`\ :sub:`𝔽`. 

12. If base < `-0`\ :sub:`𝔽` and exponent is not an integral Number, return `NaN`. 

13. Return an implementation-approximated Number value representing the result 
    of raising ℝ(base) to the ℝ(exponent) power.

The result of base `**` exponent when base is
`1`\ :sub:`𝔽` or `-1`\ :sub:`𝔽` and exponent is `+∞`\ :sub:`𝔽`
or `-∞`\ :sub:`𝔽`, or when base is `1`\ :sub:`𝔽` and
exponent is `NaN`, differs from IEEE 754-2019. The first edition
of ECMAScript specified a result of `NaN` for this operation, whereas
later revisions of IEEE 754 specified `1`\ :sub:`𝔽`. The historical
ECMAScript behaviour is preserved for compatibility reasons.

6.1.6.1.4 Number::multiply ( x, y )
+++++++++++++++++++++++++++++++++++

   Number::multiply ( x: a Number, y: a Number, ): a Number


description
   It performs multiplication according to the rules of IEEE 754-2019
   binary double-precision arithmetic, producing the product of x
   and y.

1. If x is `NaN` or y is `NaN`, return `NaN`. 
2. If x is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, then 

   a. If y is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return `NaN`. 
   b. If y > `+0`\ :sub:`𝔽`, return x. 
   c. Return -x. 

3. If y is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, then 

   a. If x is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return `NaN`. 
   b. If x > `+0`\ :sub:`𝔽`, return y. 
   c. Return -y. 

4. If x is `-0`\ :sub:`𝔽`, then 

   a. If y is `-0`\ :sub:`𝔽` or y < `-0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 
   b. Else, return `-0`\ :sub:`𝔽`. 

5. If y is `-0`\ :sub:`𝔽`, then 

   a. If x < `-0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 
   b. Else, return `-0`\ :sub:`𝔽`. 

6. Return 𝔽(ℝ(x) × ℝ(y)).

Finite-precision multiplication is commutative, but not always
associative.

6.1.6.1.5 Number::divide ( x, y )
+++++++++++++++++++++++++++++++++

   Number::divide ( x: a Number, y: a Number, ): a Number


description
   It performs division according to the rules of IEEE 754-2019 binary
   double-precision arithmetic, producing the quotient of x and
   y where x is the dividend and y is the divisor.

1. If x is `NaN` or y is `NaN`, return `NaN`. 1. If x
is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, then 1. If y is
either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, return `NaN`. 1. If y
is `+0`\ :sub:`𝔽` or y > `+0`\ :sub:`𝔽`, return x. 1. Return
-x. 1. If y is `+∞`\ :sub:`𝔽`, then 1. If x is
`+0`\ :sub:`𝔽` or x > `+0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`.
Otherwise, return `-0`\ :sub:`𝔽`. 1. If y is `-∞`\ :sub:`𝔽`,
then 1. If x is `+0`\ :sub:`𝔽` or x > `+0`\ :sub:`𝔽`, return
`-0`\ :sub:`𝔽`. Otherwise, return `+0`\ :sub:`𝔽`. 1. If x is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, then 1. If y is either
`+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return `NaN`. 1. If y >
`+0`\ :sub:`𝔽`, return x. 1. Return -x. 1. If y is
`+0`\ :sub:`𝔽`, then 1. If x > `+0`\ :sub:`𝔽`, return
`+∞`\ :sub:`𝔽`. Otherwise, return `-∞`\ :sub:`𝔽`. 1. If y is
`-0`\ :sub:`𝔽`, then 1. If x > `+0`\ :sub:`𝔽`, return
`-∞`\ :sub:`𝔽`. Otherwise, return `+∞`\ :sub:`𝔽`. 1. Return
𝔽(ℝ(x) / ℝ(y)).

6.1.6.1.6 Number::remainder ( n, d )
++++++++++++++++++++++++++++++++++++

   Number::remainder ( n: a Number, d: a Number, ): a Number


description
   It yields the remainder from an implied division of its operands
   where n is the dividend and d is the divisor.

1. If n is `NaN` or d is `NaN`, return `NaN`. 1. If n
is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, return `NaN`. 1. If
d is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, return n. 1.
If d is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return `NaN`.
1. If n is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return
n. 1. Assert: n and d are finite and non-zero. 1. Let
quotient be ℝ(n) / ℝ(d). 1. Let q be
truncate(quotient). 1. Let r be ℝ(n) - (ℝ(d) × q).
1. If r = 0 and n < `-0`\ :sub:`𝔽`, return `-0`\ :sub:`𝔽`.
1. Return 𝔽(r).

In C and C++, the remainder operator accepts only integral operands; in
ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the
`%` operator is not the same as the “remainder” operation defined by
IEEE 754-2019. The IEEE 754-2019 “remainder” operation computes the
remainder from a rounding division, not a truncating division, and so
its behaviour is not analogous to that of the usual integer remainder
operator. Instead the ECMAScript language defines `%` on
floating-point operations to behave in a manner analogous to that of the
Java integer remainder operator; this may be compared with the C library
function fmod.

6.1.6.1.7 Number::add ( x, y )
++++++++++++++++++++++++++++++

   Number::add ( x: a Number, y: a Number, ): a Number


description
   It performs addition according to the rules of IEEE 754-2019 binary
   double-precision arithmetic, producing the sum of its arguments.

1. If x is `NaN` or y is `NaN`, return `NaN`. 1. If x
is `+∞`\ :sub:`𝔽` and y is `-∞`\ :sub:`𝔽`, return `NaN`. 1. If
x is `-∞`\ :sub:`𝔽` and y is `+∞`\ :sub:`𝔽`, return `NaN`.
1. If x is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, return
x. 1. If y is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`,
return y. 1. Assert: x and y are both finite. 1. If x is
`-0`\ :sub:`𝔽` and y is `-0`\ :sub:`𝔽`, return `-0`\ :sub:`𝔽`.
1. Return 𝔽(ℝ(x) + ℝ(y)).

Finite-precision addition is commutative, but not always associative.

6.1.6.1.8 Number::subtract ( x, y )
+++++++++++++++++++++++++++++++++++

   Number::subtract ( x: a Number, y: a Number, ): a Number


description
   It performs subtraction, producing the difference of its operands;
   x is the minuend and y is the subtrahend.

1. Return Number::add(x, Number::unaryMinus(y)).

It is always the case that `x - y` produces the same result as `x +
(-y)`.

6.1.6.1.9 Number::leftShift ( x, y )
++++++++++++++++++++++++++++++++++++

   Number::leftShift ( x: a Number, y: a Number, ): an integral Number


1. Let lNum be ! ToInt32(x). 1. Let rNum be !
ToUint32(y). 1. Let shiftCount be ℝ(rNum) modulo 32. 1.
Return the result of left shifting lNum by shiftCount bits. The
mathematical value of the result is exactly representable as a 32-bit
two's complement bit string.

6.1.6.1.10 Number::signedRightShift ( x, y )
++++++++++++++++++++++++++++++++++++++++++++

   Number::signedRightShift ( x: a Number, y: a Number, ): an integral Number


1. Let lNum be ! ToInt32(x). 1. Let rNum be !
ToUint32(y). 1. Let shiftCount be ℝ(rNum) modulo 32. 1.
Return the result of performing a sign-extending right shift of lNum
by shiftCount bits. The most significant bit is propagated. The
mathematical value of the result is exactly representable as a 32-bit
two's complement bit string.

6.1.6.1.11 Number::unsignedRightShift ( x, y )
++++++++++++++++++++++++++++++++++++++++++++++

   Number::unsignedRightShift ( x: a Number, y: a Number, ): an integral Number


1. Let lNum be ! ToUint32(x). 1. Let rNum be !
ToUint32(y). 1. Let shiftCount be ℝ(rNum) modulo 32. 1.
Return the result of performing a zero-filling right shift of lNum
by shiftCount bits. Vacated bits are filled with zero. The
mathematical value of the result is exactly representable as a 32-bit
unsigned bit string.

6.1.6.1.12 Number::lessThan ( x, y )
++++++++++++++++++++++++++++++++++++

   Number::lessThan ( x: a Number, y: a Number, ): a Boolean or `undefined`


1. If x is `NaN`, return `undefined`. 1. If y is `NaN`,
return `undefined`. 1. If x is y, return `false`. 1. If
x is `+0`\ :sub:`𝔽` and y is `-0`\ :sub:`𝔽`, return
`false`. 1. If x is `-0`\ :sub:`𝔽` and y is
`+0`\ :sub:`𝔽`, return `false`. 1. If x is `+∞`\ :sub:`𝔽`,
return `false`. 1. If y is `+∞`\ :sub:`𝔽`, return `true`. 1.
If y is `-∞`\ :sub:`𝔽`, return `false`. 1. If x is
`-∞`\ :sub:`𝔽`, return `true`. 1. Assert: x and y are
finite. 1. If ℝ(x) < ℝ(y), return `true`. Otherwise, return
`false`.

6.1.6.1.13 Number::equal ( x, y )
+++++++++++++++++++++++++++++++++

   Number::equal ( x: a Number, y: a Number, ): a Boolean


1. If x is `NaN`, return `false`. 1. If y is `NaN`, return
`false`. 1. If x is y, return `true`. 1. If x is
`+0`\ :sub:`𝔽` and y is `-0`\ :sub:`𝔽`, return `true`. 1. If
x is `-0`\ :sub:`𝔽` and y is `+0`\ :sub:`𝔽`, return
`true`. 1. Return `false`.

6.1.6.1.14 Number::sameValue ( x, y )
+++++++++++++++++++++++++++++++++++++

   Number::sameValue ( x: a Number, y: a Number, ): a Boolean


1. If x is `NaN` and y is `NaN`, return `true`. 1. If
x is `+0`\ :sub:`𝔽` and y is `-0`\ :sub:`𝔽`, return
`false`. 1. If x is `-0`\ :sub:`𝔽` and y is
`+0`\ :sub:`𝔽`, return `false`. 1. If x is y, return
`true`. 1. Return `false`.

6.1.6.1.15 Number::sameValueZero ( x, y )
+++++++++++++++++++++++++++++++++++++++++

   Number::sameValueZero ( x: a Number, y: a Number, ): a Boolean


1. If x is `NaN` and y is `NaN`, return `true`. 1. If
x is `+0`\ :sub:`𝔽` and y is `-0`\ :sub:`𝔽`, return
`true`. 1. If x is `-0`\ :sub:`𝔽` and y is `+0`\ :sub:`𝔽`,
return `true`. 1. If x is y, return `true`. 1. Return
`false`.

6.1.6.1.16 NumberBitwiseOp ( op, x, y )
+++++++++++++++++++++++++++++++++++++++

   NumberBitwiseOp ( op: `&`, `^`, or `|`, x: a Number, y: a Number, ): an integral Number


1. Let lNum be ! ToInt32(x). 1. Let rNum be !
ToInt32(y). 1. Let lBits be the 32-bit two's complement bit
string representing ℝ(lNum). 1. Let rBits be the 32-bit two's
complement bit string representing ℝ(rNum). 1. If op is `&`,
then 1. Let result be the result of applying the bitwise AND
operation to lBits and rBits. 1. Else if op is `^`, then
1. Let result be the result of applying the bitwise exclusive OR
(XOR) operation to lBits and rBits. 1. Else, 1. Assert: op
is `|`. 1. Let result be the result of applying the bitwise
inclusive OR operation to lBits and rBits. 1. Return the Number
value for the integer represented by the 32-bit two's complement bit
string result.

6.1.6.1.17 Number::bitwiseAND ( x, y )
++++++++++++++++++++++++++++++++++++++

   Number::bitwiseAND ( x: a Number, y: a Number, ): an integral Number


1. Return NumberBitwiseOp(`&`, x, y).

6.1.6.1.18 Number::bitwiseXOR ( x, y )
++++++++++++++++++++++++++++++++++++++

   Number::bitwiseXOR ( x: a Number, y: a Number, ): an integral Number


1. Return NumberBitwiseOp(`^`, x, y).

6.1.6.1.19 Number::bitwiseOR ( x, y )
+++++++++++++++++++++++++++++++++++++

   Number::bitwiseOR ( x: a Number, y: a Number, ): an integral Number


1. Return NumberBitwiseOp(`|`, x, y).

6.1.6.1.20 Number::toString ( x, radix )
++++++++++++++++++++++++++++++++++++++++

   Number::toString ( x: a Number, radix: an integer in the inclusive interval from 2 to 36, ): a String


description
   It represents x as a String using a positional numeral system
   with radix radix. The digits used in the representation of a
   number using radix r are taken from the first r code units of
   `"0123456789abcdefghijklmnopqrstuvwxyz"` in order. The
   representation of numbers with magnitude greater than or equal to
   `1`\ :sub:`𝔽` never includes leading zeroes.

1. If x is `NaN`, return `"NaN"`. 1. If x is either
`+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return `"0"`. 1. If x <
`-0`\ :sub:`𝔽`, return the string-concatenation of `"-"` and
Number::toString(-x, radix). 1. If x is `+∞`\ :sub:`𝔽`,
return `"Infinity"`. 1.
[id="step-number-tostring-intermediate-values"] Let n, k, and
s be integers such that k ≥ 1, radix\ :sup:`k - 1` ≤
s < radix\ :sup:`k`, 𝔽(s × radix\ :sup:`n -
k`) is x, and k is as small as possible. Note that k is
the number of digits in the representation of s using radix
radix, that s is not divisible by radix, and that the least
significant digit of s is not necessarily uniquely determined by
these criteria. 1. If radix ≠ 10 or n is in the inclusive
interval from -5 to 21, then 1. If n ≥ k, then 1. Return the
string-concatenation of: ` the code units of the k digits of the
representation of s using radix radix ` n - k
occurrences of the code unit 0x0030 (DIGIT ZERO) 1. Else if n > 0,
then 1. Return the string-concatenation of: ` the code units of the
most significant n digits of the representation of s using radix
radix ` the code unit 0x002E (FULL STOP) ` the code units of the
remaining k - n digits of the representation of s using
radix radix 1. Else, 1. Assert: n ≤ 0. 1. Return the
string-concatenation of: ` the code unit 0x0030 (DIGIT ZERO) ` the
code unit 0x002E (FULL STOP) ` -n occurrences of the code unit
0x0030 (DIGIT ZERO) ` the code units of the k digits of the
representation of s using radix radix 1. NOTE: In this case, the
input will be represented using scientific E notation, such as
`1.2e+3`. 1. Assert: radix is 10. 1. If n < 0, then 1. Let
exponentSign be the code unit 0x002D (HYPHEN-MINUS). 1. Else, 1. Let
exponentSign be the code unit 0x002B (PLUS SIGN). 1. If k = 1,
then 1. Return the string-concatenation of: ` the code unit of the
single digit of s ` the code unit 0x0065 (LATIN SMALL LETTER E) `
exponentSign ` the code units of the decimal representation of
abs(n - 1) 1. Return the string-concatenation of: ` the code unit
of the most significant digit of the decimal representation of s `
the code unit 0x002E (FULL STOP) ` the code units of the remaining
k - 1 digits of the decimal representation of s ` the code unit
0x0065 (LATIN SMALL LETTER E) ` exponentSign ` the code units of
the decimal representation of abs(n - 1)

The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

- If x is any Number value other than `-0`\ :sub:`𝔽`, then
  ToNumber(ToString(x)) is x.
- The least significant digit of s is not always uniquely determined by
  the requirements listed in step .

For implementations that provide more accurate conversions than required
by the rules above, it is recommended that the following alternative
version of step be used as a guideline:

1. Let n, k, and s be integers such that k ≥ 1,
radix\ :sup:`k - 1` ≤ s < radix\ :sup:`k`, 𝔽(s ×
radix\ :sup:`n - k`) is x, and k is as small as
possible. If there are multiple possibilities for s, choose the
value of s for which s × radix\ :sup:`n - k` is
closest in value to ℝ(x). If there are two such possible values of
s, choose the one that is even. Note that k is the number of
digits in the representation of s using radix radix and that
s is not divisible by radix.

Implementers of ECMAScript may find useful the paper and code written by
David M. Gay for binary-to-decimal conversion of floating-point numbers:

| Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). 30 November 1990. Available as
| https://ampl.com/_archive/first-website/REFS/rounding.pdf. Associated
  code available as
| http://netlib.sandia.gov/fp/dtoa.c and as
| http://netlib.sandia.gov/fp/g_fmt.c and may also be found at the
  various `netlib` mirror sites.

The BigInt Type
---------------

The BigInt type represents an integer value. The value may be any size
and is not limited to a particular bit-width. Generally, where not
otherwise noted, operations are designed to return exact
mathematically-based answers. For binary operations, BigInts act as
two's complement binary strings, with negative numbers treated as having
bits set infinitely to the left.

BigInt::unaryMinus ( x: a BigInt, ): a BigInt
-------------------------------------------------

1. If x = `0`\ :sub:`ℤ`, return `0`\ :sub:`ℤ`. 1. Return -x.

BigInt::bitwiseNOT ( x: a BigInt, ): a BigInt
-------------------------------------------------

description
   It returns the one's complement of x.

1. Return -x - `1`\ :sub:`ℤ`.

BigInt::exponentiate ( base: a BigInt, exponent: a BigInt, )
------------------------------------------------------------

1. If exponent < `0`\ :sub:`ℤ`, throw a `RangeError` exception.
1. If base = `0`\ :sub:`ℤ` and exponent = `0`\ :sub:`ℤ`,
return `1`\ :sub:`ℤ`. 1. Return base raised to the power
exponent.

BigInt::multiply ( x: a BigInt, y: a BigInt, ): a BigInt
----------------------------------------------------------------

1. Return x × y. Even if the result has a much larger bit width
than the input, the exact mathematical answer is given.

BigInt::divide ( x: a BigInt, y: a BigInt, )
--------------------------------------------

1. If y = `0`\ :sub:`ℤ`, throw a `RangeError` exception. 1. Let
quotient be ℝ(x) / ℝ(y). 1. Return
ℤ(truncate(quotient)).

BigInt::remainder ( n: a BigInt, d: a BigInt, )
-----------------------------------------------

1. If d = `0`\ :sub:`ℤ`, throw a `RangeError` exception. 1. If
n = `0`\ :sub:`ℤ`, return `0`\ :sub:`ℤ`. 1. Let quotient be
ℝ(n) / ℝ(d). 1. Let q be ℤ(truncate(quotient)). 1.
Return n - (d × q). The sign of the result is the sign of
the dividend.

BigInt::add ( x: a BigInt, y: a BigInt, ): a BigInt
-----------------------------------------------------------

1. Return x + y.

BigInt::subtract ( x: a BigInt, y: a BigInt, ): a BigInt
----------------------------------------------------------------

1. Return x - y.

BigInt::leftShift ( x: a BigInt, y: a BigInt, ): a BigInt
-----------------------------------------------------------------

1. If y < `0`\ :sub:`ℤ`, then 1. Return ℤ(floor(ℝ(x) /
2\ :sup:`-ℝ(y)`)). 1. Return x × `2`\ :sub:`ℤ`\ :sup:`y`.
Semantics here should be equivalent to a bitwise shift, treating the
BigInt as an infinite length string of binary two's complement digits.

BigInt::signedRightShift ( x: a BigInt, y: a BigInt, ): a BigInt
------------------------------------------------------------------------

1. Return BigInt::leftShift(x, -y).

BigInt::unsignedRightShift ( x: a BigInt, y: a BigInt, ): a throw completion
------------------------------------------------------------------------------------

1. Throw a `TypeError` exception.

BigInt::lessThan ( x: a BigInt, y: a BigInt, ): a Boolean
-----------------------------------------------------------------

1. If ℝ(x) < ℝ(y), return `true`; otherwise return `false`.

BigInt::equal ( x: a BigInt, y: a BigInt, ): a Boolean
--------------------------------------------------------------

1. If ℝ(x) = ℝ(y), return `true`; otherwise return `false`.

BinaryAnd ( x: 0 or 1, y: 0 or 1, ): 0 or 1
---------------------------------------------------

1. If x = 1 and y = 1, return 1. 1. Else, return 0.

BinaryOr ( x: 0 or 1, y: 0 or 1, ): 0 or 1
--------------------------------------------------

1. If x = 1 or y = 1, return 1. 1. Else, return 0.

BinaryXor ( x: 0 or 1, y: 0 or 1, ): 0 or 1
---------------------------------------------------

1. If x = 1 and y = 0, return 1. 1. Else if x = 0 and y
= 1, return 1. 1. Else, return 0.

BigIntBitwiseOp ( op: `&`, `^`, or `|`, x: a BigInt, y: a BigInt, ): a BigInt
-----------------------------------------------------------------------------------------------

1. Set x to ℝ(x). 1. Set y to ℝ(y). 1. Let result be
0. 1. Let shift be 0. 1. Repeat, until (x = 0 or x = -1) and
(y = 0 or y = -1), 1. Let xDigit be x modulo 2. 1. Let
yDigit be y modulo 2. 1. If op is `&`, then 1. Set
result to result + 2\ :sup:`shift` × BinaryAnd(xDigit,
yDigit). 1. Else if op is `|`, then 1. Set result to
result + 2\ :sup:`shift` × BinaryOr(xDigit, yDigit). 1.
Else, 1. Assert: op is `^`. 1. Set result to result +
2\ :sup:`shift` × BinaryXor(xDigit, yDigit). 1. Set
shift to shift + 1. 1. Set x to (x - xDigit) / 2. 1.
Set y to (y - yDigit) / 2. 1. If op is `&`, then 1.
Let tmp be BinaryAnd(x modulo 2, y modulo 2). 1. Else if
op is `|`, then 1. Let tmp be BinaryOr(x modulo 2, y
modulo 2). 1. Else, 1. Assert: op is `^`. 1. Let tmp be
BinaryXor(x modulo 2, y modulo 2). 1. If tmp ≠ 0, then 1.
Set result to result - 2\ :sup:`shift`. 1. NOTE: This
extends the sign. 1. Return the BigInt value for result.

BigInt::bitwiseAND ( x: a BigInt, y: a BigInt, ): a BigInt
------------------------------------------------------------------

1. Return BigIntBitwiseOp(`&`, x, y).

BigInt::bitwiseXOR ( x: a BigInt, y: a BigInt, ): a BigInt
------------------------------------------------------------------

1. Return BigIntBitwiseOp(`^`, x, y).

BigInt::bitwiseOR ( x: a BigInt, y: a BigInt, ): a BigInt
-----------------------------------------------------------------

1. Return BigIntBitwiseOp(`|`, x, y).

BigInt::toString ( x: a BigInt, radix: an integer in the inclusive interval from 2 to 36, ): a String
-------------------------------------------------------------------------------------------------------------

description
   It represents x as a String using a positional numeral system
   with radix radix. The digits used in the representation of a
   BigInt using radix r are taken from the first r code units of
   `"0123456789abcdefghijklmnopqrstuvwxyz"` in order. The
   representation of BigInts other than `0`\ :sub:`ℤ` never includes
   leading zeroes.

1. If x < `0`\ :sub:`ℤ`, return the string-concatenation of
`"-"` and BigInt::toString(-x, radix). 1. Return the String
value consisting of the representation of x using radix radix.

The Object Type
---------------

Each instance of the Object type, also referred to simply as “an
Object”, represents a collection of properties. Each property is either
a data property, or an accessor property:

- A data property associates a key value with an ECMAScript language
  value and a set of Boolean attributes.
- An accessor property associates a key value with one or two accessor
  functions, and a set of Boolean attributes. The accessor functions are
  used to store or retrieve an ECMAScript language value that is
  associated with the property.

The properties of an object are uniquely identified using property keys.
A property key is either a String or a Symbol. All Strings and Symbols,
including the empty String, are valid as property keys. A property name
is a property key that is a String.

An integer index is a property name n such that
CanonicalNumericIndexString(n) returns an integral Number in the
inclusive interval from `+0`\ :sub:`𝔽` to 𝔽(2\ :sup:`53` - 1). An
array index is an integer index n such that
CanonicalNumericIndexString(n) returns an integral Number in the
inclusive interval from `+0`\ :sub:`𝔽` to 𝔽(2\ :sup:`32` - 2).

Every non-negative safe integer has a corresponding integer index. Every
32-bit unsigned integer except 2\ :sup:`32` - 1 has a corresponding
array index. `"-0"` is neither an integer index nor an array index.

Property keys are used to access properties and their values. There are
two kinds of access for properties: *get* and *set*, corresponding to
value retrieval and assignment, respectively. The properties accessible
via get and set access includes both *own properties* that are a direct
part of an object and *inherited properties* which are provided by
another associated object via a property inheritance relationship.
Inherited properties may be either own or inherited properties of the
associated object. Each own property of an object must each have a key
value that is distinct from the key values of the other own properties
of that object.

All objects are logically collections of properties, but there are
multiple forms of objects that differ in their semantics for accessing
and manipulating their properties. Please see for definitions of the
multiple forms of objects.

In addition, some objects are callable; these are referred to as
functions or function objects and are described further below. All
functions in ECMAScript are members of the Object type.

Property Attributes
-------------------

Attributes are used in this specification to define and explain the
state of Object properties as described in . Unless specified
explicitly, the initial value of each attribute is its Default Value.

+-------------+-------------+-------------+-------------+-------------+
| Attribute   | Types of    | Value       | Default     | Description |
| Name        | property    | Domain      | Value       |             |
|             | for which   |             |             |             |
|             | it is       |             |             |             |
|             | present     |             |             |             |
+=============+=============+=============+=============+=============+
| [[Value]]   | data        | an          | `          | The value   |
|             | property    | ECMAScript  | undefined` | retrieved   |
|             |             | language    |             | by a get    |
|             |             | value       |             | access of   |
|             |             |             |             | the         |
|             |             |             |             | property.   |
+-------------+-------------+-------------+-------------+-------------+
| [           | data        | a Boolean   | `false`   | If          |
| [Writable]] | property    |             |             | `false`,  |
|             |             |             |             | attempts by |
|             |             |             |             | ECMAScript  |
|             |             |             |             | code to     |
|             |             |             |             | change the  |
|             |             |             |             | property's  |
|             |             |             |             | [[Value]]   |
|             |             |             |             | attribute   |
|             |             |             |             | using       |
|             |             |             |             | [[Set]]     |
|             |             |             |             | will not    |
|             |             |             |             | succeed.    |
+-------------+-------------+-------------+-------------+-------------+
| [[Get]]     | accessor    | an Object   | `          | If the      |
|             | property    | or          | undefined` | value is an |
|             |             | `          |             | Object it   |
|             |             | undefined` |             | must be a   |
|             |             |             |             | function    |
|             |             |             |             | object. The |
|             |             |             |             | function's  |
|             |             |             |             | [[Call]]    |
|             |             |             |             | internal    |
|             |             |             |             | method ()   |
|             |             |             |             | is called   |
|             |             |             |             | with an     |
|             |             |             |             | empty       |
|             |             |             |             | arguments   |
|             |             |             |             | list to     |
|             |             |             |             | retrieve    |
|             |             |             |             | the         |
|             |             |             |             | property    |
|             |             |             |             | value each  |
|             |             |             |             | time a get  |
|             |             |             |             | access of   |
|             |             |             |             | the         |
|             |             |             |             | property is |
|             |             |             |             | performed.  |
+-------------+-------------+-------------+-------------+-------------+
| [[Set]]     | accessor    | an Object   | `          | If the      |
|             | property    | or          | undefined` | value is an |
|             |             | `          |             | Object it   |
|             |             | undefined` |             | must be a   |
|             |             |             |             | function    |
|             |             |             |             | object. The |
|             |             |             |             | function's  |
|             |             |             |             | [[Call]]    |
|             |             |             |             | internal    |
|             |             |             |             | method ()   |
|             |             |             |             | is called   |
|             |             |             |             | with an     |
|             |             |             |             | arguments   |
|             |             |             |             | list        |
|             |             |             |             | containing  |
|             |             |             |             | the         |
|             |             |             |             | assigned    |
|             |             |             |             | value as    |
|             |             |             |             | its sole    |
|             |             |             |             | argument    |
|             |             |             |             | each time a |
|             |             |             |             | set access  |
|             |             |             |             | of the      |
|             |             |             |             | property is |
|             |             |             |             | performed.  |
|             |             |             |             | The effect  |
|             |             |             |             | of a        |
|             |             |             |             | property's  |
|             |             |             |             | [[Set]]     |
|             |             |             |             | internal    |
|             |             |             |             | method may, |
|             |             |             |             | but is not  |
|             |             |             |             | required    |
|             |             |             |             | to, have an |
|             |             |             |             | effect on   |
|             |             |             |             | the value   |
|             |             |             |             | returned by |
|             |             |             |             | subsequent  |
|             |             |             |             | calls to    |
|             |             |             |             | the         |
|             |             |             |             | property's  |
|             |             |             |             | [[Get]]     |
|             |             |             |             | internal    |
|             |             |             |             | method.     |
+-------------+-------------+-------------+-------------+-------------+
| [[E         | data        | a Boolean   | `false`   | If          |
| numerable]] | property or |             |             | `true`,   |
|             | accessor    |             |             | the         |
|             | property    |             |             | property    |
|             |             |             |             | will be     |
|             |             |             |             | enumerated  |
|             |             |             |             | by a for-in |
|             |             |             |             | enumeration |
|             |             |             |             | (see ).     |
|             |             |             |             | Otherwise,  |
|             |             |             |             | the         |
|             |             |             |             | property is |
|             |             |             |             | said to be  |
|             |             |             |             | non-        |
|             |             |             |             | enumerable. |
+-------------+-------------+-------------+-------------+-------------+
| [[Con       | data        | a Boolean   | `false`   | If          |
| figurable]] | property or |             |             | `false`,  |
|             | accessor    |             |             | attempts to |
|             | property    |             |             | delete the  |
|             |             |             |             | property,   |
|             |             |             |             | change it   |
|             |             |             |             | from a data |
|             |             |             |             | property to |
|             |             |             |             | an accessor |
|             |             |             |             | property or |
|             |             |             |             | from an     |
|             |             |             |             | accessor    |
|             |             |             |             | property to |
|             |             |             |             | a data      |
|             |             |             |             | property,   |
|             |             |             |             | or make any |
|             |             |             |             | changes to  |
|             |             |             |             | its         |
|             |             |             |             | attributes  |
|             |             |             |             | (other than |
|             |             |             |             | replacing   |
|             |             |             |             | an existing |
|             |             |             |             | [[Value]]   |
|             |             |             |             | or setting  |
|             |             |             |             | [           |
|             |             |             |             | [Writable]] |
|             |             |             |             | to          |
|             |             |             |             | `false`)  |
|             |             |             |             | will fail.  |
+-------------+-------------+-------------+-------------+-------------+

Object Internal Methods and Internal Slots
------------------------------------------

The actual semantics of objects, in ECMAScript, are specified via
algorithms called *internal methods*. Each object in an ECMAScript
engine is associated with a set of internal methods that defines its
runtime behaviour. These internal methods are not part of the ECMAScript
language. They are defined by this specification purely for expository
purposes. However, each object within an implementation of ECMAScript
must behave as specified by the internal methods associated with it. The
exact manner in which this is accomplished is determined by the
implementation.

Internal method names are polymorphic. This means that different object
values may perform different algorithms when a common internal method
name is invoked upon them. That actual object upon which an internal
method is invoked is the “target” of the invocation. If, at runtime, the
implementation of an algorithm attempts to use an internal method of an
object that the object does not support, a `TypeError` exception is
thrown.

Internal slots correspond to internal state that is associated with
objects and used by various ECMAScript specification algorithms.
Internal slots are not object properties and they are not inherited.
Depending upon the specific internal slot specification, such state may
consist of values of any ECMAScript language type or of specific
ECMAScript specification type values. Unless explicitly specified
otherwise, internal slots are allocated as part of the process of
creating an object and may not be dynamically added to an object. Unless
specified otherwise, the initial value of an internal slot is the value
`undefined`. Various algorithms within this specification create
objects that have internal slots. However, the ECMAScript language
provides no direct way to associate internal slots with an object.

All objects have an internal slot named [[PrivateElements]], which is a
List of PrivateElements. This List represents the values of the private
fields, methods, and accessors for the object. Initially, it is an empty
List.

Internal methods and internal slots are identified within this
specification using names enclosed in double square brackets [[ ]].

summarizes the *essential internal methods* used by this specification
that are applicable to all objects created or manipulated by ECMAScript
code. Every object must have algorithms for all of the essential
internal methods. However, all objects do not necessarily use the same
algorithms for those methods.

An ordinary object is an object that satisfies all of the following
criteria:

- For the internal methods listed in , the object uses those defined in
  .
- If the object has a [[Call]] internal method, it uses either the one
  defined in or the one defined in .
- If the object has a [[Construct]] internal method, it uses either the
  one defined in or the one defined in .

An exotic object is an object that is not an ordinary object.

This specification recognizes different kinds of exotic objects by those
objects' internal methods. An object that is behaviourally equivalent to
a particular kind of exotic object (such as an Array exotic object or a
bound function exotic object), but does not have the same collection of
internal methods specified for that kind, is not recognized as that kind
of exotic object.

The “Signature” column of and other similar tables describes the
invocation pattern for each internal method. The invocation pattern
always includes a parenthesized list of descriptive parameter names. If
a parameter name is the same as an ECMAScript type name then the name
describes the required type of the parameter value. If an internal
method explicitly returns a value, its parameter list is followed by the
symbol “→” and the type name of the returned value. The type names used
in signatures refer to the types defined in clause augmented by the
following additional names. “\ *any*\ ” means the value may be any
ECMAScript language type.

In addition to its parameters, an internal method always has access to
the object that is the target of the method invocation.

An internal method implicitly returns a Completion Record, either a
normal completion that wraps a value of the return type shown in its
invocation pattern, or a throw completion.

+----------------------+----------------------+----------------------+
| Internal Method      | Signature            | Description          |
+======================+======================+======================+
| [[GetPrototypeOf]]   | ( ) **→** Object \|  | Determine the object |
|                      | Null                 | that provides        |
|                      |                      | inherited properties |
|                      |                      | for this object. A   |
|                      |                      | `null` value       |
|                      |                      | indicates that there |
|                      |                      | are no inherited     |
|                      |                      | properties.          |
+----------------------+----------------------+----------------------+
| [[SetPrototypeOf]]   | (Object \| Null)     | Associate this       |
|                      | **→** Boolean        | object with another  |
|                      |                      | object that provides |
|                      |                      | inherited            |
|                      |                      | properties. Passing  |
|                      |                      | `null` indicates   |
|                      |                      | that there are no    |
|                      |                      | inherited            |
|                      |                      | properties. Returns  |
|                      |                      | `true` indicating  |
|                      |                      | that the operation   |
|                      |                      | was completed        |
|                      |                      | successfully or      |
|                      |                      | `false` indicating |
|                      |                      | that the operation   |
|                      |                      | was not successful.  |
+----------------------+----------------------+----------------------+
| [[IsExtensible]]     | ( ) **→** Boolean    | Determine whether it |
|                      |                      | is permitted to add  |
|                      |                      | additional           |
|                      |                      | properties to this   |
|                      |                      | object.              |
+----------------------+----------------------+----------------------+
| [                    | ( ) **→** Boolean    | Control whether new  |
| [PreventExtensions]] |                      | properties may be    |
|                      |                      | added to this        |
|                      |                      | object. Returns      |
|                      |                      | `true` if the      |
|                      |                      | operation was        |
|                      |                      | successful or        |
|                      |                      | `false` if the     |
|                      |                      | operation was        |
|                      |                      | unsuccessful.        |
+----------------------+----------------------+----------------------+
| [[GetOwnProperty]]   | (propertyKey)    | Return a Property    |
|                      | **→** Undefined \|   | Descriptor for the   |
|                      | Property Descriptor  | own property of this |
|                      |                      | object whose key is  |
|                      |                      | propertyKey, or  |
|                      |                      | `undefined` if no  |
|                      |                      | such property        |
|                      |                      | exists.              |
+----------------------+----------------------+----------------------+
| [                    | (propertyKey,    | Create or alter the  |
| [DefineOwnProperty]] | P                  | own property, whose  |
|                      | ropertyDescriptor) | key is               |
|                      | **→** Boolean        | propertyKey, to  |
|                      |                      | have the state       |
|                      |                      | described by         |
|                      |                      | P                  |
|                      |                      | ropertyDescriptor. |
|                      |                      | Return `true` if   |
|                      |                      | that property was    |
|                      |                      | successfully         |
|                      |                      | created/updated or   |
|                      |                      | `false` if the     |
|                      |                      | property could not   |
|                      |                      | be created or        |
|                      |                      | updated.             |
+----------------------+----------------------+----------------------+
| [[HasProperty]]      | (propertyKey)    | Return a Boolean     |
|                      | **→** Boolean        | value indicating     |
|                      |                      | whether this object  |
|                      |                      | already has either   |
|                      |                      | an own or inherited  |
|                      |                      | property whose key   |
|                      |                      | is propertyKey.  |
+----------------------+----------------------+----------------------+
| [[Get]]              | (propertyKey,    | Return the value of  |
|                      | Receiver) **→**  | the property whose   |
|                      | *any*                | key is               |
|                      |                      | propertyKey from |
|                      |                      | this object. If any  |
|                      |                      | ECMAScript code must |
|                      |                      | be executed to       |
|                      |                      | retrieve the         |
|                      |                      | property value,      |
|                      |                      | Receiver is used |
|                      |                      | as the `this`      |
|                      |                      | value when           |
|                      |                      | evaluating the code. |
+----------------------+----------------------+----------------------+
| [[Set]]              | (propertyKey,    | Set the value of the |
|                      | value,           | property whose key   |
|                      | Receiver) **→**  | is propertyKey   |
|                      | Boolean              | to value. If any |
|                      |                      | ECMAScript code must |
|                      |                      | be executed to set   |
|                      |                      | the property value,  |
|                      |                      | Receiver is used |
|                      |                      | as the `this`      |
|                      |                      | value when           |
|                      |                      | evaluating the code. |
|                      |                      | Returns `true` if  |
|                      |                      | the property value   |
|                      |                      | was set or `false` |
|                      |                      | if it could not be   |
|                      |                      | set.                 |
+----------------------+----------------------+----------------------+
| [[Delete]]           | (propertyKey)    | Remove the own       |
|                      | **→** Boolean        | property whose key   |
|                      |                      | is propertyKey   |
|                      |                      | from this object.    |
|                      |                      | Return `false` if  |
|                      |                      | the property was not |
|                      |                      | deleted and is still |
|                      |                      | present. Return      |
|                      |                      | `true` if the      |
|                      |                      | property was deleted |
|                      |                      | or is not present.   |
+----------------------+----------------------+----------------------+
| [[OwnPropertyKeys]]  | ( ) **→** List of    | Return a List whose  |
|                      | property keys        | elements are all of  |
|                      |                      | the own property     |
|                      |                      | keys for the object. |
+----------------------+----------------------+----------------------+

summarizes additional essential internal methods that are supported by
objects that may be called as functions. A function object is an object
that supports the [[Call]] internal method. A constructor is an object
that supports the [[Construct]] internal method. Every object that
supports [[Construct]] must support [[Call]]; that is, every constructor
must be a function object. Therefore, a constructor may also be referred
to as a *constructor function* or *constructor function object*.

+-----------------+------------------------+------------------------+
| Internal Method | Signature              | Description            |
+=================+========================+========================+
| [[Call]]        | (*any*, a List of      | Executes code          |
|                 | *any*) **→** *any*     | associated with this   |
|                 |                        | object. Invoked via a  |
|                 |                        | function call          |
|                 |                        | expression. The        |
|                 |                        | arguments to the       |
|                 |                        | internal method are a  |
|                 |                        | `this` value and a   |
|                 |                        | List whose elements    |
|                 |                        | are the arguments      |
|                 |                        | passed to the function |
|                 |                        | by a call expression.  |
|                 |                        | Objects that implement |
|                 |                        | this internal method   |
|                 |                        | are *callable*.        |
+-----------------+------------------------+------------------------+
| [[Construct]]   | (a List of *any*,      | Creates an object.     |
|                 | Object) **→** Object   | Invoked via the        |
|                 |                        | `new` operator or a  |
|                 |                        | `super` call. The    |
|                 |                        | first argument to the  |
|                 |                        | internal method is a   |
|                 |                        | List whose elements    |
|                 |                        | are the arguments of   |
|                 |                        | the constructor        |
|                 |                        | invocation or the      |
|                 |                        | `super` call. The    |
|                 |                        | second argument is the |
|                 |                        | object to which the    |
|                 |                        | `new` operator was   |
|                 |                        | initially applied.     |
|                 |                        | Objects that implement |
|                 |                        | this internal method   |
|                 |                        | are called             |
|                 |                        | *constructors*. A      |
|                 |                        | function object is not |
|                 |                        | necessarily a          |
|                 |                        | constructor and such   |
|                 |                        | non-constructor        |
|                 |                        | function objects do    |
|                 |                        | not have a             |
|                 |                        | [[Construct]] internal |
|                 |                        | method.                |
+-----------------+------------------------+------------------------+

The semantics of the essential internal methods for ordinary objects and
standard exotic objects are specified in clause . If any specified use
of an internal method of an exotic object is not supported by an
implementation, that usage must throw a `TypeError` exception when
attempted.

Invariants of the Essential Internal Methods
--------------------------------------------

The Internal Methods of Objects of an ECMAScript engine must conform to
the list of invariants specified below. Ordinary ECMAScript Objects as
well as all standard exotic objects in this specification maintain these
invariants. ECMAScript Proxy objects maintain these invariants by means
of runtime checks on the result of traps invoked on the [[ProxyHandler]]
object.

Any implementation provided exotic objects must also maintain these
invariants for those objects. Violation of these invariants may cause
ECMAScript code to have unpredictable behaviour and create security
issues. However, violation of these invariants must never compromise the
memory safety of an implementation.

An implementation must not allow these invariants to be circumvented in
any manner such as by providing alternative interfaces that implement
the functionality of the essential internal methods without enforcing
their invariants.

Definitions:
------------

- The *target* of an internal method is the object upon which the
  internal method is called.
- A target is *non-extensible* if it has been observed to return
  `false` from its [[IsExtensible]] internal method, or `true` from
  its [[PreventExtensions]] internal method.
- A *non-existent* property is a property that does not exist as an own
  property on a non-extensible target.
- All references to *SameValue* are according to the definition of the
  SameValue algorithm.

Return value:
-------------

The value returned by any internal method must be a Completion Record
with either:

- [[Type]] = ~normal~, [[Target]] = ~empty~, and [[Value]] = a value of
  the "normal return type" shown below for that internal method, or
- [[Type]] = ~throw~, [[Target]] = ~empty~, and [[Value]] = any
  ECMAScript language value.

An internal method must not return a continue completion, a break
completion, or a return completion.

[[GetPrototypeOf]] ( )
----------------------

- The normal return type is either Object or Null.
- If target is non-extensible, and [[GetPrototypeOf]] returns a value
  V, then any future calls to [[GetPrototypeOf]] should return the
  SameValue as V.

An object's prototype chain should have finite length (that is, starting
from any object, recursively applying the [[GetPrototypeOf]] internal
method to its result should eventually lead to the value `null`).
However, this requirement is not enforceable as an object level
invariant if the prototype chain includes any exotic objects that do not
use the ordinary object definition of [[GetPrototypeOf]]. Such a
circular prototype chain may result in infinite loops when accessing
object properties.

[[SetPrototypeOf]] ( V )
----------------------------

- The normal return type is Boolean.
- If target is non-extensible, [[SetPrototypeOf]] must return `false`,
  unless V is the SameValue as the target's observed
  [[GetPrototypeOf]] value.

[[IsExtensible]] ( )
--------------------

- The normal return type is Boolean.
- If [[IsExtensible]] returns `false`, all future calls to
  [[IsExtensible]] on the target must return `false`.

[[PreventExtensions]] ( )
-------------------------

- The normal return type is Boolean.
- If [[PreventExtensions]] returns `true`, all future calls to
  [[IsExtensible]] on the target must return `false` and the target is
  now considered non-extensible.

[[GetOwnProperty]] ( P )
----------------------------

- The normal return type is either Property Descriptor or Undefined.
- If the return value is a Property Descriptor, it must be a fully
  populated Property Descriptor.
- If P is described as a non-configurable, non-writable own data
  property, all future calls to [[GetOwnProperty]] ( P ) must return
  Property Descriptor whose [[Value]] is SameValue as P's [[Value]]
  attribute.
- If P's attributes other than [[Writable]] and [[Value]] may change
  over time, or if the property might be deleted, then P's
  [[Configurable]] attribute must be `true`.
- If the [[Writable]] attribute may change from `false` to `true`,
  then the [[Configurable]] attribute must be `true`.
- If the target is non-extensible and P is non-existent, then all
  future calls to [[GetOwnProperty]] (P) on the target must describe
  P as non-existent (i.e. [[GetOwnProperty]] (P) must return
  `undefined`).

As a consequence of the third invariant, if a property is described as a
data property and it may return different values over time, then either
or both of the [[Writable]] and [[Configurable]] attributes must be
`true` even if no mechanism to change the value is exposed via the
other essential internal methods.

[[DefineOwnProperty]] ( P, Desc )
-----------------------------------------

- The normal return type is Boolean.
- [[DefineOwnProperty]] must return `false` if P has previously
  been observed as a non-configurable own property of the target, unless
  either:

  #. P is a writable data property. A non-configurable writable data
     property can be changed into a non-configurable non-writable data
     property.
  #. All attributes of Desc are the SameValue as P's attributes.

- [[DefineOwnProperty]] (P, Desc) must return `false` if
  target is non-extensible and P is a non-existent own property.
  That is, a non-extensible target object cannot be extended with new
  properties.

[[HasProperty]] ( P )
-------------------------

- The normal return type is Boolean.
- If P was previously observed as a non-configurable own data or
  accessor property of the target, [[HasProperty]] must return `true`.

[[Get]] ( P, Receiver )
-------------------------------

- The normal return type is any ECMAScript language type.
- If P was previously observed as a non-configurable, non-writable
  own data property of the target with value V, then [[Get]] must
  return the SameValue as V.
- If P was previously observed as a non-configurable own accessor
  property of the target whose [[Get]] attribute is `undefined`, the
  [[Get]] operation must return `undefined`.

[[Set]] ( P, V, Receiver )
--------------------------------------

- The normal return type is Boolean.
- If P was previously observed as a non-configurable, non-writable
  own data property of the target, then [[Set]] must return `false`
  unless V is the SameValue as P's [[Value]] attribute.
- If P was previously observed as a non-configurable own accessor
  property of the target whose [[Set]] attribute is `undefined`, the
  [[Set]] operation must return `false`.

[[Delete]] ( P )
--------------------

- The normal return type is Boolean.
- If P was previously observed as a non-configurable own data or
  accessor property of the target, [[Delete]] must return `false`.

[[OwnPropertyKeys]] ( )
-----------------------

- The normal return type is List.
- The returned List must not contain any duplicate entries.
- Each element of the returned List must be a property key.
- The returned List must contain at least the keys of all
  non-configurable own properties that have previously been observed.
- If the target is non-extensible, the returned List must contain only
  the keys of all own properties of the target that are observable using
  [[GetOwnProperty]].

[[Call]] ( )
------------

- The normal return type is any ECMAScript language type.

[[Construct]] ( )
-----------------

- The normal return type is Object.
- The target must also have a [[Call]] internal method.

Well-Known Intrinsic Objects
----------------------------

Well-known intrinsics are built-in objects that are explicitly
referenced by the algorithms of this specification and which usually
have realm-specific identities. Unless otherwise specified each
intrinsic object actually corresponds to a set of similar objects, one
per realm.

Within this specification a reference such as %name% means the intrinsic
object, associated with the current realm, corresponding to the name. A
reference such as %name.a.b% means, as if the `"b"` property of the
value of the `"a"` property of the intrinsic object %name% was
accessed prior to any ECMAScript code being evaluated. Determination of
the current realm and its intrinsics is described in . The well-known
intrinsics are listed in .

+----------------------+----------------------+----------------------+
| Intrinsic Name       | Global Name          | ECMAScript Language  |
|                      |                      | Association          |
+======================+======================+======================+
| %AggregateError%     | `AggregateError`   | The                  |
|                      |                      | `AggregateError`   |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Array%              | `Array`            | The Array            |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %ArrayBuffer%        | `ArrayBuffer`      | The ArrayBuffer      |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Arr                 |                      | The prototype of     |
| ayIteratorPrototype% |                      | Array Iterator       |
|                      |                      | objects ()           |
+----------------------+----------------------+----------------------+
| %AsyncFromSy         |                      | The prototype of     |
| ncIteratorPrototype% |                      | async-from-sync      |
|                      |                      | iterator objects ()  |
+----------------------+----------------------+----------------------+
| %AsyncFunction%      |                      | The constructor of   |
|                      |                      | async function       |
|                      |                      | objects ()           |
+----------------------+----------------------+----------------------+
| %Asy                 |                      | The constructor of   |
| ncGeneratorFunction% |                      | async generator      |
|                      |                      | function objects ()  |
+----------------------+----------------------+----------------------+
| %Asyn                |                      | The prototype of     |
| cGeneratorPrototype% |                      | async generator      |
|                      |                      | objects ()           |
+----------------------+----------------------+----------------------+
| %Asy                 |                      | An object that all   |
| ncIteratorPrototype% |                      | standard built-in    |
|                      |                      | async iterator       |
|                      |                      | objects indirectly   |
|                      |                      | inherit from         |
+----------------------+----------------------+----------------------+
| %Atomics%            | `Atomics`          | The `Atomics`      |
|                      |                      | object ()            |
+----------------------+----------------------+----------------------+
| %BigInt%             | `BigInt`           | The BigInt           |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %BigInt64Array%      | `BigInt64Array`    | The BigInt64Array    |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %BigUint64Array%     | `BigUint64Array`   | The BigUint64Array   |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Boolean%            | `Boolean`          | The Boolean          |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %DataView%           | `DataView`         | The DataView         |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Date%               | `Date`             | The Date constructor |
|                      |                      | ()                   |
+----------------------+----------------------+----------------------+
| %decodeURI%          | `decodeURI`        | The `decodeURI`    |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %decodeURIComponent% | `                   | The                  |
|                      | decodeURIComponent` | `                   |
|                      |                      | decodeURIComponent` |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %encodeURI%          | `encodeURI`        | The `encodeURI`    |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %encodeURIComponent% | `                   | The                  |
|                      | encodeURIComponent` | `                   |
|                      |                      | encodeURIComponent` |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %Error%              | `Error`            | The Error            |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %eval%               | `eval`             | The `eval`         |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %EvalError%          | `EvalError`        | The EvalError        |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %F                   | `Fi                 | The                  |
| inalizationRegistry% | nalizationRegistry` | FinalizationRegistry |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Float32Array%       | `Float32Array`     | The Float32Array     |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Float64Array%       | `Float64Array`     | The Float64Array     |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %For                 |                      | The prototype of     |
| InIteratorPrototype% |                      | For-In iterator      |
|                      |                      | objects ()           |
+----------------------+----------------------+----------------------+
| %Function%           | `Function`         | The Function         |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %GeneratorFunction%  |                      | The constructor of   |
|                      |                      | generator function   |
|                      |                      | objects ()           |
+----------------------+----------------------+----------------------+
| %GeneratorPrototype% |                      | The prototype of     |
|                      |                      | generator objects () |
+----------------------+----------------------+----------------------+
| %Int8Array%          | `Int8Array`        | The Int8Array        |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Int16Array%         | `Int16Array`       | The Int16Array       |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Int32Array%         | `Int32Array`       | The Int32Array       |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %isFinite%           | `isFinite`         | The `isFinite`     |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %isNaN%              | `isNaN`            | The `isNaN`        |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %Iterator%           | `Iterator`         | The `Iterator`     |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Iter                |                      | The prototype of     |
| atorHelperPrototype% |                      | Iterator Helper      |
|                      |                      | objects ()           |
+----------------------+----------------------+----------------------+
| %JSON%               | `JSON`             | The `JSON` object  |
|                      |                      | ()                   |
+----------------------+----------------------+----------------------+
| %Map%                | `Map`              | The Map constructor  |
|                      |                      | ()                   |
+----------------------+----------------------+----------------------+
| %M                   |                      | The prototype of Map |
| apIteratorPrototype% |                      | Iterator objects ()  |
+----------------------+----------------------+----------------------+
| %Math%               | `Math`             | The `Math` object  |
|                      |                      | ()                   |
+----------------------+----------------------+----------------------+
| %Number%             | `Number`           | The Number           |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Object%             | `Object`           | The Object           |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %parseFloat%         | `parseFloat`       | The `parseFloat`   |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %parseInt%           | `parseInt`         | The `parseInt`     |
|                      |                      | function ()          |
+----------------------+----------------------+----------------------+
| %Promise%            | `Promise`          | The Promise          |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Proxy%              | `Proxy`            | The Proxy            |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %RangeError%         | `RangeError`       | The RangeError       |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %ReferenceError%     | `ReferenceError`   | The ReferenceError   |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Reflect%            | `Reflect`          | The `Reflect`      |
|                      |                      | object ()            |
+----------------------+----------------------+----------------------+
| %RegExp%             | `RegExp`           | The RegExp           |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %RegExpStri          |                      | The prototype of     |
| ngIteratorPrototype% |                      | RegExp String        |
|                      |                      | Iterator objects ()  |
+----------------------+----------------------+----------------------+
| %Set%                | `Set`              | The Set constructor  |
|                      |                      | ()                   |
+----------------------+----------------------+----------------------+
| %S                   |                      | The prototype of Set |
| etIteratorPrototype% |                      | Iterator objects ()  |
+----------------------+----------------------+----------------------+
| %SharedArrayBuffer%  | \                    | The                  |
|                      | `SharedArrayBuffer` | SharedArrayBuffer    |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %String%             | `String`           | The String           |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Stri                |                      | The prototype of     |
| ngIteratorPrototype% |                      | String Iterator      |
|                      |                      | objects ()           |
+----------------------+----------------------+----------------------+
| %Symbol%             | `Symbol`           | The Symbol           |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %SyntaxError%        | `SyntaxError`      | The SyntaxError      |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %ThrowTypeError%     |                      | A function object    |
|                      |                      | that unconditionally |
|                      |                      | throws a new         |
|                      |                      | instance of          |
|                      |                      | %TypeError%          |
+----------------------+----------------------+----------------------+
| %TypedArray%         |                      | The super class of   |
|                      |                      | all typed Array      |
|                      |                      | constructors ()      |
+----------------------+----------------------+----------------------+
| %TypeError%          | `TypeError`        | The TypeError        |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Uint8Array%         | `Uint8Array`       | The Uint8Array       |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Uint8ClampedArray%  | \                    | The                  |
|                      | `Uint8ClampedArray` | Uint8ClampedArray    |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Uint16Array%        | `Uint16Array`      | The Uint16Array      |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %Uint32Array%        | `Uint32Array`      | The Uint32Array      |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %URIError%           | `URIError`         | The URIError         |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %WeakMap%            | `WeakMap`          | The WeakMap          |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %WeakRef%            | `WeakRef`          | The WeakRef          |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %WeakSet%            | `WeakSet`          | The WeakSet          |
|                      |                      | constructor ()       |
+----------------------+----------------------+----------------------+
| %WrapForVal          |                      | The prototype of     |
| idIteratorPrototype% |                      | wrapped iterator     |
|                      |                      | objects returned by  |
|                      |                      | Iterator.from ()     |
+----------------------+----------------------+----------------------+

Additional entries in .

6.2 ECMAScript Specification Types
----------------------------------

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types include Reference
Record, List, Completion Record, Property Descriptor, Environment
Record, Abstract Closure, and Data Block. Specification type values are
specification artefacts that do not necessarily correspond to any
specific entity within an ECMAScript implementation. Specification type
values may be used to describe intermediate results of ECMAScript
expression evaluation but such values cannot be stored as properties of
objects or values of ECMAScript language variables.

The Enum Specification Type
---------------------------

Enums are values which are internal to the specification and not
directly observable from ECMAScript code. Enums are denoted using a
~sans-serif~ typeface. For instance, a Completion Record's [[Type]]
field takes on values like ~normal~, ~return~, or ~throw~. Enums have no
characteristics other than their name. The name of an enum serves no
purpose other than to distinguish it from other enums, and implies
nothing about its usage or meaning in context.

The List and Record Specification Types
---------------------------------------

The List type is used to explain the evaluation of argument lists (see )
in `new` expressions, in function calls, and in other algorithms where
a simple ordered list of values is needed. Values of the List type are
simply ordered sequences of list elements containing the individual
values. These sequences may be of any length. The elements of a list may
be randomly accessed using 0-origin indices. For notational convenience
an array-like syntax can be used to access List elements. For example,
arguments[2] is shorthand for saying the 3\ :sup:`rd` element of the
List arguments.

When an algorithm iterates over the elements of a List without
specifying an order, the order used is the order of the elements in the
List.

For notational convenience within this specification, a literal syntax
can be used to express a new List value. For example, « 1, 2 » defines a
List value that has two elements each of which is initialized to a
specific value. A new empty List can be expressed as « ».

In this specification, the phrase "the list-concatenation of A,
B, ..." (where each argument is a possibly empty List) denotes a new
List value whose elements are the concatenation of the elements (in
order) of each of the arguments (in order).

As applied to a List of Strings, the phrase "sorted according to
lexicographic code unit order" means sorting by the numeric value of
each code unit up to the length of the shorter string, and sorting the
shorter string before the longer string if all are equal, as described
in the abstract operation IsLessThan.

The Record type is used to describe data aggregations within the
algorithms of this specification. A Record type value consists of one or
more named fields. The value of each field is an ECMAScript language
value or specification value. Field names are always enclosed in double
brackets, for example [[Value]].

For notational convenience within this specification, an object
literal-like syntax can be used to express a Record value. For example,
{ [[Field1]]: 42, [[Field2]]: `false`, [[Field3]]: ~empty~ } defines a
Record value that has three fields, each of which is initialized to a
specific value. Field name order is not significant. Any fields that are
not explicitly listed are considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Record value. For example, if R is the record
shown in the previous paragraph then R.[[Field2]] is shorthand for “the
field of R named [[Field2]]”.

Schema for commonly used Record field combinations may be named, and
that name may be used as a prefix to a literal Record value to identify
the specific kind of aggregations that is being described. For example:
PropertyDescriptor { [[Value]]: 42, [[Writable]]: `false`,
[[Configurable]]: `true` }.

The Set and Relation Specification Types
----------------------------------------

The *Set* type is used to explain a collection of unordered elements for
use in the memory model. It is distinct from the ECMAScript collection
type of the same name. To disambiguate, instances of the ECMAScript
collection are consistently referred to as "Set objects" within this
specification. Values of the Set type are simple collections of
elements, where no element appears more than once. Elements may be added
to and removed from Sets. Sets may be unioned, intersected, or
subtracted from each other.

The Relation type is used to explain constraints on Sets. Values of the
Relation type are Sets of ordered pairs of values from its value domain.
For example, a Relation on events is a set of ordered pairs of events.
For a Relation R and two values a and b in the value domain
of R, a R b is shorthand for saying the ordered pair
(a, b) is a member of R. A Relation is the least Relation
with respect to some conditions when it is the smallest Relation that
satisfies those conditions.

A strict partial order is a Relation value R that satisfies the
following.

- For all a, b, and c in R's domain:

  - It is not the case that a R a, and
  - If a R b and b R c, then a R c.

The two properties above are called irreflexivity and transitivity,
respectively.

A strict total order is a Relation value R that satisfies the
following.

- For all a, b, and c in R's domain:

  - a is b or a R b or b R a, and
  - It is not the case that a R a, and
  - If a R b and b R c, then a R c.

The three properties above are called totality, irreflexivity, and
transitivity, respectively.

The Completion Record Specification Type
----------------------------------------

The Completion Record specification type is used to explain the runtime
propagation of values and control flow such as the behaviour of
statements (`break`, `continue`, `return` and `throw`) that
perform nonlocal transfers of control.

Completion Records have the fields defined in .

+------------+---------------------------+---------------------------+
| Field Name | Value                     | Meaning                   |
+============+===========================+===========================+
| [[Type]]   | ~normal~, ~break~,        | The type of completion    |
|            | ~continue~, ~return~, or  | that occurred.            |
|            | ~throw~                   |                           |
+------------+---------------------------+---------------------------+
| [[Value]]  | any value except a        | The value that was        |
|            | Completion Record         | produced.                 |
+------------+---------------------------+---------------------------+
| [[Target]] | a String or ~empty~       | The target label for      |
|            |                           | directed control          |
|            |                           | transfers.                |
+------------+---------------------------+---------------------------+

The following shorthand terms are sometimes used to refer to Completion
Records.

- normal completion refers to any Completion Record with a [[Type]]
  value of ~normal~.
- break completion refers to any Completion Record with a [[Type]] value
  of ~break~.
- continue completion refers to any Completion Record with a [[Type]]
  value of ~continue~.
- return completion refers to any Completion Record with a [[Type]]
  value of ~return~.
- throw completion refers to any Completion Record with a [[Type]] value
  of ~throw~.
- abrupt completion refers to any Completion Record with a [[Type]]
  value other than ~normal~.
- a normal completion containing some type of value refers to a normal
  completion that has a value of that type in its [[Value]] field.

Callable objects that are defined in this specification only return a
normal completion or a throw completion. Returning any other kind of
Completion Record is considered an editorial error.

Implementation-defined callable objects must return either a normal
completion or a throw completion.

NormalCompletion ( value: any value except a Completion Record, ): a normal completion
------------------------------------------------------------------------------------------

1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: value,
[[Target]]: ~empty~ }.

ThrowCompletion ( value, ): a throw completion
--------------------------------------------------------------------------------

1. Return Completion Record { [[Type]]: ~throw~, [[Value]]: value,
[[Target]]: ~empty~ }.

ReturnCompletion ( value, ): a return completion
----------------------------------------------------------------------------------

1. Return Completion Record { [[Type]]: ~return~, [[Value]]: value,
[[Target]]: ~empty~ }.

UpdateEmpty ( completionRecord: a Completion Record, value: any value except a Completion Record, ): a Completion Record
--------------------------------------------------------------------------------------------------------------------------------

1. Assert: If completionRecord is either a return completion or a
throw completion, then completionRecord.[[Value]] is not ~empty~. 1.
If completionRecord.[[Value]] is not ~empty~, return ?
completionRecord. 1. Return Completion Record { [[Type]]:
completionRecord.[[Type]], [[Value]]: value, [[Target]]:
completionRecord.[[Target]] }.

The Reference Record Specification Type
---------------------------------------

The Reference Record type is used to explain the behaviour of such
operators as `delete`, `typeof`, the assignment operators, the
`super` keyword and other language features. For example, the
left-hand operand of an assignment is expected to produce a Reference
Record.

A Reference Record is a resolved name or (possibly not-yet-resolved)
property binding; its fields are defined by .

+--------------------+-----------------------+------------------------------------------------------------+
| Field Name         | Value                 | Meaning                                                    |
+====================+=======================+============================================================+
| [[Base]]           | an ECMAScript         | The value or Environment Record which holds the            |
|                    | language value, an    | binding. A [[Base]] of ~unresolvable~ indicates that the   |
|                    | Environment Record,   | binding could not be resolved.                             |
|                    | or ~unresolvable~     |                                                            |
+--------------------+-----------------------+------------------------------------------------------------+
| [[ReferencedName]] | an ECMAScript         | The name of the binding. Always a String if [[Base]]       |
|                    | language value or a   | value is an Environment Record. Otherwise, may be an       |
|                    | Private Name          | ECMAScript language value other than a String or a Symbol  |
|                    |                       | until ToPropertyKey is performed.                          |
+--------------------+-----------------------+------------------------------------------------------------+
| [[Strict]]         | a Boolean             | `true` if the Reference Record originated in strict        |
|                    |                       | mode code, `false` otherwise.                              |
+--------------------+-----------------------+------------------------------------------------------------+
| [[ThisValue]]      | an ECMAScript         | If not ~empty~, the Reference Record represents a property |
|                    | language value or     | binding that was expressed using the `super` keyword; it   |
|                    | ~empty~               | is called a Super Reference Record and its [[Base]] value  |
|                    |                       | will never be an Environment Record. In that case, the     |
|                    |                       | [[ThisValue]] field holds the `this` value at the time the |
|                    |                       | Reference Record was created.                              |
+--------------------+-----------------------+------------------------------------------------------------+

The following abstract operations are used in this specification to
operate upon Reference Records:

IsPropertyReference ( V: a Reference Record, ): a Boolean
-------------------------------------------------------------

1. If V.[[Base]] is ~unresolvable~, return `false`. 1. If
V.[[Base]] is an Environment Record, return `false`; otherwise
return `true`.

IsUnresolvableReference ( V: a Reference Record, ): a Boolean
-----------------------------------------------------------------

1. If V.[[Base]] is ~unresolvable~, return `true`; otherwise
return `false`.

IsSuperReference ( V: a Reference Record, ): a Boolean
----------------------------------------------------------

1. If V.[[ThisValue]] is not ~empty~, return `true`; otherwise
return `false`.

IsPrivateReference ( V: a Reference Record, ): a Boolean
------------------------------------------------------------

1. If V.[[ReferencedName]] is a Private Name, return `true`;
otherwise return `false`.

GetValue ( V: a Reference Record or an ECMAScript language value, )
-------------------------------------------------------------------

1. If V is not a Reference Record, return V. 1. If
IsUnresolvableReference(V) is `true`, throw a `ReferenceError`
exception. 1. If IsPropertyReference(V) is `true`, then 1.
[id="step-getvalue-toobject"] Let baseObj be ?
ToObject(V.[[Base]]). 1. If IsPrivateReference(V) is `true`,
then 1. Return ? PrivateGet(baseObj, V.[[ReferencedName]]). 1.
If V.[[ReferencedName]] is not a property key, then 1. Set
V.[[ReferencedName]] to ? ToPropertyKey(V.[[ReferencedName]]).
1. Return ? baseObj.[[Get]](V.[[ReferencedName]],
GetThisValue(V)). 1. Else, 1. Let base be V.[[Base]]. 1.
Assert: base is an Environment Record. 1. Return ?
base.GetBindingValue(V.[[ReferencedName]], V.[[Strict]])
(see ).

The object that may be created in step is not accessible outside of the
above abstract operation and the ordinary object [[Get]] internal
method. An implementation might choose to avoid the actual creation of
the object.

PutValue ( V: a Reference Record or an ECMAScript language value, W, )
----------------------------------------------------------------------

1. If V is not a Reference Record, throw a `ReferenceError`
exception. 1. If IsUnresolvableReference(V) is `true`, then 1. If
V.[[Strict]] is `true`, throw a `ReferenceError` exception. 1.
Let globalObj be GetGlobalObject(). 1. Perform ? Set(globalObj,
V.[[ReferencedName]], W, `false`). 1. Return ~unused~. 1. If
IsPropertyReference(V) is `true`, then 1.
[id="step-putvalue-toobject"] Let baseObj be ?
ToObject(V.[[Base]]). 1. If IsPrivateReference(V) is `true`,
then 1. Return ? PrivateSet(baseObj, V.[[ReferencedName]],
W). 1. If V.[[ReferencedName]] is not a property key, then 1.
Set V.[[ReferencedName]] to ?
ToPropertyKey(V.[[ReferencedName]]). 1. Let succeeded be ?
baseObj.[[Set]](V.[[ReferencedName]], W,
GetThisValue(V)). 1. If succeeded is `false` and
V.[[Strict]] is `true`, throw a `TypeError` exception. 1. Return
~unused~. 1. Else, 1. Let base be V.[[Base]]. 1. Assert:
base is an Environment Record. 1. Return ?
base.SetMutableBinding(V.[[ReferencedName]], W,
V.[[Strict]]) (see ).

The object that may be created in step is not accessible outside of the
above abstract operation and the ordinary object [[Set]] internal
method. An implementation might choose to avoid the actual creation of
that object.

GetThisValue ( V: a Reference Record, )
-------------------------------------------------------------------------

1. Assert: IsPropertyReference(V) is `true`. 1. If
IsSuperReference(V) is `true`, return V.[[ThisValue]];
otherwise return V.[[Base]].

InitializeReferencedBinding ( V: a Reference Record, W, )
---------------------------------------------------------

1. Assert: IsUnresolvableReference(V) is `false`. 1. Let base
be V.[[Base]]. 1. Assert: base is an Environment Record. 1.
Return ? base.InitializeBinding(V.[[ReferencedName]], W).

MakePrivateReference ( baseValue, privateIdentifier: a String, ): a Reference Record
--------------------------------------------------------------------------------------------------------------------------

1. Let privateEnv be the running execution context's
PrivateEnvironment. 1. Assert: privateEnv is not `null`. 1. Let
privateName be ResolvePrivateIdentifier(privateEnv,
privateIdentifier). 1. Return the Reference Record { [[Base]]:
baseValue, [[ReferencedName]]: privateName, [[Strict]]:
`true`, [[ThisValue]]: ~empty~ }.

The Property Descriptor Specification Type
------------------------------------------

The Property Descriptor type is used to explain the manipulation and
reification of Object property attributes. A Property Descriptor is a
Record with zero or more fields, where each field's name is an attribute
name and its value is a corresponding attribute value as specified in .
The schema name used within this specification to tag literal
descriptions of Property Descriptor records is “PropertyDescriptor”.

Property Descriptor values may be further classified as data Property
Descriptors and accessor Property Descriptors based upon the existence
or use of certain fields. A data Property Descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
Property Descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any Property Descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
Property Descriptor and an accessor Property Descriptor; however, it may
be neither (in which case it is a generic Property Descriptor). A fully
populated Property Descriptor is one that is either an accessor Property
Descriptor or a data Property Descriptor and that has all of the
corresponding fields defined in .

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

IsAccessorDescriptor ( Desc: a Property Descriptor or `undefined`, ): a Boolean
-------------------------------------------------------------------------------------

1. If Desc is `undefined`, return `false`. 1. If Desc has a
[[Get]] field, return `true`. 1. If Desc has a [[Set]] field,
return `true`. 1. Return `false`.

IsDataDescriptor ( Desc: a Property Descriptor or `undefined`, ): a Boolean
---------------------------------------------------------------------------------

1. If Desc is `undefined`, return `false`. 1. If Desc has a
[[Value]] field, return `true`. 1. If Desc has a [[Writable]]
field, return `true`. 1. Return `false`.

IsGenericDescriptor ( Desc: a Property Descriptor or `undefined`, ): a Boolean
------------------------------------------------------------------------------------

1. If Desc is `undefined`, return `false`. 1. If
IsAccessorDescriptor(Desc) is `true`, return `false`. 1. If
IsDataDescriptor(Desc) is `true`, return `false`. 1. Return
`true`.

FromPropertyDescriptor ( Desc: a Property Descriptor or `undefined`, ): an Object or `undefined`
--------------------------------------------------------------------------------------------------------

1. If Desc is `undefined`, return `undefined`. 1. Let obj be
OrdinaryObjectCreate(%Object.prototype%). 1. Assert: obj is an
extensible ordinary object with no own properties. 1. If Desc has a
[[Value]] field, then 1. Perform ! CreateDataPropertyOrThrow(obj,
`"value"`, Desc.[[Value]]). 1. If Desc has a [[Writable]]
field, then 1. Perform ! CreateDataPropertyOrThrow(obj,
`"writable"`, Desc.[[Writable]]). 1. If Desc has a [[Get]]
field, then 1. Perform ! CreateDataPropertyOrThrow(obj, `"get"`,
Desc.[[Get]]). 1. If Desc has a [[Set]] field, then 1. Perform !
CreateDataPropertyOrThrow(obj, `"set"`, Desc.[[Set]]). 1. If
Desc has an [[Enumerable]] field, then 1. Perform !
CreateDataPropertyOrThrow(obj, `"enumerable"`,
Desc.[[Enumerable]]). 1. If Desc has a [[Configurable]] field,
then 1. Perform ! CreateDataPropertyOrThrow(obj, `"configurable"`,
Desc.[[Configurable]]). 1. Return obj.

ToPropertyDescriptor ( Obj, )
-----------------------------

1. If Obj is not an Object, throw a `TypeError` exception. 1. Let
desc be a new Property Descriptor that initially has no fields. 1.
Let hasEnumerable be ? HasProperty(Obj, `"enumerable"`). 1. If
hasEnumerable is `true`, then 1. Let enumerable be ToBoolean(?
Get(Obj, `"enumerable"`)). 1. Set desc.[[Enumerable]] to
enumerable. 1. Let hasConfigurable be ? HasProperty(Obj,
`"configurable"`). 1. If hasConfigurable is `true`, then 1. Let
configurable be ToBoolean(? Get(Obj, `"configurable"`)). 1.
Set desc.[[Configurable]] to configurable. 1. Let hasValue
be ? HasProperty(Obj, `"value"`). 1. If hasValue is `true`,
then 1. Let value be ? Get(Obj, `"value"`). 1. Set
desc.[[Value]] to value. 1. Let hasWritable be ?
HasProperty(Obj, `"writable"`). 1. If hasWritable is `true`,
then 1. Let writable be ToBoolean(? Get(Obj, `"writable"`)).
1. Set desc.[[Writable]] to writable. 1. Let hasGet be ?
HasProperty(Obj, `"get"`). 1. If hasGet is `true`, then 1.
Let getter be ? Get(Obj, `"get"`). 1. If
IsCallable(getter) is `false` and getter is not `undefined`,
throw a `TypeError` exception. 1. Set desc.[[Get]] to getter.
1. Let hasSet be ? HasProperty(Obj, `"set"`). 1. If hasSet
is `true`, then 1. Let setter be ? Get(Obj, `"set"`). 1. If
IsCallable(setter) is `false` and setter is not `undefined`,
throw a `TypeError` exception. 1. Set desc.[[Set]] to setter.
1. If desc has a [[Get]] field or desc has a [[Set]] field, then
1. If desc has a [[Value]] field or desc has a [[Writable]]
field, throw a `TypeError` exception. 1. Return desc.

CompletePropertyDescriptor ( Desc: a Property Descriptor, ): ~unused~
-------------------------------------------------------------------------

1. Let like be the Record { [[Value]]: `undefined`, [[Writable]]:
`false`, [[Get]]: `undefined`, [[Set]]: `undefined`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }. 1. If
IsGenericDescriptor(Desc) is `true` or IsDataDescriptor(Desc)
is `true`, then 1. If Desc does not have a [[Value]] field, set
Desc.[[Value]] to like.[[Value]]. 1. If Desc does not have a
[[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].
1. Else, 1. If Desc does not have a [[Get]] field, set
Desc.[[Get]] to like.[[Get]]. 1. If Desc does not have a
[[Set]] field, set Desc.[[Set]] to like.[[Set]]. 1. If Desc
does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to
like.[[Enumerable]]. 1. If Desc does not have a [[Configurable]]
field, set Desc.[[Configurable]] to like.[[Configurable]]. 1.
Return ~unused~.

The Environment Record Specification Type
-----------------------------------------

The Environment Record type is used to explain the behaviour of name
resolution in nested functions and blocks. This type and the operations
upon it are defined in .

The Abstract Closure Specification Type
---------------------------------------

The Abstract Closure specification type is used to refer to algorithm
steps together with a collection of values. Abstract Closures are
meta-values and are invoked using function application style such as
closure(arg1, arg2). Like abstract operations, invocations
perform the algorithm steps described by the Abstract Closure.

In algorithm steps that create an Abstract Closure, values are captured
with the verb "capture" followed by a list of aliases. When an Abstract
Closure is created, it captures the value that is associated with each
alias at that time. In steps that specify the algorithm to be performed
when an Abstract Closure is called, each captured value is referred to
by the alias that was used to capture the value.

If an Abstract Closure returns a Completion Record, that Completion
Record must be either a normal completion or a throw completion.

Abstract Closures are created inline as part of other algorithms, shown
in the following example.

1. Let addend be 41. 1. Let closure be a new Abstract Closure
with parameters (x) that captures addend and performs the
following steps when called: 1. Return x + addend. 1. Let
val be closure(1). 1. Assert: val is 42.

Data Blocks
-----------

The Data Block specification type is used to describe a distinct and
mutable sequence of byte-sized (8 bit) numeric values. A byte value is
an integer in the inclusive interval from 0 to 255. A Data Block value
is created with a fixed number of bytes that each have the initial value
0.

For notational convenience within this specification, an array-like
syntax can be used to access the individual bytes of a Data Block value.
This notation presents a Data Block value as a 0-based integer-indexed
sequence of bytes. For example, if db is a 5 byte Data Block value
then db[2] can be used to access its 3\ :sup:`rd` byte.

A data block that resides in memory that can be referenced from multiple
agents concurrently is designated a Shared Data Block. A Shared Data
Block has an identity (for the purposes of equality testing Shared Data
Block values) that is *address-free*: it is tied not to the virtual
addresses the block is mapped to in any process, but to the set of
locations in memory that the block represents. Two data blocks are equal
only if the sets of the locations they contain are equal; otherwise,
they are not equal and the intersection of the sets of locations they
contain is empty. Finally, Shared Data Blocks can be distinguished from
Data Blocks.

The semantics of Shared Data Blocks is defined using Shared Data Block
events by the memory model. Abstract operations below introduce Shared
Data Block events and act as the interface between evaluation semantics
and the event semantics of the memory model. The events form a candidate
execution, on which the memory model acts as a filter. Please consult
the memory model for full semantics.

Shared Data Block events are modelled by Records, defined in the memory
model.

The following abstract operations are used in this specification to
operate upon Data Block values:

CreateByteDataBlock ( size: a non-negative integer, )
-----------------------------------------------------

1. If size > 2\ :sup:`53` - 1, throw a `RangeError` exception. 1.
Let db be a new Data Block value consisting of size bytes. If it
is impossible to create such a Data Block, throw a `RangeError`
exception. 1. Set all of the bytes of db to 0. 1. Return db.

CreateSharedByteDataBlock ( size: a non-negative integer, )
-----------------------------------------------------------

1. Let db be a new Shared Data Block value consisting of size
bytes. If it is impossible to create such a Shared Data Block, throw a
`RangeError` exception. 1. Let execution be the
[[CandidateExecution]] field of the surrounding agent's Agent Record. 1.
Let eventsRecord be the Agent Events Record of
execution.[[EventsRecords]] whose [[AgentSignifier]] is
AgentSignifier(). 1. Let zero be « 0 ». 1. For each index i of
db, do 1. Append WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]:
`true`, [[Block]]: db, [[ByteIndex]]: i, [[ElementSize]]: 1,
[[Payload]]: zero } to eventsRecord.[[EventList]]. 1. Return
db.

CopyDataBlockBytes ( toBlock: a Data Block or a Shared Data Block, toIndex: a non-negative integer, fromBlock: a Data Block or a Shared Data Block, fromIndex: a non-negative integer, count: a non-negative integer, ): ~unused~
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: fromBlock and toBlock are distinct values. 1. Let
fromSize be the number of bytes in fromBlock. 1. Assert:
fromIndex + count ≤ fromSize. 1. Let toSize be the
number of bytes in toBlock. 1. Assert: toIndex + count ≤
toSize. 1. Repeat, while count > 0, 1. If fromBlock is a
Shared Data Block, then 1. Let execution be the
[[CandidateExecution]] field of the surrounding agent's Agent Record. 1.
Let eventsRecord be the Agent Events Record of
execution.[[EventsRecords]] whose [[AgentSignifier]] is
AgentSignifier(). 1. Let bytes be a List whose sole element is a
nondeterministically chosen byte value. 1. NOTE: In implementations,
bytes is the result of a non-atomic read instruction on the
underlying hardware. The nondeterminism is a semantic prescription of
the memory model to describe observable behaviour of hardware with weak
consistency. 1. Let readEvent be ReadSharedMemory { [[Order]]:
~unordered~, [[NoTear]]: `true`, [[Block]]: fromBlock,
[[ByteIndex]]: fromIndex, [[ElementSize]]: 1 }. 1. Append
readEvent to eventsRecord.[[EventList]]. 1. Append Chosen Value
Record { [[Event]]: readEvent, [[ChosenValue]]: bytes } to
execution.[[ChosenValues]]. 1. If toBlock is a Shared Data
Block, then 1. Append WriteSharedMemory { [[Order]]: ~unordered~,
[[NoTear]]: `true`, [[Block]]: toBlock, [[ByteIndex]]:
toIndex, [[ElementSize]]: 1, [[Payload]]: bytes } to
eventsRecord.[[EventList]]. 1. Else, 1. Set toBlock[toIndex]
to bytes[0]. 1. Else, 1. Assert: toBlock is not a Shared Data
Block. 1. Set toBlock[toIndex] to fromBlock[fromIndex].
1. Set toIndex to toIndex + 1. 1. Set fromIndex to
fromIndex + 1. 1. Set count to count - 1. 1. Return
~unused~.

The PrivateElement Specification Type
-------------------------------------

The PrivateElement type is a Record used in the specification of private
class fields, methods, and accessors. Although Property Descriptors are
not used for private elements, private fields behave similarly to
non-configurable, non-enumerable, writable data properties, private
methods behave similarly to non-configurable, non-enumerable,
non-writable data properties, and private accessors behave similarly to
non-configurable, non-enumerable accessor properties.

Values of the PrivateElement type are Record values whose fields are
defined by . Such values are referred to as PrivateElements.

+------------+-----------------+-----------------+-----------------+
| Field Name | Values of the   | Value           | Meaning         |
|            | [[Kind]] field  |                 |                 |
|            | for which it is |                 |                 |
|            | present         |                 |                 |
+============+=================+=================+=================+
| [[Key]]    | All             | a Private Name  | The name of the |
|            |                 |                 | field, method,  |
|            |                 |                 | or accessor.    |
+------------+-----------------+-----------------+-----------------+
| [[Kind]]   | All             | ~field~,        | The kind of the |
|            |                 | ~method~, or    | element.        |
|            |                 | ~accessor~      |                 |
+------------+-----------------+-----------------+-----------------+
| [[Value]]  | ~field~ and     | an ECMAScript   | The value of    |
|            | ~method~        | language value  | the field.      |
+------------+-----------------+-----------------+-----------------+
| [[Get]]    | ~accessor~      | a function      | The getter for  |
|            |                 | object or       | a private       |
|            |                 | `undefined`   | accessor.       |
+------------+-----------------+-----------------+-----------------+
| [[Set]]    | ~accessor~      | a function      | The setter for  |
|            |                 | object or       | a private       |
|            |                 | `undefined`   | accessor.       |
+------------+-----------------+-----------------+-----------------+

The ClassFieldDefinition Record Specification Type
--------------------------------------------------

The ClassFieldDefinition type is a Record used in the specification of
class fields.

Values of the ClassFieldDefinition type are Record values whose fields
are defined by . Such values are referred to as ClassFieldDefinition
Records.

+-----------------+------------------------+------------------------+
| Field Name      | Value                  | Meaning                |
+=================+========================+========================+
| [[Name]]        | a Private Name, a      | The name of the field. |
|                 | String, or a Symbol    |                        |
+-----------------+------------------------+------------------------+
| [[Initializer]] | an ECMAScript function | The initializer of the |
|                 | object or ~empty~      | field, if any.         |
+-----------------+------------------------+------------------------+

Private Names
-------------

The Private Name specification type is used to describe a globally
unique value (one which differs from any other Private Name, even if
they are otherwise indistinguishable) which represents the key of a
private class element (field, method, or accessor). Each Private Name
has an associated immutable [[Description]] which is a String value. A
Private Name may be installed on any ECMAScript object with
PrivateFieldAdd or PrivateMethodOrAccessorAdd, and then read or written
using PrivateGet and PrivateSet.

The ClassStaticBlockDefinition Record Specification Type
--------------------------------------------------------

A ClassStaticBlockDefinition Record is a Record value used to
encapsulate the executable code for a class static initialization block.

ClassStaticBlockDefinition Records have the fields listed in .

+------------------+------------------------+------------------------+
| Field Name       | Value                  | Meaning                |
+==================+========================+========================+
| [[BodyFunction]] | an ECMAScript function | The function object to |
|                  | object                 | be called during       |
|                  |                        | static initialization  |
|                  |                        | of a class.            |
+------------------+------------------------+------------------------+

.. _abstract-operations-1:

7. Abstract Operations
======================

https://tc39.es/ecma262/multipage/abstract-operations.html
::

   7.1 Type Conversion
      7.1.1 ToPrimitive ( input [ , preferredType ] )
         7.1.1.1 OrdinaryToPrimitive ( O, hint )
      7.1.2 ToBoolean ( argument )
      7.1.3 ToNumeric ( value )
      7.1.4 ToNumber ( argument )
      7.1.4.1 ToNumber Applied to the String Type
         7.1.4.1.1 StringToNumber ( str )
         7.1.4.1.2 RS: StringNumericValue
         7.1.4.1.3 RoundMVResult ( n )
      7.1.5 ToIntegerOrInfinity ( argument )
      7.1.6 ToInt32 ( argument )
      7.1.7 ToUint32 ( argument )
      7.1.8 ToInt16 ( argument )
      7.1.9 ToUint16 ( argument )
      7.1.10 ToInt8 ( argument )
      7.1.11 ToUint8 ( argument )
      7.1.12 ToUint8Clamp ( argument )
      7.1.13 ToBigInt ( argument )
      7.1.14 StringToBigInt ( str )
      7.1.15 ToBigInt64 ( argument )
      7.1.16 ToBigUint64 ( argument )
      7.1.17 ToString ( argument )
      7.1.18 ToObject ( argument )
      7.1.19 ToPropertyKey ( argument )
      7.1.20 ToLength ( argument )
      7.1.21 CanonicalNumericIndexString ( argument )
      7.1.22 ToIndex ( value )
   7.2 Testing and Comparison Operations
      7.2.1 RequireObjectCoercible ( argument )
      7.2.2 IsArray ( argument )
      7.2.3 IsCallable ( argument )
      7.2.4 IsConstructor ( argument )
      7.2.5 IsExtensible ( O )
      7.2.6 IsRegExp ( argument )
      7.2.7 SS: IsStringWellFormedUnicode ( string )
      7.2.8 SameType ( x, y )
      7.2.9 SameValue ( x, y )
      7.2.10 SameValueZero ( x, y )
      7.2.11 SameValueNonNumber ( x, y )
      7.2.12 IsLessThan ( x, y, LeftFirst )
      7.2.13 IsLooselyEqual ( x, y )
      7.2.14 IsStrictlyEqual ( x, y )
   7.3 Operations on Objects
      7.3.1 MakeBasicObject ( internalSlotsList )
      7.3.2 Get ( O, P )
      7.3.3 GetV ( V, P )
      7.3.4 Set ( O, P, V, Throw )
      7.3.5 CreateDataProperty ( O, P, V )
      7.3.6 CreateDataPropertyOrThrow ( O, P, V )
      7.3.7 CreateNonEnumerableDataPropertyOrThrow ( O, P, V )
      7.3.8 DefinePropertyOrThrow ( O, P, desc )
      7.3.9 DeletePropertyOrThrow ( O, P )
      7.3.10 GetMethod ( V, P )
      7.3.11 HasProperty ( O, P )
      7.3.12 HasOwnProperty ( O, P )
      7.3.13 Call ( F, V [ , argumentsList ] )
      7.3.14 Construct ( F [ , argumentsList [ , newTarget ] ] )
      7.3.15 SetIntegrityLevel ( O, level )
      7.3.16 TestIntegrityLevel ( O, level )
      7.3.17 CreateArrayFromList ( elements )
      7.3.18 LengthOfArrayLike ( obj )
      7.3.19 CreateListFromArrayLike ( obj [ , validElementTypes ] )
      7.3.20 Invoke ( V, P [ , argumentsList ] )
      7.3.21 OrdinaryHasInstance ( C, O )
      7.3.22 SpeciesConstructor ( O, defaultConstructor )
      7.3.23 EnumerableOwnProperties ( O, kind )
      7.3.24 GetFunctionRealm ( obj )
      7.3.25 CopyDataProperties ( target, source, excludedItems )
      7.3.26 PrivateElementFind ( O, P )
      7.3.27 PrivateFieldAdd ( O, P, value )
      7.3.28 PrivateMethodOrAccessorAdd ( O, method )
      7.3.29 HostEnsureCanAddPrivateElement ( O )
      7.3.30 PrivateGet ( O, P )
      7.3.31 PrivateSet ( O, P, value )
      7.3.32 DefineField ( receiver, fieldRecord )
      7.3.33 InitializeInstanceElements ( O, constructor )
      7.3.34 AddValueToKeyedGroup ( groups, key, value )
      7.3.35 GroupBy ( items, callback, keyCoercion )
      7.3.36 SetterThatIgnoresPrototypeProperties ( thisValue, home, p, v )
   7.4 Operations on Iterator Objects
      7.4.1 Iterator Records
      7.4.2 GetIteratorDirect ( obj )
      7.4.3 GetIteratorFromMethod ( obj, method )
      7.4.4 GetIterator ( obj, kind )
      7.4.5 GetIteratorFlattenable ( obj, primitiveHandling )
      7.4.6 IteratorNext ( iteratorRecord [ , value ] )
      7.4.7 IteratorComplete ( iteratorResult )
      7.4.8 IteratorValue ( iteratorResult )
      7.4.9 IteratorStep ( iteratorRecord )
      7.4.10 IteratorStepValue ( iteratorRecord )
      7.4.11 IteratorClose ( iteratorRecord, completion )
      7.4.12 IfAbruptCloseIterator ( value, iteratorRecord )
      7.4.13 AsyncIteratorClose ( iteratorRecord, completion )
      7.4.14 CreateIteratorResultObject ( value, done )
      7.4.15 CreateListIteratorRecord ( list )
      7.4.16 IteratorToList ( iteratorRecord )

These operations are not a part of the ECMAScript language; they are
defined here solely to aid the specification of the semantics of the
ECMAScript language. Other, more specialized abstract operations are
defined throughout this specification.

Type Conversion
---------------

The ECMAScript language implicitly performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. The conversion abstract
operations are polymorphic; they can accept a value of any ECMAScript
language type. But no other specification types are used with these
operations.

The BigInt type has no implicit conversions in the ECMAScript language;
programmers must call BigInt explicitly to convert values from other
types.

ToPrimitive ( input, optional preferredType: ~string~ or ~number~, )
--------------------------------------------------------------------

description
   It converts its input argument to a non-Object type. If an object
   is capable of converting to more than one primitive type, it may use
   the optional hint preferredType to favour that type.

1. If input is an Object, then 1. Let exoticToPrim be ?
GetMethod(input, %Symbol.toPrimitive%). 1. If exoticToPrim is
not `undefined`, then 1. If preferredType is not present, then 1.
Let hint be `"default"`. 1. Else if preferredType is ~string~,
then 1. Let hint be `"string"`. 1. Else, 1. Assert:
preferredType is ~number~. 1. Let hint be `"number"`. 1. Let
result be ? Call(exoticToPrim, input, « hint »). 1. If
result is not an Object, return result. 1. Throw a `TypeError`
exception. 1. If preferredType is not present, let preferredType
be ~number~. 1. Return ? OrdinaryToPrimitive(input,
preferredType). 1. Return input.

When ToPrimitive is called without a hint, then it generally behaves as
if the hint were ~number~. However, objects may over-ride this behaviour
by defining a %Symbol.toPrimitive% method. Of the objects defined in
this specification only Dates (see ) and Symbol objects (see ) over-ride
the default ToPrimitive behaviour. Dates treat the absence of a hint as
if the hint were ~string~.

OrdinaryToPrimitive ( O: an Object, hint: ~string~ or ~number~, )
-----------------------------------------------------------------

1. If hint is ~string~, then 1. Let methodNames be «
`"toString"`, `"valueOf"` ». 1. Else, 1. Let methodNames be «
`"valueOf"`, `"toString"` ». 1. For each element name of
methodNames, do 1. Let method be ? Get(O, name). 1. If
IsCallable(method) is `true`, then 1. Let result be ?
Call(method, O). 1. If result is not an Object, return
result. 1. Throw a `TypeError` exception.

ToBoolean ( argument, ): a Boolean
--------------------------------------------------------------------

description
   It converts argument to a value of type Boolean.

1. If argument is a Boolean, return argument. 1. If argument
is one of `undefined`, `null`, `+0`\ :sub:`𝔽`, `-0`\ :sub:`𝔽`,
`NaN`, `0`\ :sub:`ℤ`, or the empty String, return `false`. 1.
[id="step-to-boolean-web-compat-insertion-point"] NOTE: This step is
replaced in section . 1. Return `true`.

ToNumeric ( value, )
--------------------

description
   It returns value converted to a Number or a BigInt.

1. Let primValue be ? ToPrimitive(value, ~number~). 1. If
primValue is a BigInt, return primValue. 1. Return ?
ToNumber(primValue).

ToNumber ( argument, )
----------------------

description
   It converts argument to a value of type Number.

1. If argument is a Number, return argument. 1. If argument
is either a Symbol or a BigInt, throw a `TypeError` exception. 1. If
argument is `undefined`, return `NaN`. 1. If argument is
either `null` or `false`, return `+0`\ :sub:`𝔽`. 1. If
argument is `true`, return `1`\ :sub:`𝔽`. 1. If argument is
a String, return StringToNumber(argument). 1. Assert: argument
is an Object. 1. Let primValue be ? ToPrimitive(argument,
~number~). 1. Assert: primValue is not an Object. 1. Return ?
ToNumber(primValue).

ToNumber Applied to the String Type
-----------------------------------

The abstract operation StringToNumber specifies how to convert a String
value to a Number value, using the following grammar.

**Syntax**


StringNumericLiteral ::: StrWhiteSpace? StrWhiteSpace? StrNumericLiteral
StrWhiteSpace? StrWhiteSpace ::: StrWhiteSpaceChar StrWhiteSpace?
StrWhiteSpaceChar ::: WhiteSpace LineTerminator StrNumericLiteral :::
StrDecimalLiteral NonDecimalIntegerLiteral[~Sep] StrDecimalLiteral :::
StrUnsignedDecimalLiteral `+` StrUnsignedDecimalLiteral `-`
StrUnsignedDecimalLiteral StrUnsignedDecimalLiteral ::: `Infinity`
DecimalDigits[~Sep] `.` DecimalDigits[~Sep]? ExponentPart[~Sep]? `.`
DecimalDigits[~Sep] ExponentPart[~Sep]? DecimalDigits[~Sep]
ExponentPart[~Sep]?

All grammar symbols not explicitly defined above have the definitions
used in the Lexical Grammar for numeric literals ()

Some differences should be noted between the syntax of a
`StringNumericLiteral` and a `NumericLiteral`:

- A `StringNumericLiteral` may include leading and/or trailing white
  space and/or line terminators.
- A `StringNumericLiteral` that is decimal may have any number of
  leading `0` digits.
- A `StringNumericLiteral` that is decimal may include a `+` or
  `-` to indicate its sign.
- A `StringNumericLiteral` that is empty or contains only white space
  is converted to `+0`\ :sub:`𝔽`.
- `Infinity` and `-Infinity` are recognized as a
  `StringNumericLiteral` but not as a `NumericLiteral`.
- A `StringNumericLiteral` cannot include a `BigIntLiteralSuffix`.
- A `StringNumericLiteral` cannot include a
  `NumericLiteralSeparator`.

StringToNumber ( str: a String, ): a Number
-----------------------------------------------

1. Let literal be ParseText(str, `StringNumericLiteral`). 1.
If literal is a List of errors, return `NaN`. 1. Return the
StringNumericValue of literal.

Runtime Semantics: StringNumericValue ( ): a Number
---------------------------------------------------

The conversion of a `StringNumericLiteral` to a Number value is
similar overall to the determination of the NumericValue of a
`NumericLiteral` (see ), but some of the details are different.

StringNumericLiteral ::: StrWhiteSpace? 1. Return `+0`\ :sub:`𝔽`.
StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?
1. Return the StringNumericValue of `StrNumericLiteral`.
StrNumericLiteral ::: NonDecimalIntegerLiteral 1. Return 𝔽(MV of
`NonDecimalIntegerLiteral`). StrDecimalLiteral ::: `-`
StrUnsignedDecimalLiteral 1. Let a be the StringNumericValue of
`StrUnsignedDecimalLiteral`. 1. If a is `+0`\ :sub:`𝔽`, return
`-0`\ :sub:`𝔽`. 1. Return -a. StrUnsignedDecimalLiteral :::
`Infinity` 1. Return `+∞`\ :sub:`𝔽`. StrUnsignedDecimalLiteral :::
DecimalDigits `.` DecimalDigits? ExponentPart? 1. Let a be the MV
of the first `DecimalDigits`. 1. If the second `DecimalDigits` is
present, then 1. Let b be the MV of the second `DecimalDigits`. 1.
Let n be the number of code points in the second `DecimalDigits`.
1. Else, 1. Let b be 0. 1. Let n be 0. 1. If `ExponentPart` is
present, let e be the MV of `ExponentPart`. Otherwise, let e
be 0. 1. Return RoundMVResult((a + (b × 10\ :sup:`-n`)) ×
10\ :sup:`e`). StrUnsignedDecimalLiteral ::: `.` DecimalDigits
ExponentPart? 1. Let b be the MV of `DecimalDigits`. 1. If
`ExponentPart` is present, let e be the MV of `ExponentPart`.
Otherwise, let e be 0. 1. Let n be the number of code points in
`DecimalDigits`. 1. Return RoundMVResult(b × 10\ :sup:`e -
n`). StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart? 1.
Let a be the MV of `DecimalDigits`. 1. If `ExponentPart` is
present, let e be the MV of `ExponentPart`. Otherwise, let e
be 0. 1. Return RoundMVResult(a × 10\ :sup:`e`).

RoundMVResult ( n: a mathematical value, ): a Number
--------------------------------------------------------

description
   It converts n to a Number in an implementation-defined manner.
   For the purposes of this abstract operation, a digit is significant
   if it is not zero or there is a non-zero digit to its left and there
   is a non-zero digit to its right. For the purposes of this abstract
   operation, "the mathematical value denoted by" a representation of a
   mathematical value is the inverse of "the decimal representation of"
   a mathematical value.

1. If the decimal representation of n has 20 or fewer significant
digits, return 𝔽(n). 1. Let option1 be the mathematical value
denoted by the result of replacing each significant digit in the decimal
representation of n after the 20th with a 0 digit. 1. Let
option2 be the mathematical value denoted by the result of replacing
each significant digit in the decimal representation of n after the
20th with a 0 digit and then incrementing it at the 20th position (with
carrying as necessary). 1. Let chosen be an implementation-defined
choice of either option1 or option2. 1. Return 𝔽(chosen).

ToIntegerOrInfinity ( argument, )
---------------------------------

description
   It converts argument to an integer representing its Number value
   with fractional part truncated, or to +∞ or -∞ when that Number value
   is infinite.

1. Let number be ? ToNumber(argument). 1. If number is one
of `NaN`, `+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return 0. 1. If
number is `+∞`\ :sub:`𝔽`, return +∞. 1. If number is
`-∞`\ :sub:`𝔽`, return -∞. 1. Return truncate(ℝ(number)).
𝔽(ToIntegerOrInfinity(x)) never returns `-0`\ :sub:`𝔽` for any
value of x. The truncation of the fractional part is performed after
converting x to a mathematical value.

ToInt32 ( argument, )
---------------------

description
   It converts argument to one of 2\ :sup:`32` integral Number
   values in the inclusive interval from 𝔽(-2\ :sup:`31`) to
   𝔽(2\ :sup:`31` - 1).

1. Let number be ? ToNumber(argument). 1. If number is not
finite or number is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`,
return `+0`\ :sub:`𝔽`. 1. Let int be truncate(ℝ(number)). 1.
Let int32bit be int modulo 2\ :sup:`32`. 1. If int32bit ≥
2\ :sup:`31`, return 𝔽(int32bit - 2\ :sup:`32`); otherwise return
𝔽(int32bit).

Given the above definition of ToInt32:

- The ToInt32 abstract operation is idempotent: if applied to a result
  that it produced, the second application leaves that value unchanged.
- ToInt32(ToUint32(x)) is the same value as ToInt32(x) for all
  values of x. (It is to preserve this latter property that
  `+∞`\ :sub:`𝔽` and `-∞`\ :sub:`𝔽` are mapped to `+0`\ :sub:`𝔽`.)
- ToInt32 maps `-0`\ :sub:`𝔽` to `+0`\ :sub:`𝔽`.

ToUint32 ( argument, )
----------------------

description
   It converts argument to one of 2\ :sup:`32` integral Number
   values in the inclusive interval from `+0`\ :sub:`𝔽` to
   𝔽(2\ :sup:`32` - 1).

1. Let number be ? ToNumber(argument). 1. If number is not
finite or number is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`,
return `+0`\ :sub:`𝔽`. 1. Let int be truncate(ℝ(number)). 1.
Let int32bit be int modulo 2\ :sup:`32`. 1.
[id="step-touint32-return"] Return 𝔽(int32bit).

Given the above definition of ToUint32:

- Step is the only difference between ToUint32 and ToInt32.
- The ToUint32 abstract operation is idempotent: if applied to a result
  that it produced, the second application leaves that value unchanged.
- ToUint32(ToInt32(x)) is the same value as ToUint32(x) for all
  values of x. (It is to preserve this latter property that
  `+∞`\ :sub:`𝔽` and `-∞`\ :sub:`𝔽` are mapped to `+0`\ :sub:`𝔽`.)
- ToUint32 maps `-0`\ :sub:`𝔽` to `+0`\ :sub:`𝔽`.

ToInt16 ( argument, )
---------------------

description
   It converts argument to one of 2\ :sup:`16` integral Number
   values in the inclusive interval from 𝔽(-2\ :sup:`15`) to
   𝔽(2\ :sup:`15` - 1).

1. Let number be ? ToNumber(argument). 1. If number is not
finite or number is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`,
return `+0`\ :sub:`𝔽`. 1. Let int be truncate(ℝ(number)). 1.
Let int16bit be int modulo 2\ :sup:`16`. 1. If int16bit ≥
2\ :sup:`15`, return 𝔽(int16bit - 2\ :sup:`16`); otherwise return
𝔽(int16bit).

ToUint16 ( argument, )
----------------------

description
   It converts argument to one of 2\ :sup:`16` integral Number
   values in the inclusive interval from `+0`\ :sub:`𝔽` to
   𝔽(2\ :sup:`16` - 1).

1. Let number be ? ToNumber(argument). 1. If number is not
finite or number is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`,
return `+0`\ :sub:`𝔽`. 1. Let int be truncate(ℝ(number)). 1.
[id="step-touint16-mod"] Let int16bit be int modulo
2\ :sup:`16`. 1. Return 𝔽(int16bit).

Given the above definition of ToUint16:

- The substitution of 2\ :sup:`16` for 2\ :sup:`32` in step is the only
  difference between ToUint32 and ToUint16.
- ToUint16 maps `-0`\ :sub:`𝔽` to `+0`\ :sub:`𝔽`.

ToInt8 ( argument, )
--------------------

description
   It converts argument to one of 2\ :sup:`8` integral Number values
   in the inclusive interval from `-128`\ :sub:`𝔽` to
   `127`\ :sub:`𝔽`.

1. Let number be ? ToNumber(argument). 1. If number is not
finite or number is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`,
return `+0`\ :sub:`𝔽`. 1. Let int be truncate(ℝ(number)). 1.
Let int8bit be int modulo 2\ :sup:`8`. 1. If int8bit ≥
2\ :sup:`7`, return 𝔽(int8bit - 2\ :sup:`8`); otherwise return
𝔽(int8bit).

ToUint8 ( argument, )
---------------------

description
   It converts argument to one of 2\ :sup:`8` integral Number values
   in the inclusive interval from `+0`\ :sub:`𝔽` to `255`\ :sub:`𝔽`.

1. Let number be ? ToNumber(argument). 1. If number is not
finite or number is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`,
return `+0`\ :sub:`𝔽`. 1. Let int be truncate(ℝ(number)). 1.
Let int8bit be int modulo 2\ :sup:`8`. 1. Return 𝔽(int8bit).

ToUint8Clamp ( argument, )
--------------------------

description
   It clamps and rounds argument to one of 2\ :sup:`8` integral
   Number values in the inclusive interval from `+0`\ :sub:`𝔽` to
   `255`\ :sub:`𝔽`.

1. Let number be ? ToNumber(argument). 1. If number is
`NaN`, return `+0`\ :sub:`𝔽`. 1. Let mv be the extended
mathematical value of number. 1. Let clamped be the result of
clamping mv between 0 and 255. 1. Let f be floor(clamped).
1. If clamped < f + 0.5, return 𝔽(f). 1. If clamped >
f + 0.5, return 𝔽(f + 1). 1. If f is even, return 𝔽(f).
Otherwise, return 𝔽(f + 1).

Unlike most other ECMAScript integer conversion operations, ToUint8Clamp
rounds rather than truncates non-integral values. It also uses “round
half to even” tie-breaking, which differs from the “round half up”
tie-breaking of `Math.round`.

ToBigInt ( argument, )
----------------------

description
   It converts argument to a BigInt value, or throws if an implicit
   conversion from Number would be required.

1. Let prim be ? ToPrimitive(argument, ~number~). 1. Return the
value that prim corresponds to in .

+---------------+-----------------------------------------------------+
| Argument Type | Result                                              |
+===============+=====================================================+
| Undefined     | Throw a `TypeError` exception.                    |
+---------------+-----------------------------------------------------+
| Null          | Throw a `TypeError` exception.                    |
+---------------+-----------------------------------------------------+
| Boolean       | Return `1n` if prim is `true` and `0n` if |
|               | prim is `false`.                              |
+---------------+-----------------------------------------------------+
| BigInt        | Return prim.                                    |
+---------------+-----------------------------------------------------+
| Number        | Throw a `TypeError` exception.                    |
+---------------+-----------------------------------------------------+
| String        | 1. Let n be StringToBigInt(prim). 1. If     |
|               | n is `undefined`, throw a `SyntaxError`     |
|               | exception. 1. Return n.                         |
+---------------+-----------------------------------------------------+
| Symbol        | Throw a `TypeError` exception.                    |
+---------------+-----------------------------------------------------+

StringToBigInt ( str: a String, ): a BigInt or `undefined`
----------------------------------------------------------------

1. Let literal be ParseText(str, `StringIntegerLiteral`). 1.
If literal is a List of errors, return `undefined`. 1. Let mv
be the MV of literal. 1. Assert: mv is an integer. 1. Return
ℤ(mv).

StringIntegerLiteral Grammar
----------------------------

StringToBigInt uses the following grammar.


**Syntax**


StringIntegerLiteral ::: StrWhiteSpace? StrWhiteSpace? StrIntegerLiteral
StrWhiteSpace? StrIntegerLiteral ::: SignedInteger[~Sep]
NonDecimalIntegerLiteral[~Sep]

Runtime Semantics: MV
---------------------

- The MV of StringIntegerLiteral ::: StrWhiteSpace? is 0.
- The MV of StringIntegerLiteral ::: StrWhiteSpace? StrIntegerLiteral
  StrWhiteSpace? is the MV of `StrIntegerLiteral`.

ToBigInt64 ( argument, )
------------------------

description
   It converts argument to one of 2\ :sup:`64` BigInt values in the
   inclusive interval from ℤ(-2\ :sup:`63`) to ℤ(2\ :sup:`63` - 1).

1. Let n be ? ToBigInt(argument). 1. Let int64bit be
ℝ(n) modulo 2\ :sup:`64`. 1. If int64bit ≥ 2\ :sup:`63`, return
ℤ(int64bit - 2\ :sup:`64`); otherwise return ℤ(int64bit).

ToBigUint64 ( argument, )
-------------------------

description
   It converts argument to one of 2\ :sup:`64` BigInt values in the
   inclusive interval from `0`\ :sub:`ℤ` to ℤ(2\ :sup:`64` - 1).

1. Let n be ? ToBigInt(argument). 1. Let int64bit be
ℝ(n) modulo 2\ :sup:`64`. 1. Return ℤ(int64bit).

ToString ( argument, )
----------------------

description
   It converts argument to a value of type String.

1. If argument is a String, return argument. 1. If argument
is a Symbol, throw a `TypeError` exception. 1. If argument is
`undefined`, return `"undefined"`. 1. If argument is `null`,
return `"null"`. 1. If argument is `true`, return `"true"`. 1.
If argument is `false`, return `"false"`. 1. If argument is
a Number, return Number::toString(argument, 10). 1. If argument
is a BigInt, return BigInt::toString(argument, 10). 1. Assert:
argument is an Object. 1. Let primValue be ?
ToPrimitive(argument, ~string~). 1. Assert: primValue is not an
Object. 1. Return ? ToString(primValue).

ToObject ( argument, )
----------------------

description
   It converts argument to a value of type Object according to :

+---------------+-----------------------------------------------------+
| Argument Type | Result                                              |
+===============+=====================================================+
| Undefined     | Throw a `TypeError` exception.                    |
+---------------+-----------------------------------------------------+
| Null          | Throw a `TypeError` exception.                    |
+---------------+-----------------------------------------------------+
| Boolean       | Return a new Boolean object whose [[BooleanData]]   |
|               | internal slot is set to argument. See for a     |
|               | description of Boolean objects.                     |
+---------------+-----------------------------------------------------+
| Number        | Return a new Number object whose [[NumberData]]     |
|               | internal slot is set to argument. See for a     |
|               | description of Number objects.                      |
+---------------+-----------------------------------------------------+
| String        | Return a new String object whose [[StringData]]     |
|               | internal slot is set to argument. See for a     |
|               | description of String objects.                      |
+---------------+-----------------------------------------------------+
| Symbol        | Return a new Symbol object whose [[SymbolData]]     |
|               | internal slot is set to argument. See for a     |
|               | description of Symbol objects.                      |
+---------------+-----------------------------------------------------+
| BigInt        | Return a new BigInt object whose [[BigIntData]]     |
|               | internal slot is set to argument. See for a     |
|               | description of BigInt objects.                      |
+---------------+-----------------------------------------------------+
| Object        | Return argument.                                |
+---------------+-----------------------------------------------------+

ToPropertyKey ( argument, )
---------------------------

description
   It converts argument to a value that can be used as a property
   key.

1. Let key be ? ToPrimitive(argument, ~string~). 1. If key
is a Symbol, then 1. Return key. 1. Return ! ToString(key).

ToLength ( argument, )
----------------------

description
   It clamps and truncates argument to a non-negative integral
   Number suitable for use as the length of an array-like object.

1. Let len be ? ToIntegerOrInfinity(argument). 1. If len ≤
0, return `+0`\ :sub:`𝔽`. 1. Return 𝔽(min(len, 2\ :sup:`53` - 1)).

CanonicalNumericIndexString ( argument: a String, ): a Number or `undefined`
----------------------------------------------------------------------------------

description
   If argument is either `"-0"` or exactly matches ToString(n)
   for some Number value n, it returns the respective Number value.
   Otherwise, it returns `undefined`.

1. If argument is `"-0"`, return `-0`\ :sub:`𝔽`. 1. Let n be
! ToNumber(argument). 1. If ! ToString(n) is argument,
return n. 1. Return `undefined`.

A canonical numeric string is any String value for which the
CanonicalNumericIndexString abstract operation does not return
`undefined`.

ToIndex ( value, )
------------------

description
   It converts value to an integer and returns that integer if it is
   non-negative and corresponds with an integer index. Otherwise, it
   throws an exception.

1. Let integer be ? ToIntegerOrInfinity(value). 1. If
integer is not in the inclusive interval from 0 to 2\ :sup:`53` - 1,
throw a `RangeError` exception. 1. Return integer.

Testing and Comparison Operations
---------------------------------

RequireObjectCoercible ( argument, )
------------------------------------

description
   It throws an error if argument is a value that cannot be
   converted to an Object using ToObject. It is defined by :

============= ================================
Argument Type Result
============= ================================
Undefined     Throw a `TypeError` exception.
Null          Throw a `TypeError` exception.
Boolean       Return argument.
Number        Return argument.
String        Return argument.
Symbol        Return argument.
BigInt        Return argument.
Object        Return argument.
============= ================================

IsArray ( argument, )
---------------------

1. If argument is not an Object, return `false`. 1. If
argument is an Array exotic object, return `true`. 1. If
argument is a Proxy exotic object, then 1. Perform ?
ValidateNonRevokedProxy(argument). 1. Let proxyTarget be
argument.[[ProxyTarget]]. 1. Return ? IsArray(proxyTarget). 1.
Return `false`.

IsCallable ( argument, ): a Boolean
---------------------------------------------------------------------

description
   It determines if argument is a callable function with a [[Call]]
   internal method.

1. If argument is not an Object, return `false`. 1. If
argument has a [[Call]] internal method, return `true`. 1. Return
`false`.

IsConstructor ( argument, ): a Boolean
------------------------------------------------------------------------

description
   It determines if argument is a function object with a
   [[Construct]] internal method.

1. If argument is not an Object, return `false`. 1. If
argument has a [[Construct]] internal method, return `true`. 1.
Return `false`.

IsExtensible ( O: an Object, )
------------------------------

description
   It is used to determine whether additional properties can be added to
   O.

1. Return ? O.[[IsExtensible]]().

IsRegExp ( argument, )
----------------------

1. If argument is not an Object, return `false`. 1. Let
matcher be ? Get(argument, %Symbol.match%). 1. If matcher is
not `undefined`, return ToBoolean(matcher). 1. If argument has
a [[RegExpMatcher]] internal slot, return `true`. 1. Return `false`.

Static Semantics: IsStringWellFormedUnicode ( string: a String, ): a Boolean
--------------------------------------------------------------------------------

description
   It interprets string as a sequence of UTF-16 encoded code points,
   as described in , and determines whether it is a `well
   formed <http://www.unicode.org/glossary/#well_formed_code_unit_sequence>`__
   UTF-16 sequence.

1. Let len be the length of string. 1. Let k be 0. 1.
Repeat, while k < len, 1. Let cp be CodePointAt(string,
k). 1. If cp.[[IsUnpairedSurrogate]] is `true`, return
`false`. 1. Set k to k + cp.[[CodeUnitCount]]. 1. Return
`true`.

SameType ( x, y, ): a Boolean
-------------------------------------------------------------------------------------------------

description
   It determines whether or not the two arguments are the same type.

1. If x is `undefined` and y is `undefined`, return
`true`. 1. If x is `null` and y is `null`, return
`true`. 1. If x is a Boolean and y is a Boolean, return
`true`. 1. If x is a Number and y is a Number, return
`true`. 1. If x is a BigInt and y is a BigInt, return
`true`. 1. If x is a Symbol and y is a Symbol, return
`true`. 1. If x is a String and y is a String, return
`true`. 1. If x is an Object and y is an Object, return
`true`. 1. Return `false`.

SameValue ( x, y, ): a Boolean
--------------------------------------------------------------------------------------------------

description
   It determines whether or not the two arguments are the same value.

1. If SameType(x, y) is `false`, return `false`. 1. If x
is a Number, then 1. Return Number::sameValue(x, y). 1. Return
SameValueNonNumber(x, y).

This algorithm differs from the IsStrictlyEqual Algorithm by treating
all `NaN` values as equivalent and by differentiating `+0`\ :sub:`𝔽`
from `-0`\ :sub:`𝔽`.

SameValueZero ( x, y, ): a Boolean
------------------------------------------------------------------------------------------------------

description
   It determines whether or not the two arguments are the same value
   (ignoring the difference between `+0`\ :sub:`𝔽` and
   `-0`\ :sub:`𝔽`).

1. If SameType(x, y) is `false`, return `false`. 1. If x
is a Number, then 1. Return Number::sameValueZero(x, y). 1.
Return SameValueNonNumber(x, y).

SameValueZero differs from SameValue only in that it treats
`+0`\ :sub:`𝔽` and `-0`\ :sub:`𝔽` as equivalent.

SameValueNonNumber ( x, but not a Number, y, but not a Number, ): a Boolean
-----------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: SameType(x, y) is `true`. 1. If x is either
`null` or `undefined`, return `true`. 1. If x is a BigInt,
then 1. Return BigInt::equal(x, y). 1. If x is a String,
then 1. If x and y have the same length and the same code units
in the same positions, return `true`; otherwise, return `false`. 1.
If x is a Boolean, then 1. If x and y are both `true` or
both `false`, return `true`; otherwise, return `false`. 1. NOTE:
All other ECMAScript language values are compared by identity. 1. If
x is y, return `true`; otherwise, return `false`. For
expository purposes, some cases are handled separately within this
algorithm even if it is unnecessary to do so. The specifics of what
"x is y" means are detailed in .

IsLessThan ( x, y, LeftFirst: a Boolean, )
------------------------------------------

description
   It provides the semantics for the comparison x < y, returning
   `true`, `false`, or `undefined` (which indicates that at least
   one operand is `NaN`). The LeftFirst flag is used to control
   the order in which operations with potentially visible side-effects
   are performed upon x and y. It is necessary because
   ECMAScript specifies left to right evaluation of expressions. If
   LeftFirst is `true`, the x parameter corresponds to an
   expression that occurs to the left of the y parameter's
   corresponding expression. If LeftFirst is `false`, the reverse
   is the case and operations must be performed upon y before x.

1. If LeftFirst is `true`, then 1. Let px be ?
ToPrimitive(x, ~number~). 1. Let py be ? ToPrimitive(y,
~number~). 1. Else, 1. NOTE: The order of evaluation needs to be
reversed to preserve left to right evaluation. 1. Let py be ?
ToPrimitive(y, ~number~). 1. Let px be ? ToPrimitive(x,
~number~). 1. [id="step-arc-string-check"] If px is a String and
py is a String, then 1. Let lx be the length of px. 1. Let
ly be the length of py. 1. For each integer i such that 0 ≤
i < min(lx, ly), in ascending order, do 1. Let cx be the
numeric value of the code unit at index i within px. 1. Let
cy be the numeric value of the code unit at index i within
py. 1. If cx < cy, return `true`. 1. If cx > cy,
return `false`. 1. If lx < ly, return `true`. Otherwise,
return `false`. 1. Else, 1. If px is a BigInt and py is a
String, then 1. Let ny be StringToBigInt(py). 1. If ny is
`undefined`, return `undefined`. 1. Return BigInt::lessThan(px,
ny). 1. If px is a String and py is a BigInt, then 1. Let
nx be StringToBigInt(px). 1. If nx is `undefined`, return
`undefined`. 1. Return BigInt::lessThan(nx, py). 1. NOTE:
Because px and py are primitive values, evaluation order is not
important. 1. Let nx be ? ToNumeric(px). 1. Let ny be ?
ToNumeric(py). 1. If SameType(nx, ny) is `true`, then 1.
If nx is a Number, then 1. Return Number::lessThan(nx, ny).
1. Else, 1. Assert: nx is a BigInt. 1. Return
BigInt::lessThan(nx, ny). 1. Assert: nx is a BigInt and
ny is a Number, or nx is a Number and ny is a BigInt. 1. If
nx or ny is `NaN`, return `undefined`. 1. If nx is
`-∞`\ :sub:`𝔽` or ny is `+∞`\ :sub:`𝔽`, return `true`. 1. If
nx is `+∞`\ :sub:`𝔽` or ny is `-∞`\ :sub:`𝔽`, return
`false`. 1. If ℝ(nx) < ℝ(ny), return `true`; otherwise
return `false`.

Step differs from step in the algorithm that handles the addition
operator `+` () by using the logical-and operation instead of the
logical-or operation.

The comparison of Strings uses a simple lexicographic ordering on
sequences of UTF-16 code unit values. There is no attempt to use the
more complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode Standard but not in the same normalization form could test as
unequal. Also note that lexicographic ordering by *code unit* differs
from ordering by *code point* for Strings containing surrogate pairs.

IsLooselyEqual ( x, y, )
------------------------

description
   It provides the semantics for the `==` operator.

1. If SameType(x, y) is `true`, then 1. Return
IsStrictlyEqual(x, y). 1. If x is `null` and y is
`undefined`, return `true`. 1. If x is `undefined` and y
is `null`, return `true`. 1.
[id="step-abstract-equality-comparison-web-compat-insertion-point"]
NOTE: This step is replaced in section . 1. If x is a Number and
y is a String, return ! IsLooselyEqual(x, ! ToNumber(y)). 1.
If x is a String and y is a Number, return ! IsLooselyEqual(!
ToNumber(x), y). 1. If x is a BigInt and y is a String,
then 1. Let n be StringToBigInt(y). 1. If n is
`undefined`, return `false`. 1. Return ! IsLooselyEqual(x,
n). 1. If x is a String and y is a BigInt, return !
IsLooselyEqual(y, x). 1. If x is a Boolean, return !
IsLooselyEqual(! ToNumber(x), y). 1. If y is a Boolean,
return ! IsLooselyEqual(x, ! ToNumber(y)). 1. If x is either
a String, a Number, a BigInt, or a Symbol and y is an Object, return
! IsLooselyEqual(x, ? ToPrimitive(y)). 1. If x is an Object
and y is either a String, a Number, a BigInt, or a Symbol, return !
IsLooselyEqual(? ToPrimitive(x), y). 1. If x is a BigInt and
y is a Number, or if x is a Number and y is a BigInt, then
1. If x is not finite or y is not finite, return `false`. 1.
If ℝ(x) = ℝ(y), return `true`; otherwise return `false`. 1.
Return `false`.

IsStrictlyEqual ( x, y, ): a Boolean
--------------------------------------------------------------------------------------------------------

description
   It provides the semantics for the `===` operator.

1. If SameType(x, y) is `false`, return `false`. 1. If x
is a Number, then 1. Return Number::equal(x, y). 1. Return
SameValueNonNumber(x, y).

This algorithm differs from the SameValue Algorithm in its treatment of
signed zeroes and NaNs.

Operations on Objects
---------------------

MakeBasicObject ( internalSlotsList: a List of internal slot names, ): an Object
------------------------------------------------------------------------------------

description
   It is the source of all ECMAScript objects that are created
   algorithmically, including both ordinary objects and exotic objects.
   It factors out common steps used in creating all objects, and
   centralizes object creation.

1. Set internalSlotsList to the list-concatenation of
internalSlotsList and « [[PrivateElements]] ». 1. Let obj be a
newly created object with an internal slot for each name in
internalSlotsList. 1. Set obj.[[PrivateElements]] to a new empty
List. 1. Set obj's essential internal methods to the default
ordinary object definitions specified in . 1. Assert: If the caller will
not be overriding both obj's [[GetPrototypeOf]] and
[[SetPrototypeOf]] essential internal methods, then
internalSlotsList contains [[Prototype]]. 1. Assert: If the caller
will not be overriding all of obj's [[SetPrototypeOf]],
[[IsExtensible]], and [[PreventExtensions]] essential internal methods,
then internalSlotsList contains [[Extensible]]. 1. If
internalSlotsList contains [[Extensible]], set
obj.[[Extensible]] to `true`. 1. Return obj.

Within this specification, exotic objects are created in abstract
operations such as ArrayCreate and BoundFunctionCreate by first calling
MakeBasicObject to obtain a basic, foundational object, and then
overriding some or all of that object's internal methods. In order to
encapsulate exotic object creation, the object's essential internal
methods are never modified outside those operations.

Get ( O: an Object, P: a property key, )
----------------------------------------

description
   It is used to retrieve the value of a specific property of an object.

1. Return ? O.[[Get]](P, O).

GetV ( V, P: a property key, )
------------------------------

description
   It is used to retrieve the value of a specific property of an
   ECMAScript language value. If the value is not an object, the
   property lookup is performed using a wrapper object appropriate for
   the type of the value.

1. Let O be ? ToObject(V). 1. Return ? O.[[Get]](P,
V).

Set ( O: an Object, P: a property key, V, Throw: a Boolean, )
-------------------------------------------------------------

description
   It is used to set the value of a specific property of an object.
   V is the new value for the property.

1. Let success be ? O.[[Set]](P, V, O). 1. If
success is `false` and Throw is `true`, throw a
`TypeError` exception. 1. Return ~unused~.

CreateDataProperty ( O: an Object, P: a property key, V, )
----------------------------------------------------------

description
   It is used to create a new own property of an object.

1. Let newDesc be the PropertyDescriptor { [[Value]]: V,
[[Writable]]: `true`, [[Enumerable]]: `true`, [[Configurable]]:
`true` }. 1. Return ? O.[[DefineOwnProperty]](P, newDesc).

This abstract operation creates a property whose attributes are set to
the same defaults used for properties created by the ECMAScript language
assignment operator. Normally, the property will not already exist. If
it does exist and is not configurable or if O is not extensible,
[[DefineOwnProperty]] will return `false`.

CreateDataPropertyOrThrow ( O: an Object, P: a property key, V, )
-----------------------------------------------------------------

description
   It is used to create a new own property of an object. It throws a
   `TypeError` exception if the requested property update cannot be
   performed.

1. Let success be ? CreateDataProperty(O, P, V). 1. If
success is `false`, throw a `TypeError` exception. 1. Return
~unused~.

This abstract operation creates a property whose attributes are set to
the same defaults used for properties created by the ECMAScript language
assignment operator. Normally, the property will not already exist. If
it does exist and is not configurable or if O is not extensible,
[[DefineOwnProperty]] will return `false` causing this operation to
throw a `TypeError` exception.

CreateNonEnumerableDataPropertyOrThrow ( O: an Object, P: a property key, V, ): ~unused~
----------------------------------------------------------------------------------------------------------------------------------

description
   It is used to create a new non-enumerable own property of an ordinary
   object.

1. Assert: O is an ordinary, extensible object with no
non-configurable properties. 1. Let newDesc be the
PropertyDescriptor { [[Value]]: V, [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }. 1. Perform !
DefinePropertyOrThrow(O, P, newDesc). 1. Return ~unused~.

This abstract operation creates a property whose attributes are set to
the same defaults used for properties created by the ECMAScript language
assignment operator except it is not enumerable. Normally, the property
will not already exist. If it does exist, DefinePropertyOrThrow is
guaranteed to complete normally.

DefinePropertyOrThrow ( O: an Object, P: a property key, desc: a Property Descriptor, )
---------------------------------------------------------------------------------------

description
   It is used to call the [[DefineOwnProperty]] internal method of an
   object in a manner that will throw a `TypeError` exception if the
   requested property update cannot be performed.

1. Let success be ? O.[[DefineOwnProperty]](P, desc). 1.
If success is `false`, throw a `TypeError` exception. 1. Return
~unused~.

DeletePropertyOrThrow ( O: an Object, P: a property key, )
----------------------------------------------------------

description
   It is used to remove a specific own property of an object. It throws
   an exception if the property is not configurable.

1. Let success be ? O.[[Delete]](P). 1. If success is
`false`, throw a `TypeError` exception. 1. Return ~unused~.

GetMethod ( V, P: a property key, )
-----------------------------------

description
   It is used to get the value of a specific property of an ECMAScript
   language value when the value of the property is expected to be a
   function.

1. Let func be ? GetV(V, P). 1. If func is either
`undefined` or `null`, return `undefined`. 1. If
IsCallable(func) is `false`, throw a `TypeError` exception. 1.
Return func.

HasProperty ( O: an Object, P: a property key, )
------------------------------------------------

description
   It is used to determine whether an object has a property with the
   specified property key. The property may be either own or inherited.

1. Return ? O.[[HasProperty]](P).

HasOwnProperty ( O: an Object, P: a property key, )
---------------------------------------------------

description
   It is used to determine whether an object has an own property with
   the specified property key.

1. Let desc be ? O.[[GetOwnProperty]](P). 1. If desc is
`undefined`, return `false`. 1. Return `true`.

Call ( F, V, optional argumentsList: a List of ECMAScript language values, )
----------------------------------------------------------------------------

description
   It is used to call the [[Call]] internal method of a function object.
   F is the function object, V is an ECMAScript language value
   that is the `this` value of the [[Call]], and argumentsList is
   the value passed to the corresponding argument of the internal
   method. If argumentsList is not present, a new empty List is used
   as its value.

1. If argumentsList is not present, set argumentsList to a new
empty List. 1. If IsCallable(F) is `false`, throw a `TypeError`
exception. 1. Return ? F.[[Call]](V, argumentsList).

Construct ( F: a constructor, optional argumentsList: a List of ECMAScript language values, optional newTarget: a constructor, )
--------------------------------------------------------------------------------------------------------------------------------

description
   It is used to call the [[Construct]] internal method of a function
   object. argumentsList and newTarget are the values to be
   passed as the corresponding arguments of the internal method. If
   argumentsList is not present, a new empty List is used as its
   value. If newTarget is not present, F is used as its value.

1. If newTarget is not present, set newTarget to F. 1. If
argumentsList is not present, set argumentsList to a new empty
List. 1. Return ? F.[[Construct]](argumentsList, newTarget).

If newTarget is not present, this operation is equivalent to: `new
F(...argumentsList)`

SetIntegrityLevel ( O: an Object, level: ~sealed~ or ~frozen~, )
----------------------------------------------------------------

description
   It is used to fix the set of own properties of an object.

1. Let status be ? O.[[PreventExtensions]](). 1. If status
is `false`, return `false`. 1. Let keys be ?
O.[[OwnPropertyKeys]](). 1. If level is ~sealed~, then 1. For
each element k of keys, do 1. Perform ?
DefinePropertyOrThrow(O, k, PropertyDescriptor {
[[Configurable]]: `false` }). 1. Else, 1. Assert: level is
~frozen~. 1. For each element k of keys, do 1. Let
currentDesc be ? O.[[GetOwnProperty]](k). 1. If
currentDesc is not `undefined`, then 1. If
IsAccessorDescriptor(currentDesc) is `true`, then 1. Let desc
be the PropertyDescriptor { [[Configurable]]: `false` }. 1. Else, 1.
Let desc be the PropertyDescriptor { [[Configurable]]: `false`,
[[Writable]]: `false` }. 1. Perform ? DefinePropertyOrThrow(O,
k, desc). 1. Return `true`.

TestIntegrityLevel ( O: an Object, level: ~sealed~ or ~frozen~, )
-----------------------------------------------------------------

description
   It is used to determine if the set of own properties of an object are
   fixed.

1. Let extensible be ? IsExtensible(O). 1. If extensible is
`true`, return `false`. 1. NOTE: If the object is extensible, none
of its properties are examined. 1. Let keys be ?
O.[[OwnPropertyKeys]](). 1. For each element k of keys, do
1. Let currentDesc be ? O.[[GetOwnProperty]](k). 1. If
currentDesc is not `undefined`, then 1. If
currentDesc.[[Configurable]] is `true`, return `false`. 1. If
level is ~frozen~ and IsDataDescriptor(currentDesc) is `true`,
then 1. If currentDesc.[[Writable]] is `true`, return `false`.
1. Return `true`.

CreateArrayFromList ( elements: a List of ECMAScript language values, ): an Array
-------------------------------------------------------------------------------------

description
   It is used to create an Array whose elements are provided by
   elements.

1. Let array be ! ArrayCreate(0). 1. Let n be 0. 1. For each
element e of elements, do 1. Perform !
CreateDataPropertyOrThrow(array, ! ToString(𝔽(n)), e). 1.
Set n to n + 1. 1. Return array.

LengthOfArrayLike ( obj: an Object, )
-------------------------------------

description
   It returns the value of the `"length"` property of an array-like
   object.

1. Return ℝ(? ToLength(? Get(obj, `"length"`))).

An array-like object is any object for which this operation returns a
normal completion.

Typically, an array-like object would also have some properties with
integer index names. However, that is not a requirement of this
definition. Arrays and String objects are examples of array-like
objects.

CreateListFromArrayLike ( obj, optional validElementTypes: ~all~ or ~property-key~, )
-------------------------------------------------------------------------------------

description
   It is used to create a List value whose elements are provided by the
   indexed properties of obj. validElementTypes indicates the
   types of values that are allowed as elements.

1. If validElementTypes is not present, set validElementTypes to
~all~. 1. If obj is not an Object, throw a `TypeError` exception.
1. Let len be ? LengthOfArrayLike(obj). 1. Let list be a new
empty List. 1. Let index be 0. 1. Repeat, while index < len,
1. Let indexName be ! ToString(𝔽(index)). 1. Let next be ?
Get(obj, indexName). 1. If validElementTypes is
~property-key~ and next is not a property key, throw a `TypeError`
exception. 1. Append next to list. 1. Set index to index
+ 1. 1. Return list.

Invoke ( V, P: a property key, optional argumentsList: a List of ECMAScript language values, )
----------------------------------------------------------------------------------------------

description
   It is used to call a method property of an ECMAScript language value.
   V serves as both the lookup point for the property and the
   `this` value of the call. argumentsList is the list of
   arguments values passed to the method. If argumentsList is not
   present, a new empty List is used as its value.

1. If argumentsList is not present, set argumentsList to a new
empty List. 1. Let func be ? GetV(V, P). 1. Return ?
Call(func, V, argumentsList).

OrdinaryHasInstance ( C, O, )
-----------------------------

description
   It implements the default algorithm for determining if O inherits
   from the instance object inheritance path provided by C.

1. If IsCallable(C) is `false`, return `false`. 1. If C has
a [[BoundTargetFunction]] internal slot, then 1. Let BC be
C.[[BoundTargetFunction]]. 1. Return ? InstanceofOperator(O,
BC). 1. If O is not an Object, return `false`. 1. Let P be
? Get(C, `"prototype"`). 1. If P is not an Object, throw a
`TypeError` exception. 1. Repeat, 1. Set O to ?
O.[[GetPrototypeOf]](). 1. If O is `null`, return `false`.
1. If SameValue(P, O) is `true`, return `true`.

SpeciesConstructor ( O: an Object, defaultConstructor: a constructor, )
-----------------------------------------------------------------------

description
   It is used to retrieve the constructor that should be used to create
   new objects that are derived from O. defaultConstructor is
   the constructor to use if a constructor %Symbol.species% property
   cannot be found starting from O.

1. Let C be ? Get(O, `"constructor"`). 1. If C is
`undefined`, return defaultConstructor. 1. If C is not an
Object, throw a `TypeError` exception. 1. Let S be ? Get(C,
%Symbol.species%). 1. If S is either `undefined` or `null`,
return defaultConstructor. 1. If IsConstructor(S) is `true`,
return S. 1. Throw a `TypeError` exception.

EnumerableOwnProperties ( O: an Object, kind: ~key~, ~value~, or ~key+value~, )
-------------------------------------------------------------------------------

1. Let ownKeys be ? O.[[OwnPropertyKeys]](). 1. Let results
be a new empty List. 1. For each element key of ownKeys, do 1.
If key is a String, then 1. Let desc be ?
O.[[GetOwnProperty]](key). 1. If desc is not `undefined`
and desc.[[Enumerable]] is `true`, then 1. If kind is ~key~,
then 1. Append key to results. 1. Else, 1. Let value be ?
Get(O, key). 1. If kind is ~value~, then 1. Append value
to results. 1. Else, 1. Assert: kind is ~key+value~. 1. Let
entry be CreateArrayFromList(« key, value »). 1. Append
entry to results. 1. Return results.

GetFunctionRealm ( obj: a function object, )
--------------------------------------------

1. If obj has a [[Realm]] internal slot, then 1. Return
obj.[[Realm]]. 1. If obj is a bound function exotic object, then
1. Let boundTargetFunction be obj.[[BoundTargetFunction]]. 1.
Return ? GetFunctionRealm(boundTargetFunction). 1. If obj is a
Proxy exotic object, then 1. Perform ? ValidateNonRevokedProxy(obj).
1. Let proxyTarget be obj.[[ProxyTarget]]. 1. Return ?
GetFunctionRealm(proxyTarget). 1.
[id="step-getfunctionrealm-default-return"] Return the current Realm
Record.

Step will only be reached if obj is a non-standard function exotic
object that does not have a [[Realm]] internal slot.

CopyDataProperties ( target: an Object, source, excludedItems: a List of property keys, )
-----------------------------------------------------------------------------------------

1. If source is either `undefined` or `null`, return ~unused~.
1. Let from be ! ToObject(source). 1. Let keys be ?
from.[[OwnPropertyKeys]](). 1. For each element nextKey of
keys, do 1. Let excluded be `false`. 1. For each element e
of excludedItems, do 1. If SameValue(e, nextKey) is
`true`, then 1. Set excluded to `true`. 1. If excluded is
`false`, then 1. Let desc be ?
from.[[GetOwnProperty]](nextKey). 1. If desc is not
`undefined` and desc.[[Enumerable]] is `true`, then 1. Let
propValue be ? Get(from, nextKey). 1. Perform !
CreateDataPropertyOrThrow(target, nextKey, propValue). 1.
Return ~unused~.

The target passed in here is always a newly created object which is not
directly accessible in case of an error being thrown.

PrivateElementFind ( O: an Object, P: a Private Name, ): a PrivateElement or ~empty~
--------------------------------------------------------------------------------------------

1. If O.[[PrivateElements]] contains a PrivateElement pe such
that pe.[[Key]] is P, then 1. Return pe. 1. Return ~empty~.

PrivateFieldAdd ( O: an Object, P: a Private Name, value, )
-----------------------------------------------------------

1. If the host is a web browser, then 1. Perform ?
HostEnsureCanAddPrivateElement(O). 1. Let entry be
PrivateElementFind(O, P). 1. If entry is not ~empty~, throw
a `TypeError` exception. 1. Append PrivateElement { [[Key]]: P,
[[Kind]]: ~field~, [[Value]]: value } to O.[[PrivateElements]].
1. Return ~unused~.

PrivateMethodOrAccessorAdd ( O: an Object, method: a PrivateElement, )
----------------------------------------------------------------------

1. Assert: method.[[Kind]] is either ~method~ or ~accessor~. 1. If
the host is a web browser, then 1. Perform ?
HostEnsureCanAddPrivateElement(O). 1. Let entry be
PrivateElementFind(O, method.[[Key]]). 1. If entry is not
~empty~, throw a `TypeError` exception. 1. Append method to
O.[[PrivateElements]]. 1. Return ~unused~.

The values for private methods and accessors are shared across
instances. This operation does not create a new copy of the method or
accessor.

HostEnsureCanAddPrivateElement ( O: an Object, )
------------------------------------------------

description
   It allows host environments to prevent the addition of private
   elements to particular host-defined exotic objects.

An implementation of HostEnsureCanAddPrivateElement must conform to the
following requirements:

- If O is not a host-defined exotic object, this abstract operation
  must return NormalCompletion(~unused~) and perform no other steps.
- Any two calls of this abstract operation with the same argument must
  return the same kind of Completion Record.

The default implementation of HostEnsureCanAddPrivateElement is to
return NormalCompletion(~unused~).

This abstract operation is only invoked by ECMAScript hosts that are web
browsers.

PrivateGet ( O: an Object, P: a Private Name, )
-----------------------------------------------

1. Let entry be PrivateElementFind(O, P). 1. If entry is
~empty~, throw a `TypeError` exception. 1. If entry.[[Kind]] is
either ~field~ or ~method~, then 1. Return entry.[[Value]]. 1.
Assert: entry.[[Kind]] is ~accessor~. 1. If entry.[[Get]] is
`undefined`, throw a `TypeError` exception. 1. Let getter be
entry.[[Get]]. 1. Return ? Call(getter, O).

PrivateSet ( O: an Object, P: a Private Name, value, )
------------------------------------------------------

1. Let entry be PrivateElementFind(O, P). 1. If entry is
~empty~, throw a `TypeError` exception. 1. If entry.[[Kind]] is
~field~, then 1. Set entry.[[Value]] to value. 1. Else if
entry.[[Kind]] is ~method~, then 1. Throw a `TypeError` exception.
1. Else, 1. Assert: entry.[[Kind]] is ~accessor~. 1. If
entry.[[Set]] is `undefined`, throw a `TypeError` exception. 1.
Let setter be entry.[[Set]]. 1. Perform ? Call(setter,
O, « value »). 1. Return ~unused~.

DefineField ( receiver: an Object, fieldRecord: a ClassFieldDefinition Record, )
--------------------------------------------------------------------------------

1. Let fieldName be fieldRecord.[[Name]]. 1. Let initializer
be fieldRecord.[[Initializer]]. 1. If initializer is not
~empty~, then 1. Let initValue be ? Call(initializer,
receiver). 1. Else, 1. Let initValue be `undefined`. 1. If
fieldName is a Private Name, then 1. Perform ?
PrivateFieldAdd(receiver, fieldName, initValue). 1. Else, 1.
Assert: fieldName is a property key. 1. Perform ?
CreateDataPropertyOrThrow(receiver, fieldName, initValue).
1. Return ~unused~.

InitializeInstanceElements ( O: an Object, constructor: an ECMAScript function object, )
----------------------------------------------------------------------------------------

1. Let methods be the value of constructor.[[PrivateMethods]].
1. For each PrivateElement method of methods, do 1. Perform ?
PrivateMethodOrAccessorAdd(O, method). 1. Let fields be the
value of constructor.[[Fields]]. 1. For each element fieldRecord
of fields, do 1. Perform ? DefineField(O, fieldRecord). 1.
Return ~unused~.

AddValueToKeyedGroup ( groups: a List of Records with fields [[Key]] (an ECMAScript language value) and [[Elements]] (a List of ECMAScript language values), key, value, ): ~unused~
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. For each Record { [[Key]], [[Elements]] } g of groups, do 1.
If SameValue(g.[[Key]], key) is `true`, then 1. Assert:
Exactly one element of groups meets this criterion. 1. Append
value to g.[[Elements]]. 1. Return ~unused~. 1. Let group be
the Record { [[Key]]: key, [[Elements]]: « value » }. 1. Append
group to groups. 1. Return ~unused~.

GroupBy ( items, callback, keyCoercion: ~property~ or ~collection~, )
---------------------------------------------------------------------

1. Perform ? RequireObjectCoercible(items). 1. If
IsCallable(callback) is `false`, throw a `TypeError` exception.
1. Let groups be a new empty List. 1. Let iteratorRecord be ?
GetIterator(items, ~sync~). 1. Let k be 0. 1. Repeat, 1. If
k ≥ 2\ :sup:`53` - 1, then 1. Let error be ThrowCompletion(a
newly created `TypeError` object). 1. Return ?
IteratorClose(iteratorRecord, error). 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is ~done~, then 1.
Return groups. 1. Let value be next. 1. Let key be
Completion(Call(callback, `undefined`, « value, 𝔽(k) »)).
1. IfAbruptCloseIterator(key, iteratorRecord). 1. If
keyCoercion is ~property~, then 1. Set key to
Completion(ToPropertyKey(key)). 1. IfAbruptCloseIterator(key,
iteratorRecord). 1. Else, 1. Assert: keyCoercion is
~collection~. 1. Set key to CanonicalizeKeyedCollectionKey(key).
1. Perform AddValueToKeyedGroup(groups, key, value). 1. Set
k to k + 1.

SetterThatIgnoresPrototypeProperties ( thisValue, home: an Object, p: a property key, v, )
------------------------------------------------------------------------------------------

1. If thisValue is not an Object, then 1. Throw a `TypeError`
exception. 1. If SameValue(thisValue, home) is `true`, then 1.
NOTE: Throwing here emulates assignment to a non-writable data property
on the home object in strict mode code. 1. Throw a `TypeError`
exception. 1. Let desc be ? thisValue.[[GetOwnProperty]](p).
1. If desc is `undefined`, then 1. Perform ?
CreateDataPropertyOrThrow(thisValue, p, v). 1. Else, 1.
Perform ? Set(thisValue, p, v, `true`). 1. Return
~unused~.

Operations on Iterator Objects
------------------------------

See Common Iteration Interfaces ().

Iterator Records
----------------

An Iterator Record is a Record value used to encapsulate an iterator or
async iterator along with the `next` method.

Iterator Records have the fields listed in .

+----------------+-------------------------+-------------------------+
| Field Name     | Value                   | Meaning                 |
+================+=========================+=========================+
| [[Iterator]]   | an Object               | An object that conforms |
|                |                         | to the iterator         |
|                |                         | interface or the async  |
|                |                         | iterator interface.     |
+----------------+-------------------------+-------------------------+
| [[NextMethod]] | an ECMAScript language  | The `next` method of  |
|                | value                   | the [[Iterator]]        |
|                |                         | object.                 |
+----------------+-------------------------+-------------------------+
| [[Done]]       | a Boolean               | Whether the iterator    |
|                |                         | has completed or been   |
|                |                         | closed.                 |
+----------------+-------------------------+-------------------------+

GetIteratorDirect ( obj: an Object, )
-------------------------------------

1. Let nextMethod be ? Get(obj, `"next"`). 1. Let
iteratorRecord be the Iterator Record { [[Iterator]]: obj,
[[NextMethod]]: nextMethod, [[Done]]: `false` }. 1. Return
iteratorRecord.

GetIteratorFromMethod ( obj, method: a function object, )
---------------------------------------------------------

1. Let iterator be ? Call(method, obj). 1. If iterator
is not an Object, throw a `TypeError` exception. 1. Return ?
GetIteratorDirect(iterator).

GetIterator ( obj, kind: ~sync~ or ~async~, )
---------------------------------------------

1. If kind is ~async~, then 1. Let method be ?
GetMethod(obj, %Symbol.asyncIterator%). 1. If method is
`undefined`, then 1. Let syncMethod be ? GetMethod(obj,
%Symbol.iterator%). 1. If syncMethod is `undefined`, throw a
`TypeError` exception. 1. Let syncIteratorRecord be ?
GetIteratorFromMethod(obj, syncMethod). 1. Return
CreateAsyncFromSyncIterator(syncIteratorRecord). 1. Else, 1. Let
method be ? GetMethod(obj, %Symbol.iterator%). 1. If method
is `undefined`, throw a `TypeError` exception. 1. Return ?
GetIteratorFromMethod(obj, method).

GetIteratorFlattenable ( obj, primitiveHandling: ~iterate-string-primitives~ or ~reject-primitives~, )
------------------------------------------------------------------------------------------------------

1. If obj is not an Object, then 1. If primitiveHandling is
~reject-primitives~, throw a `TypeError` exception. 1. Assert:
primitiveHandling is ~iterate-string-primitives~. 1. If obj is
not a String, throw a `TypeError` exception. 1. Let method be ?
GetMethod(obj, %Symbol.iterator%). 1. If method is
`undefined`, then 1. Let iterator be obj. 1. Else, 1. Let
iterator be ? Call(method, obj). 1. If iterator is not
an Object, throw a `TypeError` exception. 1. Return ?
GetIteratorDirect(iterator).

IteratorNext ( iteratorRecord: an Iterator Record, optional value, )
--------------------------------------------------------------------

1. If value is not present, then 1. Let result be
Completion(Call(iteratorRecord.[[NextMethod]],
iteratorRecord.[[Iterator]])). 1. Else, 1. Let result be
Completion(Call(iteratorRecord.[[NextMethod]],
iteratorRecord.[[Iterator]], « value »)). 1. If result is a
throw completion, then 1. Set iteratorRecord.[[Done]] to `true`.
1. Return ? result. 1. Set result to ! result. 1. If
result is not an Object, then 1. Set iteratorRecord.[[Done]] to
`true`. 1. Throw a `TypeError` exception. 1. Return result.

IteratorComplete ( iteratorResult: an Object, )
-----------------------------------------------

1. Return ToBoolean(? Get(iteratorResult, `"done"`)).

IteratorValue ( iteratorResult: an Object, )
--------------------------------------------

1. Return ? Get(iteratorResult, `"value"`).

IteratorStep ( iteratorRecord: an Iterator Record, )
----------------------------------------------------

description
   It requests the next value from iteratorRecord.[[Iterator]] by
   calling iteratorRecord.[[NextMethod]] and returns either ~done~
   indicating that the iterator has reached its end or the
   IteratorResult object if a next value is available.

1. Let result be ? IteratorNext(iteratorRecord). 1. Let done
be Completion(IteratorComplete(result)). 1. If done is a throw
completion, then 1. Set iteratorRecord.[[Done]] to `true`. 1.
Return ? done. 1. Set done to ! done. 1. If done is
`true`, then 1. Set iteratorRecord.[[Done]] to `true`. 1. Return
~done~. 1. Return result.

IteratorStepValue ( iteratorRecord: an Iterator Record, )
---------------------------------------------------------

description
   It requests the next value from iteratorRecord.[[Iterator]] by
   calling iteratorRecord.[[NextMethod]] and returns either ~done~
   indicating that the iterator has reached its end or the value from
   the IteratorResult object if a next value is available.

1. Let result be ? IteratorStep(iteratorRecord). 1. If
result is ~done~, then 1. Return ~done~. 1. Let value be
Completion(IteratorValue(result)). 1. If value is a throw
completion, then 1. Set iteratorRecord.[[Done]] to `true`. 1.
Return ? value.

IteratorClose ( iteratorRecord: an Iterator Record, completion: a Completion Record, ): a Completion Record
-------------------------------------------------------------------------------------------------------------------

description
   It is used to notify an iterator that it should perform any actions
   it would normally perform when it has reached its completed state.

1. Assert: iteratorRecord.[[Iterator]] is an Object. 1. Let
iterator be iteratorRecord.[[Iterator]]. 1. Let innerResult
be Completion(GetMethod(iterator, `"return"`)). 1. If
innerResult is a normal completion, then 1. Let return be
innerResult.[[Value]]. 1. If return is `undefined`, return ?
completion. 1. Set innerResult to Completion(Call(return,
iterator)). 1. If completion is a throw completion, return ?
completion. 1. If innerResult is a throw completion, return ?
innerResult. 1. If innerResult.[[Value]] is not an Object, throw
a `TypeError` exception. 1. Return ? completion.

IfAbruptCloseIterator ( value, iteratorRecord )
-------------------------------------------------------

IfAbruptCloseIterator is a shorthand for a sequence of algorithm steps
that use an Iterator Record. An algorithm step of the form:

1. IfAbruptCloseIterator(value, iteratorRecord).

means the same thing as:

1. Assert: value is a Completion Record. 1. If value is an
abrupt completion, return ? IteratorClose(iteratorRecord,
value). 1. Else, set value to ! value.

AsyncIteratorClose ( iteratorRecord: an Iterator Record, completion: a Completion Record, ): a Completion Record
------------------------------------------------------------------------------------------------------------------------

description
   It is used to notify an async iterator that it should perform any
   actions it would normally perform when it has reached its completed
   state.

1. Assert: iteratorRecord.[[Iterator]] is an Object. 1. Let
iterator be iteratorRecord.[[Iterator]]. 1. Let innerResult
be Completion(GetMethod(iterator, `"return"`)). 1. If
innerResult is a normal completion, then 1. Let return be
innerResult.[[Value]]. 1. If return is `undefined`, return ?
completion. 1. Set innerResult to Completion(Call(return,
iterator)). 1. If innerResult is a normal completion, set
innerResult to Completion(Await(innerResult.[[Value]])). 1. If
completion is a throw completion, return ? completion. 1. If
innerResult is a throw completion, return ? innerResult. 1. If
innerResult.[[Value]] is not an Object, throw a `TypeError`
exception. 1. Return ? completion.

CreateIteratorResultObject ( value, done: a Boolean, ): an Object that conforms to the IteratorResult interface
-----------------------------------------------------------------------------------------------------------------------------------------------------

description
   It creates an object that conforms to the IteratorResult interface.

1. Let obj be OrdinaryObjectCreate(%Object.prototype%). 1. Perform !
CreateDataPropertyOrThrow(obj, `"value"`, value). 1. Perform !
CreateDataPropertyOrThrow(obj, `"done"`, done). 1. Return
obj.

CreateListIteratorRecord ( list: a List of ECMAScript language values, ): an Iterator Record
------------------------------------------------------------------------------------------------

description
   It creates an Iterator Record whose [[NextMethod]] returns the
   successive elements of list.

1. Let closure be a new Abstract Closure with no parameters that
captures list and performs the following steps when called: 1. For
each element E of list, do 1. Perform ?
GeneratorYield(CreateIteratorResultObject(E, `false`)). 1. Return
NormalCompletion(`undefined`). 1. Let iterator be
CreateIteratorFromClosure(closure, ~empty~, %Iterator.prototype%).
1. Return the Iterator Record { [[Iterator]]: iterator,
[[NextMethod]]: %GeneratorPrototype.next%, [[Done]]: `false` }.

The list iterator object is never directly accessible to ECMAScript
code.

IteratorToList ( iteratorRecord: an Iterator Record, )
------------------------------------------------------

1. Let values be a new empty List. 1. Repeat, 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is ~done~, then 1.
Return values. 1. Append next to values.


8. Syntax-Directed Operations
=============================

https://tc39.es/ecma262/multipage/syntax-directed-operations.html
::

   8.1 RS: Evaluation
   8.2 Scope Analysis
      8.2.1 SS: BoundNames
      8.2.2 SS: DeclarationPart
      8.2.3 SS: IsConstantDeclaration
      8.2.4 SS: LexicallyDeclaredNames
      8.2.5 SS: LexicallyScopedDeclarations
      8.2.6 SS: VarDeclaredNames
      8.2.7 SS: VarScopedDeclarations
      8.2.8 SS: TopLevelLexicallyDeclaredNames
      8.2.9 SS: TopLevelLexicallyScopedDeclarations
      8.2.10 SS: TopLevelVarDeclaredNames
      8.2.11 SS: TopLevelVarScopedDeclarations
   8.3 Labels
      8.3.1 SS: ContainsDuplicateLabels
      8.3.2 SS: ContainsUndefinedBreakTarget
      8.3.3 SS: ContainsUndefinedContinueTarget
      8.4 Function Name Inference
      8.4.1 SS: HasName
      8.4.2 SS: IsFunctionDefinition
      8.4.3 SS: IsAnonymousFunctionDefinition ( expr )
      8.4.4 SS: IsIdentifierRef
      8.4.5 RS: NamedEvaluation
   8.5 Contains
      8.5.1 SS: Contains
      8.5.2 SS: ComputedPropertyContains
   8.6 Miscellaneous
      8.6.1 RS: InstantiateFunctionObject
      8.6.2 RS: BindingInitialization
      8.6.2.1 InitializeBoundName ( name, value, environment )
      8.6.3 RS: IteratorBindingInitialization
      8.6.4 SS: AssignmentTargetType
      8.6.5 SS: PropName

In addition to those defined in this section, specialized
syntax-directed operations are defined throughout this specification.

Runtime Semantics: Evaluation ( ): a Completion Record
------------------------------------------------------

effects
   user-code

The definitions for this operation are distributed over the "ECMAScript
Language" sections of this specification. Each definition appears after
the defining occurrence of the relevant productions.

Scope Analysis
--------------

Static Semantics: BoundNames ( ): a List of Strings
---------------------------------------------------

`"\`default\\`"` is used within this specification as a synthetic
name for a module's default export when it does not have another name.
An entry in the module's [[Environment]] is created with that name and
holds the corresponding value, and resolving the export named
`"default"` by calling for the module will return a ResolvedBinding
Record whose [[BindingName]] is `"\`default\\`"`, which will then
resolve in the module's [[Environment]] to the above-mentioned value.
This is done only for ease of specification, so that anonymous default
exports can be resolved like any other export. This `"\`default\\`"`
string is never accessible to ECMAScript code or to the module linking
algorithm.

BindingIdentifier : Identifier 1. Return a List whose sole element is
the StringValue of `Identifier`. BindingIdentifier : `yield` 1.
Return « `"yield"` ». BindingIdentifier : `await` 1. Return «
`"await"` ». LexicalDeclaration : LetOrConst BindingList `;` 1.
Return the BoundNames of `BindingList`. BindingList : BindingList
`,` LexicalBinding 1. Let names1 be the BoundNames of
`BindingList`. 1. Let names2 be the BoundNames of
`LexicalBinding`. 1. Return the list-concatenation of names1 and
names2. LexicalBinding : BindingIdentifier Initializer? 1. Return
the BoundNames of `BindingIdentifier`. LexicalBinding : BindingPattern
Initializer 1. Return the BoundNames of `BindingPattern`.
VariableDeclarationList : VariableDeclarationList `,`
VariableDeclaration 1. Let names1 be the BoundNames of
`VariableDeclarationList`. 1. Let names2 be the BoundNames of
`VariableDeclaration`. 1. Return the list-concatenation of names1
and names2. VariableDeclaration : BindingIdentifier Initializer? 1.
Return the BoundNames of `BindingIdentifier`. VariableDeclaration :
BindingPattern Initializer 1. Return the BoundNames of
`BindingPattern`. ObjectBindingPattern : `{` `}` 1. Return a new
empty List. ObjectBindingPattern : `{` BindingPropertyList `,`
BindingRestProperty `}` 1. Let names1 be the BoundNames of
`BindingPropertyList`. 1. Let names2 be the BoundNames of
`BindingRestProperty`. 1. Return the list-concatenation of names1
and names2. ArrayBindingPattern : `[` Elision? `]` 1. Return a
new empty List. ArrayBindingPattern : `[` Elision? BindingRestElement
`]` 1. Return the BoundNames of `BindingRestElement`.
ArrayBindingPattern : `[` BindingElementList `,` Elision? `]` 1.
Return the BoundNames of `BindingElementList`. ArrayBindingPattern :
`[` BindingElementList `,` Elision? BindingRestElement `]` 1. Let
names1 be the BoundNames of `BindingElementList`. 1. Let
names2 be the BoundNames of `BindingRestElement`. 1. Return the
list-concatenation of names1 and names2. BindingPropertyList :
BindingPropertyList `,` BindingProperty 1. Let names1 be the
BoundNames of `BindingPropertyList`. 1. Let names2 be the
BoundNames of `BindingProperty`. 1. Return the list-concatenation of
names1 and names2. BindingElementList : BindingElementList `,`
BindingElisionElement 1. Let names1 be the BoundNames of
`BindingElementList`. 1. Let names2 be the BoundNames of
`BindingElisionElement`. 1. Return the list-concatenation of
names1 and names2. BindingElisionElement : Elision?
BindingElement 1. Return the BoundNames of `BindingElement`.
BindingProperty : PropertyName `:` BindingElement 1. Return the
BoundNames of `BindingElement`. SingleNameBinding : BindingIdentifier
Initializer? 1. Return the BoundNames of `BindingIdentifier`.
BindingElement : BindingPattern Initializer? 1. Return the BoundNames of
`BindingPattern`. ForDeclaration : LetOrConst ForBinding 1. Return the
BoundNames of `ForBinding`. FunctionDeclaration : `function`
BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
1. Return the BoundNames of `BindingIdentifier`. FunctionDeclaration :
`function` `(` FormalParameters `)` `{` FunctionBody `}` 1.
Return « `"\`default\\`"` ». FormalParameters : [empty] 1. Return a
new empty List. FormalParameters : FormalParameterList `,`
FunctionRestParameter 1. Let names1 be the BoundNames of
`FormalParameterList`. 1. Let names2 be the BoundNames of
`FunctionRestParameter`. 1. Return the list-concatenation of
names1 and names2. FormalParameterList : FormalParameterList
`,` FormalParameter 1. Let names1 be the BoundNames of
`FormalParameterList`. 1. Let names2 be the BoundNames of
`FormalParameter`. 1. Return the list-concatenation of names1 and
names2. ArrowParameters :
CoverParenthesizedExpressionAndArrowParameterList 1. Let formals be
the `ArrowFormalParameters` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return the
BoundNames of formals. GeneratorDeclaration : `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
1. Return the BoundNames of `BindingIdentifier`. GeneratorDeclaration
: `function` `*` `(` FormalParameters `)` `{` GeneratorBody
`}` 1. Return « `"\`default\\`"` ». AsyncGeneratorDeclaration :
`async` `function` `*` BindingIdentifier `(` FormalParameters
`)` `{` AsyncGeneratorBody `}` 1. Return the BoundNames of
`BindingIdentifier`. AsyncGeneratorDeclaration : `async`
`function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` 1. Return « `"\`default\\`"` ». ClassDeclaration : `class`
BindingIdentifier ClassTail 1. Return the BoundNames of
`BindingIdentifier`. ClassDeclaration : `class` ClassTail 1. Return
« `"\`default\\`"` ». AsyncFunctionDeclaration : `async`
`function` BindingIdentifier `(` FormalParameters `)` `{`
AsyncFunctionBody `}` 1. Return the BoundNames of
`BindingIdentifier`. AsyncFunctionDeclaration : `async` `function`
`(` FormalParameters `)` `{` AsyncFunctionBody `}` 1. Return «
`"\`default\\`"` ». CoverCallExpressionAndAsyncArrowHead :
MemberExpression Arguments 1. Let head be the `AsyncArrowHead`
that is covered by `CoverCallExpressionAndAsyncArrowHead`. 1. Return
the BoundNames of head. ImportDeclaration : `import` ImportClause
FromClause `;` 1. Return the BoundNames of `ImportClause`.
ImportDeclaration : `import` ModuleSpecifier `;` 1. Return a new
empty List. ImportClause : ImportedDefaultBinding `,` NameSpaceImport
1. Let names1 be the BoundNames of `ImportedDefaultBinding`. 1.
Let names2 be the BoundNames of `NameSpaceImport`. 1. Return the
list-concatenation of names1 and names2. ImportClause :
ImportedDefaultBinding `,` NamedImports 1. Let names1 be the
BoundNames of `ImportedDefaultBinding`. 1. Let names2 be the
BoundNames of `NamedImports`. 1. Return the list-concatenation of
names1 and names2. NamedImports : `{` `}` 1. Return a new
empty List. ImportsList : ImportsList `,` ImportSpecifier 1. Let
names1 be the BoundNames of `ImportsList`. 1. Let names2 be
the BoundNames of `ImportSpecifier`. 1. Return the list-concatenation
of names1 and names2. ImportSpecifier : ModuleExportName `as`
ImportedBinding 1. Return the BoundNames of `ImportedBinding`.
ExportDeclaration : `export` ExportFromClause FromClause `;`
`export` NamedExports `;` 1. Return a new empty List.
ExportDeclaration : `export` VariableStatement 1. Return the
BoundNames of `VariableStatement`. ExportDeclaration : `export`
Declaration 1. Return the BoundNames of `Declaration`.
ExportDeclaration : `export` `default` HoistableDeclaration 1. Let
declarationNames be the BoundNames of `HoistableDeclaration`. 1.
If declarationNames does not include the element
`"\`default\\`"`, append `"\`default\\`"` to
declarationNames. 1. Return declarationNames. ExportDeclaration
: `export` `default` ClassDeclaration 1. Let declarationNames be
the BoundNames of `ClassDeclaration`. 1. If declarationNames does
not include the element `"\`default\\`"`, append
`"\`default\\`"` to declarationNames. 1. Return
declarationNames. ExportDeclaration : `export` `default`
AssignmentExpression `;` 1. Return « `"\`default\\`"` ».

Static Semantics: DeclarationPart ( ): a Parse Node
---------------------------------------------------

HoistableDeclaration : FunctionDeclaration 1. Return
`FunctionDeclaration`. HoistableDeclaration : GeneratorDeclaration 1.
Return `GeneratorDeclaration`. HoistableDeclaration :
AsyncFunctionDeclaration 1. Return `AsyncFunctionDeclaration`.
HoistableDeclaration : AsyncGeneratorDeclaration 1. Return
`AsyncGeneratorDeclaration`. Declaration : ClassDeclaration 1. Return
`ClassDeclaration`. Declaration : LexicalDeclaration 1. Return
`LexicalDeclaration`.

Static Semantics: IsConstantDeclaration ( ): a Boolean
------------------------------------------------------

LexicalDeclaration : LetOrConst BindingList `;` 1. Return
IsConstantDeclaration of `LetOrConst`. LetOrConst : `let` 1. Return
`false`. LetOrConst : `const` 1. Return `true`.
FunctionDeclaration : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` `function` `(`
FormalParameters `)` `{` FunctionBody `}` GeneratorDeclaration :
`function` `*` BindingIdentifier `(` FormalParameters `)` `{`
GeneratorBody `}` `function` `*` `(` FormalParameters `)`
`{` GeneratorBody `}` AsyncGeneratorDeclaration : `async`
`function` `*` BindingIdentifier `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` `async` `function` `*` `(`
FormalParameters `)` `{` AsyncGeneratorBody `}`
AsyncFunctionDeclaration : `async` `function` BindingIdentifier
`(` FormalParameters `)` `{` AsyncFunctionBody `}` `async`
`function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
1. Return `false`. ClassDeclaration : `class` BindingIdentifier
ClassTail `class` ClassTail 1. Return `false`. ExportDeclaration :
`export` ExportFromClause FromClause `;` `export` NamedExports
`;` `export` `default` AssignmentExpression `;` 1. Return
`false`.

It is not necessary to treat `export default` `AssignmentExpression`
as a constant declaration because there is no syntax that permits
assignment to the internal bound name used to reference a module's
default object.

Static Semantics: LexicallyDeclaredNames ( ): a List of Strings
---------------------------------------------------------------

Block : `{` `}` 1. Return a new empty List. StatementList :
StatementList StatementListItem 1. Let names1 be the
LexicallyDeclaredNames of `StatementList`. 1. Let names2 be the
LexicallyDeclaredNames of `StatementListItem`. 1. Return the
list-concatenation of names1 and names2. StatementListItem :
Statement 1. If `Statement` is Statement : LabelledStatement, return
the LexicallyDeclaredNames of `LabelledStatement`. 1. Return a new
empty List. StatementListItem : Declaration 1. Return the BoundNames of
`Declaration`. CaseBlock : `{` `}` 1. Return a new empty List.
CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}` 1. If
the first `CaseClauses` is present, let names1 be the
LexicallyDeclaredNames of the first `CaseClauses`. 1. Else, let
names1 be a new empty List. 1. Let names2 be the
LexicallyDeclaredNames of `DefaultClause`. 1. If the second
`CaseClauses` is present, let names3 be the LexicallyDeclaredNames
of the second `CaseClauses`. 1. Else, let names3 be a new empty
List. 1. Return the list-concatenation of names1, names2, and
names3. CaseClauses : CaseClauses CaseClause 1. Let names1 be
the LexicallyDeclaredNames of `CaseClauses`. 1. Let names2 be the
LexicallyDeclaredNames of `CaseClause`. 1. Return the
list-concatenation of names1 and names2. CaseClause : `case`
Expression `:` StatementList? 1. If the `StatementList` is present,
return the LexicallyDeclaredNames of `StatementList`. 1. Return a new
empty List. DefaultClause : `default` `:` StatementList? 1. If the
`StatementList` is present, return the LexicallyDeclaredNames of
`StatementList`. 1. Return a new empty List. LabelledStatement :
LabelIdentifier `:` LabelledItem 1. Return the LexicallyDeclaredNames
of `LabelledItem`. LabelledItem : Statement 1. Return a new empty
List. LabelledItem : FunctionDeclaration 1. Return the BoundNames of
`FunctionDeclaration`. FunctionStatementList : [empty] 1. Return a new
empty List. FunctionStatementList : StatementList 1. Return the
TopLevelLexicallyDeclaredNames of `StatementList`.
ClassStaticBlockStatementList : [empty] 1. Return a new empty List.
ClassStaticBlockStatementList : StatementList 1. Return the
TopLevelLexicallyDeclaredNames of `StatementList`. ConciseBody :
ExpressionBody 1. Return a new empty List. AsyncConciseBody :
ExpressionBody 1. Return a new empty List. Script : [empty] 1. Return a
new empty List. ScriptBody : StatementList 1. Return the
TopLevelLexicallyDeclaredNames of `StatementList`.

At the top level of a `Script`, function declarations are treated like
var declarations rather than like lexical declarations.

The LexicallyDeclaredNames of a `Module` includes the names of all of
its imported bindings.

ModuleItemList : ModuleItemList ModuleItem 1. Let names1 be the
LexicallyDeclaredNames of `ModuleItemList`. 1. Let names2 be the
LexicallyDeclaredNames of `ModuleItem`. 1. Return the
list-concatenation of names1 and names2. ModuleItem :
ImportDeclaration 1. Return the BoundNames of `ImportDeclaration`.
ModuleItem : ExportDeclaration 1. If `ExportDeclaration` is `export`
`VariableStatement`, return a new empty List. 1. Return the BoundNames
of `ExportDeclaration`. ModuleItem : StatementListItem 1. Return the
LexicallyDeclaredNames of `StatementListItem`.

At the top level of a `Module`, function declarations are treated like
lexical declarations rather than like var declarations.

Static Semantics: LexicallyScopedDeclarations ( ): a List of Parse Nodes
------------------------------------------------------------------------

StatementList : StatementList StatementListItem 1. Let declarations1
be the LexicallyScopedDeclarations of `StatementList`. 1. Let
declarations2 be the LexicallyScopedDeclarations of
`StatementListItem`. 1. Return the list-concatenation of
declarations1 and declarations2. StatementListItem : Statement
1. If `Statement` is Statement : LabelledStatement, return the
LexicallyScopedDeclarations of `LabelledStatement`. 1. Return a new
empty List. StatementListItem : Declaration 1. Return a List whose sole
element is the DeclarationPart of `Declaration`. CaseBlock : `{`
`}` 1. Return a new empty List. CaseBlock : `{` CaseClauses?
DefaultClause CaseClauses? `}` 1. If the first `CaseClauses` is
present, let declarations1 be the LexicallyScopedDeclarations of the
first `CaseClauses`. 1. Else, let declarations1 be a new empty
List. 1. Let declarations2 be the LexicallyScopedDeclarations of
`DefaultClause`. 1. If the second `CaseClauses` is present, let
declarations3 be the LexicallyScopedDeclarations of the second
`CaseClauses`. 1. Else, let declarations3 be a new empty List. 1.
Return the list-concatenation of declarations1, declarations2,
and declarations3. CaseClauses : CaseClauses CaseClause 1. Let
declarations1 be the LexicallyScopedDeclarations of `CaseClauses`.
1. Let declarations2 be the LexicallyScopedDeclarations of
`CaseClause`. 1. Return the list-concatenation of declarations1
and declarations2. CaseClause : `case` Expression `:`
StatementList? 1. If the `StatementList` is present, return the
LexicallyScopedDeclarations of `StatementList`. 1. Return a new empty
List. DefaultClause : `default` `:` StatementList? 1. If the
`StatementList` is present, return the LexicallyScopedDeclarations of
`StatementList`. 1. Return a new empty List. LabelledStatement :
LabelIdentifier `:` LabelledItem 1. Return the
LexicallyScopedDeclarations of `LabelledItem`. LabelledItem :
Statement 1. Return a new empty List. LabelledItem : FunctionDeclaration
1. Return « `FunctionDeclaration` ». FunctionStatementList : [empty]
1. Return a new empty List. FunctionStatementList : StatementList 1.
Return the TopLevelLexicallyScopedDeclarations of `StatementList`.
ClassStaticBlockStatementList : [empty] 1. Return a new empty List.
ClassStaticBlockStatementList : StatementList 1. Return the
TopLevelLexicallyScopedDeclarations of `StatementList`. ConciseBody :
ExpressionBody 1. Return a new empty List. AsyncConciseBody :
ExpressionBody 1. Return a new empty List. Script : [empty] 1. Return a
new empty List. ScriptBody : StatementList 1. Return the
TopLevelLexicallyScopedDeclarations of `StatementList`. Module :
[empty] 1. Return a new empty List. ModuleItemList : ModuleItemList
ModuleItem 1. Let declarations1 be the LexicallyScopedDeclarations
of `ModuleItemList`. 1. Let declarations2 be the
LexicallyScopedDeclarations of `ModuleItem`. 1. Return the
list-concatenation of declarations1 and declarations2.
ModuleItem : ImportDeclaration 1. Return a new empty List.
ExportDeclaration : `export` ExportFromClause FromClause `;`
`export` NamedExports `;` `export` VariableStatement 1. Return a
new empty List. ExportDeclaration : `export` Declaration 1. Return a
List whose sole element is the DeclarationPart of `Declaration`.
ExportDeclaration : `export` `default` HoistableDeclaration 1.
Return a List whose sole element is the DeclarationPart of
`HoistableDeclaration`. ExportDeclaration : `export` `default`
ClassDeclaration 1. Return a List whose sole element is
`ClassDeclaration`. ExportDeclaration : `export` `default`
AssignmentExpression `;` 1. Return a List whose sole element is this
`ExportDeclaration`.

Static Semantics: VarDeclaredNames ( ): a List of Strings
---------------------------------------------------------

Statement : EmptyStatement ExpressionStatement ContinueStatement
BreakStatement ReturnStatement ThrowStatement DebuggerStatement 1.
Return a new empty List. Block : `{` `}` 1. Return a new empty List.
StatementList : StatementList StatementListItem 1. Let names1 be the
VarDeclaredNames of `StatementList`. 1. Let names2 be the
VarDeclaredNames of `StatementListItem`. 1. Return the
list-concatenation of names1 and names2. StatementListItem :
Declaration 1. Return a new empty List. VariableStatement : `var`
VariableDeclarationList `;` 1. Return the BoundNames of
`VariableDeclarationList`. IfStatement : `if` `(` Expression `)`
Statement `else` Statement 1. Let names1 be the VarDeclaredNames
of the first `Statement`. 1. Let names2 be the VarDeclaredNames of
the second `Statement`. 1. Return the list-concatenation of names1
and names2. IfStatement : `if` `(` Expression `)` Statement 1.
Return the VarDeclaredNames of `Statement`. DoWhileStatement : `do`
Statement `while` `(` Expression `)` `;` 1. Return the
VarDeclaredNames of `Statement`. WhileStatement : `while` `(`
Expression `)` Statement 1. Return the VarDeclaredNames of
`Statement`. ForStatement : `for` `(` Expression? `;`
Expression? `;` Expression? `)` Statement 1. Return the
VarDeclaredNames of `Statement`. ForStatement : `for` `(` `var`
VariableDeclarationList `;` Expression? `;` Expression? `)`
Statement 1. Let names1 be the BoundNames of
`VariableDeclarationList`. 1. Let names2 be the VarDeclaredNames
of `Statement`. 1. Return the list-concatenation of names1 and
names2. ForStatement : `for` `(` LexicalDeclaration Expression?
`;` Expression? `)` Statement 1. Return the VarDeclaredNames of
`Statement`. ForInOfStatement : `for` `(` LeftHandSideExpression
`in` Expression `)` Statement `for` `(` ForDeclaration `in`
Expression `)` Statement `for` `(` LeftHandSideExpression `of`
AssignmentExpression `)` Statement `for` `(` ForDeclaration `of`
AssignmentExpression `)` Statement `for` `await` `(`
LeftHandSideExpression `of` AssignmentExpression `)` Statement
`for` `await` `(` ForDeclaration `of` AssignmentExpression `)`
Statement 1. Return the VarDeclaredNames of `Statement`.
ForInOfStatement : `for` `(` `var` ForBinding `in` Expression
`)` Statement `for` `(` `var` ForBinding `of`
AssignmentExpression `)` Statement `for` `await` `(` `var`
ForBinding `of` AssignmentExpression `)` Statement 1. Let names1
be the BoundNames of `ForBinding`. 1. Let names2 be the
VarDeclaredNames of `Statement`. 1. Return the list-concatenation of
names1 and names2.

This section is extended by Annex .

WithStatement : `with` `(` Expression `)` Statement 1. Return the
VarDeclaredNames of `Statement`. SwitchStatement : `switch` `(`
Expression `)` CaseBlock 1. Return the VarDeclaredNames of
`CaseBlock`. CaseBlock : `{` `}` 1. Return a new empty List.
CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}` 1. If
the first `CaseClauses` is present, let names1 be the
VarDeclaredNames of the first `CaseClauses`. 1. Else, let names1
be a new empty List. 1. Let names2 be the VarDeclaredNames of
`DefaultClause`. 1. If the second `CaseClauses` is present, let
names3 be the VarDeclaredNames of the second `CaseClauses`. 1.
Else, let names3 be a new empty List. 1. Return the
list-concatenation of names1, names2, and names3.
CaseClauses : CaseClauses CaseClause 1. Let names1 be the
VarDeclaredNames of `CaseClauses`. 1. Let names2 be the
VarDeclaredNames of `CaseClause`. 1. Return the list-concatenation of
names1 and names2. CaseClause : `case` Expression `:`
StatementList? 1. If the `StatementList` is present, return the
VarDeclaredNames of `StatementList`. 1. Return a new empty List.
DefaultClause : `default` `:` StatementList? 1. If the
`StatementList` is present, return the VarDeclaredNames of
`StatementList`. 1. Return a new empty List. LabelledStatement :
LabelIdentifier `:` LabelledItem 1. Return the VarDeclaredNames of
`LabelledItem`. LabelledItem : FunctionDeclaration 1. Return a new
empty List. TryStatement : `try` Block Catch 1. Let names1 be the
VarDeclaredNames of `Block`. 1. Let names2 be the VarDeclaredNames
of `Catch`. 1. Return the list-concatenation of names1 and
names2. TryStatement : `try` Block Finally 1. Let names1 be
the VarDeclaredNames of `Block`. 1. Let names2 be the
VarDeclaredNames of `Finally`. 1. Return the list-concatenation of
names1 and names2. TryStatement : `try` Block Catch Finally 1.
Let names1 be the VarDeclaredNames of `Block`. 1. Let names2
be the VarDeclaredNames of `Catch`. 1. Let names3 be the
VarDeclaredNames of `Finally`. 1. Return the list-concatenation of
names1, names2, and names3. Catch : `catch` `(`
CatchParameter `)` Block 1. Return the VarDeclaredNames of `Block`.
FunctionStatementList : [empty] 1. Return a new empty List.
FunctionStatementList : StatementList 1. Return the
TopLevelVarDeclaredNames of `StatementList`.
ClassStaticBlockStatementList : [empty] 1. Return a new empty List.
ClassStaticBlockStatementList : StatementList 1. Return the
TopLevelVarDeclaredNames of `StatementList`. ConciseBody :
ExpressionBody 1. Return a new empty List. AsyncConciseBody :
ExpressionBody 1. Return a new empty List. Script : [empty] 1. Return a
new empty List. ScriptBody : StatementList 1. Return the
TopLevelVarDeclaredNames of `StatementList`. ModuleItemList :
ModuleItemList ModuleItem 1. Let names1 be the VarDeclaredNames of
`ModuleItemList`. 1. Let names2 be the VarDeclaredNames of
`ModuleItem`. 1. Return the list-concatenation of names1 and
names2. ModuleItem : ImportDeclaration 1. Return a new empty List.
ModuleItem : ExportDeclaration 1. If `ExportDeclaration` is `export`
`VariableStatement`, return the BoundNames of `ExportDeclaration`.
1. Return a new empty List.

Static Semantics: VarScopedDeclarations ( ): a List of Parse Nodes
------------------------------------------------------------------

Statement : EmptyStatement ExpressionStatement ContinueStatement
BreakStatement ReturnStatement ThrowStatement DebuggerStatement 1.
Return a new empty List. Block : `{` `}` 1. Return a new empty List.
StatementList : StatementList StatementListItem 1. Let declarations1
be the VarScopedDeclarations of `StatementList`. 1. Let
declarations2 be the VarScopedDeclarations of `StatementListItem`.
1. Return the list-concatenation of declarations1 and
declarations2. StatementListItem : Declaration 1. Return a new empty
List. VariableDeclarationList : VariableDeclaration 1. Return «
`VariableDeclaration` ». VariableDeclarationList :
VariableDeclarationList `,` VariableDeclaration 1. Let
declarations1 be the VarScopedDeclarations of
`VariableDeclarationList`. 1. Return the list-concatenation of
declarations1 and « `VariableDeclaration` ». IfStatement : `if`
`(` Expression `)` Statement `else` Statement 1. Let
declarations1 be the VarScopedDeclarations of the first
`Statement`. 1. Let declarations2 be the VarScopedDeclarations of
the second `Statement`. 1. Return the list-concatenation of
declarations1 and declarations2. IfStatement : `if` `(`
Expression `)` Statement 1. Return the VarScopedDeclarations of
`Statement`. DoWhileStatement : `do` Statement `while` `(`
Expression `)` `;` 1. Return the VarScopedDeclarations of
`Statement`. WhileStatement : `while` `(` Expression `)`
Statement 1. Return the VarScopedDeclarations of `Statement`.
ForStatement : `for` `(` Expression? `;` Expression? `;`
Expression? `)` Statement 1. Return the VarScopedDeclarations of
`Statement`. ForStatement : `for` `(` `var`
VariableDeclarationList `;` Expression? `;` Expression? `)`
Statement 1. Let declarations1 be the VarScopedDeclarations of
`VariableDeclarationList`. 1. Let declarations2 be the
VarScopedDeclarations of `Statement`. 1. Return the list-concatenation
of declarations1 and declarations2. ForStatement : `for` `(`
LexicalDeclaration Expression? `;` Expression? `)` Statement 1.
Return the VarScopedDeclarations of `Statement`. ForInOfStatement :
`for` `(` LeftHandSideExpression `in` Expression `)` Statement
`for` `(` ForDeclaration `in` Expression `)` Statement `for`
`(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
`for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
`for` `await` `(` LeftHandSideExpression `of`
AssignmentExpression `)` Statement `for` `await` `(`
ForDeclaration `of` AssignmentExpression `)` Statement 1. Return the
VarScopedDeclarations of `Statement`. ForInOfStatement : `for` `(`
`var` ForBinding `in` Expression `)` Statement `for` `(`
`var` ForBinding `of` AssignmentExpression `)` Statement `for`
`await` `(` `var` ForBinding `of` AssignmentExpression `)`
Statement 1. Let declarations1 be « `ForBinding` ». 1. Let
declarations2 be the VarScopedDeclarations of `Statement`. 1.
Return the list-concatenation of declarations1 and
declarations2.

This section is extended by Annex .

WithStatement : `with` `(` Expression `)` Statement 1. Return the
VarScopedDeclarations of `Statement`. SwitchStatement : `switch`
`(` Expression `)` CaseBlock 1. Return the VarScopedDeclarations of
`CaseBlock`. CaseBlock : `{` `}` 1. Return a new empty List.
CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}` 1. If
the first `CaseClauses` is present, let declarations1 be the
VarScopedDeclarations of the first `CaseClauses`. 1. Else, let
declarations1 be a new empty List. 1. Let declarations2 be the
VarScopedDeclarations of `DefaultClause`. 1. If the second
`CaseClauses` is present, let declarations3 be the
VarScopedDeclarations of the second `CaseClauses`. 1. Else, let
declarations3 be a new empty List. 1. Return the list-concatenation
of declarations1, declarations2, and declarations3.
CaseClauses : CaseClauses CaseClause 1. Let declarations1 be the
VarScopedDeclarations of `CaseClauses`. 1. Let declarations2 be
the VarScopedDeclarations of `CaseClause`. 1. Return the
list-concatenation of declarations1 and declarations2.
CaseClause : `case` Expression `:` StatementList? 1. If the
`StatementList` is present, return the VarScopedDeclarations of
`StatementList`. 1. Return a new empty List. DefaultClause :
`default` `:` StatementList? 1. If the `StatementList` is present,
return the VarScopedDeclarations of `StatementList`. 1. Return a new
empty List. LabelledStatement : LabelIdentifier `:` LabelledItem 1.
Return the VarScopedDeclarations of `LabelledItem`. LabelledItem :
FunctionDeclaration 1. Return a new empty List. TryStatement : `try`
Block Catch 1. Let declarations1 be the VarScopedDeclarations of
`Block`. 1. Let declarations2 be the VarScopedDeclarations of
`Catch`. 1. Return the list-concatenation of declarations1 and
declarations2. TryStatement : `try` Block Finally 1. Let
declarations1 be the VarScopedDeclarations of `Block`. 1. Let
declarations2 be the VarScopedDeclarations of `Finally`. 1. Return
the list-concatenation of declarations1 and declarations2.
TryStatement : `try` Block Catch Finally 1. Let declarations1 be
the VarScopedDeclarations of `Block`. 1. Let declarations2 be the
VarScopedDeclarations of `Catch`. 1. Let declarations3 be the
VarScopedDeclarations of `Finally`. 1. Return the list-concatenation
of declarations1, declarations2, and declarations3. Catch :
`catch` `(` CatchParameter `)` Block 1. Return the
VarScopedDeclarations of `Block`. FunctionStatementList : [empty] 1.
Return a new empty List. FunctionStatementList : StatementList 1. Return
the TopLevelVarScopedDeclarations of `StatementList`.
ClassStaticBlockStatementList : [empty] 1. Return a new empty List.
ClassStaticBlockStatementList : StatementList 1. Return the
TopLevelVarScopedDeclarations of `StatementList`. ConciseBody :
ExpressionBody 1. Return a new empty List. AsyncConciseBody :
ExpressionBody 1. Return a new empty List. Script : [empty] 1. Return a
new empty List. ScriptBody : StatementList 1. Return the
TopLevelVarScopedDeclarations of `StatementList`. Module : [empty] 1.
Return a new empty List. ModuleItemList : ModuleItemList ModuleItem 1.
Let declarations1 be the VarScopedDeclarations of
`ModuleItemList`. 1. Let declarations2 be the
VarScopedDeclarations of `ModuleItem`. 1. Return the
list-concatenation of declarations1 and declarations2.
ModuleItem : ImportDeclaration 1. Return a new empty List. ModuleItem :
ExportDeclaration 1. If `ExportDeclaration` is `export`
`VariableStatement`, return the VarScopedDeclarations of
`VariableStatement`. 1. Return a new empty List.

Static Semantics: TopLevelLexicallyDeclaredNames ( ): a List of Strings
-----------------------------------------------------------------------

StatementList : StatementList StatementListItem 1. Let names1 be the
TopLevelLexicallyDeclaredNames of `StatementList`. 1. Let names2
be the TopLevelLexicallyDeclaredNames of `StatementListItem`. 1.
Return the list-concatenation of names1 and names2.
StatementListItem : Statement 1. Return a new empty List.
StatementListItem : Declaration 1. If `Declaration` is Declaration :
HoistableDeclaration, then 1. Return a new empty List. 1. Return the
BoundNames of `Declaration`.

At the top level of a function, or script, function declarations are
treated like var declarations rather than like lexical declarations.

Static Semantics: TopLevelLexicallyScopedDeclarations ( ): a List of Parse Nodes
--------------------------------------------------------------------------------

StatementList : StatementList StatementListItem 1. Let declarations1
be the TopLevelLexicallyScopedDeclarations of `StatementList`. 1. Let
declarations2 be the TopLevelLexicallyScopedDeclarations of
`StatementListItem`. 1. Return the list-concatenation of
declarations1 and declarations2. StatementListItem : Statement
1. Return a new empty List. StatementListItem : Declaration 1. If
`Declaration` is Declaration : HoistableDeclaration, then 1. Return a
new empty List. 1. Return « `Declaration` ».

Static Semantics: TopLevelVarDeclaredNames ( ): a List of Strings
-----------------------------------------------------------------

StatementList : StatementList StatementListItem 1. Let names1 be the
TopLevelVarDeclaredNames of `StatementList`. 1. Let names2 be the
TopLevelVarDeclaredNames of `StatementListItem`. 1. Return the
list-concatenation of names1 and names2. StatementListItem :
Declaration 1. If `Declaration` is Declaration : HoistableDeclaration,
then 1. Return the BoundNames of `HoistableDeclaration`. 1. Return a
new empty List. StatementListItem : Statement 1. If `Statement` is
Statement : LabelledStatement, return the TopLevelVarDeclaredNames of
`Statement`. 1. Return the VarDeclaredNames of `Statement`.

At the top level of a function or script, inner function declarations
are treated like var declarations.

LabelledStatement : LabelIdentifier `:` LabelledItem 1. Return the
TopLevelVarDeclaredNames of `LabelledItem`. LabelledItem : Statement
1. If `Statement` is Statement : LabelledStatement, return the
TopLevelVarDeclaredNames of `Statement`. 1. Return the
VarDeclaredNames of `Statement`. LabelledItem : FunctionDeclaration 1.
Return the BoundNames of `FunctionDeclaration`.

Static Semantics: TopLevelVarScopedDeclarations ( ): a List of Parse Nodes
--------------------------------------------------------------------------

StatementList : StatementList StatementListItem 1. Let declarations1
be the TopLevelVarScopedDeclarations of `StatementList`. 1. Let
declarations2 be the TopLevelVarScopedDeclarations of
`StatementListItem`. 1. Return the list-concatenation of
declarations1 and declarations2. StatementListItem : Statement
1. If `Statement` is Statement : LabelledStatement, return the
TopLevelVarScopedDeclarations of `Statement`. 1. Return the
VarScopedDeclarations of `Statement`. StatementListItem : Declaration
1. If `Declaration` is Declaration : HoistableDeclaration, then 1. Let
declaration be the DeclarationPart of `HoistableDeclaration`. 1.
Return « declaration ». 1. Return a new empty List.
LabelledStatement : LabelIdentifier `:` LabelledItem 1. Return the
TopLevelVarScopedDeclarations of `LabelledItem`. LabelledItem :
Statement 1. If `Statement` is Statement : LabelledStatement, return
the TopLevelVarScopedDeclarations of `Statement`. 1. Return the
VarScopedDeclarations of `Statement`. LabelledItem :
FunctionDeclaration 1. Return « `FunctionDeclaration` ».

Labels
------

Static Semantics: ContainsDuplicateLabels ( labelSet: a List of Strings, ): a Boolean
-----------------------------------------------------------------------------------------

Statement : VariableStatement EmptyStatement ExpressionStatement
ContinueStatement BreakStatement ReturnStatement ThrowStatement
DebuggerStatement Block : `{` `}` StatementListItem : Declaration 1.
Return `false`. StatementList : StatementList StatementListItem 1. Let
hasDuplicates be ContainsDuplicateLabels of `StatementList` with
argument labelSet. 1. If hasDuplicates is `true`, return
`true`. 1. Return ContainsDuplicateLabels of `StatementListItem`
with argument labelSet. IfStatement : `if` `(` Expression `)`
Statement `else` Statement 1. Let hasDuplicate be
ContainsDuplicateLabels of the first `Statement` with argument
labelSet. 1. If hasDuplicate is `true`, return `true`. 1.
Return ContainsDuplicateLabels of the second `Statement` with argument
labelSet. IfStatement : `if` `(` Expression `)` Statement 1.
Return ContainsDuplicateLabels of `Statement` with argument
labelSet. DoWhileStatement : `do` Statement `while` `(`
Expression `)` `;` 1. Return ContainsDuplicateLabels of
`Statement` with argument labelSet. WhileStatement : `while`
`(` Expression `)` Statement 1. Return ContainsDuplicateLabels of
`Statement` with argument labelSet. ForStatement : `for` `(`
Expression? `;` Expression? `;` Expression? `)` Statement `for`
`(` `var` VariableDeclarationList `;` Expression? `;`
Expression? `)` Statement `for` `(` LexicalDeclaration Expression?
`;` Expression? `)` Statement 1. Return ContainsDuplicateLabels of
`Statement` with argument labelSet. ForInOfStatement : `for`
`(` LeftHandSideExpression `in` Expression `)` Statement `for`
`(` `var` ForBinding `in` Expression `)` Statement `for` `(`
ForDeclaration `in` Expression `)` Statement `for` `(`
LeftHandSideExpression `of` AssignmentExpression `)` Statement
`for` `(` `var` ForBinding `of` AssignmentExpression `)`
Statement `for` `(` ForDeclaration `of` AssignmentExpression `)`
Statement `for` `await` `(` LeftHandSideExpression `of`
AssignmentExpression `)` Statement `for` `await` `(` `var`
ForBinding `of` AssignmentExpression `)` Statement `for` `await`
`(` ForDeclaration `of` AssignmentExpression `)` Statement 1.
Return ContainsDuplicateLabels of `Statement` with argument
labelSet.

This section is extended by Annex .

WithStatement : `with` `(` Expression `)` Statement 1. Return
ContainsDuplicateLabels of `Statement` with argument labelSet.
SwitchStatement : `switch` `(` Expression `)` CaseBlock 1. Return
ContainsDuplicateLabels of `CaseBlock` with argument labelSet.
CaseBlock : `{` `}` 1. Return `false`. CaseBlock : `{`
CaseClauses? DefaultClause CaseClauses? `}` 1. If the first
`CaseClauses` is present, then 1. If ContainsDuplicateLabels of the
first `CaseClauses` with argument labelSet is `true`, return
`true`. 1. If ContainsDuplicateLabels of `DefaultClause` with
argument labelSet is `true`, return `true`. 1. If the second
`CaseClauses` is not present, return `false`. 1. Return
ContainsDuplicateLabels of the second `CaseClauses` with argument
labelSet. CaseClauses : CaseClauses CaseClause 1. Let
hasDuplicates be ContainsDuplicateLabels of `CaseClauses` with
argument labelSet. 1. If hasDuplicates is `true`, return
`true`. 1. Return ContainsDuplicateLabels of `CaseClause` with
argument labelSet. CaseClause : `case` Expression `:`
StatementList? 1. If the `StatementList` is present, return
ContainsDuplicateLabels of `StatementList` with argument labelSet.
1. Return `false`. DefaultClause : `default` `:` StatementList? 1.
If the `StatementList` is present, return ContainsDuplicateLabels of
`StatementList` with argument labelSet. 1. Return `false`.
LabelledStatement : LabelIdentifier `:` LabelledItem 1. Let label
be the StringValue of `LabelIdentifier`. 1. If labelSet contains
label, return `true`. 1. Let newLabelSet be the
list-concatenation of labelSet and « label ». 1. Return
ContainsDuplicateLabels of `LabelledItem` with argument
newLabelSet. LabelledItem : FunctionDeclaration 1. Return `false`.
TryStatement : `try` Block Catch 1. Let hasDuplicates be
ContainsDuplicateLabels of `Block` with argument labelSet. 1. If
hasDuplicates is `true`, return `true`. 1. Return
ContainsDuplicateLabels of `Catch` with argument labelSet.
TryStatement : `try` Block Finally 1. Let hasDuplicates be
ContainsDuplicateLabels of `Block` with argument labelSet. 1. If
hasDuplicates is `true`, return `true`. 1. Return
ContainsDuplicateLabels of `Finally` with argument labelSet.
TryStatement : `try` Block Catch Finally 1. If ContainsDuplicateLabels
of `Block` with argument labelSet is `true`, return `true`. 1.
If ContainsDuplicateLabels of `Catch` with argument labelSet is
`true`, return `true`. 1. Return ContainsDuplicateLabels of
`Finally` with argument labelSet. Catch : `catch` `(`
CatchParameter `)` Block 1. Return ContainsDuplicateLabels of
`Block` with argument labelSet. FunctionStatementList : [empty] 1.
Return `false`. ClassStaticBlockStatementList : [empty] 1. Return
`false`. ModuleItemList : ModuleItemList ModuleItem 1. Let
hasDuplicates be ContainsDuplicateLabels of `ModuleItemList` with
argument labelSet. 1. If hasDuplicates is `true`, return
`true`. 1. Return ContainsDuplicateLabels of `ModuleItem` with
argument labelSet. ModuleItem : ImportDeclaration ExportDeclaration
1. Return `false`.

Static Semantics: ContainsUndefinedBreakTarget ( labelSet: a List of Strings, ): a Boolean
----------------------------------------------------------------------------------------------

Statement : VariableStatement EmptyStatement ExpressionStatement
ContinueStatement ReturnStatement ThrowStatement DebuggerStatement Block
: `{` `}` StatementListItem : Declaration 1. Return `false`.
StatementList : StatementList StatementListItem 1. Let
hasUndefinedLabels be ContainsUndefinedBreakTarget of
`StatementList` with argument labelSet. 1. If
hasUndefinedLabels is `true`, return `true`. 1. Return
ContainsUndefinedBreakTarget of `StatementListItem` with argument
labelSet. IfStatement : `if` `(` Expression `)` Statement
`else` Statement 1. Let hasUndefinedLabels be
ContainsUndefinedBreakTarget of the first `Statement` with argument
labelSet. 1. If hasUndefinedLabels is `true`, return `true`.
1. Return ContainsUndefinedBreakTarget of the second `Statement` with
argument labelSet. IfStatement : `if` `(` Expression `)`
Statement 1. Return ContainsUndefinedBreakTarget of `Statement` with
argument labelSet. DoWhileStatement : `do` Statement `while`
`(` Expression `)` `;` 1. Return ContainsUndefinedBreakTarget of
`Statement` with argument labelSet. WhileStatement : `while`
`(` Expression `)` Statement 1. Return ContainsUndefinedBreakTarget
of `Statement` with argument labelSet. ForStatement : `for`
`(` Expression? `;` Expression? `;` Expression? `)` Statement
`for` `(` `var` VariableDeclarationList `;` Expression? `;`
Expression? `)` Statement `for` `(` LexicalDeclaration Expression?
`;` Expression? `)` Statement 1. Return ContainsUndefinedBreakTarget
of `Statement` with argument labelSet. ForInOfStatement : `for`
`(` LeftHandSideExpression `in` Expression `)` Statement `for`
`(` `var` ForBinding `in` Expression `)` Statement `for` `(`
ForDeclaration `in` Expression `)` Statement `for` `(`
LeftHandSideExpression `of` AssignmentExpression `)` Statement
`for` `(` `var` ForBinding `of` AssignmentExpression `)`
Statement `for` `(` ForDeclaration `of` AssignmentExpression `)`
Statement `for` `await` `(` LeftHandSideExpression `of`
AssignmentExpression `)` Statement `for` `await` `(` `var`
ForBinding `of` AssignmentExpression `)` Statement `for` `await`
`(` ForDeclaration `of` AssignmentExpression `)` Statement 1.
Return ContainsUndefinedBreakTarget of `Statement` with argument
labelSet.

This section is extended by Annex .

BreakStatement : `break` `;` 1. Return `false`. BreakStatement :
`break` LabelIdentifier `;` 1. If labelSet does not contain the
StringValue of `LabelIdentifier`, return `true`. 1. Return
`false`. WithStatement : `with` `(` Expression `)` Statement 1.
Return ContainsUndefinedBreakTarget of `Statement` with argument
labelSet. SwitchStatement : `switch` `(` Expression `)`
CaseBlock 1. Return ContainsUndefinedBreakTarget of `CaseBlock` with
argument labelSet. CaseBlock : `{` `}` 1. Return `false`.
CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}` 1. If
the first `CaseClauses` is present, then 1. If
ContainsUndefinedBreakTarget of the first `CaseClauses` with argument
labelSet is `true`, return `true`. 1. If
ContainsUndefinedBreakTarget of `DefaultClause` with argument
labelSet is `true`, return `true`. 1. If the second
`CaseClauses` is not present, return `false`. 1. Return
ContainsUndefinedBreakTarget of the second `CaseClauses` with argument
labelSet. CaseClauses : CaseClauses CaseClause 1. Let
hasUndefinedLabels be ContainsUndefinedBreakTarget of
`CaseClauses` with argument labelSet. 1. If hasUndefinedLabels
is `true`, return `true`. 1. Return ContainsUndefinedBreakTarget of
`CaseClause` with argument labelSet. CaseClause : `case`
Expression `:` StatementList? 1. If the `StatementList` is present,
return ContainsUndefinedBreakTarget of `StatementList` with argument
labelSet. 1. Return `false`. DefaultClause : `default` `:`
StatementList? 1. If the `StatementList` is present, return
ContainsUndefinedBreakTarget of `StatementList` with argument
labelSet. 1. Return `false`. LabelledStatement : LabelIdentifier
`:` LabelledItem 1. Let label be the StringValue of
`LabelIdentifier`. 1. Let newLabelSet be the list-concatenation of
labelSet and « label ». 1. Return ContainsUndefinedBreakTarget
of `LabelledItem` with argument newLabelSet. LabelledItem :
FunctionDeclaration 1. Return `false`. TryStatement : `try` Block
Catch 1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of
`Block` with argument labelSet. 1. If hasUndefinedLabels is
`true`, return `true`. 1. Return ContainsUndefinedBreakTarget of
`Catch` with argument labelSet. TryStatement : `try` Block
Finally 1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of
`Block` with argument labelSet. 1. If hasUndefinedLabels is
`true`, return `true`. 1. Return ContainsUndefinedBreakTarget of
`Finally` with argument labelSet. TryStatement : `try` Block
Catch Finally 1. If ContainsUndefinedBreakTarget of `Block` with
argument labelSet is `true`, return `true`. 1. If
ContainsUndefinedBreakTarget of `Catch` with argument labelSet is
`true`, return `true`. 1. Return ContainsUndefinedBreakTarget of
`Finally` with argument labelSet. Catch : `catch` `(`
CatchParameter `)` Block 1. Return ContainsUndefinedBreakTarget of
`Block` with argument labelSet. FunctionStatementList : [empty] 1.
Return `false`. ClassStaticBlockStatementList : [empty] 1. Return
`false`. ModuleItemList : ModuleItemList ModuleItem 1. Let
hasUndefinedLabels be ContainsUndefinedBreakTarget of
`ModuleItemList` with argument labelSet. 1. If
hasUndefinedLabels is `true`, return `true`. 1. Return
ContainsUndefinedBreakTarget of `ModuleItem` with argument
labelSet. ModuleItem : ImportDeclaration ExportDeclaration 1. Return
`false`.

Static Semantics: ContainsUndefinedContinueTarget ( iterationSet: a List of Strings, labelSet: a List of Strings, ): a Boolean
--------------------------------------------------------------------------------------------------------------------------------------

Statement : VariableStatement EmptyStatement ExpressionStatement
BreakStatement ReturnStatement ThrowStatement DebuggerStatement Block :
`{` `}` StatementListItem : Declaration 1. Return `false`.
Statement : BlockStatement 1. Return ContainsUndefinedContinueTarget of
`BlockStatement` with arguments iterationSet and « ».
BreakableStatement : IterationStatement 1. Let newIterationSet be
the list-concatenation of iterationSet and labelSet. 1. Return
ContainsUndefinedContinueTarget of `IterationStatement` with arguments
newIterationSet and « ». StatementList : StatementList
StatementListItem 1. Let hasUndefinedLabels be
ContainsUndefinedContinueTarget of `StatementList` with arguments
iterationSet and « ». 1. If hasUndefinedLabels is `true`,
return `true`. 1. Return ContainsUndefinedContinueTarget of
`StatementListItem` with arguments iterationSet and « ».
IfStatement : `if` `(` Expression `)` Statement `else` Statement
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of the
first `Statement` with arguments iterationSet and « ». 1. If
hasUndefinedLabels is `true`, return `true`. 1. Return
ContainsUndefinedContinueTarget of the second `Statement` with
arguments iterationSet and « ». IfStatement : `if` `(`
Expression `)` Statement 1. Return ContainsUndefinedContinueTarget of
`Statement` with arguments iterationSet and « ». DoWhileStatement
: `do` Statement `while` `(` Expression `)` `;` 1. Return
ContainsUndefinedContinueTarget of `Statement` with arguments
iterationSet and « ». WhileStatement : `while` `(` Expression
`)` Statement 1. Return ContainsUndefinedContinueTarget of
`Statement` with arguments iterationSet and « ». ForStatement :
`for` `(` Expression? `;` Expression? `;` Expression? `)`
Statement `for` `(` `var` VariableDeclarationList `;`
Expression? `;` Expression? `)` Statement `for` `(`
LexicalDeclaration Expression? `;` Expression? `)` Statement 1.
Return ContainsUndefinedContinueTarget of `Statement` with arguments
iterationSet and « ». ForInOfStatement : `for` `(`
LeftHandSideExpression `in` Expression `)` Statement `for` `(`
`var` ForBinding `in` Expression `)` Statement `for` `(`
ForDeclaration `in` Expression `)` Statement `for` `(`
LeftHandSideExpression `of` AssignmentExpression `)` Statement
`for` `(` `var` ForBinding `of` AssignmentExpression `)`
Statement `for` `(` ForDeclaration `of` AssignmentExpression `)`
Statement `for` `await` `(` LeftHandSideExpression `of`
AssignmentExpression `)` Statement `for` `await` `(` `var`
ForBinding `of` AssignmentExpression `)` Statement `for` `await`
`(` ForDeclaration `of` AssignmentExpression `)` Statement 1.
Return ContainsUndefinedContinueTarget of `Statement` with arguments
iterationSet and « ».

This section is extended by Annex .

ContinueStatement : `continue` `;` 1. Return `false`.
ContinueStatement : `continue` LabelIdentifier `;` 1. If
iterationSet does not contain the StringValue of
`LabelIdentifier`, return `true`. 1. Return `false`. WithStatement
: `with` `(` Expression `)` Statement 1. Return
ContainsUndefinedContinueTarget of `Statement` with arguments
iterationSet and « ». SwitchStatement : `switch` `(` Expression
`)` CaseBlock 1. Return ContainsUndefinedContinueTarget of
`CaseBlock` with arguments iterationSet and « ». CaseBlock : `{`
`}` 1. Return `false`. CaseBlock : `{` CaseClauses? DefaultClause
CaseClauses? `}` 1. If the first `CaseClauses` is present, then 1.
If ContainsUndefinedContinueTarget of the first `CaseClauses` with
arguments iterationSet and « » is `true`, return `true`. 1. If
ContainsUndefinedContinueTarget of `DefaultClause` with arguments
iterationSet and « » is `true`, return `true`. 1. If the second
`CaseClauses` is not present, return `false`. 1. Return
ContainsUndefinedContinueTarget of the second `CaseClauses` with
arguments iterationSet and « ». CaseClauses : CaseClauses CaseClause
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
`CaseClauses` with arguments iterationSet and « ». 1. If
hasUndefinedLabels is `true`, return `true`. 1. Return
ContainsUndefinedContinueTarget of `CaseClause` with arguments
iterationSet and « ». CaseClause : `case` Expression `:`
StatementList? 1. If the `StatementList` is present, return
ContainsUndefinedContinueTarget of `StatementList` with arguments
iterationSet and « ». 1. Return `false`. DefaultClause :
`default` `:` StatementList? 1. If the `StatementList` is present,
return ContainsUndefinedContinueTarget of `StatementList` with
arguments iterationSet and « ». 1. Return `false`.
LabelledStatement : LabelIdentifier `:` LabelledItem 1. Let label
be the StringValue of `LabelIdentifier`. 1. Let newLabelSet be the
list-concatenation of labelSet and « label ». 1. Return
ContainsUndefinedContinueTarget of `LabelledItem` with arguments
iterationSet and newLabelSet. LabelledItem : FunctionDeclaration
1. Return `false`. TryStatement : `try` Block Catch 1. Let
hasUndefinedLabels be ContainsUndefinedContinueTarget of `Block`
with arguments iterationSet and « ». 1. If hasUndefinedLabels is
`true`, return `true`. 1. Return ContainsUndefinedContinueTarget of
`Catch` with arguments iterationSet and « ». TryStatement :
`try` Block Finally 1. Let hasUndefinedLabels be
ContainsUndefinedContinueTarget of `Block` with arguments
iterationSet and « ». 1. If hasUndefinedLabels is `true`,
return `true`. 1. Return ContainsUndefinedContinueTarget of
`Finally` with arguments iterationSet and « ». TryStatement :
`try` Block Catch Finally 1. If ContainsUndefinedContinueTarget of
`Block` with arguments iterationSet and « » is `true`, return
`true`. 1. If ContainsUndefinedContinueTarget of `Catch` with
arguments iterationSet and « » is `true`, return `true`. 1.
Return ContainsUndefinedContinueTarget of `Finally` with arguments
iterationSet and « ». Catch : `catch` `(` CatchParameter `)`
Block 1. Return ContainsUndefinedContinueTarget of `Block` with
arguments iterationSet and « ». FunctionStatementList : [empty] 1.
Return `false`. ClassStaticBlockStatementList : [empty] 1. Return
`false`. ModuleItemList : ModuleItemList ModuleItem 1. Let
hasUndefinedLabels be ContainsUndefinedContinueTarget of
`ModuleItemList` with arguments iterationSet and « ». 1. If
hasUndefinedLabels is `true`, return `true`. 1. Return
ContainsUndefinedContinueTarget of `ModuleItem` with arguments
iterationSet and « ». ModuleItem : ImportDeclaration
ExportDeclaration 1. Return `false`.

Function Name Inference
-----------------------

Static Semantics: HasName ( ): a Boolean
----------------------------------------

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 1.
Let expr be the `ParenthesizedExpression` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. If
IsFunctionDefinition of expr is `false`, return `false`. 1.
Return HasName of expr. FunctionExpression : `function` `(`
FormalParameters `)` `{` FunctionBody `}` GeneratorExpression :
`function` `*` `(` FormalParameters `)` `{` GeneratorBody
`}` AsyncGeneratorExpression : `async` `function` `*` `(`
FormalParameters `)` `{` AsyncGeneratorBody `}`
AsyncFunctionExpression : `async` `function` `(` FormalParameters
`)` `{` AsyncFunctionBody `}` ArrowFunction : ArrowParameters
`=>` ConciseBody AsyncArrowFunction : `async`
AsyncArrowBindingIdentifier `=>` AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
ClassExpression : `class` ClassTail 1. Return `false`.
FunctionExpression : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` GeneratorExpression :
`function` `*` BindingIdentifier `(` FormalParameters `)` `{`
GeneratorBody `}` AsyncGeneratorExpression : `async` `function`
`*` BindingIdentifier `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` AsyncFunctionExpression : `async`
`function` BindingIdentifier `(` FormalParameters `)` `{`
AsyncFunctionBody `}` ClassExpression : `class` BindingIdentifier
ClassTail 1. Return `true`.

Static Semantics: IsFunctionDefinition ( ): a Boolean
-----------------------------------------------------

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 1.
Let expr be the `ParenthesizedExpression` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return
IsFunctionDefinition of expr. PrimaryExpression : `this`
IdentifierReference Literal ArrayLiteral ObjectLiteral
RegularExpressionLiteral TemplateLiteral MemberExpression :
MemberExpression `[` Expression `]` MemberExpression `.`
IdentifierName MemberExpression TemplateLiteral SuperProperty
MetaProperty `new` MemberExpression Arguments MemberExpression `.`
PrivateIdentifier NewExpression : `new` NewExpression
LeftHandSideExpression : CallExpression OptionalExpression
UpdateExpression : LeftHandSideExpression `++` LeftHandSideExpression
`--` `++` UnaryExpression `--` UnaryExpression UnaryExpression :
`delete` UnaryExpression `void` UnaryExpression `typeof`
UnaryExpression `+` UnaryExpression `-` UnaryExpression `~`
UnaryExpression `!` UnaryExpression AwaitExpression
ExponentiationExpression : UpdateExpression `**`
ExponentiationExpression MultiplicativeExpression :
MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression
AdditiveExpression `-` MultiplicativeExpression ShiftExpression :
ShiftExpression `<<` AdditiveExpression ShiftExpression `>>`
AdditiveExpression ShiftExpression `>>>` AdditiveExpression
RelationalExpression : RelationalExpression `<` ShiftExpression
RelationalExpression `>` ShiftExpression RelationalExpression `<=`
ShiftExpression RelationalExpression `>=` ShiftExpression
RelationalExpression `instanceof` ShiftExpression RelationalExpression
`in` ShiftExpression PrivateIdentifier `in` ShiftExpression
EqualityExpression : EqualityExpression `==` RelationalExpression
EqualityExpression `!=` RelationalExpression EqualityExpression
`===` RelationalExpression EqualityExpression `!==`
RelationalExpression BitwiseANDExpression : BitwiseANDExpression `&`
EqualityExpression BitwiseXORExpression : BitwiseXORExpression `^`
BitwiseANDExpression BitwiseORExpression : BitwiseORExpression `|`
BitwiseXORExpression LogicalANDExpression : LogicalANDExpression `&&`
BitwiseORExpression LogicalORExpression : LogicalORExpression `||`
LogicalANDExpression CoalesceExpression : CoalesceExpressionHead `??`
BitwiseORExpression ConditionalExpression : ShortCircuitExpression `?`
AssignmentExpression `:` AssignmentExpression AssignmentExpression :
YieldExpression LeftHandSideExpression `=` AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression
LeftHandSideExpression `&&=` AssignmentExpression
LeftHandSideExpression `||=` AssignmentExpression
LeftHandSideExpression `??=` AssignmentExpression Expression :
Expression `,` AssignmentExpression 1. Return `false`.
AssignmentExpression : ArrowFunction AsyncArrowFunction
FunctionExpression : `function` BindingIdentifier? `(`
FormalParameters `)` `{` FunctionBody `}` GeneratorExpression :
`function` `*` BindingIdentifier? `(` FormalParameters `)` `{`
GeneratorBody `}` AsyncGeneratorExpression : `async` `function`
`*` BindingIdentifier? `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` AsyncFunctionExpression : `async`
`function` BindingIdentifier? `(` FormalParameters `)` `{`
AsyncFunctionBody `}` ClassExpression : `class` BindingIdentifier?
ClassTail 1. Return `true`.

Static Semantics: IsAnonymousFunctionDefinition ( expr: an `AssignmentExpression` Parse Node, an `Initializer` Parse Node, or an `Expression` Parse Node, ): a Boolean
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It determines if its argument is a function definition that does not
   bind a name.

1. If IsFunctionDefinition of expr is `false`, return `false`.
1. Let hasName be HasName of expr. 1. If hasName is
`true`, return `false`. 1. Return `true`.

Static Semantics: IsIdentifierRef ( ): a Boolean
------------------------------------------------

PrimaryExpression : IdentifierReference 1. Return `true`.
PrimaryExpression : `this` Literal ArrayLiteral ObjectLiteral
FunctionExpression ClassExpression GeneratorExpression
AsyncFunctionExpression AsyncGeneratorExpression
RegularExpressionLiteral TemplateLiteral
CoverParenthesizedExpressionAndArrowParameterList MemberExpression :
MemberExpression `[` Expression `]` MemberExpression `.`
IdentifierName MemberExpression TemplateLiteral SuperProperty
MetaProperty `new` MemberExpression Arguments MemberExpression `.`
PrivateIdentifier NewExpression : `new` NewExpression
LeftHandSideExpression : CallExpression OptionalExpression 1. Return
`false`.

Runtime Semantics: NamedEvaluation ( name: a property key or a Private Name, )
------------------------------------------------------------------------------

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 1.
Let expr be the `ParenthesizedExpression` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return ?
NamedEvaluation of expr with argument name.
ParenthesizedExpression : `(` Expression `)` 1. Assert:
IsAnonymousFunctionDefinition(`Expression`) is `true`. 1. Return ?
NamedEvaluation of `Expression` with argument name.
FunctionExpression : `function` `(` FormalParameters `)` `{`
FunctionBody `}` 1. Return InstantiateOrdinaryFunctionExpression of
`FunctionExpression` with argument name. GeneratorExpression :
`function` `*` `(` FormalParameters `)` `{` GeneratorBody
`}` 1. Return InstantiateGeneratorFunctionExpression of
`GeneratorExpression` with argument name. AsyncGeneratorExpression
: `async` `function` `*` `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` 1. Return
InstantiateAsyncGeneratorFunctionExpression of
`AsyncGeneratorExpression` with argument name.
AsyncFunctionExpression : `async` `function` `(` FormalParameters
`)` `{` AsyncFunctionBody `}` 1. Return
InstantiateAsyncFunctionExpression of `AsyncFunctionExpression` with
argument name. ArrowFunction : ArrowParameters `=>` ConciseBody 1.
Return InstantiateArrowFunctionExpression of `ArrowFunction` with
argument name. AsyncArrowFunction : `async`
AsyncArrowBindingIdentifier `=>` AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody 1. Return
InstantiateAsyncArrowFunctionExpression of `AsyncArrowFunction` with
argument name. ClassExpression : `class` ClassTail 1. Let
value be ? ClassDefinitionEvaluation of `ClassTail` with arguments
`undefined` and name. 1. Set value.[[SourceText]] to the
source text matched by `ClassExpression`. 1. Return value.

Contains
--------

Static Semantics: Contains ( symbol: a grammar symbol, ): a Boolean
-----------------------------------------------------------------------

Every grammar production alternative in this specification which is not
listed below implicitly has the following default definition of
Contains:

1. For each child node child of this Parse Node, do 1. If child
is an instance of symbol, return `true`. 1. If child is an
instance of a nonterminal, then 1. Let contained be the result of
child Contains symbol. 1. If contained is `true`, return
`true`. 1. Return `false`. FunctionDeclaration : `function`
BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
`function` `(` FormalParameters `)` `{` FunctionBody `}`
FunctionExpression : `function` BindingIdentifier? `(`
FormalParameters `)` `{` FunctionBody `}` GeneratorDeclaration :
`function` `*` BindingIdentifier `(` FormalParameters `)` `{`
GeneratorBody `}` `function` `*` `(` FormalParameters `)`
`{` GeneratorBody `}` GeneratorExpression : `function` `*`
BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody
`}` AsyncGeneratorDeclaration : `async` `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` `async` `function` `*` `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` AsyncGeneratorExpression : `async`
`function` `*` BindingIdentifier? `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` AsyncFunctionDeclaration : `async`
`function` BindingIdentifier `(` FormalParameters `)` `{`
AsyncFunctionBody `}` `async` `function` `(` FormalParameters
`)` `{` AsyncFunctionBody `}` AsyncFunctionExpression : `async`
`function` BindingIdentifier? `(` FormalParameters `)` `{`
AsyncFunctionBody `}` 1. Return `false`.

Static semantic rules that depend upon substructure generally do not
look into function definitions.

ClassTail : ClassHeritage? `{` ClassBody `}` 1. If symbol is
`ClassBody`, return `true`. 1. If symbol is `ClassHeritage`,
then 1. If `ClassHeritage` is present, return `true`; otherwise
return `false`. 1. If `ClassHeritage` is present, then 1. If
`ClassHeritage` Contains symbol is `true`, return `true`. 1.
Return the result of ComputedPropertyContains of `ClassBody` with
argument symbol.

Static semantic rules that depend upon substructure generally do not
look into class bodies except for \|PropertyName|s.

ClassStaticBlock : `static` `{` ClassStaticBlockBody `}` 1. Return
`false`.

Static semantic rules that depend upon substructure generally do not
look into `static` initialization blocks.

ArrowFunction : ArrowParameters `=>` ConciseBody 1. If symbol is
not one of `NewTarget`, `SuperProperty`, `SuperCall`, `super`,
or `this`, return `false`. 1. If `ArrowParameters` Contains
symbol is `true`, return `true`. 1. Return `ConciseBody`
Contains symbol. ArrowParameters :
CoverParenthesizedExpressionAndArrowParameterList 1. Let formals be
the `ArrowFormalParameters` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return
formals Contains symbol. AsyncArrowFunction : `async`
AsyncArrowBindingIdentifier `=>` AsyncConciseBody 1. If symbol is
not one of `NewTarget`, `SuperProperty`, `SuperCall`, `super`,
or `this`, return `false`. 1. Return `AsyncConciseBody` Contains
symbol. AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead
`=>` AsyncConciseBody 1. If symbol is not one of `NewTarget`,
`SuperProperty`, `SuperCall`, `super`, or `this`, return
`false`. 1. Let head be the `AsyncArrowHead` that is covered by
`CoverCallExpressionAndAsyncArrowHead`. 1. If head Contains
symbol is `true`, return `true`. 1. Return `AsyncConciseBody`
Contains symbol.

Contains is used to detect `new.target`, `this`, and `super` usage
within an `ArrowFunction` or `AsyncArrowFunction`.

PropertyDefinition : MethodDefinition 1. If symbol is
`MethodDefinition`, return `true`. 1. Return the result of
ComputedPropertyContains of `MethodDefinition` with argument
symbol. LiteralPropertyName : IdentifierName 1. Return `false`.
MemberExpression : MemberExpression `.` IdentifierName 1. If
`MemberExpression` Contains symbol is `true`, return `true`.
1. Return `false`. SuperProperty : `super` `.` IdentifierName 1.
If symbol is the `ReservedWord` `super`, return `true`. 1.
Return `false`. CallExpression : CallExpression `.` IdentifierName
1. If `CallExpression` Contains symbol is `true`, return
`true`. 1. Return `false`. OptionalChain : `?.` IdentifierName 1.
Return `false`. OptionalChain : OptionalChain `.` IdentifierName 1.
If `OptionalChain` Contains symbol is `true`, return `true`.
1. Return `false`.

Static Semantics: ComputedPropertyContains ( symbol: a grammar symbol, ): a Boolean
---------------------------------------------------------------------------------------

ClassElementName : PrivateIdentifier PropertyName : LiteralPropertyName
1. Return `false`. PropertyName : ComputedPropertyName 1. Return the
result of `ComputedPropertyName` Contains symbol. MethodDefinition
: ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody
`}` `get` ClassElementName `(` `)` `{` FunctionBody `}`
`set` ClassElementName `(` PropertySetParameterList `)` `{`
FunctionBody `}` 1. Return the result of ComputedPropertyContains of
`ClassElementName` with argument symbol. GeneratorMethod : `*`
ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody
`}` 1. Return the result of ComputedPropertyContains of
`ClassElementName` with argument symbol. AsyncGeneratorMethod :
`async` `*` ClassElementName `(` UniqueFormalParameters `)`
`{` AsyncGeneratorBody `}` 1. Return the result of
ComputedPropertyContains of `ClassElementName` with argument
symbol. ClassElementList : ClassElementList ClassElement 1. Let
inList be ComputedPropertyContains of `ClassElementList` with
argument symbol. 1. If inList is `true`, return `true`. 1.
Return the result of ComputedPropertyContains of `ClassElement` with
argument symbol. ClassElement : ClassStaticBlock 1. Return
`false`. ClassElement : `;` 1. Return `false`. AsyncMethod :
`async` ClassElementName `(` UniqueFormalParameters `)` `{`
AsyncFunctionBody `}` 1. Return the result of ComputedPropertyContains
of `ClassElementName` with argument symbol. FieldDefinition :
ClassElementName Initializer? 1. Return the result of
ComputedPropertyContains of `ClassElementName` with argument
symbol.

Miscellaneous
-------------

These operations are used in multiple places throughout the
specification.

Runtime Semantics: InstantiateFunctionObject ( env: an Environment Record, privateEnv: a PrivateEnvironment Record or `null`, ): an ECMAScript function object
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FunctionDeclaration : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` `function` `(`
FormalParameters `)` `{` FunctionBody `}` 1. Return
InstantiateOrdinaryFunctionObject of `FunctionDeclaration` with
arguments env and privateEnv. GeneratorDeclaration :
`function` `*` BindingIdentifier `(` FormalParameters `)` `{`
GeneratorBody `}` `function` `*` `(` FormalParameters `)`
`{` GeneratorBody `}` 1. Return InstantiateGeneratorFunctionObject
of `GeneratorDeclaration` with arguments env and privateEnv.
AsyncGeneratorDeclaration : `async` `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` `async` `function` `*` `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` 1. Return
InstantiateAsyncGeneratorFunctionObject of `AsyncGeneratorDeclaration`
with arguments env and privateEnv. AsyncFunctionDeclaration :
`async` `function` BindingIdentifier `(` FormalParameters `)`
`{` AsyncFunctionBody `}` `async` `function` `(`
FormalParameters `)` `{` AsyncFunctionBody `}` 1. Return
InstantiateAsyncFunctionObject of `AsyncFunctionDeclaration` with
arguments env and privateEnv.

Runtime Semantics: BindingInitialization ( value, environment: an Environment Record or `undefined`, )
------------------------------------------------------------------------------------------------------

`undefined` is passed for environment to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for `var` statements and formal parameter lists of some
non-strict functions (See ). In those cases a lexical binding is hoisted
and preinitialized prior to evaluation of its initializer.

BindingIdentifier : Identifier 1. Let name be the StringValue of
`Identifier`. 1. Return ? InitializeBoundName(name, value,
environment). BindingIdentifier : `yield` 1. Return ?
InitializeBoundName(`"yield"`, value, environment).
BindingIdentifier : `await` 1. Return ?
InitializeBoundName(`"await"`, value, environment).
BindingPattern : ObjectBindingPattern 1. Perform ?
RequireObjectCoercible(value). 1. Return ? BindingInitialization of
`ObjectBindingPattern` with arguments value and environment.
BindingPattern : ArrayBindingPattern 1. Let iteratorRecord be ?
GetIterator(value, ~sync~). 1. Let result be
Completion(IteratorBindingInitialization of `ArrayBindingPattern` with
arguments iteratorRecord and environment). 1. If
iteratorRecord.[[Done]] is `false`, return ?
IteratorClose(iteratorRecord, result). 1. Return ? result.
ObjectBindingPattern : `{` `}` 1. Return ~unused~.
ObjectBindingPattern : `{` BindingPropertyList `}` `{`
BindingPropertyList `,` `}` 1. Perform ?
PropertyBindingInitialization of `BindingPropertyList` with arguments
value and environment. 1. Return ~unused~. ObjectBindingPattern
: `{` BindingRestProperty `}` 1. Let excludedNames be a new
empty List. 1. Return ? RestBindingInitialization of
`BindingRestProperty` with arguments value, environment, and
excludedNames. ObjectBindingPattern : `{` BindingPropertyList
`,` BindingRestProperty `}` 1. Let excludedNames be ?
PropertyBindingInitialization of `BindingPropertyList` with arguments
value and environment. 1. Return ? RestBindingInitialization of
`BindingRestProperty` with arguments value, environment, and
excludedNames.

InitializeBoundName ( name: a String, value, environment: an Environment Record or `undefined`, )
-------------------------------------------------------------------------------------------------

1. If environment is not `undefined`, then 1. Perform !
environment.InitializeBinding(name, value). 1. Return
~unused~. 1. Else, 1. Let lhs be ? ResolveBinding(name). 1.
Return ? PutValue(lhs, value).

Runtime Semantics: IteratorBindingInitialization ( iteratorRecord: an Iterator Record, environment: an Environment Record or `undefined`, )
-------------------------------------------------------------------------------------------------------------------------------------------

When `undefined` is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

ArrayBindingPattern : `[` `]` 1. Return ~unused~.
ArrayBindingPattern : `[` Elision `]` 1. Return ?
IteratorDestructuringAssignmentEvaluation of `Elision` with argument
iteratorRecord. ArrayBindingPattern : `[` Elision?
BindingRestElement `]` 1. If `Elision` is present, then 1. Perform ?
IteratorDestructuringAssignmentEvaluation of `Elision` with argument
iteratorRecord. 1. Return ? IteratorBindingInitialization of
`BindingRestElement` with arguments iteratorRecord and
environment. ArrayBindingPattern : `[` BindingElementList `,`
Elision `]` 1. Perform ? IteratorBindingInitialization of
`BindingElementList` with arguments iteratorRecord and
environment. 1. Return ? IteratorDestructuringAssignmentEvaluation
of `Elision` with argument iteratorRecord. ArrayBindingPattern :
`[` BindingElementList `,` Elision? BindingRestElement `]` 1.
Perform ? IteratorBindingInitialization of `BindingElementList` with
arguments iteratorRecord and environment. 1. If `Elision` is
present, then 1. Perform ? IteratorDestructuringAssignmentEvaluation of
`Elision` with argument iteratorRecord. 1. Return ?
IteratorBindingInitialization of `BindingRestElement` with arguments
iteratorRecord and environment. BindingElementList :
BindingElementList `,` BindingElisionElement 1. Perform ?
IteratorBindingInitialization of `BindingElementList` with arguments
iteratorRecord and environment. 1. Return ?
IteratorBindingInitialization of `BindingElisionElement` with
arguments iteratorRecord and environment. BindingElisionElement
: Elision BindingElement 1. Perform ?
IteratorDestructuringAssignmentEvaluation of `Elision` with argument
iteratorRecord. 1. Return ? IteratorBindingInitialization of
`BindingElement` with arguments iteratorRecord and
environment. SingleNameBinding : BindingIdentifier Initializer? 1.
Let bindingId be the StringValue of `BindingIdentifier`. 1. Let
lhs be ? ResolveBinding(bindingId, environment). 1. Let
v be `undefined`. 1. If iteratorRecord.[[Done]] is `false`,
then 1. Let next be ? IteratorStepValue(iteratorRecord). 1. If
next is not ~done~, then 1. Set v to next. 1. If
`Initializer` is present and v is `undefined`, then 1. If
IsAnonymousFunctionDefinition(`Initializer`) is `true`, then 1. Set
v to ? NamedEvaluation of `Initializer` with argument
bindingId. 1. Else, 1. Let defaultValue be ? Evaluation of
`Initializer`. 1. Set v to ? GetValue(defaultValue). 1. If
environment is `undefined`, return ? PutValue(lhs, v). 1.
Return ? InitializeReferencedBinding(lhs, v). BindingElement :
BindingPattern Initializer? 1. Let v be `undefined`. 1. If
iteratorRecord.[[Done]] is `false`, then 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is not ~done~,
then 1. Set v to next. 1. If `Initializer` is present and
v is `undefined`, then 1. Let defaultValue be ? Evaluation of
`Initializer`. 1. Set v to ? GetValue(defaultValue). 1. Return
? BindingInitialization of `BindingPattern` with arguments v and
environment. BindingRestElement : `...` BindingIdentifier 1. Let
lhs be ? ResolveBinding(StringValue of `BindingIdentifier`,
environment). 1. Let A be ! ArrayCreate(0). 1. Let n be 0.
1. Repeat, 1. Let next be ~done~. 1. If iteratorRecord.[[Done]]
is `false`, then 1. Set next to ?
IteratorStepValue(iteratorRecord). 1. If next is ~done~, then 1.
If environment is `undefined`, return ? PutValue(lhs, A).
1. Return ? InitializeReferencedBinding(lhs, A). 1. Perform !
CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), next). 1. Set
n to n + 1. BindingRestElement : `...` BindingPattern 1. Let
A be ! ArrayCreate(0). 1. Let n be 0. 1. Repeat, 1. Let next
be ~done~. 1. If iteratorRecord.[[Done]] is `false`, then 1. Set
next to ? IteratorStepValue(iteratorRecord). 1. If next is
~done~, then 1. Return ? BindingInitialization of `BindingPattern`
with arguments A and environment. 1. Perform !
CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), next). 1. Set
n to n + 1. FormalParameters : [empty] 1. Return ~unused~.
FormalParameters : FormalParameterList `,` FunctionRestParameter 1.
Perform ? IteratorBindingInitialization of `FormalParameterList` with
arguments iteratorRecord and environment. 1. Return ?
IteratorBindingInitialization of `FunctionRestParameter` with
arguments iteratorRecord and environment. FormalParameterList :
FormalParameterList `,` FormalParameter 1. Perform ?
IteratorBindingInitialization of `FormalParameterList` with arguments
iteratorRecord and environment. 1. Return ?
IteratorBindingInitialization of `FormalParameter` with arguments
iteratorRecord and environment. ArrowParameters :
BindingIdentifier 1. Let v be `undefined`. 1. Assert:
iteratorRecord.[[Done]] is `false`. 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is not ~done~,
then 1. Set v to next. 1. Return ? BindingInitialization of
`BindingIdentifier` with arguments v and environment.
ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList 1.
Let formals be the `ArrowFormalParameters` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return ?
IteratorBindingInitialization of formals with arguments
iteratorRecord and environment. AsyncArrowBindingIdentifier :
BindingIdentifier 1. Let v be `undefined`. 1. Assert:
iteratorRecord.[[Done]] is `false`. 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is not ~done~,
then 1. Set v to next. 1. Return ? BindingInitialization of
`BindingIdentifier` with arguments v and environment.

Static Semantics: AssignmentTargetType ( ): ~simple~ or ~invalid~
-----------------------------------------------------------------

IdentifierReference : Identifier 1. If IsStrict(this
`IdentifierReference`) is `true` and the StringValue of
`Identifier` is either `"eval"` or `"arguments"`, return
~invalid~. 1. Return ~simple~. IdentifierReference : `yield` `await`
CallExpression : CallExpression `[` Expression `]` CallExpression
`.` IdentifierName CallExpression `.` PrivateIdentifier
MemberExpression : MemberExpression `[` Expression `]`
MemberExpression `.` IdentifierName SuperProperty MemberExpression
`.` PrivateIdentifier 1. Return ~simple~. PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList 1. Let expr be the
`ParenthesizedExpression` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return the
AssignmentTargetType of expr. PrimaryExpression : `this` Literal
ArrayLiteral ObjectLiteral FunctionExpression ClassExpression
GeneratorExpression AsyncFunctionExpression AsyncGeneratorExpression
RegularExpressionLiteral TemplateLiteral CallExpression :
CoverCallExpressionAndAsyncArrowHead SuperCall ImportCall CallExpression
Arguments CallExpression TemplateLiteral NewExpression : `new`
NewExpression MemberExpression : MemberExpression TemplateLiteral
`new` MemberExpression Arguments NewTarget : `new` `.` `target`
ImportMeta : `import` `.` `meta` LeftHandSideExpression :
OptionalExpression UpdateExpression : LeftHandSideExpression `++`
LeftHandSideExpression `--` `++` UnaryExpression `--`
UnaryExpression UnaryExpression : `delete` UnaryExpression `void`
UnaryExpression `typeof` UnaryExpression `+` UnaryExpression `-`
UnaryExpression `~` UnaryExpression `!` UnaryExpression
AwaitExpression ExponentiationExpression : UpdateExpression `**`
ExponentiationExpression MultiplicativeExpression :
MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression
AdditiveExpression `-` MultiplicativeExpression ShiftExpression :
ShiftExpression `<<` AdditiveExpression ShiftExpression `>>`
AdditiveExpression ShiftExpression `>>>` AdditiveExpression
RelationalExpression : RelationalExpression `<` ShiftExpression
RelationalExpression `>` ShiftExpression RelationalExpression `<=`
ShiftExpression RelationalExpression `>=` ShiftExpression
RelationalExpression `instanceof` ShiftExpression RelationalExpression
`in` ShiftExpression PrivateIdentifier `in` ShiftExpression
EqualityExpression : EqualityExpression `==` RelationalExpression
EqualityExpression `!=` RelationalExpression EqualityExpression
`===` RelationalExpression EqualityExpression `!==`
RelationalExpression BitwiseANDExpression : BitwiseANDExpression `&`
EqualityExpression BitwiseXORExpression : BitwiseXORExpression `^`
BitwiseANDExpression BitwiseORExpression : BitwiseORExpression `|`
BitwiseXORExpression LogicalANDExpression : LogicalANDExpression `&&`
BitwiseORExpression LogicalORExpression : LogicalORExpression `||`
LogicalANDExpression CoalesceExpression : CoalesceExpressionHead `??`
BitwiseORExpression ConditionalExpression : ShortCircuitExpression `?`
AssignmentExpression `:` AssignmentExpression AssignmentExpression :
YieldExpression ArrowFunction AsyncArrowFunction LeftHandSideExpression
`=` AssignmentExpression LeftHandSideExpression AssignmentOperator
AssignmentExpression LeftHandSideExpression `&&=` AssignmentExpression
LeftHandSideExpression `||=` AssignmentExpression
LeftHandSideExpression `??=` AssignmentExpression Expression :
Expression `,` AssignmentExpression 1. Return ~invalid~.

Static Semantics: PropName ( ): a String or ~empty~
---------------------------------------------------

PropertyDefinition : IdentifierReference 1. Return the StringValue of
`IdentifierReference`. PropertyDefinition : `...`
AssignmentExpression 1. Return ~empty~. PropertyDefinition :
PropertyName `:` AssignmentExpression 1. Return the PropName of
`PropertyName`. LiteralPropertyName : IdentifierName 1. Return the
StringValue of `IdentifierName`. LiteralPropertyName : StringLiteral
1. Return the SV of `StringLiteral`. LiteralPropertyName :
NumericLiteral 1. Let nbr be the NumericValue of `NumericLiteral`.
1. Return ! ToString(nbr). ComputedPropertyName : `[`
AssignmentExpression `]` 1. Return ~empty~. MethodDefinition :
ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody
`}` `get` ClassElementName `(` `)` `{` FunctionBody `}`
`set` ClassElementName `(` PropertySetParameterList `)` `{`
FunctionBody `}` 1. Return the PropName of `ClassElementName`.
GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters
`)` `{` GeneratorBody `}` 1. Return the PropName of
`ClassElementName`. AsyncGeneratorMethod : `async` `*`
ClassElementName `(` UniqueFormalParameters `)` `{`
AsyncGeneratorBody `}` 1. Return the PropName of `ClassElementName`.
ClassElement : ClassStaticBlock 1. Return ~empty~. ClassElement : `;`
1. Return ~empty~. AsyncMethod : `async` ClassElementName `(`
UniqueFormalParameters `)` `{` AsyncFunctionBody `}` 1. Return the
PropName of `ClassElementName`. FieldDefinition : ClassElementName
Initializer? 1. Return the PropName of `ClassElementName`.
ClassElementName : PrivateIdentifier 1. Return ~empty~.

9. Executable Code and Execution Contexts
=========================================

https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html
::

   9.1 Environment Records
      9.1.1 The Environment Record Type Hierarchy
      9.1.1.1 Declarative Environment Records
         9.1.1.1.1 HasBinding ( N )
         9.1.1.1.2 CreateMutableBinding ( N, D )
         9.1.1.1.3 CreateImmutableBinding ( N, S )
         9.1.1.1.4 InitializeBinding ( N, V )
         9.1.1.1.5 SetMutableBinding ( N, V, S )
         9.1.1.1.6 GetBindingValue ( N, S )
         9.1.1.1.7 DeleteBinding ( N )
         9.1.1.1.8 HasThisBinding ( )
         9.1.1.1.9 HasSuperBinding ( )
         9.1.1.1.10 WithBaseObject ( )
      9.1.1.2 Object Environment Records
         9.1.1.2.1 HasBinding ( N )
         9.1.1.2.2 CreateMutableBinding ( N, D )
         9.1.1.2.3 CreateImmutableBinding ( N, S )
         9.1.1.2.4 InitializeBinding ( N, V )
         9.1.1.2.5 SetMutableBinding ( N, V, S )
         9.1.1.2.6 GetBindingValue ( N, S )
         9.1.1.2.7 DeleteBinding ( N )
         9.1.1.2.8 HasThisBinding ( )
         9.1.1.2.9 HasSuperBinding ( )
         9.1.1.2.10 WithBaseObject ( )
      9.1.1.3 Function Environment Records
         9.1.1.3.1 BindThisValue ( V )
         9.1.1.3.2 HasThisBinding ( )
         9.1.1.3.3 HasSuperBinding ( )
         9.1.1.3.4 GetThisBinding ( )
         9.1.1.3.5 GetSuperBase ( )
      9.1.1.4 Global Environment Records
         9.1.1.4.1 HasBinding ( N )
         9.1.1.4.2 CreateMutableBinding ( N, D )
         9.1.1.4.3 CreateImmutableBinding ( N, S )
         9.1.1.4.4 InitializeBinding ( N, V )
         9.1.1.4.5 SetMutableBinding ( N, V, S )
         9.1.1.4.6 GetBindingValue ( N, S )
         9.1.1.4.7 DeleteBinding ( N )
         9.1.1.4.8 HasThisBinding ( )
         9.1.1.4.9 HasSuperBinding ( )
         9.1.1.4.10 WithBaseObject ( )
         9.1.1.4.11 GetThisBinding ( )
         9.1.1.4.12 HasVarDeclaration ( N )
         9.1.1.4.13 HasLexicalDeclaration ( N )
         9.1.1.4.14 HasRestrictedGlobalProperty ( N )
         9.1.1.4.15 CanDeclareGlobalVar ( N )
         9.1.1.4.16 CanDeclareGlobalFunction ( N )
         9.1.1.4.17 CreateGlobalVarBinding ( N, D )
         9.1.1.4.18 CreateGlobalFunctionBinding ( N, V, D )
      9.1.1.5 Module Environment Records
         9.1.1.5.1 GetBindingValue ( N, S )
         9.1.1.5.2 DeleteBinding ( N )
         9.1.1.5.3 HasThisBinding ( )
         9.1.1.5.4 GetThisBinding ( )
         9.1.1.5.5 CreateImportBinding ( N, M, N2 )
      9.1.2 Environment Record Operations
         9.1.2.1 GetIdentifierReference ( env, name, strict )
         9.1.2.2 NewDeclarativeEnvironment ( E )
         9.1.2.3 NewObjectEnvironment ( O, W, E )
         9.1.2.4 NewFunctionEnvironment ( F, newTarget )
         9.1.2.5 NewGlobalEnvironment ( G, thisValue )
         9.1.2.6 NewModuleEnvironment ( E )
   9.2 PrivateEnvironment Records
      9.2.1 PrivateEnvironment Record Operations
         9.2.1.1 NewPrivateEnvironment ( outerPrivateEnv )
         9.2.1.2 ResolvePrivateIdentifier ( privateEnv, identifier )
   9.3 Realms
      9.3.1 InitializeHostDefinedRealm ( )
      9.3.2 CreateIntrinsics ( realmRec )
      9.3.3 SetDefaultGlobalBindings ( realmRec )
   9.4 Execution Contexts
      9.4.1 GetActiveScriptOrModule ( )
      9.4.2 ResolveBinding ( name [ , env ] )
      9.4.3 GetThisEnvironment ( )
      9.4.4 ResolveThisBinding ( )
      9.4.5 GetNewTarget ( )
      9.4.6 GetGlobalObject ( )
   9.5 Jobs and Host Operations to Enqueue Jobs
      9.5.1 JobCallback Records
      9.5.2 HostMakeJobCallback ( callback )
      9.5.3 HostCallJobCallback ( jobCallback, V, argumentsList )
      9.5.4 HostEnqueueGenericJob ( job, realm )
      9.5.5 HostEnqueuePromiseJob ( job, realm )
      9.5.6 HostEnqueueTimeoutJob ( timeoutJob, realm, milliseconds )
   9.6 Agents
      9.6.1 AgentSignifier ( )
      9.6.2 AgentCanSuspend ( )
   9.7 Agent Clusters
   9.8 Forward Progress
   9.9 Processing Model of WeakRef and FinalizationRegistry Targets
      9.9.1 Objectives
      9.9.2 Liveness
      9.9.3 Execution
      9.9.4 Host Hooks
         9.9.4.1 HostEnqueueFinalizationRegistryCleanupJob ( finalizationRegistry )
   9.10 ClearKeptObjects ( )
   9.11 AddToKeptObjects ( value )
   9.12 CleanupFinalizationRegistry ( finalizationRegistry )
   9.13 CanBeHeldWeakly ( v )

Environment Records
-------------------

Environment Record is a specification type used to define the
association of \|Identifier|s to specific variables and functions, based
upon the lexical nesting structure of ECMAScript code. Usually an
Environment Record is associated with some specific syntactic structure
of ECMAScript code such as a `FunctionDeclaration`, a
`BlockStatement`, or a `Catch` clause of a `TryStatement`. Each
time such code is evaluated, a new Environment Record is created to
record the identifier bindings that are created by that code.

Every Environment Record has an [[OuterEnv]] field, which is either
`null` or a reference to an outer Environment Record. This is used to
model the logical nesting of Environment Record values. The outer
reference of an (inner) Environment Record is a reference to the
Environment Record that logically surrounds the inner Environment
Record. An outer Environment Record may, of course, have its own outer
Environment Record. An Environment Record may serve as the outer
environment for multiple inner Environment Records. For example, if a
`FunctionDeclaration` contains two nested \|FunctionDeclaration|s then
the Environment Records of each of the nested functions will have as
their outer Environment Record the Environment Record of the current
evaluation of the surrounding function.

Environment Records are purely specification mechanisms and need not
correspond to any specific artefact of an ECMAScript implementation. It
is impossible for an ECMAScript program to directly access or manipulate
such values.

The Environment Record Type Hierarchy
-------------------------------------

Environment Records can be thought of as existing in a simple
object-oriented hierarchy where Environment Record is an abstract class
with three concrete subclasses: Declarative Environment Record, Object
Environment Record, and Global Environment Record. Function Environment
Records and Module Environment Records are subclasses of Declarative
Environment Record.

- Environment Record (abstract)

  - A *Declarative Environment Record* is used to define the effect of
    ECMAScript language syntactic elements such as
    \|FunctionDeclaration|s, \|VariableDeclaration|s, and `Catch`
    clauses that directly associate identifier bindings with ECMAScript
    language values.

    - A *Function Environment Record* corresponds to the invocation of
      an ECMAScript function object, and contains bindings for the
      top-level declarations within that function. It may establish a
      new `this` binding. It also captures the state necessary to
      support `super` method invocations.

    - A *Module Environment Record* contains the bindings for the
      top-level declarations of a `Module`. It also contains the
      bindings that are explicitly imported by the `Module`. Its
      [[OuterEnv]] is a Global Environment Record.

  - An *Object Environment Record* is used to define the effect of
    ECMAScript elements such as `WithStatement` that associate
    identifier bindings with the properties of some object.

  - A *Global Environment Record* is used for `Script` global
    declarations. It does not have an outer environment; its
    [[OuterEnv]] is `null`. It may be prepopulated with identifier
    bindings and it includes an associated global object whose
    properties provide some of the global environment's identifier
    bindings. As ECMAScript code is executed, additional properties may
    be added to the global object and the initial properties may be
    modified.

The Environment Record abstract class includes the abstract
specification methods defined in . These abstract methods have distinct
concrete algorithms for each of the concrete subclasses.

+------------------------------+--------------------------------------+
| Method                       | Purpose                              |
+==============================+======================================+
| HasBinding(N)                | Determine if an Environment Record   |
|                              | has a binding for the String value   |
|                              | N. Return `true` if it does    |
|                              | and `false` if it does not.        |
+------------------------------+--------------------------------------+
| CreateMutableBinding(N, D)   | Create a new but uninitialized       |
|                              | mutable binding in an Environment    |
|                              | Record. The String value N is    |
|                              | the text of the bound name. If the   |
|                              | Boolean argument D is `true`   |
|                              | the binding may be subsequently      |
|                              | deleted.                             |
+------------------------------+--------------------------------------+
| CreateImmutableBinding(N, S) | Create a new but uninitialized       |
|                              | immutable binding in an Environment  |
|                              | Record. The String value N is    |
|                              | the text of the bound name. If S |
|                              | is `true` then attempts to set it  |
|                              | after it has been initialized will   |
|                              | always throw an exception,           |
|                              | regardless of the strict mode        |
|                              | setting of operations that reference |
|                              | that binding.                        |
+------------------------------+--------------------------------------+
| InitializeBinding(N, V)      | Set the value of an already existing |
|                              | but uninitialized binding in an      |
|                              | Environment Record. The String value |
|                              | N is the text of the bound name. |
|                              | V is the value for the binding   |
|                              | and is a value of any ECMAScript     |
|                              | language type.                       |
+------------------------------+--------------------------------------+
| SetMutableBinding(N, V, S)   | Set the value of an already existing |
|                              | mutable binding in an Environment    |
|                              | Record. The String value N is    |
|                              | the text of the bound name. V is |
|                              | the value for the binding and may be |
|                              | a value of any ECMAScript language   |
|                              | type. S is a Boolean flag. If    |
|                              | S is `true` and the binding    |
|                              | cannot be set throw a `TypeError`  |
|                              | exception.                           |
+------------------------------+--------------------------------------+
| GetBindingValue(N, S)        | Returns the value of an already      |
|                              | existing binding from an Environment |
|                              | Record. The String value N is    |
|                              | the text of the bound name. S is |
|                              | used to identify references          |
|                              | originating in strict mode code or   |
|                              | that otherwise require strict mode   |
|                              | reference semantics. If S is     |
|                              | `true` and the binding does not    |
|                              | exist throw a `ReferenceError`     |
|                              | exception. If the binding exists but |
|                              | is uninitialized a                   |
|                              | `ReferenceError` is thrown,        |
|                              | regardless of the value of S.    |
+------------------------------+--------------------------------------+
| DeleteBinding(N)             | Delete a binding from an Environment |
|                              | Record. The String value N is    |
|                              | the text of the bound name. If a     |
|                              | binding for N exists, remove the |
|                              | binding and return `true`. If the  |
|                              | binding exists but cannot be removed |
|                              | return `false`. If the binding     |
|                              | does not exist return `true`.      |
+------------------------------+--------------------------------------+
| HasThisBinding()             | Determine if an Environment Record   |
|                              | establishes a `this` binding.      |
|                              | Return `true` if it does and       |
|                              | `false` if it does not.            |
+------------------------------+--------------------------------------+
| HasSuperBinding()            | Determine if an Environment Record   |
|                              | establishes a `super` method       |
|                              | binding. Return `true` if it does  |
|                              | and `false` if it does not.        |
+------------------------------+--------------------------------------+
| WithBaseObject()             | If this Environment Record is        |
|                              | associated with a `with`           |
|                              | statement, return the with object.   |
|                              | Otherwise, return `undefined`.     |
+------------------------------+--------------------------------------+

Declarative Environment Records
-------------------------------

Each Declarative Environment Record is associated with an ECMAScript
program scope containing variable, constant, let, class, module, import,
and/or function declarations. A Declarative Environment Record binds the
set of identifiers defined by the declarations contained within its
scope.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

HasBinding ( N: a String, ): a normal completion containing a Boolean
-------------------------------------------------------------------------

for
   a Declarative Environment Record envRec
description
   It determines if the argument identifier is one of the identifiers
   bound by the record.

1. If envRec has a binding for N, return `true`. 1. Return
`false`.

CreateMutableBinding ( N: a String, D: a Boolean, ): a normal completion containing ~unused~
----------------------------------------------------------------------------------------------------

for
   a Declarative Environment Record envRec
description
   It creates a new mutable binding for the name N that is
   uninitialized. A binding must not already exist in this Environment
   Record for N. If D is `true`, the new binding is marked as
   being subject to deletion.

1. Assert: envRec does not already have a binding for N. 1.
Create a mutable binding in envRec for N and record that it is
uninitialized. If D is `true`, record that the newly created
binding may be deleted by a subsequent DeleteBinding call. 1. Return
~unused~.

CreateImmutableBinding ( N: a String, S: a Boolean, ): a normal completion containing ~unused~
------------------------------------------------------------------------------------------------------

for
   a Declarative Environment Record envRec
description
   It creates a new immutable binding for the name N that is
   uninitialized. A binding must not already exist in this Environment
   Record for N. If S is `true`, the new binding is marked as
   a strict binding.

1. Assert: envRec does not already have a binding for N. 1.
Create an immutable binding in envRec for N and record that it
is uninitialized. If S is `true`, record that the newly created
binding is a strict binding. 1. Return ~unused~.

InitializeBinding ( N: a String, V, ): a normal completion containing ~unused~
--------------------------------------------------------------------------------------------------------------------

for
   a Declarative Environment Record envRec
description
   It is used to set the bound value of the current binding of the
   identifier whose name is N to the value V. An uninitialized
   binding for N must already exist.

1. Assert: envRec must have an uninitialized binding for N. 1.
Set the bound value for N in envRec to V. 1. Record that the
binding for N in envRec has been initialized. 1. Return
~unused~.

SetMutableBinding ( N: a String, V, S: a Boolean, )
---------------------------------------------------

for
   a Declarative Environment Record envRec
description
   It attempts to change the bound value of the current binding of the
   identifier whose name is N to the value V. A binding for
   N normally already exists, but in rare cases it may not. If the
   binding is an immutable binding, a `TypeError` is thrown if S
   is `true`.

1. [id="step-setmutablebinding-missing-binding"] If envRec does not
have a binding for N, then 1. If S is `true`, throw a
`ReferenceError` exception. 1. Perform !
envRec.CreateMutableBinding(N, `true`). 1. Perform !
envRec.InitializeBinding(N, V). 1. Return ~unused~. 1. If
the binding for N in envRec is a strict binding, set S to
`true`. 1. If the binding for N in envRec has not yet been
initialized, then 1. Throw a `ReferenceError` exception. 1. Else if
the binding for N in envRec is a mutable binding, then 1. Change
its bound value to V. 1. Else, 1. Assert: This is an attempt to
change the value of an immutable binding. 1. If S is `true`, throw
a `TypeError` exception. 1. Return ~unused~.

An example of ECMAScript code that results in a missing binding at step
is:

.. code:: javascript

   function f() { eval("var x; x = (delete x, 0);"); }

GetBindingValue ( N: a String, S: a Boolean, )
----------------------------------------------

for
   a Declarative Environment Record envRec
description
   It returns the value of its bound identifier whose name is N. If
   the binding exists but is uninitialized a `ReferenceError` is
   thrown, regardless of the value of S.

1. Assert: envRec has a binding for N. 1. If the binding for
N in envRec is an uninitialized binding, throw a
`ReferenceError` exception. 1. Return the value currently bound to
N in envRec.

DeleteBinding ( N: a String, ): a normal completion containing a Boolean
----------------------------------------------------------------------------

for
   a Declarative Environment Record envRec
description
   It can only delete bindings that have been explicitly designated as
   being subject to deletion.

1. Assert: envRec has a binding for N. 1. If the binding for
N in envRec cannot be deleted, return `false`. 1. Remove the
binding for N from envRec. 1. Return `true`.

HasThisBinding ( ): `false`
-----------------------------

for
   a Declarative Environment Record envRec

1. Return `false`.

A regular Declarative Environment Record (i.e., one that is neither a
Function Environment Record nor a Module Environment Record) does not
provide a `this` binding.

HasSuperBinding ( ): `false`
------------------------------

for
   a Declarative Environment Record envRec

1. Return `false`.

A regular Declarative Environment Record (i.e., one that is neither a
Function Environment Record nor a Module Environment Record) does not
provide a `super` binding.

WithBaseObject ( ): `undefined`
---------------------------------

for
   a Declarative Environment Record envRec

1. Return `undefined`.

Object Environment Records
--------------------------

Each Object Environment Record is associated with an object called its
*binding object*. An Object Environment Record binds the set of string
identifier names that directly correspond to the property names of its
binding object. Property keys that are not strings in the form of an
`IdentifierName` are not included in the set of bound identifiers.
Both own and inherited properties are included in the set regardless of
the setting of their [[Enumerable]] attribute. Because properties can be
dynamically added and deleted from objects, the set of identifiers bound
by an Object Environment Record may potentially change as a side-effect
of any operation that adds or deletes properties. Any bindings that are
created as a result of such a side-effect are considered to be a mutable
binding even if the Writable attribute of the corresponding property is
`false`. Immutable bindings do not exist for Object Environment
Records.

Object Environment Records created for `with` statements () can
provide their binding object as an implicit `this` value for use in
function calls. The capability is controlled by a Boolean
[[IsWithEnvironment]] field.

Object Environment Records have the additional state fields listed in .

+-----------------------+-----------+---------------------------+
| Field Name            | Value     | Meaning                   |
+=======================+===========+===========================+
| [[BindingObject]]     | an Object | The binding object of     |
|                       |           | this Environment Record.  |
+-----------------------+-----------+---------------------------+
| [[IsWithEnvironment]] | a Boolean | Indicates whether this    |
|                       |           | Environment Record is     |
|                       |           | created for a `with`    |
|                       |           | statement.                |
+-----------------------+-----------+---------------------------+

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

HasBinding ( N: a String, )
---------------------------

for
   an Object Environment Record envRec
description
   It determines if its associated binding object has a property whose
   name is N.

1. Let bindingObject be envRec.[[BindingObject]]. 1. Let
foundBinding be ? HasProperty(bindingObject, N). 1. If
foundBinding is `false`, return `false`. 1. If
envRec.[[IsWithEnvironment]] is `false`, return `true`. 1. Let
unscopables be ? Get(bindingObject, %Symbol.unscopables%). 1. If
unscopables is an Object, then 1. Let blocked be ToBoolean(?
Get(unscopables, N)). 1. If blocked is `true`, return
`false`. 1. Return `true`.

CreateMutableBinding ( N: a String, D: a Boolean, )
---------------------------------------------------

for
   an Object Environment Record envRec
description
   It creates in an Environment Record's associated binding object a
   property whose name is N and initializes it to the value
   `undefined`. If D is `true`, the new property's
   [[Configurable]] attribute is set to `true`; otherwise it is set to
   `false`.

1. Let bindingObject be envRec.[[BindingObject]]. 1. Perform ?
DefinePropertyOrThrow(bindingObject, N, PropertyDescriptor {
[[Value]]: `undefined`, [[Writable]]: `true`, [[Enumerable]]:
`true`, [[Configurable]]: D }). 1. Return ~unused~.

Normally envRec will not have a binding for N but if it does,
the semantics of DefinePropertyOrThrow may result in an existing binding
being replaced or shadowed or cause an abrupt completion to be returned.

CreateImmutableBinding ( N, S )
---------------------------------------

The CreateImmutableBinding concrete method of an Object Environment
Record is never used within this specification.

InitializeBinding ( N: a String, V, )
-------------------------------------

for
   an Object Environment Record envRec
description
   It is used to set the bound value of the current binding of the
   identifier whose name is N to the value V.

1. Perform ? envRec.SetMutableBinding(N, V, `false`). 1.
Return ~unused~.

In this specification, all uses of CreateMutableBinding for Object
Environment Records are immediately followed by a call to
InitializeBinding for the same name. Hence, this specification does not
explicitly track the initialization state of bindings in Object
Environment Records.

.. _setmutablebinding-_n_-a-string-_v_-an-ecmascript-language-value-_s_-a-boolean-either-a-normal-completion-containing-unused-or-a-throw-completion-1:

SetMutableBinding ( N: a String, V, S: a Boolean, )
---------------------------------------------------

for
   an Object Environment Record envRec
description
   It attempts to set the value of the Environment Record's associated
   binding object's property whose name is N to the value V. A
   property named N normally already exists but if it does not or is
   not currently writable, error handling is determined by S.

1. Let bindingObject be envRec.[[BindingObject]]. 1. Let
stillExists be ? HasProperty(bindingObject, N). 1. If
stillExists is `false` and S is `true`, throw a
`ReferenceError` exception. 1. Perform ? Set(bindingObject, N,
V, S). 1. Return ~unused~.

.. _getbindingvalue-_n_-a-string-_s_-a-boolean-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-1:

GetBindingValue ( N: a String, S: a Boolean, )
----------------------------------------------

for
   an Object Environment Record envRec
description
   It returns the value of its associated binding object's property
   whose name is N. The property should already exist but if it does
   not the result depends upon S.

1. Let bindingObject be envRec.[[BindingObject]]. 1. Let
value be ? HasProperty(bindingObject, N). 1. If value is
`false`, then 1. If S is `false`, return `undefined`;
otherwise throw a `ReferenceError` exception. 1. Return ?
Get(bindingObject, N).

DeleteBinding ( N: a String, )
------------------------------

for
   an Object Environment Record envRec
description
   It can only delete bindings that correspond to properties of the
   environment object whose [[Configurable]] attribute have the value
   `true`.

1. Let bindingObject be envRec.[[BindingObject]]. 1. Return ?
bindingObject.[[Delete]](N).

.. _hasthisbinding-false-1:

HasThisBinding ( ): `false`
-----------------------------

for
   an Object Environment Record envRec

1. Return `false`.

Object Environment Records do not provide a `this` binding.

.. _hassuperbinding-false-1:

HasSuperBinding ( ): `false`
------------------------------

for
   an Object Environment Record envRec

1. Return `false`.

Object Environment Records do not provide a `super` binding.

WithBaseObject ( ): an Object or `undefined`
----------------------------------------------

for
   an Object Environment Record envRec

1. If envRec.[[IsWithEnvironment]] is `true`, return
envRec.[[BindingObject]]. 1. Otherwise, return `undefined`.

Function Environment Records
----------------------------

A Function Environment Record is a Declarative Environment Record that
is used to represent the top-level scope of a function and, if the
function is not an `ArrowFunction`, provides a `this` binding. If a
function is not an `ArrowFunction` function and references `super`,
its Function Environment Record also contains the state that is used to
perform `super` method invocations from within the function.

Function Environment Records have the additional state fields listed in
.

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[ThisValue]]        | an ECMAScript        | This is the `this` |
|                      | language value       | value used for this  |
|                      |                      | invocation of the    |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+
| [                    | ~lexical~,           | If the value is      |
| [ThisBindingStatus]] | ~initialized~, or    | ~lexical~, this is   |
|                      | ~uninitialized~      | an `ArrowFunction` |
|                      |                      | and does not have a  |
|                      |                      | local `this`       |
|                      |                      | value.               |
+----------------------+----------------------+----------------------+
| [[FunctionObject]]   | an ECMAScript        | The function object  |
|                      | function object      | whose invocation     |
|                      |                      | caused this          |
|                      |                      | Environment Record   |
|                      |                      | to be created.       |
+----------------------+----------------------+----------------------+
| [[NewTarget]]        | an Object or         | If this Environment  |
|                      | `undefined`        | Record was created   |
|                      |                      | by the [[Construct]] |
|                      |                      | internal method,     |
|                      |                      | [[NewTarget]] is the |
|                      |                      | value of the         |
|                      |                      | [[Construct]]        |
|                      |                      | newTarget        |
|                      |                      | parameter.           |
|                      |                      | Otherwise, its value |
|                      |                      | is `undefined`.    |
+----------------------+----------------------+----------------------+

Function Environment Records support all of the Declarative Environment
Record methods listed in and share the same specifications for all of
those methods except for HasThisBinding and HasSuperBinding. In
addition, Function Environment Records support the methods listed in :

+------------------+--------------------------------------------------+
| Method           | Purpose                                          |
+==================+==================================================+
| BindThisValue(V) | Set the [[ThisValue]] and record that it has     |
|                  | been initialized.                                |
+------------------+--------------------------------------------------+
| GetThisBinding() | Return the value of this Environment Record's    |
|                  | `this` binding. Throws a `ReferenceError` if |
|                  | the `this` binding has not been initialized.   |
+------------------+--------------------------------------------------+
| GetSuperBase()   | Return the object that is the base for `super` |
|                  | property accesses bound in this Environment      |
|                  | Record. The value `undefined` indicates that   |
|                  | such accesses will produce runtime errors.       |
+------------------+--------------------------------------------------+

The behaviour of the additional concrete specification methods for
Function Environment Records is defined by the following algorithms:

BindThisValue ( V, )
--------------------

for
   a Function Environment Record envRec

1. Assert: envRec.[[ThisBindingStatus]] is not ~lexical~. 1. If
envRec.[[ThisBindingStatus]] is ~initialized~, throw a
`ReferenceError` exception. 1. Set envRec.[[ThisValue]] to V.
1. Set envRec.[[ThisBindingStatus]] to ~initialized~. 1. Return
V.

HasThisBinding ( ): a Boolean
-----------------------------

for
   a Function Environment Record envRec

1. If envRec.[[ThisBindingStatus]] is ~lexical~, return `false`;
otherwise, return `true`.

HasSuperBinding ( ): a Boolean
------------------------------

for
   a Function Environment Record envRec

1. If envRec.[[ThisBindingStatus]] is ~lexical~, return `false`.
1. If envRec.[[FunctionObject]].[[HomeObject]] is `undefined`,
return `false`; otherwise, return `true`.

GetThisBinding ( )
------------------

for
   a Function Environment Record envRec

1. Assert: envRec.[[ThisBindingStatus]] is not ~lexical~. 1. If
envRec.[[ThisBindingStatus]] is ~uninitialized~, throw a
`ReferenceError` exception. 1. Return envRec.[[ThisValue]].

GetSuperBase ( ): an Object, `null`, or `undefined`
-------------------------------------------------------

for
   a Function Environment Record envRec

1. Let home be envRec.[[FunctionObject]].[[HomeObject]]. 1. If
home is `undefined`, return `undefined`. 1. Assert: home is
an ordinary object. 1. Return ! home.[[GetPrototypeOf]]().

Global Environment Records
--------------------------

A Global Environment Record is used to represent the outer most scope
that is shared by all of the ECMAScript `Script` elements that are
processed in a common realm. A Global Environment Record provides the
bindings for built-in globals (clause ), properties of the global
object, and for all top-level declarations (, ) that occur within a
`Script`.

A Global Environment Record is logically a single record but it is
specified as a composite encapsulating an Object Environment Record and
a Declarative Environment Record. The Object Environment Record has as
its base object the global object of the associated Realm Record. This
global object is the value returned by the Global Environment Record's
GetThisBinding concrete method. The Object Environment Record component
of a Global Environment Record contains the bindings for all built-in
globals (clause ) and all bindings introduced by a
`FunctionDeclaration`, `GeneratorDeclaration`,
`AsyncFunctionDeclaration`, `AsyncGeneratorDeclaration`, or
`VariableStatement` contained in global code. The bindings for all
other ECMAScript declarations in global code are contained in the
Declarative Environment Record component of the Global Environment
Record.

Properties may be created directly on a global object. Hence, the Object
Environment Record component of a Global Environment Record may contain
both bindings created explicitly by `FunctionDeclaration`,
`GeneratorDeclaration`, `AsyncFunctionDeclaration`,
`AsyncGeneratorDeclaration`, or `VariableDeclaration` declarations
and bindings created implicitly as properties of the global object. In
order to identify which bindings were explicitly created using
declarations, a Global Environment Record maintains a list of the names
bound using its CreateGlobalVarBinding and CreateGlobalFunctionBinding
concrete methods.

Global Environment Records have the additional fields listed in and the
additional methods listed in .

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[ObjectRecord]]     | an Object            | Binding object is    |
|                      | Environment Record   | the global object.   |
|                      |                      | It contains global   |
|                      |                      | built-in bindings as |
|                      |                      | well as              |
|                      |                      | \|Fu                 |
|                      |                      | nctionDeclaration\|, |
|                      |                      | \|Gen                |
|                      |                      | eratorDeclaration\|, |
|                      |                      | \|AsyncFu            |
|                      |                      | nctionDeclaration\|, |
|                      |                      | \|AsyncGen           |
|                      |                      | eratorDeclaration\|, |
|                      |                      | and                  |
|                      |                      | \|V                  |
|                      |                      | ariableDeclaration\| |
|                      |                      | bindings in global   |
|                      |                      | code for the         |
|                      |                      | associated realm.    |
+----------------------+----------------------+----------------------+
| [[GlobalThisValue]]  | an Object            | The value returned   |
|                      |                      | by `this` in       |
|                      |                      | global scope. Hosts  |
|                      |                      | may provide any      |
|                      |                      | ECMAScript Object    |
|                      |                      | value.               |
+----------------------+----------------------+----------------------+
| [                    | a Declarative        | Contains bindings    |
| [DeclarativeRecord]] | Environment Record   | for all declarations |
|                      |                      | in global code for   |
|                      |                      | the associated realm |
|                      |                      | code except for      |
|                      |                      | \|Fu                 |
|                      |                      | nctionDeclaration\|, |
|                      |                      | \|Gen                |
|                      |                      | eratorDeclaration\|, |
|                      |                      | \|AsyncFu            |
|                      |                      | nctionDeclaration\|, |
|                      |                      | \|AsyncGen           |
|                      |                      | eratorDeclaration\|, |
|                      |                      | and                  |
|                      |                      | \|V                  |
|                      |                      | ariableDeclaration\| |
|                      |                      | bindings.            |
+----------------------+----------------------+----------------------+
| [[VarNames]]         | a List of Strings    | The string names     |
|                      |                      | bound by             |
|                      |                      | \|Fu                 |
|                      |                      | nctionDeclaration\|, |
|                      |                      | \|Gen                |
|                      |                      | eratorDeclaration\|, |
|                      |                      | \|AsyncFu            |
|                      |                      | nctionDeclaration\|, |
|                      |                      | \|AsyncGen           |
|                      |                      | eratorDeclaration\|, |
|                      |                      | and                  |
|                      |                      | \|V                  |
|                      |                      | ariableDeclaration\| |
|                      |                      | declarations in      |
|                      |                      | global code for the  |
|                      |                      | associated realm.    |
+----------------------+----------------------+----------------------+

+----------------------------------+----------------------------------+
| Method                           | Purpose                          |
+==================================+==================================+
| GetThisBinding()                 | Return the value of this         |
|                                  | Environment Record's `this`    |
|                                  | binding.                         |
+----------------------------------+----------------------------------+
| HasVarDeclaration (N)            | Determines if the argument       |
|                                  | identifier has a binding in this |
|                                  | Environment Record that was      |
|                                  | created using a                  |
|                                  | `VariableDeclaration`,         |
|                                  | `FunctionDeclaration`,         |
|                                  | `GeneratorDeclaration`,        |
|                                  | `AsyncFunctionDeclaration`, or |
|                                  | `AsyncGeneratorDeclaration`.   |
+----------------------------------+----------------------------------+
| HasLexicalDeclaration (N)        | Determines if the argument       |
|                                  | identifier has a binding in this |
|                                  | Environment Record that was      |
|                                  | created using a lexical          |
|                                  | declaration such as a            |
|                                  | `LexicalDeclaration` or a      |
|                                  | `ClassDeclaration`.            |
+----------------------------------+----------------------------------+
| HasRestrictedGlobalProperty (N)  | Determines if the argument is    |
|                                  | the name of a global object      |
|                                  | property that may not be         |
|                                  | shadowed by a global lexical     |
|                                  | binding.                         |
+----------------------------------+----------------------------------+
| CanDeclareGlobalVar (N)          | Determines if a corresponding    |
|                                  | CreateGlobalVarBinding call      |
|                                  | would succeed if called for the  |
|                                  | same argument N.             |
+----------------------------------+----------------------------------+
| CanDeclareGlobalFunction (N)     | Determines if a corresponding    |
|                                  | CreateGlobalFunctionBinding call |
|                                  | would succeed if called for the  |
|                                  | same argument N.             |
+----------------------------------+----------------------------------+
| CreateGlobalVarBinding(N, D)     | Used to create and initialize to |
|                                  | `undefined` a global `var`   |
|                                  | binding in the [[ObjectRecord]]  |
|                                  | component of a Global            |
|                                  | Environment Record. The binding  |
|                                  | will be a mutable binding. The   |
|                                  | corresponding global object      |
|                                  | property will have attribute     |
|                                  | values appropriate for a         |
|                                  | `var`. The String value N  |
|                                  | is the bound name. If D is   |
|                                  | `true`, the binding may be     |
|                                  | deleted. Logically equivalent to |
|                                  | CreateMutableBinding followed by |
|                                  | a SetMutableBinding but it       |
|                                  | allows var declarations to       |
|                                  | receive special treatment.       |
+----------------------------------+----------------------------------+
| CreateGlobalFunctionBinding(N,   | Create and initialize a global   |
| V, D)                            | `function` binding in the      |
|                                  | [[ObjectRecord]] component of a  |
|                                  | Global Environment Record. The   |
|                                  | binding will be a mutable        |
|                                  | binding. The corresponding       |
|                                  | global object property will have |
|                                  | attribute values appropriate for |
|                                  | a `function`. The String value |
|                                  | N is the bound name. V   |
|                                  | is the initialization value. If  |
|                                  | the Boolean argument D is    |
|                                  | `true`, the binding may be     |
|                                  | deleted. Logically equivalent to |
|                                  | CreateMutableBinding followed by |
|                                  | a SetMutableBinding but it       |
|                                  | allows function declarations to  |
|                                  | receive special treatment.       |
+----------------------------------+----------------------------------+

The behaviour of the concrete specification methods for Global
Environment Records is defined by the following algorithms.

.. _hasbinding-_n_-a-string-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-1:

HasBinding ( N: a String, )
---------------------------

for
   a Global Environment Record envRec
description
   It determines if the argument identifier is one of the identifiers
   bound by the record.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. If !
DclRec.HasBinding(N) is `true`, return `true`. 1. Let
ObjRec be envRec.[[ObjectRecord]]. 1. Return ?
ObjRec.HasBinding(N).

.. _createmutablebinding-_n_-a-string-_d_-a-boolean-either-a-normal-completion-containing-unused-or-a-throw-completion-1:

CreateMutableBinding ( N: a String, D: a Boolean, )
---------------------------------------------------

for
   a Global Environment Record envRec
description
   It creates a new mutable binding for the name N that is
   uninitialized. The binding is created in the associated
   DeclarativeRecord. A binding for N must not already exist in the
   DeclarativeRecord. If D is `true`, the new binding is marked as
   being subject to deletion.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. If !
DclRec.HasBinding(N) is `true`, throw a `TypeError`
exception. 1. Return ! DclRec.CreateMutableBinding(N, D).

CreateImmutableBinding ( N: a String, S: a Boolean, )
-----------------------------------------------------

for
   a Global Environment Record envRec
description
   It creates a new immutable binding for the name N that is
   uninitialized. A binding must not already exist in this Environment
   Record for N. If S is `true`, the new binding is marked as
   a strict binding.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. If !
DclRec.HasBinding(N) is `true`, throw a `TypeError`
exception. 1. Return ! DclRec.CreateImmutableBinding(N, S).

.. _initializebinding-_n_-a-string-_v_-an-ecmascript-language-value-either-a-normal-completion-containing-unused-or-a-throw-completion-1:

InitializeBinding ( N: a String, V, )
-------------------------------------

for
   a Global Environment Record envRec
description
   It is used to set the bound value of the current binding of the
   identifier whose name is N to the value V. An uninitialized
   binding for N must already exist.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. If !
DclRec.HasBinding(N) is `true`, then 1. Return !
DclRec.InitializeBinding(N, V). 1. Assert: If the binding
exists, it must be in the Object Environment Record. 1. Let ObjRec
be envRec.[[ObjectRecord]]. 1. Return ?
ObjRec.InitializeBinding(N, V).

.. _setmutablebinding-_n_-a-string-_v_-an-ecmascript-language-value-_s_-a-boolean-either-a-normal-completion-containing-unused-or-a-throw-completion-2:

SetMutableBinding ( N: a String, V, S: a Boolean, )
---------------------------------------------------

for
   a Global Environment Record envRec
description
   It attempts to change the bound value of the current binding of the
   identifier whose name is N to the value V. If the binding is
   an immutable binding and S is `true`, a `TypeError` is
   thrown. A property named N normally already exists but if it does
   not or is not currently writable, error handling is determined by
   S.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. If !
DclRec.HasBinding(N) is `true`, then 1. Return ?
DclRec.SetMutableBinding(N, V, S). 1. Let ObjRec be
envRec.[[ObjectRecord]]. 1. Return ?
ObjRec.SetMutableBinding(N, V, S).

.. _getbindingvalue-_n_-a-string-_s_-a-boolean-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-2:

GetBindingValue ( N: a String, S: a Boolean, )
----------------------------------------------

for
   a Global Environment Record envRec
description
   It returns the value of its bound identifier whose name is N. If
   the binding is an uninitialized binding throw a `ReferenceError`
   exception. A property named N normally already exists but if it
   does not or is not currently writable, error handling is determined
   by S.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. If !
DclRec.HasBinding(N) is `true`, then 1. Return ?
DclRec.GetBindingValue(N, S). 1. Let ObjRec be
envRec.[[ObjectRecord]]. 1. Return ?
ObjRec.GetBindingValue(N, S).

.. _deletebinding-_n_-a-string-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-1:

DeleteBinding ( N: a String, )
------------------------------

for
   a Global Environment Record envRec
description
   It can only delete bindings that have been explicitly designated as
   being subject to deletion.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. If !
DclRec.HasBinding(N) is `true`, then 1. Return !
DclRec.DeleteBinding(N). 1. Let ObjRec be
envRec.[[ObjectRecord]]. 1. Let globalObject be
ObjRec.[[BindingObject]]. 1. Let existingProp be ?
HasOwnProperty(globalObject, N). 1. If existingProp is
`true`, then 1. Let status be ? ObjRec.DeleteBinding(N).
1. If status is `true` and envRec.[[VarNames]] contains N,
then 1. Remove N from envRec.[[VarNames]]. 1. Return status.
1. Return `true`.

HasThisBinding ( ): `true`
----------------------------

for
   a Global Environment Record envRec

1. Return `true`.

Global Environment Records always provide a `this` binding.

.. _hassuperbinding-false-2:

HasSuperBinding ( ): `false`
------------------------------

for
   a Global Environment Record envRec

1. Return `false`.

Global Environment Records do not provide a `super` binding.

.. _withbaseobject-undefined-1:

WithBaseObject ( ): `undefined`
---------------------------------

for
   a Global Environment Record envRec

1. Return `undefined`.

GetThisBinding ( ): a normal completion containing an Object
------------------------------------------------------------

for
   a Global Environment Record envRec

1. Return envRec.[[GlobalThisValue]].

HasVarDeclaration ( N: a String, ): a Boolean
-------------------------------------------------

for
   a Global Environment Record envRec
description
   It determines if the argument identifier has a binding in this record
   that was created using a `VariableStatement` or a
   `FunctionDeclaration`.

1. Let varDeclaredNames be envRec.[[VarNames]]. 1. If
varDeclaredNames contains N, return `true`. 1. Return
`false`.

HasLexicalDeclaration ( N: a String, ): a Boolean
-----------------------------------------------------

for
   a Global Environment Record envRec
description
   It determines if the argument identifier has a binding in this record
   that was created using a lexical declaration such as a
   `LexicalDeclaration` or a `ClassDeclaration`.

1. Let DclRec be envRec.[[DeclarativeRecord]]. 1. Return !
DclRec.HasBinding(N).

HasRestrictedGlobalProperty ( N: a String, )
--------------------------------------------

for
   a Global Environment Record envRec
description
   It determines if the argument identifier is the name of a property of
   the global object that must not be shadowed by a global lexical
   binding.

1. Let ObjRec be envRec.[[ObjectRecord]]. 1. Let
globalObject be ObjRec.[[BindingObject]]. 1. Let
existingProp be ? globalObject.[[GetOwnProperty]](N). 1. If
existingProp is `undefined`, return `false`. 1. If
existingProp.[[Configurable]] is `true`, return `false`. 1.
Return `true`.

Properties may exist upon a global object that were directly created
rather than being declared using a var or function declaration. A global
lexical binding may not be created that has the same name as a
non-configurable property of the global object. The global property
`"undefined"` is an example of such a property.

CanDeclareGlobalVar ( N: a String, )
------------------------------------

for
   a Global Environment Record envRec
description
   It determines if a corresponding CreateGlobalVarBinding call would
   succeed if called for the same argument N. Redundant var
   declarations and var declarations for pre-existing global object
   properties are allowed.

1. Let ObjRec be envRec.[[ObjectRecord]]. 1. Let
globalObject be ObjRec.[[BindingObject]]. 1. Let hasProperty
be ? HasOwnProperty(globalObject, N). 1. If hasProperty is
`true`, return `true`. 1. Return ? IsExtensible(globalObject).

CanDeclareGlobalFunction ( N: a String, )
-----------------------------------------

for
   a Global Environment Record envRec
description
   It determines if a corresponding CreateGlobalFunctionBinding call
   would succeed if called for the same argument N.

1. Let ObjRec be envRec.[[ObjectRecord]]. 1. Let
globalObject be ObjRec.[[BindingObject]]. 1. Let
existingProp be ? globalObject.[[GetOwnProperty]](N). 1. If
existingProp is `undefined`, return ?
IsExtensible(globalObject). 1. If existingProp.[[Configurable]]
is `true`, return `true`. 1. If IsDataDescriptor(existingProp)
is `true` and existingProp has attribute values { [[Writable]]:
`true`, [[Enumerable]]: `true` }, return `true`. 1. Return
`false`.

CreateGlobalVarBinding ( N: a String, D: a Boolean, )
-----------------------------------------------------

for
   a Global Environment Record envRec
description
   It creates and initializes a mutable binding in the associated Object
   Environment Record and records the bound name in the associated
   [[VarNames]] List. If a binding already exists, it is reused and
   assumed to be initialized.

1. Let ObjRec be envRec.[[ObjectRecord]]. 1. Let
globalObject be ObjRec.[[BindingObject]]. 1. Let hasProperty
be ? HasOwnProperty(globalObject, N). 1. Let extensible be ?
IsExtensible(globalObject). 1. If hasProperty is `false` and
extensible is `true`, then 1. Perform ?
ObjRec.CreateMutableBinding(N, D). 1. Perform ?
ObjRec.InitializeBinding(N, `undefined`). 1. If
envRec.[[VarNames]] does not contain N, then 1. Append N to
envRec.[[VarNames]]. 1. Return ~unused~.

CreateGlobalFunctionBinding ( N: a String, V, D: a Boolean, )
-------------------------------------------------------------

for
   a Global Environment Record envRec
description
   It creates and initializes a mutable binding in the associated Object
   Environment Record and records the bound name in the associated
   [[VarNames]] List. If a binding already exists, it is replaced.

1. Let ObjRec be envRec.[[ObjectRecord]]. 1. Let
globalObject be ObjRec.[[BindingObject]]. 1. Let
existingProp be ? globalObject.[[GetOwnProperty]](N). 1. If
existingProp is `undefined` or existingProp.[[Configurable]]
is `true`, then 1. Let desc be the PropertyDescriptor { [[Value]]:
V, [[Writable]]: `true`, [[Enumerable]]: `true`,
[[Configurable]]: D }. 1. Else, 1. Let desc be the
PropertyDescriptor { [[Value]]: V }. 1. Perform ?
DefinePropertyOrThrow(globalObject, N, desc). 1.
[id="step-createglobalfunctionbinding-set"] Perform ?
Set(globalObject, N, V, `false`). 1. If
envRec.[[VarNames]] does not contain N, then 1. Append N to
envRec.[[VarNames]]. 1. Return ~unused~.

Global function declarations are always represented as own properties of
the global object. If possible, an existing own property is reconfigured
to have a standard set of attribute values. Step is equivalent to what
calling the InitializeBinding concrete method would do and if
globalObject is a Proxy will produce the same sequence of Proxy trap
calls.

Module Environment Records
--------------------------

A Module Environment Record is a Declarative Environment Record that is
used to represent the outer scope of an ECMAScript `Module`. In
additional to normal mutable and immutable bindings, Module Environment
Records also provide immutable import bindings which are bindings that
provide indirect access to a target binding that exists in another
Environment Record.

Module Environment Records support all of the Declarative Environment
Record methods listed in and share the same specifications for all of
those methods except for GetBindingValue, DeleteBinding, HasThisBinding
and GetThisBinding. In addition, Module Environment Records support the
methods listed in :

+-------------------------------+-------------------------------------+
| Method                        | Purpose                             |
+===============================+=====================================+
| CreateImportBinding(N, M, N2) | Create an immutable indirect        |
|                               | binding in a Module Environment     |
|                               | Record. The String value N is   |
|                               | the text of the bound name. M   |
|                               | is a Module Record, and N2 is a |
|                               | binding that exists in M's      |
|                               | Module Environment Record.          |
+-------------------------------+-------------------------------------+
| GetThisBinding()              | Return the value of this            |
|                               | Environment Record's `this`       |
|                               | binding.                            |
+-------------------------------+-------------------------------------+

The behaviour of the additional concrete specification methods for
Module Environment Records are defined by the following algorithms:

.. _getbindingvalue-_n_-a-string-_s_-a-boolean-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-3:

GetBindingValue ( N: a String, S: a Boolean, )
----------------------------------------------

for
   a Module Environment Record envRec
description
   It returns the value of its bound identifier whose name is N.
   However, if the binding is an indirect binding the value of the
   target binding is returned. If the binding exists but is
   uninitialized a `ReferenceError` is thrown.

1. Assert: S is `true`. 1. Assert: envRec has a binding for
N. 1. If the binding for N is an indirect binding, then 1. Let
M and N2 be the indirection values provided when this binding
for N was created. 1. Let targetEnv be M.[[Environment]]. 1.
If targetEnv is ~empty~, throw a `ReferenceError` exception. 1.
Return ? targetEnv.GetBindingValue(N2, `true`). 1. If the
binding for N in envRec is an uninitialized binding, throw a
`ReferenceError` exception. 1. Return the value currently bound to
N in envRec.

S will always be `true` because a `Module` is always strict mode
code.

DeleteBinding ( N )
-----------------------

The DeleteBinding concrete method of a Module Environment Record is
never used within this specification.

Module Environment Records are only used within strict code and an early
error rule prevents the delete operator, in strict code, from being
applied to a Reference Record that would resolve to a Module Environment
Record binding. See .

.. _hasthisbinding-true-1:

HasThisBinding ( ): `true`
----------------------------

for
   a Module Environment Record envRec

1. Return `true`.

Module Environment Records always provide a `this` binding.

GetThisBinding ( ): a normal completion containing `undefined`
----------------------------------------------------------------

for
   a Module Environment Record envRec

1. Return `undefined`.

CreateImportBinding ( N: a String, M: a Module Record, N2: a String, ): ~unused~
--------------------------------------------------------------------------------------------

for
   a Module Environment Record envRec
description
   It creates a new initialized immutable indirect binding for the name
   N. A binding must not already exist in this Environment Record
   for N. N2 is the name of a binding that exists in M's
   Module Environment Record. Accesses to the value of the new binding
   will indirectly access the bound value of the target binding.

1. Assert: envRec does not already have a binding for N. 1.
Assert: When M.[[Environment]] is instantiated, it will have a
direct binding for N2. 1. Create an immutable indirect binding in
envRec for N that references M and N2 as its target
binding and record that the binding is initialized. 1. Return ~unused~.

Environment Record Operations
-----------------------------

The following abstract operations are used in this specification to
operate upon Environment Records:

GetIdentifierReference ( env: an Environment Record or `null`, name: a String, strict: a Boolean, )
---------------------------------------------------------------------------------------------------

1. If env is `null`, then 1. Return the Reference Record {
[[Base]]: ~unresolvable~, [[ReferencedName]]: name, [[Strict]]:
strict, [[ThisValue]]: ~empty~ }. 1. Let exists be ?
env.HasBinding(name). 1. If exists is `true`, then 1.
Return the Reference Record { [[Base]]: env, [[ReferencedName]]:
name, [[Strict]]: strict, [[ThisValue]]: ~empty~ }. 1. Else, 1.
Let outer be env.[[OuterEnv]]. 1. Return ?
GetIdentifierReference(outer, name, strict).

NewDeclarativeEnvironment ( E: an Environment Record or `null`, ): a Declarative Environment Record
---------------------------------------------------------------------------------------------------------

1. Let env be a new Declarative Environment Record containing no
bindings. 1. Set env.[[OuterEnv]] to E. 1. Return env.

NewObjectEnvironment ( O: an Object, W: a Boolean, E: an Environment Record or `null`, ): an Object Environment Record
------------------------------------------------------------------------------------------------------------------------------------

1. Let env be a new Object Environment Record. 1. Set
env.[[BindingObject]] to O. 1. Set env.[[IsWithEnvironment]]
to W. 1. Set env.[[OuterEnv]] to E. 1. Return env.

NewFunctionEnvironment ( F: an ECMAScript function object, newTarget: an Object or `undefined`, ): a Function Environment Record
------------------------------------------------------------------------------------------------------------------------------------------

1. Let env be a new Function Environment Record containing no
bindings. 1. Set env.[[FunctionObject]] to F. 1. If
F.[[ThisMode]] is ~lexical~, set env.[[ThisBindingStatus]] to
~lexical~. 1. Else, set env.[[ThisBindingStatus]] to
~uninitialized~. 1. Set env.[[NewTarget]] to newTarget. 1. Set
env.[[OuterEnv]] to F.[[Environment]]. 1. Return env.

NewGlobalEnvironment ( G: an Object, thisValue: an Object, ): a Global Environment Record
-------------------------------------------------------------------------------------------------

1. Let objRec be NewObjectEnvironment(G, `false`, `null`).
1. Let dclRec be NewDeclarativeEnvironment(`null`). 1. Let env
be a new Global Environment Record. 1. Set env.[[ObjectRecord]] to
objRec. 1. Set env.[[GlobalThisValue]] to thisValue. 1. Set
env.[[DeclarativeRecord]] to dclRec. 1. Set env.[[VarNames]]
to a new empty List. 1. Set env.[[OuterEnv]] to `null`. 1. Return
env.

NewModuleEnvironment ( E: an Environment Record, ): a Module Environment Record
-----------------------------------------------------------------------------------

1. Let env be a new Module Environment Record containing no
bindings. 1. Set env.[[OuterEnv]] to E. 1. Return env.

PrivateEnvironment Records
--------------------------

A PrivateEnvironment Record is a specification mechanism used to track
Private Names based upon the lexical nesting structure of
\|ClassDeclaration|s and \|ClassExpression|s in ECMAScript code. They
are similar to, but distinct from, Environment Records. Each
PrivateEnvironment Record is associated with a `ClassDeclaration` or
`ClassExpression`. Each time such a class is evaluated, a new
PrivateEnvironment Record is created to record the Private Names
declared by that class.

Each PrivateEnvironment Record has the fields defined in .

+----------------------+----------------------+----------------------+
| Field Name           | Value Type           | Meaning              |
+======================+======================+======================+
| [[Outer              | a PrivateEnvironment | The                  |
| PrivateEnvironment]] | Record or `null`   | PrivateEnvironment   |
|                      |                      | Record of the        |
|                      |                      | nearest containing   |
|                      |                      | class. `null` if   |
|                      |                      | the class with which |
|                      |                      | this                 |
|                      |                      | PrivateEnvironment   |
|                      |                      | Record is associated |
|                      |                      | is not contained in  |
|                      |                      | any other class.     |
+----------------------+----------------------+----------------------+
| [[Names]]            | a List of Private    | The Private Names    |
|                      | Names                | declared by this     |
|                      |                      | class.               |
+----------------------+----------------------+----------------------+

PrivateEnvironment Record Operations
------------------------------------

The following abstract operations are used in this specification to
operate upon PrivateEnvironment Records:

NewPrivateEnvironment ( outerPrivateEnv: a PrivateEnvironment Record or `null`, ): a PrivateEnvironment Record
--------------------------------------------------------------------------------------------------------------------

1. Let names be a new empty List. 1. Return the PrivateEnvironment
Record { [[OuterPrivateEnvironment]]: outerPrivateEnv, [[Names]]:
names }.

ResolvePrivateIdentifier ( privateEnv: a PrivateEnvironment Record, identifier: a String, ): a Private Name
-------------------------------------------------------------------------------------------------------------------

1. Let names be privateEnv.[[Names]]. 1. For each Private Name
pn of names, do 1. If pn.[[Description]] is identifier,
then 1. Return pn. 1. Let outerPrivateEnv be
privateEnv.[[OuterPrivateEnvironment]]. 1. Assert:
outerPrivateEnv is not `null`. 1. Return
ResolvePrivateIdentifier(outerPrivateEnv, identifier).

Realms
------

Before it is evaluated, all ECMAScript code must be associated with a
realm. Conceptually, a realm consists of a set of intrinsic objects, an
ECMAScript global environment, all of the ECMAScript code that is loaded
within the scope of that global environment, and other associated state
and resources.

A realm is represented in this specification as a Realm Record with the
fields specified in :

+-----------------------+-----------------------+-----------------------+
| Field Name            | Value                 | Meaning               |
+=======================+=======================+=======================+
| [[AgentSignifier]]    | an agent signifier    | The agent that owns   |
|                       |                       | this realm            |
+-----------------------+-----------------------+-----------------------+
| [[Intrinsics]]        | a Record whose field  | The intrinsic values  |
|                       | names are intrinsic   | used by code          |
|                       | keys and whose values | associated with this  |
|                       | are objects           | realm                 |
+-----------------------+-----------------------+-----------------------+
| [[GlobalObject]]      | an Object or          | The global object for |
|                       | `undefined`         | this realm            |
+-----------------------+-----------------------+-----------------------+
| [[GlobalEnv]]         | a Global Environment  | The global            |
|                       | Record                | environment for this  |
|                       |                       | realm                 |
+-----------------------+-----------------------+-----------------------+
| [[TemplateMap]]       | a List of Records     | Template objects are  |
|                       | with fields [[Site]]  | canonicalized         |
|                       | (a                    | separately for each   |
|                       | `TemplateLiteral`   | realm using its Realm |
|                       | Parse Node) and       | Record's              |
|                       | [[Array]] (an Array)  | [[TemplateMap]]. Each |
|                       |                       | [[Site]] value is a   |
|                       |                       | Parse Node that is a  |
|                       |                       | `TemplateLiteral`.  |
|                       |                       | The associated        |
|                       |                       | [[Array]] value is    |
|                       |                       | the corresponding     |
|                       |                       | template object that  |
|                       |                       | is passed to a tag    |
|                       |                       | function.             |
|                       |                       |                       |
|                       |                       | Once a Parse Node     |
|                       |                       | becomes unreachable,  |
|                       |                       | the corresponding     |
|                       |                       | [[Array]] is also     |
|                       |                       | unreachable, and it   |
|                       |                       | would be unobservable |
|                       |                       | if an implementation  |
|                       |                       | removed the pair from |
|                       |                       | the [[TemplateMap]]   |
|                       |                       | list.                 |
+-----------------------+-----------------------+-----------------------+
| [[LoadedModules]]     | a List of Records     | A map from the        |
|                       | with fields           | specifier strings     |
|                       | [[Specifier]] (a      | imported by this      |
|                       | String) and           | realm to the resolved |
|                       | [[Module]] (a Module  | Module Record. The    |
|                       | Record)               | list does not contain |
|                       |                       | two different Records |
|                       |                       | with the same         |
|                       |                       | [[Specifier]].        |
|                       |                       |                       |
|                       |                       | As mentioned in       |
|                       |                       | H                     |
|                       |                       | ostLoadImportedModule |
|                       |                       | (), [[LoadedModules]] |
|                       |                       | in Realm Records is   |
|                       |                       | only used when        |
|                       |                       | running an            |
|                       |                       | `import()`          |
|                       |                       | expression in a       |
|                       |                       | context where there   |
|                       |                       | is no active script   |
|                       |                       | or module.            |
+-----------------------+-----------------------+-----------------------+
| [[HostDefined]]       | anything (default     | Field reserved for    |
|                       | value is              | use by hosts that     |
|                       | `undefined`)        | need to associate     |
|                       |                       | additional            |
|                       |                       | information with a    |
|                       |                       | Realm Record.         |
+-----------------------+-----------------------+-----------------------+

InitializeHostDefinedRealm ( )
------------------------------

1. Let realm be a new Realm Record. 1. Perform
CreateIntrinsics(realm). 1. Set realm.[[AgentSignifier]] to
AgentSignifier(). 1. Set realm.[[GlobalObject]] to `undefined`. 1.
Set realm.[[GlobalEnv]] to `undefined`. 1. Set
realm.[[TemplateMap]] to a new empty List. 1. Let newContext be
a new execution context. 1. Set the Function of newContext to
`null`. 1. Set the Realm of newContext to realm. 1. Set the
ScriptOrModule of newContext to `null`. 1. Push newContext
onto the execution context stack; newContext is now the running
execution context. 1. If the host requires use of an exotic object to
serve as realm's global object, then 1. Let global be such an
object created in a host-defined manner. 1. Else, 1. Let global be
OrdinaryObjectCreate(realm.[[Intrinsics]].[[%Object.prototype%]]).
1. If the host requires that the `this` binding in realm's global
scope return an object other than the global object, then 1. Let
thisValue be such an object created in a host-defined manner. 1.
Else, 1. Let thisValue be global. 1. Set
realm.[[GlobalObject]] to global. 1. Set realm.[[GlobalEnv]]
to NewGlobalEnvironment(global, thisValue). 1. Perform ?
SetDefaultGlobalBindings(realm). 1. Create any host-defined global
object properties on global. 1. Return ~unused~.

CreateIntrinsics ( realmRec: a Realm Record, ): ~unused~
------------------------------------------------------------

1. Set realmRec.[[Intrinsics]] to a new Record. 1.
[declared="steps,name,length,slots,prototype"] Set fields of
realmRec.[[Intrinsics]] with the values listed in . The field names
are the names listed in column one of the table. The value of each field
is a new object value fully and recursively populated with property
values as defined by the specification of each object in clauses through
. All object property values are newly created object values. All values
that are built-in function objects are created by performing
CreateBuiltinFunction(steps, length, name, slots,
realmRec, prototype) where steps is the definition of that
function provided by this specification, name is the initial value
of the function's `"name"` property, length is the initial value
of the function's `"length"` property, slots is a list of the
names, if any, of the function's specified internal slots, and
prototype is the specified value of the function's [[Prototype]]
internal slot. The creation of the intrinsics and their properties must
be ordered to avoid any dependencies upon objects that have not yet been
created. 1. Perform
AddRestrictedFunctionProperties(realmRec.[[Intrinsics]].[[%Function.prototype%]],
realmRec). 1. Return ~unused~.

SetDefaultGlobalBindings ( realmRec: a Realm Record, )
------------------------------------------------------

1. Let global be realmRec.[[GlobalObject]]. 1. For each property
of the Global Object specified in clause , do 1. Let name be the
String value of the property name. 1. Let desc be the fully
populated data Property Descriptor for the property, containing the
specified attributes for the property. For properties listed in , , or
the value of the [[Value]] attribute is the corresponding intrinsic
object from realmRec. 1. Perform ? DefinePropertyOrThrow(global,
name, desc). 1. Return ~unused~.

Execution Contexts
------------------

An execution context is a specification device that is used to track the
runtime evaluation of code by an ECMAScript implementation. At any point
in time, there is at most one execution context per agent that is
actually executing code. This is known as the agent's running execution
context. All references to the running execution context in this
specification denote the running execution context of the surrounding
agent.

The execution context stack is used to track execution contexts. The
running execution context is always the top element of this stack. A new
execution context is created whenever control is transferred from the
executable code associated with the currently running execution context
to executable code that is not associated with that execution context.
The newly created execution context is pushed onto the stack and becomes
the running execution context.

An execution context contains whatever implementation specific state is
necessary to track the execution progress of its associated code. Each
execution context has at least the state components listed in .

+-----------------------+---------------------------------------------+
| Component             | Purpose                                     |
+=======================+=============================================+
| code evaluation state | Any state needed to perform, suspend, and   |
|                       | resume evaluation of the code associated    |
|                       | with this execution context.                |
+-----------------------+---------------------------------------------+
| Function              | If this execution context is evaluating the |
|                       | code of a function object, then the value   |
|                       | of this component is that function object.  |
|                       | If the context is evaluating the code of a  |
|                       | `Script` or `Module`, the value is      |
|                       | `null`.                                   |
+-----------------------+---------------------------------------------+
| Realm                 | The Realm Record from which associated code |
|                       | accesses ECMAScript resources.              |
+-----------------------+---------------------------------------------+
| ScriptOrModule        | The Module Record or Script Record from     |
|                       | which associated code originates. If there  |
|                       | is no originating script or module, as is   |
|                       | the case for the original execution context |
|                       | created in InitializeHostDefinedRealm, the  |
|                       | value is `null`.                          |
+-----------------------+---------------------------------------------+

Evaluation of code by the running execution context may be suspended at
various points defined within this specification. Once the running
execution context has been suspended a different execution context may
become the running execution context and commence evaluating its code.
At some later time a suspended execution context may again become the
running execution context and continue evaluating its code at the point
where it had previously been suspended. Transition of the running
execution context status among execution contexts usually occurs in
stack-like last-in/first-out manner. However, some ECMAScript features
require non-LIFO transitions of the running execution context.

The value of the Realm component of the running execution context is
also called the current Realm Record. The value of the Function
component of the running execution context is also called the active
function object.

ECMAScript code execution contexts have the additional state components
listed in .

+---------------------+-----------------------------------------------+
| Component           | Purpose                                       |
+=====================+===============================================+
| LexicalEnvironment  | Identifies the Environment Record used to     |
|                     | resolve identifier references made by code    |
|                     | within this execution context.                |
+---------------------+-----------------------------------------------+
| VariableEnvironment | Identifies the Environment Record that holds  |
|                     | bindings created by \|VariableStatement|s     |
|                     | within this execution context.                |
+---------------------+-----------------------------------------------+
| PrivateEnvironment  | Identifies the PrivateEnvironment Record that |
|                     | holds Private Names created by                |
|                     | \|ClassElement|s in the nearest containing    |
|                     | class. `null` if there is no containing     |
|                     | class.                                        |
+---------------------+-----------------------------------------------+

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Environment Records.

Execution contexts representing the evaluation of Generators have the
additional state components listed in .

========= ========================================================
Component Purpose
========= ========================================================
Generator The Generator that this execution context is evaluating.
========= ========================================================

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”, and
“VariableEnvironment” are used without qualification they are in
reference to those components of the running execution context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for ECMAScript code to directly access or observe an
execution context.

GetActiveScriptOrModule ( ): a Script Record, a Module Record, or `null`
--------------------------------------------------------------------------

description
   It is used to determine the running script or module, based on the
   running execution context.

1. If the execution context stack is empty, return `null`. 1. Let
ec be the topmost execution context on the execution context stack
whose ScriptOrModule component is not `null`. 1. If no such execution
context exists, return `null`. Otherwise, return ec's
ScriptOrModule.

ResolveBinding ( name: a String, optional env: an Environment Record or `undefined`, )
--------------------------------------------------------------------------------------

description
   It is used to determine the binding of name. env can be used
   to explicitly provide the Environment Record that is to be searched
   for the binding.

1. If env is not present or env is `undefined`, then 1. Set
env to the running execution context's LexicalEnvironment. 1.
Assert: env is an Environment Record. 1. Let strict be
IsStrict(the syntactic production that is being evaluated). 1. Return ?
GetIdentifierReference(env, name, strict).

The result of ResolveBinding is always a Reference Record whose
[[ReferencedName]] field is name.

GetThisEnvironment ( ): an Environment Record
---------------------------------------------

description
   It finds the Environment Record that currently supplies the binding
   of the keyword `this`.

1. Let env be the running execution context's LexicalEnvironment. 1.
[id="step-getthisenvironment-loop"] Repeat, 1. Let exists be
env.HasThisBinding(). 1. If exists is `true`, return env.
1. Let outer be env.[[OuterEnv]]. 1. Assert: outer is not
`null`. 1. Set env to outer.

The loop in step will always terminate because the list of environments
always ends with the global environment which has a `this` binding.

ResolveThisBinding ( )
----------------------

description
   It determines the binding of the keyword `this` using the
   LexicalEnvironment of the running execution context.

1. Let envRec be GetThisEnvironment(). 1. Return ?
envRec.GetThisBinding().

GetNewTarget ( ): an Object or `undefined`
--------------------------------------------

description
   It determines the NewTarget value using the LexicalEnvironment of the
   running execution context.

1. Let envRec be GetThisEnvironment(). 1. Assert: envRec has a
[[NewTarget]] field. 1. Return envRec.[[NewTarget]].

GetGlobalObject ( ): an Object
------------------------------

description
   It returns the global object used by the currently running execution
   context.

1. Let currentRealm be the current Realm Record. 1. Return
currentRealm.[[GlobalObject]].

Jobs and Host Operations to Enqueue Jobs
----------------------------------------

A Job is an Abstract Closure with no parameters that initiates an
ECMAScript computation when no other ECMAScript computation is currently
in progress.

Jobs are scheduled for execution by ECMAScript host environments in a
particular agent. This specification describes the host hooks
HostEnqueueGenericJob, HostEnqueueFinalizationRegistryCleanupJob,
HostEnqueuePromiseJob, and HostEnqueueTimeoutJob to schedule jobs. The
host hooks in this specification are organized by the additional
constraints imposed on the scheduling of jobs. Hosts may define
additional abstract operations which schedule jobs. Such operations
accept a Job Abstract Closure and a realm (a Realm Record or `null`)
as parameters. If a Realm Record is provided, these operations schedule
the job to be performed at some future time in the provided realm, in
the agent that owns the realm. If `null` is provided instead for the
realm, then the job does not evaluate ECMAScript code. Their
implementations must conform to the following requirements:

- At some future point in time, when there is no running context in the
  agent for which the job is scheduled and that agent's execution
  context stack is empty, the implementation must:

  #. Perform any host-defined preparation steps.
  #. Invoke the Job Abstract Closure.
  #. Perform any host-defined cleanup steps, after which the execution
     context stack must be empty.

- Only one Job may be actively undergoing evaluation at any point in
  time in an agent.
- Once evaluation of a Job starts, it must run to completion before
  evaluation of any other Job starts in an agent.
- The Abstract Closure must return a normal completion, implementing its
  own handling of errors.

Host environments are not required to treat Jobs uniformly with respect
to scheduling. For example, web browsers and Node.js treat
Promise-handling Jobs as a higher priority than other work; future
features may add Jobs that are not treated at such a high priority.

At any particular time, scriptOrModule (a Script Record, a Module
Record, or `null`) is the active script or module if all of the
following conditions are true:

- GetActiveScriptOrModule() is scriptOrModule.
- If scriptOrModule is a Script Record or Module Record, let ec
  be the topmost execution context on the execution context stack whose
  ScriptOrModule component is scriptOrModule. The Realm component of
  ec is scriptOrModule.[[Realm]].

At any particular time, an execution is prepared to evaluate ECMAScript
code if all of the following conditions are true:

- The execution context stack is not empty.
- The Realm component of the topmost execution context on the execution
  context stack is a Realm Record.

Host environments may prepare an execution to evaluate code by pushing
execution contexts onto the execution context stack. The specific steps
are implementation-defined.

The specific choice of Realm is up to the host environment. This initial
execution context and Realm is only in use before any callback function
is invoked. When a callback function related to a Job, like a Promise
handler, is invoked, the invocation pushes its own execution context and
Realm.

Particular kinds of Jobs have additional conformance requirements.

JobCallback Records
-------------------

A JobCallback Record is a Record value used to store a function object
and a host-defined value. Function objects that are invoked via a Job
enqueued by the host may have additional host-defined context. To
propagate the state, Job Abstract Closures should not capture and call
function objects directly. Instead, use HostMakeJobCallback and
HostCallJobCallback.

The WHATWG HTML specification (https://html.spec.whatwg.org/), for
example, uses the host-defined value to propagate the incumbent settings
object for Promise callbacks.

JobCallback Records have the fields listed in .

+-----------------+------------------------+------------------------+
| Field Name      | Value                  | Meaning                |
+=================+========================+========================+
| [[Callback]]    | a function object      | The function to invoke |
|                 |                        | when the Job is        |
|                 |                        | invoked.               |
+-----------------+------------------------+------------------------+
| [[HostDefined]] | anything (default      | Field reserved for use |
|                 | value is ~empty~)      | by hosts.              |
+-----------------+------------------------+------------------------+

HostMakeJobCallback ( callback: a function object, ): a JobCallback Record
------------------------------------------------------------------------------

An implementation of HostMakeJobCallback must conform to the following
requirements:

- It must return a JobCallback Record whose [[Callback]] field is
  callback.

The default implementation of HostMakeJobCallback performs the following
steps when called:

1. Return the JobCallback Record { [[Callback]]: callback,
[[HostDefined]]: ~empty~ }.

ECMAScript hosts that are not web browsers must use the default
implementation of HostMakeJobCallback.

This is called at the time that the callback is passed to the function
that is responsible for its being eventually scheduled and run. For
example, `promise.then(thenAction)` calls MakeJobCallback on
`thenAction` at the time of invoking `Promise.prototype.then`, not
at the time of scheduling the reaction Job.

HostCallJobCallback ( jobCallback: a JobCallback Record, V, argumentsList: a List of ECMAScript language values, )
------------------------------------------------------------------------------------------------------------------

An implementation of HostCallJobCallback must conform to the following
requirements:

- It must perform and return the result of
  Call(jobCallback.[[Callback]], V, argumentsList).

This requirement means that hosts cannot change the [[Call]] behaviour
of function objects defined in this specification.

The default implementation of HostCallJobCallback performs the following
steps when called:

1. Assert: IsCallable(jobCallback.[[Callback]]) is `true`. 1.
Return ? Call(jobCallback.[[Callback]], V, argumentsList).

ECMAScript hosts that are not web browsers must use the default
implementation of HostCallJobCallback.

HostEnqueueGenericJob ( job: a Job Abstract Closure, realm: a Realm Record, ): ~unused~
-----------------------------------------------------------------------------------------------

description
   It schedules job in the realm realm in the agent signified by
   realm.[[AgentSignifier]] to be performed at some future time. The
   Abstract Closures used with this algorithm are intended to be
   scheduled without additional constraints, such as priority and
   ordering.

An implementation of HostEnqueueGenericJob must conform to the
requirements in .

HostEnqueuePromiseJob ( job: a Job Abstract Closure, realm: a Realm Record or `null`, ): ~unused~
-----------------------------------------------------------------------------------------------------------

description
   It schedules job to be performed at some future time. The
   Abstract Closures used with this algorithm are intended to be related
   to the handling of Promises, or otherwise, to be scheduled with equal
   priority to Promise handling operations.

An implementation of HostEnqueuePromiseJob must conform to the
requirements in as well as the following:

- If realm is not `null`, each time job is invoked the
  implementation must perform implementation-defined steps such that
  execution is prepared to evaluate ECMAScript code at the time of
  job's invocation.
- Let scriptOrModule be GetActiveScriptOrModule() at the time
  HostEnqueuePromiseJob is invoked. If realm is not `null`, each
  time job is invoked the implementation must perform
  implementation-defined steps such that scriptOrModule is the
  active script or module at the time of job's invocation.
- Jobs must run in the same order as the HostEnqueuePromiseJob
  invocations that scheduled them.

The realm for Jobs returned by NewPromiseResolveThenableJob is
usually the result of calling GetFunctionRealm on the then function
object. The realm for Jobs returned by NewPromiseReactionJob is
usually the result of calling GetFunctionRealm on the handler if the
handler is not `undefined`. If the handler is `undefined`, realm
is `null`. For both kinds of Jobs, when GetFunctionRealm completes
abnormally (i.e. called on a revoked Proxy), realm is the current
Realm Record at the time of the GetFunctionRealm call. When the
realm is `null`, no user ECMAScript code will be evaluated and no
new ECMAScript objects (e.g. Error objects) will be created. The WHATWG
HTML specification (https://html.spec.whatwg.org/), for example, uses
realm to check for the ability to run script and for the
`entry <https://html.spec.whatwg.org/#entry>`__ concept.

HostEnqueueTimeoutJob ( timeoutJob: a Job Abstract Closure, realm: a Realm Record, milliseconds: a non-negative finite Number, ): ~unused~
------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It schedules timeoutJob in the realm realm in the agent
   signified by realm.[[AgentSignifier]] to be performed after at
   least milliseconds milliseconds.

An implementation of HostEnqueueTimeoutJob must conform to the
requirements in .

Agents
------

An agent comprises a set of ECMAScript execution contexts, an execution
context stack, a running execution context, an Agent Record, and an
executing thread. Except for the executing thread, the constituents of
an agent belong exclusively to that agent.

An agent's executing thread executes algorithmic steps on the agent's
execution contexts independently of other agents, except that an
executing thread may be used as the executing thread by multiple agents,
provided none of the agents sharing the thread have an Agent Record
whose [[CanBlock]] field is `true`.

Some web browsers share a single executing thread across multiple
unrelated tabs of a browser window, for example.

While an agent's executing thread is executing algorithmic steps, the
agent is the surrounding agent for those steps. The steps use the
surrounding agent to access the specification-level execution objects
held within the agent: the running execution context, the execution
context stack, and the Agent Record's fields.

An agent signifier is a globally-unique opaque value used to identify an
Agent.

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[LittleEndian]]     | a Boolean            | The default value    |
|                      |                      | computed for the     |
|                      |                      | *isLittleEndian*     |
|                      |                      | parameter when it is |
|                      |                      | needed by the        |
|                      |                      | algorithms           |
|                      |                      | GetValueFromBuffer   |
|                      |                      | and                  |
|                      |                      | SetValueInBuffer.    |
|                      |                      | The choice is        |
|                      |                      | im                   |
|                      |                      | plementation-defined |
|                      |                      | and should be the    |
|                      |                      | alternative that is  |
|                      |                      | most efficient for   |
|                      |                      | the implementation.  |
|                      |                      | Once the value has   |
|                      |                      | been observed it     |
|                      |                      | cannot change.       |
+----------------------+----------------------+----------------------+
| [[CanBlock]]         | a Boolean            | Determines whether   |
|                      |                      | the agent can block  |
|                      |                      | or not.              |
+----------------------+----------------------+----------------------+
| [[Signifier]]        | an agent signifier   | Uniquely identifies  |
|                      |                      | the agent within its |
|                      |                      | agent cluster.       |
+----------------------+----------------------+----------------------+
| [[IsLockFree1]]      | a Boolean            | `true` if atomic   |
|                      |                      | operations on        |
|                      |                      | one-byte values are  |
|                      |                      | lock-free, `false` |
|                      |                      | otherwise.           |
+----------------------+----------------------+----------------------+
| [[IsLockFree2]]      | a Boolean            | `true` if atomic   |
|                      |                      | operations on        |
|                      |                      | two-byte values are  |
|                      |                      | lock-free, `false` |
|                      |                      | otherwise.           |
+----------------------+----------------------+----------------------+
| [[IsLockFree8]]      | a Boolean            | `true` if atomic   |
|                      |                      | operations on        |
|                      |                      | eight-byte values    |
|                      |                      | are lock-free,       |
|                      |                      | `false` otherwise. |
+----------------------+----------------------+----------------------+
| [[                   | a candidate          | See the memory       |
| CandidateExecution]] | execution Record     | model.               |
+----------------------+----------------------+----------------------+
| [[KeptAlive]]        | a List of either     | Initially a new      |
|                      | Objects or Symbols   | empty List,          |
|                      |                      | representing the     |
|                      |                      | list of objects      |
|                      |                      | and/or symbols to be |
|                      |                      | kept alive until the |
|                      |                      | end of the current   |
|                      |                      | Job                  |
+----------------------+----------------------+----------------------+

Once the values of [[Signifier]], [[IsLockFree1]], and [[IsLockFree2]]
have been observed by any agent in the agent cluster they cannot change.

The values of [[IsLockFree1]] and [[IsLockFree2]] are not necessarily
determined by the hardware, but may also reflect implementation choices
that can vary over time and between ECMAScript implementations.

There is no [[IsLockFree4]] field: 4-byte atomic operations are always
lock-free.

In practice, if an atomic operation is implemented with any type of lock
the operation is not lock-free. Lock-free does not imply wait-free:
there is no upper bound on how many machine steps may be required to
complete a lock-free atomic operation.

That an atomic access of size *n* is lock-free does not imply anything
about the (perceived) atomicity of non-atomic accesses of size *n*,
specifically, non-atomic accesses may still be performed as a sequence
of several separate memory accesses. See ReadSharedMemory and
WriteSharedMemory for details.

An agent is a specification mechanism and need not correspond to any
particular artefact of an ECMAScript implementation.

AgentSignifier ( ): an agent signifier
--------------------------------------

1. Let AR be the Agent Record of the surrounding agent. 1. Return
AR.[[Signifier]].

AgentCanSuspend ( ): a Boolean
------------------------------

1. Let AR be the Agent Record of the surrounding agent. 1. Return
AR.[[CanBlock]].

In some environments it may not be reasonable for a given agent to
suspend. For example, in a web browser environment, it may be reasonable
to disallow suspending a document's main event handling thread, while
still allowing workers' event handling threads to suspend.

Agent Clusters
--------------

An agent cluster is a maximal set of agents that can communicate by
operating on shared memory.

Programs within different agents may share memory by unspecified means.
At a minimum, the backing memory for SharedArrayBuffers can be shared
among the agents in the cluster.

There may be agents that can communicate by message passing that cannot
share memory; they are never in the same agent cluster.

Every agent belongs to exactly one agent cluster.

The agents in a cluster need not all be alive at some particular point
in time. If agent **A** creates another agent **B**, after which **A**
terminates and **B** creates agent **C**, the three agents are in the
same cluster if **A** could share some memory with **B** and **B** could
share some memory with **C**.

All agents within a cluster must have the same value for the
[[LittleEndian]] field in their respective Agent Records.

If different agents within an agent cluster have different values of
[[LittleEndian]] it becomes hard to use shared memory for multi-byte
data.

All agents within a cluster must have the same values for the
[[IsLockFree1]] field in their respective Agent Records; similarly for
the [[IsLockFree2]] field.

All agents within a cluster must have different values for the
[[Signifier]] field in their respective Agent Records.

An embedding may deactivate (stop forward progress) or activate (resume
forward progress) an agent without the agent's knowledge or cooperation.
If the embedding does so, it must not leave some agents in the cluster
active while other agents in the cluster are deactivated indefinitely.

The purpose of the preceding restriction is to avoid a situation where
an agent deadlocks or starves because another agent has been
deactivated. For example, if an HTML shared worker that has a lifetime
independent of documents in any windows were allowed to share memory
with the dedicated worker of such an independent document, and the
document and its dedicated worker were to be deactivated while the
dedicated worker holds a lock (say, the document is pushed into its
window's history), and the shared worker then tries to acquire the lock,
then the shared worker will be blocked until the dedicated worker is
activated again, if ever. Meanwhile other workers trying to access the
shared worker from other windows will starve.

The implication of the restriction is that it will not be possible to
share memory between agents that don't belong to the same suspend/wake
collective within the embedding.

An embedding may terminate an agent without any of the agent's cluster's
other agents' prior knowledge or cooperation. If an agent is terminated
not by programmatic action of its own or of another agent in the cluster
but by forces external to the cluster, then the embedding must choose
one of two strategies: Either terminate all the agents in the cluster,
or provide reliable APIs that allow the agents in the cluster to
coordinate so that at least one remaining member of the cluster will be
able to detect the termination, with the termination data containing
enough information to identify the agent that was terminated.

Examples of that type of termination are: operating systems or users
terminating agents that are running in separate processes; the embedding
itself terminating an agent that is running in-process with the other
agents when per-agent resource accounting indicates that the agent is
runaway.

Each of the following specification values, and values transitively
reachable from them, belong to exactly one agent cluster.

- candidate execution Record
- Shared Data Block
- WaiterList Record

Prior to any evaluation of any ECMAScript code by any agent in a
cluster, the [[CandidateExecution]] field of the Agent Record for all
agents in the cluster is set to the initial candidate execution. The
initial candidate execution is an empty candidate execution whose
[[EventsRecords]] field is a List containing, for each agent, an Agent
Events Record whose [[AgentSignifier]] field is that agent's agent
signifier, and whose [[EventList]] and [[AgentSynchronizesWith]] fields
are empty Lists.

All agents in an agent cluster share the same candidate execution in its
Agent Record's [[CandidateExecution]] field. The candidate execution is
a specification mechanism used by the memory model.

An agent cluster is a specification mechanism and need not correspond to
any particular artefact of an ECMAScript implementation.

Forward Progress
----------------

For an agent to *make forward progress* is for it to perform an
evaluation step according to this specification.

An agent becomes *blocked* when its running execution context waits
synchronously and indefinitely for an external event. Only agents whose
Agent Record's [[CanBlock]] field is `true` can become blocked in this
sense. An *unblocked* agent is one that is not blocked.

Implementations must ensure that:

- every unblocked agent with a dedicated executing thread eventually
  makes forward progress
- in a set of agents that share an executing thread, one agent
  eventually makes forward progress
- an agent does not cause another agent to become blocked except via
  explicit APIs that provide blocking.

This, along with the liveness guarantee in the memory model, ensures
that all ~seq-cst~ writes eventually become observable to all agents.

Processing Model of WeakRef and FinalizationRegistry Targets
------------------------------------------------------------

Objectives
----------

This specification does not make any guarantees that any object or
symbol will be garbage collected. Objects or symbols which are not live
may be released after long periods of time, or never at all. For this
reason, this specification uses the term "may" when describing behaviour
triggered by garbage collection.

The semantics of WeakRefs and FinalizationRegistrys is based on two
operations which happen at particular points in time:

- When `WeakRef.prototype.deref` is called, the referent (if
  `undefined` is not returned) is kept alive so that subsequent,
  synchronous accesses also return the same value. This list is reset
  when synchronous work is done using the ClearKeptObjects abstract
  operation.
- When an object or symbol which is registered with a
  FinalizationRegistry becomes unreachable, a call of the
  FinalizationRegistry's cleanup callback may eventually be made, after
  synchronous ECMAScript execution completes. The FinalizationRegistry
  cleanup is performed with the CleanupFinalizationRegistry abstract
  operation.

Neither of these actions (ClearKeptObjects or
CleanupFinalizationRegistry) may interrupt synchronous ECMAScript
execution. Because hosts may assemble longer, synchronous ECMAScript
execution runs, this specification defers the scheduling of
ClearKeptObjects and CleanupFinalizationRegistry to the host
environment.

Some ECMAScript implementations include garbage collector
implementations which run in the background, including when ECMAScript
is idle. Letting the host environment schedule
CleanupFinalizationRegistry allows it to resume ECMAScript execution in
order to run finalizer work, which may free up held values, reducing
overall memory usage.

Liveness
--------

For some set of objects and/or symbols S a hypothetical
WeakRef-oblivious execution with respect to S is an execution
whereby the abstract operation WeakRefDeref of a WeakRef whose referent
is an element of S always returns `undefined`.

WeakRef-obliviousness, together with liveness, capture two notions. One,
that a WeakRef itself does not keep its referent alive. Two, that cycles
in liveness does not imply that a value is live. To be concrete, if
determining v's liveness depends on determining the liveness of a
WeakRef referent, r, r's liveness cannot assume v's
liveness, which would be circular reasoning. WeakRef-obliviousness is
defined on sets of objects or symbols instead of individual values to
account for cycles. If it were defined on individual values, then a
WeakRef referent in a cycle will be considered live even though its
identity is only observed via other WeakRef referents in the cycle.
Colloquially, we say that an individual object or symbol is live if
every set containing it is live.

At any point during evaluation, a set of objects and/or symbols S is
considered live if either of the following conditions is met:

- Any element in S is included in any agent's [[KeptAlive]] List.
- There exists a valid future hypothetical WeakRef-oblivious execution
  with respect to S that observes the identity of any value in
  S.

The second condition above intends to capture the intuition that a value
is live if its identity is observable via non-WeakRef means. A value's
identity may be observed by observing a strict equality comparison or
observing the value being used as key in a Map.

Presence of an object or a symbol in a field, an internal slot, or a
property does not imply that the value is live. For example if the value
in question is never passed back to the program, then it cannot be
observed.

This is the case for keys in a WeakMap, members of a WeakSet, as well as
the [[WeakRefTarget]] and [[UnregisterToken]] fields of a
FinalizationRegistry Cell record.

The above definition implies that, if a key in a WeakMap is not live,
then its corresponding value is not necessarily live either.

Liveness is the lower bound for guaranteeing which WeakRefs engines must
not empty. Liveness as defined here is undecidable. In practice, engines
use conservative approximations such as reachability. There is expected
to be significant implementation leeway.

Execution
---------

At any time, if a set of objects and/or symbols S is not live, an
ECMAScript implementation may perform the following steps atomically:

1. For each element value of S, do 1. For each WeakRef ref
such that ref.[[WeakRefTarget]] is value, do 1. Set
ref.[[WeakRefTarget]] to ~empty~. 1. For each FinalizationRegistry
fg such that fg.[[Cells]] contains a Record cell such that
cell.[[WeakRefTarget]] is value, do 1. Set
cell.[[WeakRefTarget]] to ~empty~. 1. Optionally, perform
HostEnqueueFinalizationRegistryCleanupJob(fg). 1. For each WeakMap
map such that map.[[WeakMapData]] contains a Record r such
that r.[[Key]] is value, do 1. Set r.[[Key]] to ~empty~. 1.
Set r.[[Value]] to ~empty~. 1. For each WeakSet set such that
set.[[WeakSetData]] contains value, do 1. Replace the element of
set.[[WeakSetData]] whose value is value with an element whose
value is ~empty~.

Together with the definition of liveness, this clause prescribes
optimizations that an implementation may apply regarding WeakRefs.

It is possible to access an object without observing its identity.
Optimizations such as dead variable elimination and scalar replacement
on properties of non-escaping objects whose identity is not observed are
allowed. These optimizations are thus allowed to observably empty
WeakRefs that point to such objects.

On the other hand, if an object's identity is observable, and that
object is in the [[WeakRefTarget]] internal slot of a WeakRef,
optimizations such as rematerialization that observably empty the
WeakRef are prohibited.

Because calling HostEnqueueFinalizationRegistryCleanupJob is optional,
registered objects in a FinalizationRegistry do not necessarily hold
that FinalizationRegistry live. Implementations may omit
FinalizationRegistry callbacks for any reason, e.g., if the
FinalizationRegistry itself becomes dead, or if the application is
shutting down.

Implementations are not obligated to empty WeakRefs for maximal sets of
non-live objects or symbols.

If an implementation chooses a non-live set S in which to empty
WeakRefs, this definition requires that it empties WeakRefs for all
values in S simultaneously. In other words, it is not conformant for
an implementation to empty a WeakRef pointing to a value v without
emptying out other WeakRefs that, if not emptied, could result in an
execution that observes the value of v.

Host Hooks
----------

HostEnqueueFinalizationRegistryCleanupJob ( finalizationRegistry: a FinalizationRegistry, ): ~unused~
---------------------------------------------------------------------------------------------------------

Let cleanupJob be a new Job Abstract Closure with no parameters that
captures finalizationRegistry and performs the following steps when
called:

1. Let cleanupResult be
Completion(CleanupFinalizationRegistry(finalizationRegistry)). 1. If
cleanupResult is an abrupt completion, perform any host-defined
steps for reporting the error. 1. Return ~unused~.

An implementation of HostEnqueueFinalizationRegistryCleanupJob schedules
cleanupJob to be performed at some future time, if possible. It must
also conform to the requirements in .

ClearKeptObjects ( ): ~unused~
------------------------------

description
   ECMAScript implementations are expected to call ClearKeptObjects when
   a synchronous sequence of ECMAScript executions completes.

1. Let agentRecord be the surrounding agent's Agent Record. 1. Set
agentRecord.[[KeptAlive]] to a new empty List. 1. Return ~unused~.

AddToKeptObjects ( value: an Object or a Symbol, ): ~unused~
----------------------------------------------------------------

1. Let agentRecord be the surrounding agent's Agent Record. 1.
Append value to agentRecord.[[KeptAlive]]. 1. Return ~unused~.
When the abstract operation AddToKeptObjects is called with a target
object or symbol, it adds the target to a list that will point strongly
at the target until ClearKeptObjects is called.

CleanupFinalizationRegistry ( finalizationRegistry: a FinalizationRegistry, )
-----------------------------------------------------------------------------

1. Assert: finalizationRegistry has [[Cells]] and
[[CleanupCallback]] internal slots. 1. Let callback be
finalizationRegistry.[[CleanupCallback]]. 1. While
finalizationRegistry.[[Cells]] contains a Record cell such that
cell.[[WeakRefTarget]] is ~empty~, an implementation may perform the
following steps: 1. Choose any such cell. 1. Remove cell from
finalizationRegistry.[[Cells]]. 1. Perform ?
HostCallJobCallback(callback, `undefined`, «
cell.[[HeldValue]] »). 1. Return ~unused~.

CanBeHeldWeakly ( v, ): a Boolean
-------------------------------------------------------------------

description
   It returns `true` if and only if v is suitable for use as a
   weak reference. Only values that are suitable for use as a weak
   reference may be a key of a WeakMap, an element of a WeakSet, the
   target of a WeakRef, or one of the targets of a FinalizationRegistry.

1. If v is an Object, return `true`. 1. If v is a Symbol and
KeyForSymbol(v) is `undefined`, return `true`. 1. Return
`false`.

A language value without language identity can be manifested without
prior reference and is unsuitable for use as a weak reference. A Symbol
value produced by Symbol.for, unlike other Symbol values, does not have
language identity and is unsuitable for use as a weak reference.
Well-known symbols are likely to never be collected, but are nonetheless
treated as suitable for use as a weak reference because they are limited
in number and therefore manageable by a variety of implementation
approaches. However, any value associated to a well-known symbol in a
live WeakMap is unlikely to be collected and could “leak” memory
resources in implementations.

10. Ordinary and Exotic Objects Behaviours
==========================================

https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html
::

   10.1 Ordinary Object Internal Methods and Internal Slots
      10.1.1 [[GetPrototypeOf]] ( )
         10.1.1.1 OrdinaryGetPrototypeOf ( O )
      10.1.2 [[SetPrototypeOf]] ( V )
         10.1.2.1 OrdinarySetPrototypeOf ( O, V )
      10.1.3 [[IsExtensible]] ( )
         10.1.3.1 OrdinaryIsExtensible ( O )
      10.1.4 [[PreventExtensions]] ( )
         10.1.4.1 OrdinaryPreventExtensions ( O )
      10.1.5 [[GetOwnProperty]] ( P )
         10.1.5.1 OrdinaryGetOwnProperty ( O, P )
      10.1.6 [[DefineOwnProperty]] ( P, Desc )
         10.1.6.1 OrdinaryDefineOwnProperty ( O, P, Desc )
         10.1.6.2 IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )
         10.1.6.3 ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )
      10.1.7 [[HasProperty]] ( P )
         10.1.7.1 OrdinaryHasProperty ( O, P )
      10.1.8 [[Get]] ( P, Receiver )
         10.1.8.1 OrdinaryGet ( O, P, Receiver )
      10.1.9 [[Set]] ( P, V, Receiver )
         10.1.9.1 OrdinarySet ( O, P, V, Receiver )
         10.1.9.2 OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )
      10.1.10 [[Delete]] ( P )
         10.1.10.1 OrdinaryDelete ( O, P )
      10.1.11 [[OwnPropertyKeys]] ( )
      10.1.11.1 OrdinaryOwnPropertyKeys ( O )
      10.1.12 OrdinaryObjectCreate ( proto [ , additionalInternalSlotsList ] )
      10.1.13 OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )
      10.1.14 GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )
      10.1.15 RequireInternalSlot ( O, internalSlot )
   10.2 ECMAScript Function Objects
      10.2.1 [[Call]] ( thisArgument, argumentsList )
         10.2.1.1 PrepareForOrdinaryCall ( F, newTarget )
         10.2.1.2 OrdinaryCallBindThis ( F, calleeContext, thisArgument )
         10.2.1.3 RS: EvaluateBody
         10.2.1.4 OrdinaryCallEvaluateBody ( F, argumentsList )
      10.2.2 [[Construct]] ( argumentsList, newTarget )
      10.2.3 OrdinaryFunctionCreate ( functionPrototype, sourceText, ParameterList, Body, thisMode, env, privateEnv )
      10.2.4 AddRestrictedFunctionProperties ( F, realm )
         10.2.4.1 %ThrowTypeError% ( )
      10.2.5 MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )
      10.2.6 MakeClassConstructor ( F )
      10.2.7 MakeMethod ( F, homeObject )
      10.2.8 DefineMethodProperty ( homeObject, key, closure, enumerable )
      10.2.9 SetFunctionName ( F, name [ , prefix ] )
      10.2.10 SetFunctionLength ( F, length )
      10.2.11 FunctionDeclarationInstantiation ( func, argumentsList )
   10.3 Built-in Function Objects
      10.3.1 [[Call]] ( thisArgument, argumentsList )
      10.3.2 [[Construct]] ( argumentsList, newTarget )
      10.3.3 BuiltinCallOrConstruct ( F, thisArgument, argumentsList, newTarget )
      10.3.4 CreateBuiltinFunction ( behaviour, length, name, additionalInternalSlotsList [ , realm [ , prototype [ , prefix ] ] ] )
   10.4 Built-in Exotic Object Internal Methods and Slots
      10.4.1 Bound Function Exotic Objects
         10.4.1.1 [[Call]] ( thisArgument, argumentsList )
         10.4.1.2 [[Construct]] ( argumentsList, newTarget )
         10.4.1.3 BoundFunctionCreate ( targetFunction, boundThis, boundArgs )
      10.4.2 Array Exotic Objects
      10.4.2.1 [[DefineOwnProperty]] ( P, Desc )
         10.4.2.2 ArrayCreate ( length [ , proto ] )
         10.4.2.3 ArraySpeciesCreate ( originalArray, length )
         10.4.2.4 ArraySetLength ( A, Desc )
      10.4.3 String Exotic Objects
         10.4.3.1 [[GetOwnProperty]] ( P )
         10.4.3.2 [[DefineOwnProperty]] ( P, Desc )
         10.4.3.3 [[OwnPropertyKeys]] ( )
         10.4.3.4 StringCreate ( value, prototype )
         10.4.3.5 StringGetOwnProperty ( S, P )
      10.4.4 Arguments Exotic Objects
         10.4.4.1 [[GetOwnProperty]] ( P )
         10.4.4.2 [[DefineOwnProperty]] ( P, Desc )
         10.4.4.3 [[Get]] ( P, Receiver )
         10.4.4.4 [[Set]] ( P, V, Receiver )
         10.4.4.5 [[Delete]] ( P )
         10.4.4.6 CreateUnmappedArgumentsObject ( argumentsList )
         10.4.4.7 CreateMappedArgumentsObject ( func, formals, argumentsList, env )
            10.4.4.7.1 MakeArgGetter ( name, env )
            10.4.4.7.2 MakeArgSetter ( name, env )
      10.4.5 TypedArray Exotic Objects
         10.4.5.1 [[GetOwnProperty]] ( P )
         10.4.5.2 [[HasProperty]] ( P )
         10.4.5.3 [[DefineOwnProperty]] ( P, Desc )
         10.4.5.4 [[Get]] ( P, Receiver )
         10.4.5.5 [[Set]] ( P, V, Receiver )
         10.4.5.6 [[Delete]] ( P )
         10.4.5.7 [[OwnPropertyKeys]] ( )
         10.4.5.8 TypedArray With Buffer Witness Records
         10.4.5.9 MakeTypedArrayWithBufferWitnessRecord ( obj, order )
         10.4.5.10 TypedArrayCreate ( prototype )
         10.4.5.11 TypedArrayByteLength ( taRecord )
         10.4.5.12 TypedArrayLength ( taRecord )
         10.4.5.13 IsTypedArrayOutOfBounds ( taRecord )
         10.4.5.14 IsValidIntegerIndex ( O, index )
         10.4.5.15 TypedArrayGetElement ( O, index )
         10.4.5.16 TypedArraySetElement ( O, index, value )
         10.4.5.17 IsArrayBufferViewOutOfBounds ( O )
      10.4.6 Module Namespace Exotic Objects
         10.4.6.1 [[GetPrototypeOf]] ( )
         10.4.6.2 [[SetPrototypeOf]] ( V )
         10.4.6.3 [[IsExtensible]] ( )
         10.4.6.4 [[PreventExtensions]] ( )
         10.4.6.5 [[GetOwnProperty]] ( P )
         10.4.6.6 [[DefineOwnProperty]] ( P, Desc )
         10.4.6.7 [[HasProperty]] ( P )
         10.4.6.8 [[Get]] ( P, Receiver )
         10.4.6.9 [[Set]] ( P, V, Receiver )
         10.4.6.10 [[Delete]] ( P )
         10.4.6.11 [[OwnPropertyKeys]] ( )
         10.4.6.12 ModuleNamespaceCreate ( module, exports )
      10.4.7 Immutable Prototype Exotic Objects
         10.4.7.1 [[SetPrototypeOf]] ( V )
         10.4.7.2 SetImmutablePrototype ( O, V )
   10.5 Proxy Object Internal Methods and Internal Slots
      10.5.1 [[GetPrototypeOf]] ( )
      10.5.2 [[SetPrototypeOf]] ( V )
      10.5.3 [[IsExtensible]] ( )
      10.5.4 [[PreventExtensions]] ( )
      10.5.5 [[GetOwnProperty]] ( P )
      10.5.6 [[DefineOwnProperty]] ( P, Desc )
      10.5.7 [[HasProperty]] ( P )
      10.5.8 [[Get]] ( P, Receiver )
      10.5.9 [[Set]] ( P, V, Receiver )
      10.5.10 [[Delete]] ( P )
      10.5.11 [[OwnPropertyKeys]] ( )
      10.5.12 [[Call]] ( thisArgument, argumentsList )
      10.5.13 [[Construct]] ( argumentsList, newTarget )
      10.5.14 ValidateNonRevokedProxy ( proxy )
      10.5.15 ProxyCreate ( target, handler )

Ordinary Object Internal Methods and Internal Slots
---------------------------------------------------

All ordinary objects have an internal slot called [[Prototype]]. The
value of this internal slot is either `null` or an object and is used
for implementing inheritance. Assume a property named P is missing
from an ordinary object O but exists on its [[Prototype]] object. If
P refers to a data property on the [[Prototype]] object, O
inherits it for get access, making it behave as if P was a property
of O. If P refers to a writable data property on the
[[Prototype]] object, set access of P on O creates a new data
property named P on O. If P refers to a non-writable data
property on the [[Prototype]] object, set access of P on O
fails. If P refers to an accessor property on the [[Prototype]]
object, the accessor is inherited by O for both get access and set
access.

Every ordinary object has a Boolean-valued [[Extensible]] internal slot
which is used to fulfill the extensibility-related internal method
invariants specified in . Namely, once the value of an object's
[[Extensible]] internal slot has been set to `false`, it is no longer
possible to add properties to the object, to modify the value of the
object's [[Prototype]] internal slot, or to subsequently change the
value of [[Extensible]] to `true`.

In the following algorithm descriptions, assume O is an ordinary
object, P is a property key value, V is any ECMAScript language
value, and Desc is a Property Descriptor record.

Each ordinary object internal method delegates to a similarly-named
abstract operation. If such an abstract operation depends on another
internal method, then the internal method is invoked on O rather
than calling the similarly-named abstract operation directly. These
semantics ensure that exotic objects have their overridden internal
methods invoked when ordinary object internal methods are applied to
them.

[[GetPrototypeOf]] ( ): a normal completion containing either an Object or `null`
-----------------------------------------------------------------------------------

for
   an ordinary object O

1. Return OrdinaryGetPrototypeOf(O).

OrdinaryGetPrototypeOf ( O: an Object, ): an Object or `null`
-------------------------------------------------------------------

1. Return O.[[Prototype]].

[[SetPrototypeOf]] ( V: an Object or `null`, ): a normal completion containing a Boolean
----------------------------------------------------------------------------------------------

for
   an ordinary object O

1. Return OrdinarySetPrototypeOf(O, V).

OrdinarySetPrototypeOf ( O: an Object, V: an Object or `null`, ): a Boolean
-------------------------------------------------------------------------------------

1. Let current be O.[[Prototype]]. 1. If SameValue(V,
current) is `true`, return `true`. 1. Let extensible be
O.[[Extensible]]. 1. If extensible is `false`, return
`false`. 1. Let p be V. 1. Let done be `false`. 1.
[id="step-ordinarysetprototypeof-loop"] Repeat, while done is
`false`, 1. If p is `null`, then 1. Set done to `true`. 1.
Else if SameValue(p, O) is `true`, then 1. Return `false`.
1. Else, 1. If p.[[GetPrototypeOf]] is not the ordinary object
internal method defined in , set done to `true`. 1. Else, set
p to p.[[Prototype]]. 1. Set O.[[Prototype]] to V. 1.
Return `true`.

The loop in step guarantees that there will be no cycles in any
prototype chain that only includes objects that use the ordinary object
definitions for [[GetPrototypeOf]] and [[SetPrototypeOf]].

[[IsExtensible]] ( ): a normal completion containing a Boolean
--------------------------------------------------------------

for
   an ordinary object O

1. Return OrdinaryIsExtensible(O).

OrdinaryIsExtensible ( O: an Object, ): a Boolean
-----------------------------------------------------

1. Return O.[[Extensible]].

[[PreventExtensions]] ( ): a normal completion containing `true`
------------------------------------------------------------------

for
   an ordinary object O

1. Return OrdinaryPreventExtensions(O).

OrdinaryPreventExtensions ( O: an Object, ): `true`
---------------------------------------------------------

1. Set O.[[Extensible]] to `false`. 1. Return `true`.

[[GetOwnProperty]] ( P: a property key, ): a normal completion containing either a Property Descriptor or `undefined`
---------------------------------------------------------------------------------------------------------------------------

for
   an ordinary object O

1. Return OrdinaryGetOwnProperty(O, P).

OrdinaryGetOwnProperty ( O: an Object, P: a property key, ): a Property Descriptor or `undefined`
-----------------------------------------------------------------------------------------------------------

1. If O does not have an own property with key P, return
`undefined`. 1. Let D be a newly created Property Descriptor with
no fields. 1. Let X be O's own property whose key is P. 1.
If X is a data property, then 1. Set D.[[Value]] to the value of
X's [[Value]] attribute. 1. Set D.[[Writable]] to the value of
X's [[Writable]] attribute. 1. Else, 1. Assert: X is an accessor
property. 1. Set D.[[Get]] to the value of X's [[Get]]
attribute. 1. Set D.[[Set]] to the value of X's [[Set]]
attribute. 1. Set D.[[Enumerable]] to the value of X's
[[Enumerable]] attribute. 1. Set D.[[Configurable]] to the value of
X's [[Configurable]] attribute. 1. Return D.

[[DefineOwnProperty]] ( P: a property key, Desc: a Property Descriptor, )
-------------------------------------------------------------------------

for
   an ordinary object O

1. Return ? OrdinaryDefineOwnProperty(O, P, Desc).

OrdinaryDefineOwnProperty ( O: an Object, P: a property key, Desc: a Property Descriptor, )
-------------------------------------------------------------------------------------------

1. Let current be ? O.[[GetOwnProperty]](P). 1. Let
extensible be ? IsExtensible(O). 1. Return
ValidateAndApplyPropertyDescriptor(O, P, extensible,
Desc, current).

IsCompatiblePropertyDescriptor ( Extensible: a Boolean, Desc: a Property Descriptor, Current: a Property Descriptor or `undefined`, ): a Boolean
--------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Return ValidateAndApplyPropertyDescriptor(`undefined`, `""`,
Extensible, Desc, Current).

ValidateAndApplyPropertyDescriptor ( O: an Object or `undefined`, P: a property key, extensible: a Boolean, Desc: a Property Descriptor, current: a Property Descriptor or `undefined`, ): a Boolean
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It returns `true` if and only if Desc can be applied as the
   property of an object with specified extensibility and current
   property current while upholding invariants. When such
   application is possible and O is not `undefined`, it is
   performed for the property named P (which is created if
   necessary).

1. Assert: P is a property key. 1. If current is `undefined`,
then 1. If extensible is `false`, return `false`. 1. If O is
`undefined`, return `true`. 1. If IsAccessorDescriptor(Desc) is
`true`, then 1. Create an own accessor property named P of object
O whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]]
attributes are set to the value of the corresponding field in Desc
if Desc has that field, or to the attribute's default value
otherwise. 1. Else, 1. Create an own data property named P of object
O whose [[Value]], [[Writable]], [[Enumerable]], and
[[Configurable]] attributes are set to the value of the corresponding
field in Desc if Desc has that field, or to the attribute's
default value otherwise. 1. Return `true`. 1. Assert: current is a
fully populated Property Descriptor. 1. If Desc does not have any
fields, return `true`. 1. If current.[[Configurable]] is
`false`, then 1. If Desc has a [[Configurable]] field and
Desc.[[Configurable]] is `true`, return `false`. 1. If Desc
has an [[Enumerable]] field and Desc.[[Enumerable]] is not
current.[[Enumerable]], return `false`. 1. If
IsGenericDescriptor(Desc) is `false` and
IsAccessorDescriptor(Desc) is not IsAccessorDescriptor(current),
return `false`. 1. If IsAccessorDescriptor(current) is `true`,
then 1. If Desc has a [[Get]] field and SameValue(Desc.[[Get]],
current.[[Get]]) is `false`, return `false`. 1. If Desc has
a [[Set]] field and SameValue(Desc.[[Set]], current.[[Set]]) is
`false`, return `false`. 1. Else if current.[[Writable]] is
`false`, then 1. If Desc has a [[Writable]] field and
Desc.[[Writable]] is `true`, return `false`. 1. NOTE: SameValue
returns `true` for `NaN` values which may be distinguishable by
other means. Returning here ensures that any existing property of O
remains unmodified. 1. If Desc has a [[Value]] field, return
SameValue(Desc.[[Value]], current.[[Value]]). 1. If O is not
`undefined`, then 1. If IsDataDescriptor(current) is `true` and
IsAccessorDescriptor(Desc) is `true`, then 1. If Desc has a
[[Configurable]] field, let configurable be
Desc.[[Configurable]]; else let configurable be
current.[[Configurable]]. 1. If Desc has a [[Enumerable]] field,
let enumerable be Desc.[[Enumerable]]; else let enumerable
be current.[[Enumerable]]. 1. Replace the property named P of
object O with an accessor property whose [[Configurable]] and
[[Enumerable]] attributes are set to configurable and
enumerable, respectively, and whose [[Get]] and [[Set]] attributes
are set to the value of the corresponding field in Desc if Desc
has that field, or to the attribute's default value otherwise. 1. Else
if IsAccessorDescriptor(current) is `true` and
IsDataDescriptor(Desc) is `true`, then 1. If Desc has a
[[Configurable]] field, let configurable be
Desc.[[Configurable]]; else let configurable be
current.[[Configurable]]. 1. If Desc has a [[Enumerable]] field,
let enumerable be Desc.[[Enumerable]]; else let enumerable
be current.[[Enumerable]]. 1. Replace the property named P of
object O with a data property whose [[Configurable]] and
[[Enumerable]] attributes are set to configurable and
enumerable, respectively, and whose [[Value]] and [[Writable]]
attributes are set to the value of the corresponding field in Desc
if Desc has that field, or to the attribute's default value
otherwise. 1. Else, 1. For each field of Desc, set the corresponding
attribute of the property named P of object O to the value of
the field. 1. Return `true`.

[[HasProperty]] ( P: a property key, )
--------------------------------------

for
   an ordinary object O

1. Return ? OrdinaryHasProperty(O, P).

OrdinaryHasProperty ( O: an Object, P: a property key, )
--------------------------------------------------------

1. Let hasOwn be ? O.[[GetOwnProperty]](P). 1. If hasOwn
is not `undefined`, return `true`. 1. Let parent be ?
O.[[GetPrototypeOf]](). 1. If parent is not `null`, then 1.
Return ? parent.[[HasProperty]](P). 1. Return `false`.

[[Get]] ( P: a property key, Receiver, )
----------------------------------------

for
   an ordinary object O

1. Return ? OrdinaryGet(O, P, Receiver).

OrdinaryGet ( O: an Object, P: a property key, Receiver, )
----------------------------------------------------------

1. Let desc be ? O.[[GetOwnProperty]](P). 1. If desc is
`undefined`, then 1. Let parent be ? O.[[GetPrototypeOf]]().
1. If parent is `null`, return `undefined`. 1. Return ?
parent.[[Get]](P, Receiver). 1. If
IsDataDescriptor(desc) is `true`, return desc.[[Value]]. 1.
Assert: IsAccessorDescriptor(desc) is `true`. 1. Let getter be
desc.[[Get]]. 1. If getter is `undefined`, return
`undefined`. 1. Return ? Call(getter, Receiver).

[[Set]] ( P: a property key, V, Receiver, )
-------------------------------------------

for
   an ordinary object O

1. Return ? OrdinarySet(O, P, V, Receiver).

OrdinarySet ( O: an Object, P: a property key, V, Receiver, )
-------------------------------------------------------------

1. Let ownDesc be ? O.[[GetOwnProperty]](P). 1. Return ?
OrdinarySetWithOwnDescriptor(O, P, V, Receiver,
ownDesc).

OrdinarySetWithOwnDescriptor ( O: an Object, P: a property key, V, Receiver, ownDesc: a Property Descriptor or `undefined`, )
-----------------------------------------------------------------------------------------------------------------------------

1. If ownDesc is `undefined`, then 1. Let parent be ?
O.[[GetPrototypeOf]](). 1. If parent is not `null`, then 1.
Return ? parent.[[Set]](P, V, Receiver). 1. Else, 1. Set
ownDesc to the PropertyDescriptor { [[Value]]: `undefined`,
[[Writable]]: `true`, [[Enumerable]]: `true`, [[Configurable]]:
`true` }. 1. If IsDataDescriptor(ownDesc) is `true`, then 1. If
ownDesc.[[Writable]] is `false`, return `false`. 1. If
Receiver is not an Object, return `false`. 1. Let
existingDescriptor be ? Receiver.[[GetOwnProperty]](P). 1.
If existingDescriptor is not `undefined`, then 1. If
IsAccessorDescriptor(existingDescriptor) is `true`, return
`false`. 1. If existingDescriptor.[[Writable]] is `false`,
return `false`. 1. Let valueDesc be the PropertyDescriptor {
[[Value]]: V }. 1. Return ?
Receiver.[[DefineOwnProperty]](P, valueDesc). 1. Else, 1.
Assert: Receiver does not currently have a property P. 1. Return
? CreateDataProperty(Receiver, P, V). 1. Assert:
IsAccessorDescriptor(ownDesc) is `true`. 1. Let setter be
ownDesc.[[Set]]. 1. If setter is `undefined`, return
`false`. 1. Perform ? Call(setter, Receiver, « V »). 1.
Return `true`.

[[Delete]] ( P: a property key, )
---------------------------------

for
   an ordinary object O

1. Return ? OrdinaryDelete(O, P).

OrdinaryDelete ( O: an Object, P: a property key, )
---------------------------------------------------

1. Let desc be ? O.[[GetOwnProperty]](P). 1. If desc is
`undefined`, return `true`. 1. If desc.[[Configurable]] is
`true`, then 1. Remove the own property with name P from O. 1.
Return `true`. 1. Return `false`.

[[OwnPropertyKeys]] ( ): a normal completion containing a List of property keys
-------------------------------------------------------------------------------

for
   an ordinary object O

1. Return OrdinaryOwnPropertyKeys(O).

OrdinaryOwnPropertyKeys ( O: an Object, ): a List of property keys
----------------------------------------------------------------------

1. Let keys be a new empty List. 1. For each own property key P
of O such that P is an array index, in ascending numeric index
order, do 1. Append P to keys. 1. For each own property key
P of O such that P is a String and P is not an array
index, in ascending chronological order of property creation, do 1.
Append P to keys. 1. For each own property key P of O
such that P is a Symbol, in ascending chronological order of
property creation, do 1. Append P to keys. 1. Return keys.

OrdinaryObjectCreate ( proto: an Object or `null`, optional additionalInternalSlotsList: a List of names of internal slots, ): an Object
--------------------------------------------------------------------------------------------------------------------------------------------------

description
   It is used to specify the runtime creation of new ordinary objects.
   additionalInternalSlotsList contains the names of additional
   internal slots that must be defined as part of the object, beyond
   [[Prototype]] and [[Extensible]]. If additionalInternalSlotsList
   is not provided, a new empty List is used.

1. Let internalSlotsList be « [[Prototype]], [[Extensible]] ». 1. If
additionalInternalSlotsList is present, set internalSlotsList to
the list-concatenation of internalSlotsList and
additionalInternalSlotsList. 1. Let O be
MakeBasicObject(internalSlotsList). 1. Set O.[[Prototype]] to
proto. 1. Return O.

Although OrdinaryObjectCreate does little more than call
MakeBasicObject, its use communicates the intention to create an
ordinary object, and not an exotic one. Thus, within this specification,
it is not called by any algorithm that subsequently modifies the
internal methods of the object in ways that would make the result
non-ordinary. Operations that create exotic objects invoke
MakeBasicObject directly.

OrdinaryCreateFromConstructor ( constructor: a function object, intrinsicDefaultProto: a String, optional internalSlotsList: a List of names of internal slots, )
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It creates an ordinary object whose [[Prototype]] value is retrieved
   from a constructor's `"prototype"` property, if it exists.
   Otherwise the intrinsic named by intrinsicDefaultProto is used
   for [[Prototype]]. internalSlotsList contains the names of
   additional internal slots that must be defined as part of the object.
   If internalSlotsList is not provided, a new empty List is used.

1. Assert: intrinsicDefaultProto is this specification's name of an
intrinsic object. The corresponding object must be an intrinsic that is
intended to be used as the [[Prototype]] value of an object. 1. Let
proto be ? GetPrototypeFromConstructor(constructor,
intrinsicDefaultProto). 1. If internalSlotsList is present, let
slotsList be internalSlotsList. 1. Else, let slotsList be a
new empty List. 1. Return OrdinaryObjectCreate(proto,
slotsList).

GetPrototypeFromConstructor ( constructor: a function object, intrinsicDefaultProto: a String, )
------------------------------------------------------------------------------------------------

description
   It determines the [[Prototype]] value that should be used to create
   an object corresponding to a specific constructor. The value is
   retrieved from the constructor's `"prototype"` property, if it
   exists. Otherwise the intrinsic named by intrinsicDefaultProto is
   used for [[Prototype]].

1. Assert: intrinsicDefaultProto is this specification's name of an
intrinsic object. The corresponding object must be an intrinsic that is
intended to be used as the [[Prototype]] value of an object. 1. Let
proto be ? Get(constructor, `"prototype"`). 1. If proto is
not an Object, then 1. Let realm be ?
GetFunctionRealm(constructor). 1. Set proto to realm's
intrinsic object named intrinsicDefaultProto. 1. Return proto.

If constructor does not supply a [[Prototype]] value, the default
value that is used is obtained from the realm of the constructor
function rather than from the running execution context.

RequireInternalSlot ( O, internalSlot: an internal slot name, )
---------------------------------------------------------------

description
   It throws an exception unless O is an Object and has the given
   internal slot.

1. If O is not an Object, throw a `TypeError` exception. 1. If
O does not have an internalSlot internal slot, throw a
`TypeError` exception. 1. Return ~unused~.

ECMAScript Function Objects
---------------------------

ECMAScript function objects encapsulate parameterized ECMAScript code
closed over a lexical environment and support the dynamic evaluation of
that code. An ECMAScript function object is an ordinary object and has
the same internal slots and the same internal methods as other ordinary
objects. The code of an ECMAScript function object may be either strict
mode code () or non-strict code. An ECMAScript function object whose
code is strict mode code is called a strict function. One whose code is
not strict mode code is called a non-strict function.

In addition to [[Extensible]] and [[Prototype]], ECMAScript function
objects also have the internal slots listed in .

+----------------------+----------------------+----------------------+
| Internal Slot        | Type                 | Description          |
+======================+======================+======================+
| [[Environment]]      | an Environment       | The Environment      |
|                      | Record               | Record that the      |
|                      |                      | function was closed  |
|                      |                      | over. Used as the    |
|                      |                      | outer environment    |
|                      |                      | when evaluating the  |
|                      |                      | code of the          |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+
| [[                   | a PrivateEnvironment | The                  |
| PrivateEnvironment]] | Record or `null`   | PrivateEnvironment   |
|                      |                      | Record for Private   |
|                      |                      | Names that the       |
|                      |                      | function was closed  |
|                      |                      | over. `null` if    |
|                      |                      | this function is not |
|                      |                      | syntactically        |
|                      |                      | contained within a   |
|                      |                      | class. Used as the   |
|                      |                      | outer                |
|                      |                      | PrivateEnvironment   |
|                      |                      | for inner classes    |
|                      |                      | when evaluating the  |
|                      |                      | code of the          |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+
| [[FormalParameters]] | a Parse Node         | The root parse node  |
|                      |                      | of the source text   |
|                      |                      | that defines the     |
|                      |                      | function's formal    |
|                      |                      | parameter list.      |
+----------------------+----------------------+----------------------+
| [[ECMAScriptCode]]   | a Parse Node         | The root parse node  |
|                      |                      | of the source text   |
|                      |                      | that defines the     |
|                      |                      | function's body.     |
+----------------------+----------------------+----------------------+
| [[ConstructorKind]]  | ~base~ or ~derived~  | Whether or not the   |
|                      |                      | function is a        |
|                      |                      | derived class        |
|                      |                      | constructor.         |
+----------------------+----------------------+----------------------+
| [[Realm]]            | a Realm Record       | The realm in which   |
|                      |                      | the function was     |
|                      |                      | created and which    |
|                      |                      | provides any         |
|                      |                      | intrinsic objects    |
|                      |                      | that are accessed    |
|                      |                      | when evaluating the  |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+
| [[ScriptOrModule]]   | a Script Record or a | The script or module |
|                      | Module Record        | in which the         |
|                      |                      | function was         |
|                      |                      | created.             |
+----------------------+----------------------+----------------------+
| [[ThisMode]]         | ~lexical~, ~strict~, | Defines how `this` |
|                      | or ~global~          | references are       |
|                      |                      | interpreted within   |
|                      |                      | the formal           |
|                      |                      | parameters and code  |
|                      |                      | body of the          |
|                      |                      | function. ~lexical~  |
|                      |                      | means that `this`  |
|                      |                      | refers to the        |
|                      |                      | `this` value of a  |
|                      |                      | lexically enclosing  |
|                      |                      | function. ~strict~   |
|                      |                      | means that the       |
|                      |                      | `this` value is    |
|                      |                      | used exactly as      |
|                      |                      | provided by an       |
|                      |                      | invocation of the    |
|                      |                      | function. ~global~   |
|                      |                      | means that a         |
|                      |                      | `this` value of    |
|                      |                      | `undefined` or     |
|                      |                      | `null` is          |
|                      |                      | interpreted as a     |
|                      |                      | reference to the     |
|                      |                      | global object, and   |
|                      |                      | any other `this`   |
|                      |                      | value is first       |
|                      |                      | passed to ToObject.  |
+----------------------+----------------------+----------------------+
| [[Strict]]           | a Boolean            | `true` if this is  |
|                      |                      | a strict function,   |
|                      |                      | `false` if this is |
|                      |                      | a non-strict         |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+
| [[HomeObject]]       | an Object            | If the function uses |
|                      |                      | `super`, this is   |
|                      |                      | the object whose     |
|                      |                      | [[GetPrototypeOf]]   |
|                      |                      | provides the object  |
|                      |                      | where `super`      |
|                      |                      | property lookups     |
|                      |                      | begin.               |
+----------------------+----------------------+----------------------+
| [[SourceText]]       | a sequence of        | The source text that |
|                      | Unicode code points  | defines the          |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+
| [[Fields]]           | a List of            | If the function is a |
|                      | ClassFieldDefinition | class, this is a     |
|                      | Records              | list of Records      |
|                      |                      | representing the     |
|                      |                      | non-static fields    |
|                      |                      | and corresponding    |
|                      |                      | initializers of the  |
|                      |                      | class.               |
+----------------------+----------------------+----------------------+
| [[PrivateMethods]]   | a List of            | If the function is a |
|                      | PrivateElements      | class, this is a     |
|                      |                      | list representing    |
|                      |                      | the non-static       |
|                      |                      | private methods and  |
|                      |                      | accessors of the     |
|                      |                      | class.               |
+----------------------+----------------------+----------------------+
| [[ClassFi            | a String, a Symbol,  | If the function is   |
| eldInitializerName]] | a Private Name, or   | created as the       |
|                      | ~empty~              | initializer of a     |
|                      |                      | class field, the     |
|                      |                      | name to use for      |
|                      |                      | NamedEvaluation of   |
|                      |                      | the field; ~empty~   |
|                      |                      | otherwise.           |
+----------------------+----------------------+----------------------+
| [[                   | a Boolean            | Indicates whether    |
| IsClassConstructor]] |                      | the function is a    |
|                      |                      | class constructor.   |
|                      |                      | (If `true`,        |
|                      |                      | invoking the         |
|                      |                      | function's [[Call]]  |
|                      |                      | will immediately     |
|                      |                      | throw a              |
|                      |                      | `TypeError`        |
|                      |                      | exception.)          |
+----------------------+----------------------+----------------------+

All ECMAScript function objects have the [[Call]] internal method
defined here. ECMAScript functions that are also constructors in
addition have the [[Construct]] internal method.

[[Call]] ( thisArgument, argumentsList: a List of ECMAScript language values, )
-------------------------------------------------------------------------------

for
   an ECMAScript function object F

1. Let callerContext be the running execution context. 1. Let
calleeContext be PrepareForOrdinaryCall(F, `undefined`). 1.
Assert: calleeContext is now the running execution context. 1. If
F.[[IsClassConstructor]] is `true`, then 1. Let error be a
newly created `TypeError` object. 1. NOTE: error is created in
calleeContext with F's associated Realm Record. 1. Remove
calleeContext from the execution context stack and restore
callerContext as the running execution context. 1. Return
ThrowCompletion(error). 1. Perform OrdinaryCallBindThis(F,
calleeContext, thisArgument). 1. Let result be
Completion(OrdinaryCallEvaluateBody(F, argumentsList)). 1.
[id="step-call-pop-context-stack"] Remove calleeContext from the
execution context stack and restore callerContext as the running
execution context. 1. If result is a return completion, return
result.[[Value]]. 1. ReturnIfAbrupt(result). 1. Return
`undefined`.

When calleeContext is removed from the execution context stack in
step it must not be destroyed if it is suspended and retained for later
resumption by an accessible Generator.

PrepareForOrdinaryCall ( F: an ECMAScript function object, newTarget: an Object or `undefined`, ): an execution context
---------------------------------------------------------------------------------------------------------------------------------

1. Let callerContext be the running execution context. 1. Let
calleeContext be a new ECMAScript code execution context. 1. Set the
Function of calleeContext to F. 1. Let calleeRealm be
F.[[Realm]]. 1. Set the Realm of calleeContext to
calleeRealm. 1. Set the ScriptOrModule of calleeContext to
F.[[ScriptOrModule]]. 1. Let localEnv be
NewFunctionEnvironment(F, newTarget). 1. Set the
LexicalEnvironment of calleeContext to localEnv. 1. Set the
VariableEnvironment of calleeContext to localEnv. 1. Set the
PrivateEnvironment of calleeContext to F.[[PrivateEnvironment]].
1. If callerContext is not already suspended, suspend
callerContext. 1. Push calleeContext onto the execution context
stack; calleeContext is now the running execution context. 1. NOTE:
Any exception objects produced after this point are associated with
calleeRealm. 1. Return calleeContext.

OrdinaryCallBindThis ( F: an ECMAScript function object, calleeContext: an execution context, thisArgument, ): ~unused~
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let thisMode be F.[[ThisMode]]. 1. If thisMode is
~lexical~, return ~unused~. 1. Let calleeRealm be F.[[Realm]].
1. Let localEnv be the LexicalEnvironment of calleeContext. 1.
If thisMode is ~strict~, then 1. Let thisValue be
thisArgument. 1. Else, 1. If thisArgument is either
`undefined` or `null`, then 1. Let globalEnv be
calleeRealm.[[GlobalEnv]]. 1. Assert: globalEnv is a Global
Environment Record. 1. Let thisValue be
globalEnv.[[GlobalThisValue]]. 1. Else, 1. Let thisValue be !
ToObject(thisArgument). 1. NOTE: ToObject produces wrapper objects
using calleeRealm. 1. Assert: localEnv is a Function Environment
Record. 1. Assert: The next step never returns an abrupt completion
because localEnv.[[ThisBindingStatus]] is not ~initialized~. 1.
Perform ! localEnv.BindThisValue(thisValue). 1. Return ~unused~.

Runtime Semantics: EvaluateBody ( functionObject: an ECMAScript function object, argumentsList: a List of ECMAScript language values, )
---------------------------------------------------------------------------------------------------------------------------------------

FunctionBody : FunctionStatementList 1. Return ? EvaluateFunctionBody of
`FunctionBody` with arguments functionObject and
argumentsList. ConciseBody : ExpressionBody 1. Return ?
EvaluateConciseBody of `ConciseBody` with arguments functionObject
and argumentsList. GeneratorBody : FunctionBody 1. Return ?
EvaluateGeneratorBody of `GeneratorBody` with arguments
functionObject and argumentsList. AsyncGeneratorBody :
FunctionBody 1. Return ? EvaluateAsyncGeneratorBody of
`AsyncGeneratorBody` with arguments functionObject and
argumentsList. AsyncFunctionBody : FunctionBody 1. Return ?
EvaluateAsyncFunctionBody of `AsyncFunctionBody` with arguments
functionObject and argumentsList. AsyncConciseBody :
ExpressionBody 1. Return ? EvaluateAsyncConciseBody of
`AsyncConciseBody` with arguments functionObject and
argumentsList. Initializer : `=` AssignmentExpression 1. Assert:
argumentsList is empty. 1. Assert:
functionObject.[[ClassFieldInitializerName]] is not ~empty~. 1. If
IsAnonymousFunctionDefinition(`AssignmentExpression`) is `true`,
then 1. Let value be ? NamedEvaluation of `Initializer` with
argument functionObject.[[ClassFieldInitializerName]]. 1. Else, 1.
Let rhs be ? Evaluation of `AssignmentExpression`. 1. Let
value be ? GetValue(rhs). 1. Return ReturnCompletion(value).

Even though field initializers constitute a function boundary, calling
FunctionDeclarationInstantiation does not have any observable effect and
so is omitted.

ClassStaticBlockBody : ClassStaticBlockStatementList 1. Assert:
argumentsList is empty. 1. Return ? EvaluateClassStaticBlockBody of
`ClassStaticBlockBody` with argument functionObject.

OrdinaryCallEvaluateBody ( F: an ECMAScript function object, argumentsList: a List of ECMAScript language values, )
-------------------------------------------------------------------------------------------------------------------

1. Return ? EvaluateBody of F.[[ECMAScriptCode]] with arguments
F and argumentsList.

[[Construct]] ( argumentsList: a List of ECMAScript language values, newTarget: a constructor, )
------------------------------------------------------------------------------------------------

for
   an ECMAScript function object F

1. Let callerContext be the running execution context. 1. Let
kind be F.[[ConstructorKind]]. 1. If kind is ~base~, then 1.
Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget,
`"%Object.prototype%"`). 1. Let calleeContext be
PrepareForOrdinaryCall(F, newTarget). 1. Assert:
calleeContext is now the running execution context. 1. If kind
is ~base~, then 1. Perform OrdinaryCallBindThis(F,
calleeContext, thisArgument). 1. Let initializeResult be
Completion(InitializeInstanceElements(thisArgument, F)). 1. If
initializeResult is an abrupt completion, then 1. Remove
calleeContext from the execution context stack and restore
callerContext as the running execution context. 1. Return ?
initializeResult. 1. Let constructorEnv be the
LexicalEnvironment of calleeContext. 1. Let result be
Completion(OrdinaryCallEvaluateBody(F, argumentsList)). 1.
Remove calleeContext from the execution context stack and restore
callerContext as the running execution context. 1. If result is
a return completion, then 1. If result.[[Value]] is an Object,
return result.[[Value]]. 1. If kind is ~base~, return
thisArgument. 1. If result.[[Value]] is not `undefined`, throw
a `TypeError` exception. 1. Else, 1. ReturnIfAbrupt(result). 1.
Let thisBinding be ? constructorEnv.GetThisBinding(). 1. Assert:
thisBinding is an Object. 1. Return thisBinding.

OrdinaryFunctionCreate ( functionPrototype: an Object, sourceText: a sequence of Unicode code points, ParameterList: a Parse Node, Body: a Parse Node, thisMode: ~lexical-this~ or ~non-lexical-this~, env: an Environment Record, privateEnv: a PrivateEnvironment Record or `null`, ): an ECMAScript function object
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It is used to specify the runtime creation of a new function with a
   default [[Call]] internal method and no [[Construct]] internal method
   (although one may be subsequently added by an operation such as
   MakeConstructor). sourceText is the source text of the syntactic
   definition of the function to be created.

1. Let internalSlotsList be the internal slots listed in . 1. Let
F be OrdinaryObjectCreate(functionPrototype,
internalSlotsList). 1. Set F.[[Call]] to the definition
specified in . 1. Set F.[[SourceText]] to sourceText. 1. Set
F.[[FormalParameters]] to ParameterList. 1. Set
F.[[ECMAScriptCode]] to Body. 1. Let Strict be
IsStrict(Body). 1. Set F.[[Strict]] to Strict. 1. If
thisMode is ~lexical-this~, set F.[[ThisMode]] to ~lexical~. 1.
Else if Strict is `true`, set F.[[ThisMode]] to ~strict~. 1.
Else, set F.[[ThisMode]] to ~global~. 1. Set
F.[[IsClassConstructor]] to `false`. 1. Set F.[[Environment]]
to env. 1. Set F.[[PrivateEnvironment]] to privateEnv. 1.
Set F.[[ScriptOrModule]] to GetActiveScriptOrModule(). 1. Set
F.[[Realm]] to the current Realm Record. 1. Set F.[[HomeObject]]
to `undefined`. 1. Set F.[[Fields]] to a new empty List. 1. Set
F.[[PrivateMethods]] to a new empty List. 1. Set
F.[[ClassFieldInitializerName]] to ~empty~. 1. Let len be the
ExpectedArgumentCount of ParameterList. 1. Perform
SetFunctionLength(F, len). 1. Return F.

AddRestrictedFunctionProperties ( F: a function object, realm: a Realm Record, ): ~unused~
--------------------------------------------------------------------------------------------------

1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has
been initialized. 1. Let thrower be
realm.[[Intrinsics]].[[%ThrowTypeError%]]. 1. Perform !
DefinePropertyOrThrow(F, `"caller"`, PropertyDescriptor { [[Get]]:
thrower, [[Set]]: thrower, [[Enumerable]]: `false`,
[[Configurable]]: `true` }). 1. Perform ! DefinePropertyOrThrow(F,
`"arguments"`, PropertyDescriptor { [[Get]]: thrower, [[Set]]:
thrower, [[Enumerable]]: `false`, [[Configurable]]: `true` }).
1. Return ~unused~.

%ThrowTypeError% ( )
--------------------

This function is the %ThrowTypeError% intrinsic object.

It is an anonymous built-in function object that is defined once for
each realm.

It performs the following steps when called:

1. Throw a `TypeError` exception.

The value of the [[Extensible]] internal slot of this function is
`false`.

The `"length"` property of this function has the attributes {
[[Writable]]: `false`, [[Enumerable]]: `false`, [[Configurable]]:
`false` }.

The `"name"` property of this function has the attributes {
[[Writable]]: `false`, [[Enumerable]]: `false`, [[Configurable]]:
`false` }.

MakeConstructor ( F: an ECMAScript function object or a built-in function object, optional writablePrototype: a Boolean, optional prototype: an Object, ): ~unused~
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It converts F into a constructor.

1. If F is an ECMAScript function object, then 1. Assert:
IsConstructor(F) is `false`. 1. Assert: F is an extensible
object that does not have a `"prototype"` own property. 1. Set
F.[[Construct]] to the definition specified in . 1. Else, 1. Set
F.[[Construct]] to the definition specified in . 1. Set
F.[[ConstructorKind]] to ~base~. 1. If writablePrototype is not
present, set writablePrototype to `true`. 1. If prototype is
not present, then 1. Set prototype to
OrdinaryObjectCreate(%Object.prototype%). 1. Perform !
DefinePropertyOrThrow(prototype, `"constructor"`,
PropertyDescriptor { [[Value]]: F, [[Writable]]:
writablePrototype, [[Enumerable]]: `false`, [[Configurable]]:
`true` }). 1. Perform ! DefinePropertyOrThrow(F, `"prototype"`,
PropertyDescriptor { [[Value]]: prototype, [[Writable]]:
writablePrototype, [[Enumerable]]: `false`, [[Configurable]]:
`false` }). 1. Return ~unused~.

MakeClassConstructor ( F: an ECMAScript function object, ): ~unused~
------------------------------------------------------------------------

1. Assert: F.[[IsClassConstructor]] is `false`. 1. Set
F.[[IsClassConstructor]] to `true`. 1. Return ~unused~.

MakeMethod ( F: an ECMAScript function object, homeObject: an Object, ): ~unused~
-----------------------------------------------------------------------------------------

description
   It configures F as a method.

1. Assert: homeObject is an ordinary object. 1. Set
F.[[HomeObject]] to homeObject. 1. Return ~unused~.

DefineMethodProperty ( homeObject: an Object, key: a property key or Private Name, closure: a function object, enumerable: a Boolean, )
---------------------------------------------------------------------------------------------------------------------------------------

1. Assert: homeObject is an ordinary, extensible object. 1. If
key is a Private Name, then 1. Return PrivateElement { [[Key]]:
key, [[Kind]]: ~method~, [[Value]]: closure }. 1. Else, 1. Let
desc be the PropertyDescriptor { [[Value]]: closure,
[[Writable]]: `true`, [[Enumerable]]: enumerable,
[[Configurable]]: `true` }. 1. Perform ?
DefinePropertyOrThrow(homeObject, key, desc). 1. NOTE:
DefinePropertyOrThrow only returns an abrupt completion when attempting
to define a class static method whose key is `"prototype"`. 1.
Return ~unused~.

SetFunctionName ( F: a function object, name: a property key or Private Name, optional prefix: a String, ): ~unused~
--------------------------------------------------------------------------------------------------------------------------------

description
   It adds a `"name"` property to F.

1. Assert: F is an extensible object that does not have a `"name"`
own property. 1. If name is a Symbol, then 1. Let description be
name's [[Description]] value. 1. If description is
`undefined`, set name to the empty String. 1. Else, set name
to the string-concatenation of `"["`, description, and `"]"`. 1.
Else if name is a Private Name, then 1. Set name to
name.[[Description]]. 1. If F has an [[InitialName]] internal
slot, then 1. Set F.[[InitialName]] to name. 1. If prefix is
present, then 1. Set name to the string-concatenation of prefix,
the code unit 0x0020 (SPACE), and name. 1. If F has an
[[InitialName]] internal slot, then 1. Optionally, set
F.[[InitialName]] to name. 1. Perform !
DefinePropertyOrThrow(F, `"name"`, PropertyDescriptor { [[Value]]:
name, [[Writable]]: `false`, [[Enumerable]]: `false`,
[[Configurable]]: `true` }). 1. Return ~unused~.

SetFunctionLength ( F: a function object, length: a non-negative integer or +∞, ): ~unused~
---------------------------------------------------------------------------------------------------

description
   It adds a `"length"` property to F.

1. Assert: F is an extensible object that does not have a
`"length"` own property. 1. Perform ! DefinePropertyOrThrow(F,
`"length"`, PropertyDescriptor { [[Value]]: 𝔽(length),
[[Writable]]: `false`, [[Enumerable]]: `false`, [[Configurable]]:
`true` }). 1. Return ~unused~.

FunctionDeclarationInstantiation ( func: an ECMAScript function object, argumentsList: a List of ECMAScript language values, )
------------------------------------------------------------------------------------------------------------------------------

description
   func is the function object for which the execution context is
   being established.

When an execution context is established for evaluating an ECMAScript
function a new Function Environment Record is created and bindings for
each formal parameter are instantiated in that Environment Record. Each
declaration in the function body is also instantiated. If the function's
formal parameters do not include any default value initializers then the
body declarations are instantiated in the same Environment Record as the
parameters. If default value parameter initializers exist, a second
Environment Record is created for the body declarations. Formal
parameters and functions are initialized as part of
FunctionDeclarationInstantiation. All other bindings are initialized
during evaluation of the function body.

It performs the following steps when called:

1. Let calleeContext be the running execution context. 1. Let
code be func.[[ECMAScriptCode]]. 1. Let strict be
func.[[Strict]]. 1. Let formals be
func.[[FormalParameters]]. 1. Let parameterNames be the
BoundNames of formals. 1. If parameterNames has any duplicate
entries, let hasDuplicates be `true`. Otherwise, let
hasDuplicates be `false`. 1. Let simpleParameterList be
IsSimpleParameterList of formals. 1. Let hasParameterExpressions
be ContainsExpression of formals. 1. Let varNames be the
VarDeclaredNames of code. 1. Let varDeclarations be the
VarScopedDeclarations of code. 1. Let lexicalNames be the
LexicallyDeclaredNames of code. 1. Let functionNames be a new
empty List. 1. Let functionsToInitialize be a new empty List. 1. For
each element d of varDeclarations, in reverse List order, do 1.
If d is neither a `VariableDeclaration` nor a `ForBinding` nor a
`BindingIdentifier`, then 1. Assert: d is either a
`FunctionDeclaration`, a `GeneratorDeclaration`, an
`AsyncFunctionDeclaration`, or an `AsyncGeneratorDeclaration`. 1.
Let fn be the sole element of the BoundNames of d. 1. If
functionNames does not contain fn, then 1. Insert fn as the
first element of functionNames. 1. NOTE: If there are multiple
function declarations for the same name, the last declaration is used.
1. Insert d as the first element of functionsToInitialize. 1.
Let argumentsObjectNeeded be `true`. 1. If func.[[ThisMode]]
is ~lexical~, then 1. NOTE: Arrow functions never have an arguments
object. 1. Set argumentsObjectNeeded to `false`. 1. Else if
parameterNames contains `"arguments"`, then 1. Set
argumentsObjectNeeded to `false`. 1. Else if
hasParameterExpressions is `false`, then 1. If functionNames
contains `"arguments"` or lexicalNames contains `"arguments"`,
then 1. Set argumentsObjectNeeded to `false`. 1. If strict is
`true` or hasParameterExpressions is `false`, then 1. NOTE: Only
a single Environment Record is needed for the parameters, since calls to
`eval` in strict mode code cannot create new bindings which are
visible outside of the `eval`. 1. Let env be the
LexicalEnvironment of calleeContext. 1. Else, 1. NOTE: A separate
Environment Record is needed to ensure that bindings created by direct
eval calls in the formal parameter list are outside the environment
where parameters are declared. 1. Let calleeEnv be the
LexicalEnvironment of calleeContext. 1. Let env be
NewDeclarativeEnvironment(calleeEnv). 1. Assert: The
VariableEnvironment of calleeContext and calleeEnv are the same
Environment Record. 1. Set the LexicalEnvironment of calleeContext
to env. 1. For each String paramName of parameterNames, do
1. Let alreadyDeclared be ! env.HasBinding(paramName). 1.
NOTE: Early errors ensure that duplicate parameter names can only occur
in non-strict functions that do not have parameter default values or
rest parameters. 1. If alreadyDeclared is `false`, then 1. Perform
! env.CreateMutableBinding(paramName, `false`). 1. If
hasDuplicates is `true`, then 1. Perform !
env.InitializeBinding(paramName, `undefined`). 1. If
argumentsObjectNeeded is `true`, then 1. If strict is `true`
or simpleParameterList is `false`, then 1. Let ao be
CreateUnmappedArgumentsObject(argumentsList). 1. Else, 1. NOTE: A
mapped argument object is only provided for non-strict functions that
don't have a rest parameter, any parameter default value initializers,
or any destructured parameters. 1. Let ao be
CreateMappedArgumentsObject(func, formals, argumentsList,
env). 1. If strict is `true`, then 1. Perform !
env.CreateImmutableBinding(`"arguments"`, `false`). 1. NOTE: In
strict mode code early errors prevent attempting to assign to this
binding, so its mutability is not observable. 1. Else, 1. Perform !
env.CreateMutableBinding(`"arguments"`, `false`). 1. Perform !
env.InitializeBinding(`"arguments"`, ao). 1. Let
parameterBindings be the list-concatenation of parameterNames
and « `"arguments"` ». 1. Else, 1. Let parameterBindings be
parameterNames. 1. Let iteratorRecord be
CreateListIteratorRecord(argumentsList). 1. If hasDuplicates is
`true`, then 1. Perform ? IteratorBindingInitialization of formals
with arguments iteratorRecord and `undefined`. 1. Else, 1. Perform
? IteratorBindingInitialization of formals with arguments
iteratorRecord and env. 1. If hasParameterExpressions is
`false`, then 1. NOTE: Only a single Environment Record is needed for
the parameters and top-level vars. 1. Let instantiatedVarNames be a
copy of the List parameterBindings. 1. For each element n of
varNames, do 1. If instantiatedVarNames does not contain n,
then 1. Append n to instantiatedVarNames. 1. Perform !
env.CreateMutableBinding(n, `false`). 1. Perform !
env.InitializeBinding(n, `undefined`). 1. Let varEnv be
env. 1. Else, 1. NOTE: A separate Environment Record is needed to
ensure that closures created by expressions in the formal parameter list
do not have visibility of declarations in the function body. 1. Let
varEnv be NewDeclarativeEnvironment(env). 1. Set the
VariableEnvironment of calleeContext to varEnv. 1. Let
instantiatedVarNames be a new empty List. 1. For each element n
of varNames, do 1. If instantiatedVarNames does not contain
n, then 1. Append n to instantiatedVarNames. 1. Perform !
varEnv.CreateMutableBinding(n, `false`). 1. If
parameterBindings does not contain n, or if functionNames
contains n, then 1. Let initialValue be `undefined`. 1. Else,
1. Let initialValue be ! env.GetBindingValue(n, `false`).
1. Perform ! varEnv.InitializeBinding(n, initialValue). 1.
NOTE: A var with the same name as a formal parameter initially has the
same value as the corresponding initialized parameter. 1.
[id="step-functiondeclarationinstantiation-web-compat-insertion-point"]
NOTE: Annex adds additional steps at this point. 1. If strict is
`false`, then 1. Let lexEnv be
NewDeclarativeEnvironment(varEnv). 1. NOTE: Non-strict functions use
a separate Environment Record for top-level lexical declarations so that
a direct eval can determine whether any var scoped declarations
introduced by the eval code conflict with pre-existing top-level
lexically scoped declarations. This is not needed for strict functions
because a strict direct eval always places all declarations into a new
Environment Record. 1. Else, 1. Let lexEnv be varEnv. 1. Set the
LexicalEnvironment of calleeContext to lexEnv. 1. Let
lexDeclarations be the LexicallyScopedDeclarations of code. 1.
For each element d of lexDeclarations, do 1. NOTE: A lexically
declared name cannot be the same as a function/generator declaration,
formal parameter, or a var name. Lexically declared names are only
instantiated here but not initialized. 1. For each element dn of the
BoundNames of d, do 1. If IsConstantDeclaration of d is
`true`, then 1. Perform ! lexEnv.CreateImmutableBinding(dn,
`true`). 1. Else, 1. Perform ! lexEnv.CreateMutableBinding(dn,
`false`). 1. Let privateEnv be the PrivateEnvironment of
calleeContext. 1. For each Parse Node f of
functionsToInitialize, do 1. Let fn be the sole element of the
BoundNames of f. 1. Let fo be InstantiateFunctionObject of f
with arguments lexEnv and privateEnv. 1. Perform !
varEnv.SetMutableBinding(fn, fo, `false`). 1. Return
~unused~.

provides an extension to the above algorithm that is necessary for
backwards compatibility with web browser implementations of ECMAScript
that predate ECMAScript 2015.

Built-in Function Objects
-------------------------

A built-in function object is an ordinary object; it must satisfy the
requirements for ordinary objects set out in .

In addition to the internal slots required of every ordinary object (see
), a built-in function object must also have the following internal
slots:

- [[Realm]], a Realm Record that represents the realm in which the
  function was created.
- [[InitialName]], a String that is the initial name of the function. It
  is used by .

The initial value of a built-in function object's [[Prototype]] internal
slot is %Function.prototype%, unless otherwise specified.

A built-in function object must have a [[Call]] internal method that
conforms to the definition in .

A built-in function object has a [[Construct]] internal method if and
only if it is described as a “constructor”, or some algorithm in this
specification explicitly sets its [[Construct]] internal method. Such a
[[Construct]] internal method must conform to the definition in .

An implementation may provide additional built-in function objects that
are not defined in this specification.

.. _call-_thisargument_-an-ecmascript-language-value-_argumentslist_-a-list-of-ecmascript-language-values-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-1:

[[Call]] ( thisArgument, argumentsList: a List of ECMAScript language values, )
-------------------------------------------------------------------------------

for
   a built-in function object F

1. Return ? BuiltinCallOrConstruct(F, thisArgument,
argumentsList, `undefined`).

.. _construct-_argumentslist_-a-list-of-ecmascript-language-values-_newtarget_-a-constructor-either-a-normal-completion-containing-an-object-or-a-throw-completion-1:

[[Construct]] ( argumentsList: a List of ECMAScript language values, newTarget: a constructor, )
------------------------------------------------------------------------------------------------

for
   a built-in function object F (when the method is present)

1. Return ? BuiltinCallOrConstruct(F, ~uninitialized~,
argumentsList, newTarget).

BuiltinCallOrConstruct ( F: a built-in function object, thisArgument or ~uninitialized~, argumentsList: a List of ECMAScript language values, newTarget: a constructor or `undefined`, )
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let callerContext be the running execution context. 1. If
callerContext is not already suspended, suspend callerContext.
1. Let calleeContext be a new execution context. 1. Set the Function
of calleeContext to F. 1. Let calleeRealm be
F.[[Realm]]. 1. Set the Realm of calleeContext to
calleeRealm. 1. Set the ScriptOrModule of calleeContext to
`null`. 1. Perform any necessary implementation-defined initialization
of calleeContext. 1. Push calleeContext onto the execution
context stack; calleeContext is now the running execution context.
1. [id="step-call-builtin-function-result"] Let result be the
Completion Record that is the result of evaluating F in a manner
that conforms to the specification of F. If thisArgument is
~uninitialized~, the `this` value is uninitialized; otherwise,
thisArgument provides the `this` value. argumentsList provides
the named parameters. newTarget provides the NewTarget value. 1.
NOTE: If F is defined in this document, “the specification of F”
is the behaviour specified for it via algorithm steps or other means. 1.
Remove calleeContext from the execution context stack and restore
callerContext as the running execution context. 1. Return ?
result.

When calleeContext is removed from the execution context stack it
must not be destroyed if it has been suspended and retained by an
accessible Generator for later resumption.

CreateBuiltinFunction ( behaviour: an Abstract Closure, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification, length: a non-negative integer or +∞, name: a property key or a Private Name, additionalInternalSlotsList: a List of names of internal slots, optional realm: a Realm Record, optional prototype: an Object or `null`, optional prefix: a String, ): a built-in function object
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   additionalInternalSlotsList contains the names of additional
   internal slots that must be defined as part of the object. This
   operation creates a built-in function object.

1. If realm is not present, set realm to the current Realm
Record. 1. If prototype is not present, set prototype to
realm.[[Intrinsics]].[[%Function.prototype%]]. 1. Let
internalSlotsList be a List containing the names of all the internal
slots that requires for the built-in function object that is about to be
created. 1. Append to internalSlotsList the elements of
additionalInternalSlotsList. 1. Let func be a new built-in
function object that, when called, performs the action described by
behaviour using the provided arguments as the values of the
corresponding parameters specified by behaviour. The new function
object has internal slots whose names are the elements of
internalSlotsList, and an [[InitialName]] internal slot. 1. Set
func.[[Prototype]] to prototype. 1. Set func.[[Extensible]]
to `true`. 1. Set func.[[Realm]] to realm. 1. Set
func.[[InitialName]] to `null`. 1. Perform
SetFunctionLength(func, length). 1. If prefix is not
present, then 1. Perform SetFunctionName(func, name). 1. Else,
1. Perform SetFunctionName(func, name, prefix). 1. Return
func.

Each built-in function defined in this specification is created by
calling the CreateBuiltinFunction abstract operation.

Built-in Exotic Object Internal Methods and Slots
-------------------------------------------------

This specification defines several kinds of built-in exotic objects.
These objects generally behave similar to ordinary objects except for a
few specific situations. The following exotic objects use the ordinary
object internal methods except where it is explicitly specified
otherwise below:

Bound Function Exotic Objects
-----------------------------

A bound function exotic object is an exotic object that wraps another
function object. A bound function exotic object is callable (it has a
[[Call]] internal method and may have a [[Construct]] internal method).
Calling a bound function exotic object generally results in a call of
its wrapped function.

An object is a bound function exotic object if its [[Call]] and (if
applicable) [[Construct]] internal methods use the following
implementations, and its other essential internal methods use the
definitions found in . These methods are installed in
BoundFunctionCreate.

Bound function exotic objects do not have the internal slots of
ECMAScript function objects listed in . Instead they have the internal
slots listed in , in addition to [[Prototype]] and [[Extensible]].

+----------------------+----------------------+----------------------+
| Internal Slot        | Type                 | Description          |
+======================+======================+======================+
| [[B                  | a callable Object    | The wrapped function |
| oundTargetFunction]] |                      | object.              |
+----------------------+----------------------+----------------------+
| [[BoundThis]]        | an ECMAScript        | The value that is    |
|                      | language value       | always passed as the |
|                      |                      | `this` value when  |
|                      |                      | calling the wrapped  |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+
| [[BoundArguments]]   | a List of ECMAScript | A list of values     |
|                      | language values      | whose elements are   |
|                      |                      | used as the first    |
|                      |                      | arguments to any     |
|                      |                      | call to the wrapped  |
|                      |                      | function.            |
+----------------------+----------------------+----------------------+

.. _call-_thisargument_-an-ecmascript-language-value-_argumentslist_-a-list-of-ecmascript-language-values-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-2:

[[Call]] ( thisArgument, argumentsList: a List of ECMAScript language values, )
-------------------------------------------------------------------------------

for
   a bound function exotic object F

1. Let target be F.[[BoundTargetFunction]]. 1. Let boundThis
be F.[[BoundThis]]. 1. Let boundArgs be
F.[[BoundArguments]]. 1. Let args be the list-concatenation of
boundArgs and argumentsList. 1. Return ? Call(target,
boundThis, args).

.. _construct-_argumentslist_-a-list-of-ecmascript-language-values-_newtarget_-a-constructor-either-a-normal-completion-containing-an-object-or-a-throw-completion-2:

[[Construct]] ( argumentsList: a List of ECMAScript language values, newTarget: a constructor, )
------------------------------------------------------------------------------------------------

for
   a bound function exotic object F

1. Let target be F.[[BoundTargetFunction]]. 1. Assert:
IsConstructor(target) is `true`. 1. Let boundArgs be
F.[[BoundArguments]]. 1. Let args be the list-concatenation of
boundArgs and argumentsList. 1. If SameValue(F,
newTarget) is `true`, set newTarget to target. 1. Return ?
Construct(target, args, newTarget).

BoundFunctionCreate ( targetFunction: a function object, boundThis, boundArgs: a List of ECMAScript language values, )
----------------------------------------------------------------------------------------------------------------------

description
   It is used to specify the creation of new bound function exotic
   objects.

1. Let proto be ? targetFunction.[[GetPrototypeOf]](). 1. Let
internalSlotsList be the list-concatenation of « [[Prototype]],
[[Extensible]] » and the internal slots listed in . 1. Let obj be
MakeBasicObject(internalSlotsList). 1. Set obj.[[Prototype]] to
proto. 1. Set obj.[[Call]] as described in . 1. If
IsConstructor(targetFunction) is `true`, then 1. Set
obj.[[Construct]] as described in . 1. Set
obj.[[BoundTargetFunction]] to targetFunction. 1. Set
obj.[[BoundThis]] to boundThis. 1. Set
obj.[[BoundArguments]] to boundArgs. 1. Return obj.

Array Exotic Objects
--------------------

An Array is an exotic object that gives special treatment to array index
property keys (see ). A property whose property name is an array index
is also called an *element*. Every Array has a non-configurable
`"length"` property whose value is always a non-negative integral
Number whose mathematical value is strictly less than 2\ :sup:`32`. The
value of the `"length"` property is numerically greater than the name
of every own property whose name is an array index; whenever an own
property of an Array is created or changed, other properties are
adjusted as necessary to maintain this invariant. Specifically, whenever
an own property is added whose name is an array index, the value of the
`"length"` property is changed, if necessary, to be one more than the
numeric value of that array index; and whenever the value of the
`"length"` property is changed, every own property whose name is an
array index whose value is not smaller than the new length is deleted.
This constraint applies only to own properties of an Array and is
unaffected by `"length"` or array index properties that may be
inherited from its prototypes.

An object is an Array exotic object (or simply, an Array) if its
[[DefineOwnProperty]] internal method uses the following implementation,
and its other essential internal methods use the definitions found in .
These methods are installed in ArrayCreate.

.. _defineownproperty-_p_-a-property-key-_desc_-a-property-descriptor-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-1:

[[DefineOwnProperty]] ( P: a property key, Desc: a Property Descriptor, )
-------------------------------------------------------------------------

for
   an Array exotic object A

1. If P is `"length"`, then 1. Return ? ArraySetLength(A,
Desc). 1. Else if P is an array index, then 1. Let
lengthDesc be OrdinaryGetOwnProperty(A, `"length"`). 1.
Assert: IsDataDescriptor(lengthDesc) is `true`. 1. Assert:
lengthDesc.[[Configurable]] is `false`. 1. Let length be
lengthDesc.[[Value]]. 1. Assert: length is a non-negative
integral Number. 1. Let index be ! ToUint32(P). 1. If index
≥ length and lengthDesc.[[Writable]] is `false`, return
`false`. 1. Let succeeded be ! OrdinaryDefineOwnProperty(A,
P, Desc). 1. If succeeded is `false`, return `false`. 1.
If index ≥ length, then 1. Set lengthDesc.[[Value]] to
index + `1`\ :sub:`𝔽`. 1. Set succeeded to !
OrdinaryDefineOwnProperty(A, `"length"`, lengthDesc). 1.
Assert: succeeded is `true`. 1. Return `true`. 1. Return ?
OrdinaryDefineOwnProperty(A, P, Desc).

ArrayCreate ( length: a non-negative integer, optional proto: an Object, )
--------------------------------------------------------------------------

description
   It is used to specify the creation of new Arrays.

1. If length > 2\ :sup:`32` - 1, throw a `RangeError` exception.
1. If proto is not present, set proto to %Array.prototype%. 1.
Let A be MakeBasicObject(« [[Prototype]], [[Extensible]] »). 1. Set
A.[[Prototype]] to proto. 1. Set A.[[DefineOwnProperty]] as
specified in . 1. Perform ! OrdinaryDefineOwnProperty(A,
`"length"`, PropertyDescriptor { [[Value]]: 𝔽(length),
[[Writable]]: `true`, [[Enumerable]]: `false`, [[Configurable]]:
`false` }). 1. Return A.

ArraySpeciesCreate ( originalArray: an Object, length: a non-negative integer, )
--------------------------------------------------------------------------------

description
   It is used to specify the creation of a new Array or similar object
   using a constructor function that is derived from originalArray.
   It does not enforce that the constructor function returns an Array.

1. Let isArray be ? IsArray(originalArray). 1. If isArray is
`false`, return ? ArrayCreate(length). 1. Let C be ?
Get(originalArray, `"constructor"`). 1. If IsConstructor(C) is
`true`, then 1. Let thisRealm be the current Realm Record. 1. Let
realmC be ? GetFunctionRealm(C). 1. If thisRealm and
realmC are not the same Realm Record, then 1. If SameValue(C,
realmC.[[Intrinsics]].[[%Array%]]) is `true`, set C to
`undefined`. 1. If C is an Object, then 1. Set C to ?
Get(C, %Symbol.species%). 1. If C is `null`, set C to
`undefined`. 1. If C is `undefined`, return ?
ArrayCreate(length). 1. If IsConstructor(C) is `false`, throw
a `TypeError` exception. 1. Return ? Construct(C, « 𝔽(length)
»).

If originalArray was created using the standard built-in Array
constructor for a realm that is not the realm of the running execution
context, then a new Array is created using the realm of the running
execution context. This maintains compatibility with Web browsers that
have historically had that behaviour for the `Array.prototype` methods
that now are defined using ArraySpeciesCreate.

ArraySetLength ( A: an Array, Desc: a Property Descriptor, )
------------------------------------------------------------

1. If Desc does not have a [[Value]] field, then 1. Return !
OrdinaryDefineOwnProperty(A, `"length"`, Desc). 1. Let
newLenDesc be a copy of Desc. 1.
[id="step-arraysetlength-newlen"] Let newLen be ?
ToUint32(Desc.[[Value]]). 1. [id="step-arraysetlength-numberlen"]
Let numberLen be ? ToNumber(Desc.[[Value]]). 1. If
SameValueZero(newLen, numberLen) is `false`, throw a
`RangeError` exception. 1. Set newLenDesc.[[Value]] to newLen.
1. Let oldLenDesc be OrdinaryGetOwnProperty(A, `"length"`). 1.
Assert: IsDataDescriptor(oldLenDesc) is `true`. 1. Assert:
oldLenDesc.[[Configurable]] is `false`. 1. Let oldLen be
oldLenDesc.[[Value]]. 1. If newLen ≥ oldLen, then 1. Return
! OrdinaryDefineOwnProperty(A, `"length"`, newLenDesc). 1. If
oldLenDesc.[[Writable]] is `false`, return `false`. 1. If
newLenDesc does not have a [[Writable]] field or
newLenDesc.[[Writable]] is `true`, then 1. Let newWritable be
`true`. 1. Else, 1. NOTE: Setting the [[Writable]] attribute to
`false` is deferred in case any elements cannot be deleted. 1. Let
newWritable be `false`. 1. Set newLenDesc.[[Writable]] to
`true`. 1. Let succeeded be ! OrdinaryDefineOwnProperty(A,
`"length"`, newLenDesc). 1. If succeeded is `false`, return
`false`. 1. For each own property key P of A such that P
is an array index and ! ToUint32(P) ≥ newLen, in descending
numeric index order, do 1. Let deleteSucceeded be !
A.[[Delete]](P). 1. If deleteSucceeded is `false`, then 1.
Set newLenDesc.[[Value]] to ! ToUint32(P) + `1`\ :sub:`𝔽`. 1.
If newWritable is `false`, set newLenDesc.[[Writable]] to
`false`. 1. Perform ! OrdinaryDefineOwnProperty(A, `"length"`,
newLenDesc). 1. Return `false`. 1. If newWritable is
`false`, then 1. Set succeeded to !
OrdinaryDefineOwnProperty(A, `"length"`, PropertyDescriptor {
[[Writable]]: `false` }). 1. Assert: succeeded is `true`. 1.
Return `true`.

In steps and , if Desc.[[Value]] is an object then its `valueOf`
method is called twice. This is legacy behaviour that was specified with
this effect starting with the 2\ :sup:`nd` Edition of this
specification.

String Exotic Objects
---------------------

A String object is an exotic object that encapsulates a String value and
exposes virtual integer-indexed data properties corresponding to the
individual code unit elements of the String value. String exotic objects
always have a data property named `"length"` whose value is the length
of the encapsulated String value. Both the code unit data properties and
the `"length"` property are non-writable and non-configurable.

An object is a String exotic object (or simply, a String object) if its
[[GetOwnProperty]], [[DefineOwnProperty]], and [[OwnPropertyKeys]]
internal methods use the following implementations, and its other
essential internal methods use the definitions found in . These methods
are installed in StringCreate.

String exotic objects have the same internal slots as ordinary objects.
They also have a [[StringData]] internal slot.

.. _getownproperty-_p_-a-property-key-a-normal-completion-containing-either-a-property-descriptor-or-undefined-1:

[[GetOwnProperty]] ( P: a property key, ): a normal completion containing either a Property Descriptor or `undefined`
---------------------------------------------------------------------------------------------------------------------------

for
   a String exotic object S

1. Let desc be OrdinaryGetOwnProperty(S, P). 1. If desc
is not `undefined`, return desc. 1. Return
StringGetOwnProperty(S, P).

[[DefineOwnProperty]] ( P: a property key, Desc: a Property Descriptor, ): a normal completion containing a Boolean
---------------------------------------------------------------------------------------------------------------------------

for
   a String exotic object S

1. Let stringDesc be StringGetOwnProperty(S, P). 1. If
stringDesc is not `undefined`, then 1. Let extensible be
S.[[Extensible]]. 1. Return
IsCompatiblePropertyDescriptor(extensible, Desc,
stringDesc). 1. Return ! OrdinaryDefineOwnProperty(S, P,
Desc).

.. _ownpropertykeys-a-normal-completion-containing-a-list-of-property-keys-1:

[[OwnPropertyKeys]] ( ): a normal completion containing a List of property keys
-------------------------------------------------------------------------------

for
   a String exotic object O

1. Let keys be a new empty List. 1. Let str be
O.[[StringData]]. 1. Assert: str is a String. 1. Let len be
the length of str. 1. For each integer i such that 0 ≤ i <
len, in ascending order, do 1. Append ! ToString(𝔽(i)) to
keys. 1. For each own property key P of O such that P is
an array index and ! ToIntegerOrInfinity(P) ≥ len, in ascending
numeric index order, do 1. Append P to keys. 1. For each own
property key P of O such that P is a String and P is not
an array index, in ascending chronological order of property creation,
do 1. Append P to keys. 1. For each own property key P of
O such that P is a Symbol, in ascending chronological order of
property creation, do 1. Append P to keys. 1. Return keys.

StringCreate ( value: a String, prototype: an Object, ): a String exotic object
---------------------------------------------------------------------------------------

description
   It is used to specify the creation of new String exotic objects.

1. Let S be MakeBasicObject(« [[Prototype]], [[Extensible]],
[[StringData]] »). 1. Set S.[[Prototype]] to prototype. 1. Set
S.[[StringData]] to value. 1. Set S.[[GetOwnProperty]] as
specified in . 1. Set S.[[DefineOwnProperty]] as specified in . 1.
Set S.[[OwnPropertyKeys]] as specified in . 1. Let length be the
length of value. 1. Perform ! DefinePropertyOrThrow(S,
`"length"`, PropertyDescriptor { [[Value]]: 𝔽(length),
[[Writable]]: `false`, [[Enumerable]]: `false`, [[Configurable]]:
`false` }). 1. Return S.

StringGetOwnProperty ( S: an Object that has a [[StringData]] internal slot, P: a property key, ): a Property Descriptor or `undefined`
-------------------------------------------------------------------------------------------------------------------------------------------------

1. If P is not a String, return `undefined`. 1. Let index be
CanonicalNumericIndexString(P). 1. If index is `undefined`,
return `undefined`. 1. If index is not an integral Number, return
`undefined`. 1. If index is `-0`\ :sub:`𝔽`, return
`undefined`. 1. Let str be S.[[StringData]]. 1. Assert:
str is a String. 1. Let len be the length of str. 1. If
ℝ(index) < 0 or len ≤ ℝ(index), return `undefined`. 1. Let
resultStr be the substring of str from ℝ(index) to
ℝ(index) + 1. 1. Return the PropertyDescriptor { [[Value]]:
resultStr, [[Writable]]: `false`, [[Enumerable]]: `true`,
[[Configurable]]: `false` }.

Arguments Exotic Objects
------------------------

Most ECMAScript functions make an arguments object available to their
code. Depending upon the characteristics of the function definition, its
arguments object is either an ordinary object or an arguments exotic
object. An arguments exotic object is an exotic object whose array index
properties map to the formal parameters bindings of an invocation of its
associated ECMAScript function.

An object is an arguments exotic object if its internal methods use the
following implementations, with the ones not specified here using those
found in . These methods are installed in CreateMappedArgumentsObject.

While CreateUnmappedArgumentsObject is grouped into this clause, it
creates an ordinary object, not an arguments exotic object.

Arguments exotic objects have the same internal slots as ordinary
objects. They also have a [[ParameterMap]] internal slot. Ordinary
arguments objects also have a [[ParameterMap]] internal slot whose value
is always undefined. For ordinary argument objects the [[ParameterMap]]
internal slot is only used by `Object.prototype.toString` () to
identify them as such.

The integer-indexed data properties of an arguments exotic object whose
numeric name values are less than the number of formal parameters of the
corresponding function object initially share their values with the
corresponding argument bindings in the function's execution context.
This means that changing the property changes the corresponding value of
the argument binding and vice-versa. This correspondence is broken if
such a property is deleted and then redefined or if the property is
changed into an accessor property. If the arguments object is an
ordinary object, the values of its properties are simply a copy of the
arguments passed to the function and there is no dynamic linkage between
the property values and the formal parameter values.

The ParameterMap object and its property values are used as a device for
specifying the arguments object correspondence to argument bindings. The
ParameterMap object and the objects that are the values of its
properties are not directly observable from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

Ordinary arguments objects define a non-configurable accessor property
named `"callee"` which throws a `TypeError` exception on access. The
`"callee"` property has a more specific meaning for arguments exotic
objects, which are created only for some class of non-strict functions.
The definition of this property in the ordinary variant exists to ensure
that it is not defined in any other manner by conforming ECMAScript
implementations.

ECMAScript implementations of arguments exotic objects have historically
contained an accessor property named `"caller"`. Prior to ECMAScript
2017, this specification included the definition of a throwing
`"caller"` property on ordinary arguments objects. Since
implementations do not contain this extension any longer, ECMAScript
2017 dropped the requirement for a throwing `"caller"` accessor.

.. _getownproperty-_p_-a-property-key-a-normal-completion-containing-either-a-property-descriptor-or-undefined-2:

[[GetOwnProperty]] ( P: a property key, ): a normal completion containing either a Property Descriptor or `undefined`
---------------------------------------------------------------------------------------------------------------------------

for
   an arguments exotic object args

1. Let desc be OrdinaryGetOwnProperty(args, P). 1. If
desc is `undefined`, return `undefined`. 1. Let map be
args.[[ParameterMap]]. 1. Let isMapped be !
HasOwnProperty(map, P). 1. If isMapped is `true`, then 1.
Set desc.[[Value]] to ! Get(map, P). 1. Return desc.

.. _defineownproperty-_p_-a-property-key-_desc_-a-property-descriptor-a-normal-completion-containing-a-boolean-1:

[[DefineOwnProperty]] ( P: a property key, Desc: a Property Descriptor, ): a normal completion containing a Boolean
---------------------------------------------------------------------------------------------------------------------------

for
   an arguments exotic object args

1. Let map be args.[[ParameterMap]]. 1. Let isMapped be !
HasOwnProperty(map, P). 1. Let newArgDesc be Desc. 1. If
isMapped is `true` and IsDataDescriptor(Desc) is `true`,
then 1. If Desc does not have a [[Value]] field, Desc has a
[[Writable]] field, and Desc.[[Writable]] is `false`, then 1. Set
newArgDesc to a copy of Desc. 1. Set newArgDesc.[[Value]] to
! Get(map, P). 1. Let allowed be !
OrdinaryDefineOwnProperty(args, P, newArgDesc). 1. If
allowed is `false`, return `false`. 1. If isMapped is
`true`, then 1. If IsAccessorDescriptor(Desc) is `true`, then 1.
Perform ! map.[[Delete]](P). 1. Else, 1. If Desc has a
[[Value]] field, then 1. Assert: The following Set will succeed, since
formal parameters mapped by arguments objects are always writable. 1.
Perform ! Set(map, P, Desc.[[Value]], `false`). 1. If
Desc has a [[Writable]] field and Desc.[[Writable]] is
`false`, then 1. Perform ! map.[[Delete]](P). 1. Return
`true`.

.. _get-_p_-a-property-key-_receiver_-an-ecmascript-language-value-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-1:

[[Get]] ( P: a property key, Receiver, )
----------------------------------------

for
   an arguments exotic object args

1. Let map be args.[[ParameterMap]]. 1. Let isMapped be !
HasOwnProperty(map, P). 1. If isMapped is `false`, then 1.
Return ? OrdinaryGet(args, P, Receiver). 1. Else, 1. Assert:
map contains a formal parameter mapping for P. 1. Return !
Get(map, P).

.. _set-_p_-a-property-key-_v_-an-ecmascript-language-value-_receiver_-an-ecmascript-language-value-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-1:

[[Set]] ( P: a property key, V, Receiver, )
-------------------------------------------

for
   an arguments exotic object args

1. If SameValue(args, Receiver) is `false`, then 1. Let
isMapped be `false`. 1. Else, 1. Let map be
args.[[ParameterMap]]. 1. Let isMapped be !
HasOwnProperty(map, P). 1. If isMapped is `true`, then 1.
Assert: The following Set will succeed, since formal parameters mapped
by arguments objects are always writable. 1. Perform ! Set(map,
P, V, `false`). 1. Return ? OrdinarySet(args, P,
V, Receiver).

.. _delete-_p_-a-property-key-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-1:

[[Delete]] ( P: a property key, )
---------------------------------

for
   an arguments exotic object args

1. Let map be args.[[ParameterMap]]. 1. Let isMapped be !
HasOwnProperty(map, P). 1. Let result be ?
OrdinaryDelete(args, P). 1. If result is `true` and
isMapped is `true`, then 1. Perform ! map.[[Delete]](P).
1. Return result.

CreateUnmappedArgumentsObject ( argumentsList: a List of ECMAScript language values, ): an ordinary object
--------------------------------------------------------------------------------------------------------------

1. Let len be the number of elements in argumentsList. 1. Let
obj be OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]]
»). 1. Set obj.[[ParameterMap]] to `undefined`. 1. Perform !
DefinePropertyOrThrow(obj, `"length"`, PropertyDescriptor {
[[Value]]: 𝔽(len), [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `true` }). 1. Let index be 0. 1.
Repeat, while index < len, 1. Let val be
argumentsList[index]. 1. Perform !
CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val).
1. Set index to index + 1. 1. Perform !
DefinePropertyOrThrow(obj, %Symbol.iterator%, PropertyDescriptor {
[[Value]]: %Array.prototype.values%, [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }). 1. Perform !
DefinePropertyOrThrow(obj, `"callee"`, PropertyDescriptor {
[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Return obj.

CreateMappedArgumentsObject ( func: an Object, formals: a Parse Node, argumentsList: a List of ECMAScript language values, env: an Environment Record, ): an arguments exotic object
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: formals does not contain a rest parameter, any binding
patterns, or any initializers. It may contain duplicate identifiers. 1.
Let len be the number of elements in argumentsList. 1. Let
obj be MakeBasicObject(« [[Prototype]], [[Extensible]],
[[ParameterMap]] »). 1. Set obj.[[GetOwnProperty]] as specified in .
1. Set obj.[[DefineOwnProperty]] as specified in . 1. Set
obj.[[Get]] as specified in . 1. Set obj.[[Set]] as specified in
. 1. Set obj.[[Delete]] as specified in . 1. Set
obj.[[Prototype]] to %Object.prototype%. 1. Let map be
OrdinaryObjectCreate(`null`). 1. Set obj.[[ParameterMap]] to
map. 1. Let parameterNames be the BoundNames of formals. 1.
Let numberOfParameters be the number of elements in
parameterNames. 1. Let index be 0. 1. Repeat, while index <
len, 1. Let val be argumentsList[index]. 1. Perform !
CreateDataPropertyOrThrow(obj, ! ToString(𝔽(index)), val).
1. Set index to index + 1. 1. Perform !
DefinePropertyOrThrow(obj, `"length"`, PropertyDescriptor {
[[Value]]: 𝔽(len), [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `true` }). 1. Let mappedNames be a
new empty List. 1. Set index to numberOfParameters - 1. 1.
Repeat, while index ≥ 0, 1. Let name be
parameterNames[index]. 1. If mappedNames does not contain
name, then 1. Append name to mappedNames. 1. If index <
len, then 1. Let g be MakeArgGetter(name, env). 1. Let
p be MakeArgSetter(name, env). 1. Perform !
map.[[DefineOwnProperty]](! ToString(𝔽(index)),
PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]:
`false`, [[Configurable]]: `true` }). 1. Set index to index
- 1. 1. Perform ! DefinePropertyOrThrow(obj, %Symbol.iterator%,
PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]:
`true`, [[Enumerable]]: `false`, [[Configurable]]: `true` }). 1.
Perform ! DefinePropertyOrThrow(obj, `"callee"`,
PropertyDescriptor { [[Value]]: func, [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }). 1. Return
obj.

MakeArgGetter ( name: a String, env: an Environment Record, ): a function object
----------------------------------------------------------------------------------------

description
   It creates a built-in function object that when executed returns the
   value bound for name in env.

1. Let getterClosure be a new Abstract Closure with no parameters
that captures name and env and performs the following steps when
called: 1. Return env.GetBindingValue(name, `false`). 1. Let
getter be CreateBuiltinFunction(getterClosure, 0, `""`, « »).
1. NOTE: getter is never directly accessible to ECMAScript code. 1.
Return getter.

MakeArgSetter ( name: a String, env: an Environment Record, ): a function object
----------------------------------------------------------------------------------------

description
   It creates a built-in function object that when executed sets the
   value bound for name in env.

1. Let setterClosure be a new Abstract Closure with parameters
(value) that captures name and env and performs the
following steps when called: 1. Return !
env.SetMutableBinding(name, value, `false`). 1. Let
setter be CreateBuiltinFunction(setterClosure, 1, `""`, « »).
1. NOTE: setter is never directly accessible to ECMAScript code. 1.
Return setter.

TypedArray Exotic Objects
-------------------------

A TypedArray is an exotic object that performs special handling of
integer index property keys.

TypedArrays have the same internal slots as ordinary objects and
additionally [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]],
[[ContentType]], and [[TypedArrayName]] internal slots.

An object is a TypedArray if its [[GetOwnProperty]], [[HasProperty]],
[[DefineOwnProperty]], [[Get]], [[Set]], [[Delete]], and
[[OwnPropertyKeys]] internal methods use the definitions in this
section, and its other essential internal methods use the definitions
found in . These methods are installed by TypedArrayCreate.

.. _getownproperty-_p_-a-property-key-a-normal-completion-containing-either-a-property-descriptor-or-undefined-3:

[[GetOwnProperty]] ( P: a property key, ): a normal completion containing either a Property Descriptor or `undefined`
---------------------------------------------------------------------------------------------------------------------------

for
   a TypedArray O

1. If P is a String, then 1. Let numericIndex be
CanonicalNumericIndexString(P). 1. If numericIndex is not
`undefined`, then 1. Let value be TypedArrayGetElement(O,
numericIndex). 1. If value is `undefined`, return
`undefined`. 1. Return the PropertyDescriptor { [[Value]]: value,
[[Writable]]: `true`, [[Enumerable]]: `true`, [[Configurable]]:
`true` }. 1. Return OrdinaryGetOwnProperty(O, P).

.. _hasproperty-_p_-a-property-key-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-1:

[[HasProperty]] ( P: a property key, )
--------------------------------------

for
   a TypedArray O

1. If P is a String, then 1. Let numericIndex be
CanonicalNumericIndexString(P). 1. If numericIndex is not
`undefined`, return IsValidIntegerIndex(O, numericIndex). 1.
Return ? OrdinaryHasProperty(O, P).

.. _defineownproperty-_p_-a-property-key-_desc_-a-property-descriptor-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-2:

[[DefineOwnProperty]] ( P: a property key, Desc: a Property Descriptor, )
-------------------------------------------------------------------------

for
   a TypedArray O

1. If P is a String, then 1. Let numericIndex be
CanonicalNumericIndexString(P). 1. If numericIndex is not
`undefined`, then 1. If IsValidIntegerIndex(O, numericIndex)
is `false`, return `false`. 1. If Desc has a [[Configurable]]
field and Desc.[[Configurable]] is `false`, return `false`. 1.
If Desc has an [[Enumerable]] field and Desc.[[Enumerable]] is
`false`, return `false`. 1. If IsAccessorDescriptor(Desc) is
`true`, return `false`. 1. If Desc has a [[Writable]] field and
Desc.[[Writable]] is `false`, return `false`. 1. If Desc has
a [[Value]] field, perform ? TypedArraySetElement(O,
numericIndex, Desc.[[Value]]). 1. Return `true`. 1. Return !
OrdinaryDefineOwnProperty(O, P, Desc).

.. _get-_p_-a-property-key-_receiver_-an-ecmascript-language-value-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-2:

[[Get]] ( P: a property key, Receiver, )
----------------------------------------

for
   a TypedArray O

1. If P is a String, then 1. Let numericIndex be
CanonicalNumericIndexString(P). 1. If numericIndex is not
`undefined`, then 1. Return TypedArrayGetElement(O,
numericIndex). 1. Return ? OrdinaryGet(O, P, Receiver).

.. _set-_p_-a-property-key-_v_-an-ecmascript-language-value-_receiver_-an-ecmascript-language-value-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-2:

[[Set]] ( P: a property key, V, Receiver, )
-------------------------------------------

for
   a TypedArray O

1. If P is a String, then 1. Let numericIndex be
CanonicalNumericIndexString(P). 1. If numericIndex is not
`undefined`, then 1. If SameValue(O, Receiver) is `true`,
then 1. Perform ? TypedArraySetElement(O, numericIndex, V).
1. Return `true`. 1. If IsValidIntegerIndex(O, numericIndex)
is `false`, return `true`. 1. Return ? OrdinarySet(O, P,
V, Receiver).

[[Delete]] ( P: a property key, ): a normal completion containing a Boolean
-------------------------------------------------------------------------------

for
   a TypedArray O

1. If P is a String, then 1. Let numericIndex be
CanonicalNumericIndexString(P). 1. If numericIndex is not
`undefined`, then 1. If IsValidIntegerIndex(O, numericIndex)
is `false`, return `true`; else return `false`. 1. Return !
OrdinaryDelete(O, P).

.. _ownpropertykeys-a-normal-completion-containing-a-list-of-property-keys-2:

[[OwnPropertyKeys]] ( ): a normal completion containing a List of property keys
-------------------------------------------------------------------------------

for
   a TypedArray O

1. Let taRecord be MakeTypedArrayWithBufferWitnessRecord(O,
~seq-cst~). 1. Let keys be a new empty List. 1. If
IsTypedArrayOutOfBounds(taRecord) is `false`, then 1. Let
length be TypedArrayLength(taRecord). 1. For each integer i
such that 0 ≤ i < length, in ascending order, do 1. Append !
ToString(𝔽(i)) to keys. 1. For each own property key P of
O such that P is a String and P is not an integer index, in
ascending chronological order of property creation, do 1. Append P
to keys. 1. For each own property key P of O such that P
is a Symbol, in ascending chronological order of property creation, do
1. Append P to keys. 1. Return keys.

TypedArray With Buffer Witness Records
--------------------------------------

An TypedArray With Buffer Witness Record is a Record value used to
encapsulate a TypedArray along with a cached byte length of the viewed
buffer. It is used to help ensure there is a single shared memory read
event of the byte length data block when the viewed buffer is a growable
SharedArrayBuffer.

TypedArray With Buffer Witness Records have the fields listed in .

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[Object]]           | a TypedArray         | The TypedArray whose |
|                      |                      | buffer's byte length |
|                      |                      | is loaded.           |
+----------------------+----------------------+----------------------+
| [[Cach               | a non-negative       | The byte length of   |
| edBufferByteLength]] | integer or           | the object's         |
|                      | ~detached~           | [                    |
|                      |                      | [ViewedArrayBuffer]] |
|                      |                      | when the Record was  |
|                      |                      | created.             |
+----------------------+----------------------+----------------------+

MakeTypedArrayWithBufferWitnessRecord ( obj: a TypedArray, order: ~seq-cst~ or ~unordered~, ): a TypedArray With Buffer Witness Record
----------------------------------------------------------------------------------------------------------------------------------------------

1. Let buffer be obj.[[ViewedArrayBuffer]]. 1. If
IsDetachedBuffer(buffer) is `true`, then 1. Let byteLength be
~detached~. 1. Else, 1. Let byteLength be
ArrayBufferByteLength(buffer, order). 1. Return the TypedArray
With Buffer Witness Record { [[Object]]: obj,
[[CachedBufferByteLength]]: byteLength }.

TypedArrayCreate ( prototype: an Object, ): a TypedArray
------------------------------------------------------------

description
   It is used to specify the creation of new TypedArrays.

1. Let internalSlotsList be « [[Prototype]], [[Extensible]],
[[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]],
[[ByteLength]], [[ByteOffset]], [[ArrayLength]] ». 1. Let A be
MakeBasicObject(internalSlotsList). 1. Set A.[[GetOwnProperty]]
as specified in . 1. Set A.[[HasProperty]] as specified in . 1. Set
A.[[DefineOwnProperty]] as specified in . 1. Set A.[[Get]] as
specified in . 1. Set A.[[Set]] as specified in . 1. Set
A.[[Delete]] as specified in . 1. Set A.[[OwnPropertyKeys]] as
specified in . 1. Set A.[[Prototype]] to prototype. 1. Return
A.

TypedArrayByteLength ( taRecord: a TypedArray With Buffer Witness Record, ): a non-negative integer
-------------------------------------------------------------------------------------------------------

1. If IsTypedArrayOutOfBounds(taRecord) is `true`, return 0. 1.
Let length be TypedArrayLength(taRecord). 1. If length = 0,
return 0. 1. Let O be taRecord.[[Object]]. 1. If
O.[[ByteLength]] is not ~auto~, return O.[[ByteLength]]. 1. Let
elementSize be TypedArrayElementSize(O). 1. Return length ×
elementSize.

TypedArrayLength ( taRecord: a TypedArray With Buffer Witness Record, ): a non-negative integer
---------------------------------------------------------------------------------------------------

1. Assert: IsTypedArrayOutOfBounds(taRecord) is `false`. 1. Let
O be taRecord.[[Object]]. 1. If O.[[ArrayLength]] is not
~auto~, return O.[[ArrayLength]]. 1. Assert:
IsFixedLengthArrayBuffer(O.[[ViewedArrayBuffer]]) is `false`. 1.
Let byteOffset be O.[[ByteOffset]]. 1. Let elementSize be
TypedArrayElementSize(O). 1. Let byteLength be
taRecord.[[CachedBufferByteLength]]. 1. Assert: byteLength is
not ~detached~. 1. Return floor((byteLength - byteOffset) /
elementSize).

IsTypedArrayOutOfBounds ( taRecord: a TypedArray With Buffer Witness Record, ): a Boolean
---------------------------------------------------------------------------------------------

description
   It checks if any of the object's numeric properties reference a value
   at an index not contained within the underlying buffer's bounds.

1. Let O be taRecord.[[Object]]. 1. Let bufferByteLength be
taRecord.[[CachedBufferByteLength]]. 1. Assert:
IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is `true` if and only if
bufferByteLength is ~detached~. 1. If bufferByteLength is
~detached~, return `true`. 1. Let byteOffsetStart be
O.[[ByteOffset]]. 1. If O.[[ArrayLength]] is ~auto~, then 1. Let
byteOffsetEnd be bufferByteLength. 1. Else, 1. Let
elementSize be TypedArrayElementSize(O). 1. Let
byteOffsetEnd be byteOffsetStart + O.[[ArrayLength]] ×
elementSize. 1. If byteOffsetStart > bufferByteLength or
byteOffsetEnd > bufferByteLength, return `true`. 1. NOTE:
0-length TypedArrays are not considered out-of-bounds. 1. Return
`false`.

IsValidIntegerIndex ( O: a TypedArray, index: a Number, ): a Boolean
----------------------------------------------------------------------------

1. If IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is `true`, return
`false`. 1. If index is not an integral Number, return `false`.
1. If index is `-0`\ :sub:`𝔽`, return `false`. 1. Let
taRecord be MakeTypedArrayWithBufferWitnessRecord(O,
~unordered~). 1. NOTE: Bounds checking is not a synchronizing operation
when O's backing buffer is a growable SharedArrayBuffer. 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, return `false`. 1.
Let length be TypedArrayLength(taRecord). 1. If ℝ(index) < 0
or ℝ(index) ≥ length, return `false`. 1. Return `true`.

TypedArrayGetElement ( O: a TypedArray, index: a Number, ): a Number, a BigInt, or `undefined`
--------------------------------------------------------------------------------------------------------

1. If IsValidIntegerIndex(O, index) is `false`, return
`undefined`. 1. Let offset be O.[[ByteOffset]]. 1. Let
elementSize be TypedArrayElementSize(O). 1. Let
byteIndexInBuffer be (ℝ(index) × elementSize) + offset.
1. Let elementType be TypedArrayElementType(O). 1. Return
GetValueFromBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer,
elementType, `true`, ~unordered~).

TypedArraySetElement ( O: a TypedArray, index: a Number, value, )
-----------------------------------------------------------------

1. If O.[[ContentType]] is ~bigint~, let numValue be ?
ToBigInt(value). 1. Otherwise, let numValue be ?
ToNumber(value). 1. If IsValidIntegerIndex(O, index) is
`true`, then 1. Let offset be O.[[ByteOffset]]. 1. Let
elementSize be TypedArrayElementSize(O). 1. Let
byteIndexInBuffer be (ℝ(index) × elementSize) + offset.
1. Let elementType be TypedArrayElementType(O). 1. Perform
SetValueInBuffer(O.[[ViewedArrayBuffer]], byteIndexInBuffer,
elementType, numValue, `true`, ~unordered~). 1. Return
~unused~.

This operation always appears to succeed, but it has no effect when
attempting to write past the end of a TypedArray or to a TypedArray
which is backed by a detached ArrayBuffer.

IsArrayBufferViewOutOfBounds ( O: a TypedArray or a DataView, ): a Boolean
------------------------------------------------------------------------------

description
   It checks if either any of a TypedArray's numeric properties or a
   DataView object's methods can reference a value at an index not
   contained within the underlying data block's bounds. This abstract
   operation exists as a convenience for upstream specifications.

1. If O has a [[DataView]] internal slot, then 1. Let viewRecord
be MakeDataViewWithBufferWitnessRecord(O, ~seq-cst~). 1. Return
IsViewOutOfBounds(viewRecord). 1. Let taRecord be
MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~). 1. Return
IsTypedArrayOutOfBounds(taRecord).

Module Namespace Exotic Objects
-------------------------------

A module namespace exotic object is an exotic object that exposes the
bindings exported from an ECMAScript `Module` (See ). There is a
one-to-one correspondence between the String-keyed own properties of a
module namespace exotic object and the binding names exported by the
`Module`. The exported bindings include any bindings that are
indirectly exported using `export `` export items. Each String-valued
own property key is the StringValue of the corresponding exported
binding name. These are the only String-keyed properties of a module
namespace exotic object. Each such property has the attributes {
[[Writable]]: `true`, [[Enumerable]]: `true`, [[Configurable]]:
`false` }. Module namespace exotic objects are not extensible.

An object is a module namespace exotic object if its [[GetPrototypeOf]],
[[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]],
[[GetOwnProperty]], [[DefineOwnProperty]], [[HasProperty]], [[Get]],
[[Set]], [[Delete]], and [[OwnPropertyKeys]] internal methods use the
definitions in this section, and its other essential internal methods
use the definitions found in . These methods are installed by
ModuleNamespaceCreate.

Module namespace exotic objects have the internal slots defined in .

+---------------+-------------------+--------------------------------+
| Internal Slot | Type              | Description                    |
+===============+===================+================================+
| [[Module]]    | a Module Record   | The Module Record whose        |
|               |                   | exports this namespace         |
|               |                   | exposes.                       |
+---------------+-------------------+--------------------------------+
| [[Exports]]   | a List of Strings | A List whose elements are the  |
|               |                   | String values of the exported  |
|               |                   | names exposed as own           |
|               |                   | properties of this object. The |
|               |                   | list is sorted according to    |
|               |                   | lexicographic code unit order. |
+---------------+-------------------+--------------------------------+

[[GetPrototypeOf]] ( ): a normal completion containing `null`
---------------------------------------------------------------

for
   a module namespace exotic object

1. Return `null`.

.. _setprototypeof-_v_-an-object-or-null-a-normal-completion-containing-a-boolean-1:

[[SetPrototypeOf]] ( V: an Object or `null`, ): a normal completion containing a Boolean
----------------------------------------------------------------------------------------------

for
   a module namespace exotic object O

1. Return ! SetImmutablePrototype(O, V).

[[IsExtensible]] ( ): a normal completion containing `false`
--------------------------------------------------------------

for
   a module namespace exotic object

1. Return `false`.

.. _preventextensions-a-normal-completion-containing-true-1:

[[PreventExtensions]] ( ): a normal completion containing `true`
------------------------------------------------------------------

for
   a module namespace exotic object

1. Return `true`.

[[GetOwnProperty]] ( P: a property key, )
-----------------------------------------

for
   a module namespace exotic object O

1. If P is a Symbol, return OrdinaryGetOwnProperty(O, P). 1.
Let exports be O.[[Exports]]. 1. If exports does not contain
P, return `undefined`. 1. Let value be ? O.[[Get]](P,
O). 1. Return PropertyDescriptor { [[Value]]: value,
[[Writable]]: `true`, [[Enumerable]]: `true`, [[Configurable]]:
`false` }.

.. _defineownproperty-_p_-a-property-key-_desc_-a-property-descriptor-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-3:

[[DefineOwnProperty]] ( P: a property key, Desc: a Property Descriptor, )
-------------------------------------------------------------------------

for
   a module namespace exotic object O

1. If P is a Symbol, return ! OrdinaryDefineOwnProperty(O,
P, Desc). 1. Let current be ?
O.[[GetOwnProperty]](P). 1. If current is `undefined`,
return `false`. 1. If Desc has a [[Configurable]] field and
Desc.[[Configurable]] is `true`, return `false`. 1. If Desc
has an [[Enumerable]] field and Desc.[[Enumerable]] is `false`,
return `false`. 1. If IsAccessorDescriptor(Desc) is `true`,
return `false`. 1. If Desc has a [[Writable]] field and
Desc.[[Writable]] is `false`, return `false`. 1. If Desc has
a [[Value]] field, return SameValue(Desc.[[Value]],
current.[[Value]]). 1. Return `true`.

[[HasProperty]] ( P: a property key, ): a normal completion containing a Boolean
------------------------------------------------------------------------------------

for
   a module namespace exotic object O

1. If P is a Symbol, return ! OrdinaryHasProperty(O, P). 1.
Let exports be O.[[Exports]]. 1. If exports contains P,
return `true`. 1. Return `false`.

.. _get-_p_-a-property-key-_receiver_-an-ecmascript-language-value-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-3:

[[Get]] ( P: a property key, Receiver, )
----------------------------------------

for
   a module namespace exotic object O

1. If P is a Symbol, then 1. Return ! OrdinaryGet(O, P,
Receiver). 1. Let exports be O.[[Exports]]. 1. If
exports does not contain P, return `undefined`. 1. Let m
be O.[[Module]]. 1. Let binding be m.ResolveExport(P).
1. Assert: binding is a ResolvedBinding Record. 1. Let
targetModule be binding.[[Module]]. 1. Assert: targetModule
is not `undefined`. 1. If binding.[[BindingName]] is ~namespace~,
then 1. Return GetModuleNamespace(targetModule). 1. Let
targetEnv be targetModule.[[Environment]]. 1. If targetEnv
is ~empty~, throw a `ReferenceError` exception. 1. Return ?
targetEnv.GetBindingValue(binding.[[BindingName]], `true`).

ResolveExport is side-effect free. Each time this operation is called
with a specific exportName, resolveSet pair as arguments it must
return the same result. An implementation might choose to pre-compute or
cache the ResolveExport results for the [[Exports]] of each module
namespace exotic object.

[[Set]] ( P: a property key, V, Receiver, ): a normal completion containing `false`
-------------------------------------------------------------------------------------------------------------------------------------------------------------

for
   a module namespace exotic object

1. Return `false`.

.. _delete-_p_-a-property-key-a-normal-completion-containing-a-boolean-1:

[[Delete]] ( P: a property key, ): a normal completion containing a Boolean
-------------------------------------------------------------------------------

for
   a module namespace exotic object O

1. If P is a Symbol, then 1. Return ! OrdinaryDelete(O, P).
1. Let exports be O.[[Exports]]. 1. If exports contains
P, return `false`. 1. Return `true`.

.. _ownpropertykeys-a-normal-completion-containing-a-list-of-property-keys-3:

[[OwnPropertyKeys]] ( ): a normal completion containing a List of property keys
-------------------------------------------------------------------------------

for
   a module namespace exotic object O

1. Let exports be O.[[Exports]]. 1. Let symbolKeys be
OrdinaryOwnPropertyKeys(O). 1. Return the list-concatenation of
exports and symbolKeys.

ModuleNamespaceCreate ( module: a Module Record, exports: a List of Strings, ): a module namespace exotic object
------------------------------------------------------------------------------------------------------------------------

description
   It is used to specify the creation of new module namespace exotic
   objects.

1. Assert: module.[[Namespace]] is ~empty~. 1. Let
internalSlotsList be the internal slots listed in . 1. Let M be
MakeBasicObject(internalSlotsList). 1. Set M's essential
internal methods to the definitions specified in . 1. Set
M.[[Module]] to module. 1. Let sortedExports be a List whose
elements are the elements of exports, sorted according to
lexicographic code unit order. 1. Set M.[[Exports]] to
sortedExports. 1. Create own properties of M corresponding to
the definitions in . 1. Set module.[[Namespace]] to M. 1. Return
M.

Immutable Prototype Exotic Objects
----------------------------------

An immutable prototype exotic object is an exotic object that has a
[[Prototype]] internal slot that will not change once it is initialized.

An object is an immutable prototype exotic object if its
[[SetPrototypeOf]] internal method uses the following implementation.
(Its other essential internal methods may use any implementation,
depending on the specific immutable prototype exotic object in
question.)

Unlike other exotic objects, there is not a dedicated creation abstract
operation provided for immutable prototype exotic objects. This is
because they are only used by %Object.prototype% and by host
environments, and in host environments, the relevant objects are
potentially exotic in other ways and thus need their own dedicated
creation operation.

[[SetPrototypeOf]] ( V: an Object or `null`, )
----------------------------------------------

for
   an immutable prototype exotic object O

1. Return ? SetImmutablePrototype(O, V).

SetImmutablePrototype ( O: an Object, V: an Object or `null`, )
---------------------------------------------------------------

1. Let current be ? O.[[GetPrototypeOf]](). 1. If
SameValue(V, current) is `true`, return `true`. 1. Return
`false`.

Proxy Object Internal Methods and Internal Slots
------------------------------------------------

A Proxy object is an exotic object whose essential internal methods are
partially implemented using ECMAScript code. Every Proxy object has an
internal slot called [[ProxyHandler]]. The value of [[ProxyHandler]] is
an object, called the proxy's *handler object*, or `null`. Methods
(see ) of a handler object may be used to augment the implementation for
one or more of the Proxy object's internal methods. Every Proxy object
also has an internal slot called [[ProxyTarget]] whose value is either
an object or the `null` value. This object is called the proxy's
*target object*.

An object is a Proxy exotic object if its essential internal methods
(including [[Call]] and [[Construct]], if applicable) use the
definitions in this section. These internal methods are installed in
ProxyCreate.

===================== ============================
Internal Method       Handler Method
===================== ============================
[[GetPrototypeOf]]    `getPrototypeOf`
[[SetPrototypeOf]]    `setPrototypeOf`
[[IsExtensible]]      `isExtensible`
[[PreventExtensions]] `preventExtensions`
[[GetOwnProperty]]    `getOwnPropertyDescriptor`
[[DefineOwnProperty]] `defineProperty`
[[HasProperty]]       `has`
[[Get]]               `get`
[[Set]]               `set`
[[Delete]]            `deleteProperty`
[[OwnPropertyKeys]]   `ownKeys`
[[Call]]              `apply`
[[Construct]]         `construct`
===================== ============================

When a handler method is called to provide the implementation of a Proxy
object internal method, the handler method is passed the proxy's target
object as a parameter. A proxy's handler object does not necessarily
have a method corresponding to every essential internal method. Invoking
an internal method on the proxy results in the invocation of the
corresponding internal method on the proxy's target object if the
handler object does not have a method corresponding to the internal
trap.

The [[ProxyHandler]] and [[ProxyTarget]] internal slots of a Proxy
object are always initialized when the object is created and typically
may not be modified. Some Proxy objects are created in a manner that
permits them to be subsequently *revoked*. When a proxy is revoked, its
[[ProxyHandler]] and [[ProxyTarget]] internal slots are set to `null`
causing subsequent invocations of internal methods on that Proxy object
to throw a `TypeError` exception.

Because Proxy objects permit the implementation of internal methods to
be provided by arbitrary ECMAScript code, it is possible to define a
Proxy object whose handler methods violates the invariants defined in .
Some of the internal method invariants defined in are essential
integrity invariants. These invariants are explicitly enforced by the
Proxy object internal methods specified in this section. An ECMAScript
implementation must be robust in the presence of all possible invariant
violations.

In the following algorithm descriptions, assume O is an ECMAScript
Proxy object, P is a property key value, V is any ECMAScript
language value and Desc is a Property Descriptor record.

[[GetPrototypeOf]] ( )
----------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"getPrototypeOf"`). 1. If trap is
`undefined`, then 1. Return ? target.[[GetPrototypeOf]](). 1. Let
handlerProto be ? Call(trap, handler, « target »). 1. If
handlerProto is not an Object and handlerProto is not `null`,
throw a `TypeError` exception. 1. Let extensibleTarget be ?
IsExtensible(target). 1. If extensibleTarget is `true`, return
handlerProto. 1. Let targetProto be ?
target.[[GetPrototypeOf]](). 1. If SameValue(handlerProto,
targetProto) is `false`, throw a `TypeError` exception. 1.
Return handlerProto.

[[GetPrototypeOf]] for Proxy objects enforces the following invariants:

- The result of [[GetPrototypeOf]] must be either an Object or `null`.
- If the target object is not extensible, [[GetPrototypeOf]] applied to
  the Proxy object must return the same value as [[GetPrototypeOf]]
  applied to the Proxy object's target object.

.. _setprototypeof-_v_-an-object-or-null-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-1:

[[SetPrototypeOf]] ( V: an Object or `null`, )
----------------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"setPrototypeOf"`). 1. If trap is
`undefined`, then 1. Return ? target.[[SetPrototypeOf]](V). 1.
Let booleanTrapResult be ToBoolean(? Call(trap, handler, «
target, V »)). 1. If booleanTrapResult is `false`, return
`false`. 1. Let extensibleTarget be ? IsExtensible(target). 1.
If extensibleTarget is `true`, return `true`. 1. Let
targetProto be ? target.[[GetPrototypeOf]](). 1. If
SameValue(V, targetProto) is `false`, throw a `TypeError`
exception. 1. Return `true`.

[[SetPrototypeOf]] for Proxy objects enforces the following invariants:

- The result of [[SetPrototypeOf]] is a Boolean value.
- If the target object is not extensible, the argument value must be the
  same as the result of [[GetPrototypeOf]] applied to target object.

[[IsExtensible]] ( )
--------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"isExtensible"`). 1. If trap is
`undefined`, then 1. Return ? IsExtensible(target). 1. Let
booleanTrapResult be ToBoolean(? Call(trap, handler, «
target »)). 1. Let targetResult be ? IsExtensible(target).
1. If booleanTrapResult is not targetResult, throw a
`TypeError` exception. 1. Return booleanTrapResult.

[[IsExtensible]] for Proxy objects enforces the following invariants:

- The result of [[IsExtensible]] is a Boolean value.
- [[IsExtensible]] applied to the Proxy object must return the same
  value as [[IsExtensible]] applied to the Proxy object's target object
  with the same argument.

[[PreventExtensions]] ( )
-------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"preventExtensions"`). 1. If trap is
`undefined`, then 1. Return ? target.[[PreventExtensions]](). 1.
Let booleanTrapResult be ToBoolean(? Call(trap, handler, «
target »)). 1. If booleanTrapResult is `true`, then 1. Let
extensibleTarget be ? IsExtensible(target). 1. If
extensibleTarget is `true`, throw a `TypeError` exception. 1.
Return booleanTrapResult.

[[PreventExtensions]] for Proxy objects enforces the following
invariants:

- The result of [[PreventExtensions]] is a Boolean value.
- [[PreventExtensions]] applied to the Proxy object only returns
  `true` if [[IsExtensible]] applied to the Proxy object's target
  object is `false`.

.. _getownproperty-_p_-a-property-key-either-a-normal-completion-containing-either-a-property-descriptor-or-undefined-or-a-throw-completion-1:

[[GetOwnProperty]] ( P: a property key, )
-----------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"getOwnPropertyDescriptor"`). 1. If trap
is `undefined`, then 1. Return ? target.[[GetOwnProperty]](P).
1. Let trapResultObj be ? Call(trap, handler, « target,
P »). 1. If trapResultObj is not an Object and trapResultObj
is not `undefined`, throw a `TypeError` exception. 1. Let
targetDesc be ? target.[[GetOwnProperty]](P). 1. If
trapResultObj is `undefined`, then 1. If targetDesc is
`undefined`, return `undefined`. 1. If
targetDesc.[[Configurable]] is `false`, throw a `TypeError`
exception. 1. Let extensibleTarget be ? IsExtensible(target). 1.
If extensibleTarget is `false`, throw a `TypeError` exception.
1. Return `undefined`. 1. Let extensibleTarget be ?
IsExtensible(target). 1. Let resultDesc be ?
ToPropertyDescriptor(trapResultObj). 1. Perform
CompletePropertyDescriptor(resultDesc). 1. Let valid be
IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc,
targetDesc). 1. If valid is `false`, throw a `TypeError`
exception. 1. If resultDesc.[[Configurable]] is `false`, then 1.
If targetDesc is `undefined` or targetDesc.[[Configurable]] is
`true`, then 1. Throw a `TypeError` exception. 1. If resultDesc
has a [[Writable]] field and resultDesc.[[Writable]] is `false`,
then 1. Assert: targetDesc has a [[Writable]] field. 1. If
targetDesc.[[Writable]] is `true`, throw a `TypeError`
exception. 1. Return resultDesc.

[[GetOwnProperty]] for Proxy objects enforces the following invariants:

- The result of [[GetOwnProperty]] must be either an Object or
  `undefined`.
- A property cannot be reported as non-existent, if it exists as a
  non-configurable own property of the target object.
- A property cannot be reported as non-existent, if it exists as an own
  property of a non-extensible target object.
- A property cannot be reported as existent, if it does not exist as an
  own property of the target object and the target object is not
  extensible.
- A property cannot be reported as non-configurable, unless it exists as
  a non-configurable own property of the target object.
- A property cannot be reported as both non-configurable and
  non-writable, unless it exists as a non-configurable, non-writable own
  property of the target object.

.. _defineownproperty-_p_-a-property-key-_desc_-a-property-descriptor-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-4:

[[DefineOwnProperty]] ( P: a property key, Desc: a Property Descriptor, )
-------------------------------------------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"defineProperty"`). 1. If trap is
`undefined`, then 1. Return ? target.[[DefineOwnProperty]](P,
Desc). 1. Let descObj be FromPropertyDescriptor(Desc). 1.
Let booleanTrapResult be ToBoolean(? Call(trap, handler, «
target, P, descObj »)). 1. If booleanTrapResult is
`false`, return `false`. 1. Let targetDesc be ?
target.[[GetOwnProperty]](P). 1. Let extensibleTarget be ?
IsExtensible(target). 1. If Desc has a [[Configurable]] field
and Desc.[[Configurable]] is `false`, then 1. Let
settingConfigFalse be `true`. 1. Else, 1. Let
settingConfigFalse be `false`. 1. If targetDesc is
`undefined`, then 1. If extensibleTarget is `false`, throw a
`TypeError` exception. 1. If settingConfigFalse is `true`, throw
a `TypeError` exception. 1. Else, 1. If
IsCompatiblePropertyDescriptor(extensibleTarget, Desc,
targetDesc) is `false`, throw a `TypeError` exception. 1. If
settingConfigFalse is `true` and targetDesc.[[Configurable]]
is `true`, throw a `TypeError` exception. 1. If
IsDataDescriptor(targetDesc) is `true`,
targetDesc.[[Configurable]] is `false`, and
targetDesc.[[Writable]] is `true`, then 1. If Desc has a
[[Writable]] field and Desc.[[Writable]] is `false`, throw a
`TypeError` exception. 1. Return `true`.

[[DefineOwnProperty]] for Proxy objects enforces the following
invariants:

- The result of [[DefineOwnProperty]] is a Boolean value.
- A property cannot be added, if the target object is not extensible.
- A property cannot be non-configurable, unless there exists a
  corresponding non-configurable own property of the target object.
- A non-configurable property cannot be non-writable, unless there
  exists a corresponding non-configurable, non-writable own property of
  the target object.
- If a property has a corresponding target object property then applying
  the Property Descriptor of the property to the target object using
  [[DefineOwnProperty]] will not throw an exception.

.. _hasproperty-_p_-a-property-key-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-2:

[[HasProperty]] ( P: a property key, )
--------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"has"`). 1. If trap is `undefined`, then
1. Return ? target.[[HasProperty]](P). 1. Let
booleanTrapResult be ToBoolean(? Call(trap, handler, «
target, P »)). 1. If booleanTrapResult is `false`, then 1.
Let targetDesc be ? target.[[GetOwnProperty]](P). 1. If
targetDesc is not `undefined`, then 1. If
targetDesc.[[Configurable]] is `false`, throw a `TypeError`
exception. 1. Let extensibleTarget be ? IsExtensible(target). 1.
If extensibleTarget is `false`, throw a `TypeError` exception.
1. Return booleanTrapResult.

[[HasProperty]] for Proxy objects enforces the following invariants:

- The result of [[HasProperty]] is a Boolean value.
- A property cannot be reported as non-existent, if it exists as a
  non-configurable own property of the target object.
- A property cannot be reported as non-existent, if it exists as an own
  property of the target object and the target object is not extensible.

.. _get-_p_-a-property-key-_receiver_-an-ecmascript-language-value-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-4:

[[Get]] ( P: a property key, Receiver, )
----------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"get"`). 1. If trap is `undefined`, then
1. Return ? target.[[Get]](P, Receiver). 1. Let
trapResult be ? Call(trap, handler, « target, P,
Receiver »). 1. Let targetDesc be ?
target.[[GetOwnProperty]](P). 1. If targetDesc is not
`undefined` and targetDesc.[[Configurable]] is `false`, then 1.
If IsDataDescriptor(targetDesc) is `true` and
targetDesc.[[Writable]] is `false`, then 1. If
SameValue(trapResult, targetDesc.[[Value]]) is `false`, throw
a `TypeError` exception. 1. If IsAccessorDescriptor(targetDesc) is
`true` and targetDesc.[[Get]] is `undefined`, then 1. If
trapResult is not `undefined`, throw a `TypeError` exception. 1.
Return trapResult.

[[Get]] for Proxy objects enforces the following invariants:

- The value reported for a property must be the same as the value of the
  corresponding target object property if the target object property is
  a non-writable, non-configurable own data property.
- The value reported for a property must be `undefined` if the
  corresponding target object property is a non-configurable own
  accessor property that has `undefined` as its [[Get]] attribute.

.. _set-_p_-a-property-key-_v_-an-ecmascript-language-value-_receiver_-an-ecmascript-language-value-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-3:

[[Set]] ( P: a property key, V, Receiver, )
-------------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"set"`). 1. If trap is `undefined`, then
1. Return ? target.[[Set]](P, V, Receiver). 1. Let
booleanTrapResult be ToBoolean(? Call(trap, handler, «
target, P, V, Receiver »)). 1. If booleanTrapResult
is `false`, return `false`. 1. Let targetDesc be ?
target.[[GetOwnProperty]](P). 1. If targetDesc is not
`undefined` and targetDesc.[[Configurable]] is `false`, then 1.
If IsDataDescriptor(targetDesc) is `true` and
targetDesc.[[Writable]] is `false`, then 1. If SameValue(V,
targetDesc.[[Value]]) is `false`, throw a `TypeError` exception.
1. If IsAccessorDescriptor(targetDesc) is `true`, then 1. If
targetDesc.[[Set]] is `undefined`, throw a `TypeError`
exception. 1. Return `true`.

[[Set]] for Proxy objects enforces the following invariants:

- The result of [[Set]] is a Boolean value.
- Cannot change the value of a property to be different from the value
  of the corresponding target object property if the corresponding
  target object property is a non-writable, non-configurable own data
  property.
- Cannot set the value of a property if the corresponding target object
  property is a non-configurable own accessor property that has
  `undefined` as its [[Set]] attribute.

.. _delete-_p_-a-property-key-either-a-normal-completion-containing-a-boolean-or-a-throw-completion-2:

[[Delete]] ( P: a property key, )
---------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"deleteProperty"`). 1. If trap is
`undefined`, then 1. Return ? target.[[Delete]](P). 1. Let
booleanTrapResult be ToBoolean(? Call(trap, handler, «
target, P »)). 1. If booleanTrapResult is `false`, return
`false`. 1. Let targetDesc be ?
target.[[GetOwnProperty]](P). 1. If targetDesc is
`undefined`, return `true`. 1. If targetDesc.[[Configurable]] is
`false`, throw a `TypeError` exception. 1. Let extensibleTarget
be ? IsExtensible(target). 1. If extensibleTarget is `false`,
throw a `TypeError` exception. 1. Return `true`.

[[Delete]] for Proxy objects enforces the following invariants:

- The result of [[Delete]] is a Boolean value.
- A property cannot be reported as deleted, if it exists as a
  non-configurable own property of the target object.
- A property cannot be reported as deleted, if it exists as an own
  property of the target object and the target object is non-extensible.

[[OwnPropertyKeys]] ( )
-----------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"ownKeys"`). 1. If trap is `undefined`,
then 1. Return ? target.[[OwnPropertyKeys]](). 1. Let
trapResultArray be ? Call(trap, handler, « target »). 1.
Let trapResult be ? CreateListFromArrayLike(trapResultArray,
~property-key~). 1. If trapResult contains any duplicate entries,
throw a `TypeError` exception. 1. Let extensibleTarget be ?
IsExtensible(target). 1. Let targetKeys be ?
target.[[OwnPropertyKeys]](). 1. Assert: targetKeys is a List of
property keys. 1. Assert: targetKeys contains no duplicate entries.
1. Let targetConfigurableKeys be a new empty List. 1. Let
targetNonconfigurableKeys be a new empty List. 1. For each element
key of targetKeys, do 1. Let desc be ?
target.[[GetOwnProperty]](key). 1. If desc is not
`undefined` and desc.[[Configurable]] is `false`, then 1. Append
key to targetNonconfigurableKeys. 1. Else, 1. Append key to
targetConfigurableKeys. 1. If extensibleTarget is `true` and
targetNonconfigurableKeys is empty, then 1. Return trapResult.
1. Let uncheckedResultKeys be a List whose elements are the elements
of trapResult. 1. For each element key of
targetNonconfigurableKeys, do 1. If uncheckedResultKeys does not
contain key, throw a `TypeError` exception. 1. Remove key from
uncheckedResultKeys. 1. If extensibleTarget is `true`, return
trapResult. 1. For each element key of
targetConfigurableKeys, do 1. If uncheckedResultKeys does not
contain key, throw a `TypeError` exception. 1. Remove key from
uncheckedResultKeys. 1. If uncheckedResultKeys is not empty,
throw a `TypeError` exception. 1. Return trapResult.

[[OwnPropertyKeys]] for Proxy objects enforces the following invariants:

- The result of [[OwnPropertyKeys]] is a List.
- The returned List contains no duplicate entries.
- Each element of the returned List is a property key.
- The result List must contain the keys of all non-configurable own
  properties of the target object.
- If the target object is not extensible, then the result List must
  contain all the keys of the own properties of the target object and no
  other values.

.. _call-_thisargument_-an-ecmascript-language-value-_argumentslist_-a-list-of-ecmascript-language-values-either-a-normal-completion-containing-an-ecmascript-language-value-or-a-throw-completion-3:

[[Call]] ( thisArgument, argumentsList: a List of ECMAScript language values, )
-------------------------------------------------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Let handler be O.[[ProxyHandler]]. 1.
Assert: handler is an Object. 1. Let trap be ?
GetMethod(handler, `"apply"`). 1. If trap is `undefined`,
then 1. Return ? Call(target, thisArgument, argumentsList).
1. Let argArray be CreateArrayFromList(argumentsList). 1. Return
? Call(trap, handler, « target, thisArgument,
argArray »).

A Proxy exotic object only has a [[Call]] internal method if the initial
value of its [[ProxyTarget]] internal slot is an object that has a
[[Call]] internal method.

.. _construct-_argumentslist_-a-list-of-ecmascript-language-values-_newtarget_-a-constructor-either-a-normal-completion-containing-an-object-or-a-throw-completion-3:

[[Construct]] ( argumentsList: a List of ECMAScript language values, newTarget: a constructor, )
------------------------------------------------------------------------------------------------

for
   a Proxy exotic object O

1. Perform ? ValidateNonRevokedProxy(O). 1. Let target be
O.[[ProxyTarget]]. 1. Assert: IsConstructor(target) is `true`.
1. Let handler be O.[[ProxyHandler]]. 1. Assert: handler is
an Object. 1. Let trap be ? GetMethod(handler, `"construct"`).
1. If trap is `undefined`, then 1. Return ? Construct(target,
argumentsList, newTarget). 1. Let argArray be
CreateArrayFromList(argumentsList). 1. Let newObj be ?
Call(trap, handler, « target, argArray, newTarget
»). 1. If newObj is not an Object, throw a `TypeError` exception.
1. Return newObj.

A Proxy exotic object only has a [[Construct]] internal method if the
initial value of its [[ProxyTarget]] internal slot is an object that has
a [[Construct]] internal method.

[[Construct]] for Proxy objects enforces the following invariants:

- The result of [[Construct]] must be an Object.

ValidateNonRevokedProxy ( proxy: a Proxy exotic object, )
---------------------------------------------------------

description
   It throws a `TypeError` exception if proxy has been revoked.

1. If proxy.[[ProxyTarget]] is `null`, throw a `TypeError`
exception. 1. Assert: proxy.[[ProxyHandler]] is not `null`. 1.
Return ~unused~.

ProxyCreate ( target, handler, )
--------------------------------

description
   It is used to specify the creation of new Proxy objects.

1. If target is not an Object, throw a `TypeError` exception. 1.
If handler is not an Object, throw a `TypeError` exception. 1. Let
P be MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »). 1. Set
P's essential internal methods, except for [[Call]] and
[[Construct]], to the definitions specified in . 1. If
IsCallable(target) is `true`, then 1. Set P.[[Call]] as
specified in . 1. If IsConstructor(target) is `true`, then 1. Set
P.[[Construct]] as specified in . 1. Set P.[[ProxyTarget]] to
target. 1. Set P.[[ProxyHandler]] to handler. 1. Return
P.

11. ECMAScript Language: Source Text
====================================

https://tc39.es/ecma262/multipage/ecmascript-language-source-code.html
::

   11.1 Source Text
      11.1.1 SS: UTF16EncodeCodePoint ( cp )
      11.1.2 SS: CodePointsToString ( text )
      11.1.3 SS: UTF16SurrogatePairToCodePoint ( lead, trail )
      11.1.4 SS: CodePointAt ( string, position )
      11.1.5 SS: StringToCodePoints ( string )
      11.1.6 SS: ParseText ( sourceText, goalSymbol )
   11.2 Types of Source Code
      11.2.1 Directive Prologues and the Use Strict Directive
      11.2.2 Strict Mode Code
         11.2.2.1 SS: IsStrict ( node )
      11.2.3 Non-ECMAScript Functions

Source Text
-----------


**Syntax**


SourceCharacter :: > any Unicode code point

ECMAScript source text is a sequence of Unicode code points. All Unicode
code point values from U+0000 to U+10FFFF, including surrogate code
points, may occur in ECMAScript source text where permitted by the
ECMAScript grammars. The actual encodings used to store and interchange
ECMAScript source text is not relevant to this specification. Regardless
of the external source text encoding, a conforming ECMAScript
implementation processes the source text as if it was an equivalent
sequence of `SourceCharacter` values, each `SourceCharacter` being a
Unicode code point. Conforming ECMAScript implementations are not
required to perform any normalization of source text, or behave as
though they were performing normalization of source text.

The components of a combining character sequence are treated as
individual Unicode code points even though a user might think of the
whole sequence as a single character.

In string literals, regular expression literals, template literals and
identifiers, any Unicode code point may also be expressed using Unicode
escape sequences that explicitly express a code point's numeric value.
Within a comment, such an escape sequence is effectively ignored as part
of the comment.

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence `\\\\u000A`, for example, occurs within a single-line
comment, it is interpreted as a line terminator (Unicode code point
U+000A is LINE FEED (LF)) and therefore the next code point is not part
of the comment. Similarly, if the Unicode escape sequence `\\\\u000A`
occurs within a string literal in a Java program, it is likewise
interpreted as a line terminator, which is not allowed within a string
literal—one must write `\\\\n` instead of `\\\\u000A` to cause a
LINE FEED (LF) to be part of the value of a string literal. In an
ECMAScript program, a Unicode escape sequence occurring within a comment
is never interpreted and therefore cannot contribute to termination of
the comment. Similarly, a Unicode escape sequence occurring within a
string literal in an ECMAScript program always contributes to the
literal and is never interpreted as a line terminator or as a code point
that might terminate the string literal.

Static Semantics: UTF16EncodeCodePoint ( cp: a Unicode code point, ): a String
----------------------------------------------------------------------------------

1. Assert: 0 ≤ cp ≤ 0x10FFFF. 1. If cp ≤ 0xFFFF, return the
String value consisting of the code unit whose numeric value is cp.
1. Let cu1 be the code unit whose numeric value is floor((cp -
0x10000) / 0x400) + 0xD800. 1. Let cu2 be the code unit whose
numeric value is ((cp - 0x10000) modulo 0x400) + 0xDC00. 1. Return
the string-concatenation of cu1 and cu2.

Static Semantics: CodePointsToString ( text: a sequence of Unicode code points, ): a String
-----------------------------------------------------------------------------------------------

description
   It converts text into a String value, as described in .

1. Let result be the empty String. 1. For each code point cp of
text, do 1. Set result to the string-concatenation of result
and UTF16EncodeCodePoint(cp). 1. Return result.

Static Semantics: UTF16SurrogatePairToCodePoint ( lead: a code unit, trail: a code unit, ): a code point
----------------------------------------------------------------------------------------------------------------

description
   Two code units that form a UTF-16 surrogate pair are converted to a
   code point.

1. Assert: lead is a leading surrogate and trail is a trailing
surrogate. 1. Let cp be (lead - 0xD800) × 0x400 + (trail -
0xDC00) + 0x10000. 1. Return the code point cp.

Static Semantics: CodePointAt ( string: a String, position: a non-negative integer, ): a Record with fields [[CodePoint]] (a code point), [[CodeUnitCount]] (a positive integer), and [[IsUnpairedSurrogate]] (a Boolean)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It interprets string as a sequence of UTF-16 encoded code points,
   as described in , and reads from it a single code point starting with
   the code unit at index position.

1. Let size be the length of string. 1. Assert: position ≥ 0
and position < size. 1. Let first be the code unit at index
position within string. 1. Let cp be the code point whose
numeric value is the numeric value of first. 1. If first is
neither a leading surrogate nor a trailing surrogate, then 1. Return the
Record { [[CodePoint]]: cp, [[CodeUnitCount]]: 1,
[[IsUnpairedSurrogate]]: `false` }. 1. If first is a trailing
surrogate or position + 1 = size, then 1. Return the Record {
[[CodePoint]]: cp, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]:
`true` }. 1. Let second be the code unit at index position + 1
within string. 1. If second is not a trailing surrogate, then 1.
Return the Record { [[CodePoint]]: cp, [[CodeUnitCount]]: 1,
[[IsUnpairedSurrogate]]: `true` }. 1. Set cp to
UTF16SurrogatePairToCodePoint(first, second). 1. Return the
Record { [[CodePoint]]: cp, [[CodeUnitCount]]: 2,
[[IsUnpairedSurrogate]]: `false` }.

Static Semantics: StringToCodePoints ( string: a String, ): a List of code points
-------------------------------------------------------------------------------------

description
   It returns the sequence of Unicode code points that results from
   interpreting string as UTF-16 encoded Unicode text as described
   in .

1. Let codePoints be a new empty List. 1. Let size be the length
of string. 1. Let position be 0. 1. Repeat, while position <
size, 1. Let cp be CodePointAt(string, position). 1.
Append cp.[[CodePoint]] to codePoints. 1. Set position to
position + cp.[[CodeUnitCount]]. 1. Return codePoints.

Static Semantics: ParseText ( sourceText: a String or a sequence of Unicode code points, goalSymbol: a nonterminal in one of the ECMAScript grammars, ): a Parse Node or a non-empty List of `SyntaxError` objects
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. If sourceText is a String, set sourceText to
StringToCodePoints(sourceText). 1. Attempt to parse sourceText
using goalSymbol as the goal symbol, and analyse the parse result
for any early error conditions. Parsing and early error detection may be
interleaved in an implementation-defined manner. 1. If the parse
succeeded and no early errors were found, return the Parse Node (an
instance of goalSymbol) at the root of the parse tree resulting from
the parse. 1. Otherwise, return a List of one or more `SyntaxError`
objects representing the parsing errors and/or early errors. If more
than one parsing error or early error is present, the number and
ordering of error objects in the list is implementation-defined, but at
least one must be present.

Consider a text that has an early error at a particular point, and also
a syntax error at a later point. An implementation that does a parse
pass followed by an early errors pass might report the syntax error and
not proceed to the early errors pass. An implementation that interleaves
the two activities might report the early error and not proceed to find
the syntax error. A third implementation might report both errors. All
of these behaviours are conformant.

See also clause .

Types of Source Code
--------------------

There are four types of ECMAScript code:

- Global code is source text that is treated as an ECMAScript
  `Script`. The global code of a particular `Script` does not
  include any source text that is parsed as part of a
  `FunctionDeclaration`, `FunctionExpression`,
  `GeneratorDeclaration`, `GeneratorExpression`,
  `AsyncFunctionDeclaration`, `AsyncFunctionExpression`,
  `AsyncGeneratorDeclaration`, `AsyncGeneratorExpression`,
  `MethodDefinition`, `ArrowFunction`, `AsyncArrowFunction`,
  `ClassDeclaration`, or `ClassExpression`.

- Eval code is the source text supplied to the built-in `eval`
  function. More precisely, if the parameter to the built-in `eval`
  function is a String, it is treated as an ECMAScript `Script`. The
  eval code for a particular invocation of `eval` is the global code
  portion of that `Script`.

- Function code is source text that is parsed to supply the value of the
  [[ECMAScriptCode]] and [[FormalParameters]] internal slots (see ) of
  an ECMAScript function object. The function code of a particular
  ECMAScript function does not include any source text that is parsed as
  the function code of a nested `FunctionDeclaration`,
  `FunctionExpression`, `GeneratorDeclaration`,
  `GeneratorExpression`, `AsyncFunctionDeclaration`,
  `AsyncFunctionExpression`, `AsyncGeneratorDeclaration`,
  `AsyncGeneratorExpression`, `MethodDefinition`, `ArrowFunction`,
  `AsyncArrowFunction`, `ClassDeclaration`, or `ClassExpression`.

  In addition, if the source text referred to above is parsed as:

  - the `FormalParameters` and `FunctionBody` of a
    `FunctionDeclaration` or `FunctionExpression`,
  - the `FormalParameters` and `GeneratorBody` of a
    `GeneratorDeclaration` or `GeneratorExpression`,
  - the `FormalParameters` and `AsyncFunctionBody` of an
    `AsyncFunctionDeclaration` or `AsyncFunctionExpression`, or
  - the `FormalParameters` and `AsyncGeneratorBody` of an
    `AsyncGeneratorDeclaration` or `AsyncGeneratorExpression`,

  then the source text matched by the `BindingIdentifier` (if any) of
  that declaration or expression is also included in the function code
  of the corresponding function.

- Module code is source text that is code that is provided as a
  `ModuleBody`. It is the code that is directly evaluated when a
  module is initialized. The module code of a particular module does not
  include any source text that is parsed as part of a nested
  `FunctionDeclaration`, `FunctionExpression`,
  `GeneratorDeclaration`, `GeneratorExpression`,
  `AsyncFunctionDeclaration`, `AsyncFunctionExpression`,
  `AsyncGeneratorDeclaration`, `AsyncGeneratorExpression`,
  `MethodDefinition`, `ArrowFunction`, `AsyncArrowFunction`,
  `ClassDeclaration`, or `ClassExpression`.

Function code is generally provided as the bodies of Function
Definitions (), Arrow Function Definitions (), Method Definitions (),
Generator Function Definitions (), Async Function Definitions (), Async
Generator Function Definitions (), and Async Arrow Functions ().
Function code is also derived from the arguments to the Function
constructor (), the GeneratorFunction constructor (), and the
AsyncFunction constructor ().

The practical effect of including the `BindingIdentifier` in function
code is that the Early Errors for strict mode code are applied to a
`BindingIdentifier` that is the name of a function whose body contains
a "use strict" directive, even if the surrounding code is not strict
mode code.

Directive Prologues and the Use Strict Directive
------------------------------------------------

A Directive Prologue is the longest sequence of \|ExpressionStatement|s
occurring as the initial \|StatementListItem|s or \|ModuleItem|s of a
`FunctionBody`, a `ScriptBody`, or a `ModuleBody` and where each
`ExpressionStatement` in the sequence consists entirely of a
`StringLiteral` token followed by a semicolon. The semicolon may
appear explicitly or may be inserted by automatic semicolon insertion
(). A Directive Prologue may be an empty sequence.

A Use Strict Directive is an `ExpressionStatement` in a Directive
Prologue whose `StringLiteral` is either of the exact code point
sequences `"use strict"` or `'use strict'`. A Use Strict Directive
may not contain an `EscapeSequence` or `LineContinuation`.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

The \|ExpressionStatement|s of a Directive Prologue are evaluated
normally during evaluation of the containing production. Implementations
may define implementation specific meanings for \|ExpressionStatement|s
which are not a Use Strict Directive and which occur in a Directive
Prologue. If an appropriate notification mechanism exists, an
implementation should issue a warning if it encounters in a Directive
Prologue an `ExpressionStatement` that is not a Use Strict Directive
and which does not have a meaning defined by the implementation.

Strict Mode Code
----------------

An ECMAScript syntactic unit may be processed using either unrestricted
or strict mode syntax and semantics (). Code is interpreted as strict
mode code in the following situations:

- Global code is strict mode code if it begins with a Directive Prologue
  that contains a Use Strict Directive.
- Module code is always strict mode code.
- All parts of a `ClassDeclaration` or a `ClassExpression` are
  strict mode code.
- Eval code is strict mode code if it begins with a Directive Prologue
  that contains a Use Strict Directive or if the call to `eval` is a
  direct eval that is contained in strict mode code.
- Function code is strict mode code if the associated
  `FunctionDeclaration`, `FunctionExpression`,
  `GeneratorDeclaration`, `GeneratorExpression`,
  `AsyncFunctionDeclaration`, `AsyncFunctionExpression`,
  `AsyncGeneratorDeclaration`, `AsyncGeneratorExpression`,
  `MethodDefinition`, `ArrowFunction`, or `AsyncArrowFunction` is
  contained in strict mode code or if the code that produces the value
  of the function's [[ECMAScriptCode]] internal slot begins with a
  Directive Prologue that contains a Use Strict Directive.
- Function code that is supplied as the arguments to the built-in
  Function, Generator, AsyncFunction, and AsyncGenerator constructors is
  strict mode code if the last argument is a String that when processed
  is a `FunctionBody` that begins with a Directive Prologue that
  contains a Use Strict Directive.

ECMAScript code that is not strict mode code is called non-strict code.

Static Semantics: IsStrict ( node: a Parse Node, ): a Boolean
-----------------------------------------------------------------

1. If the source text matched by node is strict mode code, return
`true`; else return `false`.

Non-ECMAScript Functions
------------------------

An ECMAScript implementation may support the evaluation of function
exotic objects whose evaluative behaviour is expressed in some
host-defined form of executable code other than ECMAScript source text.
Whether a function object is defined within ECMAScript code or is a
built-in function is not observable from the perspective of ECMAScript
code that calls or is called by such a function object.

12. ECMAScript Language: Lexical Grammar
========================================

https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html
::

   12.1 Unicode Format-Control Characters
   12.2 White Space
   12.3 Line Terminators
   12.4 Comments
   12.5 Hashbang Comments
   12.6 Tokens
   12.7 Names and Keywords
      12.7.1 Identifier Names
         12.7.1.1 SS: Early Errors
         12.7.1.2 SS: IdentifierCodePoints
         12.7.1.3 SS: IdentifierCodePoint
      12.7.2 Keywords and Reserved Words
   12.8 Punctuators
   12.9 Literals
      12.9.1 Null Literals
      12.9.2 Boolean Literals
      12.9.3 Numeric Literals
         12.9.3.1 SS: Early Errors
         12.9.3.2 SS: MV
         12.9.3.3 SS: NumericValue
      12.9.4 String Literals
         12.9.4.1 SS: Early Errors
         12.9.4.2 SS: SV
         12.9.4.3 SS: MV
      12.9.5 Regular Expression Literals
         12.9.5.1 SS: BodyText
         12.9.5.2 SS: FlagText
      12.9.6 Template Literal Lexical Components
         12.9.6.1 SS: TV
         12.9.6.2 SS: TRV
   12.10 Automatic Semicolon Insertion
   12.10.1 Rules of Automatic Semicolon Insertion
   12.10.2 Examples of Automatic Semicolon Insertion
   12.10.3 Interesting Cases of Automatic Semicolon Insertion
   12.10.3.1 Interesting Cases of Automatic Semicolon Insertion in Statement Lists
   12.10.3.2 Cases of Automatic Semicolon Insertion and “[no LineTerminator here]”
   12.10.3.2.1 List of Grammar Productions with Optional Operands and “[no LineTerminator here]”


The source text of an ECMAScript `Script` or `Module` is first
converted into a sequence of input elements, which are tokens, line
terminators, comments, or white space. The source text is scanned from
left to right, repeatedly taking the longest possible sequence of code
points as the next input element.

There are several situations where the identification of lexical input
elements is sensitive to the syntactic grammar context that is consuming
the input elements. This requires multiple goal symbols for the lexical
grammar. The `InputElementHashbangOrRegExp` goal is used at the start
of a `Script` or `Module`. The `InputElementRegExpOrTemplateTail`
goal is used in syntactic grammar contexts where a
`RegularExpressionLiteral`, a `TemplateMiddle`, or a
`TemplateTail` is permitted. The `InputElementRegExp` goal symbol is
used in all syntactic grammar contexts where a
`RegularExpressionLiteral` is permitted but neither a
`TemplateMiddle`, nor a `TemplateTail` is permitted. The
`InputElementTemplateTail` goal is used in all syntactic grammar
contexts where a `TemplateMiddle` or a `TemplateTail` is permitted
but a `RegularExpressionLiteral` is not permitted. In all other
contexts, `InputElementDiv` is used as the lexical goal symbol.

The use of multiple lexical goals ensures that there are no lexical
ambiguities that would affect automatic semicolon insertion. For
example, there are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
`RegularExpressionLiteral` are permitted. This is not affected by
semicolon insertion (see ); in examples such as the following:

.. code:: javascript

         a = b
         /hi/g.exec(c).map(d);
       

where the first non-whitespace, non-comment code point after a
`LineTerminator` is U+002F (SOLIDUS) and the syntactic context allows
division or division-assignment, no semicolon is inserted at the
`LineTerminator`. That is, the above example is interpreted in the
same way as:

.. code:: javascript

         a = b / hi / g.exec(c).map(d);
       


**Syntax**


InputElementDiv :: WhiteSpace LineTerminator Comment CommonToken
DivPunctuator RightBracePunctuator InputElementRegExp :: WhiteSpace
LineTerminator Comment CommonToken RightBracePunctuator
RegularExpressionLiteral InputElementRegExpOrTemplateTail :: WhiteSpace
LineTerminator Comment CommonToken RegularExpressionLiteral
TemplateSubstitutionTail InputElementTemplateTail :: WhiteSpace
LineTerminator Comment CommonToken DivPunctuator
TemplateSubstitutionTail InputElementHashbangOrRegExp :: WhiteSpace
LineTerminator Comment CommonToken HashbangComment
RegularExpressionLiteral

Unicode Format-Control Characters
---------------------------------

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK or
RIGHT-TO-LEFT MARK) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals, template literals, and
regular expression literals.

U+FEFF (ZERO WIDTH NO-BREAK SPACE) is a format-control character used
primarily at the start of a text to mark it as Unicode and to allow
detection of the text's encoding and byte order. <ZWNBSP> characters
intended for this purpose can sometimes also appear after the start of a
text, for example as a result of concatenating files. In ECMAScript
source text <ZWNBSP> code points are treated as white space characters
(see ) outside of comments, string literals, template literals, and
regular expression literals.

White Space
-----------

White space code points are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space code points may occur between any
two tokens and at the start or end of input. White space code points may
occur within a `StringLiteral`, a `RegularExpressionLiteral`, a
`Template`, or a `TemplateSubstitutionTail` where they are
considered significant code points forming part of a literal value. They
may also occur within a `Comment`, but cannot appear within any other
kind of token.

The ECMAScript white space code points are listed in .

+--------------------------+--------------------------+--------------+
| Code Points              | Name                     | Abbreviation |
+==========================+==========================+==============+
| `U+0009`                 | CHARACTER TABULATION     | <TAB>        |
+--------------------------+--------------------------+--------------+
| `U+000B`                 | LINE TABULATION          | <VT>         |
+--------------------------+--------------------------+--------------+
| `U+000C`                 | FORM FEED (FF)           | <FF>         |
+--------------------------+--------------------------+--------------+
| `U+FEFF`                 | ZERO WIDTH NO-BREAK      | <ZWNBSP>     |
|                          | SPACE                    |              |
+--------------------------+--------------------------+--------------+
| any code point in        |                          | <USP>        |
| general category         |                          |              |
| “Space_Separator”        |                          |              |
+--------------------------+--------------------------+--------------+

U+0020 (SPACE) and U+00A0 (NO-BREAK SPACE) code points are part of
<USP>.

Other than for the code points listed in , ECMAScript `WhiteSpace`
intentionally excludes all code points that have the Unicode
“White_Space” property but which are not classified in general category
“Space_Separator” (“Zs”).


**Syntax**


WhiteSpace :: <TAB> <VT> <FF> <ZWNBSP> <USP>

Line Terminators
----------------

Like white space code points, line terminator code points are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space code points,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (). A line terminator cannot occur within any token except a
`StringLiteral`, `Template`, or `TemplateSubstitutionTail`. <LF>
and <CR> line terminators cannot occur within a `StringLiteral` token
except as part of a `LineContinuation`.

A line terminator can occur within a `MultiLineComment` but cannot
occur within a `SingleLineComment`.

Line terminators are included in the set of white space code points that
are matched by the `\\\\s` class in regular expressions.

The ECMAScript line terminator code points are listed in .

========== ==================== ============
Code Point Unicode Name         Abbreviation
========== ==================== ============
`U+000A` LINE FEED (LF)       <LF>
`U+000D` CARRIAGE RETURN (CR) <CR>
`U+2028` LINE SEPARATOR       <LS>
`U+2029` PARAGRAPH SEPARATOR  <PS>
========== ==================== ============

Only the Unicode code points in are treated as line terminators. Other
new line or line breaking Unicode code points are not treated as line
terminators but are treated as white space if they meet the requirements
listed in . The sequence <CR><LF> is commonly used as a line terminator.
It should be considered a single `SourceCharacter` for the purpose of
reporting line numbers.


**Syntax**


LineTerminator :: <LF> <CR> <LS> <PS> LineTerminatorSequence :: <LF>
<CR> [lookahead != <LF>] <LS> <PS> <CR> <LF>

Comments
--------

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any Unicode code point except
a `LineTerminator` code point, and because of the general rule that a
token is always as long as possible, a single-line comment always
consists of all code points from the `//` marker to the end of the
line. However, the `LineTerminator` at the end of the line is not
considered to be part of the single-line comment; it is recognized
separately by the lexical grammar and becomes part of the stream of
input elements for the syntactic grammar. This point is very important,
because it implies that the presence or absence of single-line comments
does not affect the process of automatic semicolon insertion (see ).

Comments behave like white space and are discarded except that, if a
`MultiLineComment` contains a line terminator code point, then the
entire comment is considered to be a `LineTerminator` for purposes of
parsing by the syntactic grammar.


**Syntax**


Comment :: MultiLineComment SingleLineComment MultiLineComment ::
`/`` MultiLineCommentChars? `*/` MultiLineCommentChars ::
MultiLineNotAsteriskChar MultiLineCommentChars? `*`
PostAsteriskCommentChars? PostAsteriskCommentChars ::
MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars? `*`
PostAsteriskCommentChars? MultiLineNotAsteriskChar :: SourceCharacter
but not `*` MultiLineNotForwardSlashOrAsteriskChar :: SourceCharacter
but not one of `/` or `*` SingleLineComment :: `//`
SingleLineCommentChars? SingleLineCommentChars :: SingleLineCommentChar
SingleLineCommentChars? SingleLineCommentChar :: SourceCharacter but not
LineTerminator

A number of productions in this section are given alternative
definitions in section

Hashbang Comments
-----------------

Hashbang Comments are location-sensitive and like other types of
comments are discarded from the stream of input elements for the
syntactic grammar.


**Syntax**


HashbangComment :: `#!` SingleLineCommentChars?

Tokens
------


**Syntax**


CommonToken :: IdentifierName PrivateIdentifier Punctuator
NumericLiteral StringLiteral Template

The `DivPunctuator`, `RegularExpressionLiteral`,
`RightBracePunctuator`, and `TemplateSubstitutionTail` productions
derive additional tokens that are not included in the `CommonToken`
production.

Names and Keywords
------------------

`IdentifierName` and `ReservedWord` are tokens that are interpreted
according to the Default Identifier Syntax given in Unicode Standard
Annex #31, Identifier and Pattern Syntax, with some small modifications.
`ReservedWord` is an enumerated subset of `IdentifierName`. The
syntactic grammar defines `Identifier` as an `IdentifierName` that
is not a `ReservedWord`. The Unicode identifier grammar is based on
character properties specified by the Unicode Standard. The Unicode code
points in the specified categories in the latest version of the Unicode
Standard must be treated as in those categories by all conforming
ECMAScript implementations. ECMAScript implementations may recognize
identifier code points defined in later editions of the Unicode
Standard.

This standard specifies specific code point additions: U+0024 (DOLLAR
SIGN) and U+005F (LOW LINE) are permitted anywhere in an
`IdentifierName`.


**Syntax**


PrivateIdentifier :: `#` IdentifierName IdentifierName ::
IdentifierStart IdentifierName IdentifierPart IdentifierStart ::
IdentifierStartChar `\\` UnicodeEscapeSequence IdentifierPart ::
IdentifierPartChar `\\` UnicodeEscapeSequence IdentifierStartChar ::
UnicodeIDStart `$` `` IdentifierPartChar :: UnicodeIDContinue
`$` // emu-format ignore AsciiLetter :: one of `a` `b` `c` `d`
`e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p`
`q` `r` `s` `t` `u` `v` `w` `x` `y` `z` `A` `B`
`C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N`
`O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`
UnicodeIDStart :: > any Unicode code point with the Unicode property
“ID_Start” UnicodeIDContinue :: > any Unicode code point with the
Unicode property “ID_Continue”

The definitions of the nonterminal `UnicodeEscapeSequence` is given in
.

The nonterminal `IdentifierPart` derives `` via
\|UnicodeIDContinue\|.

The sets of code points with Unicode properties “ID_Start” and
“ID_Continue” include, respectively, the code points with Unicode
properties “Other_ID_Start” and “Other_ID_Continue”.

Identifier Names
----------------

Unicode escape sequences are permitted in an `IdentifierName`, where
they contribute a single Unicode code point equal to the
IdentifierCodePoint of the `UnicodeEscapeSequence`. The `\\\\`
preceding the `UnicodeEscapeSequence` does not contribute any code
points. A `UnicodeEscapeSequence` cannot be used to contribute a code
point to an `IdentifierName` that would otherwise be invalid. In other
words, if a `\\\\` `UnicodeEscapeSequence` sequence were replaced by
the `SourceCharacter` it contributes, the result must still be a valid
`IdentifierName` that has the exact same sequence of
`SourceCharacter` elements as the original `IdentifierName`. All
interpretations of `IdentifierName` within this specification are
based upon their actual code points regardless of whether or not an
escape sequence was used to contribute any particular code point.

Two \|IdentifierName|s that are canonically equivalent according to the
Unicode Standard are *not* equal unless, after replacement of each
`UnicodeEscapeSequence`, they are represented by the exact same
sequence of code points.

Static Semantics: Early Errors
------------------------------

IdentifierStart :: `\\` UnicodeEscapeSequence

- It is a Syntax Error if the IdentifierCodePoint of
  `UnicodeEscapeSequence` is not some Unicode code point matched by
  the `IdentifierStartChar` lexical grammar production.

IdentifierPart :: `\\` UnicodeEscapeSequence

- It is a Syntax Error if the IdentifierCodePoint of
  `UnicodeEscapeSequence` is not some Unicode code point matched by
  the `IdentifierPartChar` lexical grammar production.

Static Semantics: IdentifierCodePoints ( ): a List of code points
-----------------------------------------------------------------

IdentifierName :: IdentifierStart 1. Let cp be the
IdentifierCodePoint of `IdentifierStart`. 1. Return « cp ».
IdentifierName :: IdentifierName IdentifierPart 1. Let cps be the
IdentifierCodePoints of the derived `IdentifierName`. 1. Let cp be
the IdentifierCodePoint of `IdentifierPart`. 1. Return the
list-concatenation of cps and « cp ».

Static Semantics: IdentifierCodePoint ( ): a code point
-------------------------------------------------------

IdentifierStart :: IdentifierStartChar 1. Return the code point matched
by `IdentifierStartChar`. IdentifierPart :: IdentifierPartChar 1.
Return the code point matched by `IdentifierPartChar`.
UnicodeEscapeSequence :: `u` Hex4Digits 1. Return the code point whose
numeric value is the MV of \|Hex4Digits\|. UnicodeEscapeSequence ::
`u{` CodePoint `}` 1. Return the code point whose numeric value is
the MV of `CodePoint`.

Keywords and Reserved Words
---------------------------

A keyword is a token that matches `IdentifierName`, but also has a
syntactic use; that is, it appears literally, in a `fixed width` font,
in some syntactic production. The keywords of ECMAScript include `if`,
`while`, `async`, `await`, and many others.

A reserved word is an `IdentifierName` that cannot be used as an
identifier. Many keywords are reserved words, but some are not, and some
are reserved only in certain contexts. `if` and `while` are reserved
words. `await` is reserved only inside async functions and modules.
`async` is not reserved; it can be used as a variable name or
statement label without restriction.

This specification uses a combination of grammatical productions and
early error rules to specify which names are valid identifiers and which
are reserved words. All tokens in the `ReservedWord` list below,
except for `await` and `yield`, are unconditionally reserved.
Exceptions for `await` and `yield` are specified in , using
parameterized syntactic productions. Lastly, several early error rules
restrict the set of valid identifiers. See , , , and . In summary, there
are five categories of identifier names:

- Those that are always allowed as identifiers, and are not keywords,
  such as `Math`, `window`, `toString`, and ``;

- Those that are never allowed as identifiers, namely the
  \|ReservedWord|s listed below except `await` and `yield`;

- Those that are contextually allowed as identifiers, namely `await`
  and `yield`;

- Those that are contextually disallowed as identifiers, in strict mode
  code: `let`, `static`, `implements`, `interface`, `package`,
  `private`, `protected`, and `public`;

- Those that are always allowed as identifiers, but also appear as
  keywords within certain syntactic productions, at places where
  `Identifier` is not allowed: `as`, `async`, `from`, `get`,
  `meta`, `of`, `set`, and `target`.

The term conditional keyword, or contextual keyword, is sometimes used
to refer to the keywords that fall in the last three categories, and
thus can be used as identifiers in some contexts and as keywords in
others.


**Syntax**


// emu-format ignore ReservedWord :: one of `await` `break` `case`
`catch` `class` `const` `continue` `debugger` `default`
`delete` `do` `else` `enum` `export` `extends` `false`
`finally` `for` `function` `if` `import` `in` `instanceof`
`new` `null` `return` `super` `switch` `this` `throw`
`true` `try` `typeof` `var` `void` `while` `with`
`yield`

Per , keywords in the grammar match literal sequences of specific
`SourceCharacter` elements. A code point in a keyword cannot be
expressed by a `\\\\` `UnicodeEscapeSequence`.

An `IdentifierName` can contain `\\\\` \|UnicodeEscapeSequence|s,
but it is not possible to declare a variable named "else" by spelling it
`els\\u{65}`. The early error rules in rule out identifiers with the
same StringValue as a reserved word.

`enum` is not currently used as a keyword in this specification. It is
a *future reserved word*, set aside for use as a keyword in future
language extensions.

Similarly, `implements`, `interface`, `package`, `private`,
`protected`, and `public` are future reserved words in strict mode
code.

The names `arguments` and `eval` are not keywords, but they are
subject to some restrictions in strict mode code. See , , , , , and .

Punctuators
-----------


**Syntax**


Punctuator :: OptionalChainingPunctuator OtherPunctuator
OptionalChainingPunctuator :: `?.` [lookahead ∉ DecimalDigit] //
emu-format ignore OtherPunctuator :: one of `{` `(` `)` `[`
`]` `.` `...` `;` `,` `<` `>` `<=` `>=` `==` `!=`
`===` `!==` `+` `-` `*` `%` `**` `++` `--` `<<`
`>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `??` `?`
`:` `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=`
`&=` `|=` `^=` `&&=` `||=` `??=` `=>` DivPunctuator ::
`/` `/=` RightBracePunctuator :: `}`

Literals
--------

Null Literals
-------------


**Syntax**


NullLiteral :: `null`

Boolean Literals
----------------


**Syntax**


BooleanLiteral :: `true` `false`

Numeric Literals
----------------


**Syntax**


NumericLiteralSeparator :: `` NumericLiteral :: DecimalLiteral
DecimalBigIntegerLiteral NonDecimalIntegerLiteral[+Sep]
NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
LegacyOctalIntegerLiteral DecimalBigIntegerLiteral :: `0`
BigIntLiteralSuffix NonZeroDigit DecimalDigits[+Sep]?
BigIntLiteralSuffix NonZeroDigit NumericLiteralSeparator
DecimalDigits[+Sep] BigIntLiteralSuffix NonDecimalIntegerLiteral[Sep] ::
BinaryIntegerLiteral[?Sep] OctalIntegerLiteral[?Sep]
HexIntegerLiteral[?Sep] BigIntLiteralSuffix :: `n` DecimalLiteral ::
DecimalIntegerLiteral `.` DecimalDigits[+Sep]? ExponentPart[+Sep]?
`.` DecimalDigits[+Sep] ExponentPart[+Sep]? DecimalIntegerLiteral
ExponentPart[+Sep]? DecimalIntegerLiteral :: `0` NonZeroDigit
NonZeroDigit NumericLiteralSeparator? DecimalDigits[+Sep]
NonOctalDecimalIntegerLiteral DecimalDigits[Sep] :: DecimalDigit
DecimalDigits[?Sep] DecimalDigit [+Sep] DecimalDigits[+Sep]
NumericLiteralSeparator DecimalDigit DecimalDigit :: one of `0` `1`
`2` `3` `4` `5` `6` `7` `8` `9` NonZeroDigit :: one of
`1` `2` `3` `4` `5` `6` `7` `8` `9` ExponentPart[Sep]
:: ExponentIndicator SignedInteger[?Sep] ExponentIndicator :: one of
`e` `E` SignedInteger[Sep] :: DecimalDigits[?Sep] `+`
DecimalDigits[?Sep] `-` DecimalDigits[?Sep] BinaryIntegerLiteral[Sep]
:: `0b` BinaryDigits[?Sep] `0B` BinaryDigits[?Sep] BinaryDigits[Sep]
:: BinaryDigit BinaryDigits[?Sep] BinaryDigit [+Sep] BinaryDigits[+Sep]
NumericLiteralSeparator BinaryDigit BinaryDigit :: one of `0` `1`
OctalIntegerLiteral[Sep] :: `0o` OctalDigits[?Sep] `0O`
OctalDigits[?Sep] OctalDigits[Sep] :: OctalDigit OctalDigits[?Sep]
OctalDigit [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit
LegacyOctalIntegerLiteral :: `0` OctalDigit LegacyOctalIntegerLiteral
OctalDigit NonOctalDecimalIntegerLiteral :: `0` NonOctalDigit
LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
NonOctalDecimalIntegerLiteral DecimalDigit
LegacyOctalLikeDecimalIntegerLiteral :: `0` OctalDigit
LegacyOctalLikeDecimalIntegerLiteral OctalDigit OctalDigit :: one of
`0` `1` `2` `3` `4` `5` `6` `7` NonOctalDigit :: one of
`8` `9` HexIntegerLiteral[Sep] :: `0x` HexDigits[?Sep] `0X`
HexDigits[?Sep] HexDigits[Sep] :: HexDigit HexDigits[?Sep] HexDigit
[+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit // emu-format
ignore HexDigit :: one of `0` `1` `2` `3` `4` `5` `6`
`7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C`
`D` `E` `F`

The `SourceCharacter` immediately following a `NumericLiteral` must
not be an `IdentifierStart` or `DecimalDigit`.

For example: `3in` is an error and not the two input elements `3`
and `in`.


Static Semantics: Early Errors
------------------------------

NumericLiteral :: LegacyOctalIntegerLiteral DecimalIntegerLiteral ::
NonOctalDecimalIntegerLiteral

- It is a Syntax Error if IsStrict(this production) is `true`.

In non-strict code, this syntax is Legacy.

Static Semantics: MV
--------------------

A numeric literal stands for a value of the Number type or the BigInt
type.

- The MV of DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits
  is the MV of `DecimalIntegerLiteral` plus (the MV of
  `DecimalDigits` × 10\ :sup:`-n`), where n is the number of
  code points in `DecimalDigits`, excluding all occurrences of
  `NumericLiteralSeparator`.
- The MV of DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart
  is the MV of `DecimalIntegerLiteral` × 10\ :sup:`e`, where e
  is the MV of `ExponentPart`.
- The MV of DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits
  ExponentPart is (the MV of `DecimalIntegerLiteral` plus (the MV of
  `DecimalDigits` × 10\ :sup:`-n`)) × 10\ :sup:`e`, where
  n is the number of code points in `DecimalDigits`, excluding all
  occurrences of `NumericLiteralSeparator` and e is the MV of
  `ExponentPart`.
- The MV of DecimalLiteral :: `.` DecimalDigits is the MV of
  `DecimalDigits` × 10\ :sup:`-n`, where n is the number of
  code points in `DecimalDigits`, excluding all occurrences of
  `NumericLiteralSeparator`.
- The MV of DecimalLiteral :: `.` DecimalDigits ExponentPart is the MV
  of `DecimalDigits` × 10\ :sup:`e - n`, where n is the
  number of code points in `DecimalDigits`, excluding all occurrences
  of `NumericLiteralSeparator`, and e is the MV of
  `ExponentPart`.
- The MV of DecimalLiteral :: DecimalIntegerLiteral ExponentPart is the
  MV of `DecimalIntegerLiteral` × 10\ :sup:`e`, where e is the
  MV of `ExponentPart`.
- The MV of DecimalIntegerLiteral :: `0` is 0.
- The MV of DecimalIntegerLiteral :: NonZeroDigit
  NumericLiteralSeparator? DecimalDigits is (the MV of `NonZeroDigit`
  × 10\ :sup:`n`) plus the MV of `DecimalDigits`, where n is
  the number of code points in `DecimalDigits`, excluding all
  occurrences of `NumericLiteralSeparator`.
- The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the MV of
  `DecimalDigits` × 10) plus the MV of `DecimalDigit`.
- The MV of DecimalDigits :: DecimalDigits NumericLiteralSeparator
  DecimalDigit is (the MV of `DecimalDigits` × 10) plus the MV of
  `DecimalDigit`.
- The MV of ExponentPart :: ExponentIndicator SignedInteger is the MV of
  `SignedInteger`.
- The MV of SignedInteger :: `-` DecimalDigits is the negative of the
  MV of `DecimalDigits`.
- The MV of DecimalDigit :: `0` or of HexDigit :: `0` or of
  OctalDigit :: `0` or of LegacyOctalEscapeSequence :: `0` or of
  BinaryDigit :: `0` is 0.
- The MV of DecimalDigit :: `1` or of NonZeroDigit :: `1` or of
  HexDigit :: `1` or of OctalDigit :: `1` or of BinaryDigit :: `1`
  is 1.
- The MV of DecimalDigit :: `2` or of NonZeroDigit :: `2` or of
  HexDigit :: `2` or of OctalDigit :: `2` is 2.
- The MV of DecimalDigit :: `3` or of NonZeroDigit :: `3` or of
  HexDigit :: `3` or of OctalDigit :: `3` is 3.
- The MV of DecimalDigit :: `4` or of NonZeroDigit :: `4` or of
  HexDigit :: `4` or of OctalDigit :: `4` is 4.
- The MV of DecimalDigit :: `5` or of NonZeroDigit :: `5` or of
  HexDigit :: `5` or of OctalDigit :: `5` is 5.
- The MV of DecimalDigit :: `6` or of NonZeroDigit :: `6` or of
  HexDigit :: `6` or of OctalDigit :: `6` is 6.
- The MV of DecimalDigit :: `7` or of NonZeroDigit :: `7` or of
  HexDigit :: `7` or of OctalDigit :: `7` is 7.
- The MV of DecimalDigit :: `8` or of NonZeroDigit :: `8` or of
  NonOctalDigit :: `8` or of HexDigit :: `8` is 8.
- The MV of DecimalDigit :: `9` or of NonZeroDigit :: `9` or of
  NonOctalDigit :: `9` or of HexDigit :: `9` is 9.
- The MV of HexDigit :: `a` or of HexDigit :: `A` is 10.
- The MV of HexDigit :: `b` or of HexDigit :: `B` is 11.
- The MV of HexDigit :: `c` or of HexDigit :: `C` is 12.
- The MV of HexDigit :: `d` or of HexDigit :: `D` is 13.
- The MV of HexDigit :: `e` or of HexDigit :: `E` is 14.
- The MV of HexDigit :: `f` or of HexDigit :: `F` is 15.
- The MV of BinaryDigits :: BinaryDigits BinaryDigit is (the MV of
  `BinaryDigits` × 2) plus the MV of `BinaryDigit`.
- The MV of BinaryDigits :: BinaryDigits NumericLiteralSeparator
  BinaryDigit is (the MV of `BinaryDigits` × 2) plus the MV of
  `BinaryDigit`.
- The MV of OctalDigits :: OctalDigits OctalDigit is (the MV of
  `OctalDigits` × 8) plus the MV of `OctalDigit`.
- The MV of OctalDigits :: OctalDigits NumericLiteralSeparator
  OctalDigit is (the MV of `OctalDigits` × 8) plus the MV of
  `OctalDigit`.
- The MV of LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral
  OctalDigit is (the MV of `LegacyOctalIntegerLiteral` times 8) plus
  the MV of `OctalDigit`.
- The MV of NonOctalDecimalIntegerLiteral ::
  LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit is (the MV of
  `LegacyOctalLikeDecimalIntegerLiteral` times 10) plus the MV of
  `NonOctalDigit`.
- The MV of NonOctalDecimalIntegerLiteral ::
  NonOctalDecimalIntegerLiteral DecimalDigit is (the MV of
  `NonOctalDecimalIntegerLiteral` times 10) plus the MV of
  `DecimalDigit`.
- The MV of LegacyOctalLikeDecimalIntegerLiteral ::
  LegacyOctalLikeDecimalIntegerLiteral OctalDigit is (the MV of
  `LegacyOctalLikeDecimalIntegerLiteral` times 10) plus the MV of
  `OctalDigit`.
- The MV of HexDigits :: HexDigits HexDigit is (the MV of `HexDigits`
  × 16) plus the MV of `HexDigit`.
- The MV of HexDigits :: HexDigits NumericLiteralSeparator HexDigit is
  (the MV of `HexDigits` × 16) plus the MV of `HexDigit`.

Static Semantics: NumericValue ( ): a Number or a BigInt
--------------------------------------------------------

NumericLiteral :: DecimalLiteral 1. Return RoundMVResult(MV of
`DecimalLiteral`). NumericLiteral :: NonDecimalIntegerLiteral 1.
Return 𝔽(MV of `NonDecimalIntegerLiteral`). NumericLiteral ::
LegacyOctalIntegerLiteral 1. Return 𝔽(MV of
`LegacyOctalIntegerLiteral`). NumericLiteral ::
NonDecimalIntegerLiteral BigIntLiteralSuffix 1. Return the BigInt value
for the MV of `NonDecimalIntegerLiteral`. DecimalBigIntegerLiteral ::
`0` BigIntLiteralSuffix 1. Return `0`\ :sub:`ℤ`.
DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix 1. Return
the BigInt value for the MV of `NonZeroDigit`.
DecimalBigIntegerLiteral :: NonZeroDigit DecimalDigits
BigIntLiteralSuffix NonZeroDigit NumericLiteralSeparator DecimalDigits
BigIntLiteralSuffix 1. Let n be the number of code points in
`DecimalDigits`, excluding all occurrences of
`NumericLiteralSeparator`. 1. Let mv be (the MV of
`NonZeroDigit` × 10\ :sup:`n`) plus the MV of `DecimalDigits`.
1. Return ℤ(mv).

String Literals
---------------

A string literal is 0 or more Unicode code points enclosed in single or
double quotes. Unicode code points may also be represented by an escape
sequence. All code points may appear literally in a string literal
except for the closing quote code points, U+005C (REVERSE SOLIDUS),
U+000D (CARRIAGE RETURN), and U+000A (LINE FEED). Any code points may
appear in the form of an escape sequence. String literals evaluate to
ECMAScript String values. When generating these String values Unicode
code points are UTF-16 encoded as defined in . Code points belonging to
the Basic Multilingual Plane are encoded as a single code unit element
of the string. All other code points are encoded as two code unit
elements of the string.


**Syntax**


StringLiteral :: `"` DoubleStringCharacters? `"` `'`
SingleStringCharacters? `'` DoubleStringCharacters ::
DoubleStringCharacter DoubleStringCharacters? SingleStringCharacters ::
SingleStringCharacter SingleStringCharacters? DoubleStringCharacter ::
SourceCharacter but not one of `"` or `\\` or LineTerminator <LS>
<PS> `\\` EscapeSequence LineContinuation SingleStringCharacter ::
SourceCharacter but not one of `'` or `\\` or LineTerminator <LS>
<PS> `\\` EscapeSequence LineContinuation LineContinuation :: `\\`
LineTerminatorSequence EscapeSequence :: CharacterEscapeSequence `0`
[lookahead ∉ DecimalDigit] LegacyOctalEscapeSequence
NonOctalDecimalEscapeSequence HexEscapeSequence UnicodeEscapeSequence
CharacterEscapeSequence :: SingleEscapeCharacter NonEscapeCharacter
SingleEscapeCharacter :: one of `'` `"` `\\` `b` `f` `n`
`r` `t` `v` NonEscapeCharacter :: SourceCharacter but not one of
EscapeCharacter or LineTerminator EscapeCharacter ::
SingleEscapeCharacter DecimalDigit `x` `u` LegacyOctalEscapeSequence
:: `0` [lookahead ∈ { `8`, `9` }] NonZeroOctalDigit [lookahead ∉
OctalDigit] ZeroToThree OctalDigit [lookahead ∉ OctalDigit] FourToSeven
OctalDigit ZeroToThree OctalDigit OctalDigit NonZeroOctalDigit ::
OctalDigit but not `0` ZeroToThree :: one of `0` `1` `2` `3`
FourToSeven :: one of `4` `5` `6` `7`
NonOctalDecimalEscapeSequence :: one of `8` `9` HexEscapeSequence ::
`x` HexDigit HexDigit UnicodeEscapeSequence :: `u` Hex4Digits `u{`
CodePoint `}` Hex4Digits :: HexDigit HexDigit HexDigit HexDigit

The definition of the nonterminal `HexDigit` is given in .
`SourceCharacter` is defined in .

<LF> and <CR> cannot appear in a string literal, except as part of a
`LineContinuation` to produce the empty code points sequence. The
proper way to include either in the String value of a string literal is
to use an escape sequence such as `\\\\n` or `\\\\u000A`.


Static Semantics: Early Errors
------------------------------

EscapeSequence :: LegacyOctalEscapeSequence
NonOctalDecimalEscapeSequence

- It is a Syntax Error if IsStrict(this production) is `true`.

In non-strict code, this syntax is Legacy.

It is possible for string literals to precede a Use Strict Directive
that places the enclosing code in strict mode, and implementations must
take care to enforce the above rules for such literals. For example, the
following source text contains a Syntax Error:

.. code:: javascript

               function invalid() { "\7"; "use strict"; }
             

Static Semantics: SV ( ): a String
----------------------------------

description
   A string literal stands for a value of the String type. SV produces
   String values for string literals through recursive application on
   the various parts of the string literal. As part of this process,
   some Unicode code points within the string literal are interpreted as
   having a mathematical value, as described below or in .

- The SV of StringLiteral :: `"` `"` is the empty String.
- The SV of StringLiteral :: `'` `'` is the empty String.
- The SV of DoubleStringCharacters :: DoubleStringCharacter
  DoubleStringCharacters is the string-concatenation of the SV of
  `DoubleStringCharacter` and the SV of `DoubleStringCharacters`.
- The SV of SingleStringCharacters :: SingleStringCharacter
  SingleStringCharacters is the string-concatenation of the SV of
  `SingleStringCharacter` and the SV of `SingleStringCharacters`.
- The SV of DoubleStringCharacter :: SourceCharacter but not one of
  `"` or `\\` or LineTerminator is the result of performing
  UTF16EncodeCodePoint on the code point matched by `SourceCharacter`.
- The SV of DoubleStringCharacter :: <LS> is the String value consisting
  of the code unit 0x2028 (LINE SEPARATOR).
- The SV of DoubleStringCharacter :: <PS> is the String value consisting
  of the code unit 0x2029 (PARAGRAPH SEPARATOR).
- The SV of DoubleStringCharacter :: LineContinuation is the empty
  String.
- The SV of SingleStringCharacter :: SourceCharacter but not one of
  `'` or `\\` or LineTerminator is the result of performing
  UTF16EncodeCodePoint on the code point matched by `SourceCharacter`.
- The SV of SingleStringCharacter :: <LS> is the String value consisting
  of the code unit 0x2028 (LINE SEPARATOR).
- The SV of SingleStringCharacter :: <PS> is the String value consisting
  of the code unit 0x2029 (PARAGRAPH SEPARATOR).
- The SV of SingleStringCharacter :: LineContinuation is the empty
  String.
- The SV of EscapeSequence :: `0` is the String value consisting of
  the code unit 0x0000 (NULL).
- The SV of CharacterEscapeSequence :: SingleEscapeCharacter is the
  String value consisting of the code unit whose numeric value is
  determined by the `SingleEscapeCharacter` according to .

=============== =============== ====================== ========
Escape Sequence Code Unit Value Unicode Character Name Symbol
=============== =============== ====================== ========
`\\\\b`       `0x0008`      BACKSPACE              <BS>
`\\\\t`       `0x0009`      CHARACTER TABULATION   <HT>
`\\\\n`       `0x000A`      LINE FEED (LF)         <LF>
`\\\\v`       `0x000B`      LINE TABULATION        <VT>
`\\\\f`       `0x000C`      FORM FEED (FF)         <FF>
`\\\\r`       `0x000D`      CARRIAGE RETURN (CR)   <CR>
`\\\\"`       `0x0022`      QUOTATION MARK         `"`
`\\\\'`       `0x0027`      APOSTROPHE             `'`
`\\\\\\\\`    `0x005C`      REVERSE SOLIDUS        `\\\\`
=============== =============== ====================== ========

- The SV of NonEscapeCharacter :: SourceCharacter but not one of
  EscapeCharacter or LineTerminator is the result of performing
  UTF16EncodeCodePoint on the code point matched by `SourceCharacter`.
- The SV of EscapeSequence :: LegacyOctalEscapeSequence is the String
  value consisting of the code unit whose numeric value is the MV of
  `LegacyOctalEscapeSequence`.
- The SV of NonOctalDecimalEscapeSequence :: `8` is the String value
  consisting of the code unit 0x0038 (DIGIT EIGHT).
- The SV of NonOctalDecimalEscapeSequence :: `9` is the String value
  consisting of the code unit 0x0039 (DIGIT NINE).
- The SV of HexEscapeSequence :: `x` HexDigit HexDigit is the String
  value consisting of the code unit whose numeric value is the MV of
  `HexEscapeSequence`.
- The SV of Hex4Digits :: HexDigit HexDigit HexDigit HexDigit is the
  String value consisting of the code unit whose numeric value is the MV
  of \|Hex4Digits\|.
- The SV of UnicodeEscapeSequence :: `u{` CodePoint `}` is the
  result of performing UTF16EncodeCodePoint on the MV of `CodePoint`.
- The SV of TemplateEscapeSequence :: `0` is the String value
  consisting of the code unit 0x0000 (NULL).


Static Semantics: MV
--------------------

- The MV of LegacyOctalEscapeSequence :: ZeroToThree OctalDigit is (8
  times the MV of `ZeroToThree`) plus the MV of `OctalDigit`.
- The MV of LegacyOctalEscapeSequence :: FourToSeven OctalDigit is (8
  times the MV of `FourToSeven`) plus the MV of `OctalDigit`.
- The MV of LegacyOctalEscapeSequence :: ZeroToThree OctalDigit
  OctalDigit is (64 (that is, 8\ :sup:`2`) times the MV of
  `ZeroToThree`) plus (8 times the MV of the first `OctalDigit`)
  plus the MV of the second `OctalDigit`.
- The MV of ZeroToThree :: `0` is 0.
- The MV of ZeroToThree :: `1` is 1.
- The MV of ZeroToThree :: `2` is 2.
- The MV of ZeroToThree :: `3` is 3.
- The MV of FourToSeven :: `4` is 4.
- The MV of FourToSeven :: `5` is 5.
- The MV of FourToSeven :: `6` is 6.
- The MV of FourToSeven :: `7` is 7.
- The MV of HexEscapeSequence :: `x` HexDigit HexDigit is (16 times
  the MV of the first `HexDigit`) plus the MV of the second
  `HexDigit`.
- The MV of Hex4Digits :: HexDigit HexDigit HexDigit HexDigit is (0x1000
  × the MV of the first `HexDigit`) plus (0x100 × the MV of the second
  `HexDigit`) plus (0x10 × the MV of the third `HexDigit`) plus the
  MV of the fourth `HexDigit`.

Regular Expression Literals
---------------------------

A regular expression literal is an input element that is converted to a
RegExp object (see ) each time the literal is evaluated. Two regular
expression literals in a program evaluate to regular expression objects
that never compare as `===` to each other even if the two literals'
contents are identical. A RegExp object may also be created at runtime
by `new RegExp` or calling the RegExp constructor as a function (see
).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The source text comprising the
`RegularExpressionBody` and the `RegularExpressionFlags` are
subsequently parsed again using the more stringent ECMAScript Regular
Expression grammar ().

An implementation may extend the ECMAScript Regular Expression grammar
defined in , but it must not extend the `RegularExpressionBody` and
`RegularExpressionFlags` productions defined below or the productions
used by these productions.


**Syntax**


RegularExpressionLiteral :: `/` RegularExpressionBody `/`
RegularExpressionFlags RegularExpressionBody ::
RegularExpressionFirstChar RegularExpressionChars RegularExpressionChars
:: [empty] RegularExpressionChars RegularExpressionChar
RegularExpressionFirstChar :: RegularExpressionNonTerminator but not one
of `*` or `\\` or `/` or `[` RegularExpressionBackslashSequence
RegularExpressionClass RegularExpressionChar ::
RegularExpressionNonTerminator but not one of `\\` or `/` or `[`
RegularExpressionBackslashSequence RegularExpressionClass
RegularExpressionBackslashSequence :: `\\`
RegularExpressionNonTerminator RegularExpressionNonTerminator ::
SourceCharacter but not LineTerminator RegularExpressionClass :: `[`
RegularExpressionClassChars `]` RegularExpressionClassChars :: [empty]
RegularExpressionClassChars RegularExpressionClassChar
RegularExpressionClassChar :: RegularExpressionNonTerminator but not one
of `]` or `\\` RegularExpressionBackslashSequence
RegularExpressionFlags :: [empty] RegularExpressionFlags
IdentifierPartChar

Regular expression literals may not be empty; instead of representing an
empty regular expression literal, the code unit sequence `//` starts a
single-line comment. To specify an empty regular expression, use:
`/(?:)/`.

Static Semantics: BodyText ( ): source text
-------------------------------------------

RegularExpressionLiteral :: `/` RegularExpressionBody `/`
RegularExpressionFlags 1. Return the source text that was recognized as
`RegularExpressionBody`.

Static Semantics: FlagText ( ): source text
-------------------------------------------

RegularExpressionLiteral :: `/` RegularExpressionBody `/`
RegularExpressionFlags 1. Return the source text that was recognized as
`RegularExpressionFlags`.

Template Literal Lexical Components
-----------------------------------


**Syntax**


Template :: NoSubstitutionTemplate TemplateHead NoSubstitutionTemplate
:: ``` TemplateCharacters? ``` TemplateHead :: ```
TemplateCharacters? `${` TemplateSubstitutionTail :: TemplateMiddle
TemplateTail TemplateMiddle :: `}` TemplateCharacters? `${`
TemplateTail :: `}` TemplateCharacters? ``` TemplateCharacters ::
TemplateCharacter TemplateCharacters? TemplateCharacter :: `$`
[lookahead != `{`] `\\` TemplateEscapeSequence `\\`
NotEscapeSequence LineContinuation LineTerminatorSequence
SourceCharacter but not one of ``` or `\\` or `$` or
LineTerminator TemplateEscapeSequence :: CharacterEscapeSequence `0`
[lookahead ∉ DecimalDigit] HexEscapeSequence UnicodeEscapeSequence
NotEscapeSequence :: `0` DecimalDigit DecimalDigit but not `0` `x`
[lookahead ∉ HexDigit] `x` HexDigit [lookahead ∉ HexDigit] `u`
[lookahead ∉ HexDigit] [lookahead != `{`] `u` HexDigit [lookahead ∉
HexDigit] `u` HexDigit HexDigit [lookahead ∉ HexDigit] `u` HexDigit
HexDigit HexDigit [lookahead ∉ HexDigit] `u` `{` [lookahead ∉
HexDigit] `u` `{` NotCodePoint [lookahead ∉ HexDigit] `u` `{`
CodePoint [lookahead ∉ HexDigit] [lookahead != `}`] NotCodePoint ::
HexDigits[~Sep] [> but only if the MV of `HexDigits` > 0x10FFFF]
CodePoint :: HexDigits[~Sep] [> but only if the MV of `HexDigits` ≤
0x10FFFF]

`TemplateSubstitutionTail` is used by the `InputElementTemplateTail`
alternative lexical goal.

Static Semantics: TV ( ): a String or `undefined`
---------------------------------------------------

description
   A template literal component is interpreted by TV as a value of the
   String type. TV is used to construct the indexed components of a
   template object (colloquially, the template values). In TV, escape
   sequences are replaced by the UTF-16 code unit(s) of the Unicode code
   point represented by the escape sequence.

- The TV of NoSubstitutionTemplate :: ``` ``` is the empty String.
- The TV of TemplateHead :: ``` `${` is the empty String.
- The TV of TemplateMiddle :: `}` `${` is the empty String.
- The TV of TemplateTail :: `}` ``` is the empty String.
- The TV of TemplateCharacters :: TemplateCharacter TemplateCharacters
  is `undefined` if the TV of `TemplateCharacter` is `undefined`
  or the TV of `TemplateCharacters` is `undefined`. Otherwise, it is
  the string-concatenation of the TV of `TemplateCharacter` and the TV
  of `TemplateCharacters`.
- The TV of TemplateCharacter :: SourceCharacter but not one of ``` or
  `\\` or `$` or LineTerminator is the result of performing
  UTF16EncodeCodePoint on the code point matched by `SourceCharacter`.
- The TV of TemplateCharacter :: `$` is the String value consisting of
  the code unit 0x0024 (DOLLAR SIGN).
- The TV of TemplateCharacter :: `\\` TemplateEscapeSequence is the SV
  of `TemplateEscapeSequence`.
- The TV of TemplateCharacter :: `\\` NotEscapeSequence is
  `undefined`.
- The TV of TemplateCharacter :: LineTerminatorSequence is the TRV of
  `LineTerminatorSequence`.
- The TV of LineContinuation :: `\\` LineTerminatorSequence is the
  empty String.

Static Semantics: TRV ( ): a String
-----------------------------------

description
   A template literal component is interpreted by TRV as a value of the
   String type. TRV is used to construct the raw components of a
   template object (colloquially, the template raw values). TRV is
   similar to TV with the difference being that in TRV, escape sequences
   are interpreted as they appear in the literal.

- The TRV of NoSubstitutionTemplate :: ``` ``` is the empty String.
- The TRV of TemplateHead :: ``` `${` is the empty String.
- The TRV of TemplateMiddle :: `}` `${` is the empty String.
- The TRV of TemplateTail :: `}` ``` is the empty String.
- The TRV of TemplateCharacters :: TemplateCharacter TemplateCharacters
  is the string-concatenation of the TRV of `TemplateCharacter` and
  the TRV of `TemplateCharacters`.
- The TRV of TemplateCharacter :: SourceCharacter but not one of ```
  or `\\` or `$` or LineTerminator is the result of performing
  UTF16EncodeCodePoint on the code point matched by `SourceCharacter`.
- The TRV of TemplateCharacter :: `$` is the String value consisting
  of the code unit 0x0024 (DOLLAR SIGN).
- The TRV of TemplateCharacter :: `\\` TemplateEscapeSequence is the
  string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the
  TRV of `TemplateEscapeSequence`.
- The TRV of TemplateCharacter :: `\\` NotEscapeSequence is the
  string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the
  TRV of `NotEscapeSequence`.
- The TRV of TemplateEscapeSequence :: `0` is the String value
  consisting of the code unit 0x0030 (DIGIT ZERO).
- The TRV of NotEscapeSequence :: `0` DecimalDigit is the
  string-concatenation of the code unit 0x0030 (DIGIT ZERO) and the TRV
  of `DecimalDigit`.
- The TRV of NotEscapeSequence :: `x` [lookahead ∉ HexDigit] is the
  String value consisting of the code unit 0x0078 (LATIN SMALL LETTER
  X).
- The TRV of NotEscapeSequence :: `x` HexDigit [lookahead ∉ HexDigit]
  is the string-concatenation of the code unit 0x0078 (LATIN SMALL
  LETTER X) and the TRV of `HexDigit`.
- The TRV of NotEscapeSequence :: `u` [lookahead ∉ HexDigit]
  [lookahead != `{`] is the String value consisting of the code unit
  0x0075 (LATIN SMALL LETTER U).
- The TRV of NotEscapeSequence :: `u` HexDigit [lookahead ∉ HexDigit]
  is the string-concatenation of the code unit 0x0075 (LATIN SMALL
  LETTER U) and the TRV of `HexDigit`.
- The TRV of NotEscapeSequence :: `u` HexDigit HexDigit [lookahead ∉
  HexDigit] is the string-concatenation of the code unit 0x0075 (LATIN
  SMALL LETTER U), the TRV of the first `HexDigit`, and the TRV of the
  second `HexDigit`.
- The TRV of NotEscapeSequence :: `u` HexDigit HexDigit HexDigit
  [lookahead ∉ HexDigit] is the string-concatenation of the code unit
  0x0075 (LATIN SMALL LETTER U), the TRV of the first `HexDigit`, the
  TRV of the second `HexDigit`, and the TRV of the third `HexDigit`.
- The TRV of NotEscapeSequence :: `u` `{` [lookahead ∉ HexDigit] is
  the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER
  U) and the code unit 0x007B (LEFT CURLY BRACKET).
- The TRV of NotEscapeSequence :: `u` `{` NotCodePoint [lookahead ∉
  HexDigit] is the string-concatenation of the code unit 0x0075 (LATIN
  SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the
  TRV of `NotCodePoint`.
- The TRV of NotEscapeSequence :: `u` `{` CodePoint [lookahead ∉
  HexDigit] [lookahead != `}`] is the string-concatenation of the code
  unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY
  BRACKET), and the TRV of `CodePoint`.
- The TRV of DecimalDigit :: one of `0` `1` `2` `3` `4` `5`
  `6` `7` `8` `9` is the result of performing
  UTF16EncodeCodePoint on the single code point matched by this
  production.
- The TRV of CharacterEscapeSequence :: NonEscapeCharacter is the SV of
  `NonEscapeCharacter`.
- The TRV of SingleEscapeCharacter :: one of `'` `"` `\\` `b`
  `f` `n` `r` `t` `v` is the result of performing
  UTF16EncodeCodePoint on the single code point matched by this
  production.
- The TRV of HexEscapeSequence :: `x` HexDigit HexDigit is the
  string-concatenation of the code unit 0x0078 (LATIN SMALL LETTER X),
  the TRV of the first `HexDigit`, and the TRV of the second
  `HexDigit`.
- The TRV of UnicodeEscapeSequence :: `u` Hex4Digits is the
  string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U)
  and the TRV of \|Hex4Digits\|.
- The TRV of UnicodeEscapeSequence :: `u{` CodePoint `}` is the
  string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U),
  the code unit 0x007B (LEFT CURLY BRACKET), the TRV of `CodePoint`,
  and the code unit 0x007D (RIGHT CURLY BRACKET).
- The TRV of Hex4Digits :: HexDigit HexDigit HexDigit HexDigit is the
  string-concatenation of the TRV of the first `HexDigit`, the TRV of
  the second `HexDigit`, the TRV of the third `HexDigit`, and the
  TRV of the fourth `HexDigit`.
- The TRV of HexDigits :: HexDigits HexDigit is the string-concatenation
  of the TRV of `HexDigits` and the TRV of `HexDigit`.
- The TRV of HexDigit :: one of `0` `1` `2` `3` `4` `5`
  `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A`
  `B` `C` `D` `E` `F` is the result of performing
  UTF16EncodeCodePoint on the single code point matched by this
  production.
- The TRV of LineContinuation :: `\\` LineTerminatorSequence is the
  string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the
  TRV of `LineTerminatorSequence`.
- The TRV of LineTerminatorSequence :: <LF> is the String value
  consisting of the code unit 0x000A (LINE FEED).
- The TRV of LineTerminatorSequence :: <CR> is the String value
  consisting of the code unit 0x000A (LINE FEED).
- The TRV of LineTerminatorSequence :: <LS> is the String value
  consisting of the code unit 0x2028 (LINE SEPARATOR).
- The TRV of LineTerminatorSequence :: <PS> is the String value
  consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
- The TRV of LineTerminatorSequence :: <CR> <LF> is the String value
  consisting of the code unit 0x000A (LINE FEED).

TV excludes the code units of `LineContinuation` while TRV includes
them. <CR><LF> and <CR> \|LineTerminatorSequence|s are normalized to
<LF> for both TV and TRV. An explicit `TemplateEscapeSequence` is
needed to include a <CR> or <CR><LF> sequence.

Automatic Semicolon Insertion
-----------------------------

Most ECMAScript statements and declarations must be terminated with a
semicolon. Such semicolons may always appear explicitly in the source
text. For convenience, however, such semicolons may be omitted from the
source text in certain situations. These situations are described by
saying that semicolons are automatically inserted into the source code
token stream in those situations.

Rules of Automatic Semicolon Insertion
--------------------------------------

In the following rules, “token” means the actual recognized lexical
token determined using the current lexical goal symbol as described in
clause .

There are three basic rules of semicolon insertion:

#. When, as the source text is parsed from left to right, a token
   (called the *offending token*) is encountered that is not allowed by
   any production of the grammar, then a semicolon is automatically
   inserted before the offending token if one or more of the following
   conditions is true:

   - The offending token is separated from the previous token by at
     least one `LineTerminator`.
   - The offending token is `}`.
   - The previous token is `)` and the inserted semicolon would then
     be parsed as the terminating semicolon of a do-while statement ().

#. When, as the source text is parsed from left to right, the end of the
   input stream of tokens is encountered and the parser is unable to
   parse the input token stream as a single instance of the goal
   nonterminal, then a semicolon is automatically inserted at the end of
   the input stream.

#. When, as the source text is parsed from left to right, a token is
   encountered that is allowed by some production of the grammar, but
   the production is a *restricted production* and the token would be
   the first token for a terminal or nonterminal immediately following
   the annotation “[no `LineTerminator` here]” within the restricted
   production (and therefore such a token is called a restricted token),
   and the restricted token is separated from the previous token by at
   least one `LineTerminator`, then a semicolon is automatically
   inserted before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a `for` statement
(see ).

The following are the only restricted productions in the grammar:

UpdateExpression[Yield, Await] : LeftHandSideExpression[?Yield, ?Await]
[no LineTerminator here] `++` LeftHandSideExpression[?Yield, ?Await]
[no LineTerminator here] `--` ContinueStatement[Yield, Await] :
`continue` `;` `continue` [no LineTerminator here]
LabelIdentifier[?Yield, ?Await] `;` BreakStatement[Yield, Await] :
`break` `;` `break` [no LineTerminator here]
LabelIdentifier[?Yield, ?Await] `;` ReturnStatement[Yield, Await] :
`return` `;` `return` [no LineTerminator here] Expression[+In,
?Yield, ?Await] `;` ThrowStatement[Yield, Await] : `throw` [no
LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
YieldExpression[In, Await] : `yield` `yield` [no LineTerminator
here] AssignmentExpression[?In, +Yield, ?Await] `yield` [no
LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
ArrowFunction[In, Yield, Await] : ArrowParameters[?Yield, ?Await] [no
LineTerminator here] `=>` ConciseBody[?In]
AsyncFunctionDeclaration[Yield, Await, Default] : `async` [no
LineTerminator here] `function` BindingIdentifier[?Yield, ?Await]
`(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody
`}` [+Default] `async` [no LineTerminator here] `function` `(`
FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
AsyncFunctionExpression : `async` [no LineTerminator here]
`function` BindingIdentifier[~Yield, +Await]? `(`
FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
AsyncMethod[Yield, Await] : `async` [no LineTerminator here]
ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield,
+Await] `)` `{` AsyncFunctionBody `}`
AsyncGeneratorDeclaration[Yield, Await, Default] : `async` [no
LineTerminator here] `function` `*` BindingIdentifier[?Yield,
?Await] `(` FormalParameters[+Yield, +Await] `)` `{`
AsyncGeneratorBody `}` [+Default] `async` [no LineTerminator here]
`function` `*` `(` FormalParameters[+Yield, +Await] `)` `{`
AsyncGeneratorBody `}` AsyncGeneratorExpression : `async` [no
LineTerminator here] `function` `*` BindingIdentifier[+Yield,
+Await]? `(` FormalParameters[+Yield, +Await] `)` `{`
AsyncGeneratorBody `}` AsyncGeneratorMethod[Yield, Await] : `async`
[no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(`
UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody
`}` AsyncArrowFunction[In, Yield, Await] : `async` [no
LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no
LineTerminator here] `=>` AsyncConciseBody[?In]
CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator
here] `=>` AsyncConciseBody[?In] #callcover AsyncArrowHead : `async`
[no LineTerminator here] ArrowFormalParameters[~Yield, +Await]

The practical effect of these restricted productions is as follows:

- When a `++` or `--` token is encountered where the parser would
  treat it as a postfix operator, and at least one `LineTerminator`
  occurred between the preceding token and the `++` or `--` token,
  then a semicolon is automatically inserted before the `++` or `--`
  token.
- When a `continue`, `break`, `return`, `throw`, or `yield`
  token is encountered and a `LineTerminator` is encountered before
  the next token, a semicolon is automatically inserted after the
  `continue`, `break`, `return`, `throw`, or `yield` token.
- When arrow function parameter(s) are followed by a `LineTerminator`
  before a `=>` token, a semicolon is automatically inserted and the
  punctuator causes a syntax error.
- When an `async` token is followed by a `LineTerminator` before a
  `function` or `IdentifierName` or `(` token, a semicolon is
  automatically inserted and the `async` token is not treated as part
  of the same expression or class element as the following tokens.
- When an `async` token is followed by a `LineTerminator` before a
  `*` token, a semicolon is automatically inserted and the punctuator
  causes a syntax error.

The resulting practical advice to ECMAScript programmers is:

- A postfix `++` or `--` operator should be on the same line as its
  operand.
- An `Expression` in a `return` or `throw` statement or an
  `AssignmentExpression` in a `yield` expression should start on the
  same line as the `return`, `throw`, or `yield` token.
- A `LabelIdentifier` in a `break` or `continue` statement should
  be on the same line as the `break` or `continue` token.
- The end of an arrow function's parameter(s) and its `=>` should be
  on the same line.
- The `async` token preceding an asynchronous function or method
  should be on the same line as the immediately following token.

Examples of Automatic Semicolon Insertion
-----------------------------------------

*This section is non-normative.*

The source

.. code:: javascript

   { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

.. code:: javascript

           { 1
           2 } 3
         

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

.. code:: javascript

           { 1
           ;2 ;} 3;
         

which is a valid ECMAScript sentence.

The source

.. code:: javascript

           for (a; b
           )
         

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
`for` statement. Automatic semicolon insertion never inserts one of
the two semicolons in the header of a `for` statement.

The source

.. code:: javascript

           return
           a + b
         

is transformed by automatic semicolon insertion into the following:

.. code:: javascript

           return;
           a + b;
         

The expression `a + b` is not treated as a value to be returned by the
`return` statement, because a `LineTerminator` separates it from the
token `return`.

The source

.. code:: javascript

           a = b
           ++c
         

is transformed by automatic semicolon insertion into the following:

.. code:: javascript

           a = b;
           ++c;
         

The token `++` is not treated as a postfix operator applying to the
variable `b`, because a `LineTerminator` occurs between `b` and
`++`.

The source

.. code:: javascript

           if (a > b)
           else c = d
         

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the `else` token, even though no production
of the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

.. code:: javascript

           a = b + c
           (d + e).print()
         

is *not* transformed by automatic semicolon insertion, because the
parenthesized expression that begins the second line can be interpreted
as an argument list for a function call:

.. code:: javascript

   a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.

Interesting Cases of Automatic Semicolon Insertion
--------------------------------------------------

*This section is non-normative.*

ECMAScript programs can be written in a style with very few semicolons
by relying on automatic semicolon insertion. As described above,
semicolons are not inserted at every newline, and automatic semicolon
insertion can depend on multiple tokens across line terminators.

As new syntactic features are added to ECMAScript, additional grammar
productions could be added that cause lines relying on automatic
semicolon insertion preceding them to change grammar productions when
parsed.

For the purposes of this section, a case of automatic semicolon
insertion is considered interesting if it is a place where a semicolon
may or may not be inserted, depending on the source text which precedes
it. The rest of this section describes a number of interesting cases of
automatic semicolon insertion in this version of ECMAScript.

Interesting Cases of Automatic Semicolon Insertion in Statement Lists
---------------------------------------------------------------------

In a `StatementList`, many \|StatementListItem|s end in semicolons,
which may be omitted using automatic semicolon insertion. As a
consequence of the rules above, at the end of a line ending an
expression, a semicolon is required if the following line begins with
any of the following:

- **An opening parenthesis (``(``)**. Without a semicolon, the two lines
  together are treated as a `CallExpression`.
- **An opening square bracket (``[``)**. Without a semicolon, the two
  lines together are treated as property access, rather than an
  `ArrayLiteral` or `ArrayAssignmentPattern`.
- **A template literal (:literal:```)**. Without a semicolon, the two
  lines together are interpreted as a tagged Template (), with the
  previous expression as the `MemberExpression`.
- **Unary ``+`` or ``-``**. Without a semicolon, the two lines together
  are interpreted as a usage of the corresponding binary operator.
- **A RegExp literal**. Without a semicolon, the two lines together may
  be parsed instead as the `/` `MultiplicativeOperator`, for example
  if the RegExp has flags.

Cases of Automatic Semicolon Insertion and “[no `LineTerminator` here]”
-------------------------------------------------------------------------

*This section is non-normative.*

ECMAScript contains grammar productions which include “[no
`LineTerminator` here]”. These productions are sometimes a means to
have optional operands in the grammar. Introducing a `LineTerminator`
in these locations would change the grammar production of a source text
by using the grammar production without the optional operand.

The rest of this section describes a number of productions using “[no
`LineTerminator` here]” in this version of ECMAScript.

List of Grammar Productions with Optional Operands and “[no `LineTerminator` here]”
-------------------------------------------------------------------------------------

- `UpdateExpression`.
- `ContinueStatement`.
- `BreakStatement`.
- `ReturnStatement`.
- `YieldExpression`.
- Async Function Definitions () with relation to Function Definitions ()

13. ECMAScript Language: Expressions
====================================

https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html
::

   13.1 Identifiers
      13.1.1 SS: Early Errors
      13.1.2 SS: StringValue
      13.1.3 RS: Evaluation
   13.2 Primary Expression
      13.2.1 The this Keyword
         13.2.1.1 RS: Evaluation
      13.2.2 Identifier Reference
      13.2.3 Literals
         13.2.3.1 RS: Evaluation
      13.2.4 Array Initializer
         13.2.4.1 RS: ArrayAccumulation
         13.2.4.2 RS: Evaluation
      13.2.5 Object Initializer
         13.2.5.1 SS: Early Errors
         13.2.5.2 SS: IsComputedPropertyKey
         13.2.5.3 SS: PropertyNameList
         13.2.5.4 RS: Evaluation
         13.2.5.5 RS: PropertyDefinitionEvaluation
      13.2.6 Function Defining Expressions
      13.2.7 Regular Expression Literals
         13.2.7.1 SS: Early Errors
         13.2.7.2 SS: IsValidRegularExpressionLiteral ( literal )
         13.2.7.3 RS: Evaluation
      13.2.8 Template Literals
         13.2.8.1 SS: Early Errors
         13.2.8.2 SS: TemplateStrings
         13.2.8.3 SS: TemplateString ( templateToken, raw )
         13.2.8.4 GetTemplateObject ( templateLiteral )
         13.2.8.5 RS: SubstitutionEvaluation
         13.2.8.6 RS: Evaluation
      13.2.9 The Grouping Operator
         13.2.9.1 SS: Early Errors
         13.2.9.2 RS: Evaluation
   13.3 Left-Hand-Side Expressions
      13.3.1 13.3.1 Static Semantics
         13.3.1.1 SS: Early Errors
      13.3.2 Property Accessors
      13.3.3 EvaluatePropertyAccessWithExpressionKey ( baseValue, expression, strict )
      13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )
      13.3.5 The new Operator
         13.3.5.1 RS: Evaluation
         13.3.5.1.1 EvaluateNew ( constructExpr, arguments )
      13.3.6 Function Calls
         13.3.6.1 RS: Evaluation
         13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )
      13.3.7 The super Keyword
         13.3.7.1 RS: Evaluation
         13.3.7.2 GetSuperConstructor ( )
         13.3.7.3 MakeSuperPropertyReference ( actualThis, propertyKey, strict )
      13.3.8 Argument Lists
         13.3.8.1 RS: ArgumentListEvaluation
      13.3.9 Optional Chains
         13.3.9.1 RS: Evaluation
         13.3.9.2 RS: ChainEvaluation
      13.3.10 Import Calls
         13.3.10.1 RS: Evaluation
            13.3.10.1.1 ContinueDynamicImport ( promiseCapability, moduleCompletion )
      13.3.11 Tagged Templates
      13.3.11.1 RS: Evaluation
      13.3.12 Meta Properties
         13.3.12.1 RS: Evaluation
            13.3.12.1.1 HostGetImportMetaProperties ( moduleRecord )
            13.3.12.1.2 HostFinalizeImportMeta ( importMeta, moduleRecord )
   13.4 Update Expressions
      13.4.1 13.4.1 SS: Early Errors
      13.4.2 Postfix Increment Operator
         13.4.2.1 RS: Evaluation
      13.4.3 Postfix Decrement Operator
         13.4.3.1 RS: Evaluation
      13.4.4 Prefix Increment Operator
         13.4.4.1 RS: Evaluation
      13.4.5 Prefix Decrement Operator
         13.4.5.1 RS: Evaluation
   13.5 Unary Operators
      13.5.1 The delete Operator
         13.5.1.1 SS: Early Errors
         13.5.1.2 RS: Evaluation
      13.5.2 The void Operator
         13.5.2.1 RS: Evaluation
      13.5.3 The typeof Operator
         13.5.3.1 RS: Evaluation
      13.5.4 Unary + Operator
         13.5.4.1 RS: Evaluation
      13.5.5 Unary - Operator
         13.5.5.1 RS: Evaluation
      13.5.6 Bitwise NOT Operator ( ~ )
         13.5.6.1 RS: Evaluation
      13.5.7 Logical NOT Operator ( ! )
         13.5.7.1 RS: Evaluation
   13.6 Exponentiation Operator
      13.6.1 RS: Evaluation
   13.7 Multiplicative Operators
      13.7.1 RS: Evaluation
   13.8 Additive Operators
      13.8.1 The Addition Operator ( + )
         13.8.1.1 RS: Evaluation
      13.8.2 The Subtraction Operator ( - )
         13.8.2.1 RS: Evaluation
   13.9 Bitwise Shift Operators
      13.9.1 The Left Shift Operator ( << )
      13.9.1.1 RS: Evaluation
      13.9.2 The Signed Right Shift Operator ( >> )
         13.9.2.1 RS: Evaluation
      13.9.3 The Unsigned Right Shift Operator ( >>> )
         13.9.3.1 RS: Evaluation
   13.10 Relational Operators
      13.10.1 RS: Evaluation
      13.10.2 InstanceofOperator ( V, target )
   13.11 Equality Operators
      13.11.1 RS: Evaluation
   13.12 Binary Bitwise Operators
      13.12.1 RS: Evaluation
   13.13 Binary Logical Operators
      13.13.1 RS: Evaluation
   13.14 13.14 Conditional Operator ( ? : )
      13.--14.1 RS: Evaluation
   13.15 Assignment Operators
      13.15.1 SS: Early Errors
      13.15.2 RS: Evaluation
      13.15.3 ApplyStringOrNumericBinaryOperator ( lVal, opText, rVal )
      13.15.4 EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand )
      13.15.5 Destructuring Assignment
   13.16 Comma Operator ( , )
      13.16.1 RS: Evaluation

13.1 Identifiers
----------------


**Syntax**

   IdentifierReference[Yield, Await] :
      | Identifier
      | [~Yield] yield
      | [~Await] await

   BindingIdentifier[Yield, Await] :
      | Identifier
      | yield
      | await

   LabelIdentifier[Yield, Await] :
      | Identifier
      | [~Yield] yield
      | [~Await] await

   Identifier :
      | IdentifierName but not ReservedWord

.. Note::

   `yield` and `await` are permitted as `BindingIdentifier` in the
   grammar, and prohibited with static semantics below, to prohibit
   automatic semicolon insertion in cases such as

.. code:: javascript

           let
           await 0;



13.1.1 Static Semantics: Early Errors
'''''''''''''''''''''''''''''''''''''

BindingIdentifier : Identifier

- It is a Syntax Error if IsStrict(this production) is `true` and the
  StringValue of `Identifier` is either `"arguments"` or `"eval"`.

| IdentifierReference : `yield` 
| BindingIdentifier : `yield`
| LabelIdentifier : `yield`

- It is a Syntax Error if IsStrict(this production) is `true`.

| IdentifierReference : `await` 
| BindingIdentifier : `await`
| LabelIdentifier : `await`

- It is a Syntax Error if the goal symbol of the syntactic grammar is `Module`.

BindingIdentifier[Yield, Await] : `yield`

- It is a Syntax Error if this production has a :sub:`[Yield]` parameter.

BindingIdentifier[Yield, Await] : `await`

- It is a Syntax Error if this production has an :sub:`[Await]` parameter.

| IdentifierReference[Yield, Await] : Identifier 
| BindingIdentifier[Yield, Await] : Identifier 
| LabelIdentifier[Yield, Await] : Identifier

- It is a Syntax Error if this production has a :sub:`[Yield]` parameter
  and the StringValue of `Identifier` is `"yield"`.
- It is a Syntax Error if this production has an :sub:`[Await]`
  parameter and the StringValue of `Identifier` is `"await"`.

Identifier : IdentifierName but not ReservedWord

- It is a Syntax Error if IsStrict(this phrase) is `true` and the
  StringValue of `IdentifierName` is one of `"implements"`,
  `"interface"`, `"let"`, `"package"`, `"private"`,
  `"protected"`, `"public"`, `"static"`, or `"yield"`.
- It is a Syntax Error if the goal symbol of the syntactic grammar is
  `Module` and the StringValue of `IdentifierName` is `"await"`.
- It is a Syntax Error if the StringValue of `IdentifierName` is the
  StringValue of any `ReservedWord` except for `yield` or `await`.

.. Note::

   The StringValue of `IdentifierName` normalizes any Unicode escape
   sequences in `IdentifierName` hence such escapes cannot be used to
   write an `Identifier` whose code point sequence is the same as a
   `ReservedWord`.

13.1.2 Static Semantics: StringValue ( ): a String
''''''''''''''''''''''''''''''''''''''''''''''''''

The syntax-directed operation StringValue takes no arguments and returns a String. 
It is defined piecewise over the following productions:

IdentifierName :: 
   IdentifierStart 
   IdentifierName IdentifierPart 

1. Let idTextUnescaped be the IdentifierCodePoints of `IdentifierName`.
1. Return CodePointsToString(idTextUnescaped). 

| IdentifierReference : `yield` 
| BindingIdentifier : `yield` 
| LabelIdentifier : `yield` 

1. Return `"yield"`. 

| IdentifierReference : `await` 
| BindingIdentifier : `await` 
| LabelIdentifier : `await` 

1. Return `"await"`. 

Identifier : IdentifierName but not ReservedWord 

1. Return the StringValue of `IdentifierName`. 

PrivateIdentifier :: `#` IdentifierName 

1. Return the string-concatenation of 0x0023 (NUMBER SIGN) and the StringValue of
`IdentifierName`. 

ModuleExportName : StringLiteral 

1. Return the SV of `StringLiteral`.

13.1.3 Runtime Semantics: Evaluation
''''''''''''''''''''''''''''''''''''

IdentifierReference : Identifier 

1. Return ? ResolveBinding(StringValue of `Identifier`). 

IdentifierReference : `yield` 

1. Return ? ResolveBinding(`"yield"`). 

IdentifierReference : `await` 

1. Return ? ResolveBinding(`"await"`).

.. Note::

   The result of evaluating an `IdentifierReference` is always a value of
   type Reference.

.. Note::

   In non-strict code, the keyword `yield` may be used as an identifier.
   Evaluating the `IdentifierReference` resolves the binding of `yield`
   as if it was an `Identifier`. Early Error restriction ensures that
   such an evaluation only can occur for non-strict code.


13.2 Primary Expression
-----------------------


**Syntax**

   PrimaryExpression[Yield, Await] :
      | this
      | IdentifierReference[?Yield, ?Await]
      | Literal
      | ArrayLiteral[?Yield, ?Await]
      | ObjectLiteral[?Yield, ?Await]
      | FunctionExpression
      | ClassExpression[?Yield, ?Await]
      | GeneratorExpression
      | AsyncFunctionExpression
      | AsyncGeneratorExpression
      | RegularExpressionLiteral
      | TemplateLiteral[?Yield, ?Await, ~Tagged]
      | CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

   CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
      | ( Expression[+In, ?Yield, ?Await] )
      | ( Expression[+In, ?Yield, ?Await] , )
      | ( )
      | ( ... BindingIdentifier[?Yield, ?Await] )
      | ( ... BindingPattern[?Yield, ?Await] )
      | ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] )
      | ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] )

**Supplemental Syntax**

   When processing an instance of the production

   PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

   the interpretation of CoverParenthesizedExpressionAndArrowParameterList is refined using the following grammar:

   ParenthesizedExpression[Yield, Await] :
      ( Expression[+In, ?Yield, ?Await] )


13.2.1 The `this` Keyword
'''''''''''''''''''''''''



13.2.1.1 Runtime Semantics: Evaluation
''''''''''''''''''''''''''''''''''''''

   PrimaryExpression : 
      `this` 1. Return ? ResolveThisBinding().

13.2.2 Identifier Reference
'''''''''''''''''''''''''''

See for `IdentifierReference`.


13.2.3 Literals
'''''''''''''''


**Syntax**


   Literal : 
      | NullLiteral
      | BooleanLiteral
      | NumericLiteral
      | StringLiteral



13.2.3.1 Runtime Semantics: Evaluation
''''''''''''''''''''''''''''''''''''''

Literal : NullLiteral

   1. Return null.

Literal : BooleanLiteral

   1. If BooleanLiteral is the token false, return false.
   2. If BooleanLiteral is the token true, return true.

Literal : NumericLiteral

   1. Return the NumericValue of NumericLiteral as defined in 12.9.3.

Literal : StringLiteral

   1. Return the SV of StringLiteral as defined in 12.9.4.2.


13.2.4 Array Initializer
''''''''''''''''''''''''

An `ArrayLiteral` is an expression describing the initialization of an
Array, using a list, of zero or more expressions each of which
represents an array element, enclosed in square brackets. The elements
need not be literals; they are evaluated each time the array initializer
is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
`AssignmentExpression` (i.e., a comma at the beginning or after
another comma), the missing array element contributes to the length of
the Array and increases the index of subsequent elements. Elided array
elements are not defined. If an element is elided at the end of an
array, that element does not contribute to the length of the Array.


**Syntax**


ArrayLiteral[Yield, Await] : `[` Elision? `]` `[`
ElementList[?Yield, ?Await] `]` `[` ElementList[?Yield, ?Await]
`,` Elision? `]` ElementList[Yield, Await] : Elision?
AssignmentExpression[+In, ?Yield, ?Await] Elision? SpreadElement[?Yield,
?Await] ElementList[?Yield, ?Await] `,` Elision?
AssignmentExpression[+In, ?Yield, ?Await] ElementList[?Yield, ?Await]
`,` Elision? SpreadElement[?Yield, ?Await] Elision : `,` Elision
`,` SpreadElement[Yield, Await] : `...` AssignmentExpression[+In,
?Yield, ?Await]

13.2.4.1 Runtime Semantics: ArrayAccumulation ( array: an Array, nextIndex: an integer, )
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Elision : `,` 1. Let len be nextIndex + 1. 1. Perform ?
Set(array, `"length"`, 𝔽(len), `true`). 1. NOTE: The above
step throws if len exceeds 2\ :sup:`32` - 1. 1. Return len.
Elision : Elision `,` 1. Return ? ArrayAccumulation of `Elision`
with arguments array and (nextIndex + 1). ElementList : Elision?
AssignmentExpression 1. If `Elision` is present, then 1. Set
nextIndex to ? ArrayAccumulation of `Elision` with arguments
array and nextIndex. 1. Let initResult be ? Evaluation of
`AssignmentExpression`. 1. Let initValue be ?
GetValue(initResult). 1. Perform !
CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)),
initValue). 1. Return nextIndex + 1. ElementList : Elision?
SpreadElement 1. If `Elision` is present, then 1. Set nextIndex to
? ArrayAccumulation of `Elision` with arguments array and
nextIndex. 1. Return ? ArrayAccumulation of `SpreadElement` with
arguments array and nextIndex. ElementList : ElementList `,`
Elision? AssignmentExpression 1. Set nextIndex to ?
ArrayAccumulation of `ElementList` with arguments array and
nextIndex. 1. If `Elision` is present, then 1. Set nextIndex
to ? ArrayAccumulation of `Elision` with arguments array and
nextIndex. 1. Let initResult be ? Evaluation of
`AssignmentExpression`. 1. Let initValue be ?
GetValue(initResult). 1. Perform !
CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)),
initValue). 1. Return nextIndex + 1. ElementList : ElementList
`,` Elision? SpreadElement 1. Set nextIndex to ? ArrayAccumulation
of `ElementList` with arguments array and nextIndex. 1. If
`Elision` is present, then 1. Set nextIndex to ? ArrayAccumulation
of `Elision` with arguments array and nextIndex. 1. Return ?
ArrayAccumulation of `SpreadElement` with arguments array and
nextIndex. SpreadElement : `...` AssignmentExpression 1. Let
spreadRef be ? Evaluation of `AssignmentExpression`. 1. Let
spreadObj be ? GetValue(spreadRef). 1. Let iteratorRecord be
? GetIterator(spreadObj, ~sync~). 1. Repeat, 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is ~done~, return
nextIndex. 1. Perform ! CreateDataPropertyOrThrow(array, !
ToString(𝔽(nextIndex)), next). 1. Set nextIndex to
nextIndex + 1.

CreateDataPropertyOrThrow is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Set]].



Runtime Semantics: Evaluation
-----------------------------

ArrayLiteral : `[` Elision? `]` 1. Let array be !
ArrayCreate(0). 1. If `Elision` is present, then 1. Perform ?
ArrayAccumulation of `Elision` with arguments array and 0. 1.
Return array. ArrayLiteral : `[` ElementList `]` 1. Let
array be ! ArrayCreate(0). 1. Perform ? ArrayAccumulation of
`ElementList` with arguments array and 0. 1. Return array.
ArrayLiteral : `[` ElementList `,` Elision? `]` 1. Let array
be ! ArrayCreate(0). 1. Let nextIndex be ? ArrayAccumulation of
`ElementList` with arguments array and 0. 1. If `Elision` is
present, then 1. Perform ? ArrayAccumulation of `Elision` with
arguments array and nextIndex. 1. Return array.

Object Initializer
------------------

An object initializer is an expression describing the initialization of
an Object, written in a form resembling a literal. It is a list of zero
or more pairs of property keys and associated values, enclosed in curly
brackets. The values need not be literals; they are evaluated each time
the object initializer is evaluated.


**Syntax**


ObjectLiteral[Yield, Await] : `{` `}` `{`
PropertyDefinitionList[?Yield, ?Await] `}` `{`
PropertyDefinitionList[?Yield, ?Await] `,` `}`
PropertyDefinitionList[Yield, Await] : PropertyDefinition[?Yield,
?Await] PropertyDefinitionList[?Yield, ?Await] `,`
PropertyDefinition[?Yield, ?Await] PropertyDefinition[Yield, Await] :
IdentifierReference[?Yield, ?Await] CoverInitializedName[?Yield, ?Await]
PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield,
?Await] MethodDefinition[?Yield, ?Await] `...`
AssignmentExpression[+In, ?Yield, ?Await] PropertyName[Yield, Await] :
LiteralPropertyName ComputedPropertyName[?Yield, ?Await]
LiteralPropertyName : IdentifierName StringLiteral NumericLiteral
ComputedPropertyName[Yield, Await] : `[` AssignmentExpression[+In,
?Yield, ?Await] `]` CoverInitializedName[Yield, Await] :
IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]
Initializer[In, Yield, Await] : `=` AssignmentExpression[?In, ?Yield,
?Await]

`MethodDefinition` is defined in .

In certain contexts, `ObjectLiteral` is used as a cover grammar for a
more restricted secondary grammar. The `CoverInitializedName`
production is necessary to fully cover these secondary grammars.
However, use of this production results in an early Syntax Error in
normal contexts where an actual `ObjectLiteral` is expected.


Static Semantics: Early Errors
------------------------------

PropertyDefinition : MethodDefinition

- It is a Syntax Error if HasDirectSuper of `MethodDefinition` is
  `true`.
- It is a Syntax Error if the PrivateBoundIdentifiers of
  `MethodDefinition` is not empty.

In addition to describing an actual object initializer the
`ObjectLiteral` productions are also used as a cover grammar for
`ObjectAssignmentPattern` and may be recognized as part of a
`CoverParenthesizedExpressionAndArrowParameterList`. When
`ObjectLiteral` appears in a context where `ObjectAssignmentPattern`
is required the following Early Error rules are **not** applied. In
addition, they are not applied when initially parsing a
`CoverParenthesizedExpressionAndArrowParameterList` or
`CoverCallExpressionAndAsyncArrowHead`.

PropertyDefinition : CoverInitializedName

- It is a Syntax Error if any source text is matched by this production.

This production exists so that `ObjectLiteral` can serve as a cover
grammar for `ObjectAssignmentPattern`. It cannot occur in an actual
object initializer.

ObjectLiteral : `{` PropertyDefinitionList `}` `{`
PropertyDefinitionList `,` `}`

- It is a Syntax Error if the PropertyNameList of
  `PropertyDefinitionList` contains any duplicate entries for
  `"_proto"` and at least two of those entries were obtained
  from productions of the form PropertyDefinition : PropertyName `:`
  AssignmentExpression. This rule is not applied if this
  `ObjectLiteral` is contained within a `Script` that is being
  parsed for JSON.parse (see step of JSON.parse).

The List returned by PropertyNameList does not include property names
defined using a `ComputedPropertyName`.

Static Semantics: IsComputedPropertyKey ( ): a Boolean
------------------------------------------------------

PropertyName : LiteralPropertyName 1. Return `false`. PropertyName :
ComputedPropertyName 1. Return `true`.

Static Semantics: PropertyNameList ( ): a List of Strings
---------------------------------------------------------

PropertyDefinitionList : PropertyDefinition 1. Let propName be the
PropName of `PropertyDefinition`. 1. If propName is ~empty~,
return a new empty List. 1. Return « propName ».
PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition
1. Let list be the PropertyNameList of `PropertyDefinitionList`.
1. Let propName be the PropName of `PropertyDefinition`. 1. If
propName is ~empty~, return list. 1. Return the
list-concatenation of list and « propName ».



Runtime Semantics: Evaluation
-----------------------------

ObjectLiteral : `{` `}` 1. Return
OrdinaryObjectCreate(%Object.prototype%). ObjectLiteral : `{`
PropertyDefinitionList `}` `{` PropertyDefinitionList `,` `}` 1.
Let obj be OrdinaryObjectCreate(%Object.prototype%). 1. Perform ?
PropertyDefinitionEvaluation of `PropertyDefinitionList` with argument
obj. 1. Return obj. LiteralPropertyName : IdentifierName 1.
Return the StringValue of `IdentifierName`. LiteralPropertyName :
StringLiteral 1. Return the SV of `StringLiteral`. LiteralPropertyName
: NumericLiteral 1. Let nbr be the NumericValue of
`NumericLiteral`. 1. Return ! ToString(nbr). ComputedPropertyName
: `[` AssignmentExpression `]` 1. Let exprValue be ? Evaluation
of `AssignmentExpression`. 1. Let propName be ?
GetValue(exprValue). 1. Return ? ToPropertyKey(propName).

Runtime Semantics: PropertyDefinitionEvaluation ( object: an Object, )
----------------------------------------------------------------------

PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition
1. Perform ? PropertyDefinitionEvaluation of `PropertyDefinitionList`
with argument object. 1. Perform ? PropertyDefinitionEvaluation of
`PropertyDefinition` with argument object. 1. Return ~unused~.
PropertyDefinition : `...` AssignmentExpression 1. Let exprValue
be ? Evaluation of `AssignmentExpression`. 1. Let fromValue be ?
GetValue(exprValue). 1. Let excludedNames be a new empty List.
1. Perform ? CopyDataProperties(object, fromValue,
excludedNames). 1. Return ~unused~. PropertyDefinition :
IdentifierReference 1. Let propName be the StringValue of
`IdentifierReference`. 1. Let exprValue be ? Evaluation of
`IdentifierReference`. 1. Let propValue be ?
GetValue(exprValue). 1. Assert: object is an ordinary,
extensible object with no non-configurable properties. 1. Perform !
CreateDataPropertyOrThrow(object, propName, propValue). 1.
Return ~unused~. PropertyDefinition : PropertyName `:`
AssignmentExpression 1. Let propKey be ? Evaluation of
`PropertyName`. 1. If this `PropertyDefinition` is contained within
a `Script` that is being evaluated for JSON.parse (see step of
JSON.parse), then 1. Let isProtoSetter be `false`. 1. Else if
propKey is `"_proto"` and IsComputedPropertyKey of
`PropertyName` is `false`, then 1. Let isProtoSetter be
`true`. 1. Else, 1. Let isProtoSetter be `false`. 1. If
IsAnonymousFunctionDefinition(`AssignmentExpression`) is `true` and
isProtoSetter is `false`, then 1. Let propValue be ?
NamedEvaluation of `AssignmentExpression` with argument propKey.
1. Else, 1. Let exprValueRef be ? Evaluation of
`AssignmentExpression`. 1. Let propValue be ?
GetValue(exprValueRef). 1. If isProtoSetter is `true`, then 1.
If propValue is an Object or propValue is `null`, then 1.
Perform ! object.[[SetPrototypeOf]](propValue). 1. Return
~unused~. 1. Assert: object is an ordinary, extensible object with
no non-configurable properties. 1. Perform !
CreateDataPropertyOrThrow(object, propKey, propValue). 1.
Return ~unused~. PropertyDefinition : MethodDefinition 1. Perform ?
MethodDefinitionEvaluation of `MethodDefinition` with arguments
object and `true`. 1. Return ~unused~.

Function Defining Expressions
-----------------------------

See for PrimaryExpression : FunctionExpression.

See for PrimaryExpression : GeneratorExpression.

See for PrimaryExpression : ClassExpression.

See for PrimaryExpression : AsyncFunctionExpression.

See for PrimaryExpression : AsyncGeneratorExpression.

.. _regular-expression-literals-1:

Regular Expression Literals
---------------------------


**Syntax**


See .


Static Semantics: Early Errors
------------------------------

PrimaryExpression : RegularExpressionLiteral

- It is a Syntax Error if
  IsValidRegularExpressionLiteral(`RegularExpressionLiteral`) is
  `false`.

Static Semantics: IsValidRegularExpressionLiteral ( literal: a `RegularExpressionLiteral` Parse Node, ): a Boolean
------------------------------------------------------------------------------------------------------------------------

description
   It determines if its argument is a valid regular expression literal.

1. Let flags be the FlagText of literal. 1. If flags
contains any code points other than `d`, `g`, `i`, `m`, `s`,
`u`, `v`, or `y`, or if flags contains any code point more
than once, return `false`. 1. If flags contains `u`, let u
be `true`; else let u be `false`. 1. If flags contains
`v`, let v be `true`; else let v be `false`. 1. Let
patternText be the BodyText of literal. 1. If u is `false`
and v is `false`, then 1. Let stringValue be
CodePointsToString(patternText). 1. Set patternText to the
sequence of code points resulting from interpreting each of the 16-bit
elements of stringValue as a Unicode BMP code point. UTF-16 decoding
is not applied to the elements. 1. Let parseResult be
ParsePattern(patternText, u, v). 1. If parseResult is a
Parse Node, return `true`; else return `false`.



Runtime Semantics: Evaluation
-----------------------------

PrimaryExpression : RegularExpressionLiteral 1. Let pattern be
CodePointsToString(BodyText of `RegularExpressionLiteral`). 1. Let
flags be CodePointsToString(FlagText of
`RegularExpressionLiteral`). 1. Return ! RegExpCreate(pattern,
flags).

Template Literals
-----------------


**Syntax**


TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
SubstitutionTemplate[?Yield, ?Await, ?Tagged]
SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead
Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
TemplateSpans[Yield, Await, Tagged] : TemplateTail
TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail
TemplateMiddleList[Yield, Await, Tagged] : TemplateMiddle
Expression[+In, ?Yield, ?Await] TemplateMiddleList[?Yield, ?Await,
?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]


Static Semantics: Early Errors
------------------------------

TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate

- It is a Syntax Error if the :sub:`[Tagged]` parameter was not set and
  `NoSubstitutionTemplate` Contains `NotEscapeSequence`.

TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield,
?Await, ?Tagged]

- It is a Syntax Error if the number of elements in the TemplateStrings
  of `TemplateLiteral` with argument `false` is greater than or
  equal to 2\ :sup:`32`.

SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead
Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

- It is a Syntax Error if the :sub:`[Tagged]` parameter was not set and
  `TemplateHead` Contains `NotEscapeSequence`.

TemplateSpans[Yield, Await, Tagged] : TemplateTail

- It is a Syntax Error if the :sub:`[Tagged]` parameter was not set and
  `TemplateTail` Contains `NotEscapeSequence`.

TemplateMiddleList[Yield, Await, Tagged] : TemplateMiddle
Expression[+In, ?Yield, ?Await] TemplateMiddleList[?Yield, ?Await,
?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]

- It is a Syntax Error if the :sub:`[Tagged]` parameter was not set and
  `TemplateMiddle` Contains `NotEscapeSequence`.

Static Semantics: TemplateStrings ( raw: a Boolean, ): a List of either Strings or `undefined`
----------------------------------------------------------------------------------------------------

TemplateLiteral : NoSubstitutionTemplate 1. Return «
TemplateString(`NoSubstitutionTemplate`, raw) ».
SubstitutionTemplate : TemplateHead Expression TemplateSpans 1. Let
head be « TemplateString(`TemplateHead`, raw) ». 1. Let
tail be the TemplateStrings of `TemplateSpans` with argument
raw. 1. Return the list-concatenation of head and tail.
TemplateSpans : TemplateTail 1. Return «
TemplateString(`TemplateTail`, raw) ». TemplateSpans :
TemplateMiddleList TemplateTail 1. Let middle be the TemplateStrings
of `TemplateMiddleList` with argument raw. 1. Let tail be «
TemplateString(`TemplateTail`, raw) ». 1. Return the
list-concatenation of middle and tail. TemplateMiddleList :
TemplateMiddle Expression 1. Return « TemplateString(`TemplateMiddle`,
raw) ». TemplateMiddleList : TemplateMiddleList TemplateMiddle
Expression 1. Let front be the TemplateStrings of
`TemplateMiddleList` with argument raw. 1. Let last be «
TemplateString(`TemplateMiddle`, raw) ». 1. Return the
list-concatenation of front and last.

Static Semantics: TemplateString ( templateToken: a `NoSubstitutionTemplate` Parse Node, a `TemplateHead` Parse Node, a `TemplateMiddle` Parse Node, or a `TemplateTail` Parse Node, raw: a Boolean, ): a String or `undefined`
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. If raw is `true`, then 1. Let string be the TRV of
templateToken. 1. Else, 1. Let string be the TV of
templateToken. 1. Return string.

This operation returns `undefined` if raw is `false` and
templateToken contains a `NotEscapeSequence`. In all other cases,
it returns a String.

GetTemplateObject ( templateLiteral: a Parse Node, ): an Array
------------------------------------------------------------------

1. Let realm be the current Realm Record. 1. Let
templateRegistry be realm.[[TemplateMap]]. 1. For each element
e of templateRegistry, do 1. If e.[[Site]] is the same Parse
Node as templateLiteral, then 1. Return e.[[Array]]. 1. Let
rawStrings be the TemplateStrings of templateLiteral with
argument `true`. 1. Assert: rawStrings is a List of Strings. 1.
Let cookedStrings be the TemplateStrings of templateLiteral with
argument `false`. 1. Let count be the number of elements in the
List cookedStrings. 1. Assert: count ≤ 2\ :sup:`32` - 1. 1. Let
template be ! ArrayCreate(count). 1. Let rawObj be !
ArrayCreate(count). 1. Let index be 0. 1. Repeat, while
index < count, 1. Let prop be ! ToString(𝔽(index)). 1.
Let cookedValue be cookedStrings[index]. 1. Perform !
DefinePropertyOrThrow(template, prop, PropertyDescriptor {
[[Value]]: cookedValue, [[Writable]]: `false`, [[Enumerable]]:
`true`, [[Configurable]]: `false` }). 1. Let rawValue be the
String value rawStrings[index]. 1. Perform !
DefinePropertyOrThrow(rawObj, prop, PropertyDescriptor {
[[Value]]: rawValue, [[Writable]]: `false`, [[Enumerable]]:
`true`, [[Configurable]]: `false` }). 1. Set index to index
+ 1. 1. Perform ! SetIntegrityLevel(rawObj, ~frozen~). 1. Perform !
DefinePropertyOrThrow(template, `"raw"`, PropertyDescriptor {
[[Value]]: rawObj, [[Writable]]: `false`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Perform !
SetIntegrityLevel(template, ~frozen~). 1. Append the Record {
[[Site]]: templateLiteral, [[Array]]: template } to
realm.[[TemplateMap]]. 1. Return template.

The creation of a template object cannot result in an abrupt completion.

Each `TemplateLiteral` in the program code of a realm is associated
with a unique template object that is used in the evaluation of tagged
Templates (). The template objects are frozen and the same template
object is used each time a specific tagged Template is evaluated.
Whether template objects are created lazily upon first evaluation of the
`TemplateLiteral` or eagerly prior to first evaluation is an
implementation choice that is not observable to ECMAScript code.

Future editions of this specification may define additional
non-enumerable properties of template objects.

Runtime Semantics: SubstitutionEvaluation ( )
---------------------------------------------

TemplateSpans : TemplateTail 1. Return a new empty List. TemplateSpans :
TemplateMiddleList TemplateTail 1. Return ? SubstitutionEvaluation of
`TemplateMiddleList`. TemplateMiddleList : TemplateMiddle Expression
1. Let subRef be ? Evaluation of `Expression`. 1. Let sub be ?
GetValue(subRef). 1. Return « sub ». TemplateMiddleList :
TemplateMiddleList TemplateMiddle Expression 1. Let preceding be ?
SubstitutionEvaluation of `TemplateMiddleList`. 1. Let nextRef be
? Evaluation of `Expression`. 1. Let next be ?
GetValue(nextRef). 1. Return the list-concatenation of preceding
and « next ».



Runtime Semantics: Evaluation
-----------------------------

TemplateLiteral : NoSubstitutionTemplate 1. Return the TV of
`NoSubstitutionTemplate` as defined in . SubstitutionTemplate :
TemplateHead Expression TemplateSpans 1. Let head be the TV of
`TemplateHead` as defined in . 1. Let subRef be ? Evaluation of
`Expression`. 1. Let sub be ? GetValue(subRef). 1. Let
middle be ? ToString(sub). 1. Let tail be ? Evaluation of
`TemplateSpans`. 1. Return the string-concatenation of head,
middle, and tail.

The string conversion semantics applied to the `Expression` value are
like `String.prototype.concat` rather than the `+` operator.

TemplateSpans : TemplateTail 1. Return the TV of `TemplateTail` as
defined in . TemplateSpans : TemplateMiddleList TemplateTail 1. Let
head be ? Evaluation of `TemplateMiddleList`. 1. Let tail be
the TV of `TemplateTail` as defined in . 1. Return the
string-concatenation of head and tail. TemplateMiddleList :
TemplateMiddle Expression 1. Let head be the TV of
`TemplateMiddle` as defined in . 1. Let subRef be ? Evaluation of
`Expression`. 1. Let sub be ? GetValue(subRef). 1. Let
middle be ? ToString(sub). 1. Return the string-concatenation of
head and middle.

The string conversion semantics applied to the `Expression` value are
like `String.prototype.concat` rather than the `+` operator.

TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression 1. Let
rest be ? Evaluation of `TemplateMiddleList`. 1. Let middle be
the TV of `TemplateMiddle` as defined in . 1. Let subRef be ?
Evaluation of `Expression`. 1. Let sub be ? GetValue(subRef).
1. Let last be ? ToString(sub). 1. Return the
string-concatenation of rest, middle, and last.

The string conversion semantics applied to the `Expression` value are
like `String.prototype.concat` rather than the `+` operator.

The Grouping Operator
---------------------


Static Semantics: Early Errors
------------------------------

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList

- `CoverParenthesizedExpressionAndArrowParameterList` must cover a
  `ParenthesizedExpression`.



Runtime Semantics: Evaluation
-----------------------------

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 1.
Let expr be the `ParenthesizedExpression` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return ?
Evaluation of expr. ParenthesizedExpression : `(` Expression `)`
1. Return ? Evaluation of `Expression`. This may be of type Reference.

This algorithm does not apply GetValue to Evaluation of `Expression`.
The principal motivation for this is so that operators such as
`delete` and `typeof` may be applied to parenthesized expressions.

13.3 Left-Hand-Side Expressions
-------------------------------


**Syntax**


MemberExpression[Yield, Await] : PrimaryExpression[?Yield, ?Await]
MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await]
`]` MemberExpression[?Yield, ?Await] `.` IdentifierName
MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await,
+Tagged] SuperProperty[?Yield, ?Await] MetaProperty `new`
MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
MemberExpression[?Yield, ?Await] `.` PrivateIdentifier
SuperProperty[Yield, Await] : `super` `[` Expression[+In, ?Yield,
?Await] `]` `super` `.` IdentifierName MetaProperty : NewTarget
ImportMeta NewTarget : `new` `.` `target` ImportMeta : `import`
`.` `meta` NewExpression[Yield, Await] : MemberExpression[?Yield,
?Await] `new` NewExpression[?Yield, ?Await] CallExpression[Yield,
Await] : CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
SuperCall[?Yield, ?Await] ImportCall[?Yield, ?Await]
CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await]
`]` CallExpression[?Yield, ?Await] `.` IdentifierName
CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
CallExpression[?Yield, ?Await] `.` PrivateIdentifier SuperCall[Yield,
Await] : `super` Arguments[?Yield, ?Await] ImportCall[Yield, Await] :
`import` `(` AssignmentExpression[+In, ?Yield, ?Await] `)`
Arguments[Yield, Await] : `(` `)` `(` ArgumentList[?Yield, ?Await]
`)` `(` ArgumentList[?Yield, ?Await] `,` `)` ArgumentList[Yield,
Await] : AssignmentExpression[+In, ?Yield, ?Await] `...`
AssignmentExpression[+In, ?Yield, ?Await] ArgumentList[?Yield, ?Await]
`,` AssignmentExpression[+In, ?Yield, ?Await] ArgumentList[?Yield,
?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]
OptionalExpression[Yield, Await] : MemberExpression[?Yield, ?Await]
OptionalChain[?Yield, ?Await] CallExpression[?Yield, ?Await]
OptionalChain[?Yield, ?Await] OptionalExpression[?Yield, ?Await]
OptionalChain[?Yield, ?Await] OptionalChain[Yield, Await] : `?.`
Arguments[?Yield, ?Await] `?.` `[` Expression[+In, ?Yield, ?Await]
`]` `?.` IdentifierName `?.` TemplateLiteral[?Yield, ?Await,
+Tagged] `?.` PrivateIdentifier OptionalChain[?Yield, ?Await]
Arguments[?Yield, ?Await] OptionalChain[?Yield, ?Await] `[`
Expression[+In, ?Yield, ?Await] `]` OptionalChain[?Yield, ?Await]
`.` IdentifierName OptionalChain[?Yield, ?Await]
TemplateLiteral[?Yield, ?Await, +Tagged] OptionalChain[?Yield, ?Await]
`.` PrivateIdentifier LeftHandSideExpression[Yield, Await] :
NewExpression[?Yield, ?Await] CallExpression[?Yield, ?Await]
OptionalExpression[?Yield, ?Await]

.. _supplemental-syntax-1:

**Supplemental Syntax**

| When processing an instance of the production
| CallExpression : CoverCallExpressionAndAsyncArrowHead
| the interpretation of `CoverCallExpressionAndAsyncArrowHead` is
  refined using the following grammar:

CallMemberExpression[Yield, Await] : MemberExpression[?Yield, ?Await]
Arguments[?Yield, ?Await]


Static Semantics
----------------


Static Semantics: Early Errors
------------------------------

OptionalChain : `?.` TemplateLiteral OptionalChain TemplateLiteral

- It is a Syntax Error if any source text is matched by this production.

This production exists in order to prevent automatic semicolon insertion
rules () from being applied to the following code:

.. code:: javascript

               a?.b
               `c`
             

so that it would be interpreted as two valid statements. The purpose is
to maintain consistency with similar code without optional chaining:

.. code:: javascript

               a.b
               `c`
             

which is a valid statement and where automatic semicolon insertion does
not apply.

ImportMeta : `import` `.` `meta`

- It is a Syntax Error if the syntactic goal symbol is not `Module`.

Property Accessors
------------------

Properties are accessed by name, using either the dot notation:

.. container:: rhs

   `MemberExpression` `.` `IdentifierName`
   `CallExpression` `.` `IdentifierName`

or the bracket notation:

.. container:: rhs

   `MemberExpression` `[` `Expression` `]`
   `CallExpression` `[` `Expression` `]`

The dot notation is explained by the following syntactic conversion:

.. container:: rhs

   `MemberExpression` `.` `IdentifierName`

is identical in its behaviour to

.. container:: rhs

   `MemberExpression` `[` <*identifier-name-string*> `]`

and similarly

.. container:: rhs

   `CallExpression` `.` `IdentifierName`

is identical in its behaviour to

.. container:: rhs

   `CallExpression` `[` <*identifier-name-string*> `]`

where <*identifier-name-string*> is the StringValue of
`IdentifierName`.



Runtime Semantics: Evaluation
-----------------------------

MemberExpression : MemberExpression `[` Expression `]` 1. Let
baseReference be ? Evaluation of `MemberExpression`. 1. Let
baseValue be ? GetValue(baseReference). 1. Let strict be
IsStrict(this `MemberExpression`). 1. Return ?
EvaluatePropertyAccessWithExpressionKey(baseValue, `Expression`,
strict). MemberExpression : MemberExpression `.` IdentifierName 1.
Let baseReference be ? Evaluation of `MemberExpression`. 1. Let
baseValue be ? GetValue(baseReference). 1. Let strict be
IsStrict(this `MemberExpression`). 1. Return
EvaluatePropertyAccessWithIdentifierKey(baseValue,
`IdentifierName`, strict). MemberExpression : MemberExpression
`.` PrivateIdentifier 1. Let baseReference be ? Evaluation of
`MemberExpression`. 1. Let baseValue be ?
GetValue(baseReference). 1. Let fieldNameString be the
StringValue of `PrivateIdentifier`. 1. Return
MakePrivateReference(baseValue, fieldNameString). CallExpression
: CallExpression `[` Expression `]` 1. Let baseReference be ?
Evaluation of `CallExpression`. 1. Let baseValue be ?
GetValue(baseReference). 1. Let strict be IsStrict(this
`CallExpression`). 1. Return ?
EvaluatePropertyAccessWithExpressionKey(baseValue, `Expression`,
strict). CallExpression : CallExpression `.` IdentifierName 1. Let
baseReference be ? Evaluation of `CallExpression`. 1. Let
baseValue be ? GetValue(baseReference). 1. Let strict be
IsStrict(this `CallExpression`). 1. Return
EvaluatePropertyAccessWithIdentifierKey(baseValue,
`IdentifierName`, strict). CallExpression : CallExpression `.`
PrivateIdentifier 1. Let baseReference be ? Evaluation of
`CallExpression`. 1. Let baseValue be ?
GetValue(baseReference). 1. Let fieldNameString be the
StringValue of `PrivateIdentifier`. 1. Return
MakePrivateReference(baseValue, fieldNameString).

EvaluatePropertyAccessWithExpressionKey ( baseValue, expression: an `Expression` Parse Node, strict: a Boolean, )
-----------------------------------------------------------------------------------------------------------------

1. Let propertyNameReference be ? Evaluation of expression. 1.
Let propertyNameValue be ? GetValue(propertyNameReference). 1.
NOTE: In most cases, ToPropertyKey will be performed on
propertyNameValue immediately after this step. However, in the case
of `a[b] = c`, it will not be performed until after evaluation of
`c`. 1. Return the Reference Record { [[Base]]: baseValue,
[[ReferencedName]]: propertyNameValue, [[Strict]]: strict,
[[ThisValue]]: ~empty~ }.

EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName: an `IdentifierName` Parse Node, strict: a Boolean, ): a Reference Record
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let propertyNameString be the StringValue of identifierName.
1. Return the Reference Record { [[Base]]: baseValue,
[[ReferencedName]]: propertyNameString, [[Strict]]: strict,
[[ThisValue]]: ~empty~ }.

The `new` Operator
--------------------



Runtime Semantics: Evaluation
-----------------------------

NewExpression : `new` NewExpression 1. Return ?
EvaluateNew(`NewExpression`, ~empty~). MemberExpression : `new`
MemberExpression Arguments 1. Return ? EvaluateNew(`MemberExpression`,
`Arguments`).

EvaluateNew ( constructExpr: a `NewExpression` Parse Node or a `MemberExpression` Parse Node, arguments: ~empty~ or an `Arguments` Parse Node, )
------------------------------------------------------------------------------------------------------------------------------------------------

1. Let ref be ? Evaluation of constructExpr. 1. Let
constructor be ? GetValue(ref). 1. If arguments is ~empty~,
then 1. Let argList be a new empty List. 1. Else, 1. Let argList
be ? ArgumentListEvaluation of arguments. 1. If
IsConstructor(constructor) is `false`, throw a `TypeError`
exception. 1. Return ? Construct(constructor, argList).

Function Calls
--------------



Runtime Semantics: Evaluation
-----------------------------

CallExpression : CoverCallExpressionAndAsyncArrowHead 1. Let expr be
the `CallMemberExpression` that is covered by
`CoverCallExpressionAndAsyncArrowHead`. 1. Let memberExpr be the
`MemberExpression` of expr. 1. Let arguments be the
`Arguments` of expr. 1. Let ref be ? Evaluation of
memberExpr. 1. Let func be ? GetValue(ref). 1. If ref is
a Reference Record, IsPropertyReference(ref) is `false`, and
ref.[[ReferencedName]] is `"eval"`, then 1. If SameValue(func,
%eval%) is `true`, then 1. Let argList be ? ArgumentListEvaluation
of arguments. 1. If argList has no elements, return
`undefined`. 1. Let evalArg be the first element of argList.
1. If IsStrict(this `CallExpression`) is `true`, let
strictCaller be `true`. Otherwise let strictCaller be
`false`. 1. [id="step-callexpression-evaluation-direct-eval"] Return ?
PerformEval(evalArg, strictCaller, `true`). 1. Let
thisCall be this `CallExpression`. 1. Let tailCall be
IsInTailPosition(thisCall). 1. Return ? EvaluateCall(func,
ref, arguments, tailCall).

A `CallExpression` evaluation that executes step is a direct eval.

CallExpression : CallExpression Arguments 1. Let ref be ? Evaluation
of `CallExpression`. 1. Let func be ? GetValue(ref). 1. Let
thisCall be this `CallExpression`. 1. Let tailCall be
IsInTailPosition(thisCall). 1. Return ? EvaluateCall(func,
ref, `Arguments`, tailCall).

EvaluateCall ( func, ref or a Reference Record, arguments: a Parse Node, tailPosition: a Boolean, )
---------------------------------------------------------------------------------------------------

1. If ref is a Reference Record, then 1. If
IsPropertyReference(ref) is `true`, then 1. Let thisValue be
GetThisValue(ref). 1. Else, 1. Let refEnv be ref.[[Base]].
1. Assert: refEnv is an Environment Record. 1. Let thisValue be
refEnv.WithBaseObject(). 1. Else, 1. Let thisValue be
`undefined`. 1. Let argList be ? ArgumentListEvaluation of
arguments. 1. If func is not an Object, throw a `TypeError`
exception. 1. If IsCallable(func) is `false`, throw a
`TypeError` exception. 1. If tailPosition is `true`, perform
PrepareForTailCall(). 1. Return ? Call(func, thisValue,
argList).

The `super` Keyword
---------------------



Runtime Semantics: Evaluation
-----------------------------

SuperProperty : `super` `[` Expression `]` 1. Let env be
GetThisEnvironment(). 1. Let actualThis be ?
env.GetThisBinding(). 1. Let propertyNameReference be ?
Evaluation of `Expression`. 1. Let propertyNameValue be ?
GetValue(propertyNameReference). 1. Let strict be IsStrict(this
`SuperProperty`). 1. NOTE: In most cases, ToPropertyKey will be
performed on propertyNameValue immediately after this step. However,
in the case of `super[b] = c`, it will not be performed until after
evaluation of `c`. 1. Return
MakeSuperPropertyReference(actualThis, propertyNameValue,
strict). SuperProperty : `super` `.` IdentifierName 1. Let
env be GetThisEnvironment(). 1. Let actualThis be ?
env.GetThisBinding(). 1. Let propertyKey be the StringValue of
`IdentifierName`. 1. Let strict be IsStrict(this
`SuperProperty`). 1. Return MakeSuperPropertyReference(actualThis,
propertyKey, strict). SuperCall : `super` Arguments 1. Let
newTarget be GetNewTarget(). 1. Assert: newTarget is an Object.
1. Let func be GetSuperConstructor(). 1. Let argList be ?
ArgumentListEvaluation of `Arguments`. 1. If IsConstructor(func)
is `false`, throw a `TypeError` exception. 1. Let result be ?
Construct(func, argList, newTarget). 1. Let thisER be
GetThisEnvironment(). 1. Perform ? thisER.BindThisValue(result).
1. Let F be thisER.[[FunctionObject]]. 1. Assert: F is an
ECMAScript function object. 1. Perform ?
InitializeInstanceElements(result, F). 1. Return result.

GetSuperConstructor ( )
-----------------------------------------------------

1. Let envRec be GetThisEnvironment(). 1. Assert: envRec is a
Function Environment Record. 1. Let activeFunction be
envRec.[[FunctionObject]]. 1. Assert: activeFunction is an
ECMAScript function object. 1. Let superConstructor be !
activeFunction.[[GetPrototypeOf]](). 1. Return superConstructor.

MakeSuperPropertyReference ( actualThis, propertyKey, strict: a Boolean, ): a Super Reference Record
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let env be GetThisEnvironment(). 1. Assert:
env.HasSuperBinding() is `true`. 1. Let baseValue be
env.GetSuperBase(). 1. Return the Reference Record { [[Base]]:
baseValue, [[ReferencedName]]: propertyKey, [[Strict]]:
strict, [[ThisValue]]: actualThis }.

Argument Lists
--------------

The evaluation of an argument list produces a List of values.

Runtime Semantics: ArgumentListEvaluation ( )
---------------------------------------------

Arguments : `(` `)` 1. Return a new empty List. ArgumentList :
AssignmentExpression 1. Let ref be ? Evaluation of
`AssignmentExpression`. 1. Let arg be ? GetValue(ref). 1.
Return « arg ». ArgumentList : `...` AssignmentExpression 1. Let
list be a new empty List. 1. Let spreadRef be ? Evaluation of
`AssignmentExpression`. 1. Let spreadObj be ?
GetValue(spreadRef). 1. Let iteratorRecord be ?
GetIterator(spreadObj, ~sync~). 1. Repeat, 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is ~done~, return
list. 1. Append next to list. ArgumentList : ArgumentList
`,` AssignmentExpression 1. Let precedingArgs be ?
ArgumentListEvaluation of `ArgumentList`. 1. Let ref be ?
Evaluation of `AssignmentExpression`. 1. Let arg be ?
GetValue(ref). 1. Return the list-concatenation of precedingArgs
and « arg ». ArgumentList : ArgumentList `,` `...`
AssignmentExpression 1. Let precedingArgs be ?
ArgumentListEvaluation of `ArgumentList`. 1. Let spreadRef be ?
Evaluation of `AssignmentExpression`. 1. Let iteratorRecord be ?
GetIterator(? GetValue(spreadRef), ~sync~). 1. Repeat, 1. Let
next be ? IteratorStepValue(iteratorRecord). 1. If next is
~done~, return precedingArgs. 1. Append next to
precedingArgs. TemplateLiteral : NoSubstitutionTemplate 1. Let
templateLiteral be this `TemplateLiteral`. 1. Let siteObj be
GetTemplateObject(templateLiteral). 1. Return « siteObj ».
TemplateLiteral : SubstitutionTemplate 1. Let templateLiteral be
this `TemplateLiteral`. 1. Let siteObj be
GetTemplateObject(templateLiteral). 1. Let remaining be ?
ArgumentListEvaluation of `SubstitutionTemplate`. 1. Return the
list-concatenation of « siteObj » and remaining.
SubstitutionTemplate : TemplateHead Expression TemplateSpans 1. Let
firstSubRef be ? Evaluation of `Expression`. 1. Let firstSub
be ? GetValue(firstSubRef). 1. Let restSub be ?
SubstitutionEvaluation of `TemplateSpans`. 1. Assert: restSub is a
possibly empty List. 1. Return the list-concatenation of « firstSub
» and restSub.

Optional Chains
---------------

An optional chain is a chain of one or more property accesses and
function calls, the first of which begins with the token `?.`.



Runtime Semantics: Evaluation
-----------------------------

OptionalExpression : MemberExpression OptionalChain 1. Let
baseReference be ? Evaluation of `MemberExpression`. 1. Let
baseValue be ? GetValue(baseReference). 1. If baseValue is
either `undefined` or `null`, then 1. Return `undefined`. 1.
Return ? ChainEvaluation of `OptionalChain` with arguments
baseValue and baseReference. OptionalExpression : CallExpression
OptionalChain 1. Let baseReference be ? Evaluation of
`CallExpression`. 1. Let baseValue be ?
GetValue(baseReference). 1. If baseValue is either `undefined`
or `null`, then 1. Return `undefined`. 1. Return ? ChainEvaluation
of `OptionalChain` with arguments baseValue and baseReference.
OptionalExpression : OptionalExpression OptionalChain 1. Let
baseReference be ? Evaluation of `OptionalExpression`. 1. Let
baseValue be ? GetValue(baseReference). 1. If baseValue is
either `undefined` or `null`, then 1. Return `undefined`. 1.
Return ? ChainEvaluation of `OptionalChain` with arguments
baseValue and baseReference.

Runtime Semantics: ChainEvaluation ( baseValue, baseReference or a Reference Record, )
--------------------------------------------------------------------------------------

OptionalChain : `?.` Arguments 1. Let thisChain be this
`OptionalChain`. 1. Let tailCall be
IsInTailPosition(thisChain). 1. Return ? EvaluateCall(baseValue,
baseReference, `Arguments`, tailCall). OptionalChain : `?.`
`[` Expression `]` 1. Let strict be IsStrict(this
`OptionalChain`). 1. Return ?
EvaluatePropertyAccessWithExpressionKey(baseValue, `Expression`,
strict). OptionalChain : `?.` IdentifierName 1. Let strict be
IsStrict(this `OptionalChain`). 1. Return
EvaluatePropertyAccessWithIdentifierKey(baseValue,
`IdentifierName`, strict). OptionalChain : `?.`
PrivateIdentifier 1. Let fieldNameString be the StringValue of
`PrivateIdentifier`. 1. Return MakePrivateReference(baseValue,
fieldNameString). OptionalChain : OptionalChain Arguments 1. Let
optionalChain be `OptionalChain`. 1. Let newReference be ?
ChainEvaluation of optionalChain with arguments baseValue and
baseReference. 1. Let newValue be ? GetValue(newReference).
1. Let thisChain be this `OptionalChain`. 1. Let tailCall be
IsInTailPosition(thisChain). 1. Return ? EvaluateCall(newValue,
newReference, `Arguments`, tailCall). OptionalChain :
OptionalChain `[` Expression `]` 1. Let optionalChain be
`OptionalChain`. 1. Let newReference be ? ChainEvaluation of
optionalChain with arguments baseValue and baseReference. 1.
Let newValue be ? GetValue(newReference). 1. Let strict be
IsStrict(this `OptionalChain`). 1. Return ?
EvaluatePropertyAccessWithExpressionKey(newValue, `Expression`,
strict). OptionalChain : OptionalChain `.` IdentifierName 1. Let
optionalChain be `OptionalChain`. 1. Let newReference be ?
ChainEvaluation of optionalChain with arguments baseValue and
baseReference. 1. Let newValue be ? GetValue(newReference).
1. Let strict be IsStrict(this `OptionalChain`). 1. Return
EvaluatePropertyAccessWithIdentifierKey(newValue,
`IdentifierName`, strict). OptionalChain : OptionalChain `.`
PrivateIdentifier 1. Let optionalChain be `OptionalChain`. 1. Let
newReference be ? ChainEvaluation of optionalChain with
arguments baseValue and baseReference. 1. Let newValue be ?
GetValue(newReference). 1. Let fieldNameString be the
StringValue of `PrivateIdentifier`. 1. Return
MakePrivateReference(newValue, fieldNameString).

Import Calls
------------



Runtime Semantics: Evaluation
-----------------------------

ImportCall : `import` `(` AssignmentExpression `)` 1. Let
referrer be GetActiveScriptOrModule(). 1. If referrer is
`null`, set referrer to the current Realm Record. 1. Let
argRef be ? Evaluation of `AssignmentExpression`. 1. Let
specifier be ? GetValue(argRef). 1. Let promiseCapability be
! NewPromiseCapability(%Promise%). 1. Let specifierString be
Completion(ToString(specifier)). 1.
IfAbruptRejectPromise(specifierString, promiseCapability). 1.
Perform HostLoadImportedModule(referrer, specifierString,
~empty~, promiseCapability). 1. Return
promiseCapability.[[Promise]].

ContinueDynamicImport ( promiseCapability: a PromiseCapability Record, moduleCompletion
---------------------------------------------------------------------------------------

description
   It completes the process of a dynamic import originally started by an
   `import()` call, resolving or rejecting the promise returned by
   that call as appropriate.

1. If moduleCompletion is an abrupt completion, then 1. Perform !
Call(promiseCapability.[[Reject]], `undefined`, «
moduleCompletion.[[Value]] »). 1. Return ~unused~. 1. Let module
be moduleCompletion.[[Value]]. 1. Let loadPromise be
module.LoadRequestedModules(). 1. Let rejectedClosure be a new
Abstract Closure with parameters (reason) that captures
promiseCapability and performs the following steps when called: 1.
Perform ! Call(promiseCapability.[[Reject]], `undefined`, «
reason »). 1. Return ~unused~. 1. Let onRejected be
CreateBuiltinFunction(rejectedClosure, 1, `""`, « »). 1. Let
linkAndEvaluateClosure be a new Abstract Closure with no parameters
that captures module, promiseCapability, and onRejected and
performs the following steps when called: 1. Let link be
Completion(module.Link()). 1. If link is an abrupt completion,
then 1. Perform ! Call(promiseCapability.[[Reject]], `undefined`,
« link.[[Value]] »). 1. Return ~unused~. 1. Let evaluatePromise
be module.Evaluate(). 1. Let fulfilledClosure be a new Abstract
Closure with no parameters that captures module and
promiseCapability and performs the following steps when called: 1.
Let namespace be GetModuleNamespace(module). 1. Perform !
Call(promiseCapability.[[Resolve]], `undefined`, « namespace
»). 1. Return ~unused~. 1. Let onFulfilled be
CreateBuiltinFunction(fulfilledClosure, 0, `""`, « »). 1. Perform
PerformPromiseThen(evaluatePromise, onFulfilled,
onRejected). 1. Return ~unused~. 1. Let linkAndEvaluate be
CreateBuiltinFunction(linkAndEvaluateClosure, 0, `""`, « »). 1.
Perform PerformPromiseThen(loadPromise, linkAndEvaluate,
onRejected). 1. Return ~unused~.

Tagged Templates
----------------

A tagged template is a function call where the arguments of the call are
derived from a `TemplateLiteral` (). The actual arguments include a
template object () and the values produced by evaluating the expressions
embedded within the `TemplateLiteral`.



Runtime Semantics: Evaluation
-----------------------------

MemberExpression : MemberExpression TemplateLiteral 1. Let tagRef be
? Evaluation of `MemberExpression`. 1. Let tagFunc be ?
GetValue(tagRef). 1. Let thisCall be this `MemberExpression`.
1. Let tailCall be IsInTailPosition(thisCall). 1. Return ?
EvaluateCall(tagFunc, tagRef, `TemplateLiteral`,
tailCall). CallExpression : CallExpression TemplateLiteral 1. Let
tagRef be ? Evaluation of `CallExpression`. 1. Let tagFunc be
? GetValue(tagRef). 1. Let thisCall be this `CallExpression`.
1. Let tailCall be IsInTailPosition(thisCall). 1. Return ?
EvaluateCall(tagFunc, tagRef, `TemplateLiteral`,
tailCall).

Meta Properties
---------------



Runtime Semantics: Evaluation
-----------------------------

NewTarget : `new` `.` `target` 1. Return GetNewTarget().
ImportMeta : `import` `.` `meta` 1. Let module be
GetActiveScriptOrModule(). 1. Assert: module is a Source Text Module
Record. 1. Let importMeta be module.[[ImportMeta]]. 1. If
importMeta is ~empty~, then 1. Set importMeta to
OrdinaryObjectCreate(`null`). 1. Let importMetaValues be
HostGetImportMetaProperties(module). 1. For each Record { [[Key]],
[[Value]] } p of importMetaValues, do 1. Perform !
CreateDataPropertyOrThrow(importMeta, p.[[Key]],
p.[[Value]]). 1. Perform HostFinalizeImportMeta(importMeta,
module). 1. Set module.[[ImportMeta]] to importMeta. 1.
Return importMeta. 1. Else, 1. Assert: importMeta is an Object.
1. Return importMeta.

HostGetImportMetaProperties ( moduleRecord: a Module Record, ): a List of Records with fields [[Key]] (a property key) and [[Value]] (an ECMAScript language value)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It allows hosts to provide property keys and values for the object
   returned from `import.meta`.

The default implementation of HostGetImportMetaProperties is to return a
new empty List.

HostFinalizeImportMeta ( importMeta: an Object, moduleRecord: a Module Record, ): ~unused~
--------------------------------------------------------------------------------------------------

description
   It allows hosts to perform any extraordinary operations to prepare
   the object returned from `import.meta`.

Most hosts will be able to simply define HostGetImportMetaProperties,
and leave HostFinalizeImportMeta with its default behaviour. However,
HostFinalizeImportMeta provides an "escape hatch" for hosts which need
to directly manipulate the object before it is exposed to ECMAScript
code.

The default implementation of HostFinalizeImportMeta is to return
~unused~.

13.4 Update Expressions
-----------------------


**Syntax**


UpdateExpression[Yield, Await] : LeftHandSideExpression[?Yield, ?Await]
LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`
`++` UnaryExpression[?Yield, ?Await] `--` UnaryExpression[?Yield,
?Await]


Static Semantics: Early Errors
------------------------------

UpdateExpression : LeftHandSideExpression `++` LeftHandSideExpression
`--`

- It is an early Syntax Error if the AssignmentTargetType of
  `LeftHandSideExpression` is not ~simple~.

UpdateExpression : `++` UnaryExpression `--` UnaryExpression

- It is an early Syntax Error if the AssignmentTargetType of
  `UnaryExpression` is not ~simple~.

Postfix Increment Operator
--------------------------



Runtime Semantics: Evaluation
-----------------------------

UpdateExpression : LeftHandSideExpression `++` 1. Let lhs be ?
Evaluation of `LeftHandSideExpression`. 1. Let oldValue be ?
ToNumeric(? GetValue(lhs)). 1. If oldValue is a Number, then 1.
Let newValue be Number::add(oldValue, `1`\ :sub:`𝔽`). 1. Else,
1. Assert: oldValue is a BigInt. 1. Let newValue be
BigInt::add(oldValue, `1`\ :sub:`ℤ`). 1. Perform ?
PutValue(lhs, newValue). 1. Return oldValue.

Postfix Decrement Operator
--------------------------



Runtime Semantics: Evaluation
-----------------------------

UpdateExpression : LeftHandSideExpression `--` 1. Let lhs be ?
Evaluation of `LeftHandSideExpression`. 1. Let oldValue be ?
ToNumeric(? GetValue(lhs)). 1. If oldValue is a Number, then 1.
Let newValue be Number::subtract(oldValue, `1`\ :sub:`𝔽`). 1.
Else, 1. Assert: oldValue is a BigInt. 1. Let newValue be
BigInt::subtract(oldValue, `1`\ :sub:`ℤ`). 1. Perform ?
PutValue(lhs, newValue). 1. Return oldValue.

Prefix Increment Operator
-------------------------



Runtime Semantics: Evaluation
-----------------------------

UpdateExpression : `++` UnaryExpression 1. Let expr be ?
Evaluation of `UnaryExpression`. 1. Let oldValue be ? ToNumeric(?
GetValue(expr)). 1. If oldValue is a Number, then 1. Let
newValue be Number::add(oldValue, `1`\ :sub:`𝔽`). 1. Else, 1.
Assert: oldValue is a BigInt. 1. Let newValue be
BigInt::add(oldValue, `1`\ :sub:`ℤ`). 1. Perform ?
PutValue(expr, newValue). 1. Return newValue.

Prefix Decrement Operator
-------------------------



Runtime Semantics: Evaluation
-----------------------------

UpdateExpression : `--` UnaryExpression 1. Let expr be ?
Evaluation of `UnaryExpression`. 1. Let oldValue be ? ToNumeric(?
GetValue(expr)). 1. If oldValue is a Number, then 1. Let
newValue be Number::subtract(oldValue, `1`\ :sub:`𝔽`). 1.
Else, 1. Assert: oldValue is a BigInt. 1. Let newValue be
BigInt::subtract(oldValue, `1`\ :sub:`ℤ`). 1. Perform ?
PutValue(expr, newValue). 1. Return newValue.

13.5 Unary Operators
--------------------


**Syntax**


UnaryExpression[Yield, Await] : UpdateExpression[?Yield, ?Await]
`delete` UnaryExpression[?Yield, ?Await] `void`
UnaryExpression[?Yield, ?Await] `typeof` UnaryExpression[?Yield,
?Await] `+` UnaryExpression[?Yield, ?Await] `-`
UnaryExpression[?Yield, ?Await] `~` UnaryExpression[?Yield, ?Await]
`!` UnaryExpression[?Yield, ?Await] [+Await] AwaitExpression[?Yield]

The `delete` Operator
-----------------------


Static Semantics: Early Errors
------------------------------

UnaryExpression : `delete` UnaryExpression

- It is a Syntax Error if IsStrict(the `UnaryExpression`) is `true`
  and the derived `UnaryExpression` is PrimaryExpression :
  IdentifierReference, MemberExpression : MemberExpression `.`
  PrivateIdentifier, CallExpression : CallExpression `.`
  PrivateIdentifier, OptionalChain : `?.` PrivateIdentifier, or
  OptionalChain : OptionalChain `.` PrivateIdentifier.

- | It is a Syntax Error if the derived `UnaryExpression` is
  | PrimaryExpression :
    CoverParenthesizedExpressionAndArrowParameterList
  | and `CoverParenthesizedExpressionAndArrowParameterList` ultimately
    derives a phrase that, if used in place of `UnaryExpression`,
    would produce a Syntax Error according to these rules. This rule is
    recursively applied.

The last rule means that expressions such as `delete (((foo)))`
produce early errors because of recursive application of the first rule.



Runtime Semantics: Evaluation
-----------------------------

UnaryExpression : `delete` UnaryExpression 1. Let ref be ?
Evaluation of `UnaryExpression`. 1. If ref is not a Reference
Record, return `true`. 1. If IsUnresolvableReference(ref) is
`true`, then 1. Assert: ref.[[Strict]] is `false`. 1. Return
`true`. 1. If IsPropertyReference(ref) is `true`, then 1.
Assert: IsPrivateReference(ref) is `false`. 1. If
IsSuperReference(ref) is `true`, throw a `ReferenceError`
exception. 1. [id="step-delete-operator-toobject"] Let baseObj be ?
ToObject(ref.[[Base]]). 1. If ref.[[ReferencedName]] is not a
property key, then 1. Set ref.[[ReferencedName]] to ?
ToPropertyKey(ref.[[ReferencedName]]). 1. Let deleteStatus be ?
baseObj.[[Delete]](ref.[[ReferencedName]]). 1. If
deleteStatus is `false` and ref.[[Strict]] is `true`, throw
a `TypeError` exception. 1. Return deleteStatus. 1. Else, 1. Let
base be ref.[[Base]]. 1. Assert: base is an Environment
Record. 1. Return ? base.DeleteBinding(ref.[[ReferencedName]]).

When a `delete` operator occurs within strict mode code, a
`SyntaxError` exception is thrown if its `UnaryExpression` is a
direct reference to a variable, function argument, or function name. In
addition, if a `delete` operator occurs within strict mode code and
the property to be deleted has the attribute { [[Configurable]]:
`false` } (or otherwise cannot be deleted), a `TypeError` exception
is thrown.

The object that may be created in step is not accessible outside of the
above abstract operation and the ordinary object [[Delete]] internal
method. An implementation might choose to avoid the actual creation of
that object.

The `void` Operator
---------------------



Runtime Semantics: Evaluation
-----------------------------

UnaryExpression : `void` UnaryExpression 1. Let expr be ?
Evaluation of `UnaryExpression`. 1. Perform ? GetValue(expr). 1.
Return `undefined`.

GetValue must be called even though its value is not used because it may
have observable side-effects.

The `typeof` Operator
-----------------------



Runtime Semantics: Evaluation
-----------------------------

UnaryExpression : `typeof` UnaryExpression 1. Let val be ?
Evaluation of `UnaryExpression`. 1. If val is a Reference Record,
then 1. If IsUnresolvableReference(val) is `true`, return
`"undefined"`. 1. Set val to ? GetValue(val). 1. If val is
`undefined`, return `"undefined"`. 1. If val is `null`, return
`"object"`. 1. If val is a String, return `"string"`. 1. If
val is a Symbol, return `"symbol"`. 1. If val is a Boolean,
return `"boolean"`. 1. If val is a Number, return `"number"`. 1.
If val is a BigInt, return `"bigint"`. 1. Assert: val is an
Object. 1. [id="step-typeof-web-compat-insertion-point"] NOTE: This step
is replaced in section . 1. If val has a [[Call]] internal slot,
return `"function"`. 1. Return `"object"`.

Unary `+` Operator
--------------------

The unary + operator converts its operand to Number type.



Runtime Semantics: Evaluation
-----------------------------

UnaryExpression : `+` UnaryExpression 1. Let expr be ? Evaluation
of `UnaryExpression`. 1. Return ? ToNumber(? GetValue(expr)).

Unary `-` Operator
--------------------

The unary `-` operator converts its operand to a numeric value and
then negates it. Negating `+0`\ :sub:`𝔽` produces `-0`\ :sub:`𝔽`,
and negating `-0`\ :sub:`𝔽` produces `+0`\ :sub:`𝔽`.



Runtime Semantics: Evaluation
-----------------------------

UnaryExpression : `-` UnaryExpression 1. Let expr be ? Evaluation
of `UnaryExpression`. 1. Let oldValue be ? ToNumeric(?
GetValue(expr)). 1. If oldValue is a Number, then 1. Return
Number::unaryMinus(oldValue). 1. Else, 1. Assert: oldValue is a
BigInt. 1. Return BigInt::unaryMinus(oldValue).

Bitwise NOT Operator ( `~` )
------------------------------



Runtime Semantics: Evaluation
-----------------------------

UnaryExpression : `~` UnaryExpression 1. Let expr be ? Evaluation
of `UnaryExpression`. 1. Let oldValue be ? ToNumeric(?
GetValue(expr)). 1. If oldValue is a Number, then 1. Return
Number::bitwiseNOT(oldValue). 1. Else, 1. Assert: oldValue is a
BigInt. 1. Return BigInt::bitwiseNOT(oldValue).

Logical NOT Operator ( `!` )
------------------------------



Runtime Semantics: Evaluation
-----------------------------

UnaryExpression : `!` UnaryExpression 1. Let expr be ? Evaluation
of `UnaryExpression`. 1. Let oldValue be ToBoolean(?
GetValue(expr)). 1. If oldValue is `true`, return `false`.
1. Return `true`.

13.6 Exponentiation Operator
----------------------------


**Syntax**


ExponentiationExpression[Yield, Await] : UnaryExpression[?Yield, ?Await]
UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield,
?Await]



Runtime Semantics: Evaluation
-----------------------------

ExponentiationExpression : UpdateExpression `**`
ExponentiationExpression 1. Return ?
EvaluateStringOrNumericBinaryExpression(`UpdateExpression`, `**`,
`ExponentiationExpression`).

13.7 Multiplicative Operators
-----------------------------


**Syntax**


MultiplicativeExpression[Yield, Await] :
ExponentiationExpression[?Yield, ?Await]
MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator
ExponentiationExpression[?Yield, ?Await] MultiplicativeOperator : one of
`*` `/` `%`

- The `*` operator performs multiplication, producing the product of
  its operands.
- The `/` operator performs division, producing the quotient of its
  operands.
- The `%` operator yields the remainder of its operands from an
  implied division.



Runtime Semantics: Evaluation
-----------------------------

MultiplicativeExpression : MultiplicativeExpression
MultiplicativeOperator ExponentiationExpression 1. Let opText be the
source text matched by `MultiplicativeOperator`. 1. Return ?
EvaluateStringOrNumericBinaryExpression(`MultiplicativeExpression`,
opText, `ExponentiationExpression`).

13.8 Additive Operators
-----------------------


**Syntax**


AdditiveExpression[Yield, Await] : MultiplicativeExpression[?Yield,
?Await] AdditiveExpression[?Yield, ?Await] `+`
MultiplicativeExpression[?Yield, ?Await] AdditiveExpression[?Yield,
?Await] `-` MultiplicativeExpression[?Yield, ?Await]

The Addition Operator ( `+` )
-------------------------------

The addition operator either performs string concatenation or numeric
addition.



Runtime Semantics: Evaluation
-----------------------------

AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression
1. Return ?
EvaluateStringOrNumericBinaryExpression(`AdditiveExpression`, `+`,
`MultiplicativeExpression`).

The Subtraction Operator ( `-` )
----------------------------------

The `-` operator performs subtraction, producing the difference of its
operands.



Runtime Semantics: Evaluation
-----------------------------

AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression
1. Return ?
EvaluateStringOrNumericBinaryExpression(`AdditiveExpression`, `-`,
`MultiplicativeExpression`).

13.9 Bitwise Shift Operators
----------------------------


**Syntax**


ShiftExpression[Yield, Await] : AdditiveExpression[?Yield, ?Await]
ShiftExpression[?Yield, ?Await] `<<` AdditiveExpression[?Yield,
?Await] ShiftExpression[?Yield, ?Await] `>>`
AdditiveExpression[?Yield, ?Await] ShiftExpression[?Yield, ?Await]
`>>>` AdditiveExpression[?Yield, ?Await]

The Left Shift Operator ( `<<` )
----------------------------------

Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.



Runtime Semantics: Evaluation
-----------------------------

ShiftExpression : ShiftExpression `<<` AdditiveExpression 1. Return ?
EvaluateStringOrNumericBinaryExpression(`ShiftExpression`, `<<`,
`AdditiveExpression`).

The Signed Right Shift Operator ( `>>` )
------------------------------------------

Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.



Runtime Semantics: Evaluation
-----------------------------

ShiftExpression : ShiftExpression `>>` AdditiveExpression 1. Return ?
EvaluateStringOrNumericBinaryExpression(`ShiftExpression`, `>>`,
`AdditiveExpression`).

The Unsigned Right Shift Operator ( `>>>` )
---------------------------------------------

Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.



Runtime Semantics: Evaluation
-----------------------------

ShiftExpression : ShiftExpression `>>>` AdditiveExpression 1. Return ?
EvaluateStringOrNumericBinaryExpression(`ShiftExpression`, `>>>`,
`AdditiveExpression`).

13.10 Relational Operators
--------------------------

.. Note::

   The result of evaluating a relational operator is always of type
   Boolean, reflecting whether the relationship named by the operator holds
   between its two operands.


**Syntax**

RelationalExpression[In, Yield, Await] :
   | ShiftExpression[?Yield, ?Await]
   | RelationalExpression[?In, ?Yield, ?Await] < ShiftExpression[?Yield, ?Await]
   | RelationalExpression[?In, ?Yield, ?Await] > ShiftExpression[?Yield, ?Await]
   | RelationalExpression[?In, ?Yield, ?Await] <= ShiftExpression[?Yield, ?Await]
   | RelationalExpression[?In, ?Yield, ?Await] >= ShiftExpression[?Yield, ?Await]
   | RelationalExpression[?In, ?Yield, ?Await] **instanceof** ShiftExpression[?Yield, ?Await]
   | [+In] RelationalExpression[+In, ?Yield, ?Await] **in** ShiftExpression[?Yield, ?Await]
   | [+In] PrivateIdentifier **in** ShiftExpression[?Yield, ?Await]


.. Note::

   The :sub:`[In]` grammar parameter is needed to avoid confusing the
   `in` operator in a relational expression with the `in` operator in a
   `for` statement.



13.10.1 Runtime Semantics: Evaluation
'''''''''''''''''''''''''''''''''''''

RelationalExpression : RelationalExpression `<` ShiftExpression 

1. Let lRef be ? Evaluation of `RelationalExpression`. 
2. Let lVal be ? GetValue(lRef). 
3. Let rRef be ? Evaluation of `ShiftExpression`. 
4. Let rVal be ? GetValue(rRef). 
5. Let r be ? IsLessThan(lVal, rVal, `true`). 
6. If r is `undefined`, return `false`. Otherwise, return r.

RelationalExpression : RelationalExpression `>` ShiftExpression 

1. Let lRef be ? Evaluation of `RelationalExpression`. 
2. Let lVal be ? GetValue(lRef). 
3. Let rRef be ? Evaluation of `ShiftExpression`. 
4. Let rVal be ? GetValue(rRef). 
5. Let r be ? IsLessThan(rVal, lVal, `false`). 
6. If r is `undefined`, return `false`. Otherwise, return r.

RelationalExpression : RelationalExpression `<=` ShiftExpression 

1. Let lRef be ? Evaluation of `RelationalExpression`. 
2. Let lVal be ? GetValue(lRef). 
3. Let rRef be ? Evaluation of `ShiftExpression`. 
4. Let rVal be ? GetValue(rRef). 
5. Let r be ? IsLessThan(rVal, lVal, `false`). 
6. If r is either `true` or `undefined`, return `false`. Otherwise, return `true`. 

RelationalExpression : RelationalExpression `>=` ShiftExpression 

1. Let lRef be ? Evaluation of `RelationalExpression`. 
2. Let lVal be ? GetValue(lRef). 
3. Let rRef be ? Evaluation of `ShiftExpression`. 
4. Let rVal be ? GetValue(rRef). 
5. Let r be ? IsLessThan(lVal, rVal, `true`). 
6. If r is either `true` or `undefined`, return `false`. Otherwise, return `true`. 

RelationalExpression : RelationalExpression `instanceof` ShiftExpression 

1. Let lRef be ? Evaluation of `RelationalExpression`. 
2. Let lVal be ? GetValue(lRef). 
3. Let rRef be ? Evaluation of `ShiftExpression`. 
4. Let rVal be ? GetValue(rRef). 
5. Return ? InstanceofOperator(lVal, rVal). 

RelationalExpression : RelationalExpression `in` ShiftExpression 

1. Let lRef be ? Evaluation of `RelationalExpression`. 
2. Let lVal be ? GetValue(lRef). 
3. Let rRef be ? Evaluation of `ShiftExpression`. 
4. Let rVal be ? GetValue(rRef). 
5. If rVal is not an Object, throw a `TypeError` exception. 
6. Return ? HasProperty(rVal, ? ToPropertyKey(lVal)). 

RelationalExpression : PrivateIdentifier `in` ShiftExpression 

1. Let privateIdentifier be the StringValue of `PrivateIdentifier`. 
2. Let rRef be ? Evaluation of `ShiftExpression`. 
3. Let rVal be ? GetValue(rRef). 
4. If rVal is not an Object, throw a `TypeError` exception. 
5. Let privateEnv be the running execution context's PrivateEnvironment. 
6. Let privateName be ResolvePrivateIdentifier(privateEnv, privateIdentifier). 
7. If PrivateElementFind(rVal, privateName) is not ~empty~, return `true`. 
8. Return `false`.


13.10.2 InstanceofOperator ( V, target, )
'''''''''''''''''''''''''''''''''''''''''

description
   It implements the generic algorithm for determining if V is an
   instance of target either by consulting target's
   %Symbol.hasInstance% method or, if absent, determining whether the
   value of target's `"prototype"` property is present in V's
   prototype chain.

1. If target is not an Object, throw a `TypeError` exception. 
2. Let instOfHandler be ? GetMethod(target, %Symbol.hasInstance%).
3. If instOfHandler is not `undefined`, then 
   a. Return ToBoolean(? Call(instOfHandler, target, « V »)). 
4. [id="step-instanceof-check-function"] If IsCallable(target) is `false`, throw a `TypeError` exception. 
5. [id="step-instanceof-fallback"] Return ? OrdinaryHasInstance(target, V).

.. Note::

   Steps and provide compatibility with previous editions of ECMAScript
   that did not use a %Symbol.hasInstance% method to define the
   `instanceof` operator semantics. If an object does not define or
   inherit %Symbol.hasInstance% it uses the default `instanceof`
   semantics.

13.11 Equality Operators
------------------------

.. Note::

   The result of evaluating an equality operator is always of type Boolean,
   reflecting whether the relationship named by the operator holds between
   its two operands.


**Syntax**

   EqualityExpression[In, Yield, Await] :
      | RelationalExpression[?In, ?Yield, ?Await]
      | EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await]
      | EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await]
      | EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await]
      | EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await]


13.11.1 Runtime Semantics: Evaluation
'''''''''''''''''''''''''''''''''''''

EqualityExpression : EqualityExpression `==` RelationalExpression 

1. Let lRef be ? Evaluation of `EqualityExpression`. 
1. Let lVal be ? GetValue(lRef). 
1. Let rRef be ? Evaluation of `RelationalExpression`. 
1. Let rVal be ? GetValue(rRef). 
1. Return ? IsLooselyEqual(rVal, lVal). 

EqualityExpression : EqualityExpression `!=` RelationalExpression 

1. Let lRef be ? Evaluation of `EqualityExpression`. 
1. Let lVal be ? GetValue(lRef). 
1. Let rRef be ? Evaluation of `RelationalExpression`. 
1. Let rVal be ? GetValue(rRef). 
1. Let r be ? IsLooselyEqual(rVal, lVal). 
1. If r is `true`, return `false`. Otherwise, return `true`.

EqualityExpression : EqualityExpression `===` RelationalExpression 

1. Let lRef be ? Evaluation of `EqualityExpression`. 
1. Let lVal be ? GetValue(lRef). 
1. Let rRef be ? Evaluation of `RelationalExpression`. 
1. Let rVal be ? GetValue(rRef). 
1. Return IsStrictlyEqual(rVal, lVal). 

EqualityExpression : EqualityExpression `!==` RelationalExpression 

1. Let lRef be ? Evaluation of `EqualityExpression`. 
1. Let lVal be ? GetValue(lRef). 
1. Let rRef be ? Evaluation of `RelationalExpression`. 
1. Let rVal be ? GetValue(rRef). 
1. Let r be IsStrictlyEqual(rVal, lVal). 
1. If r is `true`, return `false`. Otherwise, return `true`.


Given the above definition of equality:

- String comparison can be forced by: `${a}` == `${b}`.
- Numeric comparison can be forced by: `+a == +b`.
- Boolean comparison can be forced by: `!a == !b`.

The equality operators maintain the following invariants:

- `A != B` is equivalent to `!(A == B)`.
- `A == B` is equivalent to `B == A`, except in the order of
  evaluation of `A` and `B`.

The equality operator is not always transitive. For example, there might
be two distinct String objects, each representing the same String value;
each String object would be considered equal to the String value by the
`==` operator, but the two String objects would not be equal to each
other. For example:

- `new String("a") == "a"` and `"a" == new String("a")` are both `true`.
- `new String("a") == new String("a")` is `false`.

Comparison of Strings uses a simple equality test on sequences of code
unit values. There is no attempt to use the more complex, semantically
oriented definitions of character or string equality and collating order
defined in the Unicode specification. Therefore Strings values that are
canonically equal according to the Unicode Standard could test as
unequal. In effect this algorithm assumes that both Strings are already
in normalized form.

13.12 Binary Bitwise Operators
------------------------------


**Syntax**


BitwiseANDExpression[In, Yield, Await] : EqualityExpression[?In, ?Yield,
?Await] BitwiseANDExpression[?In, ?Yield, ?Await] `&`
EqualityExpression[?In, ?Yield, ?Await] BitwiseXORExpression[In, Yield,
Await] : BitwiseANDExpression[?In, ?Yield, ?Await]
BitwiseXORExpression[?In, ?Yield, ?Await] `^`
BitwiseANDExpression[?In, ?Yield, ?Await] BitwiseORExpression[In, Yield,
Await] : BitwiseXORExpression[?In, ?Yield, ?Await]
BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In,
?Yield, ?Await]



Runtime Semantics: Evaluation
-----------------------------

BitwiseANDExpression : BitwiseANDExpression `&` EqualityExpression 1.
Return ?
EvaluateStringOrNumericBinaryExpression(\|BitwiseANDExpression\|, `&`,
`EqualityExpression`). BitwiseXORExpression : BitwiseXORExpression
`^` BitwiseANDExpression 1. Return ?
EvaluateStringOrNumericBinaryExpression(\|BitwiseXORExpression\|, `^`,
\|BitwiseANDExpression\|). BitwiseORExpression : BitwiseORExpression
`|` BitwiseXORExpression 1. Return ?
EvaluateStringOrNumericBinaryExpression(\|BitwiseORExpression\|, `|`,
\|BitwiseXORExpression\|).

13.13 Binary Logical Operators
------------------------------


**Syntax**


LogicalANDExpression[In, Yield, Await] : BitwiseORExpression[?In,
?Yield, ?Await] LogicalANDExpression[?In, ?Yield, ?Await] `&&`
BitwiseORExpression[?In, ?Yield, ?Await] LogicalORExpression[In, Yield,
Await] : LogicalANDExpression[?In, ?Yield, ?Await]
LogicalORExpression[?In, ?Yield, ?Await] `||`
LogicalANDExpression[?In, ?Yield, ?Await] CoalesceExpression[In, Yield,
Await] : CoalesceExpressionHead[?In, ?Yield, ?Await] `??`
BitwiseORExpression[?In, ?Yield, ?Await] CoalesceExpressionHead[In,
Yield, Await] : CoalesceExpression[?In, ?Yield, ?Await]
BitwiseORExpression[?In, ?Yield, ?Await] ShortCircuitExpression[In,
Yield, Await] : LogicalORExpression[?In, ?Yield, ?Await]
CoalesceExpression[?In, ?Yield, ?Await]

The value produced by a `&&` or `||` operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.



Runtime Semantics: Evaluation
-----------------------------

LogicalANDExpression : LogicalANDExpression `&&` BitwiseORExpression
1. Let lRef be ? Evaluation of \|LogicalANDExpression\|. 1. Let
lVal be ? GetValue(lRef). 1. If ToBoolean(lVal) is
`false`, return lVal. 1. Let rRef be ? Evaluation of
\|BitwiseORExpression\|. 1. Return ? GetValue(rRef).
LogicalORExpression : LogicalORExpression `||` LogicalANDExpression 1.
Let lRef be ? Evaluation of \|LogicalORExpression\|. 1. Let lVal
be ? GetValue(lRef). 1. If ToBoolean(lVal) is `true`, return
lVal. 1. Let rRef be ? Evaluation of \|LogicalANDExpression\|.
1. Return ? GetValue(rRef). CoalesceExpression :
CoalesceExpressionHead `??` BitwiseORExpression 1. Let lRef be ?
Evaluation of `CoalesceExpressionHead`. 1. Let lVal be ?
GetValue(lRef). 1. If lVal is either `undefined` or `null`,
then 1. Let rRef be ? Evaluation of \|BitwiseORExpression\|. 1.
Return ? GetValue(rRef). 1. Else, 1. Return lVal.

13.14 Conditional Operator ( ? : )
----------------------------------


**Syntax**


ConditionalExpression[In, Yield, Await] : ShortCircuitExpression[?In,
?Yield, ?Await] ShortCircuitExpression[?In, ?Yield, ?Await] `?`
AssignmentExpression[+In, ?Yield, ?Await] `:`
AssignmentExpression[?In, ?Yield, ?Await]

The grammar for a `ConditionalExpression` in ECMAScript is slightly
different from that in C and Java, which each allow the second
subexpression to be an `Expression` but restrict the third expression
to be a `ConditionalExpression`. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.



Runtime Semantics: Evaluation
-----------------------------

ConditionalExpression : ShortCircuitExpression `?`
AssignmentExpression `:` AssignmentExpression 1. Let lRef be ?
Evaluation of `ShortCircuitExpression`. 1. Let lVal be ToBoolean(?
GetValue(lRef)). 1. If lVal is `true`, then 1. Let trueRef
be ? Evaluation of the first `AssignmentExpression`. 1. Return ?
GetValue(trueRef). 1. Else, 1. Let falseRef be ? Evaluation of
the second `AssignmentExpression`. 1. Return ? GetValue(falseRef).

13.15 Assignment Operators
--------------------------


**Syntax**


AssignmentExpression[In, Yield, Await] : ConditionalExpression[?In,
?Yield, ?Await] [+Yield] YieldExpression[?In, ?Await] ArrowFunction[?In,
?Yield, ?Await] AsyncArrowFunction[?In, ?Yield, ?Await]
LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In,
?Yield, ?Await] #assignment LeftHandSideExpression[?Yield, ?Await]
AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
LeftHandSideExpression[?Yield, ?Await] `&&=` AssignmentExpression[?In,
?Yield, ?Await] LeftHandSideExpression[?Yield, ?Await] `||=`
AssignmentExpression[?In, ?Yield, ?Await] LeftHandSideExpression[?Yield,
?Await] `??=` AssignmentExpression[?In, ?Yield, ?Await] // emu-format
ignore AssignmentOperator : one of `*=` `/=` `%=` `+=` `-=`
`<<=` `>>=` `>>>=` `&=` `^=` `|=` `**=`


Static Semantics: Early Errors
------------------------------

AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression

- If `LeftHandSideExpression` is either an `ObjectLiteral` or an
  `ArrayLiteral`, `LeftHandSideExpression` must cover an
  `AssignmentPattern`.
- If `LeftHandSideExpression` is neither an `ObjectLiteral` nor an
  `ArrayLiteral`, it is a Syntax Error if the AssignmentTargetType of
  `LeftHandSideExpression` is not ~simple~.

AssignmentExpression : LeftHandSideExpression AssignmentOperator
AssignmentExpression LeftHandSideExpression `&&=` AssignmentExpression
LeftHandSideExpression `||=` AssignmentExpression
LeftHandSideExpression `??=` AssignmentExpression

- It is a Syntax Error if the AssignmentTargetType of
  `LeftHandSideExpression` is not ~simple~.



Runtime Semantics: Evaluation
-----------------------------

AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression
1. If `LeftHandSideExpression` is neither an `ObjectLiteral` nor an
`ArrayLiteral`, then 1. Let lRef be ? Evaluation of
`LeftHandSideExpression`. 1. If
IsAnonymousFunctionDefinition(`AssignmentExpression`) is `true` and
IsIdentifierRef of `LeftHandSideExpression` is `true`, then 1. Let
lhs be the StringValue of `LeftHandSideExpression`. 1. Let
rVal be ? NamedEvaluation of `AssignmentExpression` with argument
lhs. 1. Else, 1. Let rRef be ? Evaluation of
`AssignmentExpression`. 1. Let rVal be ? GetValue(rRef). 1.
[id="step-assignmentexpression-evaluation-simple-putvalue"] Perform ?
PutValue(lRef, rVal). 1. Return rVal. 1. Let
assignmentPattern be the `AssignmentPattern` that is covered by
`LeftHandSideExpression`. 1. Let rRef be ? Evaluation of
`AssignmentExpression`. 1. Let rVal be ? GetValue(rRef). 1.
Perform ? DestructuringAssignmentEvaluation of assignmentPattern
with argument rVal. 1. Return rVal. AssignmentExpression :
LeftHandSideExpression AssignmentOperator AssignmentExpression 1. Let
lRef be ? Evaluation of `LeftHandSideExpression`. 1.
[id="step-assignmentexpression-evaluation-compound-getvalue"] Let
lVal be ? GetValue(lRef). 1. Let rRef be ? Evaluation of
`AssignmentExpression`. 1. Let rVal be ? GetValue(rRef). 1.
Let assignmentOpText be the source text matched by
`AssignmentOperator`. 1. Let opText be the sequence of Unicode
code points associated with assignmentOpText in the following table:

.. container:: float

   ==================== ==========
   assignmentOpText opText
   ==================== ==========
   `**=`              `**`
   `*=`               `*`
   `/=`               `/`
   `%=`               `%`
   `+=`               `+`
   `-=`               `-`
   `<<=`              `<<`
   `>>=`              `>>`
   `>>>=`             `>>>`
   `&=`               `&`
   `^=`               `^`
   `|=`               `|`
   ==================== ==========

1. Let r be ? ApplyStringOrNumericBinaryOperator(lVal,
opText, rVal). 1.
[id="step-assignmentexpression-evaluation-compound-putvalue"] Perform ?
PutValue(lRef, r). 1. Return r. AssignmentExpression :
LeftHandSideExpression `&&=` AssignmentExpression 1. Let lRef be ?
Evaluation of `LeftHandSideExpression`. 1.
[id="step-assignmentexpression-evaluation-lgcl-and-getvalue"] Let
lVal be ? GetValue(lRef). 1. If ToBoolean(lVal) is
`false`, return lVal. 1. If
IsAnonymousFunctionDefinition(`AssignmentExpression`) is `true` and
IsIdentifierRef of `LeftHandSideExpression` is `true`, then 1. Let
lhs be the StringValue of `LeftHandSideExpression`. 1. Let
rVal be ? NamedEvaluation of `AssignmentExpression` with argument
lhs. 1. Else, 1. Let rRef be ? Evaluation of
`AssignmentExpression`. 1. Let rVal be ? GetValue(rRef). 1.
[id="step-assignmentexpression-evaluation-lgcl-and-putvalue"] Perform ?
PutValue(lRef, rVal). 1. Return rVal. AssignmentExpression :
LeftHandSideExpression `||=` AssignmentExpression 1. Let lRef be ?
Evaluation of `LeftHandSideExpression`. 1.
[id="step-assignmentexpression-evaluation-lgcl-or-getvalue"] Let
lVal be ? GetValue(lRef). 1. If ToBoolean(lVal) is `true`,
return lVal. 1. If
IsAnonymousFunctionDefinition(`AssignmentExpression`) is `true` and
IsIdentifierRef of `LeftHandSideExpression` is `true`, then 1. Let
lhs be the StringValue of `LeftHandSideExpression`. 1. Let
rVal be ? NamedEvaluation of `AssignmentExpression` with argument
lhs. 1. Else, 1. Let rRef be ? Evaluation of
`AssignmentExpression`. 1. Let rVal be ? GetValue(rRef). 1.
[id="step-assignmentexpression-evaluation-lgcl-or-putvalue"] Perform ?
PutValue(lRef, rVal). 1. Return rVal. AssignmentExpression :
LeftHandSideExpression `??=` AssignmentExpression 1. Let lRef be ?
Evaluation of `LeftHandSideExpression`. 1.
[id="step-assignmentexpression-evaluation-lgcl-nullish-getvalue"] Let
lVal be ? GetValue(lRef). 1. If lVal is neither
`undefined` nor `null`, return lVal. 1. If
IsAnonymousFunctionDefinition(`AssignmentExpression`) is `true` and
IsIdentifierRef of `LeftHandSideExpression` is `true`, then 1. Let
lhs be the StringValue of `LeftHandSideExpression`. 1. Let
rVal be ? NamedEvaluation of `AssignmentExpression` with argument
lhs. 1. Else, 1. Let rRef be ? Evaluation of
`AssignmentExpression`. 1. Let rVal be ? GetValue(rRef). 1.
[id="step-assignmentexpression-evaluation-lgcl-nullish-putvalue"]
Perform ? PutValue(lRef, rVal). 1. Return rVal.

When this expression occurs within strict mode code, it is a runtime
error if lRef in step , , , , is an unresolvable reference. If it
is, a `ReferenceError` exception is thrown. Additionally, it is a
runtime error if the lRef in step , , , is a reference to a data
property with the attribute value { [[Writable]]: `false` }, to an
accessor property with the attribute value { [[Set]]: `undefined` },
or to a non-existent property of an object for which the IsExtensible
predicate returns the value `false`. In these cases a `TypeError`
exception is thrown.

ApplyStringOrNumericBinaryOperator ( lVal, opText: `**`, `*`, `/`, `%`, `+`, `-`, `<<`, `>>`, `>>>`, `&`, `^`, or `|`, rVal, )
------------------------------------------------------------------------------------------------------------------------------

1. If opText is `+`, then 1.
[id="step-binary-op-toprimitive-lval"] Let lPrim be ?
ToPrimitive(lVal). 1. [id="step-binary-op-toprimitive-rval"] Let
rPrim be ? ToPrimitive(rVal). 1.
[id="step-binary-op-string-check"] If lPrim is a String or rPrim
is a String, then 1. Let lStr be ? ToString(lPrim). 1. Let
rStr be ? ToString(rPrim). 1. Return the string-concatenation of
lStr and rStr. 1. Set lVal to lPrim. 1. Set rVal to
rPrim. 1. NOTE: At this point, it must be a numeric operation. 1.
Let lNum be ? ToNumeric(lVal). 1. Let rNum be ?
ToNumeric(rVal). 1. If SameType(lNum, rNum) is `false`,
throw a `TypeError` exception. 1. If lNum is a BigInt, then 1. If
opText is `**`, return ? BigInt::exponentiate(lNum, rNum).
1. If opText is `/`, return ? BigInt::divide(lNum, rNum).
1. If opText is `%`, return ? BigInt::remainder(lNum,
rNum). 1. If opText is `>>>`, return ?
BigInt::unsignedRightShift(lNum, rNum). 1. Let operation be
the abstract operation associated with opText in the following
table:

.. container:: float

   ========== ========================
   opText operation
   ========== ========================
   `*`      BigInt::multiply
   `+`      BigInt::add
   `-`      BigInt::subtract
   `<<`     BigInt::leftShift
   `>>`     BigInt::signedRightShift
   `&`      BigInt::bitwiseAND
   `^`      BigInt::bitwiseXOR
   `|`      BigInt::bitwiseOR
   ========== ========================

1. Else, 1. Assert: lNum is a Number. 1. Let operation be the
abstract operation associated with opText in the following table:

.. container:: float

   ========== ==========================
   opText operation
   ========== ==========================
   `**`     Number::exponentiate
   `*`      Number::multiply
   `/`      Number::divide
   `%`      Number::remainder
   `+`      Number::add
   `-`      Number::subtract
   `<<`     Number::leftShift
   `>>`     Number::signedRightShift
   `>>>`    Number::unsignedRightShift
   `&`      Number::bitwiseAND
   `^`      Number::bitwiseXOR
   `|`      Number::bitwiseOR
   ========== ==========================

1. Return operation(lNum, rNum).

No hint is provided in the calls to ToPrimitive in steps and . All
standard objects except Dates handle the absence of a hint as if
~number~ were given; Dates handle the absence of a hint as if ~string~
were given. Exotic objects may handle the absence of a hint in some
other manner.

Step differs from step of the IsLessThan algorithm, by using the
logical-or operation instead of the logical-and operation.

EvaluateStringOrNumericBinaryExpression ( leftOperand: a Parse Node, opText: a sequence of Unicode code points, rightOperand: a Parse Node, )
---------------------------------------------------------------------------------------------------------------------------------------------

1. Let lRef be ? Evaluation of leftOperand. 1. Let lVal be ?
GetValue(lRef). 1. Let rRef be ? Evaluation of rightOperand.
1. Let rVal be ? GetValue(rRef). 1. Return ?
ApplyStringOrNumericBinaryOperator(lVal, opText, rVal).

Destructuring Assignment
------------------------

.. _supplemental-syntax-2:

**Supplemental Syntax**

| In certain circumstances when processing an instance of the production
| AssignmentExpression : LeftHandSideExpression `=`
  AssignmentExpression
| the interpretation of `LeftHandSideExpression` is refined using the
  following grammar:

AssignmentPattern[Yield, Await] : ObjectAssignmentPattern[?Yield,
?Await] ArrayAssignmentPattern[?Yield, ?Await]
ObjectAssignmentPattern[Yield, Await] : `{` `}` `{`
AssignmentRestProperty[?Yield, ?Await] `}` `{`
AssignmentPropertyList[?Yield, ?Await] `}` `{`
AssignmentPropertyList[?Yield, ?Await] `,`
AssignmentRestProperty[?Yield, ?Await]? `}`
ArrayAssignmentPattern[Yield, Await] : `[` Elision?
AssignmentRestElement[?Yield, ?Await]? `]` `[`
AssignmentElementList[?Yield, ?Await] `]` `[`
AssignmentElementList[?Yield, ?Await] `,` Elision?
AssignmentRestElement[?Yield, ?Await]? `]`
AssignmentRestProperty[Yield, Await] : `...`
DestructuringAssignmentTarget[?Yield, ?Await]
AssignmentPropertyList[Yield, Await] : AssignmentProperty[?Yield,
?Await] AssignmentPropertyList[?Yield, ?Await] `,`
AssignmentProperty[?Yield, ?Await] AssignmentElementList[Yield, Await] :
AssignmentElisionElement[?Yield, ?Await] AssignmentElementList[?Yield,
?Await] `,` AssignmentElisionElement[?Yield, ?Await]
AssignmentElisionElement[Yield, Await] : Elision?
AssignmentElement[?Yield, ?Await] AssignmentProperty[Yield, Await] :
IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]
AssignmentElement[Yield, Await] : DestructuringAssignmentTarget[?Yield,
?Await] Initializer[+In, ?Yield, ?Await]? AssignmentRestElement[Yield,
Await] : `...` DestructuringAssignmentTarget[?Yield, ?Await]
DestructuringAssignmentTarget[Yield, Await] :
LeftHandSideExpression[?Yield, ?Await]


Static Semantics: Early Errors
------------------------------

AssignmentProperty : IdentifierReference Initializer?

- It is a Syntax Error if the AssignmentTargetType of
  `IdentifierReference` is not ~simple~.

AssignmentRestProperty : `...` DestructuringAssignmentTarget

- It is a Syntax Error if `DestructuringAssignmentTarget` is either an
  `ArrayLiteral` or an `ObjectLiteral`.

DestructuringAssignmentTarget : LeftHandSideExpression

- If `LeftHandSideExpression` is either an `ObjectLiteral` or an
  `ArrayLiteral`, `LeftHandSideExpression` must cover an
  `AssignmentPattern`.
- If `LeftHandSideExpression` is neither an `ObjectLiteral` nor an
  `ArrayLiteral`, it is a Syntax Error if the AssignmentTargetType of
  `LeftHandSideExpression` is not ~simple~.

Runtime Semantics: DestructuringAssignmentEvaluation ( value, )
---------------------------------------------------------------

ObjectAssignmentPattern : `{` `}` 1. Perform ?
RequireObjectCoercible(value). 1. Return ~unused~.
ObjectAssignmentPattern : `{` AssignmentPropertyList `}` `{`
AssignmentPropertyList `,` `}` 1. Perform ?
RequireObjectCoercible(value). 1. Perform ?
PropertyDestructuringAssignmentEvaluation of `AssignmentPropertyList`
with argument value. 1. Return ~unused~. ObjectAssignmentPattern :
`{` AssignmentRestProperty `}` 1. Perform ?
RequireObjectCoercible(value). 1. Let excludedNames be a new
empty List. 1. Return ? RestDestructuringAssignmentEvaluation of
`AssignmentRestProperty` with arguments value and
excludedNames. ObjectAssignmentPattern : `{`
AssignmentPropertyList `,` AssignmentRestProperty `}` 1. Perform ?
RequireObjectCoercible(value). 1. Let excludedNames be ?
PropertyDestructuringAssignmentEvaluation of `AssignmentPropertyList`
with argument value. 1. Return ?
RestDestructuringAssignmentEvaluation of `AssignmentRestProperty` with
arguments value and excludedNames. ArrayAssignmentPattern :
`[` `]` 1. Let iteratorRecord be ? GetIterator(value,
~sync~). 1. Return ? IteratorClose(iteratorRecord,
NormalCompletion(~unused~)). ArrayAssignmentPattern : `[` Elision
`]` 1. Let iteratorRecord be ? GetIterator(value, ~sync~). 1.
Let result be Completion(IteratorDestructuringAssignmentEvaluation
of `Elision` with argument iteratorRecord). 1. If
iteratorRecord.[[Done]] is `false`, return ?
IteratorClose(iteratorRecord, result). 1. Return result.
ArrayAssignmentPattern : `[` Elision? AssignmentRestElement `]` 1.
Let iteratorRecord be ? GetIterator(value, ~sync~). 1. If
`Elision` is present, then 1. Let status be
Completion(IteratorDestructuringAssignmentEvaluation of `Elision` with
argument iteratorRecord). 1. If status is an abrupt completion,
then 1. Assert: iteratorRecord.[[Done]] is `true`. 1. Return ?
status. 1. Let result be
Completion(IteratorDestructuringAssignmentEvaluation of
`AssignmentRestElement` with argument iteratorRecord). 1. If
iteratorRecord.[[Done]] is `false`, return ?
IteratorClose(iteratorRecord, result). 1. Return result.
ArrayAssignmentPattern : `[` AssignmentElementList `]` 1. Let
iteratorRecord be ? GetIterator(value, ~sync~). 1. Let
result be Completion(IteratorDestructuringAssignmentEvaluation of
`AssignmentElementList` with argument iteratorRecord). 1. If
iteratorRecord.[[Done]] is `false`, return ?
IteratorClose(iteratorRecord, result). 1. Return result.
ArrayAssignmentPattern : `[` AssignmentElementList `,` Elision?
AssignmentRestElement? `]` 1. Let iteratorRecord be ?
GetIterator(value, ~sync~). 1. Let status be
Completion(IteratorDestructuringAssignmentEvaluation of
`AssignmentElementList` with argument iteratorRecord). 1. If
status is an abrupt completion, then 1. If
iteratorRecord.[[Done]] is `false`, return ?
IteratorClose(iteratorRecord, status). 1. Return ? status.
1. If `Elision` is present, then 1. Set status to
Completion(IteratorDestructuringAssignmentEvaluation of `Elision` with
argument iteratorRecord). 1. If status is an abrupt completion,
then 1. Assert: iteratorRecord.[[Done]] is `true`. 1. Return ?
status. 1. If `AssignmentRestElement` is present, then 1. Set
status to Completion(IteratorDestructuringAssignmentEvaluation of
`AssignmentRestElement` with argument iteratorRecord). 1. If
iteratorRecord.[[Done]] is `false`, return ?
IteratorClose(iteratorRecord, status). 1. Return ? status.

Runtime Semantics: PropertyDestructuringAssignmentEvaluation ( value, )
-----------------------------------------------------------------------

description
   It collects a list of all destructured property keys.

AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty
1. Let propertyNames be ? PropertyDestructuringAssignmentEvaluation
of `AssignmentPropertyList` with argument value. 1. Let
nextNames be ? PropertyDestructuringAssignmentEvaluation of
`AssignmentProperty` with argument value. 1. Return the
list-concatenation of propertyNames and nextNames.
AssignmentProperty : IdentifierReference Initializer? 1. Let P be
the StringValue of `IdentifierReference`. 1. Let lRef be ?
ResolveBinding(P). 1. Let v be ? GetV(value, P). 1. If
`Initializer` is present and v is `undefined`, then 1. If
IsAnonymousFunctionDefinition(`Initializer`) is `true`, then 1. Set
v to ? NamedEvaluation of `Initializer` with argument P. 1.
Else, 1. Let defaultValue be ? Evaluation of `Initializer`. 1. Set
v to ? GetValue(defaultValue). 1. Perform ? PutValue(lRef,
v). 1. Return « P ». AssignmentProperty : PropertyName `:`
AssignmentElement 1. Let name be ? Evaluation of `PropertyName`.
1. Perform ? KeyedDestructuringAssignmentEvaluation of
`AssignmentElement` with arguments value and name. 1. Return «
name ».

Runtime Semantics: RestDestructuringAssignmentEvaluation ( value, excludedNames: a List of property keys, )
-----------------------------------------------------------------------------------------------------------

AssignmentRestProperty : `...` DestructuringAssignmentTarget 1. Let
lRef be ? Evaluation of `DestructuringAssignmentTarget`. 1. Let
restObj be OrdinaryObjectCreate(%Object.prototype%). 1. Perform ?
CopyDataProperties(restObj, value, excludedNames). 1. Return
? PutValue(lRef, restObj).

Runtime Semantics: IteratorDestructuringAssignmentEvaluation ( iteratorRecord: an Iterator Record, )
----------------------------------------------------------------------------------------------------

AssignmentElementList : AssignmentElisionElement 1. Return ?
IteratorDestructuringAssignmentEvaluation of
`AssignmentElisionElement` with argument iteratorRecord.
AssignmentElementList : AssignmentElementList `,`
AssignmentElisionElement 1. Perform ?
IteratorDestructuringAssignmentEvaluation of `AssignmentElementList`
with argument iteratorRecord. 1. Return ?
IteratorDestructuringAssignmentEvaluation of
`AssignmentElisionElement` with argument iteratorRecord.
AssignmentElisionElement : AssignmentElement 1. Return ?
IteratorDestructuringAssignmentEvaluation of `AssignmentElement` with
argument iteratorRecord. AssignmentElisionElement : Elision
AssignmentElement 1. Perform ? IteratorDestructuringAssignmentEvaluation
of `Elision` with argument iteratorRecord. 1. Return ?
IteratorDestructuringAssignmentEvaluation of `AssignmentElement` with
argument iteratorRecord. Elision : `,` 1. If
iteratorRecord.[[Done]] is `false`, then 1. Perform ?
IteratorStep(iteratorRecord). 1. Return ~unused~. Elision : Elision
`,` 1. Perform ? IteratorDestructuringAssignmentEvaluation of
`Elision` with argument iteratorRecord. 1. If
iteratorRecord.[[Done]] is `false`, then 1. Perform ?
IteratorStep(iteratorRecord). 1. Return ~unused~. AssignmentElement
: DestructuringAssignmentTarget Initializer? 1. If
`DestructuringAssignmentTarget` is neither an `ObjectLiteral` nor an
`ArrayLiteral`, then 1. Let lRef be ? Evaluation of
`DestructuringAssignmentTarget`. 1. Let value be `undefined`. 1.
If iteratorRecord.[[Done]] is `false`, then 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is not ~done~,
then 1. Set value to next. 1. If `Initializer` is present and
value is `undefined`, then 1. If
IsAnonymousFunctionDefinition(`Initializer`) is `true` and
IsIdentifierRef of `DestructuringAssignmentTarget` is `true`, then
1. Let target be the StringValue of
`DestructuringAssignmentTarget`. 1. Let v be ? NamedEvaluation of
`Initializer` with argument target. 1. Else, 1. Let
defaultValue be ? Evaluation of `Initializer`. 1. Let v be ?
GetValue(defaultValue). 1. Else, 1. Let v be value. 1. If
`DestructuringAssignmentTarget` is either an `ObjectLiteral` or an
`ArrayLiteral`, then 1. Let nestedAssignmentPattern be the
`AssignmentPattern` that is covered by
`DestructuringAssignmentTarget`. 1. Return ?
DestructuringAssignmentEvaluation of nestedAssignmentPattern with
argument v. 1. Return ? PutValue(lRef, v).

Left to right evaluation order is maintained by evaluating a
`DestructuringAssignmentTarget` that is not a destructuring pattern
prior to accessing the iterator or evaluating the `Initializer`.

AssignmentRestElement : `...` DestructuringAssignmentTarget 1. If
`DestructuringAssignmentTarget` is neither an `ObjectLiteral` nor an
`ArrayLiteral`, then 1. Let lRef be ? Evaluation of
`DestructuringAssignmentTarget`. 1. Let A be ! ArrayCreate(0). 1.
Let n be 0. 1. Repeat, while iteratorRecord.[[Done]] is
`false`, 1. Let next be ? IteratorStepValue(iteratorRecord).
1. If next is not ~done~, then 1. Perform !
CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), next). 1. Set
n to n + 1. 1. If `DestructuringAssignmentTarget` is neither
an `ObjectLiteral` nor an `ArrayLiteral`, then 1. Return ?
PutValue(lRef, A). 1. Let nestedAssignmentPattern be the
`AssignmentPattern` that is covered by
`DestructuringAssignmentTarget`. 1. Return ?
DestructuringAssignmentEvaluation of nestedAssignmentPattern with
argument A.

Runtime Semantics: KeyedDestructuringAssignmentEvaluation ( value, propertyName: a property key, )
--------------------------------------------------------------------------------------------------

AssignmentElement : DestructuringAssignmentTarget Initializer? 1. If
`DestructuringAssignmentTarget` is neither an `ObjectLiteral` nor an
`ArrayLiteral`, then 1. Let lRef be ? Evaluation of
`DestructuringAssignmentTarget`. 1. Let v be ? GetV(value,
propertyName). 1. If `Initializer` is present and v is
`undefined`, then 1. If IsAnonymousFunctionDefinition(`Initializer`)
is `true` and IsIdentifierRef of `DestructuringAssignmentTarget` is
`true`, then 1. Let target be the StringValue of
`DestructuringAssignmentTarget`. 1. Let rhsValue be ?
NamedEvaluation of `Initializer` with argument target. 1. Else, 1.
Let defaultValue be ? Evaluation of `Initializer`. 1. Let
rhsValue be ? GetValue(defaultValue). 1. Else, 1. Let
rhsValue be v. 1. If `DestructuringAssignmentTarget` is either
an `ObjectLiteral` or an `ArrayLiteral`, then 1. Let
assignmentPattern be the `AssignmentPattern` that is covered by
`DestructuringAssignmentTarget`. 1. Return ?
DestructuringAssignmentEvaluation of assignmentPattern with argument
rhsValue. 1. Return ? PutValue(lRef, rhsValue).

13.16 Comma Operator ( , )
--------------------------


**Syntax**


Expression[In, Yield, Await] : AssignmentExpression[?In, ?Yield, ?Await]
Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield,
?Await]



Runtime Semantics: Evaluation
'''''''''''''''''''''''''''''

Expression : Expression `,` AssignmentExpression 1. Let lRef be ?
Evaluation of `Expression`. 1. Perform ? GetValue(lRef). 1. Let
rRef be ? Evaluation of `AssignmentExpression`. 1. Return ?
GetValue(rRef).

GetValue must be called even though its value is not used because it may
have observable side-effects.

14. ECMAScript Language: Statements and Declarations
====================================================

https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html
::

   14.1 Statement Semantics
      14.1.1 RS: Evaluation
   14.2 Block
      14.2.1 SS: Early Errors
      14.2.2 RS: Evaluation
      14.2.3 BlockDeclarationInstantiation ( code, env )
   14.3 Declarations and the Variable Statement
      14.3.1 Let and Const Declarations
         14.3.1.1 SS: Early Errors
         14.3.1.2 RS: Evaluation
      14.3.2 Variable Statement
         14.3.2.1 RS: Evaluation
      14.3.3 Destructuring Binding Patterns
         14.3.3.1 RS: PropertyBindingInitialization
         14.3.3.2 RS: RestBindingInitialization
         14.3.3.3 RS: KeyedBindingInitialization
   14.4 Empty Statement
      14.4.1 RS: Evaluation
   14.5 Expression Statement
      14.5.1 RS: Evaluation
   14.6 The if Statement
      14.6.1 SS: Early Errors
      14.6.2 RS: Evaluation
   14.7 Iteration Statements
      14.7.1 Semantics
         14.7.1.1 LoopContinues ( completion, labelSet )
         14.7.1.2 RS: LoopEvaluation
      14.7.2 The do-while Statement
         14.7.2.1 SS: Early Errors
         14.7.2.2 RS: DoWhileLoopEvaluation
      14.7.3 The while Statement
         14.7.3.1 SS: Early Errors
         14.7.3.2 RS: WhileLoopEvaluation
      14.7.4 The for Statement
         14.7.4.1 SS: Early Errors
         14.7.4.2 RS: ForLoopEvaluation
         14.7.4.3 ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet )
         14.7.4.4 CreatePerIterationEnvironment ( perIterationBindings )
      14.7.5 The for-in, for-of, and for-await-of Statements
         14.7.5.1 SS: Early Errors
         14.7.5.2 SS: IsDestructuring
         14.7.5.3 RS: ForDeclarationBindingInitialization
         14.7.5.4 RS: ForDeclarationBindingInstantiation
         14.7.5.5 RS: ForInOfLoopEvaluation
         14.7.5.6 ForIn/OfHeadEvaluation ( uninitializedBoundNames, expr, iterationKind )
         14.7.5.7 ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [ , iteratorKind ] )
         14.7.5.8 RS: Evaluation
         14.7.5.9 EnumerateObjectProperties ( O )
            14.7.5.10 For-In Iterator Objects
            14.7.5.10.1 CreateForInIterator ( object )
            14.7.5.10.2 The %ForInIteratorPrototype% Object
            14.7.5.10.2.1 %ForInIteratorPrototype%.next ( )
            14.7.5.10.3 Properties of For-In Iterator Instances
   14.8 The continue Statement
      14.8.1 SS: Early Errors
      14.8.2 RS: Evaluation
   14.9 The break Statement
      14.9.1 SS: Early Errors
      14.9.2 RS: Evaluation
   14.10 The return Statement
      14.10.1 RS: Evaluation
   14.11 The with Statement
      14.11.1 SS: Early Errors
      14.11.2 RS: Evaluation
   14.12 The switch Statement
      14.12.1 SS: Early Errors
      14.12.2 RS: CaseBlockEvaluation
      14.12.3 CaseClauseIsSelected ( C, input )
      14.12.4 RS: Evaluation
   14.13 Labelled Statements
      14.13.1 SS: Early Errors
      14.13.2 SS: IsLabelledFunction ( stmt )
      14.13.3 RS: Evaluation
      14.13.4 RS: LabelledEvaluation
   14.14 The throw Statement
      14.14.1 RS: Evaluation
   14.15 The try Statement
      14.15.1 SS: Early Errors
      14.15.2 RS: CatchClauseEvaluation
      14.15.3 RS: Evaluation
   14.16 The debugger Statement
      14.16.1 RS: Evaluation


**Syntax**


Statement[Yield, Await, Return] : BlockStatement[?Yield, ?Await,
?Return] VariableStatement[?Yield, ?Await] EmptyStatement
ExpressionStatement[?Yield, ?Await] IfStatement[?Yield, ?Await, ?Return]
BreakableStatement[?Yield, ?Await, ?Return] ContinueStatement[?Yield,
?Await] BreakStatement[?Yield, ?Await] [+Return] ReturnStatement[?Yield,
?Await] WithStatement[?Yield, ?Await, ?Return] LabelledStatement[?Yield,
?Await, ?Return] ThrowStatement[?Yield, ?Await] TryStatement[?Yield,
?Await, ?Return] DebuggerStatement Declaration[Yield, Await] :
HoistableDeclaration[?Yield, ?Await, ~Default] ClassDeclaration[?Yield,
?Await, ~Default] LexicalDeclaration[+In, ?Yield, ?Await]
HoistableDeclaration[Yield, Await, Default] :
FunctionDeclaration[?Yield, ?Await, ?Default]
GeneratorDeclaration[?Yield, ?Await, ?Default]
AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]
BreakableStatement[Yield, Await, Return] : IterationStatement[?Yield,
?Await, ?Return] SwitchStatement[?Yield, ?Await, ?Return]

Statement Semantics
-------------------



Runtime Semantics: Evaluation
-----------------------------

HoistableDeclaration : GeneratorDeclaration AsyncFunctionDeclaration
AsyncGeneratorDeclaration 1. Return ~empty~. HoistableDeclaration :
FunctionDeclaration 1. Return ? Evaluation of `FunctionDeclaration`.
BreakableStatement : IterationStatement SwitchStatement 1. Let
newLabelSet be a new empty List. 1. Return ? LabelledEvaluation of
this `BreakableStatement` with argument newLabelSet.

Block
-----


**Syntax**


BlockStatement[Yield, Await, Return] : Block[?Yield, ?Await, ?Return]
Block[Yield, Await, Return] : `{` StatementList[?Yield, ?Await,
?Return]? `}` StatementList[Yield, Await, Return] :
StatementListItem[?Yield, ?Await, ?Return] StatementList[?Yield, ?Await,
?Return] StatementListItem[?Yield, ?Await, ?Return]
StatementListItem[Yield, Await, Return] : Statement[?Yield, ?Await,
?Return] Declaration[?Yield, ?Await]


Static Semantics: Early Errors
------------------------------

Block : `{` StatementList `}`

- It is a Syntax Error if the LexicallyDeclaredNames of
  `StatementList` contains any duplicate entries.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `StatementList` also occurs in the VarDeclaredNames of
  `StatementList`.



Runtime Semantics: Evaluation
-----------------------------

Block : `{` `}` 1. Return ~empty~. Block : `{` StatementList `}`
1. Let oldEnv be the running execution context's LexicalEnvironment.
1. Let blockEnv be NewDeclarativeEnvironment(oldEnv). 1. Perform
BlockDeclarationInstantiation(`StatementList`, blockEnv). 1. Set
the running execution context's LexicalEnvironment to blockEnv. 1.
Let blockValue be Completion(Evaluation of `StatementList`). 1.
Set the running execution context's LexicalEnvironment to oldEnv. 1.
Return ? blockValue.

No matter how control leaves the `Block` the LexicalEnvironment is
always restored to its former state.

StatementList : StatementList StatementListItem 1. Let sl be ?
Evaluation of `StatementList`. 1. Let s be Completion(Evaluation
of `StatementListItem`). 1. Return ? UpdateEmpty(s, sl).

The value of a `StatementList` is the value of the last
value-producing item in the `StatementList`. For example, the
following calls to the `eval` function all return the value 1:

.. code:: javascript

             eval("1;;;;;")
             eval("1;{}")
             eval("1;var a;")
           

BlockDeclarationInstantiation ( code: a Parse Node, env: a Declarative Environment Record, ): ~unused~
--------------------------------------------------------------------------------------------------------------

description
   code is the Parse Node corresponding to the body of the block.
   env is the Environment Record in which bindings are to be
   created.

When a `Block` or `CaseBlock` is evaluated a new Declarative
Environment Record is created and bindings for each block scoped
variable, constant, function, or class declared in the block are
instantiated in the Environment Record.

It performs the following steps when called:

1. Let declarations be the LexicallyScopedDeclarations of code.
1. Let privateEnv be the running execution context's
PrivateEnvironment. 1. For each element d of declarations, do 1.
For each element dn of the BoundNames of d, do 1. If
IsConstantDeclaration of d is `true`, then 1. Perform !
env.CreateImmutableBinding(dn, `true`). 1. Else, 1.
[id="step-blockdeclarationinstantiation-createmutablebinding"] Perform !
env.CreateMutableBinding(dn, `false`). NOTE: This step is
replaced in section . 1. If d is either a `FunctionDeclaration`, a
`GeneratorDeclaration`, an `AsyncFunctionDeclaration`, or an
`AsyncGeneratorDeclaration`, then 1. Let fn be the sole element of
the BoundNames of d. 1. Let fo be InstantiateFunctionObject of
d with arguments env and privateEnv. 1.
[id="step-blockdeclarationinstantiation-initializebinding"] Perform !
env.InitializeBinding(fn, fo). NOTE: This step is replaced
in section . 1. Return ~unused~.

Declarations and the Variable Statement
---------------------------------------

Let and Const Declarations
--------------------------

`let` and `const` declarations define variables that are scoped to
the running execution context's LexicalEnvironment. The variables are
created when their containing Environment Record is instantiated but may
not be accessed in any way until the variable's `LexicalBinding` is
evaluated. A variable defined by a `LexicalBinding` with an
`Initializer` is assigned the value of its `Initializer`'s
`AssignmentExpression` when the `LexicalBinding` is evaluated, not
when the variable is created. If a `LexicalBinding` in a `let`
declaration does not have an `Initializer` the variable is assigned
the value `undefined` when the `LexicalBinding` is evaluated.


**Syntax**


LexicalDeclaration[In, Yield, Await] : LetOrConst BindingList[?In,
?Yield, ?Await] `;` LetOrConst : `let` `const` BindingList[In,
Yield, Await] : LexicalBinding[?In, ?Yield, ?Await] BindingList[?In,
?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]
LexicalBinding[In, Yield, Await] : BindingIdentifier[?Yield, ?Await]
Initializer[?In, ?Yield, ?Await]? BindingPattern[?Yield, ?Await]
Initializer[?In, ?Yield, ?Await]


Static Semantics: Early Errors
------------------------------

LexicalDeclaration : LetOrConst BindingList `;`

- It is a Syntax Error if the BoundNames of `BindingList` contains
  `"let"`.
- It is a Syntax Error if the BoundNames of `BindingList` contains any
  duplicate entries.

LexicalBinding : BindingIdentifier Initializer?

- It is a Syntax Error if `Initializer` is not present and
  IsConstantDeclaration of the `LexicalDeclaration` containing this
  `LexicalBinding` is `true`.



Runtime Semantics: Evaluation
-----------------------------

LexicalDeclaration : LetOrConst BindingList `;` 1. Perform ?
Evaluation of `BindingList`. 1. Return ~empty~. BindingList :
BindingList `,` LexicalBinding 1. Perform ? Evaluation of
`BindingList`. 1. Return ? Evaluation of `LexicalBinding`.
LexicalBinding : BindingIdentifier 1. Let lhs be !
ResolveBinding(StringValue of `BindingIdentifier`). 1. Perform !
InitializeReferencedBinding(lhs, `undefined`). 1. Return ~empty~.

A static semantics rule ensures that this form of `LexicalBinding`
never occurs in a `const` declaration.

LexicalBinding : BindingIdentifier Initializer 1. Let bindingId be
the StringValue of `BindingIdentifier`. 1. Let lhs be !
ResolveBinding(bindingId). 1. If
IsAnonymousFunctionDefinition(`Initializer`) is `true`, then 1. Let
value be ? NamedEvaluation of `Initializer` with argument
bindingId. 1. Else, 1. Let rhs be ? Evaluation of
`Initializer`. 1. Let value be ? GetValue(rhs). 1. Perform !
InitializeReferencedBinding(lhs, value). 1. Return ~empty~.
LexicalBinding : BindingPattern Initializer 1. Let rhs be ?
Evaluation of `Initializer`. 1. Let value be ? GetValue(rhs).
1. Let env be the running execution context's LexicalEnvironment. 1.
Return ? BindingInitialization of `BindingPattern` with arguments
value and env.

Variable Statement
------------------

A `var` statement declares variables that are scoped to the running
execution context's VariableEnvironment. Var variables are created when
their containing Environment Record is instantiated and are initialized
to `undefined` when created. Within the scope of any
VariableEnvironment a common `BindingIdentifier` may appear in more
than one `VariableDeclaration` but those declarations collectively
define only one variable. A variable defined by a
`VariableDeclaration` with an `Initializer` is assigned the value of
its `Initializer`'s `AssignmentExpression` when the
`VariableDeclaration` is executed, not when the variable is created.


**Syntax**


VariableStatement[Yield, Await] : `var` VariableDeclarationList[+In,
?Yield, ?Await] `;` VariableDeclarationList[In, Yield, Await] :
VariableDeclaration[?In, ?Yield, ?Await] VariableDeclarationList[?In,
?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]
VariableDeclaration[In, Yield, Await] : BindingIdentifier[?Yield,
?Await] Initializer[?In, ?Yield, ?Await]? BindingPattern[?Yield, ?Await]
Initializer[?In, ?Yield, ?Await]



Runtime Semantics: Evaluation
-----------------------------

VariableStatement : `var` VariableDeclarationList `;` 1. Perform ?
Evaluation of `VariableDeclarationList`. 1. Return ~empty~.
VariableDeclarationList : VariableDeclarationList `,`
VariableDeclaration 1. Perform ? Evaluation of
`VariableDeclarationList`. 1. Return ? Evaluation of
`VariableDeclaration`. VariableDeclaration : BindingIdentifier 1.
Return ~empty~. VariableDeclaration : BindingIdentifier Initializer 1.
Let bindingId be the StringValue of `BindingIdentifier`. 1. Let
lhs be ? ResolveBinding(bindingId). 1. If
IsAnonymousFunctionDefinition(`Initializer`) is `true`, then 1. Let
value be ? NamedEvaluation of `Initializer` with argument
bindingId. 1. Else, 1. Let rhs be ? Evaluation of
`Initializer`. 1. Let value be ? GetValue(rhs). 1.
[id="step-vardecllist-evaluation-putvalue"] Perform ? PutValue(lhs,
value). 1. Return ~empty~.

If a `VariableDeclaration` is nested within a with statement and the
`BindingIdentifier` in the `VariableDeclaration` is the same as a
property name of the binding object of the with statement's Object
Environment Record, then step will assign value to the property
instead of assigning to the VariableEnvironment binding of the
`Identifier`.

VariableDeclaration : BindingPattern Initializer 1. Let rhs be ?
Evaluation of `Initializer`. 1. Let rVal be ? GetValue(rhs).
1. Return ? BindingInitialization of `BindingPattern` with arguments
rVal and `undefined`.

Destructuring Binding Patterns
------------------------------


**Syntax**


BindingPattern[Yield, Await] : ObjectBindingPattern[?Yield, ?Await]
ArrayBindingPattern[?Yield, ?Await] ObjectBindingPattern[Yield, Await] :
`{` `}` `{` BindingRestProperty[?Yield, ?Await] `}` `{`
BindingPropertyList[?Yield, ?Await] `}` `{`
BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield,
?Await]? `}` ArrayBindingPattern[Yield, Await] : `[` Elision?
BindingRestElement[?Yield, ?Await]? `]` `[`
BindingElementList[?Yield, ?Await] `]` `[`
BindingElementList[?Yield, ?Await] `,` Elision?
BindingRestElement[?Yield, ?Await]? `]` BindingRestProperty[Yield,
Await] : `...` BindingIdentifier[?Yield, ?Await]
BindingPropertyList[Yield, Await] : BindingProperty[?Yield, ?Await]
BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield,
?Await] BindingElementList[Yield, Await] : BindingElisionElement[?Yield,
?Await] BindingElementList[?Yield, ?Await] `,`
BindingElisionElement[?Yield, ?Await] BindingElisionElement[Yield,
Await] : Elision? BindingElement[?Yield, ?Await] BindingProperty[Yield,
Await] : SingleNameBinding[?Yield, ?Await] PropertyName[?Yield, ?Await]
`:` BindingElement[?Yield, ?Await] BindingElement[Yield, Await] :
SingleNameBinding[?Yield, ?Await] BindingPattern[?Yield, ?Await]
Initializer[+In, ?Yield, ?Await]? SingleNameBinding[Yield, Await] :
BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
BindingRestElement[Yield, Await] : `...` BindingIdentifier[?Yield,
?Await] `...` BindingPattern[?Yield, ?Await]

Runtime Semantics: PropertyBindingInitialization ( value, environment: an Environment Record or `undefined`, )
--------------------------------------------------------------------------------------------------------------

description
   It collects a list of all bound property names.

BindingPropertyList : BindingPropertyList `,` BindingProperty 1. Let
boundNames be ? PropertyBindingInitialization of
`BindingPropertyList` with arguments value and environment. 1.
Let nextNames be ? PropertyBindingInitialization of
`BindingProperty` with arguments value and environment. 1.
Return the list-concatenation of boundNames and nextNames.
BindingProperty : SingleNameBinding 1. Let name be the sole element
of the BoundNames of `SingleNameBinding`. 1. Perform ?
KeyedBindingInitialization of `SingleNameBinding` with arguments
value, environment, and name. 1. Return « name ».
BindingProperty : PropertyName `:` BindingElement 1. Let P be ?
Evaluation of `PropertyName`. 1. Perform ? KeyedBindingInitialization
of `BindingElement` with arguments value, environment, and
P. 1. Return « P ».

Runtime Semantics: RestBindingInitialization ( value, environment: an Environment Record or `undefined`, excludedNames: a List of property keys, )
--------------------------------------------------------------------------------------------------------------------------------------------------

BindingRestProperty : `...` BindingIdentifier 1. Let lhs be ?
ResolveBinding(StringValue of `BindingIdentifier`, environment).
1. Let restObj be OrdinaryObjectCreate(%Object.prototype%). 1.
Perform ? CopyDataProperties(restObj, value, excludedNames).
1. If environment is `undefined`, return ? PutValue(lhs,
restObj). 1. Return ? InitializeReferencedBinding(lhs,
restObj).

Runtime Semantics: KeyedBindingInitialization ( value, environment: an Environment Record or `undefined`, propertyName: a property key, )
-----------------------------------------------------------------------------------------------------------------------------------------

When `undefined` is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

BindingElement : BindingPattern Initializer? 1. Let v be ?
GetV(value, propertyName). 1. If `Initializer` is present and
v is `undefined`, then 1. Let defaultValue be ? Evaluation of
`Initializer`. 1. Set v to ? GetValue(defaultValue). 1. Return
? BindingInitialization of `BindingPattern` with arguments v and
environment. SingleNameBinding : BindingIdentifier Initializer? 1.
Let bindingId be the StringValue of `BindingIdentifier`. 1. Let
lhs be ? ResolveBinding(bindingId, environment). 1. Let
v be ? GetV(value, propertyName). 1. If `Initializer` is
present and v is `undefined`, then 1. If
IsAnonymousFunctionDefinition(`Initializer`) is `true`, then 1. Set
v to ? NamedEvaluation of `Initializer` with argument
bindingId. 1. Else, 1. Let defaultValue be ? Evaluation of
`Initializer`. 1. Set v to ? GetValue(defaultValue). 1. If
environment is `undefined`, return ? PutValue(lhs, v). 1.
Return ? InitializeReferencedBinding(lhs, v).

Empty Statement
---------------


**Syntax**


EmptyStatement : `;`



Runtime Semantics: Evaluation
-----------------------------

EmptyStatement : `;` 1. Return ~empty~.

Expression Statement
--------------------


**Syntax**


ExpressionStatement[Yield, Await] : [lookahead ∉ { `{`, `function`,
`async` [no LineTerminator here] `function`, `class`, `let`
`[` }] Expression[+In, ?Yield, ?Await] `;`

An `ExpressionStatement` cannot start with a U+007B (LEFT CURLY
BRACKET) because that might make it ambiguous with a `Block`. An
`ExpressionStatement` cannot start with the `function` or `class`
keywords because that would make it ambiguous with a
`FunctionDeclaration`, a `GeneratorDeclaration`, or a
`ClassDeclaration`. An `ExpressionStatement` cannot start with
`async function` because that would make it ambiguous with an
`AsyncFunctionDeclaration` or a `AsyncGeneratorDeclaration`. An
`ExpressionStatement` cannot start with the two token sequence `let
[` because that would make it ambiguous with a `let`
`LexicalDeclaration` whose first `LexicalBinding` was an
`ArrayBindingPattern`.



Runtime Semantics: Evaluation
-----------------------------

ExpressionStatement : Expression `;` 1. Let exprRef be ?
Evaluation of `Expression`. 1. Return ? GetValue(exprRef).

The `if` Statement
--------------------


**Syntax**


IfStatement[Yield, Await, Return] : `if` `(` Expression[+In, ?Yield,
?Await] `)` Statement[?Yield, ?Await, ?Return] `else`
Statement[?Yield, ?Await, ?Return] `if` `(` Expression[+In, ?Yield,
?Await] `)` Statement[?Yield, ?Await, ?Return] [lookahead != `else`]
The lookahead-restriction [lookahead ≠ `else`] resolves the classic
"dangling else" problem in the usual way. That is, when the choice of
associated `if` is otherwise ambiguous, the `else` is associated
with the nearest (innermost) of the candidate `if`s


Static Semantics: Early Errors
------------------------------

IfStatement : `if` `(` Expression `)` Statement `else` Statement

- It is a Syntax Error if IsLabelledFunction(the first `Statement`) is
  `true`.
- It is a Syntax Error if IsLabelledFunction(the second `Statement`)
  is `true`.

IfStatement : `if` `(` Expression `)` Statement

- It is a Syntax Error if IsLabelledFunction(`Statement`) is `true`.

It is only necessary to apply this rule if the extension specified in is
implemented.



Runtime Semantics: Evaluation
-----------------------------

IfStatement : `if` `(` Expression `)` Statement `else` Statement
1. Let exprRef be ? Evaluation of `Expression`. 1. Let
exprValue be ToBoolean(? GetValue(exprRef)). 1. If exprValue
is `true`, then 1. Let stmtCompletion be Completion(Evaluation of
the first `Statement`). 1. Else, 1. Let stmtCompletion be
Completion(Evaluation of the second `Statement`). 1. Return ?
UpdateEmpty(stmtCompletion, `undefined`). IfStatement : `if`
`(` Expression `)` Statement 1. Let exprRef be ? Evaluation of
`Expression`. 1. Let exprValue be ToBoolean(?
GetValue(exprRef)). 1. If exprValue is `false`, then 1. Return
`undefined`. 1. Else, 1. Let stmtCompletion be
Completion(Evaluation of `Statement`). 1. Return ?
UpdateEmpty(stmtCompletion, `undefined`).

Iteration Statements
--------------------


**Syntax**


IterationStatement[Yield, Await, Return] : DoWhileStatement[?Yield,
?Await, ?Return] WhileStatement[?Yield, ?Await, ?Return]
ForStatement[?Yield, ?Await, ?Return] ForInOfStatement[?Yield, ?Await,
?Return]

Semantics
---------

LoopContinues ( completion: a Completion Record, labelSet: a List of Strings, ): a Boolean
--------------------------------------------------------------------------------------------------

1. If completion is a normal completion, return `true`. 1. If
completion is not a continue completion, return `false`. 1. If
completion.[[Target]] is ~empty~, return `true`. 1. If
labelSet contains completion.[[Target]], return `true`. 1.
Return `false`.

Within the `Statement` part of an `IterationStatement` a
`ContinueStatement` may be used to begin a new iteration.

Runtime Semantics: LoopEvaluation ( labelSet: a List of Strings, )
------------------------------------------------------------------

IterationStatement : DoWhileStatement 1. Return ? DoWhileLoopEvaluation
of `DoWhileStatement` with argument labelSet. IterationStatement :
WhileStatement 1. Return ? WhileLoopEvaluation of `WhileStatement`
with argument labelSet. IterationStatement : ForStatement 1. Return
? ForLoopEvaluation of `ForStatement` with argument labelSet.
IterationStatement : ForInOfStatement 1. Return ? ForInOfLoopEvaluation
of `ForInOfStatement` with argument labelSet.

The `do`-`while` Statement
------------------------------


**Syntax**


DoWhileStatement[Yield, Await, Return] : `do` Statement[?Yield,
?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)`
`;`


Static Semantics: Early Errors
------------------------------

DoWhileStatement : `do` Statement `while` `(` Expression `)`
`;`

- It is a Syntax Error if IsLabelledFunction(`Statement`) is `true`.

It is only necessary to apply this rule if the extension specified in is
implemented.

Runtime Semantics: DoWhileLoopEvaluation ( labelSet: a List of Strings, )
-------------------------------------------------------------------------

DoWhileStatement : `do` Statement `while` `(` Expression `)`
`;` 1. Let V be `undefined`. 1. Repeat, 1. Let stmtResult be
Completion(Evaluation of `Statement`). 1. If
LoopContinues(stmtResult, labelSet) is `false`, return ?
UpdateEmpty(stmtResult, V). 1. If stmtResult.[[Value]] is
not ~empty~, set V to stmtResult.[[Value]]. 1. Let exprRef
be ? Evaluation of `Expression`. 1. Let exprValue be ?
GetValue(exprRef). 1. If ToBoolean(exprValue) is `false`,
return V.

The `while` Statement
-----------------------


**Syntax**


WhileStatement[Yield, Await, Return] : `while` `(` Expression[+In,
?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]


Static Semantics: Early Errors
------------------------------

WhileStatement : `while` `(` Expression `)` Statement

- It is a Syntax Error if IsLabelledFunction(`Statement`) is `true`.

It is only necessary to apply this rule if the extension specified in is
implemented.

Runtime Semantics: WhileLoopEvaluation ( labelSet: a List of Strings, )
-----------------------------------------------------------------------

WhileStatement : `while` `(` Expression `)` Statement 1. Let V
be `undefined`. 1. Repeat, 1. Let exprRef be ? Evaluation of
`Expression`. 1. Let exprValue be ? GetValue(exprRef). 1. If
ToBoolean(exprValue) is `false`, return V. 1. Let
stmtResult be Completion(Evaluation of `Statement`). 1. If
LoopContinues(stmtResult, labelSet) is `false`, return ?
UpdateEmpty(stmtResult, V). 1. If stmtResult.[[Value]] is
not ~empty~, set V to stmtResult.[[Value]].

The `for` Statement
---------------------


**Syntax**


ForStatement[Yield, Await, Return] : `for` `(` [lookahead != `let`
`[`] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield,
?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield,
?Await, ?Return] `for` `(` `var` VariableDeclarationList[~In,
?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;`
Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await,
?Return] `for` `(` LexicalDeclaration[~In, ?Yield, ?Await]
Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]?
`)` Statement[?Yield, ?Await, ?Return]


Static Semantics: Early Errors
------------------------------

ForStatement : `for` `(` Expression? `;` Expression? `;`
Expression? `)` Statement `for` `(` `var`
VariableDeclarationList `;` Expression? `;` Expression? `)`
Statement `for` `(` LexicalDeclaration Expression? `;` Expression?
`)` Statement

- It is a Syntax Error if IsLabelledFunction(`Statement`) is `true`.

It is only necessary to apply this rule if the extension specified in is
implemented.

ForStatement : `for` `(` LexicalDeclaration Expression? `;`
Expression? `)` Statement

- It is a Syntax Error if any element of the BoundNames of
  `LexicalDeclaration` also occurs in the VarDeclaredNames of
  `Statement`.

Runtime Semantics: ForLoopEvaluation ( labelSet: a List of Strings, )
---------------------------------------------------------------------

ForStatement : `for` `(` Expression? `;` Expression? `;`
Expression? `)` Statement 1. If the first `Expression` is present,
then 1. Let exprRef be ? Evaluation of the first `Expression`. 1.
Perform ? GetValue(exprRef). 1. If the second `Expression` is
present, let test be the second `Expression`; otherwise, let
test be ~empty~. 1. If the third `Expression` is present, let
increment be the third `Expression`; otherwise, let increment
be ~empty~. 1. Return ? ForBodyEvaluation(test, increment,
`Statement`, « », labelSet). ForStatement : `for` `(` `var`
VariableDeclarationList `;` Expression? `;` Expression? `)`
Statement 1. Perform ? Evaluation of `VariableDeclarationList`. 1. If
the first `Expression` is present, let test be the first
`Expression`; otherwise, let test be ~empty~. 1. If the second
`Expression` is present, let increment be the second
`Expression`; otherwise, let increment be ~empty~. 1. Return ?
ForBodyEvaluation(test, increment, `Statement`, « »,
labelSet). ForStatement : `for` `(` LexicalDeclaration
Expression? `;` Expression? `)` Statement 1. Let oldEnv be the
running execution context's LexicalEnvironment. 1. Let loopEnv be
NewDeclarativeEnvironment(oldEnv). 1. Let isConst be
IsConstantDeclaration of `LexicalDeclaration`. 1. Let boundNames
be the BoundNames of `LexicalDeclaration`. 1. For each element dn
of boundNames, do 1. If isConst is `true`, then 1. Perform !
loopEnv.CreateImmutableBinding(dn, `true`). 1. Else, 1.
Perform ! loopEnv.CreateMutableBinding(dn, `false`). 1. Set
the running execution context's LexicalEnvironment to loopEnv. 1.
Let forDcl be Completion(Evaluation of `LexicalDeclaration`). 1.
If forDcl is an abrupt completion, then 1. Set the running execution
context's LexicalEnvironment to oldEnv. 1. Return ? forDcl. 1.
If isConst is `false`, let perIterationLets be boundNames;
otherwise let perIterationLets be a new empty List. 1. If the first
`Expression` is present, let test be the first `Expression`;
otherwise, let test be ~empty~. 1. If the second `Expression` is
present, let increment be the second `Expression`; otherwise, let
increment be ~empty~. 1. Let bodyResult be
Completion(ForBodyEvaluation(test, increment, `Statement`,
perIterationLets, labelSet)). 1. Set the running execution
context's LexicalEnvironment to oldEnv. 1. Return ? bodyResult.

ForBodyEvaluation ( test: an `Expression` Parse Node or ~empty~, increment: an `Expression` Parse Node or ~empty~, stmt: a `Statement` Parse Node, perIterationBindings: a List of Strings, labelSet: a List of Strings, )
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let V be `undefined`. 1. Perform ?
CreatePerIterationEnvironment(perIterationBindings). 1. Repeat, 1.
If test is not ~empty~, then 1. Let testRef be ? Evaluation of
test. 1. Let testValue be ? GetValue(testRef). 1. If
ToBoolean(testValue) is `false`, return V. 1. Let result
be Completion(Evaluation of stmt). 1. If LoopContinues(result,
labelSet) is `false`, return ? UpdateEmpty(result, V). 1.
If result.[[Value]] is not ~empty~, set V to
result.[[Value]]. 1. Perform ?
CreatePerIterationEnvironment(perIterationBindings). 1. If
increment is not ~empty~, then 1. Let incRef be ? Evaluation of
increment. 1. Perform ? GetValue(incRef).

CreatePerIterationEnvironment ( perIterationBindings: a List of Strings, )
--------------------------------------------------------------------------

1. If perIterationBindings has any elements, then 1. Let
lastIterationEnv be the running execution context's
LexicalEnvironment. 1. Let outer be
lastIterationEnv.[[OuterEnv]]. 1. Assert: outer is not `null`.
1. Let thisIterationEnv be NewDeclarativeEnvironment(outer). 1.
For each element bn of perIterationBindings, do 1. Perform !
thisIterationEnv.CreateMutableBinding(bn, `false`). 1. Let
lastValue be ? lastIterationEnv.GetBindingValue(bn,
`true`). 1. Perform ! thisIterationEnv.InitializeBinding(bn,
lastValue). 1. Set the running execution context's
LexicalEnvironment to thisIterationEnv. 1. Return ~unused~.

The `for`-`in`, `for`-`of`, and `for`-`await`-`of` Statements
---------------------------------------------------------------------------


**Syntax**


ForInOfStatement[Yield, Await, Return] : `for` `(` [lookahead !=
`let` `[`] LeftHandSideExpression[?Yield, ?Await] `in`
Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
`for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In,
?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `for` `(`
ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await]
`)` Statement[?Yield, ?Await, ?Return] `for` `(` [lookahead ∉ {
`let`, `async` `of` }] LeftHandSideExpression[?Yield, ?Await]
`of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield,
?Await, ?Return] `for` `(` `var` ForBinding[?Yield, ?Await] `of`
AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield,
?Await, ?Return] `for` `(` ForDeclaration[?Yield, ?Await] `of`
AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield,
?Await, ?Return] [+Await] `for` `await` `(` [lookahead != `let`]
LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In,
?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] [+Await]
`for` `await` `(` `var` ForBinding[?Yield, ?Await] `of`
AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield,
?Await, ?Return] [+Await] `for` `await` `(` ForDeclaration[?Yield,
?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)`
Statement[?Yield, ?Await, ?Return] ForDeclaration[Yield, Await] :
LetOrConst ForBinding[?Yield, ?Await] ForBinding[Yield, Await] :
BindingIdentifier[?Yield, ?Await] BindingPattern[?Yield, ?Await]

This section is extended by Annex .


Static Semantics: Early Errors
------------------------------

ForInOfStatement : `for` `(` LeftHandSideExpression `in`
Expression `)` Statement `for` `(` `var` ForBinding `in`
Expression `)` Statement `for` `(` ForDeclaration `in`
Expression `)` Statement `for` `(` LeftHandSideExpression `of`
AssignmentExpression `)` Statement `for` `(` `var` ForBinding
`of` AssignmentExpression `)` Statement `for` `(` ForDeclaration
`of` AssignmentExpression `)` Statement `for` `await` `(`
LeftHandSideExpression `of` AssignmentExpression `)` Statement
`for` `await` `(` `var` ForBinding `of` AssignmentExpression
`)` Statement `for` `await` `(` ForDeclaration `of`
AssignmentExpression `)` Statement

- It is a Syntax Error if IsLabelledFunction(`Statement`) is `true`.

It is only necessary to apply this rule if the extension specified in is
implemented.

ForInOfStatement : `for` `(` LeftHandSideExpression `in`
Expression `)` Statement `for` `(` LeftHandSideExpression `of`
AssignmentExpression `)` Statement `for` `await` `(`
LeftHandSideExpression `of` AssignmentExpression `)` Statement

- If `LeftHandSideExpression` is either an `ObjectLiteral` or an
  `ArrayLiteral`, `LeftHandSideExpression` must cover an
  `AssignmentPattern`.
- If `LeftHandSideExpression` is neither an `ObjectLiteral` nor an
  `ArrayLiteral`, it is a Syntax Error if the AssignmentTargetType of
  `LeftHandSideExpression` is not ~simple~.

ForInOfStatement : `for` `(` ForDeclaration `in` Expression `)`
Statement `for` `(` ForDeclaration `of` AssignmentExpression `)`
Statement `for` `await` `(` ForDeclaration `of`
AssignmentExpression `)` Statement

- It is a Syntax Error if the BoundNames of `ForDeclaration` contains
  `"let"`.
- It is a Syntax Error if any element of the BoundNames of
  `ForDeclaration` also occurs in the VarDeclaredNames of
  `Statement`.
- It is a Syntax Error if the BoundNames of `ForDeclaration` contains
  any duplicate entries.

Static Semantics: IsDestructuring ( ): a Boolean
------------------------------------------------

MemberExpression : PrimaryExpression 1. If `PrimaryExpression` is
either an `ObjectLiteral` or an `ArrayLiteral`, return `true`. 1.
Return `false`. MemberExpression : MemberExpression `[` Expression
`]` MemberExpression `.` IdentifierName MemberExpression
TemplateLiteral SuperProperty MetaProperty `new` MemberExpression
Arguments MemberExpression `.` PrivateIdentifier NewExpression :
`new` NewExpression LeftHandSideExpression : CallExpression
OptionalExpression 1. Return `false`. ForDeclaration : LetOrConst
ForBinding 1. Return IsDestructuring of `ForBinding`. ForBinding :
BindingIdentifier 1. Return `false`. ForBinding : BindingPattern 1.
Return `true`.

This section is extended by Annex .

Runtime Semantics: ForDeclarationBindingInitialization ( value, environment: an Environment Record or `undefined`, )
--------------------------------------------------------------------------------------------------------------------

`undefined` is passed for environment to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for `var` statements and the formal parameter lists of some
non-strict functions (see ). In those cases a lexical binding is hoisted
and preinitialized prior to evaluation of its initializer.

ForDeclaration : LetOrConst ForBinding 1. Return ? BindingInitialization
of `ForBinding` with arguments value and environment.

Runtime Semantics: ForDeclarationBindingInstantiation ( environment: a Declarative Environment Record, ): ~unused~
----------------------------------------------------------------------------------------------------------------------

ForDeclaration : LetOrConst ForBinding 1. For each element name of
the BoundNames of `ForBinding`, do 1. If IsConstantDeclaration of
`LetOrConst` is `true`, then 1. Perform !
environment.CreateImmutableBinding(name, `true`). 1. Else, 1.
Perform ! environment.CreateMutableBinding(name, `false`). 1.
Return ~unused~.

Runtime Semantics: ForInOfLoopEvaluation ( labelSet: a List of Strings, )
-------------------------------------------------------------------------

ForInOfStatement : `for` `(` LeftHandSideExpression `in`
Expression `)` Statement 1. Let keyResult be ?
ForIn/OfHeadEvaluation(« », `Expression`, ~enumerate~). 1. Return ?
ForIn/OfBodyEvaluation(`LeftHandSideExpression`, `Statement`,
keyResult, ~enumerate~, ~assignment~, labelSet).
ForInOfStatement : `for` `(` `var` ForBinding `in` Expression
`)` Statement 1. Let keyResult be ? ForIn/OfHeadEvaluation(« »,
`Expression`, ~enumerate~). 1. Return ?
ForIn/OfBodyEvaluation(`ForBinding`, `Statement`, keyResult,
~enumerate~, ~var-binding~, labelSet). ForInOfStatement : `for`
`(` ForDeclaration `in` Expression `)` Statement 1. Let
keyResult be ? ForIn/OfHeadEvaluation(BoundNames of
`ForDeclaration`, `Expression`, ~enumerate~). 1. Return ?
ForIn/OfBodyEvaluation(`ForDeclaration`, `Statement`, keyResult,
~enumerate~, ~lexical-binding~, labelSet). ForInOfStatement :
`for` `(` LeftHandSideExpression `of` AssignmentExpression `)`
Statement 1. Let keyResult be ? ForIn/OfHeadEvaluation(« »,
`AssignmentExpression`, ~iterate~). 1. Return ?
ForIn/OfBodyEvaluation(`LeftHandSideExpression`, `Statement`,
keyResult, ~iterate~, ~assignment~, labelSet). ForInOfStatement
: `for` `(` `var` ForBinding `of` AssignmentExpression `)`
Statement 1. Let keyResult be ? ForIn/OfHeadEvaluation(« »,
`AssignmentExpression`, ~iterate~). 1. Return ?
ForIn/OfBodyEvaluation(`ForBinding`, `Statement`, keyResult,
~iterate~, ~var-binding~, labelSet). ForInOfStatement : `for`
`(` ForDeclaration `of` AssignmentExpression `)` Statement 1. Let
keyResult be ? ForIn/OfHeadEvaluation(BoundNames of
`ForDeclaration`, `AssignmentExpression`, ~iterate~). 1. Return ?
ForIn/OfBodyEvaluation(`ForDeclaration`, `Statement`, keyResult,
~iterate~, ~lexical-binding~, labelSet). ForInOfStatement : `for`
`await` `(` LeftHandSideExpression `of` AssignmentExpression `)`
Statement 1. Let keyResult be ? ForIn/OfHeadEvaluation(« »,
`AssignmentExpression`, ~async-iterate~). 1. Return ?
ForIn/OfBodyEvaluation(`LeftHandSideExpression`, `Statement`,
keyResult, ~iterate~, ~assignment~, labelSet, ~async~).
ForInOfStatement : `for` `await` `(` `var` ForBinding `of`
AssignmentExpression `)` Statement 1. Let keyResult be ?
ForIn/OfHeadEvaluation(« », `AssignmentExpression`, ~async-iterate~).
1. Return ? ForIn/OfBodyEvaluation(`ForBinding`, `Statement`,
keyResult, ~iterate~, ~var-binding~, labelSet, ~async~).
ForInOfStatement : `for` `await` `(` ForDeclaration `of`
AssignmentExpression `)` Statement 1. Let keyResult be ?
ForIn/OfHeadEvaluation(BoundNames of `ForDeclaration`,
`AssignmentExpression`, ~async-iterate~). 1. Return ?
ForIn/OfBodyEvaluation(`ForDeclaration`, `Statement`, keyResult,
~iterate~, ~lexical-binding~, labelSet, ~async~).

This section is extended by Annex .

ForIn/OfHeadEvaluation ( uninitializedBoundNames: a List of Strings, expr: an `Expression` Parse Node or an `AssignmentExpression` Parse Node, iterationKind: ~enumerate~, ~iterate~, or ~async-iterate~, )
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let oldEnv be the running execution context's LexicalEnvironment.
1. If uninitializedBoundNames is not empty, then 1. Assert:
uninitializedBoundNames has no duplicate entries. 1. Let newEnv
be NewDeclarativeEnvironment(oldEnv). 1. For each String name of
uninitializedBoundNames, do 1. Perform !
newEnv.CreateMutableBinding(name, `false`). 1. Set the running
execution context's LexicalEnvironment to newEnv. 1. Let exprRef
be Completion(Evaluation of expr). 1. Set the running execution
context's LexicalEnvironment to oldEnv. 1. Let exprValue be ?
GetValue(? exprRef). 1. If iterationKind is ~enumerate~, then 1.
If exprValue is either `undefined` or `null`, then 1. Return
Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]:
~empty~ }. 1. Let obj be ! ToObject(exprValue). 1. Let
iterator be EnumerateObjectProperties(obj). 1. Let
nextMethod be ! GetV(iterator, `"next"`). 1. Return the
Iterator Record { [[Iterator]]: iterator, [[NextMethod]]:
nextMethod, [[Done]]: `false` }. 1. Else, 1. Assert:
iterationKind is either ~iterate~ or ~async-iterate~. 1. If
iterationKind is ~async-iterate~, let iteratorKind be ~async~.
1. Else, let iteratorKind be ~sync~. 1. Return ?
GetIterator(exprValue, iteratorKind).

ForIn/OfBodyEvaluation ( lhs: a Parse Node, stmt: a `Statement` Parse Node, iteratorRecord: an Iterator Record, iterationKind: ~enumerate~ or ~iterate~, lhsKind: ~assignment~, ~var-binding~, or ~lexical-binding~, labelSet: a List of Strings, optional iteratorKind: ~sync~ or ~async~, )
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. If iteratorKind is not present, set iteratorKind to ~sync~.
1. Let oldEnv be the running execution context's LexicalEnvironment.
1. Let V be `undefined`. 1. Let destructuring be
IsDestructuring of lhs. 1. If destructuring is `true` and
lhsKind is ~assignment~, then 1. Assert: lhs is a
`LeftHandSideExpression`. 1. Let assignmentPattern be the
`AssignmentPattern` that is covered by lhs. 1. Repeat, 1. Let
nextResult be ? Call(iteratorRecord.[[NextMethod]],
iteratorRecord.[[Iterator]]). 1. If iteratorKind is ~async~, set
nextResult to ? Await(nextResult). 1. If nextResult is not
an Object, throw a `TypeError` exception. 1. Let done be ?
IteratorComplete(nextResult). 1. If done is `true`, return
V. 1. Let nextValue be ? IteratorValue(nextResult). 1. If
lhsKind is either ~assignment~ or ~var-binding~, then 1. If
destructuring is `true`, then 1. If lhsKind is ~assignment~,
then 1. Let status be Completion(DestructuringAssignmentEvaluation
of assignmentPattern with argument nextValue). 1. Else, 1.
Assert: lhsKind is ~var-binding~. 1. Assert: lhs is a
`ForBinding`. 1. Let status be Completion(BindingInitialization of
lhs with arguments nextValue and `undefined`). 1. Else, 1. Let
lhsRef be Completion(Evaluation of lhs). (It may be evaluated
repeatedly.) 1. If lhsRef is an abrupt completion, then 1. Let
status be lhsRef. 1. Else, 1. Let status be
Completion(PutValue(lhsRef.[[Value]], nextValue)). 1. Else, 1.
Assert: lhsKind is ~lexical-binding~. 1. Assert: lhs is a
`ForDeclaration`. 1. Let iterationEnv be
NewDeclarativeEnvironment(oldEnv). 1. Perform
ForDeclarationBindingInstantiation of lhs with argument
iterationEnv. 1. Set the running execution context's
LexicalEnvironment to iterationEnv. 1. If destructuring is
`true`, then 1. Let status be
Completion(ForDeclarationBindingInitialization of lhs with arguments
nextValue and iterationEnv). 1. Else, 1. Assert: lhs binds a
single name. 1. Let lhsName be the sole element of the BoundNames of
lhs. 1. Let lhsRef be ! ResolveBinding(lhsName). 1. Let
status be Completion(InitializeReferencedBinding(lhsRef,
nextValue)). 1. If status is an abrupt completion, then 1. Set
the running execution context's LexicalEnvironment to oldEnv. 1. If
iteratorKind is ~async~, return ?
AsyncIteratorClose(iteratorRecord, status). 1. If
iterationKind is ~enumerate~, then 1. Return ? status. 1. Else,
1. Assert: iterationKind is ~iterate~. 1. Return ?
IteratorClose(iteratorRecord, status). 1. Let result be
Completion(Evaluation of stmt). 1. Set the running execution
context's LexicalEnvironment to oldEnv. 1. If
LoopContinues(result, labelSet) is `false`, then 1. If
iterationKind is ~enumerate~, then 1. Return ?
UpdateEmpty(result, V). 1. Else, 1. Assert: iterationKind is
~iterate~. 1. Set status to Completion(UpdateEmpty(result,
V)). 1. If iteratorKind is ~async~, return ?
AsyncIteratorClose(iteratorRecord, status). 1. Return ?
IteratorClose(iteratorRecord, status). 1. If
result.[[Value]] is not ~empty~, set V to result.[[Value]].



Runtime Semantics: Evaluation
-----------------------------

BindingIdentifier : Identifier `yield` `await` 1. Let bindingId
be the StringValue of `BindingIdentifier`. 1. Return ?
ResolveBinding(bindingId).

EnumerateObjectProperties ( O: an Object, ): an iterator object
-------------------------------------------------------------------

1. Return an iterator object whose `next` method iterates over all the
String-valued keys of enumerable properties of O. The iterator
object is never directly accessible to ECMAScript code. The mechanics
and order of enumerating the properties is not specified but must
conform to the rules specified below.

The iterator's `throw` and `return` methods are `null` and are
never invoked. The iterator's `next` method processes object
properties to determine whether the property key should be returned as
an iterator value. Returned property keys do not include keys that are
Symbols. Properties of the target object may be deleted during
enumeration. A property that is deleted before it is processed by the
iterator's `next` method is ignored. If new properties are added to
the target object during enumeration, the newly added properties are not
guaranteed to be processed in the active enumeration. A property name
will be returned by the iterator's `next` method at most once in any
enumeration.

Enumerating the properties of the target object includes enumerating
properties of its prototype, and the prototype of the prototype, and so
on, recursively; but a property of a prototype is not processed if it
has the same name as a property that has already been processed by the
iterator's `next` method. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object has
already been processed. The enumerable property names of prototype
objects must be obtained by invoking EnumerateObjectProperties passing
the prototype object as the argument. EnumerateObjectProperties must
obtain the own property keys of the target object by calling its
[[OwnPropertyKeys]] internal method. Property attributes of the target
object must be obtained by calling its [[GetOwnProperty]] internal
method.

In addition, if neither O nor any object in its prototype chain is a
Proxy exotic object, TypedArray, module namespace exotic object, or
implementation provided exotic object, then the iterator must behave as
would the iterator given by CreateForInIterator(O) until one of the
following occurs:

- the value of the [[Prototype]] internal slot of O or an object in
  its prototype chain changes,
- a property is removed from O or an object in its prototype chain,
- a property is added to an object in O's prototype chain, or
- the value of the [[Enumerable]] attribute of a property of O or an
  object in its prototype chain changes.

ECMAScript implementations are not required to implement the algorithm
in directly. They may choose any implementation whose behaviour will not
deviate from that algorithm unless one of the constraints in the
previous paragraph is violated.

The following is an informative definition of an ECMAScript generator
function that conforms to these rules:

.. code:: javascript

               function* EnumerateObjectProperties(obj) {
                 const visited = new Set();
                 for (const key of Reflect.ownKeys(obj)) {
                   if (typeof key === "symbol") continue;
                   const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                   if (desc) {
                     visited.add(key);
                     if (desc.enumerable) yield key;
                   }
                 }
                 const proto = Reflect.getPrototypeOf(obj);
                 if (proto === null) return;
                 for (const protoKey of EnumerateObjectProperties(proto)) {
                   if (!visited.has(protoKey)) yield protoKey;
                 }
               }
             

The list of exotic objects for which implementations are not required to
match CreateForInIterator was chosen because implementations
historically differed in behaviour for those cases, and agreed in all
others.

For-In Iterator Objects
-----------------------

A For-In Iterator is an object that represents a specific iteration over
some specific object. For-In Iterator objects are never directly
accessible to ECMAScript code; they exist solely to illustrate the
behaviour of EnumerateObjectProperties.

CreateForInIterator ( object: an Object, ): a For-In Iterator
-----------------------------------------------------------------

description
   It is used to create a For-In Iterator object which iterates over the
   own and inherited enumerable string properties of object in a
   specific order.

1. Let iterator be OrdinaryObjectCreate(%ForInIteratorPrototype%, «
[[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »).
1. Set iterator.[[Object]] to object. 1. Set
iterator.[[ObjectWasVisited]] to `false`. 1. Set
iterator.[[VisitedKeys]] to a new empty List. 1. Set
iterator.[[RemainingKeys]] to a new empty List. 1. Return
iterator.

The %ForInIteratorPrototype% Object
-----------------------------------

The %ForInIteratorPrototype% object:

- has properties that are inherited by all For-In Iterator objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- is never directly accessible to ECMAScript code.
- has the following properties:

%ForInIteratorPrototype%.next ( )
---------------------------------

1. Let O be the `this` value. 1. Assert: O is an Object. 1.
Assert: O has all of the internal slots of a For-In Iterator
Instance (). 1. Let object be O.[[Object]]. 1. Repeat, 1. If
O.[[ObjectWasVisited]] is `false`, then 1. Let keys be ?
object.[[OwnPropertyKeys]](). 1. For each element key of
keys, do 1. If key is a String, then 1. Append key to
O.[[RemainingKeys]]. 1. Set O.[[ObjectWasVisited]] to `true`.
1. Repeat, while O.[[RemainingKeys]] is not empty, 1. Let r be
the first element of O.[[RemainingKeys]]. 1. Remove the first
element from O.[[RemainingKeys]]. 1. If O.[[VisitedKeys]] does
not contain r, then 1. Let desc be ?
object.[[GetOwnProperty]](r). 1. If desc is not
`undefined`, then 1. Append r to O.[[VisitedKeys]]. 1. If
desc.[[Enumerable]] is `true`, return
CreateIteratorResultObject(r, `false`). 1. Set object to ?
object.[[GetPrototypeOf]](). 1. Set O.[[Object]] to object.
1. Set O.[[ObjectWasVisited]] to `false`. 1. If object is
`null`, return CreateIteratorResultObject(`undefined`, `true`).

Properties of For-In Iterator Instances
---------------------------------------

For-In Iterator instances are ordinary objects that inherit properties
from the %ForInIteratorPrototype% intrinsic object. For-In Iterator
instances are initially created with the internal slots listed in .

+----------------------+-------------------+-----------------------+
| Internal Slot        | Type              | Description           |
+======================+===================+=======================+
| [[Object]]           | an Object         | The Object value      |
|                      |                   | whose properties are  |
|                      |                   | being iterated.       |
+----------------------+-------------------+-----------------------+
| [[ObjectWasVisited]] | a Boolean         | `true` if the       |
|                      |                   | iterator has invoked  |
|                      |                   | [[OwnPropertyKeys]]   |
|                      |                   | on [[Object]],        |
|                      |                   | `false` otherwise.  |
+----------------------+-------------------+-----------------------+
| [[VisitedKeys]]      | a List of Strings | The values that have  |
|                      |                   | been emitted by this  |
|                      |                   | iterator thus far.    |
+----------------------+-------------------+-----------------------+
| [[RemainingKeys]]    | a List of Strings | The values remaining  |
|                      |                   | to be emitted for the |
|                      |                   | current object,       |
|                      |                   | before iterating the  |
|                      |                   | properties of its     |
|                      |                   | prototype (if its     |
|                      |                   | prototype is not      |
|                      |                   | `null`).            |
+----------------------+-------------------+-----------------------+

The `continue` Statement
--------------------------


**Syntax**


ContinueStatement[Yield, Await] : `continue` `;` `continue` [no
LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`


Static Semantics: Early Errors
------------------------------

ContinueStatement : `continue` `;` `continue` LabelIdentifier
`;`

- It is a Syntax Error if this `ContinueStatement` is not nested,
  directly or indirectly (but not crossing function or `static`
  initialization block boundaries), within an `IterationStatement`.



Runtime Semantics: Evaluation
-----------------------------

ContinueStatement : `continue` `;` 1. Return Completion Record {
[[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
ContinueStatement : `continue` LabelIdentifier `;` 1. Let label
be the StringValue of `LabelIdentifier`. 1. Return Completion Record {
[[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: label }.

The `break` Statement
-----------------------


**Syntax**


BreakStatement[Yield, Await] : `break` `;` `break` [no
LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`


Static Semantics: Early Errors
------------------------------

BreakStatement : `break` `;`

- It is a Syntax Error if this `BreakStatement` is not nested,
  directly or indirectly (but not crossing function or `static`
  initialization block boundaries), within an `IterationStatement` or
  a `SwitchStatement`.



Runtime Semantics: Evaluation
-----------------------------

BreakStatement : `break` `;` 1. Return Completion Record { [[Type]]:
~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }. BreakStatement :
`break` LabelIdentifier `;` 1. Let label be the StringValue of
`LabelIdentifier`. 1. Return Completion Record { [[Type]]: ~break~,
[[Value]]: ~empty~, [[Target]]: label }.

The `return` Statement
------------------------


**Syntax**


ReturnStatement[Yield, Await] : `return` `;` `return` [no
LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

A `return` statement causes a function to cease execution and, in most
cases, returns a value to the caller. If `Expression` is omitted, the
return value is `undefined`. Otherwise, the return value is the value
of `Expression`. A `return` statement may not actually return a
value to the caller depending on surrounding context. For example, in a
`try` block, a `return` statement's Completion Record may be
replaced with another Completion Record during evaluation of the
`finally` block.



Runtime Semantics: Evaluation
-----------------------------

ReturnStatement : `return` `;` 1. Return
ReturnCompletion(`undefined`). ReturnStatement : `return` Expression
`;` 1. Let exprRef be ? Evaluation of `Expression`. 1. Let
exprValue be ? GetValue(exprRef). 1. If GetGeneratorKind() is
~async~, set exprValue to ? Await(exprValue). 1. Return
ReturnCompletion(exprValue).

The `with` Statement
----------------------

Use of the Legacy `with` statement is discouraged in new ECMAScript
code. Consider alternatives that are permitted in both strict mode code
and non-strict code, such as destructuring assignment.


**Syntax**


WithStatement[Yield, Await, Return] : `with` `(` Expression[+In,
?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

The `with` statement adds an Object Environment Record for a computed
object to the lexical environment of the running execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.


Static Semantics: Early Errors
------------------------------

WithStatement : `with` `(` Expression `)` Statement

- It is a Syntax Error if IsStrict(this production) is `true`.
- It is a Syntax Error if IsLabelledFunction(`Statement`) is `true`.

It is only necessary to apply the second rule if the extension specified
in is implemented.



Runtime Semantics: Evaluation
-----------------------------

WithStatement : `with` `(` Expression `)` Statement 1. Let val
be ? Evaluation of `Expression`. 1. Let obj be ? ToObject(?
GetValue(val)). 1. Let oldEnv be the running execution context's
LexicalEnvironment. 1. Let newEnv be NewObjectEnvironment(obj,
`true`, oldEnv). 1. Set the running execution context's
LexicalEnvironment to newEnv. 1. Let C be Completion(Evaluation
of `Statement`). 1. Set the running execution context's
LexicalEnvironment to oldEnv. 1. Return ? UpdateEmpty(C,
`undefined`).

No matter how control leaves the embedded `Statement`, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.

The `switch` Statement
------------------------


**Syntax**


SwitchStatement[Yield, Await, Return] : `switch` `(` Expression[+In,
?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]
CaseBlock[Yield, Await, Return] : `{` CaseClauses[?Yield, ?Await,
?Return]? `}` `{` CaseClauses[?Yield, ?Await, ?Return]?
DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await,
?Return]? `}` CaseClauses[Yield, Await, Return] : CaseClause[?Yield,
?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield,
?Await, ?Return] CaseClause[Yield, Await, Return] : `case`
Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await,
?Return]? DefaultClause[Yield, Await, Return] : `default` `:`
StatementList[?Yield, ?Await, ?Return]?


Static Semantics: Early Errors
------------------------------

SwitchStatement : `switch` `(` Expression `)` CaseBlock

- It is a Syntax Error if the LexicallyDeclaredNames of `CaseBlock`
  contains any duplicate entries.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `CaseBlock` also occurs in the VarDeclaredNames of `CaseBlock`.

Runtime Semantics: CaseBlockEvaluation ( input, )
-------------------------------------------------

CaseBlock : `{` `}` 1. Return `undefined`. CaseBlock : `{`
CaseClauses `}` 1. Let V be `undefined`. 1. Let A be the
List of `CaseClause` items in `CaseClauses`, in source text order.
1. Let found be `false`. 1. For each `CaseClause` C of
A, do 1. If found is `false`, then 1. Set found to ?
CaseClauseIsSelected(C, input). 1. If found is `true`,
then 1. Let R be Completion(Evaluation of C). 1. If
R.[[Value]] is not ~empty~, set V to R.[[Value]]. 1. If
R is an abrupt completion, return ? UpdateEmpty(R, V). 1.
Return V. CaseBlock : `{` CaseClauses? DefaultClause CaseClauses?
`}` 1. Let V be `undefined`. 1. If the first `CaseClauses` is
present, then 1. Let A be the List of `CaseClause` items in the
first `CaseClauses`, in source text order. 1. Else, 1. Let A be a
new empty List. 1. Let found be `false`. 1. For each
`CaseClause` C of A, do 1. If found is `false`, then 1.
Set found to ? CaseClauseIsSelected(C, input). 1. If
found is `true`, then 1. Let R be Completion(Evaluation of
C). 1. If R.[[Value]] is not ~empty~, set V to
R.[[Value]]. 1. If R is an abrupt completion, return ?
UpdateEmpty(R, V). 1. Let foundInB be `false`. 1. If the
second `CaseClauses` is present, then 1. Let B be the List of
`CaseClause` items in the second `CaseClauses`, in source text
order. 1. Else, 1. Let B be a new empty List. 1. If found is
`false`, then 1. For each `CaseClause` C of B, do 1. If
foundInB is `false`, then 1. Set foundInB to ?
CaseClauseIsSelected(C, input). 1. If foundInB is `true`,
then 1. Let R be Completion(Evaluation of `CaseClause` C). 1.
If R.[[Value]] is not ~empty~, set V to R.[[Value]]. 1. If
R is an abrupt completion, return ? UpdateEmpty(R, V). 1. If
foundInB is `true`, return V. 1. Let defaultR be
Completion(Evaluation of `DefaultClause`). 1. If
defaultR.[[Value]] is not ~empty~, set V to
defaultR.[[Value]]. 1. If defaultR is an abrupt completion,
return ? UpdateEmpty(defaultR, V). 1. NOTE: The following is
another complete iteration of the second `CaseClauses`. 1. For each
`CaseClause` C of B, do 1. Let R be Completion(Evaluation
of `CaseClause` C). 1. If R.[[Value]] is not ~empty~, set
V to R.[[Value]]. 1. If R is an abrupt completion, return ?
UpdateEmpty(R, V). 1. Return V.

CaseClauseIsSelected ( C: a `CaseClause` Parse Node, input, )
-------------------------------------------------------------

description
   It determines whether C matches input.

1. Assert: C is an instance of the production CaseClause : `case`
Expression `:` StatementList?. 1. Let exprRef be ? Evaluation of
the `Expression` of C. 1. Let clauseSelector be ?
GetValue(exprRef). 1. Return IsStrictlyEqual(input,
clauseSelector).

This operation does not execute C's `StatementList` (if any). The
`CaseBlock` algorithm uses its return value to determine which
`StatementList` to start executing.



Runtime Semantics: Evaluation
-----------------------------

SwitchStatement : `switch` `(` Expression `)` CaseBlock 1. Let
exprRef be ? Evaluation of `Expression`. 1. Let switchValue be
? GetValue(exprRef). 1. Let oldEnv be the running execution
context's LexicalEnvironment. 1. Let blockEnv be
NewDeclarativeEnvironment(oldEnv). 1. Perform
BlockDeclarationInstantiation(`CaseBlock`, blockEnv). 1. Set the
running execution context's LexicalEnvironment to blockEnv. 1. Let
R be Completion(CaseBlockEvaluation of `CaseBlock` with argument
switchValue). 1. Set the running execution context's
LexicalEnvironment to oldEnv. 1. Return R.

No matter how control leaves the `SwitchStatement` the
LexicalEnvironment is always restored to its former state.

CaseClause : `case` Expression `:` 1. Return ~empty~. CaseClause :
`case` Expression `:` StatementList 1. Return ? Evaluation of
`StatementList`. DefaultClause : `default` `:` 1. Return ~empty~.
DefaultClause : `default` `:` StatementList 1. Return ? Evaluation
of `StatementList`.

Labelled Statements
-------------------


**Syntax**


LabelledStatement[Yield, Await, Return] : LabelIdentifier[?Yield,
?Await] `:` LabelledItem[?Yield, ?Await, ?Return] LabelledItem[Yield,
Await, Return] : Statement[?Yield, ?Await, ?Return]
FunctionDeclaration[?Yield, ?Await, ~Default]

A `Statement` may be prefixed by a label. Labelled statements are only
used in conjunction with labelled `break` and `continue` statements.
ECMAScript has no `goto` statement. A `Statement` can be part of a
`LabelledStatement`, which itself can be part of a
`LabelledStatement`, and so on. The labels introduced this way are
collectively referred to as the “current label set” when describing the
semantics of individual statements.


Static Semantics: Early Errors
------------------------------

LabelledItem : FunctionDeclaration

- It is a Syntax Error if any source text is matched by this production.

An alternative definition for this rule is provided in .

Static Semantics: IsLabelledFunction ( stmt: a `Statement` Parse Node, ): a Boolean
-----------------------------------------------------------------------------------------

1. If stmt is not a `LabelledStatement`, return `false`. 1. Let
item be the `LabelledItem` of stmt. 1. If item is
LabelledItem : FunctionDeclaration, return `true`. 1. Let subStmt
be the `Statement` of item. 1. Return
IsLabelledFunction(subStmt).



Runtime Semantics: Evaluation
-----------------------------

LabelledStatement : LabelIdentifier `:` LabelledItem 1. Return ?
LabelledEvaluation of this `LabelledStatement` with argument « ».

Runtime Semantics: LabelledEvaluation ( labelSet: a List of Strings, )
----------------------------------------------------------------------

BreakableStatement : IterationStatement 1. Let stmtResult be
Completion(LoopEvaluation of `IterationStatement` with argument
labelSet). 1. If stmtResult is a break completion, then 1. If
stmtResult.[[Target]] is ~empty~, then 1. If
stmtResult.[[Value]] is ~empty~, set stmtResult to
NormalCompletion(`undefined`). 1. Else, set stmtResult to
NormalCompletion(stmtResult.[[Value]]). 1. Return ? stmtResult.
BreakableStatement : SwitchStatement 1. Let stmtResult be
Completion(Evaluation of `SwitchStatement`). 1. If stmtResult is a
break completion, then 1. If stmtResult.[[Target]] is ~empty~, then
1. If stmtResult.[[Value]] is ~empty~, set stmtResult to
NormalCompletion(`undefined`). 1. Else, set stmtResult to
NormalCompletion(stmtResult.[[Value]]). 1. Return ? stmtResult.

A `BreakableStatement` is one that can be exited via an unlabelled
`BreakStatement`.

LabelledStatement : LabelIdentifier `:` LabelledItem 1. Let label
be the StringValue of `LabelIdentifier`. 1. Let newLabelSet be the
list-concatenation of labelSet and « label ». 1. Let
stmtResult be Completion(LabelledEvaluation of `LabelledItem` with
argument newLabelSet). 1. If stmtResult is a break completion
and stmtResult.[[Target]] is label, then 1. Set stmtResult
to NormalCompletion(stmtResult.[[Value]]). 1. Return ?
stmtResult. LabelledItem : FunctionDeclaration 1. Return ?
Evaluation of `FunctionDeclaration`. Statement : BlockStatement
VariableStatement EmptyStatement ExpressionStatement IfStatement
ContinueStatement BreakStatement ReturnStatement WithStatement
ThrowStatement TryStatement DebuggerStatement 1. Return ? Evaluation of
`Statement`.

The only two productions of `Statement` which have special semantics
for LabelledEvaluation are `BreakableStatement` and
`LabelledStatement`.

The `throw` Statement
-----------------------


**Syntax**


ThrowStatement[Yield, Await] : `throw` [no LineTerminator here]
Expression[+In, ?Yield, ?Await] `;`



Runtime Semantics: Evaluation
-----------------------------

ThrowStatement : `throw` Expression `;` 1. Let exprRef be ?
Evaluation of `Expression`. 1. Let exprValue be ?
GetValue(exprRef). 1. Return ThrowCompletion(exprValue).

The `try` Statement
---------------------


**Syntax**


TryStatement[Yield, Await, Return] : `try` Block[?Yield, ?Await,
?Return] Catch[?Yield, ?Await, ?Return] `try` Block[?Yield, ?Await,
?Return] Finally[?Yield, ?Await, ?Return] `try` Block[?Yield, ?Await,
?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
Catch[Yield, Await, Return] : `catch` `(` CatchParameter[?Yield,
?Await] `)` Block[?Yield, ?Await, ?Return] `catch` Block[?Yield,
?Await, ?Return] Finally[Yield, Await, Return] : `finally`
Block[?Yield, ?Await, ?Return] CatchParameter[Yield, Await] :
BindingIdentifier[?Yield, ?Await] BindingPattern[?Yield, ?Await]

The `try` statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a `throw` statement.
The `catch` clause provides the exception-handling code. When a catch
clause catches an exception, its `CatchParameter` is bound to that
exception.


Static Semantics: Early Errors
------------------------------

Catch : `catch` `(` CatchParameter `)` Block

- It is a Syntax Error if the BoundNames of `CatchParameter` contains
  any duplicate elements.
- It is a Syntax Error if any element of the BoundNames of
  `CatchParameter` also occurs in the LexicallyDeclaredNames of
  `Block`.
- It is a Syntax Error if any element of the BoundNames of
  `CatchParameter` also occurs in the VarDeclaredNames of `Block`.

An alternative static semantics for this production is given in .

Runtime Semantics: CatchClauseEvaluation ( thrownValue, )
---------------------------------------------------------

Catch : `catch` `(` CatchParameter `)` Block 1. Let oldEnv be
the running execution context's LexicalEnvironment. 1. Let catchEnv
be NewDeclarativeEnvironment(oldEnv). 1. For each element
argName of the BoundNames of `CatchParameter`, do 1. Perform !
catchEnv.CreateMutableBinding(argName, `false`). 1. Set the
running execution context's LexicalEnvironment to catchEnv. 1. Let
status be Completion(BindingInitialization of `CatchParameter`
with arguments thrownValue and catchEnv). 1. If status is an
abrupt completion, then 1. Set the running execution context's
LexicalEnvironment to oldEnv. 1. Return ? status. 1. Let B
be Completion(Evaluation of `Block`). 1. Set the running execution
context's LexicalEnvironment to oldEnv. 1. Return ? B. Catch :
`catch` Block 1. Return ? Evaluation of `Block`.

No matter how control leaves the `Block` the LexicalEnvironment is
always restored to its former state.



Runtime Semantics: Evaluation
-----------------------------

TryStatement : `try` Block Catch 1. Let B be Completion(Evaluation
of `Block`). 1. If B is a throw completion, let C be
Completion(CatchClauseEvaluation of `Catch` with argument
B.[[Value]]). 1. Else, let C be B. 1. Return ?
UpdateEmpty(C, `undefined`). TryStatement : `try` Block Finally
1. Let B be Completion(Evaluation of `Block`). 1. Let F be
Completion(Evaluation of `Finally`). 1. If F is a normal
completion, set F to B. 1. Return ? UpdateEmpty(F,
`undefined`). TryStatement : `try` Block Catch Finally 1. Let B
be Completion(Evaluation of `Block`). 1. If B is a throw
completion, let C be Completion(CatchClauseEvaluation of `Catch`
with argument B.[[Value]]). 1. Else, let C be B. 1. Let
F be Completion(Evaluation of `Finally`). 1. If F is a normal
completion, set F to C. 1. Return ? UpdateEmpty(F,
`undefined`).

The `debugger` Statement
--------------------------


**Syntax**


DebuggerStatement : `debugger` `;`



Runtime Semantics: Evaluation
-----------------------------

Evaluating a `DebuggerStatement` may allow an implementation to cause
a breakpoint when run under a debugger. If a debugger is not present or
active this statement has no observable effect.

DebuggerStatement : `debugger` `;` 1. If an implementation-defined
debugging facility is available and enabled, then 1. Perform an
implementation-defined debugging action. 1. Return a new
implementation-defined Completion Record. 1. Else, 1. Return ~empty~.

15. ECMAScript Language: Functions and Classes
==============================================

https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html
::

   15.1 Parameter Lists
      15.1.1 SS: Early Errors
      15.1.2 SS: ContainsExpression
      15.1.3 SS: IsSimpleParameterList
      15.1.4 SS: HasInitializer
      15.1.5 SS: ExpectedArgumentCount
   15.2 Function Definitions
      15.2.1 SS: Early Errors
      15.2.2 SS: FunctionBodyContainsUseStrict
      15.2.3 RS: EvaluateFunctionBody
      15.2.4 RS: InstantiateOrdinaryFunctionObject
      15.2.5 RS: InstantiateOrdinaryFunctionExpression
      15.2.6 RS: Evaluation
   15.3 Arrow Function Definitions
      15.3.1 SS: Early Errors
      15.3.2 SS: ConciseBodyContainsUseStrict
      15.3.3 RS: EvaluateConciseBody
      15.3.4 RS: InstantiateArrowFunctionExpression
      15.3.5 RS: Evaluation
   15.4 Method Definitions
      15.4.1 SS: Early Errors
      15.4.2 SS: HasDirectSuper
      15.4.3 SS: SpecialMethod
      15.4.4 RS: DefineMethod
      15.4.5 RS: MethodDefinitionEvaluation
   15.5 Generator Function Definitions
      15.5.1 SS: Early Errors
      15.5.2 RS: EvaluateGeneratorBody
      15.5.3 RS: InstantiateGeneratorFunctionObject
      15.5.4 RS: InstantiateGeneratorFunctionExpression
      15.5.5 RS: Evaluation
   15.6 Async Generator Function Definitions
      15.6.1 SS: Early Errors
      15.6.2 RS: EvaluateAsyncGeneratorBody
      15.6.3 RS: InstantiateAsyncGeneratorFunctionObject
      15.6.4 RS: InstantiateAsyncGeneratorFunctionExpression
      15.6.5 RS: Evaluation
   15.7 Class Definitions
      15.7.1 SS: Early Errors
      15.7.2 SS: ClassElementKind
      15.7.3 SS: ConstructorMethod
      15.7.4 SS: IsStatic
      15.7.5 SS: NonConstructorElements
      15.7.6 SS: PrototypePropertyNameList
      15.7.7 SS: AllPrivateIdentifiersValid
      15.7.8 SS: PrivateBoundIdentifiers
      15.7.9 SS: ContainsArguments
      15.7.10 RS: ClassFieldDefinitionEvaluation
      15.7.11 RS: ClassStaticBlockDefinitionEvaluation
      15.7.12 RS: EvaluateClassStaticBlockBody
      15.7.13 RS: ClassElementEvaluation
      15.7.14 RS: ClassDefinitionEvaluation
      15.7.15 RS: BindingClassDeclarationEvaluation
      15.7.16 RS: Evaluation
   15.8 Async Function Definitions
      15.8.1 SS: Early Errors
      15.8.2 RS: InstantiateAsyncFunctionObject
      15.8.3 RS: InstantiateAsyncFunctionExpression
      15.8.4 RS: EvaluateAsyncFunctionBody
      15.8.5 RS: Evaluation
   15.9 Async Arrow Function Definitions
      15.9.1 SS: Early Errors
      15.9.2 SS: AsyncConciseBodyContainsUseStrict
      15.9.3 RS: EvaluateAsyncConciseBody
      15.9.4 RS: InstantiateAsyncArrowFunctionExpression
      15.9.5 RS: Evaluation
   15.10 Tail Position Calls
      15.10.1 SS: IsInTailPosition ( call )
      15.10.2 SS: HasCallInTailPosition
      15.10.3 PrepareForTailCall ( )

Various ECMAScript language elements cause the creation of ECMAScript
function objects (). Evaluation of such functions starts with the
execution of their [[Call]] internal method ().

Parameter Lists
---------------


**Syntax**


UniqueFormalParameters[Yield, Await] : FormalParameters[?Yield, ?Await]
FormalParameters[Yield, Await] : [empty] FunctionRestParameter[?Yield,
?Await] FormalParameterList[?Yield, ?Await] FormalParameterList[?Yield,
?Await] `,` FormalParameterList[?Yield, ?Await] `,`
FunctionRestParameter[?Yield, ?Await] FormalParameterList[Yield, Await]
: FormalParameter[?Yield, ?Await] FormalParameterList[?Yield, ?Await]
`,` FormalParameter[?Yield, ?Await] FunctionRestParameter[Yield,
Await] : BindingRestElement[?Yield, ?Await] FormalParameter[Yield,
Await] : BindingElement[?Yield, ?Await]


Static Semantics: Early Errors
------------------------------

UniqueFormalParameters : FormalParameters

- It is a Syntax Error if the BoundNames of `FormalParameters`
  contains any duplicate elements.

FormalParameters : FormalParameterList

- It is a Syntax Error if IsSimpleParameterList of
  `FormalParameterList` is `false` and the BoundNames of
  `FormalParameterList` contains any duplicate elements.

Multiple occurrences of the same `BindingIdentifier` in a
`FormalParameterList` is only allowed for functions which have simple
parameter lists and which are not defined in strict mode code.

Static Semantics: ContainsExpression ( ): a Boolean
---------------------------------------------------

ObjectBindingPattern : `{` `}` `{` BindingRestProperty `}` 1.
Return `false`. ObjectBindingPattern : `{` BindingPropertyList `,`
BindingRestProperty `}` 1. Return ContainsExpression of
`BindingPropertyList`. ArrayBindingPattern : `[` Elision? `]` 1.
Return `false`. ArrayBindingPattern : `[` Elision?
BindingRestElement `]` 1. Return ContainsExpression of
`BindingRestElement`. ArrayBindingPattern : `[` BindingElementList
`,` Elision? `]` 1. Return ContainsExpression of
`BindingElementList`. ArrayBindingPattern : `[` BindingElementList
`,` Elision? BindingRestElement `]` 1. Let has be
ContainsExpression of `BindingElementList`. 1. If has is `true`,
return `true`. 1. Return ContainsExpression of `BindingRestElement`.
BindingPropertyList : BindingPropertyList `,` BindingProperty 1. Let
has be ContainsExpression of `BindingPropertyList`. 1. If has
is `true`, return `true`. 1. Return ContainsExpression of
`BindingProperty`. BindingElementList : BindingElementList `,`
BindingElisionElement 1. Let has be ContainsExpression of
`BindingElementList`. 1. If has is `true`, return `true`. 1.
Return ContainsExpression of `BindingElisionElement`.
BindingElisionElement : Elision? BindingElement 1. Return
ContainsExpression of `BindingElement`. BindingProperty : PropertyName
`:` BindingElement 1. Let has be IsComputedPropertyKey of
`PropertyName`. 1. If has is `true`, return `true`. 1. Return
ContainsExpression of `BindingElement`. BindingElement :
BindingPattern Initializer 1. Return `true`. SingleNameBinding :
BindingIdentifier 1. Return `false`. SingleNameBinding :
BindingIdentifier Initializer 1. Return `true`. BindingRestElement :
`...` BindingIdentifier 1. Return `false`. BindingRestElement :
`...` BindingPattern 1. Return ContainsExpression of
`BindingPattern`. FormalParameters : [empty] 1. Return `false`.
FormalParameters : FormalParameterList `,` FunctionRestParameter 1. If
ContainsExpression of `FormalParameterList` is `true`, return
`true`. 1. Return ContainsExpression of `FunctionRestParameter`.
FormalParameterList : FormalParameterList `,` FormalParameter 1. If
ContainsExpression of `FormalParameterList` is `true`, return
`true`. 1. Return ContainsExpression of `FormalParameter`.
ArrowParameters : BindingIdentifier 1. Return `false`. ArrowParameters
: CoverParenthesizedExpressionAndArrowParameterList 1. Let formals
be the `ArrowFormalParameters` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return
ContainsExpression of formals. AsyncArrowBindingIdentifier :
BindingIdentifier 1. Return `false`.

Static Semantics: IsSimpleParameterList ( ): a Boolean
------------------------------------------------------

BindingElement : BindingPattern 1. Return `false`. BindingElement :
BindingPattern Initializer 1. Return `false`. SingleNameBinding :
BindingIdentifier 1. Return `true`. SingleNameBinding :
BindingIdentifier Initializer 1. Return `false`. FormalParameters :
[empty] 1. Return `true`. FormalParameters : FunctionRestParameter 1.
Return `false`. FormalParameters : FormalParameterList `,`
FunctionRestParameter 1. Return `false`. FormalParameterList :
FormalParameterList `,` FormalParameter 1. If IsSimpleParameterList of
`FormalParameterList` is `false`, return `false`. 1. Return
IsSimpleParameterList of `FormalParameter`. FormalParameter :
BindingElement 1. Return IsSimpleParameterList of `BindingElement`.
ArrowParameters : BindingIdentifier 1. Return `true`. ArrowParameters
: CoverParenthesizedExpressionAndArrowParameterList 1. Let formals
be the `ArrowFormalParameters` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return
IsSimpleParameterList of formals. AsyncArrowBindingIdentifier :
BindingIdentifier 1. Return `true`.
CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments 1. Let
head be the `AsyncArrowHead` that is covered by
`CoverCallExpressionAndAsyncArrowHead`. 1. Return
IsSimpleParameterList of head.

Static Semantics: HasInitializer ( ): a Boolean
-----------------------------------------------

BindingElement : BindingPattern 1. Return `false`. BindingElement :
BindingPattern Initializer 1. Return `true`. SingleNameBinding :
BindingIdentifier 1. Return `false`. SingleNameBinding :
BindingIdentifier Initializer 1. Return `true`. FormalParameterList :
FormalParameterList `,` FormalParameter 1. If HasInitializer of
`FormalParameterList` is `true`, return `true`. 1. Return
HasInitializer of `FormalParameter`.

Static Semantics: ExpectedArgumentCount ( ): a non-negative integer
-------------------------------------------------------------------

FormalParameters : [empty] FunctionRestParameter 1. Return 0.
FormalParameters : FormalParameterList `,` FunctionRestParameter 1.
Return the ExpectedArgumentCount of `FormalParameterList`.

The ExpectedArgumentCount of a `FormalParameterList` is the number of
`FormalParameters` to the left of either the rest parameter or the
first `FormalParameter` with an Initializer. A `FormalParameter`
without an initializer is allowed after the first parameter with an
initializer but such parameters are considered to be optional with
`undefined` as their default value.

FormalParameterList : FormalParameter 1. If HasInitializer of
`FormalParameter` is `true`, return 0. 1. Return 1.
FormalParameterList : FormalParameterList `,` FormalParameter 1. Let
count be the ExpectedArgumentCount of `FormalParameterList`. 1. If
HasInitializer of `FormalParameterList` is `true` or HasInitializer
of `FormalParameter` is `true`, return count. 1. Return
count + 1. ArrowParameters : BindingIdentifier 1. Return 1.
ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList 1.
Let formals be the `ArrowFormalParameters` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return the
ExpectedArgumentCount of formals. PropertySetParameterList :
FormalParameter 1. If HasInitializer of `FormalParameter` is `true`,
return 0. 1. Return 1. AsyncArrowBindingIdentifier : BindingIdentifier
1. Return 1.

Function Definitions
--------------------


**Syntax**


FunctionDeclaration[Yield, Await, Default] : `function`
BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await]
`)` `{` FunctionBody[~Yield, ~Await] `}` [+Default] `function`
`(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield,
~Await] `}` FunctionExpression : `function`
BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield,
~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
FunctionBody[Yield, Await] : FunctionStatementList[?Yield, ?Await]
FunctionStatementList[Yield, Await] : StatementList[?Yield, ?Await,
+Return]?


Static Semantics: Early Errors
------------------------------

FunctionDeclaration : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` `function` `(`
FormalParameters `)` `{` FunctionBody `}` FunctionExpression :
`function` BindingIdentifier? `(` FormalParameters `)` `{`
FunctionBody `}`

- If IsStrict(`FormalParameters`) is `true`, the Early Error rules
  for UniqueFormalParameters : FormalParameters are applied.
- If `BindingIdentifier` is present and
  IsStrict(`BindingIdentifier`) is `true`, it is a Syntax Error if
  the StringValue of `BindingIdentifier` is either `"eval"` or
  `"arguments"`.
- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `FunctionBody` is `true` and IsSimpleParameterList of
  `FormalParameters` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `FormalParameters` also occurs in the LexicallyDeclaredNames of
  `FunctionBody`.
- It is a Syntax Error if `FormalParameters` Contains
  `SuperProperty` is `true`.
- It is a Syntax Error if `FunctionBody` Contains `SuperProperty` is
  `true`.
- It is a Syntax Error if `FormalParameters` Contains `SuperCall` is
  `true`.
- It is a Syntax Error if `FunctionBody` Contains `SuperCall` is
  `true`.

The LexicallyDeclaredNames of a `FunctionBody` does not include
identifiers bound using var or function declarations.

FunctionBody : FunctionStatementList

- It is a Syntax Error if the LexicallyDeclaredNames of
  `FunctionStatementList` contains any duplicate entries.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `FunctionStatementList` also occurs in the VarDeclaredNames of
  `FunctionStatementList`.
- It is a Syntax Error if ContainsDuplicateLabels of
  `FunctionStatementList` with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedBreakTarget of
  `FunctionStatementList` with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedContinueTarget of
  `FunctionStatementList` with arguments « » and « » is `true`.

Static Semantics: FunctionBodyContainsUseStrict ( ): a Boolean
--------------------------------------------------------------

FunctionBody : FunctionStatementList 1. If the Directive Prologue of
`FunctionBody` contains a Use Strict Directive, return `true`;
otherwise, return `false`.

Runtime Semantics: EvaluateFunctionBody ( functionObject: an ECMAScript function object, argumentsList: a List of ECMAScript language values, )
-----------------------------------------------------------------------------------------------------------------------------------------------

FunctionBody : FunctionStatementList 1. Perform ?
FunctionDeclarationInstantiation(functionObject, argumentsList).
1. Return ? Evaluation of `FunctionStatementList`.

Runtime Semantics: InstantiateOrdinaryFunctionObject ( env: an Environment Record, privateEnv: a PrivateEnvironment Record or `null`, ): an ECMAScript function object
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FunctionDeclaration : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` 1. Let name be the
StringValue of `BindingIdentifier`. 1. Let sourceText be the
source text matched by `FunctionDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%Function.prototype%, sourceText,
`FormalParameters`, `FunctionBody`, ~non-lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(F, name). 1. Perform
MakeConstructor(F). 1. Return F. FunctionDeclaration :
`function` `(` FormalParameters `)` `{` FunctionBody `}` 1.
Let sourceText be the source text matched by
`FunctionDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%Function.prototype%, sourceText,
`FormalParameters`, `FunctionBody`, ~non-lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(F, `"default"`). 1.
Perform MakeConstructor(F). 1. Return F.

An anonymous `FunctionDeclaration` can only occur as part of an
`export default` declaration, and its function code is therefore
always strict mode code.

Runtime Semantics: InstantiateOrdinaryFunctionExpression ( optional name: a property key or a Private Name, ): an ECMAScript function object
------------------------------------------------------------------------------------------------------------------------------------------------

FunctionExpression : `function` `(` FormalParameters `)` `{`
FunctionBody `}` 1. If name is not present, set name to
`""`. 1. Let env be the LexicalEnvironment of the running
execution context. 1. Let privateEnv be the running execution
context's PrivateEnvironment. 1. Let sourceText be the source text
matched by `FunctionExpression`. 1. Let closure be
OrdinaryFunctionCreate(%Function.prototype%, sourceText,
`FormalParameters`, `FunctionBody`, ~non-lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(closure, name). 1.
Perform MakeConstructor(closure). 1. Return closure.
FunctionExpression : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` 1. Assert: name is
not present. 1. Set name to the StringValue of
`BindingIdentifier`. 1. Let outerEnv be the running execution
context's LexicalEnvironment. 1. Let funcEnv be
NewDeclarativeEnvironment(outerEnv). 1. Perform !
funcEnv.CreateImmutableBinding(name, `false`). 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by `FunctionExpression`.
1. Let closure be OrdinaryFunctionCreate(%Function.prototype%,
sourceText, `FormalParameters`, `FunctionBody`,
~non-lexical-this~, funcEnv, privateEnv). 1. Perform
SetFunctionName(closure, name). 1. Perform
MakeConstructor(closure). 1. Perform !
funcEnv.InitializeBinding(name, closure). 1. Return
closure.

The `BindingIdentifier` in a `FunctionExpression` can be referenced
from inside the `FunctionExpression`'s `FunctionBody` to allow the
function to call itself recursively. However, unlike in a
`FunctionDeclaration`, the `BindingIdentifier` in a
`FunctionExpression` cannot be referenced from and does not affect the
scope enclosing the `FunctionExpression`.



Runtime Semantics: Evaluation
-----------------------------

FunctionDeclaration : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` 1. Return ~empty~.

An alternative semantics is provided in .

FunctionDeclaration : `function` `(` FormalParameters `)` `{`
FunctionBody `}` 1. Return ~empty~. FunctionExpression : `function`
BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
1. Return InstantiateOrdinaryFunctionExpression of
`FunctionExpression`.

A `"prototype"` property is automatically created for every function
defined using a `FunctionDeclaration` or `FunctionExpression`, to
allow for the possibility that the function will be used as a
constructor.

FunctionStatementList : [empty] 1. Return `undefined`.

Arrow Function Definitions
--------------------------


**Syntax**


ArrowFunction[In, Yield, Await] : ArrowParameters[?Yield, ?Await] [no
LineTerminator here] `=>` ConciseBody[?In] ArrowParameters[Yield,
Await] : BindingIdentifier[?Yield, ?Await]
CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
#parencover ConciseBody[In] : [lookahead != `{`] ExpressionBody[?In,
~Await] `{` FunctionBody[~Yield, ~Await] `}` ExpressionBody[In,
Await] : AssignmentExpression[?In, ~Yield, ?Await]

.. _supplemental-syntax-3:

**Supplemental Syntax**

| When processing an instance of the production
| ArrowParameters[Yield, Await] :
  CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
| the interpretation of
  `CoverParenthesizedExpressionAndArrowParameterList` is refined using
  the following grammar:

ArrowFormalParameters[Yield, Await] : `(`
UniqueFormalParameters[?Yield, ?Await] `)`


Static Semantics: Early Errors
------------------------------

ArrowFunction : ArrowParameters `=>` ConciseBody

- It is a Syntax Error if `ArrowParameters` Contains
  `YieldExpression` is `true`.
- It is a Syntax Error if `ArrowParameters` Contains
  `AwaitExpression` is `true`.
- It is a Syntax Error if ConciseBodyContainsUseStrict of
  `ConciseBody` is `true` and IsSimpleParameterList of
  `ArrowParameters` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `ArrowParameters` also occurs in the LexicallyDeclaredNames of
  `ConciseBody`.

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

- `CoverParenthesizedExpressionAndArrowParameterList` must cover an
  `ArrowFormalParameters`.

Static Semantics: ConciseBodyContainsUseStrict ( ): a Boolean
-------------------------------------------------------------

ConciseBody : ExpressionBody 1. Return `false`. ConciseBody : `{`
FunctionBody `}` 1. Return FunctionBodyContainsUseStrict of
`FunctionBody`.

Runtime Semantics: EvaluateConciseBody ( functionObject: an ECMAScript function object, argumentsList: a List of ECMAScript language values, )
----------------------------------------------------------------------------------------------------------------------------------------------

ConciseBody : ExpressionBody 1. Perform ?
FunctionDeclarationInstantiation(functionObject, argumentsList).
1. Return ? Evaluation of `ExpressionBody`.

Runtime Semantics: InstantiateArrowFunctionExpression ( optional name: a property key or a Private Name, ): an ECMAScript function object
---------------------------------------------------------------------------------------------------------------------------------------------

ArrowFunction : ArrowParameters `=>` ConciseBody 1. If name is not
present, set name to `""`. 1. Let env be the
LexicalEnvironment of the running execution context. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by `ArrowFunction`. 1.
[id="step-arrowfunction-evaluation-functioncreate"] Let closure be
OrdinaryFunctionCreate(%Function.prototype%, sourceText,
`ArrowParameters`, `ConciseBody`, ~lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(closure, name). 1.
Return closure.

An `ArrowFunction` does not define local bindings for `arguments`,
`super`, `this`, or `new.target`. Any reference to `arguments`,
`super`, `this`, or `new.target` within an `ArrowFunction` must
resolve to a binding in a lexically enclosing environment. Typically
this will be the Function Environment of an immediately enclosing
function. Even though an `ArrowFunction` may contain references to
`super`, the function object created in step is not made into a method
by performing MakeMethod. An `ArrowFunction` that references `super`
is always contained within a non-`ArrowFunction` and the necessary
state to implement `super` is accessible via the env that is
captured by the function object of the `ArrowFunction`.



Runtime Semantics: Evaluation
-----------------------------

ArrowFunction : ArrowParameters `=>` ConciseBody 1. Return
InstantiateArrowFunctionExpression of `ArrowFunction`. ExpressionBody
: AssignmentExpression 1. Let exprRef be ? Evaluation of
`AssignmentExpression`. 1. Let exprValue be ?
GetValue(exprRef). 1. Return ReturnCompletion(exprValue).

Method Definitions
------------------


**Syntax**


MethodDefinition[Yield, Await] : ClassElementName[?Yield, ?Await] `(`
UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield,
~Await] `}` GeneratorMethod[?Yield, ?Await] AsyncMethod[?Yield,
?Await] AsyncGeneratorMethod[?Yield, ?Await] `get`
ClassElementName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield,
~Await] `}` `set` ClassElementName[?Yield, ?Await] `(`
PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`
PropertySetParameterList : FormalParameter[~Yield, ~Await]


Static Semantics: Early Errors
------------------------------

MethodDefinition : ClassElementName `(` UniqueFormalParameters `)`
`{` FunctionBody `}`

- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `FunctionBody` is `true` and IsSimpleParameterList of
  `UniqueFormalParameters` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `UniqueFormalParameters` also occurs in the LexicallyDeclaredNames
  of `FunctionBody`.

MethodDefinition : `set` ClassElementName `(`
PropertySetParameterList `)` `{` FunctionBody `}`

- It is a Syntax Error if the BoundNames of `PropertySetParameterList`
  contains any duplicate elements.
- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `FunctionBody` is `true` and IsSimpleParameterList of
  `PropertySetParameterList` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `PropertySetParameterList` also occurs in the LexicallyDeclaredNames
  of `FunctionBody`.

Static Semantics: HasDirectSuper ( ): a Boolean
-----------------------------------------------

MethodDefinition : ClassElementName `(` UniqueFormalParameters `)`
`{` FunctionBody `}` 1. If `UniqueFormalParameters` Contains
`SuperCall` is `true`, return `true`. 1. Return `FunctionBody`
Contains `SuperCall`. MethodDefinition : `get` ClassElementName
`(` `)` `{` FunctionBody `}` 1. Return `FunctionBody` Contains
`SuperCall`. MethodDefinition : `set` ClassElementName `(`
PropertySetParameterList `)` `{` FunctionBody `}` 1. If
`PropertySetParameterList` Contains `SuperCall` is `true`, return
`true`. 1. Return `FunctionBody` Contains `SuperCall`.
GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters
`)` `{` GeneratorBody `}` 1. If `UniqueFormalParameters`
Contains `SuperCall` is `true`, return `true`. 1. Return
`GeneratorBody` Contains `SuperCall`. AsyncGeneratorMethod :
`async` `*` ClassElementName `(` UniqueFormalParameters `)`
`{` AsyncGeneratorBody `}` 1. If `UniqueFormalParameters` Contains
`SuperCall` is `true`, return `true`. 1. Return
`AsyncGeneratorBody` Contains `SuperCall`. AsyncMethod : `async`
ClassElementName `(` UniqueFormalParameters `)` `{`
AsyncFunctionBody `}` 1. If `UniqueFormalParameters` Contains
`SuperCall` is `true`, return `true`. 1. Return
`AsyncFunctionBody` Contains `SuperCall`.

Static Semantics: SpecialMethod ( ): a Boolean
----------------------------------------------

MethodDefinition : ClassElementName `(` UniqueFormalParameters `)`
`{` FunctionBody `}` 1. Return `false`. MethodDefinition :
GeneratorMethod AsyncMethod AsyncGeneratorMethod `get`
ClassElementName `(` `)` `{` FunctionBody `}` `set`
ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody
`}` 1. Return `true`.

Runtime Semantics: DefineMethod ( object: an Object, optional functionPrototype: an Object, )
---------------------------------------------------------------------------------------------

MethodDefinition : ClassElementName `(` UniqueFormalParameters `)`
`{` FunctionBody `}` 1. Let propKey be ? Evaluation of
`ClassElementName`. 1. Let env be the running execution context's
LexicalEnvironment. 1. Let privateEnv be the running execution
context's PrivateEnvironment. 1. If functionPrototype is present,
then 1. Let prototype be functionPrototype. 1. Else, 1. Let
prototype be %Function.prototype%. 1. Let sourceText be the
source text matched by `MethodDefinition`. 1. Let closure be
OrdinaryFunctionCreate(prototype, sourceText,
`UniqueFormalParameters`, `FunctionBody`, ~non-lexical-this~,
env, privateEnv). 1. Perform MakeMethod(closure,
object). 1. Return the Record { [[Key]]: propKey, [[Closure]]:
closure }.

Runtime Semantics: MethodDefinitionEvaluation ( object: an Object, enumerable: a Boolean, )
-------------------------------------------------------------------------------------------

MethodDefinition : ClassElementName `(` UniqueFormalParameters `)`
`{` FunctionBody `}` 1. Let methodDef be ? DefineMethod of
`MethodDefinition` with argument object. 1. Perform
SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]). 1.
Return ? DefineMethodProperty(object, methodDef.[[Key]],
methodDef.[[Closure]], enumerable). MethodDefinition : `get`
ClassElementName `(` `)` `{` FunctionBody `}` 1. Let propKey
be ? Evaluation of `ClassElementName`. 1. Let env be the running
execution context's LexicalEnvironment. 1. Let privateEnv be the
running execution context's PrivateEnvironment. 1. Let sourceText be
the source text matched by `MethodDefinition`. 1. Let
formalParameterList be an instance of the production
FormalParameters : [empty]. 1. Let closure be
OrdinaryFunctionCreate(%Function.prototype%, sourceText,
formalParameterList, `FunctionBody`, ~non-lexical-this~, env,
privateEnv). 1. Perform MakeMethod(closure, object). 1.
Perform SetFunctionName(closure, propKey, `"get"`). 1. If
propKey is a Private Name, then 1. Return PrivateElement { [[Key]]:
propKey, [[Kind]]: ~accessor~, [[Get]]: closure, [[Set]]:
`undefined` }. 1. Else, 1. Let desc be the PropertyDescriptor {
[[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]:
`true` }. 1. Perform ? DefinePropertyOrThrow(object, propKey,
desc). 1. Return ~unused~. MethodDefinition : `set`
ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody
`}` 1. Let propKey be ? Evaluation of `ClassElementName`. 1. Let
env be the running execution context's LexicalEnvironment. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by `MethodDefinition`.
1. Let closure be OrdinaryFunctionCreate(%Function.prototype%,
sourceText, `PropertySetParameterList`, `FunctionBody`,
~non-lexical-this~, env, privateEnv). 1. Perform
MakeMethod(closure, object). 1. Perform
SetFunctionName(closure, propKey, `"set"`). 1. If propKey
is a Private Name, then 1. Return PrivateElement { [[Key]]: propKey,
[[Kind]]: ~accessor~, [[Get]]: `undefined`, [[Set]]: closure }. 1.
Else, 1. Let desc be the PropertyDescriptor { [[Set]]: closure,
[[Enumerable]]: enumerable, [[Configurable]]: `true` }. 1. Perform
? DefinePropertyOrThrow(object, propKey, desc). 1. Return
~unused~. GeneratorMethod : `*` ClassElementName `(`
UniqueFormalParameters `)` `{` GeneratorBody `}` 1. Let
propKey be ? Evaluation of `ClassElementName`. 1. Let env be
the running execution context's LexicalEnvironment. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by `GeneratorMethod`. 1.
Let closure be OrdinaryFunctionCreate(%GeneratorFunction.prototype%,
sourceText, `UniqueFormalParameters`, `GeneratorBody`,
~non-lexical-this~, env, privateEnv). 1. Perform
MakeMethod(closure, object). 1. Perform
SetFunctionName(closure, propKey). 1. Let prototype be
OrdinaryObjectCreate(%GeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(closure, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Return ?
DefineMethodProperty(object, propKey, closure,
enumerable). AsyncGeneratorMethod : `async` `*` ClassElementName
`(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}` 1. Let
propKey be ? Evaluation of `ClassElementName`. 1. Let env be
the running execution context's LexicalEnvironment. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by
`AsyncGeneratorMethod`. 1. Let closure be
OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%,
sourceText, `UniqueFormalParameters`, `AsyncGeneratorBody`,
~non-lexical-this~, env, privateEnv). 1. Perform
MakeMethod(closure, object). 1. Perform
SetFunctionName(closure, propKey). 1. Let prototype be
OrdinaryObjectCreate(%AsyncGeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(closure, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Return ?
DefineMethodProperty(object, propKey, closure,
enumerable). AsyncMethod : `async` ClassElementName `(`
UniqueFormalParameters `)` `{` AsyncFunctionBody `}` 1. Let
propKey be ? Evaluation of `ClassElementName`. 1. Let env be
the LexicalEnvironment of the running execution context. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by `AsyncMethod`. 1. Let
closure be OrdinaryFunctionCreate(%AsyncFunction.prototype%,
sourceText, `UniqueFormalParameters`, `AsyncFunctionBody`,
~non-lexical-this~, env, privateEnv). 1. Perform
MakeMethod(closure, object). 1. Perform
SetFunctionName(closure, propKey). 1. Return ?
DefineMethodProperty(object, propKey, closure,
enumerable).

Generator Function Definitions
------------------------------


**Syntax**


GeneratorDeclaration[Yield, Await, Default] : `function` `*`
BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await]
`)` `{` GeneratorBody `}` [+Default] `function` `*` `(`
FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
GeneratorExpression : `function` `*` BindingIdentifier[+Yield,
~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{`
GeneratorBody `}` GeneratorMethod[Yield, Await] : `*`
ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield,
~Await] `)` `{` GeneratorBody `}` GeneratorBody :
FunctionBody[+Yield, ~Await] YieldExpression[In, Await] : `yield`
`yield` [no LineTerminator here] AssignmentExpression[?In, +Yield,
?Await] `yield` [no LineTerminator here] `*`
AssignmentExpression[?In, +Yield, ?Await]

The syntactic context immediately following `yield` requires use of
the `InputElementRegExpOrTemplateTail` lexical goal.

`YieldExpression` cannot be used within the `FormalParameters` of a
generator function because any expressions that are part of
`FormalParameters` are evaluated before the resulting Generator is in
a resumable state.

Abstract operations relating to Generators are defined in .


Static Semantics: Early Errors
------------------------------

GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters
`)` `{` GeneratorBody `}`

- It is a Syntax Error if HasDirectSuper of `GeneratorMethod` is
  `true`.
- It is a Syntax Error if `UniqueFormalParameters` Contains
  `YieldExpression` is `true`.
- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `GeneratorBody` is `true` and IsSimpleParameterList of
  `UniqueFormalParameters` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `UniqueFormalParameters` also occurs in the LexicallyDeclaredNames
  of `GeneratorBody`.

GeneratorDeclaration : `function` `*` BindingIdentifier `(`
FormalParameters `)` `{` GeneratorBody `}` `function` `*`
`(` FormalParameters `)` `{` GeneratorBody `}`
GeneratorExpression : `function` `*` BindingIdentifier? `(`
FormalParameters `)` `{` GeneratorBody `}`

- If IsStrict(`FormalParameters`) is `true`, the Early Error rules
  for UniqueFormalParameters : FormalParameters are applied.
- If `BindingIdentifier` is present and
  IsStrict(`BindingIdentifier`) is `true`, it is a Syntax Error if
  the StringValue of `BindingIdentifier` is either `"eval"` or
  `"arguments"`.
- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `GeneratorBody` is `true` and IsSimpleParameterList of
  `FormalParameters` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `FormalParameters` also occurs in the LexicallyDeclaredNames of
  `GeneratorBody`.
- It is a Syntax Error if `FormalParameters` Contains
  `YieldExpression` is `true`.
- It is a Syntax Error if `FormalParameters` Contains
  `SuperProperty` is `true`.
- It is a Syntax Error if `GeneratorBody` Contains `SuperProperty`
  is `true`.
- It is a Syntax Error if `FormalParameters` Contains `SuperCall` is
  `true`.
- It is a Syntax Error if `GeneratorBody` Contains `SuperCall` is
  `true`.

Runtime Semantics: EvaluateGeneratorBody ( functionObject: an ECMAScript function object, argumentsList: a List of ECMAScript language values, ): a throw completion or a return completion
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

GeneratorBody : FunctionBody 1. Perform ?
FunctionDeclarationInstantiation(functionObject, argumentsList).
1. Let G be ? OrdinaryCreateFromConstructor(functionObject,
`"%GeneratorPrototype%"`, « [[GeneratorState]], [[GeneratorContext]],
[[GeneratorBrand]] »). 1. Set G.[[GeneratorBrand]] to ~empty~. 1.
Set G.[[GeneratorState]] to ~suspended-start~. 1. Perform
GeneratorStart(G, `FunctionBody`). 1. Return
ReturnCompletion(G).

Runtime Semantics: InstantiateGeneratorFunctionObject ( env: an Environment Record, privateEnv: a PrivateEnvironment Record or `null`, ): an ECMAScript function object
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

GeneratorDeclaration : `function` `*` BindingIdentifier `(`
FormalParameters `)` `{` GeneratorBody `}` 1. Let name be the
StringValue of `BindingIdentifier`. 1. Let sourceText be the
source text matched by `GeneratorDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
`FormalParameters`, `GeneratorBody`, ~non-lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(F, name). 1. Let
prototype be OrdinaryObjectCreate(%GeneratorPrototype%). 1. Perform
! DefinePropertyOrThrow(F, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Return F.
GeneratorDeclaration : `function` `*` `(` FormalParameters `)`
`{` GeneratorBody `}` 1. Let sourceText be the source text
matched by `GeneratorDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
`FormalParameters`, `GeneratorBody`, ~non-lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(F, `"default"`). 1.
Let prototype be OrdinaryObjectCreate(%GeneratorPrototype%). 1.
Perform ! DefinePropertyOrThrow(F, `"prototype"`,
PropertyDescriptor { [[Value]]: prototype, [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }). 1. Return
F.

An anonymous `GeneratorDeclaration` can only occur as part of an
`export default` declaration, and its function code is therefore
always strict mode code.

Runtime Semantics: InstantiateGeneratorFunctionExpression ( optional name: a property key or a Private Name, ): an ECMAScript function object
-------------------------------------------------------------------------------------------------------------------------------------------------

GeneratorExpression : `function` `*` `(` FormalParameters `)`
`{` GeneratorBody `}` 1. If name is not present, set name to
`""`. 1. Let env be the LexicalEnvironment of the running
execution context. 1. Let privateEnv be the running execution
context's PrivateEnvironment. 1. Let sourceText be the source text
matched by `GeneratorExpression`. 1. Let closure be
OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
`FormalParameters`, `GeneratorBody`, ~non-lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(closure, name). 1.
Let prototype be OrdinaryObjectCreate(%GeneratorPrototype%). 1.
Perform ! DefinePropertyOrThrow(closure, `"prototype"`,
PropertyDescriptor { [[Value]]: prototype, [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }). 1. Return
closure. GeneratorExpression : `function` `*` BindingIdentifier
`(` FormalParameters `)` `{` GeneratorBody `}` 1. Assert:
name is not present. 1. Set name to the StringValue of
`BindingIdentifier`. 1. Let outerEnv be the running execution
context's LexicalEnvironment. 1. Let funcEnv be
NewDeclarativeEnvironment(outerEnv). 1. Perform !
funcEnv.CreateImmutableBinding(name, `false`). 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by
`GeneratorExpression`. 1. Let closure be
OrdinaryFunctionCreate(%GeneratorFunction.prototype%, sourceText,
`FormalParameters`, `GeneratorBody`, ~non-lexical-this~,
funcEnv, privateEnv). 1. Perform SetFunctionName(closure,
name). 1. Let prototype be
OrdinaryObjectCreate(%GeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(closure, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Perform !
funcEnv.InitializeBinding(name, closure). 1. Return
closure.

The `BindingIdentifier` in a `GeneratorExpression` can be referenced
from inside the `GeneratorExpression`'s `FunctionBody` to allow the
generator code to call itself recursively. However, unlike in a
`GeneratorDeclaration`, the `BindingIdentifier` in a
`GeneratorExpression` cannot be referenced from and does not affect
the scope enclosing the `GeneratorExpression`.



Runtime Semantics: Evaluation
-----------------------------

GeneratorExpression : `function` `*` BindingIdentifier? `(`
FormalParameters `)` `{` GeneratorBody `}` 1. Return
InstantiateGeneratorFunctionExpression of `GeneratorExpression`.
YieldExpression : `yield` 1. Return ? Yield(`undefined`).
YieldExpression : `yield` AssignmentExpression 1. Let exprRef be ?
Evaluation of `AssignmentExpression`. 1. Let value be ?
GetValue(exprRef). 1. Return ? Yield(value). YieldExpression :
`yield` `*` AssignmentExpression 1. Let generatorKind be
GetGeneratorKind(). 1. Let exprRef be ? Evaluation of
`AssignmentExpression`. 1. Let value be ? GetValue(exprRef).
1. Let iteratorRecord be ? GetIterator(value,
generatorKind). 1. Let iterator be
iteratorRecord.[[Iterator]]. 1. Let received be
NormalCompletion(`undefined`). 1. Repeat, 1. If received is a
normal completion, then 1. Let innerResult be ?
Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]],
« received.[[Value]] »). 1. If generatorKind is ~async~, set
innerResult to ? Await(innerResult). 1. If innerResult is
not an Object, throw a `TypeError` exception. 1. Let done be ?
IteratorComplete(innerResult). 1. If done is `true`, then 1.
Return ? IteratorValue(innerResult). 1. If generatorKind is
~async~, set received to Completion(AsyncGeneratorYield(?
IteratorValue(innerResult))). 1. Else, set received to
Completion(GeneratorYield(innerResult)). 1. Else if received is
a throw completion, then 1. Let throw be ? GetMethod(iterator,
`"throw"`). 1. If throw is not `undefined`, then 1. Let
innerResult be ? Call(throw, iterator, «
received.[[Value]] »). 1. If generatorKind is ~async~, set
innerResult to ? Await(innerResult). 1. NOTE: Exceptions from
the inner iterator `throw` method are propagated. Normal completions
from an inner `throw` method are processed similarly to an inner
`next`. 1. If innerResult is not an Object, throw a `TypeError`
exception. 1. Let done be ? IteratorComplete(innerResult). 1. If
done is `true`, then 1. Return ? IteratorValue(innerResult).
1. If generatorKind is ~async~, set received to
Completion(AsyncGeneratorYield(? IteratorValue(innerResult))). 1.
Else, set received to Completion(GeneratorYield(innerResult)).
1. Else, 1. NOTE: If iterator does not have a `throw` method, this
throw is going to terminate the `yield*` loop. But first we need to
give iterator a chance to clean up. 1. Let closeCompletion be
NormalCompletion(~empty~). 1. If generatorKind is ~async~, perform ?
AsyncIteratorClose(iteratorRecord, closeCompletion). 1. Else,
perform ? IteratorClose(iteratorRecord, closeCompletion). 1.
NOTE: The next step throws a `TypeError` to indicate that there was a
`yield*` protocol violation: iterator does not have a `throw`
method. 1. Throw a `TypeError` exception. 1. Else, 1. Assert:
received is a return completion. 1. Let return be ?
GetMethod(iterator, `"return"`). 1. If return is
`undefined`, then 1. Set value to received.[[Value]]. 1. If
generatorKind is ~async~, then 1. Set value to ?
Await(value). 1. Return ReturnCompletion(value). 1. Let
innerReturnResult be ? Call(return, iterator, «
received.[[Value]] »). 1. If generatorKind is ~async~, set
innerReturnResult to ? Await(innerReturnResult). 1. If
innerReturnResult is not an Object, throw a `TypeError` exception.
1. Let done be ? IteratorComplete(innerReturnResult). 1. If
done is `true`, then 1. Set value to ?
IteratorValue(innerReturnResult). 1. Return
ReturnCompletion(value). 1. If generatorKind is ~async~, set
received to Completion(AsyncGeneratorYield(?
IteratorValue(innerReturnResult))). 1. Else, set received to
Completion(GeneratorYield(innerReturnResult)).

Async Generator Function Definitions
------------------------------------


**Syntax**


AsyncGeneratorDeclaration[Yield, Await, Default] : `async` [no
LineTerminator here] `function` `*` BindingIdentifier[?Yield,
?Await] `(` FormalParameters[+Yield, +Await] `)` `{`
AsyncGeneratorBody `}` [+Default] `async` [no LineTerminator here]
`function` `*` `(` FormalParameters[+Yield, +Await] `)` `{`
AsyncGeneratorBody `}` AsyncGeneratorExpression : `async` [no
LineTerminator here] `function` `*` BindingIdentifier[+Yield,
+Await]? `(` FormalParameters[+Yield, +Await] `)` `{`
AsyncGeneratorBody `}` AsyncGeneratorMethod[Yield, Await] : `async`
[no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(`
UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody
`}` AsyncGeneratorBody : FunctionBody[+Yield, +Await]

`YieldExpression` and `AwaitExpression` cannot be used within the
`FormalParameters` of an async generator function because any
expressions that are part of `FormalParameters` are evaluated before
the resulting AsyncGenerator is in a resumable state.

Abstract operations relating to AsyncGenerators are defined in .


Static Semantics: Early Errors
------------------------------

AsyncGeneratorMethod : `async` `*` ClassElementName `(`
UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

- It is a Syntax Error if HasDirectSuper of `AsyncGeneratorMethod` is
  `true`.
- It is a Syntax Error if `UniqueFormalParameters` Contains
  `YieldExpression` is `true`.
- It is a Syntax Error if `UniqueFormalParameters` Contains
  `AwaitExpression` is `true`.
- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `AsyncGeneratorBody` is `true` and IsSimpleParameterList of
  `UniqueFormalParameters` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `UniqueFormalParameters` also occurs in the LexicallyDeclaredNames
  of `AsyncGeneratorBody`.

AsyncGeneratorDeclaration : `async` `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` `async` `function` `*` `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` AsyncGeneratorExpression : `async`
`function` `*` BindingIdentifier? `(` FormalParameters `)` `{`
AsyncGeneratorBody `}`

- If IsStrict(`FormalParameters`) is `true`, the Early Error rules
  for UniqueFormalParameters : FormalParameters are applied.
- If `BindingIdentifier` is present and
  IsStrict(`BindingIdentifier`) is `true`, it is a Syntax Error if
  the StringValue of `BindingIdentifier` is either `"eval"` or
  `"arguments"`.
- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `AsyncGeneratorBody` is `true` and IsSimpleParameterList of
  `FormalParameters` is `false`.
- It is a Syntax Error if any element of the BoundNames of
  `FormalParameters` also occurs in the LexicallyDeclaredNames of
  `AsyncGeneratorBody`.
- It is a Syntax Error if `FormalParameters` Contains
  `YieldExpression` is `true`.
- It is a Syntax Error if `FormalParameters` Contains
  `AwaitExpression` is `true`.
- It is a Syntax Error if `FormalParameters` Contains
  `SuperProperty` is `true`.
- It is a Syntax Error if `AsyncGeneratorBody` Contains
  `SuperProperty` is `true`.
- It is a Syntax Error if `FormalParameters` Contains `SuperCall` is
  `true`.
- It is a Syntax Error if `AsyncGeneratorBody` Contains `SuperCall`
  is `true`.

Runtime Semantics: EvaluateAsyncGeneratorBody ( functionObject: an ECMAScript function object, argumentsList: a List of ECMAScript language values, ): a throw completion or a return completion
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AsyncGeneratorBody : FunctionBody 1. Perform ?
FunctionDeclarationInstantiation(functionObject, argumentsList).
1. Let generator be ?
OrdinaryCreateFromConstructor(functionObject,
`"%AsyncGeneratorPrototype%"`, « [[AsyncGeneratorState]],
[[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]]
»). 1. Set generator.[[GeneratorBrand]] to ~empty~. 1. Set
generator.[[AsyncGeneratorState]] to ~suspended-start~. 1. Perform
AsyncGeneratorStart(generator, `FunctionBody`). 1. Return
ReturnCompletion(generator).

Runtime Semantics: InstantiateAsyncGeneratorFunctionObject ( env: an Environment Record, privateEnv: a PrivateEnvironment Record or `null`, ): an ECMAScript function object
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AsyncGeneratorDeclaration : `async` `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` 1. Let name be the StringValue of `BindingIdentifier`. 1.
Let sourceText be the source text matched by
`AsyncGeneratorDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%,
sourceText, `FormalParameters`, `AsyncGeneratorBody`,
~non-lexical-this~, env, privateEnv). 1. Perform
SetFunctionName(F, name). 1. Let prototype be
OrdinaryObjectCreate(%AsyncGeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(F, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Return F.
AsyncGeneratorDeclaration : `async` `function` `*` `(`
FormalParameters `)` `{` AsyncGeneratorBody `}` 1. Let
sourceText be the source text matched by
`AsyncGeneratorDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%,
sourceText, `FormalParameters`, `AsyncGeneratorBody`,
~non-lexical-this~, env, privateEnv). 1. Perform
SetFunctionName(F, `"default"`). 1. Let prototype be
OrdinaryObjectCreate(%AsyncGeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(F, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Return F.

An anonymous `AsyncGeneratorDeclaration` can only occur as part of an
`export default` declaration.

Runtime Semantics: InstantiateAsyncGeneratorFunctionExpression ( optional name: a property key or a Private Name, ): an ECMAScript function object
------------------------------------------------------------------------------------------------------------------------------------------------------

AsyncGeneratorExpression : `async` `function` `*` `(`
FormalParameters `)` `{` AsyncGeneratorBody `}` 1. If name is
not present, set name to `""`. 1. Let env be the
LexicalEnvironment of the running execution context. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by
`AsyncGeneratorExpression`. 1. Let closure be
OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%,
sourceText, `FormalParameters`, `AsyncGeneratorBody`,
~non-lexical-this~, env, privateEnv). 1. Perform
SetFunctionName(closure, name). 1. Let prototype be
OrdinaryObjectCreate(%AsyncGeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(closure, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Return closure.
AsyncGeneratorExpression : `async` `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` 1. Assert: name is not present. 1. Set name to the
StringValue of `BindingIdentifier`. 1. Let outerEnv be the running
execution context's LexicalEnvironment. 1. Let funcEnv be
NewDeclarativeEnvironment(outerEnv). 1. Perform !
funcEnv.CreateImmutableBinding(name, `false`). 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by
`AsyncGeneratorExpression`. 1. Let closure be
OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%,
sourceText, `FormalParameters`, `AsyncGeneratorBody`,
~non-lexical-this~, funcEnv, privateEnv). 1. Perform
SetFunctionName(closure, name). 1. Let prototype be
OrdinaryObjectCreate(%AsyncGeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(closure, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Perform !
funcEnv.InitializeBinding(name, closure). 1. Return
closure.

The `BindingIdentifier` in an `AsyncGeneratorExpression` can be
referenced from inside the `AsyncGeneratorExpression`'s
`AsyncGeneratorBody` to allow the generator code to call itself
recursively. However, unlike in an `AsyncGeneratorDeclaration`, the
`BindingIdentifier` in an `AsyncGeneratorExpression` cannot be
referenced from and does not affect the scope enclosing the
`AsyncGeneratorExpression`.



Runtime Semantics: Evaluation
-----------------------------

AsyncGeneratorExpression : `async` `function` `*`
BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` 1. Return InstantiateAsyncGeneratorFunctionExpression of
`AsyncGeneratorExpression`.

Class Definitions
-----------------


**Syntax**


ClassDeclaration[Yield, Await, Default] : `class`
BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await] [+Default]
`class` ClassTail[?Yield, ?Await] ClassExpression[Yield, Await] :
`class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]
ClassTail[Yield, Await] : ClassHeritage[?Yield, ?Await]? `{`
ClassBody[?Yield, ?Await]? `}` ClassHeritage[Yield, Await] :
`extends` LeftHandSideExpression[?Yield, ?Await] ClassBody[Yield,
Await] : ClassElementList[?Yield, ?Await] ClassElementList[Yield, Await]
: ClassElement[?Yield, ?Await] ClassElementList[?Yield, ?Await]
ClassElement[?Yield, ?Await] ClassElement[Yield, Await] :
MethodDefinition[?Yield, ?Await] `static` MethodDefinition[?Yield,
?Await] FieldDefinition[?Yield, ?Await] `;` `static`
FieldDefinition[?Yield, ?Await] `;` ClassStaticBlock `;`
FieldDefinition[Yield, Await] : ClassElementName[?Yield, ?Await]
Initializer[+In, ?Yield, ?Await]? ClassElementName[Yield, Await] :
PropertyName[?Yield, ?Await] PrivateIdentifier ClassStaticBlock :
`static` `{` ClassStaticBlockBody `}` ClassStaticBlockBody :
ClassStaticBlockStatementList ClassStaticBlockStatementList :
StatementList[~Yield, +Await, ~Return]?

A class definition is always strict mode code.


Static Semantics: Early Errors
------------------------------

ClassTail : ClassHeritage? `{` ClassBody `}`

- It is a Syntax Error if `ClassHeritage` is not present and the
  following algorithm returns `true`:

  1. Let constructor be the ConstructorMethod of `ClassBody`. 1.
  If constructor is ~empty~, return `false`. 1. Return
  HasDirectSuper of constructor.

ClassBody : ClassElementList

- It is a Syntax Error if the PrototypePropertyNameList of
  `ClassElementList` contains more than one occurrence of
  `"constructor"`.
- It is a Syntax Error if the PrivateBoundIdentifiers of
  `ClassElementList` contains any duplicate entries, unless the name
  is used once for a getter and once for a setter and in no other
  entries, and the getter and setter are either both static or both
  non-static.

ClassElement : MethodDefinition

- It is a Syntax Error if the PropName of `MethodDefinition` is not
  `"constructor"` and HasDirectSuper of `MethodDefinition` is
  `true`.
- It is a Syntax Error if the PropName of `MethodDefinition` is
  `"constructor"` and SpecialMethod of `MethodDefinition` is
  `true`.

ClassElement : `static` MethodDefinition

- It is a Syntax Error if HasDirectSuper of `MethodDefinition` is
  `true`.
- It is a Syntax Error if the PropName of `MethodDefinition` is
  `"prototype"`.

ClassElement : FieldDefinition `;`

- It is a Syntax Error if the PropName of `FieldDefinition` is
  `"constructor"`.

ClassElement : `static` FieldDefinition `;`

- It is a Syntax Error if the PropName of `FieldDefinition` is either
  `"prototype"` or `"constructor"`.

FieldDefinition : ClassElementName Initializer?

- It is a Syntax Error if `Initializer` is present and
  ContainsArguments of `Initializer` is `true`.
- It is a Syntax Error if `Initializer` is present and `Initializer`
  Contains `SuperCall` is `true`.

ClassElementName : PrivateIdentifier

- It is a Syntax Error if the StringValue of `PrivateIdentifier` is
  `"#constructor"`.

ClassStaticBlockBody : ClassStaticBlockStatementList

- It is a Syntax Error if the LexicallyDeclaredNames of
  `ClassStaticBlockStatementList` contains any duplicate entries.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `ClassStaticBlockStatementList` also occurs in the VarDeclaredNames
  of `ClassStaticBlockStatementList`.
- It is a Syntax Error if ContainsDuplicateLabels of
  `ClassStaticBlockStatementList` with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedBreakTarget of
  `ClassStaticBlockStatementList` with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedContinueTarget of
  `ClassStaticBlockStatementList` with arguments « » and « » is
  `true`.
- It is a Syntax Error if ContainsArguments of
  `ClassStaticBlockStatementList` is `true`.
- It is a Syntax Error if `ClassStaticBlockStatementList` Contains
  `SuperCall` is `true`.
- It is a Syntax Error if `ClassStaticBlockStatementList` Contains
  `await` is `true`.

Static Semantics: ClassElementKind ( ): ~constructor-method~, ~non-constructor-method~, or ~empty~
--------------------------------------------------------------------------------------------------

ClassElement : MethodDefinition 1. If the PropName of
`MethodDefinition` is `"constructor"`, return ~constructor-method~.
1. Return ~non-constructor-method~. ClassElement : `static`
MethodDefinition FieldDefinition `;` `static` FieldDefinition `;`
1. Return ~non-constructor-method~. ClassElement : ClassStaticBlock 1.
Return ~non-constructor-method~. ClassElement : `;` 1. Return ~empty~.

Static Semantics: ConstructorMethod ( ): a `ClassElement` Parse Node or ~empty~
---------------------------------------------------------------------------------

ClassElementList : ClassElement 1. If the ClassElementKind of
`ClassElement` is ~constructor-method~, return `ClassElement`. 1.
Return ~empty~. ClassElementList : ClassElementList ClassElement 1. Let
head be the ConstructorMethod of `ClassElementList`. 1. If
head is not ~empty~, return head. 1. If the ClassElementKind of
`ClassElement` is ~constructor-method~, return `ClassElement`. 1.
Return ~empty~.

Early Error rules ensure that there is only one method definition named
`"constructor"` and that it is not an accessor property or generator
definition.

Static Semantics: IsStatic ( ): a Boolean
-----------------------------------------

ClassElement : MethodDefinition 1. Return `false`. ClassElement :
`static` MethodDefinition 1. Return `true`. ClassElement :
FieldDefinition `;` 1. Return `false`. ClassElement : `static`
FieldDefinition `;` 1. Return `true`. ClassElement :
ClassStaticBlock 1. Return `true`. ClassElement : `;` 1. Return
`false`.

Static Semantics: NonConstructorElements ( ): a List of `ClassElement` Parse Nodes
------------------------------------------------------------------------------------

ClassElementList : ClassElement 1. If the ClassElementKind of
`ClassElement` is ~non-constructor-method~, then 1. Return «
`ClassElement` ». 1. Return a new empty List. ClassElementList :
ClassElementList ClassElement 1. Let list be the
NonConstructorElements of `ClassElementList`. 1. If the
ClassElementKind of `ClassElement` is ~non-constructor-method~, then
1. Append `ClassElement` to the end of list. 1. Return list.

Static Semantics: PrototypePropertyNameList ( ): a List of property keys
------------------------------------------------------------------------

ClassElementList : ClassElement 1. Let propName be the PropName of
`ClassElement`. 1. If propName is ~empty~, return a new empty
List. 1. If IsStatic of `ClassElement` is `true`, return a new empty
List. 1. Return « propName ». ClassElementList : ClassElementList
ClassElement 1. Let list be the PrototypePropertyNameList of
`ClassElementList`. 1. Let propName be the PropName of
`ClassElement`. 1. If propName is ~empty~, return list. 1. If
IsStatic of `ClassElement` is `true`, return list. 1. Return the
list-concatenation of list and « propName ».

Static Semantics: AllPrivateIdentifiersValid ( names: a List of Strings, ): a Boolean
-----------------------------------------------------------------------------------------

Every grammar production alternative in this specification which is not
listed below implicitly has the following default definition of
AllPrivateIdentifiersValid:

1. For each child node child of this Parse Node, do 1. If child
is an instance of a nonterminal, then 1. If AllPrivateIdentifiersValid
of child with argument names is `false`, return `false`. 1.
Return `true`. MemberExpression : MemberExpression `.`
PrivateIdentifier 1. If names contains the StringValue of
`PrivateIdentifier`, then 1. Return AllPrivateIdentifiersValid of
`MemberExpression` with argument names. 1. Return `false`.
CallExpression : CallExpression `.` PrivateIdentifier 1. If names
contains the StringValue of `PrivateIdentifier`, then 1. Return
AllPrivateIdentifiersValid of `CallExpression` with argument
names. 1. Return `false`. OptionalChain : `?.` PrivateIdentifier
1. If names contains the StringValue of `PrivateIdentifier`,
return `true`. 1. Return `false`. OptionalChain : OptionalChain
`.` PrivateIdentifier 1. If names contains the StringValue of
`PrivateIdentifier`, then 1. Return AllPrivateIdentifiersValid of
`OptionalChain` with argument names. 1. Return `false`.
ClassBody : ClassElementList 1. Let newNames be the
list-concatenation of names and the PrivateBoundIdentifiers of
`ClassBody`. 1. Return AllPrivateIdentifiersValid of
`ClassElementList` with argument newNames. RelationalExpression :
PrivateIdentifier `in` ShiftExpression 1. If names contains the
StringValue of `PrivateIdentifier`, then 1. Return
AllPrivateIdentifiersValid of `ShiftExpression` with argument
names. 1. Return `false`.

Static Semantics: PrivateBoundIdentifiers ( ): a List of Strings
----------------------------------------------------------------

FieldDefinition : ClassElementName Initializer? 1. Return the
PrivateBoundIdentifiers of `ClassElementName`. ClassElementName :
PrivateIdentifier 1. Return a List whose sole element is the StringValue
of `PrivateIdentifier`. ClassElementName : PropertyName ClassElement :
ClassStaticBlock `;` 1. Return a new empty List. ClassElementList :
ClassElementList ClassElement 1. Let names1 be the
PrivateBoundIdentifiers of `ClassElementList`. 1. Let names2 be
the PrivateBoundIdentifiers of `ClassElement`. 1. Return the
list-concatenation of names1 and names2. MethodDefinition :
ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody
`}` `get` ClassElementName `(` `)` `{` FunctionBody `}`
`set` ClassElementName `(` PropertySetParameterList `)` `{`
FunctionBody `}` GeneratorMethod : `*` ClassElementName `(`
UniqueFormalParameters `)` `{` GeneratorBody `}` AsyncMethod :
`async` ClassElementName `(` UniqueFormalParameters `)` `{`
AsyncFunctionBody `}` AsyncGeneratorMethod : `async` `*`
ClassElementName `(` UniqueFormalParameters `)` `{`
AsyncGeneratorBody `}` 1. Return the PrivateBoundIdentifiers of
`ClassElementName`.

Static Semantics: ContainsArguments ( ): a Boolean
--------------------------------------------------

Every grammar production alternative in this specification which is not
listed below implicitly has the following default definition of
ContainsArguments:

1. For each child node child of this Parse Node, do 1. If child
is an instance of a nonterminal, then 1. If ContainsArguments of
child is `true`, return `true`. 1. Return `false`.
IdentifierReference : Identifier 1. If the StringValue of `Identifier`
is `"arguments"`, return `true`. 1. Return `false`.
FunctionDeclaration : `function` BindingIdentifier `(`
FormalParameters `)` `{` FunctionBody `}` `function` `(`
FormalParameters `)` `{` FunctionBody `}` FunctionExpression :
`function` BindingIdentifier? `(` FormalParameters `)` `{`
FunctionBody `}` GeneratorDeclaration : `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
`function` `*` `(` FormalParameters `)` `{` GeneratorBody
`}` GeneratorExpression : `function` `*` BindingIdentifier? `(`
FormalParameters `)` `{` GeneratorBody `}`
AsyncGeneratorDeclaration : `async` `function` `*`
BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody
`}` `async` `function` `*` `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` AsyncGeneratorExpression : `async`
`function` `*` BindingIdentifier? `(` FormalParameters `)` `{`
AsyncGeneratorBody `}` AsyncFunctionDeclaration : `async`
`function` BindingIdentifier `(` FormalParameters `)` `{`
AsyncFunctionBody `}` `async` `function` `(` FormalParameters
`)` `{` AsyncFunctionBody `}` AsyncFunctionExpression : `async`
`function` BindingIdentifier? `(` FormalParameters `)` `{`
AsyncFunctionBody `}` 1. Return `false`. MethodDefinition :
ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody
`}` `get` ClassElementName `(` `)` `{` FunctionBody `}`
`set` ClassElementName `(` PropertySetParameterList `)` `{`
FunctionBody `}` GeneratorMethod : `*` ClassElementName `(`
UniqueFormalParameters `)` `{` GeneratorBody `}`
AsyncGeneratorMethod : `async` `*` ClassElementName `(`
UniqueFormalParameters `)` `{` AsyncGeneratorBody `}` AsyncMethod
: `async` ClassElementName `(` UniqueFormalParameters `)` `{`
AsyncFunctionBody `}` 1. Return ContainsArguments of
`ClassElementName`.

Runtime Semantics: ClassFieldDefinitionEvaluation ( homeObject: an Object, )
----------------------------------------------------------------------------

FieldDefinition : ClassElementName Initializer? 1. Let name be ?
Evaluation of `ClassElementName`. 1. If `Initializer` is present,
then 1. Let formalParameterList be an instance of the production
FormalParameters : [empty]. 1. Let env be the LexicalEnvironment of
the running execution context. 1. Let privateEnv be the running
execution context's PrivateEnvironment. 1. Let sourceText be the
empty sequence of Unicode code points. 1. Let initializer be
OrdinaryFunctionCreate(%Function.prototype%, sourceText,
formalParameterList, `Initializer`, ~non-lexical-this~, env,
privateEnv). 1. Perform MakeMethod(initializer, homeObject).
1. Set initializer.[[ClassFieldInitializerName]] to name. 1.
Else, 1. Let initializer be ~empty~. 1. Return the
ClassFieldDefinition Record { [[Name]]: name, [[Initializer]]:
initializer }. The function created for initializer is never
directly accessible to ECMAScript code.

Runtime Semantics: ClassStaticBlockDefinitionEvaluation ( homeObject: an Object, ): a ClassStaticBlockDefinition Record
---------------------------------------------------------------------------------------------------------------------------

ClassStaticBlock : `static` `{` ClassStaticBlockBody `}` 1. Let
lex be the running execution context's LexicalEnvironment. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the empty sequence of Unicode code points. 1. Let
formalParameters be an instance of the production FormalParameters :
[empty]. 1. [id="step-synthetic-class-static-block-fn"] Let
bodyFunction be OrdinaryFunctionCreate(%Function.prototype%,
sourceText, formalParameters, `ClassStaticBlockBody`,
~non-lexical-this~, lex, privateEnv). 1. Perform
MakeMethod(bodyFunction, homeObject). 1. Return the
ClassStaticBlockDefinition Record { [[BodyFunction]]: bodyFunction
}. The function bodyFunction is never directly accessible to
ECMAScript code.

Runtime Semantics: EvaluateClassStaticBlockBody ( functionObject: an ECMAScript function object, )
--------------------------------------------------------------------------------------------------

ClassStaticBlockBody : ClassStaticBlockStatementList 1. Assert:
functionObject is a synthetic function created by
ClassStaticBlockDefinitionEvaluation step . 1. Perform !
FunctionDeclarationInstantiation(functionObject, « »). 1. Return ?
Evaluation of `ClassStaticBlockStatementList`.

Runtime Semantics: ClassElementEvaluation ( object: an Object, )
----------------------------------------------------------------

ClassElement : FieldDefinition `;` `static` FieldDefinition `;` 1.
Return ? ClassFieldDefinitionEvaluation of `FieldDefinition` with
argument object. ClassElement : MethodDefinition `static`
MethodDefinition 1. Return ? MethodDefinitionEvaluation of
`MethodDefinition` with arguments object and `false`.
ClassElement : ClassStaticBlock 1. Return the
ClassStaticBlockDefinitionEvaluation of `ClassStaticBlock` with
argument object. ClassElement : `;` 1. Return ~unused~.

Runtime Semantics: ClassDefinitionEvaluation ( classBinding: a String or `undefined`, className: a property key or a Private Name, )
------------------------------------------------------------------------------------------------------------------------------------

For ease of specification, private methods and accessors are included
alongside private fields in the [[PrivateElements]] slot of class
instances. However, any given object has either all or none of the
private methods and accessors defined by a given class. This feature has
been designed so that implementations may choose to implement private
methods and accessors using a strategy which does not require tracking
each method or accessor individually.

For example, an implementation could directly associate instance private
methods with their corresponding Private Name and track, for each
object, which class constructors have run with that object as their
`this` value. Looking up an instance private method on an object then
consists of checking that the class constructor which defines the method
has been used to initialize the object, then returning the method
associated with the Private Name.

This differs from private fields: because field initializers can throw
during class instantiation, an individual object may have some proper
subset of the private fields of a given class, and so private fields
must in general be tracked individually.

ClassTail : ClassHeritage? `{` ClassBody? `}` 1. Let env be the
LexicalEnvironment of the running execution context. 1. Let classEnv
be NewDeclarativeEnvironment(env). 1. If classBinding is not
`undefined`, then 1. Perform !
classEnv.CreateImmutableBinding(classBinding, `true`). 1. Let
outerPrivateEnvironment be the running execution context's
PrivateEnvironment. 1. Let classPrivateEnvironment be
NewPrivateEnvironment(outerPrivateEnvironment). 1. If `ClassBody`
is present, then 1. For each String dn of the
PrivateBoundIdentifiers of `ClassBody`, do 1. If
classPrivateEnvironment.[[Names]] contains a Private Name pn
such that pn.[[Description]] is dn, then 1. Assert: This is only
possible for getter/setter pairs. 1. Else, 1. Let name be a new
Private Name whose [[Description]] is dn. 1. Append name to
classPrivateEnvironment.[[Names]]. 1. If `ClassHeritage` is not
present, then 1. Let protoParent be %Object.prototype%. 1. Let
constructorParent be %Function.prototype%. 1. Else, 1. Set the
running execution context's LexicalEnvironment to classEnv. 1. NOTE:
The running execution context's PrivateEnvironment is
outerPrivateEnvironment when evaluating `ClassHeritage`. 1. Let
superclassRef be Completion(Evaluation of `ClassHeritage`). 1. Set
the running execution context's LexicalEnvironment to env. 1. Let
superclass be ? GetValue(? superclassRef). 1. If superclass
is `null`, then 1. Let protoParent be `null`. 1. Let
constructorParent be %Function.prototype%. 1. Else if
IsConstructor(superclass) is `false`, then 1. Throw a
`TypeError` exception. 1. Else, 1. Let protoParent be ?
Get(superclass, `"prototype"`). 1. If protoParent is not an
Object and protoParent is not `null`, throw a `TypeError`
exception. 1. Let constructorParent be superclass. 1. Let
proto be OrdinaryObjectCreate(protoParent). 1. If `ClassBody`
is not present, let constructor be ~empty~. 1. Else, let
constructor be the ConstructorMethod of `ClassBody`. 1. Set the
running execution context's LexicalEnvironment to classEnv. 1. Set
the running execution context's PrivateEnvironment to
classPrivateEnvironment. 1. If constructor is ~empty~, then 1.
Let defaultConstructor be a new Abstract Closure with no parameters
that captures nothing and performs the following steps when called: 1.
Let args be the List of arguments that was passed to this function
by [[Call]] or [[Construct]]. 1. If NewTarget is `undefined`, throw a
`TypeError` exception. 1. Let F be the active function object. 1.
If F.[[ConstructorKind]] is ~derived~, then 1. NOTE: This branch
behaves similarly to `constructor(...args) { super(...args); }`. The
most notable distinction is that while the aforementioned ECMAScript
source text observably calls the %Symbol.iterator% method on
`%Array.prototype%`, this function does not. 1. Let func be !
F.[[GetPrototypeOf]](). 1. If IsConstructor(func) is `false`,
throw a `TypeError` exception. 1. Let result be ?
Construct(func, args, NewTarget). 1. Else, 1. NOTE: This branch
behaves similarly to `constructor() {}`. 1. Let result be ?
OrdinaryCreateFromConstructor(NewTarget, `"%Object.prototype%"`). 1.
Perform ? InitializeInstanceElements(result, F). 1. Return
result. 1. Let F be
CreateBuiltinFunction(defaultConstructor, 0, className, «
[[ConstructorKind]], [[SourceText]] », the current Realm Record,
constructorParent). 1. Else, 1. Let constructorInfo be !
DefineMethod of constructor with arguments proto and
constructorParent. 1. Let F be constructorInfo.[[Closure]].
1. Perform MakeClassConstructor(F). 1. Perform
SetFunctionName(F, className). 1. Perform MakeConstructor(F,
`false`, proto). 1. If `ClassHeritage` is present, set
F.[[ConstructorKind]] to ~derived~. 1. Perform !
DefineMethodProperty(proto, `"constructor"`, F, `false`). 1.
If `ClassBody` is not present, let elements be a new empty List.
1. Else, let elements be the NonConstructorElements of
`ClassBody`. 1. Let instancePrivateMethods be a new empty List. 1.
Let staticPrivateMethods be a new empty List. 1. Let
instanceFields be a new empty List. 1. Let staticElements be a
new empty List. 1. For each `ClassElement` e of elements, do
1. If IsStatic of e is `false`, then 1. Let element be
Completion(ClassElementEvaluation of e with argument proto). 1.
Else, 1. Let element be Completion(ClassElementEvaluation of e
with argument F). 1. If element is an abrupt completion, then 1.
Set the running execution context's LexicalEnvironment to env. 1.
Set the running execution context's PrivateEnvironment to
outerPrivateEnvironment. 1. Return ? element. 1. Set element
to ! element. 1. If element is a PrivateElement, then 1. Assert:
element.[[Kind]] is either ~method~ or ~accessor~. 1. If IsStatic of
e is `false`, let container be instancePrivateMethods. 1.
Else, let container be staticPrivateMethods. 1. If container
contains a PrivateElement pe such that pe.[[Key]] is
element.[[Key]], then 1. Assert: element.[[Kind]] and
pe.[[Kind]] are both ~accessor~. 1. If element.[[Get]] is
`undefined`, then 1. Let combined be PrivateElement { [[Key]]:
element.[[Key]], [[Kind]]: ~accessor~, [[Get]]: pe.[[Get]],
[[Set]]: element.[[Set]] }. 1. Else, 1. Let combined be
PrivateElement { [[Key]]: element.[[Key]], [[Kind]]: ~accessor~,
[[Get]]: element.[[Get]], [[Set]]: pe.[[Set]] }. 1. Replace
pe in container with combined. 1. Else, 1. Append
element to container. 1. Else if element is a
ClassFieldDefinition Record, then 1. If IsStatic of e is `false`,
append element to instanceFields. 1. Else, append element to
staticElements. 1. Else if element is a
ClassStaticBlockDefinition Record, then 1. Append element to
staticElements. 1. Set the running execution context's
LexicalEnvironment to env. 1. If classBinding is not
`undefined`, then 1. Perform !
classEnv.InitializeBinding(classBinding, F). 1. Set
F.[[PrivateMethods]] to instancePrivateMethods. 1. Set
F.[[Fields]] to instanceFields. 1. For each PrivateElement
method of staticPrivateMethods, do 1. Perform !
PrivateMethodOrAccessorAdd(F, method). 1. For each element
elementRecord of staticElements, do 1. If elementRecord is a
ClassFieldDefinition Record, then 1. Let result be
Completion(DefineField(F, elementRecord)). 1. Else, 1. Assert:
elementRecord is a ClassStaticBlockDefinition Record. 1. Let
result be Completion(Call(elementRecord.[[BodyFunction]],
F)). 1. If result is an abrupt completion, then 1. Set the
running execution context's PrivateEnvironment to
outerPrivateEnvironment. 1. Return ? result. 1. Set the running
execution context's PrivateEnvironment to outerPrivateEnvironment.
1. Return F.

Runtime Semantics: BindingClassDeclarationEvaluation ( )
--------------------------------------------------------

ClassDeclaration : `class` BindingIdentifier ClassTail 1. Let
className be the StringValue of `BindingIdentifier`. 1. Let
value be ? ClassDefinitionEvaluation of `ClassTail` with arguments
className and className. 1. Set value.[[SourceText]] to the
source text matched by `ClassDeclaration`. 1. Let env be the
running execution context's LexicalEnvironment. 1. Perform ?
InitializeBoundName(className, value, env). 1. Return
value. ClassDeclaration : `class` ClassTail 1. Let value be ?
ClassDefinitionEvaluation of `ClassTail` with arguments `undefined`
and `"default"`. 1. Set value.[[SourceText]] to the source text
matched by `ClassDeclaration`. 1. Return value.

ClassDeclaration : `class` ClassTail only occurs as part of an
`ExportDeclaration` and establishing its binding is handled as part of
the evaluation action for that production. See .



Runtime Semantics: Evaluation
-----------------------------

ClassDeclaration : `class` BindingIdentifier ClassTail 1. Perform ?
BindingClassDeclarationEvaluation of this `ClassDeclaration`. 1.
Return ~empty~.

ClassDeclaration : `class` ClassTail only occurs as part of an
`ExportDeclaration` and is never directly evaluated.

ClassExpression : `class` ClassTail 1. Let value be ?
ClassDefinitionEvaluation of `ClassTail` with arguments `undefined`
and `""`. 1. Set value.[[SourceText]] to the source text matched
by `ClassExpression`. 1. Return value. ClassExpression : `class`
BindingIdentifier ClassTail 1. Let className be the StringValue of
`BindingIdentifier`. 1. Let value be ? ClassDefinitionEvaluation
of `ClassTail` with arguments className and className. 1. Set
value.[[SourceText]] to the source text matched by
`ClassExpression`. 1. Return value. ClassElementName :
PrivateIdentifier 1. Let privateIdentifier be the StringValue of
`PrivateIdentifier`. 1. Let privateEnvRec be the running execution
context's PrivateEnvironment. 1. Let names be
privateEnvRec.[[Names]]. 1. Assert: Exactly one element of names
is a Private Name whose [[Description]] is privateIdentifier. 1. Let
privateName be the Private Name in names whose [[Description]]
is privateIdentifier. 1. Return privateName.
ClassStaticBlockStatementList : [empty] 1. Return `undefined`.

Async Function Definitions
--------------------------


**Syntax**


AsyncFunctionDeclaration[Yield, Await, Default] : `async` [no
LineTerminator here] `function` BindingIdentifier[?Yield, ?Await]
`(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody
`}` [+Default] `async` [no LineTerminator here] `function` `(`
FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
AsyncFunctionExpression : `async` [no LineTerminator here]
`function` BindingIdentifier[~Yield, +Await]? `(`
FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
AsyncMethod[Yield, Await] : `async` [no LineTerminator here]
ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield,
+Await] `)` `{` AsyncFunctionBody `}` AsyncFunctionBody :
FunctionBody[~Yield, +Await] AwaitExpression[Yield] : `await`
UnaryExpression[?Yield, +Await]

`await` is parsed as a keyword of an `AwaitExpression` when the
:sub:`[Await]` parameter is present. The :sub:`[Await]` parameter is
present in the top level of the following contexts, although the
parameter may be absent in some contexts depending on the nonterminals,
such as `FunctionBody`:

- In an `AsyncFunctionBody`.
- In the `FormalParameters` of an `AsyncFunctionDeclaration`,
  `AsyncFunctionExpression`, `AsyncGeneratorDeclaration`, or
  `AsyncGeneratorExpression`. `AwaitExpression` in this position is
  a Syntax error via static semantics.
- In a `Module`.

When `Script` is the syntactic goal symbol, `await` may be parsed as
an identifier when the :sub:`[Await]` parameter is absent. This includes
the following contexts:

- Anywhere outside of an `AsyncFunctionBody` or `FormalParameters`
  of an `AsyncFunctionDeclaration`, `AsyncFunctionExpression`,
  `AsyncGeneratorDeclaration`, or `AsyncGeneratorExpression`.
- In the `BindingIdentifier` of a `FunctionExpression`,
  `GeneratorExpression`, or `AsyncGeneratorExpression`.

Unlike `YieldExpression`, it is a Syntax Error to omit the operand of
an `AwaitExpression`. You must await something.


Static Semantics: Early Errors
------------------------------

AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters
`)` `{` AsyncFunctionBody `}`

- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `AsyncFunctionBody` is `true` and IsSimpleParameterList of
  `UniqueFormalParameters` is `false`.
- It is a Syntax Error if HasDirectSuper of `AsyncMethod` is `true`.
- It is a Syntax Error if `UniqueFormalParameters` Contains
  `AwaitExpression` is `true`.
- It is a Syntax Error if any element of the BoundNames of
  `UniqueFormalParameters` also occurs in the LexicallyDeclaredNames
  of `AsyncFunctionBody`.

AsyncFunctionDeclaration : `async` `function` BindingIdentifier
`(` FormalParameters `)` `{` AsyncFunctionBody `}` `async`
`function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
AsyncFunctionExpression : `async` `function` BindingIdentifier?
`(` FormalParameters `)` `{` AsyncFunctionBody `}`

- It is a Syntax Error if FunctionBodyContainsUseStrict of
  `AsyncFunctionBody` is `true` and IsSimpleParameterList of
  `FormalParameters` is `false`.
- It is a Syntax Error if `FormalParameters` Contains
  `AwaitExpression` is `true`.
- If IsStrict(`FormalParameters`) is `true`, the Early Error rules
  for UniqueFormalParameters : FormalParameters are applied.
- If `BindingIdentifier` is present and
  IsStrict(`BindingIdentifier`) is `true`, it is a Syntax Error if
  the StringValue of `BindingIdentifier` is either `"eval"` or
  `"arguments"`.
- It is a Syntax Error if any element of the BoundNames of
  `FormalParameters` also occurs in the LexicallyDeclaredNames of
  `AsyncFunctionBody`.
- It is a Syntax Error if `FormalParameters` Contains
  `SuperProperty` is `true`.
- It is a Syntax Error if `AsyncFunctionBody` Contains
  `SuperProperty` is `true`.
- It is a Syntax Error if `FormalParameters` Contains `SuperCall` is
  `true`.
- It is a Syntax Error if `AsyncFunctionBody` Contains `SuperCall`
  is `true`.

Runtime Semantics: InstantiateAsyncFunctionObject ( env: an Environment Record, privateEnv: a PrivateEnvironment Record or `null`, ): an ECMAScript function object
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AsyncFunctionDeclaration : `async` `function` BindingIdentifier
`(` FormalParameters `)` `{` AsyncFunctionBody `}` 1. Let
name be the StringValue of `BindingIdentifier`. 1. Let
sourceText be the source text matched by
`AsyncFunctionDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
`FormalParameters`, `AsyncFunctionBody`, ~non-lexical-this~,
env, privateEnv). 1. Perform SetFunctionName(F, name).
1. Return F. AsyncFunctionDeclaration : `async` `function` `(`
FormalParameters `)` `{` AsyncFunctionBody `}` 1. Let
sourceText be the source text matched by
`AsyncFunctionDeclaration`. 1. Let F be
OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
`FormalParameters`, `AsyncFunctionBody`, ~non-lexical-this~,
env, privateEnv). 1. Perform SetFunctionName(F,
`"default"`). 1. Return F.

Runtime Semantics: InstantiateAsyncFunctionExpression ( optional name: a property key or a Private Name, ): an ECMAScript function object
---------------------------------------------------------------------------------------------------------------------------------------------

AsyncFunctionExpression : `async` `function` `(` FormalParameters
`)` `{` AsyncFunctionBody `}` 1. If name is not present, set
name to `""`. 1. Let env be the LexicalEnvironment of the
running execution context. 1. Let privateEnv be the running
execution context's PrivateEnvironment. 1. Let sourceText be the
source text matched by `AsyncFunctionExpression`. 1. Let closure
be OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
`FormalParameters`, `AsyncFunctionBody`, ~non-lexical-this~,
env, privateEnv). 1. Perform SetFunctionName(closure,
name). 1. Return closure. AsyncFunctionExpression : `async`
`function` BindingIdentifier `(` FormalParameters `)` `{`
AsyncFunctionBody `}` 1. Assert: name is not present. 1. Set
name to the StringValue of `BindingIdentifier`. 1. Let
outerEnv be the LexicalEnvironment of the running execution context.
1. Let funcEnv be NewDeclarativeEnvironment(outerEnv). 1.
Perform ! funcEnv.CreateImmutableBinding(name, `false`). 1.
Let privateEnv be the running execution context's
PrivateEnvironment. 1. Let sourceText be the source text matched by
`AsyncFunctionExpression`. 1. Let closure be
OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
`FormalParameters`, `AsyncFunctionBody`, ~non-lexical-this~,
funcEnv, privateEnv). 1. Perform SetFunctionName(closure,
name). 1. Perform ! funcEnv.InitializeBinding(name,
closure). 1. Return closure.

The `BindingIdentifier` in an `AsyncFunctionExpression` can be
referenced from inside the `AsyncFunctionExpression`'s
`AsyncFunctionBody` to allow the function to call itself recursively.
However, unlike in a `FunctionDeclaration`, the `BindingIdentifier`
in a `AsyncFunctionExpression` cannot be referenced from and does not
affect the scope enclosing the `AsyncFunctionExpression`.

Runtime Semantics: EvaluateAsyncFunctionBody ( functionObject: an ECMAScript function object, argumentsList: a List of ECMAScript language values, ): a return completion
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AsyncFunctionBody : FunctionBody 1. Let promiseCapability be !
NewPromiseCapability(%Promise%). 1. Let completion be
Completion(FunctionDeclarationInstantiation(functionObject,
argumentsList)). 1. If completion is an abrupt completion, then
1. Perform ! Call(promiseCapability.[[Reject]], `undefined`, «
completion.[[Value]] »). 1. Else, 1. Perform
AsyncFunctionStart(promiseCapability, `FunctionBody`). 1. Return
ReturnCompletion(promiseCapability.[[Promise]]).



Runtime Semantics: Evaluation
-----------------------------

AsyncFunctionExpression : `async` `function` BindingIdentifier?
`(` FormalParameters `)` `{` AsyncFunctionBody `}` 1. Return
InstantiateAsyncFunctionExpression of `AsyncFunctionExpression`.
AwaitExpression : `await` UnaryExpression 1. Let exprRef be ?
Evaluation of `UnaryExpression`. 1. Let value be ?
GetValue(exprRef). 1. Return ? Await(value).

Async Arrow Function Definitions
--------------------------------


**Syntax**


AsyncArrowFunction[In, Yield, Await] : `async` [no LineTerminator
here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here]
`=>` AsyncConciseBody[?In]
CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator
here] `=>` AsyncConciseBody[?In] #callcover AsyncConciseBody[In] :
[lookahead != `{`] ExpressionBody[?In, +Await] `{` AsyncFunctionBody
`}` AsyncArrowBindingIdentifier[Yield] : BindingIdentifier[?Yield,
+Await] CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]

.. _supplemental-syntax-4:

**Supplemental Syntax**

| When processing an instance of the production
| AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>`
  AsyncConciseBody
| the interpretation of `CoverCallExpressionAndAsyncArrowHead` is
  refined using the following grammar:

AsyncArrowHead : `async` [no LineTerminator here]
ArrowFormalParameters[~Yield, +Await]


Static Semantics: Early Errors
------------------------------

AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>`
AsyncConciseBody

- It is a Syntax Error if any element of the BoundNames of
  `AsyncArrowBindingIdentifier` also occurs in the
  LexicallyDeclaredNames of `AsyncConciseBody`.

AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>`
AsyncConciseBody

- `CoverCallExpressionAndAsyncArrowHead` must cover an
  `AsyncArrowHead`.
- It is a Syntax Error if `CoverCallExpressionAndAsyncArrowHead`
  Contains `YieldExpression` is `true`.
- It is a Syntax Error if `CoverCallExpressionAndAsyncArrowHead`
  Contains `AwaitExpression` is `true`.
- It is a Syntax Error if any element of the BoundNames of
  `CoverCallExpressionAndAsyncArrowHead` also occurs in the
  LexicallyDeclaredNames of `AsyncConciseBody`.
- It is a Syntax Error if AsyncConciseBodyContainsUseStrict of
  `AsyncConciseBody` is `true` and IsSimpleParameterList of
  `CoverCallExpressionAndAsyncArrowHead` is `false`.

Static Semantics: AsyncConciseBodyContainsUseStrict ( ): a Boolean
------------------------------------------------------------------

AsyncConciseBody : ExpressionBody 1. Return `false`. AsyncConciseBody
: `{` AsyncFunctionBody `}` 1. Return FunctionBodyContainsUseStrict
of `AsyncFunctionBody`.

Runtime Semantics: EvaluateAsyncConciseBody ( functionObject: an ECMAScript function object, argumentsList: a List of ECMAScript language values, ): a return completion
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AsyncConciseBody : ExpressionBody 1. Let promiseCapability be !
NewPromiseCapability(%Promise%). 1. Let completion be
Completion(FunctionDeclarationInstantiation(functionObject,
argumentsList)). 1. If completion is an abrupt completion, then
1. Perform ! Call(promiseCapability.[[Reject]], `undefined`, «
completion.[[Value]] »). 1. Else, 1. Perform
AsyncFunctionStart(promiseCapability, `ExpressionBody`). 1. Return
ReturnCompletion(promiseCapability.[[Promise]]).

Runtime Semantics: InstantiateAsyncArrowFunctionExpression ( optional name: a property key or a Private Name, ): an ECMAScript function object
--------------------------------------------------------------------------------------------------------------------------------------------------

AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>`
AsyncConciseBody 1. If name is not present, set name to `""`.
1. Let env be the LexicalEnvironment of the running execution
context. 1. Let privateEnv be the running execution context's
PrivateEnvironment. 1. Let sourceText be the source text matched by
`AsyncArrowFunction`. 1. Let parameters be
`AsyncArrowBindingIdentifier`. 1. Let closure be
OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
parameters, `AsyncConciseBody`, ~lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(closure, name). 1.
Return closure. AsyncArrowFunction :
CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody 1. If
name is not present, set name to `""`. 1. Let env be the
LexicalEnvironment of the running execution context. 1. Let
privateEnv be the running execution context's PrivateEnvironment. 1.
Let sourceText be the source text matched by `AsyncArrowFunction`.
1. Let head be the `AsyncArrowHead` that is covered by
`CoverCallExpressionAndAsyncArrowHead`. 1. Let parameters be the
`ArrowFormalParameters` of head. 1. Let closure be
OrdinaryFunctionCreate(%AsyncFunction.prototype%, sourceText,
parameters, `AsyncConciseBody`, ~lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(closure, name). 1.
Return closure.



Runtime Semantics: Evaluation
-----------------------------

AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>`
AsyncConciseBody CoverCallExpressionAndAsyncArrowHead `=>`
AsyncConciseBody 1. Return InstantiateAsyncArrowFunctionExpression of
`AsyncArrowFunction`.

Tail Position Calls
-------------------

Static Semantics: IsInTailPosition ( call: a `CallExpression` Parse Node, a `MemberExpression` Parse Node, or an `OptionalChain` Parse Node, ): a Boolean
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. If IsStrict(call) is `false`, return `false`. 1. If call
is not contained within a `FunctionBody`, a `ConciseBody`, or an
`AsyncConciseBody`, return `false`. 1. Let body be the
`FunctionBody`, `ConciseBody`, or `AsyncConciseBody` that most
closely contains call. 1. If body is the `FunctionBody` of a
`GeneratorBody`, return `false`. 1. If body is the
`FunctionBody` of an `AsyncFunctionBody`, return `false`. 1. If
body is the `FunctionBody` of an `AsyncGeneratorBody`, return
`false`. 1. If body is an `AsyncConciseBody`, return `false`.
1. Return the result of HasCallInTailPosition of body with argument
call.

Tail Position calls are only defined in strict mode code because of a
common non-standard language extension (see ) that enables observation
of the chain of caller contexts.

Static Semantics: HasCallInTailPosition ( call: a `CallExpression` Parse Node, a `MemberExpression` Parse Node, or an `OptionalChain` Parse Node, ): a Boolean
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

call is a Parse Node that represents a specific range of source
text. When the following algorithms compare call to another Parse
Node, it is a test of whether they represent the same source text.

A potential tail position call that is immediately followed by return
GetValue of the call result is also a possible tail position call. A
function call cannot return a Reference Record, so such a GetValue
operation will always return the same value as the actual function call
result.

StatementList : StatementList StatementListItem 1. Let has be
HasCallInTailPosition of `StatementList` with argument call. 1. If
has is `true`, return `true`. 1. Return HasCallInTailPosition of
`StatementListItem` with argument call. FunctionStatementList :
[empty] StatementListItem : Declaration Statement : VariableStatement
EmptyStatement ExpressionStatement ContinueStatement BreakStatement
ThrowStatement DebuggerStatement Block : `{` `}` ReturnStatement :
`return` `;` LabelledItem : FunctionDeclaration ForInOfStatement :
`for` `(` LeftHandSideExpression `of` AssignmentExpression `)`
Statement `for` `(` `var` ForBinding `of` AssignmentExpression
`)` Statement `for` `(` ForDeclaration `of` AssignmentExpression
`)` Statement CaseBlock : `{` `}` 1. Return `false`. IfStatement
: `if` `(` Expression `)` Statement `else` Statement 1. Let
has be HasCallInTailPosition of the first `Statement` with
argument call. 1. If has is `true`, return `true`. 1. Return
HasCallInTailPosition of the second `Statement` with argument
call. IfStatement : `if` `(` Expression `)` Statement
DoWhileStatement : `do` Statement `while` `(` Expression `)`
`;` WhileStatement : `while` `(` Expression `)` Statement
ForStatement : `for` `(` Expression? `;` Expression? `;`
Expression? `)` Statement `for` `(` `var`
VariableDeclarationList `;` Expression? `;` Expression? `)`
Statement `for` `(` LexicalDeclaration Expression? `;` Expression?
`)` Statement ForInOfStatement : `for` `(` LeftHandSideExpression
`in` Expression `)` Statement `for` `(` `var` ForBinding
`in` Expression `)` Statement `for` `(` ForDeclaration `in`
Expression `)` Statement WithStatement : `with` `(` Expression
`)` Statement 1. Return HasCallInTailPosition of `Statement` with
argument call. LabelledStatement : LabelIdentifier `:`
LabelledItem 1. Return HasCallInTailPosition of `LabelledItem` with
argument call. ReturnStatement : `return` Expression `;` 1.
Return HasCallInTailPosition of `Expression` with argument call.
SwitchStatement : `switch` `(` Expression `)` CaseBlock 1. Return
HasCallInTailPosition of `CaseBlock` with argument call. CaseBlock
: `{` CaseClauses? DefaultClause CaseClauses? `}` 1. Let has be
`false`. 1. If the first `CaseClauses` is present, set has to
HasCallInTailPosition of the first `CaseClauses` with argument
call. 1. If has is `true`, return `true`. 1. Set has to
HasCallInTailPosition of `DefaultClause` with argument call. 1. If
has is `true`, return `true`. 1. If the second `CaseClauses`
is present, set has to HasCallInTailPosition of the second
`CaseClauses` with argument call. 1. Return has. CaseClauses :
CaseClauses CaseClause 1. Let has be HasCallInTailPosition of
`CaseClauses` with argument call. 1. If has is `true`,
return `true`. 1. Return HasCallInTailPosition of `CaseClause` with
argument call. CaseClause : `case` Expression `:` StatementList?
DefaultClause : `default` `:` StatementList? 1. If `StatementList`
is present, return HasCallInTailPosition of `StatementList` with
argument call. 1. Return `false`. TryStatement : `try` Block
Catch 1. Return HasCallInTailPosition of `Catch` with argument
call. TryStatement : `try` Block Finally `try` Block Catch
Finally 1. Return HasCallInTailPosition of `Finally` with argument
call. Catch : `catch` `(` CatchParameter `)` Block 1. Return
HasCallInTailPosition of `Block` with argument call.
AssignmentExpression : YieldExpression ArrowFunction AsyncArrowFunction
LeftHandSideExpression `=` AssignmentExpression LeftHandSideExpression
AssignmentOperator AssignmentExpression LeftHandSideExpression `&&=`
AssignmentExpression LeftHandSideExpression `||=` AssignmentExpression
LeftHandSideExpression `??=` AssignmentExpression BitwiseANDExpression
: BitwiseANDExpression `&` EqualityExpression BitwiseXORExpression :
BitwiseXORExpression `^` BitwiseANDExpression BitwiseORExpression :
BitwiseORExpression `|` BitwiseXORExpression EqualityExpression :
EqualityExpression `==` RelationalExpression EqualityExpression `!=`
RelationalExpression EqualityExpression `===` RelationalExpression
EqualityExpression `!==` RelationalExpression RelationalExpression :
RelationalExpression `<` ShiftExpression RelationalExpression `>`
ShiftExpression RelationalExpression `<=` ShiftExpression
RelationalExpression `>=` ShiftExpression RelationalExpression
`instanceof` ShiftExpression RelationalExpression `in`
ShiftExpression PrivateIdentifier `in` ShiftExpression ShiftExpression
: ShiftExpression `<<` AdditiveExpression ShiftExpression `>>`
AdditiveExpression ShiftExpression `>>>` AdditiveExpression
AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression
AdditiveExpression `-` MultiplicativeExpression
MultiplicativeExpression : MultiplicativeExpression
MultiplicativeOperator ExponentiationExpression ExponentiationExpression
: UpdateExpression `**` ExponentiationExpression UpdateExpression :
LeftHandSideExpression `++` LeftHandSideExpression `--` `++`
UnaryExpression `--` UnaryExpression UnaryExpression : `delete`
UnaryExpression `void` UnaryExpression `typeof` UnaryExpression
`+` UnaryExpression `-` UnaryExpression `~` UnaryExpression `!`
UnaryExpression AwaitExpression CallExpression : SuperCall ImportCall
CallExpression `[` Expression `]` CallExpression `.`
IdentifierName CallExpression `.` PrivateIdentifier NewExpression :
`new` NewExpression MemberExpression : MemberExpression `[`
Expression `]` MemberExpression `.` IdentifierName SuperProperty
MetaProperty `new` MemberExpression Arguments MemberExpression `.`
PrivateIdentifier PrimaryExpression : `this` IdentifierReference
Literal ArrayLiteral ObjectLiteral FunctionExpression ClassExpression
GeneratorExpression AsyncFunctionExpression AsyncGeneratorExpression
RegularExpressionLiteral TemplateLiteral 1. Return `false`. Expression
: AssignmentExpression Expression `,` AssignmentExpression 1. Return
HasCallInTailPosition of `AssignmentExpression` with argument
call. ConditionalExpression : ShortCircuitExpression `?`
AssignmentExpression `:` AssignmentExpression 1. Let has be
HasCallInTailPosition of the first `AssignmentExpression` with
argument call. 1. If has is `true`, return `true`. 1. Return
HasCallInTailPosition of the second `AssignmentExpression` with
argument call. LogicalANDExpression : LogicalANDExpression `&&`
BitwiseORExpression 1. Return HasCallInTailPosition of
\|BitwiseORExpression\| with argument call. LogicalORExpression :
LogicalORExpression `||` LogicalANDExpression 1. Return
HasCallInTailPosition of \|LogicalANDExpression\| with argument
call. CoalesceExpression : CoalesceExpressionHead `??`
BitwiseORExpression 1. Return HasCallInTailPosition of
\|BitwiseORExpression\| with argument call. CallExpression :
CoverCallExpressionAndAsyncArrowHead CallExpression Arguments
CallExpression TemplateLiteral 1. If this `CallExpression` is
call, return `true`. 1. Return `false`. OptionalExpression :
MemberExpression OptionalChain CallExpression OptionalChain
OptionalExpression OptionalChain 1. Return HasCallInTailPosition of
`OptionalChain` with argument call. OptionalChain : `?.` `[`
Expression `]` `?.` IdentifierName `?.` PrivateIdentifier
OptionalChain `[` Expression `]` OptionalChain `.` IdentifierName
OptionalChain `.` PrivateIdentifier 1. Return `false`. OptionalChain
: `?.` Arguments OptionalChain Arguments 1. If this `OptionalChain`
is call, return `true`. 1. Return `false`. MemberExpression :
MemberExpression TemplateLiteral 1. If this `MemberExpression` is
call, return `true`. 1. Return `false`. PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList 1. Let expr be the
`ParenthesizedExpression` that is covered by
`CoverParenthesizedExpressionAndArrowParameterList`. 1. Return
HasCallInTailPosition of expr with argument call.
ParenthesizedExpression : `(` Expression `)` 1. Return
HasCallInTailPosition of `Expression` with argument call.

PrepareForTailCall ( ): ~unused~
--------------------------------

1. Assert: The current execution context will not subsequently be used
for the evaluation of any ECMAScript code or built-in functions. The
invocation of Call subsequent to the invocation of this abstract
operation will create and push a new execution context before performing
any such evaluation. 1. Discard all resources associated with the
current execution context. 1. Return ~unused~.

A tail position call must either release any transient internal
resources associated with the currently executing function execution
context before invoking the target function or reuse those resources in
support of the target function.

For example, a tail position call should only grow an implementation's
activation record stack by the amount that the size of the target
function's activation record exceeds the size of the calling function's
activation record. If the target function's activation record is
smaller, then the total size of the stack should decrease.

16. ECMAScript Language: Scripts and Modules
============================================

https://tc39.es/ecma262/multipage/ecmascript-language-scripts-and-modules.html
::

   16.1 Scripts
      16.1.1 SS: Early Errors
      16.1.2 SS: ScriptIsStrict
      16.1.3 RS: Evaluation
      16.1.4 Script Records
      16.1.5 ParseScript ( sourceText, realm, hostDefined )
      16.1.6 ScriptEvaluation ( scriptRecord )
      16.1.7 GlobalDeclarationInstantiation ( script, env )
   16.2 Modules
      16.2.1 Module Semantics
         16.2.1.1 SS: Early Errors
         16.2.1.2 SS: ImportedLocalNames ( importEntries )
         16.2.1.3 SS: ModuleRequests
         16.2.1.4 Abstract Module Records
         16.2.1.5 Cyclic Module Records
            16.2.1.5.1 LoadRequestedModules ( [ hostDefined ] )
               16.2.1.5.1.1 InnerModuleLoading ( state, module )
               16.2.1.5.1.2 ContinueModuleLoading ( state, moduleCompletion )
            16.2.1.5.2 Link ( )
               16.2.1.5.2.1 InnerModuleLinking ( module, stack, index )
            16.2.1.5.3 Evaluate ( )
               16.2.1.5.3.1 InnerModuleEvaluation ( module, stack, index )
               16.2.1.5.3.2 ExecuteAsyncModule ( module )
               16.2.1.5.3.3 GatherAvailableAncestors ( module, execList )
               16.2.1.5.3.4 AsyncModuleExecutionFulfilled ( module )
               16.2.1.5.3.5 AsyncModuleExecutionRejected ( module, error )
            16.2.1.5.4 Example Cyclic Module Record Graphs
         16.2.1.6 Source Text Module Records
            16.2.1.6.1 ParseModule ( sourceText, realm, hostDefined )
            16.2.1.6.2 GetExportedNames ( [ exportStarSet ] )
            16.2.1.6.3 ResolveExport ( exportName [ , resolveSet ] )
            16.2.1.6.4 InitializeEnvironment ( )
            16.2.1.6.5 ExecuteModule ( [ capability ] )
         16.2.1.7 GetImportedModule ( referrer, specifier )
         16.2.1.8 HostLoadImportedModule ( referrer, specifier, hostDefined, payload )
         16.2.1.9 FinishLoadingImportedModule ( referrer, specifier, payload, result )
         16.2.1.10 GetModuleNamespace ( module )
         16.2.1.11 RS: Evaluation
      16.2.2 Imports
         16.2.2.1 SS: Early Errors
         16.2.2.2 SS: ImportEntries
         16.2.2.3 SS: ImportEntriesForModule
      16.2.3 Exports
         16.2.3.1 SS: Early Errors
         16.2.3.2 SS: ExportedBindings
         16.2.3.3 SS: ExportedNames
         16.2.3.4 SS: ExportEntries
         16.2.3.5 SS: ExportEntriesForModule
         16.2.3.6 SS: ReferencedBindings
         16.2.3.7 RS: Evaluation

Scripts
-------


**Syntax**


Script : ScriptBody? 

ScriptBody : StatementList[~Yield, ~Await, ~Return]


Static Semantics: Early Errors
------------------------------

Script : ScriptBody

- It is a Syntax Error if the LexicallyDeclaredNames of `ScriptBody`
  contains any duplicate entries.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `ScriptBody` also occurs in the VarDeclaredNames of `ScriptBody`.

ScriptBody : StatementList

- It is a Syntax Error if `StatementList` Contains `super` unless
  the source text containing `super` is eval code that is being
  processed by a direct eval. Additional early error rules for `super`
  within direct eval are defined in .
- It is a Syntax Error if `StatementList` Contains `NewTarget`
  unless the source text containing `NewTarget` is eval code that is
  being processed by a direct eval. Additional early error rules for
  `NewTarget` in direct eval are defined in .
- It is a Syntax Error if ContainsDuplicateLabels of `StatementList`
  with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedBreakTarget of
  `StatementList` with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedContinueTarget of
  `StatementList` with arguments « » and « » is `true`.
- It is a Syntax Error if AllPrivateIdentifiersValid of
  `StatementList` with argument « » is `false` unless the source
  text containing `ScriptBody` is eval code that is being processed by
  a direct eval.

Static Semantics: ScriptIsStrict ( ): a Boolean
-----------------------------------------------

Script : ScriptBody? 1. If `ScriptBody` is present and the Directive
Prologue of `ScriptBody` contains a Use Strict Directive, return
`true`; otherwise, return `false`.



Runtime Semantics: Evaluation
-----------------------------

Script : [empty] 1. Return `undefined`.

Script Records
--------------

A Script Record encapsulates information about a script being evaluated.
Each script record contains the fields listed in .

+--------------------+-----------------------+-----------------------+
| Field Name         | Value Type            | Meaning               |
+====================+=======================+=======================+
| [[Realm]]          | a Realm Record        | The realm within      |
|                    |                       | which this script was |
|                    |                       | created.              |
+--------------------+-----------------------+-----------------------+
| [[ECMAScriptCode]] | a `Script` Parse    | The result of parsing |
|                    | Node                  | the source text of    |
|                    |                       | this script.          |
+--------------------+-----------------------+-----------------------+
| [[LoadedModules]]  | a List of Records     | A map from the        |
|                    | with fields           | specifier strings     |
|                    | [[Specifier]] (a      | imported by this      |
|                    | String) and           | script to the         |
|                    | [[Module]] (a Module  | resolved Module       |
|                    | Record)               | Record. The list does |
|                    |                       | not contain two       |
|                    |                       | different Records     |
|                    |                       | with the same         |
|                    |                       | [[Specifier]].        |
+--------------------+-----------------------+-----------------------+
| [[HostDefined]]    | anything (default     | Field reserved for    |
|                    | value is ~empty~)     | use by host           |
|                    |                       | environments that     |
|                    |                       | need to associate     |
|                    |                       | additional            |
|                    |                       | information with a    |
|                    |                       | script.               |
+--------------------+-----------------------+-----------------------+

ParseScript ( sourceText: ECMAScript source text, realm: a Realm Record, hostDefined: anything, ): a Script Record or a non-empty List of `SyntaxError` objects
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It creates a Script Record based upon the result of parsing
   sourceText as a `Script`.

1. Let script be ParseText(sourceText, `Script`). 1. If
script is a List of errors, return script. 1. Return Script
Record { [[Realm]]: realm, [[ECMAScriptCode]]: script,
[[LoadedModules]]: « », [[HostDefined]]: hostDefined }.

An implementation may parse script source text and analyse it for Early
Error conditions prior to evaluation of ParseScript for that script
source text. However, the reporting of any errors must be deferred until
the point where this specification actually performs ParseScript upon
that source text.

ScriptEvaluation ( scriptRecord: a Script Record, )
---------------------------------------------------


1. Let globalEnv be scriptRecord.[[Realm]].[[GlobalEnv]]. 
1. Let scriptContext be a new ECMAScript code execution context. 
1. Set the Function of scriptContext to `null`. 
1. Set the Realm of scriptContext to scriptRecord.[[Realm]]. 
1. Set the ScriptOrModule of scriptContext to scriptRecord. 
1. Set the VariableEnvironment of scriptContext to globalEnv. 
1. Set the LexicalEnvironment of scriptContext to globalEnv. 
1. Set the PrivateEnvironment of scriptContext to `null`. 
1. Suspend the running execution context. 
1. Push scriptContext onto the execution context stack; scriptContext 
   is now the running execution context.
1. Let script be scriptRecord.[[ECMAScriptCode]]. 
1. Let result be Completion(GlobalDeclarationInstantiation(script, globalEnv)). 
1. If result is a normal completion, then 
   1. Set result to Completion(Evaluation of script). 
   1. If result is a normal completion and result.[[Value]] is ~empty~, then 
      1. Set result to NormalCompletion(`undefined`). 
1. Suspend scriptContext and remove it from the execution context stack. 
1. Assert: The execution context stack is not empty. 
1. Resume the context that is now on the top of the execution context stack 
   as the running execution context. 
1. Return ? result.

GlobalDeclarationInstantiation ( script: a `Script` Parse Node, env: a Global Environment Record, )
---------------------------------------------------------------------------------------------------

description
   script is the `Script` for which the execution context is being
   established. env is the global environment in which bindings are
   to be created.

When an execution context is established for evaluating scripts,
declarations are instantiated in the current global environment. Each
global binding declared in the code is instantiated.

It performs the following steps when called:

1. Let lexNames be the LexicallyDeclaredNames of script. 1. Let
varNames be the VarDeclaredNames of script. 1. For each element
name of lexNames, do 1. If env.HasVarDeclaration(name)
is `true`, throw a `SyntaxError` exception. 1. If
env.HasLexicalDeclaration(name) is `true`, throw a
`SyntaxError` exception. 1. Let hasRestrictedGlobal be ?
env.HasRestrictedGlobalProperty(name). 1. If
hasRestrictedGlobal is `true`, throw a `SyntaxError` exception.
1. For each element name of varNames, do 1. If
env.HasLexicalDeclaration(name) is `true`, throw a
`SyntaxError` exception. 1. Let varDeclarations be the
VarScopedDeclarations of script. 1. Let functionsToInitialize be
a new empty List. 1. Let declaredFunctionNames be a new empty List.
1. For each element d of varDeclarations, in reverse List order,
do 1. If d is not either a `VariableDeclaration`, a
`ForBinding`, or a `BindingIdentifier`, then 1. Assert: d is
either a `FunctionDeclaration`, a `GeneratorDeclaration`, an
`AsyncFunctionDeclaration`, or an `AsyncGeneratorDeclaration`. 1.
NOTE: If there are multiple function declarations for the same name, the
last declaration is used. 1. Let fn be the sole element of the
BoundNames of d. 1. If declaredFunctionNames does not contain
fn, then 1. Let fnDefinable be ?
env.CanDeclareGlobalFunction(fn). 1. If fnDefinable is
`false`, throw a `TypeError` exception. 1. Append fn to
declaredFunctionNames. 1. Insert d as the first element of
functionsToInitialize. 1. Let declaredVarNames be a new empty
List. 1. For each element d of varDeclarations, do 1. If d
is either a `VariableDeclaration`, a `ForBinding`, or a
`BindingIdentifier`, then 1. For each String vn of the BoundNames
of d, do 1. If declaredFunctionNames does not contain vn,
then 1. Let vnDefinable be ? env.CanDeclareGlobalVar(vn). 1.
If vnDefinable is `false`, throw a `TypeError` exception. 1. If
declaredVarNames does not contain vn, then 1. Append vn to
declaredVarNames. 1. NOTE: No abnormal terminations occur after this
algorithm step if the global object is an ordinary object. However, if
the global object is a Proxy exotic object it may exhibit behaviours
that cause abnormal terminations in some of the following steps. 1.
[id="step-globaldeclarationinstantiation-web-compat-insertion-point"]
NOTE: Annex adds additional steps at this point. 1. Let
lexDeclarations be the LexicallyScopedDeclarations of script. 1.
Let privateEnv be `null`. 1. For each element d of
lexDeclarations, do 1. NOTE: Lexically declared names are only
instantiated here but not initialized. 1. For each element dn of the
BoundNames of d, do 1. If IsConstantDeclaration of d is
`true`, then 1. Perform ? env.CreateImmutableBinding(dn,
`true`). 1. Else, 1. Perform ? env.CreateMutableBinding(dn,
`false`). 1. For each Parse Node f of functionsToInitialize,
do 1. Let fn be the sole element of the BoundNames of f. 1. Let
fo be InstantiateFunctionObject of f with arguments env and
privateEnv. 1. Perform ? env.CreateGlobalFunctionBinding(fn,
fo, `false`). 1. For each String vn of declaredVarNames,
do 1. Perform ? env.CreateGlobalVarBinding(vn, `false`). 1.
Return ~unused~.

Early errors specified in prevent name conflicts between function/var
declarations and let/const/class declarations as well as redeclaration
of let/const/class bindings for declaration contained within a single
`Script`. However, such conflicts and redeclarations that span more
than one `Script` are detected as runtime errors during
GlobalDeclarationInstantiation. If any such errors are detected, no
bindings are instantiated for the script. However, if the global object
is defined using Proxy exotic objects then the runtime tests for
conflicting declarations may be unreliable resulting in an abrupt
completion and some global declarations not being instantiated. If this
occurs, the code for the `Script` is not evaluated.

Unlike explicit var or function declarations, properties that are
directly created on the global object result in global bindings that may
be shadowed by let/const/class declarations.

Modules
-------


**Syntax**


Module : ModuleBody? ModuleBody : ModuleItemList ModuleItemList :
ModuleItem ModuleItemList ModuleItem ModuleItem : ImportDeclaration
ExportDeclaration StatementListItem[~Yield, +Await, ~Return]
ModuleExportName : IdentifierName StringLiteral

Module Semantics
----------------


Static Semantics: Early Errors
------------------------------

ModuleBody : ModuleItemList

- It is a Syntax Error if the LexicallyDeclaredNames of
  `ModuleItemList` contains any duplicate entries.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `ModuleItemList` also occurs in the VarDeclaredNames of
  `ModuleItemList`.
- It is a Syntax Error if the ExportedNames of `ModuleItemList`
  contains any duplicate entries.
- It is a Syntax Error if any element of the ExportedBindings of
  `ModuleItemList` does not also occur in either the VarDeclaredNames
  of `ModuleItemList`, or the LexicallyDeclaredNames of
  `ModuleItemList`.
- It is a Syntax Error if `ModuleItemList` Contains `super`.
- It is a Syntax Error if `ModuleItemList` Contains `NewTarget`.
- It is a Syntax Error if ContainsDuplicateLabels of `ModuleItemList`
  with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedBreakTarget of
  `ModuleItemList` with argument « » is `true`.
- It is a Syntax Error if ContainsUndefinedContinueTarget of
  `ModuleItemList` with arguments « » and « » is `true`.
- It is a Syntax Error if AllPrivateIdentifiersValid of
  `ModuleItemList` with argument « » is `false`.

The duplicate ExportedNames rule implies that multiple `export
default` `ExportDeclaration` items within a `ModuleBody` is a
Syntax Error. Additional error conditions relating to conflicting or
duplicate declarations are checked during module linking prior to
evaluation of a `Module`. If any such errors are detected the
`Module` is not evaluated.

ModuleExportName : StringLiteral

- It is a Syntax Error if IsStringWellFormedUnicode(SV of
  `StringLiteral`) is `false`.

Static Semantics: ImportedLocalNames ( importEntries: a List of ImportEntry Records, ): a List of Strings
-------------------------------------------------------------------------------------------------------------

description
   It creates a List of all of the local name bindings defined by
   importEntries.

1. Let localNames be a new empty List. 1. For each ImportEntry
Record i of importEntries, do 1. Append i.[[LocalName]] to
localNames. 1. Return localNames.

Static Semantics: ModuleRequests ( ): a List of Strings
-------------------------------------------------------

Module : [empty] 1. Return a new empty List. ModuleItemList : ModuleItem
1. Return the ModuleRequests of `ModuleItem`. ModuleItemList :
ModuleItemList ModuleItem 1. Let moduleNames be the ModuleRequests
of `ModuleItemList`. 1. Let additionalNames be the ModuleRequests
of `ModuleItem`. 1. For each String name of additionalNames,
do 1. If moduleNames does not contain name, then 1. Append
name to moduleNames. 1. Return moduleNames. ModuleItem :
StatementListItem 1. Return a new empty List. ImportDeclaration :
`import` ImportClause FromClause `;` 1. Return the ModuleRequests of
`FromClause`. ModuleSpecifier : StringLiteral 1. Return a List whose
sole element is the SV of `StringLiteral`. ExportDeclaration :
`export` ExportFromClause FromClause `;` 1. Return the
ModuleRequests of `FromClause`. ExportDeclaration : `export`
NamedExports `;` `export` VariableStatement `export` Declaration
`export` `default` HoistableDeclaration `export` `default`
ClassDeclaration `export` `default` AssignmentExpression `;` 1.
Return a new empty List.

Abstract Module Records
-----------------------

A Module Record encapsulates structural information about the imports
and exports of a single module. This information is used to link the
imports and exports of sets of connected modules. A Module Record
includes four fields that are only used when evaluating a module.

For specification purposes Module Record values are values of the Record
specification type and can be thought of as existing in a simple
object-oriented hierarchy where Module Record is an abstract class with
both abstract and concrete subclasses. This specification defines the
abstract subclass named Cyclic Module Record and its concrete subclass
named Source Text Module Record. Other specifications and
implementations may define additional Module Record subclasses
corresponding to alternative module definition facilities that they
defined.

Module Record defines the fields listed in . All Module Definition
subclasses include at least those fields. Module Record also defines the
abstract method list in . All Module definition subclasses must provide
concrete implementations of these abstract methods.

+-----------------+------------------------+------------------------+
| Field Name      | Value Type             | Meaning                |
+=================+========================+========================+
| [[Realm]]       | a Realm Record         | The Realm within which |
|                 |                        | this module was        |
|                 |                        | created.               |
+-----------------+------------------------+------------------------+
| [[Environment]] | a Module Environment   | The Environment Record |
|                 | Record or ~empty~      | containing the top     |
|                 |                        | level bindings for     |
|                 |                        | this module. This      |
|                 |                        | field is set when the  |
|                 |                        | module is linked.      |
+-----------------+------------------------+------------------------+
| [[Namespace]]   | an Object or ~empty~   | The Module Namespace   |
|                 |                        | Object () if one has   |
|                 |                        | been created for this  |
|                 |                        | module.                |
+-----------------+------------------------+------------------------+
| [[HostDefined]] | anything (default      | Field reserved for use |
|                 | value is               | by host environments   |
|                 | `undefined`)         | that need to associate |
|                 |                        | additional information |
|                 |                        | with a module.         |
+-----------------+------------------------+------------------------+

+-----------------------------------+-----------------------------------+
| Method                            | Purpose                           |
+===================================+===================================+
| LoadRequestedModules( [           | Prepares the module for linking   |
| hostDefined ] )               | by recursively loading all its    |
|                                   | dependencies, and returns a       |
|                                   | promise.                          |
+-----------------------------------+-----------------------------------+
| GetE                              | Return a list of all names that   |
| xportedNames([exportStarSet]) | are either directly or indirectly |
|                                   | exported from this module.        |
|                                   |                                   |
|                                   | LoadRequestedModules must have    |
|                                   | completed successfully prior to   |
|                                   | invoking this method.             |
+-----------------------------------+-----------------------------------+
| ResolveExport(exportName [,   | Return the binding of a name      |
| resolveSet])                  | exported by this module. Bindings |
|                                   | are represented by a              |
|                                   | ResolvedBinding Record, of the    |
|                                   | form { [[Module]]: Module Record, |
|                                   | [[BindingName]]: String \|        |
|                                   | ~namespace~ }. If the export is a |
|                                   | Module Namespace Object without a |
|                                   | direct binding in any module,     |
|                                   | [[BindingName]] will be set to    |
|                                   | ~namespace~. Return `null` if   |
|                                   | the name cannot be resolved, or   |
|                                   | ~ambiguous~ if multiple bindings  |
|                                   | were found.                       |
|                                   |                                   |
|                                   | Each time this operation is       |
|                                   | called with a specific            |
|                                   | exportName, resolveSet    |
|                                   | pair as arguments it must return  |
|                                   | the same result.                  |
|                                   |                                   |
|                                   | LoadRequestedModules must have    |
|                                   | completed successfully prior to   |
|                                   | invoking this method.             |
+-----------------------------------+-----------------------------------+
| Link()                            | Prepare the module for evaluation |
|                                   | by transitively resolving all     |
|                                   | module dependencies and creating  |
|                                   | a Module Environment Record.      |
|                                   |                                   |
|                                   | LoadRequestedModules must have    |
|                                   | completed successfully prior to   |
|                                   | invoking this method.             |
+-----------------------------------+-----------------------------------+
| Evaluate()                        | Returns a promise for the         |
|                                   | evaluation of this module and its |
|                                   | dependencies, resolving on        |
|                                   | successful evaluation or if it    |
|                                   | has already been evaluated        |
|                                   | successfully, and rejecting for   |
|                                   | an evaluation error or if it has  |
|                                   | already been evaluated            |
|                                   | unsuccessfully. If the promise is |
|                                   | rejected, hosts are expected to   |
|                                   | handle the promise rejection and  |
|                                   | rethrow the evaluation error.     |
|                                   |                                   |
|                                   | Link must have completed          |
|                                   | successfully prior to invoking    |
|                                   | this method.                      |
+-----------------------------------+-----------------------------------+

Cyclic Module Records
---------------------

A Cyclic Module Record is used to represent information about a module
that can participate in dependency cycles with other modules that are
subclasses of the Cyclic Module Record type. Module Records that are not
subclasses of the Cyclic Module Record type must not participate in
dependency cycles with Source Text Module Records.

In addition to the fields defined in Cyclic Module Records have the
additional fields listed in

+----------------------+----------------------+----------------------+
| Field Name           | Value Type           | Meaning              |
+======================+======================+======================+
| [[Status]]           | ~new~, ~unlinked~,   | Initially ~new~.     |
|                      | ~linking~, ~linked~, | Transitions to       |
|                      | ~evaluating~,        | ~unlinked~,          |
|                      | ~evaluating-async~,  | ~linking~, ~linked~, |
|                      | or ~evaluated~       | ~evaluating~,        |
|                      |                      | possibly             |
|                      |                      | ~evaluating-async~,  |
|                      |                      | ~evaluated~ (in that |
|                      |                      | order) as the module |
|                      |                      | progresses           |
|                      |                      | throughout its       |
|                      |                      | lifecycle.           |
|                      |                      | ~evaluating-async~   |
|                      |                      | indicates this       |
|                      |                      | module is queued to  |
|                      |                      | execute on           |
|                      |                      | completion of its    |
|                      |                      | asynchronous         |
|                      |                      | dependencies or it   |
|                      |                      | is a module whose    |
|                      |                      | [[HasTLA]] field is  |
|                      |                      | `true` that has    |
|                      |                      | been executed and is |
|                      |                      | pending top-level    |
|                      |                      | completion.          |
+----------------------+----------------------+----------------------+
| [[EvaluationError]]  | a throw completion   | A throw completion   |
|                      | or ~empty~           | representing the     |
|                      |                      | exception that       |
|                      |                      | occurred during      |
|                      |                      | evaluation.          |
|                      |                      | `undefined` if no  |
|                      |                      | exception occurred   |
|                      |                      | or if [[Status]] is  |
|                      |                      | not ~evaluated~.     |
+----------------------+----------------------+----------------------+
| [[DFSIndex]]         | an integer or        | Auxiliary field used |
|                      | ~empty~              | during Link and      |
|                      |                      | Evaluate only. If    |
|                      |                      | [[Status]] is either |
|                      |                      | ~linking~ or         |
|                      |                      | ~evaluating~, this   |
|                      |                      | non-negative number  |
|                      |                      | records the point at |
|                      |                      | which the module was |
|                      |                      | first visited during |
|                      |                      | the depth-first      |
|                      |                      | traversal of the     |
|                      |                      | dependency graph.    |
+----------------------+----------------------+----------------------+
| [[DFSAncestorIndex]] | an integer or        | Auxiliary field used |
|                      | ~empty~              | during Link and      |
|                      |                      | Evaluate only. If    |
|                      |                      | [[Status]] is either |
|                      |                      | ~linking~ or         |
|                      |                      | ~evaluating~, this   |
|                      |                      | is either the        |
|                      |                      | module's own         |
|                      |                      | [[DFSIndex]] or that |
|                      |                      | of an "earlier"      |
|                      |                      | module in the same   |
|                      |                      | strongly connected   |
|                      |                      | component.           |
+----------------------+----------------------+----------------------+
| [[RequestedModules]] | a List of Strings    | A List of all the    |
|                      |                      | `ModuleSpecifier`  |
|                      |                      | strings used by the  |
|                      |                      | module represented   |
|                      |                      | by this record to    |
|                      |                      | request the          |
|                      |                      | importation of a     |
|                      |                      | module. The List is  |
|                      |                      | in source text       |
|                      |                      | occurrence order.    |
+----------------------+----------------------+----------------------+
| [[LoadedModules]]    | a List of Records    | A map from the       |
|                      | with fields          | specifier strings    |
|                      | [[Specifier]] (a     | used by the module   |
|                      | String) and          | represented by this  |
|                      | [[Module]] (a Module | record to request    |
|                      | Record)              | the importation of a |
|                      |                      | module to the        |
|                      |                      | resolved Module      |
|                      |                      | Record. The list     |
|                      |                      | does not contain two |
|                      |                      | different Records    |
|                      |                      | with the same        |
|                      |                      | [[Specifier]].       |
+----------------------+----------------------+----------------------+
| [[CycleRoot]]        | a Cyclic Module      | The first visited    |
|                      | Record or ~empty~    | module of the cycle, |
|                      |                      | the root DFS         |
|                      |                      | ancestor of the      |
|                      |                      | strongly connected   |
|                      |                      | component. For a     |
|                      |                      | module not in a      |
|                      |                      | cycle, this would be |
|                      |                      | the module itself.   |
|                      |                      | Once Evaluate has    |
|                      |                      | completed, a         |
|                      |                      | module's             |
|                      |                      | [[DFSAncestorIndex]] |
|                      |                      | is the [[DFSIndex]]  |
|                      |                      | of its               |
|                      |                      | [[CycleRoot]].       |
+----------------------+----------------------+----------------------+
| [[HasTLA]]           | a Boolean            | Whether this module  |
|                      |                      | is individually      |
|                      |                      | asynchronous (for    |
|                      |                      | example, if it's a   |
|                      |                      | Source Text Module   |
|                      |                      | Record containing a  |
|                      |                      | top-level await).    |
|                      |                      | Having an            |
|                      |                      | asynchronous         |
|                      |                      | dependency does not  |
|                      |                      | mean this field is   |
|                      |                      | `true`. This field |
|                      |                      | must not change      |
|                      |                      | after the module is  |
|                      |                      | parsed.              |
+----------------------+----------------------+----------------------+
| [[AsyncEvaluation]]  | a Boolean            | Whether this module  |
|                      |                      | is either itself     |
|                      |                      | asynchronous or has  |
|                      |                      | an asynchronous      |
|                      |                      | dependency. Note:    |
|                      |                      | The order in which   |
|                      |                      | this field is set is |
|                      |                      | used to order queued |
|                      |                      | executions, see .    |
+----------------------+----------------------+----------------------+
| [[                   | a PromiseCapability  | If this module is    |
| TopLevelCapability]] | Record or ~empty~    | the [[CycleRoot]] of |
|                      |                      | some cycle, and      |
|                      |                      | Evaluate() was       |
|                      |                      | called on some       |
|                      |                      | module in that       |
|                      |                      | cycle, this field    |
|                      |                      | contains the         |
|                      |                      | PromiseCapability    |
|                      |                      | Record for that      |
|                      |                      | entire evaluation.   |
|                      |                      | It is used to settle |
|                      |                      | the Promise object   |
|                      |                      | that is returned     |
|                      |                      | from the Evaluate()  |
|                      |                      | abstract method.     |
|                      |                      | This field will be   |
|                      |                      | ~empty~ for any      |
|                      |                      | dependencies of that |
|                      |                      | module, unless a     |
|                      |                      | top-level Evaluate() |
|                      |                      | has been initiated   |
|                      |                      | for some of those    |
|                      |                      | dependencies.        |
+----------------------+----------------------+----------------------+
| [[                   | a List of Cyclic     | If this module or a  |
| AsyncParentModules]] | Module Records       | dependency has       |
|                      |                      | [[HasTLA]] `true`, |
|                      |                      | and execution is in  |
|                      |                      | progress, this       |
|                      |                      | tracks the parent    |
|                      |                      | importers of this    |
|                      |                      | module for the       |
|                      |                      | top-level execution  |
|                      |                      | job. These parent    |
|                      |                      | modules will not     |
|                      |                      | start executing      |
|                      |                      | before this module   |
|                      |                      | has successfully     |
|                      |                      | completed execution. |
+----------------------+----------------------+----------------------+
| [[Pendin             | an integer or        | If this module has   |
| gAsyncDependencies]] | ~empty~              | any asynchronous     |
|                      |                      | dependencies, this   |
|                      |                      | tracks the number of |
|                      |                      | asynchronous         |
|                      |                      | dependency modules   |
|                      |                      | remaining to execute |
|                      |                      | for this module. A   |
|                      |                      | module with          |
|                      |                      | asynchronous         |
|                      |                      | dependencies will be |
|                      |                      | executed when this   |
|                      |                      | field reaches 0 and  |
|                      |                      | there are no         |
|                      |                      | execution errors.    |
+----------------------+----------------------+----------------------+

In addition to the methods defined in Cyclic Module Records have the
additional methods listed in

+----------------------------------+----------------------------------+
| Method                           | Purpose                          |
+==================================+==================================+
| InitializeEnvironment()          | Initialize the Environment       |
|                                  | Record of the module, including  |
|                                  | resolving all imported bindings, |
|                                  | and create the module's          |
|                                  | execution context.               |
+----------------------------------+----------------------------------+
| ExecuteModule( [                 | Evaluate the module's code       |
| promiseCapability ] )        | within its execution context. If |
|                                  | this module has `true` in      |
|                                  | [[HasTLA]], then a               |
|                                  | PromiseCapability Record is      |
|                                  | passed as an argument, and the   |
|                                  | method is expected to resolve or |
|                                  | reject the given capability. In  |
|                                  | this case, the method must not   |
|                                  | throw an exception, but instead  |
|                                  | reject the PromiseCapability     |
|                                  | Record if necessary.             |
+----------------------------------+----------------------------------+

A GraphLoadingState Record is a Record that contains information about
the loading process of a module graph. It's used to continue loading
after a call to HostLoadImportedModule. Each GraphLoadingState Record
has the fields defined in :

+----------------------+----------------------+----------------------+
| Field Name           | Value Type           | Meaning              |
+======================+======================+======================+
| [                    | a PromiseCapability  | The promise to       |
| [PromiseCapability]] | Record               | resolve when the     |
|                      |                      | loading process      |
|                      |                      | finishes.            |
+----------------------+----------------------+----------------------+
| [[IsLoading]]        | a Boolean            | It is true if the    |
|                      |                      | loading process has  |
|                      |                      | not finished yet,    |
|                      |                      | neither successfully |
|                      |                      | nor with an error.   |
+----------------------+----------------------+----------------------+
| [[P                  | a non-negative       | It tracks the number |
| endingModulesCount]] | integer              | of pending           |
|                      |                      | Ho                   |
|                      |                      | stLoadImportedModule |
|                      |                      | calls.               |
+----------------------+----------------------+----------------------+
| [[Visited]]          | a List of Cyclic     | It is a list of the  |
|                      | Module Records       | Cyclic Module        |
|                      |                      | Records that have    |
|                      |                      | been already loaded  |
|                      |                      | by the current       |
|                      |                      | loading process, to  |
|                      |                      | avoid infinite loops |
|                      |                      | with circular        |
|                      |                      | dependencies.        |
+----------------------+----------------------+----------------------+
| [[HostDefined]]      | anything (default    | It contains          |
|                      | value is ~empty~)    | host-defined data to |
|                      |                      | pass from the        |
|                      |                      | LoadRequestedModules |
|                      |                      | caller to            |
|                      |                      | Hos                  |
|                      |                      | tLoadImportedModule. |
+----------------------+----------------------+----------------------+

LoadRequestedModules ( optional hostDefined: anything, ): a Promise
-----------------------------------------------------------------------

for
   a Cyclic Module Record module
description
   It populates the [[LoadedModules]] of all the Module Records in the
   dependency graph of module (most of the work is done by the
   auxiliary function InnerModuleLoading). It takes an optional
   hostDefined parameter that is passed to the
   HostLoadImportedModule hook.

1. If hostDefined is not present, let hostDefined be ~empty~. 1.
Let pc be ! NewPromiseCapability(%Promise%). 1. Let state be the
GraphLoadingState Record { [[IsLoading]]: `true`,
[[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]:
pc, [[HostDefined]]: hostDefined }. 1. Perform
InnerModuleLoading(state, module). 1. Return pc.[[Promise]].
The hostDefined parameter can be used to pass additional information
necessary to fetch the imported modules. It is used, for example, by
HTML to set the correct fetch destination for
``<link rel="preload" as="...">`` tags. ``import()`` expressions never
set the hostDefined parameter.

InnerModuleLoading ( state: a GraphLoadingState Record, module: a Module Record, ): ~unused~
----------------------------------------------------------------------------------------------------

description
   It is used by LoadRequestedModules to recursively perform the actual
   loading process for module's dependency graph.

1. Assert: state.[[IsLoading]] is `true`. 1. If module is a
Cyclic Module Record, module.[[Status]] is ~new~, and
state.[[Visited]] does not contain module, then 1. Append
module to state.[[Visited]]. 1. Let requestedModulesCount be
the number of elements in module.[[RequestedModules]]. 1. Set
state.[[PendingModulesCount]] to state.[[PendingModulesCount]] +
requestedModulesCount. 1. For each String required of
module.[[RequestedModules]], do 1. If module.[[LoadedModules]]
contains a Record whose [[Specifier]] is required, then 1. Let
record be that Record. 1. Perform InnerModuleLoading(state,
record.[[Module]]). 1. Else, 1. Perform
HostLoadImportedModule(module, required,
state.[[HostDefined]], state). 1. NOTE: HostLoadImportedModule
will call FinishLoadingImportedModule, which re-enters the graph loading
process through ContinueModuleLoading. 1. If state.[[IsLoading]] is
`false`, return ~unused~. 1. Assert: state.[[PendingModulesCount]]
≥ 1. 1. Set state.[[PendingModulesCount]] to
state.[[PendingModulesCount]] - 1. 1. If
state.[[PendingModulesCount]] = 0, then 1. Set
state.[[IsLoading]] to `false`. 1. For each Cyclic Module Record
loaded of state.[[Visited]], do 1. If loaded.[[Status]] is
~new~, set loaded.[[Status]] to ~unlinked~. 1. Perform !
Call(state.[[PromiseCapability]].[[Resolve]], `undefined`, «
`undefined` »). 1. Return ~unused~.

ContinueModuleLoading ( state: a GraphLoadingState Record, moduleCompletion
---------------------------------------------------------------------------

description
   It is used to re-enter the loading process after a call to
   HostLoadImportedModule.

1. If state.[[IsLoading]] is `false`, return ~unused~. 1. If
moduleCompletion is a normal completion, then 1. Perform
InnerModuleLoading(state, moduleCompletion.[[Value]]). 1. Else,
1. Set state.[[IsLoading]] to `false`. 1. Perform !
Call(state.[[PromiseCapability]].[[Reject]], `undefined`, «
moduleCompletion.[[Value]] »). 1. Return ~unused~.

Link ( )
--------

for
   a Cyclic Module Record module
description
   On success, Link transitions this module's [[Status]] from ~unlinked~
   to ~linked~. On failure, an exception is thrown and this module's
   [[Status]] remains ~unlinked~. (Most of the work is done by the
   auxiliary function InnerModuleLinking.)

1. Assert: module.[[Status]] is one of ~unlinked~, ~linked~,
~evaluating-async~, or ~evaluated~. 1. Let stack be a new empty
List. 1. Let result be Completion(InnerModuleLinking(module,
stack, 0)). 1. If result is an abrupt completion, then 1. For
each Cyclic Module Record m of stack, do 1. Assert:
m.[[Status]] is ~linking~. 1. Set m.[[Status]] to ~unlinked~. 1.
Assert: module.[[Status]] is ~unlinked~. 1. Return ? result. 1.
Assert: module.[[Status]] is one of ~linked~, ~evaluating-async~, or
~evaluated~. 1. Assert: stack is empty. 1. Return ~unused~.

InnerModuleLinking ( module: a Module Record, stack: a List of Cyclic Module Records, index: a non-negative integer, )
----------------------------------------------------------------------------------------------------------------------

description
   It is used by Link to perform the actual linking process for
   module, as well as recursively on all other modules in the
   dependency graph. The stack and index parameters, as well as
   a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track
   of the depth-first search (DFS) traversal. In particular,
   [[DFSAncestorIndex]] is used to discover strongly connected
   components (SCCs), such that all modules in an SCC transition to
   ~linked~ together.

1. If module is not a Cyclic Module Record, then 1. Perform ?
module.Link(). 1. Return index. 1. If module.[[Status]] is
one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then 1.
Return index. 1. Assert: module.[[Status]] is ~unlinked~. 1. Set
module.[[Status]] to ~linking~. 1. Set module.[[DFSIndex]] to
index. 1. Set module.[[DFSAncestorIndex]] to index. 1. Set
index to index + 1. 1. Append module to stack. 1. For
each String required of module.[[RequestedModules]], do 1. Let
requiredModule be GetImportedModule(module, required). 1.
Set index to ? InnerModuleLinking(requiredModule, stack,
index). 1. If requiredModule is a Cyclic Module Record, then 1.
Assert: requiredModule.[[Status]] is one of ~linking~, ~linked~,
~evaluating-async~, or ~evaluated~. 1. Assert:
requiredModule.[[Status]] is ~linking~ if and only if stack
contains requiredModule. 1. If requiredModule.[[Status]] is
~linking~, then 1. Set module.[[DFSAncestorIndex]] to
min(module.[[DFSAncestorIndex]],
requiredModule.[[DFSAncestorIndex]]). 1. Perform ?
module.InitializeEnvironment(). 1. Assert: module occurs exactly
once in stack. 1. Assert: module.[[DFSAncestorIndex]] ≤
module.[[DFSIndex]]. 1. If module.[[DFSAncestorIndex]] =
module.[[DFSIndex]], then 1. Let done be `false`. 1. Repeat,
while done is `false`, 1. Let requiredModule be the last
element of stack. 1. Remove the last element of stack. 1.
Assert: requiredModule is a Cyclic Module Record. 1. Set
requiredModule.[[Status]] to ~linked~. 1. If requiredModule and
module are the same Module Record, set done to `true`. 1.
Return index.

Evaluate ( ): a Promise
-----------------------

for
   a Cyclic Module Record module
description
   Evaluate transitions this module's [[Status]] from ~linked~ to either
   ~evaluating-async~ or ~evaluated~. The first time it is called on a
   module in a given strongly connected component, Evaluate creates and
   returns a Promise which resolves when the module has finished
   evaluating. This Promise is stored in the [[TopLevelCapability]]
   field of the [[CycleRoot]] for the component. Future invocations of
   Evaluate on any module in the component return the same Promise.
   (Most of the work is done by the auxiliary function
   InnerModuleEvaluation.)

1. Assert: This call to Evaluate is not happening at the same time as
another call to Evaluate within the surrounding agent. 1. Assert:
module.[[Status]] is one of ~linked~, ~evaluating-async~, or
~evaluated~. 1. If module.[[Status]] is either ~evaluating-async~ or
~evaluated~, set module to module.[[CycleRoot]]. 1. If
module.[[TopLevelCapability]] is not ~empty~, then 1. Return
module.[[TopLevelCapability]].[[Promise]]. 1. Let stack be a new
empty List. 1. Let capability be ! NewPromiseCapability(%Promise%).
1. Set module.[[TopLevelCapability]] to capability. 1. Let
result be Completion(InnerModuleEvaluation(module, stack,
0)). 1. If result is an abrupt completion, then 1. For each Cyclic
Module Record m of stack, do 1. Assert: m.[[Status]] is
~evaluating~. 1. Set m.[[Status]] to ~evaluated~. 1. Set
m.[[EvaluationError]] to result. 1. Assert:
module.[[Status]] is ~evaluated~. 1. Assert:
module.[[EvaluationError]] and result are the same Completion
Record. 1. Perform ! Call(capability.[[Reject]], `undefined`, «
result.[[Value]] »). 1. Else, 1. Assert: module.[[Status]] is
either ~evaluating-async~ or ~evaluated~. 1. Assert:
module.[[EvaluationError]] is ~empty~. 1. If
module.[[AsyncEvaluation]] is `false`, then 1. Assert:
module.[[Status]] is ~evaluated~. 1. Perform !
Call(capability.[[Resolve]], `undefined`, « `undefined` »). 1.
Assert: stack is empty. 1. Return capability.[[Promise]].

InnerModuleEvaluation ( module: a Module Record, stack: a List of Cyclic Module Records, index: a non-negative integer, )
-------------------------------------------------------------------------------------------------------------------------

description
   It is used by Evaluate to perform the actual evaluation process for
   module, as well as recursively on all other modules in the
   dependency graph. The stack and index parameters, as well as
   module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used
   the same way as in InnerModuleLinking.

1. If module is not a Cyclic Module Record, then 1. Let promise
be ! module.Evaluate(). 1. Assert: promise.[[PromiseState]] is
not ~pending~. 1. If promise.[[PromiseState]] is ~rejected~, then 1.
Return ThrowCompletion(promise.[[PromiseResult]]). 1. Return
index. 1. If module.[[Status]] is either ~evaluating-async~ or
~evaluated~, then 1. If module.[[EvaluationError]] is ~empty~,
return index. 1. Otherwise, return ? module.[[EvaluationError]].
1. If module.[[Status]] is ~evaluating~, return index. 1.
Assert: module.[[Status]] is ~linked~. 1. Set module.[[Status]]
to ~evaluating~. 1. Set module.[[DFSIndex]] to index. 1. Set
module.[[DFSAncestorIndex]] to index. 1. Set
module.[[PendingAsyncDependencies]] to 0. 1. Set index to
index + 1. 1. Append module to stack. 1. For each String
required of module.[[RequestedModules]], do 1. Let
requiredModule be GetImportedModule(module, required). 1.
Set index to ? InnerModuleEvaluation(requiredModule, stack,
index). 1. If requiredModule is a Cyclic Module Record, then 1.
Assert: requiredModule.[[Status]] is one of ~evaluating~,
~evaluating-async~, or ~evaluated~. 1. Assert:
requiredModule.[[Status]] is ~evaluating~ if and only if stack
contains requiredModule. 1. If requiredModule.[[Status]] is
~evaluating~, then 1. Set module.[[DFSAncestorIndex]] to
min(module.[[DFSAncestorIndex]],
requiredModule.[[DFSAncestorIndex]]). 1. Else, 1. Set
requiredModule to requiredModule.[[CycleRoot]]. 1. Assert:
requiredModule.[[Status]] is either ~evaluating-async~ or
~evaluated~. 1. If requiredModule.[[EvaluationError]] is not
~empty~, return ? requiredModule.[[EvaluationError]]. 1. If
requiredModule.[[AsyncEvaluation]] is `true`, then 1. Set
module.[[PendingAsyncDependencies]] to
module.[[PendingAsyncDependencies]] + 1. 1. Append module to
requiredModule.[[AsyncParentModules]]. 1. If
module.[[PendingAsyncDependencies]] > 0 or module.[[HasTLA]] is
`true`, then 1. Assert: module.[[AsyncEvaluation]] is `false`
and was never previously set to `true`. 1. Set
module.[[AsyncEvaluation]] to `true`. 1. NOTE: The order in which
module records have their [[AsyncEvaluation]] fields transition to
`true` is significant. (See .) 1. If
module.[[PendingAsyncDependencies]] = 0, perform
ExecuteAsyncModule(module). 1. Else, 1. Perform ?
module.ExecuteModule(). 1. Assert: module occurs exactly once in
stack. 1. Assert: module.[[DFSAncestorIndex]] ≤
module.[[DFSIndex]]. 1. If module.[[DFSAncestorIndex]] =
module.[[DFSIndex]], then 1. Let done be `false`. 1. Repeat,
while done is `false`, 1. Let requiredModule be the last
element of stack. 1. Remove the last element of stack. 1.
Assert: requiredModule is a Cyclic Module Record. 1. If
requiredModule.[[AsyncEvaluation]] is `false`, set
requiredModule.[[Status]] to ~evaluated~. 1. Otherwise, set
requiredModule.[[Status]] to ~evaluating-async~. 1. If
requiredModule and module are the same Module Record, set
done to `true`. 1. Set requiredModule.[[CycleRoot]] to
module. 1. Return index.

A module is ~evaluating~ while it is being traversed by
InnerModuleEvaluation. A module is ~evaluated~ on execution completion
or ~evaluating-async~ during execution if its [[HasTLA]] field is
`true` or if it has asynchronous dependencies.

Any modules depending on a module of an asynchronous cycle when that
cycle is not ~evaluating~ will instead depend on the execution of the
root of the cycle via [[CycleRoot]]. This ensures that the cycle state
can be treated as a single strongly connected component through its root
module state.

ExecuteAsyncModule ( module: a Cyclic Module Record, ): ~unused~
--------------------------------------------------------------------

1. Assert: module.[[Status]] is either ~evaluating~ or
~evaluating-async~. 1. Assert: module.[[HasTLA]] is `true`. 1. Let
capability be ! NewPromiseCapability(%Promise%). 1. Let
fulfilledClosure be a new Abstract Closure with no parameters that
captures module and performs the following steps when called: 1.
Perform AsyncModuleExecutionFulfilled(module). 1. Return
`undefined`. 1. Let onFulfilled be
CreateBuiltinFunction(fulfilledClosure, 0, `""`, « »). 1. Let
rejectedClosure be a new Abstract Closure with parameters
(error) that captures module and performs the following steps
when called: 1. Perform AsyncModuleExecutionRejected(module,
error). 1. Return `undefined`. 1. Let onRejected be
CreateBuiltinFunction(rejectedClosure, 0, `""`, « »). 1. Perform
PerformPromiseThen(capability.[[Promise]], onFulfilled,
onRejected). 1. Perform ! module.ExecuteModule(capability).
1. Return ~unused~.

GatherAvailableAncestors ( module: a Cyclic Module Record, execList: a List of Cyclic Module Records, ): ~unused~
-------------------------------------------------------------------------------------------------------------------------

1. For each Cyclic Module Record m of
module.[[AsyncParentModules]], do 1. If execList does not
contain m and m.[[CycleRoot]].[[EvaluationError]] is ~empty~,
then 1. Assert: m.[[Status]] is ~evaluating-async~. 1. Assert:
m.[[EvaluationError]] is ~empty~. 1. Assert:
m.[[AsyncEvaluation]] is `true`. 1. Assert:
m.[[PendingAsyncDependencies]] > 0. 1. Set
m.[[PendingAsyncDependencies]] to m.[[PendingAsyncDependencies]]
- 1. 1. If m.[[PendingAsyncDependencies]] = 0, then 1. Append m
to execList. 1. If m.[[HasTLA]] is `false`, perform
GatherAvailableAncestors(m, execList). 1. Return ~unused~.

When an asynchronous execution for a root module is fulfilled, this
function determines the list of modules which are able to synchronously
execute together on this completion, populating them in execList.

AsyncModuleExecutionFulfilled ( module: a Cyclic Module Record, ): ~unused~
-------------------------------------------------------------------------------

1. If module.[[Status]] is ~evaluated~, then 1. Assert:
module.[[EvaluationError]] is not ~empty~. 1. Return ~unused~. 1.
Assert: module.[[Status]] is ~evaluating-async~. 1. Assert:
module.[[AsyncEvaluation]] is `true`. 1. Assert:
module.[[EvaluationError]] is ~empty~. 1. Set
module.[[AsyncEvaluation]] to `false`. 1. Set
module.[[Status]] to ~evaluated~. 1. If
module.[[TopLevelCapability]] is not ~empty~, then 1. Assert:
module.[[CycleRoot]] and module are the same Module Record. 1.
Perform ! Call(module.[[TopLevelCapability]].[[Resolve]],
`undefined`, « `undefined` »). 1. Let execList be a new empty
List. 1. Perform GatherAvailableAncestors(module, execList). 1.
Let sortedExecList be a List whose elements are the elements of
execList, in the order in which they had their [[AsyncEvaluation]]
fields set to `true` in InnerModuleEvaluation. 1. Assert: All elements
of sortedExecList have their [[AsyncEvaluation]] field set to
`true`, [[PendingAsyncDependencies]] field set to 0, and
[[EvaluationError]] field set to ~empty~. 1. For each Cyclic Module
Record m of sortedExecList, do 1. If m.[[Status]] is
~evaluated~, then 1. Assert: m.[[EvaluationError]] is not ~empty~.
1. Else if m.[[HasTLA]] is `true`, then 1. Perform
ExecuteAsyncModule(m). 1. Else, 1. Let result be
m.ExecuteModule(). 1. If result is an abrupt completion, then 1.
Perform AsyncModuleExecutionRejected(m, result.[[Value]]). 1.
Else, 1. Set m.[[AsyncEvaluation]] to `false`. 1. Set
m.[[Status]] to ~evaluated~. 1. If m.[[TopLevelCapability]] is
not ~empty~, then 1. Assert: m.[[CycleRoot]] and m are the same
Module Record. 1. Perform !
Call(m.[[TopLevelCapability]].[[Resolve]], `undefined`, «
`undefined` »). 1. Return ~unused~.

AsyncModuleExecutionRejected ( module: a Cyclic Module Record, error, ): ~unused~
-----------------------------------------------------------------------------------------------------------------------

1. If module.[[Status]] is ~evaluated~, then 1. Assert:
module.[[EvaluationError]] is not ~empty~. 1. Return ~unused~. 1.
Assert: module.[[Status]] is ~evaluating-async~. 1. Assert:
module.[[AsyncEvaluation]] is `true`. 1. Assert:
module.[[EvaluationError]] is ~empty~. 1. Set
module.[[EvaluationError]] to ThrowCompletion(error). 1. Set
module.[[Status]] to ~evaluated~. 1. Set
module.[[AsyncEvaluation]] to `false`. 1. NOTE:
module.[[AsyncEvaluation]] is set to `false` for symmetry with
AsyncModuleExecutionFulfilled. In InnerModuleEvaluation, the value of a
module's [[AsyncEvaluation]] internal slot is unused when its
[[EvaluationError]] internal slot is not ~empty~. 1. For each Cyclic
Module Record m of module.[[AsyncParentModules]], do 1. Perform
AsyncModuleExecutionRejected(m, error). 1. If
module.[[TopLevelCapability]] is not ~empty~, then 1. Assert:
module.[[CycleRoot]] and module are the same Module Record. 1.
Perform ! Call(module.[[TopLevelCapability]].[[Reject]],
`undefined`, « error »). 1. Return ~unused~.

Example Cyclic Module Record Graphs
-----------------------------------

This non-normative section gives a series of examples of the linking and
evaluation of a few common module graphs, with a specific focus on how
errors can occur.

First consider the following simple module graph:
::

            ╭───────╮
            │   A   │
            ╰───────╯
                ↓
            ╭───────╮
            │   B   │
            ╰───────╯
                ↓
            ╭───────╮
            │   C   │
            ╰───────╯

   Figure 2: A simple module graph

.. .. figure:: https://tc39.es/ecma262/img/module-graph-simple.svg
   :width: 121px
   :height: 211px

   A module graph in which module A depends on module B, and module B depends on module C


Let's first assume that there are no error conditions. When a host first
calls A.LoadRequestedModules(), this will complete successfully by
assumption, and recursively load the dependencies of B and C as
well (respectively, C and none), and then set A.[[Status]] =
B.[[Status]] = C.[[Status]] = ~unlinked~. Then, when the host
calls A.Link(), it will complete successfully (again by assumption)
such that A.[[Status]] = B.[[Status]] = C.[[Status]] =
linked. These preparatory steps can be performed at any time. Later,
when the host is ready to incur any possible side effects of the
modules, it can call A.Evaluate(), which will complete successfully,
returning a Promise resolving to `undefined` (again by assumption),
recursively having evaluated first C and then B. Each module's
[[Status]] at this point will be ~evaluated~.

Consider then cases involving linking errors, after a successful call to
A.LoadRequestedModules(). If InnerModuleLinking of C succeeds
but, thereafter, fails for B, for example because it imports
something that C does not provide, then the original A.Link()
will fail, and both A and B's [[Status]] remain ~unlinked~.
C's [[Status]] has become ~linked~, though.

Finally, consider a case involving evaluation errors after a successful
call to Link(). If InnerModuleEvaluation of C succeeds but,
thereafter, fails for B, for example because B contains code
that throws an exception, then the original A.Evaluate() will fail,
returning a rejected Promise. The resulting exception will be recorded
in both A and B's [[EvaluationError]] fields, and their
[[Status]] will become ~evaluated~. C will also become ~evaluated~
but, in contrast to A and B, will remain without an
[[EvaluationError]], as it successfully completed evaluation. Storing
the exception ensures that any time a host tries to reuse A or B
by calling their Evaluate() method, it will encounter the same
exception. (Hosts are not required to reuse Cyclic Module Records;
similarly, hosts are not required to expose the exception objects thrown
by these methods. However, the specification enables such uses.)

Now consider a different type of error condition:
::

   ╭───────╮
   │   A   │
   ╰───────╯
       ↓
   ╭───────╮
   │  ???  │
   ╰───────╯

Figure 3: A module graph with an unresolvable module

.. .. figure:: https://tc39.es/ecma262/img/module-graph-missing.svg
   :width: 121px
   :height: 121px

   A module graph in which module A depends on a missing (unresolvable) module, represented by ???


In this scenario, module A declares a dependency on some other
module, but no Module Record exists for that module, i.e.
HostLoadImportedModule calls FinishLoadingImportedModule with an
exception when asked for it. This could occur for a variety of reasons,
such as the corresponding resource not existing, or the resource
existing but ParseModule returning some errors when trying to parse the
resulting source text. Hosts can choose to expose the cause of failure
via the completion they pass to FinishLoadingImportedModule. In any
case, this exception causes a loading failure, which results in A's
[[Status]] remaining ~new~.

The difference here between loading, linking and evaluation errors is
due to the following characteristic:

- Evaluation must be only performed once, as it can cause side effects;
  it is thus important to remember whether evaluation has already been
  performed, even if unsuccessfully. (In the error case, it makes sense
  to also remember the exception because otherwise subsequent Evaluate()
  calls would have to synthesize a new one.)
- Linking, on the other hand, is side-effect-free, and thus even if it
  fails, it can be retried at a later time with no issues.
- Loading closely interacts with the host, and it may be desirable for
  some of them to allow users to retry failed loads (for example, if the
  failure is caused by temporarily bad network conditions).

Now, consider a module graph with a cycle:

::

         ╭─────────╮
      ╭─>│    A    │
      │  ╰─────────╯
      │  ╭────┴────╮
      │  ↓         ↓
   ╭───────╮    ╭───────╮
   │   B   │    │   C   │
   ╰───────╯    ╰───────╯

   Figure 4: A cyclic module graph

.. .. figure:: https://tc39.es/ecma262/img/module-graph-cycle.svg
   :width: 181px
   :height: 121px

   A module graph in which module A depends on module B and C, but module B also depends on module A


Here we assume that the entry point is module A, so that the host
proceeds by calling A.LoadRequestedModules(), which performs
InnerModuleLoading on A. This in turn calls InnerModuleLoading on
B and C. Because of the cycle, this again triggers
InnerModuleLoading on A, but at this point it is a no-op since
A's dependencies loading has already been triggered during this
LoadRequestedModules process. When all the modules in the graph have
been successfully loaded, their [[Status]] transitions from ~new~ to
~unlinked~ at the same time.

Then the host proceeds by calling A.Link(), which performs
InnerModuleLinking on A. This in turn calls InnerModuleLinking on
B. Because of the cycle, this again triggers InnerModuleLinking on
A, but at this point it is a no-op since A.[[Status]] is already
~linking~. B.[[Status]] itself remains ~linking~ when control gets
back to A and InnerModuleLinking is triggered on C. After this
returns with C.[[Status]] being ~linked~, both A and B
transition from ~linking~ to ~linked~ together; this is by design, since
they form a strongly connected component. It's possible to transition
the status of modules in the same SCC at the same time because during
this phase the module graph is traversed with a depth-first search.

An analogous story occurs for the evaluation phase of a cyclic module
graph, in the success case.

Now consider a case where A has a linking error; for example, it
tries to import a binding from C that does not exist. In that case,
the above steps still occur, including the early return from the second
call to InnerModuleLinking on A. However, once we unwind back to the
original InnerModuleLinking on A, it fails during
InitializeEnvironment, namely right after C.ResolveExport(). The
thrown `SyntaxError` exception propagates up to A.Link, which
resets all modules that are currently on its stack (these are always
exactly the modules that are still ~linking~). Hence both A and
B become ~unlinked~. Note that C is left as ~linked~.

Alternatively, consider a case where A has an evaluation error; for
example, its source code throws an exception. In that case, the
evaluation-time analogue of the above steps still occurs, including the
early return from the second call to InnerModuleEvaluation on A.
However, once we unwind back to the original InnerModuleEvaluation on
A, it fails by assumption. The exception thrown propagates up to
A.Evaluate(), which records the error in all modules that are
currently on its stack (i.e., the modules that are still
~evaluating~) as well as via [[AsyncParentModules]], which form a chain
for modules which contain or depend on top-level `await` through the
whole dependency graph through the AsyncModuleExecutionRejected
algorithm. Hence both A and B become ~evaluated~ and the
exception is recorded in both A and B's [[EvaluationError]]
fields, while C is left as ~evaluated~ with no [[EvaluationError]].

Lastly, consider a module graph with a cycle, where all modules complete
asynchronously:
::

         ╭───────────╮
         │     A     │
         ╰───────────╯
        ╭──────┴──────╮
        ↓      ↑      ↓
   ╭────────╮  │  ╭────────╮
   │    B   │  │  │   C    │
   ╰────────╯  │  ╰────────╯
        ╰────╮ │ ╭───╯  ╰────╮
             ↓ │ ↓           ↓
          ╭─────────╮     ╭─────────╮
          │    D    │     │    E    │
          ╰─────────╯     ╰─────────╯

   Figure 5: An asynchronous cyclic module graph

.. .. figure:: https://tc39.es/ecma262/img/module-graph-cycle-async.svg
   :width: 241px
   :height: 211px

   A module graph in which module A depends on module B and C, module B depends 
   on module D, module C depends on module D and E, and module D depends on module A

Loading and linking happen as before, and all modules end up with
[[Status]] set to ~linked~.

Calling A.Evaluate() calls InnerModuleEvaluation on A, B,
and D, which all transition to ~evaluating~. Then
InnerModuleEvaluation is called on A again, which is a no-op because
it is already ~evaluating~. At this point,
D.[[PendingAsyncDependencies]] is 0, so ExecuteAsyncModule(D) is
called and we call D.ExecuteModule with a new PromiseCapability
tracking the asynchronous execution of D. We unwind back to the
InnerModuleEvaluation on B, setting
B.[[PendingAsyncDependencies]] to 1 and B.[[AsyncEvaluation]] to
`true`. We unwind back to the original InnerModuleEvaluation on A,
setting A.[[PendingAsyncDependencies]] to 1. In the next iteration
of the loop over A's dependencies, we call InnerModuleEvaluation on
C and thus on D (again a no-op) and E. As E has no
dependencies and is not part of a cycle, we call
ExecuteAsyncModule(E) in the same manner as D and E is
immediately removed from the stack. We unwind once more to the original
InnerModuleEvaluation on A, setting C.[[AsyncEvaluation]] to
`true`. Now we finish the loop over A's dependencies, set
A.[[AsyncEvaluation]] to `true`, and remove the entire strongly
connected component from the stack, transitioning all of the modules to
~evaluating-async~ at once. At this point, the fields of the modules are
as given in .

+-----------+-----------+-----------+-----------+-----------+-----------+
| Field     | A     | B     | C     | D     | E     |
|           |           |           |           |           |           |
| .. co     |           |           |           |           |           |
| ntainer:: |           |           |           |           |           |
| slash     |           |           |           |           |           |
|           |           |           |           |           |           |
| Module    |           |           |           |           |           |
+===========+===========+===========+===========+===========+===========+
| [[D       | 0         | 1         | 3         | 2         | 4         |
| FSIndex]] |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| [[        | 0         | 0         | 0         | 0         | 4         |
| DFSAncest |           |           |           |           |           |
| orIndex]] |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| [         | ~evaluati | ~evaluati | ~evaluati | ~evaluati | ~evaluati |
| [Status]] | ng-async~ | ng-async~ | ng-async~ | ng-async~ | ng-async~ |
+-----------+-----------+-----------+-----------+-----------+-----------+
| [         | `true`  | `true`  | `true`  | `true`  | `true`  |
| [AsyncEva |           |           |           |           |           |
| luation]] |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| [[As      | « »       | « A » | « A » | « B,  | « C » |
| yncParent |           |           |           | C »   |           |
| Modules]] |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+
| [         | 2 (B  | 1 (D) | 2 (D  | 0         | 0         |
| [PendingA | and       |           | and       |           |           |
| syncDepen | C)    |           | E)    |           |           |
| dencies]] |           |           |           |           |           |
+-----------+-----------+-----------+-----------+-----------+-----------+

Let us assume that E finishes executing first. When that happens,
AsyncModuleExecutionFulfilled is called, E.[[Status]] is set to
~evaluated~ and C.[[PendingAsyncDependencies]] is decremented to
become 1. The fields of the updated modules are as given in .

============================ ================== ===========
Fields / Modules             C              E
============================ ================== ===========
[[DFSIndex]]                 3                  4
[[DFSAncestorIndex]]         0                  4
[[Status]]                   ~evaluating-async~ ~evaluated~
[[AsyncEvaluation]]          `true`           `true`
[[AsyncParentModules]]       « A »          « C »
[[PendingAsyncDependencies]] 1 (D)          0
============================ ================== ===========

D is next to finish (as it was the only module that was still
executing). When that happens, AsyncModuleExecutionFulfilled is called
again and D.[[Status]] is set to ~evaluated~. Then
B.[[PendingAsyncDependencies]] is decremented to become 0,
ExecuteAsyncModule is called on B, and it starts executing.
C.[[PendingAsyncDependencies]] is also decremented to become 0, and
C starts executing (potentially in parallel to B if B
contains an `await`). The fields of the updated modules are as given
in .

+----------------+----------------+----------------+----------------+
| Fields /       | B          | C          | D          |
| Module         |                |                |                |
+================+================+================+================+
| [[DFSIndex]]   | 1              | 3              | 2              |
+----------------+----------------+----------------+----------------+
| [[DFSA         | 0              | 0              | 0              |
| ncestorIndex]] |                |                |                |
+----------------+----------------+----------------+----------------+
| [[Status]]     | ~eva           | ~eva           | ~evaluated~    |
|                | luating-async~ | luating-async~ |                |
+----------------+----------------+----------------+----------------+
| [[Asy          | `true`       | `true`       | `true`       |
| ncEvaluation]] |                |                |                |
+----------------+----------------+----------------+----------------+
| [[AsyncP       | « A »      | « A »      | « B, C |
| arentModules]] |                |                | »              |
+----------------+----------------+----------------+----------------+
| [[PendingAsync | 0              | 0              | 0              |
| Dependencies]] |                |                |                |
+----------------+----------------+----------------+----------------+

Let us assume that C finishes executing next. When that happens,
AsyncModuleExecutionFulfilled is called again, C.[[Status]] is set
to ~evaluated~ and A.[[PendingAsyncDependencies]] is decremented to
become 1. The fields of the updated modules are as given in .

============================ ================== ===========
Fields / Modules             A              C
============================ ================== ===========
[[DFSIndex]]                 0                  3
[[DFSAncestorIndex]]         0                  0
[[Status]]                   ~evaluating-async~ ~evaluated~
[[AsyncEvaluation]]          `true`           `true`
[[AsyncParentModules]]       « »                « A »
[[PendingAsyncDependencies]] 1 (B)          0
============================ ================== ===========

Then, B finishes executing. When that happens,
AsyncModuleExecutionFulfilled is called again and B.[[Status]] is
set to ~evaluated~. A.[[PendingAsyncDependencies]] is decremented to
become 0, so ExecuteAsyncModule is called and it starts executing. The
fields of the updated modules are as given in .

============================ ================== ===========
Fields / Modules             A              B
============================ ================== ===========
[[DFSIndex]]                 0                  1
[[DFSAncestorIndex]]         0                  0
[[Status]]                   ~evaluating-async~ ~evaluated~
[[AsyncEvaluation]]          `true`           `true`
[[AsyncParentModules]]       « »                « A »
[[PendingAsyncDependencies]] 0                  0
============================ ================== ===========

Finally, A finishes executing. When that happens,
AsyncModuleExecutionFulfilled is called again and A.[[Status]] is
set to ~evaluated~. At this point, the Promise in
A.[[TopLevelCapability]] (which was returned from A.Evaluate())
is resolved, and this concludes the handling of this module graph. The
fields of the updated module are as given in .

============================ ===========
Fields / Modules             A
============================ ===========
[[DFSIndex]]                 0
[[DFSAncestorIndex]]         0
[[Status]]                   ~evaluated~
[[AsyncEvaluation]]          `true`
[[AsyncParentModules]]       « »
[[PendingAsyncDependencies]] 0
============================ ===========

Alternatively, consider a failure case where C fails execution and
returns an error before B has finished executing. When that happens,
AsyncModuleExecutionRejected is called, which sets C.[[Status]] to
~evaluated~ and C.[[EvaluationError]] to the error. It then
propagates this error to all of the AsyncParentModules by performing
AsyncModuleExecutionRejected on each of them. The fields of the updated
modules are as given in .

============================ =========== ========================
Fields / Modules             A       C
============================ =========== ========================
[[DFSIndex]]                 0           3
[[DFSAncestorIndex]]         0           0
[[Status]]                   ~evaluated~ ~evaluated~
[[AsyncEvaluation]]          `true`    `true`
[[AsyncParentModules]]       « »         « A »
[[PendingAsyncDependencies]] 1 (B)   0
[[EvaluationError]]          ~empty~     C's evaluation error
============================ =========== ========================

A will be rejected with the same error as C since C will
call AsyncModuleExecutionRejected on A with C's error.
A.[[Status]] is set to ~evaluated~. At this point the Promise in
A.[[TopLevelCapability]] (which was returned from A.Evaluate())
is rejected. The fields of the updated module are as given in .

============================ ========================
Fields / Modules             A
============================ ========================
[[DFSIndex]]                 0
[[DFSAncestorIndex]]         0
[[Status]]                   ~evaluated~
[[AsyncEvaluation]]          `true`
[[AsyncParentModules]]       « »
[[PendingAsyncDependencies]] 0
[[EvaluationError]]          C's Evaluation Error
============================ ========================

Then, B finishes executing without an error. When that happens,
AsyncModuleExecutionFulfilled is called again and B.[[Status]] is
set to ~evaluated~. GatherAvailableAncestors is called on B.
However, A.[[CycleRoot]] is A which has an evaluation error, so
it will not be added to the returned sortedExecList and
AsyncModuleExecutionFulfilled will return without further processing.
Any future importer of B will resolve the rejection of
B.[[CycleRoot]].[[EvaluationError]] from the evaluation error from
C that was set on the cycle root A. The fields of the updated
modules are as given in .

============================ ======================== ===========
Fields / Modules             A                    B
============================ ======================== ===========
[[DFSIndex]]                 0                        1
[[DFSAncestorIndex]]         0                        0
[[Status]]                   ~evaluated~              ~evaluated~
[[AsyncEvaluation]]          `true`                 `true`
[[AsyncParentModules]]       « »                      « A »
[[PendingAsyncDependencies]] 0                        0
[[EvaluationError]]          C's Evaluation Error ~empty~
============================ ======================== ===========

Source Text Module Records
--------------------------

A Source Text Module Record is used to represent information about a
module that was defined from ECMAScript source text () that was parsed
using the goal symbol `Module`. Its fields contain digested
information about the names that are imported and exported by the
module, and its concrete methods use these digests to link and evaluate
the module.

A Source Text Module Record can exist in a module graph with other
subclasses of the abstract Module Record type, and can participate in
cycles with other subclasses of the Cyclic Module Record type.

In addition to the fields defined in , Source Text Module Records have
the additional fields listed in . Each of these fields is initially set
in ParseModule.

+----------------------+----------------------+----------------------+
| Field Name           | Value Type           | Meaning              |
+======================+======================+======================+
| [[ECMAScriptCode]]   | a Parse Node         | The result of        |
|                      |                      | parsing the source   |
|                      |                      | text of this module  |
|                      |                      | using `Module` as  |
|                      |                      | the goal symbol.     |
+----------------------+----------------------+----------------------+
| [[Context]]          | an ECMAScript code   | The execution        |
|                      | execution context or | context associated   |
|                      | ~empty~              | with this module. It |
|                      |                      | is ~empty~ until the |
|                      |                      | module's environment |
|                      |                      | has been             |
|                      |                      | initialized.         |
+----------------------+----------------------+----------------------+
| [[ImportMeta]]       | an Object or ~empty~ | An object exposed    |
|                      |                      | through the          |
|                      |                      | `import.meta` meta |
|                      |                      | property. It is      |
|                      |                      | ~empty~ until it is  |
|                      |                      | accessed by          |
|                      |                      | ECMAScript code.     |
+----------------------+----------------------+----------------------+
| [[ImportEntries]]    | a List of            | A List of            |
|                      | ImportEntry Records  | ImportEntry records  |
|                      |                      | derived from the     |
|                      |                      | code of this module. |
+----------------------+----------------------+----------------------+
| [[                   | a List of            | A List of            |
| LocalExportEntries]] | ExportEntry Records  | ExportEntry records  |
|                      |                      | derived from the     |
|                      |                      | code of this module  |
|                      |                      | that correspond to   |
|                      |                      | declarations that    |
|                      |                      | occur within the     |
|                      |                      | module.              |
+----------------------+----------------------+----------------------+
| [[Ind                | a List of            | A List of            |
| irectExportEntries]] | ExportEntry Records  | ExportEntry records  |
|                      |                      | derived from the     |
|                      |                      | code of this module  |
|                      |                      | that correspond to   |
|                      |                      | reexported imports   |
|                      |                      | that occur within    |
|                      |                      | the module or        |
|                      |                      | exports from         |
|                      |                      | `export ` as       |
|                      |                      | namespace`          |
|                      |                      | declarations.        |
+----------------------+----------------------+----------------------+
| [                    | a List of            | A List of            |
| [StarExportEntries]] | ExportEntry Records  | ExportEntry records  |
|                      |                      | derived from the     |
|                      |                      | code of this module  |
|                      |                      | that correspond to   |
|                      |                      | `export ``        |
|                      |                      | declarations that    |
|                      |                      | occur within the     |
|                      |                      | module, not          |
|                      |                      | including `export   |
|                      |                      | ` as namespace`    |
|                      |                      | declarations.        |
+----------------------+----------------------+----------------------+

An ImportEntry Record is a Record that digests information about a
single declarative import. Each ImportEntry Record has the fields
defined in :

+-------------------+-----------------------+-----------------------+
| Field Name        | Value Type            | Meaning               |
+===================+=======================+=======================+
| [[ModuleRequest]] | a String              | String value of the   |
|                   |                       | `ModuleSpecifier`   |
|                   |                       | of the                |
|                   |                       | \                     |
|                   |                       | |ImportDeclaration\|. |
+-------------------+-----------------------+-----------------------+
| [[ImportName]]    | a String or           | The name under which  |
|                   | ~namespace-object~    | the desired binding   |
|                   |                       | is exported by the    |
|                   |                       | module identified by  |
|                   |                       | [[ModuleRequest]].    |
|                   |                       | The value             |
|                   |                       | ~namespace-object~    |
|                   |                       | indicates that the    |
|                   |                       | import request is for |
|                   |                       | the target module's   |
|                   |                       | namespace object.     |
+-------------------+-----------------------+-----------------------+
| [[LocalName]]     | a String              | The name that is used |
|                   |                       | to locally access the |
|                   |                       | imported value from   |
|                   |                       | within the importing  |
|                   |                       | module.               |
+-------------------+-----------------------+-----------------------+

gives examples of ImportEntry records fields used to represent the
syntactic import forms:

+----------------+----------------+----------------+---------------+
| Import         | [[M            | [[ImportName]] | [[LocalName]] |
| Statement Form | oduleRequest]] |                |               |
+================+================+================+===============+
| `import v     | `"mod"`      | `"default"`  | `"v"`       |
| from "mod";`  |                |                |               |
+----------------+----------------+----------------+---------------+
| `import ` as | `"mod"`      | ~nam           | `"ns"`      |
| ns from        |                | espace-object~ |               |
| "mod";`       |                |                |               |
+----------------+----------------+----------------+---------------+
| `import {x}   | `"mod"`      | `"x"`        | `"x"`       |
| from "mod";`  |                |                |               |
+----------------+----------------+----------------+---------------+
| `import {x as | `"mod"`      | `"x"`        | `"v"`       |
| v} from        |                |                |               |
| "mod";`       |                |                |               |
+----------------+----------------+----------------+---------------+
| `import       | An ImportEntry |                |               |
| "mod";`       | Record is not  |                |               |
|                | created.       |                |               |
+----------------+----------------+----------------+---------------+

An ExportEntry Record is a Record that digests information about a
single declarative export. Each ExportEntry Record has the fields
defined in :

+-------------------+-----------------------+-----------------------+
| Field Name        | Value Type            | Meaning               |
+===================+=======================+=======================+
| [[ExportName]]    | a String or `null`  | The name used to      |
|                   |                       | export this binding   |
|                   |                       | by this module.       |
+-------------------+-----------------------+-----------------------+
| [[ModuleRequest]] | a String or `null`  | The String value of   |
|                   |                       | the                   |
|                   |                       | `ModuleSpecifier`   |
|                   |                       | of the                |
|                   |                       | \                     |
|                   |                       | |ExportDeclaration\|. |
|                   |                       | `null` if the       |
|                   |                       | `ExportDeclaration` |
|                   |                       | does not have a       |
|                   |                       | `ModuleSpecifier`.  |
+-------------------+-----------------------+-----------------------+
| [[ImportName]]    | a String, `null`,   | The name under which  |
|                   | ~all~, or             | the desired binding   |
|                   | ~all-but-default~     | is exported by the    |
|                   |                       | module identified by  |
|                   |                       | [[ModuleRequest]].    |
|                   |                       | `null` if the       |
|                   |                       | `ExportDeclaration` |
|                   |                       | does not have a       |
|                   |                       | `ModuleSpecifier`.  |
|                   |                       | ~all~ is used for     |
|                   |                       | `export ` as ns     |
|                   |                       | from "mod"`          |
|                   |                       | declarations.         |
|                   |                       | ~all-but-default~ is  |
|                   |                       | used for `export `  |
|                   |                       | from "mod"`          |
|                   |                       | declarations.         |
+-------------------+-----------------------+-----------------------+
| [[LocalName]]     | a String or `null`  | The name that is used |
|                   |                       | to locally access the |
|                   |                       | exported value from   |
|                   |                       | within the importing  |
|                   |                       | module. `null` if   |
|                   |                       | the exported value is |
|                   |                       | not locally           |
|                   |                       | accessible from       |
|                   |                       | within the module.    |
+-------------------+-----------------------+-----------------------+

gives examples of the ExportEntry record fields used to represent the
syntactic export forms:

+-------------+-------------+-------------+-------------+-------------+
| Export      | [[E         | [[Modu      | [[I         | [[          |
| Statement   | xportName]] | leRequest]] | mportName]] | LocalName]] |
| Form        |             |             |             |             |
+=============+=============+=============+=============+=============+
| `export    | `"v"`     | `null`    | `null`    | `"v"`     |
| var v;`    |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export    | `          | `null`    | `null`    | `"f"`     |
| default     | "default"` |             |             |             |
| function    |             |             |             |             |
| f() {}`    |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export    | `          | `null`    | `null`    | `"\`def   |
| default     | "default"` |             |             | ault\\`"` |
| function () |             |             |             |             |
| {}`        |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export    | `          | `null`    | `null`    | `"\`def   |
| default     | "default"` |             |             | ault\\`"` |
| 42;`       |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export    | `"x"`     | `null`    | `null`    | `"x"`     |
| {x};`      |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export {v | `"x"`     | `null`    | `null`    | `"v"`     |
| as x};`    |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export    | `"x"`     | `"mod"`   | `"x"`     | `null`    |
| {x} from    |             |             |             |             |
| "mod";`    |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export {v | `"x"`     | `"mod"`   | `"v"`     | `null`    |
| as x} from  |             |             |             |             |
| "mod";`    |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export ` | `null`    | `"mod"`   | ~all-b      | `null`    |
| from        |             |             | ut-default~ |             |
| "mod";`    |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| `export ` | `"ns"`    | `"mod"`   | ~all~       | `null`    |
| as ns from  |             |             |             |             |
| "mod";`    |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+

The following definitions specify the required concrete methods and
other abstract operations for Source Text Module Records

ParseModule ( sourceText: ECMAScript source text, realm: a Realm Record, hostDefined: anything, ): a Source Text Module Record or a non-empty List of `SyntaxError` objects
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It creates a Source Text Module Record based upon the result of
   parsing sourceText as a `Module`.

1. Let body be ParseText(sourceText, `Module`). 1. If body
is a List of errors, return body. 1. Let requestedModules be the
ModuleRequests of body. 1. Let importEntries be the
ImportEntries of body. 1. Let importedBoundNames be
ImportedLocalNames(importEntries). 1. Let indirectExportEntries
be a new empty List. 1. Let localExportEntries be a new empty List.
1. Let starExportEntries be a new empty List. 1. Let
exportEntries be the ExportEntries of body. 1. For each
ExportEntry Record ee of exportEntries, do 1. If
ee.[[ModuleRequest]] is `null`, then 1. If importedBoundNames
does not contain ee.[[LocalName]], then 1. Append ee to
localExportEntries. 1. Else, 1. Let ie be the element of
importEntries whose [[LocalName]] is ee.[[LocalName]]. 1. If
ie.[[ImportName]] is ~namespace-object~, then 1. NOTE: This is a
re-export of an imported module namespace object. 1. Append ee to
localExportEntries. 1. Else, 1. NOTE: This is a re-export of a
single name. 1. Append the ExportEntry Record { [[ModuleRequest]]:
ie.[[ModuleRequest]], [[ImportName]]: ie.[[ImportName]],
[[LocalName]]: `null`, [[ExportName]]: ee.[[ExportName]] } to
indirectExportEntries. 1. Else if ee.[[ImportName]] is
~all-but-default~, then 1. Assert: ee.[[ExportName]] is `null`. 1.
Append ee to starExportEntries. 1. Else, 1. Append ee to
indirectExportEntries. 1. Let async be body Contains
`await`. 1. Return Source Text Module Record { [[Realm]]: realm,
[[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]:
~empty~, [[HasTLA]]: async, [[AsyncEvaluation]]: `false`,
[[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « »,
[[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~,
[[EvaluationError]]: ~empty~, [[HostDefined]]: hostDefined,
[[ECMAScriptCode]]: body, [[Context]]: ~empty~, [[ImportMeta]]:
~empty~, [[RequestedModules]]: requestedModules, [[LoadedModules]]:
« », [[ImportEntries]]: importEntries, [[LocalExportEntries]]:
localExportEntries, [[IndirectExportEntries]]:
indirectExportEntries, [[StarExportEntries]]: starExportEntries,
[[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.

An implementation may parse module source text and analyse it for Early
Error conditions prior to the evaluation of ParseModule for that module
source text. However, the reporting of any errors must be deferred until
the point where this specification actually performs ParseModule upon
that source text.

GetExportedNames ( optional exportStarSet: a List of Source Text Module Records, ): a List of Strings
---------------------------------------------------------------------------------------------------------

for
   a Source Text Module Record module

1. Assert: module.[[Status]] is not ~new~. 1. If exportStarSet
is not present, set exportStarSet to a new empty List. 1. If
exportStarSet contains module, then 1. Assert: We've reached the
starting point of an `export `` circularity. 1. Return a new empty
List. 1. Append module to exportStarSet. 1. Let
exportedNames be a new empty List. 1. For each ExportEntry Record
e of module.[[LocalExportEntries]], do 1. Assert: module
provides the direct binding for this export. 1. Assert:
e.[[ExportName]] is not `null`. 1. Append e.[[ExportName]] to
exportedNames. 1. For each ExportEntry Record e of
module.[[IndirectExportEntries]], do 1. Assert: module imports a
specific binding for this export. 1. Assert: e.[[ExportName]] is not
`null`. 1. Append e.[[ExportName]] to exportedNames. 1. For
each ExportEntry Record e of module.[[StarExportEntries]], do 1.
Assert: e.[[ModuleRequest]] is not `null`. 1. Let
requestedModule be GetImportedModule(module,
e.[[ModuleRequest]]). 1. Let starNames be
requestedModule.GetExportedNames(exportStarSet). 1. For each
element n of starNames, do 1. If n is not `"default"`,
then 1. If exportedNames does not contain n, then 1. Append
n to exportedNames. 1. Return exportedNames.

GetExportedNames does not filter out or throw an exception for names
that have ambiguous star export bindings.

ResolveExport ( exportName: a String, optional resolveSet: a List of Records with fields [[Module]] (a Module Record) and [[ExportName]] (a String), ): a ResolvedBinding Record, `null`, or ~ambiguous~
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

for
   a Source Text Module Record module
description
   ResolveExport attempts to resolve an imported binding to the actual
   defining module and local binding name. The defining module may be
   the module represented by the Module Record this method was invoked
   on or some other module that is imported by that module. The
   parameter resolveSet is used to detect unresolved circular
   import/export paths. If a pair consisting of specific Module Record
   and exportName is reached that is already in resolveSet, an
   import circularity has been encountered. Before recursively calling
   ResolveExport, a pair consisting of module and exportName is
   added to resolveSet.

   If a defining module is found, a ResolvedBinding Record { [[Module]],
   [[BindingName]] } is returned. This record identifies the resolved
   binding of the originally requested export, unless this is the export
   of a namespace with no local binding. In this case, [[BindingName]]
   will be set to ~namespace~. If no definition was found or the request
   is found to be circular, `null` is returned. If the request is
   found to be ambiguous, ~ambiguous~ is returned.

1. Assert: module.[[Status]] is not ~new~. 1. If resolveSet is
not present, set resolveSet to a new empty List. 1. For each Record
{ [[Module]], [[ExportName]] } r of resolveSet, do 1. If
module and r.[[Module]] are the same Module Record and
exportName is r.[[ExportName]], then 1. Assert: This is a
circular import request. 1. Return `null`. 1. Append the Record {
[[Module]]: module, [[ExportName]]: exportName } to
resolveSet. 1. For each ExportEntry Record e of
module.[[LocalExportEntries]], do 1. If e.[[ExportName]] is
exportName, then 1. Assert: module provides the direct binding
for this export. 1. Return ResolvedBinding Record { [[Module]]:
module, [[BindingName]]: e.[[LocalName]] }. 1. For each
ExportEntry Record e of module.[[IndirectExportEntries]], do 1.
If e.[[ExportName]] is exportName, then 1. Assert:
e.[[ModuleRequest]] is not `null`. 1. Let importedModule be
GetImportedModule(module, e.[[ModuleRequest]]). 1. If
e.[[ImportName]] is ~all~, then 1. Assert: module does not
provide the direct binding for this export. 1. Return ResolvedBinding
Record { [[Module]]: importedModule, [[BindingName]]: ~namespace~ }.
1. Else, 1. Assert: module imports a specific binding for this
export. 1. Return importedModule.ResolveExport(e.[[ImportName]],
resolveSet). 1. If exportName is `"default"`, then 1. Assert:
A `default` export was not explicitly defined by this module. 1.
Return `null`. 1. NOTE: A `default` export cannot be provided by an
`export ` from "mod"` declaration. 1. Let starResolution be
`null`. 1. For each ExportEntry Record e of
module.[[StarExportEntries]], do 1. Assert: e.[[ModuleRequest]]
is not `null`. 1. Let importedModule be
GetImportedModule(module, e.[[ModuleRequest]]). 1. Let
resolution be importedModule.ResolveExport(exportName,
resolveSet). 1. If resolution is ~ambiguous~, return
~ambiguous~. 1. If resolution is not `null`, then 1. Assert:
resolution is a ResolvedBinding Record. 1. If starResolution is
`null`, then 1. Set starResolution to resolution. 1. Else, 1.
Assert: There is more than one `*` import that includes the requested
name. 1. If resolution.[[Module]] and starResolution.[[Module]]
are not the same Module Record, return ~ambiguous~. 1. If
resolution.[[BindingName]] is not starResolution.[[BindingName]]
and either resolution.[[BindingName]] or
starResolution.[[BindingName]] is ~namespace~, return ~ambiguous~.
1. If resolution.[[BindingName]] is a String,
starResolution.[[BindingName]] is a String, and
resolution.[[BindingName]] is not
starResolution.[[BindingName]], return ~ambiguous~. 1. Return
starResolution.

InitializeEnvironment ( )
-------------------------

for
   a Source Text Module Record module

1. For each ExportEntry Record e of
module.[[IndirectExportEntries]], do 1. Assert: e.[[ExportName]]
is not `null`. 1. Let resolution be
module.ResolveExport(e.[[ExportName]]). 1. If resolution is
either `null` or ~ambiguous~, throw a `SyntaxError` exception. 1.
Assert: resolution is a ResolvedBinding Record. 1. Assert: All named
exports from module are resolvable. 1. Let realm be
module.[[Realm]]. 1. Assert: realm is not `undefined`. 1. Let
env be NewModuleEnvironment(realm.[[GlobalEnv]]). 1. Set
module.[[Environment]] to env. 1. For each ImportEntry Record
in of module.[[ImportEntries]], do 1. Let importedModule be
GetImportedModule(module, in.[[ModuleRequest]]). 1. If
in.[[ImportName]] is ~namespace-object~, then 1. Let namespace
be GetModuleNamespace(importedModule). 1. Perform !
env.CreateImmutableBinding(in.[[LocalName]], `true`). 1.
Perform ! env.InitializeBinding(in.[[LocalName]],
namespace). 1. Else, 1. Let resolution be
importedModule.ResolveExport(in.[[ImportName]]). 1. If
resolution is either `null` or ~ambiguous~, throw a
`SyntaxError` exception. 1. If resolution.[[BindingName]] is
~namespace~, then 1. Let namespace be
GetModuleNamespace(resolution.[[Module]]). 1. Perform !
env.CreateImmutableBinding(in.[[LocalName]], `true`). 1.
Perform ! env.InitializeBinding(in.[[LocalName]],
namespace). 1. Else, 1. Perform
env.CreateImportBinding(in.[[LocalName]],
resolution.[[Module]], resolution.[[BindingName]]). 1. Let
moduleContext be a new ECMAScript code execution context. 1. Set the
Function of moduleContext to `null`. 1. Assert:
module.[[Realm]] is not `undefined`. 1. Set the Realm of
moduleContext to module.[[Realm]]. 1. Set the ScriptOrModule of
moduleContext to module. 1. Set the VariableEnvironment of
moduleContext to module.[[Environment]]. 1. Set the
LexicalEnvironment of moduleContext to module.[[Environment]].
1. Set the PrivateEnvironment of moduleContext to `null`. 1. Set
module.[[Context]] to moduleContext. 1. Push moduleContext
onto the execution context stack; moduleContext is now the running
execution context. 1. Let code be module.[[ECMAScriptCode]]. 1.
Let varDeclarations be the VarScopedDeclarations of code. 1. Let
declaredVarNames be a new empty List. 1. For each element d of
varDeclarations, do 1. For each element dn of the BoundNames of
d, do 1. If declaredVarNames does not contain dn, then 1.
Perform ! env.CreateMutableBinding(dn, `false`). 1. Perform !
env.InitializeBinding(dn, `undefined`). 1. Append dn to
declaredVarNames. 1. Let lexDeclarations be the
LexicallyScopedDeclarations of code. 1. Let privateEnv be
`null`. 1. For each element d of lexDeclarations, do 1. For
each element dn of the BoundNames of d, do 1. If
IsConstantDeclaration of d is `true`, then 1. Perform !
env.CreateImmutableBinding(dn, `true`). 1. Else, 1. Perform !
env.CreateMutableBinding(dn, `false`). 1. If d is either a
`FunctionDeclaration`, a `GeneratorDeclaration`, an
`AsyncFunctionDeclaration`, or an `AsyncGeneratorDeclaration`, then
1. Let fo be InstantiateFunctionObject of d with arguments
env and privateEnv. 1. Perform !
env.InitializeBinding(dn, fo). 1. Remove moduleContext
from the execution context stack. 1. Return ~unused~.

ExecuteModule ( optional capability: a PromiseCapability Record, )
------------------------------------------------------------------

for
   a Source Text Module Record module

1. Let moduleContext be a new ECMAScript code execution context. 1.
Set the Function of moduleContext to `null`. 1. Set the Realm of
moduleContext to module.[[Realm]]. 1. Set the ScriptOrModule of
moduleContext to module. 1. Assert: module has been linked
and declarations in its module environment have been instantiated. 1.
Set the VariableEnvironment of moduleContext to
module.[[Environment]]. 1. Set the LexicalEnvironment of
moduleContext to module.[[Environment]]. 1. Suspend the running
execution context. 1. If module.[[HasTLA]] is `false`, then 1.
Assert: capability is not present. 1. Push moduleContext onto
the execution context stack; moduleContext is now the running
execution context. 1. Let result be Completion(Evaluation of
module.[[ECMAScriptCode]]). 1. Suspend moduleContext and remove
it from the execution context stack. 1. Resume the context that is now
on the top of the execution context stack as the running execution
context. 1. If result is an abrupt completion, then 1. Return ?
result. 1. Else, 1. Assert: capability is a PromiseCapability
Record. 1. Perform AsyncBlockStart(capability,
module.[[ECMAScriptCode]], moduleContext). 1. Return ~unused~.

GetImportedModule ( referrer: a Cyclic Module Record, specifier: a String, ): a Module Record
-----------------------------------------------------------------------------------------------------

description

1. Assert: Exactly one element of referrer.[[LoadedModules]] is a
Record whose [[Specifier]] is specifier, since LoadRequestedModules
has completed successfully on referrer prior to invoking this
abstract operation. 1. Let record be the Record in
referrer.[[LoadedModules]] whose [[Specifier]] is specifier. 1.
Return record.[[Module]].

HostLoadImportedModule ( referrer: a Script Record, a Cyclic Module Record, or a Realm Record, specifier: a String, hostDefined: anything, payload: a GraphLoadingState Record or a PromiseCapability Record, ): ~unused~
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description

An example of when referrer can be a Realm Record is in a web
browser host. There, if a user clicks on a control given by

.. code:: html

   <button type="button" onclick="import('./foo.mjs')">Click me</button>

there will be no active script or module at the time the `import()`
expression runs. More generally, this can happen in any situation where
the host pushes execution contexts with `null` ScriptOrModule
components onto the execution context stack.

An implementation of HostLoadImportedModule must conform to the
following requirements:

- The host environment must perform
  FinishLoadingImportedModule(referrer, specifier, payload,
  result), where result is either a normal completion containing
  the loaded Module Record or a throw completion, either synchronously
  or asynchronously.
- If this operation is called multiple times with the same
  (referrer, specifier) pair and it performs
  FinishLoadingImportedModule(referrer, specifier, payload,
  result) where result is a normal completion, then it must
  perform FinishLoadingImportedModule(referrer, specifier,
  payload, result) with the same result each time.
- The operation must treat payload as an opaque value to be passed
  through to FinishLoadingImportedModule.

The actual process performed is host-defined, but typically consists of
performing whatever I/O operations are necessary to load the appropriate
Module Record. Multiple different (referrer, specifier) pairs
may map to the same Module Record instance. The actual mapping semantics
is host-defined but typically a normalization process is applied to
specifier as part of the mapping process. A typical normalization
process would include actions such as expansion of relative and
abbreviated path specifiers.

FinishLoadingImportedModule ( referrer: a Script Record, a Cyclic Module Record, or a Realm Record, specifier: a String, payload: a GraphLoadingState Record or a PromiseCapability Record, result
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description

1. If result is a normal completion, then 1. If
referrer.[[LoadedModules]] contains a Record whose [[Specifier]] is
specifier, then 1. Assert: That Record's [[Module]] is
result.[[Value]]. 1. Else, 1. Append the Record { [[Specifier]]:
specifier, [[Module]]: result.[[Value]] } to
referrer.[[LoadedModules]]. 1. If payload is a GraphLoadingState
Record, then 1. Perform ContinueModuleLoading(payload, result).
1. Else, 1. Perform ContinueDynamicImport(payload, result). 1.
Return ~unused~.

GetModuleNamespace ( module: an instance of a concrete subclass of Module Record, ): a Module Namespace Object or ~empty~
-----------------------------------------------------------------------------------------------------------------------------

description
   It retrieves the Module Namespace Object representing module's
   exports, lazily creating it the first time it was requested, and
   storing it in module.[[Namespace]] for future retrieval.

1. Assert: If module is a Cyclic Module Record, then
module.[[Status]] is not ~new~ or ~unlinked~. 1. Let namespace
be module.[[Namespace]]. 1. If namespace is ~empty~, then 1. Let
exportedNames be module.GetExportedNames(). 1. Let
unambiguousNames be a new empty List. 1. For each element name
of exportedNames, do 1. Let resolution be
module.ResolveExport(name). 1. If resolution is a
ResolvedBinding Record, append name to unambiguousNames. 1. Set
namespace to ModuleNamespaceCreate(module,
unambiguousNames). 1. Return namespace.

GetModuleNamespace never throws. Instead, unresolvable names are simply
excluded from the namespace at this point. They will lead to a real
linking error later unless they are all ambiguous star exports that are
not explicitly requested anywhere.



Runtime Semantics: Evaluation
-----------------------------

Module : [empty] 1. Return `undefined`. ModuleBody : ModuleItemList 1.
Let result be Completion(Evaluation of `ModuleItemList`). 1. If
result is a normal completion and result.[[Value]] is ~empty~,
then 1. Return `undefined`. 1. Return ? result. ModuleItemList :
ModuleItemList ModuleItem 1. Let sl be ? Evaluation of
`ModuleItemList`. 1. Let s be Completion(Evaluation of
`ModuleItem`). 1. Return ? UpdateEmpty(s, sl).

The value of a `ModuleItemList` is the value of the last
value-producing item in the `ModuleItemList`.

ModuleItem : ImportDeclaration 1. Return ~empty~.

Imports
-------


**Syntax**


ImportDeclaration : `import` ImportClause FromClause `;` `import`
ModuleSpecifier `;` ImportClause : ImportedDefaultBinding
NameSpaceImport NamedImports ImportedDefaultBinding `,`
NameSpaceImport ImportedDefaultBinding `,` NamedImports
ImportedDefaultBinding : ImportedBinding NameSpaceImport : `*` `as`
ImportedBinding NamedImports : `{` `}` `{` ImportsList `}` `{`
ImportsList `,` `}` FromClause : `from` ModuleSpecifier
ImportsList : ImportSpecifier ImportsList `,` ImportSpecifier
ImportSpecifier : ImportedBinding ModuleExportName `as`
ImportedBinding ModuleSpecifier : StringLiteral ImportedBinding :
BindingIdentifier[~Yield, +Await]


Static Semantics: Early Errors
------------------------------

ModuleItem : ImportDeclaration

- It is a Syntax Error if the BoundNames of `ImportDeclaration`
  contains any duplicate entries.

Static Semantics: ImportEntries ( ): a List of ImportEntry Records
------------------------------------------------------------------

Module : [empty] 1. Return a new empty List. ModuleItemList :
ModuleItemList ModuleItem 1. Let entries1 be the ImportEntries of
`ModuleItemList`. 1. Let entries2 be the ImportEntries of
`ModuleItem`. 1. Return the list-concatenation of entries1 and
entries2. ModuleItem : ExportDeclaration StatementListItem 1. Return
a new empty List. ImportDeclaration : `import` ImportClause FromClause
`;` 1. Let module be the sole element of the ModuleRequests of
`FromClause`. 1. Return the ImportEntriesForModule of `ImportClause`
with argument module. ImportDeclaration : `import` ModuleSpecifier
`;` 1. Return a new empty List.

Static Semantics: ImportEntriesForModule ( module: a String, ): a List of ImportEntry Records
-------------------------------------------------------------------------------------------------

ImportClause : ImportedDefaultBinding `,` NameSpaceImport 1. Let
entries1 be the ImportEntriesForModule of `ImportedDefaultBinding`
with argument module. 1. Let entries2 be the
ImportEntriesForModule of `NameSpaceImport` with argument module.
1. Return the list-concatenation of entries1 and entries2.
ImportClause : ImportedDefaultBinding `,` NamedImports 1. Let
entries1 be the ImportEntriesForModule of `ImportedDefaultBinding`
with argument module. 1. Let entries2 be the
ImportEntriesForModule of `NamedImports` with argument module. 1.
Return the list-concatenation of entries1 and entries2.
ImportedDefaultBinding : ImportedBinding 1. Let localName be the
sole element of the BoundNames of `ImportedBinding`. 1. Let
defaultEntry be the ImportEntry Record { [[ModuleRequest]]:
module, [[ImportName]]: `"default"`, [[LocalName]]: localName
}. 1. Return « defaultEntry ». NameSpaceImport : `*` `as`
ImportedBinding 1. Let localName be the StringValue of
`ImportedBinding`. 1. Let entry be the ImportEntry Record {
[[ModuleRequest]]: module, [[ImportName]]: ~namespace-object~,
[[LocalName]]: localName }. 1. Return « entry ». NamedImports :
`{` `}` 1. Return a new empty List. ImportsList : ImportsList `,`
ImportSpecifier 1. Let specs1 be the ImportEntriesForModule of
`ImportsList` with argument module. 1. Let specs2 be the
ImportEntriesForModule of `ImportSpecifier` with argument module.
1. Return the list-concatenation of specs1 and specs2.
ImportSpecifier : ImportedBinding 1. Let localName be the sole
element of the BoundNames of `ImportedBinding`. 1. Let entry be
the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]:
localName, [[LocalName]]: localName }. 1. Return « entry ».
ImportSpecifier : ModuleExportName `as` ImportedBinding 1. Let
importName be the StringValue of `ModuleExportName`. 1. Let
localName be the StringValue of `ImportedBinding`. 1. Let
entry be the ImportEntry Record { [[ModuleRequest]]: module,
[[ImportName]]: importName, [[LocalName]]: localName }. 1.
Return « entry ».

Exports
-------


**Syntax**


ExportDeclaration : `export` ExportFromClause FromClause `;`
`export` NamedExports `;` `export` VariableStatement[~Yield,
+Await] `export` Declaration[~Yield, +Await] `export` `default`
HoistableDeclaration[~Yield, +Await, +Default] `export` `default`
ClassDeclaration[~Yield, +Await, +Default] `export` `default`
[lookahead ∉ { `function`, `async` [no LineTerminator here]
`function`, `class` }] AssignmentExpression[+In, ~Yield, +Await]
`;` ExportFromClause : `*` `*` `as` ModuleExportName
NamedExports NamedExports : `{` `}` `{` ExportsList `}` `{`
ExportsList `,` `}` ExportsList : ExportSpecifier ExportsList `,`
ExportSpecifier ExportSpecifier : ModuleExportName ModuleExportName
`as` ModuleExportName


Static Semantics: Early Errors
------------------------------

ExportDeclaration : `export` NamedExports `;`

- It is a Syntax Error if the ReferencedBindings of `NamedExports`
  contains any \|StringLiteral|s.
- For each `IdentifierName` n in the ReferencedBindings of
  `NamedExports`: It is a Syntax Error if the StringValue of n is
  a `ReservedWord` or the StringValue of n is one of
  `"implements"`, `"interface"`, `"let"`, `"package"`,
  `"private"`, `"protected"`, `"public"`, or `"static"`.

The above rule means that each ReferencedBindings of `NamedExports` is
treated as an `IdentifierReference`.

Static Semantics: ExportedBindings ( ): a List of Strings
---------------------------------------------------------

ExportedBindings are the locally bound names that are explicitly
associated with a `Module`'s ExportedNames.

ModuleItemList : ModuleItemList ModuleItem 1. Let names1 be the
ExportedBindings of `ModuleItemList`. 1. Let names2 be the
ExportedBindings of `ModuleItem`. 1. Return the list-concatenation of
names1 and names2. ModuleItem : ImportDeclaration
StatementListItem 1. Return a new empty List. ExportDeclaration :
`export` ExportFromClause FromClause `;` 1. Return a new empty List.
ExportDeclaration : `export` NamedExports `;` 1. Return the
ExportedBindings of `NamedExports`. ExportDeclaration : `export`
VariableStatement 1. Return the BoundNames of `VariableStatement`.
ExportDeclaration : `export` Declaration 1. Return the BoundNames of
`Declaration`. ExportDeclaration : `export` `default`
HoistableDeclaration `export` `default` ClassDeclaration `export`
`default` AssignmentExpression `;` 1. Return the BoundNames of this
`ExportDeclaration`. NamedExports : `{` `}` 1. Return a new empty
List. ExportsList : ExportsList `,` ExportSpecifier 1. Let names1
be the ExportedBindings of `ExportsList`. 1. Let names2 be the
ExportedBindings of `ExportSpecifier`. 1. Return the
list-concatenation of names1 and names2. ExportSpecifier :
ModuleExportName 1. Return a List whose sole element is the StringValue
of `ModuleExportName`. ExportSpecifier : ModuleExportName `as`
ModuleExportName 1. Return a List whose sole element is the StringValue
of the first `ModuleExportName`.

Static Semantics: ExportedNames ( ): a List of Strings
------------------------------------------------------

ExportedNames are the externally visible names that a `Module`
explicitly maps to one of its local name bindings.

ModuleItemList : ModuleItemList ModuleItem 1. Let names1 be the
ExportedNames of `ModuleItemList`. 1. Let names2 be the
ExportedNames of `ModuleItem`. 1. Return the list-concatenation of
names1 and names2. ModuleItem : ExportDeclaration 1. Return the
ExportedNames of `ExportDeclaration`. ModuleItem : ImportDeclaration
StatementListItem 1. Return a new empty List. ExportDeclaration :
`export` ExportFromClause FromClause `;` 1. Return the ExportedNames
of `ExportFromClause`. ExportFromClause : `*` 1. Return a new empty
List. ExportFromClause : `*` `as` ModuleExportName 1. Return a List
whose sole element is the StringValue of `ModuleExportName`.
ExportFromClause : NamedExports 1. Return the ExportedNames of
`NamedExports`. ExportDeclaration : `export` VariableStatement 1.
Return the BoundNames of `VariableStatement`. ExportDeclaration :
`export` Declaration 1. Return the BoundNames of `Declaration`.
ExportDeclaration : `export` `default` HoistableDeclaration
`export` `default` ClassDeclaration `export` `default`
AssignmentExpression `;` 1. Return « `"default"` ». NamedExports :
`{` `}` 1. Return a new empty List. ExportsList : ExportsList `,`
ExportSpecifier 1. Let names1 be the ExportedNames of
`ExportsList`. 1. Let names2 be the ExportedNames of
`ExportSpecifier`. 1. Return the list-concatenation of names1 and
names2. ExportSpecifier : ModuleExportName 1. Return a List whose
sole element is the StringValue of `ModuleExportName`. ExportSpecifier
: ModuleExportName `as` ModuleExportName 1. Return a List whose sole
element is the StringValue of the second `ModuleExportName`.

Static Semantics: ExportEntries ( ): a List of ExportEntry Records
------------------------------------------------------------------

Module : [empty] 1. Return a new empty List. ModuleItemList :
ModuleItemList ModuleItem 1. Let entries1 be the ExportEntries of
`ModuleItemList`. 1. Let entries2 be the ExportEntries of
`ModuleItem`. 1. Return the list-concatenation of entries1 and
entries2. ModuleItem : ImportDeclaration StatementListItem 1. Return
a new empty List. ExportDeclaration : `export` ExportFromClause
FromClause `;` 1. Let module be the sole element of the
ModuleRequests of `FromClause`. 1. Return the ExportEntriesForModule
of `ExportFromClause` with argument module. ExportDeclaration :
`export` NamedExports `;` 1. Return the ExportEntriesForModule of
`NamedExports` with argument `null`. ExportDeclaration : `export`
VariableStatement 1. Let entries be a new empty List. 1. Let
names be the BoundNames of `VariableStatement`. 1. For each
element name of names, do 1. Append the ExportEntry Record {
[[ModuleRequest]]: `null`, [[ImportName]]: `null`, [[LocalName]]:
name, [[ExportName]]: name } to entries. 1. Return
entries. ExportDeclaration : `export` Declaration 1. Let
entries be a new empty List. 1. Let names be the BoundNames of
`Declaration`. 1. For each element name of names, do 1. Append
the ExportEntry Record { [[ModuleRequest]]: `null`, [[ImportName]]:
`null`, [[LocalName]]: name, [[ExportName]]: name } to
entries. 1. Return entries. ExportDeclaration : `export`
`default` HoistableDeclaration 1. Let names be the BoundNames of
`HoistableDeclaration`. 1. Let localName be the sole element of
names. 1. Return a List whose sole element is a new ExportEntry
Record { [[ModuleRequest]]: `null`, [[ImportName]]: `null`,
[[LocalName]]: localName, [[ExportName]]: `"default"` }.
ExportDeclaration : `export` `default` ClassDeclaration 1. Let
names be the BoundNames of `ClassDeclaration`. 1. Let
localName be the sole element of names. 1. Return a List whose
sole element is a new ExportEntry Record { [[ModuleRequest]]: `null`,
[[ImportName]]: `null`, [[LocalName]]: localName, [[ExportName]]:
`"default"` }. ExportDeclaration : `export` `default`
AssignmentExpression `;` 1. Let entry be the ExportEntry Record {
[[ModuleRequest]]: `null`, [[ImportName]]: `null`, [[LocalName]]:
`"\`default\\`"`, [[ExportName]]: `"default"` }. 1. Return «
entry ».

`"\`default\\`"` is used within this specification as a synthetic
name for anonymous default export values. See this note for more
details.

Static Semantics: ExportEntriesForModule ( module: a String or `null`, ): a List of ExportEntry Records
-------------------------------------------------------------------------------------------------------------

ExportFromClause : `*` 1. Let entry be the ExportEntry Record {
[[ModuleRequest]]: module, [[ImportName]]: ~all-but-default~,
[[LocalName]]: `null`, [[ExportName]]: `null` }. 1. Return «
entry ». ExportFromClause : `*` `as` ModuleExportName 1. Let
exportName be the StringValue of `ModuleExportName`. 1. Let
entry be the ExportEntry Record { [[ModuleRequest]]: module,
[[ImportName]]: ~all~, [[LocalName]]: `null`, [[ExportName]]:
exportName }. 1. Return « entry ». NamedExports : `{` `}` 1.
Return a new empty List. ExportsList : ExportsList `,` ExportSpecifier
1. Let specs1 be the ExportEntriesForModule of `ExportsList` with
argument module. 1. Let specs2 be the ExportEntriesForModule of
`ExportSpecifier` with argument module. 1. Return the
list-concatenation of specs1 and specs2. ExportSpecifier :
ModuleExportName 1. Let sourceName be the StringValue of
`ModuleExportName`. 1. If module is `null`, then 1. Let
localName be sourceName. 1. Let importName be `null`. 1.
Else, 1. Let localName be `null`. 1. Let importName be
sourceName. 1. Return a List whose sole element is a new ExportEntry
Record { [[ModuleRequest]]: module, [[ImportName]]: importName,
[[LocalName]]: localName, [[ExportName]]: sourceName }.
ExportSpecifier : ModuleExportName `as` ModuleExportName 1. Let
sourceName be the StringValue of the first `ModuleExportName`. 1.
Let exportName be the StringValue of the second
`ModuleExportName`. 1. If module is `null`, then 1. Let
localName be sourceName. 1. Let importName be `null`. 1.
Else, 1. Let localName be `null`. 1. Let importName be
sourceName. 1. Return a List whose sole element is a new ExportEntry
Record { [[ModuleRequest]]: module, [[ImportName]]: importName,
[[LocalName]]: localName, [[ExportName]]: exportName }.

Static Semantics: ReferencedBindings ( ): a List of Parse Nodes
---------------------------------------------------------------

NamedExports : `{` `}` 1. Return a new empty List. ExportsList :
ExportsList `,` ExportSpecifier 1. Let names1 be the
ReferencedBindings of `ExportsList`. 1. Let names2 be the
ReferencedBindings of `ExportSpecifier`. 1. Return the
list-concatenation of names1 and names2. ExportSpecifier :
ModuleExportName `as` ModuleExportName 1. Return the
ReferencedBindings of the first `ModuleExportName`. ModuleExportName :
IdentifierName 1. Return a List whose sole element is the
`IdentifierName`. ModuleExportName : StringLiteral 1. Return a List
whose sole element is the `StringLiteral`.



Runtime Semantics: Evaluation
-----------------------------

ExportDeclaration : `export` ExportFromClause FromClause `;`
`export` NamedExports `;` 1. Return ~empty~. ExportDeclaration :
`export` VariableStatement 1. Return ? Evaluation of
`VariableStatement`. ExportDeclaration : `export` Declaration 1.
Return ? Evaluation of `Declaration`. ExportDeclaration : `export`
`default` HoistableDeclaration 1. Return ? Evaluation of
`HoistableDeclaration`. ExportDeclaration : `export` `default`
ClassDeclaration 1. Let value be ? BindingClassDeclarationEvaluation
of `ClassDeclaration`. 1. Let className be the sole element of the
BoundNames of `ClassDeclaration`. 1. If className is
`"\`default\\`"`, then 1. Let env be the running execution
context's LexicalEnvironment. 1. Perform ?
InitializeBoundName(`"\`default\\`"`, value, env). 1. Return
~empty~. ExportDeclaration : `export` `default` AssignmentExpression
`;` 1. If IsAnonymousFunctionDefinition(`AssignmentExpression`) is
`true`, then 1. Let value be ? NamedEvaluation of
`AssignmentExpression` with argument `"default"`. 1. Else, 1. Let
rhs be ? Evaluation of `AssignmentExpression`. 1. Let value be
? GetValue(rhs). 1. Let env be the running execution context's
LexicalEnvironment. 1. Perform ?
InitializeBoundName(`"\`default\\`"`, value, env). 1. Return
~empty~.

17. Error Handling and Language Extensions
==========================================

https://tc39.es/ecma262/multipage/error-handling-and-language-extensions.html

An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An early error is an error
that can be detected and reported prior to the evaluation of any
construct in the `Script` containing the error. The presence of an
early error prevents the evaluation of the construct. An implementation
must report early errors in a `Script` as part of parsing that
`Script` in ParseScript. Early errors in a `Module` are reported at
the point when the `Module` would be evaluated and the `Module` is
never initialized. Early errors in **eval** code are reported at the
time `eval` is called and prevent evaluation of the **eval** code. All
errors that are not early errors are runtime errors.

An implementation must report as an early error any occurrence of a
condition that is listed in a “Static Semantics: Early Errors” subclause
of this specification.

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

- Except as restricted in , a host or implementation may extend
  `Script` syntax, `Module` syntax, and regular expression pattern
  or flag syntax. To permit this, all operations (such as calling
  `eval`, using a regular expression literal, or using the Function or
  RegExp constructor) that are allowed to throw `SyntaxError` are
  permitted to exhibit host-defined behaviour instead of throwing
  `SyntaxError` when they encounter a host-defined extension to the
  script syntax or regular expression pattern or flag syntax.
- Except as restricted in , a host or implementation may provide
  additional types, values, objects, properties, and functions beyond
  those described in this specification. This may cause constructs (such
  as looking up a variable in the global scope) to have host-defined
  behaviour instead of throwing an error (such as `ReferenceError`).

Forbidden Extensions
--------------------

An implementation must not extend this specification in the following
ways:

- ECMAScript function objects defined using syntactic constructors in
  strict mode code must not be created with own properties named
  `"caller"` or `"arguments"`. Such own properties also must not be
  created for function objects defined using an `ArrowFunction`,
  `MethodDefinition`, `GeneratorDeclaration`,
  `GeneratorExpression`, `AsyncGeneratorDeclaration`,
  `AsyncGeneratorExpression`, `ClassDeclaration`,
  `ClassExpression`, `AsyncFunctionDeclaration`,
  `AsyncFunctionExpression`, or `AsyncArrowFunction` regardless of
  whether the definition is contained in strict mode code. Built-in
  functions, strict functions created using the Function constructor,
  generator functions created using the Generator constructor, async
  functions created using the AsyncFunction constructor, and functions
  created using the `bind` method also must not be created with such
  own properties.
- If an implementation extends any function object with an own property
  named `"caller"` the value of that property, as observed using
  [[Get]] or [[GetOwnProperty]], must not be a strict function object.
  If it is an accessor property, the function that is the value of the
  property's [[Get]] attribute must never return a strict function when
  called.
- Neither mapped nor unmapped arguments objects may be created with an
  own property named `"caller"`.
- The behaviour of built-in methods which are specified in ECMA-402,
  such as those named `toLocaleString`, must not be extended except as
  specified in ECMA-402.
- The RegExp pattern grammars in and must not be extended to recognize
  any of the source characters A-Z or a-z as
  \|IdentityEscape[+UnicodeMode]\| when the :sub:`[UnicodeMode]` grammar
  parameter is present.
- The Syntactic Grammar must not be extended in any manner that allows
  the token `:` to immediately follow source text that is matched by
  the `BindingIdentifier` nonterminal symbol.
- When processing strict mode code, an implementation must not relax the
  early error rules of .
- `TemplateEscapeSequence` must not be extended to include
  `LegacyOctalEscapeSequence` or `NonOctalDecimalEscapeSequence` as
  defined in .
- When processing strict mode code, the extensions defined in , , , and
  must not be supported.
- When parsing for the `Module` goal symbol, the lexical grammar
  extensions defined in must not be supported.
- `ImportCall` must not be extended.

18. ECMAScript Standard Built-in Objects
========================================

https://tc39.es/ecma262/multipage/ecmascript-standard-built-in-objects.html

There are certain built-in objects available whenever an ECMAScript
`Script` or `Module` begins execution. One, the global object, is
part of the global environment of the executing program. Others are
accessible as initial properties of the global object or indirectly as
properties of accessible built-in objects.

Unless specified otherwise, a built-in object that is callable as a
function is a built-in function object with the characteristics
described in . Unless specified otherwise, the [[Extensible]] internal
slot of a built-in object initially has the value `true`. Every
built-in function object has a [[Realm]] internal slot whose value is
the Realm Record of the realm for which the object was initially
created.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the `new` operator. For each built-in function, this
specification describes the arguments required by that function and the
properties of that function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a `new` expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a built-in function or constructor is given fewer arguments than the
function is specified to require, the function or constructor shall
behave exactly as if it had been given sufficient additional arguments,
each such argument being the `undefined` value. Such missing arguments
are considered to be “not present” and may be identified in that manner
by specification algorithms. In the description of a particular
function, the terms “`this` value” and “NewTarget” have the meanings
given in .

Unless otherwise specified in the description of a particular function,
if a built-in function or constructor described is given more arguments
than the function is specified to allow, the extra arguments are
evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
`TypeError` exception that is predicated simply on the presence of an
extra argument.

Implementations that add additional capabilities to the set of built-in
functions are encouraged to do so by adding new functions rather than
adding new parameters to existing functions.

Unless otherwise specified every built-in function and every built-in
constructor has the Function prototype object, which is the initial
value of the expression `Function.prototype` (), as the value of its
[[Prototype]] internal slot.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
`Object.prototype` (), as the value of its [[Prototype]] internal
slot, except the Object prototype object itself.

If this specification defines a built-in constructor's behaviour via
algorithm steps, then that is its behaviour for the purposes of both
[[Call]] and [[Construct]]. If such an algorithm needs to distinguish
the two cases, it checks whether NewTarget is `undefined`, which
indicates a [[Call]] invocation.

Built-in function objects that are not identified as constructors do not
implement the [[Construct]] internal method unless otherwise specified
in the description of a particular function.

Built-in function objects that are not constructors do not have a
`"prototype"` property unless otherwise specified in the description
of a particular function.

Each built-in function defined in this specification is created by
calling the CreateBuiltinFunction abstract operation (). The values of
the length and name parameters are the initial values of the
`"length"` and `"name"` properties as discussed below. The values of
the prefix parameter are similarly discussed below.

Every built-in function object, including constructors, has a
`"length"` property whose value is a non-negative integral Number.
Unless otherwise specified, this value is the number of required
parameters shown in the subclause heading for the function description.
Optional parameters and rest parameters are not included in the
parameter count.

For example, the function object that is the initial value of the
`"map"` property of the Array prototype object is described under the
subclause heading «Array.prototype.map (callback [ , thisArg])» which
shows the two named arguments callback and thisArg, the latter being
optional; therefore the value of the `"length"` property of that
function object is `1`\ :sub:`𝔽`.

Unless otherwise specified, the `"length"` property of a built-in
function object has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Every built-in function object, including constructors, has a `"name"`
property whose value is a String. Unless otherwise specified, this value
is the name that is given to the function in this specification.
Functions that are identified as anonymous functions use the empty
String as the value of the `"name"` property. For functions that are
specified as properties of objects, the name value is the property name
string used to access the function. Functions that are specified as get
or set accessor functions of built-in properties have `"get"` or
`"set"` (respectively) passed to the prefix parameter when calling
CreateBuiltinFunction.

The value of the `"name"` property is explicitly specified for each
built-in functions whose property key is a Symbol value. If such an
explicitly specified value starts with the prefix `"get "` or `"set
"` and the function for which it is specified is a get or set accessor
function of a built-in property, the value without the prefix is passed
to the name parameter, and the value `"get"` or `"set"`
(respectively) is passed to the prefix parameter when calling
CreateBuiltinFunction.

Unless otherwise specified, the `"name"` property of a built-in
function object has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Every other data property described in clauses through and in Annex has
the attributes { [[Writable]]: `true`, [[Enumerable]]: `false`,
[[Configurable]]: `true` } unless otherwise specified.

Every accessor property described in clauses through and in Annex has
the attributes { [[Enumerable]]: `false`, [[Configurable]]: `true` }
unless otherwise specified. If only a get accessor function is
described, the set accessor function is the default value,
`undefined`. If only a set accessor is described the get accessor is
the default value, `undefined`.

19. The Global Object
=====================

https://tc39.es/ecma262/multipage/global-object.html
::

   19.1 Value Properties of the Global Object
      19.1.1 globalThis
      19.1.2 Infinity
      19.1.3 NaN
      19.1.4 undefined
   19.2 Function Properties of the Global Object
      19.2.1 eval ( x )
         19.2.1.1 PerformEval ( x, strictCaller, direct )
         19.2.1.2 HostEnsureCanCompileStrings ( calleeRealm, parameterStrings, bodyString, direct )
         19.2.1.3 EvalDeclarationInstantiation ( body, varEnv, lexEnv, privateEnv, strict )
      19.2.2 isFinite ( number )
      19.2.3 isNaN ( number )
      19.2.4 parseFloat ( string )
      19.2.5 parseInt ( string, radix )
      19.2.6 URI Handling Functions
         19.2.6.1 decodeURI ( encodedURI )
         19.2.6.2 decodeURIComponent ( encodedURIComponent )
         19.2.6.3 encodeURI ( uri )
         19.2.6.4 encodeURIComponent ( uriComponent )
         19.2.6.5 Encode ( string, extraUnescaped )
         19.2.6.6 Decode ( string, preserveEscapeSet )
         19.2.6.7 ParseHexOctet ( string, position )
   19.3 Constructor Properties of the Global Object
      19.3.1 AggregateError ( ... )
      19.3.2 Array ( ... )
      19.3.3 ArrayBuffer ( ... )
      19.3.4 BigInt ( ... )
      19.3.5 BigInt64Array ( ... )
      19.3.6 BigUint64Array ( ... )
      19.3.7 Boolean ( ... )
      19.3.8 DataView ( ... )
      19.3.9 Date ( ... )
      19.3.10 Error ( ... )
      19.3.11 EvalError ( ... )
      19.3.12 FinalizationRegistry ( ... )
      19.3.13 Float32Array ( ... )
      19.3.14 Float64Array ( ... )
      19.3.15 Function ( ... )
      19.3.16 Int8Array ( ... )
      19.3.17 Int16Array ( ... )
      19.3.18 Int32Array ( ... )
      19.3.19 Iterator ( ... )
      19.3.20 Map ( ... )
      19.3.21 Number ( ... )
      19.3.22 Object ( ... )
      19.3.23 Promise ( ... )
      19.3.24 Proxy ( ... )
      19.3.25 RangeError ( ... )
      19.3.26 ReferenceError ( ... )
      19.3.27 RegExp ( ... )
      19.3.28 Set ( ... )
      19.3.29 SharedArrayBuffer ( ... )
      19.3.30 String ( ... )
      19.3.31 Symbol ( ... )
      19.3.32 SyntaxError ( ... )
      19.3.33 TypeError ( ... )
      19.3.34 Uint8Array ( ... )
      19.3.35 Uint8ClampedArray ( ... )
      19.3.36 Uint16Array ( ... )
      19.3.37 Uint32Array ( ... )
      19.3.38 URIError ( ... )
      19.3.39 WeakMap ( ... )
      19.3.40 WeakRef ( ... )
      19.3.41 WeakSet ( ... )
   19.4 Other Properties of the Global Object
      19.4.1 Atomics
      19.4.2 JSON
      19.4.3 Math
      19.4.4 Reflect

The global object:

- is created before control enters any execution context.
- does not have a [[Construct]] internal method; it cannot be used as a
  constructor with the `new` operator.
- does not have a [[Call]] internal method; it cannot be invoked as a
  function.
- has a [[Prototype]] internal slot whose value is host-defined.
- may have host-defined properties in addition to the properties defined
  in this specification. This may include a property whose value is the
  global object itself.

Value Properties of the Global Object
-------------------------------------

globalThis
----------

The initial value of the `"globalThis"` property of the global object
in a Realm Record realm is
realm.[[GlobalEnv]].[[GlobalThisValue]].

This property has the attributes { [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

.. _infinity-1:

Infinity
--------

The value of `Infinity` is `+∞`\ :sub:`𝔽` (see ). This property has
the attributes { [[Writable]]: `false`, [[Enumerable]]: `false`,
[[Configurable]]: `false` }.

.. _nan-1:

NaN
---

The value of `NaN` is `NaN` (see ). This property has the attributes
{ [[Writable]]: `false`, [[Enumerable]]: `false`, [[Configurable]]:
`false` }.

undefined
---------

The value of `undefined` is `undefined` (see ). This property has
the attributes { [[Writable]]: `false`, [[Enumerable]]: `false`,
[[Configurable]]: `false` }.

Function Properties of the Global Object
----------------------------------------

eval ( x )
--------------

This function is the %eval% intrinsic object.

It performs the following steps when called:

1. Return ? PerformEval(x, `false`, `false`).

PerformEval ( x, strictCaller: a Boolean, direct: a Boolean, )
--------------------------------------------------------------

1. Assert: If direct is `false`, then strictCaller is also
`false`. 1. If x is not a String, return x. 1. Let
evalRealm be the current Realm Record. 1. NOTE: In the case of a
direct eval, evalRealm is the realm of both the caller of `eval`
and of the `eval` function itself. 1. Perform ?
HostEnsureCanCompileStrings(evalRealm, « », x, direct). 1.
Let inFunction be `false`. 1. Let inMethod be `false`. 1.
Let inDerivedConstructor be `false`. 1. Let
inClassFieldInitializer be `false`. 1. If direct is `true`,
then 1. Let thisEnvRec be GetThisEnvironment(). 1. If thisEnvRec
is a Function Environment Record, then 1. Let F be
thisEnvRec.[[FunctionObject]]. 1. Set inFunction to `true`. 1.
Set inMethod to thisEnvRec.HasSuperBinding(). 1. If
F.[[ConstructorKind]] is ~derived~, set inDerivedConstructor to
`true`. 1. Let classFieldInitializerName be
F.[[ClassFieldInitializerName]]. 1. If classFieldInitializerName
is not ~empty~, set inClassFieldInitializer to `true`. 1. Perform
the following substeps in an implementation-defined order, possibly
interleaving parsing and error detection: 1. Let script be
ParseText(x, `Script`). 1. If script is a List of errors,
throw a `SyntaxError` exception. 1. If script Contains
`ScriptBody` is `false`, return `undefined`. 1. Let body be
the `ScriptBody` of script. 1. If inFunction is `false` and
body Contains `NewTarget`, throw a `SyntaxError` exception. 1.
If inMethod is `false` and body Contains `SuperProperty`,
throw a `SyntaxError` exception. 1. If inDerivedConstructor is
`false` and body Contains `SuperCall`, throw a `SyntaxError`
exception. 1. If inClassFieldInitializer is `true` and
ContainsArguments of body is `true`, throw a `SyntaxError`
exception. 1. If strictCaller is `true`, let strictEval be
`true`. 1. Else, let strictEval be ScriptIsStrict of script.
1. Let runningContext be the running execution context. 1. NOTE: If
direct is `true`, runningContext will be the execution context
that performed the direct eval. If direct is `false`,
runningContext will be the execution context for the invocation of
the `eval` function. 1. If direct is `true`, then 1. Let
lexEnv be NewDeclarativeEnvironment(runningContext's
LexicalEnvironment). 1. Let varEnv be runningContext's
VariableEnvironment. 1. Let privateEnv be runningContext's
PrivateEnvironment. 1. Else, 1. Let lexEnv be
NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]). 1. Let
varEnv be evalRealm.[[GlobalEnv]]. 1. Let privateEnv be
`null`. 1. If strictEval is `true`, set varEnv to
lexEnv. 1. If runningContext is not already suspended, suspend
runningContext. 1. Let evalContext be a new ECMAScript code
execution context. 1. Set evalContext's Function to `null`. 1. Set
evalContext's Realm to evalRealm. 1. Set evalContext's
ScriptOrModule to runningContext's ScriptOrModule. 1. Set
evalContext's VariableEnvironment to varEnv. 1. Set
evalContext's LexicalEnvironment to lexEnv. 1. Set
evalContext's PrivateEnvironment to privateEnv. 1. Push
evalContext onto the execution context stack; evalContext is now
the running execution context. 1. Let result be
Completion(EvalDeclarationInstantiation(body, varEnv,
lexEnv, privateEnv, strictEval)). 1. If result is a
normal completion, then 1. Set result to Completion(Evaluation of
body). 1. If result is a normal completion and
result.[[Value]] is ~empty~, then 1. Set result to
NormalCompletion(`undefined`). 1. Suspend evalContext and remove
it from the execution context stack. 1. Resume the context that is now
on the top of the execution context stack as the running execution
context. 1. Return ? result.

The eval code cannot instantiate variable or function bindings in the
variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict mode
code. Instead such bindings are instantiated in a new
VariableEnvironment that is only accessible to the eval code. Bindings
introduced by `let`, `const`, or `class` declarations are always
instantiated in a new LexicalEnvironment.

HostEnsureCanCompileStrings ( calleeRealm: a Realm Record, parameterStrings: a List of Strings, bodyString: a String, direct: a Boolean, )
------------------------------------------------------------------------------------------------------------------------------------------

description
   It allows host environments to block certain ECMAScript functions
   which allow developers to interpret and evaluate strings as
   ECMAScript code.

parameterStrings represents the strings that, when using one of the
function constructors, will be concatenated together to build the
parameters list. bodyString represents the function body or the
string passed to an `eval` call. direct signifies whether the
evaluation is a direct eval.

The default implementation of HostEnsureCanCompileStrings is to return
NormalCompletion(~unused~).

EvalDeclarationInstantiation ( body: a `ScriptBody` Parse Node, varEnv: an Environment Record, lexEnv: a Declarative Environment Record, privateEnv: a PrivateEnvironment Record or `null`, strict: a Boolean, )
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let varNames be the VarDeclaredNames of body. 1. Let
varDeclarations be the VarScopedDeclarations of body. 1. If
strict is `false`, then 1. If varEnv is a Global Environment
Record, then 1. For each element name of varNames, do 1. If
varEnv.HasLexicalDeclaration(name) is `true`, throw a
`SyntaxError` exception. 1. NOTE: `eval` will not create a global
var declaration that would be shadowed by a global lexical declaration.
1. Let thisEnv be lexEnv. 1. Assert: The following loop will
terminate. 1. Repeat, while thisEnv and varEnv are not the same
Environment Record, 1. If thisEnv is not an Object Environment
Record, then 1. NOTE: The environment of with statements cannot contain
any lexical declaration so it doesn't need to be checked for var/let
hoisting conflicts. 1. For each element name of varNames, do 1.
If ! thisEnv.HasBinding(name) is `true`, then 1.
[id="step-evaldeclarationinstantiation-throw-duplicate-binding"] Throw a
`SyntaxError` exception. 1. NOTE: Annex defines alternate semantics
for the above step. 1. NOTE: A direct eval will not hoist var
declaration over a like-named lexical declaration. 1. Set thisEnv to
thisEnv.[[OuterEnv]]. 1. Let privateIdentifiers be a new empty
List. 1. Let pointer be privateEnv. 1. Repeat, while pointer
is not `null`, 1. For each Private Name binding of
pointer.[[Names]], do 1. If privateIdentifiers does not contain
binding.[[Description]], append binding.[[Description]] to
privateIdentifiers. 1. Set pointer to
pointer.[[OuterPrivateEnvironment]]. 1. If
AllPrivateIdentifiersValid of body with argument
privateIdentifiers is `false`, throw a `SyntaxError` exception.
1. Let functionsToInitialize be a new empty List. 1. Let
declaredFunctionNames be a new empty List. 1. For each element d
of varDeclarations, in reverse List order, do 1. If d is not
either a `VariableDeclaration`, a `ForBinding`, or a
`BindingIdentifier`, then 1. Assert: d is either a
`FunctionDeclaration`, a `GeneratorDeclaration`, an
`AsyncFunctionDeclaration`, or an `AsyncGeneratorDeclaration`. 1.
NOTE: If there are multiple function declarations for the same name, the
last declaration is used. 1. Let fn be the sole element of the
BoundNames of d. 1. If declaredFunctionNames does not contain
fn, then 1. If varEnv is a Global Environment Record, then 1.
Let fnDefinable be ? varEnv.CanDeclareGlobalFunction(fn). 1.
If fnDefinable is `false`, throw a `TypeError` exception. 1.
Append fn to declaredFunctionNames. 1. Insert d as the first
element of functionsToInitialize. 1. Let declaredVarNames be a
new empty List. 1. For each element d of varDeclarations, do 1.
If d is either a `VariableDeclaration`, a `ForBinding`, or a
`BindingIdentifier`, then 1. For each String vn of the BoundNames
of d, do 1. If declaredFunctionNames does not contain vn,
then 1. If varEnv is a Global Environment Record, then 1. Let
vnDefinable be ? varEnv.CanDeclareGlobalVar(vn). 1. If
vnDefinable is `false`, throw a `TypeError` exception. 1. If
declaredVarNames does not contain vn, then 1. Append vn to
declaredVarNames. 1.
[id="step-evaldeclarationinstantiation-web-compat-insertion-point"]
NOTE: Annex adds additional steps at this point. 1.
[id="step-evaldeclarationinstantiation-post-validation"] NOTE: No
abnormal terminations occur after this algorithm step unless varEnv
is a Global Environment Record and the global object is a Proxy exotic
object. 1. Let lexDeclarations be the LexicallyScopedDeclarations of
body. 1. For each element d of lexDeclarations, do 1. NOTE:
Lexically declared names are only instantiated here but not initialized.
1. For each element dn of the BoundNames of d, do 1. If
IsConstantDeclaration of d is `true`, then 1. Perform ?
lexEnv.CreateImmutableBinding(dn, `true`). 1. Else, 1. Perform
? lexEnv.CreateMutableBinding(dn, `false`). 1. For each Parse
Node f of functionsToInitialize, do 1. Let fn be the sole
element of the BoundNames of f. 1. Let fo be
InstantiateFunctionObject of f with arguments lexEnv and
privateEnv. 1. If varEnv is a Global Environment Record, then 1.
Perform ? varEnv.CreateGlobalFunctionBinding(fn, fo,
`true`). 1. Else, 1. Let bindingExists be !
varEnv.HasBinding(fn). 1. If bindingExists is `false`,
then 1. NOTE: The following invocation cannot return an abrupt
completion because of the validation preceding step . 1. Perform !
varEnv.CreateMutableBinding(fn, `true`). 1. Perform !
varEnv.InitializeBinding(fn, fo). 1. Else, 1. Perform !
varEnv.SetMutableBinding(fn, fo, `false`). 1. For each
String vn of declaredVarNames, do 1. If varEnv is a Global
Environment Record, then 1. Perform ?
varEnv.CreateGlobalVarBinding(vn, `true`). 1. Else, 1. Let
bindingExists be ! varEnv.HasBinding(vn). 1. If
bindingExists is `false`, then 1. NOTE: The following invocation
cannot return an abrupt completion because of the validation preceding
step . 1. Perform ! varEnv.CreateMutableBinding(vn, `true`).
1. Perform ! varEnv.InitializeBinding(vn, `undefined`). 1.
Return ~unused~.

An alternative version of this algorithm is described in .

isFinite ( number )
-----------------------

This function is the %isFinite% intrinsic object.

It performs the following steps when called:

1. Let num be ? ToNumber(number). 1. If num is not finite,
return `false`. 1. Otherwise, return `true`.

isNaN ( number )
--------------------

This function is the %isNaN% intrinsic object.

It performs the following steps when called:

1. Let num be ? ToNumber(number). 1. If num is `NaN`,
return `true`. 1. Otherwise, return `false`.

A reliable way for ECMAScript code to test if a value `X` is `NaN`
is an expression of the form `X !== X`. The result will be `true` if
and only if `X` is `NaN`.

parseFloat ( string )
-------------------------

This function produces a Number value dictated by interpretation of the
contents of the string argument as a decimal literal.

It is the %parseFloat% intrinsic object.

It performs the following steps when called:

1. Let inputString be ? ToString(string). 1. Let
trimmedString be ! TrimString(inputString, ~start~). 1. Let
trimmed be StringToCodePoints(trimmedString). 1. Let
trimmedPrefix be the longest prefix of trimmed that satisfies
the syntax of a `StrDecimalLiteral`, which might be trimmed
itself. If there is no such prefix, return `NaN`. 1. Let
parsedNumber be ParseText(trimmedPrefix, `StrDecimalLiteral`).
1. Assert: parsedNumber is a Parse Node. 1. Return the
StringNumericValue of parsedNumber.

This function may interpret only a leading portion of string as a
Number value; it ignores any code units that cannot be interpreted as
part of the notation of a decimal literal, and no indication is given
that any such code units were ignored.

parseInt ( string, radix )
----------------------------------

This function produces an integral Number dictated by interpretation of
the contents of string according to the specified radix. Leading
white space in string is ignored. If radix coerces to 0 (such as
when it is `undefined`), it is assumed to be 10 except when the number
representation begins with `"0x"` or `"0X"`, in which case it is
assumed to be 16. If radix is 16, the number representation may
optionally begin with `"0x"` or `"0X"`.

It is the %parseInt% intrinsic object.

It performs the following steps when called:

1. Let inputString be ? ToString(string). 1. Let S be !
TrimString(inputString, ~start~). 1. Let sign be 1. 1. If S
is not empty and the first code unit of S is the code unit 0x002D
(HYPHEN-MINUS), set sign to -1. 1. If S is not empty and the
first code unit of S is either the code unit 0x002B (PLUS SIGN) or
the code unit 0x002D (HYPHEN-MINUS), set S to the substring of S
from index 1. 1. Let R be ℝ(? ToInt32(radix)). 1. Let
stripPrefix be `true`. 1. If R ≠ 0, then 1. If R < 2 or
R > 36, return `NaN`. 1. If R ≠ 16, set stripPrefix to
`false`. 1. Else, 1. Set R to 10. 1. If stripPrefix is
`true`, then 1. If the length of S is at least 2 and the first two
code units of S are either `"0x"` or `"0X"`, then 1. Set S
to the substring of S from index 2. 1. Set R to 16. 1. If S
contains a code unit that is not a radix-R digit, let end be the
index within S of the first such code unit; otherwise, let end
be the length of S. 1. Let Z be the substring of S from 0 to
end. 1. If Z is empty, return `NaN`. 1. Let mathInt be the
integer value that is represented by Z in radix-R notation,
using the letters **A** through **Z** and **a** through **z** for digits
with values 10 through 35. (However, if R = 10 and Z contains
more than 20 significant digits, every significant digit after the 20th
may be replaced by a 0 digit, at the option of the implementation; and
if R is not one of 2, 4, 8, 10, 16, or 32, then mathInt may be
an implementation-approximated integer representing the integer value
denoted by Z in radix-R notation.) 1. If mathInt = 0, then
1. If sign = -1, return `-0`\ :sub:`𝔽`. 1. Return
`+0`\ :sub:`𝔽`. 1. Return 𝔽(sign × mathInt).

This function may interpret only a leading portion of string as an
integer value; it ignores any code units that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such code units were ignored.

URI Handling Functions
----------------------

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in this section. `encodeURI`
and `decodeURI` are intended to work with complete URIs; they assume
that any reserved characters are intended to have special meaning (e.g.,
as delimiters) and so are not encoded. `encodeURIComponent` and
`decodeURIComponent` are intended to work with the individual
components of a URI; they assume that any reserved characters represent
text and must be encoded to avoid special meaning when the component is
part of a complete URI.

The set of reserved characters is based upon RFC 2396 and does not
reflect changes introduced by the more recent RFC 3986.

Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

decodeURI ( encodedURI )
----------------------------

This function computes a new version of a URI in which each escape
sequence and UTF-8 encoding of the sort that might be introduced by the
`encodeURI` function is replaced with the UTF-16 encoding of the code
point that it represents. Escape sequences that could not have been
introduced by `encodeURI` are not replaced.

It is the %decodeURI% intrinsic object.

It performs the following steps when called:

1. Let uriString be ? ToString(encodedURI). 1. Let
preserveEscapeSet be `";/?:@&=+$,#"`. 1. Return ?
Decode(uriString, preserveEscapeSet).

decodeURIComponent ( encodedURIComponent )
----------------------------------------------

This function computes a new version of a URI in which each escape
sequence and UTF-8 encoding of the sort that might be introduced by the
`encodeURIComponent` function is replaced with the UTF-16 encoding of
the code point that it represents.

It is the %decodeURIComponent% intrinsic object.

It performs the following steps when called:

1. Let componentString be ? ToString(encodedURIComponent). 1.
Let preserveEscapeSet be the empty String. 1. Return ?
Decode(componentString, preserveEscapeSet).

encodeURI ( uri )
---------------------

This function computes a new version of a UTF-16 encoded () URI in which
each instance of certain code points is replaced by one, two, three, or
four escape sequences representing the UTF-8 encoding of the code point.

It is the %encodeURI% intrinsic object.

It performs the following steps when called:

1. Let uriString be ? ToString(uri). 1. Let extraUnescaped
be `";/?:@&=+$,#"`. 1. Return ? Encode(uriString,
extraUnescaped).

encodeURIComponent ( uriComponent )
---------------------------------------

This function computes a new version of a UTF-16 encoded () URI in which
each instance of certain code points is replaced by one, two, three, or
four escape sequences representing the UTF-8 encoding of the code point.

It is the %encodeURIComponent% intrinsic object.

It performs the following steps when called:

1. Let componentString be ? ToString(uriComponent). 1. Let
extraUnescaped be the empty String. 1. Return ?
Encode(componentString, extraUnescaped).

Encode ( string: a String, extraUnescaped: a String, )
------------------------------------------------------

description
   It performs URI encoding and escaping, interpreting string as a
   sequence of UTF-16 encoded code points as described in . If a
   character is identified as unreserved in RFC 2396 or appears in
   extraUnescaped, it is not escaped.

1. Let len be the length of string. 1. Let R be the empty
String. 1. Let alwaysUnescaped be the string-concatenation of the
ASCII word characters and `"-.!~\\`'()"`. 1. Let unescapedSet be
the string-concatenation of alwaysUnescaped and extraUnescaped.
1. Let k be 0. 1. Repeat, while k < len, 1. Let C be the
code unit at index k within string. 1. If unescapedSet
contains C, then 1. Set k to k + 1. 1. Set R to the
string-concatenation of R and C. 1. Else, 1. Let cp be
CodePointAt(string, k). 1. If cp.[[IsUnpairedSurrogate]] is
`true`, throw a `URIError` exception. 1. Set k to k +
cp.[[CodeUnitCount]]. 1. Let Octets be the List of octets
resulting by applying the UTF-8 transformation to cp.[[CodePoint]].
1. For each element octet of Octets, do 1. Let hex be the
String representation of octet, formatted as an uppercase
hexadecimal number. 1. Set R to the string-concatenation of R,
`"%"`, and StringPad(hex, 2, `"0"`, ~start~). 1. Return R.

Because percent-encoding is used to represent individual octets, a
single code point may be expressed as multiple consecutive escape
sequences (one for each of its 8-bit UTF-8 code units).

Decode ( string: a String, preserveEscapeSet: a String, )
---------------------------------------------------------

description
   It performs URI unescaping and decoding, preserving any escape
   sequences that correspond to Basic Latin characters in
   preserveEscapeSet.

1. Let len be the length of string. 1. Let R be the empty
String. 1. Let k be 0. 1. Repeat, while k < len, 1. Let
C be the code unit at index k within string. 1. Let S be
C. 1. If C is the code unit 0x0025 (PERCENT SIGN), then 1. If
k + 3 > len, throw a `URIError` exception. 1. Let escape
be the substring of string from k to k + 3. 1. Let B be
ParseHexOctet(string, k + 1). 1. If B is not an integer,
throw a `URIError` exception. 1. Set k to k + 2. 1. Let n
be the number of leading 1 bits in B. 1. If n = 0, then 1. Let
asciiChar be the code unit whose numeric value is B. 1. If
preserveEscapeSet contains asciiChar, set S to escape.
Otherwise, set S to asciiChar. 1. Else, 1. If n = 1 or n
> 4, throw a `URIError` exception. 1. Let Octets be « B ». 1.
Let j be 1. 1. Repeat, while j < n, 1. Set k to k +
1. 1. If k + 3 > len, throw a `URIError` exception. 1. If the
code unit at index k within string is not the code unit 0x0025
(PERCENT SIGN), throw a `URIError` exception. 1. Let
continuationByte be ParseHexOctet(string, k + 1). 1. If
continuationByte is not an integer, throw a `URIError` exception.
1. Append continuationByte to Octets. 1. Set k to k + 2.
1. Set j to j + 1. 1. Assert: The length of Octets is n.
1. If Octets does not contain a valid UTF-8 encoding of a Unicode
code point, throw a `URIError` exception. 1. Let V be the code
point obtained by applying the UTF-8 transformation to Octets, that
is, from a List of octets into a 21-bit value. 1. Set S to
UTF16EncodeCodePoint(V). 1. Set R to the string-concatenation of
R and S. 1. Set k to k + 1. 1. Return R.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence 0xC0 0x80 must not decode into the code
unit 0x0000. Implementations of the Decode algorithm are required to
throw a `URIError` when encountering such invalid sequences.

ParseHexOctet ( string: a String, position: a non-negative integer, ): either a non-negative integer or a non-empty List of `SyntaxError` objects
-----------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It parses a sequence of two hexadecimal characters at the specified
   position in string into an unsigned 8-bit integer.

1. Let len be the length of string. 1. Assert: position + 2
≤ len. 1. Let hexDigits be the substring of string from
position to position + 2. 1. Let parseResult be
ParseText(hexDigits, \|HexDigits[~Sep]\|). 1. If parseResult is
not a Parse Node, return parseResult. 1. Let n be the MV of
parseResult. 1. Assert: n is in the inclusive interval from 0 to
255. 1. Return n.

Constructor Properties of the Global Object
-------------------------------------------

AggregateError ( . . . )
------------------------

See .

Array ( . . . )
---------------

See .

ArrayBuffer ( . . . )
---------------------

See .

BigInt ( . . . )
----------------

See .

BigInt64Array ( . . . )
-----------------------

See .

BigUint64Array ( . . . )
------------------------

See .

Boolean ( . . . )
-----------------

See .

DataView ( . . . )
------------------

See .

Date ( . . . )
--------------

See .

Error ( . . . )
---------------

See .

EvalError ( . . . )
-------------------

See .

FinalizationRegistry ( . . . )
------------------------------

See .

Float32Array ( . . . )
----------------------

See .

Float64Array ( . . . )
----------------------

See .

Function ( . . . )
------------------

See .

Int8Array ( . . . )
-------------------

See .

Int16Array ( . . . )
--------------------

See .

Int32Array ( . . . )
--------------------

See .

Iterator ( . . . )
------------------

See .

Map ( . . . )
-------------

See .

Number ( . . . )
----------------

See .

Object ( . . . )
----------------

See .

Promise ( . . . )
-----------------

See .

Proxy ( . . . )
---------------

See .

RangeError ( . . . )
--------------------

See .

ReferenceError ( . . . )
------------------------

See .

RegExp ( . . . )
----------------

See .

Set ( . . . )
-------------

See .

SharedArrayBuffer ( . . . )
---------------------------

See .

String ( . . . )
----------------

See .

Symbol ( . . . )
----------------

See .

SyntaxError ( . . . )
---------------------

See .

TypeError ( . . . )
-------------------

See .

Uint8Array ( . . . )
--------------------

See .

Uint8ClampedArray ( . . . )
---------------------------

See .

Uint16Array ( . . . )
---------------------

See .

Uint32Array ( . . . )
---------------------

See .

URIError ( . . . )
------------------

See .

WeakMap ( . . . )
-----------------

See .

WeakRef ( . . . )
-----------------

See .

WeakSet ( . . . )
-----------------

See .

Other Properties of the Global Object
-------------------------------------

Atomics
-------

See .

JSON
----

See .

Math
----

See .

Reflect
-------

See .

20. Fundamental Objects
=======================

https://tc39.es/ecma262/multipage/fundamental-objects.html
::

   20.1 Object Objects
      20.1.1 The Object Constructor
          20.1.1.1 Object ( [ value ] )
      20.1.2 Properties of the Object Constructor
          20.1.2.1 Object.assign ( target, ...sources )
          20.1.2.2 Object.create ( O, Properties )
          20.1.2.3 Object.defineProperties ( O, Properties )
              20.1.2.3.1 ObjectDefineProperties ( O, Properties )
          20.1.2.4 Object.defineProperty ( O, P, Attributes )
          20.1.2.5 Object.entries ( O )
          20.1.2.6 Object.freeze ( O )
          20.1.2.7 Object.fromEntries ( iterable )
          20.1.2.8 Object.getOwnPropertyDescriptor ( O, P )
          20.1.2.9 Object.getOwnPropertyDescriptors ( O )
          20.1.2.10 Object.getOwnPropertyNames ( O )
          20.1.2.11 Object.getOwnPropertySymbols ( O )
              20.1.2.11.1 GetOwnPropertyKeys ( O, type ) 
          20.1.2.12 Object.getPrototypeOf ( O )
          20.1.2.13 Object.groupBy ( items, callback )
          20.1.2.14 Object.hasOwn ( O, P )
          20.1.2.15 Object.is ( value1, value2 )
          20.1.2.16 Object.isExtensible ( O )
          20.1.2.17 Object.isFrozen ( O )
          20.1.2.18 Object.isSealed ( O )
          20.1.2.19 Object.keys ( O )
          20.1.2.20 Object.preventExtensions ( O )
          20.1.2.21 Object.prototype
          20.1.2.22 Object.seal ( O )
          20.1.2.23 Object.setPrototypeOf ( O, proto )
          20.1.2.24 Object.values ( O )
      20.1.3 Properties of the Object Prototype Object
          20.1.3.1 Object.prototype.constructor
          20.1.3.2 Object.prototype.hasOwnProperty ( V )
          20.1.3.3 Object.prototype.isPrototypeOf ( V )
          20.1.3.4 Object.prototype.propertyIsEnumerable ( V )
          20.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
          20.1.3.6 Object.prototype.toString ( )
          20.1.3.7 Object.prototype.valueOf ( )
          20.1.3.8 Object.prototype.__proto__
              20.1.3.8.1 get Object.prototype.__proto__ 
              20.1.3.8.2 set Object.prototype.__proto__ 
          20.1.3.9 Legacy Object.prototype Accessor Methods
              20.1.3.9.1 Object.prototype.__defineGetter__ ( P, getter )
              20.1.3.9.2 Object.prototype.__defineSetter__ ( P, setter )
              20.1.3.9.3 Object.prototype.__lookupGetter__ ( P )
              20.1.3.9.4 Object.prototype.__lookupSetter__ ( P )
      20.1.4 Properties of Object Instances
   20.2 Function Objects
      20.2.1 The Function Constructor
          20.2.1.1 Function ( ...parameterArgs, bodyArg )
              20.2.1.1.1 CreateDynamicFunction ( constructor, newTarget, kind, parameterArgs, bodyArg )
      20.2.2 Properties of the Function Constructor
          20.2.2.1 Function.prototype
      20.2.3 Properties of the Function Prototype Object
          20.2.3.1 Function.prototype.apply ( thisArg, argArray ) 
          20.2.3.2 Function.prototype.bind ( thisArg, ...args ) 
          20.2.3.3 Function.prototype.call ( thisArg, ...args ) 
          20.2.3.4 Function.prototype.constructor
          20.2.3.5 Function.prototype.toString ( )
          20.2.3.6 Function.prototype [ %Symbol.hasInstance% ] ( V )
      20.2.4 Function Instances
          20.2.4.1 length
          20.2.4.2 name
          20.2.4.3 prototype
      20.2.5 HostHasSourceTextAvailable ( func )
   20.3 Boolean Objects
      20.3.1 The Boolean Constructor
          20.3.1.1 Boolean ( value )
      20.3.2 Properties of the Boolean Constructor
          20.3.2.1 Boolean.prototype
      20.3.3 Properties of the Boolean Prototype Object
          20.3.3.1 Boolean.prototype.constructor
          20.3.3.2 Boolean.prototype.toString ( )
          20.3.3.3 Boolean.prototype.valueOf ( )
              20.3.3.3.1 ThisBooleanValue ( value )
      20.3.4 Properties of Boolean Instances
   20.4 Symbol Objects
      20.4.1 The Symbol Constructor
          20.4.1.1 Symbol ( [ description ] )
      20.4.2 Properties of the Symbol Constructor
          20.4.2.1 Symbol.asyncIterator
          20.4.2.2 Symbol.for ( key )
          20.4.2.3 Symbol.hasInstance
          20.4.2.4 Symbol.isConcatSpreadable
          20.4.2.5 Symbol.iterator
          20.4.2.6 Symbol.keyFor ( sym )
          20.4.2.7 Symbol.match
          20.4.2.8 Symbol.matchAll
          20.4.2.9 Symbol.prototype
          20.4.2.10 Symbol.replace
          20.4.2.11 Symbol.search
          20.4.2.12 Symbol.species
          20.4.2.13 Symbol.split
          20.4.2.14 Symbol.toPrimitive
          20.4.2.15 Symbol.toStringTag
          20.4.2.16 Symbol.unscopables
      20.4.3 Properties of the Symbol Prototype Object
          20.4.3.1 Symbol.prototype.constructor
          20.4.3.2 get Symbol.prototype.description
          20.4.3.3 Symbol.prototype.toString ( )
              20.4.3.3.1 SymbolDescriptiveString ( sym ) 
          20.4.3.4 Symbol.prototype.valueOf ( )
              20.4.3.4.1 ThisSymbolValue ( value )
          20.4.3.5 Symbol.prototype [ %Symbol.toPrimitive% ] ( hint )
          20.4.3.6 Symbol.prototype [ %Symbol.toStringTag% ]
      20.4.4 Properties of Symbol Instances
      20.4.5 Abstract Operations for Symbols
          20.4.5.1 KeyForSymbol ( sym )
   20.5 Error Objects
      20.5.1 The Error Constructor
          20.5.1.1 Error ( message [ , options ] )
      20.5.2 Properties of the Error Constructor
          20.5.2.1 Error.prototype
      20.5.3 Properties of the Error Prototype Object
          20.5.3.1 Error.prototype.constructor
          20.5.3.2 Error.prototype.message
          20.5.3.3 Error.prototype.name
          20.5.3.4 Error.prototype.toString ( )
      20.5.4 Properties of Error Instances
      20.5.5 Native Error Types Used in This Standard
          20.5.5.1 EvalError
          20.5.5.2 RangeError
          20.5.5.3 ReferenceError
          20.5.5.4 SyntaxError
          20.5.5.5 TypeError
          20.5.5.6 URIError
      20.5.6 NativeError Object Structure
          20.5.6.1 The NativeError Constructors
              20.5.6.1.1 NativeError ( message [ , options ] )
          20.5.6.2 Properties of the NativeError Constructors
              20.5.6.2.1 NativeError.prototype
          20.5.6.3 Properties of the NativeError Prototype Objects
              20.5.6.3.1 NativeError.prototype.constructor 
              20.5.6.3.2 NativeError.prototype.message
              20.5.6.3.3 NativeError.prototype.name
          20.5.6.4 Properties of NativeError Instances
      20.5.7 AggregateError Objects
          20.5.7.1 The AggregateError Constructor
              20.5.7.1.1 AggregateError ( errors, message [ , options ] )
          20.5.7.2 Properties of the AggregateError Constructor
              20.5.7.2.1 AggregateError.prototype
          20.5.7.3 Properties of the AggregateError Prototype Object
              20.5.7.3.1 AggregateError.prototype.constructor
              20.5.7.3.2 AggregateError.prototype.message
              20.5.7.3.3 AggregateError.prototype.name 
          20.5.7.4 Properties of AggregateError Instances
      20.5.8 Abstract Operations for Error Objects
          20.5.8.1 InstallErrorCause ( O, options )

Object Objects
--------------

The Object Constructor
----------------------

The Object constructor:

- is %Object%.
- is the initial value of the `"Object"` property of the global
  object.
- creates a new ordinary object when called as a constructor.
- performs a type conversion when called as a function rather than as a
  constructor.
- may be used as the value of an `extends` clause of a class
  definition.

Object ( [ value ] )
------------------------

This function performs the following steps when called:

1. If NewTarget is neither `undefined` nor the active function object,
then 1. Return ? OrdinaryCreateFromConstructor(NewTarget,
`"%Object.prototype%"`). 1. If value is either `undefined` or
`null`, return OrdinaryObjectCreate(%Object.prototype%). 1. Return !
ToObject(value).

Properties of the Object Constructor
------------------------------------

The Object constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has a `"length"` property whose value is `1`\ :sub:`𝔽`.
- has the following additional properties:

Object.assign ( target, ..._sources )
-------------------------------------------

This function copies the values of all of the enumerable own properties
from one or more source objects to a target object.

It performs the following steps when called:

1. Let to be ? ToObject(target). 1. If only one argument was
passed, return to. 1. For each element nextSource of
sources, do 1. If nextSource is neither `undefined` nor
`null`, then 1. Let from be ! ToObject(nextSource). 1. Let
keys be ? from.[[OwnPropertyKeys]](). 1. For each element
nextKey of keys, do 1. Let desc be ?
from.[[GetOwnProperty]](nextKey). 1. If desc is not
`undefined` and desc.[[Enumerable]] is `true`, then 1. Let
propValue be ? Get(from, nextKey). 1. Perform ? Set(to,
nextKey, propValue, `true`). 1. Return to.

The `"length"` property of this function is `2`\ :sub:`𝔽`.

Object.create ( O, Properties )
---------------------------------------

This function creates a new object with a specified prototype.

It performs the following steps when called:

1. If O is not an Object and O is not `null`, throw a
`TypeError` exception. 1. Let obj be OrdinaryObjectCreate(O).
1. If Properties is not `undefined`, then 1. Return ?
ObjectDefineProperties(obj, Properties). 1. Return obj.

Object.defineProperties ( O, Properties )
-------------------------------------------------

This function adds own properties and/or updates the attributes of
existing own properties of an object.

It performs the following steps when called:

1. If O is not an Object, throw a `TypeError` exception. 1. Return
? ObjectDefineProperties(O, Properties).

ObjectDefineProperties ( O: an Object, Properties, )
----------------------------------------------------

1. Let props be ? ToObject(Properties). 1. Let keys be ?
props.[[OwnPropertyKeys]](). 1. Let descriptors be a new empty
List. 1. For each element nextKey of keys, do 1. Let
propDesc be ? props.[[GetOwnProperty]](nextKey). 1. If
propDesc is not `undefined` and propDesc.[[Enumerable]] is
`true`, then 1. Let descObj be ? Get(props, nextKey). 1.
Let desc be ? ToPropertyDescriptor(descObj). 1. Append the
Record { [[Key]]: nextKey, [[Descriptor]]: desc } to
descriptors. 1. For each element property of descriptors, do
1. Perform ? DefinePropertyOrThrow(O, property.[[Key]],
property.[[Descriptor]]). 1. Return O.

Object.defineProperty ( O, P, Attributes )
------------------------------------------------------

This function adds an own property and/or updates the attributes of an
existing own property of an object.

It performs the following steps when called:

1. If O is not an Object, throw a `TypeError` exception. 1. Let
key be ? ToPropertyKey(P). 1. Let desc be ?
ToPropertyDescriptor(Attributes). 1. Perform ?
DefinePropertyOrThrow(O, key, desc). 1. Return O.

Object.entries ( O )
------------------------

This function performs the following steps when called:

1. Let obj be ? ToObject(O). 1. Let entryList be ?
EnumerableOwnProperties(obj, ~key+value~). 1. Return
CreateArrayFromList(entryList).

Object.freeze ( O )
-----------------------

This function performs the following steps when called:

1. If O is not an Object, return O. 1. Let status be ?
SetIntegrityLevel(O, ~frozen~). 1. If status is `false`, throw
a `TypeError` exception. 1. Return O.

Object.fromEntries ( iterable )
-----------------------------------

This function performs the following steps when called:

1. Perform ? RequireObjectCoercible(iterable). 1. Let obj be
OrdinaryObjectCreate(%Object.prototype%). 1. Assert: obj is an
extensible ordinary object with no own properties. 1. Let closure be
a new Abstract Closure with parameters (key, value) that
captures obj and performs the following steps when called: 1. Let
propertyKey be ? ToPropertyKey(key). 1. Perform !
CreateDataPropertyOrThrow(obj, propertyKey, value). 1.
Return `undefined`. 1. Let adder be
CreateBuiltinFunction(closure, 2, `""`, « »). 1. Return ?
AddEntriesFromIterable(obj, iterable, adder). The function
created for adder is never directly accessible to ECMAScript code.

Object.getOwnPropertyDescriptor ( O, P )
------------------------------------------------

This function performs the following steps when called:

1. Let obj be ? ToObject(O). 1. Let key be ?
ToPropertyKey(P). 1. Let desc be ?
obj.[[GetOwnProperty]](key). 1. Return
FromPropertyDescriptor(desc).

Object.getOwnPropertyDescriptors ( O )
------------------------------------------

This function performs the following steps when called:

1. Let obj be ? ToObject(O). 1. Let ownKeys be ?
obj.[[OwnPropertyKeys]](). 1. Let descriptors be
OrdinaryObjectCreate(%Object.prototype%). 1. For each element key of
ownKeys, do 1. Let desc be ?
obj.[[GetOwnProperty]](key). 1. Let descriptor be
FromPropertyDescriptor(desc). 1. If descriptor is not
`undefined`, perform ! CreateDataPropertyOrThrow(descriptors,
key, descriptor). 1. Return descriptors.

Object.getOwnPropertyNames ( O )
------------------------------------

This function performs the following steps when called:

1. Return CreateArrayFromList(? GetOwnPropertyKeys(O, ~string~)).

Object.getOwnPropertySymbols ( O )
--------------------------------------

This function performs the following steps when called:

1. Return CreateArrayFromList(? GetOwnPropertyKeys(O, ~symbol~)).

GetOwnPropertyKeys ( O, type: ~string~ or ~symbol~, )
-----------------------------------------------------

1. Let obj be ? ToObject(O). 1. Let keys be ?
obj.[[OwnPropertyKeys]](). 1. Let nameList be a new empty List.
1. For each element nextKey of keys, do 1. If nextKey is a
Symbol and type is ~symbol~, or if nextKey is a String and
type is ~string~, then 1. Append nextKey to nameList. 1.
Return nameList.

Object.getPrototypeOf ( O )
-------------------------------

This function performs the following steps when called:

1. Let obj be ? ToObject(O). 1. Return ?
obj.[[GetPrototypeOf]]().

Object.groupBy ( items, callback )
------------------------------------------

callback should be a function that accepts two arguments.
`groupBy` calls callback once for each element in items, in
ascending order, and constructs a new object. Each value returned by
callback is coerced to a property key. For each such property key,
the result object has a property whose key is that property key and
whose value is an array containing all the elements for which the
callback return value coerced to that key.

callback is called with two arguments: the value of the element and
the index of the element.

The return value of `groupBy` is an object that does not inherit from
%Object.prototype%.

This function performs the following steps when called:

1. Let groups be ? GroupBy(items, callback, ~property~). 1.
Let obj be OrdinaryObjectCreate(`null`). 1. For each Record {
[[Key]], [[Elements]] } g of groups, do 1. Let elements be
CreateArrayFromList(g.[[Elements]]). 1. Perform !
CreateDataPropertyOrThrow(obj, g.[[Key]], elements). 1.
Return obj.

Object.hasOwn ( O, P )
------------------------------

This function performs the following steps when called:

1. Let obj be ? ToObject(O). 1. Let key be ?
ToPropertyKey(P). 1. Return ? HasOwnProperty(obj, key).

Object.is ( value1, value2 )
------------------------------------

This function performs the following steps when called:

1. Return SameValue(value1, value2).

Object.isExtensible ( O )
-----------------------------

This function performs the following steps when called:

1. If O is not an Object, return `false`. 1. Return ?
IsExtensible(O).

Object.isFrozen ( O )
-------------------------

This function performs the following steps when called:

1. If O is not an Object, return `true`. 1. Return ?
TestIntegrityLevel(O, ~frozen~).

Object.isSealed ( O )
-------------------------

This function performs the following steps when called:

1. If O is not an Object, return `true`. 1. Return ?
TestIntegrityLevel(O, ~sealed~).

Object.keys ( O )
---------------------

This function performs the following steps when called:

1. Let obj be ? ToObject(O). 1. Let keyList be ?
EnumerableOwnProperties(obj, ~key~). 1. Return
CreateArrayFromList(keyList).

Object.preventExtensions ( O )
----------------------------------

This function performs the following steps when called:

1. If O is not an Object, return O. 1. Let status be ?
O.[[PreventExtensions]](). 1. If status is `false`, throw a
`TypeError` exception. 1. Return O.

Object.prototype
----------------

The initial value of `Object.prototype` is the Object prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Object.seal ( O )
---------------------

This function performs the following steps when called:

1. If O is not an Object, return O. 1. Let status be ?
SetIntegrityLevel(O, ~sealed~). 1. If status is `false`, throw
a `TypeError` exception. 1. Return O.

Object.setPrototypeOf ( O, proto )
------------------------------------------

This function performs the following steps when called:

1. Set O to ? RequireObjectCoercible(O). 1. If proto is not
an Object and proto is not `null`, throw a `TypeError`
exception. 1. If O is not an Object, return O. 1. Let status
be ? O.[[SetPrototypeOf]](proto). 1. If status is `false`,
throw a `TypeError` exception. 1. Return O.

Object.values ( O )
-----------------------

This function performs the following steps when called:

1. Let obj be ? ToObject(O). 1. Let valueList be ?
EnumerableOwnProperties(obj, ~value~). 1. Return
CreateArrayFromList(valueList).

Properties of the Object Prototype Object
-----------------------------------------

The Object prototype object:

- is %Object.prototype%.
- has an [[Extensible]] internal slot whose value is `true`.
- has the internal methods defined for ordinary objects, except for the
  [[SetPrototypeOf]] method, which is as defined in . (Thus, it is an
  immutable prototype exotic object.)
- has a [[Prototype]] internal slot whose value is `null`.

Object.prototype.constructor
----------------------------

The initial value of `Object.prototype.constructor` is %Object%.

Object.prototype.hasOwnProperty ( V )
-----------------------------------------

This method performs the following steps when called:

1. [id="step-hasownproperty-topropertykey"] Let P be ?
ToPropertyKey(V). 1. [id="step-hasownproperty-toobject"] Let O
be ? ToObject(`this` value). 1. Return ? HasOwnProperty(O, P).

The ordering of steps and is chosen to ensure that any exception that
would have been thrown by step in previous editions of this
specification will continue to be thrown even if the `this` value is
`undefined` or `null`.

Object.prototype.isPrototypeOf ( V )
----------------------------------------

This method performs the following steps when called:

1. [id="step-isprototypeof-check-object"] If V is not an Object,
return `false`. 1. [id="step-isprototypeof-toobject"] Let O be ?
ToObject(`this` value). 1. Repeat, 1. Set V to ?
V.[[GetPrototypeOf]](). 1. If V is `null`, return `false`.
1. If SameValue(O, V) is `true`, return `true`.

The ordering of steps and preserves the behaviour specified by previous
editions of this specification for the case where V is not an object
and the `this` value is `undefined` or `null`.

Object.prototype.propertyIsEnumerable ( V )
-----------------------------------------------

This method performs the following steps when called:

1. [id="step-propertyisenumerable-topropertykey"] Let P be ?
ToPropertyKey(V). 1. [id="step-propertyisenumerable-toobject"] Let
O be ? ToObject(`this` value). 1. Let desc be ?
O.[[GetOwnProperty]](P). 1. If desc is `undefined`, return
`false`. 1. Return desc.[[Enumerable]].

This method does not consider objects in the prototype chain.

The ordering of steps and is chosen to ensure that any exception that
would have been thrown by step in previous editions of this
specification will continue to be thrown even if the `this` value is
`undefined` or `null`.

Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
-------------------------------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Return ? Invoke(O,
`"toString"`).

The optional parameters to this method are not used but are intended to
correspond to the parameter pattern used by ECMA-402 `toLocaleString`
methods. Implementations that do not include ECMA-402 support must not
use those parameter positions for other purposes.

This method provides a generic `toLocaleString` implementation for
objects that have no locale-sensitive `toString` behaviour. `Array`,
`Number`, `Date`, and %TypedArray% provide their own
locale-sensitive `toLocaleString` methods.

ECMA-402 intentionally does not provide an alternative to this default
implementation.

Object.prototype.toString ( )
-----------------------------

This method performs the following steps when called:

1. If the `this` value is `undefined`, return `"[object
Undefined]"`. 1. If the `this` value is `null`, return `"[object
Null]"`. 1. Let O be ! ToObject(`this` value). 1. Let isArray
be ? IsArray(O). 1. If isArray is `true`, let builtinTag
be `"Array"`. 1. Else if O has a [[ParameterMap]] internal slot,
let builtinTag be `"Arguments"`. 1. Else if O has a [[Call]]
internal method, let builtinTag be `"Function"`. 1. Else if O
has an [[ErrorData]] internal slot, let builtinTag be `"Error"`.
1. Else if O has a [[BooleanData]] internal slot, let builtinTag
be `"Boolean"`. 1. Else if O has a [[NumberData]] internal slot,
let builtinTag be `"Number"`. 1. Else if O has a
[[StringData]] internal slot, let builtinTag be `"String"`. 1.
Else if O has a [[DateValue]] internal slot, let builtinTag be
`"Date"`. 1. Else if O has a [[RegExpMatcher]] internal slot, let
builtinTag be `"RegExp"`. 1. Else, let builtinTag be
`"Object"`. 1. Let tag be ? Get(O, %Symbol.toStringTag%). 1.
If tag is not a String, set tag to builtinTag. 1. Return the
string-concatenation of `"[object "`, tag, and `"]"`.

Historically, this method was occasionally used to access the String
value of the [[Class]] internal slot that was used in previous editions
of this specification as a nominal type tag for various built-in
objects. The above definition of `toString` preserves compatibility
for legacy code that uses `toString` as a test for those specific
kinds of built-in objects. It does not provide a reliable type testing
mechanism for other kinds of built-in or program defined objects. In
addition, programs can use %Symbol.toStringTag% in ways that will
invalidate the reliability of such legacy type tests.

Object.prototype.valueOf ( )
----------------------------

This method performs the following steps when called:

1. Return ? ToObject(`this` value).

Object.prototype._proto
-----------------------------

`Object.prototype._proto` is an accessor property with
attributes { [[Enumerable]]: `false`, [[Configurable]]: `true` }.
The [[Get]] and [[Set]] attributes are defined as follows:

get Object.prototype._proto
---------------------------------

The value of the [[Get]] attribute is a built-in function that requires
no arguments. It performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Return ?
O.[[GetPrototypeOf]]().

set Object.prototype._proto
---------------------------------

The value of the [[Set]] attribute is a built-in function that takes an
argument proto. It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. If
proto is not an Object and proto is not `null`, return
`undefined`. 1. If O is not an Object, return `undefined`. 1.
Let status be ? O.[[SetPrototypeOf]](proto). 1. If
status is `false`, throw a `TypeError` exception. 1. Return
`undefined`.

Legacy Object.prototype Accessor Methods
----------------------------------------

Object.prototype._defineGetter ( P, getter )
----------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. If IsCallable(getter)
is `false`, throw a `TypeError` exception. 1. Let desc be
PropertyDescriptor { [[Get]]: getter, [[Enumerable]]: `true`,
[[Configurable]]: `true` }. 1. Let key be ? ToPropertyKey(P).
1. Perform ? DefinePropertyOrThrow(O, key, desc). 1. Return
`undefined`.

Object.prototype._defineSetter ( P, setter )
----------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. If IsCallable(setter)
is `false`, throw a `TypeError` exception. 1. Let desc be
PropertyDescriptor { [[Set]]: setter, [[Enumerable]]: `true`,
[[Configurable]]: `true` }. 1. Let key be ? ToPropertyKey(P).
1. Perform ? DefinePropertyOrThrow(O, key, desc). 1. Return
`undefined`.

Object.prototype._lookupGetter ( P )
----------------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let key be ?
ToPropertyKey(P). 1. Repeat, 1. Let desc be ?
O.[[GetOwnProperty]](key). 1. If desc is not `undefined`,
then 1. If IsAccessorDescriptor(desc) is `true`, return
desc.[[Get]]. 1. Return `undefined`. 1. Set O to ?
O.[[GetPrototypeOf]](). 1. If O is `null`, return
`undefined`.

Object.prototype._lookupSetter ( P )
----------------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let key be ?
ToPropertyKey(P). 1. Repeat, 1. Let desc be ?
O.[[GetOwnProperty]](key). 1. If desc is not `undefined`,
then 1. If IsAccessorDescriptor(desc) is `true`, return
desc.[[Set]]. 1. Return `undefined`. 1. Set O to ?
O.[[GetPrototypeOf]](). 1. If O is `null`, return
`undefined`.

Properties of Object Instances
------------------------------

Object instances have no special properties beyond those inherited from
the Object prototype object.

Function Objects
----------------

The Function Constructor
------------------------

The Function constructor:

- is %Function%.
- is the initial value of the `"Function"` property of the global
  object.
- creates and initializes a new function object when called as a
  function rather than as a constructor. Thus the function call
  `Function(…)` is equivalent to the object creation expression `new
  Function(…)` with the same arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Function behaviour must include a `super` call to the Function
  constructor to create and initialize a subclass instance with the
  internal slots necessary for built-in function behaviour. All
  ECMAScript syntactic forms for defining function objects create
  instances of Function. There is no syntactic means to create instances
  of Function subclasses except for the built-in GeneratorFunction,
  AsyncFunction, and AsyncGeneratorFunction subclasses.

Function ( ..._parameterArgs, bodyArg )
---------------------------------------------

The last argument (if any) specifies the body (executable code) of a
function; any preceding arguments specify formal parameters.

This function performs the following steps when called:

1. Let C be the active function object. 1. If bodyArg is not
present, set bodyArg to the empty String. 1. Return ?
CreateDynamicFunction(C, NewTarget, ~normal~, parameterArgs,
bodyArg).

It is permissible but not necessary to have one argument for each formal
parameter to be specified. For example, all three of the following
expressions produce the same result:

.. code:: javascript

               new Function("a", "b", "c", "return a+b+c")
               new Function("a, b, c", "return a+b+c")
               new Function("a,b", "c", "return a+b+c")
             

CreateDynamicFunction ( constructor: a constructor, newTarget: a constructor or `undefined`, kind: ~normal~, ~generator~, ~async~, or ~async-generator~, parameterArgs: a List of ECMAScript language values, bodyArg, )
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   constructor is the constructor function that is performing this
   action. newTarget is the constructor that `new` was initially
   applied to. parameterArgs and bodyArg reflect the argument
   values that were passed to constructor.

1. If newTarget is `undefined`, set newTarget to
constructor. 1. If kind is ~normal~, then 1. Let prefix be
`"function"`. 1. Let exprSym be the grammar symbol
`FunctionExpression`. 1. Let bodySym be the grammar symbol
\|FunctionBody[~Yield, ~Await]\|. 1. Let parameterSym be the grammar
symbol \|FormalParameters[~Yield, ~Await]\|. 1. Let fallbackProto be
`"%Function.prototype%"`. 1. Else if kind is ~generator~, then 1.
Let prefix be `"function\\`"`. 1. Let exprSym be the grammar
symbol `GeneratorExpression`. 1. Let bodySym be the grammar symbol
`GeneratorBody`. 1. Let parameterSym be the grammar symbol
\|FormalParameters[+Yield, ~Await]\|. 1. Let fallbackProto be
`"%GeneratorFunction.prototype%"`. 1. Else if kind is ~async~,
then 1. Let prefix be `"async function"`. 1. Let exprSym be
the grammar symbol `AsyncFunctionExpression`. 1. Let bodySym be
the grammar symbol `AsyncFunctionBody`. 1. Let parameterSym be the
grammar symbol \|FormalParameters[~Yield, +Await]\|. 1. Let
fallbackProto be `"%AsyncFunction.prototype%"`. 1. Else, 1.
Assert: kind is ~async-generator~. 1. Let prefix be `"async
function\\`"`. 1. Let exprSym be the grammar symbol
`AsyncGeneratorExpression`. 1. Let bodySym be the grammar symbol
`AsyncGeneratorBody`. 1. Let parameterSym be the grammar symbol
\|FormalParameters[+Yield, +Await]\|. 1. Let fallbackProto be
`"%AsyncGeneratorFunction.prototype%"`. 1. Let argCount be the
number of elements in parameterArgs. 1. Let parameterStrings be
a new empty List. 1. For each element arg of parameterArgs, do
1. Append ? ToString(arg) to parameterStrings. 1. Let
bodyString be ? ToString(bodyArg). 1. Let currentRealm be
the current Realm Record. 1. Perform ?
HostEnsureCanCompileStrings(currentRealm, parameterStrings,
bodyString, `false`). 1. Let P be the empty String. 1. If
argCount > 0, then 1. Set P to parameterStrings[0]. 1. Let
k be 1. 1. Repeat, while k < argCount, 1. Let
nextArgString be parameterStrings[k]. 1. Set P to the
string-concatenation of P, `","` (a comma), and nextArgString.
1. Set k to k + 1. 1. Let bodyParseString be the
string-concatenation of 0x000A (LINE FEED), bodyString, and 0x000A
(LINE FEED). 1. Let sourceString be the string-concatenation of
prefix, `" anonymous("`, P, 0x000A (LINE FEED), `") {"`,
bodyParseString, and `"}"`. 1. Let sourceText be
StringToCodePoints(sourceString). 1. Let parameters be
ParseText(P, parameterSym). 1. If parameters is a List of
errors, throw a `SyntaxError` exception. 1. Let body be
ParseText(bodyParseString, bodySym). 1. If body is a List of
errors, throw a `SyntaxError` exception. 1. NOTE: The parameters and
body are parsed separately to ensure that each is valid alone. For
example, `new Function("/`", "`/ ) {")` does not evaluate to a
function. 1. NOTE: If this step is reached, sourceText must have the
syntax of exprSym (although the reverse implication does not hold).
The purpose of the next two steps is to enforce any Early Error rules
which apply to exprSym directly. 1. Let expr be
ParseText(sourceText, exprSym). 1. If expr is a List of
errors, throw a `SyntaxError` exception. 1. Let proto be ?
GetPrototypeFromConstructor(newTarget, fallbackProto). 1. Let
env be currentRealm.[[GlobalEnv]]. 1. Let privateEnv be
`null`. 1. Let F be OrdinaryFunctionCreate(proto,
sourceText, parameters, body, ~non-lexical-this~, env,
privateEnv). 1. Perform SetFunctionName(F, `"anonymous"`). 1.
If kind is ~generator~, then 1. Let prototype be
OrdinaryObjectCreate(%GeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(F, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Else if kind is
~async-generator~, then 1. Let prototype be
OrdinaryObjectCreate(%AsyncGeneratorPrototype%). 1. Perform !
DefinePropertyOrThrow(F, `"prototype"`, PropertyDescriptor {
[[Value]]: prototype, [[Writable]]: `true`, [[Enumerable]]:
`false`, [[Configurable]]: `false` }). 1. Else if kind is
~normal~, then 1. Perform MakeConstructor(F). 1. NOTE: Functions
whose kind is ~async~ are not constructable and do not have a
[[Construct]] internal method or a `"prototype"` property. 1. Return
F.

CreateDynamicFunction defines a `"prototype"` property on any function
it creates whose kind is not ~async~ to provide for the possibility
that the function will be used as a constructor.

Properties of the Function Constructor
--------------------------------------

The Function constructor:

- is itself a built-in function object.
- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has a `"length"` property whose value is `1`\ :sub:`𝔽`.
- has the following properties:

Function.prototype
------------------

The value of `Function.prototype` is the Function prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the Function Prototype Object
-------------------------------------------

The Function prototype object:

- is %Function.prototype%.
- is itself a built-in function object.
- accepts any arguments and returns `undefined` when invoked.
- does not have a [[Construct]] internal method; it cannot be used as a
  constructor with the `new` operator.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- does not have a `"prototype"` property.
- has a `"length"` property whose value is `+0`\ :sub:`𝔽`.
- has a `"name"` property whose value is the empty String.

The Function prototype object is specified to be a function object to
ensure compatibility with ECMAScript code that was created prior to the
ECMAScript 2015 specification.

Function.prototype.apply ( thisArg, argArray )
------------------------------------------------------

This method performs the following steps when called:

1. Let func be the `this` value. 1. If IsCallable(func) is
`false`, throw a `TypeError` exception. 1. If argArray is either
`undefined` or `null`, then 1. Perform PrepareForTailCall(). 1.
Return ? Call(func, thisArg). 1. Let argList be ?
CreateListFromArrayLike(argArray). 1. Perform PrepareForTailCall().
1. [id="step-function-proto-apply-call"] Return ? Call(func,
thisArg, argList).

The thisArg value is passed without modification as the `this`
value. This is a change from Edition 3, where an `undefined` or
`null` thisArg is replaced with the global object and ToObject is
applied to all other values and that result is passed as the `this`
value. Even though the thisArg is passed without modification,
non-strict functions still perform these transformations upon entry to
the function.

If func is either an arrow function or a bound function exotic
object, then the thisArg will be ignored by the function [[Call]] in
step .

Function.prototype.bind ( thisArg, ..._args )
---------------------------------------------------

This method performs the following steps when called:

1. Let Target be the `this` value. 1. If IsCallable(Target) is
`false`, throw a `TypeError` exception. 1. Let F be ?
BoundFunctionCreate(Target, thisArg, args). 1. Let L be
0. 1. Let targetHasLength be ? HasOwnProperty(Target,
`"length"`). 1. If targetHasLength is `true`, then 1. Let
targetLen be ? Get(Target, `"length"`). 1. If targetLen is
a Number, then 1. If targetLen is `+∞`\ :sub:`𝔽`, then 1. Set
L to +∞. 1. Else if targetLen is `-∞`\ :sub:`𝔽`, then 1. Set
L to 0. 1. Else, 1. Let targetLenAsInt be !
ToIntegerOrInfinity(targetLen). 1. Assert: targetLenAsInt is
finite. 1. Let argCount be the number of elements in args. 1.
Set L to max(targetLenAsInt - argCount, 0). 1. Perform
SetFunctionLength(F, L). 1. Let targetName be ?
Get(Target, `"name"`). 1. If targetName is not a String, set
targetName to the empty String. 1. Perform SetFunctionName(F,
targetName, `"bound"`). 1. Return F.

Function objects created using `Function.prototype.bind` are exotic
objects. They also do not have a `"prototype"` property.

If Target is either an arrow function or a bound function exotic
object, then the thisArg passed to this method will not be used by
subsequent calls to F.

Function.prototype.call ( thisArg, ..._args )
---------------------------------------------------

This method performs the following steps when called:

1. Let func be the `this` value. 1. If IsCallable(func) is
`false`, throw a `TypeError` exception. 1. Perform
PrepareForTailCall(). 1. [id="step-function-proto-call-call"] Return ?
Call(func, thisArg, args).

The thisArg value is passed without modification as the `this`
value. This is a change from Edition 3, where an `undefined` or
`null` thisArg is replaced with the global object and ToObject is
applied to all other values and that result is passed as the `this`
value. Even though the thisArg is passed without modification,
non-strict functions still perform these transformations upon entry to
the function.

If func is either an arrow function or a bound function exotic
object, then the thisArg will be ignored by the function [[Call]] in
step .

Function.prototype.constructor
------------------------------

The initial value of `Function.prototype.constructor` is %Function%.

Function.prototype.toString ( )
-------------------------------

This method performs the following steps when called:

1. Let func be the `this` value. 1. If func is an Object,
func has a [[SourceText]] internal slot, func.[[SourceText]] is
a sequence of Unicode code points, and
HostHasSourceTextAvailable(func) is `true`, then 1. Return
CodePointsToString(func.[[SourceText]]). 1. If func is a
built-in function object, return an implementation-defined String source
code representation of func. The representation must have the syntax
of a `NativeFunction`. Additionally, if func has an
[[InitialName]] internal slot and func.[[InitialName]] is a String,
the portion of the returned String that would be matched by
\|NativeFunctionAccessor?\| `PropertyName` must be the value of
func.[[InitialName]]. 1. If func is an Object and
IsCallable(func) is `true`, return an implementation-defined
String source code representation of func. The representation must
have the syntax of a `NativeFunction`. 1. Throw a `TypeError`
exception. NativeFunction : `function` NativeFunctionAccessor?
PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await]
`)` `{` `[` `native` `code` `]` `}` NativeFunctionAccessor
: `get` `set`

Function.prototype [ %Symbol.hasInstance% ] ( V )
-----------------------------------------------------

This method performs the following steps when called:

1. Let F be the `this` value. 1. Return ?
OrdinaryHasInstance(F, V).

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

This is the default implementation of `%Symbol.hasInstance%` that most
functions inherit. `%Symbol.hasInstance%` is called by the
`instanceof` operator to determine whether a value is an instance of a
specific constructor. An expression such as

.. code:: javascript

               v instanceof F
             

evaluates as

.. code:: javascript

               F[%Symbol.hasInstance%](v)
             

A constructor function can control which objects are recognized as its
instances by `instanceof` by exposing a different
`%Symbol.hasInstance%` method on the function.

This property is non-writable and non-configurable to prevent tampering
that could be used to globally expose the target function of a bound
function.

The value of the `"name"` property of this method is
`"[Symbol.hasInstance]"`.

Function Instances
------------------

Every Function instance is an ECMAScript function object and has the
internal slots listed in . Function objects created using the
`Function.prototype.bind` method () have the internal slots listed in
.

Function instances have the following properties:

length
------

The value of the `"length"` property is an integral Number that
indicates the typical number of arguments expected by the function.
However, the language permits the function to be invoked with some other
number of arguments. The behaviour of a function when invoked on a
number of arguments other than the number specified by its `"length"`
property depends on the function. This property has the attributes {
[[Writable]]: `false`, [[Enumerable]]: `false`, [[Configurable]]:
`true` }.

name
----

The value of the `"name"` property is a String that is descriptive of
the function. The name has no semantic significance but is typically a
variable or property name that is used to refer to the function at its
point of definition in ECMAScript source text. This property has the
attributes { [[Writable]]: `false`, [[Enumerable]]: `false`,
[[Configurable]]: `true` }.

Anonymous functions objects that do not have a contextual name
associated with them by this specification use the empty String as the
value of the `"name"` property.

.. _prototype-1:

prototype
---------

Function instances that can be used as a constructor have a
`"prototype"` property. Whenever such a Function instance is created
another ordinary object is also created and is the initial value of the
function's `"prototype"` property. Unless otherwise specified, the
value of the `"prototype"` property is used to initialize the
[[Prototype]] internal slot of the object created when that function is
invoked as a constructor.

This property has the attributes { [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Function objects created using `Function.prototype.bind`, or by
evaluating a `MethodDefinition` (that is not a `GeneratorMethod` or
`AsyncGeneratorMethod`) or an `ArrowFunction` do not have a
`"prototype"` property.

HostHasSourceTextAvailable ( func: a function object, ): a Boolean
----------------------------------------------------------------------

description
   It allows host environments to prevent the source text from being
   provided for func.

An implementation of HostHasSourceTextAvailable must conform to the
following requirements:

- It must be deterministic with respect to its parameters. Each time it
  is called with a specific func as its argument, it must return the
  same result.

The default implementation of HostHasSourceTextAvailable is to return
`true`.

Boolean Objects
---------------

The Boolean Constructor
-----------------------

The Boolean constructor:

- is %Boolean%.
- is the initial value of the `"Boolean"` property of the global
  object.
- creates and initializes a new Boolean object when called as a
  constructor.
- performs a type conversion when called as a function rather than as a
  constructor.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Boolean behaviour must include a `super` call to the Boolean
  constructor to create and initialize the subclass instance with a
  [[BooleanData]] internal slot.

Boolean ( value )
---------------------

This function performs the following steps when called:

1. Let b be ToBoolean(value). 1. If NewTarget is `undefined`,
return b. 1. Let O be ? OrdinaryCreateFromConstructor(NewTarget,
`"%Boolean.prototype%"`, « [[BooleanData]] »). 1. Set
O.[[BooleanData]] to b. 1. Return O.

Properties of the Boolean Constructor
-------------------------------------

The Boolean constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Boolean.prototype
-----------------

The initial value of `Boolean.prototype` is the Boolean prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the Boolean Prototype Object
------------------------------------------

The Boolean prototype object:

- is %Boolean.prototype%.
- is an ordinary object.
- is itself a Boolean object; it has a [[BooleanData]] internal slot
  with the value `false`.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

Boolean.prototype.constructor
-----------------------------

The initial value of `Boolean.prototype.constructor` is %Boolean%.

Boolean.prototype.toString ( )
------------------------------

This method performs the following steps when called:

1. Let b be ? ThisBooleanValue(`this` value). 1. If b is
`true`, return `"true"`; else return `"false"`.

Boolean.prototype.valueOf ( )
-----------------------------

This method performs the following steps when called:

1. Return ? ThisBooleanValue(`this` value).

ThisBooleanValue ( value, )
---------------------------

1. If value is a Boolean, return value. 1. If value is an
Object and value has a [[BooleanData]] internal slot, then 1. Let
b be value.[[BooleanData]]. 1. Assert: b is a Boolean. 1.
Return b. 1. Throw a `TypeError` exception.

Properties of Boolean Instances
-------------------------------

Boolean instances are ordinary objects that inherit properties from the
Boolean prototype object. Boolean instances have a [[BooleanData]]
internal slot. The [[BooleanData]] internal slot is the Boolean value
represented by this Boolean object.

Symbol Objects
--------------

The Symbol Constructor
----------------------

The Symbol constructor:

- is %Symbol%.
- is the initial value of the `"Symbol"` property of the global
  object.
- returns a new Symbol value when called as a function.
- is not intended to be used with the `new` operator.
- is not intended to be subclassed.
- may be used as the value of an `extends` clause of a class
  definition but a `super` call to it will cause an exception.

Symbol ( [ description ] )
------------------------------

This function performs the following steps when called:

1. If NewTarget is not `undefined`, throw a `TypeError` exception.
1. If description is `undefined`, let descString be
`undefined`. 1. Else, let descString be ?
ToString(description). 1. Return a new Symbol whose [[Description]]
is descString.

Properties of the Symbol Constructor
------------------------------------

The Symbol constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Symbol.asyncIterator
--------------------

The initial value of `Symbol.asyncIterator` is the well-known symbol
%Symbol.asyncIterator% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.for ( key )
----------------------

This function performs the following steps when called:

1. Let stringKey be ? ToString(key). 1. For each element e
of the GlobalSymbolRegistry List, do 1. If e.[[Key]] is
stringKey, return e.[[Symbol]]. 1. Assert: GlobalSymbolRegistry
does not currently contain an entry for stringKey. 1. Let
newSymbol be a new Symbol whose [[Description]] is stringKey. 1.
Append the Record { [[Key]]: stringKey, [[Symbol]]: newSymbol }
to the GlobalSymbolRegistry List. 1. Return newSymbol.

The GlobalSymbolRegistry is an append-only List that is globally
available. It is shared by all realms. Prior to the evaluation of any
ECMAScript code, it is initialized as a new empty List. Elements of the
GlobalSymbolRegistry are Records with the structure defined in .

========== ======== ================================================
Field Name Value    Usage
========== ======== ================================================
[[Key]]    a String A string key used to globally identify a Symbol.
[[Symbol]] a Symbol A symbol that can be retrieved from any realm.
========== ======== ================================================

Symbol.hasInstance
------------------

The initial value of `Symbol.hasInstance` is the well-known symbol
%Symbol.hasInstance% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.isConcatSpreadable
-------------------------

The initial value of `Symbol.isConcatSpreadable` is the well-known
symbol %Symbol.isConcatSpreadable% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.iterator
---------------

The initial value of `Symbol.iterator` is the well-known symbol
%Symbol.iterator% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.keyFor ( sym )
-------------------------

This function performs the following steps when called:

1. If sym is not a Symbol, throw a `TypeError` exception. 1.
Return KeyForSymbol(sym).

Symbol.match
------------

The initial value of `Symbol.match` is the well-known symbol
%Symbol.match% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.matchAll
---------------

The initial value of `Symbol.matchAll` is the well-known symbol
%Symbol.matchAll% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.prototype
----------------

The initial value of `Symbol.prototype` is the Symbol prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.replace
--------------

The initial value of `Symbol.replace` is the well-known symbol
%Symbol.replace% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.search
-------------

The initial value of `Symbol.search` is the well-known symbol
%Symbol.search% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.species
--------------

The initial value of `Symbol.species` is the well-known symbol
%Symbol.species% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.split
------------

The initial value of `Symbol.split` is the well-known symbol
%Symbol.split% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.toPrimitive
------------------

The initial value of `Symbol.toPrimitive` is the well-known symbol
%Symbol.toPrimitive% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.toStringTag
------------------

The initial value of `Symbol.toStringTag` is the well-known symbol
%Symbol.toStringTag% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Symbol.unscopables
------------------

The initial value of `Symbol.unscopables` is the well-known symbol
%Symbol.unscopables% ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the Symbol Prototype Object
-----------------------------------------

The Symbol prototype object:

- is %Symbol.prototype%.
- is an ordinary object.
- is not a Symbol instance and does not have a [[SymbolData]] internal
  slot.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

Symbol.prototype.constructor
----------------------------

The initial value of `Symbol.prototype.constructor` is %Symbol%.

get Symbol.prototype.description
--------------------------------

`Symbol.prototype.description` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let s be the `this` value. 1. Let sym be ?
ThisSymbolValue(s). 1. Return sym.[[Description]].

Symbol.prototype.toString ( )
-----------------------------

This method performs the following steps when called:

1. Let sym be ? ThisSymbolValue(`this` value). 1. Return
SymbolDescriptiveString(sym).

SymbolDescriptiveString ( sym: a Symbol, ): a String
--------------------------------------------------------

1. Let desc be sym's [[Description]] value. 1. If desc is
`undefined`, set desc to the empty String. 1. Assert: desc is
a String. 1. Return the string-concatenation of `"Symbol("`, desc,
and `")"`.

Symbol.prototype.valueOf ( )
----------------------------

This method performs the following steps when called:

1. Return ? ThisSymbolValue(`this` value).

ThisSymbolValue ( value, )
--------------------------

1. If value is a Symbol, return value. 1. If value is an
Object and value has a [[SymbolData]] internal slot, then 1. Let
s be value.[[SymbolData]]. 1. Assert: s is a Symbol. 1.
Return s. 1. Throw a `TypeError` exception.

Symbol.prototype [ %Symbol.toPrimitive% ] ( hint )
------------------------------------------------------

This method is called by ECMAScript language operators to convert a
Symbol object to a primitive value.

It performs the following steps when called:

1. Return ? ThisSymbolValue(`this` value).

The argument is ignored.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

The value of the `"name"` property of this method is
`"[Symbol.toPrimitive]"`.

Symbol.prototype [ %Symbol.toStringTag% ]
-----------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Symbol"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of Symbol Instances
------------------------------

Symbol instances are ordinary objects that inherit properties from the
Symbol prototype object. Symbol instances have a [[SymbolData]] internal
slot. The [[SymbolData]] internal slot is the Symbol value represented
by this Symbol object.

Abstract Operations for Symbols
-------------------------------

KeyForSymbol ( sym: a Symbol, ): a String or `undefined`
--------------------------------------------------------------

description
   If sym is in the GlobalSymbolRegistry (see ) the String used to
   register sym will be returned.

1. For each element e of the GlobalSymbolRegistry List, do 1. If
SameValue(e.[[Symbol]], sym) is `true`, return e.[[Key]].
1. Assert: GlobalSymbolRegistry does not currently contain an entry for
sym. 1. Return `undefined`.

Error Objects
-------------

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

When an ECMAScript implementation detects a runtime error, it throws a
new instance of one of the NativeError objects defined in or a new
instance of the AggregateError object defined in .

The Error Constructor
---------------------

The Error constructor:

- is %Error%.
- is the initial value of the `"Error"` property of the global object.
- creates and initializes a new Error object when called as a function
  rather than as a constructor. Thus the function call `Error(…)` is
  equivalent to the object creation expression `new Error(…)` with the
  same arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Error behaviour must include a `super` call to the Error constructor
  to create and initialize subclass instances with an [[ErrorData]]
  internal slot.

Error ( message [ , options ] )
---------------------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, let newTarget be the active
function object; else let newTarget be NewTarget. 1. Let O be ?
OrdinaryCreateFromConstructor(newTarget, `"%Error.prototype%"`, «
[[ErrorData]] »). 1. If message is not `undefined`, then 1. Let
msg be ? ToString(message). 1. Perform
CreateNonEnumerableDataPropertyOrThrow(O, `"message"`, msg).
1. Perform ? InstallErrorCause(O, options). 1. Return O.

Properties of the Error Constructor
-----------------------------------

The Error constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Error.prototype
---------------

The initial value of `Error.prototype` is the Error prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the Error Prototype Object
----------------------------------------

The Error prototype object:

- is %Error.prototype%.
- is an ordinary object.
- is not an Error instance and does not have an [[ErrorData]] internal
  slot.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

Error.prototype.constructor
---------------------------

The initial value of `Error.prototype.constructor` is %Error%.

Error.prototype.message
-----------------------

The initial value of `Error.prototype.message` is the empty String.

Error.prototype.name
--------------------

The initial value of `Error.prototype.name` is `"Error"`.

Error.prototype.toString ( )
----------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. Let name be ? Get(O, `"name"`).
1. If name is `undefined`, set name to `"Error"`; otherwise
set name to ? ToString(name). 1. Let msg be ? Get(O,
`"message"`). 1. If msg is `undefined`, set msg to the empty
String; otherwise set msg to ? ToString(msg). 1. If name is
the empty String, return msg. 1. If msg is the empty String,
return name. 1. Return the string-concatenation of name, the
code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and msg.

Properties of Error Instances
-----------------------------

Error instances are ordinary objects that inherit properties from the
Error prototype object and have an [[ErrorData]] internal slot whose
value is `undefined`. The only specified uses of [[ErrorData]] is to
identify Error, AggregateError, and NativeError instances as Error
objects within `Object.prototype.toString`.

Native Error Types Used in This Standard
----------------------------------------

A new instance of one of the NativeError objects below or of the
AggregateError object is thrown when a runtime error is detected. All
NativeError objects share the same structure, as described in .

EvalError
---------

The EvalError constructor is %EvalError%.

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

RangeError
----------

The RangeError constructor is %RangeError%.

Indicates a value that is not in the set or range of allowable values.

ReferenceError
--------------

The ReferenceError constructor is %ReferenceError%.

Indicate that an invalid reference has been detected.

SyntaxError
-----------

The SyntaxError constructor is %SyntaxError%.

Indicates that a parsing error has occurred.

TypeError
---------

The TypeError constructor is %TypeError%.

TypeError is used to indicate an unsuccessful operation when none of the
other NativeError objects are an appropriate indication of the
failure cause.

URIError
--------

The URIError constructor is %URIError%.

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition.

NativeError Object Structure
--------------------------------

Each of these objects has the structure described below, differing only
in the name used as the constructor name and in the `"name"` property
of the prototype object.

For each error object, references to NativeError in the definition
should be replaced with the appropriate error object name from .

The NativeError Constructors
--------------------------------

Each NativeError constructor:

- creates and initializes a new NativeError object when called as a
  function rather than as a constructor. A call of the object as a
  function is equivalent to calling it as a constructor with the same
  arguments. Thus the function call ``NativeError``\ ``(…)`` is
  equivalent to the object creation expression
  ``new``\ ``NativeError``\ ``(…)`` with the same arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  NativeError behaviour must include a `super` call to the
  NativeError constructor to create and initialize subclass
  instances with an [[ErrorData]] internal slot.

NativeError ( message [ , options ] )
-------------------------------------------------

Each NativeError function performs the following steps when called:

1. If NewTarget is `undefined`, let newTarget be the active
function object; else let newTarget be NewTarget. 1.
[id="step-nativeerror-ordinarycreatefromconstructor"] Let O be ?
OrdinaryCreateFromConstructor(newTarget,
``"%``\ ``NativeError``\ ``.prototype%"``, « [[ErrorData]] »). 1. If
message is not `undefined`, then 1. Let msg be ?
ToString(message). 1. Perform
CreateNonEnumerableDataPropertyOrThrow(O, `"message"`, msg).
1. Perform ? InstallErrorCause(O, options). 1. Return O.

The actual value of the string passed in step is either
`"%EvalError.prototype%"`, `"%RangeError.prototype%"`,
`"%ReferenceError.prototype%"`, `"%SyntaxError.prototype%"`,
`"%TypeError.prototype%"`, or `"%URIError.prototype%"` corresponding
to which NativeError constructor is being defined.

Properties of the NativeError Constructors
----------------------------------------------

Each NativeError constructor:

- has a [[Prototype]] internal slot whose value is %Error%.
- has a `"name"` property whose value is the String value
  "``NativeError``".
- has the following properties:

NativeError.prototype
-------------------------

The initial value of ``NativeError``\ ``.prototype`` is a
NativeError prototype object (). Each NativeError constructor
has a distinct prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the NativeError Prototype Objects
---------------------------------------------------

Each NativeError prototype object:

- is an ordinary object.
- is not an Error instance and does not have an [[ErrorData]] internal
  slot.
- has a [[Prototype]] internal slot whose value is %Error.prototype%.

NativeError.prototype.constructor
-------------------------------------

The initial value of the `"constructor"` property of the prototype for
a given NativeError constructor is the constructor itself.

NativeError.prototype.message
---------------------------------

The initial value of the `"message"` property of the prototype for a
given NativeError constructor is the empty String.

NativeError.prototype.name
------------------------------

The initial value of the `"name"` property of the prototype for a
given NativeError constructor is the String value consisting of the
name of the constructor (the name used instead of NativeError).

Properties of NativeError Instances
---------------------------------------

NativeError instances are ordinary objects that inherit properties
from their NativeError prototype object and have an [[ErrorData]]
internal slot whose value is `undefined`. The only specified use of
[[ErrorData]] is by `Object.prototype.toString` () to identify Error,
AggregateError, or NativeError instances.

AggregateError Objects
----------------------

The AggregateError Constructor
------------------------------

The AggregateError constructor:

- is %AggregateError%.
- is the initial value of the `"AggregateError"` property of the
  global object.
- creates and initializes a new AggregateError object when called as a
  function rather than as a constructor. Thus the function call
  `AggregateError(…)` is equivalent to the object creation expression
  `new AggregateError(…)` with the same arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  AggregateError behaviour must include a `super` call to the
  AggregateError constructor to create and initialize subclass instances
  with an [[ErrorData]] internal slot.

AggregateError ( errors, message [ , options ] )
------------------------------------------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, let newTarget be the active
function object; else let newTarget be NewTarget. 1. Let O be ?
OrdinaryCreateFromConstructor(newTarget,
`"%AggregateError.prototype%"`, « [[ErrorData]] »). 1. If message
is not `undefined`, then 1. Let msg be ? ToString(message). 1.
Perform CreateNonEnumerableDataPropertyOrThrow(O, `"message"`,
msg). 1. Perform ? InstallErrorCause(O, options). 1. Let
errorsList be ? IteratorToList(? GetIterator(errors, ~sync~)).
1. Perform ! DefinePropertyOrThrow(O, `"errors"`,
PropertyDescriptor { [[Configurable]]: `true`, [[Enumerable]]:
`false`, [[Writable]]: `true`, [[Value]]:
CreateArrayFromList(errorsList) }). 1. Return O.

Properties of the AggregateError Constructor
--------------------------------------------

The AggregateError constructor:

- has a [[Prototype]] internal slot whose value is %Error%.
- has the following properties:

AggregateError.prototype
------------------------

The initial value of `AggregateError.prototype` is
%AggregateError.prototype%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the AggregateError Prototype Object
-------------------------------------------------

The AggregateError prototype object:

- is %AggregateError.prototype%.
- is an ordinary object.
- is not an Error instance or an AggregateError instance and does not
  have an [[ErrorData]] internal slot.
- has a [[Prototype]] internal slot whose value is %Error.prototype%.

AggregateError.prototype.constructor
------------------------------------

The initial value of `AggregateError.prototype.constructor` is
%AggregateError%.

AggregateError.prototype.message
--------------------------------

The initial value of `AggregateError.prototype.message` is the empty
String.

AggregateError.prototype.name
-----------------------------

The initial value of `AggregateError.prototype.name` is
`"AggregateError"`.

Properties of AggregateError Instances
--------------------------------------

AggregateError instances are ordinary objects that inherit properties
from their AggregateError prototype object and have an [[ErrorData]]
internal slot whose value is `undefined`. The only specified use of
[[ErrorData]] is by `Object.prototype.toString` () to identify Error,
AggregateError, or NativeError instances.

Abstract Operations for Error Objects
-------------------------------------

InstallErrorCause ( O: an Object, options, )
--------------------------------------------

description
   It is used to create a `"cause"` property on O when a
   `"cause"` property is present on options.

1. If options is an Object and ? HasProperty(options,
`"cause"`) is `true`, then 1. Let cause be ? Get(options,
`"cause"`). 1. Perform CreateNonEnumerableDataPropertyOrThrow(O,
`"cause"`, cause). 1. Return ~unused~.

21. Numbers and Dates
=====================

https://tc39.es/ecma262/multipage/numbers-and-dates.html
::

    21.1 Number Objects
        21.1.1 The Number Constructor
            21.1.1.1 Number ( value )
        21.1.2 Properties of the Number Constructor
          21.1.2.1 Number.EPSILON
            21.1.2.2 Number.isFinite ( number )
            21.1.2.3 Number.isInteger ( number )
            21.1.2.4 Number.isNaN ( number )
            21.1.2.5 Number.isSafeInteger ( number )
          21.1.2.6 Number.MAX_SAFE_INTEGER
          21.1.2.7 Number.MAX_VALUE
          21.1.2.8 Number.MIN_SAFE_INTEGER
          21.1.2.9 Number.MIN_VALUE
          21.1.2.10 Number.NaN
          21.1.2.11 Number.NEGATIVE_INFINITY
            21.1.2.12 Number.parseFloat ( string )
            21.1.2.13 Number.parseInt ( string, radix )
          21.1.2.14 Number.POSITIVE_INFINITY
          21.1.2.15 Number.prototype
        21.1.3 Properties of the Number Prototype Object
          21.1.3.1 Number.prototype.constructor
            21.1.3.2 Number.prototype.toExponential ( fractionDigits )
            21.1.3.3 Number.prototype.toFixed ( fractionDigits )
            21.1.3.4 Number.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
            21.1.3.5 Number.prototype.toPrecision ( precision )
            21.1.3.6 Number.prototype.toString ( [ radix ] )
            21.1.3.7 Number.prototype.valueOf ( )
                21.1.3.7.1 ThisNumberValue ( value )
      21.1.4 Properties of Number Instances
    21.2 BigInt Objects
        21.2.1 The BigInt Constructor
            21.2.1.1 BigInt ( value )
                21.2.1.1.1 NumberToBigInt ( number )
        21.2.2 Properties of the BigInt Constructor
            21.2.2.1 BigInt.asIntN ( bits, bigint )
            21.2.2.2 BigInt.asUintN ( bits, bigint )
          21.2.2.3 BigInt.prototype
        21.2.3 Properties of the BigInt Prototype Object
          21.2.3.1 BigInt.prototype.constructor
            21.2.3.2 BigInt.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
            21.2.3.3 BigInt.prototype.toString ( [ radix ] )
            21.2.3.4 BigInt.prototype.valueOf ( )
                21.2.3.4.1 ThisBigIntValue ( value )
          21.2.3.5 BigInt.prototype [ %Symbol.toStringTag% ]
      21.2.4 Properties of BigInt Instances
    21.3 The Math Object
        21.3.1 Value Properties of the Math Object
          21.3.1.1 Math.E
          21.3.1.2 Math.LN10
          21.3.1.3 Math.LN2
          21.3.1.4 Math.LOG10E
          21.3.1.5 Math.LOG2E
          21.3.1.6 Math.PI
          21.3.1.7 Math.SQRT1_2
          21.3.1.8 Math.SQRT2
          21.3.1.9 Math [ %Symbol.toStringTag% ]
        21.3.2 Function Properties of the Math Object
            21.3.2.1 Math.abs ( x )
            21.3.2.2 Math.acos ( x )
            21.3.2.3 Math.acosh ( x )
            21.3.2.4 Math.asin ( x )
            21.3.2.5 Math.asinh ( x )
            21.3.2.6 Math.atan ( x )
            21.3.2.7 Math.atanh ( x )
            21.3.2.8 Math.atan2 ( y, x )
            21.3.2.9 Math.cbrt ( x )
            21.3.2.10 Math.ceil ( x )
            21.3.2.11 Math.clz32 ( x )
            21.3.2.12 Math.cos ( x )
            21.3.2.13 Math.cosh ( x )
            21.3.2.14 Math.exp ( x )
            21.3.2.15 Math.expm1 ( x )
            21.3.2.16 Math.floor ( x )
            21.3.2.17 Math.fround ( x )
            21.3.2.18 Math.hypot ( ...args )
            21.3.2.19 Math.imul ( x, y )
            21.3.2.20 Math.log ( x )
            21.3.2.21 Math.log1p ( x )
            21.3.2.22 Math.log10 ( x )
            21.3.2.23 Math.log2 ( x )
            21.3.2.24 Math.max ( ...args )
            21.3.2.25 Math.min ( ...args )
            21.3.2.26 Math.pow ( base, exponent )
          21.3.2.27 Math.random ( )
            21.3.2.28 Math.round ( x )
            21.3.2.29 Math.sign ( x )
            21.3.2.30 Math.sin ( x )
            21.3.2.31 Math.sinh ( x )
            21.3.2.32 Math.sqrt ( x )
            21.3.2.33 Math.tan ( x )
            21.3.2.34 Math.tanh ( x )
            21.3.2.35 Math.trunc ( x )
    21.4 Date Objects
        21.4.1 Overview of Date Objects and Definitions of Abstract Operations
          21.4.1.1 Time Values and Time Range
          21.4.1.2 Time-related Constants
            21.4.1.3 Day ( t )
            21.4.1.4 TimeWithinDay ( t )
            21.4.1.5 DaysInYear ( y )
            21.4.1.6 DayFromYear ( y )
            21.4.1.7 TimeFromYear ( y )
            21.4.1.8 YearFromTime ( t )
            21.4.1.9 DayWithinYear ( t )
            21.4.1.10 InLeapYear ( t )
            21.4.1.11 MonthFromTime ( t )
            21.4.1.12 DateFromTime ( t )
            21.4.1.13 WeekDay ( t )
            21.4.1.14 HourFromTime ( t )
            21.4.1.15 MinFromTime ( t )
            21.4.1.16 SecFromTime ( t )
            21.4.1.17 msFromTime ( t )
            21.4.1.18 GetUTCEpochNanoseconds ( year, month , day, hour, minute, second, millisecond, microsecond, nanosecond )
            21.4.1.19 Time Zone Identifiers
            21.4.1.20 GetNamedTimeZoneEpochNanoseconds ( timeZoneIdentifier, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond )
            21.4.1.21 GetNamedTimeZoneOffsetNanoseconds ( timeZoneIdentifier, epochNanoseconds )
          21.4.1.22 Time Zone Identifier Record
          21.4.1.23 AvailableNamedTimeZoneIdentifiers ( )
          21.4.1.24 SystemTimeZoneIdentifier ( )
            21.4.1.25 LocalTime ( t )
            21.4.1.26 UTC ( t )
            21.4.1.27 MakeTime ( hour, min, sec , ms )
            21.4.1.28 MakeDay ( year, month, date )
            21.4.1.29 MakeDate ( day, time )
            21.4.1.30 MakeFullYear ( year )
            21.4.1.31 TimeClip ( time )
            21.4.1.32 Date Time String Format
              21.4.1.32.1 Expanded Years
            21.4.1.33 Time Zone Offset String Format
                21.4.1.33.1 IsTimeZoneOffsetString ( offsetString )
                21.4.1.33.2 ParseTimeZoneOffsetString ( offsetString )
        21.4.2 The Date Constructor
            21.4.2.1 Date ( ...values )
        21.4.3 Properties of the Date Constructor
          21.4.3.1 Date.now ( )
            21.4.3.2 Date.parse ( string )
          21.4.3.3 Date.prototype
            21.4.3.4 Date.UTC ( year [ , month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ] )
        21.4.4 Properties of the Date Prototype Object
          21.4.4.1 Date.prototype.constructor
          21.4.4.2 Date.prototype.getDate ( )
          21.4.4.3 Date.prototype.getDay ( )
          21.4.4.4 Date.prototype.getFullYear ( )
          21.4.4.5 Date.prototype.getHours ( )
          21.4.4.6 Date.prototype.getMilliseconds ( )
          21.4.4.7 Date.prototype.getMinutes ( )
          21.4.4.8 Date.prototype.getMonth ( )
          21.4.4.9 Date.prototype.getSeconds ( )
          21.4.4.10 Date.prototype.getTime ( )
          21.4.4.11 Date.prototype.getTimezoneOffset ( )
          21.4.4.12 Date.prototype.getUTCDate ( )
          21.4.4.13 Date.prototype.getUTCDay ( )
          21.4.4.14 Date.prototype.getUTCFullYear ( )
          21.4.4.15 Date.prototype.getUTCHours ( )
          21.4.4.16 Date.prototype.getUTCMilliseconds ( )
          21.4.4.17 Date.prototype.getUTCMinutes ( )
          21.4.4.18 Date.prototype.getUTCMonth ( )
          21.4.4.19 Date.prototype.getUTCSeconds ( )
            21.4.4.20 Date.prototype.setDate ( date )
            21.4.4.21 Date.prototype.setFullYear ( year [ , month [ , date ] ] )
            21.4.4.22 Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
            21.4.4.23 Date.prototype.setMilliseconds ( ms )
            21.4.4.24 Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
            21.4.4.25 Date.prototype.setMonth ( month [ , date ] )
            21.4.4.26 Date.prototype.setSeconds ( sec [ , ms ] )
            21.4.4.27 Date.prototype.setTime ( time )
            21.4.4.28 Date.prototype.setUTCDate ( date )
            21.4.4.29 Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
            21.4.4.30 Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
            21.4.4.31 Date.prototype.setUTCMilliseconds ( ms )
            21.4.4.32 Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] )
            21.4.4.33 Date.prototype.setUTCMonth ( month [ , date ] )
            21.4.4.34 Date.prototype.setUTCSeconds ( sec [ , ms ] )
          21.4.4.35 Date.prototype.toDateString ( )
          21.4.4.36 Date.prototype.toISOString ( )
            21.4.4.37 Date.prototype.toJSON ( key )
            21.4.4.38 Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )
            21.4.4.39 Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
            21.4.4.40 Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )
            21.4.4.41 Date.prototype.toString ( )
                21.4.4.41.1 TimeString ( tv )
                21.4.4.41.2 DateString ( tv )
                21.4.4.41.3 TimeZoneString ( tv )
                21.4.4.41.4 ToDateString ( tv )
          21.4.4.42 Date.prototype.toTimeString ( )
          21.4.4.43 Date.prototype.toUTCString ( )
          21.4.4.44 Date.prototype.valueOf ( )
            21.4.4.45 Date.prototype [ %Symbol.toPrimitive% ] ( hint )
      21.4.5 Properties of Date Instances


Number Objects
--------------

The Number Constructor
----------------------

The Number constructor:

- is %Number%.
- is the initial value of the `"Number"` property of the global
  object.
- creates and initializes a new Number object when called as a
  constructor.
- performs a type conversion when called as a function rather than as a
  constructor.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Number behaviour must include a `super` call to the Number
  constructor to create and initialize the subclass instance with a
  [[NumberData]] internal slot.

Number ( value )
--------------------

This function performs the following steps when called:

1. If value is present, then 1. Let prim be ?
ToNumeric(value). 1. If prim is a BigInt, let n be
𝔽(ℝ(prim)). 1. Otherwise, let n be prim. 1. Else, 1. Let
n be `+0`\ :sub:`𝔽`. 1. If NewTarget is `undefined`, return
n. 1. Let O be ? OrdinaryCreateFromConstructor(NewTarget,
`"%Number.prototype%"`, « [[NumberData]] »). 1. Set
O.[[NumberData]] to n. 1. Return O.

Properties of the Number Constructor
------------------------------------

The Number constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Number.EPSILON
--------------

The value of `Number.EPSILON` is the Number value for the magnitude of
the difference between 1 and the smallest value greater than 1 that is
representable as a Number value, which is approximately
2.2204460492503130808472633361816 × 10\ :sup:`-16`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.isFinite ( number )
------------------------------

This function performs the following steps when called:

1. If number is not a Number, return `false`. 1. If number is
not finite, return `false`. 1. Otherwise, return `true`.

Number.isInteger ( number )
-------------------------------

This function performs the following steps when called:

1. If number is an integral Number, return `true`. 1. Return
`false`.

Number.isNaN ( number )
---------------------------

This function performs the following steps when called:

1. If number is not a Number, return `false`. 1. If number is
`NaN`, return `true`. 1. Otherwise, return `false`.

This function differs from the global isNaN function () in that it does
not convert its argument to a Number before determining whether it is
`NaN`.

Number.isSafeInteger ( number )
-----------------------------------

An integer n is a "safe integer" if and only if the Number value for
n is not the Number value for any other integer.

This function performs the following steps when called:

1. If number is an integral Number, then 1. If abs(ℝ(number)) ≤
2\ :sup:`53` - 1, return `true`. 1. Return `false`.

Number.MAX_SAFE_INTEGER
-----------------------

Due to rounding behaviour necessitated by precision limitations of IEEE
754-2019, the Number value for every integer greater than
`Number.MAX_SAFE_INTEGER` is shared with at least one other integer.
Such large-magnitude integers are therefore not safe, and are not
guaranteed to be exactly representable as Number values or even to be
distinguishable from each other. For example, both `9007199254740992`
and `9007199254740993` evaluate to the Number value
`9007199254740992`\ :sub:`𝔽`.

The value of `Number.MAX_SAFE_INTEGER` is
`9007199254740991`\ :sub:`𝔽` (𝔽(2\ :sup:`53` - 1)).

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.MAX_VALUE
----------------

The value of `Number.MAX_VALUE` is the largest positive finite value
of the Number type, which is approximately 1.7976931348623157 ×
10\ :sup:`308`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.MIN_SAFE_INTEGER
-----------------------

Due to rounding behaviour necessitated by precision limitations of IEEE
754-2019, the Number value for every integer less than
`Number.MIN_SAFE_INTEGER` is shared with at least one other integer.
Such large-magnitude integers are therefore not safe, and are not
guaranteed to be exactly representable as Number values or even to be
distinguishable from each other. For example, both `-9007199254740992`
and `-9007199254740993` evaluate to the Number value
`-9007199254740992`\ :sub:`𝔽`.

The value of `Number.MIN_SAFE_INTEGER` is
`-9007199254740991`\ :sub:`𝔽` (𝔽(-(2\ :sup:`53` - 1))).

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.MIN_VALUE
----------------

The value of `Number.MIN_VALUE` is the smallest positive value of the
Number type, which is approximately 5 × 10\ :sup:`-324`.

In the IEEE 754-2019 double precision binary representation, the
smallest possible value is a denormalized number. If an implementation
does not support denormalized values, the value of `Number.MIN_VALUE`
must be the smallest non-zero positive value that can actually be
represented by the implementation.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.NaN
----------

The value of `Number.NaN` is `NaN`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.NEGATIVE_INFINITY
------------------------

The value of `Number.NEGATIVE_INFINITY` is `-∞`\ :sub:`𝔽`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.parseFloat ( string )
--------------------------------

The initial value of the `"parseFloat"` property is %parseFloat%.

Number.parseInt ( string, radix )
-----------------------------------------

The initial value of the `"parseInt"` property is %parseInt%.

Number.POSITIVE_INFINITY
------------------------

The value of `Number.POSITIVE_INFINITY` is `+∞`\ :sub:`𝔽`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Number.prototype
----------------

The initial value of `Number.prototype` is the Number prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the Number Prototype Object
-----------------------------------------

The Number prototype object:

- is %Number.prototype%.
- is an ordinary object.
- is itself a Number object; it has a [[NumberData]] internal slot with
  the value `+0`\ :sub:`𝔽`.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the `this` value passed to
them must be either a Number value or an object that has a
[[NumberData]] internal slot that has been initialized to a Number
value.

The phrase “this Number value” within the specification of a method
refers to the result returned by calling the abstract operation
ThisNumberValue with the `this` value of the method invocation passed
as the argument.

Number.prototype.constructor
----------------------------

The initial value of `Number.prototype.constructor` is %Number%.

Number.prototype.toExponential ( fractionDigits )
-----------------------------------------------------

This method returns a String containing this Number value represented in
decimal exponential notation with one digit before the significand's
decimal point and fractionDigits digits after the significand's
decimal point. If fractionDigits is `undefined`, it includes as
many significand digits as necessary to uniquely specify the Number
(just like in ToString except that in this case the Number is always
output in exponential notation).

It performs the following steps when called:

1. Let x be ? ThisNumberValue(`this` value). 1. Let f be ?
ToIntegerOrInfinity(fractionDigits). 1. Assert: If
fractionDigits is `undefined`, then f is 0. 1. If x is not
finite, return Number::toString(x, 10). 1. If f < 0 or f >
100, throw a `RangeError` exception. 1. Set x to ℝ(x). 1. Let
s be the empty String. 1. If x < 0, then 1. Set s to
`"-"`. 1. Set x to -x. 1. If x = 0, then 1. Let m be
the String value consisting of f + 1 occurrences of the code unit
0x0030 (DIGIT ZERO). 1. Let e be 0. 1. Else, 1. If
fractionDigits is not `undefined`, then 1. Let e and n be
integers such that 10\ :sup:`f` ≤ n < 10\ :sup:`f + 1` and
for which n × 10\ :sup:`e - f` - x is as close to zero
as possible. If there are two such sets of e and n, pick the
e and n for which n × 10\ :sup:`e - f` is larger. 1.
Else, 1. [id="step-number-proto-toexponential-intermediate-values"] Let
e, n, and ff be integers such that ff ≥ 0,
10\ :sup:`ff` ≤ n < 10\ :sup:`ff + 1`, 𝔽(n ×
10\ :sup:`e - ff`) is 𝔽(x), and ff is as small as
possible. Note that the decimal representation of n has ff + 1
digits, n is not divisible by 10, and the least significant digit of
n is not necessarily uniquely determined by these criteria. 1. Set
f to ff. 1. Let m be the String value consisting of the
digits of the decimal representation of n (in order, with no leading
zeroes). 1. If f ≠ 0, then 1. Let a be the first code unit of
m. 1. Let b be the other f code units of m. 1. Set m
to the string-concatenation of a, `"."`, and b. 1. If e =
0, then 1. Let c be `"+"`. 1. Let d be `"0"`. 1. Else, 1. If
e > 0, then 1. Let c be `"+"`. 1. Else, 1. Assert: e < 0.
1. Let c be `"-"`. 1. Set e to -e. 1. Let d be the
String value consisting of the digits of the decimal representation of
e (in order, with no leading zeroes). 1. Set m to the
string-concatenation of m, `"e"`, c, and d. 1. Return the
string-concatenation of s and m.

For implementations that provide more accurate conversions than required
by the rules above, it is recommended that the following alternative
version of step be used as a guideline:

1. Let e, n, and f be integers such that f ≥ 0,
10\ :sup:`f` ≤ n < 10\ :sup:`f + 1`, 𝔽(n ×
10\ :sup:`e - f`) is 𝔽(x), and f is as small as
possible. If there are multiple possibilities for n, choose the
value of n for which 𝔽(n × 10\ :sup:`e - f`) is closest
in value to 𝔽(x). If there are two such possible values of n,
choose the one that is even.

Number.prototype.toFixed ( fractionDigits )
-----------------------------------------------

This method returns a String containing this Number value represented in
decimal fixed-point notation with fractionDigits digits after the
decimal point. If fractionDigits is `undefined`, 0 is assumed.

It performs the following steps when called:

1. Let x be ? ThisNumberValue(`this` value). 1. Let f be ?
ToIntegerOrInfinity(fractionDigits). 1. Assert: If
fractionDigits is `undefined`, then f is 0. 1. If f is not
finite, throw a `RangeError` exception. 1. If f < 0 or f >
100, throw a `RangeError` exception. 1. If x is not finite, return
Number::toString(x, 10). 1. Set x to ℝ(x). 1. Let s be
the empty String. 1. If x < 0, then 1. Set s to `"-"`. 1. Set
x to -x. 1. If x ≥ 10\ :sup:`21`, then 1. Let m be !
ToString(𝔽(x)). 1. Else, 1. Let n be an integer for which n
/ 10\ :sup:`f` - x is as close to zero as possible. If there are
two such n, pick the larger n. 1. If n = 0, let m be
`"0"`. Otherwise, let m be the String value consisting of the
digits of the decimal representation of n (in order, with no leading
zeroes). 1. If f ≠ 0, then 1. Let k be the length of m. 1.
If k ≤ f, then 1. Let z be the String value consisting of
f + 1 - k occurrences of the code unit 0x0030 (DIGIT ZERO). 1.
Set m to the string-concatenation of z and m. 1. Set k
to f + 1. 1. Let a be the first k - f code units of
m. 1. Let b be the other f code units of m. 1. Set m
to the string-concatenation of a, `"."`, and b. 1. Return the
string-concatenation of s and m.

The output of `toFixed` may be more precise than `toString` for some
values because toString only prints enough significant digits to
distinguish the number from adjacent Number values. For example,

| `(1000000000000000128).toString()` returns
  `"1000000000000000100"`, while
| `(1000000000000000128).toFixed(0)` returns
  `"1000000000000000128"`.

Number.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
-------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method produces a String value that represents this Number value
formatted according to the conventions of the host environment's current
locale. This method is implementation-defined, and it is permissible,
but not encouraged, for it to return the same thing as `toString`.

The meanings of the optional parameters to this method are defined in
the ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

Number.prototype.toPrecision ( precision )
----------------------------------------------

This method returns a String containing this Number value represented
either in decimal exponential notation with one digit before the
significand's decimal point and precision - 1 digits after the
significand's decimal point or in decimal fixed notation with
precision significant digits. If precision is `undefined`, it
calls ToString instead.

It performs the following steps when called:

1. Let x be ? ThisNumberValue(`this` value). 1. If precision
is `undefined`, return ! ToString(x). 1. Let p be ?
ToIntegerOrInfinity(precision). 1. If x is not finite, return
Number::toString(x, 10). 1. If p < 1 or p > 100, throw a
`RangeError` exception. 1. Set x to ℝ(x). 1. Let s be the
empty String. 1. If x < 0, then 1. Set s to the code unit 0x002D
(HYPHEN-MINUS). 1. Set x to -x. 1. If x = 0, then 1. Let
m be the String value consisting of p occurrences of the code
unit 0x0030 (DIGIT ZERO). 1. Let e be 0. 1. Else, 1. Let e and
n be integers such that 10\ :sup:`p - 1` ≤ n <
10\ :sup:`p` and for which n × 10\ :sup:`e - p + 1` -
x is as close to zero as possible. If there are two such sets of
e and n, pick the e and n for which n ×
10\ :sup:`e - p + 1` is larger. 1. Let m be the String value
consisting of the digits of the decimal representation of n (in
order, with no leading zeroes). 1. If e < -6 or e ≥ p, then
1. Assert: e ≠ 0. 1. If p ≠ 1, then 1. Let a be the first
code unit of m. 1. Let b be the other p - 1 code units of
m. 1. Set m to the string-concatenation of a, `"."`, and
b. 1. If e > 0, then 1. Let c be the code unit 0x002B (PLUS
SIGN). 1. Else, 1. Assert: e < 0. 1. Let c be the code unit
0x002D (HYPHEN-MINUS). 1. Set e to -e. 1. Let d be the
String value consisting of the digits of the decimal representation of
e (in order, with no leading zeroes). 1. Return the
string-concatenation of s, m, the code unit 0x0065 (LATIN SMALL
LETTER E), c, and d. 1. If e = p - 1, return the
string-concatenation of s and m. 1. If e ≥ 0, then 1. Set
m to the string-concatenation of the first e + 1 code units of
m, the code unit 0x002E (FULL STOP), and the remaining p -
(e + 1) code units of m. 1. Else, 1. Set m to the
string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit
0x002E (FULL STOP), -(e + 1) occurrences of the code unit 0x0030
(DIGIT ZERO), and the String m. 1. Return the string-concatenation
of s and m.

Number.prototype.toString ( [ radix ] )
-------------------------------------------

The optional radix should be an integral Number value in the
inclusive interval from `2`\ :sub:`𝔽` to `36`\ :sub:`𝔽`. If
radix is `undefined` then `10`\ :sub:`𝔽` is used as the value of
radix.

This method performs the following steps when called:

1. Let x be ? ThisNumberValue(`this` value). 1. If radix is
`undefined`, let radixMV be 10. 1. Else, let radixMV be ?
ToIntegerOrInfinity(radix). 1. If radixMV is not in the
inclusive interval from 2 to 36, throw a `RangeError` exception. 1.
Return Number::toString(x, radixMV).

This method is not generic; it throws a `TypeError` exception if its
`this` value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

The `"length"` property of this method is `1`\ :sub:`𝔽`.

Number.prototype.valueOf ( )
----------------------------

1. Return ? ThisNumberValue(`this` value).

ThisNumberValue ( value, )
--------------------------

1. If value is a Number, return value. 1. If value is an
Object and value has a [[NumberData]] internal slot, then 1. Let
n be value.[[NumberData]]. 1. Assert: n is a Number. 1.
Return n. 1. Throw a `TypeError` exception.

Properties of Number Instances
------------------------------

Number instances are ordinary objects that inherit properties from the
Number prototype object. Number instances also have a [[NumberData]]
internal slot. The [[NumberData]] internal slot is the Number value
represented by this Number object.

BigInt Objects
--------------

The BigInt Constructor
----------------------

The BigInt constructor:

- is %BigInt%.
- is the initial value of the `"BigInt"` property of the global
  object.
- performs a type conversion when called as a function rather than as a
  constructor.
- is not intended to be used with the `new` operator or to be
  subclassed. It may be used as the value of an `extends` clause of a
  class definition but a `super` call to the BigInt constructor will
  cause an exception.

BigInt ( value )
--------------------

This function performs the following steps when called:

1. If NewTarget is not `undefined`, throw a `TypeError` exception.
1. Let prim be ? ToPrimitive(value, ~number~). 1. If prim is
a Number, return ? NumberToBigInt(prim). 1. Otherwise, return ?
ToBigInt(prim).

NumberToBigInt ( number: a Number, )
------------------------------------

1. If number is not an integral Number, throw a `RangeError`
exception. 1. Return ℤ(ℝ(number)).

Properties of the BigInt Constructor
------------------------------------

The BigInt constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

BigInt.asIntN ( bits, bigint )
--------------------------------------

This function performs the following steps when called:

1. Set bits to ? ToIndex(bits). 1. Set bigint to ?
ToBigInt(bigint). 1. Let mod be ℝ(bigint) modulo
2\ :sup:`bits`. 1. If mod ≥ 2\ :sup:`bits - 1`, return
ℤ(mod - 2\ :sup:`bits`); otherwise, return ℤ(mod).

BigInt.asUintN ( bits, bigint )
---------------------------------------

This function performs the following steps when called:

1. Set bits to ? ToIndex(bits). 1. Set bigint to ?
ToBigInt(bigint). 1. Return ℤ(ℝ(bigint) modulo
2\ :sup:`bits`).

BigInt.prototype
----------------

The initial value of `BigInt.prototype` is the BigInt prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the BigInt Prototype Object
-----------------------------------------

The BigInt prototype object:

- is %BigInt.prototype%.
- is an ordinary object.
- is not a BigInt object; it does not have a [[BigIntData]] internal
  slot.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

The phrase “this BigInt value” within the specification of a method
refers to the result returned by calling the abstract operation
ThisBigIntValue with the `this` value of the method invocation passed
as the argument.

BigInt.prototype.constructor
----------------------------

The initial value of `BigInt.prototype.constructor` is %BigInt%.

BigInt.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
-------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method produces a String value that represents this BigInt value
formatted according to the conventions of the host environment's current
locale. This method is implementation-defined, and it is permissible,
but not encouraged, for it to return the same thing as `toString`.

The meanings of the optional parameters to this method are defined in
the ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

BigInt.prototype.toString ( [ radix ] )
-------------------------------------------

The optional radix should be an integral Number value in the
inclusive interval from `2`\ :sub:`𝔽` to `36`\ :sub:`𝔽`. If
radix is `undefined` then `10`\ :sub:`𝔽` is used as the value of
radix.

This method performs the following steps when called:

1. Let x be ? ThisBigIntValue(`this` value). 1. If radix is
`undefined`, let radixMV be 10. 1. Else, let radixMV be ?
ToIntegerOrInfinity(radix). 1. If radixMV is not in the
inclusive interval from 2 to 36, throw a `RangeError` exception. 1.
Return BigInt::toString(x, radixMV).

This method is not generic; it throws a `TypeError` exception if its
`this` value is not a BigInt or a BigInt object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

BigInt.prototype.valueOf ( )
----------------------------

1. Return ? ThisBigIntValue(`this` value).

ThisBigIntValue ( value, )
--------------------------

1. If value is a BigInt, return value. 1. If value is an
Object and value has a [[BigIntData]] internal slot, then 1. Assert:
value.[[BigIntData]] is a BigInt. 1. Return
value.[[BigIntData]]. 1. Throw a `TypeError` exception.

BigInt.prototype [ %Symbol.toStringTag% ]
-----------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"BigInt"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of BigInt Instances
------------------------------

BigInt instances are ordinary objects that inherit properties from the
BigInt prototype object. BigInt instances also have a [[BigIntData]]
internal slot. The [[BigIntData]] internal slot is the BigInt value
represented by this BigInt object.

The Math Object
---------------

The Math object:

- is %Math%.
- is the initial value of the `"Math"` property of the global object.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is not a function object.
- does not have a [[Construct]] internal method; it cannot be used as a
  constructor with the `new` operator.
- does not have a [[Call]] internal method; it cannot be invoked as a
  function.

In this specification, the phrase “the Number value for x” has a
technical meaning defined in .

Value Properties of the Math Object
-----------------------------------

Math.E
------

The Number value for *e*, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Math.LN10
---------

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Math.LN2
--------

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Math.LOG10E
-----------

The Number value for the base-10 logarithm of *e*, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

The value of `Math.LOG10E` is approximately the reciprocal of the
value of `Math.LN10`.

Math.LOG2E
----------

The Number value for the base-2 logarithm of *e*, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

The value of `Math.LOG2E` is approximately the reciprocal of the value
of `Math.LN2`.

Math.PI
-------

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Math.SQRT1_2
------------

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

The value of `Math.SQRT1_2` is approximately the reciprocal of the
value of `Math.SQRT2`.

Math.SQRT2
----------

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Math [ %Symbol.toStringTag% ]
-----------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Math"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Function Properties of the Math Object
--------------------------------------

The behaviour of the functions `acos`, `acosh`, `asin`, `asinh`,
`atan`, `atanh`, `atan2`, `cbrt`, `cos`, `cosh`, `exp`,
`expm1`, `hypot`, `log`, `log1p`, `log2`, `log10`, `pow`,
`random`, `sin`, `sinh`, `tan`, and `tanh` is not precisely
specified here except to require specific results for certain argument
values that represent boundary cases of interest. For other argument
values, these functions are intended to compute approximations to the
results of familiar mathematical functions, but some latitude is allowed
in the choice of approximation algorithms. The general intent is that an
implementer should be able to use the same mathematical library for
ECMAScript on a given hardware platform that is available to C
programmers on that platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754-2019 arithmetic contained
in `fdlibm`, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

Math.abs ( x )
------------------

This function returns the absolute value of x; the result has the
same magnitude as x but has positive sign.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is `NaN`, return
`NaN`. 1. If n is `-0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 1. If
n is `-∞`\ :sub:`𝔽`, return `+∞`\ :sub:`𝔽`. 1. If n <
`-0`\ :sub:`𝔽`, return -n. 1. Return n.

Math.acos ( x )
-------------------

This function returns the inverse cosine of x. The result is
expressed in radians and is in the inclusive interval from
`+0`\ :sub:`𝔽` to 𝔽(π).

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is `NaN`, n >
`1`\ :sub:`𝔽`, or n < `-1`\ :sub:`𝔽`, return `NaN`. 1. If
n is `1`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing the inverse cosine
of ℝ(n).

Math.acosh ( x )
--------------------

This function returns the inverse hyperbolic cosine of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is either `NaN` or
`+∞`\ :sub:`𝔽`, return n. 1. If n is `1`\ :sub:`𝔽`, return
`+0`\ :sub:`𝔽`. 1. If n < `1`\ :sub:`𝔽`, return `NaN`. 1.
Return an implementation-approximated Number value representing the
inverse hyperbolic cosine of ℝ(n).

Math.asin ( x )
-------------------

This function returns the inverse sine of x. The result is expressed
in radians and is in the inclusive interval from 𝔽(-π / 2) to 𝔽(π / 2).

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return n. 1. If n >
`1`\ :sub:`𝔽` or n < `-1`\ :sub:`𝔽`, return `NaN`. 1. Return
an implementation-approximated Number value representing the inverse
sine of ℝ(n).

Math.asinh ( x )
--------------------

This function returns the inverse hyperbolic sine of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite or n is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return n. 1. Return an
implementation-approximated Number value representing the inverse
hyperbolic sine of ℝ(n).

Math.atan ( x )
-------------------

This function returns the inverse tangent of x. The result is
expressed in radians and is in the inclusive interval from 𝔽(-π / 2) to
𝔽(π / 2).

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return n. 1. If n is
`+∞`\ :sub:`𝔽`, return an implementation-approximated Number value
representing π / 2. 1. If n is `-∞`\ :sub:`𝔽`, return an
implementation-approximated Number value representing -π / 2. 1. Return
an implementation-approximated Number value representing the inverse
tangent of ℝ(n).

Math.atanh ( x )
--------------------

This function returns the inverse hyperbolic tangent of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return n. 1. If n >
`1`\ :sub:`𝔽` or n < `-1`\ :sub:`𝔽`, return `NaN`. 1. If n
is `1`\ :sub:`𝔽`, return `+∞`\ :sub:`𝔽`. 1. If n is
`-1`\ :sub:`𝔽`, return `-∞`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing the inverse
hyperbolic tangent of ℝ(n).

Math.atan2 ( y, x )
---------------------------

This function returns the inverse tangent of the quotient y / x
of the arguments y and x, where the signs of y and x are
used to determine the quadrant of the result. Note that it is
intentional and traditional for the two-argument inverse tangent
function that the argument named y be first and the argument named
x be second. The result is expressed in radians and is in the
inclusive interval from -π to +π.

It performs the following steps when called:

1. Let ny be ? ToNumber(y). 1. Let nx be ? ToNumber(x).
1. If ny is `NaN` or nx is `NaN`, return `NaN`. 1. If
ny is `+∞`\ :sub:`𝔽`, then 1. If nx is `+∞`\ :sub:`𝔽`,
return an implementation-approximated Number value representing π / 4.
1. If nx is `-∞`\ :sub:`𝔽`, return an implementation-approximated
Number value representing 3π / 4. 1. Return an
implementation-approximated Number value representing π / 2. 1. If
ny is `-∞`\ :sub:`𝔽`, then 1. If nx is `+∞`\ :sub:`𝔽`,
return an implementation-approximated Number value representing -π / 4.
1. If nx is `-∞`\ :sub:`𝔽`, return an implementation-approximated
Number value representing -3π / 4. 1. Return an
implementation-approximated Number value representing -π / 2. 1. If
ny is `+0`\ :sub:`𝔽`, then 1. If nx > `+0`\ :sub:`𝔽` or
nx is `+0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing π. 1. If ny is
`-0`\ :sub:`𝔽`, then 1. If nx > `+0`\ :sub:`𝔽` or nx is
`+0`\ :sub:`𝔽`, return `-0`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing -π. 1. Assert:
ny is finite and is neither `+0`\ :sub:`𝔽` nor `-0`\ :sub:`𝔽`.
1. If ny > `+0`\ :sub:`𝔽`, then 1. If nx is `+∞`\ :sub:`𝔽`,
return `+0`\ :sub:`𝔽`. 1. If nx is `-∞`\ :sub:`𝔽`, return an
implementation-approximated Number value representing π. 1. If nx is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return an
implementation-approximated Number value representing π / 2. 1. If
ny < `-0`\ :sub:`𝔽`, then 1. If nx is `+∞`\ :sub:`𝔽`, return
`-0`\ :sub:`𝔽`. 1. If nx is `-∞`\ :sub:`𝔽`, return an
implementation-approximated Number value representing -π. 1. If nx
is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return an
implementation-approximated Number value representing -π / 2. 1. Assert:
nx is finite and is neither `+0`\ :sub:`𝔽` nor `-0`\ :sub:`𝔽`.
1. Let r be the inverse tangent of abs(ℝ(ny) / ℝ(nx)). 1. If
nx < `-0`\ :sub:`𝔽`, then 1. If ny > `+0`\ :sub:`𝔽`, set
r to π - r. 1. Else, set r to -π + r. 1. Else, 1. If
ny < `-0`\ :sub:`𝔽`, set r to -r. 1. Return an
implementation-approximated Number value representing r.

Math.cbrt ( x )
-------------------

This function returns the cube root of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite or n is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return n. 1. Return an
implementation-approximated Number value representing the cube root of
ℝ(n).

Math.ceil ( x )
-------------------

This function returns the smallest (closest to -∞) integral Number value
that is not less than x. If x is already an integral Number, the
result is x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite or n is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return n. 1. If n <
`-0`\ :sub:`𝔽` and n > `-1`\ :sub:`𝔽`, return `-0`\ :sub:`𝔽`.
1. If n is an integral Number, return n. 1. Return the smallest
(closest to -∞) integral Number value that is not less than n.

The value of `Math.ceil(x)` is the same as the value of
`-Math.floor(-x)`.

Math.clz32 ( x )
--------------------

This function performs the following steps when called:

1. Let n be ? ToUint32(x). 1. Let p be the number of leading
zero bits in the unsigned 32-bit binary representation of n. 1.
Return 𝔽(p).

If n is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, this method
returns `32`\ :sub:`𝔽`. If the most significant bit of the 32-bit
binary encoding of n is 1, this method returns `+0`\ :sub:`𝔽`.

Math.cos ( x )
------------------

This function returns the cosine of x. The argument is expressed in
radians.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite, return
`NaN`. 1. If n is either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`,
return `1`\ :sub:`𝔽`. 1. Return an implementation-approximated Number
value representing the cosine of ℝ(n).

Math.cosh ( x )
-------------------

This function returns the hyperbolic cosine of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is `NaN`, return
`NaN`. 1. If n is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`,
return `+∞`\ :sub:`𝔽`. 1. If n is either `+0`\ :sub:`𝔽` or
`-0`\ :sub:`𝔽`, return `1`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing the hyperbolic
cosine of ℝ(n).

The value of `Math.cosh(x)` is the same as the value of `(Math.exp(x)
+ Math.exp(-x)) / 2`.

Math.exp ( x )
------------------

This function returns the exponential function of x (e raised to
the power of x, where e is the base of the natural logarithms).

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is either `NaN` or
`+∞`\ :sub:`𝔽`, return n. 1. If n is either `+0`\ :sub:`𝔽`
or `-0`\ :sub:`𝔽`, return `1`\ :sub:`𝔽`. 1. If n is
`-∞`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing the exponential
function of ℝ(n).

Math.expm1 ( x )
--------------------

This function returns the result of subtracting 1 from the exponential
function of x (e raised to the power of x, where e is
the base of the natural logarithms). The result is computed in a way
that is accurate even when the value of x is close to 0.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, `-0`\ :sub:`𝔽`, or `+∞`\ :sub:`𝔽`, return n.
1. If n is `-∞`\ :sub:`𝔽`, return `-1`\ :sub:`𝔽`. 1. Let exp
be the exponential function of ℝ(n). 1. Return an
implementation-approximated Number value representing exp - 1.

Math.floor ( x )
--------------------

This function returns the greatest (closest to +∞) integral Number value
that is not greater than x. If x is already an integral Number,
the result is x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite or n is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return n. 1. If n <
`1`\ :sub:`𝔽` and n > `+0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`.
1. If n is an integral Number, return n. 1. Return the greatest
(closest to +∞) integral Number value that is not greater than n.

The value of `Math.floor(x)` is the same as the value of
`-Math.ceil(-x)`.

Math.fround ( x )
---------------------

This function performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is `NaN`, return
`NaN`. 1. If n is one of `+0`\ :sub:`𝔽`, `-0`\ :sub:`𝔽`,
`+∞`\ :sub:`𝔽`, or `-∞`\ :sub:`𝔽`, return n. 1. Let n32 be
the result of converting n to IEEE 754-2019 binary32 format using
roundTiesToEven mode. 1. Let n64 be the result of converting n32
to IEEE 754-2019 binary64 format. 1. Return the ECMAScript Number value
corresponding to n64.

Math.hypot ( ..._args )
-------------------------

Given zero or more arguments, this function returns the square root of
the sum of squares of its arguments.

It performs the following steps when called:

1. Let coerced be a new empty List. 1. For each element arg of
args, do 1. Let n be ? ToNumber(arg). 1. Append n to
coerced. 1. For each element number of coerced, do 1. If
number is either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, return
`+∞`\ :sub:`𝔽`. 1. Let onlyZero be `true`. 1. For each element
number of coerced, do 1. If number is `NaN`, return
`NaN`. 1. If number is neither `+0`\ :sub:`𝔽` nor
`-0`\ :sub:`𝔽`, set onlyZero to `false`. 1. If onlyZero is
`true`, return `+0`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing the square root of
the sum of squares of the mathematical values of the elements of
coerced.

The `"length"` property of this function is `2`\ :sub:`𝔽`.

Implementations should take care to avoid the loss of precision from
overflows and underflows that are prone to occur in naive
implementations when this function is called with two or more arguments.

Math.imul ( x, y )
--------------------------

This function performs the following steps when called:

1. Let a be ℝ(? ToUint32(x)). 1. Let b be ℝ(?
ToUint32(y)). 1. Let product be (a × b) modulo
2\ :sup:`32`. 1. If product ≥ 2\ :sup:`31`, return 𝔽(product -
2\ :sup:`32`); otherwise return 𝔽(product).

Math.log ( x )
------------------

This function returns the natural logarithm of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is either `NaN` or
`+∞`\ :sub:`𝔽`, return n. 1. If n is `1`\ :sub:`𝔽`, return
`+0`\ :sub:`𝔽`. 1. If n is either `+0`\ :sub:`𝔽` or
`-0`\ :sub:`𝔽`, return `-∞`\ :sub:`𝔽`. 1. If n <
`-0`\ :sub:`𝔽`, return `NaN`. 1. Return an
implementation-approximated Number value representing the natural
logarithm of ℝ(n).

Math.log1p ( x )
--------------------

This function returns the natural logarithm of 1 + x. The result is
computed in a way that is accurate even when the value of x is close to
zero.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, `-0`\ :sub:`𝔽`, or `+∞`\ :sub:`𝔽`, return n.
1. If n is `-1`\ :sub:`𝔽`, return `-∞`\ :sub:`𝔽`. 1. If n <
`-1`\ :sub:`𝔽`, return `NaN`. 1. Return an
implementation-approximated Number value representing the natural
logarithm of 1 + ℝ(n).

Math.log10 ( x )
--------------------

This function returns the base 10 logarithm of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is either `NaN` or
`+∞`\ :sub:`𝔽`, return n. 1. If n is `1`\ :sub:`𝔽`, return
`+0`\ :sub:`𝔽`. 1. If n is either `+0`\ :sub:`𝔽` or
`-0`\ :sub:`𝔽`, return `-∞`\ :sub:`𝔽`. 1. If n <
`-0`\ :sub:`𝔽`, return `NaN`. 1. Return an
implementation-approximated Number value representing the base 10
logarithm of ℝ(n).

Math.log2 ( x )
-------------------

This function returns the base 2 logarithm of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is either `NaN` or
`+∞`\ :sub:`𝔽`, return n. 1. If n is `1`\ :sub:`𝔽`, return
`+0`\ :sub:`𝔽`. 1. If n is either `+0`\ :sub:`𝔽` or
`-0`\ :sub:`𝔽`, return `-∞`\ :sub:`𝔽`. 1. If n <
`-0`\ :sub:`𝔽`, return `NaN`. 1. Return an
implementation-approximated Number value representing the base 2
logarithm of ℝ(n).

Math.max ( ..._args )
-----------------------

Given zero or more arguments, this function calls ToNumber on each of
the arguments and returns the largest of the resulting values.

It performs the following steps when called:

1. Let coerced be a new empty List. 1. For each element arg of
args, do 1. Let n be ? ToNumber(arg). 1. Append n to
coerced. 1. Let highest be `-∞`\ :sub:`𝔽`. 1. For each element
number of coerced, do 1. If number is `NaN`, return
`NaN`. 1. If number is `+0`\ :sub:`𝔽` and highest is
`-0`\ :sub:`𝔽`, set highest to `+0`\ :sub:`𝔽`. 1. If number
> highest, set highest to number. 1. Return highest.

The comparison of values to determine the largest value is done using
the IsLessThan algorithm except that `+0`\ :sub:`𝔽` is considered to
be larger than `-0`\ :sub:`𝔽`.

The `"length"` property of this function is `2`\ :sub:`𝔽`.

Math.min ( ..._args )
-----------------------

Given zero or more arguments, this function calls ToNumber on each of
the arguments and returns the smallest of the resulting values.

It performs the following steps when called:

1. Let coerced be a new empty List. 1. For each element arg of
args, do 1. Let n be ? ToNumber(arg). 1. Append n to
coerced. 1. Let lowest be `+∞`\ :sub:`𝔽`. 1. For each element
number of coerced, do 1. If number is `NaN`, return
`NaN`. 1. If number is `-0`\ :sub:`𝔽` and lowest is
`+0`\ :sub:`𝔽`, set lowest to `-0`\ :sub:`𝔽`. 1. If number <
lowest, set lowest to number. 1. Return lowest.

The comparison of values to determine the largest value is done using
the IsLessThan algorithm except that `+0`\ :sub:`𝔽` is considered to
be larger than `-0`\ :sub:`𝔽`.

The `"length"` property of this function is `2`\ :sub:`𝔽`.

Math.pow ( base, exponent )
-----------------------------------

This function performs the following steps when called:

1. Set base to ? ToNumber(base). 1. Set exponent to ?
ToNumber(exponent). 1. Return Number::exponentiate(base,
exponent).

Math.random ( )
---------------

This function returns a Number value with positive sign, greater than or
equal to `+0`\ :sub:`𝔽` but strictly less than `1`\ :sub:`𝔽`, chosen
randomly or pseudo randomly with approximately uniform distribution over
that range, using an implementation-defined algorithm or strategy.

Each `Math.random` function created for distinct realms must produce a
distinct sequence of values from successive calls.

Math.round ( x )
--------------------

This function returns the Number value that is closest to x and is
integral. If two integral Numbers are equally close to x, then the
result is the Number value that is closer to +∞. If x is already
integral, the result is x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite or n is
an integral Number, return n. 1. If n < `0.5`\ :sub:`𝔽` and
n > `+0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 1. If n <
`-0`\ :sub:`𝔽` and n ≥ `-0.5`\ :sub:`𝔽`, return
`-0`\ :sub:`𝔽`. 1. Return the integral Number closest to n,
preferring the Number closer to +∞ in the case of a tie.

`Math.round(3.5)` returns 4, but `Math.round(-3.5)` returns -3.

The value of `Math.round(x)` is not always the same as the value of
`Math.floor(x + 0.5)`. When `x` is `-0`\ :sub:`𝔽` or `x` is less
than `+0`\ :sub:`𝔽` but greater than or equal to `-0.5`\ :sub:`𝔽`,
`Math.round(x)` returns `-0`\ :sub:`𝔽`, but `Math.floor(x + 0.5)`
returns `+0`\ :sub:`𝔽`. `Math.round(x)` may also differ from the
value of `Math.floor(x + 0.5)`because of internal rounding when
computing `x + 0.5`.

Math.sign ( x )
-------------------

This function returns the sign of x, indicating whether x is
positive, negative, or zero.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return n. 1. If n <
`-0`\ :sub:`𝔽`, return `-1`\ :sub:`𝔽`. 1. Return `1`\ :sub:`𝔽`.

Math.sin ( x )
------------------

This function returns the sine of x. The argument is expressed in
radians.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return n. 1. If n is
either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, return `NaN`. 1. Return
an implementation-approximated Number value representing the sine of
ℝ(n).

Math.sinh ( x )
-------------------

This function returns the hyperbolic sine of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite or n is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return n. 1. Return an
implementation-approximated Number value representing the hyperbolic
sine of ℝ(n).

The value of `Math.sinh(x)` is the same as the value of `(Math.exp(x)
- Math.exp(-x)) / 2`.

Math.sqrt ( x )
-------------------

This function returns the square root of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, `-0`\ :sub:`𝔽`, or `+∞`\ :sub:`𝔽`, return n.
1. If n < `-0`\ :sub:`𝔽`, return `NaN`. 1. Return 𝔽(the square
root of ℝ(n)).

Math.tan ( x )
------------------

This function returns the tangent of x. The argument is expressed in
radians.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return n. 1. If n is
either `+∞`\ :sub:`𝔽` or `-∞`\ :sub:`𝔽`, return `NaN`. 1. Return
an implementation-approximated Number value representing the tangent of
ℝ(n).

Math.tanh ( x )
-------------------

This function returns the hyperbolic tangent of x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is one of `NaN`,
`+0`\ :sub:`𝔽`, or `-0`\ :sub:`𝔽`, return n. 1. If n is
`+∞`\ :sub:`𝔽`, return `1`\ :sub:`𝔽`. 1. If n is
`-∞`\ :sub:`𝔽`, return `-1`\ :sub:`𝔽`. 1. Return an
implementation-approximated Number value representing the hyperbolic
tangent of ℝ(n).

The value of `Math.tanh(x)` is the same as the value of `(Math.exp(x)
- Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))`.

Math.trunc ( x )
--------------------

This function returns the integral part of the number x, removing
any fractional digits. If x is already integral, the result is
x.

It performs the following steps when called:

1. Let n be ? ToNumber(x). 1. If n is not finite or n is
either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽`, return n. 1. If n <
`1`\ :sub:`𝔽` and n > `+0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`.
1. If n < `-0`\ :sub:`𝔽` and n > `-1`\ :sub:`𝔽`, return
`-0`\ :sub:`𝔽`. 1. Return the integral Number nearest n in the
direction of `+0`\ :sub:`𝔽`.

Date Objects
------------

Overview of Date Objects and Definitions of Abstract Operations
---------------------------------------------------------------

The following abstract operations operate on time values (defined in ).
Note that, in every case, if any argument to one of these functions is
`NaN`, the result will be `NaN`.

Time Values and Time Range
--------------------------

Time measurement in ECMAScript is analogous to time measurement in
POSIX, in particular sharing definition in terms of the proleptic
Gregorian calendar, an epoch of midnight at the beginning of 1 January
1970 UTC, and an accounting of every day as comprising exactly 86,400
seconds (each of which is 1000 milliseconds long).

An ECMAScript time value is a Number, either a finite integral Number
representing an instant in time to millisecond precision or `NaN`
representing no specific instant. A time value that is a multiple of 24
× 60 × 60 × 1000 = 86,400,000 (i.e., is 86,400,000 × d for some
integer d) represents the instant at the start of the UTC day that
follows the epoch by d whole UTC days (preceding the epoch for
negative d). Every other finite time value t is defined relative
to the greatest preceding time value s that is such a multiple, and
represents the instant that occurs within the same UTC day as s but
follows it by (t - s) milliseconds.

Time values do not account for UTC leap seconds—there are no time values
representing instants within positive leap seconds, and there are time
values representing instants removed from the UTC timeline by negative
leap seconds. However, the definition of time values nonetheless yields
piecewise alignment with UTC, with discontinuities only at leap second
boundaries and zero difference outside of leap seconds.

A Number can exactly represent all integers from -9,007,199,254,740,992
to 9,007,199,254,740,992 ( and ). A time value supports a slightly
smaller range of -8,640,000,000,000,000 to 8,640,000,000,000,000
milliseconds. This yields a supported time value range of exactly
-100,000,000 days to 100,000,000 days relative to midnight at the
beginning of 1 January 1970 UTC.

The exact moment of midnight at the beginning of 1 January 1970 UTC is
represented by the time value `+0`\ :sub:`𝔽`.

In the proleptic Gregorian calendar, leap years are precisely those
which are both divisible by 4 and either divisible by 400 or not
divisible by 100.

The 400 year cycle of the proleptic Gregorian calendar contains 97 leap
years. This yields an average of 365.2425 days per year, which is
31,556,952,000 milliseconds. Therefore, the maximum range a Number could
represent exactly with millisecond precision is approximately -285,426
to 285,426 years relative to 1970. The smaller range supported by a time
value as specified in this section is approximately -273,790 to 273,790
years relative to 1970.

Time-related Constants
----------------------

These constants are referenced by algorithms in the following sections.

HoursPerDay = 24 MinutesPerHour = 60 SecondsPerMinute = 60 msPerSecond =
`1000`\ :sub:`𝔽` msPerMinute = `60000`\ :sub:`𝔽` = msPerSecond ×
𝔽(SecondsPerMinute) msPerHour = `3600000`\ :sub:`𝔽` = msPerMinute ×
𝔽(MinutesPerHour) msPerDay = `86400000`\ :sub:`𝔽` = msPerHour ×
𝔽(HoursPerDay)

Day ( t: a finite time value, ): an integral Number
-------------------------------------------------------

description
   It returns the day number of the day in which t falls.

1. Return 𝔽(floor(ℝ(t / msPerDay))).

TimeWithinDay ( t: a finite time value, ): an integral Number in the interval from `+0`\ :sub:`𝔽` (inclusive) to msPerDay (exclusive)
-------------------------------------------------------------------------------------------------------------------------------------------

description
   It returns the number of milliseconds since the start of the day in
   which t falls.

1. Return 𝔽(ℝ(t) modulo ℝ(msPerDay)).

DaysInYear ( y: an integral Number, ): `365`\ :sub:`𝔽` or `366`\ :sub:`𝔽`
---------------------------------------------------------------------------------

description
   It returns the number of days in year y. Leap years have 366
   days; all other years have 365.

1. Let ry be ℝ(y). 1. If (ry modulo 400) = 0, return
`366`\ :sub:`𝔽`. 1. If (ry modulo 100) = 0, return
`365`\ :sub:`𝔽`. 1. If (ry modulo 4) = 0, return
`366`\ :sub:`𝔽`. 1. Return `365`\ :sub:`𝔽`.

DayFromYear ( y: an integral Number, ): an integral Number
--------------------------------------------------------------

description
   It returns the day number of the first day of year y.

1. Let ry be ℝ(y). 1.
[declared="numYears1,numYears4,numYears100,numYears400"] NOTE: In the
following steps, numYears1, numYears4, numYears100, and
numYears400 represent the number of years divisible by 1, 4, 100,
and 400, respectively, that occur between the epoch and the start of
year y. The number is negative if y is before the epoch. 1. Let
numYears1 be (ry - 1970). 1. Let numYears4 be floor((ry
- 1969) / 4). 1. Let numYears100 be floor((ry - 1901) / 100). 1.
Let numYears400 be floor((ry - 1601) / 400). 1. Return 𝔽(365 ×
numYears1 + numYears4 - numYears100 + numYears400).

TimeFromYear ( y: an integral Number, ): a time value
---------------------------------------------------------

description
   It returns the time value of the start of year y.

1. Return msPerDay × DayFromYear(y).

YearFromTime ( t: a finite time value, ): an integral Number
----------------------------------------------------------------

description
   It returns the year in which t falls.

1. [declared="y"] Return the largest integral Number y (closest to
+∞) such that TimeFromYear(y) ≤ t.

DayWithinYear ( t: a finite time value, ): an integral Number in the inclusive interval from `+0`\ :sub:`𝔽` to `365`\ :sub:`𝔽`
--------------------------------------------------------------------------------------------------------------------------------------

1. Return Day(t) - DayFromYear(YearFromTime(t)).

InLeapYear ( t: a finite time value, ): `+0`\ :sub:`𝔽` or `1`\ :sub:`𝔽`
-------------------------------------------------------------------------------

description
   It returns `1`\ :sub:`𝔽` if t is within a leap year and
   `+0`\ :sub:`𝔽` otherwise.

1. If DaysInYear(YearFromTime(t)) is `366`\ :sub:`𝔽`, return
`1`\ :sub:`𝔽`; else return `+0`\ :sub:`𝔽`.

MonthFromTime ( t: a finite time value, ): an integral Number in the inclusive interval from `+0`\ :sub:`𝔽` to `11`\ :sub:`𝔽`
-------------------------------------------------------------------------------------------------------------------------------------

description
   It returns a Number identifying the month in which t falls. A
   month value of `+0`\ :sub:`𝔽` specifies January; `1`\ :sub:`𝔽`
   specifies February; `2`\ :sub:`𝔽` specifies March; `3`\ :sub:`𝔽`
   specifies April; `4`\ :sub:`𝔽` specifies May; `5`\ :sub:`𝔽`
   specifies June; `6`\ :sub:`𝔽` specifies July; `7`\ :sub:`𝔽`
   specifies August; `8`\ :sub:`𝔽` specifies September;
   `9`\ :sub:`𝔽` specifies October; `10`\ :sub:`𝔽` specifies
   November; and `11`\ :sub:`𝔽` specifies December. Note that
   MonthFromTime(`+0`\ :sub:`𝔽`) = `+0`\ :sub:`𝔽`, corresponding to
   Thursday, 1 January 1970.

1. Let inLeapYear be InLeapYear(t). 1. Let dayWithinYear be
DayWithinYear(t). 1. If dayWithinYear < `31`\ :sub:`𝔽`, return
`+0`\ :sub:`𝔽`. 1. If dayWithinYear < `59`\ :sub:`𝔽` +
inLeapYear, return `1`\ :sub:`𝔽`. 1. If dayWithinYear <
`90`\ :sub:`𝔽` + inLeapYear, return `2`\ :sub:`𝔽`. 1. If
dayWithinYear < `120`\ :sub:`𝔽` + inLeapYear, return
`3`\ :sub:`𝔽`. 1. If dayWithinYear < `151`\ :sub:`𝔽` +
inLeapYear, return `4`\ :sub:`𝔽`. 1. If dayWithinYear <
`181`\ :sub:`𝔽` + inLeapYear, return `5`\ :sub:`𝔽`. 1. If
dayWithinYear < `212`\ :sub:`𝔽` + inLeapYear, return
`6`\ :sub:`𝔽`. 1. If dayWithinYear < `243`\ :sub:`𝔽` +
inLeapYear, return `7`\ :sub:`𝔽`. 1. If dayWithinYear <
`273`\ :sub:`𝔽` + inLeapYear, return `8`\ :sub:`𝔽`. 1. If
dayWithinYear < `304`\ :sub:`𝔽` + inLeapYear, return
`9`\ :sub:`𝔽`. 1. If dayWithinYear < `334`\ :sub:`𝔽` +
inLeapYear, return `10`\ :sub:`𝔽`. 1. Assert: dayWithinYear <
`365`\ :sub:`𝔽` + inLeapYear. 1. Return `11`\ :sub:`𝔽`.

DateFromTime ( t: a finite time value, ): an integral Number in the inclusive interval from `1`\ :sub:`𝔽` to `31`\ :sub:`𝔽`
-----------------------------------------------------------------------------------------------------------------------------------

description
   It returns the day of the month in which t falls.

1. Let inLeapYear be InLeapYear(t). 1. Let dayWithinYear be
DayWithinYear(t). 1. Let month be MonthFromTime(t). 1. If
month is `+0`\ :sub:`𝔽`, return dayWithinYear +
`1`\ :sub:`𝔽`. 1. If month is `1`\ :sub:`𝔽`, return
dayWithinYear - `30`\ :sub:`𝔽`. 1. If month is
`2`\ :sub:`𝔽`, return dayWithinYear - `58`\ :sub:`𝔽` -
inLeapYear. 1. If month is `3`\ :sub:`𝔽`, return
dayWithinYear - `89`\ :sub:`𝔽` - inLeapYear. 1. If month
is `4`\ :sub:`𝔽`, return dayWithinYear - `119`\ :sub:`𝔽` -
inLeapYear. 1. If month is `5`\ :sub:`𝔽`, return
dayWithinYear - `150`\ :sub:`𝔽` - inLeapYear. 1. If month
is `6`\ :sub:`𝔽`, return dayWithinYear - `180`\ :sub:`𝔽` -
inLeapYear. 1. If month is `7`\ :sub:`𝔽`, return
dayWithinYear - `211`\ :sub:`𝔽` - inLeapYear. 1. If month
is `8`\ :sub:`𝔽`, return dayWithinYear - `242`\ :sub:`𝔽` -
inLeapYear. 1. If month is `9`\ :sub:`𝔽`, return
dayWithinYear - `272`\ :sub:`𝔽` - inLeapYear. 1. If month
is `10`\ :sub:`𝔽`, return dayWithinYear - `303`\ :sub:`𝔽` -
inLeapYear. 1. Assert: month is `11`\ :sub:`𝔽`. 1. Return
dayWithinYear - `333`\ :sub:`𝔽` - inLeapYear.

WeekDay ( t: a finite time value, ): an integral Number in the inclusive interval from `+0`\ :sub:`𝔽` to `6`\ :sub:`𝔽`
------------------------------------------------------------------------------------------------------------------------------

description
   It returns a Number identifying the day of the week in which t
   falls. A weekday value of `+0`\ :sub:`𝔽` specifies Sunday;
   `1`\ :sub:`𝔽` specifies Monday; `2`\ :sub:`𝔽` specifies Tuesday;
   `3`\ :sub:`𝔽` specifies Wednesday; `4`\ :sub:`𝔽` specifies
   Thursday; `5`\ :sub:`𝔽` specifies Friday; and `6`\ :sub:`𝔽`
   specifies Saturday. Note that WeekDay(`+0`\ :sub:`𝔽`) =
   `4`\ :sub:`𝔽`, corresponding to Thursday, 1 January 1970.

1. Return 𝔽(ℝ(Day(t) + `4`\ :sub:`𝔽`) modulo 7).

HourFromTime ( t: a finite time value, ): an integral Number in the inclusive interval from `+0`\ :sub:`𝔽` to `23`\ :sub:`𝔽`
------------------------------------------------------------------------------------------------------------------------------------

description
   It returns the hour of the day in which t falls.

1. Return 𝔽(floor(ℝ(t / msPerHour)) modulo HoursPerDay).

MinFromTime ( t: a finite time value, ): an integral Number in the inclusive interval from `+0`\ :sub:`𝔽` to `59`\ :sub:`𝔽`
-----------------------------------------------------------------------------------------------------------------------------------

description
   It returns the minute of the hour in which t falls.

1. Return 𝔽(floor(ℝ(t / msPerMinute)) modulo MinutesPerHour).

SecFromTime ( t: a finite time value, ): an integral Number in the inclusive interval from `+0`\ :sub:`𝔽` to `59`\ :sub:`𝔽`
-----------------------------------------------------------------------------------------------------------------------------------

description
   It returns the second of the minute in which t falls.

1. Return 𝔽(floor(ℝ(t / msPerSecond)) modulo SecondsPerMinute).

msFromTime ( t: a finite time value, ): an integral Number in the inclusive interval from `+0`\ :sub:`𝔽` to `999`\ :sub:`𝔽`
-----------------------------------------------------------------------------------------------------------------------------------

description
   It returns the millisecond of the second in which t falls.

1. Return 𝔽(ℝ(t) modulo ℝ(msPerSecond)).

GetUTCEpochNanoseconds ( year: an integer, month: an integer in the inclusive interval from 1 to 12, day: an integer in the inclusive interval from 1 to 31, hour: an integer in the inclusive interval from 0 to 23, minute: an integer in the inclusive interval from 0 to 59, second: an integer in the inclusive interval from 0 to 59, millisecond: an integer in the inclusive interval from 0 to 999, microsecond: an integer in the inclusive interval from 0 to 999, nanosecond: an integer in the inclusive interval from 0 to 999, ): a BigInt
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   The returned value represents a number of nanoseconds since the epoch
   that corresponds to the given ISO 8601 calendar date and wall-clock
   time in UTC.

1. Let date be MakeDay(𝔽(year), 𝔽(month - 1), 𝔽(day)).
1. Let time be MakeTime(𝔽(hour), 𝔽(minute), 𝔽(second),
𝔽(millisecond)). 1. Let ms be MakeDate(date, time). 1.
Assert: ms is an integral Number. 1. Return ℤ(ℝ(ms) ×
10\ :sup:`6` + microsecond × 10\ :sup:`3` + nanosecond).

Time Zone Identifiers
---------------------

Time zones in ECMAScript are represented by time zone identifiers, which
are Strings composed entirely of code units in the inclusive interval
from 0x0000 to 0x007F. Time zones supported by an ECMAScript
implementation may be available named time zones, represented by the
[[Identifier]] field of the Time Zone Identifier Records returned by
AvailableNamedTimeZoneIdentifiers, or offset time zones, represented by
Strings for which IsTimeZoneOffsetString returns `true`.

A primary time zone identifier is the preferred identifier for an
available named time zone. A non-primary time zone identifier is an
identifier for an available named time zone that is not a primary time
zone identifier. An available named time zone identifier is either a
primary time zone identifier or a non-primary time zone identifier. Each
available named time zone identifier is associated with exactly one
available named time zone. Each available named time zone is associated
with exactly one primary time zone identifier and zero or more
non-primary time zone identifiers.

ECMAScript implementations must support an available named time zone
with the identifier `"UTC"`, which must be the primary time zone
identifier for the UTC time zone. In addition, implementations may
support any number of other available named time zones.

Implementations that follow the requirements for time zones as described
in the ECMA-402 Internationalization API specification are called time
zone aware. Time zone aware implementations must support available named
time zones corresponding to the Zone and Link names of the IANA Time
Zone Database, and only such names. In time zone aware implementations,
a primary time zone identifier is a Zone name, and a non-primary time
zone identifier is a Link name, respectively, in the IANA Time Zone
Database except as specifically overridden by
AvailableNamedTimeZoneIdentifiers as specified in the ECMA-402
specification. Implementations that do not support the entire IANA Time
Zone Database are still recommended to use IANA Time Zone Database names
as identifiers to represent time zones.

GetNamedTimeZoneEpochNanoseconds ( timeZoneIdentifier: a String, year: an integer, month: an integer in the inclusive interval from 1 to 12, day: an integer in the inclusive interval from 1 to 31, hour: an integer in the inclusive interval from 0 to 23, minute: an integer in the inclusive interval from 0 to 59, second: an integer in the inclusive interval from 0 to 59, millisecond: an integer in the inclusive interval from 0 to 999, microsecond: an integer in the inclusive interval from 0 to 999, nanosecond: an integer in the inclusive interval from 0 to 999, ): a List of BigInts
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   Each value in the returned List represents a number of nanoseconds
   since the epoch that corresponds to the given ISO 8601 calendar date
   and wall-clock time in the named time zone identified by
   timeZoneIdentifier.

When the input represents a local time occurring more than once because
of a negative time zone transition (e.g. when daylight saving time ends
or the time zone offset is decreased due to a time zone rule change),
the returned List will have more than one element and will be sorted by
ascending numerical value. When the input represents a local time
skipped because of a positive time zone transition (e.g. when daylight
saving time begins or the time zone offset is increased due to a time
zone rule change), the returned List will be empty. Otherwise, the
returned List will have one element.

The default implementation of GetNamedTimeZoneEpochNanoseconds, to be
used for ECMAScript implementations that do not include local political
rules for any time zones, performs the following steps when called:

1. Assert: timeZoneIdentifier is `"UTC"`. 1. Let
epochNanoseconds be GetUTCEpochNanoseconds(year, month,
day, hour, minute, second, millisecond,
microsecond, nanosecond). 1. Return « epochNanoseconds ».

It is required for time zone aware implementations (and recommended for
all others) to use the time zone information of the IANA Time Zone
Database https://www.iana.org/time-zones/.

1:30 AM on 5 November 2017 in America/New_York is repeated twice, so
GetNamedTimeZoneEpochNanoseconds(`"America/New_York"`, 2017, 11, 5, 1,
30, 0, 0, 0, 0) would return a List of length 2 in which the first
element represents 05:30 UTC (corresponding with 01:30 US Eastern
Daylight Time at UTC offset -04:00) and the second element represents
06:30 UTC (corresponding with 01:30 US Eastern Standard Time at UTC
offset -05:00).

2:30 AM on 12 March 2017 in America/New_York does not exist, so
GetNamedTimeZoneEpochNanoseconds(`"America/New_York"`, 2017, 3, 12, 2,
30, 0, 0, 0, 0) would return an empty List.

GetNamedTimeZoneOffsetNanoseconds ( timeZoneIdentifier: a String, epochNanoseconds: a BigInt, ): an integer
-------------------------------------------------------------------------------------------------------------------

The returned integer represents the offset from UTC of the named time
zone identified by timeZoneIdentifier, at the instant corresponding
with epochNanoseconds relative to the epoch, both in nanoseconds.

The default implementation of GetNamedTimeZoneOffsetNanoseconds, to be
used for ECMAScript implementations that do not include local political
rules for any time zones, performs the following steps when called:

1. Assert: timeZoneIdentifier is `"UTC"`. 1. Return 0.

Time zone offset values may be positive or negative.

Time Zone Identifier Record
---------------------------

A Time Zone Identifier Record is a Record used to describe an available
named time zone identifier and its corresponding primary time zone
identifier.

Time Zone Identifier Records have the fields listed in .

+-----------------------+----------+----------------------------+
| Field Name            | Value    | Meaning                    |
+=======================+==========+============================+
| [[Identifier]]        | a String | An available named time    |
|                       |          | zone identifier that is    |
|                       |          | supported by the           |
|                       |          | implementation.            |
+-----------------------+----------+----------------------------+
| [[PrimaryIdentifier]] | a String | The primary time zone      |
|                       |          | identifier that            |
|                       |          | [[Identifier]] resolves    |
|                       |          | to.                        |
+-----------------------+----------+----------------------------+

If [[Identifier]] is a primary time zone identifier, then [[Identifier]]
is [[PrimaryIdentifier]].

AvailableNamedTimeZoneIdentifiers ( ): a List of Time Zone Identifier Records
-----------------------------------------------------------------------------

description
   Its result describes all available named time zone identifiers in
   this implementation, as well as the primary time zone identifier
   corresponding to each available named time zone identifier. The List
   is ordered according to the [[Identifier]] field of each Time Zone
   Identifier Record.

Time zone aware implementations, including all implementations that
implement the ECMA-402 Internationalization API, must implement the
AvailableNamedTimeZoneIdentifiers abstract operation as specified in the
ECMA-402 specification. For implementations that are not time zone
aware, AvailableNamedTimeZoneIdentifiers performs the following steps
when called:

1. If the implementation does not include local political rules for any
time zones, then 1. Return « the Time Zone Identifier Record {
[[Identifier]]: `"UTC"`, [[PrimaryIdentifier]]: `"UTC"` } ». 1. Let
identifiers be the List of unique available named time zone
identifiers, sorted according to lexicographic code unit order. 1. Let
result be a new empty List. 1. For each element identifier of
identifiers, do 1. Let primary be identifier. 1. If
identifier is a non-primary time zone identifier in this
implementation and identifier is not `"UTC"`, then 1. Set
primary to the primary time zone identifier associated with
identifier. 1. NOTE: An implementation may need to resolve
identifier iteratively to obtain the primary time zone identifier.
1. Let record be the Time Zone Identifier Record { [[Identifier]]:
identifier, [[PrimaryIdentifier]]: primary }. 1. Append
record to result. 1. Assert: result contains a Time Zone
Identifier Record r such that r.[[Identifier]] is `"UTC"` and
r.[[PrimaryIdentifier]] is `"UTC"`. 1. Return result.

SystemTimeZoneIdentifier ( ): a String
--------------------------------------

description
   It returns a String representing the host environment's current time
   zone, which is either a String representing a UTC offset for which
   IsTimeZoneOffsetString returns `true`, or a primary time zone
   identifier.

1. If the implementation only supports the UTC time zone, return
`"UTC"`. 1. Let systemTimeZoneString be the String representing
the host environment's current time zone, either a primary time zone
identifier or an offset time zone identifier. 1. Return
systemTimeZoneString.

To ensure the level of functionality that implementations commonly
provide in the methods of the Date object, it is recommended that
SystemTimeZoneIdentifier return an IANA time zone name corresponding to
the host environment's time zone setting, if such a thing exists.
GetNamedTimeZoneEpochNanoseconds and GetNamedTimeZoneOffsetNanoseconds
must reflect the local political rules for standard time and daylight
saving time in that time zone, if such rules exist.

For example, if the host environment is a browser on a system where the
user has chosen US Eastern Time as their time zone,
SystemTimeZoneIdentifier returns `"America/New_York"`.

LocalTime ( t: a finite time value, ): an integral Number
-------------------------------------------------------------

description
   It converts t from UTC to local time. The local political rules
   for standard time and daylight saving time in effect at t should
   be used to determine the result in the way specified in this section.

1. Let systemTimeZoneIdentifier be SystemTimeZoneIdentifier(). 1. If
IsTimeZoneOffsetString(systemTimeZoneIdentifier) is `true`, then
1. Let offsetNs be
ParseTimeZoneOffsetString(systemTimeZoneIdentifier). 1. Else, 1. Let
offsetNs be
GetNamedTimeZoneOffsetNanoseconds(systemTimeZoneIdentifier,
ℤ(ℝ(t) × 10\ :sup:`6`)). 1. Let offsetMs be
truncate(offsetNs / 10\ :sup:`6`). 1. Return t +
𝔽(offsetMs).

If political rules for the local time t are not available within the
implementation, the result is t because SystemTimeZoneIdentifier
returns `"UTC"` and GetNamedTimeZoneOffsetNanoseconds returns 0.

It is required for time zone aware implementations (and recommended for
all others) to use the time zone information of the IANA Time Zone
Database https://www.iana.org/time-zones/.

Two different input time values t\ :sub:`UTC` are converted to the
same local time t\ :sub:`local` at a negative time zone transition when
there are repeated times (e.g. the daylight saving time ends or the time
zone adjustment is decreased.).

LocalTime(UTC(t\ :sub:`local`)) is not necessarily always equal to
t\ :sub:`local`. Correspondingly, UTC(LocalTime(t\ :sub:`UTC`))
is not necessarily always equal to t\ :sub:`UTC`.

UTC ( t: a Number, ): a time value
--------------------------------------

description
   It converts t from local time to a UTC time value. The local
   political rules for standard time and daylight saving time in effect
   at t should be used to determine the result in the way specified
   in this section.

1. If t is not finite, return `NaN`. 1. Let
systemTimeZoneIdentifier be SystemTimeZoneIdentifier(). 1. If
IsTimeZoneOffsetString(systemTimeZoneIdentifier) is `true`, then
1. Let offsetNs be
ParseTimeZoneOffsetString(systemTimeZoneIdentifier). 1. Else, 1. Let
possibleInstants be
GetNamedTimeZoneEpochNanoseconds(systemTimeZoneIdentifier,
ℝ(YearFromTime(t)), ℝ(MonthFromTime(t)) + 1,
ℝ(DateFromTime(t)), ℝ(HourFromTime(t)), ℝ(MinFromTime(t)),
ℝ(SecFromTime(t)), ℝ(msFromTime(t)), 0, 0). 1. NOTE: The
following steps ensure that when t represents local time repeating
multiple times at a negative time zone transition (e.g. when the
daylight saving time ends or the time zone offset is decreased due to a
time zone rule change) or skipped local time at a positive time zone
transition (e.g. when the daylight saving time starts or the time zone
offset is increased due to a time zone rule change), t is
interpreted using the time zone offset before the transition. 1. If
possibleInstants is not empty, then 1. Let disambiguatedInstant
be possibleInstants[0]. 1. Else, 1. NOTE: t represents a local
time skipped at a positive time zone transition (e.g. due to daylight
saving time starting or a time zone rule change increasing the UTC
offset). 1. [declared="tBefore"] Let possibleInstantsBefore be
GetNamedTimeZoneEpochNanoseconds(systemTimeZoneIdentifier,
ℝ(YearFromTime(tBefore)), ℝ(MonthFromTime(tBefore)) + 1,
ℝ(DateFromTime(tBefore)), ℝ(HourFromTime(tBefore)),
ℝ(MinFromTime(tBefore)), ℝ(SecFromTime(tBefore)),
ℝ(msFromTime(tBefore)), 0, 0), where tBefore is the largest
integral Number < t for which possibleInstantsBefore is not
empty (i.e., tBefore represents the last local time before the
transition). 1. Let disambiguatedInstant be the last element of
possibleInstantsBefore. 1. Let offsetNs be
GetNamedTimeZoneOffsetNanoseconds(systemTimeZoneIdentifier,
disambiguatedInstant). 1. Let offsetMs be truncate(offsetNs
/ 10\ :sup:`6`). 1. Return t - 𝔽(offsetMs).

Input t is nominally a time value but may be any Number value. The
algorithm must not limit t to the time value range, so that inputs
corresponding with a boundary of the time value range can be supported
regardless of local UTC offset. For example, the maximum time value is
8.64 × 10\ :sup:`15`, corresponding with `"+275760-09-13T00:00:00Z"`.
In an environment where the local time zone offset is ahead of UTC by 1
hour at that instant, it is represented by the larger input of 8.64 ×
10\ :sup:`15` + 3.6 × 10\ :sup:`6`, corresponding with
`"+275760-09-13T01:00:00+01:00"`.

If political rules for the local time t are not available within the
implementation, the result is t because SystemTimeZoneIdentifier
returns `"UTC"` and GetNamedTimeZoneOffsetNanoseconds returns 0.

It is required for time zone aware implementations (and recommended for
all others) to use the time zone information of the IANA Time Zone
Database https://www.iana.org/time-zones/.

1:30 AM on 5 November 2017 in America/New_York is repeated twice (fall
backward), but it must be interpreted as 1:30 AM UTC-04 instead of 1:30
AM UTC-05. In UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1,
30, 0, 0)))), the value of offsetMs is -4 × msPerHour.

2:30 AM on 12 March 2017 in America/New_York does not exist, but it must
be interpreted as 2:30 AM UTC-05 (equivalent to 3:30 AM UTC-04). In
UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0)))),
the value of offsetMs is -5 × msPerHour.

UTC(LocalTime(t\ :sub:`UTC`)) is not necessarily always equal to
t\ :sub:`UTC`. Correspondingly, LocalTime(UTC(t\ :sub:`local`))
is not necessarily always equal to t\ :sub:`local`.

MakeTime ( hour: a Number, min: a Number, sec: a Number, ms: a Number, ): a Number
--------------------------------------------------------------------------------------------------

description
   It calculates a number of milliseconds.

1. If hour is not finite, min is not finite, sec is not
finite, or ms is not finite, return `NaN`. 1. Let h be 𝔽(!
ToIntegerOrInfinity(hour)). 1. Let m be 𝔽(!
ToIntegerOrInfinity(min)). 1. Let s be 𝔽(!
ToIntegerOrInfinity(sec)). 1. Let milli be 𝔽(!
ToIntegerOrInfinity(ms)). 1. Return ((h × msPerHour + m ×
msPerMinute) + s × msPerSecond) + milli.

The arithmetic in MakeTime is floating-point arithmetic, which is not
associative, so the operations must be performed in the correct order.

MakeDay ( year: a Number, month: a Number, date: a Number, ): a Number
----------------------------------------------------------------------------------

description
   It calculates a number of days.

1. If year is not finite, month is not finite, or date is
not finite, return `NaN`. 1. Let y be 𝔽(!
ToIntegerOrInfinity(year)). 1. Let m be 𝔽(!
ToIntegerOrInfinity(month)). 1. Let dt be 𝔽(!
ToIntegerOrInfinity(date)). 1. Let ym be y +
𝔽(floor(ℝ(m) / 12)). 1. If ym is not finite, return `NaN`. 1.
Let mn be 𝔽(ℝ(m) modulo 12). 1. Find a finite time value t
such that YearFromTime(t) is ym, MonthFromTime(t) is mn,
and DateFromTime(t) is `1`\ :sub:`𝔽`; but if this is not possible
(because some argument is out of range), return `NaN`. 1. Return
Day(t) + dt - `1`\ :sub:`𝔽`.

MakeDate ( day: a Number, time: a Number, ): a Number
-------------------------------------------------------------

description
   It calculates a number of milliseconds.

1. If day is not finite or time is not finite, return `NaN`.
1. Let tv be day × msPerDay + time. 1. If tv is not
finite, return `NaN`. 1. Return tv.

MakeFullYear ( year: a Number, ): an integral Number or `NaN`
-------------------------------------------------------------------

description
   It returns the full year associated with the integer part of
   year, interpreting any value in the inclusive interval from 0 to
   99 as a count of years since the start of 1900. For alignment with
   the proleptic Gregorian calendar, "full year" is defined as the
   signed count of complete years since the start of year 0 (1 B.C.).

1. If year is `NaN`, return `NaN`. 1. Let truncated be !
ToIntegerOrInfinity(year). 1. If truncated is in the inclusive
interval from 0 to 99, return `1900`\ :sub:`𝔽` + 𝔽(truncated). 1.
Return 𝔽(truncated).

TimeClip ( time: a Number, ): a Number
------------------------------------------

description
   It calculates a number of milliseconds.

1. If time is not finite, return `NaN`. 1. If abs(ℝ(time)) >
8.64 × 10\ :sup:`15`, return `NaN`. 1. Return 𝔽(!
ToIntegerOrInfinity(time)).

Date Time String Format
-----------------------

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 calendar date extended format. The
format is as follows: `YYYY-MM-DDTHH:mm:ss.sssZ`

Where the elements are as follows:

.. container:: float

   +----------+----------------------------------------------------------+
   | `YYYY` | is the year in the proleptic Gregorian calendar as four  |
   |          | decimal digits from 0000 to 9999, or as an expanded year |
   |          | of `"+"` or `"-"` followed by six decimal digits.    |
   +----------+----------------------------------------------------------+
   | `-`    | `"-"` (hyphen) appears literally twice in the string.  |
   +----------+----------------------------------------------------------+
   | `MM`   | is the month of the year as two decimal digits from 01   |
   |          | (January) to 12 (December).                              |
   +----------+----------------------------------------------------------+
   | `DD`   | is the day of the month as two decimal digits from 01 to |
   |          | 31.                                                      |
   +----------+----------------------------------------------------------+
   | `T`    | `"T"` appears literally in the string, to indicate the |
   |          | beginning of the time element.                           |
   +----------+----------------------------------------------------------+
   | `HH`   | is the number of complete hours that have passed since   |
   |          | midnight as two decimal digits from 00 to 24.            |
   +----------+----------------------------------------------------------+
   | `:`    | `":"` (colon) appears literally twice in the string.   |
   +----------+----------------------------------------------------------+
   | `mm`   | is the number of complete minutes since the start of the |
   |          | hour as two decimal digits from 00 to 59.                |
   +----------+----------------------------------------------------------+
   | `ss`   | is the number of complete seconds since the start of the |
   |          | minute as two decimal digits from 00 to 59.              |
   +----------+----------------------------------------------------------+
   | `.`    | `"."` (dot) appears literally in the string.           |
   +----------+----------------------------------------------------------+
   | `sss`  | is the number of complete milliseconds since the start   |
   |          | of the second as three decimal digits.                   |
   +----------+----------------------------------------------------------+
   | `Z`    | is the UTC offset representation specified as `"Z"`    |
   |          | (for UTC with no offset) or as either `"+"` or `"-"` |
   |          | followed by a time expression `HH:mm` (a subset of the |
   |          | time zone offset string format for indicating local time |
   |          | ahead of or behind UTC, respectively)                    |
   +----------+----------------------------------------------------------+

This format includes date-only forms:

::

   YYYY
   YYYY-MM
   YYYY-MM-DD
           

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional UTC offset representation appended:

::

   THH:mm
   THH:mm:ss
   THH:mm:ss.sss
           

A string containing out-of-bounds or nonconforming elements is not a
valid instance of this format.

As every day both starts and ends with midnight, the two notations
`00:00` and `24:00` are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: `1995-02-04T24:00`
and `1995-02-05T00:00`. This interpretation of the latter form as "end
of a calendar day" is consistent with ISO 8601, even though that
specification reserves it for describing time intervals and does not
permit it within representations of single points in time.

There exists no international standard that specifies abbreviations for
civil time zones like CET, EST, etc. and sometimes the same abbreviation
is even used for two very different time zones. For this reason, both
ISO 8601 and this format specify numeric representations of time zone
offsets.

Expanded Years
--------------

Covering the full time value range of approximately 273,790 years
forward or backward from 1 January 1970 () requires representing years
before 0 or after 9999. ISO 8601 permits expansion of the year
representation, but only by mutual agreement of the partners in
information interchange. In the simplified ECMAScript format, such an
expanded year representation shall have 6 digits and is always prefixed
with a + or - sign. The year 0 is considered positive and must be
prefixed with a + sign. The representation of the year 0 as -000000 is
invalid. Strings matching the Date Time String Format with expanded
years representing instants in time outside the range of a time value
are treated as unrecognizable by `Date.parse` and cause that function
to return `NaN` without falling back to implementation-specific
behaviour or heuristics.

Examples of date-time values with expanded years:

.. container:: float

   ======================= ===========
   -271821-04-20T00:00:00Z 271822 B.C.
   -000001-01-01T00:00:00Z 2 B.C.
   +000000-01-01T00:00:00Z 1 B.C.
   +000001-01-01T00:00:00Z 1 A.D.
   +001970-01-01T00:00:00Z 1970 A.D.
   +002009-12-15T00:00:00Z 2009 A.D.
   +275760-09-13T00:00:00Z 275760 A.D.
   ======================= ===========

Time Zone Offset String Format
------------------------------

ECMAScript defines a string interchange format for UTC offsets, derived
from ISO 8601. The format is described by the following grammar.


**Syntax**


UTCOffset ::: ASCIISign Hour ASCIISign Hour HourSubcomponents[+Extended]
ASCIISign Hour HourSubcomponents[~Extended] ASCIISign ::: one of `+`
`-` Hour ::: `0` DecimalDigit `1` DecimalDigit `20` `21`
`22` `23` HourSubcomponents[Extended] ::: TimeSeparator[?Extended]
MinuteSecond TimeSeparator[?Extended] MinuteSecond
TimeSeparator[?Extended] MinuteSecond TemporalDecimalFraction?
TimeSeparator[Extended] ::: [+Extended] `:` [~Extended] [empty]
MinuteSecond ::: `0` DecimalDigit `1` DecimalDigit `2`
DecimalDigit `3` DecimalDigit `4` DecimalDigit `5` DecimalDigit
TemporalDecimalFraction ::: TemporalDecimalSeparator DecimalDigit
TemporalDecimalSeparator DecimalDigit DecimalDigit
TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
DecimalDigit TemporalDecimalSeparator DecimalDigit DecimalDigit
DecimalDigit DecimalDigit DecimalDigit TemporalDecimalSeparator
DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
DecimalDigit TemporalDecimalSeparator DecimalDigit DecimalDigit
DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
DecimalDigit TemporalDecimalSeparator ::: one of `.` `,`

IsTimeZoneOffsetString ( offsetString: a String, ): a Boolean
-----------------------------------------------------------------

description
   The return value indicates whether offsetString conforms to the
   grammar given by \|UTCOffset\|.

1. Let parseResult be ParseText(offsetString, \|UTCOffset\|). 1.
If parseResult is a List of errors, return `false`. 1. Return
`true`.

ParseTimeZoneOffsetString ( offsetString: a String, ): an integer
---------------------------------------------------------------------

description
   The return value is the UTC offset, as a number of nanoseconds, that
   corresponds to the String offsetString.

1. Let parseResult be ParseText(offsetString, \|UTCOffset\|). 1.
Assert: parseResult is not a List of errors. 1. Assert:
parseResult contains a \|ASCIISign\| Parse Node. 1. Let
parsedSign be the source text matched by the \|ASCIISign\| Parse
Node contained within parseResult. 1. If parsedSign is the
single code point U+002D (HYPHEN-MINUS), then 1. Let sign be -1. 1.
Else, 1. Let sign be 1. 1. NOTE: Applications of StringToNumber
below do not lose precision, since each of the parsed values is
guaranteed to be a sufficiently short string of decimal digits. 1.
Assert: parseResult contains an `Hour` Parse Node. 1. Let
parsedHours be the source text matched by the `Hour` Parse Node
contained within parseResult. 1. Let hours be
ℝ(StringToNumber(CodePointsToString(parsedHours))). 1. If
parseResult does not contain a `MinuteSecond` Parse Node, then 1.
Let minutes be 0. 1. Else, 1. Let parsedMinutes be the source
text matched by the first `MinuteSecond` Parse Node contained within
parseResult. 1. Let minutes be
ℝ(StringToNumber(CodePointsToString(parsedMinutes))). 1. If
parseResult does not contain two `MinuteSecond` Parse Nodes, then
1. Let seconds be 0. 1. Else, 1. Let parsedSeconds be the source
text matched by the second `MinuteSecond` Parse Node contained within
parseResult. 1. Let seconds be
ℝ(StringToNumber(CodePointsToString(parsedSeconds))). 1. If
parseResult does not contain a `TemporalDecimalFraction` Parse
Node, then 1. Let nanoseconds be 0. 1. Else, 1. Let
parsedFraction be the source text matched by the
`TemporalDecimalFraction` Parse Node contained within parseResult.
1. Let fraction be the string-concatenation of
CodePointsToString(parsedFraction) and `"000000000"`. 1. Let
nanosecondsString be the substring of fraction from 1 to 10. 1.
Let nanoseconds be ℝ(StringToNumber(nanosecondsString)). 1.
Return sign × (((hours × 60 + minutes) × 60 + seconds) ×
10\ :sup:`9` + nanoseconds).

The Date Constructor
--------------------

The Date constructor:

- is %Date%.
- is the initial value of the `"Date"` property of the global object.
- creates and initializes a new Date when called as a constructor.
- returns a String representing the current time (UTC) when called as a
  function rather than as a constructor.
- is a function whose behaviour differs based upon the number and types
  of its arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Date behaviour must include a `super` call to the Date constructor
  to create and initialize the subclass instance with a [[DateValue]]
  internal slot.

Date ( ..._values )
---------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, then 1. Let now be the time value
(UTC) identifying the current time. 1. Return ToDateString(now). 1.
Let numberOfArgs be the number of elements in values. 1. If
numberOfArgs = 0, then 1. Let dv be the time value (UTC)
identifying the current time. 1. Else if numberOfArgs = 1, then 1.
Let value be values[0]. 1. If value is an Object and
value has a [[DateValue]] internal slot, then 1. Let tv be
value.[[DateValue]]. 1. Else, 1. Let v be ?
ToPrimitive(value). 1. If v is a String, then 1. Assert: The
next step never returns an abrupt completion because v is a String.
1. Let tv be the result of parsing v as a date, in exactly the
same manner as for the `parse` method (). 1. Else, 1. Let tv be ?
ToNumber(v). 1. Let dv be TimeClip(tv). 1. Else, 1. Assert:
numberOfArgs ≥ 2. 1. Let y be ? ToNumber(values[0]). 1. Let
m be ? ToNumber(values[1]). 1. If numberOfArgs > 2, let
dt be ? ToNumber(values[2]); else let dt be `1`\ :sub:`𝔽`.
1. If numberOfArgs > 3, let h be ? ToNumber(values[3]); else
let h be `+0`\ :sub:`𝔽`. 1. If numberOfArgs > 4, let min
be ? ToNumber(values[4]); else let min be `+0`\ :sub:`𝔽`. 1.
If numberOfArgs > 5, let s be ? ToNumber(values[5]); else
let s be `+0`\ :sub:`𝔽`. 1. If numberOfArgs > 6, let milli
be ? ToNumber(values[6]); else let milli be `+0`\ :sub:`𝔽`. 1.
Let yr be MakeFullYear(y). 1. Let finalDate be
MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s,
milli)). 1. Let dv be TimeClip(UTC(finalDate)). 1. Let O
be ? OrdinaryCreateFromConstructor(NewTarget, `"%Date.prototype%"`, «
[[DateValue]] »). 1. Set O.[[DateValue]] to dv. 1. Return O.

Properties of the Date Constructor
----------------------------------

The Date constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has a `"length"` property whose value is `7`\ :sub:`𝔽`.
- has the following properties:

Date.now ( )
------------

This function returns the time value designating the UTC date and time
of the occurrence of the call to it.

Date.parse ( string )
-------------------------

This function applies the ToString operator to its argument. If ToString
results in an abrupt completion the Completion Record is immediately
returned. Otherwise, this function interprets the resulting String as a
date and time; it returns a Number, the UTC time value corresponding to
the date and time. The String may be interpreted as a local time, a UTC
time, or a time in some other time zone, depending on the contents of
the String. The function first attempts to parse the String according to
the format described in Date Time String Format (), including expanded
years. If the String does not conform to that format the function may
fall back to any implementation-specific heuristics or
implementation-specific date formats. Strings that are unrecognizable or
contain out-of-bounds format element values shall cause this function to
return `NaN`.

If the String conforms to the Date Time String Format, substitute values
take the place of absent format elements. When the `MM` or `DD`
elements are absent, `"01"` is used. When the `HH`, `mm`, or
`ss` elements are absent, `"00"` is used. When the `sss` element
is absent, `"000"` is used. When the UTC offset representation is
absent, date-only forms are interpreted as a UTC time and date-time
forms are interpreted as a local time.

If `x` is any Date whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

.. code:: javascript

             x.valueOf()
             Date.parse(x.toString())
             Date.parse(x.toUTCString())
             Date.parse(x.toISOString())
           

However, the expression

.. code:: javascript

             Date.parse(x.toLocaleString())
           

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by this function is
implementation-defined when given any String value that does not conform
to the Date Time String Format () and that could not be produced in that
implementation by the `toString` or `toUTCString` method.

Date.prototype
--------------

The initial value of `Date.prototype` is the Date prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Date.UTC ( year [ , month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ] )
---------------------------------------------------------------------------------------------------------------------

This function performs the following steps when called:

1. Let y be ? ToNumber(year). 1. If month is present, let
m be ? ToNumber(month); else let m be `+0`\ :sub:`𝔽`. 1.
If date is present, let dt be ? ToNumber(date); else let
dt be `1`\ :sub:`𝔽`. 1. If hours is present, let h be ?
ToNumber(hours); else let h be `+0`\ :sub:`𝔽`. 1. If
minutes is present, let min be ? ToNumber(minutes); else let
min be `+0`\ :sub:`𝔽`. 1. If seconds is present, let s be
? ToNumber(seconds); else let s be `+0`\ :sub:`𝔽`. 1. If
ms is present, let milli be ? ToNumber(ms); else let
milli be `+0`\ :sub:`𝔽`. 1. Let yr be MakeFullYear(y). 1.
Return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h,
min, s, milli))).

The `"length"` property of this function is `7`\ :sub:`𝔽`.

This function differs from the Date constructor in two ways: it returns
a time value as a Number, rather than creating a Date, and it interprets
the arguments in UTC rather than as local time.

Properties of the Date Prototype Object
---------------------------------------

The Date prototype object:

- is %Date.prototype%.
- is itself an ordinary object.
- is not a Date instance and does not have a [[DateValue]] internal
  slot.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

Unless explicitly defined otherwise, the methods of the Date prototype
object defined below are not generic and the `this` value passed to
them must be an object that has a [[DateValue]] internal slot that has
been initialized to a time value.

Date.prototype.constructor
--------------------------

The initial value of `Date.prototype.constructor` is %Date%.

Date.prototype.getDate ( )
--------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return DateFromTime(LocalTime(t)).

Date.prototype.getDay ( )
-------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return WeekDay(LocalTime(t)).

Date.prototype.getFullYear ( )
------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return YearFromTime(LocalTime(t)).

Date.prototype.getHours ( )
---------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return HourFromTime(LocalTime(t)).

Date.prototype.getMilliseconds ( )
----------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return msFromTime(LocalTime(t)).

Date.prototype.getMinutes ( )
-----------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return MinFromTime(LocalTime(t)).

Date.prototype.getMonth ( )
---------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return MonthFromTime(LocalTime(t)).

Date.prototype.getSeconds ( )
-----------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return SecFromTime(LocalTime(t)).

Date.prototype.getTime ( )
--------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Return
dateObject.[[DateValue]].

Date.prototype.getTimezoneOffset ( )
------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return (t - LocalTime(t)) / msPerMinute.

Date.prototype.getUTCDate ( )
-----------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return DateFromTime(t).

Date.prototype.getUTCDay ( )
----------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return WeekDay(t).

Date.prototype.getUTCFullYear ( )
---------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return YearFromTime(t).

Date.prototype.getUTCHours ( )
------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return HourFromTime(t).

Date.prototype.getUTCMilliseconds ( )
-------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return msFromTime(t).

Date.prototype.getUTCMinutes ( )
--------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return MinFromTime(t).

Date.prototype.getUTCMonth ( )
------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return MonthFromTime(t).

Date.prototype.getUTCSeconds ( )
--------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return SecFromTime(t).

Date.prototype.setDate ( date )
-----------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let dt be ? ToNumber(date). 1.
If t is `NaN`, return `NaN`. 1. Set t to LocalTime(t).
1. Let newDate be MakeDate(MakeDay(YearFromTime(t),
MonthFromTime(t), dt), TimeWithinDay(t)). 1. Let u be
TimeClip(UTC(newDate)). 1. Set dateObject.[[DateValue]] to
u. 1. Return u.

Date.prototype.setFullYear ( year [ , month [ , date ] ] )
----------------------------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let y be ? ToNumber(year). 1.
If t is `NaN`, set t to `+0`\ :sub:`𝔽`; otherwise, set t
to LocalTime(t). 1. If month is not present, let m be
MonthFromTime(t); otherwise, let m be ? ToNumber(month). 1.
If date is not present, let dt be DateFromTime(t);
otherwise, let dt be ? ToNumber(date). 1. Let newDate be
MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)). 1. Let
u be TimeClip(UTC(newDate)). 1. Set dateObject.[[DateValue]]
to u. 1. Return u.

The `"length"` property of this method is `3`\ :sub:`𝔽`.

If month is not present, this method behaves as if month was
present with the value `getMonth()`. If date is not present, it
behaves as if date was present with the value `getDate()`.

Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
-----------------------------------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let h be ? ToNumber(hour). 1.
If min is present, let m be ? ToNumber(min). 1. If sec
is present, let s be ? ToNumber(sec). 1. If ms is present,
let milli be ? ToNumber(ms). 1. If t is `NaN`, return
`NaN`. 1. Set t to LocalTime(t). 1. If min is not present,
let m be MinFromTime(t). 1. If sec is not present, let s
be SecFromTime(t). 1. If ms is not present, let milli be
msFromTime(t). 1. Let date be MakeDate(Day(t),
MakeTime(h, m, s, milli)). 1. Let u be
TimeClip(UTC(date)). 1. Set dateObject.[[DateValue]] to u.
1. Return u.

The `"length"` property of this method is `4`\ :sub:`𝔽`.

If min is not present, this method behaves as if min was present
with the value `getMinutes()`. If sec is not present, it behaves
as if sec was present with the value `getSeconds()`. If ms is
not present, it behaves as if ms was present with the value
`getMilliseconds()`.

Date.prototype.setMilliseconds ( ms )
-----------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Set ms to ? ToNumber(ms). 1. If
t is `NaN`, return `NaN`. 1. Set t to LocalTime(t). 1.
Let time be MakeTime(HourFromTime(t), MinFromTime(t),
SecFromTime(t), ms). 1. Let u be
TimeClip(UTC(MakeDate(Day(t), time))). 1. Set
dateObject.[[DateValue]] to u. 1. Return u.

Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
----------------------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let m be ? ToNumber(min). 1. If
sec is present, let s be ? ToNumber(sec). 1. If ms is
present, let milli be ? ToNumber(ms). 1. If t is `NaN`,
return `NaN`. 1. Set t to LocalTime(t). 1. If sec is not
present, let s be SecFromTime(t). 1. If ms is not present,
let milli be msFromTime(t). 1. Let date be
MakeDate(Day(t), MakeTime(HourFromTime(t), m, s,
milli)). 1. Let u be TimeClip(UTC(date)). 1. Set
dateObject.[[DateValue]] to u. 1. Return u.

The `"length"` property of this method is `3`\ :sub:`𝔽`.

If sec is not present, this method behaves as if sec was present
with the value `getSeconds()`. If ms is not present, this behaves
as if ms was present with the value `getMilliseconds()`.

Date.prototype.setMonth ( month [ , date ] )
----------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let m be ? ToNumber(month). 1.
If date is present, let dt be ? ToNumber(date). 1. If t
is `NaN`, return `NaN`. 1. Set t to LocalTime(t). 1. If
date is not present, let dt be DateFromTime(t). 1. Let
newDate be MakeDate(MakeDay(YearFromTime(t), m, dt),
TimeWithinDay(t)). 1. Let u be TimeClip(UTC(newDate)). 1.
Set dateObject.[[DateValue]] to u. 1. Return u.

The `"length"` property of this method is `2`\ :sub:`𝔽`.

If date is not present, this method behaves as if date was
present with the value `getDate()`.

Date.prototype.setSeconds ( sec [ , ms ] )
--------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let s be ? ToNumber(sec). 1. If
ms is present, let milli be ? ToNumber(ms). 1. If t is
`NaN`, return `NaN`. 1. Set t to LocalTime(t). 1. If ms
is not present, let milli be msFromTime(t). 1. Let date be
MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t),
s, milli)). 1. Let u be TimeClip(UTC(date)). 1. Set
dateObject.[[DateValue]] to u. 1. Return u.

The `"length"` property of this method is `2`\ :sub:`𝔽`.

If ms is not present, this method behaves as if ms was present
with the value `getMilliseconds()`.

Date.prototype.setTime ( time )
-----------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be ?
ToNumber(time). 1. Let v be TimeClip(t). 1. Set
dateObject.[[DateValue]] to v. 1. Return v.

Date.prototype.setUTCDate ( date )
--------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let dt be ? ToNumber(date). 1.
If t is `NaN`, return `NaN`. 1. Let newDate be
MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt),
TimeWithinDay(t)). 1. Let v be TimeClip(newDate). 1. Set
dateObject.[[DateValue]] to v. 1. Return v.

Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
-------------------------------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, set t to
`+0`\ :sub:`𝔽`. 1. Let y be ? ToNumber(year). 1. If month
is not present, let m be MonthFromTime(t); otherwise, let m
be ? ToNumber(month). 1. If date is not present, let dt be
DateFromTime(t); otherwise, let dt be ? ToNumber(date). 1.
Let newDate be MakeDate(MakeDay(y, m, dt),
TimeWithinDay(t)). 1. Let v be TimeClip(newDate). 1. Set
dateObject.[[DateValue]] to v. 1. Return v.

The `"length"` property of this method is `3`\ :sub:`𝔽`.

If month is not present, this method behaves as if month was
present with the value `getUTCMonth()`. If date is not present, it
behaves as if date was present with the value `getUTCDate()`.

Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
--------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let h be ? ToNumber(hour). 1.
If min is present, let m be ? ToNumber(min). 1. If sec
is present, let s be ? ToNumber(sec). 1. If ms is present,
let milli be ? ToNumber(ms). 1. If t is `NaN`, return
`NaN`. 1. If min is not present, let m be MinFromTime(t).
1. If sec is not present, let s be SecFromTime(t). 1. If
ms is not present, let milli be msFromTime(t). 1. Let
date be MakeDate(Day(t), MakeTime(h, m, s,
milli)). 1. Let v be TimeClip(date). 1. Set
dateObject.[[DateValue]] to v. 1. Return v.

The `"length"` property of this method is `4`\ :sub:`𝔽`.

If min is not present, this method behaves as if min was present
with the value `getUTCMinutes()`. If sec is not present, it
behaves as if sec was present with the value `getUTCSeconds()`. If
ms is not present, it behaves as if ms was present with the
value `getUTCMilliseconds()`.

Date.prototype.setUTCMilliseconds ( ms )
--------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Set ms to ? ToNumber(ms). 1. If
t is `NaN`, return `NaN`. 1. Let time be
MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t),
ms). 1. Let v be TimeClip(MakeDate(Day(t), time)). 1.
Set dateObject.[[DateValue]] to v. 1. Return v.

Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] )
-------------------------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let m be ? ToNumber(min). 1. If
sec is present, let s be ? ToNumber(sec). 1. If ms is
present, let milli be ? ToNumber(ms). 1. If t is `NaN`,
return `NaN`. 1. If sec is not present, let s be
SecFromTime(t). 1. If ms is not present, let milli be
msFromTime(t). 1. Let date be MakeDate(Day(t),
MakeTime(HourFromTime(t), m, s, milli)). 1. Let v be
TimeClip(date). 1. Set dateObject.[[DateValue]] to v. 1.
Return v.

The `"length"` property of this method is `3`\ :sub:`𝔽`.

If sec is not present, this method behaves as if sec was present
with the value `getUTCSeconds()`. If ms is not present, it behaves
as if ms was present with the value return by
`getUTCMilliseconds()`.

Date.prototype.setUTCMonth ( month [ , date ] )
-------------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let m be ? ToNumber(month). 1.
If date is present, let dt be ? ToNumber(date). 1. If t
is `NaN`, return `NaN`. 1. If date is not present, let dt be
DateFromTime(t). 1. Let newDate be
MakeDate(MakeDay(YearFromTime(t), m, dt),
TimeWithinDay(t)). 1. Let v be TimeClip(newDate). 1. Set
dateObject.[[DateValue]] to v. 1. Return v.

The `"length"` property of this method is `2`\ :sub:`𝔽`.

If date is not present, this method behaves as if date was
present with the value `getUTCDate()`.

Date.prototype.setUTCSeconds ( sec [ , ms ] )
-----------------------------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let s be ? ToNumber(sec). 1. If
ms is present, let milli be ? ToNumber(ms). 1. If t is
`NaN`, return `NaN`. 1. If ms is not present, let milli be
msFromTime(t). 1. Let date be MakeDate(Day(t),
MakeTime(HourFromTime(t), MinFromTime(t), s, milli)). 1.
Let v be TimeClip(date). 1. Set dateObject.[[DateValue]] to
v. 1. Return v.

The `"length"` property of this method is `2`\ :sub:`𝔽`.

If ms is not present, this method behaves as if ms was present
with the value `getUTCMilliseconds()`.

Date.prototype.toDateString ( )
-------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let tv be
dateObject.[[DateValue]]. 1. If tv is `NaN`, return `"Invalid
Date"`. 1. Let t be LocalTime(tv). 1. Return DateString(t).

Date.prototype.toISOString ( )
------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let tv be
dateObject.[[DateValue]]. 1. If tv is `NaN`, throw a
`RangeError` exception. 1. Assert: tv is an integral Number. 1. If
tv corresponds with a year that cannot be represented in the Date
Time String Format, throw a `RangeError` exception. 1. Return a String
representation of tv in the Date Time String Format on the UTC time
scale, including all format elements and the UTC offset representation
`"Z"`.

Date.prototype.toJSON ( key )
---------------------------------

This method provides a String representation of a Date for use by
`JSON.stringify` ().

It performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let tv be ?
ToPrimitive(O, ~number~). 1. If tv is a Number and tv is not
finite, return `null`. 1. Return ? Invoke(O, `"toISOString"`).

The argument is ignored.

This method is intentionally generic; it does not require that its
`this` value be a Date. Therefore, it can be transferred to other
kinds of objects for use as a method. However, it does require that any
such object have a `toISOString` method.

Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )
---------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method returns a String value. The contents of the String are
implementation-defined, but are intended to represent the “date” portion
of the Date in the current time zone in a convenient, human-readable
form that corresponds to the conventions of the host environment's
current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
-----------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method returns a String value. The contents of the String are
implementation-defined, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment's current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )
---------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method returns a String value. The contents of the String are
implementation-defined, but are intended to represent the “time” portion
of the Date in the current time zone in a convenient, human-readable
form that corresponds to the conventions of the host environment's
current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

Date.prototype.toString ( )
---------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let tv be
dateObject.[[DateValue]]. 1. Return ToDateString(tv).

For any Date `d` such that `d.[[DateValue]]` is evenly divisible by
1000, the result of `Date.parse(d.toString())` = `d.valueOf()`. See
.

This method is not generic; it throws a `TypeError` exception if its
`this` value is not a Date. Therefore, it cannot be transferred to
other kinds of objects for use as a method.

TimeString ( tv: a Number, but not `NaN`, ): a String
-----------------------------------------------------------

1. Let hour be ToZeroPaddedDecimalString(ℝ(HourFromTime(tv)),
2). 1. Let minute be
ToZeroPaddedDecimalString(ℝ(MinFromTime(tv)), 2). 1. Let second
be ToZeroPaddedDecimalString(ℝ(SecFromTime(tv)), 2). 1. Return the
string-concatenation of hour, `":"`, minute, `":"`,
second, the code unit 0x0020 (SPACE), and `"GMT"`.

DateString ( tv: a Number, but not `NaN`, ): a String
-----------------------------------------------------------

1. Let weekday be the Name of the entry in with the Number
WeekDay(tv). 1. Let month be the Name of the entry in with the
Number MonthFromTime(tv). 1. Let day be
ToZeroPaddedDecimalString(ℝ(DateFromTime(tv)), 2). 1. Let yv be
YearFromTime(tv). 1. If yv is `+0`\ :sub:`𝔽` or yv >
`+0`\ :sub:`𝔽`, let yearSign be the empty String; otherwise, let
yearSign be `"-"`. 1. Let paddedYear be
ToZeroPaddedDecimalString(abs(ℝ(yv)), 4). 1. Return the
string-concatenation of weekday, the code unit 0x0020 (SPACE),
month, the code unit 0x0020 (SPACE), day, the code unit 0x0020
(SPACE), yearSign, and paddedYear.

================ =========
Number           Name
================ =========
`+0`\ :sub:`𝔽` `"Sun"`
`1`\ :sub:`𝔽`  `"Mon"`
`2`\ :sub:`𝔽`  `"Tue"`
`3`\ :sub:`𝔽`  `"Wed"`
`4`\ :sub:`𝔽`  `"Thu"`
`5`\ :sub:`𝔽`  `"Fri"`
`6`\ :sub:`𝔽`  `"Sat"`
================ =========

================ =========
Number           Name
================ =========
`+0`\ :sub:`𝔽` `"Jan"`
`1`\ :sub:`𝔽`  `"Feb"`
`2`\ :sub:`𝔽`  `"Mar"`
`3`\ :sub:`𝔽`  `"Apr"`
`4`\ :sub:`𝔽`  `"May"`
`5`\ :sub:`𝔽`  `"Jun"`
`6`\ :sub:`𝔽`  `"Jul"`
`7`\ :sub:`𝔽`  `"Aug"`
`8`\ :sub:`𝔽`  `"Sep"`
`9`\ :sub:`𝔽`  `"Oct"`
`10`\ :sub:`𝔽` `"Nov"`
`11`\ :sub:`𝔽` `"Dec"`
================ =========

TimeZoneString ( tv: an integral Number, ): a String
--------------------------------------------------------

1. Let systemTimeZoneIdentifier be SystemTimeZoneIdentifier(). 1. If
IsTimeZoneOffsetString(systemTimeZoneIdentifier) is `true`, then
1. Let offsetNs be
ParseTimeZoneOffsetString(systemTimeZoneIdentifier). 1. Else, 1. Let
offsetNs be
GetNamedTimeZoneOffsetNanoseconds(systemTimeZoneIdentifier,
ℤ(ℝ(tv) × 10\ :sup:`6`)). 1. Let offset be
𝔽(truncate(offsetNs / 10\ :sup:`6`)). 1. If offset is
`+0`\ :sub:`𝔽` or offset > `+0`\ :sub:`𝔽`, then 1. Let
offsetSign be `"+"`. 1. Let absOffset be offset. 1. Else,
1. Let offsetSign be `"-"`. 1. Let absOffset be -offset.
1. Let offsetMin be
ToZeroPaddedDecimalString(ℝ(MinFromTime(absOffset)), 2). 1. Let
offsetHour be
ToZeroPaddedDecimalString(ℝ(HourFromTime(absOffset)), 2). 1. Let
tzName be an implementation-defined string that is either the empty
String or the string-concatenation of the code unit 0x0020 (SPACE), the
code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone
name, and the code unit 0x0029 (RIGHT PARENTHESIS). 1. Return the
string-concatenation of offsetSign, offsetHour, offsetMin,
and tzName.

ToDateString ( tv: an integral Number or `NaN`, ): a String
-----------------------------------------------------------------

1. If tv is `NaN`, return `"Invalid Date"`. 1. Let t be
LocalTime(tv). 1. Return the string-concatenation of
DateString(t), the code unit 0x0020 (SPACE), TimeString(t), and
TimeZoneString(tv).

Date.prototype.toTimeString ( )
-------------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let tv be
dateObject.[[DateValue]]. 1. If tv is `NaN`, return `"Invalid
Date"`. 1. Let t be LocalTime(tv). 1. Return the
string-concatenation of TimeString(t) and TimeZoneString(tv).

Date.prototype.toUTCString ( )
------------------------------

This method returns a String value representing the instant in time
corresponding to the `this` value. The format of the String is based
upon "HTTP-date" from RFC 7231, generalized to support the full range of
times supported by ECMAScript Dates.

It performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let tv be
dateObject.[[DateValue]]. 1. If tv is `NaN`, return `"Invalid
Date"`. 1. Let weekday be the Name of the entry in with the Number
WeekDay(tv). 1. Let month be the Name of the entry in with the
Number MonthFromTime(tv). 1. Let day be
ToZeroPaddedDecimalString(ℝ(DateFromTime(tv)), 2). 1. Let yv be
YearFromTime(tv). 1. If yv is `+0`\ :sub:`𝔽` or yv >
`+0`\ :sub:`𝔽`, let yearSign be the empty String; otherwise, let
yearSign be `"-"`. 1. Let paddedYear be
ToZeroPaddedDecimalString(abs(ℝ(yv)), 4). 1. Return the
string-concatenation of weekday, `","`, the code unit 0x0020
(SPACE), day, the code unit 0x0020 (SPACE), month, the code unit
0x0020 (SPACE), yearSign, paddedYear, the code unit 0x0020
(SPACE), and TimeString(tv).

Date.prototype.valueOf ( )
--------------------------

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Return
dateObject.[[DateValue]].

Date.prototype [ %Symbol.toPrimitive% ] ( hint )
----------------------------------------------------

This method is called by ECMAScript language operators to convert a Date
to a primitive value. The allowed values for hint are `"default"`,
`"number"`, and `"string"`. Dates are unique among built-in
ECMAScript object in that they treat `"default"` as being equivalent
to `"string"`, All other built-in ECMAScript objects treat
`"default"` as being equivalent to `"number"`.

It performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If hint is either `"string"` or
`"default"`, then 1. Let tryFirst be ~string~. 1. Else if hint
is `"number"`, then 1. Let tryFirst be ~number~. 1. Else, 1. Throw
a `TypeError` exception. 1. Return ? OrdinaryToPrimitive(O,
tryFirst).

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

The value of the `"name"` property of this method is
`"[Symbol.toPrimitive]"`.

Properties of Date Instances
----------------------------

Date instances are ordinary objects that inherit properties from the
Date prototype object. Date instances also have a [[DateValue]] internal
slot. The [[DateValue]] internal slot is the time value represented by
this Date.

22. Text Processing
===================

https://tc39.es/ecma262/multipage/text-processing.html
::

   22.1 String Objects
       22.1.1 The String Constructor
         22.1.1.1 String ( value )
       22.1.2 Properties of the String Constructor
         22.1.2.1 String.fromCharCode ( ...codeUnits )
         22.1.2.2 String.fromCodePoint ( ...codePoints )
       22.1.2.3 String.prototype
         22.1.2.4 String.raw ( template, ... substitutions )
       22.1.3 Properties of the String Prototype Object
         22.1.3.1 String.prototype.at ( index )
         22.1.3.2 String.prototype.charAt ( pos )
         22.1.3.3 String.prototype.charCodeAt ( pos )
         22.1.3.4 String.prototype.codePointAt ( pos )
         22.1.3.5 String.prototype.concat ( ...args )
       22.1.3.6 String.prototype.constructor
         22.1.3.7 String.prototype.endsWith ( searchString [ , endPosition ] )
         22.1.3.8 String.prototype.includes ( searchString [ , position ] )
         22.1.3.9 String.prototype.indexOf ( searchString [ , position ] )
       22.1.3.10 String.prototype.isWellFormed ( )
         22.1.3.11 String.prototype.lastIndexOf ( searchString [ , position ] )
         22.1.3.12 String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )
         22.1.3.13 String.prototype.match ( regexp )
         22.1.3.14 String.prototype.matchAll ( regexp )
         22.1.3.15 String.prototype.normalize ( [ form ] )
         22.1.3.16 String.prototype.padEnd ( maxLength [ , fillString ] )
           22.1.3.17 String.prototype.padStart ( maxLength [ , fillString ] )
             22.1.3.17.1 StringPaddingBuiltinsImpl ( O, maxLength, fillString, placement )
             22.1.3.17.2 StringPad ( S, maxLength, fillString, placement )
             22.1.3.17.3 ToZeroPaddedDecimalString ( n, minLength )
         22.1.3.18 String.prototype.repeat ( count )
           22.1.3.19 String.prototype.replace ( searchValue, replaceValue )
             22.1.3.19.1 GetSubstitution ( matched, str, position, captures, namedCaptures, replacementTemplate )
         22.1.3.20 String.prototype.replaceAll ( searchValue, replaceValue )
         22.1.3.21 String.prototype.search ( regexp )
         22.1.3.22 String.prototype.slice ( start, end )
         22.1.3.23 String.prototype.split ( separator, limit )
         22.1.3.24 String.prototype.startsWith ( searchString [ , position ] )
         22.1.3.25 String.prototype.substring ( start, end )
         22.1.3.26 String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] )
         22.1.3.27 String.prototype.toLocaleUpperCase ( [ reserved1 [ , reserved2 ] ] )
       22.1.3.28 String.prototype.toLowerCase ( )
       22.1.3.29 String.prototype.toString ( )
       22.1.3.30 String.prototype.toUpperCase ( )
       22.1.3.31 String.prototype.toWellFormed ( )
           22.1.3.32 String.prototype.trim ( )
             22.1.3.32.1 TrimString ( string, where )
       22.1.3.33 String.prototype.trimEnd ( )
       22.1.3.34 String.prototype.trimStart ( )
           22.1.3.35 String.prototype.valueOf ( )
             22.1.3.35.1 ThisStringValue ( value )
       22.1.3.36 String.prototype [ %Symbol.iterator% ] ( )
       22.1.4 Properties of String Instances
       22.1.4.1 length
       22.1.5 String Iterator Objects
           22.1.5.1 The %StringIteratorPrototype% Object
           22.1.5.1.1 %StringIteratorPrototype%.next ( )
             22.1.5.1.2 %StringIteratorPrototype% [ %Symbol.toStringTag% ]
   22.2 RegExp (Regular Expression) Objects
       22.2.1 Patterns
       22.2.1.1 SS: Early Errors
         22.2.1.2 SS: CountLeftCapturingParensWithin ( node )
         22.2.1.3 SS: CountLeftCapturingParensBefore ( node )
         22.2.1.4 SS: MightBothParticipate ( x, y )
       22.2.1.5 SS: CapturingGroupNumber
       22.2.1.6 SS: IsCharacterClass
       22.2.1.7 SS: CharacterValue
       22.2.1.8 SS: MayContainStrings
         22.2.1.9 SS: GroupSpecifiersThatMatch ( thisGroupName )
       22.2.1.10 SS: CapturingGroupName
       22.2.1.11 SS: RegExpIdentifierCodePoints
       22.2.1.12 SS: RegExpIdentifierCodePoint
       22.2.2 Pattern Semantics
           22.2.2.1 Notation
           22.2.2.1.1 RegExp Records
       22.2.2.2 RS: CompilePattern
           22.2.2.3 RS: CompileSubpattern
             22.2.2.3.1 RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )
           22.2.2.3.2 EmptyMatcher ( )
             22.2.2.3.3 MatchTwoAlternatives ( m1, m2 )
             22.2.2.3.4 MatchSequence ( m1, m2, direction )
           22.2.2.4 RS: CompileAssertion
             22.2.2.4.1 IsWordChar ( rer, Input, e )
       22.2.2.5 RS: CompileQuantifier
       22.2.2.6 RS: CompileQuantifierPrefix
           22.2.2.7 RS: CompileAtom
             22.2.2.7.1 CharacterSetMatcher ( rer, A, invert, direction )
             22.2.2.7.2 BackreferenceMatcher ( rer, ns, direction )
             22.2.2.7.3 Canonicalize ( rer, ch )
       22.2.2.8 RS: CompileCharacterClass
           22.2.2.9 RS: CompileToCharSet
             22.2.2.9.1 CharacterRange ( A, B )
             22.2.2.9.2 HasEitherUnicodeFlag ( rer )
             22.2.2.9.3 WordCharacters ( rer )
             22.2.2.9.4 AllCharacters ( rer )
             22.2.2.9.5 MaybeSimpleCaseFolding ( rer, A )
             22.2.2.9.6 CharacterComplement ( rer, S )
             22.2.2.9.7 UnicodeMatchProperty ( rer, p )
             22.2.2.9.8 UnicodeMatchPropertyValue ( p, v )
       22.2.2.10 RS: CompileClassSetString
       22.2.3 Abstract Operations for RegExp Creation
         22.2.3.1 RegExpCreate ( P, F )
         22.2.3.2 RegExpAlloc ( newTarget )
         22.2.3.3 RegExpInitialize ( obj, pattern, flags )
         22.2.3.4 SS: ParsePattern ( patternText, u, v )
       22.2.4 The RegExp Constructor
         22.2.4.1 RegExp ( pattern, flags )
       22.2.5 Properties of the RegExp Constructor
       22.2.5.1 RegExp.prototype
       22.2.5.2 get RegExp [ %Symbol.species% ]
       22.2.6 Properties of the RegExp Prototype Object
       22.2.6.1 RegExp.prototype.constructor
         22.2.6.2 RegExp.prototype.exec ( string )
       22.2.6.3 get RegExp.prototype.dotAll
           22.2.6.4 get RegExp.prototype.flags
             22.2.6.4.1 RegExpHasFlag ( R, codeUnit )
       22.2.6.5 get RegExp.prototype.global
       22.2.6.6 get RegExp.prototype.hasIndices
       22.2.6.7 get RegExp.prototype.ignoreCase
         22.2.6.8 RegExp.prototype [ %Symbol.match% ] ( string )
         22.2.6.9 RegExp.prototype [ %Symbol.matchAll% ] ( string )
       22.2.6.10 get RegExp.prototype.multiline
         22.2.6.11 RegExp.prototype [ %Symbol.replace% ] ( string, replaceValue )
         22.2.6.12 RegExp.prototype [ %Symbol.search% ] ( string )
           22.2.6.13 get RegExp.prototype.source
             22.2.6.13.1 EscapeRegExpPattern ( P, F )
         22.2.6.14 RegExp.prototype [ %Symbol.split% ] ( string, limit )
       22.2.6.15 get RegExp.prototype.sticky
         22.2.6.16 RegExp.prototype.test ( S )
       22.2.6.17 RegExp.prototype.toString ( )
       22.2.6.18 get RegExp.prototype.unicode
       22.2.6.19 get RegExp.prototype.unicodeSets
       22.2.7 Abstract Operations for RegExp Matching
         22.2.7.1 RegExpExec ( R, S )
         22.2.7.2 RegExpBuiltinExec ( R, S )
         22.2.7.3 AdvanceStringIndex ( S, index, unicode )
         22.2.7.4 GetStringIndex ( S, codePointIndex )
       22.2.7.5 Match Records
         22.2.7.6 GetMatchString ( S, match )
         22.2.7.7 GetMatchIndexPair ( S, match )
         22.2.7.8 MakeMatchIndicesIndexPairArray ( S, indices, groupNames, hasGroups )
       22.2.8 Properties of RegExp Instances
       22.2.8.1 lastIndex
       22.2.9 RegExp String Iterator Objects
         22.2.9.1 CreateRegExpStringIterator ( R, S, global, fullUnicode )
           22.2.9.2 The %RegExpStringIteratorPrototype% Object
           22.2.9.2.1 %RegExpStringIteratorPrototype%.next ( )
             22.2.9.2.2 %RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]


String Objects
--------------

The String Constructor
----------------------

The String constructor:

- is %String%.
- is the initial value of the `"String"` property of the global
  object.
- creates and initializes a new String object when called as a
  constructor.
- performs a type conversion when called as a function rather than as a
  constructor.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  String behaviour must include a `super` call to the String
  constructor to create and initialize the subclass instance with a
  [[StringData]] internal slot.

String ( value )
--------------------

This function performs the following steps when called:

1. If value is not present, then 1. Let s be the empty String.
1. Else, 1. If NewTarget is `undefined` and value is a Symbol,
return SymbolDescriptiveString(value). 1. Let s be ?
ToString(value). 1. If NewTarget is `undefined`, return s. 1.
Return StringCreate(s, ? GetPrototypeFromConstructor(NewTarget,
`"%String.prototype%"`)).

Properties of the String Constructor
------------------------------------

The String constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

String.fromCharCode ( ..._codeUnits )
---------------------------------------

This function may be called with any number of arguments which form the
rest parameter codeUnits.

It performs the following steps when called:

1. Let result be the empty String. 1. For each element next of
codeUnits, do 1. Let nextCU be the code unit whose numeric value
is ℝ(? ToUint16(next)). 1. Set result to the
string-concatenation of result and nextCU. 1. Return result.

The `"length"` property of this function is `1`\ :sub:`𝔽`.

String.fromCodePoint ( ..._codePoints )
-----------------------------------------

This function may be called with any number of arguments which form the
rest parameter codePoints.

It performs the following steps when called:

1. Let result be the empty String. 1. For each element next of
codePoints, do 1. Let nextCP be ? ToNumber(next). 1. If
nextCP is not an integral Number, throw a `RangeError` exception.
1. If ℝ(nextCP) < 0 or ℝ(nextCP) > 0x10FFFF, throw a
`RangeError` exception. 1. Set result to the string-concatenation
of result and UTF16EncodeCodePoint(ℝ(nextCP)). 1. Assert: If
codePoints is empty, then result is the empty String. 1. Return
result.

The `"length"` property of this function is `1`\ :sub:`𝔽`.

String.prototype
----------------

The initial value of `String.prototype` is the String prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

String.raw ( template, ..._substitutions )
------------------------------------------------

This function may be called with a variable number of arguments. The
first argument is template and the remainder of the arguments form
the List substitutions.

It performs the following steps when called:

1. Let substitutionCount be the number of elements in
substitutions. 1. Let cooked be ? ToObject(template). 1. Let
literals be ? ToObject(? Get(cooked, `"raw"`)). 1. Let
literalCount be ? LengthOfArrayLike(literals). 1. If
literalCount ≤ 0, return the empty String. 1. Let R be the empty
String. 1. Let nextIndex be 0. 1. Repeat, 1. Let nextLiteralVal
be ? Get(literals, ! ToString(𝔽(nextIndex))). 1. Let
nextLiteral be ? ToString(nextLiteralVal). 1. Set R to the
string-concatenation of R and nextLiteral. 1. If nextIndex +
1 = literalCount, return R. 1. If nextIndex <
substitutionCount, then 1. Let nextSubVal be
substitutions[nextIndex]. 1. Let nextSub be ?
ToString(nextSubVal). 1. Set R to the string-concatenation of
R and nextSub. 1. Set nextIndex to nextIndex + 1.

This function is intended for use as a tag function of a Tagged Template
(). When called as such, the first argument will be a well formed
template object and the rest parameter will contain the substitution
values.

Properties of the String Prototype Object
-----------------------------------------

The String prototype object:

- is %String.prototype%.
- is a String exotic object and has the internal methods specified for
  such objects.
- has a [[StringData]] internal slot whose value is the empty String.
- has a `"length"` property whose initial value is `+0`\ :sub:`𝔽`
  and whose attributes are { [[Writable]]: `false`, [[Enumerable]]:
  `false`, [[Configurable]]: `false` }.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

Unless explicitly stated otherwise, the methods of the String prototype
object defined below are not generic and the `this` value passed to
them must be either a String value or an object that has a
[[StringData]] internal slot that has been initialized to a String
value.

String.prototype.at ( index )
---------------------------------

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let len be the length of S. 1. Let
relativeIndex be ? ToIntegerOrInfinity(index). 1. If
relativeIndex ≥ 0, then 1. Let k be relativeIndex. 1. Else,
1. Let k be len + relativeIndex. 1. If k < 0 or k ≥
len, return `undefined`. 1. Return the substring of S from
k to k + 1.

String.prototype.charAt ( pos )
-----------------------------------

This method returns a single element String containing the code unit at
index pos within the String value resulting from converting this
object to a String. If there is no element at that index, the result is
the empty String. The result is a String value, not a String object.

If `pos` is an integral Number, then the result of `x.charAt(pos)`
is equivalent to the result of `x.substring(pos, pos + 1)`.

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let position be ?
ToIntegerOrInfinity(pos). 1. Let size be the length of S. 1.
If position < 0 or position ≥ size, return the empty String.
1. Return the substring of S from position to position + 1.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.charCodeAt ( pos )
---------------------------------------

This method returns a Number (a non-negative integral Number less than
2\ :sup:`16`) that is the numeric value of the code unit at index
pos within the String resulting from converting this object to a
String. If there is no element at that index, the result is `NaN`.

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let position be ?
ToIntegerOrInfinity(pos). 1. Let size be the length of S. 1.
If position < 0 or position ≥ size, return `NaN`. 1.
Return the Number value for the numeric value of the code unit at index
position within the String S.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore it can be transferred to
other kinds of objects for use as a method.

String.prototype.codePointAt ( pos )
----------------------------------------

This method returns a non-negative integral Number less than or equal to
`0x10FFFF`\ :sub:`𝔽` that is the numeric value of the UTF-16 encoded
code point () starting at the string element at index pos within the
String resulting from converting this object to a String. If there is no
element at that index, the result is `undefined`. If a valid UTF-16
surrogate pair does not begin at pos, the result is the code unit at
pos.

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let position be ?
ToIntegerOrInfinity(pos). 1. Let size be the length of S. 1.
If position < 0 or position ≥ size, return `undefined`. 1.
Let cp be CodePointAt(S, position). 1. Return
𝔽(cp.[[CodePoint]]).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore it can be transferred to
other kinds of objects for use as a method.

String.prototype.concat ( ..._args )
--------------------------------------

When this method is called it returns the String value consisting of the
code units of the `this` value (converted to a String) followed by the
code units of each of the arguments converted to a String. The result is
a String value, not a String object.

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let R be S. 1. For each element
next of args, do 1. Let nextString be ? ToString(next).
1. Set R to the string-concatenation of R and nextString. 1.
Return R.

The `"length"` property of this method is `1`\ :sub:`𝔽`.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore it can be transferred to
other kinds of objects for use as a method.

String.prototype.constructor
----------------------------

The initial value of `String.prototype.constructor` is %String%.

String.prototype.endsWith ( searchString [ , endPosition ] )
--------------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let isRegExp be ?
IsRegExp(searchString). 1. If isRegExp is `true`, throw a
`TypeError` exception. 1. Let searchStr be ?
ToString(searchString). 1. Let len be the length of S. 1. If
endPosition is `undefined`, let pos be len; else let
pos be ? ToIntegerOrInfinity(endPosition). 1. Let end be the
result of clamping pos between 0 and len. 1. Let
searchLength be the length of searchStr. 1. If searchLength
= 0, return `true`. 1. Let start be end - searchLength. 1.
If start < 0, return `false`. 1. Let substring be the
substring of S from start to end. 1. If substring is
searchStr, return `true`. 1. Return `false`.

This method returns `true` if the sequence of code units of
searchString converted to a String is the same as the corresponding
code units of this object (converted to a String) starting at
endPosition - length(this). Otherwise it returns `false`.

Throwing an exception if the first argument is a RegExp is specified in
order to allow future editions to define extensions that allow such
argument values.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.includes ( searchString [ , position ] )
-----------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let isRegExp be ?
IsRegExp(searchString). 1. If isRegExp is `true`, throw a
`TypeError` exception. 1. Let searchStr be ?
ToString(searchString). 1. Let pos be ?
ToIntegerOrInfinity(position). 1. Assert: If position is
`undefined`, then pos is 0. 1. Let len be the length of S.
1. Let start be the result of clamping pos between 0 and
len. 1. Let index be StringIndexOf(S, searchStr,
start). 1. If index is ~not-found~, return `false`. 1. Return
`true`.

If searchString appears as a substring of the result of converting
this object to a String, at one or more indices that are greater than or
equal to position, this function returns `true`; otherwise, it
returns `false`. If position is `undefined`, 0 is assumed, so as
to search all of the String.

Throwing an exception if the first argument is a RegExp is specified in
order to allow future editions to define extensions that allow such
argument values.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.indexOf ( searchString [ , position ] )
----------------------------------------------------------------

If searchString appears as a substring of the result of converting
this object to a String, at one or more indices that are greater than or
equal to position, then the smallest such index is returned;
otherwise, `-1`\ :sub:`𝔽` is returned. If position is
`undefined`, `+0`\ :sub:`𝔽` is assumed, so as to search all of the
String.

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let searchStr be ?
ToString(searchString). 1. Let pos be ?
ToIntegerOrInfinity(position). 1. Assert: If position is
`undefined`, then pos is 0. 1. Let len be the length of S.
1. Let start be the result of clamping pos between 0 and
len. 1. Let result be StringIndexOf(S, searchStr,
start). 1. If result is ~not-found~, return `-1`\ :sub:`𝔽`. 1.
Return 𝔽(result).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.isWellFormed ( )
---------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Return IsStringWellFormedUnicode(S).

String.prototype.lastIndexOf ( searchString [ , position ] )
--------------------------------------------------------------------

If searchString appears as a substring of the result of converting
this object to a String at one or more indices that are smaller than or
equal to position, then the greatest such index is returned;
otherwise, `-1`\ :sub:`𝔽` is returned. If position is
`undefined`, the length of the String value is assumed, so as to
search all of the String.

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let searchStr be ?
ToString(searchString). 1. Let numPos be ?
ToNumber(position). 1. Assert: If position is `undefined`,
then numPos is `NaN`. 1. If numPos is `NaN`, let pos be
+∞; otherwise, let pos be ! ToIntegerOrInfinity(numPos). 1. Let
len be the length of S. 1. Let searchLen be the length of
searchStr. 1. Let start be the result of clamping pos
between 0 and len - searchLen. 1. Let result be
StringLastIndexOf(S, searchStr, start). 1. If result is
~not-found~, return `-1`\ :sub:`𝔽`. 1. Return 𝔽(result).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )
-----------------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method returns a Number other than `NaN` representing the result
of an implementation-defined locale-sensitive String comparison of the
`this` value (converted to a String S) with that (converted to
a String thatValue). The result is intended to correspond with a
sort order of String values according to conventions of the host
environment's current locale, and will be negative when S is ordered
before thatValue, positive when S is ordered after
thatValue, and zero in all other cases (representing no relative
ordering between S and thatValue).

Before performing the comparisons, this method performs the following
steps to prepare the Strings:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let thatValue be ? ToString(that).

The meaning of the optional second and third parameters to this method
are defined in the ECMA-402 specification; implementations that do not
include ECMA-402 support must not assign any other interpretation to
those parameter positions.

The actual return values are implementation-defined to permit encoding
additional information in them, but this method, when considered as a
method of two arguments, is required to be a consistent comparator
defining a total ordering on the set of all Strings. This method is also
required to recognize and honour canonical equivalence according to the
Unicode Standard, including returning `+0`\ :sub:`𝔽` when comparing
distinguishable Strings that are canonically equivalent.

This method itself is not directly suitable as an argument to
`Array.prototype.sort` because the latter requires a function of two
arguments.

This method may rely on whatever language- and/or locale-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and is intended to compare according to the
conventions of the host environment's current locale. However,
regardless of comparison capabilities, this method must recognize and
honour canonical equivalence according to the Unicode Standard—for
example, the following comparisons must all return `+0`\ :sub:`𝔽`:

.. code:: javascript

               // Å ANGSTROM SIGN vs.
               // Å LATIN CAPITAL LETTER A + COMBINING RING ABOVE
               "\u212B".localeCompare("A\u030A")

               // Ω OHM SIGN vs.
               // Ω GREEK CAPITAL LETTER OMEGA
               "\u2126".localeCompare("\u03A9")

               // ṩ LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
               // ṩ LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
               "\u1E69".localeCompare("s\u0307\u0323")

               // ḍ̇ LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
               // ḍ̇ LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
               "\u1E0B\u0323".localeCompare("\u1E0D\u0307")

               // 가 HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
               // 가 HANGUL SYLLABLE GA
               "\u1100\u1161".localeCompare("\uAC00")
             

For a definition and discussion of canonical equivalence see the Unicode
Standard, chapters 2 and 3, as well as `Unicode Standard Annex #15,
Unicode Normalization Forms <https://unicode.org/reports/tr15/>`__ and
`Unicode Technical Note #5, Canonical Equivalence in
Applications <https://unicode.org/notes/tn5/>`__. Also see `Unicode
Technical Standard #10, Unicode Collation
Algorithm <https://unicode.org/reports/tr10/>`__.

It is recommended that this method should not honour Unicode
compatibility equivalents or compatibility decompositions as defined in
the Unicode Standard, chapter 3, section 3.7.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.match ( regexp )
-------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. If
regexp is neither `undefined` nor `null`, then 1. Let
matcher be ? GetMethod(regexp, %Symbol.match%). 1. If
matcher is not `undefined`, then 1. Return ? Call(matcher,
regexp, « O »). 1. Let S be ? ToString(O). 1. Let rx
be ? RegExpCreate(regexp, `undefined`). 1. Return ? Invoke(rx,
%Symbol.match%, « S »).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.matchAll ( regexp )
----------------------------------------

This method performs a regular expression match of the String
representing the `this` value against regexp and returns an
iterator that yields match results. Each match result is an Array
containing the matched portion of the String as the first element,
followed by the portions matched by any capturing groups. If the regular
expression never matches, the returned iterator does not yield any match
results.

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. If
regexp is neither `undefined` nor `null`, then 1. Let
isRegExp be ? IsRegExp(regexp). 1. If isRegExp is `true`,
then 1. Let flags be ? Get(regexp, `"flags"`). 1. Perform ?
RequireObjectCoercible(flags). 1. If ? ToString(flags) does not
contain `"g"`, throw a `TypeError` exception. 1. Let matcher be
? GetMethod(regexp, %Symbol.matchAll%). 1. If matcher is not
`undefined`, then 1. Return ? Call(matcher, regexp, « O
»). 1. Let S be ? ToString(O). 1. Let rx be ?
RegExpCreate(regexp, `"g"`). 1. Return ? Invoke(rx,
%Symbol.matchAll%, « S »). This method is intentionally generic, it
does not require that its `this` value be a String object. Therefore,
it can be transferred to other kinds of objects for use as a method.
Similarly to `String.prototype.split`, `String.prototype.matchAll`
is designed to typically act without mutating its inputs.

String.prototype.normalize ( [ form ] )
-------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. If form is `undefined`, let f be
`"NFC"`. 1. Else, let f be ? ToString(form). 1. If f is
not one of `"NFC"`, `"NFD"`, `"NFKC"`, or `"NFKD"`, throw a
`RangeError` exception. 1. Let ns be the String value that is the
result of normalizing S into the normalization form named by f
as specified in `the latest Unicode Standard, Normalization
Forms <https://www.unicode.org/versions/latest/ch03.pdf>`__. 1. Return
ns.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore it can be transferred to
other kinds of objects for use as a method.

String.prototype.padEnd ( maxLength [ , fillString ] )
--------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Return ?
StringPaddingBuiltinsImpl(O, maxLength, fillString, ~end~).

String.prototype.padStart ( maxLength [ , fillString ] )
----------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Return ?
StringPaddingBuiltinsImpl(O, maxLength, fillString,
~start~).

StringPaddingBuiltinsImpl ( O, maxLength, fillString, placement: ~start~ or ~end~, )
------------------------------------------------------------------------------------

1. Let S be ? ToString(O). 1. Let intMaxLength be ℝ(?
ToLength(maxLength)). 1. Let stringLength be the length of
S. 1. If intMaxLength ≤ stringLength, return S. 1. If
fillString is `undefined`, set fillString to the String value
consisting solely of the code unit 0x0020 (SPACE). 1. Else, set
fillString to ? ToString(fillString). 1. Return StringPad(S,
intMaxLength, fillString, placement).

StringPad ( S: a String, maxLength: a non-negative integer, fillString: a String, placement: ~start~ or ~end~, ): a String
------------------------------------------------------------------------------------------------------------------------------------------

1. Let stringLength be the length of S. 1. If maxLength ≤
stringLength, return S. 1. If fillString is the empty
String, return S. 1. Let fillLen be maxLength -
stringLength. 1. Let truncatedStringFiller be the String value
consisting of repeated concatenations of fillString truncated to
length fillLen. 1. If placement is ~start~, return the
string-concatenation of truncatedStringFiller and S. 1. Else,
return the string-concatenation of S and truncatedStringFiller.

The argument maxLength will be clamped such that it can be no
smaller than the length of S.

The argument fillString defaults to `" "` (the String value
consisting of the code unit 0x0020 SPACE).

ToZeroPaddedDecimalString ( n: a non-negative integer, minLength: a non-negative integer, ): a String
-------------------------------------------------------------------------------------------------------------

1. Let S be the String representation of n, formatted as a
decimal number. 1. Return StringPad(S, minLength, `"0"`,
~start~).

String.prototype.repeat ( count )
-------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let n be ? ToIntegerOrInfinity(count).
1. If n < 0 or n = +∞, throw a `RangeError` exception. 1. If
n = 0, return the empty String. 1. Return the String value that is
made from n copies of S appended together.

This method creates the String value consisting of the code units of the
`this` value (converted to String) repeated count times.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.replace ( searchValue, replaceValue )
--------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. If
searchValue is neither `undefined` nor `null`, then 1. Let
replacer be ? GetMethod(searchValue, %Symbol.replace%). 1. If
replacer is not `undefined`, then 1. Return ? Call(replacer,
searchValue, « O, replaceValue »). 1. Let string be ?
ToString(O). 1. Let searchString be ? ToString(searchValue).
1. Let functionalReplace be IsCallable(replaceValue). 1. If
functionalReplace is `false`, then 1. Set replaceValue to ?
ToString(replaceValue). 1. Let searchLength be the length of
searchString. 1. Let position be StringIndexOf(string,
searchString, 0). 1. If position is ~not-found~, return
string. 1. Let preceding be the substring of string from 0
to position. 1. Let following be the substring of string
from position + searchLength. 1. If functionalReplace is
`true`, then 1. Let replacement be ? ToString(?
Call(replaceValue, `undefined`, « searchString,
𝔽(position), string »)). 1. Else, 1. Assert: replaceValue is
a String. 1. Let captures be a new empty List. 1. Let
replacement be ! GetSubstitution(searchString, string,
position, captures, `undefined`, replaceValue). 1. Return
the string-concatenation of preceding, replacement, and
following.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

GetSubstitution ( matched: a String, str: a String, position: a non-negative integer, captures: a List of either Strings or `undefined`, namedCaptures: an Object or `undefined`, replacementTemplate: a String, )
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   For the purposes of this abstract operation, a *decimal digit* is a
   code unit in the inclusive interval from 0x0030 (DIGIT ZERO) to
   0x0039 (DIGIT NINE).

1. Let stringLength be the length of str. 1. Assert:
position ≤ stringLength. 1. Let result be the empty String.
1. Let templateRemainder be replacementTemplate. 1. Repeat,
while templateRemainder is not the empty String, 1.
[declared="ref,refReplacement"] NOTE: The following steps isolate
ref (a prefix of templateRemainder), determine
refReplacement (its replacement), and then append that replacement
to result. 1. If templateRemainder starts with `"$$"`, then 1.
Let ref be `"$$"`. 1. Let refReplacement be `"$"`. 1. Else
if templateRemainder starts with `"$`"`, then 1. Let ref be
`"$`"`. 1. Let refReplacement be the substring of str from 0
to position. 1. Else if templateRemainder starts with `"$&"`,
then 1. Let ref be `"$&"`. 1. Let refReplacement be
matched. 1. Else if templateRemainder starts with `"$'"`
(0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then 1. Let
ref be `"$'"`. 1. Let matchLength be the length of
matched. 1. Let tailPos be position + matchLength. 1.
Let refReplacement be the substring of str from min(tailPos,
stringLength). 1. NOTE: tailPos can exceed stringLength only
if this abstract operation was invoked by a call to the intrinsic
%Symbol.replace% method of %RegExp.prototype% on an object whose
`"exec"` property is not the intrinsic %RegExp.prototype.exec%. 1.
Else if templateRemainder starts with `"$"` followed by 1 or more
decimal digits, then 1. If templateRemainder starts with `"$"`
followed by 2 or more decimal digits, let digitCount be 2.
Otherwise, let digitCount be 1. 1. Let digits be the substring
of templateRemainder from 1 to 1 + digitCount. 1. Let index
be ℝ(StringToNumber(digits)). 1. Assert: 0 ≤ index ≤ 99. 1. Let
captureLen be the number of elements in captures. 1. If
index > captureLen and digitCount = 2, then 1. NOTE: When a
two-digit replacement pattern specifies an index exceeding the count of
capturing groups, it is treated as a one-digit replacement pattern
followed by a literal digit. 1. Set digitCount to 1. 1. Set
digits to the substring of digits from 0 to 1. 1. Set index
to ℝ(StringToNumber(digits)). 1. Let ref be the substring of
templateRemainder from 0 to 1 + digitCount. 1. If 1 ≤ index
≤ captureLen, then 1. Let capture be captures[index -
1]. 1. If capture is `undefined`, then 1. Let refReplacement
be the empty String. 1. Else, 1. Let refReplacement be capture.
1. Else, 1. Let refReplacement be ref. 1. Else if
templateRemainder starts with `"$<"`, then 1. Let gtPos be
StringIndexOf(templateRemainder, `">"`, 0). 1. If gtPos is
~not-found~ or namedCaptures is `undefined`, then 1. Let ref
be `"$<"`. 1. Let refReplacement be ref. 1. Else, 1. Let
ref be the substring of templateRemainder from 0 to gtPos +
1. 1. Let groupName be the substring of templateRemainder from 2
to gtPos. 1. Assert: namedCaptures is an Object. 1. Let
capture be ? Get(namedCaptures, groupName). 1. If
capture is `undefined`, then 1. Let refReplacement be the
empty String. 1. Else, 1. Let refReplacement be ?
ToString(capture). 1. Else, 1. Let ref be the substring of
templateRemainder from 0 to 1. 1. Let refReplacement be ref.
1. Let refLength be the length of ref. 1. Set
templateRemainder to the substring of templateRemainder from
refLength. 1. Set result to the string-concatenation of
result and refReplacement. 1. Return result.

String.prototype.replaceAll ( searchValue, replaceValue )
-----------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. If
searchValue is neither `undefined` nor `null`, then 1. Let
isRegExp be ? IsRegExp(searchValue). 1. If isRegExp is
`true`, then 1. Let flags be ? Get(searchValue, `"flags"`).
1. Perform ? RequireObjectCoercible(flags). 1. If ?
ToString(flags) does not contain `"g"`, throw a `TypeError`
exception. 1. Let replacer be ? GetMethod(searchValue,
%Symbol.replace%). 1. If replacer is not `undefined`, then 1.
Return ? Call(replacer, searchValue, « O, replaceValue
»). 1. Let string be ? ToString(O). 1. Let searchString be ?
ToString(searchValue). 1. Let functionalReplace be
IsCallable(replaceValue). 1. If functionalReplace is `false`,
then 1. Set replaceValue to ? ToString(replaceValue). 1. Let
searchLength be the length of searchString. 1. Let advanceBy
be max(1, searchLength). 1. Let matchPositions be a new empty
List. 1. Let position be StringIndexOf(string, searchString,
0). 1. Repeat, while position is not ~not-found~, 1. Append
position to matchPositions. 1. Set position to
StringIndexOf(string, searchString, position +
advanceBy). 1. Let endOfLastMatch be 0. 1. Let result be the
empty String. 1. For each element p of matchPositions, do 1. Let
preserved be the substring of string from endOfLastMatch to
p. 1. If functionalReplace is `true`, then 1. Let
replacement be ? ToString(? Call(replaceValue, `undefined`, «
searchString, 𝔽(p), string »)). 1. Else, 1. Assert:
replaceValue is a String. 1. Let captures be a new empty List.
1. Let replacement be ! GetSubstitution(searchString,
string, p, captures, `undefined`, replaceValue). 1.
Set result to the string-concatenation of result, preserved,
and replacement. 1. Set endOfLastMatch to p +
searchLength. 1. If endOfLastMatch < the length of string,
then 1. Set result to the string-concatenation of result and the
substring of string from endOfLastMatch. 1. Return result.

String.prototype.search ( regexp )
--------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. If
regexp is neither `undefined` nor `null`, then 1. Let
searcher be ? GetMethod(regexp, %Symbol.search%). 1. If
searcher is not `undefined`, then 1. Return ? Call(searcher,
regexp, « O »). 1. Let string be ? ToString(O). 1. Let
rx be ? RegExpCreate(regexp, `undefined`). 1. Return ?
Invoke(rx, %Symbol.search%, « string »).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.slice ( start, end )
---------------------------------------------

This method returns a substring of the result of converting this object
to a String, starting from index start and running to, but not
including, index end (or through the end of the String if end is
`undefined`). If start is negative, it is treated as
sourceLength + start where sourceLength is the length of the
String. If end is negative, it is treated as sourceLength +
end where sourceLength is the length of the String. The result
is a String value, not a String object.

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let len be the length of S. 1. Let
intStart be ? ToIntegerOrInfinity(start). 1. If intStart =
-∞, let from be 0. 1. Else if intStart < 0, let from be
max(len + intStart, 0). 1. Else, let from be
min(intStart, len). 1. If end is `undefined`, let
intEnd be len; else let intEnd be ?
ToIntegerOrInfinity(end). 1. If intEnd = -∞, let to be 0. 1.
Else if intEnd < 0, let to be max(len + intEnd, 0). 1.
Else, let to be min(intEnd, len). 1. If from ≥ to,
return the empty String. 1. Return the substring of S from from
to to.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore it can be transferred to
other kinds of objects for use as a method.

String.prototype.split ( separator, limit )
---------------------------------------------------

This method returns an Array into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
separator; these occurrences are not part of any String in the
returned array, but serve to divide up the String value. The value of
separator may be a String of any length or it may be an object, such
as a RegExp, that has a %Symbol.split% method.

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. If
separator is neither `undefined` nor `null`, then 1. Let
splitter be ? GetMethod(separator, %Symbol.split%). 1. If
splitter is not `undefined`, then 1. Return ? Call(splitter,
separator, « O, limit »). 1. Let S be ? ToString(O).
1. If limit is `undefined`, let lim be 2\ :sup:`32` - 1; else
let lim be ℝ(? ToUint32(limit)). 1. Let R be ?
ToString(separator). 1. If lim = 0, then 1. Return
CreateArrayFromList(« »). 1. If separator is `undefined`, then 1.
Return CreateArrayFromList(« S »). 1. Let separatorLength be the
length of R. 1. If separatorLength = 0, then 1. Let strLen
be the length of S. 1. Let outLen be the result of clamping
lim between 0 and strLen. 1. Let head be the substring of
S from 0 to outLen. 1. Let codeUnits be a List consisting of
the sequence of code units that are the elements of head. 1. Return
CreateArrayFromList(codeUnits). 1. If S is the empty String,
return CreateArrayFromList(« S »). 1. Let substrings be a new
empty List. 1. Let i be 0. 1. Let j be StringIndexOf(S,
R, 0). 1. Repeat, while j is not ~not-found~, 1. Let T be
the substring of S from i to j. 1. Append T to
substrings. 1. If the number of elements in substrings is
lim, return CreateArrayFromList(substrings). 1. Set i to
j + separatorLength. 1. Set j to StringIndexOf(S, R,
i). 1. Let T be the substring of S from i. 1. Append
T to substrings. 1. Return CreateArrayFromList(substrings).

The value of separator may be an empty String. In this case,
separator does not match the empty substring at the beginning or end
of the input String, nor does it match the empty substring at the end of
the previous separator match. If separator is the empty String, the
String is split up into individual code unit elements; the length of the
result array equals the length of the String, and each substring
contains one code unit.

If the `this` value is (or converts to) the empty String, the result
depends on whether separator can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If separator is `undefined`, then the result array contains just
one String, which is the `this` value (converted to a String). If
limit is not `undefined`, then the output array is truncated so
that it contains no more than limit elements.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.startsWith ( searchString [ , position ] )
-------------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let isRegExp be ?
IsRegExp(searchString). 1. If isRegExp is `true`, throw a
`TypeError` exception. 1. Let searchStr be ?
ToString(searchString). 1. Let len be the length of S. 1. If
position is `undefined`, let pos be 0; else let pos be ?
ToIntegerOrInfinity(position). 1. Let start be the result of
clamping pos between 0 and len. 1. Let searchLength be the
length of searchStr. 1. If searchLength = 0, return `true`. 1.
Let end be start + searchLength. 1. If end > len,
return `false`. 1. Let substring be the substring of S from
start to end. 1. If substring is searchStr, return
`true`. 1. Return `false`.

This method returns `true` if the sequence of code units of
searchString converted to a String is the same as the corresponding
code units of this object (converted to a String) starting at index
position. Otherwise it returns `false`.

Throwing an exception if the first argument is a RegExp is specified in
order to allow future editions to define extensions that allow such
argument values.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.substring ( start, end )
-------------------------------------------------

This method returns a substring of the result of converting this object
to a String, starting from index start and running to, but not
including, index end of the String (or through the end of the String
if end is `undefined`). The result is a String value, not a String
object.

If either argument is `NaN` or negative, it is replaced with zero; if
either argument is strictly greater than the length of the String, it is
replaced with the length of the String.

If start is strictly greater than end, they are swapped.

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let len be the length of S. 1. Let
intStart be ? ToIntegerOrInfinity(start). 1. If end is
`undefined`, let intEnd be len; else let intEnd be ?
ToIntegerOrInfinity(end). 1. Let finalStart be the result of
clamping intStart between 0 and len. 1. Let finalEnd be the
result of clamping intEnd between 0 and len. 1. Let from be
min(finalStart, finalEnd). 1. Let to be max(finalStart,
finalEnd). 1. Return the substring of S from from to to.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] )
----------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method interprets a String value as a sequence of UTF-16 encoded
code points, as described in .

It works exactly the same as `toLowerCase` except that it is intended
to yield a locale-sensitive result corresponding with conventions of the
host environment's current locale. There will only be a difference in
the few cases (such as Turkish) where the rules for that language
conflict with the regular Unicode case mappings.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.toLocaleUpperCase ( [ reserved1 [ , reserved2 ] ] )
----------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used:

This method interprets a String value as a sequence of UTF-16 encoded
code points, as described in .

It works exactly the same as `toUpperCase` except that it is intended
to yield a locale-sensitive result corresponding with conventions of the
host environment's current locale. There will only be a difference in
the few cases (such as Turkish) where the rules for that language
conflict with the regular Unicode case mappings.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.toLowerCase ( )
--------------------------------

This method interprets a String value as a sequence of UTF-16 encoded
code points, as described in .

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let sText be StringToCodePoints(S). 1.
Let lowerText be toLowercase(sText), according to the Unicode
Default Case Conversion algorithm. 1. Let L be
CodePointsToString(lowerText). 1. Return L.

The result must be derived according to the locale-insensitive case
mappings in the Unicode Character Database (this explicitly includes not
only the file
```UnicodeData.txt`` <https://unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`__,
but also all locale-insensitive mappings in the file
```SpecialCasing.txt`` <https://unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt>`__
that accompanies it).

The case mapping of some code points may produce multiple code points.
In this case the result String may not be the same length as the source
String. Because both `toUpperCase` and `toLowerCase` have
context-sensitive behaviour, the methods are not symmetrical. In other
words, `s.toUpperCase().toLowerCase()` is not necessarily equal to
`s.toLowerCase()`.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.toString ( )
-----------------------------

This method performs the following steps when called:

1. Return ? ThisStringValue(`this` value).

For a String object, this method happens to return the same thing as the
`valueOf` method.

String.prototype.toUpperCase ( )
--------------------------------

This method interprets a String value as a sequence of UTF-16 encoded
code points, as described in .

It behaves in exactly the same way as `String.prototype.toLowerCase`,
except that the String is mapped using the toUppercase algorithm of the
Unicode Default Case Conversion.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.toWellFormed ( )
---------------------------------

This method returns a String representation of this object with all
leading surrogates and trailing surrogates that are not part of a
surrogate pair replaced with U+FFFD (REPLACEMENT CHARACTER).

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let strLen be the length of S. 1. Let
k be 0. 1. Let result be the empty String. 1. Repeat, while
k < strLen, 1. Let cp be CodePointAt(S, k). 1. If
cp.[[IsUnpairedSurrogate]] is `true`, then 1. Set result to
the string-concatenation of result and 0xFFFD (REPLACEMENT
CHARACTER). 1. Else, 1. Set result to the string-concatenation of
result and UTF16EncodeCodePoint(cp.[[CodePoint]]). 1. Set k
to k + cp.[[CodeUnitCount]]. 1. Return result.

String.prototype.trim ( )
-------------------------

This method interprets a String value as a sequence of UTF-16 encoded
code points, as described in .

It performs the following steps when called:

1. Let S be the `this` value. 1. Return ? TrimString(S,
~start+end~).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

TrimString ( string, where: ~start~, ~end~, or ~start+end~, )
-------------------------------------------------------------

description
   It interprets string as a sequence of UTF-16 encoded code points,
   as described in .

1. Let str be ? RequireObjectCoercible(string). 1. Let S be
? ToString(str). 1. If where is ~start~, then 1. Let T be
the String value that is a copy of S with leading white space
removed. 1. Else if where is ~end~, then 1. Let T be the String
value that is a copy of S with trailing white space removed. 1.
Else, 1. Assert: where is ~start+end~. 1. Let T be the String
value that is a copy of S with both leading and trailing white space
removed. 1. Return T.

The definition of white space is the union of `WhiteSpace` and
`LineTerminator`. When determining whether a Unicode code point is in
Unicode general category “Space_Separator” (“Zs”), code unit sequences
are interpreted as UTF-16 encoded code point sequences as specified in .

String.prototype.trimEnd ( )
----------------------------

This method interprets a String value as a sequence of UTF-16 encoded
code points, as described in .

It performs the following steps when called:

1. Let S be the `this` value. 1. Return ? TrimString(S,
~end~).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.trimStart ( )
------------------------------

This method interprets a String value as a sequence of UTF-16 encoded
code points, as described in .

It performs the following steps when called:

1. Let S be the `this` value. 1. Return ? TrimString(S,
~start~).

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore, it can be transferred to
other kinds of objects for use as a method.

String.prototype.valueOf ( )
----------------------------

This method performs the following steps when called:

1. Return ? ThisStringValue(`this` value).

ThisStringValue ( value, )
--------------------------

1. If value is a String, return value. 1. If value is an
Object and value has a [[StringData]] internal slot, then 1. Let
s be value.[[StringData]]. 1. Assert: s is a String. 1.
Return s. 1. Throw a `TypeError` exception.

String.prototype [ %Symbol.iterator% ] ( )
------------------------------------------

This method returns an iterator object that iterates over the code
points of a String value, returning each code point as a String value.

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let s
be ? ToString(O). 1. Let closure be a new Abstract Closure with
no parameters that captures s and performs the following steps when
called: 1. Let len be the length of s. 1. Let position be 0.
1. Repeat, while position < len, 1. Let cp be
CodePointAt(s, position). 1. Let nextIndex be position +
cp.[[CodeUnitCount]]. 1. Let resultString be the substring of
s from position to nextIndex. 1. Set position to
nextIndex. 1. Perform ?
GeneratorYield(CreateIteratorResultObject(resultString, `false`)).
1. Return `undefined`. 1. Return
CreateIteratorFromClosure(closure, `"%StringIteratorPrototype%"`,
%StringIteratorPrototype%).

The value of the `"name"` property of this method is
`"[Symbol.iterator]"`.

Properties of String Instances
------------------------------

String instances are String exotic objects and have the internal methods
specified for such objects. String instances inherit properties from the
String prototype object. String instances also have a [[StringData]]
internal slot. The [[StringData]] internal slot is the String value
represented by this String object.

String instances have a `"length"` property, and a set of enumerable
properties with integer-indexed names.

.. _length-1:

length
------

The number of elements in the String value represented by this String
object.

Once a String object is initialized, this property is unchanging. It has
the attributes { [[Writable]]: `false`, [[Enumerable]]: `false`,
[[Configurable]]: `false` }.

String Iterator Objects
-----------------------

A String Iterator is an object that represents a specific iteration over
some specific String instance object. There is not a named constructor
for String Iterator objects. Instead, String Iterator objects are
created by calling certain methods of String instance objects.

The %StringIteratorPrototype% Object
------------------------------------

The %StringIteratorPrototype% object:

- has properties that are inherited by all String Iterator objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- has the following properties:

%StringIteratorPrototype%.next ( )
----------------------------------

1. Return ? GeneratorResume(`this` value, ~empty~,
`"%StringIteratorPrototype%"`).

%StringIteratorPrototype% [ %Symbol.toStringTag% ]
--------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"String Iterator"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

RegExp (Regular Expression) Objects
-----------------------------------

A RegExp object contains a regular expression and the associated flags.

The form and functionality of regular expressions is modelled after the
regular expression facility in the Perl 5 programming language.

Patterns
--------

The RegExp constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of `Pattern`.


**Syntax**


Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `|`
Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: [empty]
Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier
Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: `^`
`$` `\\b` `\\B` `(?=` Disjunction[?UnicodeMode,
?UnicodeSetsMode, ?NamedCaptureGroups] `)` `(?!`
Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
`(?<=` Disjunction[?UnicodeMode, ?UnicodeSetsMode,
?NamedCaptureGroups] `)` `(?<!` Disjunction[?UnicodeMode,
?UnicodeSetsMode, ?NamedCaptureGroups] `)` Quantifier ::
QuantifierPrefix QuantifierPrefix `?` QuantifierPrefix :: `*` `+`
`?` `{` DecimalDigits[~Sep] `}` `{` DecimalDigits[~Sep] `,}`
`{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`
Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
PatternCharacter `.` `\\` AtomEscape[?UnicodeMode,
?NamedCaptureGroups] CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
`(` GroupSpecifier[?UnicodeMode]? Disjunction[?UnicodeMode,
?UnicodeSetsMode, ?NamedCaptureGroups] `)` `(?:`
Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
SyntaxCharacter :: one of `^` `$` `\\` `.` `*` `+` `?`
`(` `)` `[` `]` `{` `}` `|` PatternCharacter ::
SourceCharacter but not SyntaxCharacter AtomEscape[UnicodeMode,
NamedCaptureGroups] :: DecimalEscape CharacterClassEscape[?UnicodeMode]
CharacterEscape[?UnicodeMode] [+NamedCaptureGroups] `k`
GroupName[?UnicodeMode] CharacterEscape[UnicodeMode] :: ControlEscape
`c` AsciiLetter `0` [lookahead ∉ DecimalDigit] HexEscapeSequence
RegExpUnicodeEscapeSequence[?UnicodeMode] IdentityEscape[?UnicodeMode]
ControlEscape :: one of `f` `n` `r` `t` `v`
GroupSpecifier[UnicodeMode] :: `?` GroupName[?UnicodeMode]
GroupName[UnicodeMode] :: `<` RegExpIdentifierName[?UnicodeMode] `>`
RegExpIdentifierName[UnicodeMode] :: RegExpIdentifierStart[?UnicodeMode]
RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]
RegExpIdentifierStart[UnicodeMode] :: IdentifierStartChar `\\`
RegExpUnicodeEscapeSequence[+UnicodeMode] [~UnicodeMode]
UnicodeLeadSurrogate UnicodeTrailSurrogate
RegExpIdentifierPart[UnicodeMode] :: IdentifierPartChar `\\`
RegExpUnicodeEscapeSequence[+UnicodeMode] [~UnicodeMode]
UnicodeLeadSurrogate UnicodeTrailSurrogate
RegExpUnicodeEscapeSequence[UnicodeMode] :: [+UnicodeMode] `u`
HexLeadSurrogate `\\u` HexTrailSurrogate [+UnicodeMode] `u`
HexLeadSurrogate [+UnicodeMode] `u` HexTrailSurrogate [+UnicodeMode]
`u` HexNonSurrogate [~UnicodeMode] `u` Hex4Digits [+UnicodeMode]
`u{` CodePoint `}` UnicodeLeadSurrogate :: > any Unicode code point
in the inclusive interval from U+D800 to U+DBFF UnicodeTrailSurrogate ::
> any Unicode code point in the inclusive interval from U+DC00 to U+DFFF

Each `\\\\u` `HexTrailSurrogate` for which the choice of associated
`u` `HexLeadSurrogate` is ambiguous shall be associated with the
nearest possible `u` `HexLeadSurrogate` that would otherwise have no
corresponding `\\\\u` `HexTrailSurrogate`.

HexLeadSurrogate :: Hex4Digits [> but only if the MV of \|Hex4Digits\|
is in the inclusive interval from 0xD800 to 0xDBFF] HexTrailSurrogate ::
Hex4Digits [> but only if the MV of \|Hex4Digits\| is in the inclusive
interval from 0xDC00 to 0xDFFF] HexNonSurrogate :: Hex4Digits [> but
only if the MV of \|Hex4Digits\| is not in the inclusive interval from
0xD800 to 0xDFFF] IdentityEscape[UnicodeMode] :: [+UnicodeMode]
SyntaxCharacter [+UnicodeMode] `/` [~UnicodeMode] SourceCharacter but
not UnicodeIDContinue DecimalEscape :: NonZeroDigit DecimalDigits[~Sep]?
[lookahead ∉ DecimalDigit] CharacterClassEscape[UnicodeMode] :: `d`
`D` `s` `S` `w` `W` [+UnicodeMode] `p{`
UnicodePropertyValueExpression `}` [+UnicodeMode] `P{`
UnicodePropertyValueExpression `}` UnicodePropertyValueExpression ::
UnicodePropertyName `=` UnicodePropertyValue
LoneUnicodePropertyNameOrValue UnicodePropertyName ::
UnicodePropertyNameCharacters UnicodePropertyNameCharacters ::
UnicodePropertyNameCharacter UnicodePropertyNameCharacters?
UnicodePropertyValue :: UnicodePropertyValueCharacters
LoneUnicodePropertyNameOrValue :: UnicodePropertyValueCharacters
UnicodePropertyValueCharacters :: UnicodePropertyValueCharacter
UnicodePropertyValueCharacters? UnicodePropertyValueCharacter ::
UnicodePropertyNameCharacter DecimalDigit UnicodePropertyNameCharacter
:: AsciiLetter `` CharacterClass[UnicodeMode, UnicodeSetsMode] ::
`[` [lookahead != `^`] ClassContents[?UnicodeMode, ?UnicodeSetsMode]
`]` `[^` ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`
ClassContents[UnicodeMode, UnicodeSetsMode] :: [empty]
[~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode] [+UnicodeSetsMode]
ClassSetExpression NonemptyClassRanges[UnicodeMode] ::
ClassAtom[?UnicodeMode] ClassAtom[?UnicodeMode]
NonemptyClassRangesNoDash[?UnicodeMode] ClassAtom[?UnicodeMode] `-`
ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]
NonemptyClassRangesNoDash[UnicodeMode] :: ClassAtom[?UnicodeMode]
ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
ClassAtomNoDash[?UnicodeMode] `-` ClassAtom[?UnicodeMode]
ClassContents[?UnicodeMode, ~UnicodeSetsMode] ClassAtom[UnicodeMode] ::
`-` ClassAtomNoDash[?UnicodeMode] ClassAtomNoDash[UnicodeMode] ::
SourceCharacter but not one of `\\` or `]` or `-` `\\`
ClassEscape[?UnicodeMode] ClassEscape[UnicodeMode] :: `b`
[+UnicodeMode] `-` CharacterClassEscape[?UnicodeMode]
CharacterEscape[?UnicodeMode] ClassSetExpression :: ClassUnion
ClassIntersection ClassSubtraction ClassUnion :: ClassSetRange
ClassUnion? ClassSetOperand ClassUnion? ClassIntersection ::
ClassSetOperand `&&` [lookahead != `&`] ClassSetOperand
ClassIntersection `&&` [lookahead != `&`] ClassSetOperand
ClassSubtraction :: ClassSetOperand `--` ClassSetOperand
ClassSubtraction `--` ClassSetOperand ClassSetRange ::
ClassSetCharacter `-` ClassSetCharacter ClassSetOperand :: NestedClass
ClassStringDisjunction ClassSetCharacter NestedClass :: `[` [lookahead
!= `^`] ClassContents[+UnicodeMode, +UnicodeSetsMode] `]` `[^`
ClassContents[+UnicodeMode, +UnicodeSetsMode] `]` `\\`
CharacterClassEscape[+UnicodeMode]

The first two lines here are equivalent to CharacterClass.

ClassStringDisjunction :: `\\q{` ClassStringDisjunctionContents `}`
ClassStringDisjunctionContents :: ClassString ClassString `|`
ClassStringDisjunctionContents ClassString :: [empty]
NonEmptyClassString NonEmptyClassString :: ClassSetCharacter
NonEmptyClassString? ClassSetCharacter :: [lookahead ∉
ClassSetReservedDoublePunctuator] SourceCharacter but not
ClassSetSyntaxCharacter `\\` CharacterEscape[+UnicodeMode] `\\`
ClassSetReservedPunctuator `\\b` ClassSetReservedDoublePunctuator ::
one of `&&` `!!` `##` `$$` `%%` `**` `++` `,,` `..`
`::` `;;` `<<` `==` `>>` `??` `@@` `^^` ```` `~~`
ClassSetSyntaxCharacter :: one of `(` `)` `[` `]` `{` `}`
`/` `-` `\\` `|` ClassSetReservedPunctuator :: one of `&`
`-` `!` `#` `%` `,` `:` `;` `<` `=` `>` `@` ```
`~`

A number of productions in this section are given alternative
definitions in section .


Static Semantics: Early Errors
------------------------------

This section is amended in .

Pattern :: Disjunction

- It is a Syntax Error if CountLeftCapturingParensWithin(`Pattern`) ≥
  2\ :sup:`32` - 1.
- It is a Syntax Error if `Pattern` contains two distinct
  \|GroupSpecifier|s x and y such that the CapturingGroupName of
  x is the CapturingGroupName of y and such that
  MightBothParticipate(x, y) is `true`.

QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`

- It is a Syntax Error if the MV of the first `DecimalDigits` is
  strictly greater than the MV of the second `DecimalDigits`.

AtomEscape :: `k` GroupName

- It is a Syntax Error if GroupSpecifiersThatMatch(`GroupName`) is
  empty.

AtomEscape :: DecimalEscape

- It is a Syntax Error if the CapturingGroupNumber of `DecimalEscape`
  is strictly greater than CountLeftCapturingParensWithin(the
  `Pattern` containing `AtomEscape`).

NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents

- It is a Syntax Error if IsCharacterClass of the first `ClassAtom` is
  `true` or IsCharacterClass of the second `ClassAtom` is `true`.
- It is a Syntax Error if IsCharacterClass of the first `ClassAtom` is
  `false`, IsCharacterClass of the second `ClassAtom` is `false`,
  and the CharacterValue of the first `ClassAtom` is strictly greater
  than the CharacterValue of the second `ClassAtom`.

NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom
ClassContents

- It is a Syntax Error if IsCharacterClass of `ClassAtomNoDash` is
  `true` or IsCharacterClass of `ClassAtom` is `true`.
- It is a Syntax Error if IsCharacterClass of `ClassAtomNoDash` is
  `false`, IsCharacterClass of `ClassAtom` is `false`, and the
  CharacterValue of `ClassAtomNoDash` is strictly greater than the
  CharacterValue of `ClassAtom`.

RegExpIdentifierStart :: `\\` RegExpUnicodeEscapeSequence

- It is a Syntax Error if the CharacterValue of
  `RegExpUnicodeEscapeSequence` is not the numeric value of some code
  point matched by the `IdentifierStartChar` lexical grammar
  production.

RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate

- It is a Syntax Error if the RegExpIdentifierCodePoint of
  `RegExpIdentifierStart` is not matched by the \|UnicodeIDStart\|
  lexical grammar production.

RegExpIdentifierPart :: `\\` RegExpUnicodeEscapeSequence

- It is a Syntax Error if the CharacterValue of
  `RegExpUnicodeEscapeSequence` is not the numeric value of some code
  point matched by the `IdentifierPartChar` lexical grammar
  production.

RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate

- It is a Syntax Error if the RegExpIdentifierCodePoint of
  `RegExpIdentifierPart` is not matched by the \|UnicodeIDContinue\|
  lexical grammar production.

UnicodePropertyValueExpression :: UnicodePropertyName `=`
UnicodePropertyValue

- It is a Syntax Error if the source text matched by
  `UnicodePropertyName` is not a Unicode property name or property
  alias listed in the “Property name and aliases” column of .
- It is a Syntax Error if the source text matched by
  `UnicodePropertyValue` is not a property value or property value
  alias for the Unicode property or property alias given by the source
  text matched by `UnicodePropertyName` listed in
  ```PropertyValueAliases.txt`` <https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt>`__.

UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue

- It is a Syntax Error if the source text matched by
  `LoneUnicodePropertyNameOrValue` is not a Unicode property value or
  property value alias for the General_Category (gc) property listed in
  ```PropertyValueAliases.txt`` <https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt>`__,
  nor a binary property or binary property alias listed in the “Property
  name and aliases” column of , nor a binary property of strings listed
  in the “Property name” column of .
- It is a Syntax Error if the enclosing `Pattern` does not have a
  :sub:`[UnicodeSetsMode]` parameter and the source text matched by
  `LoneUnicodePropertyNameOrValue` is a binary property of strings
  listed in the “Property name” column of .

CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`

- It is a Syntax Error if MayContainStrings of the
  `UnicodePropertyValueExpression` is `true`.

CharacterClass :: `[^` ClassContents `]`

- It is a Syntax Error if MayContainStrings of the `ClassContents` is
  `true`.

NestedClass :: `[^` ClassContents `]`

- It is a Syntax Error if MayContainStrings of the `ClassContents` is
  `true`.

ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter

- It is a Syntax Error if the CharacterValue of the first
  `ClassSetCharacter` is strictly greater than the CharacterValue of
  the second `ClassSetCharacter`.

Static Semantics: CountLeftCapturingParensWithin ( node: a Parse Node, ): a non-negative integer
----------------------------------------------------------------------------------------------------

description
   It returns the number of left-capturing parentheses in node. A
   left-capturing parenthesis is any `(` pattern character that is
   matched by the `(` terminal of the Atom :: `(` GroupSpecifier?
   Disjunction `)` production.

This section is amended in .

1. Assert: node is an instance of a production in the RegExp Pattern
grammar. 1. Return the number of Atom :: `(` GroupSpecifier?
Disjunction `)` Parse Nodes contained within node.

Static Semantics: CountLeftCapturingParensBefore ( node: a Parse Node, ): a non-negative integer
----------------------------------------------------------------------------------------------------

description
   It returns the number of left-capturing parentheses within the
   enclosing pattern that occur to the left of node.

This section is amended in .

1. Assert: node is an instance of a production in the RegExp Pattern
grammar. 1. Let pattern be the `Pattern` containing node. 1.
Return the number of Atom :: `(` GroupSpecifier? Disjunction `)`
Parse Nodes contained within pattern that either occur before
node or contain node.

Static Semantics: MightBothParticipate ( x: a Parse Node, y: a Parse Node, ): a Boolean
-----------------------------------------------------------------------------------------------

1. Assert: x and y have the same enclosing `Pattern`. 1. If
the enclosing `Pattern` contains a Disjunction :: Alternative `|`
Disjunction Parse Node such that either x is contained within the
`Alternative` and y is contained within the derived
`Disjunction`, or x is contained within the derived
`Disjunction` and y is contained within the `Alternative`,
return `false`. 1. Return `true`.

Static Semantics: CapturingGroupNumber ( ): a positive integer
--------------------------------------------------------------

This section is amended in .

DecimalEscape :: NonZeroDigit 1. Return the MV of `NonZeroDigit`.
DecimalEscape :: NonZeroDigit DecimalDigits 1. Let n be the number
of code points in `DecimalDigits`. 1. Return (the MV of
`NonZeroDigit` × 10\ :sup:`n` plus the MV of `DecimalDigits`).

The definitions of “the MV of `NonZeroDigit`” and “the MV of
`DecimalDigits`” are in .

Static Semantics: IsCharacterClass ( ): a Boolean
-------------------------------------------------

This section is amended in .

ClassAtom :: `-` ClassAtomNoDash :: SourceCharacter but not one of
`\\` or `]` or `-` ClassEscape :: `b` `-` CharacterEscape 1.
Return `false`. ClassEscape :: CharacterClassEscape 1. Return
`true`.

Static Semantics: CharacterValue ( ): a non-negative integer
------------------------------------------------------------

This section is amended in .

ClassAtom :: `-` 1. Return the numeric value of U+002D (HYPHEN-MINUS).
ClassAtomNoDash :: SourceCharacter but not one of `\\` or `]` or
`-` 1. Let ch be the code point matched by `SourceCharacter`. 1.
Return the numeric value of ch. ClassEscape :: `b` 1. Return the
numeric value of U+0008 (BACKSPACE). ClassEscape :: `-` 1. Return the
numeric value of U+002D (HYPHEN-MINUS). CharacterEscape :: ControlEscape
1. Return the numeric value according to .

============= ============= ========== ==================== ======
ControlEscape Numeric Value Code Point Unicode Name         Symbol
============= ============= ========== ==================== ======
`t`         9             `U+0009` CHARACTER TABULATION <HT>
`n`         10            `U+000A` LINE FEED (LF)       <LF>
`v`         11            `U+000B` LINE TABULATION      <VT>
`f`         12            `U+000C` FORM FEED (FF)       <FF>
`r`         13            `U+000D` CARRIAGE RETURN (CR) <CR>
============= ============= ========== ==================== ======

CharacterEscape :: `c` AsciiLetter 1. Let ch be the code point
matched by `AsciiLetter`. 1. Let i be the numeric value of ch.
1. Return the remainder of dividing i by 32. CharacterEscape ::
`0` [lookahead ∉ DecimalDigit] 1. Return the numeric value of U+0000
(NULL).

`\\\\0` represents the <NUL> character and cannot be followed by a
decimal digit.

CharacterEscape :: HexEscapeSequence 1. Return the MV of
`HexEscapeSequence`. RegExpUnicodeEscapeSequence :: `u`
HexLeadSurrogate `\\u` HexTrailSurrogate 1. Let lead be the
CharacterValue of `HexLeadSurrogate`. 1. Let trail be the
CharacterValue of `HexTrailSurrogate`. 1. Let cp be
UTF16SurrogatePairToCodePoint(lead, trail). 1. Return the
numeric value of cp. RegExpUnicodeEscapeSequence :: `u` Hex4Digits
1. Return the MV of \|Hex4Digits\|. RegExpUnicodeEscapeSequence ::
`u{` CodePoint `}` 1. Return the MV of `CodePoint`.
HexLeadSurrogate :: Hex4Digits HexTrailSurrogate :: Hex4Digits
HexNonSurrogate :: Hex4Digits 1. Return the MV of \|Hex4Digits\|.
CharacterEscape :: IdentityEscape 1. Let ch be the code point
matched by `IdentityEscape`. 1. Return the numeric value of ch.
ClassSetCharacter :: SourceCharacter but not ClassSetSyntaxCharacter 1.
Let ch be the code point matched by `SourceCharacter`. 1. Return
the numeric value of ch. ClassSetCharacter :: `\\`
ClassSetReservedPunctuator 1. Let ch be the code point matched by
`ClassSetReservedPunctuator`. 1. Return the numeric value of ch.
ClassSetCharacter :: `\\b` 1. Return the numeric value of U+0008
(BACKSPACE).

Static Semantics: MayContainStrings ( ): a Boolean
--------------------------------------------------

CharacterClassEscape :: `d` `D` `s` `S` `w` `W` `P{`
UnicodePropertyValueExpression `}` UnicodePropertyValueExpression ::
UnicodePropertyName `=` UnicodePropertyValue NestedClass :: `[^`
ClassContents `]` ClassContents :: [empty] NonemptyClassRanges
ClassSetOperand :: ClassSetCharacter 1. Return `false`.
UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue 1. If
the source text matched by `LoneUnicodePropertyNameOrValue` is a
binary property of strings listed in the “Property name” column of ,
return `true`. 1. Return `false`. ClassUnion :: ClassSetRange
ClassUnion? 1. If the `ClassUnion` is present, return
MayContainStrings of the `ClassUnion`. 1. Return `false`. ClassUnion
:: ClassSetOperand ClassUnion? 1. If MayContainStrings of the
`ClassSetOperand` is `true`, return `true`. 1. If `ClassUnion`
is present, return MayContainStrings of the `ClassUnion`. 1. Return
`false`. ClassIntersection :: ClassSetOperand `&&` ClassSetOperand
1. If MayContainStrings of the first `ClassSetOperand` is `false`,
return `false`. 1. If MayContainStrings of the second
`ClassSetOperand` is `false`, return `false`. 1. Return `true`.
ClassIntersection :: ClassIntersection `&&` ClassSetOperand 1. If
MayContainStrings of the `ClassIntersection` is `false`, return
`false`. 1. If MayContainStrings of the `ClassSetOperand` is
`false`, return `false`. 1. Return `true`. ClassSubtraction ::
ClassSetOperand `--` ClassSetOperand 1. Return MayContainStrings of
the first `ClassSetOperand`. ClassSubtraction :: ClassSubtraction
`--` ClassSetOperand 1. Return MayContainStrings of the
`ClassSubtraction`. ClassStringDisjunctionContents :: ClassString
`|` ClassStringDisjunctionContents 1. If MayContainStrings of the
`ClassString` is `true`, return `true`. 1. Return
MayContainStrings of the `ClassStringDisjunctionContents`. ClassString
:: [empty] 1. Return `true`. ClassString :: NonEmptyClassString 1.
Return MayContainStrings of the `NonEmptyClassString`.
NonEmptyClassString :: ClassSetCharacter NonEmptyClassString? 1. If
`NonEmptyClassString` is present, return `true`. 1. Return
`false`.

Static Semantics: GroupSpecifiersThatMatch ( thisGroupName: a `GroupName` Parse Node, ): a List of `GroupSpecifier` Parse Nodes
---------------------------------------------------------------------------------------------------------------------------------------

1. Let name be the CapturingGroupName of thisGroupName. 1. Let
pattern be the `Pattern` containing thisGroupName. 1. Let
result be a new empty List. 1. For each `GroupSpecifier` gs
that pattern contains, do 1. If the CapturingGroupName of gs is
name, then 1. Append gs to result. 1. Return result.

Static Semantics: CapturingGroupName ( ): a String
--------------------------------------------------

GroupName :: `<` RegExpIdentifierName `>` 1. Let idTextUnescaped
be the RegExpIdentifierCodePoints of `RegExpIdentifierName`. 1. Return
CodePointsToString(idTextUnescaped).

Static Semantics: RegExpIdentifierCodePoints ( ): a List of code points
-----------------------------------------------------------------------

RegExpIdentifierName :: RegExpIdentifierStart 1. Let cp be the
RegExpIdentifierCodePoint of `RegExpIdentifierStart`. 1. Return «
cp ». RegExpIdentifierName :: RegExpIdentifierName
RegExpIdentifierPart 1. Let cps be the RegExpIdentifierCodePoints of
the derived `RegExpIdentifierName`. 1. Let cp be the
RegExpIdentifierCodePoint of `RegExpIdentifierPart`. 1. Return the
list-concatenation of cps and « cp ».

Static Semantics: RegExpIdentifierCodePoint ( ): a code point
-------------------------------------------------------------

RegExpIdentifierStart :: IdentifierStartChar 1. Return the code point
matched by `IdentifierStartChar`. RegExpIdentifierPart ::
IdentifierPartChar 1. Return the code point matched by
`IdentifierPartChar`. RegExpIdentifierStart :: `\\`
RegExpUnicodeEscapeSequence RegExpIdentifierPart :: `\\`
RegExpUnicodeEscapeSequence 1. Return the code point whose numeric value
is the CharacterValue of `RegExpUnicodeEscapeSequence`.
RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate 1.
Let lead be the code unit whose numeric value is the numeric value
of the code point matched by `UnicodeLeadSurrogate`. 1. Let trail
be the code unit whose numeric value is the numeric value of the code
point matched by `UnicodeTrailSurrogate`. 1. Return
UTF16SurrogatePairToCodePoint(lead, trail).

Pattern Semantics
-----------------

A regular expression pattern is converted into an Abstract Closure using
the process described below. An implementation is encouraged to use more
efficient algorithms than the ones listed below, as long as the results
are the same. The Abstract Closure is used as the value of a RegExp
object's [[RegExpMatcher]] internal slot.

A `Pattern` is a BMP pattern if its associated flags contain neither a
`u` nor a `v`. Otherwise, it is a Unicode pattern. A BMP pattern
matches against a String interpreted as consisting of a sequence of
16-bit values that are Unicode code points in the range of the Basic
Multilingual Plane. A Unicode pattern matches against a String
interpreted as consisting of Unicode code points encoded using UTF-16.
In the context of describing the behaviour of a BMP pattern “character”
means a single 16-bit Unicode BMP code point. In the context of
describing the behaviour of a Unicode pattern “character” means a UTF-16
encoded code point (). In either context, “character value” means the
numeric value of the corresponding non-encoded code point.

The syntax and semantics of `Pattern` is defined as if the source text
for the `Pattern` was a List of `SourceCharacter` values where each
`SourceCharacter` corresponds to a Unicode code point. If a BMP
pattern contains a non-BMP `SourceCharacter` the entire pattern is
encoded using UTF-16 and the individual code units of that encoding are
used as the elements of the List.

For example, consider a pattern expressed in source text as the single
non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as a
Unicode pattern, it would be a single element (character) List
consisting of the single code point U+1D11E. However, interpreted as a
BMP pattern, it is first UTF-16 encoded to produce a two element List
consisting of the code units 0xD834 and 0xDD1E.

Patterns are passed to the RegExp constructor as ECMAScript String
values in which non-BMP characters are UTF-16 encoded. For example, the
single character MUSICAL SYMBOL G CLEF pattern, expressed as a String
value, is a String of length 2 whose elements were the code units 0xD834
and 0xDD1E. So no further translation of the string would be necessary
to process it as a BMP pattern consisting of two pattern characters.
However, to process it as a Unicode pattern
UTF16SurrogatePairToCodePoint must be used in producing a List whose
sole element is a single pattern character, the code point U+1D11E.

An implementation may not actually perform such translations to or from
UTF-16, but the semantics of this specification requires that the result
of pattern matching be as if such translations were performed.

Notation
--------

The descriptions below use the following internal data structures:

- A CharSetElement is one of the two following entities:

  - If rer.[[UnicodeSets]] is `false`, then a CharSetElement is a
    character in the sense of the Pattern Semantics above.
  - If rer.[[UnicodeSets]] is `true`, then a CharSetElement is a
    sequence whose elements are characters in the sense of the Pattern
    Semantics above. This includes the empty sequence, sequences of one
    character, and sequences of more than one character. For
    convenience, when working with CharSetElements of this kind, an
    individual character is treated interchangeably with a sequence of
    one character.

- A CharSet is a mathematical set of CharSetElements.
- A CaptureRange is a Record { [[StartIndex]], [[EndIndex]] } that
  represents the range of characters included in a capture, where
  [[StartIndex]] is an integer representing the start index (inclusive)
  of the range within Input, and [[EndIndex]] is an integer
  representing the end index (exclusive) of the range within Input.
  For any CaptureRange, these indices must satisfy the invariant that
  [[StartIndex]] ≤ [[EndIndex]].
- A MatchState is a Record { [[Input]], [[EndIndex]], [[Captures]] }
  where [[Input]] is a List of characters representing the String being
  matched, [[EndIndex]] is an integer, and [[Captures]] is a List of
  values, one for each left-capturing parenthesis in the pattern. States
  are used to represent partial match states in the regular expression
  matching algorithms. The [[EndIndex]] is one plus the index of the
  last input character matched so far by the pattern, while [[Captures]]
  holds the results of capturing parentheses. The n\ :sup:`th`
  element of [[Captures]] is either a CaptureRange representing the
  range of characters captured by the n\ :sup:`th` set of capturing
  parentheses, or `undefined` if the n\ :sup:`th` set of capturing
  parentheses hasn't been reached yet. Due to backtracking, many States
  may be in use at any time during the matching process.
- A MatchResult is either a MatchState or the special token ~failure~
  that indicates that the match failed.
- A MatcherContinuation is an Abstract Closure that takes one MatchState
  argument and returns a MatchResult result. The MatcherContinuation
  attempts to match the remaining portion (specified by the closure's
  captured values) of the pattern against Input, starting at the
  intermediate state given by its MatchState argument. If the match
  succeeds, the MatcherContinuation returns the final MatchState that it
  reached; if the match fails, the MatcherContinuation returns
  ~failure~.
- A Matcher is an Abstract Closure that takes two arguments—a MatchState
  and a MatcherContinuation—and returns a MatchResult result. A Matcher
  attempts to match a middle subpattern (specified by the closure's
  captured values) of the pattern against the MatchState's [[Input]],
  starting at the intermediate state given by its MatchState argument.
  The MatcherContinuation argument should be a closure that matches the
  rest of the pattern. After matching the subpattern of a pattern to
  obtain a new MatchState, the Matcher then calls MatcherContinuation on
  that new MatchState to test if the rest of the pattern can match as
  well. If it can, the Matcher returns the MatchState returned by
  MatcherContinuation; if not, the Matcher may try different choices at
  its choice points, repeatedly calling MatcherContinuation until it
  either succeeds or all possibilities have been exhausted.

RegExp Records
--------------

A RegExp Record is a Record value used to store information about a
RegExp that is needed during compilation and possibly during matching.

It has the following fields:

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[IgnoreCase]]       | a Boolean            | indicates whether    |
|                      |                      | `"i"` appears in   |
|                      |                      | the RegExp's flags   |
+----------------------+----------------------+----------------------+
| [[Multiline]]        | a Boolean            | indicates whether    |
|                      |                      | `"m"` appears in   |
|                      |                      | the RegExp's flags   |
+----------------------+----------------------+----------------------+
| [[DotAll]]           | a Boolean            | indicates whether    |
|                      |                      | `"s"` appears in   |
|                      |                      | the RegExp's flags   |
+----------------------+----------------------+----------------------+
| [[Unicode]]          | a Boolean            | indicates whether    |
|                      |                      | `"u"` appears in   |
|                      |                      | the RegExp's flags   |
+----------------------+----------------------+----------------------+
| [[UnicodeSets]]      | a Boolean            | indicates whether    |
|                      |                      | `"v"` appears in   |
|                      |                      | the RegExp's flags   |
+----------------------+----------------------+----------------------+
| [[Ca                 | a non-negative       | the number of        |
| pturingGroupsCount]] | integer              | left-capturing       |
|                      |                      | parentheses in the   |
|                      |                      | RegExp's pattern     |
+----------------------+----------------------+----------------------+

Runtime Semantics: CompilePattern ( rer: a RegExp Record, ): an Abstract Closure that takes a List of characters and a non-negative integer and returns a MatchResult
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Pattern :: Disjunction 1. Let m be CompileSubpattern of
`Disjunction` with arguments rer and ~forward~. 1. Return a new
Abstract Closure with parameters (Input, index) that captures
rer and m and performs the following steps when called: 1.
Assert: Input is a List of characters. 1. Assert: 0 ≤ index ≤
the number of elements in Input. 1. Let c be a new
MatcherContinuation with parameters (y) that captures nothing and
performs the following steps when called: 1. Assert: y is a
MatchState. 1. Return y. 1. Let cap be a List of
rer.[[CapturingGroupsCount]] `undefined` values, indexed 1 through
rer.[[CapturingGroupsCount]]. 1. Let x be the MatchState {
[[Input]]: Input, [[EndIndex]]: index, [[Captures]]: cap }.
1. Return m(x, c).

A Pattern compiles to an Abstract Closure value. RegExpBuiltinExec can
then apply this procedure to a List of characters and an offset within
that List to determine whether the pattern would match starting at
exactly that offset within the List, and, if it does match, what the
values of the capturing parentheses would be. The algorithms in are
designed so that compiling a pattern may throw a `SyntaxError`
exception; on the other hand, once the pattern is successfully compiled,
applying the resulting Abstract Closure to find a match in a List of
characters cannot throw an exception (except for any
implementation-defined exceptions that can occur anywhere such as
out-of-memory).

Runtime Semantics: CompileSubpattern ( rer: a RegExp Record, direction: ~forward~ or ~backward~, ): a Matcher
---------------------------------------------------------------------------------------------------------------------

This section is amended in .

Disjunction :: Alternative `|` Disjunction 1. Let m1 be
CompileSubpattern of `Alternative` with arguments rer and
direction. 1. Let m2 be CompileSubpattern of `Disjunction`
with arguments rer and direction. 1. Return
MatchTwoAlternatives(m1, m2).

The `|` regular expression operator separates two alternatives. The
pattern first tries to match the left `Alternative` (followed by the
sequel of the regular expression); if it fails, it tries to match the
right `Disjunction` (followed by the sequel of the regular
expression). If the left `Alternative`, the right `Disjunction`, and
the sequel all have choice points, all choices in the sequel are tried
before moving on to the next choice in the left `Alternative`. If
choices in the left `Alternative` are exhausted, the right
`Disjunction` is tried instead of the left `Alternative`. Any
capturing parentheses inside a portion of the pattern skipped by `|`
produce `undefined` values instead of Strings. Thus, for example,

.. code:: javascript

   /a|ab/.exec("abc")

returns the result `"a"` and not `"ab"`. Moreover,

.. code:: javascript

   /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

.. code:: javascript

   ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

.. code:: javascript

   ["abc", "ab", undefined, "ab", "c", "c", undefined]

The order in which the two alternatives are tried is independent of the
value of direction.

Alternative :: [empty] 1. Return EmptyMatcher(). Alternative ::
Alternative Term 1. Let m1 be CompileSubpattern of `Alternative`
with arguments rer and direction. 1. Let m2 be
CompileSubpattern of `Term` with arguments rer and direction.
1. Return MatchSequence(m1, m2, direction).

Consecutive \|Term|s try to simultaneously match consecutive portions of
Input. When direction is ~forward~, if the left `Alternative`,
the right `Term`, and the sequel of the regular expression all have
choice points, all choices in the sequel are tried before moving on to
the next choice in the right `Term`, and all choices in the right
`Term` are tried before moving on to the next choice in the left
`Alternative`. When direction is ~backward~, the evaluation order
of `Alternative` and `Term` are reversed.

Term :: Assertion 1. Return CompileAssertion of `Assertion` with
argument rer.

The resulting Matcher is independent of direction.

Term :: Atom 1. Return CompileAtom of `Atom` with arguments rer
and direction. Term :: Atom Quantifier 1. Let m be CompileAtom
of `Atom` with arguments rer and direction. 1. Let q be
CompileQuantifier of `Quantifier`. 1. Assert: q.[[Min]] ≤
q.[[Max]]. 1. Let parenIndex be
CountLeftCapturingParensBefore(`Term`). 1. Let parenCount be
CountLeftCapturingParensWithin(`Atom`). 1. Return a new Matcher with
parameters (x, c) that captures m, q, parenIndex,
and parenCount and performs the following steps when called: 1.
Assert: x is a MatchState. 1. Assert: c is a
MatcherContinuation. 1. Return RepeatMatcher(m, q.[[Min]],
q.[[Max]], q.[[Greedy]], x, c, parenIndex,
parenCount).

RepeatMatcher ( m: a Matcher, min: a non-negative integer, max: a non-negative integer or +∞, greedy: a Boolean, x: a MatchState, c: a MatcherContinuation, parenIndex: a non-negative integer, parenCount: a non-negative integer, ): a MatchResult
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. If max = 0, return c(x). 1. Let d be a new
MatcherContinuation with parameters (y) that captures m,
min, max, greedy, x, c, parenIndex, and
parenCount and performs the following steps when called: 1. Assert:
y is a MatchState. 1. [id="step-repeatmatcher-done"] If min = 0
and y.[[EndIndex]] = x.[[EndIndex]], return ~failure~. 1. If
min = 0, let min2 be 0; otherwise let min2 be min - 1.
1. If max = +∞, let max2 be +∞; otherwise let max2 be
max - 1. 1. Return RepeatMatcher(m, min2, max2,
greedy, y, c, parenIndex, parenCount). 1. Let
cap be a copy of x.[[Captures]]. 1.
[id="step-repeatmatcher-clear-captures"] For each integer k in the
inclusive interval from parenIndex + 1 to parenIndex +
parenCount, set cap[k] to `undefined`. 1. Let Input be
x.[[Input]]. 1. Let e be x.[[EndIndex]]. 1. Let xr be
the MatchState { [[Input]]: Input, [[EndIndex]]: e,
[[Captures]]: cap }. 1. If min ≠ 0, return m(xr, d).
1. If greedy is `false`, then 1. Let z be c(x). 1. If
z is not ~failure~, return z. 1. Return m(xr, d). 1.
Let z be m(xr, d). 1. If z is not ~failure~, return
z. 1. Return c(x).

An `Atom` followed by a `Quantifier` is repeated the number of times
specified by the `Quantifier`. A `Quantifier` can be non-greedy, in
which case the `Atom` pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
`Atom` pattern is repeated as many times as possible while still
matching the sequel. The `Atom` pattern is repeated rather than the
input character sequence that it matches, so different repetitions of
the `Atom` can match different input substrings.

If the `Atom` and the sequel of the regular expression all have choice
points, the `Atom` is first matched as many (or as few, if non-greedy)
times as possible. All choices in the sequel are tried before moving on
to the next choice in the last repetition of `Atom`. All choices in
the last (n\ :sup:`th`) repetition of `Atom` are tried before moving
on to the next choice in the next-to-last (n - 1)\ :sup:`st` repetition
of `Atom`; at which point it may turn out that more or fewer
repetitions of `Atom` are now possible; these are exhausted (again,
starting with either as few or as many as possible) before moving on to
the next choice in the (n - 1)\ :sup:`st` repetition of `Atom` and so
on.

Compare

.. code:: javascript

   /a[a-z]{2,4}/.exec("abcdefghi")

which returns `"abcde"` with

.. code:: javascript

   /a[a-z]{2,4}?/.exec("abcdefghi")

which returns `"abc"`.

Consider also

.. code:: javascript

   /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

.. code:: javascript

   ["aaba", "ba"]

and not any of:

.. code:: javascript

                 ["aabaac", "aabaac"]
                 ["aabaac", "c"]
               

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

.. code:: javascript

   "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")

which returns the gcd in unary notation `"aaaaa"`.

Step of the RepeatMatcher clears `Atom`'s captures each time `Atom`
is repeated. We can see its behaviour in the regular expression

.. code:: javascript

   /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

.. code:: javascript

   ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

.. code:: javascript

   ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost `*` clears all captured
Strings contained in the quantified `Atom`, which in this case
includes capture Strings numbered 2, 3, 4, and 5.

Step of the RepeatMatcher states that once the minimum number of
repetitions has been satisfied, any more expansions of `Atom` that
match the empty character sequence are not considered for further
repetitions. This prevents the regular expression engine from falling
into an infinite loop on patterns such as:

.. code:: javascript

   /(a*)*/.exec("b")

or the slightly more complicated:

.. code:: javascript

   /(a*)b\1+/.exec("baaaac")

which returns the array

.. code:: javascript

   ["b", ""]

EmptyMatcher ( ): a Matcher
---------------------------

1. Return a new Matcher with parameters (x, c) that captures
nothing and performs the following steps when called: 1. Assert: x
is a MatchState. 1. Assert: c is a MatcherContinuation. 1. Return
c(x).

MatchTwoAlternatives ( m1: a Matcher, m2: a Matcher, ): a Matcher
-------------------------------------------------------------------------

1. Return a new Matcher with parameters (x, c) that captures
m1 and m2 and performs the following steps when called: 1.
Assert: x is a MatchState. 1. Assert: c is a
MatcherContinuation. 1. Let r be m1(x, c). 1. If r
is not ~failure~, return r. 1. Return m2(x, c).

MatchSequence ( m1: a Matcher, m2: a Matcher, direction: ~forward~ or ~backward~, ): a Matcher
----------------------------------------------------------------------------------------------------------

1. If direction is ~forward~, then 1. Return a new Matcher with
parameters (x, c) that captures m1 and m2 and performs
the following steps when called: 1. Assert: x is a MatchState. 1.
Assert: c is a MatcherContinuation. 1. Let d be a new
MatcherContinuation with parameters (y) that captures c and
m2 and performs the following steps when called: 1. Assert: y is
a MatchState. 1. Return m2(y, c). 1. Return m1(x,
d). 1. Else, 1. Assert: direction is ~backward~. 1. Return a new
Matcher with parameters (x, c) that captures m1 and m2
and performs the following steps when called: 1. Assert: x is a
MatchState. 1. Assert: c is a MatcherContinuation. 1. Let d be a
new MatcherContinuation with parameters (y) that captures c and
m1 and performs the following steps when called: 1. Assert: y is
a MatchState. 1. Return m1(y, c). 1. Return m2(x,
d).

Runtime Semantics: CompileAssertion ( rer: a RegExp Record, ): a Matcher
----------------------------------------------------------------------------

This section is amended in .

Assertion :: `^` 1. Return a new Matcher with parameters (x,
c) that captures rer and performs the following steps when
called: 1. Assert: x is a MatchState. 1. Assert: c is a
MatcherContinuation. 1. Let Input be x.[[Input]]. 1. Let e
be x.[[EndIndex]]. 1. If e = 0, or if rer.[[Multiline]] is
`true` and the character Input[e - 1] is matched by
`LineTerminator`, then 1. Return c(x). 1. Return ~failure~.

Even when the `y` flag is used with a pattern, `^` always matches
only at the beginning of Input, or (if rer.[[Multiline]] is
`true`) at the beginning of a line.

Assertion :: `$` 1. Return a new Matcher with parameters (x,
c) that captures rer and performs the following steps when
called: 1. Assert: x is a MatchState. 1. Assert: c is a
MatcherContinuation. 1. Let Input be x.[[Input]]. 1. Let e
be x.[[EndIndex]]. 1. Let InputLength be the number of elements
in Input. 1. If e = InputLength, or if rer.[[Multiline]]
is `true` and the character Input[e] is matched by
`LineTerminator`, then 1. Return c(x). 1. Return ~failure~.
Assertion :: `\\b` 1. Return a new Matcher with parameters (x,
c) that captures rer and performs the following steps when
called: 1. Assert: x is a MatchState. 1. Assert: c is a
MatcherContinuation. 1. Let Input be x.[[Input]]. 1. Let e
be x.[[EndIndex]]. 1. Let a be IsWordChar(rer, Input,
e - 1). 1. Let b be IsWordChar(rer, Input, e). 1. If
a is `true` and b is `false`, or if a is `false` and
b is `true`, return c(x). 1. Return ~failure~. Assertion
:: `\\B` 1. Return a new Matcher with parameters (x, c) that
captures rer and performs the following steps when called: 1.
Assert: x is a MatchState. 1. Assert: c is a
MatcherContinuation. 1. Let Input be x.[[Input]]. 1. Let e
be x.[[EndIndex]]. 1. Let a be IsWordChar(rer, Input,
e - 1). 1. Let b be IsWordChar(rer, Input, e). 1. If
a is `true` and b is `true`, or if a is `false` and
b is `false`, return c(x). 1. Return ~failure~. Assertion
:: `(?=` Disjunction `)` 1. Let m be CompileSubpattern of
`Disjunction` with arguments rer and ~forward~. 1. Return a new
Matcher with parameters (x, c) that captures m and performs
the following steps when called: 1. Assert: x is a MatchState. 1.
Assert: c is a MatcherContinuation. 1. Let d be a new
MatcherContinuation with parameters (y) that captures nothing and
performs the following steps when called: 1. Assert: y is a
MatchState. 1. Return y. 1. Let r be m(x, d). 1. If
r is ~failure~, return ~failure~. 1. Assert: r is a MatchState.
1. Let cap be r.[[Captures]]. 1. Let Input be
x.[[Input]]. 1. Let xe be x.[[EndIndex]]. 1. Let z be
the MatchState { [[Input]]: Input, [[EndIndex]]: xe,
[[Captures]]: cap }. 1. Return c(z).

The form `(?=` `Disjunction` `)` specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside
`Disjunction` must match at the current position, but the current
position is not advanced before matching the sequel. If `Disjunction`
can match at the current position in several ways, only the first one is
tried. Unlike other regular expression operators, there is no
backtracking into a `(?=` form (this unusual behaviour is inherited
from Perl). This only matters when the `Disjunction` contains
capturing parentheses and the sequel of the pattern contains
backreferences to those captures.

For example,

.. code:: javascript

   /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first `b` and therefore
returns the array:

.. code:: javascript

   ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

.. code:: javascript

   /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

.. code:: javascript

   ["aba", "a"]

and not:

.. code:: javascript

   ["aaaba", "a"]

Assertion :: `(?!` Disjunction `)` 1. Let m be CompileSubpattern
of `Disjunction` with arguments rer and ~forward~. 1. Return a new
Matcher with parameters (x, c) that captures m and performs
the following steps when called: 1. Assert: x is a MatchState. 1.
Assert: c is a MatcherContinuation. 1. Let d be a new
MatcherContinuation with parameters (y) that captures nothing and
performs the following steps when called: 1. Assert: y is a
MatchState. 1. Return y. 1. Let r be m(x, d). 1. If
r is not ~failure~, return ~failure~. 1. Return c(x).

The form `(?!` `Disjunction` `)` specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside
`Disjunction` must fail to match at the current position. The current
position is not advanced before matching the sequel. `Disjunction` can
contain capturing parentheses, but backreferences to them only make
sense from within `Disjunction` itself. Backreferences to these
capturing parentheses from elsewhere in the pattern always return
`undefined` because the negative lookahead must fail for the pattern
to succeed. For example,

.. code:: javascript

   /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an `a` not immediately followed by some positive number n of
`a`'s, a `b`, another n `a`'s (specified by the first `\\\\2`)
and a `c`. The second `\\\\2` is outside the negative lookahead, so
it matches against `undefined` and therefore always succeeds. The
whole expression returns the array:

.. code:: javascript

   ["baaabaac", "ba", undefined, "abaac"]

Assertion :: `(?<=` Disjunction `)` 1. Let m be
CompileSubpattern of `Disjunction` with arguments rer and
~backward~. 1. Return a new Matcher with parameters (x, c) that
captures m and performs the following steps when called: 1. Assert:
x is a MatchState. 1. Assert: c is a MatcherContinuation. 1. Let
d be a new MatcherContinuation with parameters (y) that captures
nothing and performs the following steps when called: 1. Assert: y
is a MatchState. 1. Return y. 1. Let r be m(x, d).
1. If r is ~failure~, return ~failure~. 1. Assert: r is a
MatchState. 1. Let cap be r.[[Captures]]. 1. Let Input be
x.[[Input]]. 1. Let xe be x.[[EndIndex]]. 1. Let z be
the MatchState { [[Input]]: Input, [[EndIndex]]: xe,
[[Captures]]: cap }. 1. Return c(z). Assertion :: `(?<!`
Disjunction `)` 1. Let m be CompileSubpattern of `Disjunction`
with arguments rer and ~backward~. 1. Return a new Matcher with
parameters (x, c) that captures m and performs the following
steps when called: 1. Assert: x is a MatchState. 1. Assert: c is
a MatcherContinuation. 1. Let d be a new MatcherContinuation with
parameters (y) that captures nothing and performs the following
steps when called: 1. Assert: y is a MatchState. 1. Return y. 1.
Let r be m(x, d). 1. If r is not ~failure~, return
~failure~. 1. Return c(x).

IsWordChar ( rer: a RegExp Record, Input: a List of characters, e: an integer, ): a Boolean
-------------------------------------------------------------------------------------------------------

1. Let InputLength be the number of elements in Input. 1. If
e = -1 or e = InputLength, return `false`. 1. Let c be
the character Input[e]. 1. If WordCharacters(rer) contains
c, return `true`. 1. Return `false`.

Runtime Semantics: CompileQuantifier ( ): a Record with fields [[Min]] (a non-negative integer), [[Max]] (a non-negative integer or +∞), and [[Greedy]] (a Boolean)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Quantifier :: QuantifierPrefix 1. Let qp be CompileQuantifierPrefix
of `QuantifierPrefix`. 1. Return the Record { [[Min]]: qp.[[Min]],
[[Max]]: qp.[[Max]], [[Greedy]]: `true` }. Quantifier ::
QuantifierPrefix `?` 1. Let qp be CompileQuantifierPrefix of
`QuantifierPrefix`. 1. Return the Record { [[Min]]: qp.[[Min]],
[[Max]]: qp.[[Max]], [[Greedy]]: `false` }.

Runtime Semantics: CompileQuantifierPrefix ( ): a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +∞)
------------------------------------------------------------------------------------------------------------------------------------------------

QuantifierPrefix :: `*` 1. Return the Record { [[Min]]: 0, [[Max]]: +∞
}. QuantifierPrefix :: `+` 1. Return the Record { [[Min]]: 1, [[Max]]:
+∞ }. QuantifierPrefix :: `?` 1. Return the Record { [[Min]]: 0,
[[Max]]: 1 }. QuantifierPrefix :: `{` DecimalDigits `}` 1. Let i
be the MV of `DecimalDigits` (see ). 1. Return the Record { [[Min]]:
i, [[Max]]: i }. QuantifierPrefix :: `{` DecimalDigits `,}`
1. Let i be the MV of `DecimalDigits`. 1. Return the Record {
[[Min]]: i, [[Max]]: +∞ }. QuantifierPrefix :: `{` DecimalDigits
`,` DecimalDigits `}` 1. Let i be the MV of the first
`DecimalDigits`. 1. Let j be the MV of the second
`DecimalDigits`. 1. Return the Record { [[Min]]: i, [[Max]]: j
}.

Runtime Semantics: CompileAtom ( rer: a RegExp Record, direction: ~forward~ or ~backward~, ): a Matcher
---------------------------------------------------------------------------------------------------------------

This section is amended in .

Atom :: PatternCharacter 1. Let ch be the character matched by
`PatternCharacter`. 1. Let A be a one-element CharSet containing
the character ch. 1. Return CharacterSetMatcher(rer, A,
`false`, direction). Atom :: `.` 1. Let A be
AllCharacters(rer). 1. If rer.[[DotAll]] is not `true`, then
1. Remove from A all characters corresponding to a code point on the
right-hand side of the `LineTerminator` production. 1. Return
CharacterSetMatcher(rer, A, `false`, direction). Atom ::
CharacterClass 1. Let cc be CompileCharacterClass of
`CharacterClass` with argument rer. 1. Let cs be
cc.[[CharSet]]. 1. If rer.[[UnicodeSets]] is `false`, or if
every CharSetElement of cs consists of a single character (including
if cs is empty), return CharacterSetMatcher(rer, cs,
cc.[[Invert]], direction). 1. Assert: cc.[[Invert]] is
`false`. 1. Let lm be an empty List of Matchers. 1. For each
CharSetElement s in cs containing more than 1 character,
iterating in descending order of length, do 1. Let cs2 be a
one-element CharSet containing the last code point of s. 1. Let
m2 be CharacterSetMatcher(rer, cs2, `false`,
direction). 1. For each code point c1 in s, iterating
backwards from its second-to-last code point, do 1. Let cs1 be a
one-element CharSet containing c1. 1. Let m1 be
CharacterSetMatcher(rer, cs1, `false`, direction). 1. Set
m2 to MatchSequence(m1, m2, direction). 1. Append m2
to lm. 1. Let singles be the CharSet containing every
CharSetElement of cs that consists of a single character. 1. Append
CharacterSetMatcher(rer, singles, `false`, direction) to
lm. 1. If cs contains the empty sequence of characters, append
EmptyMatcher() to lm. 1. Let m2 be the last Matcher in lm.
1. For each Matcher m1 of lm, iterating backwards from its
second-to-last element, do 1. Set m2 to MatchTwoAlternatives(m1,
m2). 1. Return m2. Atom :: `(` GroupSpecifier? Disjunction
`)` 1. Let m be CompileSubpattern of `Disjunction` with
arguments rer and direction. 1. Let parenIndex be
CountLeftCapturingParensBefore(`Atom`). 1. Return a new Matcher with
parameters (x, c) that captures direction, m, and
parenIndex and performs the following steps when called: 1. Assert:
x is a MatchState. 1. Assert: c is a MatcherContinuation. 1. Let
d be a new MatcherContinuation with parameters (y) that captures
x, c, direction, and parenIndex and performs the
following steps when called: 1. Assert: y is a MatchState. 1. Let
cap be a copy of y.[[Captures]]. 1. Let Input be
x.[[Input]]. 1. Let xe be x.[[EndIndex]]. 1. Let ye be
y.[[EndIndex]]. 1. If direction is ~forward~, then 1. Assert:
xe ≤ ye. 1. Let r be the CaptureRange { [[StartIndex]]:
xe, [[EndIndex]]: ye }. 1. Else, 1. Assert: direction is
~backward~. 1. Assert: ye ≤ xe. 1. Let r be the CaptureRange
{ [[StartIndex]]: ye, [[EndIndex]]: xe }. 1. Set
cap[parenIndex + 1] to r. 1. Let z be the MatchState {
[[Input]]: Input, [[EndIndex]]: ye, [[Captures]]: cap }. 1.
Return c(z). 1. Return m(x, d).

Parentheses of the form `(` `Disjunction` `)` serve both to group
the components of the `Disjunction` pattern together and to save the
result of the match. The result can be used either in a backreference
(`\\\\` followed by a non-zero decimal number), referenced in a
replace String, or returned as part of an array from the regular
expression matching Abstract Closure. To inhibit the capturing behaviour
of parentheses, use the form `(?:` `Disjunction` `)` instead.

Atom :: `(?:` Disjunction `)` 1. Return CompileSubpattern of
`Disjunction` with arguments rer and direction. AtomEscape ::
DecimalEscape 1. Let n be the CapturingGroupNumber of
`DecimalEscape`. 1. Assert: n ≤ rer.[[CapturingGroupsCount]].
1. Return BackreferenceMatcher(rer, « n », direction).

An escape sequence of the form `\\\\` followed by a non-zero decimal
number n matches the result of the n\ :sup:`th` set of capturing
parentheses (). It is an error if the regular expression has fewer than
n capturing parentheses. If the regular expression has n or more
capturing parentheses but the n\ :sup:`th` one is `undefined`
because it has not captured anything, then the backreference always
succeeds.

AtomEscape :: CharacterEscape 1. Let cv be the CharacterValue of
`CharacterEscape`. 1. Let ch be the character whose character
value is cv. 1. Let A be a one-element CharSet containing the
character ch. 1. Return CharacterSetMatcher(rer, A,
`false`, direction). AtomEscape :: CharacterClassEscape 1. Let
cs be CompileToCharSet of `CharacterClassEscape` with argument
rer. 1. If rer.[[UnicodeSets]] is `false`, or if every
CharSetElement of cs consists of a single character (including if
cs is empty), return CharacterSetMatcher(rer, cs, `false`,
direction). 1. Let lm be an empty List of Matchers. 1. For each
CharSetElement s in cs containing more than 1 character,
iterating in descending order of length, do 1. Let cs2 be a
one-element CharSet containing the last code point of s. 1. Let
m2 be CharacterSetMatcher(rer, cs2, `false`,
direction). 1. For each code point c1 in s, iterating
backwards from its second-to-last code point, do 1. Let cs1 be a
one-element CharSet containing c1. 1. Let m1 be
CharacterSetMatcher(rer, cs1, `false`, direction). 1. Set
m2 to MatchSequence(m1, m2, direction). 1. Append m2
to lm. 1. Let singles be the CharSet containing every
CharSetElement of cs that consists of a single character. 1. Append
CharacterSetMatcher(rer, singles, `false`, direction) to
lm. 1. If cs contains the empty sequence of characters, append
EmptyMatcher() to lm. 1. Let m2 be the last Matcher in lm.
1. For each Matcher m1 of lm, iterating backwards from its
second-to-last element, do 1. Set m2 to MatchTwoAlternatives(m1,
m2). 1. Return m2. AtomEscape :: `k` GroupName 1. Let
matchingGroupSpecifiers be GroupSpecifiersThatMatch(`GroupName`).
1. Let parenIndices be a new empty List. 1. For each
`GroupSpecifier` groupSpecifier of matchingGroupSpecifiers, do
1. Let parenIndex be
CountLeftCapturingParensBefore(groupSpecifier). 1. Append
parenIndex to parenIndices. 1. Return
BackreferenceMatcher(rer, parenIndices, direction).

CharacterSetMatcher ( rer: a RegExp Record, A: a CharSet, invert: a Boolean, direction: ~forward~ or ~backward~, ): a Matcher
---------------------------------------------------------------------------------------------------------------------------------------------

1. If rer.[[UnicodeSets]] is `true`, then 1. Assert: invert is
`false`. 1. Assert: Every CharSetElement of A consists of a single
character. 1. Return a new Matcher with parameters (x, c) that
captures rer, A, invert, and direction and performs the
following steps when called: 1. Assert: x is a MatchState. 1.
Assert: c is a MatcherContinuation. 1. Let Input be
x.[[Input]]. 1. Let e be x.[[EndIndex]]. 1. If direction
is ~forward~, let f be e + 1. 1. Else, let f be e - 1.
1. Let InputLength be the number of elements in Input. 1. If
f < 0 or f > InputLength, return ~failure~. 1. Let index
be min(e, f). 1. Let ch be the character
Input[index]. 1. Let cc be Canonicalize(rer, ch). 1.
If there exists a CharSetElement in A containing exactly one
character a such that Canonicalize(rer, a) is cc, let
found be `true`. Otherwise, let found be `false`. 1. If
invert is `false` and found is `false`, return ~failure~. 1.
If invert is `true` and found is `true`, return ~failure~.
1. Let cap be x.[[Captures]]. 1. Let y be the MatchState {
[[Input]]: Input, [[EndIndex]]: f, [[Captures]]: cap }. 1.
Return c(y).

BackreferenceMatcher ( rer: a RegExp Record, ns: a List of positive integers, direction: ~forward~ or ~backward~, ): a Matcher
------------------------------------------------------------------------------------------------------------------------------------------

1. Return a new Matcher with parameters (x, c) that captures
rer, ns, and direction and performs the following steps when
called: 1. Assert: x is a MatchState. 1. Assert: c is a
MatcherContinuation. 1. Let Input be x.[[Input]]. 1. Let cap
be x.[[Captures]]. 1. Let r be `undefined`. 1. For each
integer n of ns, do 1. If cap[n] is not `undefined`,
then 1. Assert: r is `undefined`. 1. Set r to cap[n].
1. If r is `undefined`, return c(x). 1. Let e be
x.[[EndIndex]]. 1. Let rs be r.[[StartIndex]]. 1. Let re
be r.[[EndIndex]]. 1. Let len be re - rs. 1. If
direction is ~forward~, let f be e + len. 1. Else, let
f be e - len. 1. Let InputLength be the number of
elements in Input. 1. If f < 0 or f > InputLength,
return ~failure~. 1. Let g be min(e, f). 1. If there exists
an integer i in the interval from 0 (inclusive) to len
(exclusive) such that Canonicalize(rer, Input[rs + i])
is not Canonicalize(rer, Input[g + i]), return
~failure~. 1. Let y be the MatchState { [[Input]]: Input,
[[EndIndex]]: f, [[Captures]]: cap }. 1. Return c(y).

Canonicalize ( rer: a RegExp Record, ch: a character, ): a character
----------------------------------------------------------------------------

1. If HasEitherUnicodeFlag(rer) is `true` and
rer.[[IgnoreCase]] is `true`, then 1. If the file
```CaseFolding.txt`` <https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt>`__
of the Unicode Character Database provides a simple or common case
folding mapping for ch, return the result of applying that mapping
to ch. 1. Return ch. 1. If rer.[[IgnoreCase]] is `false`,
return ch. 1. Assert: ch is a UTF-16 code unit. 1. Let cp be
the code point whose numeric value is the numeric value of ch. 1.
Let u be toUppercase(« cp »), according to the Unicode Default
Case Conversion algorithm. 1. Let uStr be CodePointsToString(u).
1. If the length of uStr ≠ 1, return ch. 1. Let cu be
uStr's single code unit element. 1. If the numeric value of ch ≥
128 and the numeric value of cu < 128, return ch. 1. Return
cu.

In case-insignificant matches when HasEitherUnicodeFlag(rer) is
`true`, all characters are implicitly case-folded using the simple
mapping provided by the Unicode Standard immediately before they are
compared. The simple mapping always maps to a single code point, so it
does not map, for example, `ß` (U+00DF LATIN SMALL LETTER SHARP S) to
`ss` or `SS`. It may however map code points outside the Basic Latin
block to code points within it—for example, `ſ` (U+017F LATIN SMALL
LETTER LONG S) case-folds to `s` (U+0073 LATIN SMALL LETTER S) and
`K` (U+212A KELVIN SIGN) case-folds to `k` (U+006B LATIN SMALL
LETTER K). Strings containing those code points are matched by regular
expressions such as `/[a-z]/ui`.

In case-insignificant matches when HasEitherUnicodeFlag(rer) is
`false`, the mapping is based on Unicode Default Case Conversion
algorithm toUppercase rather than toCasefold, which results in some
subtle differences. For example, `Ω` (U+2126 OHM SIGN) is mapped by
toUppercase to itself but by toCasefold to `ω` (U+03C9 GREEK SMALL
LETTER OMEGA) along with `Ω` (U+03A9 GREEK CAPITAL LETTER OMEGA), so
`"\\u2126"` is matched by `/[ω]/ui` and `/[\\u03A9]/ui` but not by
`/[ω]/i` or `/[\\u03A9]/i`. Also, no code point outside the Basic
Latin block is mapped to a code point within it, so strings such as
`"\\u017F ſ"` and `"\\u212A K"` are not matched by `/[a-z]/i`.

Runtime Semantics: CompileCharacterClass ( rer: a RegExp Record, ): a Record with fields [[CharSet]] (a CharSet) and [[Invert]] (a Boolean)
-----------------------------------------------------------------------------------------------------------------------------------------------

CharacterClass :: `[` ClassContents `]` 1. Let A be
CompileToCharSet of `ClassContents` with argument rer. 1. Return
the Record { [[CharSet]]: A, [[Invert]]: `false` }. CharacterClass
:: `[^` ClassContents `]` 1. Let A be CompileToCharSet of
`ClassContents` with argument rer. 1. If rer.[[UnicodeSets]]
is `true`, then 1. Return the Record { [[CharSet]]:
CharacterComplement(rer, A), [[Invert]]: `false` }. 1. Return
the Record { [[CharSet]]: A, [[Invert]]: `true` }.

Runtime Semantics: CompileToCharSet ( rer: a RegExp Record, ): a CharSet
----------------------------------------------------------------------------

This section is amended in .

ClassContents :: [empty] 1. Return the empty CharSet.
NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash 1. Let A
be CompileToCharSet of `ClassAtom` with argument rer. 1. Let B
be CompileToCharSet of `NonemptyClassRangesNoDash` with argument
rer. 1. Return the union of CharSets A and B.
NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents 1. Let
A be CompileToCharSet of the first `ClassAtom` with argument
rer. 1. Let B be CompileToCharSet of the second `ClassAtom`
with argument rer. 1. Let C be CompileToCharSet of
`ClassContents` with argument rer. 1. Let D be
CharacterRange(A, B). 1. Return the union of D and C.
NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash
1. Let A be CompileToCharSet of `ClassAtomNoDash` with argument
rer. 1. Let B be CompileToCharSet of
`NonemptyClassRangesNoDash` with argument rer. 1. Return the union
of CharSets A and B. NonemptyClassRangesNoDash ::
ClassAtomNoDash `-` ClassAtom ClassContents 1. Let A be
CompileToCharSet of `ClassAtomNoDash` with argument rer. 1. Let
B be CompileToCharSet of `ClassAtom` with argument rer. 1. Let
C be CompileToCharSet of `ClassContents` with argument rer. 1.
Let D be CharacterRange(A, B). 1. Return the union of D
and C.

`ClassContents` can expand into a single `ClassAtom` and/or ranges
of two `ClassAtom` separated by dashes. In the latter case the
`ClassContents` includes all characters between the first
`ClassAtom` and the second `ClassAtom`, inclusive; an error occurs
if either `ClassAtom` does not represent a single character (for
example, if one is \\w) or if the first `ClassAtom`'s character value
is strictly greater than the second `ClassAtom`'s character value.

Even if the pattern ignores case, the case of the two ends of a range is
significant in determining which characters belong to the range. Thus,
for example, the pattern `/[E-F]/i` matches only the letters `E`,
`F`, `e`, and `f`, while the pattern `/[E-f]/i` matches all
uppercase and lowercase letters in the Unicode Basic Latin block as well
as the symbols `[`, `\\\\`, `]`, `^`, ``, and :literal:```.

A `-` character can be treated literally or it can denote a range. It
is treated literally if it is the first or last character of
`ClassContents`, the beginning or end limit of a range specification,
or immediately follows a range specification.

ClassAtom :: `-` 1. Return the CharSet containing the single character
`-` U+002D (HYPHEN-MINUS). ClassAtomNoDash :: SourceCharacter but not
one of `\\` or `]` or `-` 1. Return the CharSet containing the
character matched by `SourceCharacter`. ClassEscape :: `b` `-`
CharacterEscape 1. Let cv be the CharacterValue of this
`ClassEscape`. 1. Let c be the character whose character value is
cv. 1. Return the CharSet containing the single character c.

A `ClassAtom` can use any of the escape sequences that are allowed in
the rest of the regular expression except for `\\\\b`, `\\\\B`, and
backreferences. Inside a `CharacterClass`, `\\\\b` means the
backspace character, while `\\\\B` and backreferences raise errors.
Using a backreference inside a `ClassAtom` causes an error.

CharacterClassEscape :: `d` 1. Return the ten-element CharSet
containing the characters `0`, `1`, `2`, `3`, `4`, `5`,
`6`, `7`, `8`, and `9`. CharacterClassEscape :: `D` 1. Let
S be the CharSet returned by CharacterClassEscape :: `d`. 1.
Return CharacterComplement(rer, S). CharacterClassEscape ::
`s` 1. Return the CharSet containing all characters corresponding to a
code point on the right-hand side of the `WhiteSpace` or
`LineTerminator` productions. CharacterClassEscape :: `S` 1. Let
S be the CharSet returned by CharacterClassEscape :: `s`. 1.
Return CharacterComplement(rer, S). CharacterClassEscape ::
`w` 1. Return MaybeSimpleCaseFolding(rer,
WordCharacters(rer)). CharacterClassEscape :: `W` 1. Let S be
the CharSet returned by CharacterClassEscape :: `w`. 1. Return
CharacterComplement(rer, S). CharacterClassEscape :: `p{`
UnicodePropertyValueExpression `}` 1. Return CompileToCharSet of
`UnicodePropertyValueExpression` with argument rer.
CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}` 1.
Let S be CompileToCharSet of `UnicodePropertyValueExpression` with
argument rer. 1. Assert: S contains only single code points. 1.
Return CharacterComplement(rer, S).
UnicodePropertyValueExpression :: UnicodePropertyName `=`
UnicodePropertyValue 1. Let ps be the source text matched by
`UnicodePropertyName`. 1. Let p be UnicodeMatchProperty(rer,
ps). 1. Assert: p is a Unicode property name or property alias
listed in the “Property name and aliases” column of . 1. Let vs be
the source text matched by `UnicodePropertyValue`. 1. Let v be
UnicodeMatchPropertyValue(p, vs). 1. Let A be the CharSet
containing all Unicode code points whose character database definition
includes the property p with value v. 1. Return
MaybeSimpleCaseFolding(rer, A). UnicodePropertyValueExpression
:: LoneUnicodePropertyNameOrValue 1. Let s be the source text
matched by `LoneUnicodePropertyNameOrValue`. 1. If
UnicodeMatchPropertyValue(`General_Category`, s) is a Unicode
property value or property value alias for the General_Category (gc)
property listed in
```PropertyValueAliases.txt`` <https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt>`__,
then 1. Return the CharSet containing all Unicode code points whose
character database definition includes the property “General_Category”
with value s. 1. Let p be UnicodeMatchProperty(rer, s).
1. Assert: p is a binary Unicode property or binary property alias
listed in the “Property name and aliases” column of , or a binary
Unicode property of strings listed in the “Property name” column of . 1.
Let A be the CharSet containing all CharSetElements whose character
database definition includes the property p with value “True”. 1.
Return MaybeSimpleCaseFolding(rer, A). ClassUnion ::
ClassSetRange ClassUnion? 1. Let A be CompileToCharSet of
`ClassSetRange` with argument rer. 1. If `ClassUnion` is
present, then 1. Let B be CompileToCharSet of `ClassUnion` with
argument rer. 1. Return the union of CharSets A and B. 1.
Return A. ClassUnion :: ClassSetOperand ClassUnion? 1. Let A be
CompileToCharSet of `ClassSetOperand` with argument rer. 1. If
`ClassUnion` is present, then 1. Let B be CompileToCharSet of
`ClassUnion` with argument rer. 1. Return the union of CharSets
A and B. 1. Return A. ClassIntersection :: ClassSetOperand
`&&` ClassSetOperand 1. Let A be CompileToCharSet of the first
`ClassSetOperand` with argument rer. 1. Let B be
CompileToCharSet of the second `ClassSetOperand` with argument
rer. 1. Return the intersection of CharSets A and B.
ClassIntersection :: ClassIntersection `&&` ClassSetOperand 1. Let
A be CompileToCharSet of the `ClassIntersection` with argument
rer. 1. Let B be CompileToCharSet of the `ClassSetOperand`
with argument rer. 1. Return the intersection of CharSets A and
B. ClassSubtraction :: ClassSetOperand `--` ClassSetOperand 1. Let
A be CompileToCharSet of the first `ClassSetOperand` with argument
rer. 1. Let B be CompileToCharSet of the second
`ClassSetOperand` with argument rer. 1. Return the CharSet
containing the CharSetElements of A which are not also
CharSetElements of B. ClassSubtraction :: ClassSubtraction `--`
ClassSetOperand 1. Let A be CompileToCharSet of the
`ClassSubtraction` with argument rer. 1. Let B be
CompileToCharSet of the `ClassSetOperand` with argument rer. 1.
Return the CharSet containing the CharSetElements of A which are not
also CharSetElements of B. ClassSetRange :: ClassSetCharacter `-`
ClassSetCharacter 1. Let A be CompileToCharSet of the first
`ClassSetCharacter` with argument rer. 1. Let B be
CompileToCharSet of the second `ClassSetCharacter` with argument
rer. 1. Return MaybeSimpleCaseFolding(rer, CharacterRange(A,
B)).

The result will often consist of two or more ranges. When UnicodeSets is
`true` and IgnoreCase is `true`, then
MaybeSimpleCaseFolding(rer, [Ā-č]) will include only the
odd-numbered code points of that range.

ClassSetOperand :: ClassSetCharacter 1. Let A be CompileToCharSet of
`ClassSetCharacter` with argument rer. 1. Return
MaybeSimpleCaseFolding(rer, A). ClassSetOperand ::
ClassStringDisjunction 1. Let A be CompileToCharSet of
`ClassStringDisjunction` with argument rer. 1. Return
MaybeSimpleCaseFolding(rer, A). ClassSetOperand :: NestedClass
1. Return CompileToCharSet of `NestedClass` with argument rer.
NestedClass :: `[` ClassContents `]` 1. Return CompileToCharSet of
`ClassContents` with argument rer. NestedClass :: `[^`
ClassContents `]` 1. Let A be CompileToCharSet of
`ClassContents` with argument rer. 1. Return
CharacterComplement(rer, A). NestedClass :: `\\`
CharacterClassEscape 1. Return CompileToCharSet of
`CharacterClassEscape` with argument rer. ClassStringDisjunction
:: `\\q{` ClassStringDisjunctionContents `}` 1. Return
CompileToCharSet of `ClassStringDisjunctionContents` with argument
rer. ClassStringDisjunctionContents :: ClassString 1. Let s be
CompileClassSetString of `ClassString` with argument rer. 1.
Return the CharSet containing the one string s.
ClassStringDisjunctionContents :: ClassString `|`
ClassStringDisjunctionContents 1. Let s be CompileClassSetString of
`ClassString` with argument rer. 1. Let A be the CharSet
containing the one string s. 1. Let B be CompileToCharSet of
`ClassStringDisjunctionContents` with argument rer. 1. Return the
union of CharSets A and B. ClassSetCharacter :: SourceCharacter
but not ClassSetSyntaxCharacter `\\` CharacterEscape `\\`
ClassSetReservedPunctuator 1. Let cv be the CharacterValue of this
`ClassSetCharacter`. 1. Let c be the character whose character
value is cv. 1. Return the CharSet containing the single character
c. ClassSetCharacter :: `\\b` 1. Return the CharSet containing the
single character U+0008 (BACKSPACE).

CharacterRange ( A: a CharSet, B: a CharSet, ): a CharSet
-----------------------------------------------------------------

1. Assert: A and B each contain exactly one character. 1. Let
a be the one character in CharSet A. 1. Let b be the one
character in CharSet B. 1. Let i be the character value of
character a. 1. Let j be the character value of character b.
1. Assert: i ≤ j. 1. Return the CharSet containing all
characters with a character value in the inclusive interval from i
to j.

HasEitherUnicodeFlag ( rer: a RegExp Record, ): a Boolean
-------------------------------------------------------------

1. If rer.[[Unicode]] is `true` or rer.[[UnicodeSets]] is
`true`, then 1. Return `true`. 1. Return `false`.

WordCharacters ( rer: a RegExp Record, ): a CharSet
-------------------------------------------------------

description
   Returns a CharSet containing the characters considered "word
   characters" for the purposes of `\\\\b`, `\\\\B`, `\\\\w`, and
   `\\\\W`

1. Let basicWordChars be the CharSet containing every character in
the ASCII word characters. 1. Let extraWordChars be the CharSet
containing all characters c such that c is not in
basicWordChars but Canonicalize(rer, c) is in
basicWordChars. 1. Assert: extraWordChars is empty unless
HasEitherUnicodeFlag(rer) is `true` and rer.[[IgnoreCase]] is
`true`. 1. Return the union of basicWordChars and
extraWordChars.

AllCharacters ( rer: a RegExp Record, ): a CharSet
------------------------------------------------------

description
   Returns the set of “all characters” according to the regular
   expression flags.

1. If rer.[[UnicodeSets]] is `true` and rer.[[IgnoreCase]] is
`true`, then 1. [declared="c"] Return the CharSet containing all
Unicode code points c that do not have a `Simple Case
Folding <https://www.unicode.org/reports/tr44/#Simple_Case_Folding>`__
mapping (that is, scf(c)=_c). 1. Else if
HasEitherUnicodeFlag(rer) is `true`, then 1. Return the CharSet
containing all code point values. 1. Else, 1. Return the CharSet
containing all code unit values.

MaybeSimpleCaseFolding ( rer: a RegExp Record, A: a CharSet, ): a CharSet
---------------------------------------------------------------------------------

description
   If rer.[[UnicodeSets]] is `false` or rer.[[IgnoreCase]] is
   `false`, it returns A. Otherwise, it uses the `Simple Case
   Folding <https://www.unicode.org/reports/tr44/#Simple_Case_Folding>`__
   (scf(cp)) definitions in the file
   ```CaseFolding.txt`` <https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt>`__
   of the Unicode Character Database (each of which maps a single code
   point to another single code point) to map each CharSetElement of
   A character-by-character into a canonical form and returns the
   resulting CharSet.

1. If rer.[[UnicodeSets]] is `false` or rer.[[IgnoreCase]] is
`false`, return A. 1. Let B be a new empty CharSet. 1. For
each CharSetElement s of A, do 1. Let t be an empty sequence
of characters. 1. For each single code point cp in s, do 1.
Append scf(cp) to t. 1. Add t to B. 1. Return B.

CharacterComplement ( rer: a RegExp Record, S: a CharSet, ): a CharSet
------------------------------------------------------------------------------

1. Let A be AllCharacters(rer). 1. Return the CharSet containing
the CharSetElements of A which are not also CharSetElements of
S.

UnicodeMatchProperty ( rer: a RegExp Record, p: ECMAScript source text, ): a Unicode property name
----------------------------------------------------------------------------------------------------------

1. If rer.[[UnicodeSets]] is `true` and p is a Unicode
property name listed in the “Property name” column of , then 1. Return
the List of Unicode code points p. 1. Assert: p is a Unicode
property name or property alias listed in the “Property name and
aliases” column of or . 1. Let c be the canonical property name of
p as given in the “Canonical property name” column of the
corresponding row. 1. Return the List of Unicode code points c.

Implementations must support the Unicode property names and aliases
listed in , , and . To ensure interoperability, implementations must not
support any other property names or aliases.

For example, `Script_Extensions` (property name) and `scx` (property
alias) are valid, but `script_extensions` or `Scx` aren't.

The listed properties form a superset of what `UTS18
RL1.2 <https://unicode.org/reports/tr18/#RL1.2>`__ requires.

The spellings of entries in these tables (including casing) match the
spellings used in the file
```PropertyAliases.txt`` <https://unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt>`__
in the Unicode Character Database. The precise spellings in that file
are `guaranteed to be
stable <https://www.unicode.org/policies/stability_policy.html#Alias_Stability>`__.

UnicodeMatchPropertyValue ( p: ECMAScript source text, v: ECMAScript source text, ): a Unicode property value
---------------------------------------------------------------------------------------------------------------------

1. Assert: p is a canonical, unaliased Unicode property name listed
in the “Canonical property name” column of . 1. Assert: v is a
property value or property value alias for the Unicode property p
listed in
```PropertyValueAliases.txt`` <https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt>`__.
1. Let value be the canonical property value of v as given in
the “Canonical property value” column of the corresponding row. 1.
Return the List of Unicode code points value.

Implementations must support the Unicode property values and property
value aliases listed in
```PropertyValueAliases.txt`` <https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt>`__
for the properties listed in . To ensure interoperability,
implementations must not support any other property values or property
value aliases.

For example, `Xpeo` and `Old_Persian` are valid
`Script_Extensions` values, but `xpeo` and `Old Persian` aren't.

This algorithm differs from `the matching rules for symbolic values
listed in
UAX44 <https://unicode.org/reports/tr44/#Matching_Symbolic>`__: case,
white space, U+002D (HYPHEN-MINUS), and U+005F (LOW LINE) are not
ignored, and the `Is` prefix is not supported.

Runtime Semantics: CompileClassSetString ( rer: a RegExp Record, ): a sequence of characters
------------------------------------------------------------------------------------------------

ClassString :: [empty] 1. Return an empty sequence of characters.
ClassString :: NonEmptyClassString 1. Return CompileClassSetString of
`NonEmptyClassString` with argument rer. NonEmptyClassString ::
ClassSetCharacter NonEmptyClassString? 1. Let cs be CompileToCharSet
of `ClassSetCharacter` with argument rer. 1. Let s1 be the
sequence of characters that is the single CharSetElement of cs. 1.
If `NonEmptyClassString` is present, then 1. Let s2 be
CompileClassSetString of `NonEmptyClassString` with argument rer.
1. Return the concatenation of s1 and s2. 1. Return s1.

Abstract Operations for RegExp Creation
---------------------------------------

RegExpCreate ( P, F: a String or `undefined`, )
-----------------------------------------------

1. Let obj be ! RegExpAlloc(%RegExp%). 1. Return ?
RegExpInitialize(obj, P, F).

RegExpAlloc ( newTarget: a constructor, )
-----------------------------------------

1. Let obj be ? OrdinaryCreateFromConstructor(newTarget,
`"%RegExp.prototype%"`, « [[OriginalSource]], [[OriginalFlags]],
[[RegExpRecord]], [[RegExpMatcher]] »). 1. Perform !
DefinePropertyOrThrow(obj, `"lastIndex"`, PropertyDescriptor {
[[Writable]]: `true`, [[Enumerable]]: `false`, [[Configurable]]:
`false` }). 1. Return obj.

RegExpInitialize ( obj: an Object, pattern, flags, )
----------------------------------------------------

1. If pattern is `undefined`, let P be the empty String. 1.
Else, let P be ? ToString(pattern). 1. If flags is
`undefined`, let F be the empty String. 1. Else, let F be ?
ToString(flags). 1. If F contains any code unit other than
`"d"`, `"g"`, `"i"`, `"m"`, `"s"`, `"u"`, `"v"`, or
`"y"`, or if F contains any code unit more than once, throw a
`SyntaxError` exception. 1. If F contains `"i"`, let i be
`true`; else let i be `false`. 1. If F contains `"m"`, let
m be `true`; else let m be `false`. 1. If F contains
`"s"`, let s be `true`; else let s be `false`. 1. If F
contains `"u"`, let u be `true`; else let u be `false`. 1.
If F contains `"v"`, let v be `true`; else let v be
`false`. 1. If u is `true` or v is `true`, then 1. Let
patternText be StringToCodePoints(P). 1. Else, 1. Let
patternText be the result of interpreting each of P's 16-bit
elements as a Unicode BMP code point. UTF-16 decoding is not applied to
the elements. 1. Let parseResult be ParsePattern(patternText,
u, v). 1. If parseResult is a non-empty List of
`SyntaxError` objects, throw a `SyntaxError` exception. 1. Assert:
parseResult is a `Pattern` Parse Node. 1. Set
obj.[[OriginalSource]] to P. 1. Set obj.[[OriginalFlags]] to
F. 1. Let capturingGroupsCount be
CountLeftCapturingParensWithin(parseResult). 1. Let rer be the
RegExp Record { [[IgnoreCase]]: i, [[Multiline]]: m, [[DotAll]]:
s, [[Unicode]]: u, [[UnicodeSets]]: v,
[[CapturingGroupsCount]]: capturingGroupsCount }. 1. Set
obj.[[RegExpRecord]] to rer. 1. Set obj.[[RegExpMatcher]] to
CompilePattern of parseResult with argument rer. 1. Perform ?
Set(obj, `"lastIndex"`, `+0`\ :sub:`𝔽`, `true`). 1. Return
obj.

Static Semantics: ParsePattern ( patternText: a sequence of Unicode code points, u: a Boolean, v: a Boolean, ): a Parse Node or a non-empty List of `SyntaxError` objects
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

This section is amended in .

1. If v is `true` and u is `true`, then 1. Let
parseResult be a List containing one or more `SyntaxError`
objects. 1. Else if v is `true`, then 1. Let parseResult be
ParseText(patternText, \|Pattern[+UnicodeMode, +UnicodeSetsMode,
+NamedCaptureGroups]\|). 1. Else if u is `true`, then 1. Let
parseResult be ParseText(patternText, \|Pattern[+UnicodeMode,
~UnicodeSetsMode, +NamedCaptureGroups]\|). 1. Else, 1. Let
parseResult be ParseText(patternText, \|Pattern[~UnicodeMode,
~UnicodeSetsMode, +NamedCaptureGroups]\|). 1. Return parseResult.

The RegExp Constructor
----------------------

The RegExp constructor:

- is %RegExp%.
- is the initial value of the `"RegExp"` property of the global
  object.
- creates and initializes a new RegExp object when called as a
  constructor.
- when called as a function rather than as a constructor, returns either
  a new RegExp object, or the argument itself if the only argument is a
  RegExp object.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  RegExp behaviour must include a `super` call to the RegExp
  constructor to create and initialize subclass instances with the
  necessary internal slots.

RegExp ( pattern, flags )
---------------------------------

This function performs the following steps when called:

1. Let patternIsRegExp be ? IsRegExp(pattern). 1. If NewTarget
is `undefined`, then 1. Let newTarget be the active function
object. 1. If patternIsRegExp is `true` and flags is
`undefined`, then 1. Let patternConstructor be ? Get(pattern,
`"constructor"`). 1. If SameValue(newTarget,
patternConstructor) is `true`, return pattern. 1. Else, 1. Let
newTarget be NewTarget. 1. If pattern is an Object and
pattern has a [[RegExpMatcher]] internal slot, then 1. Let P be
pattern.[[OriginalSource]]. 1. If flags is `undefined`, let
F be pattern.[[OriginalFlags]]. 1. Else, let F be flags.
1. Else if patternIsRegExp is `true`, then 1. Let P be ?
Get(pattern, `"source"`). 1. If flags is `undefined`, then
1. Let F be ? Get(pattern, `"flags"`). 1. Else, 1. Let F
be flags. 1. Else, 1. Let P be pattern. 1. Let F be
flags. 1. Let O be ? RegExpAlloc(newTarget). 1. Return ?
RegExpInitialize(O, P, F).

If pattern is supplied using a `StringLiteral`, the usual escape
sequence substitutions are performed before the String is processed by
this function. If pattern must contain an escape sequence to be
recognized by this function, any U+005C (REVERSE SOLIDUS) code points
must be escaped within the `StringLiteral` to prevent them being
removed when the contents of the `StringLiteral` are formed.

Properties of the RegExp Constructor
------------------------------------

The RegExp constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

RegExp.prototype
----------------

The initial value of `RegExp.prototype` is the RegExp prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

get RegExp [ %Symbol.species% ]
-------------------------------

`RegExp[%Symbol.species%]` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

RegExp prototype methods normally use their `this` value's constructor
to create a derived object. However, a subclass constructor may
over-ride that default behaviour by redefining its %Symbol.species%
property.

Properties of the RegExp Prototype Object
-----------------------------------------

The RegExp prototype object:

- is %RegExp.prototype%.
- is an ordinary object.
- is not a RegExp instance and does not have a [[RegExpMatcher]]
  internal slot or any of the other internal slots of RegExp instance
  objects.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

The RegExp prototype object does not have a `"valueOf"` property of
its own; however, it inherits the `"valueOf"` property from the Object
prototype object.

RegExp.prototype.constructor
----------------------------

The initial value of `RegExp.prototype.constructor` is %RegExp%.

RegExp.prototype.exec ( string )
------------------------------------

This method searches string for an occurrence of the regular
expression pattern and returns an Array containing the results of the
match, or `null` if string did not match.

It performs the following steps when called:

1. Let R be the `this` value. 1. Perform ?
RequireInternalSlot(R, [[RegExpMatcher]]). 1. Let S be ?
ToString(string). 1. Return ? RegExpBuiltinExec(R, S).

get RegExp.prototype.dotAll
---------------------------

`RegExp.prototype.dotAll` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x0073 (LATIN SMALL LETTER S). 1. Return ? RegExpHasFlag(R, cu).

get RegExp.prototype.flags
--------------------------

`RegExp.prototype.flags` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let R be the `this` value. 1. If R is not an Object, throw
a `TypeError` exception. 1. Let codeUnits be a new empty List. 1.
Let hasIndices be ToBoolean(? Get(R, `"hasIndices"`)). 1. If
hasIndices is `true`, append the code unit 0x0064 (LATIN SMALL
LETTER D) to codeUnits. 1. Let global be ToBoolean(? Get(R,
`"global"`)). 1. If global is `true`, append the code unit
0x0067 (LATIN SMALL LETTER G) to codeUnits. 1. Let ignoreCase be
ToBoolean(? Get(R, `"ignoreCase"`)). 1. If ignoreCase is
`true`, append the code unit 0x0069 (LATIN SMALL LETTER I) to
codeUnits. 1. Let multiline be ToBoolean(? Get(R,
`"multiline"`)). 1. If multiline is `true`, append the code unit
0x006D (LATIN SMALL LETTER M) to codeUnits. 1. Let dotAll be
ToBoolean(? Get(R, `"dotAll"`)). 1. If dotAll is `true`,
append the code unit 0x0073 (LATIN SMALL LETTER S) to codeUnits. 1.
Let unicode be ToBoolean(? Get(R, `"unicode"`)). 1. If
unicode is `true`, append the code unit 0x0075 (LATIN SMALL LETTER
U) to codeUnits. 1. Let unicodeSets be ToBoolean(? Get(R,
`"unicodeSets"`)). 1. If unicodeSets is `true`, append the code
unit 0x0076 (LATIN SMALL LETTER V) to codeUnits. 1. Let sticky
be ToBoolean(? Get(R, `"sticky"`)). 1. If sticky is `true`,
append the code unit 0x0079 (LATIN SMALL LETTER Y) to codeUnits. 1.
Return the String value whose code units are the elements of the List
codeUnits. If codeUnits has no elements, the empty String is
returned.

RegExpHasFlag ( R, codeUnit: a code unit, )
-------------------------------------------

1. If R is not an Object, throw a `TypeError` exception. 1. If
R does not have an [[OriginalFlags]] internal slot, then 1. If
SameValue(R, %RegExp.prototype%) is `true`, return `undefined`.
1. Otherwise, throw a `TypeError` exception. 1. Let flags be
R.[[OriginalFlags]]. 1. If flags contains codeUnit, return
`true`. 1. Return `false`.

get RegExp.prototype.global
---------------------------

`RegExp.prototype.global` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x0067 (LATIN SMALL LETTER G). 1. Return ? RegExpHasFlag(R, cu).

get RegExp.prototype.hasIndices
-------------------------------

`RegExp.prototype.hasIndices` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x0064 (LATIN SMALL LETTER D). 1. Return ? RegExpHasFlag(R, cu).

get RegExp.prototype.ignoreCase
-------------------------------

`RegExp.prototype.ignoreCase` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x0069 (LATIN SMALL LETTER I). 1. Return ? RegExpHasFlag(R, cu).

RegExp.prototype [ %Symbol.match% ] ( string )
--------------------------------------------------

This method performs the following steps when called:

1. Let rx be the `this` value. 1. If rx is not an Object,
throw a `TypeError` exception. 1. Let S be ? ToString(string).
1. Let flags be ? ToString(? Get(rx, `"flags"`)). 1. If
flags does not contain `"g"`, then 1. Return ? RegExpExec(rx,
S). 1. Else, 1. If flags contains `"u"` or flags contains
`"v"`, let fullUnicode be `true`. Otherwise, let fullUnicode
be `false`. 1. Perform ? Set(rx, `"lastIndex"`,
`+0`\ :sub:`𝔽`, `true`). 1. Let A be ! ArrayCreate(0). 1. Let
n be 0. 1. Repeat, 1. Let result be ? RegExpExec(rx, S).
1. If result is `null`, then 1. If n = 0, return `null`. 1.
Return A. 1. Else, 1. Let matchStr be ? ToString(?
Get(result, `"0"`)). 1. Perform ! CreateDataPropertyOrThrow(A,
! ToString(𝔽(n)), matchStr). 1. If matchStr is the empty
String, then 1. Let thisIndex be ℝ(? ToLength(? Get(rx,
`"lastIndex"`))). 1. Let nextIndex be AdvanceStringIndex(S,
thisIndex, fullUnicode). 1. Perform ? Set(rx,
`"lastIndex"`, 𝔽(nextIndex), `true`). 1. Set n to n + 1.

The value of the `"name"` property of this method is
`"[Symbol.match]"`.

The %Symbol.match% property is used by the IsRegExp abstract operation
to identify objects that have the basic behaviour of regular
expressions. The absence of a %Symbol.match% property or the existence
of such a property whose value does not Boolean coerce to `true`
indicates that the object is not intended to be used as a regular
expression object.

RegExp.prototype [ %Symbol.matchAll% ] ( string )
-----------------------------------------------------

This method performs the following steps when called:

1. Let R be the `this` value. 1. If R is not an Object, throw
a `TypeError` exception. 1. Let S be ? ToString(string). 1.
Let C be ? SpeciesConstructor(R, %RegExp%). 1. Let flags be
? ToString(? Get(R, `"flags"`)). 1. Let matcher be ?
Construct(C, « R, flags »). 1. Let lastIndex be ?
ToLength(? Get(R, `"lastIndex"`)). 1. Perform ? Set(matcher,
`"lastIndex"`, lastIndex, `true`). 1. If flags contains
`"g"`, let global be `true`. 1. Else, let global be
`false`. 1. If flags contains `"u"` or flags contains
`"v"`, let fullUnicode be `true`. 1. Else, let fullUnicode
be `false`. 1. Return CreateRegExpStringIterator(matcher, S,
global, fullUnicode).

The value of the `"name"` property of this method is
`"[Symbol.matchAll]"`.

get RegExp.prototype.multiline
------------------------------

`RegExp.prototype.multiline` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x006D (LATIN SMALL LETTER M). 1. Return ? RegExpHasFlag(R, cu).

RegExp.prototype [ %Symbol.replace% ] ( string, replaceValue )
----------------------------------------------------------------------

This method performs the following steps when called:

1. Let rx be the `this` value. 1. If rx is not an Object,
throw a `TypeError` exception. 1. Let S be ? ToString(string).
1. Let lengthS be the length of S. 1. Let functionalReplace
be IsCallable(replaceValue). 1. If functionalReplace is
`false`, then 1. Set replaceValue to ? ToString(replaceValue).
1. Let flags be ? ToString(? Get(rx, `"flags"`)). 1. If
flags contains `"g"`, let global be `true`. Otherwise, let
global be `false`. 1. If global is `true`, then 1. Perform ?
Set(rx, `"lastIndex"`, `+0`\ :sub:`𝔽`, `true`). 1. Let
results be a new empty List. 1. Let done be `false`. 1.
Repeat, while done is `false`, 1. Let result be ?
RegExpExec(rx, S). 1. If result is `null`, then 1. Set
done to `true`. 1. Else, 1. Append result to results. 1.
If global is `false`, then 1. Set done to `true`. 1. Else,
1. Let matchStr be ? ToString(? Get(result, `"0"`)). 1. If
matchStr is the empty String, then 1. Let thisIndex be ℝ(?
ToLength(? Get(rx, `"lastIndex"`))). 1. If flags contains
`"u"` or flags contains `"v"`, let fullUnicode be `true`.
Otherwise, let fullUnicode be `false`. 1. Let nextIndex be
AdvanceStringIndex(S, thisIndex, fullUnicode). 1. Perform ?
Set(rx, `"lastIndex"`, 𝔽(nextIndex), `true`). 1. Let
accumulatedResult be the empty String. 1. Let nextSourcePosition
be 0. 1. For each element result of results, do 1. Let
resultLength be ? LengthOfArrayLike(result). 1. Let
nCaptures be max(resultLength - 1, 0). 1. Let matched be ?
ToString(? Get(result, `"0"`)). 1. Let matchLength be the
length of matched. 1. Let position be ? ToIntegerOrInfinity(?
Get(result, `"index"`)). 1. Set position to the result of
clamping position between 0 and lengthS. 1. Let captures be
a new empty List. 1. Let n be 1. 1. Repeat, while n ≤
nCaptures, 1. Let capN be ? Get(result, !
ToString(𝔽(n))). 1. If capN is not `undefined`, then 1. Set
capN to ? ToString(capN). 1. Append capN to captures. 1.
NOTE: When n = 1, the preceding step puts the first element into
captures (at index 0). More generally, the n\ :sup:`th` capture
(the characters captured by the n\ :sup:`th` set of capturing
parentheses) is at captures[n - 1]. 1. Set n to n + 1.
1. Let namedCaptures be ? Get(result, `"groups"`). 1. If
functionalReplace is `true`, then 1. Let replacerArgs be the
list-concatenation of « matched », captures, and «
𝔽(position), S ». 1. If namedCaptures is not `undefined`,
then 1. Append namedCaptures to replacerArgs. 1. Let
replacementValue be ? Call(replaceValue, `undefined`,
replacerArgs). 1. Let replacementString be ?
ToString(replacementValue). 1. Else, 1. If namedCaptures is not
`undefined`, then 1. Set namedCaptures to ?
ToObject(namedCaptures). 1. Let replacementString be ?
GetSubstitution(matched, S, position, captures,
namedCaptures, replaceValue). 1. If position ≥
nextSourcePosition, then 1. NOTE: position should not normally
move backwards. If it does, it is an indication of an ill-behaving
RegExp subclass or use of an access triggered side-effect to change the
global flag or other characteristics of rx. In such cases, the
corresponding substitution is ignored. 1. Set accumulatedResult to
the string-concatenation of accumulatedResult, the substring of
S from nextSourcePosition to position, and
replacementString. 1. Set nextSourcePosition to position +
matchLength. 1. If nextSourcePosition ≥ lengthS, return
accumulatedResult. 1. Return the string-concatenation of
accumulatedResult and the substring of S from
nextSourcePosition.

The value of the `"name"` property of this method is
`"[Symbol.replace]"`.

RegExp.prototype [ %Symbol.search% ] ( string )
---------------------------------------------------

This method performs the following steps when called:

1. Let rx be the `this` value. 1. If rx is not an Object,
throw a `TypeError` exception. 1. Let S be ? ToString(string).
1. Let previousLastIndex be ? Get(rx, `"lastIndex"`). 1. If
previousLastIndex is not `+0`\ :sub:`𝔽`, then 1. Perform ?
Set(rx, `"lastIndex"`, `+0`\ :sub:`𝔽`, `true`). 1. Let
result be ? RegExpExec(rx, S). 1. Let currentLastIndex
be ? Get(rx, `"lastIndex"`). 1. If SameValue(currentLastIndex,
previousLastIndex) is `false`, then 1. Perform ? Set(rx,
`"lastIndex"`, previousLastIndex, `true`). 1. If result is
`null`, return `-1`\ :sub:`𝔽`. 1. Return ? Get(result,
`"index"`).

The value of the `"name"` property of this method is
`"[Symbol.search]"`.

The `"lastIndex"` and `"global"` properties of this RegExp object
are ignored when performing the search. The `"lastIndex"` property is
left unchanged.

get RegExp.prototype.source
---------------------------

`RegExp.prototype.source` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let R be the `this` value. 1. If R is not an Object, throw
a `TypeError` exception. 1. If R does not have an
[[OriginalSource]] internal slot, then 1. If SameValue(R,
%RegExp.prototype%) is `true`, return `"(?:)"`. 1. Otherwise, throw
a `TypeError` exception. 1. Assert: R has an [[OriginalFlags]]
internal slot. 1. Let src be R.[[OriginalSource]]. 1. Let
flags be R.[[OriginalFlags]]. 1. Return
EscapeRegExpPattern(src, flags).

EscapeRegExpPattern ( P: a String, F: a String, ): a String
-------------------------------------------------------------------

1. If F contains `"v"`, then 1. Let patternSymbol be
\|Pattern[+UnicodeMode, +UnicodeSetsMode]\|. 1. Else if F contains
`"u"`, then 1. Let patternSymbol be \|Pattern[+UnicodeMode,
~UnicodeSetsMode]\|. 1. Else, 1. Let patternSymbol be
\|Pattern[~UnicodeMode, ~UnicodeSetsMode]\|. 1. Let S be a String in
the form of a patternSymbol equivalent to P interpreted as
UTF-16 encoded Unicode code points (), in which certain code points are
escaped as described below. S may or may not differ from P;
however, the Abstract Closure that would result from evaluating S as
a patternSymbol must behave identically to the Abstract Closure
given by the constructed object's [[RegExpMatcher]] internal slot.
Multiple calls to this abstract operation using the same values for
P and F must produce identical results. 1. The code points `/`
or any `LineTerminator` occurring in the pattern shall be escaped in
S as necessary to ensure that the string-concatenation of `"/"`,
S, `"/"`, and F can be parsed (in an appropriate lexical
context) as a `RegularExpressionLiteral` that behaves identically to
the constructed regular expression. For example, if P is `"/"`,
then S could be `"\\\\/"` or `"\\\\u002F"`, among other
possibilities, but not `"/"`, because `///` followed by F would
be parsed as a `SingleLineComment` rather than a
`RegularExpressionLiteral`. If P is the empty String, this
specification can be met by letting S be `"(?:)"`. 1. Return
S.

RegExp.prototype [ %Symbol.split% ] ( string, limit )
-------------------------------------------------------------

This method returns an Array into which substrings of the result of
converting string to a String have been stored. The substrings are
determined by searching from left to right for matches of the `this`
value regular expression; these occurrences are not part of any String
in the returned array, but serve to divide up the String value.

The `this` value may be an empty regular expression or a regular
expression that can match an empty String. In this case, the regular
expression does not match the empty substring at the beginning or end of
the input String, nor does it match the empty substring at the end of
the previous separator match. (For example, if the regular expression
matches the empty String, the String is split up into individual code
unit elements; the length of the result array equals the length of the
String, and each substring contains one code unit.) Only the first match
at a given index of the String is considered, even if backtracking could
yield a non-empty substring match at that index. (For example,
`/a`?/[Symbol.split]("ab")` evaluates to the array `["a", "b"]`,
while `/a*/[Symbol.split]("ab")` evaluates to the array `["","b"]`.)

If string is (or converts to) the empty String, the result depends
on whether the regular expression can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If the regular expression contains capturing parentheses, then each time
separator is matched the results (including any `undefined`
results) of the capturing parentheses are spliced into the output array.
For example,

.. code:: javascript

   /<(\/)?([^<>]+)>/[Symbol.split]("A<B>bold</B>and<CODE>coded</CODE>")

evaluates to the array

.. code:: javascript

   ["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]

If limit is not `undefined`, then the output array is truncated so
that it contains no more than limit elements.

This method performs the following steps when called:

1. Let rx be the `this` value. 1. If rx is not an Object,
throw a `TypeError` exception. 1. Let S be ? ToString(string).
1. Let C be ? SpeciesConstructor(rx, %RegExp%). 1. Let flags
be ? ToString(? Get(rx, `"flags"`)). 1. If flags contains
`"u"` or flags contains `"v"`, let unicodeMatching be
`true`. 1. Else, let unicodeMatching be `false`. 1. If flags
contains `"y"`, let newFlags be flags. 1. Else, let
newFlags be the string-concatenation of flags and `"y"`. 1.
Let splitter be ? Construct(C, « rx, newFlags »). 1. Let
A be ! ArrayCreate(0). 1. Let lengthA be 0. 1. If limit is
`undefined`, let lim be 2\ :sup:`32` - 1; else let lim be ℝ(?
ToUint32(limit)). 1. If lim = 0, return A. 1. If S is
the empty String, then 1. Let z be ? RegExpExec(splitter,
S). 1. If z is not `null`, return A. 1. Perform !
CreateDataPropertyOrThrow(A, `"0"`, S). 1. Return A. 1.
Let size be the length of S. 1. Let p be 0. 1. Let q be
p. 1. Repeat, while q < size, 1. Perform ? Set(splitter,
`"lastIndex"`, 𝔽(q), `true`). 1. Let z be ?
RegExpExec(splitter, S). 1. If z is `null`, then 1. Set
q to AdvanceStringIndex(S, q, unicodeMatching). 1. Else,
1. Let e be ℝ(? ToLength(? Get(splitter, `"lastIndex"`))). 1.
Set e to min(e, size). 1. If e = p, then 1. Set
q to AdvanceStringIndex(S, q, unicodeMatching). 1. Else,
1. Let T be the substring of S from p to q. 1. Perform !
CreateDataPropertyOrThrow(A, ! ToString(𝔽(lengthA)), T). 1.
Set lengthA to lengthA + 1. 1. If lengthA = lim, return
A. 1. Set p to e. 1. Let numberOfCaptures be ?
LengthOfArrayLike(z). 1. Set numberOfCaptures to
max(numberOfCaptures - 1, 0). 1. Let i be 1. 1. Repeat, while
i ≤ numberOfCaptures, 1. Let nextCapture be ? Get(z, !
ToString(𝔽(i))). 1. Perform ! CreateDataPropertyOrThrow(A, !
ToString(𝔽(lengthA)), nextCapture). 1. Set i to i + 1.
1. Set lengthA to lengthA + 1. 1. If lengthA = lim,
return A. 1. Set q to p. 1. Let T be the substring of
S from p to size. 1. Perform !
CreateDataPropertyOrThrow(A, ! ToString(𝔽(lengthA)), T). 1.
Return A.

The value of the `"name"` property of this method is
`"[Symbol.split]"`.

This method ignores the value of the `"global"` and `"sticky"`
properties of this RegExp object.

get RegExp.prototype.sticky
---------------------------

`RegExp.prototype.sticky` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x0079 (LATIN SMALL LETTER Y). 1. Return ? RegExpHasFlag(R, cu).

RegExp.prototype.test ( S )
-------------------------------

This method performs the following steps when called:

1. Let R be the `this` value. 1. If R is not an Object, throw
a `TypeError` exception. 1. Let string be ? ToString(S). 1.
Let match be ? RegExpExec(R, string). 1. If match is not
`null`, return `true`; else return `false`.

RegExp.prototype.toString ( )
-----------------------------

1. Let R be the `this` value. 1. If R is not an Object, throw
a `TypeError` exception. 1. Let pattern be ? ToString(? Get(R,
`"source"`)). 1. Let flags be ? ToString(? Get(R,
`"flags"`)). 1. Let result be the string-concatenation of `"/"`,
pattern, `"/"`, and flags. 1. Return result.

The returned String has the form of a `RegularExpressionLiteral` that
evaluates to another RegExp object with the same behaviour as this
object.

get RegExp.prototype.unicode
----------------------------

`RegExp.prototype.unicode` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x0075 (LATIN SMALL LETTER U). 1. Return ? RegExpHasFlag(R, cu).

get RegExp.prototype.unicodeSets
--------------------------------

`RegExp.prototype.unicodeSets` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let R be the `this` value. 1. Let cu be the code unit
0x0076 (LATIN SMALL LETTER V). 1. Return ? RegExpHasFlag(R, cu).

Abstract Operations for RegExp Matching
---------------------------------------

RegExpExec ( R: an Object, S: a String, )
-----------------------------------------

1. Let exec be ? Get(R, `"exec"`). 1. If IsCallable(exec)
is `true`, then 1. Let result be ? Call(exec, R, « S
»). 1. If result is not an Object and result is not `null`,
throw a `TypeError` exception. 1. Return result. 1. Perform ?
RequireInternalSlot(R, [[RegExpMatcher]]). 1. Return ?
RegExpBuiltinExec(R, S).

If a callable `"exec"` property is not found this algorithm falls back
to attempting to use the built-in RegExp matching algorithm. This
provides compatible behaviour for code written for prior editions where
most built-in algorithms that use regular expressions did not perform a
dynamic property lookup of `"exec"`.

RegExpBuiltinExec ( R: an initialized RegExp instance, S: a String, )
---------------------------------------------------------------------

1. Let length be the length of S. 1. Let lastIndex be ℝ(?
ToLength(? Get(R, `"lastIndex"`))). 1. Let flags be
R.[[OriginalFlags]]. 1. If flags contains `"g"`, let
global be `true`; else let global be `false`. 1. If
flags contains `"y"`, let sticky be `true`; else let
sticky be `false`. 1. If flags contains `"d"`, let
hasIndices be `true`; else let hasIndices be `false`. 1. If
global is `false` and sticky is `false`, set lastIndex
to 0. 1. Let matcher be R.[[RegExpMatcher]]. 1. If flags
contains `"u"` or flags contains `"v"`, let fullUnicode be
`true`; else let fullUnicode be `false`. 1. Let
matchSucceeded be `false`. 1. If fullUnicode is `true`, let
input be StringToCodePoints(S). Otherwise, let input be a
List whose elements are the code units that are the elements of S.
1. NOTE: Each element of input is considered to be a character. 1.
Repeat, while matchSucceeded is `false`, 1. If lastIndex >
length, then 1. If global is `true` or sticky is `true`,
then 1. Perform ? Set(R, `"lastIndex"`, `+0`\ :sub:`𝔽`,
`true`). 1. Return `null`. 1. Let inputIndex be the index into
input of the character that was obtained from element lastIndex
of S. 1. Let r be matcher(input, inputIndex). 1. If
r is ~failure~, then 1. If sticky is `true`, then 1. Perform ?
Set(R, `"lastIndex"`, `+0`\ :sub:`𝔽`, `true`). 1. Return
`null`. 1. Set lastIndex to AdvanceStringIndex(S,
lastIndex, fullUnicode). 1. Else, 1. Assert: r is a
MatchState. 1. Set matchSucceeded to `true`. 1. Let e be
r.[[EndIndex]]. 1. If fullUnicode is `true`, set e to
GetStringIndex(S, e). 1. If global is `true` or sticky
is `true`, then 1. Perform ? Set(R, `"lastIndex"`, 𝔽(e),
`true`). 1. Let n be the number of elements in r.[[Captures]].
1. Assert: n = R.[[RegExpRecord]].[[CapturingGroupsCount]]. 1.
Assert: n < 2\ :sup:`32` - 1. 1. Let A be ! ArrayCreate(n +
1). 1. Assert: The mathematical value of A's `"length"` property
is n + 1. 1. Perform ! CreateDataPropertyOrThrow(A, `"index"`,
𝔽(lastIndex)). 1. Perform ! CreateDataPropertyOrThrow(A,
`"input"`, S). 1. Let match be the Match Record {
[[StartIndex]]: lastIndex, [[EndIndex]]: e }. 1. Let indices
be a new empty List. 1. Let groupNames be a new empty List. 1.
Append match to indices. 1. Let matchedSubstr be
GetMatchString(S, match). 1. Perform !
CreateDataPropertyOrThrow(A, `"0"`, matchedSubstr). 1. If
R contains any `GroupName`, then 1. Let groups be
OrdinaryObjectCreate(`null`). 1. Let hasGroups be `true`. 1.
Else, 1. Let groups be `undefined`. 1. Let hasGroups be
`false`. 1. Perform ! CreateDataPropertyOrThrow(A, `"groups"`,
groups). 1. Let matchedGroupNames be a new empty List. 1. For
each integer i such that 1 ≤ i ≤ n, in ascending order, do
1. Let captureI be i\ :sup:`th` element of r.[[Captures]].
1. If captureI is `undefined`, then 1. Let capturedValue be
`undefined`. 1. Append `undefined` to indices. 1. Else, 1. Let
captureStart be captureI.[[StartIndex]]. 1. Let captureEnd
be captureI.[[EndIndex]]. 1. If fullUnicode is `true`, then 1.
Set captureStart to GetStringIndex(S, captureStart). 1. Set
captureEnd to GetStringIndex(S, captureEnd). 1. Let
capture be the Match Record { [[StartIndex]]: captureStart,
[[EndIndex]]: captureEnd }. 1. Let capturedValue be
GetMatchString(S, capture). 1. Append capture to
indices. 1. Perform ! CreateDataPropertyOrThrow(A, !
ToString(𝔽(i)), capturedValue). 1. If the i\ :sup:`th`
capture of R was defined with a `GroupName`, then 1. Let s be
the CapturingGroupName of that `GroupName`. 1. If
matchedGroupNames contains s, then 1. Assert: capturedValue
is `undefined`. 1. Append `undefined` to groupNames. 1. Else, 1.
If capturedValue is not `undefined`, append s to
matchedGroupNames. 1. NOTE: If there are multiple groups named
s, groups may already have an s property at this point.
However, because groups is an ordinary object whose properties are
all writable data properties, the call to CreateDataPropertyOrThrow is
nevertheless guaranteed to succeed. 1. Perform !
CreateDataPropertyOrThrow(groups, s, capturedValue). 1.
Append s to groupNames. 1. Else, 1. Append `undefined` to
groupNames. 1. If hasIndices is `true`, then 1. Let
indicesArray be MakeMatchIndicesIndexPairArray(S, indices,
groupNames, hasGroups). 1. Perform !
CreateDataPropertyOrThrow(A, `"indices"`, indicesArray). 1.
Return A.

AdvanceStringIndex ( S: a String, index: a non-negative integer, unicode: a Boolean, ): an integer
--------------------------------------------------------------------------------------------------------------

1. Assert: index ≤ 2\ :sup:`53` - 1. 1. If unicode is `false`,
return index + 1. 1. Let length be the length of S. 1. If
index + 1 ≥ length, return index + 1. 1. Let cp be
CodePointAt(S, index). 1. Return index +
cp.[[CodeUnitCount]].

GetStringIndex ( S: a String, codePointIndex: a non-negative integer, ): a non-negative integer
-------------------------------------------------------------------------------------------------------

description
   It interprets S as a sequence of UTF-16 encoded code points, as
   described in , and returns the code unit index corresponding to code
   point index codePointIndex when such an index exists. Otherwise,
   it returns the length of S.

1. If S is the empty String, return 0. 1. Let len be the length
of S. 1. Let codeUnitCount be 0. 1. Let codePointCount be 0.
1. Repeat, while codeUnitCount < len, 1. If codePointCount =
codePointIndex, return codeUnitCount. 1. Let cp be
CodePointAt(S, codeUnitCount). 1. Set codeUnitCount to
codeUnitCount + cp.[[CodeUnitCount]]. 1. Set codePointCount
to codePointCount + 1. 1. Return len.

Match Records
-------------

A Match Record is a Record value used to encapsulate the start and end
indices of a regular expression match or capture.

Match Records have the fields listed in .

+----------------+-------------------------+-------------------------+
| Field Name     | Value                   | Meaning                 |
+================+=========================+=========================+
| [[StartIndex]] | a non-negative integer  | The number of code      |
|                |                         | units from the start of |
|                |                         | a string at which the   |
|                |                         | match begins            |
|                |                         | (inclusive).            |
+----------------+-------------------------+-------------------------+
| [[EndIndex]]   | an integer ≥            | The number of code      |
|                | [[StartIndex]]          | units from the start of |
|                |                         | a string at which the   |
|                |                         | match ends (exclusive). |
+----------------+-------------------------+-------------------------+

GetMatchString ( S: a String, match: a Match Record, ): a String
------------------------------------------------------------------------

1. Assert: match.[[StartIndex]] ≤ match.[[EndIndex]] ≤ the
length of S. 1. Return the substring of S from
match.[[StartIndex]] to match.[[EndIndex]].

GetMatchIndexPair ( S: a String, match: a Match Record, ): an Array
---------------------------------------------------------------------------

1. Assert: match.[[StartIndex]] ≤ match.[[EndIndex]] ≤ the
length of S. 1. Return CreateArrayFromList(«
𝔽(match.[[StartIndex]]), 𝔽(match.[[EndIndex]]) »).

MakeMatchIndicesIndexPairArray ( S: a String, indices: a List of either Match Records or `undefined`, groupNames: a List of either Strings or `undefined`, hasGroups: a Boolean, ): an Array
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let n be the number of elements in indices. 1. Assert: n
< 2\ :sup:`32` - 1. 1. Assert: groupNames has n - 1 elements. 1.
NOTE: The groupNames List contains elements aligned with the
indices List starting at indices[1]. 1. Let A be !
ArrayCreate(n). 1. If hasGroups is `true`, then 1. Let
groups be OrdinaryObjectCreate(`null`). 1. Else, 1. Let groups
be `undefined`. 1. Perform ! CreateDataPropertyOrThrow(A,
`"groups"`, groups). 1. For each integer i such that 0 ≤ i
< n, in ascending order, do 1. Let matchIndices be
indices[i]. 1. If matchIndices is not `undefined`, then 1.
Let matchIndexPair be GetMatchIndexPair(S, matchIndices). 1.
Else, 1. Let matchIndexPair be `undefined`. 1. Perform !
CreateDataPropertyOrThrow(A, ! ToString(𝔽(i)),
matchIndexPair). 1. If i > 0 and groupNames[i - 1] is
not `undefined`, then 1. Assert: groups is not `undefined`. 1.
Let s be groupNames[i - 1]. 1. NOTE: If there are multiple
groups named s, groups may already have an s property at
this point. However, because groups is an ordinary object whose
properties are all writable data properties, the call to
CreateDataPropertyOrThrow is nevertheless guaranteed to succeed. 1.
Perform ! CreateDataPropertyOrThrow(groups, s,
matchIndexPair). 1. Return A.

Properties of RegExp Instances
------------------------------

RegExp instances are ordinary objects that inherit properties from the
RegExp prototype object. RegExp instances have internal slots
[[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], and
[[RegExpMatcher]]. The value of the [[RegExpMatcher]] internal slot is
an Abstract Closure representation of the `Pattern` of the RegExp
object.

Prior to ECMAScript 2015, RegExp instances were specified as having the
own data properties `"source"`, `"global"`, `"ignoreCase"`, and
`"multiline"`. Those properties are now specified as accessor
properties of `RegExp.prototype`.

RegExp instances also have the following property:

lastIndex
---------

The value of the `"lastIndex"` property specifies the String index at
which to start the next match. It is coerced to an integral Number when
used (see ). This property shall have the attributes { [[Writable]]:
`true`, [[Enumerable]]: `false`, [[Configurable]]: `false` }.

RegExp String Iterator Objects
------------------------------

A RegExp String Iterator is an object that represents a specific
iteration over some specific String instance object, matching against
some specific RegExp instance object. There is not a named constructor
for RegExp String Iterator objects. Instead, RegExp String Iterator
objects are created by calling certain methods of RegExp instance
objects.

CreateRegExpStringIterator ( R: an Object, S: a String, global: a Boolean, fullUnicode: a Boolean, ): a Generator
---------------------------------------------------------------------------------------------------------------------------------

1. Let closure be a new Abstract Closure with no parameters that
captures R, S, global, and fullUnicode and performs the
following steps when called: 1. Repeat, 1. Let match be ?
RegExpExec(R, S). 1. If match is `null`, return
`undefined`. 1. If global is `false`, then 1. Perform ?
GeneratorYield(CreateIteratorResultObject(match, `false`)). 1.
Return `undefined`. 1. Let matchStr be ? ToString(? Get(match,
`"0"`)). 1. If matchStr is the empty String, then 1. Let
thisIndex be ℝ(? ToLength(? Get(R, `"lastIndex"`))). 1. Let
nextIndex be AdvanceStringIndex(S, thisIndex,
fullUnicode). 1. Perform ? Set(R, `"lastIndex"`,
𝔽(nextIndex), `true`). 1. Perform ?
GeneratorYield(CreateIteratorResultObject(match, `false`)). 1.
Return CreateIteratorFromClosure(closure,
`"%RegExpStringIteratorPrototype%"`, %RegExpStringIteratorPrototype%).

The %RegExpStringIteratorPrototype% Object
------------------------------------------

The %RegExpStringIteratorPrototype% object:

- has properties that are inherited by all RegExp String Iterator
  objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- has the following properties:

%RegExpStringIteratorPrototype%.next ( )
----------------------------------------

1. Return ? GeneratorResume(`this` value, ~empty~,
`"%RegExpStringIteratorPrototype%"`).

%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]
--------------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"RegExp String Iterator"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

23. Indexed Collections
=======================

https://tc39.es/ecma262/multipage/indexed-collections.html
::

    23.1 Array Objects
        23.1.1 The Array Constructor
            23.1.1.1 Array ( ...values )
        23.1.2 Properties of the Array Constructor
            23.1.2.1 Array.from ( items [ , mapper [ , thisArg ] ] )
            23.1.2.2 Array.isArray ( arg )
            23.1.2.3 Array.of ( ...items )
            23.1.2.4 Array.prototype
            23.1.2.5 get Array [ %Symbol.species% ]
        23.1.3 Properties of the Array Prototype Object
            23.1.3.1 Array.prototype.at ( index )
            23.1.3.2 Array.prototype.concat ( ...items )
                23.1.3.2.1 IsConcatSpreadable ( O )
            23.1.3.3 Array.prototype.constructor
            23.1.3.4 Array.prototype.copyWithin ( target, start [ , end ] )
            23.1.3.5 Array.prototype.entries ( )
            23.1.3.6 Array.prototype.every ( callback [ , thisArg ] )
            23.1.3.7 Array.prototype.fill ( value [ , start [ , end ] ] )
            23.1.3.8 Array.prototype.filter ( callback [ , thisArg ] )
            23.1.3.9 Array.prototype.find ( predicate [ , thisArg ] )
            23.1.3.10 Array.prototype.findIndex ( predicate [ , thisArg ] )
            23.1.3.11 Array.prototype.findLast ( predicate [ , thisArg ] )
            23.1.3.12 Array.prototype.findLastIndex ( predicate [ , thisArg ] )
                23.1.3.12.1 FindViaPredicate ( O, len, direction, predicate, thisArg )
            23.1.3.13 Array.prototype.flat ( [ depth ] )
                23.1.3.13.1 FlattenIntoArray ( target, source, sourceLen, start, depth [ , mapperFunction [ , thisArg ] ] )
            23.1.3.14 Array.prototype.flatMap ( mapperFunction [ , thisArg ] )
            23.1.3.15 Array.prototype.forEach ( callback [ , thisArg ] )
            23.1.3.16 Array.prototype.includes ( searchElement [ , fromIndex ] )
            23.1.3.17 Array.prototype.indexOf ( searchElement [ , fromIndex ] )
            23.1.3.18 Array.prototype.join ( separator )
            23.1.3.19 Array.prototype.keys ( )
            23.1.3.20 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
            23.1.3.21 Array.prototype.map ( callback [ , thisArg ] )
            23.1.3.22 Array.prototype.pop ( )
            23.1.3.23 Array.prototype.push ( ...items )
            23.1.3.24 Array.prototype.reduce ( callback [ , initialValue ] )
            23.1.3.25 Array.prototype.reduceRight ( callback [ , initialValue ] )
            23.1.3.26 Array.prototype.reverse ( )
            23.1.3.27 Array.prototype.shift ( )
            23.1.3.28 Array.prototype.slice ( start, end )
            23.1.3.29 Array.prototype.some ( callback [ , thisArg ] )
            23.1.3.30 Array.prototype.sort ( comparator )
                23.1.3.30.1 SortIndexedProperties ( obj, len, SortCompare, holes )
                23.1.3.30.2 CompareArrayElements ( x, y, comparator )
            23.1.3.31 Array.prototype.splice ( start, deleteCount, ...items )
            23.1.3.32 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
            23.1.3.33 Array.prototype.toReversed ( )
            23.1.3.34 Array.prototype.toSorted ( comparator )
            23.1.3.35 Array.prototype.toSpliced ( start, skipCount, ...items )
            23.1.3.36 Array.prototype.toString ( )
            23.1.3.37 Array.prototype.unshift ( ...items )
            23.1.3.38 Array.prototype.values ( )
            23.1.3.39 Array.prototype.with ( index, value )
            23.1.3.40 Array.prototype [ %Symbol.iterator% ] ( )
            23.1.3.41 Array.prototype [ %Symbol.unscopables% ]
        23.1.4 Properties of Array Instances
            23.1.4.1 length
        23.1.5 Array Iterator Objects
            23.1.5.1 CreateArrayIterator ( array, kind )
            23.1.5.2 The %ArrayIteratorPrototype% Object
                23.1.5.2.1 %ArrayIteratorPrototype%.next ( )
                23.1.5.2.2 %ArrayIteratorPrototype% [ %Symbol.toStringTag% ]
    23.2 TypedArray Objects
        23.2.1 The %TypedArray% Intrinsic Object
            23.2.1.1 %TypedArray% ( )
        23.2.2 Properties of the %TypedArray% Intrinsic Object
            23.2.2.1 %TypedArray%.from ( source [ , mapper [ , thisArg ] ] )
            23.2.2.2 %TypedArray%.of ( ...items )
            23.2.2.3 %TypedArray%.prototype
            23.2.2.4 get %TypedArray% [ %Symbol.species% ]
        23.2.3 Properties of the %TypedArray% Prototype Object
            23.2.3.1 %TypedArray%.prototype.at ( index )
            23.2.3.2 get %TypedArray%.prototype.buffer
            23.2.3.3 get %TypedArray%.prototype.byteLength
            23.2.3.4 get %TypedArray%.prototype.byteOffset
            23.2.3.5 %TypedArray%.prototype.constructor
            23.2.3.6 %TypedArray%.prototype.copyWithin ( target, start [ , end ] )
            23.2.3.7 %TypedArray%.prototype.entries ( )
            23.2.3.8 %TypedArray%.prototype.every ( callback [ , thisArg ] )
            23.2.3.9 %TypedArray%.prototype.fill ( value [ , start [ , end ] ] )
            23.2.3.10 %TypedArray%.prototype.filter ( callback [ , thisArg ] )
            23.2.3.11 %TypedArray%.prototype.find ( predicate [ , thisArg ] )
            23.2.3.12 %TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )
            23.2.3.13 %TypedArray%.prototype.findLast ( predicate [ , thisArg ] )
            23.2.3.14 %TypedArray%.prototype.findLastIndex ( predicate [ , thisArg ] )
            23.2.3.15 %TypedArray%.prototype.forEach ( callback [ , thisArg ] )
            23.2.3.16 %TypedArray%.prototype.includes ( searchElement [ , fromIndex ] )
            23.2.3.17 %TypedArray%.prototype.indexOf ( searchElement [ , fromIndex ] )
            23.2.3.18 %TypedArray%.prototype.join ( separator )
            23.2.3.19 %TypedArray%.prototype.keys ( )
            23.2.3.20 %TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
            23.2.3.21 get %TypedArray%.prototype.length
            23.2.3.22 %TypedArray%.prototype.map ( callback [ , thisArg ] )
            23.2.3.23 %TypedArray%.prototype.reduce ( callback [ , initialValue ] )
            23.2.3.24 %TypedArray%.prototype.reduceRight ( callback [ , initialValue ] )
            23.2.3.25 %TypedArray%.prototype.reverse ( )
            23.2.3.26 %TypedArray%.prototype.set ( source [ , offset ] )
                23.2.3.26.1 SetTypedArrayFromTypedArray ( target, targetOffset, source )
                23.2.3.26.2 SetTypedArrayFromArrayLike ( target, targetOffset, source )
            23.2.3.27 %TypedArray%.prototype.slice ( start, end )
            23.2.3.28 %TypedArray%.prototype.some ( callback [ , thisArg ] )
            23.2.3.29 %TypedArray%.prototype.sort ( comparator )
            23.2.3.30 %TypedArray%.prototype.subarray ( start, end )
            23.2.3.31 %TypedArray%.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
            23.2.3.32 %TypedArray%.prototype.toReversed ( )
            23.2.3.33 %TypedArray%.prototype.toSorted ( comparator )
            23.2.3.34 %TypedArray%.prototype.toString ( )
            23.2.3.35 %TypedArray%.prototype.values ( )
            23.2.3.36 %TypedArray%.prototype.with ( index, value )
            23.2.3.37 %TypedArray%.prototype [ %Symbol.iterator% ] ( )
            23.2.3.38 get %TypedArray%.prototype [ %Symbol.toStringTag% ]
        23.2.4 Abstract Operations for TypedArray Objects
            23.2.4.1 TypedArraySpeciesCreate ( exemplar, argumentList )
            23.2.4.2 TypedArrayCreateFromConstructor ( constructor, argumentList )
            23.2.4.3 TypedArrayCreateSameType ( exemplar, argumentList )
            23.2.4.4 ValidateTypedArray ( O, order )
            23.2.4.5 TypedArrayElementSize ( O )
            23.2.4.6 TypedArrayElementType ( O )
            23.2.4.7 CompareTypedArrayElements ( x, y, comparator )
        23.2.5 The TypedArray Constructors
            23.2.5.1 TypedArray ( ...args )
                23.2.5.1.1 AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] ) 
                23.2.5.1.2 InitializeTypedArrayFromTypedArray ( O, srcArray )
                23.2.5.1.3 InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )
                23.2.5.1.4 InitializeTypedArrayFromList ( O, values )
                23.2.5.1.5 InitializeTypedArrayFromArrayLike ( O, arrayLike )
                23.2.5.1.6 AllocateTypedArrayBuffer ( O, length )
        23.2.6 Properties of the TypedArray Constructors
            23.2.6.1 TypedArray.BYTES_PER_ELEMENT
            23.2.6.2 TypedArray.prototype
        23.2.7 Properties of the TypedArray Prototype Objects
            23.2.7.1 TypedArray.prototype.BYTES_PER_ELEMENT
            23.2.7.2 TypedArray.prototype.constructor
        23.2.8 Properties of TypedArray Instances

Array Objects
-------------

Arrays are exotic objects that give special treatment to a certain class
of property names. See for a definition of this special treatment.

The Array Constructor
---------------------

The Array constructor:

- is %Array%.
- is the initial value of the `"Array"` property of the global object.
- creates and initializes a new Array when called as a constructor.
- also creates and initializes a new Array when called as a function
  rather than as a constructor. Thus the function call `Array(…)` is
  equivalent to the object creation expression `new Array(…)` with the
  same arguments.
- is a function whose behaviour differs based upon the number and types
  of its arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the exotic
  Array behaviour must include a `super` call to the Array constructor
  to initialize subclass instances that are Array exotic objects.
  However, most of the `Array.prototype` methods are generic methods
  that are not dependent upon their `this` value being an Array exotic
  object.

Array ( ..._values )
----------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, let newTarget be the active
function object; else let newTarget be NewTarget. 1. Let proto
be ? GetPrototypeFromConstructor(newTarget,
`"%Array.prototype%"`). 1. Let numberOfArgs be the number of
elements in values. 1. If numberOfArgs = 0, then 1. Return !
ArrayCreate(0, proto). 1. Else if numberOfArgs = 1, then 1. Let
len be values[0]. 1. Let array be ! ArrayCreate(0,
proto). 1. If len is not a Number, then 1. Perform !
CreateDataPropertyOrThrow(array, `"0"`, len). 1. Let
intLen be `1`\ :sub:`𝔽`. 1. Else, 1. Let intLen be !
ToUint32(len). 1. If SameValueZero(intLen, len) is
`false`, throw a `RangeError` exception. 1. Perform ! Set(array,
`"length"`, intLen, `true`). 1. Return array. 1. Else, 1.
Assert: numberOfArgs ≥ 2. 1. Let array be ?
ArrayCreate(numberOfArgs, proto). 1. Let k be 0. 1. Repeat,
while k < numberOfArgs, 1. Let Pk be ! ToString(𝔽(k)).
1. Let itemK be values[k]. 1. Perform !
CreateDataPropertyOrThrow(array, Pk, itemK). 1. Set k to
k + 1. 1. Assert: The mathematical value of array's `"length"`
property is numberOfArgs. 1. Return array.

Properties of the Array Constructor
-----------------------------------

The Array constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has a `"length"` property whose value is `1`\ :sub:`𝔽`.
- has the following properties:

Array.from ( items [ , mapper [ , thisArg ] ] )
-----------------------------------------------------------

This method performs the following steps when called:

1. Let C be the `this` value. 1. If mapper is `undefined`,
then 1. Let mapping be `false`. 1. Else, 1. If
IsCallable(mapper) is `false`, throw a `TypeError` exception. 1.
Let mapping be `true`. 1. Let usingIterator be ?
GetMethod(items, %Symbol.iterator%). 1. If usingIterator is not
`undefined`, then 1. If IsConstructor(C) is `true`, then 1. Let
A be ? Construct(C). 1. Else, 1. Let A be ! ArrayCreate(0).
1. Let iteratorRecord be ? GetIteratorFromMethod(items,
usingIterator). 1. Let k be 0. 1. Repeat, 1. If k ≥
2\ :sup:`53` - 1, then 1. Let error be ThrowCompletion(a newly
created `TypeError` object). 1. Return ?
IteratorClose(iteratorRecord, error). 1. Let Pk be !
ToString(𝔽(k)). 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is ~done~, then 1.
Perform ? Set(A, `"length"`, 𝔽(k), `true`). 1. Return A.
1. If mapping is `true`, then 1. Let mappedValue be
Completion(Call(mapper, thisArg, « next, 𝔽(k) »)). 1.
IfAbruptCloseIterator(mappedValue, iteratorRecord). 1. Else, 1.
Let mappedValue be next. 1. Let defineStatus be
Completion(CreateDataPropertyOrThrow(A, Pk, mappedValue)).
1. IfAbruptCloseIterator(defineStatus, iteratorRecord). 1. Set
k to k + 1. 1. NOTE: items is not iterable so assume it is
an array-like object. 1. Let arrayLike be ! ToObject(items). 1.
Let len be ? LengthOfArrayLike(arrayLike). 1. If
IsConstructor(C) is `true`, then 1. Let A be ?
Construct(C, « 𝔽(len) »). 1. Else, 1. Let A be ?
ArrayCreate(len). 1. Let k be 0. 1. Repeat, while k <
len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let kValue be ?
Get(arrayLike, Pk). 1. If mapping is `true`, then 1. Let
mappedValue be ? Call(mapper, thisArg, « kValue,
𝔽(k) »). 1. Else, 1. Let mappedValue be kValue. 1. Perform ?
CreateDataPropertyOrThrow(A, Pk, mappedValue). 1. Set k
to k + 1. 1. Perform ? Set(A, `"length"`, 𝔽(len),
`true`). 1. Return A.

This method is an intentionally generic factory method; it does not
require that its `this` value be the Array constructor. Therefore it
can be transferred to or inherited by any other constructors that may be
called with a single numeric argument.

Array.isArray ( arg )
-------------------------

This function performs the following steps when called:

1. Return ? IsArray(arg).

Array.of ( ..._items )
------------------------

This method performs the following steps when called:

1. Let len be the number of elements in items. 1. Let
lenNumber be 𝔽(len). 1. Let C be the `this` value. 1. If
IsConstructor(C) is `true`, then 1. Let A be ?
Construct(C, « lenNumber »). 1. Else, 1. Let A be ?
ArrayCreate(len). 1. Let k be 0. 1. Repeat, while k <
len, 1. Let kValue be items[k]. 1. Let Pk be !
ToString(𝔽(k)). 1. Perform ? CreateDataPropertyOrThrow(A,
Pk, kValue). 1. Set k to k + 1. 1. Perform ? Set(A,
`"length"`, lenNumber, `true`). 1. Return A.

This method is an intentionally generic factory method; it does not
require that its `this` value be the Array constructor. Therefore it
can be transferred to or inherited by other constructors that may be
called with a single numeric argument.

Array.prototype
---------------

The value of `Array.prototype` is the Array prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

get Array [ %Symbol.species% ]
------------------------------

`Array[%Symbol.species%]` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

Array prototype methods normally use their `this` value's constructor
to create a derived object. However, a subclass constructor may
over-ride that default behaviour by redefining its %Symbol.species%
property.

Properties of the Array Prototype Object
----------------------------------------

The Array prototype object:

- is %Array.prototype%.
- is an Array exotic object and has the internal methods specified for
  such objects.
- has a `"length"` property whose initial value is `+0`\ :sub:`𝔽`
  and whose attributes are { [[Writable]]: `true`, [[Enumerable]]:
  `false`, [[Configurable]]: `false` }.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.

The Array prototype object is specified to be an Array exotic object to
ensure compatibility with ECMAScript code that was created prior to the
ECMAScript 2015 specification.

Array.prototype.at ( index )
--------------------------------

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let relativeIndex be ?
ToIntegerOrInfinity(index). 1. If relativeIndex ≥ 0, then 1. Let
k be relativeIndex. 1. Else, 1. Let k be len +
relativeIndex. 1. If k < 0 or k ≥ len, return
`undefined`. 1. Return ? Get(O, ! ToString(𝔽(k))).

Array.prototype.concat ( ..._items )
--------------------------------------

This method returns an array containing the array elements of the object
followed by the array elements of each argument.

It performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let A be ?
ArraySpeciesCreate(O, 0). 1. Let n be 0. 1. Prepend O to
items. 1. For each element E of items, do 1. Let
spreadable be ? IsConcatSpreadable(E). 1. If spreadable is
`true`, then 1. Let len be ? LengthOfArrayLike(E). 1. If n
+ len > 2\ :sup:`53` - 1, throw a `TypeError` exception. 1. Let
k be 0. 1. Repeat, while k < len, 1. Let Pk be !
ToString(𝔽(k)). 1. Let exists be ? HasProperty(E, Pk).
1. If exists is `true`, then 1. Let subElement be ? Get(E,
Pk). 1. Perform ? CreateDataPropertyOrThrow(A, !
ToString(𝔽(n)), subElement). 1. Set n to n + 1. 1. Set
k to k + 1. 1. Else, 1. NOTE: E is added as a single item
rather than spread. 1. If n ≥ 2\ :sup:`53` - 1, throw a
`TypeError` exception. 1. Perform ? CreateDataPropertyOrThrow(A, !
ToString(𝔽(n)), E). 1. Set n to n + 1. 1.
[id="step-array-proto-concat-set-length"] Perform ? Set(A,
`"length"`, 𝔽(n), `true`). 1. Return A.

The `"length"` property of this method is `1`\ :sub:`𝔽`.

The explicit setting of the `"length"` property in step is intended to
ensure the length is correct when the final non-empty element of
items has trailing holes or when A is not a built-in Array.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

IsConcatSpreadable ( O, )
-------------------------

1. If O is not an Object, return `false`. 1. Let spreadable be
? Get(O, %Symbol.isConcatSpreadable%). 1. If spreadable is not
`undefined`, return ToBoolean(spreadable). 1. Return ?
IsArray(O).

Array.prototype.constructor
---------------------------

The initial value of `Array.prototype.constructor` is %Array%.

Array.prototype.copyWithin ( target, start [ , end ] )
------------------------------------------------------------------

The end argument is optional. If it is not provided, the length of
the `this` value is used.

If target is negative, it is treated as length + target
where length is the length of the array. If start is negative,
it is treated as length + start. If end is negative, it is
treated as length + end.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let relativeTarget be ?
ToIntegerOrInfinity(target). 1. If relativeTarget = -∞, let
to be 0. 1. Else if relativeTarget < 0, let to be
max(len + relativeTarget, 0). 1. Else, let to be
min(relativeTarget, len). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let
from be 0. 1. Else if relativeStart < 0, let from be
max(len + relativeStart, 0). 1. Else, let from be
min(relativeStart, len). 1. If end is `undefined`, let
relativeEnd be len; else let relativeEnd be ?
ToIntegerOrInfinity(end). 1. If relativeEnd = -∞, let final
be 0. 1. Else if relativeEnd < 0, let final be max(len +
relativeEnd, 0). 1. Else, let final be min(relativeEnd,
len). 1. Let count be min(final - from, len -
to). 1. If from < to and to < from + count, then
1. Let direction be -1. 1. Set from to from + count - 1.
1. Set to to to + count - 1. 1. Else, 1. Let direction
be 1. 1. Repeat, while count > 0, 1. Let fromKey be !
ToString(𝔽(from)). 1. Let toKey be ! ToString(𝔽(to)). 1. Let
fromPresent be ? HasProperty(O, fromKey). 1. If
fromPresent is `true`, then 1. Let fromValue be ? Get(O,
fromKey). 1. Perform ? Set(O, toKey, fromValue,
`true`). 1. Else, 1. Assert: fromPresent is `false`. 1. Perform
? DeletePropertyOrThrow(O, toKey). 1. Set from to from +
direction. 1. Set to to to + direction. 1. Set count
to count - 1. 1. Return O.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.entries ( )
---------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Return
CreateArrayIterator(O, ~key+value~).

Array.prototype.every ( callback [ , thisArg ] )
--------------------------------------------------------

callback should be a function that accepts three arguments and
returns a value that is coercible to a Boolean value. `every` calls
callback once for each element present in the array, in ascending
order, until it finds one where callback returns `false`. If such
an element is found, `every` immediately returns `false`. Otherwise,
`every` returns `true`. callback is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a thisArg parameter is provided, it will be used as the `this`
value for each invocation of callback. If it is not provided,
`undefined` is used instead.

callback is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

`every` does not directly mutate the object on which it is called but
the object may be mutated by the calls to callback.

The range of elements processed by `every` is set before the first
call to callback. Elements which are appended to the array after the
call to `every` begins will not be visited by callback. If
existing elements of the array are changed, their value as passed to
callback will be the value at the time `every` visits them;
elements that are deleted after the call to `every` begins and before
being visited are not visited. `every` acts like the "for all"
quantifier in mathematics. In particular, for an empty array, it returns
`true`.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If IsCallable(callback) is `false`,
throw a `TypeError` exception. 1. Let k be 0. 1. Repeat, while
k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kPresent be ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Let kValue be ? Get(O, Pk). 1. Let
testResult be ToBoolean(? Call(callback, thisArg, «
kValue, 𝔽(k), O »)). 1. If testResult is `false`,
return `false`. 1. Set k to k + 1. 1. Return `true`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.fill ( value [ , start [ , end ] ] )
----------------------------------------------------------------

The start argument is optional. If it is not provided,
`+0`\ :sub:`𝔽` is used.

The end argument is optional. If it is not provided, the length of
the `this` value is used.

If start is negative, it is treated as length + start where
length is the length of the array. If end is negative, it is
treated as length + end.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let k
be 0. 1. Else if relativeStart < 0, let k be max(len +
relativeStart, 0). 1. Else, let k be min(relativeStart,
len). 1. If end is `undefined`, let relativeEnd be
len; else let relativeEnd be ? ToIntegerOrInfinity(end). 1.
If relativeEnd = -∞, let final be 0. 1. Else if relativeEnd
< 0, let final be max(len + relativeEnd, 0). 1. Else, let
final be min(relativeEnd, len). 1. Repeat, while k <
final, 1. Let Pk be ! ToString(𝔽(k)). 1. Perform ?
Set(O, Pk, value, `true`). 1. Set k to k + 1. 1.
Return O.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.filter ( callback [ , thisArg ] )
---------------------------------------------------------

callback should be a function that accepts three arguments and
returns a value that is coercible to a Boolean value. `filter` calls
callback once for each element in the array, in ascending order, and
constructs a new array of all the values for which callback returns
`true`. callback is called only for elements of the array which
actually exist; it is not called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the `this`
value for each invocation of callback. If it is not provided,
`undefined` is used instead.

callback is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

`filter` does not directly mutate the object on which it is called but
the object may be mutated by the calls to callback.

The range of elements processed by `filter` is set before the first
call to callback. Elements which are appended to the array after the
call to `filter` begins will not be visited by callback. If
existing elements of the array are changed their value as passed to
callback will be the value at the time `filter` visits them;
elements that are deleted after the call to `filter` begins and before
being visited are not visited.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If IsCallable(callback) is `false`,
throw a `TypeError` exception. 1. Let A be ?
ArraySpeciesCreate(O, 0). 1. Let k be 0. 1. Let to be 0. 1.
Repeat, while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1.
Let kPresent be ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Let kValue be ? Get(O, Pk). 1. Let
selected be ToBoolean(? Call(callback, thisArg, «
kValue, 𝔽(k), O »)). 1. If selected is `true`, then 1.
Perform ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(to)),
kValue). 1. Set to to to + 1. 1. Set k to k + 1. 1.
Return A.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.find ( predicate [ , thisArg ] )
--------------------------------------------------------

This method calls predicate once for each element of the array, in
ascending index order, until it finds one where predicate returns a
value that coerces to `true`. If such an element is found, `find`
immediately returns that element value. Otherwise, `find` returns
`undefined`.

See FindViaPredicate for additional information.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let findRec be ?
FindViaPredicate(O, len, ~ascending~, predicate,
thisArg). 1. Return findRec.[[Value]].

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.findIndex ( predicate [ , thisArg ] )
-------------------------------------------------------------

This method calls predicate once for each element of the array, in
ascending index order, until it finds one where predicate returns a
value that coerces to `true`. If such an element is found,
`findIndex` immediately returns the index of that element value.
Otherwise, `findIndex` returns -1.

See FindViaPredicate for additional information.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let findRec be ?
FindViaPredicate(O, len, ~ascending~, predicate,
thisArg). 1. Return findRec.[[Index]].

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.findLast ( predicate [ , thisArg ] )
------------------------------------------------------------

This method calls predicate once for each element of the array, in
descending index order, until it finds one where predicate returns a
value that coerces to `true`. If such an element is found,
`findLast` immediately returns that element value. Otherwise,
`findLast` returns `undefined`.

See FindViaPredicate for additional information.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let findRec be ?
FindViaPredicate(O, len, ~descending~, predicate,
thisArg). 1. Return findRec.[[Value]].

This method is intentionally generic; it does not require that its
`this` value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method.

Array.prototype.findLastIndex ( predicate [ , thisArg ] )
-----------------------------------------------------------------

This method calls predicate once for each element of the array, in
descending index order, until it finds one where predicate returns a
value that coerces to `true`. If such an element is found,
`findLastIndex` immediately returns the index of that element value.
Otherwise, `findLastIndex` returns -1.

See FindViaPredicate for additional information.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let findRec be ?
FindViaPredicate(O, len, ~descending~, predicate,
thisArg). 1. Return findRec.[[Index]].

This method is intentionally generic; it does not require that its
`this` value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method.

FindViaPredicate ( O: an Object, len: a non-negative integer, direction: ~ascending~ or ~descending~, predicate, thisArg, )
---------------------------------------------------------------------------------------------------------------------------

description
   O should be an array-like object or a TypedArray. This operation
   calls predicate once for each element of O, in either
   ascending index order or descending index order (as indicated by
   direction), until it finds one where predicate returns a
   value that coerces to `true`. At that point, this operation returns
   a Record that gives the index and value of the element found. If no
   such element is found, this operation returns a Record that specifies
   `-1`\ :sub:`𝔽` for the index and `undefined` for the value.

   predicate should be a function. When called for an element of the
   array, it is passed three arguments: the value of the element, the
   index of the element, and the object being traversed. Its return
   value will be coerced to a Boolean value.

   thisArg will be used as the `this` value for each invocation of
   predicate.

   This operation does not directly mutate the object on which it is
   called, but the object may be mutated by the calls to predicate.

   The range of elements processed is set before the first call to
   predicate, just before the traversal begins. Elements that are
   appended to the array after this will not be visited by
   predicate. If existing elements of the array are changed, their
   value as passed to predicate will be the value at the time that
   this operation visits them. Elements that are deleted after traversal
   begins and before being visited are still visited and are either
   looked up from the prototype or are `undefined`.

1. If IsCallable(predicate) is `false`, throw a `TypeError`
exception. 1. If direction is ~ascending~, then 1. Let indices
be a List of the integers in the interval from 0 (inclusive) to len
(exclusive), in ascending order. 1. Else, 1. Let indices be a List
of the integers in the interval from 0 (inclusive) to len
(exclusive), in descending order. 1. For each integer k of
indices, do 1. Let Pk be ! ToString(𝔽(k)). 1. NOTE: If O
is a TypedArray, the following invocation of Get will return a normal
completion. 1. Let kValue be ? Get(O, Pk). 1. Let
testResult be ? Call(predicate, thisArg, « kValue,
𝔽(k), O »). 1. If ToBoolean(testResult) is `true`, return
the Record { [[Index]]: 𝔽(k), [[Value]]: kValue }. 1. Return the
Record { [[Index]]: `-1`\ :sub:`𝔽`, [[Value]]: `undefined` }.

Array.prototype.flat ( [ depth ] )
--------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let sourceLen be ?
LengthOfArrayLike(O). 1. Let depthNum be 1. 1. If depth is
not `undefined`, then 1. Set depthNum to ?
ToIntegerOrInfinity(depth). 1. If depthNum < 0, set depthNum
to 0. 1. Let A be ? ArraySpeciesCreate(O, 0). 1. Perform ?
FlattenIntoArray(A, O, sourceLen, 0, depthNum). 1.
Return A.

FlattenIntoArray ( target: an Object, source: an Object, sourceLen: a non-negative integer, start: a non-negative integer, depth: a non-negative integer or +∞, optional mapperFunction: a function object, optional thisArg, )
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: If mapperFunction is present, then
IsCallable(mapperFunction) is `true`, thisArg is present, and
depth is 1. 1. Let targetIndex be start. 1. Let
sourceIndex be `+0`\ :sub:`𝔽`. 1. Repeat, while ℝ(sourceIndex)
< sourceLen, 1. Let P be ! ToString(sourceIndex). 1. Let
exists be ? HasProperty(source, P). 1. If exists is
`true`, then 1. Let element be ? Get(source, P). 1. If
mapperFunction is present, then 1. Set element to ?
Call(mapperFunction, thisArg, « element, sourceIndex,
source »). 1. Let shouldFlatten be `false`. 1. If depth >
0, then 1. Set shouldFlatten to ? IsArray(element). 1. If
shouldFlatten is `true`, then 1. If depth = +∞, let
newDepth be +∞. 1. Else, let newDepth be depth - 1. 1. Let
elementLen be ? LengthOfArrayLike(element). 1. Set
targetIndex to ? FlattenIntoArray(target, element,
elementLen, targetIndex, newDepth). 1. Else, 1. If
targetIndex ≥ 2\ :sup:`53` - 1, throw a `TypeError` exception. 1.
Perform ? CreateDataPropertyOrThrow(target, !
ToString(𝔽(targetIndex)), element). 1. Set targetIndex to
targetIndex + 1. 1. Set sourceIndex to sourceIndex +
`1`\ :sub:`𝔽`. 1. Return targetIndex.

Array.prototype.flatMap ( mapperFunction [ , thisArg ] )
----------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let sourceLen be ?
LengthOfArrayLike(O). 1. If IsCallable(mapperFunction) is
`false`, throw a `TypeError` exception. 1. Let A be ?
ArraySpeciesCreate(O, 0). 1. Perform ? FlattenIntoArray(A,
O, sourceLen, 0, 1, mapperFunction, thisArg). 1. Return
A.

Array.prototype.forEach ( callback [ , thisArg ] )
----------------------------------------------------------

callback should be a function that accepts three arguments.
`forEach` calls callback once for each element present in the
array, in ascending order. callback is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a thisArg parameter is provided, it will be used as the `this`
value for each invocation of callback. If it is not provided,
`undefined` is used instead.

callback is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

`forEach` does not directly mutate the object on which it is called
but the object may be mutated by the calls to callback.

The range of elements processed by `forEach` is set before the first
call to callback. Elements which are appended to the array after the
call to `forEach` begins will not be visited by callback. If
existing elements of the array are changed, their value as passed to
callback will be the value at the time `forEach` visits them;
elements that are deleted after the call to `forEach` begins and
before being visited are not visited.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If IsCallable(callback) is `false`,
throw a `TypeError` exception. 1. Let k be 0. 1. Repeat, while
k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kPresent be ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Let kValue be ? Get(O, Pk). 1. Perform ?
Call(callback, thisArg, « kValue, 𝔽(k), O »). 1. Set
k to k + 1. 1. Return `undefined`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.includes ( searchElement [ , fromIndex ] )
------------------------------------------------------------------

This method compares searchElement to the elements of the array, in
ascending order, using the SameValueZero algorithm, and if found at any
position, returns `true`; otherwise, it returns `false`.

The optional second argument fromIndex defaults to `+0`\ :sub:`𝔽`
(i.e. the whole array is searched). If it is greater than or equal to
the length of the array, `false` is returned, i.e. the array will not
be searched. If it is less than `-0`\ :sub:`𝔽`, it is used as the
offset from the end of the array to compute fromIndex. If the
computed index is less than or equal to `+0`\ :sub:`𝔽`, the whole
array will be searched.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If len = 0, return `false`. 1. Let
n be ? ToIntegerOrInfinity(fromIndex). 1. Assert: If
fromIndex is `undefined`, then n is 0. 1. If n = +∞,
return `false`. 1. Else if n = -∞, set n to 0. 1. If n ≥
0, then 1. Let k be n. 1. Else, 1. Let k be len + n.
1. If k < 0, set k to 0. 1. Repeat, while k < len, 1.
Let elementK be ? Get(O, ! ToString(𝔽(k))). 1. If
SameValueZero(searchElement, elementK) is `true`, return
`true`. 1. Set k to k + 1. 1. Return `false`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

This method intentionally differs from the similar `indexOf` method in
two ways. First, it uses the SameValueZero algorithm, instead of
IsStrictlyEqual, allowing it to detect `NaN` array elements. Second,
it does not skip missing array elements, instead treating them as
`undefined`.

Array.prototype.indexOf ( searchElement [ , fromIndex ] )
-----------------------------------------------------------------

This method compares searchElement to the elements of the array, in
ascending order, using the IsStrictlyEqual algorithm, and if found at
one or more indices, returns the smallest such index; otherwise, it
returns `-1`\ :sub:`𝔽`.

The optional second argument fromIndex defaults to `+0`\ :sub:`𝔽`
(i.e. the whole array is searched). If it is greater than or equal to
the length of the array, `-1`\ :sub:`𝔽` is returned, i.e. the array
will not be searched. If it is less than `-0`\ :sub:`𝔽`, it is used as
the offset from the end of the array to compute fromIndex. If the
computed index is less than or equal to `+0`\ :sub:`𝔽`, the whole
array will be searched.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If len = 0, return `-1`\ :sub:`𝔽`. 1.
Let n be ? ToIntegerOrInfinity(fromIndex). 1. Assert: If
fromIndex is `undefined`, then n is 0. 1. If n = +∞,
return `-1`\ :sub:`𝔽`. 1. Else if n = -∞, set n to 0. 1. If
n ≥ 0, then 1. Let k be n. 1. Else, 1. Let k be len
+ n. 1. If k < 0, set k to 0. 1. Repeat, while k <
len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let kPresent be ?
HasProperty(O, Pk). 1. If kPresent is `true`, then 1. Let
elementK be ? Get(O, Pk). 1. If
IsStrictlyEqual(searchElement, elementK) is `true`, return
𝔽(k). 1. Set k to k + 1. 1. Return `-1`\ :sub:`𝔽`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.join ( separator )
--------------------------------------

This method converts the elements of the array to Strings, and then
concatenates these Strings, separated by occurrences of the
separator. If no separator is provided, a single comma is used as
the separator.

It performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If separator is `undefined`, let
sep be `","`. 1. Else, let sep be ? ToString(separator).
1. Let R be the empty String. 1. Let k be 0. 1. Repeat, while
k < len, 1. If k > 0, set R to the string-concatenation
of R and sep. 1. Let element be ? Get(O, !
ToString(𝔽(k))). 1. If element is neither `undefined` nor
`null`, then 1. Let S be ? ToString(element). 1. Set R to
the string-concatenation of R and S. 1. Set k to k + 1.
1. Return R.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore, it can be transferred to other
kinds of objects for use as a method.

Array.prototype.keys ( )
------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Return
CreateArrayIterator(O, ~key~).

Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
---------------------------------------------------------------------

This method compares searchElement to the elements of the array in
descending order using the IsStrictlyEqual algorithm, and if found at
one or more indices, returns the largest such index; otherwise, it
returns `-1`\ :sub:`𝔽`.

The optional second argument fromIndex defaults to the array's
length minus one (i.e. the whole array is searched). If it is greater
than or equal to the length of the array, the whole array will be
searched. If it is less than `-0`\ :sub:`𝔽`, it is used as the offset
from the end of the array to compute fromIndex. If the computed
index is less than or equal to `+0`\ :sub:`𝔽`, `-1`\ :sub:`𝔽` is
returned.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If len = 0, return `-1`\ :sub:`𝔽`. 1.
If fromIndex is present, let n be ?
ToIntegerOrInfinity(fromIndex); else let n be len - 1. 1. If
n = -∞, return `-1`\ :sub:`𝔽`. 1. If n ≥ 0, then 1. Let k
be min(n, len - 1). 1. Else, 1. Let k be len + n. 1.
Repeat, while k ≥ 0, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kPresent be ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Let elementK be ? Get(O, Pk). 1. If
IsStrictlyEqual(searchElement, elementK) is `true`, return
𝔽(k). 1. Set k to k - 1. 1. Return `-1`\ :sub:`𝔽`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.map ( callback [ , thisArg ] )
------------------------------------------------------

callback should be a function that accepts three arguments. `map`
calls callback once for each element in the array, in ascending
order, and constructs a new Array from the results. callback is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the `this`
value for each invocation of callback. If it is not provided,
`undefined` is used instead.

callback is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

`map` does not directly mutate the object on which it is called but
the object may be mutated by the calls to callback.

The range of elements processed by `map` is set before the first call
to callback. Elements which are appended to the array after the call
to `map` begins will not be visited by callback. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time `map` visits them; elements that are
deleted after the call to `map` begins and before being visited are
not visited.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If IsCallable(callback) is `false`,
throw a `TypeError` exception. 1. Let A be ?
ArraySpeciesCreate(O, len). 1. Let k be 0. 1. Repeat, while
k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kPresent be ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Let kValue be ? Get(O, Pk). 1. Let
mappedValue be ? Call(callback, thisArg, « kValue,
𝔽(k), O »). 1. Perform ? CreateDataPropertyOrThrow(A,
Pk, mappedValue). 1. Set k to k + 1. 1. Return A.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.pop ( )
-----------------------

This method removes the last element of the array and returns it.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If len = 0, then 1. Perform ?
Set(O, `"length"`, `+0`\ :sub:`𝔽`, `true`). 1. Return
`undefined`. 1. Else, 1. Assert: len > 0. 1. Let newLen be
𝔽(len - 1). 1. Let index be ! ToString(newLen). 1. Let
element be ? Get(O, index). 1. Perform ?
DeletePropertyOrThrow(O, index). 1. Perform ? Set(O,
`"length"`, newLen, `true`). 1. Return element.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.push ( ..._items )
------------------------------------

This method appends the arguments to the end of the array, in the order
in which they appear. It returns the new length of the array.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let argCount be the number of elements
in items. 1. If len + argCount > 2\ :sup:`53` - 1, throw a
`TypeError` exception. 1. For each element E of items, do 1.
Perform ? Set(O, ! ToString(𝔽(len)), E, `true`). 1. Set
len to len + 1. 1. Perform ? Set(O, `"length"`,
𝔽(len), `true`). 1. Return 𝔽(len).

The `"length"` property of this method is `1`\ :sub:`𝔽`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.reduce ( callback [ , initialValue ] )
--------------------------------------------------------------

callback should be a function that takes four arguments. `reduce`
calls the callback, as a function, once for each element after the first
element present in the array, in ascending order.

callback is called with four arguments: the previousValue (value
from the previous call to callback), the currentValue (value of
the current element), the currentIndex, and the object being
traversed. The first time that callback is called, the previousValue
and currentValue can be one of two values. If an initialValue
was supplied in the call to `reduce`, then previousValue will be
initialValue and currentValue will be the first value in the
array. If no initialValue was supplied, then previousValue will
be the first value in the array and currentValue will be the second.
It is a `TypeError` if the array contains no elements and
initialValue is not provided.

`reduce` does not directly mutate the object on which it is called but
the object may be mutated by the calls to callback.

The range of elements processed by `reduce` is set before the first
call to callback. Elements that are appended to the array after the
call to `reduce` begins will not be visited by callback. If
existing elements of the array are changed, their value as passed to
callback will be the value at the time `reduce` visits them;
elements that are deleted after the call to `reduce` begins and before
being visited are not visited.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If IsCallable(callback) is `false`,
throw a `TypeError` exception. 1. If len = 0 and initialValue
is not present, throw a `TypeError` exception. 1. Let k be 0. 1.
Let accumulator be `undefined`. 1. If initialValue is present,
then 1. Set accumulator to initialValue. 1. Else, 1. Let
kPresent be `false`. 1. Repeat, while kPresent is `false`
and k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Set
kPresent to ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Set accumulator to ? Get(O, Pk). 1. Set
k to k + 1. 1. If kPresent is `false`, throw a
`TypeError` exception. 1. Repeat, while k < len, 1. Let Pk
be ! ToString(𝔽(k)). 1. Let kPresent be ? HasProperty(O,
Pk). 1. If kPresent is `true`, then 1. Let kValue be ?
Get(O, Pk). 1. Set accumulator to ? Call(callback,
`undefined`, « accumulator, kValue, 𝔽(k), O »). 1. Set
k to k + 1. 1. Return accumulator.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.reduceRight ( callback [ , initialValue ] )
-------------------------------------------------------------------

callback should be a function that takes four arguments.
`reduceRight` calls the callback, as a function, once for each element
after the first element present in the array, in descending order.

callback is called with four arguments: the previousValue (value
from the previous call to callback), the currentValue (value of
the current element), the currentIndex, and the object being
traversed. The first time the function is called, the previousValue
and currentValue can be one of two values. If an initialValue
was supplied in the call to `reduceRight`, then previousValue will
be initialValue and currentValue will be the last value in the
array. If no initialValue was supplied, then previousValue will
be the last value in the array and currentValue will be the
second-to-last value. It is a `TypeError` if the array contains no
elements and initialValue is not provided.

`reduceRight` does not directly mutate the object on which it is
called but the object may be mutated by the calls to callback.

The range of elements processed by `reduceRight` is set before the
first call to callback. Elements that are appended to the array
after the call to `reduceRight` begins will not be visited by
callback. If existing elements of the array are changed by
callback, their value as passed to callback will be the value at
the time `reduceRight` visits them; elements that are deleted after
the call to `reduceRight` begins and before being visited are not
visited.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If IsCallable(callback) is `false`,
throw a `TypeError` exception. 1. If len = 0 and initialValue
is not present, throw a `TypeError` exception. 1. Let k be len
- 1. 1. Let accumulator be `undefined`. 1. If initialValue is
present, then 1. Set accumulator to initialValue. 1. Else, 1.
Let kPresent be `false`. 1. Repeat, while kPresent is
`false` and k ≥ 0, 1. Let Pk be ! ToString(𝔽(k)). 1. Set
kPresent to ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Set accumulator to ? Get(O, Pk). 1. Set
k to k - 1. 1. If kPresent is `false`, throw a
`TypeError` exception. 1. Repeat, while k ≥ 0, 1. Let Pk be !
ToString(𝔽(k)). 1. Let kPresent be ? HasProperty(O, Pk).
1. If kPresent is `true`, then 1. Let kValue be ? Get(O,
Pk). 1. Set accumulator to ? Call(callback, `undefined`, «
accumulator, kValue, 𝔽(k), O »). 1. Set k to k -
1. 1. Return accumulator.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.reverse ( )
---------------------------

This method rearranges the elements of the array so as to reverse their
order. It returns the reversed array.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let middle be floor(len / 2). 1.
Let lower be 0. 1. Repeat, while lower ≠ middle, 1. Let
upper be len - lower - 1. 1. Let upperP be !
ToString(𝔽(upper)). 1. Let lowerP be ! ToString(𝔽(lower)).
1. Let lowerExists be ? HasProperty(O, lowerP). 1. If
lowerExists is `true`, then 1. Let lowerValue be ? Get(O,
lowerP). 1. Let upperExists be ? HasProperty(O, upperP).
1. If upperExists is `true`, then 1. Let upperValue be ?
Get(O, upperP). 1. If lowerExists is `true` and
upperExists is `true`, then 1. Perform ? Set(O, lowerP,
upperValue, `true`). 1. Perform ? Set(O, upperP,
lowerValue, `true`). 1. Else if lowerExists is `false` and
upperExists is `true`, then 1. Perform ? Set(O, lowerP,
upperValue, `true`). 1. Perform ? DeletePropertyOrThrow(O,
upperP). 1. Else if lowerExists is `true` and upperExists
is `false`, then 1. Perform ? DeletePropertyOrThrow(O,
lowerP). 1. Perform ? Set(O, upperP, lowerValue,
`true`). 1. Else, 1. Assert: lowerExists and upperExists are
both `false`. 1. NOTE: No action is required. 1. Set lower to
lower + 1. 1. Return O.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore, it can be transferred to other
kinds of objects for use as a method.

Array.prototype.shift ( )
-------------------------

This method removes the first element of the array and returns it.

It performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If len = 0, then 1. Perform ?
Set(O, `"length"`, `+0`\ :sub:`𝔽`, `true`). 1. Return
`undefined`. 1. Let first be ? Get(O, `"0"`). 1. Let k
be 1. 1. Repeat, while k < len, 1. Let from be !
ToString(𝔽(k)). 1. Let to be ! ToString(𝔽(k - 1)). 1. Let
fromPresent be ? HasProperty(O, from). 1. If fromPresent
is `true`, then 1. Let fromValue be ? Get(O, from). 1.
Perform ? Set(O, to, fromValue, `true`). 1. Else, 1.
Assert: fromPresent is `false`. 1. Perform ?
DeletePropertyOrThrow(O, to). 1. Set k to k + 1. 1.
Perform ? DeletePropertyOrThrow(O, ! ToString(𝔽(len - 1))). 1.
Perform ? Set(O, `"length"`, 𝔽(len - 1), `true`). 1. Return
first.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.slice ( start, end )
--------------------------------------------

This method returns an array containing the elements of the array from
element start up to, but not including, element end (or through
the end of the array if end is `undefined`). If start is
negative, it is treated as length + start where length is
the length of the array. If end is negative, it is treated as
length + end where length is the length of the array.

It performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let k
be 0. 1. Else if relativeStart < 0, let k be max(len +
relativeStart, 0). 1. Else, let k be min(relativeStart,
len). 1. If end is `undefined`, let relativeEnd be
len; else let relativeEnd be ? ToIntegerOrInfinity(end). 1.
If relativeEnd = -∞, let final be 0. 1. Else if relativeEnd
< 0, let final be max(len + relativeEnd, 0). 1. Else, let
final be min(relativeEnd, len). 1. Let count be
max(final - k, 0). 1. Let A be ? ArraySpeciesCreate(O,
count). 1. Let n be 0. 1. Repeat, while k < final, 1.
Let Pk be ! ToString(𝔽(k)). 1. Let kPresent be ?
HasProperty(O, Pk). 1. If kPresent is `true`, then 1. Let
kValue be ? Get(O, Pk). 1. Perform ?
CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), kValue). 1.
Set k to k + 1. 1. Set n to n + 1. 1.
[id="step-array-proto-slice-set-length"] Perform ? Set(A,
`"length"`, 𝔽(n), `true`). 1. Return A.

The explicit setting of the `"length"` property in step is intended to
ensure the length is correct even when A is not a built-in Array.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.some ( callback [ , thisArg ] )
-------------------------------------------------------

callback should be a function that accepts three arguments and
returns a value that is coercible to a Boolean value. `some` calls
callback once for each element present in the array, in ascending
order, until it finds one where callback returns `true`. If such
an element is found, `some` immediately returns `true`. Otherwise,
`some` returns `false`. callback is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a thisArg parameter is provided, it will be used as the `this`
value for each invocation of callback. If it is not provided,
`undefined` is used instead.

callback is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

`some` does not directly mutate the object on which it is called but
the object may be mutated by the calls to callback.

The range of elements processed by `some` is set before the first call
to callback. Elements that are appended to the array after the call
to `some` begins will not be visited by callback. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time that `some` visits them; elements that
are deleted after the call to `some` begins and before being visited
are not visited. `some` acts like the "exists" quantifier in
mathematics. In particular, for an empty array, it returns `false`.

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. If IsCallable(callback) is `false`,
throw a `TypeError` exception. 1. Let k be 0. 1. Repeat, while
k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kPresent be ? HasProperty(O, Pk). 1. If kPresent is
`true`, then 1. Let kValue be ? Get(O, Pk). 1. Let
testResult be ToBoolean(? Call(callback, thisArg, «
kValue, 𝔽(k), O »)). 1. If testResult is `true`,
return `true`. 1. Set k to k + 1. 1. Return `false`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.sort ( comparator )
---------------------------------------

This method sorts the elements of this array. If comparator is not
`undefined`, it should be a function that accepts two arguments x
and y and returns a negative Number if x < y, a positive
Number if x > y, or a zero otherwise.

It performs the following steps when called:

1. [id="step-array-sort-comparefn"] If comparator is not
`undefined` and IsCallable(comparator) is `false`, throw a
`TypeError` exception. 1. Let obj be ? ToObject(`this` value).
1. [id="step-array-sort-len"] Let len be ?
LengthOfArrayLike(obj). 1. Let SortCompare be a new Abstract
Closure with parameters (x, y) that captures comparator and
performs the following steps when called: 1. Return ?
CompareArrayElements(x, y, comparator). 1.
[id="step-array-sortindexedproperties"] Let sortedList be ?
SortIndexedProperties(obj, len, SortCompare, ~skip-holes~).
1. Let itemCount be the number of elements in sortedList. 1. Let
j be 0. 1. Repeat, while j < itemCount, 1. Perform ?
Set(obj, ! ToString(𝔽(j)), sortedList[j], `true`). 1.
Set j to j + 1. 1. NOTE: The call to SortIndexedProperties in
step uses ~skip-holes~. The remaining indices are deleted to preserve
the number of holes that were detected and excluded from the sort. 1.
Repeat, while j < len, 1. Perform ?
DeletePropertyOrThrow(obj, ! ToString(𝔽(j))). 1. Set j to
j + 1. 1. Return obj.

Because non-existent property values always compare greater than
`undefined` property values, and `undefined` always compares greater
than any other value (see CompareArrayElements), `undefined` property
values always sort to the end of the result, followed by non-existent
property values.

Method calls performed by the ToString abstract operations in steps and
have the potential to cause SortCompare to not behave as a
consistent comparator.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore, it can be transferred to other
kinds of objects for use as a method.

SortIndexedProperties ( obj: an Object, len: a non-negative integer, SortCompare: an Abstract Closure with two parameters, holes: ~skip-holes~ or ~read-through-holes~, )
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let items be a new empty List. 1. Let k be 0. 1. Repeat,
while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. If
holes is ~skip-holes~, then 1. Let kRead be ?
HasProperty(obj, Pk). 1. Else, 1. Assert: holes is
~read-through-holes~. 1. Let kRead be `true`. 1. If kRead is
`true`, then 1. Let kValue be ? Get(obj, Pk). 1. Append
kValue to items. 1. Set k to k + 1. 1.
[id="step-array-sort"] Sort items using an implementation-defined
sequence of calls to SortCompare. If any such call returns an abrupt
completion, stop before performing any further calls to SortCompare
and return that Completion Record. 1. Return items.

The sort order is the ordering of items after completion of step of
the algorithm above. The sort order is implementation-defined if
SortCompare is not a consistent comparator for the elements of
items. When SortIndexedProperties is invoked by Array.prototype.sort
or Array.prototype.toSorted, the sort order is also
implementation-defined if comparator is `undefined`, and all
applications of ToString, to any specific value passed as an argument to
SortCompare, do not produce the same result.

Unless the sort order is specified to be implementation-defined, it must
satisfy all of the following conditions:

- There must be some mathematical permutation π of the non-negative
  integers less than itemCount, such that for every non-negative
  integer j less than itemCount, the element old[j] is
  exactly the same as new[π(j)].
- Then for all non-negative integers j and k, each less than
  itemCount, if ℝ(SortCompare(old[j], old[k])) < 0, then
  π(j) < π(k).
- And for all non-negative integers j and k such that j <
  k < itemCount, if ℝ(SortCompare(old[j], old[k])) =
  0, then π(j) < π(k); i.e., the sort is stable.

Here the notation old[j] is used to refer to items[j] before
step is executed, and the notation new[j] to refer to
items[j] after step has been executed.

An abstract closure or function comparator is a consistent
comparator for a set of values S if all of the requirements below
are met for all values a, b, and c (possibly the same value)
in the set S: The notation a <:sub:`C` b means
ℝ(comparator(a, b)) < 0; a =\ :sub:`C` b means
ℝ(comparator(a, b)) = 0; and a >\ :sub:`C` b means
ℝ(comparator(a, b)) > 0.

- Calling comparator(a, b) always returns the same value
  v when given a specific pair of values a and b as its two
  arguments. Furthermore, v is a Number, and v is not `NaN`.
  Note that this implies that exactly one of a <:sub:`C` b,
  a =\ :sub:`C` b, and a >\ :sub:`C` b will be true for
  a given pair of a and b.
- Calling comparator(a, b) does not modify obj or any
  object on obj's prototype chain.
- a =\ :sub:`C` a (reflexivity)
- If a =\ :sub:`C` b, then b =\ :sub:`C` a (symmetry)
- If a =\ :sub:`C` b and b =\ :sub:`C` c, then a
  =\ :sub:`C` c (transitivity of =\ :sub:`C`)
- If a <:sub:`C` b and b <:sub:`C` c, then a
  <:sub:`C` c (transitivity of <:sub:`C`)
- If a >\ :sub:`C` b and b >\ :sub:`C` c, then a
  >\ :sub:`C` c (transitivity of >\ :sub:`C`)

The above conditions are necessary and sufficient to ensure that
comparator divides the set S into equivalence classes and that
these equivalence classes are totally ordered.

CompareArrayElements ( x, y, comparator: a function object or `undefined`, )
----------------------------------------------------------------------------

1. If x and y are both `undefined`, return `+0`\ :sub:`𝔽`.
1. If x is `undefined`, return `1`\ :sub:`𝔽`. 1. If y is
`undefined`, return `-1`\ :sub:`𝔽`. 1. If comparator is not
`undefined`, then 1. Let v be ? ToNumber(? Call(comparator,
`undefined`, « x, y »)). 1. If v is `NaN`, return
`+0`\ :sub:`𝔽`. 1. Return v. 1. [id="step-sortcompare-tostring-x"]
Let xString be ? ToString(x). 1.
[id="step-sortcompare-tostring-y"] Let yString be ? ToString(y).
1. Let xSmaller be ! IsLessThan(xString, yString, `true`).
1. If xSmaller is `true`, return `-1`\ :sub:`𝔽`. 1. Let
ySmaller be ! IsLessThan(yString, xString, `true`). 1. If
ySmaller is `true`, return `1`\ :sub:`𝔽`. 1. Return
`+0`\ :sub:`𝔽`.

Array.prototype.splice ( start, deleteCount, ..._items )
------------------------------------------------------------------

This method deletes the deleteCount elements of the array starting
at integer index start and replaces them with the elements of
items. It returns an Array containing the deleted elements (if any).

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let
actualStart be 0. 1. Else if relativeStart < 0, let
actualStart be max(len + relativeStart, 0). 1. Else, let
actualStart be min(relativeStart, len). 1. Let itemCount
be the number of elements in items. 1. If start is not present,
then 1. Let actualDeleteCount be 0. 1. Else if deleteCount is
not present, then 1. Let actualDeleteCount be len -
actualStart. 1. Else, 1. Let dc be ?
ToIntegerOrInfinity(deleteCount). 1. Let actualDeleteCount be
the result of clamping dc between 0 and len - actualStart.
1. If len + itemCount - actualDeleteCount > 2\ :sup:`53` -
1, throw a `TypeError` exception. 1. Let A be ?
ArraySpeciesCreate(O, actualDeleteCount). 1. Let k be 0. 1.
Repeat, while k < actualDeleteCount, 1. Let from be !
ToString(𝔽(actualStart + k)). 1. If ? HasProperty(O,
from) is `true`, then 1. Let fromValue be ? Get(O,
from). 1. Perform ? CreateDataPropertyOrThrow(A, !
ToString(𝔽(k)), fromValue). 1. Set k to k + 1. 1.
[id="step-array-proto-splice-set-length"] Perform ? Set(A,
`"length"`, 𝔽(actualDeleteCount), `true`). 1. If itemCount <
actualDeleteCount, then 1. Set k to actualStart. 1. Repeat,
while k < (len - actualDeleteCount), 1. Let from be !
ToString(𝔽(k + actualDeleteCount)). 1. Let to be !
ToString(𝔽(k + itemCount)). 1. If ? HasProperty(O, from)
is `true`, then 1. Let fromValue be ? Get(O, from). 1.
Perform ? Set(O, to, fromValue, `true`). 1. Else, 1.
Perform ? DeletePropertyOrThrow(O, to). 1. Set k to k +
1. 1. Set k to len. 1. Repeat, while k > (len -
actualDeleteCount + itemCount), 1. Perform ?
DeletePropertyOrThrow(O, ! ToString(𝔽(k - 1))). 1. Set k to
k - 1. 1. Else if itemCount > actualDeleteCount, then 1. Set
k to (len - actualDeleteCount). 1. Repeat, while k >
actualStart, 1. Let from be ! ToString(𝔽(k +
actualDeleteCount - 1)). 1. Let to be ! ToString(𝔽(k +
itemCount - 1)). 1. If ? HasProperty(O, from) is `true`,
then 1. Let fromValue be ? Get(O, from). 1. Perform ?
Set(O, to, fromValue, `true`). 1. Else, 1. Perform ?
DeletePropertyOrThrow(O, to). 1. Set k to k - 1. 1. Set
k to actualStart. 1. For each element E of items, do 1.
Perform ? Set(O, ! ToString(𝔽(k)), E, `true`). 1. Set
k to k + 1. 1. [id="step-array-proto-splice-set-length-2"]
Perform ? Set(O, `"length"`, 𝔽(len - actualDeleteCount +
itemCount), `true`). 1. Return A.

The explicit setting of the `"length"` property in steps and is
intended to ensure the lengths are correct even when the objects are not
built-in Arrays.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
------------------------------------------------------------------------

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement this method as specified in the
ECMA-402 specification. If an ECMAScript implementation does not include
the ECMA-402 API the following specification of this method is used.

The first edition of ECMA-402 did not include a replacement
specification for this method.

The meanings of the optional parameters to this method are defined in
the ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

This method performs the following steps when called:

1. Let array be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(array). 1. Let separator be the
implementation-defined list-separator String value appropriate for the
host environment's current locale (such as `", "`). 1. Let R be
the empty String. 1. Let k be 0. 1. Repeat, while k < len,
1. If k > 0, set R to the string-concatenation of R and
separator. 1. Let element be ? Get(array, !
ToString(𝔽(k))). 1. If element is neither `undefined` nor
`null`, then 1. Let S be ? ToString(? Invoke(element,
`"toLocaleString"`)). 1. Set R to the string-concatenation of
R and S. 1. Set k to k + 1. 1. Return R.

This method converts the elements of the array to Strings using their
`toLocaleString` methods, and then concatenates these Strings,
separated by occurrences of an implementation-defined locale-sensitive
separator String. This method is analogous to `toString` except that
it is intended to yield a locale-sensitive result corresponding with
conventions of the host environment's current locale.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.toReversed ( )
------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let A be ? ArrayCreate(len). 1. Let
k be 0. 1. Repeat, while k < len, 1. Let from be !
ToString(𝔽(len - k - 1)). 1. Let Pk be ! ToString(𝔽(k)).
1. Let fromValue be ? Get(O, from). 1. Perform !
CreateDataPropertyOrThrow(A, Pk, fromValue). 1. Set k to
k + 1. 1. Return A.

Array.prototype.toSorted ( comparator )
-------------------------------------------

This method performs the following steps when called:

1. If comparator is not `undefined` and IsCallable(comparator)
is `false`, throw a `TypeError` exception. 1. Let O be ?
ToObject(`this` value). 1. Let len be ? LengthOfArrayLike(O).
1. Let A be ? ArrayCreate(len). 1. Let SortCompare be a new
Abstract Closure with parameters (x, y) that captures
comparator and performs the following steps when called: 1. Return ?
CompareArrayElements(x, y, comparator). 1. Let
sortedList be ? SortIndexedProperties(O, len,
SortCompare, ~read-through-holes~). 1. Let j be 0. 1. Repeat,
while j < len, 1. Perform ! CreateDataPropertyOrThrow(A, !
ToString(𝔽(j)), sortedList[j]). 1. Set j to j + 1.
1. Return A.

Array.prototype.toSpliced ( start, skipCount, ..._items )
-------------------------------------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let
actualStart be 0. 1. Else if relativeStart < 0, let
actualStart be max(len + relativeStart, 0). 1. Else, let
actualStart be min(relativeStart, len). 1. Let
insertCount be the number of elements in items. 1. If start
is not present, then 1. Let actualSkipCount be 0. 1. Else if
skipCount is not present, then 1. Let actualSkipCount be len
- actualStart. 1. Else, 1. Let sc be ?
ToIntegerOrInfinity(skipCount). 1. Let actualSkipCount be the
result of clamping sc between 0 and len - actualStart. 1.
Let newLen be len + insertCount - actualSkipCount. 1. If
newLen > 2\ :sup:`53` - 1, throw a `TypeError` exception. 1. Let
A be ? ArrayCreate(newLen). 1. Let i be 0. 1. Let r be
actualStart + actualSkipCount. 1. Repeat, while i <
actualStart, 1. Let Pi be ! ToString(𝔽(i)). 1. Let
iValue be ? Get(O, Pi). 1. Perform !
CreateDataPropertyOrThrow(A, Pi, iValue). 1. Set i to
i + 1. 1. For each element E of items, do 1. Let Pi be !
ToString(𝔽(i)). 1. Perform ! CreateDataPropertyOrThrow(A,
Pi, E). 1. Set i to i + 1. 1. Repeat, while i <
newLen, 1. Let Pi be ! ToString(𝔽(i)). 1. Let from be !
ToString(𝔽(r)). 1. Let fromValue be ? Get(O, from). 1.
Perform ! CreateDataPropertyOrThrow(A, Pi, fromValue). 1.
Set i to i + 1. 1. Set r to r + 1. 1. Return A.

Array.prototype.toString ( )
----------------------------

This method performs the following steps when called:

1. Let array be ? ToObject(`this` value). 1. Let func be ?
Get(array, `"join"`). 1. If IsCallable(func) is `false`, set
func to the intrinsic function %Object.prototype.toString%. 1.
Return ? Call(func, array).

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.unshift ( ..._items )
---------------------------------------

This method prepends the arguments to the start of the array, such that
their order within the array is the same as the order in which they
appear in the argument list.

It performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let argCount be the number of elements
in items. 1. If argCount > 0, then 1. If len + argCount
> 2\ :sup:`53` - 1, throw a `TypeError` exception. 1. Let k be
len. 1. Repeat, while k > 0, 1. Let from be !
ToString(𝔽(k - 1)). 1. Let to be ! ToString(𝔽(k +
argCount - 1)). 1. Let fromPresent be ? HasProperty(O,
from). 1. If fromPresent is `true`, then 1. Let fromValue
be ? Get(O, from). 1. Perform ? Set(O, to,
fromValue, `true`). 1. Else, 1. Assert: fromPresent is
`false`. 1. Perform ? DeletePropertyOrThrow(O, to). 1. Set
k to k - 1. 1. Let j be `+0`\ :sub:`𝔽`. 1. For each
element E of items, do 1. Perform ? Set(O, !
ToString(j), E, `true`). 1. Set j to j +
`1`\ :sub:`𝔽`. 1. Perform ? Set(O, `"length"`, 𝔽(len +
argCount), `true`). 1. Return 𝔽(len + argCount).

The `"length"` property of this method is `1`\ :sub:`𝔽`.

This method is intentionally generic; it does not require that its
`this` value be an Array. Therefore it can be transferred to other
kinds of objects for use as a method.

Array.prototype.values ( )
--------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Return
CreateArrayIterator(O, ~value~).

Array.prototype.with ( index, value )
---------------------------------------------

This method performs the following steps when called:

1. Let O be ? ToObject(`this` value). 1. Let len be ?
LengthOfArrayLike(O). 1. Let relativeIndex be ?
ToIntegerOrInfinity(index). 1. If relativeIndex ≥ 0, let
actualIndex be relativeIndex. 1. Else, let actualIndex be
len + relativeIndex. 1. If actualIndex ≥ len or
actualIndex < 0, throw a `RangeError` exception. 1. Let A be ?
ArrayCreate(len). 1. Let k be 0. 1. Repeat, while k <
len, 1. Let Pk be ! ToString(𝔽(k)). 1. If k =
actualIndex, let fromValue be value. 1. Else, let
fromValue be ? Get(O, Pk). 1. Perform !
CreateDataPropertyOrThrow(A, Pk, fromValue). 1. Set k to
k + 1. 1. Return A.

Array.prototype [ %Symbol.iterator% ] ( )
-----------------------------------------

The initial value of the %Symbol.iterator% property is
%Array.prototype.values%, defined in .

Array.prototype [ %Symbol.unscopables% ]
----------------------------------------

The initial value of the %Symbol.unscopables% data property is an object
created by the following steps:

1. Let unscopableList be OrdinaryObjectCreate(`null`). 1. Perform
! CreateDataPropertyOrThrow(unscopableList, `"at"`, `true`). 1.
Perform ! CreateDataPropertyOrThrow(unscopableList,
`"copyWithin"`, `true`). 1. Perform !
CreateDataPropertyOrThrow(unscopableList, `"entries"`, `true`).
1. Perform ! CreateDataPropertyOrThrow(unscopableList, `"fill"`,
`true`). 1. Perform ! CreateDataPropertyOrThrow(unscopableList,
`"find"`, `true`). 1. Perform !
CreateDataPropertyOrThrow(unscopableList, `"findIndex"`,
`true`). 1. Perform ! CreateDataPropertyOrThrow(unscopableList,
`"findLast"`, `true`). 1. Perform !
CreateDataPropertyOrThrow(unscopableList, `"findLastIndex"`,
`true`). 1. Perform ! CreateDataPropertyOrThrow(unscopableList,
`"flat"`, `true`). 1. Perform !
CreateDataPropertyOrThrow(unscopableList, `"flatMap"`, `true`).
1. Perform ! CreateDataPropertyOrThrow(unscopableList,
`"includes"`, `true`). 1. Perform !
CreateDataPropertyOrThrow(unscopableList, `"keys"`, `true`). 1.
Perform ! CreateDataPropertyOrThrow(unscopableList,
`"toReversed"`, `true`). 1. Perform !
CreateDataPropertyOrThrow(unscopableList, `"toSorted"`, `true`).
1. Perform ! CreateDataPropertyOrThrow(unscopableList,
`"toSpliced"`, `true`). 1. Perform !
CreateDataPropertyOrThrow(unscopableList, `"values"`, `true`).
1. Return unscopableList.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

The own property names of this object are property names that were not
included as standard properties of `Array.prototype` prior to the
ECMAScript 2015 specification. These names are ignored for `with`
statement binding purposes in order to preserve the behaviour of
existing code that might use one of these names as a binding in an outer
scope that is shadowed by a `with` statement whose binding object is
an Array.

The reason that `"with"` is not included in the unscopableList is
because it is already a reserved word.

Properties of Array Instances
-----------------------------

Array instances are Array exotic objects and have the internal methods
specified for such objects. Array instances inherit properties from the
Array prototype object.

Array instances have a `"length"` property, and a set of enumerable
properties with array index names.

.. _length-2:

length
------

The `"length"` property of an Array instance is a data property whose
value is always numerically greater than the name of every configurable
own property whose name is an array index.

The `"length"` property initially has the attributes { [[Writable]]:
`true`, [[Enumerable]]: `false`, [[Configurable]]: `false` }.

Reducing the value of the `"length"` property has the side-effect of
deleting own array elements whose array index is between the old and new
length values. However, non-configurable properties can not be deleted.
Attempting to set the `"length"` property of an Array to a value that
is numerically less than or equal to the largest numeric own property
name of an existing non-configurable array-indexed property of the array
will result in the length being set to a numeric value that is one
greater than that non-configurable numeric own property name. See .

Array Iterator Objects
----------------------

An Array Iterator is an object that represents a specific iteration over
some specific Array instance object. There is not a named constructor
for Array Iterator objects. Instead, Array Iterator objects are created
by calling certain methods of Array instance objects.

CreateArrayIterator ( array: an Object, kind: ~key+value~, ~key~, or ~value~, ): a Generator
----------------------------------------------------------------------------------------------------

description
   It is used to create iterator objects for Array methods that return
   such iterators.

1. Let closure be a new Abstract Closure with no parameters that
captures kind and array and performs the following steps when
called: 1. Let index be 0. 1. Repeat, 1. If array has a
[[TypedArrayName]] internal slot, then 1. Let taRecord be
MakeTypedArrayWithBufferWitnessRecord(array, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, throw a `TypeError`
exception. 1. Let len be TypedArrayLength(taRecord). 1. Else, 1.
Let len be ? LengthOfArrayLike(array). 1. If index ≥
len, return NormalCompletion(`undefined`). 1. Let indexNumber
be 𝔽(index). 1. If kind is ~key~, then 1. Let result be
indexNumber. 1. Else, 1. Let elementKey be !
ToString(indexNumber). 1. Let elementValue be ? Get(array,
elementKey). 1. If kind is ~value~, then 1. Let result be
elementValue. 1. Else, 1. Assert: kind is ~key+value~. 1. Let
result be CreateArrayFromList(« indexNumber, elementValue
»). 1. Perform ? GeneratorYield(CreateIteratorResultObject(result,
`false`)). 1. Set index to index + 1. 1. Return
CreateIteratorFromClosure(closure, `"%ArrayIteratorPrototype%"`,
%ArrayIteratorPrototype%).

The %ArrayIteratorPrototype% Object
-----------------------------------

The %ArrayIteratorPrototype% object:

- has properties that are inherited by all Array Iterator objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- has the following properties:

%ArrayIteratorPrototype%.next ( )
---------------------------------

1. Return ? GeneratorResume(`this` value, ~empty~,
`"%ArrayIteratorPrototype%"`).

%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]
-------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Array Iterator"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

TypedArray Objects
------------------

A TypedArray presents an array-like view of an underlying binary
data buffer (). A TypedArray element type is the underlying binary
scalar data type that all elements of a TypedArray instance have.
There is a distinct TypedArray constructor, listed in , for each of
the supported element types. Each constructor in has a corresponding
distinct prototype object.

+-------------+-------------+-------------+-------------+-------------+
| Constructor | Element     | Element     | Conversion  | Description |
| Name and    | Type        | Size        | Operation   |             |
| Intrinsic   |             |             |             |             |
+=============+=============+=============+=============+=============+
| Int8Array   | ~int8~      | 1           | ToInt8      | 8-bit two's |
| %Int8Array% |             |             |             | complement  |
|             |             |             |             | signed      |
|             |             |             |             | integer     |
+-------------+-------------+-------------+-------------+-------------+
| Uint8Array  | ~uint8~     | 1           | ToUint8     | 8-bit       |
| %           |             |             |             | unsigned    |
| Uint8Array% |             |             |             | integer     |
+-------------+-------------+-------------+-------------+-------------+
| Uint8C      | ~ui         | 1           | T           | 8-bit       |
| lampedArray | nt8clamped~ |             | oUint8Clamp | unsigned    |
| %Uint8Cl    |             |             |             | integer     |
| ampedArray% |             |             |             | (clamped    |
|             |             |             |             | conversion) |
+-------------+-------------+-------------+-------------+-------------+
| Int16Array  | ~int16~     | 2           | ToInt16     | 16-bit      |
| %           |             |             |             | two's       |
| Int16Array% |             |             |             | complement  |
|             |             |             |             | signed      |
|             |             |             |             | integer     |
+-------------+-------------+-------------+-------------+-------------+
| Uint16Array | ~uint16~    | 2           | ToUint16    | 16-bit      |
| %U          |             |             |             | unsigned    |
| int16Array% |             |             |             | integer     |
+-------------+-------------+-------------+-------------+-------------+
| Int32Array  | ~int32~     | 4           | ToInt32     | 32-bit      |
| %           |             |             |             | two's       |
| Int32Array% |             |             |             | complement  |
|             |             |             |             | signed      |
|             |             |             |             | integer     |
+-------------+-------------+-------------+-------------+-------------+
| Uint32Array | ~uint32~    | 4           | ToUint32    | 32-bit      |
| %U          |             |             |             | unsigned    |
| int32Array% |             |             |             | integer     |
+-------------+-------------+-------------+-------------+-------------+
| Bi          | ~bigint64~  | 8           | ToBigInt64  | 64-bit      |
| gInt64Array |             |             |             | two's       |
| %Big        |             |             |             | complement  |
| Int64Array% |             |             |             | signed      |
|             |             |             |             | integer     |
+-------------+-------------+-------------+-------------+-------------+
| Big         | ~biguint64~ | 8           | ToBigUint64 | 64-bit      |
| Uint64Array |             |             |             | unsigned    |
| %BigU       |             |             |             | integer     |
| int64Array% |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| F           | ~float32~   | 4           |             | 32-bit IEEE |
| loat32Array |             |             |             | floating    |
| %Fl         |             |             |             | point       |
| oat32Array% |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| F           | ~float64~   | 8           |             | 64-bit IEEE |
| loat64Array |             |             |             | floating    |
| %Fl         |             |             |             | point       |
| oat64Array% |             |             |             |             |
+-------------+-------------+-------------+-------------+-------------+

In the definitions below, references to TypedArray should be
replaced with the appropriate constructor name from the above table.

The %TypedArray% Intrinsic Object
---------------------------------

The %TypedArray% intrinsic object:

- is a constructor function object that all of the TypedArray
  constructor objects inherit from.
- along with its corresponding prototype object, provides common
  properties that are inherited by all TypedArray constructors and
  their instances.
- does not have a global name or appear as a property of the global
  object.
- acts as the abstract superclass of the various TypedArray
  constructors.
- will throw an error when invoked, because it is an abstract class
  constructor. The TypedArray constructors do not perform a
  `super` call to it.

%TypedArray% ( )
----------------

This function performs the following steps when called:

1. Throw a `TypeError` exception.

The `"length"` property of this function is `+0`\ :sub:`𝔽`.

Properties of the %TypedArray% Intrinsic Object
-----------------------------------------------

The %TypedArray% intrinsic object:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has a `"name"` property whose value is `"TypedArray"`.
- has the following properties:

%TypedArray%.from ( source [ , mapper [ , thisArg ] ] )
-------------------------------------------------------------------

This method performs the following steps when called:

1. Let C be the `this` value. 1. If IsConstructor(C) is
`false`, throw a `TypeError` exception. 1. If mapper is
`undefined`, then 1. Let mapping be `false`. 1. Else, 1. If
IsCallable(mapper) is `false`, throw a `TypeError` exception. 1.
Let mapping be `true`. 1. Let usingIterator be ?
GetMethod(source, %Symbol.iterator%). 1. If usingIterator is not
`undefined`, then 1. Let values be ? IteratorToList(?
GetIteratorFromMethod(source, usingIterator)). 1. Let len be
the number of elements in values. 1. Let targetObj be ?
TypedArrayCreateFromConstructor(C, « 𝔽(len) »). 1. Let k be
0. 1. Repeat, while k < len, 1. Let Pk be !
ToString(𝔽(k)). 1. Let kValue be the first element of
values. 1. Remove the first element from values. 1. If
mapping is `true`, then 1. Let mappedValue be ?
Call(mapper, thisArg, « kValue, 𝔽(k) »). 1. Else, 1. Let
mappedValue be kValue. 1. Perform ? Set(targetObj, Pk,
mappedValue, `true`). 1. Set k to k + 1. 1. Assert:
values is now an empty List. 1. Return targetObj. 1. NOTE:
source is not an iterable object, so assume it is already an
array-like object. 1. Let arrayLike be ! ToObject(source). 1.
Let len be ? LengthOfArrayLike(arrayLike). 1. Let targetObj
be ? TypedArrayCreateFromConstructor(C, « 𝔽(len) »). 1. Let
k be 0. 1. Repeat, while k < len, 1. Let Pk be !
ToString(𝔽(k)). 1. Let kValue be ? Get(arrayLike, Pk).
1. If mapping is `true`, then 1. Let mappedValue be ?
Call(mapper, thisArg, « kValue, 𝔽(k) »). 1. Else, 1. Let
mappedValue be kValue. 1. Perform ? Set(targetObj, Pk,
mappedValue, `true`). 1. Set k to k + 1. 1. Return
targetObj.

%TypedArray%.of ( ..._items )
-------------------------------

This method performs the following steps when called:

1. Let len be the number of elements in items. 1. Let C be
the `this` value. 1. If IsConstructor(C) is `false`, throw a
`TypeError` exception. 1. Let newObj be ?
TypedArrayCreateFromConstructor(C, « 𝔽(len) »). 1. Let k be
0. 1. Repeat, while k < len, 1. Let kValue be
items[k]. 1. Let Pk be ! ToString(𝔽(k)). 1. Perform ?
Set(newObj, Pk, kValue, `true`). 1. Set k to k +
1. 1. Return newObj.

%TypedArray%.prototype
----------------------

The initial value of %TypedArray%`.prototype` is the %TypedArray%
prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

get %TypedArray% [ %Symbol.species% ]
-------------------------------------

%TypedArray%`[%Symbol.species%]` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

%TypedArray.prototype% methods normally use their `this` value's
constructor to create a derived object. However, a subclass constructor
may over-ride that default behaviour by redefining its %Symbol.species%
property.

Properties of the %TypedArray% Prototype Object
-----------------------------------------------

The %TypedArray% prototype object:

- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is %TypedArray.prototype%.
- is an ordinary object.
- does not have a [[ViewedArrayBuffer]] or any other of the internal
  slots that are specific to TypedArray instance objects.

%TypedArray%.prototype.at ( index )
---------------------------------------

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let relativeIndex be ?
ToIntegerOrInfinity(index). 1. If relativeIndex ≥ 0, then 1. Let
k be relativeIndex. 1. Else, 1. Let k be len +
relativeIndex. 1. If k < 0 or k ≥ len, return
`undefined`. 1. Return ! Get(O, ! ToString(𝔽(k))).

get %TypedArray%.prototype.buffer
---------------------------------

%TypedArray%`.prototype.buffer` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[TypedArrayName]]). 1. Assert: O has a
[[ViewedArrayBuffer]] internal slot. 1. Let buffer be
O.[[ViewedArrayBuffer]]. 1. Return buffer.

get %TypedArray%.prototype.byteLength
-------------------------------------

%TypedArray%`.prototype.byteLength` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[TypedArrayName]]). 1. Assert: O has a
[[ViewedArrayBuffer]] internal slot. 1. Let taRecord be
MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~). 1. Let size
be TypedArrayByteLength(taRecord). 1. Return 𝔽(size).

get %TypedArray%.prototype.byteOffset
-------------------------------------

%TypedArray%`.prototype.byteOffset` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[TypedArrayName]]). 1. Assert: O has a
[[ViewedArrayBuffer]] internal slot. 1. Let taRecord be
MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, return
`+0`\ :sub:`𝔽`. 1. Let offset be O.[[ByteOffset]]. 1. Return
𝔽(offset).

%TypedArray%.prototype.constructor
----------------------------------

The initial value of %TypedArray%`.prototype.constructor` is
%TypedArray%.

%TypedArray%.prototype.copyWithin ( target, start [ , end ] )
-------------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.copyWithin` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let relativeTarget be ?
ToIntegerOrInfinity(target). 1. If relativeTarget = -∞, let
targetIndex be 0. 1. Else if relativeTarget < 0, let
targetIndex be max(len + relativeTarget, 0). 1. Else, let
targetIndex be min(relativeTarget, len). 1. Let
relativeStart be ? ToIntegerOrInfinity(start). 1. If
relativeStart = -∞, let startIndex be 0. 1. Else if
relativeStart < 0, let startIndex be max(len +
relativeStart, 0). 1. Else, let startIndex be
min(relativeStart, len). 1. If end is `undefined`, let
relativeEnd be len; else let relativeEnd be ?
ToIntegerOrInfinity(end). 1. If relativeEnd = -∞, let
endIndex be 0. 1. Else if relativeEnd < 0, let endIndex be
max(len + relativeEnd, 0). 1. Else, let endIndex be
min(relativeEnd, len). 1. Let count be min(endIndex -
startIndex, len - targetIndex). 1. If count > 0, then 1.
NOTE: The copying must be performed in a manner that preserves the
bit-level encoding of the source data. 1. Let buffer be
O.[[ViewedArrayBuffer]]. 1. Set taRecord to
MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, throw a `TypeError`
exception. 1. Set len to TypedArrayLength(taRecord). 1. Let
elementSize be TypedArrayElementSize(O). 1. Let byteOffset
be O.[[ByteOffset]]. 1. Let bufferByteLimit be (len ×
elementSize) + byteOffset. 1. Let toByteIndex be
(targetIndex × elementSize) + byteOffset. 1. Let
fromByteIndex be (startIndex × elementSize) +
byteOffset. 1. Let countBytes be count × elementSize. 1.
If fromByteIndex < toByteIndex and toByteIndex <
fromByteIndex + countBytes, then 1. Let direction be -1. 1.
Set fromByteIndex to fromByteIndex + countBytes - 1. 1. Set
toByteIndex to toByteIndex + countBytes - 1. 1. Else, 1. Let
direction be 1. 1. Repeat, while countBytes > 0, 1. If
fromByteIndex < bufferByteLimit and toByteIndex <
bufferByteLimit, then 1. Let value be
GetValueFromBuffer(buffer, fromByteIndex, ~uint8~, `true`,
~unordered~). 1. Perform SetValueInBuffer(buffer, toByteIndex,
~uint8~, value, `true`, ~unordered~). 1. Set fromByteIndex to
fromByteIndex + direction. 1. Set toByteIndex to
toByteIndex + direction. 1. Set countBytes to countBytes
- 1. 1. Else, 1. Set countBytes to 0. 1. Return O.

%TypedArray%.prototype.entries ( )
----------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
ValidateTypedArray(O, ~seq-cst~). 1. Return
CreateArrayIterator(O, ~key+value~).

%TypedArray%.prototype.every ( callback [ , thisArg ] )
---------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.every` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If IsCallable(callback) is
`false`, throw a `TypeError` exception. 1. Let k be 0. 1.
Repeat, while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1.
Let kValue be ! Get(O, Pk). 1. Let testResult be
ToBoolean(? Call(callback, thisArg, « kValue, 𝔽(k),
O »)). 1. If testResult is `false`, return `false`. 1. Set
k to k + 1. 1. Return `true`.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.fill ( value [ , start [ , end ] ] )
-----------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.fill` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If O.[[ContentType]] is ~bigint~,
set value to ? ToBigInt(value). 1. Otherwise, set value to ?
ToNumber(value). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let
startIndex be 0. 1. Else if relativeStart < 0, let
startIndex be max(len + relativeStart, 0). 1. Else, let
startIndex be min(relativeStart, len). 1. If end is
`undefined`, let relativeEnd be len; else let relativeEnd
be ? ToIntegerOrInfinity(end). 1. If relativeEnd = -∞, let
endIndex be 0. 1. Else if relativeEnd < 0, let endIndex be
max(len + relativeEnd, 0). 1. Else, let endIndex be
min(relativeEnd, len). 1. Set taRecord to
MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, throw a `TypeError`
exception. 1. Set len to TypedArrayLength(taRecord). 1. Set
endIndex to min(endIndex, len). 1. Let k be
startIndex. 1. Repeat, while k < endIndex, 1. Let Pk be
! ToString(𝔽(k)). 1. Perform ! Set(O, Pk, value,
`true`). 1. Set k to k + 1. 1. Return O.

%TypedArray%.prototype.filter ( callback [ , thisArg ] )
----------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.filter` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If IsCallable(callback) is
`false`, throw a `TypeError` exception. 1. Let kept be a new
empty List. 1. Let captured be 0. 1. Let k be 0. 1. Repeat,
while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kValue be ! Get(O, Pk). 1. Let selected be ToBoolean(?
Call(callback, thisArg, « kValue, 𝔽(k), O »)). 1. If
selected is `true`, then 1. Append kValue to kept. 1. Set
captured to captured + 1. 1. Set k to k + 1. 1. Let
A be ? TypedArraySpeciesCreate(O, « 𝔽(captured) »). 1. Let
n be 0. 1. For each element e of kept, do 1. Perform !
Set(A, ! ToString(𝔽(n)), e, `true`). 1. Set n to n
+ 1. 1. Return A.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.find ( predicate [ , thisArg ] )
---------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.find` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let findRec be ?
FindViaPredicate(O, len, ~ascending~, predicate,
thisArg). 1. Return findRec.[[Value]].

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )
--------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.findIndex` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let findRec be ?
FindViaPredicate(O, len, ~ascending~, predicate,
thisArg). 1. Return findRec.[[Index]].

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.findLast ( predicate [ , thisArg ] )
-------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.findLast` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let findRec be ?
FindViaPredicate(O, len, ~descending~, predicate,
thisArg). 1. Return findRec.[[Value]].

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.findLastIndex ( predicate [ , thisArg ] )
------------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.findLastIndex` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let findRec be ?
FindViaPredicate(O, len, ~descending~, predicate,
thisArg). 1. Return findRec.[[Index]].

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.forEach ( callback [ , thisArg ] )
-----------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.forEach` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If IsCallable(callback) is
`false`, throw a `TypeError` exception. 1. Let k be 0. 1.
Repeat, while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1.
Let kValue be ! Get(O, Pk). 1. Perform ? Call(callback,
thisArg, « kValue, 𝔽(k), O »). 1. Set k to k +
1. 1. Return `undefined`.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.includes ( searchElement [ , fromIndex ] )
-------------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.includes` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If len = 0, return `false`. 1.
Let n be ? ToIntegerOrInfinity(fromIndex). 1. Assert: If
fromIndex is `undefined`, then n is 0. 1. If n = +∞,
return `false`. 1. Else if n = -∞, set n to 0. 1. If n ≥
0, then 1. Let k be n. 1. Else, 1. Let k be len + n.
1. If k < 0, set k to 0. 1. Repeat, while k < len, 1.
Let elementK be ! Get(O, ! ToString(𝔽(k))). 1. If
SameValueZero(searchElement, elementK) is `true`, return
`true`. 1. Set k to k + 1. 1. Return `false`.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.indexOf ( searchElement [ , fromIndex ] )
------------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.indexOf` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If len = 0, return
`-1`\ :sub:`𝔽`. 1. Let n be ? ToIntegerOrInfinity(fromIndex).
1. Assert: If fromIndex is `undefined`, then n is 0. 1. If
n = +∞, return `-1`\ :sub:`𝔽`. 1. Else if n = -∞, set n to
0. 1. If n ≥ 0, then 1. Let k be n. 1. Else, 1. Let k be
len + n. 1. If k < 0, set k to 0. 1. Repeat, while k
< len, 1. Let kPresent be ! HasProperty(O, !
ToString(𝔽(k))). 1. If kPresent is `true`, then 1. Let
elementK be ! Get(O, ! ToString(𝔽(k))). 1. If
IsStrictlyEqual(searchElement, elementK) is `true`, return
𝔽(k). 1. Set k to k + 1. 1. Return `-1`\ :sub:`𝔽`.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.join ( separator )
---------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.join` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If separator is `undefined`,
let sep be `","`. 1. Else, let sep be ?
ToString(separator). 1. Let R be the empty String. 1. Let k
be 0. 1. Repeat, while k < len, 1. If k > 0, set R to
the string-concatenation of R and sep. 1. Let element be !
Get(O, ! ToString(𝔽(k))). 1. If element is not
`undefined`, then 1. Let S be ! ToString(element). 1. Set
R to the string-concatenation of R and S. 1. Set k to
k + 1. 1. Return R.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.keys ( )
-------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
ValidateTypedArray(O, ~seq-cst~). 1. Return
CreateArrayIterator(O, ~key~).

%TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
----------------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.lastIndexOf` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If len = 0, return
`-1`\ :sub:`𝔽`. 1. If fromIndex is present, let n be ?
ToIntegerOrInfinity(fromIndex); else let n be len - 1. 1. If
n = -∞, return `-1`\ :sub:`𝔽`. 1. If n ≥ 0, then 1. Let k
be min(n, len - 1). 1. Else, 1. Let k be len + n. 1.
Repeat, while k ≥ 0, 1. Let kPresent be ! HasProperty(O, !
ToString(𝔽(k))). 1. If kPresent is `true`, then 1. Let
elementK be ! Get(O, ! ToString(𝔽(k))). 1. If
IsStrictlyEqual(searchElement, elementK) is `true`, return
𝔽(k). 1. Set k to k - 1. 1. Return `-1`\ :sub:`𝔽`.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

get %TypedArray%.prototype.length
---------------------------------

%TypedArray%`.prototype.length` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[TypedArrayName]]). 1. Assert: O has
[[ViewedArrayBuffer]] and [[ArrayLength]] internal slots. 1. Let
taRecord be MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~).
1. If IsTypedArrayOutOfBounds(taRecord) is `true`, return
`+0`\ :sub:`𝔽`. 1. Let length be TypedArrayLength(taRecord).
1. Return 𝔽(length).

This function is not generic. The `this` value must be an object with
a [[TypedArrayName]] internal slot.

%TypedArray%.prototype.map ( callback [ , thisArg ] )
-------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.map` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If IsCallable(callback) is
`false`, throw a `TypeError` exception. 1. Let A be ?
TypedArraySpeciesCreate(O, « 𝔽(len) »). 1. Let k be 0. 1.
Repeat, while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1.
Let kValue be ! Get(O, Pk). 1. Let mappedValue be ?
Call(callback, thisArg, « kValue, 𝔽(k), O »). 1.
Perform ? Set(A, Pk, mappedValue, `true`). 1. Set k to
k + 1. 1. Return A.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.reduce ( callback [ , initialValue ] )
---------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.reduce` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If IsCallable(callback) is
`false`, throw a `TypeError` exception. 1. If len = 0 and
initialValue is not present, throw a `TypeError` exception. 1. Let
k be 0. 1. Let accumulator be `undefined`. 1. If
initialValue is present, then 1. Set accumulator to
initialValue. 1. Else, 1. Let Pk be ! ToString(𝔽(k)). 1. Set
accumulator to ! Get(O, Pk). 1. Set k to k + 1. 1.
Repeat, while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1.
Let kValue be ! Get(O, Pk). 1. Set accumulator to ?
Call(callback, `undefined`, « accumulator, kValue,
𝔽(k), O »). 1. Set k to k + 1. 1. Return
accumulator.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.reduceRight ( callback [ , initialValue ] )
--------------------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.reduceRight` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If IsCallable(callback) is
`false`, throw a `TypeError` exception. 1. If len = 0 and
initialValue is not present, throw a `TypeError` exception. 1. Let
k be len - 1. 1. Let accumulator be `undefined`. 1. If
initialValue is present, then 1. Set accumulator to
initialValue. 1. Else, 1. Let Pk be ! ToString(𝔽(k)). 1. Set
accumulator to ! Get(O, Pk). 1. Set k to k - 1. 1.
Repeat, while k ≥ 0, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kValue be ! Get(O, Pk). 1. Set accumulator to ?
Call(callback, `undefined`, « accumulator, kValue,
𝔽(k), O »). 1. Set k to k - 1. 1. Return
accumulator.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.reverse ( )
----------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.reverse` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let middle be floor(len / 2).
1. Let lower be 0. 1. Repeat, while lower ≠ middle, 1. Let
upper be len - lower - 1. 1. Let upperP be !
ToString(𝔽(upper)). 1. Let lowerP be ! ToString(𝔽(lower)).
1. Let lowerValue be ! Get(O, lowerP). 1. Let upperValue
be ! Get(O, upperP). 1. Perform ! Set(O, lowerP,
upperValue, `true`). 1. Perform ! Set(O, upperP,
lowerValue, `true`). 1. Set lower to lower + 1. 1. Return
O.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.set ( source [ , offset ] )
----------------------------------------------------------

This method sets multiple values in this TypedArray, reading the
values from source. The details differ based upon the type of
source. The optional offset value indicates the first element
index in this TypedArray where values are written. If omitted, it is
assumed to be 0.

It performs the following steps when called:

1. Let target be the `this` value. 1. Perform ?
RequireInternalSlot(target, [[TypedArrayName]]). 1. Assert:
target has a [[ViewedArrayBuffer]] internal slot. 1. Let
targetOffset be ? ToIntegerOrInfinity(offset). 1. If
targetOffset < 0, throw a `RangeError` exception. 1. If source
is an Object that has a [[TypedArrayName]] internal slot, then 1.
Perform ? SetTypedArrayFromTypedArray(target, targetOffset,
source). 1. Else, 1. Perform ?
SetTypedArrayFromArrayLike(target, targetOffset, source). 1.
Return `undefined`.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

SetTypedArrayFromTypedArray ( target: a TypedArray, targetOffset: a non-negative integer or +∞, source: a TypedArray, )
-----------------------------------------------------------------------------------------------------------------------

description
   It sets multiple values in target, starting at index
   targetOffset, reading the values from source.

1. Let targetBuffer be target.[[ViewedArrayBuffer]]. 1. Let
targetRecord be MakeTypedArrayWithBufferWitnessRecord(target,
~seq-cst~). 1. If IsTypedArrayOutOfBounds(targetRecord) is `true`,
throw a `TypeError` exception. 1. Let targetLength be
TypedArrayLength(targetRecord). 1. Let srcBuffer be
source.[[ViewedArrayBuffer]]. 1. Let srcRecord be
MakeTypedArrayWithBufferWitnessRecord(source, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(srcRecord) is `true`, throw a
`TypeError` exception. 1. Let srcLength be
TypedArrayLength(srcRecord). 1. Let targetType be
TypedArrayElementType(target). 1. Let targetElementSize be
TypedArrayElementSize(target). 1. Let targetByteOffset be
target.[[ByteOffset]]. 1. Let srcType be
TypedArrayElementType(source). 1. Let srcElementSize be
TypedArrayElementSize(source). 1. Let srcByteOffset be
source.[[ByteOffset]]. 1. If targetOffset = +∞, throw a
`RangeError` exception. 1. If srcLength + targetOffset >
targetLength, throw a `RangeError` exception. 1. If
target.[[ContentType]] is not source.[[ContentType]], throw a
`TypeError` exception. 1. If IsSharedArrayBuffer(srcBuffer) is
`true`, IsSharedArrayBuffer(targetBuffer) is `true`, and
srcBuffer.[[ArrayBufferData]] is
targetBuffer.[[ArrayBufferData]], let sameSharedArrayBuffer be
`true`; otherwise, let sameSharedArrayBuffer be `false`. 1. If
SameValue(srcBuffer, targetBuffer) is `true` or
sameSharedArrayBuffer is `true`, then 1. Let srcByteLength be
TypedArrayByteLength(srcRecord). 1. Set srcBuffer to ?
CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength).
1. Let srcByteIndex be 0. 1. Else, 1. Let srcByteIndex be
srcByteOffset. 1. Let targetByteIndex be (targetOffset ×
targetElementSize) + targetByteOffset. 1. Let limit be
targetByteIndex + (targetElementSize × srcLength). 1. If
srcType is targetType, then 1. NOTE: The transfer must be
performed in a manner that preserves the bit-level encoding of the
source data. 1. Repeat, while targetByteIndex < limit, 1. Let
value be GetValueFromBuffer(srcBuffer, srcByteIndex,
~uint8~, `true`, ~unordered~). 1. Perform
SetValueInBuffer(targetBuffer, targetByteIndex, ~uint8~,
value, `true`, ~unordered~). 1. Set srcByteIndex to
srcByteIndex + 1. 1. Set targetByteIndex to targetByteIndex
+ 1. 1. Else, 1. Repeat, while targetByteIndex < limit, 1. Let
value be GetValueFromBuffer(srcBuffer, srcByteIndex,
srcType, `true`, ~unordered~). 1. Perform
SetValueInBuffer(targetBuffer, targetByteIndex, targetType,
value, `true`, ~unordered~). 1. Set srcByteIndex to
srcByteIndex + srcElementSize. 1. Set targetByteIndex to
targetByteIndex + targetElementSize. 1. Return ~unused~.

SetTypedArrayFromArrayLike ( target: a TypedArray, targetOffset: a non-negative integer or +∞, source, but not a TypedArray, )
------------------------------------------------------------------------------------------------------------------------------

description
   It sets multiple values in target, starting at index
   targetOffset, reading the values from source.

1. Let targetRecord be
MakeTypedArrayWithBufferWitnessRecord(target, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(targetRecord) is `true`, throw a
`TypeError` exception. 1. Let targetLength be
TypedArrayLength(targetRecord). 1. Let src be ?
ToObject(source). 1. Let srcLength be ?
LengthOfArrayLike(src). 1. If targetOffset = +∞, throw a
`RangeError` exception. 1. If srcLength + targetOffset >
targetLength, throw a `RangeError` exception. 1. Let k be 0.
1. Repeat, while k < srcLength, 1. Let Pk be !
ToString(𝔽(k)). 1. Let value be ? Get(src, Pk). 1. Let
targetIndex be 𝔽(targetOffset + k). 1. Perform ?
TypedArraySetElement(target, targetIndex, value). 1. Set
k to k + 1. 1. Return ~unused~.

%TypedArray%.prototype.slice ( start, end )
---------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.slice` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let srcArrayLength be
TypedArrayLength(taRecord). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let
startIndex be 0. 1. Else if relativeStart < 0, let
startIndex be max(srcArrayLength + relativeStart, 0). 1.
Else, let startIndex be min(relativeStart, srcArrayLength).
1. If end is `undefined`, let relativeEnd be
srcArrayLength; else let relativeEnd be ?
ToIntegerOrInfinity(end). 1. If relativeEnd = -∞, let
endIndex be 0. 1. Else if relativeEnd < 0, let endIndex be
max(srcArrayLength + relativeEnd, 0). 1. Else, let endIndex
be min(relativeEnd, srcArrayLength). 1. Let countBytes be
max(endIndex - startIndex, 0). 1. Let A be ?
TypedArraySpeciesCreate(O, « 𝔽(countBytes) »). 1. If
countBytes > 0, then 1. Set taRecord to
MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, throw a `TypeError`
exception. 1. Set endIndex to min(endIndex,
TypedArrayLength(taRecord)). 1. Set countBytes to
max(endIndex - startIndex, 0). 1. Let srcType be
TypedArrayElementType(O). 1. Let targetType be
TypedArrayElementType(A). 1. If srcType is targetType, then
1. NOTE: The transfer must be performed in a manner that preserves the
bit-level encoding of the source data. 1. Let srcBuffer be
O.[[ViewedArrayBuffer]]. 1. Let targetBuffer be
A.[[ViewedArrayBuffer]]. 1. Let elementSize be
TypedArrayElementSize(O). 1. Let srcByteOffset be
O.[[ByteOffset]]. 1. Let srcByteIndex be (startIndex ×
elementSize) + srcByteOffset. 1. Let targetByteIndex be
A.[[ByteOffset]]. 1. Let endByteIndex be targetByteIndex +
(countBytes × elementSize). 1. Repeat, while targetByteIndex
< endByteIndex, 1. Let value be
GetValueFromBuffer(srcBuffer, srcByteIndex, ~uint8~, `true`,
~unordered~). 1. Perform SetValueInBuffer(targetBuffer,
targetByteIndex, ~uint8~, value, `true`, ~unordered~). 1. Set
srcByteIndex to srcByteIndex + 1. 1. Set targetByteIndex to
targetByteIndex + 1. 1. Else, 1. Let n be 0. 1. Let k be
startIndex. 1. Repeat, while k < endIndex, 1. Let Pk be
! ToString(𝔽(k)). 1. Let kValue be ! Get(O, Pk). 1.
Perform ! Set(A, ! ToString(𝔽(n)), kValue, `true`). 1. Set
k to k + 1. 1. Set n to n + 1. 1. Return A.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.some ( callback [ , thisArg ] )
--------------------------------------------------------------

The interpretation and use of the arguments of this method are the same
as for `Array.prototype.some` as defined in .

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. If IsCallable(callback) is
`false`, throw a `TypeError` exception. 1. Let k be 0. 1.
Repeat, while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1.
Let kValue be ! Get(O, Pk). 1. Let testResult be
ToBoolean(? Call(callback, thisArg, « kValue, 𝔽(k),
O »)). 1. If testResult is `true`, return `true`. 1. Set
k to k + 1. 1. Return `false`.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.sort ( comparator )
----------------------------------------------

This is a distinct method that, except as described below, implements
the same requirements as those of `Array.prototype.sort` as defined in
. The implementation of this method may be optimized with the knowledge
that the `this` value is an object that has a fixed length and whose
integer-indexed properties are not sparse.

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

It performs the following steps when called:

1. If comparator is not `undefined` and IsCallable(comparator)
is `false`, throw a `TypeError` exception. 1. Let obj be the
`this` value. 1. Let taRecord be ? ValidateTypedArray(obj,
~seq-cst~). 1. Let len be TypedArrayLength(taRecord). 1. NOTE:
The following closure performs a numeric comparison rather than the
string comparison used in . 1. Let SortCompare be a new Abstract
Closure with parameters (x, y) that captures comparator and
performs the following steps when called: 1. Return ?
CompareTypedArrayElements(x, y, comparator). 1. Let
sortedList be ? SortIndexedProperties(obj, len,
SortCompare, ~read-through-holes~). 1. Let j be 0. 1. Repeat,
while j < len, 1. Perform ! Set(obj, ! ToString(𝔽(j)),
sortedList[j], `true`). 1. Set j to j + 1. 1. Return
obj.

Because `NaN` always compares greater than any other value (see
CompareTypedArrayElements), `NaN` property values always sort to the
end of the result when comparator is not provided.

%TypedArray%.prototype.subarray ( start, end )
------------------------------------------------------

This method returns a new TypedArray whose element type is the
element type of this TypedArray and whose ArrayBuffer is the
ArrayBuffer of this TypedArray, referencing the elements in the
interval from start (inclusive) to end (exclusive). If either
start or end is negative, it refers to an index from the end of
the array, as opposed to from the beginning.

It performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[TypedArrayName]]). 1. Assert: O has a
[[ViewedArrayBuffer]] internal slot. 1. Let buffer be
O.[[ViewedArrayBuffer]]. 1. Let srcRecord be
MakeTypedArrayWithBufferWitnessRecord(O, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(srcRecord) is `true`, then 1. Let
srcLength be 0. 1. Else, 1. Let srcLength be
TypedArrayLength(srcRecord). 1. Let relativeStart be ?
ToIntegerOrInfinity(start). 1. If relativeStart = -∞, let
startIndex be 0. 1. Else if relativeStart < 0, let
startIndex be max(srcLength + relativeStart, 0). 1. Else,
let startIndex be min(relativeStart, srcLength). 1. Let
elementSize be TypedArrayElementSize(O). 1. Let
srcByteOffset be O.[[ByteOffset]]. 1. Let beginByteOffset be
srcByteOffset + (startIndex × elementSize). 1. If
O.[[ArrayLength]] is ~auto~ and end is `undefined`, then 1.
Let argumentsList be « buffer, 𝔽(beginByteOffset) ». 1.
Else, 1. If end is `undefined`, let relativeEnd be
srcLength; else let relativeEnd be ?
ToIntegerOrInfinity(end). 1. If relativeEnd = -∞, let
endIndex be 0. 1. Else if relativeEnd < 0, let endIndex be
max(srcLength + relativeEnd, 0). 1. Else, let endIndex be
min(relativeEnd, srcLength). 1. Let newLength be
max(endIndex - startIndex, 0). 1. Let argumentsList be «
buffer, 𝔽(beginByteOffset), 𝔽(newLength) ». 1. Return ?
TypedArraySpeciesCreate(O, argumentsList).

This method is not generic. The `this` value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
-------------------------------------------------------------------------------

This is a distinct method that implements the same algorithm as
`Array.prototype.toLocaleString` as defined in except that
TypedArrayLength is called in place of performing a [[Get]] of
`"length"`. The implementation of the algorithm may be optimized with
the knowledge that the `this` value has a fixed length when the
underlying buffer is not resizable and whose integer-indexed properties
are not sparse. However, such optimization must not introduce any
observable changes in the specified behaviour of the algorithm.

This method is not generic. ValidateTypedArray is called with the
`this` value and ~seq-cst~ as arguments prior to evaluating the
algorithm. If its result is an abrupt completion that exception is
thrown instead of evaluating the algorithm.

If the ECMAScript implementation includes the ECMA-402
Internationalization API this method is based upon the algorithm for
`Array.prototype.toLocaleString` that is in the ECMA-402
specification.

%TypedArray%.prototype.toReversed ( )
-------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let length be
TypedArrayLength(taRecord). 1. Let A be ?
TypedArrayCreateSameType(O, « 𝔽(length) »). 1. Let k be 0.
1. Repeat, while k < length, 1. Let from be !
ToString(𝔽(length - k - 1)). 1. Let Pk be !
ToString(𝔽(k)). 1. Let fromValue be ! Get(O, from). 1.
Perform ! Set(A, Pk, fromValue, `true`). 1. Set k to
k + 1. 1. Return A.

%TypedArray%.prototype.toSorted ( comparator )
--------------------------------------------------

This method performs the following steps when called:

1. If comparator is not `undefined` and IsCallable(comparator)
is `false`, throw a `TypeError` exception. 1. Let O be the
`this` value. 1. Let taRecord be ? ValidateTypedArray(O,
~seq-cst~). 1. Let len be TypedArrayLength(taRecord). 1. Let
A be ? TypedArrayCreateSameType(O, « 𝔽(len) »). 1. NOTE: The
following closure performs a numeric comparison rather than the string
comparison used in . 1. Let SortCompare be a new Abstract Closure
with parameters (x, y) that captures comparator and performs
the following steps when called: 1. Return ?
CompareTypedArrayElements(x, y, comparator). 1. Let
sortedList be ? SortIndexedProperties(O, len,
SortCompare, ~read-through-holes~). 1. Let j be 0. 1. Repeat,
while j < len, 1. Perform ! Set(A, ! ToString(𝔽(j)),
sortedList[j], `true`). 1. Set j to j + 1. 1. Return
A.

%TypedArray%.prototype.toString ( )
-----------------------------------

The initial value of the `"toString"` property is
%Array.prototype.toString%, defined in .

%TypedArray%.prototype.values ( )
---------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
ValidateTypedArray(O, ~seq-cst~). 1. Return
CreateArrayIterator(O, ~value~).

%TypedArray%.prototype.with ( index, value )
----------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Let taRecord be ?
ValidateTypedArray(O, ~seq-cst~). 1. Let len be
TypedArrayLength(taRecord). 1. Let relativeIndex be ?
ToIntegerOrInfinity(index). 1. If relativeIndex ≥ 0, let
actualIndex be relativeIndex. 1. Else, let actualIndex be
len + relativeIndex. 1. If O.[[ContentType]] is ~bigint~,
let numericValue be ? ToBigInt(value). 1. Else, let
numericValue be ? ToNumber(value). 1. If
IsValidIntegerIndex(O, 𝔽(actualIndex)) is `false`, throw a
`RangeError` exception. 1. Let A be ?
TypedArrayCreateSameType(O, « 𝔽(len) »). 1. Let k be 0. 1.
Repeat, while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1.
If k = actualIndex, let fromValue be numericValue. 1.
Else, let fromValue be ! Get(O, Pk). 1. Perform ! Set(A,
Pk, fromValue, `true`). 1. Set k to k + 1. 1. Return
A.

%TypedArray%.prototype [ %Symbol.iterator% ] ( )
------------------------------------------------

The initial value of the %Symbol.iterator% property is
%TypedArray.prototype.values%, defined in .

get %TypedArray%.prototype [ %Symbol.toStringTag% ]
---------------------------------------------------

%TypedArray%`.prototype[%Symbol.toStringTag%]` is an accessor property
whose set accessor function is `undefined`. Its get accessor function
performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, return
`undefined`. 1. If O does not have a [[TypedArrayName]] internal
slot, return `undefined`. 1. Let name be O.[[TypedArrayName]].
1. Assert: name is a String. 1. Return name.

This property has the attributes { [[Enumerable]]: `false`,
[[Configurable]]: `true` }.

The initial value of the `"name"` property of this function is `"get
[Symbol.toStringTag]"`.

Abstract Operations for TypedArray Objects
------------------------------------------

TypedArraySpeciesCreate ( exemplar: a TypedArray, argumentList: a List of ECMAScript language values, )
-------------------------------------------------------------------------------------------------------

description
   It is used to specify the creation of a new TypedArray using a
   constructor function that is derived from exemplar. Unlike
   ArraySpeciesCreate, which can create non-Array objects through the
   use of %Symbol.species%, this operation enforces that the constructor
   function creates an actual TypedArray.

1. Let defaultConstructor be the intrinsic object associated with
the constructor name exemplar.[[TypedArrayName]] in . 1. Let
constructor be ? SpeciesConstructor(exemplar,
defaultConstructor). 1. Let result be ?
TypedArrayCreateFromConstructor(constructor, argumentList). 1.
Assert: result has [[TypedArrayName]] and [[ContentType]] internal
slots. 1. If result.[[ContentType]] is not
exemplar.[[ContentType]], throw a `TypeError` exception. 1. Return
result.

TypedArrayCreateFromConstructor ( constructor: a constructor, argumentList: a List of ECMAScript language values, )
-------------------------------------------------------------------------------------------------------------------

description
   It is used to specify the creation of a new TypedArray using a
   constructor function.

1. Let newTypedArray be ? Construct(constructor,
argumentList). 1. Let taRecord be ?
ValidateTypedArray(newTypedArray, ~seq-cst~). 1. If the number of
elements in argumentList is 1 and argumentList[0] is a Number,
then 1. If IsTypedArrayOutOfBounds(taRecord) is `true`, throw a
`TypeError` exception. 1. Let length be
TypedArrayLength(taRecord). 1. If length <
ℝ(argumentList[0]), throw a `TypeError` exception. 1. Return
newTypedArray.

TypedArrayCreateSameType ( exemplar: a TypedArray, argumentList: a List of ECMAScript language values, )
--------------------------------------------------------------------------------------------------------

description
   It is used to specify the creation of a new TypedArray using a
   constructor function that is derived from exemplar. Unlike
   TypedArraySpeciesCreate, which can construct custom TypedArray
   subclasses through the use of %Symbol.species%, this operation always
   uses one of the built-in TypedArray constructors.

1. Let constructor be the intrinsic object associated with the
constructor name exemplar.[[TypedArrayName]] in . 1. Let result
be ? TypedArrayCreateFromConstructor(constructor, argumentList).
1. Assert: result has [[TypedArrayName]] and [[ContentType]]
internal slots. 1. Assert: result.[[ContentType]] is
exemplar.[[ContentType]]. 1. Return result.

ValidateTypedArray ( O, order: ~seq-cst~ or ~unordered~, )
----------------------------------------------------------

1. Perform ? RequireInternalSlot(O, [[TypedArrayName]]). 1. Assert:
O has a [[ViewedArrayBuffer]] internal slot. 1. Let taRecord be
MakeTypedArrayWithBufferWitnessRecord(O, order). 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, throw a `TypeError`
exception. 1. Return taRecord.

TypedArrayElementSize ( O: a TypedArray, ): a non-negative integer
----------------------------------------------------------------------

1. Return the Element Size value specified in for
O.[[TypedArrayName]].

TypedArrayElementType ( O: a TypedArray, ): a TypedArray element type
-------------------------------------------------------------------------

1. Return the Element Type value specified in for
O.[[TypedArrayName]].

CompareTypedArrayElements ( x: a Number or a BigInt, y: a Number or a BigInt, comparator: a function object or `undefined`, )
-----------------------------------------------------------------------------------------------------------------------------

1. Assert: x is a Number and y is a Number, or x is a BigInt
and y is a BigInt. 1. If comparator is not `undefined`, then
1. Let v be ? ToNumber(? Call(comparator, `undefined`, «
x, y »)). 1. If v is `NaN`, return `+0`\ :sub:`𝔽`. 1.
Return v. 1. If x and y are both `NaN`, return
`+0`\ :sub:`𝔽`. 1. If x is `NaN`, return `1`\ :sub:`𝔽`. 1. If
y is `NaN`, return `-1`\ :sub:`𝔽`. 1. If x < y, return
`-1`\ :sub:`𝔽`. 1. If x > y, return `1`\ :sub:`𝔽`. 1. If
x is `-0`\ :sub:`𝔽` and y is `+0`\ :sub:`𝔽`, return
`-1`\ :sub:`𝔽`. 1. If x is `+0`\ :sub:`𝔽` and y is
`-0`\ :sub:`𝔽`, return `1`\ :sub:`𝔽`. 1. Return `+0`\ :sub:`𝔽`.
This performs a numeric comparison rather than the string comparison
used in .

The TypedArray Constructors
-------------------------------

Each TypedArray constructor:

- is an intrinsic object that has the structure described below,
  differing only in the name used as the constructor name instead of
  TypedArray, in .
- is a function whose behaviour differs based upon the number and types
  of its arguments. The actual behaviour of a call of TypedArray
  depends upon the number and kind of arguments that are passed to it.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  TypedArray behaviour must include a `super` call to the
  TypedArray constructor to create and initialize the subclass
  instance with the internal state necessary to support the
  %TypedArray%`.prototype` built-in methods.

TypedArray ( ..._args )
-----------------------------

Each TypedArray constructor performs the following steps when
called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Let constructorName be the String value of the Constructor Name
value specified in for this ``TypedArray`` constructor. 1. Let proto
be ``"%``\ ``TypedArray``\ ``.prototype%"``. 1. Let numberOfArgs be
the number of elements in args. 1. If numberOfArgs = 0, then 1.
Return ? AllocateTypedArray(constructorName, NewTarget, proto,
0). 1. Else, 1. Let firstArgument be args[0]. 1. If
firstArgument is an Object, then 1. Let O be ?
AllocateTypedArray(constructorName, NewTarget, proto). 1. If
firstArgument has a [[TypedArrayName]] internal slot, then 1.
Perform ? InitializeTypedArrayFromTypedArray(O, firstArgument).
1. Else if firstArgument has an [[ArrayBufferData]] internal slot,
then 1. If numberOfArgs > 1, let byteOffset be args[1]; else
let byteOffset be `undefined`. 1. If numberOfArgs > 2, let
length be args[2]; else let length be `undefined`. 1.
Perform ? InitializeTypedArrayFromArrayBuffer(O, firstArgument,
byteOffset, length). 1. Else, 1. Assert: firstArgument is an
Object and firstArgument does not have either a [[TypedArrayName]]
or an [[ArrayBufferData]] internal slot. 1. Let usingIterator be ?
GetMethod(firstArgument, %Symbol.iterator%). 1. If usingIterator
is not `undefined`, then 1. Let values be ? IteratorToList(?
GetIteratorFromMethod(firstArgument, usingIterator)). 1. Perform
? InitializeTypedArrayFromList(O, values). 1. Else, 1. NOTE:
firstArgument is not an iterable object, so assume it is already an
array-like object. 1. Perform ? InitializeTypedArrayFromArrayLike(O,
firstArgument). 1. Return O. 1. Else, 1. Assert:
firstArgument is not an Object. 1. Let elementLength be ?
ToIndex(firstArgument). 1. Return ?
AllocateTypedArray(constructorName, NewTarget, proto,
elementLength).

AllocateTypedArray ( constructorName: a String which is the name of a TypedArray constructor in , newTarget: a constructor, defaultProto: a String, optional length: a non-negative integer, )
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It is used to validate and create an instance of a TypedArray
   constructor. If the length argument is passed, an ArrayBuffer of
   that length is also allocated and associated with the new TypedArray
   instance. AllocateTypedArray provides common semantics that is used
   by TypedArray.

1. Let proto be ? GetPrototypeFromConstructor(newTarget,
defaultProto). 1. Let obj be TypedArrayCreate(proto). 1.
Assert: obj.[[ViewedArrayBuffer]] is `undefined`. 1. Set
obj.[[TypedArrayName]] to constructorName. 1. If
constructorName is either `"BigInt64Array"` or
`"BigUint64Array"`, set obj.[[ContentType]] to ~bigint~. 1.
Otherwise, set obj.[[ContentType]] to ~number~. 1. If length is
not present, then 1. Set obj.[[ByteLength]] to 0. 1. Set
obj.[[ByteOffset]] to 0. 1. Set obj.[[ArrayLength]] to 0. 1.
Else, 1. Perform ? AllocateTypedArrayBuffer(obj, length). 1.
Return obj.

InitializeTypedArrayFromTypedArray ( O: a TypedArray, srcArray: a TypedArray, )
-------------------------------------------------------------------------------

1. Let srcData be srcArray.[[ViewedArrayBuffer]]. 1. Let
elementType be TypedArrayElementType(O). 1. Let elementSize
be TypedArrayElementSize(O). 1. Let srcType be
TypedArrayElementType(srcArray). 1. Let srcElementSize be
TypedArrayElementSize(srcArray). 1. Let srcByteOffset be
srcArray.[[ByteOffset]]. 1. Let srcRecord be
MakeTypedArrayWithBufferWitnessRecord(srcArray, ~seq-cst~). 1. If
IsTypedArrayOutOfBounds(srcRecord) is `true`, throw a
`TypeError` exception. 1. Let elementLength be
TypedArrayLength(srcRecord). 1. Let byteLength be
elementSize × elementLength. 1. If elementType is
srcType, then 1. Let data be ? CloneArrayBuffer(srcData,
srcByteOffset, byteLength). 1. Else, 1. Let data be ?
AllocateArrayBuffer(%ArrayBuffer%, byteLength). 1. If
srcArray.[[ContentType]] is not O.[[ContentType]], throw a
`TypeError` exception. 1. Let srcByteIndex be srcByteOffset.
1. Let targetByteIndex be 0. 1. Let count be elementLength.
1. Repeat, while count > 0, 1. Let value be
GetValueFromBuffer(srcData, srcByteIndex, srcType, `true`,
~unordered~). 1. Perform SetValueInBuffer(data, targetByteIndex,
elementType, value, `true`, ~unordered~). 1. Set
srcByteIndex to srcByteIndex + srcElementSize. 1. Set
targetByteIndex to targetByteIndex + elementSize. 1. Set
count to count - 1. 1. Set O.[[ViewedArrayBuffer]] to
data. 1. Set O.[[ByteLength]] to byteLength. 1. Set
O.[[ByteOffset]] to 0. 1. Set O.[[ArrayLength]] to
elementLength. 1. Return ~unused~.

InitializeTypedArrayFromArrayBuffer ( O: a TypedArray, buffer: an ArrayBuffer or a SharedArrayBuffer, byteOffset, length, )
---------------------------------------------------------------------------------------------------------------------------

1. Let elementSize be TypedArrayElementSize(O). 1. Let
offset be ? ToIndex(byteOffset). 1. If offset modulo
elementSize ≠ 0, throw a `RangeError` exception. 1. Let
bufferIsFixedLength be IsFixedLengthArrayBuffer(buffer). 1. If
length is not `undefined`, then 1. Let newLength be ?
ToIndex(length). 1. If IsDetachedBuffer(buffer) is `true`,
throw a `TypeError` exception. 1. Let bufferByteLength be
ArrayBufferByteLength(buffer, ~seq-cst~). 1. If length is
`undefined` and bufferIsFixedLength is `false`, then 1. If
offset > bufferByteLength, throw a `RangeError` exception. 1.
Set O.[[ByteLength]] to ~auto~. 1. Set O.[[ArrayLength]] to
~auto~. 1. Else, 1. If length is `undefined`, then 1. If
bufferByteLength modulo elementSize ≠ 0, throw a `RangeError`
exception. 1. Let newByteLength be bufferByteLength -
offset. 1. If newByteLength < 0, throw a `RangeError`
exception. 1. Else, 1. Let newByteLength be newLength ×
elementSize. 1. If offset + newByteLength >
bufferByteLength, throw a `RangeError` exception. 1. Set
O.[[ByteLength]] to newByteLength. 1. Set O.[[ArrayLength]]
to newByteLength / elementSize. 1. Set
O.[[ViewedArrayBuffer]] to buffer. 1. Set O.[[ByteOffset]]
to offset. 1. Return ~unused~.

InitializeTypedArrayFromList ( O: a TypedArray, values: a List of ECMAScript language values, )
-----------------------------------------------------------------------------------------------

1. Let len be the number of elements in values. 1. Perform ?
AllocateTypedArrayBuffer(O, len). 1. Let k be 0. 1. Repeat,
while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kValue be the first element of values. 1. Remove the first
element from values. 1. Perform ? Set(O, Pk, kValue,
`true`). 1. Set k to k + 1. 1. Assert: values is now an
empty List. 1. Return ~unused~.

InitializeTypedArrayFromArrayLike ( O: a TypedArray, arrayLike: an Object, but not a TypedArray or an ArrayBuffer, )
--------------------------------------------------------------------------------------------------------------------

1. Let len be ? LengthOfArrayLike(arrayLike). 1. Perform ?
AllocateTypedArrayBuffer(O, len). 1. Let k be 0. 1. Repeat,
while k < len, 1. Let Pk be ! ToString(𝔽(k)). 1. Let
kValue be ? Get(arrayLike, Pk). 1. Perform ? Set(O,
Pk, kValue, `true`). 1. Set k to k + 1. 1. Return
~unused~.

AllocateTypedArrayBuffer ( O: a TypedArray, length: a non-negative integer, )
-----------------------------------------------------------------------------

description
   It allocates and associates an ArrayBuffer with O.

1. Assert: O.[[ViewedArrayBuffer]] is `undefined`. 1. Let
elementSize be TypedArrayElementSize(O). 1. Let byteLength
be elementSize × length. 1. Let data be ?
AllocateArrayBuffer(%ArrayBuffer%, byteLength). 1. Set
O.[[ViewedArrayBuffer]] to data. 1. Set O.[[ByteLength]] to
byteLength. 1. Set O.[[ByteOffset]] to 0. 1. Set
O.[[ArrayLength]] to length. 1. Return ~unused~.

Properties of the TypedArray Constructors
---------------------------------------------

Each TypedArray constructor:

- has a [[Prototype]] internal slot whose value is %TypedArray%.
- has a `"length"` property whose value is `3`\ :sub:`𝔽`.
- has a `"name"` property whose value is the String value of the
  constructor name specified for it in .
- has the following properties:

TypedArray.BYTES_PER_ELEMENT
--------------------------------

The value of TypedArray`.BYTES_PER_ELEMENT` is the Element Size
value specified in for TypedArray.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

TypedArray.prototype
------------------------

The initial value of TypedArray`.prototype` is the corresponding
TypedArray prototype intrinsic object ().

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the TypedArray Prototype Objects
--------------------------------------------------

Each TypedArray prototype object:

- has a [[Prototype]] internal slot whose value is
  %TypedArray.prototype%.
- is an ordinary object.
- does not have a [[ViewedArrayBuffer]] or any other of the internal
  slots that are specific to TypedArray instance objects.

TypedArray.prototype.BYTES_PER_ELEMENT
------------------------------------------

The value of TypedArray`.prototype.BYTES_PER_ELEMENT` is the
Element Size value specified in for TypedArray.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

TypedArray.prototype.constructor
------------------------------------

The initial value of the `"constructor"` property of the prototype for
a given TypedArray constructor is the constructor itself.

Properties of TypedArray Instances
--------------------------------------

TypedArray instances are TypedArrays. Each TypedArray instance
inherits properties from the corresponding TypedArray prototype
object. Each TypedArray instance has the following internal slots:
[[TypedArrayName]], [[ViewedArrayBuffer]], [[ByteLength]],
[[ByteOffset]], and [[ArrayLength]].

24. Keyed Collections
=====================

https://tc39.es/ecma262/multipage/keyed-collections.html
::

    24.1 Map Objects
        24.1.1 The Map Constructor
            24.1.1.1 Map ( [ iterable ] )
            24.1.1.2 AddEntriesFromIterable ( target, iterable, adder )
        24.1.2 Properties of the Map Constructor
            24.1.2.1 Map.groupBy ( items, callback )
            24.1.2.2 Map.prototype
            24.1.2.3 get Map [ %Symbol.species% ]
        24.1.3 Properties of the Map Prototype Object
            24.1.3.1 Map.prototype.clear ( )
            24.1.3.2 Map.prototype.constructor
            24.1.3.3 Map.prototype.delete ( key )
            24.1.3.4 Map.prototype.entries ( )
            24.1.3.5 Map.prototype.forEach ( callback [ , thisArg ] )
            24.1.3.6 Map.prototype.get ( key )
            24.1.3.7 Map.prototype.has ( key )
            24.1.3.8 Map.prototype.keys ( )
            24.1.3.9 Map.prototype.set ( key, value )
            24.1.3.10 get Map.prototype.size
            24.1.3.11 Map.prototype.values ( )
            24.1.3.12 Map.prototype [ %Symbol.iterator% ] ( )
            24.1.3.13 Map.prototype [ %Symbol.toStringTag% ]
        24.1.4 Properties of Map Instances
        24.1.5 Map Iterator Objects
            24.1.5.1 CreateMapIterator ( map, kind )
            24.1.5.2 The %MapIteratorPrototype% Object
                24.1.5.2.1 %MapIteratorPrototype%.next ( )
                24.1.5.2.2 %MapIteratorPrototype% [ %Symbol.toStringTag% ]
    24.2 Set Objects
        24.2.1 Abstract Operations For Set Objects
            24.2.1.1 Set Records
            24.2.1.2 GetSetRecord ( obj )
            24.2.1.3 SetDataHas ( setData, value )
            24.2.1.4 SetDataIndex ( setData, value )
            24.2.1.5 SetDataSize ( setData )
        24.2.2 The Set Constructor
            24.2.2.1 Set ( [ iterable ] )
        24.2.3 Properties of the Set Constructor
            24.2.3.1 Set.prototype
            24.2.3.2 get Set [ %Symbol.species% ]
        24.2.4 Properties of the Set Prototype Object
            24.2.4.1 Set.prototype.add ( value )
            24.2.4.2 Set.prototype.clear ( )
            24.2.4.3 Set.prototype.constructor
            24.2.4.4 Set.prototype.delete ( value )
            24.2.4.5 Set.prototype.difference ( other )
            24.2.4.6 Set.prototype.entries ( )
            24.2.4.7 Set.prototype.forEach ( callback [ , thisArg ] )
            24.2.4.8 Set.prototype.has ( value )
            24.2.4.9 Set.prototype.intersection ( other )
            24.2.4.10 Set.prototype.isDisjointFrom ( other )
            24.2.4.11 Set.prototype.isSubsetOf ( other )
            24.2.4.12 Set.prototype.isSupersetOf ( other )
            24.2.4.13 Set.prototype.keys ( )
            24.2.4.14 get Set.prototype.size
            24.2.4.15 Set.prototype.symmetricDifference ( other )
            24.2.4.16 Set.prototype.union ( other )
            24.2.4.17 Set.prototype.values ( )
            24.2.4.18 Set.prototype [ %Symbol.iterator% ] ( )
            24.2.4.19 Set.prototype [ %Symbol.toStringTag% ]
        24.2.5 Properties of Set Instances
        24.2.6 Set Iterator Objects
            24.2.6.1 CreateSetIterator ( set, kind )
            24.2.6.2 The %SetIteratorPrototype% Object
                24.2.6.2.1 %SetIteratorPrototype%.next ( )
                24.2.6.2.2 %SetIteratorPrototype% [ %Symbol.toStringTag% ]
    24.3 WeakMap Objects
        24.3.1 The WeakMap Constructor
            24.3.1.1 WeakMap ( [ iterable ] )
        24.3.2 Properties of the WeakMap Constructor
            24.3.2.1 WeakMap.prototype
        24.3.3 Properties of the WeakMap Prototype Object
            24.3.3.1 WeakMap.prototype.constructor
            24.3.3.2 WeakMap.prototype.delete ( key )
            24.3.3.3 WeakMap.prototype.get ( key )
            24.3.3.4 WeakMap.prototype.has ( key )
            24.3.3.5 WeakMap.prototype.set ( key, value )
            24.3.3.6 WeakMap.prototype [ %Symbol.toStringTag% ]
        24.3.4 Properties of WeakMap Instances
    24.4 WeakSet Objects
        24.4.1 The WeakSet Constructor
            24.4.1.1 WeakSet ( [ iterable ] )
        24.4.2 Properties of the WeakSet Constructor
            24.4.2.1 WeakSet.prototype
        24.4.3 Properties of the WeakSet Prototype Object
            24.4.3.1 WeakSet.prototype.add ( value )
            24.4.3.2 WeakSet.prototype.constructor
            24.4.3.3 WeakSet.prototype.delete ( value )
            24.4.3.4 WeakSet.prototype.has ( value )
            24.4.3.5 WeakSet.prototype [ %Symbol.toStringTag% ]
        24.4.4 Properties of WeakSet Instances
    24.5 Abstract Operations for Keyed Collections
        24.5.1 CanonicalizeKeyedCollectionKey ( key )


Map Objects
-----------

Maps are collections of key/value pairs where both the keys and values
may be arbitrary ECMAScript language values. A distinct key value may
only occur in one key/value pair within the Map's collection. Distinct
key values are discriminated using the SameValueZero comparison
algorithm.

Maps must be implemented using either hash tables or other mechanisms
that, on average, provide access times that are sublinear on the number
of elements in the collection. The data structure used in this
specification is only intended to describe the required observable
semantics of Maps. It is not intended to be a viable implementation
model.

The Map Constructor
-------------------

The Map constructor:

- is %Map%.
- is the initial value of the `"Map"` property of the global object.
- creates and initializes a new Map when called as a constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value in an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Map behaviour must include a `super` call to the Map constructor to
  create and initialize the subclass instance with the internal state
  necessary to support the `Map.prototype` built-in methods.

Map ( [ iterable ] )
------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Let map be ? OrdinaryCreateFromConstructor(NewTarget,
`"%Map.prototype%"`, « [[MapData]] »). 1. Set map.[[MapData]] to a
new empty List. 1. If iterable is either `undefined` or `null`,
return map. 1. Let adder be ? Get(map, `"set"`). 1. If
IsCallable(adder) is `false`, throw a `TypeError` exception. 1.
Return ? AddEntriesFromIterable(map, iterable, adder).

If the parameter iterable is present, it is expected to be an object
that implements an %Symbol.iterator% method that returns an iterator
object that produces a two element array-like object whose first element
is a value that will be used as a Map key and whose second element is
the value to associate with that key.

AddEntriesFromIterable ( target: an Object, iterable, but not `undefined` or `null`, adder: a function object, )
----------------------------------------------------------------------------------------------------------------

description
   adder will be invoked, with target as the receiver.

1. Let iteratorRecord be ? GetIterator(iterable, ~sync~). 1.
Repeat, 1. Let next be ? IteratorStepValue(iteratorRecord). 1.
If next is ~done~, return target. 1. If next is not an
Object, then 1. Let error be ThrowCompletion(a newly created
`TypeError` object). 1. Return ? IteratorClose(iteratorRecord,
error). 1. Let k be Completion(Get(next, `"0"`)). 1.
IfAbruptCloseIterator(k, iteratorRecord). 1. Let v be
Completion(Get(next, `"1"`)). 1. IfAbruptCloseIterator(v,
iteratorRecord). 1. Let status be Completion(Call(adder,
target, « k, v »)). 1. IfAbruptCloseIterator(status,
iteratorRecord).

The parameter iterable is expected to be an object that implements
an %Symbol.iterator% method that returns an iterator object that
produces a two element array-like object whose first element is a value
that will be used as a Map key and whose second element is the value to
associate with that key.

Properties of the Map Constructor
---------------------------------

The Map constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Map.groupBy ( items, callback )
---------------------------------------

callback should be a function that accepts two arguments.
`groupBy` calls callback once for each element in items, in
ascending order, and constructs a new Map. Each value returned by
callback is used as a key in the Map. For each such key, the result
Map has an entry whose key is that key and whose value is an array
containing all the elements for which callback returned that key.

callback is called with two arguments: the value of the element and
the index of the element.

The return value of `groupBy` is a Map.

This function performs the following steps when called:

1. Let groups be ? GroupBy(items, callback, ~collection~).
1. Let map be ! Construct(%Map%). 1. For each Record { [[Key]],
[[Elements]] } g of groups, do 1. Let elements be
CreateArrayFromList(g.[[Elements]]). 1. Let entry be the Record
{ [[Key]]: g.[[Key]], [[Value]]: elements }. 1. Append entry
to map.[[MapData]]. 1. Return map.

Map.prototype
-------------

The initial value of `Map.prototype` is the Map prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

get Map [ %Symbol.species% ]
----------------------------

`Map[%Symbol.species%]` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

Methods that create derived collection objects should call
%Symbol.species% to determine the constructor to use to create the
derived objects. Subclass constructor may over-ride %Symbol.species% to
change the default constructor assignment.

Properties of the Map Prototype Object
--------------------------------------

The Map prototype object:

- is %Map.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have a [[MapData]] internal slot.

Map.prototype.clear ( )
-----------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[MapData]]). 1. For each Record { [[Key]],
[[Value]] } p of M.[[MapData]], do 1. Set p.[[Key]] to
~empty~. 1. Set p.[[Value]] to ~empty~. 1. Return `undefined`.

The existing [[MapData]] List is preserved because there may be existing
Map Iterator objects that are suspended midway through iterating over
that List.

Map.prototype.constructor
-------------------------

The initial value of `Map.prototype.constructor` is %Map%.

Map.prototype.delete ( key )
--------------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[MapData]]). 1. Set key to
CanonicalizeKeyedCollectionKey(key). 1. For each Record { [[Key]],
[[Value]] } p of M.[[MapData]], do 1. If p.[[Key]] is not
~empty~ and SameValue(p.[[Key]], key) is `true`, then 1. Set
p.[[Key]] to ~empty~. 1. Set p.[[Value]] to ~empty~. 1. Return
`true`. 1. Return `false`.

The value ~empty~ is used as a specification device to indicate that an
entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Map.prototype.entries ( )
-------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Return ? CreateMapIterator(M,
~key+value~).

Map.prototype.forEach ( callback [ , thisArg ] )
--------------------------------------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[MapData]]). 1. If IsCallable(callback)
is `false`, throw a `TypeError` exception. 1. Let entries be
M.[[MapData]]. 1. Let numEntries be the number of elements in
entries. 1. Let index be 0. 1. Repeat, while index <
numEntries, 1. Let e be entries[index]. 1. Set index
to index + 1. 1. If e.[[Key]] is not ~empty~, then 1. Perform ?
Call(callback, thisArg, « e.[[Value]], e.[[Key]], M
»). 1. NOTE: The number of elements in entries may have increased
during execution of callback. 1. Set numEntries to the number of
elements in entries. 1. Return `undefined`.

callback should be a function that accepts three arguments.
`forEach` calls callback once for each key/value pair present in
the Map, in key insertion order. callback is called only for keys of
the Map which actually exist; it is not called for keys that have been
deleted from the Map.

If a thisArg parameter is provided, it will be used as the `this`
value for each invocation of callback. If it is not provided,
`undefined` is used instead.

callback is called with three arguments: the value of the item, the
key of the item, and the Map being traversed.

`forEach` does not directly mutate the object on which it is called
but the object may be mutated by the calls to callback. Each entry
of a map's [[MapData]] is only visited once. New keys added after the
call to `forEach` begins are visited. A key will be revisited if it is
deleted after it has been visited and then re-added before the
`forEach` call completes. Keys that are deleted after the call to
`forEach` begins and before being visited are not visited unless the
key is added again before the `forEach` call completes.

Map.prototype.get ( key )
-----------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[MapData]]). 1. Set key to
CanonicalizeKeyedCollectionKey(key). 1. For each Record { [[Key]],
[[Value]] } p of M.[[MapData]], do 1. If p.[[Key]] is not
~empty~ and SameValue(p.[[Key]], key) is `true`, return
p.[[Value]]. 1. Return `undefined`.

Map.prototype.has ( key )
-----------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[MapData]]). 1. Set key to
CanonicalizeKeyedCollectionKey(key). 1. For each Record { [[Key]],
[[Value]] } p of M.[[MapData]], do 1. If p.[[Key]] is not
~empty~ and SameValue(p.[[Key]], key) is `true`, return
`true`. 1. Return `false`.

Map.prototype.keys ( )
----------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Return ? CreateMapIterator(M,
~key~).

Map.prototype.set ( key, value )
----------------------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[MapData]]). 1. Set key to
CanonicalizeKeyedCollectionKey(key). 1. For each Record { [[Key]],
[[Value]] } p of M.[[MapData]], do 1. If p.[[Key]] is not
~empty~ and SameValue(p.[[Key]], key) is `true`, then 1. Set
p.[[Value]] to value. 1. Return M. 1. Let p be the
Record { [[Key]]: key, [[Value]]: value }. 1. Append p to
M.[[MapData]]. 1. Return M.

get Map.prototype.size
----------------------

`Map.prototype.size` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[MapData]]). 1. Let count be 0. 1. For
each Record { [[Key]], [[Value]] } p of M.[[MapData]], do 1. If
p.[[Key]] is not ~empty~, set count to count + 1. 1. Return
𝔽(count).

Map.prototype.values ( )
------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Return ? CreateMapIterator(M,
~value~).

Map.prototype [ %Symbol.iterator% ] ( )
---------------------------------------

The initial value of the %Symbol.iterator% property is
%Map.prototype.entries%, defined in .

Map.prototype [ %Symbol.toStringTag% ]
--------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Map"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of Map Instances
---------------------------

Map instances are ordinary objects that inherit properties from the Map
prototype. Map instances also have a [[MapData]] internal slot.

Map Iterator Objects
--------------------

A Map Iterator is an object that represents a specific iteration over
some specific Map instance object. There is not a named constructor for
Map Iterator objects. Instead, map iterator objects are created by
calling certain methods of Map instance objects.

CreateMapIterator ( map, kind: ~key+value~, ~key~, or ~value~, )
----------------------------------------------------------------

description
   It is used to create iterator objects for Map methods that return
   such iterators.

1. Perform ? RequireInternalSlot(map, [[MapData]]). 1. Let
closure be a new Abstract Closure with no parameters that captures
map and kind and performs the following steps when called: 1.
Let entries be map.[[MapData]]. 1. Let index be 0. 1. Let
numEntries be the number of elements in entries. 1. Repeat,
while index < numEntries, 1. Let e be
entries[index]. 1. Set index to index + 1. 1. If
e.[[Key]] is not ~empty~, then 1. If kind is ~key~, then 1. Let
result be e.[[Key]]. 1. Else if kind is ~value~, then 1. Let
result be e.[[Value]]. 1. Else, 1. Assert: kind is
~key+value~. 1. Let result be CreateArrayFromList(« e.[[Key]],
e.[[Value]] »). 1. Perform ?
GeneratorYield(CreateIteratorResultObject(result, `false`)). 1.
NOTE: The number of elements in entries may have increased while
execution of this abstract operation was paused by GeneratorYield. 1.
Set numEntries to the number of elements in entries. 1. Return
`undefined`. 1. Return CreateIteratorFromClosure(closure,
`"%MapIteratorPrototype%"`, %MapIteratorPrototype%).

The %MapIteratorPrototype% Object
---------------------------------

The %MapIteratorPrototype% object:

- has properties that are inherited by all Map Iterator objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- has the following properties:

%MapIteratorPrototype%.next ( )
-------------------------------

1. Return ? GeneratorResume(`this` value, ~empty~,
`"%MapIteratorPrototype%"`).

%MapIteratorPrototype% [ %Symbol.toStringTag% ]
-----------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Map Iterator"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Set Objects
-----------

Set objects are collections of ECMAScript language values. A distinct
value may only occur once as an element of a Set's collection. Distinct
values are discriminated using the SameValueZero comparison algorithm.

Set objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structure used in
this specification is only intended to describe the required observable
semantics of Set objects. It is not intended to be a viable
implementation model.

Abstract Operations For Set Objects
-----------------------------------

Set Records
-----------

A Set Record is a Record value used to encapsulate the interface of a
Set or similar object.

Set Records have the fields listed in .

+---------------+-------------------------+-------------------------+
| Field Name    | Value                   | Meaning                 |
+===============+=========================+=========================+
| [[SetObject]] | an Object               | the Set or similar      |
|               |                         | object.                 |
+---------------+-------------------------+-------------------------+
| [[Size]]      | a non-negative integer  | The reported size of    |
|               | or +∞                   | the object.             |
+---------------+-------------------------+-------------------------+
| [[Has]]       | a function object       | The `has` method of   |
|               |                         | the object.             |
+---------------+-------------------------+-------------------------+
| [[Keys]]      | a function object       | The `keys` method of  |
|               |                         | the object.             |
+---------------+-------------------------+-------------------------+

GetSetRecord ( obj, )
---------------------

1. If obj is not an Object, throw a `TypeError` exception. 1. Let
rawSize be ? Get(obj, `"size"`). 1. Let numSize be ?
ToNumber(rawSize). 1. NOTE: If rawSize is `undefined`, then
numSize will be `NaN`. 1. If numSize is `NaN`, throw a
`TypeError` exception. 1. Let intSize be !
ToIntegerOrInfinity(numSize). 1. If intSize < 0, throw a
`RangeError` exception. 1. Let has be ? Get(obj, `"has"`).
1. If IsCallable(has) is `false`, throw a `TypeError` exception.
1. Let keys be ? Get(obj, `"keys"`). 1. If
IsCallable(keys) is `false`, throw a `TypeError` exception. 1.
Return a new Set Record { [[SetObject]]: obj, [[Size]]: intSize,
[[Has]]: has, [[Keys]]: keys }.

SetDataHas ( setData: a List of either ECMAScript language values or ~empty~, value, ): a Boolean
---------------------------------------------------------------------------------------------------------------------------------------

1. If SetDataIndex(setData, value) is ~not-found~, return
`false`. 1. Return `true`.

SetDataIndex ( setData: a List of either ECMAScript language values or ~empty~, value, ): a non-negative integer or ~not-found~
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Set value to CanonicalizeKeyedCollectionKey(value). 1. Let
size be the number of elements in setData. 1. Let index be
0. 1. Repeat, while index < size, 1. Let e be
setData[index]. 1. If e is not ~empty~ and e is
value, then 1. Return index. 1. Set index to index + 1.
1. Return ~not-found~.

SetDataSize ( setData: a List of either ECMAScript language values or ~empty~, ): a non-negative integer
------------------------------------------------------------------------------------------------------------

1. Let count be 0. 1. For each element e of setData, do 1.
If e is not ~empty~, set count to count + 1. 1. Return
count.

The Set Constructor
-------------------

The Set constructor:

- is %Set%.
- is the initial value of the `"Set"` property of the global object.
- creates and initializes a new Set object when called as a constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value in an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Set behaviour must include a `super` call to the Set constructor to
  create and initialize the subclass instance with the internal state
  necessary to support the `Set.prototype` built-in methods.

Set ( [ iterable ] )
------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Let set be ? OrdinaryCreateFromConstructor(NewTarget,
`"%Set.prototype%"`, « [[SetData]] »). 1. Set set.[[SetData]] to a
new empty List. 1. If iterable is either `undefined` or `null`,
return set. 1. Let adder be ? Get(set, `"add"`). 1. If
IsCallable(adder) is `false`, throw a `TypeError` exception. 1.
Let iteratorRecord be ? GetIterator(iterable, ~sync~). 1.
Repeat, 1. Let next be ? IteratorStepValue(iteratorRecord). 1.
If next is ~done~, return set. 1. Let status be
Completion(Call(adder, set, « next »)). 1.
IfAbruptCloseIterator(status, iteratorRecord).

Properties of the Set Constructor
---------------------------------

The Set constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Set.prototype
-------------

The initial value of `Set.prototype` is the Set prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

get Set [ %Symbol.species% ]
----------------------------

`Set[%Symbol.species%]` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

Methods that create derived collection objects should call
%Symbol.species% to determine the constructor to use to create the
derived objects. Subclass constructor may over-ride %Symbol.species% to
change the default constructor assignment.

Properties of the Set Prototype Object
--------------------------------------

The Set prototype object:

- is %Set.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have a [[SetData]] internal slot.

Set.prototype.add ( value )
-------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[SetData]]). 1. Set value to
CanonicalizeKeyedCollectionKey(value). 1. For each element e of
S.[[SetData]], do 1. If e is not ~empty~ and SameValue(e,
value) is `true`, then 1. Return S. 1. Append value to
S.[[SetData]]. 1. Return S.

Set.prototype.clear ( )
-----------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[SetData]]). 1. For each element e of
S.[[SetData]], do 1. Replace the element of S.[[SetData]] whose
value is e with an element whose value is ~empty~. 1. Return
`undefined`.

The existing [[SetData]] List is preserved because there may be existing
Set Iterator objects that are suspended midway through iterating over
that List.

Set.prototype.constructor
-------------------------

The initial value of `Set.prototype.constructor` is %Set%.

Set.prototype.delete ( value )
----------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[SetData]]). 1. Set value to
CanonicalizeKeyedCollectionKey(value). 1. For each element e of
S.[[SetData]], do 1. If e is not ~empty~ and SameValue(e,
value) is `true`, then 1. Replace the element of S.[[SetData]]
whose value is e with an element whose value is ~empty~. 1. Return
`true`. 1. Return `false`.

The value ~empty~ is used as a specification device to indicate that an
entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Set.prototype.difference ( other )
--------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[SetData]]). 1. Let otherRec be ?
GetSetRecord(other). 1. Let resultSetData be a copy of
O.[[SetData]]. 1. If SetDataSize(O.[[SetData]]) ≤
otherRec.[[Size]], then 1. Let thisSize be the number of
elements in O.[[SetData]]. 1. Let index be 0. 1. Repeat, while
index < thisSize, 1. Let e be resultSetData[index].
1. If e is not ~empty~, then 1. Let inOther be ToBoolean(?
Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »)). 1.
If inOther is `true`, then 1. Set resultSetData[index] to
~empty~. 1. Set index to index + 1. 1. Else, 1. Let keysIter
be ? GetIteratorFromMethod(otherRec.[[SetObject]],
otherRec.[[Keys]]). 1. Let next be ~not-started~. 1. Repeat,
while next is not ~done~, 1. Set next to ?
IteratorStepValue(keysIter). 1. If next is not ~done~, then 1.
Set next to CanonicalizeKeyedCollectionKey(next). 1. Let
valueIndex be SetDataIndex(resultSetData, next). 1. If
valueIndex is not ~not-found~, then 1. Set
resultSetData[valueIndex] to ~empty~. 1. Let result be
OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »). 1. Set
result.[[SetData]] to resultSetData. 1. Return result.

Set.prototype.entries ( )
-------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateSetIterator(S,
~key+value~).

For iteration purposes, a Set appears similar to a Map where each entry
has the same value for its key and value.

Set.prototype.forEach ( callback [ , thisArg ] )
--------------------------------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[SetData]]). 1. If IsCallable(callback)
is `false`, throw a `TypeError` exception. 1. Let entries be
S.[[SetData]]. 1. Let numEntries be the number of elements in
entries. 1. Let index be 0. 1. Repeat, while index <
numEntries, 1. Let e be entries[index]. 1. Set index
to index + 1. 1. If e is not ~empty~, then 1. Perform ?
Call(callback, thisArg, « e, e, S »). 1. NOTE: The
number of elements in entries may have increased during execution of
callback. 1. Set numEntries to the number of elements in
entries. 1. Return `undefined`.

callback should be a function that accepts three arguments.
`forEach` calls callback once for each value present in the Set
object, in value insertion order. callback is called only for values
of the Set which actually exist; it is not called for keys that have
been deleted from the set.

If a thisArg parameter is provided, it will be used as the `this`
value for each invocation of callback. If it is not provided,
`undefined` is used instead.

callback is called with three arguments: the first two arguments are
a value contained in the Set. The same value is passed for both
arguments. The Set object being traversed is passed as the third
argument.

The callback is called with three arguments to be consistent with
the call back functions used by `forEach` methods for Map and Array.
For Sets, each item value is considered to be both the key and the
value.

`forEach` does not directly mutate the object on which it is called
but the object may be mutated by the calls to callback.

Each value is normally visited only once. However, a value will be
revisited if it is deleted after it has been visited and then re-added
before the `forEach` call completes. Values that are deleted after the
call to `forEach` begins and before being visited are not visited
unless the value is added again before the `forEach` call completes.
New values added after the call to `forEach` begins are visited.

Set.prototype.has ( value )
-------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[SetData]]). 1. Set value to
CanonicalizeKeyedCollectionKey(value). 1. For each element e of
S.[[SetData]], do 1. If e is not ~empty~ and SameValue(e,
value) is `true`, return `true`. 1. Return `false`.

Set.prototype.intersection ( other )
----------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[SetData]]). 1. Let otherRec be ?
GetSetRecord(other). 1. Let resultSetData be a new empty List.
1. If SetDataSize(O.[[SetData]]) ≤ otherRec.[[Size]], then 1.
Let thisSize be the number of elements in O.[[SetData]]. 1. Let
index be 0. 1. Repeat, while index < thisSize, 1. Let e
be O.[[SetData]][index]. 1. Set index to index + 1. 1.
If e is not ~empty~, then 1. Let inOther be ToBoolean(?
Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »)). 1.
If inOther is `true`, then 1. NOTE: It is possible for earlier
calls to otherRec.[[Has]] to remove and re-add an element of
O.[[SetData]], which can cause the same element to be visited twice
during this iteration. 1. If SetDataHas(resultSetData, e) is
`false`, then 1. Append e to resultSetData. 1. NOTE: The
number of elements in O.[[SetData]] may have increased during
execution of otherRec.[[Has]]. 1. Set thisSize to the number of
elements in O.[[SetData]]. 1. Else, 1. Let keysIter be ?
GetIteratorFromMethod(otherRec.[[SetObject]],
otherRec.[[Keys]]). 1. Let next be ~not-started~. 1. Repeat,
while next is not ~done~, 1. Set next to ?
IteratorStepValue(keysIter). 1. If next is not ~done~, then 1.
Set next to CanonicalizeKeyedCollectionKey(next). 1. Let
inThis be SetDataHas(O.[[SetData]], next). 1. If inThis
is `true`, then 1. NOTE: Because other is an arbitrary object, it
is possible for its `"keys"` iterator to produce the same value more
than once. 1. If SetDataHas(resultSetData, next) is `false`,
then 1. Append next to resultSetData. 1. Let result be
OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »). 1. Set
result.[[SetData]] to resultSetData. 1. Return result.

Set.prototype.isDisjointFrom ( other )
------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[SetData]]). 1. Let otherRec be ?
GetSetRecord(other). 1. If SetDataSize(O.[[SetData]]) ≤
otherRec.[[Size]], then 1. Let thisSize be the number of
elements in O.[[SetData]]. 1. Let index be 0. 1. Repeat, while
index < thisSize, 1. Let e be O.[[SetData]][index].
1. Set index to index + 1. 1. If e is not ~empty~, then 1.
Let inOther be ToBoolean(? Call(otherRec.[[Has]],
otherRec.[[SetObject]], « e »)). 1. If inOther is `true`,
return `false`. 1. NOTE: The number of elements in O.[[SetData]]
may have increased during execution of otherRec.[[Has]]. 1. Set
thisSize to the number of elements in O.[[SetData]]. 1. Else, 1.
Let keysIter be ? GetIteratorFromMethod(otherRec.[[SetObject]],
otherRec.[[Keys]]). 1. Let next be ~not-started~. 1. Repeat,
while next is not ~done~, 1. Set next to ?
IteratorStepValue(keysIter). 1. If next is not ~done~, then 1.
If SetDataHas(O.[[SetData]], next) is `true`, then 1. Perform
? IteratorClose(keysIter, NormalCompletion(~unused~)). 1. Return
`false`. 1. Return `true`.

Set.prototype.isSubsetOf ( other )
--------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[SetData]]). 1. Let otherRec be ?
GetSetRecord(other). 1. If SetDataSize(O.[[SetData]]) >
otherRec.[[Size]], return `false`. 1. Let thisSize be the
number of elements in O.[[SetData]]. 1. Let index be 0. 1.
Repeat, while index < thisSize, 1. Let e be
O.[[SetData]][index]. 1. Set index to index + 1. 1. If
e is not ~empty~, then 1. Let inOther be ToBoolean(?
Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »)). 1.
If inOther is `false`, return `false`. 1. NOTE: The number of
elements in O.[[SetData]] may have increased during execution of
otherRec.[[Has]]. 1. Set thisSize to the number of elements in
O.[[SetData]]. 1. Return `true`.

Set.prototype.isSupersetOf ( other )
----------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[SetData]]). 1. Let otherRec be ?
GetSetRecord(other). 1. If SetDataSize(O.[[SetData]]) <
otherRec.[[Size]], return `false`. 1. Let keysIter be ?
GetIteratorFromMethod(otherRec.[[SetObject]],
otherRec.[[Keys]]). 1. Let next be ~not-started~. 1. Repeat,
while next is not ~done~, 1. Set next to ?
IteratorStepValue(keysIter). 1. If next is not ~done~, then 1.
If SetDataHas(O.[[SetData]], next) is `false`, then 1. Perform
? IteratorClose(keysIter, NormalCompletion(~unused~)). 1. Return
`false`. 1. Return `true`.

Set.prototype.keys ( )
----------------------

The initial value of the `"keys"` property is %Set.prototype.values%,
defined in .

For iteration purposes, a Set appears similar to a Map where each entry
has the same value for its key and value.

get Set.prototype.size
----------------------

`Set.prototype.size` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[SetData]]). 1. Let size be
SetDataSize(S.[[SetData]]). 1. Return 𝔽(size).

Set.prototype.symmetricDifference ( other )
-----------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[SetData]]). 1. Let otherRec be ?
GetSetRecord(other). 1. Let keysIter be ?
GetIteratorFromMethod(otherRec.[[SetObject]],
otherRec.[[Keys]]). 1. Let resultSetData be a copy of
O.[[SetData]]. 1. Let next be ~not-started~. 1. Repeat, while
next is not ~done~, 1. Set next to ?
IteratorStepValue(keysIter). 1. If next is not ~done~, then 1.
Set next to CanonicalizeKeyedCollectionKey(next). 1. Let
resultIndex be SetDataIndex(resultSetData, next). 1. If
resultIndex is ~not-found~, let alreadyInResult be `false`.
Otherwise let alreadyInResult be `true`. 1. If
SetDataHas(O.[[SetData]], next) is `true`, then 1. If
alreadyInResult is `true`, set resultSetData[resultIndex]
to ~empty~. 1. Else, 1. If alreadyInResult is `false`, append
next to resultSetData. 1. Let result be
OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »). 1. Set
result.[[SetData]] to resultSetData. 1. Return result.

Set.prototype.union ( other )
---------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[SetData]]). 1. Let otherRec be ?
GetSetRecord(other). 1. Let keysIter be ?
GetIteratorFromMethod(otherRec.[[SetObject]],
otherRec.[[Keys]]). 1. Let resultSetData be a copy of
O.[[SetData]]. 1. Let next be ~not-started~. 1. Repeat, while
next is not ~done~, 1. Set next to ?
IteratorStepValue(keysIter). 1. If next is not ~done~, then 1.
Set next to CanonicalizeKeyedCollectionKey(next). 1. If
SetDataHas(resultSetData, next) is `false`, then 1. Append
next to resultSetData. 1. Let result be
OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »). 1. Set
result.[[SetData]] to resultSetData. 1. Return result.

Set.prototype.values ( )
------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateSetIterator(S,
~value~).

Set.prototype [ %Symbol.iterator% ] ( )
---------------------------------------

The initial value of the %Symbol.iterator% property is
%Set.prototype.values%, defined in .

Set.prototype [ %Symbol.toStringTag% ]
--------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Set"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of Set Instances
---------------------------

Set instances are ordinary objects that inherit properties from the Set
prototype. Set instances also have a [[SetData]] internal slot.

Set Iterator Objects
--------------------

A Set Iterator is an ordinary object, with the structure defined below,
that represents a specific iteration over some specific Set instance
object. There is not a named constructor for Set Iterator objects.
Instead, set iterator objects are created by calling certain methods of
Set instance objects.

CreateSetIterator ( set, kind: ~key+value~ or ~value~, )
--------------------------------------------------------

description
   It is used to create iterator objects for Set methods that return
   such iterators.

1. Perform ? RequireInternalSlot(set, [[SetData]]). 1. Let
closure be a new Abstract Closure with no parameters that captures
set and kind and performs the following steps when called: 1.
Let index be 0. 1. Let entries be set.[[SetData]]. 1. Let
numEntries be the number of elements in entries. 1. Repeat,
while index < numEntries, 1. Let e be
entries[index]. 1. Set index to index + 1. 1. If e
is not ~empty~, then 1. If kind is ~key+value~, then 1. Let
result be CreateArrayFromList(« e, e »). 1. Perform ?
GeneratorYield(CreateIteratorResultObject(result, `false`)). 1.
Else, 1. Assert: kind is ~value~. 1. Perform ?
GeneratorYield(CreateIteratorResultObject(e, `false`)). 1. NOTE:
The number of elements in entries may have increased while execution
of this abstract operation was paused by GeneratorYield. 1. Set
numEntries to the number of elements in entries. 1. Return
`undefined`. 1. Return CreateIteratorFromClosure(closure,
`"%SetIteratorPrototype%"`, %SetIteratorPrototype%).

The %SetIteratorPrototype% Object
---------------------------------

The %SetIteratorPrototype% object:

- has properties that are inherited by all Set Iterator objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- has the following properties:

%SetIteratorPrototype%.next ( )
-------------------------------

1. Return ? GeneratorResume(`this` value, ~empty~,
`"%SetIteratorPrototype%"`).

%SetIteratorPrototype% [ %Symbol.toStringTag% ]
-----------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Set Iterator"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

WeakMap Objects
---------------

WeakMaps are collections of key/value pairs where the keys are objects
and/or symbols and values may be arbitrary ECMAScript language values. A
WeakMap may be queried to see if it contains a key/value pair with a
specific key, but no mechanism is provided for enumerating the values it
holds as keys. In certain conditions, values which are not live are
removed as WeakMap keys, as described in .

An implementation may impose an arbitrarily determined latency between
the time a key/value pair of a WeakMap becomes inaccessible and the time
when the key/value pair is removed from the WeakMap. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution. For that reason, an ECMAScript
implementation must not provide any means to observe a key of a WeakMap
that does not require the observer to present the observed key.

WeakMaps must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of key/value pairs in the collection. The data structure used
in this specification is only intended to describe the required
observable semantics of WeakMaps. It is not intended to be a viable
implementation model.

WeakMap and WeakSet are intended to provide mechanisms for dynamically
associating state with an object or symbol in a manner that does not
“leak” memory resources if, in the absence of the WeakMap or WeakSet
instance, the object or symbol otherwise became inaccessible and subject
to resource reclamation by the implementation's garbage collection
mechanisms. This characteristic can be achieved by using an inverted
per-object/symbol mapping of WeakMap or WeakSet instances to keys.
Alternatively, each WeakMap or WeakSet instance may internally store its
key and value data, but this approach requires coordination between the
WeakMap or WeakSet implementation and the garbage collector. The
following references describe mechanism that may be useful to
implementations of WeakMap and WeakSet:

Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In
*Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
programming, systems, languages, and applications (OOPSLA '97)*, A.
Michael Berman (Ed.). ACM, New York, NY, USA, 176-183,
http://doi.acm.org/10.1145/263698.263733.

Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak
Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21,
pp. 3481-3497, 2008,
http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak

The WeakMap Constructor
-----------------------

The WeakMap constructor:

- is %WeakMap%.
- is the initial value of the `"WeakMap"` property of the global
  object.
- creates and initializes a new WeakMap when called as a constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value in an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  WeakMap behaviour must include a `super` call to the WeakMap
  constructor to create and initialize the subclass instance with the
  internal state necessary to support the `WeakMap.prototype` built-in
  methods.

WeakMap ( [ iterable ] )
----------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Let map be ? OrdinaryCreateFromConstructor(NewTarget,
`"%WeakMap.prototype%"`, « [[WeakMapData]] »). 1. Set
map.[[WeakMapData]] to a new empty List. 1. If iterable is
either `undefined` or `null`, return map. 1. Let adder be ?
Get(map, `"set"`). 1. If IsCallable(adder) is `false`, throw
a `TypeError` exception. 1. Return ? AddEntriesFromIterable(map,
iterable, adder).

If the parameter iterable is present, it is expected to be an object
that implements an %Symbol.iterator% method that returns an iterator
object that produces a two element array-like object whose first element
is a value that will be used as a WeakMap key and whose second element
is the value to associate with that key.

Properties of the WeakMap Constructor
-------------------------------------

The WeakMap constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

WeakMap.prototype
-----------------

The initial value of `WeakMap.prototype` is the WeakMap prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the WeakMap Prototype Object
------------------------------------------

The WeakMap prototype object:

- is %WeakMap.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have a [[WeakMapData]] internal slot.

WeakMap.prototype.constructor
-----------------------------

The initial value of `WeakMap.prototype.constructor` is %WeakMap%.

WeakMap.prototype.delete ( key )
------------------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[WeakMapData]]). 1. If
CanBeHeldWeakly(key) is `false`, return `false`. 1. For each
Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do 1. If
p.[[Key]] is not ~empty~ and SameValue(p.[[Key]], key) is
`true`, then 1. Set p.[[Key]] to ~empty~. 1. Set p.[[Value]]
to ~empty~. 1. Return `true`. 1. Return `false`.

The value ~empty~ is used as a specification device to indicate that an
entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakMap.prototype.get ( key )
---------------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[WeakMapData]]). 1. If
CanBeHeldWeakly(key) is `false`, return `undefined`. 1. For each
Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do 1. If
p.[[Key]] is not ~empty~ and SameValue(p.[[Key]], key) is
`true`, return p.[[Value]]. 1. Return `undefined`.

WeakMap.prototype.has ( key )
---------------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[WeakMapData]]). 1. If
CanBeHeldWeakly(key) is `false`, return `false`. 1. For each
Record { [[Key]], [[Value]] } p of M.[[WeakMapData]], do 1. If
p.[[Key]] is not ~empty~ and SameValue(p.[[Key]], key) is
`true`, return `true`. 1. Return `false`.

WeakMap.prototype.set ( key, value )
--------------------------------------------

This method performs the following steps when called:

1. Let M be the `this` value. 1. Perform ?
RequireInternalSlot(M, [[WeakMapData]]). 1. If
CanBeHeldWeakly(key) is `false`, throw a `TypeError` exception.
1. For each Record { [[Key]], [[Value]] } p of
M.[[WeakMapData]], do 1. If p.[[Key]] is not ~empty~ and
SameValue(p.[[Key]], key) is `true`, then 1. Set
p.[[Value]] to value. 1. Return M. 1. Let p be the
Record { [[Key]]: key, [[Value]]: value }. 1. Append p to
M.[[WeakMapData]]. 1. Return M.

WeakMap.prototype [ %Symbol.toStringTag% ]
------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"WeakMap"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of WeakMap Instances
-------------------------------

WeakMap instances are ordinary objects that inherit properties from the
WeakMap prototype. WeakMap instances also have a [[WeakMapData]]
internal slot.

WeakSet Objects
---------------

WeakSets are collections of objects and/or symbols. A distinct object or
symbol may only occur once as an element of a WeakSet's collection. A
WeakSet may be queried to see if it contains a specific value, but no
mechanism is provided for enumerating the values it holds. In certain
conditions, values which are not live are removed as WeakSet elements,
as described in .

An implementation may impose an arbitrarily determined latency between
the time a value contained in a WeakSet becomes inaccessible and the
time when the value is removed from the WeakSet. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution. For that reason, an ECMAScript
implementation must not provide any means to determine if a WeakSet
contains a particular value that does not require the observer to
present the observed value.

WeakSets must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structure used in
this specification is only intended to describe the required observable
semantics of WeakSets. It is not intended to be a viable implementation
model.

See the NOTE in .

The WeakSet Constructor
-----------------------

The WeakSet constructor:

- is %WeakSet%.
- is the initial value of the `"WeakSet"` property of the global
  object.
- creates and initializes a new WeakSet when called as a constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value in an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  WeakSet behaviour must include a `super` call to the WeakSet
  constructor to create and initialize the subclass instance with the
  internal state necessary to support the `WeakSet.prototype` built-in
  methods.

WeakSet ( [ iterable ] )
----------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Let set be ? OrdinaryCreateFromConstructor(NewTarget,
`"%WeakSet.prototype%"`, « [[WeakSetData]] »). 1. Set
set.[[WeakSetData]] to a new empty List. 1. If iterable is
either `undefined` or `null`, return set. 1. Let adder be ?
Get(set, `"add"`). 1. If IsCallable(adder) is `false`, throw
a `TypeError` exception. 1. Let iteratorRecord be ?
GetIterator(iterable, ~sync~). 1. Repeat, 1. Let next be ?
IteratorStepValue(iteratorRecord). 1. If next is ~done~, return
set. 1. Let status be Completion(Call(adder, set, «
next »)). 1. IfAbruptCloseIterator(status, iteratorRecord).

Properties of the WeakSet Constructor
-------------------------------------

The WeakSet constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

WeakSet.prototype
-----------------

The initial value of `WeakSet.prototype` is the WeakSet prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the WeakSet Prototype Object
------------------------------------------

The WeakSet prototype object:

- is %WeakSet.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have a [[WeakSetData]] internal slot.

WeakSet.prototype.add ( value )
-----------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[WeakSetData]]). 1. If
CanBeHeldWeakly(value) is `false`, throw a `TypeError`
exception. 1. For each element e of S.[[WeakSetData]], do 1. If
e is not ~empty~ and SameValue(e, value) is `true`, then
1. Return S. 1. Append value to S.[[WeakSetData]]. 1. Return
S.

WeakSet.prototype.constructor
-----------------------------

The initial value of `WeakSet.prototype.constructor` is %WeakSet%.

WeakSet.prototype.delete ( value )
--------------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[WeakSetData]]). 1. If
CanBeHeldWeakly(value) is `false`, return `false`. 1. For each
element e of S.[[WeakSetData]], do 1. If e is not ~empty~
and SameValue(e, value) is `true`, then 1. Replace the element
of S.[[WeakSetData]] whose value is e with an element whose
value is ~empty~. 1. Return `true`. 1. Return `false`.

The value ~empty~ is used as a specification device to indicate that an
entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakSet.prototype.has ( value )
-----------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Perform ?
RequireInternalSlot(S, [[WeakSetData]]). 1. If
CanBeHeldWeakly(value) is `false`, return `false`. 1. For each
element e of S.[[WeakSetData]], do 1. If e is not ~empty~
and SameValue(e, value) is `true`, return `true`. 1. Return
`false`.

WeakSet.prototype [ %Symbol.toStringTag% ]
------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"WeakSet"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of WeakSet Instances
-------------------------------

WeakSet instances are ordinary objects that inherit properties from the
WeakSet prototype. WeakSet instances also have a [[WeakSetData]]
internal slot.

Abstract Operations for Keyed Collections
-----------------------------------------

CanonicalizeKeyedCollectionKey ( key, )
-------------------------------------------------------------------------------------------------------

1. If key is `-0`\ :sub:`𝔽`, return `+0`\ :sub:`𝔽`. 1. Return
key.

25. Structured Data
===================

https://tc39.es/ecma262/multipage/structured-data.html
::

    25.1 ArrayBuffer Objects
        25.1.1 Notation
        25.1.2 Fixed-length and Resizable ArrayBuffer Objects
        25.1.3 Abstract Operations For ArrayBuffer Objects
            25.1.3.1 AllocateArrayBuffer ( constructor, byteLength [ , maxByteLength ] )
            25.1.3.2 ArrayBufferByteLength ( arrayBuffer, order )
            25.1.3.3 ArrayBufferCopyAndDetach ( arrayBuffer, newLength, preserveResizability )
            25.1.3.4 IsDetachedBuffer ( arrayBuffer )
            25.1.3.5 DetachArrayBuffer ( arrayBuffer [ , key ] )
            25.1.3.6 CloneArrayBuffer ( srcBuffer, srcByteOffset, srcLength )
            25.1.3.7 GetArrayBufferMaxByteLengthOption ( options )
            25.1.3.8 HostResizeArrayBuffer ( buffer, newByteLength )
            25.1.3.9 IsFixedLengthArrayBuffer ( arrayBuffer )
            25.1.3.10 IsUnsignedElementType ( type )
            25.1.3.11 IsUnclampedIntegerElementType ( type )
            25.1.3.12 IsBigIntElementType ( type )
            25.1.3.13 IsNoTearConfiguration ( type, order )
            25.1.3.14 RawBytesToNumeric ( type, rawBytes, isLittleEndian )
            25.1.3.15 GetRawBytesFromSharedBlock ( block, byteIndex, type, isTypedArray, order )
            25.1.3.16 GetValueFromBuffer ( arrayBuffer, byteIndex, type, isTypedArray, order [ , isLittleEndian ] )
            25.1.3.17 NumericToRawBytes ( type, value, isLittleEndian )
            25.1.3.18 SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isTypedArray, order [ , isLittleEndian ] )
            25.1.3.19 GetModifySetValueInBuffer ( arrayBuffer, byteIndex, type, value, op )
        25.1.4 The ArrayBuffer Constructor
            25.1.4.1 ArrayBuffer ( length [ , options ] )
        25.1.5 Properties of the ArrayBuffer Constructor
            25.1.5.1 ArrayBuffer.isView ( arg )
            25.1.5.2 ArrayBuffer.prototype
            25.1.5.3 get ArrayBuffer [ %Symbol.species% ]
        25.1.6 Properties of the ArrayBuffer Prototype Object
            25.1.6.1 get ArrayBuffer.prototype.byteLength
            25.1.6.2 ArrayBuffer.prototype.constructor
            25.1.6.3 get ArrayBuffer.prototype.detached
            25.1.6.4 get ArrayBuffer.prototype.maxByteLength
            25.1.6.5 get ArrayBuffer.prototype.resizable
            25.1.6.6 ArrayBuffer.prototype.resize ( newLength )
            25.1.6.7 ArrayBuffer.prototype.slice ( start, end )
            25.1.6.8 ArrayBuffer.prototype.transfer ( [ newLength ] )
            25.1.6.9 ArrayBuffer.prototype.transferToFixedLength ( [ newLength ] )
            25.1.6.10 ArrayBuffer.prototype [ %Symbol.toStringTag% ]
        25.1.7 Properties of ArrayBuffer Instances
        25.1.8 Resizable ArrayBuffer Guidelines
    25.2 SharedArrayBuffer Objects
        25.2.1 Fixed-length and Growable SharedArrayBuffer Objects
        25.2.2 Abstract Operations for SharedArrayBuffer Objects
            25.2.2.1 AllocateSharedArrayBuffer ( constructor, byteLength [ , maxByteLength ] )
            25.2.2.2 IsSharedArrayBuffer ( obj )
            25.2.2.3 HostGrowSharedArrayBuffer ( buffer, newByteLength )
        25.2.3 The SharedArrayBuffer Constructor
            25.2.3.1 SharedArrayBuffer ( length [ , options ] )
        25.2.4 Properties of the SharedArrayBuffer Constructor
            25.2.4.1 SharedArrayBuffer.prototype
            25.2.4.2 get SharedArrayBuffer [ %Symbol.species% ]
        25.2.5 Properties of the SharedArrayBuffer Prototype Object
            25.2.5.1 get SharedArrayBuffer.prototype.byteLength
            25.2.5.2 SharedArrayBuffer.prototype.constructor
            25.2.5.3 SharedArrayBuffer.prototype.grow ( newLength )
            25.2.5.4 get SharedArrayBuffer.prototype.growable
            25.2.5.5 get SharedArrayBuffer.prototype.maxByteLength
            25.2.5.6 SharedArrayBuffer.prototype.slice ( start, end )
            25.2.5.7 SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]
        25.2.6 Properties of SharedArrayBuffer Instances
        25.2.7 Growable SharedArrayBuffer Guidelines
    25.3 DataView Objects
        25.3.1 Abstract Operations For DataView Objects
            25.3.1.1 DataView With Buffer Witness Records
            25.3.1.2 MakeDataViewWithBufferWitnessRecord ( obj, order )
            25.3.1.3 GetViewByteLength ( viewRecord )
            25.3.1.4 IsViewOutOfBounds ( viewRecord )
            25.3.1.5 GetViewValue ( view, requestIndex, isLittleEndian, type )
            25.3.1.6 SetViewValue ( view, requestIndex, isLittleEndian, type, value )
        25.3.2 The DataView Constructor
            25.3.2.1 DataView ( buffer [ , byteOffset [ , byteLength ] ] )
        25.3.3 Properties of the DataView Constructor
            25.3.3.1 DataView.prototype
        25.3.4 Properties of the DataView Prototype Object
            25.3.4.1 get DataView.prototype.buffer
            25.3.4.2 get DataView.prototype.byteLength
            25.3.4.3 get DataView.prototype.byteOffset
            25.3.4.4 DataView.prototype.constructor
            25.3.4.5 DataView.prototype.getBigInt64 ( byteOffset [ , littleEndian ] )
            25.3.4.6 DataView.prototype.getBigUint64 ( byteOffset [ , littleEndian ] )
            25.3.4.7 DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )
            25.3.4.8 DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )
            25.3.4.9 DataView.prototype.getInt8 ( byteOffset )
            25.3.4.10 DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )
            25.3.4.11 DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )
            25.3.4.12 DataView.prototype.getUint8 ( byteOffset )
            25.3.4.13 DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )
            25.3.4.14 DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )
            25.3.4.15 DataView.prototype.setBigInt64 ( byteOffset, value [ , littleEndian ] )
            25.3.4.16 DataView.prototype.setBigUint64 ( byteOffset, value [ , littleEndian ] )
            25.3.4.17 DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )
            25.3.4.18 DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )
            25.3.4.19 DataView.prototype.setInt8 ( byteOffset, value )
            25.3.4.20 DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )
            25.3.4.21 DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )
            25.3.4.22 DataView.prototype.setUint8 ( byteOffset, value )
            25.3.4.23 DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )
            25.3.4.24 DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )
            25.3.4.25 DataView.prototype [ %Symbol.toStringTag% ]
        25.3.5 Properties of DataView Instances
    25.4 The Atomics Object
        25.4.1 Waiter Record
        25.4.2 WaiterList Records
        25.4.3 Abstract Operations for Atomics
            25.4.3.1 ValidateIntegerTypedArray ( typedArray, waitable )
            25.4.3.2 ValidateAtomicAccess ( taRecord, requestIndex )
            25.4.3.3 ValidateAtomicAccessOnIntegerTypedArray ( typedArray, requestIndex [ , waitable ] )
            25.4.3.4 RevalidateAtomicAccess ( typedArray, byteIndexInBuffer )
            25.4.3.5 GetWaiterList ( block, i )
            25.4.3.6 EnterCriticalSection ( WL )
            25.4.3.7 LeaveCriticalSection ( WL )
            25.4.3.8 AddWaiter ( WL, waiterRecord )
            25.4.3.9 RemoveWaiter ( WL, waiterRecord )
            25.4.3.10 RemoveWaiters ( WL, c )
            25.4.3.11 SuspendThisAgent ( WL, waiterRecord )
            25.4.3.12 NotifyWaiter ( WL, waiterRecord )
            25.4.3.13 EnqueueResolveInAgentJob ( agentSignifier, promiseCapability, resolution )
            25.4.3.14 DoWait ( mode, typedArray, index, value, timeout )
            25.4.3.15 EnqueueAtomicsWaitAsyncTimeoutJob ( WL, waiterRecord )
            25.4.3.16 AtomicCompareExchangeInSharedBlock ( block, byteIndexInBuffer, elementSize, expectedBytes, replacementBytes )
            25.4.3.17 AtomicReadModifyWrite ( typedArray, index, value, op )
            25.4.3.18 ByteListBitwiseOp ( op, xBytes, yBytes )
            25.4.3.19 ByteListEqual ( xBytes, yBytes )
        25.4.4 Atomics.add ( typedArray, index, value )
        25.4.5 Atomics.and ( typedArray, index, value )
        25.4.6 Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )
        25.4.7 Atomics.exchange ( typedArray, index, value )
        25.4.8 Atomics.isLockFree ( size )
        25.4.9 Atomics.load ( typedArray, index )
        25.4.10 Atomics.or ( typedArray, index, value )
        25.4.11 Atomics.store ( typedArray, index, value )
        25.4.12 Atomics.sub ( typedArray, index, value )
        25.4.13 Atomics.wait ( typedArray, index, value, timeout )
        25.4.14 Atomics.waitAsync ( typedArray, index, value, timeout )
        25.4.15 Atomics.notify ( typedArray, index, count )
        25.4.16 Atomics.xor ( typedArray, index, value )
        25.4.17 Atomics [ %Symbol.toStringTag% ]
    25.5 The JSON Object
        25.5.1 JSON.parse ( text [ , reviver ] )
            25.5.1.1 InternalizeJSONProperty ( holder, name, reviver )
        25.5.2 JSON.stringify ( value [ , replacer [ , space ] ] )
            25.5.2.1 JSON Serialization Record
            25.5.2.2 SerializeJSONProperty ( state, key, holder )
            25.5.2.3 QuoteJSONString ( value )
            25.5.2.4 UnicodeEscape ( C )
            25.5.2.5 SerializeJSONObject ( state, value )
            25.5.2.6 SerializeJSONArray ( state, value )
        25.5.3 JSON [ %Symbol.toStringTag% ]


ArrayBuffer Objects
-------------------

.. _notation-1:

Notation
--------

The descriptions below in this section, , and use the read-modify-write
modification function internal data structure.

A read-modify-write modification function is a mathematical function
that is represented as an abstract closure that takes two Lists of byte
values as arguments and returns a List of byte values. These abstract
closures satisfy all of the following properties:

- They perform all their algorithm steps atomically.
- Their individual algorithm steps are not observable.

To aid verifying that a read-modify-write modification function's
algorithm steps constitute a pure, mathematical function, the following
editorial conventions are recommended:

- They do not access, directly or transitively via invoked abstract
  operations and abstract closures, any language or specification values
  except their parameters and captured values.
- They do not return Completion Records.

Fixed-length and Resizable ArrayBuffer Objects
----------------------------------------------

A fixed-length ArrayBuffer is an ArrayBuffer whose byte length cannot
change after creation.

A resizable ArrayBuffer is an ArrayBuffer whose byte length may change
after creation via calls to .

The kind of ArrayBuffer object that is created depends on the arguments
passed to .

Abstract Operations For ArrayBuffer Objects
-------------------------------------------

AllocateArrayBuffer ( constructor: a constructor, byteLength: a non-negative integer, optional maxByteLength: a non-negative integer or ~empty~, )
--------------------------------------------------------------------------------------------------------------------------------------------------

description
   It is used to create an ArrayBuffer.

1. Let slots be « [[ArrayBufferData]], [[ArrayBufferByteLength]],
[[ArrayBufferDetachKey]] ». 1. If maxByteLength is present and
maxByteLength is not ~empty~, let allocatingResizableBuffer be
`true`; otherwise let allocatingResizableBuffer be `false`. 1.
If allocatingResizableBuffer is `true`, then 1. If byteLength
> maxByteLength, throw a `RangeError` exception. 1. Append
[[ArrayBufferMaxByteLength]] to slots. 1. Let obj be ?
OrdinaryCreateFromConstructor(constructor,
`"%ArrayBuffer.prototype%"`, slots). 1. Let block be ?
CreateByteDataBlock(byteLength). 1. Set obj.[[ArrayBufferData]]
to block. 1. Set obj.[[ArrayBufferByteLength]] to
byteLength. 1. If allocatingResizableBuffer is `true`, then 1.
If it is not possible to create a Data Block block consisting of
maxByteLength bytes, throw a `RangeError` exception. 1. NOTE:
Resizable ArrayBuffers are designed to be implementable with in-place
growth. Implementations may throw if, for example, virtual memory cannot
be reserved up front. 1. Set obj.[[ArrayBufferMaxByteLength]] to
maxByteLength. 1. Return obj.

ArrayBufferByteLength ( arrayBuffer: an ArrayBuffer or SharedArrayBuffer, order: ~seq-cst~ or ~unordered~, ): a non-negative integer
--------------------------------------------------------------------------------------------------------------------------------------------

1. If IsSharedArrayBuffer(arrayBuffer) is `true` and
arrayBuffer has an [[ArrayBufferByteLengthData]] internal slot, then
1. Let bufferByteLengthBlock be
arrayBuffer.[[ArrayBufferByteLengthData]]. 1. Let rawLength be
GetRawBytesFromSharedBlock(bufferByteLengthBlock, 0, ~biguint64~,
`true`, order). 1. Let isLittleEndian be the value of the
[[LittleEndian]] field of the surrounding agent's Agent Record. 1.
Return ℝ(RawBytesToNumeric(~biguint64~, rawLength,
isLittleEndian)). 1. Assert: IsDetachedBuffer(arrayBuffer) is
`false`. 1. Return arrayBuffer.[[ArrayBufferByteLength]].

ArrayBufferCopyAndDetach ( arrayBuffer, newLength, preserveResizability: ~preserve-resizability~ or ~fixed-length~, )
---------------------------------------------------------------------------------------------------------------------

1. Perform ? RequireInternalSlot(arrayBuffer, [[ArrayBufferData]]).
1. If IsSharedArrayBuffer(arrayBuffer) is `true`, throw a
`TypeError` exception. 1. If newLength is `undefined`, then 1.
Let newByteLength be arrayBuffer.[[ArrayBufferByteLength]]. 1.
Else, 1. Let newByteLength be ? ToIndex(newLength). 1. If
IsDetachedBuffer(arrayBuffer) is `true`, throw a `TypeError`
exception. 1. If preserveResizability is ~preserve-resizability~ and
IsFixedLengthArrayBuffer(arrayBuffer) is `false`, then 1. Let
newMaxByteLength be arrayBuffer.[[ArrayBufferMaxByteLength]]. 1.
Else, 1. Let newMaxByteLength be ~empty~. 1. If
arrayBuffer.[[ArrayBufferDetachKey]] is not `undefined`, throw a
`TypeError` exception. 1. Let newBuffer be ?
AllocateArrayBuffer(%ArrayBuffer%, newByteLength,
newMaxByteLength). 1. Let copyLength be min(newByteLength,
arrayBuffer.[[ArrayBufferByteLength]]). 1. Let fromBlock be
arrayBuffer.[[ArrayBufferData]]. 1. Let toBlock be
newBuffer.[[ArrayBufferData]]. 1. Perform
CopyDataBlockBytes(toBlock, 0, fromBlock, 0, copyLength). 1.
NOTE: Neither creation of the new Data Block nor copying from the old
Data Block are observable. Implementations may implement this method as
a zero-copy move or a `realloc`. 1. Perform !
DetachArrayBuffer(arrayBuffer). 1. Return newBuffer.

IsDetachedBuffer ( arrayBuffer: an ArrayBuffer or a SharedArrayBuffer, ): a Boolean
---------------------------------------------------------------------------------------

1. If arrayBuffer.[[ArrayBufferData]] is `null`, return `true`.
1. Return `false`.

DetachArrayBuffer ( arrayBuffer: an ArrayBuffer, optional key: anything, )
--------------------------------------------------------------------------

skip global checks
   true

1. Assert: IsSharedArrayBuffer(arrayBuffer) is `false`. 1. If
key is not present, set key to `undefined`. 1. If
arrayBuffer.[[ArrayBufferDetachKey]] is not key, throw a
`TypeError` exception. 1. Set arrayBuffer.[[ArrayBufferData]] to
`null`. 1. Set arrayBuffer.[[ArrayBufferByteLength]] to 0. 1.
Return ~unused~.

Detaching an ArrayBuffer instance disassociates the Data Block used as
its backing store from the instance and sets the byte length of the
buffer to 0.

CloneArrayBuffer ( srcBuffer: an ArrayBuffer or a SharedArrayBuffer, srcByteOffset: a non-negative integer, srcLength: a non-negative integer, )
------------------------------------------------------------------------------------------------------------------------------------------------

description
   It creates a new ArrayBuffer whose data is a copy of srcBuffer's
   data over the range starting at srcByteOffset and continuing for
   srcLength bytes.

1. Assert: IsDetachedBuffer(srcBuffer) is `false`. 1. Let
targetBuffer be ? AllocateArrayBuffer(%ArrayBuffer%, srcLength).
1. Let srcBlock be srcBuffer.[[ArrayBufferData]]. 1. Let
targetBlock be targetBuffer.[[ArrayBufferData]]. 1. Perform
CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset,
srcLength). 1. Return targetBuffer.

GetArrayBufferMaxByteLengthOption ( options, )
----------------------------------------------

1. If options is not an Object, return ~empty~. 1. Let
maxByteLength be ? Get(options, `"maxByteLength"`). 1. If
maxByteLength is `undefined`, return ~empty~. 1. Return ?
ToIndex(maxByteLength).

HostResizeArrayBuffer ( buffer: an ArrayBuffer, newByteLength: a non-negative integer, )
----------------------------------------------------------------------------------------

description
   It gives the host an opportunity to perform implementation-defined
   resizing of buffer. If the host chooses not to handle resizing of
   buffer, it may return ~unhandled~ for the default behaviour.

The implementation of HostResizeArrayBuffer must conform to the
following requirements:

- The abstract operation does not detach buffer.
- If the abstract operation completes normally with ~handled~,
  buffer.[[ArrayBufferByteLength]] is newByteLength.

The default implementation of HostResizeArrayBuffer is to return
NormalCompletion(~unhandled~).

IsFixedLengthArrayBuffer ( arrayBuffer: an ArrayBuffer or a SharedArrayBuffer, ): a Boolean
-----------------------------------------------------------------------------------------------

1. If arrayBuffer has an [[ArrayBufferMaxByteLength]] internal slot,
return `false`. 1. Return `true`.

IsUnsignedElementType ( type: a TypedArray element type, ): a Boolean
-------------------------------------------------------------------------

description
   It verifies if the argument type is an unsigned TypedArray
   element type.

1. If type is one of ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, or
~biguint64~, return `true`. 1. Return `false`.

IsUnclampedIntegerElementType ( type: a TypedArray element type, ): a Boolean
---------------------------------------------------------------------------------

description
   It verifies if the argument type is an Integer TypedArray element
   type not including ~uint8clamped~.

1. If type is one of ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, or
~uint32~, return `true`. 1. Return `false`.

IsBigIntElementType ( type: a TypedArray element type, ): a Boolean
-----------------------------------------------------------------------

description
   It verifies if the argument type is a BigInt TypedArray element
   type.

1. If type is either ~biguint64~ or ~bigint64~, return `true`. 1.
Return `false`.

IsNoTearConfiguration ( type: a TypedArray element type, order: ~seq-cst~, ~unordered~, or ~init~, ): a Boolean
-----------------------------------------------------------------------------------------------------------------------

1. If IsUnclampedIntegerElementType(type) is `true`, return
`true`. 1. If IsBigIntElementType(type) is `true` and order
is neither ~init~ nor ~unordered~, return `true`. 1. Return `false`.

RawBytesToNumeric ( type: a TypedArray element type, rawBytes: a List of byte values, isLittleEndian: a Boolean, ): a Number or a BigInt
----------------------------------------------------------------------------------------------------------------------------------------------------

1. Let elementSize be the Element Size value specified in for
Element Type type. 1. If isLittleEndian is `false`, reverse
the order of the elements of rawBytes. 1. If type is ~float32~,
then 1. Let value be the byte elements of rawBytes concatenated
and interpreted as a little-endian bit string encoding of an IEEE
754-2019 binary32 value. 1. If value is an IEEE 754-2019 binary32
NaN value, return the `NaN` Number value. 1. Return the Number value
that corresponds to value. 1. If type is ~float64~, then 1. Let
value be the byte elements of rawBytes concatenated and
interpreted as a little-endian bit string encoding of an IEEE 754-2019
binary64 value. 1. If value is an IEEE 754-2019 binary64 NaN value,
return the `NaN` Number value. 1. Return the Number value that
corresponds to value. 1. If IsUnsignedElementType(type) is
`true`, then 1. Let intValue be the byte elements of rawBytes
concatenated and interpreted as a bit string encoding of an unsigned
little-endian binary number. 1. Else, 1. Let intValue be the byte
elements of rawBytes concatenated and interpreted as a bit string
encoding of a binary little-endian two's complement number of bit length
elementSize × 8. 1. If IsBigIntElementType(type) is `true`,
return the BigInt value that corresponds to intValue. 1. Otherwise,
return the Number value that corresponds to intValue.

GetRawBytesFromSharedBlock ( block: a Shared Data Block, byteIndex: a non-negative integer, type: a TypedArray element type, isTypedArray: a Boolean, order: ~seq-cst~ or ~unordered~, ): a List of byte values
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let elementSize be the Element Size value specified in for
Element Type type. 1. Let execution be the
[[CandidateExecution]] field of the surrounding agent's Agent Record. 1.
Let eventsRecord be the Agent Events Record of
execution.[[EventsRecords]] whose [[AgentSignifier]] is
AgentSignifier(). 1. If isTypedArray is `true` and
IsNoTearConfiguration(type, order) is `true`, let noTear
be `true`; otherwise let noTear be `false`. 1. Let rawValue
be a List of length elementSize whose elements are
nondeterministically chosen byte values. 1. NOTE: In implementations,
rawValue is the result of a non-atomic or atomic read instruction on
the underlying hardware. The nondeterminism is a semantic prescription
of the memory model to describe observable behaviour of hardware with
weak consistency. 1. Let readEvent be ReadSharedMemory { [[Order]]:
order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]:
byteIndex, [[ElementSize]]: elementSize }. 1. Append
readEvent to eventsRecord.[[EventList]]. 1. Append Chosen Value
Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to
execution.[[ChosenValues]]. 1. Return rawValue.

GetValueFromBuffer ( arrayBuffer: an ArrayBuffer or SharedArrayBuffer, byteIndex: a non-negative integer, type: a TypedArray element type, isTypedArray: a Boolean, order: ~seq-cst~ or ~unordered~, optional isLittleEndian: a Boolean, ): a Number or a BigInt
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: IsDetachedBuffer(arrayBuffer) is `false`. 1. Assert:
There are sufficient bytes in arrayBuffer starting at byteIndex
to represent a value of type. 1. Let block be
arrayBuffer.[[ArrayBufferData]]. 1. Let elementSize be the
Element Size value specified in for Element Type type. 1. If
IsSharedArrayBuffer(arrayBuffer) is `true`, then 1. Assert:
block is a Shared Data Block. 1. Let rawValue be
GetRawBytesFromSharedBlock(block, byteIndex, type,
isTypedArray, order). 1. Else, 1. Let rawValue be a List
whose elements are bytes from block at indices in the interval from
byteIndex (inclusive) to byteIndex + elementSize
(exclusive). 1. Assert: The number of elements in rawValue is
elementSize. 1. If isLittleEndian is not present, set
isLittleEndian to the value of the [[LittleEndian]] field of the
surrounding agent's Agent Record. 1. Return RawBytesToNumeric(type,
rawValue, isLittleEndian).

NumericToRawBytes ( type: a TypedArray element type, value: a Number or a BigInt, isLittleEndian: a Boolean, ): a List of byte values
-------------------------------------------------------------------------------------------------------------------------------------------------

1. If type is ~float32~, then 1. Let rawBytes be a List whose
elements are the 4 bytes that are the result of converting value to
IEEE 754-2019 binary32 format using roundTiesToEven mode. The bytes are
arranged in little endian order. If value is `NaN`, rawBytes
may be set to any implementation chosen IEEE 754-2019 binary32 format
Not-a-Number encoding. An implementation must always choose the same
encoding for each implementation distinguishable `NaN` value. 1. Else
if type is ~float64~, then 1. Let rawBytes be a List whose
elements are the 8 bytes that are the IEEE 754-2019 binary64 format
encoding of value. The bytes are arranged in little endian order. If
value is `NaN`, rawBytes may be set to any implementation
chosen IEEE 754-2019 binary64 format Not-a-Number encoding. An
implementation must always choose the same encoding for each
implementation distinguishable `NaN` value. 1. Else, 1. Let n be
the Element Size value specified in for Element Type type. 1. Let
conversionOperation be the abstract operation named in the
Conversion Operation column in for Element Type type. 1. Let
intValue be ℝ(conversionOperation(value)). 1. If
intValue ≥ 0, then 1. Let rawBytes be a List whose elements are
the n-byte binary encoding of intValue. The bytes are ordered in
little endian order. 1. Else, 1. Let rawBytes be a List whose
elements are the n-byte binary two's complement encoding of
intValue. The bytes are ordered in little endian order. 1. If
isLittleEndian is `false`, reverse the order of the elements of
rawBytes. 1. Return rawBytes.

SetValueInBuffer ( arrayBuffer: an ArrayBuffer or SharedArrayBuffer, byteIndex: a non-negative integer, type: a TypedArray element type, value: a Number or a BigInt, isTypedArray: a Boolean, order: ~seq-cst~, ~unordered~, or ~init~, optional isLittleEndian: a Boolean, ): ~unused~
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: IsDetachedBuffer(arrayBuffer) is `false`. 1. Assert:
There are sufficient bytes in arrayBuffer starting at byteIndex
to represent a value of type. 1. Assert: value is a BigInt if
IsBigIntElementType(type) is `true`; otherwise, value is a
Number. 1. Let block be arrayBuffer.[[ArrayBufferData]]. 1. Let
elementSize be the Element Size value specified in for Element Type
type. 1. If isLittleEndian is not present, set
isLittleEndian to the value of the [[LittleEndian]] field of the
surrounding agent's Agent Record. 1. Let rawBytes be
NumericToRawBytes(type, value, isLittleEndian). 1. If
IsSharedArrayBuffer(arrayBuffer) is `true`, then 1. Let
execution be the [[CandidateExecution]] field of the surrounding
agent's Agent Record. 1. Let eventsRecord be the Agent Events Record
of execution.[[EventsRecords]] whose [[AgentSignifier]] is
AgentSignifier(). 1. If isTypedArray is `true` and
IsNoTearConfiguration(type, order) is `true`, let noTear
be `true`; otherwise let noTear be `false`. 1. Append
WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear,
[[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]:
elementSize, [[Payload]]: rawBytes } to
eventsRecord.[[EventList]]. 1. Else, 1. Store the individual bytes
of rawBytes into block, starting at block[byteIndex]. 1.
Return ~unused~.

GetModifySetValueInBuffer ( arrayBuffer: an ArrayBuffer or a SharedArrayBuffer, byteIndex: a non-negative integer, type: a TypedArray element type, value: a Number or a BigInt, op: a read-modify-write modification function, ): a Number or a BigInt
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: IsDetachedBuffer(arrayBuffer) is `false`. 1. Assert:
There are sufficient bytes in arrayBuffer starting at byteIndex
to represent a value of type. 1. Assert: value is a BigInt if
IsBigIntElementType(type) is `true`; otherwise, value is a
Number. 1. Let block be arrayBuffer.[[ArrayBufferData]]. 1. Let
elementSize be the Element Size value specified in for Element Type
type. 1. Let isLittleEndian be the value of the [[LittleEndian]]
field of the surrounding agent's Agent Record. 1. Let rawBytes be
NumericToRawBytes(type, value, isLittleEndian). 1. If
IsSharedArrayBuffer(arrayBuffer) is `true`, then 1. Let
execution be the [[CandidateExecution]] field of the surrounding
agent's Agent Record. 1. Let eventsRecord be the Agent Events Record
of execution.[[EventsRecords]] whose [[AgentSignifier]] is
AgentSignifier(). 1. Let rawBytesRead be a List of length
elementSize whose elements are nondeterministically chosen byte
values. 1. NOTE: In implementations, rawBytesRead is the result of a
load-link, of a load-exclusive, or of an operand of a read-modify-write
instruction on the underlying hardware. The nondeterminism is a semantic
prescription of the memory model to describe observable behaviour of
hardware with weak consistency. 1. Let rmwEvent be
ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]:
`true`, [[Block]]: block, [[ByteIndex]]: byteIndex,
[[ElementSize]]: elementSize, [[Payload]]: rawBytes,
[[ModifyOp]]: op }. 1. Append rmwEvent to
eventsRecord.[[EventList]]. 1. Append Chosen Value Record {
[[Event]]: rmwEvent, [[ChosenValue]]: rawBytesRead } to
execution.[[ChosenValues]]. 1. Else, 1. Let rawBytesRead be a
List of length elementSize whose elements are the sequence of
elementSize bytes starting with block[byteIndex]. 1. Let
rawBytesModified be op(rawBytesRead, rawBytes). 1. Store
the individual bytes of rawBytesModified into block, starting at
block[byteIndex]. 1. Return RawBytesToNumeric(type,
rawBytesRead, isLittleEndian).

The ArrayBuffer Constructor
---------------------------

The ArrayBuffer constructor:

- is %ArrayBuffer%.
- is the initial value of the `"ArrayBuffer"` property of the global
  object.
- creates and initializes a new ArrayBuffer when called as a
  constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  ArrayBuffer behaviour must include a `super` call to the ArrayBuffer
  constructor to create and initialize subclass instances with the
  internal state necessary to support the `ArrayBuffer.prototype`
  built-in methods.

ArrayBuffer ( length [ , options ] )
--------------------------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Let byteLength be ? ToIndex(length). 1. Let
requestedMaxByteLength be ?
GetArrayBufferMaxByteLengthOption(options). 1. Return ?
AllocateArrayBuffer(NewTarget, byteLength,
requestedMaxByteLength).

Properties of the ArrayBuffer Constructor
-----------------------------------------

The ArrayBuffer constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

ArrayBuffer.isView ( arg )
------------------------------

This function performs the following steps when called:

1. If arg is not an Object, return `false`. 1. If arg has a
[[ViewedArrayBuffer]] internal slot, return `true`. 1. Return
`false`.

ArrayBuffer.prototype
---------------------

The initial value of `ArrayBuffer.prototype` is the ArrayBuffer
prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

get ArrayBuffer [ %Symbol.species% ]
------------------------------------

`ArrayBuffer[%Symbol.species%]` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

normally uses its `this` value's constructor to create a derived
object. However, a subclass constructor may over-ride that default
behaviour for the method by redefining its %Symbol.species% property.

Properties of the ArrayBuffer Prototype Object
----------------------------------------------

The ArrayBuffer prototype object:

- is %ArrayBuffer.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]]
  internal slot.

get ArrayBuffer.prototype.byteLength
------------------------------------

`ArrayBuffer.prototype.byteLength` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `true`, throw a `TypeError` exception.
1. If IsDetachedBuffer(O) is `true`, return `+0`\ :sub:`𝔽`. 1.
Let length be O.[[ArrayBufferByteLength]]. 1. Return
𝔽(length).

ArrayBuffer.prototype.constructor
---------------------------------

The initial value of `ArrayBuffer.prototype.constructor` is
%ArrayBuffer%.

get ArrayBuffer.prototype.detached
----------------------------------

`ArrayBuffer.prototype.detached` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `true`, throw a `TypeError` exception.
1. Return IsDetachedBuffer(O).

get ArrayBuffer.prototype.maxByteLength
---------------------------------------

`ArrayBuffer.prototype.maxByteLength` is an accessor property whose
set accessor function is `undefined`. Its get accessor function
performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `true`, throw a `TypeError` exception.
1. If IsDetachedBuffer(O) is `true`, return `+0`\ :sub:`𝔽`. 1.
If IsFixedLengthArrayBuffer(O) is `true`, then 1. Let length
be O.[[ArrayBufferByteLength]]. 1. Else, 1. Let length be
O.[[ArrayBufferMaxByteLength]]. 1. Return 𝔽(length).

get ArrayBuffer.prototype.resizable
-----------------------------------

`ArrayBuffer.prototype.resizable` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `true`, throw a `TypeError` exception.
1. If IsFixedLengthArrayBuffer(O) is `false`, return `true`;
otherwise return `false`.

ArrayBuffer.prototype.resize ( newLength )
----------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferMaxByteLength]]). 1. If
IsSharedArrayBuffer(O) is `true`, throw a `TypeError` exception.
1. Let newByteLength be ? ToIndex(newLength). 1. If
IsDetachedBuffer(O) is `true`, throw a `TypeError` exception. 1.
If newByteLength > O.[[ArrayBufferMaxByteLength]], throw a
`RangeError` exception. 1. Let hostHandled be ?
HostResizeArrayBuffer(O, newByteLength). 1. If hostHandled
is ~handled~, return `undefined`. 1. Let oldBlock be
O.[[ArrayBufferData]]. 1. Let newBlock be ?
CreateByteDataBlock(newByteLength). 1. Let copyLength be
min(newByteLength, O.[[ArrayBufferByteLength]]). 1. Perform
CopyDataBlockBytes(newBlock, 0, oldBlock, 0, copyLength). 1.
NOTE: Neither creation of the new Data Block nor copying from the old
Data Block are observable. Implementations may implement this method as
in-place growth or shrinkage. 1. Set O.[[ArrayBufferData]] to
newBlock. 1. Set O.[[ArrayBufferByteLength]] to
newByteLength. 1. Return `undefined`.

ArrayBuffer.prototype.slice ( start, end )
--------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `true`, throw a `TypeError` exception.
1. If IsDetachedBuffer(O) is `true`, throw a `TypeError`
exception. 1. Let len be O.[[ArrayBufferByteLength]]. 1. Let
relativeStart be ? ToIntegerOrInfinity(start). 1. If
relativeStart = -∞, let first be 0. 1. Else if relativeStart
< 0, let first be max(len + relativeStart, 0). 1. Else, let
first be min(relativeStart, len). 1. If end is
`undefined`, let relativeEnd be len; else let relativeEnd
be ? ToIntegerOrInfinity(end). 1. If relativeEnd = -∞, let
final be 0. 1. Else if relativeEnd < 0, let final be
max(len + relativeEnd, 0). 1. Else, let final be
min(relativeEnd, len). 1. Let newLen be max(final -
first, 0). 1. Let ctor be ? SpeciesConstructor(O,
%ArrayBuffer%). 1. Let new be ? Construct(ctor, « 𝔽(newLen)
»). 1. Perform ? RequireInternalSlot(new, [[ArrayBufferData]]). 1.
If IsSharedArrayBuffer(new) is `true`, throw a `TypeError`
exception. 1. If IsDetachedBuffer(new) is `true`, throw a
`TypeError` exception. 1. If SameValue(new, O) is `true`,
throw a `TypeError` exception. 1. If new.[[ArrayBufferByteLength]]
< newLen, throw a `TypeError` exception. 1. NOTE: Side-effects of
the above steps may have detached or resized O. 1. If
IsDetachedBuffer(O) is `true`, throw a `TypeError` exception. 1.
Let fromBuf be O.[[ArrayBufferData]]. 1. Let toBuf be
new.[[ArrayBufferData]]. 1. Let currentLen be
O.[[ArrayBufferByteLength]]. 1. If first < currentLen, then
1. Let count be min(newLen, currentLen - first). 1.
Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first,
count). 1. Return new.

ArrayBuffer.prototype.transfer ( [ newLength ] )
----------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Return ?
ArrayBufferCopyAndDetach(O, newLength, ~preserve-resizability~).

ArrayBuffer.prototype.transferToFixedLength ( [ newLength ] )
-----------------------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Return ?
ArrayBufferCopyAndDetach(O, newLength, ~fixed-length~).

ArrayBuffer.prototype [ %Symbol.toStringTag% ]
----------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"ArrayBuffer"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of ArrayBuffer Instances
-----------------------------------

ArrayBuffer instances inherit properties from the ArrayBuffer prototype
object. ArrayBuffer instances each have an [[ArrayBufferData]] internal
slot, an [[ArrayBufferByteLength]] internal slot, and an
[[ArrayBufferDetachKey]] internal slot. ArrayBuffer instances which are
resizable each have an [[ArrayBufferMaxByteLength]] internal slot.

ArrayBuffer instances whose [[ArrayBufferData]] is `null` are
considered to be detached and all operators to access or modify data
contained in the ArrayBuffer instance will fail.

ArrayBuffer instances whose [[ArrayBufferDetachKey]] is set to a value
other than `undefined` need to have all DetachArrayBuffer calls
passing that same "detach key" as an argument, otherwise a TypeError
will result. This internal slot is only ever set by certain embedding
environments, not by algorithms in this specification.

Resizable ArrayBuffer Guidelines
--------------------------------

The following are guidelines for ECMAScript programmers working with
resizable ArrayBuffer.

We recommend that programs be tested in their deployment environments
where possible. The amount of available physical memory differs greatly
between hardware devices. Similarly, virtual memory subsystems also
differ greatly between hardware devices as well as operating systems. An
application that runs without out-of-memory errors on a 64-bit desktop
web browser could run out of memory on a 32-bit mobile web browser.

When choosing a value for the `"maxByteLength"` option for resizable
ArrayBuffer, we recommend that the smallest possible size for the
application be chosen. We recommend that `"maxByteLength"` does not
exceed 1,073,741,824 (2\ :sup:`30` bytes or 1GiB).

Please note that successfully constructing a resizable ArrayBuffer for a
particular maximum size does not guarantee that future resizes will
succeed.

The following are guidelines for ECMAScript implementers implementing
resizable ArrayBuffer.

Resizable ArrayBuffer can be implemented as copying upon resize, as
in-place growth via reserving virtual memory up front, or as a
combination of both for different values of the constructor's
`"maxByteLength"` option.

If a host is multi-tenanted (i.e. it runs many ECMAScript applications
simultaneously), such as a web browser, and its implementations choose
to implement in-place growth by reserving virtual memory, we recommend
that both 32-bit and 64-bit implementations throw for values of
`"maxByteLength"` ≥ 1GiB to 1.5GiB. This is to reduce the likelihood a
single application can exhaust the virtual memory address space and to
reduce interoperability risk.

If a host does not have virtual memory, such as those running on
embedded devices without an MMU, or if a host only implements resizing
by copying, it may accept any Number value for the `"maxByteLength"`
option. However, we recommend a `RangeError` be thrown if a memory
block of the requested size can never be allocated. For example, if the
requested size is greater than the maximum amount of usable memory on
the device.

SharedArrayBuffer Objects
-------------------------

Fixed-length and Growable SharedArrayBuffer Objects
---------------------------------------------------

A fixed-length SharedArrayBuffer is a SharedArrayBuffer whose byte
length cannot change after creation.

A growable SharedArrayBuffer is a SharedArrayBuffer whose byte length
may increase after creation via calls to .

The kind of SharedArrayBuffer object that is created depends on the
arguments passed to .

Abstract Operations for SharedArrayBuffer Objects
-------------------------------------------------

AllocateSharedArrayBuffer ( constructor: a constructor, byteLength: a non-negative integer, optional maxByteLength: a non-negative integer or ~empty~, )
--------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It is used to create a SharedArrayBuffer.

1. Let slots be « [[ArrayBufferData]] ». 1. If maxByteLength is
present and maxByteLength is not ~empty~, let
allocatingGrowableBuffer be `true`; otherwise let
allocatingGrowableBuffer be `false`. 1. If
allocatingGrowableBuffer is `true`, then 1. If byteLength >
maxByteLength, throw a `RangeError` exception. 1. Append
[[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to
slots. 1. Else, 1. Append [[ArrayBufferByteLength]] to slots. 1.
Let obj be ? OrdinaryCreateFromConstructor(constructor,
`"%SharedArrayBuffer.prototype%"`, slots). 1. If
allocatingGrowableBuffer is `true`, let allocLength be
maxByteLength; otherwise let allocLength be byteLength. 1.
Let block be ? CreateSharedByteDataBlock(allocLength). 1. Set
obj.[[ArrayBufferData]] to block. 1. If
allocatingGrowableBuffer is `true`, then 1. Assert: byteLength
≤ maxByteLength. 1. Let byteLengthBlock be ?
CreateSharedByteDataBlock(8). 1. Perform
SetValueInBuffer(byteLengthBlock, 0, ~biguint64~, ℤ(byteLength),
`true`, ~seq-cst~). 1. Set obj.[[ArrayBufferByteLengthData]] to
byteLengthBlock. 1. Set obj.[[ArrayBufferMaxByteLength]] to
maxByteLength. 1. Else, 1. Set obj.[[ArrayBufferByteLength]] to
byteLength. 1. Return obj.

IsSharedArrayBuffer ( obj: an ArrayBuffer or a SharedArrayBuffer, ): a Boolean
----------------------------------------------------------------------------------

description
   It tests whether an object is an ArrayBuffer, a SharedArrayBuffer, or
   a subtype of either.

1. Let bufferData be obj.[[ArrayBufferData]]. 1. If
bufferData is `null`, return `false`. 1. If bufferData is a
Data Block, return `false`. 1. Assert: bufferData is a Shared Data
Block. 1. Return `true`.

HostGrowSharedArrayBuffer ( buffer: a SharedArrayBuffer, newByteLength: a non-negative integer, )
-------------------------------------------------------------------------------------------------

description
   It gives the host an opportunity to perform implementation-defined
   growing of buffer. If the host chooses not to handle growing of
   buffer, it may return ~unhandled~ for the default behaviour.

The implementation of HostGrowSharedArrayBuffer must conform to the
following requirements:

- If the abstract operation does not complete normally with ~unhandled~,
  and newByteLength < the current byte length of the buffer or
  newByteLength > buffer.[[ArrayBufferMaxByteLength]], throw a
  `RangeError` exception.
- Let isLittleEndian be the value of the [[LittleEndian]] field of
  the surrounding agent's Agent Record. If the abstract operation
  completes normally with ~handled~, a WriteSharedMemory or
  ReadModifyWriteSharedMemory event whose [[Order]] is ~seq-cst~,
  [[Payload]] is NumericToRawBytes(~biguint64~, newByteLength,
  isLittleEndian), [[Block]] is
  buffer.[[ArrayBufferByteLengthData]], [[ByteIndex]] is 0, and
  [[ElementSize]] is 8 is added to the surrounding agent's candidate
  execution such that racing calls to
  `SharedArrayBuffer.prototype.grow` are not "lost", i.e. silently do
  nothing.

The second requirement above is intentionally vague about how or when
the current byte length of buffer is read. Because the byte length
must be updated via an atomic read-modify-write operation on the
underlying hardware, architectures that use load-link/store-conditional
or load-exclusive/store-exclusive instruction pairs may wish to keep the
paired instructions close in the instruction stream. As such,
SharedArrayBuffer.prototype.grow itself does not perform bounds checking
on newByteLength before calling HostGrowSharedArrayBuffer, nor is
there a requirement on when the current byte length is read.

This is in contrast with HostResizeArrayBuffer, which is guaranteed that
the value of newByteLength is ≥ 0 and ≤
buffer.[[ArrayBufferMaxByteLength]].

The default implementation of HostGrowSharedArrayBuffer is to return
NormalCompletion(~unhandled~).

The SharedArrayBuffer Constructor
---------------------------------

The SharedArrayBuffer constructor:

- is %SharedArrayBuffer%.
- is the initial value of the `"SharedArrayBuffer"` property of the
  global object, if that property is present (see below).
- creates and initializes a new SharedArrayBuffer when called as a
  constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  SharedArrayBuffer behaviour must include a `super` call to the
  SharedArrayBuffer constructor to create and initialize subclass
  instances with the internal state necessary to support the
  `SharedArrayBuffer.prototype` built-in methods.

Whenever a host does not provide concurrent access to SharedArrayBuffers
it may omit the `"SharedArrayBuffer"` property of the global object.

Unlike an `ArrayBuffer`, a `SharedArrayBuffer` cannot become
detached, and its internal [[ArrayBufferData]] slot is never `null`.

SharedArrayBuffer ( length [ , options ] )
--------------------------------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Let byteLength be ? ToIndex(length). 1. Let
requestedMaxByteLength be ?
GetArrayBufferMaxByteLengthOption(options). 1. Return ?
AllocateSharedArrayBuffer(NewTarget, byteLength,
requestedMaxByteLength).

Properties of the SharedArrayBuffer Constructor
-----------------------------------------------

The SharedArrayBuffer constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

SharedArrayBuffer.prototype
---------------------------

The initial value of `SharedArrayBuffer.prototype` is the
SharedArrayBuffer prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

get SharedArrayBuffer [ %Symbol.species% ]
------------------------------------------

`SharedArrayBuffer[%Symbol.species%]` is an accessor property whose
set accessor function is `undefined`. Its get accessor function
performs the following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

Properties of the SharedArrayBuffer Prototype Object
----------------------------------------------------

The SharedArrayBuffer prototype object:

- is %SharedArrayBuffer.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]]
  internal slot.

get SharedArrayBuffer.prototype.byteLength
------------------------------------------

`SharedArrayBuffer.prototype.byteLength` is an accessor property whose
set accessor function is `undefined`. Its get accessor function
performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `false`, throw a `TypeError`
exception. 1. Let length be ArrayBufferByteLength(O, ~seq-cst~).
1. Return 𝔽(length).

SharedArrayBuffer.prototype.constructor
---------------------------------------

The initial value of `SharedArrayBuffer.prototype.constructor` is
%SharedArrayBuffer%.

SharedArrayBuffer.prototype.grow ( newLength )
--------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferMaxByteLength]]). 1. If
IsSharedArrayBuffer(O) is `false`, throw a `TypeError`
exception. 1. Let newByteLength be ? ToIndex(newLength). 1. Let
hostHandled be ? HostGrowSharedArrayBuffer(O,
newByteLength). 1. If hostHandled is ~handled~, return
`undefined`. 1. Let isLittleEndian be the value of the
[[LittleEndian]] field of the surrounding agent's Agent Record. 1. Let
byteLengthBlock be O.[[ArrayBufferByteLengthData]]. 1. Let
currentByteLengthRawBytes be
GetRawBytesFromSharedBlock(byteLengthBlock, 0, ~biguint64~,
`true`, ~seq-cst~). 1. Let newByteLengthRawBytes be
NumericToRawBytes(~biguint64~, ℤ(newByteLength),
isLittleEndian). 1. Repeat, 1. NOTE: This is a compare-and-exchange
loop to ensure that parallel, racing grows of the same buffer are
totally ordered, are not lost, and do not silently do nothing. The loop
exits if it was able to attempt to grow uncontended. 1. Let
currentByteLength be ℝ(RawBytesToNumeric(~biguint64~,
currentByteLengthRawBytes, isLittleEndian)). 1. If
newByteLength = currentByteLength, return `undefined`. 1. If
newByteLength < currentByteLength or newByteLength >
O.[[ArrayBufferMaxByteLength]], throw a `RangeError` exception. 1.
Let byteLengthDelta be newByteLength - currentByteLength. 1.
If it is impossible to create a new Shared Data Block value consisting
of byteLengthDelta bytes, throw a `RangeError` exception. 1. NOTE:
No new Shared Data Block is constructed and used here. The observable
behaviour of growable SharedArrayBuffers is specified by allocating a
max-sized Shared Data Block at construction time, and this step captures
the requirement that implementations that run out of memory must throw a
`RangeError`. 1. Let readByteLengthRawBytes be
AtomicCompareExchangeInSharedBlock(byteLengthBlock, 0, 8,
currentByteLengthRawBytes, newByteLengthRawBytes). 1. If
ByteListEqual(readByteLengthRawBytes, currentByteLengthRawBytes)
is `true`, return `undefined`. 1. Set currentByteLengthRawBytes
to readByteLengthRawBytes.

Spurious failures of the compare-exchange to update the length are
prohibited. If the bounds checking for the new length passes and the
implementation is not out of memory, a ReadModifyWriteSharedMemory event
(i.e. a successful compare-exchange) is always added into the candidate
execution.

Parallel calls to SharedArrayBuffer.prototype.grow are totally ordered.
For example, consider two racing calls: `sab.grow(10)` and
`sab.grow(20)`. One of the two calls is guaranteed to win the race.
The call to `sab.grow(10)` will never shrink `sab` even if
`sab.grow(20)` happened first; in that case it will instead throw a
RangeError.

get SharedArrayBuffer.prototype.growable
----------------------------------------

`SharedArrayBuffer.prototype.growable` is an accessor property whose
set accessor function is `undefined`. Its get accessor function
performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `false`, throw a `TypeError`
exception. 1. If IsFixedLengthArrayBuffer(O) is `false`, return
`true`; otherwise return `false`.

get SharedArrayBuffer.prototype.maxByteLength
---------------------------------------------

`SharedArrayBuffer.prototype.maxByteLength` is an accessor property
whose set accessor function is `undefined`. Its get accessor function
performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `false`, throw a `TypeError`
exception. 1. If IsFixedLengthArrayBuffer(O) is `true`, then 1.
Let length be O.[[ArrayBufferByteLength]]. 1. Else, 1. Let
length be O.[[ArrayBufferMaxByteLength]]. 1. Return
𝔽(length).

SharedArrayBuffer.prototype.slice ( start, end )
--------------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[ArrayBufferData]]). 1. If
IsSharedArrayBuffer(O) is `false`, throw a `TypeError`
exception. 1. Let len be ArrayBufferByteLength(O, ~seq-cst~). 1.
Let relativeStart be ? ToIntegerOrInfinity(start). 1. If
relativeStart = -∞, let first be 0. 1. Else if relativeStart
< 0, let first be max(len + relativeStart, 0). 1. Else, let
first be min(relativeStart, len). 1. If end is
`undefined`, let relativeEnd be len; else let relativeEnd
be ? ToIntegerOrInfinity(end). 1. If relativeEnd = -∞, let
final be 0. 1. Else if relativeEnd < 0, let final be
max(len + relativeEnd, 0). 1. Else, let final be
min(relativeEnd, len). 1. Let newLen be max(final -
first, 0). 1. Let ctor be ? SpeciesConstructor(O,
%SharedArrayBuffer%). 1. Let new be ? Construct(ctor, «
𝔽(newLen) »). 1. Perform ? RequireInternalSlot(new,
[[ArrayBufferData]]). 1. If IsSharedArrayBuffer(new) is `false`,
throw a `TypeError` exception. 1. If new.[[ArrayBufferData]] is
O.[[ArrayBufferData]], throw a `TypeError` exception. 1. If
ArrayBufferByteLength(new, ~seq-cst~) < newLen, throw a
`TypeError` exception. 1. Let fromBuf be
O.[[ArrayBufferData]]. 1. Let toBuf be
new.[[ArrayBufferData]]. 1. Perform CopyDataBlockBytes(toBuf, 0,
fromBuf, first, newLen). 1. Return new.

SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]
----------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"SharedArrayBuffer"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of SharedArrayBuffer Instances
-----------------------------------------

SharedArrayBuffer instances inherit properties from the
SharedArrayBuffer prototype object. SharedArrayBuffer instances each
have an [[ArrayBufferData]] internal slot. SharedArrayBuffer instances
which are not growable each have an [[ArrayBufferByteLength]] internal
slot. SharedArrayBuffer instances which are growable each have an
[[ArrayBufferByteLengthData]] internal slot and an
[[ArrayBufferMaxByteLength]] internal slot.

SharedArrayBuffer instances, unlike ArrayBuffer instances, are never
detached.

Growable SharedArrayBuffer Guidelines
-------------------------------------

The following are guidelines for ECMAScript programmers working with
growable SharedArrayBuffer.

We recommend that programs be tested in their deployment environments
where possible. The amount of available physical memory differ greatly
between hardware devices. Similarly, virtual memory subsystems also
differ greatly between hardware devices as well as operating systems. An
application that runs without out-of-memory errors on a 64-bit desktop
web browser could run out of memory on a 32-bit mobile web browser.

When choosing a value for the `"maxByteLength"` option for growable
SharedArrayBuffer, we recommend that the smallest possible size for the
application be chosen. We recommend that `"maxByteLength"` does not
exceed 1073741824, or 1GiB.

Please note that successfully constructing a growable SharedArrayBuffer
for a particular maximum size does not guarantee that future grows will
succeed.

Not all loads of a growable SharedArrayBuffer's length are synchronizing
~seq-cst~ loads. Loads of the length that are for bounds-checking of an
integer-indexed property access, e.g. `u8[idx]`, are not
synchronizing. In general, in the absence of explicit synchronization,
one property access being in-bound does not imply a subsequent property
access in the same agent is also in-bound. In contrast, explicit loads
of the length via the `length` and `byteLength` getters on
SharedArrayBuffer, %TypedArray%.prototype, and DataView.prototype are
synchronizing. Loads of the length that are performed by built-in
methods to check if a TypedArray is entirely out-of-bounds are also
synchronizing.

The following are guidelines for ECMAScript implementers implementing
growable SharedArrayBuffer.

We recommend growable SharedArrayBuffer be implemented as in-place
growth via reserving virtual memory up front.

Because grow operations can happen in parallel with memory accesses on a
growable SharedArrayBuffer, the constraints of the memory model require
that even unordered accesses do not "tear" (bits of their values will
not be mixed). In practice, this means the underlying data block of a
growable SharedArrayBuffer cannot be grown by being copied without
stopping the world. We do not recommend stopping the world as an
implementation strategy because it introduces a serialization point and
is slow.

Grown memory must appear zeroed from the moment of its creation,
including to any racy accesses in parallel. This can be accomplished via
zero-filled-on-demand virtual memory pages, or careful synchronization
if manually zeroing memory.

Integer-indexed property access on TypedArray views of growable
SharedArrayBuffers is intended to be optimizable similarly to access on
TypedArray views of non-growable SharedArrayBuffers, because
integer-indexed property loads on are not synchronizing on the
underlying buffer's length (see programmer guidelines above). For
example, bounds checks for property accesses may still be hoisted out of
loops.

In practice it is difficult to implement growable SharedArrayBuffer by
copying on hosts that do not have virtual memory, such as those running
on embedded devices without an MMU. Memory usage behaviour of growable
SharedArrayBuffers on such hosts may significantly differ from that of
hosts with virtual memory. Such hosts should clearly communicate memory
usage expectations to users.

DataView Objects
----------------

Abstract Operations For DataView Objects
----------------------------------------

DataView With Buffer Witness Records
------------------------------------

A DataView With Buffer Witness Record is a Record value used to
encapsulate a DataView along with a cached byte length of the viewed
buffer. It is used to help ensure there is a single shared memory read
event of the byte length data block when the viewed buffer is a growable
SharedArrayBuffers.

DataView With Buffer Witness Records have the fields listed in .

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[Object]]           | a DataView           | The DataView object  |
|                      |                      | whose buffer's byte  |
|                      |                      | length is loaded.    |
+----------------------+----------------------+----------------------+
| [[Cach               | a non-negative       | The byte length of   |
| edBufferByteLength]] | integer or           | the object's         |
|                      | ~detached~           | [                    |
|                      |                      | [ViewedArrayBuffer]] |
|                      |                      | when the Record was  |
|                      |                      | created.             |
+----------------------+----------------------+----------------------+

MakeDataViewWithBufferWitnessRecord ( obj: a DataView, order: ~seq-cst~ or ~unordered~, ): a DataView With Buffer Witness Record
----------------------------------------------------------------------------------------------------------------------------------------

1. Let buffer be obj.[[ViewedArrayBuffer]]. 1. If
IsDetachedBuffer(buffer) is `true`, then 1. Let byteLength be
~detached~. 1. Else, 1. Let byteLength be
ArrayBufferByteLength(buffer, order). 1. Return the DataView
With Buffer Witness Record { [[Object]]: obj,
[[CachedBufferByteLength]]: byteLength }.

GetViewByteLength ( viewRecord: a DataView With Buffer Witness Record, ): a non-negative integer
----------------------------------------------------------------------------------------------------

1. Assert: IsViewOutOfBounds(viewRecord) is `false`. 1. Let
view be viewRecord.[[Object]]. 1. If view.[[ByteLength]] is
not ~auto~, return view.[[ByteLength]]. 1. Assert:
IsFixedLengthArrayBuffer(view.[[ViewedArrayBuffer]]) is `false`.
1. Let byteOffset be view.[[ByteOffset]]. 1. Let byteLength
be viewRecord.[[CachedBufferByteLength]]. 1. Assert: byteLength
is not ~detached~. 1. Return byteLength - byteOffset.

IsViewOutOfBounds ( viewRecord: a DataView With Buffer Witness Record, ): a Boolean
---------------------------------------------------------------------------------------

1. Let view be viewRecord.[[Object]]. 1. Let
bufferByteLength be viewRecord.[[CachedBufferByteLength]]. 1.
Assert: IsDetachedBuffer(view.[[ViewedArrayBuffer]]) is `true` if
and only if bufferByteLength is ~detached~. 1. If
bufferByteLength is ~detached~, return `true`. 1. Let
byteOffsetStart be view.[[ByteOffset]]. 1. If
view.[[ByteLength]] is ~auto~, then 1. Let byteOffsetEnd be
bufferByteLength. 1. Else, 1. Let byteOffsetEnd be
byteOffsetStart + view.[[ByteLength]]. 1. If byteOffsetStart
> bufferByteLength or byteOffsetEnd > bufferByteLength,
return `true`. 1. NOTE: 0-length DataViews are not considered
out-of-bounds. 1. Return `false`.

GetViewValue ( view, requestIndex, isLittleEndian, type: a TypedArray element type, )
-------------------------------------------------------------------------------------

description
   It is used by functions on DataView instances to retrieve values from
   the view's buffer.

1. Perform ? RequireInternalSlot(view, [[DataView]]). 1. Assert:
view has a [[ViewedArrayBuffer]] internal slot. 1. Let getIndex
be ? ToIndex(requestIndex). 1. Set isLittleEndian to
ToBoolean(isLittleEndian). 1. Let viewOffset be
view.[[ByteOffset]]. 1. Let viewRecord be
MakeDataViewWithBufferWitnessRecord(view, ~unordered~). 1. NOTE:
Bounds checking is not a synchronizing operation when view's backing
buffer is a growable SharedArrayBuffer. 1. If
IsViewOutOfBounds(viewRecord) is `true`, throw a `TypeError`
exception. 1. Let viewSize be GetViewByteLength(viewRecord). 1.
Let elementSize be the Element Size value specified in for Element
Type type. 1. If getIndex + elementSize > viewSize,
throw a `RangeError` exception. 1. Let bufferIndex be getIndex
+ viewOffset. 1. Return
GetValueFromBuffer(view.[[ViewedArrayBuffer]], bufferIndex,
type, `false`, ~unordered~, isLittleEndian).

SetViewValue ( view, requestIndex, isLittleEndian, type: a TypedArray element type, value, )
--------------------------------------------------------------------------------------------

description
   It is used by functions on DataView instances to store values into
   the view's buffer.

1. Perform ? RequireInternalSlot(view, [[DataView]]). 1. Assert:
view has a [[ViewedArrayBuffer]] internal slot. 1. Let getIndex
be ? ToIndex(requestIndex). 1. If IsBigIntElementType(type) is
`true`, let numberValue be ? ToBigInt(value). 1. Otherwise,
let numberValue be ? ToNumber(value). 1. Set isLittleEndian
to ToBoolean(isLittleEndian). 1. Let viewOffset be
view.[[ByteOffset]]. 1. Let viewRecord be
MakeDataViewWithBufferWitnessRecord(view, ~unordered~). 1. NOTE:
Bounds checking is not a synchronizing operation when view's backing
buffer is a growable SharedArrayBuffer. 1. If
IsViewOutOfBounds(viewRecord) is `true`, throw a `TypeError`
exception. 1. Let viewSize be GetViewByteLength(viewRecord). 1.
Let elementSize be the Element Size value specified in for Element
Type type. 1. If getIndex + elementSize > viewSize,
throw a `RangeError` exception. 1. Let bufferIndex be getIndex
+ viewOffset. 1. Perform
SetValueInBuffer(view.[[ViewedArrayBuffer]], bufferIndex,
type, numberValue, `false`, ~unordered~, isLittleEndian).
1. Return `undefined`.

The DataView Constructor
------------------------

The DataView constructor:

- is %DataView%.
- is the initial value of the `"DataView"` property of the global
  object.
- creates and initializes a new DataView when called as a constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  DataView behaviour must include a `super` call to the DataView
  constructor to create and initialize subclass instances with the
  internal state necessary to support the `DataView.prototype`
  built-in methods.

DataView ( buffer [ , byteOffset [ , byteLength ] ] )
-----------------------------------------------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Perform ? RequireInternalSlot(buffer, [[ArrayBufferData]]). 1. Let
offset be ? ToIndex(byteOffset). 1. If
IsDetachedBuffer(buffer) is `true`, throw a `TypeError`
exception. 1. Let bufferByteLength be
ArrayBufferByteLength(buffer, ~seq-cst~). 1. If offset >
bufferByteLength, throw a `RangeError` exception. 1. Let
bufferIsFixedLength be IsFixedLengthArrayBuffer(buffer). 1. If
byteLength is `undefined`, then 1. If bufferIsFixedLength is
`true`, then 1. Let viewByteLength be bufferByteLength -
offset. 1. Else, 1. Let viewByteLength be ~auto~. 1. Else, 1.
Let viewByteLength be ? ToIndex(byteLength). 1. If offset +
viewByteLength > bufferByteLength, throw a `RangeError`
exception. 1. Let O be ? OrdinaryCreateFromConstructor(NewTarget,
`"%DataView.prototype%"`, « [[DataView]], [[ViewedArrayBuffer]],
[[ByteLength]], [[ByteOffset]] »). 1. If IsDetachedBuffer(buffer) is
`true`, throw a `TypeError` exception. 1. Set bufferByteLength
to ArrayBufferByteLength(buffer, ~seq-cst~). 1. If offset >
bufferByteLength, throw a `RangeError` exception. 1. If
byteLength is not `undefined`, then 1. If offset +
viewByteLength > bufferByteLength, throw a `RangeError`
exception. 1. Set O.[[ViewedArrayBuffer]] to buffer. 1. Set
O.[[ByteLength]] to viewByteLength. 1. Set O.[[ByteOffset]]
to offset. 1. Return O.

Properties of the DataView Constructor
--------------------------------------

The DataView constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

DataView.prototype
------------------

The initial value of `DataView.prototype` is the DataView prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the DataView Prototype Object
-------------------------------------------

The DataView prototype object:

- is %DataView.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have a [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]],
  or [[ByteOffset]] internal slot.

get DataView.prototype.buffer
-----------------------------

`DataView.prototype.buffer` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[DataView]]). 1. Assert: O has a
[[ViewedArrayBuffer]] internal slot. 1. Let buffer be
O.[[ViewedArrayBuffer]]. 1. Return buffer.

get DataView.prototype.byteLength
---------------------------------

`DataView.prototype.byteLength` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[DataView]]). 1. Assert: O has a
[[ViewedArrayBuffer]] internal slot. 1. Let viewRecord be
MakeDataViewWithBufferWitnessRecord(O, ~seq-cst~). 1. If
IsViewOutOfBounds(viewRecord) is `true`, throw a `TypeError`
exception. 1. Let size be GetViewByteLength(viewRecord). 1.
Return 𝔽(size).

get DataView.prototype.byteOffset
---------------------------------

`DataView.prototype.byteOffset` is an accessor property whose set
accessor function is `undefined`. Its get accessor function performs
the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[DataView]]). 1. Assert: O has a
[[ViewedArrayBuffer]] internal slot. 1. Let viewRecord be
MakeDataViewWithBufferWitnessRecord(O, ~seq-cst~). 1. If
IsViewOutOfBounds(viewRecord) is `true`, throw a `TypeError`
exception. 1. Let offset be O.[[ByteOffset]]. 1. Return
𝔽(offset).

DataView.prototype.constructor
------------------------------

The initial value of `DataView.prototype.constructor` is %DataView%.

DataView.prototype.getBigInt64 ( byteOffset [ , littleEndian ] )
------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? GetViewValue(v,
byteOffset, littleEndian, ~bigint64~).

DataView.prototype.getBigUint64 ( byteOffset [ , littleEndian ] )
-------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? GetViewValue(v,
byteOffset, littleEndian, ~biguint64~).

DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )
-----------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
GetViewValue(v, byteOffset, littleEndian, ~float32~).

DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )
-----------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
GetViewValue(v, byteOffset, littleEndian, ~float64~).

DataView.prototype.getInt8 ( byteOffset )
---------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? GetViewValue(v,
byteOffset, `true`, ~int8~).

DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )
---------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
GetViewValue(v, byteOffset, littleEndian, ~int16~).

DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )
---------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
GetViewValue(v, byteOffset, littleEndian, ~int32~).

DataView.prototype.getUint8 ( byteOffset )
----------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? GetViewValue(v,
byteOffset, `true`, ~uint8~).

DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )
----------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
GetViewValue(v, byteOffset, littleEndian, ~uint16~).

DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )
----------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
GetViewValue(v, byteOffset, littleEndian, ~uint32~).

DataView.prototype.setBigInt64 ( byteOffset, value [ , littleEndian ] )
-----------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? SetViewValue(v,
byteOffset, littleEndian, ~bigint64~, value).

DataView.prototype.setBigUint64 ( byteOffset, value [ , littleEndian ] )
------------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? SetViewValue(v,
byteOffset, littleEndian, ~biguint64~, value).

DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )
----------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
SetViewValue(v, byteOffset, littleEndian, ~float32~,
value).

DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )
----------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
SetViewValue(v, byteOffset, littleEndian, ~float64~,
value).

DataView.prototype.setInt8 ( byteOffset, value )
--------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? SetViewValue(v,
byteOffset, `true`, ~int8~, value).

DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )
--------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
SetViewValue(v, byteOffset, littleEndian, ~int16~,
value).

DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )
--------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
SetViewValue(v, byteOffset, littleEndian, ~int32~,
value).

DataView.prototype.setUint8 ( byteOffset, value )
---------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. Return ? SetViewValue(v,
byteOffset, `true`, ~uint8~, value).

DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )
---------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
SetViewValue(v, byteOffset, littleEndian, ~uint16~,
value).

DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )
---------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let v be the `this` value. 1. If littleEndian is not
present, set littleEndian to `false`. 1. Return ?
SetViewValue(v, byteOffset, littleEndian, ~uint32~,
value).

DataView.prototype [ %Symbol.toStringTag% ]
-------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"DataView"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of DataView Instances
--------------------------------

DataView instances are ordinary objects that inherit properties from the
DataView prototype object. DataView instances each have [[DataView]],
[[ViewedArrayBuffer]], [[ByteLength]], and [[ByteOffset]] internal
slots.

The value of the [[DataView]] internal slot is not used within this
specification. The simple presence of that internal slot is used within
the specification to identify objects created using the DataView
constructor.

The Atomics Object
------------------

The Atomics object:

- is %Atomics%.
- is the initial value of the `"Atomics"` property of the global
  object.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- does not have a [[Construct]] internal method; it cannot be used as a
  constructor with the `new` operator.
- does not have a [[Call]] internal method; it cannot be invoked as a
  function.

The Atomics object provides functions that operate indivisibly
(atomically) on shared memory array cells as well as functions that let
agents wait for and dispatch primitive events. When used with
discipline, the Atomics functions allow multi-agent programs that
communicate through shared memory to execute in a well-understood order
even on parallel CPUs. The rules that govern shared-memory communication
are provided by the memory model, defined below.

For informative guidelines for programming and implementing shared
memory in ECMAScript, please see the notes at the end of the memory
model section.

Waiter Record
-------------

A Waiter Record is a Record value used to denote a particular call to
`Atomics.wait` or `Atomics.waitAsync`.

A Waiter Record has fields listed in .

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[AgentSignifier]]   | an agent signifier   | The agent that       |
|                      |                      | called               |
|                      |                      | `Atomics.wait` or  |
|                      |                      | `                   |
|                      |                      | Atomics.waitAsync`. |
+----------------------+----------------------+----------------------+
| [                    | a PromiseCapability  | If denoting a call   |
| [PromiseCapability]] | Record or ~blocking~ | to                   |
|                      |                      | `                   |
|                      |                      | Atomics.waitAsync`, |
|                      |                      | the resulting        |
|                      |                      | promise, otherwise   |
|                      |                      | ~blocking~.          |
+----------------------+----------------------+----------------------+
| [[TimeoutTime]]      | a non-negative       | The earliest time by |
|                      | extended             | which timeout may be |
|                      | mathematical value   | triggered; computed  |
|                      |                      | using time values.   |
+----------------------+----------------------+----------------------+
| [[Result]]           | `"ok"` or          | The return value of  |
|                      | `"timed-out"`      | the call.            |
+----------------------+----------------------+----------------------+

WaiterList Records
------------------

A WaiterList Record is used to explain waiting and notification of
agents via `Atomics.wait`, `Atomics.waitAsync`, and
`Atomics.notify`.

A WaiterList Record has fields listed in .

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[Waiters]]          | a List of Waiter     | The calls to         |
|                      | Records              | `Atomics.wait` or  |
|                      |                      | \                    |
|                      |                      | `Atomics.waitAsync` |
|                      |                      | that are waiting on  |
|                      |                      | the location with    |
|                      |                      | which this           |
|                      |                      | WaiterList is        |
|                      |                      | associated.          |
+----------------------+----------------------+----------------------+
| [[Mo                 | a Synchronize event  | The event of the     |
| stRecentLeaveEvent]] | or ~empty~           | most recent leaving  |
|                      |                      | of its critical      |
|                      |                      | section, or ~empty~  |
|                      |                      | if its critical      |
|                      |                      | section has never    |
|                      |                      | been entered.        |
+----------------------+----------------------+----------------------+

There can be multiple Waiter Records in a WaiterList with the same agent
signifier.

The agent cluster has a store of WaiterList Records; the store is
indexed by (block, i), where block is a Shared Data Block
and i a byte offset into the memory of block. WaiterList Records
are agent-independent: a lookup in the store of WaiterList Records by
(block, i) will result in the same WaiterList Record in any
agent in the agent cluster.

Each WaiterList Record has a critical section that controls exclusive
access to that WaiterList Record during evaluation. Only a single agent
may enter a WaiterList Record's critical section at one time. Entering
and leaving a WaiterList Record's critical section is controlled by the
abstract operations EnterCriticalSection and LeaveCriticalSection.
Operations on a WaiterList Record—adding and removing waiting agents,
traversing the list of agents, suspending and notifying agents on the
list, setting and retrieving the Synchronize event—may only be performed
by agents that have entered the WaiterList Record's critical section.

Abstract Operations for Atomics
-------------------------------

ValidateIntegerTypedArray ( typedArray, waitable: a Boolean, )
--------------------------------------------------------------

1. Let taRecord be ? ValidateTypedArray(typedArray,
~unordered~). 1. NOTE: Bounds checking is not a synchronizing operation
when typedArray's backing buffer is a growable SharedArrayBuffer. 1.
If waitable is `true`, then 1. If
typedArray.[[TypedArrayName]] is neither `"Int32Array"` nor
`"BigInt64Array"`, throw a `TypeError` exception. 1. Else, 1. Let
type be TypedArrayElementType(typedArray). 1. If
IsUnclampedIntegerElementType(type) is `false` and
IsBigIntElementType(type) is `false`, throw a `TypeError`
exception. 1. Return taRecord.

ValidateAtomicAccess ( taRecord: a TypedArray With Buffer Witness Record, requestIndex, )
-----------------------------------------------------------------------------------------

1. Let length be TypedArrayLength(taRecord). 1. Let
accessIndex be ? ToIndex(requestIndex). 1. Assert:
accessIndex ≥ 0. 1. If accessIndex ≥ length, throw a
`RangeError` exception. 1. Let typedArray be
taRecord.[[Object]]. 1. Let elementSize be
TypedArrayElementSize(typedArray). 1. Let offset be
typedArray.[[ByteOffset]]. 1. Return (accessIndex ×
elementSize) + offset.

ValidateAtomicAccessOnIntegerTypedArray ( typedArray, requestIndex, optional waitable: a Boolean, )
---------------------------------------------------------------------------------------------------

1. If waitable is not present, set waitable to `false`. 1. Let
taRecord be ? ValidateIntegerTypedArray(typedArray,
waitable). 1. Return ? ValidateAtomicAccess(taRecord,
requestIndex).

RevalidateAtomicAccess ( typedArray: a TypedArray, byteIndexInBuffer: an integer, )
-----------------------------------------------------------------------------------

description
   This operation revalidates the index within the backing buffer for
   atomic operations after all argument coercions are performed in
   Atomics methods, as argument coercions can have arbitrary side
   effects, which could cause the buffer to become out of bounds. This
   operation does not throw when typedArray's backing buffer is a
   SharedArrayBuffer.

1. Let taRecord be
MakeTypedArrayWithBufferWitnessRecord(typedArray, ~unordered~). 1.
NOTE: Bounds checking is not a synchronizing operation when
typedArray's backing buffer is a growable SharedArrayBuffer. 1. If
IsTypedArrayOutOfBounds(taRecord) is `true`, throw a `TypeError`
exception. 1. Assert: byteIndexInBuffer ≥
typedArray.[[ByteOffset]]. 1. If byteIndexInBuffer ≥
taRecord.[[CachedBufferByteLength]], throw a `RangeError`
exception. 1. Return ~unused~.

GetWaiterList ( block: a Shared Data Block, i: a non-negative integer that is evenly divisible by 4, ): a WaiterList Record
-----------------------------------------------------------------------------------------------------------------------------------

1. Assert: i and i + 3 are valid byte offsets within the memory
of block. 1. Return the WaiterList Record that is referenced by the
pair (block, i).

EnterCriticalSection ( WL: a WaiterList Record, ): ~unused~
---------------------------------------------------------------

1. Assert: The surrounding agent is not in the critical section for any
WaiterList Record. 1. Wait until no agent is in the critical section for
WL, then enter the critical section for WL (without allowing any
other agent to enter). 1. If WL.[[MostRecentLeaveEvent]] is not
~empty~, then 1. NOTE: A WL whose critical section has been entered
at least once has a Synchronize event set by LeaveCriticalSection. 1.
Let execution be the [[CandidateExecution]] field of the surrounding
agent's Agent Record. 1. Let eventsRecord be the Agent Events Record
of execution.[[EventsRecords]] whose [[AgentSignifier]] is
AgentSignifier(). 1. Let enterEvent be a new Synchronize event. 1.
Append enterEvent to eventsRecord.[[EventList]]. 1. Append
(WL.[[MostRecentLeaveEvent]], enterEvent) to
eventsRecord.[[AgentSynchronizesWith]]. 1. Return ~unused~.

EnterCriticalSection has contention when an agent attempting to enter
the critical section must wait for another agent to leave it. When there
is no contention, FIFO order of EnterCriticalSection calls is
observable. When there is contention, an implementation may choose an
arbitrary order but may not cause an agent to wait indefinitely.

LeaveCriticalSection ( WL: a WaiterList Record, ): ~unused~
---------------------------------------------------------------

1. Assert: The surrounding agent is in the critical section for WL.
1. Let execution be the [[CandidateExecution]] field of the
surrounding agent's Agent Record. 1. Let eventsRecord be the Agent
Events Record of execution.[[EventsRecords]] whose
[[AgentSignifier]] is AgentSignifier(). 1. Let leaveEvent be a new
Synchronize event. 1. Append leaveEvent to
eventsRecord.[[EventList]]. 1. Set WL.[[MostRecentLeaveEvent]]
to leaveEvent. 1. Leave the critical section for WL. 1. Return
~unused~.

AddWaiter ( WL: a WaiterList Record, waiterRecord: a Waiter Record, ): ~unused~
---------------------------------------------------------------------------------------

1. Assert: The surrounding agent is in the critical section for WL.
1. Assert: There is no Waiter Record in WL.[[Waiters]] whose
[[PromiseCapability]] field is waiterRecord.[[PromiseCapability]]
and whose [[AgentSignifier]] field is
waiterRecord.[[AgentSignifier]]. 1. Append waiterRecord to
WL.[[Waiters]]. 1. Return ~unused~.

RemoveWaiter ( WL: a WaiterList Record, waiterRecord: a Waiter Record, ): ~unused~
------------------------------------------------------------------------------------------

1. Assert: The surrounding agent is in the critical section for WL.
1. Assert: WL.[[Waiters]] contains waiterRecord. 1. Remove
waiterRecord from WL.[[Waiters]]. 1. Return ~unused~.

RemoveWaiters ( WL: a WaiterList Record, c: a non-negative integer or +∞, ): a List of Waiter Records
-------------------------------------------------------------------------------------------------------------

1. Assert: The surrounding agent is in the critical section for WL.
1. Let len be the number of elements in WL.[[Waiters]]. 1. Let
n be min(c, len). 1. Let L be a List whose elements are
the first n elements of WL.[[Waiters]]. 1. Remove the first
n elements of WL.[[Waiters]]. 1. Return L.

SuspendThisAgent ( WL: a WaiterList Record, waiterRecord: a Waiter Record, ): ~unused~
----------------------------------------------------------------------------------------------

1. Assert: The surrounding agent is in the critical section for WL.
1. Assert: WL.[[Waiters]] contains waiterRecord. 1. Let
thisAgent be AgentSignifier(). 1. Assert:
waiterRecord.[[AgentSignifier]] is thisAgent. 1. Assert:
waiterRecord.[[PromiseCapability]] is ~blocking~. 1. Assert:
AgentCanSuspend() is `true`. 1. Perform LeaveCriticalSection(WL)
and suspend the surrounding agent until the time is
waiterRecord.[[TimeoutTime]], performing the combined operation in
such a way that a notification that arrives after the critical section
is exited but before the suspension takes effect is not lost. The
surrounding agent can only wake from suspension due to a timeout or due
to another agent calling NotifyWaiter with arguments WL and
thisAgent (i.e. via a call to `Atomics.notify`). 1. Perform
EnterCriticalSection(WL). 1. Return ~unused~.

NotifyWaiter ( WL: a WaiterList Record, waiterRecord: a Waiter Record, ): ~unused~
------------------------------------------------------------------------------------------

1. Assert: The surrounding agent is in the critical section for WL.
1. If waiterRecord.[[PromiseCapability]] is ~blocking~, then 1. Wake
the agent whose signifier is waiterRecord.[[AgentSignifier]] from
suspension. 1. NOTE: This causes the agent to resume execution in
SuspendThisAgent. 1. Else if AgentSignifier() is
waiterRecord.[[AgentSignifier]], then 1. Let promiseCapability
be waiterRecord.[[PromiseCapability]]. 1. Perform !
Call(promiseCapability.[[Resolve]], `undefined`, «
waiterRecord.[[Result]] »). 1. Else, 1. Perform
EnqueueResolveInAgentJob(waiterRecord.[[AgentSignifier]],
waiterRecord.[[PromiseCapability]], waiterRecord.[[Result]]). 1.
Return ~unused~.

An agent must not access another agent's promise capability in any
capacity beyond passing it to the host.

EnqueueResolveInAgentJob ( agentSignifier: an agent signifier, promiseCapability: a PromiseCapability Record, resolution: `"ok"` or `"timed-out"`, ): ~unused~
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let resolveJob be a new Job Abstract Closure with no parameters
that captures agentSignifier, promiseCapability, and
resolution and performs the following steps when called: 1. Assert:
AgentSignifier() is agentSignifier. 1. Perform !
Call(promiseCapability.[[Resolve]], `undefined`, « resolution
»). 1. Return ~unused~. 1. Let realmInTargetAgent be !
GetFunctionRealm(promiseCapability.[[Resolve]]). 1. Assert:
agentSignifier is realmInTargetAgent.[[AgentSignifier]]. 1.
Perform HostEnqueueGenericJob(resolveJob, realmInTargetAgent).
1. Return ~unused~.

DoWait ( mode: ~sync~ or ~async~, typedArray, index, value, timeout, )
----------------------------------------------------------------------

1. Let taRecord be ? ValidateIntegerTypedArray(typedArray,
`true`). 1. Let buffer be
taRecord.[[Object]].[[ViewedArrayBuffer]]. 1. If
IsSharedArrayBuffer(buffer) is `false`, throw a `TypeError`
exception. 1. Let i be ? ValidateAtomicAccess(taRecord,
index). 1. Let arrayTypeName be
typedArray.[[TypedArrayName]]. 1. If arrayTypeName is
`"BigInt64Array"`, let v be ? ToBigInt64(value). 1. Else, let
v be ? ToInt32(value). 1. Let q be ? ToNumber(timeout).
1. If q is either `NaN` or `+∞`\ :sub:`𝔽`, let t be +∞; else
if q is `-∞`\ :sub:`𝔽`, let t be 0; else let t be
max(ℝ(q), 0). 1. If mode is ~sync~ and AgentCanSuspend() is
`false`, throw a `TypeError` exception. 1. Let block be
buffer.[[ArrayBufferData]]. 1. Let offset be
typedArray.[[ByteOffset]]. 1. Let byteIndexInBuffer be (i ×
4) + offset. 1. Let WL be GetWaiterList(block,
byteIndexInBuffer). 1. If mode is ~sync~, then 1. Let
promiseCapability be ~blocking~. 1. Let resultObject be
`undefined`. 1. Else, 1. Let promiseCapability be !
NewPromiseCapability(%Promise%). 1. Let resultObject be
OrdinaryObjectCreate(%Object.prototype%). 1. Perform
EnterCriticalSection(WL). 1. Let elementType be
TypedArrayElementType(typedArray). 1. Let w be
GetValueFromBuffer(buffer, byteIndexInBuffer, elementType,
`true`, ~seq-cst~). 1. If v ≠ w, then 1. Perform
LeaveCriticalSection(WL). 1. If mode is ~sync~, return
`"not-equal"`. 1. Perform !
CreateDataPropertyOrThrow(resultObject, `"async"`, `false`). 1.
Perform ! CreateDataPropertyOrThrow(resultObject, `"value"`,
`"not-equal"`). 1. Return resultObject. 1. If t = 0 and
mode is ~async~, then 1. NOTE: There is no special handling of
synchronous immediate timeouts. Asynchronous immediate timeouts have
special handling in order to fail fast and avoid unnecessary Promise
jobs. 1. Perform LeaveCriticalSection(WL). 1. Perform !
CreateDataPropertyOrThrow(resultObject, `"async"`, `false`). 1.
Perform ! CreateDataPropertyOrThrow(resultObject, `"value"`,
`"timed-out"`). 1. Return resultObject. 1. Let thisAgent be
AgentSignifier(). 1. Let now be the time value (UTC) identifying the
current time. 1. Let additionalTimeout be an implementation-defined
non-negative mathematical value. 1. Let timeoutTime be ℝ(now) +
t + additionalTimeout. 1. NOTE: When t is +∞,
timeoutTime is also +∞. 1. Let waiterRecord be a new Waiter
Record { [[AgentSignifier]]: thisAgent, [[PromiseCapability]]:
promiseCapability, [[TimeoutTime]]: timeoutTime, [[Result]]:
`"ok"` }. 1. Perform AddWaiter(WL, waiterRecord). 1. If
mode is ~sync~, then 1. Perform SuspendThisAgent(WL,
waiterRecord). 1. Else if timeoutTime is finite, then 1. Perform
EnqueueAtomicsWaitAsyncTimeoutJob(WL, waiterRecord). 1. Perform
LeaveCriticalSection(WL). 1. If mode is ~sync~, return
waiterRecord.[[Result]]. 1. Perform !
CreateDataPropertyOrThrow(resultObject, `"async"`, `true`). 1.
Perform ! CreateDataPropertyOrThrow(resultObject, `"value"`,
promiseCapability.[[Promise]]). 1. Return resultObject.

additionalTimeout allows implementations to pad timeouts as
necessary, such as for reducing power consumption or coarsening timer
resolution to mitigate timing attacks. This value may differ from call
to call of DoWait.

EnqueueAtomicsWaitAsyncTimeoutJob ( WL: a WaiterList Record, waiterRecord: a Waiter Record, ): ~unused~
---------------------------------------------------------------------------------------------------------------

1. Let timeoutJob be a new Job Abstract Closure with no parameters
that captures WL and waiterRecord and performs the following
steps when called: 1. Perform EnterCriticalSection(WL). 1. If
WL.[[Waiters]] contains waiterRecord, then 1. Let
timeOfJobExecution be the time value (UTC) identifying the current
time. 1. Assert: ℝ(timeOfJobExecution) ≥
waiterRecord.[[TimeoutTime]] (ignoring potential non-monotonicity of
time values). 1. Set waiterRecord.[[Result]] to `"timed-out"`. 1.
Perform RemoveWaiter(WL, waiterRecord). 1. Perform
NotifyWaiter(WL, waiterRecord). 1. Perform
LeaveCriticalSection(WL). 1. Return ~unused~. 1. Let now be the
time value (UTC) identifying the current time. 1. Let currentRealm
be the current Realm Record. 1. Perform
HostEnqueueTimeoutJob(timeoutJob, currentRealm,
𝔽(waiterRecord.[[TimeoutTime]]) - now). 1. Return ~unused~.

AtomicCompareExchangeInSharedBlock ( block: a Shared Data Block, byteIndexInBuffer: an integer, elementSize: a non-negative integer, expectedBytes: a List of byte values, replacementBytes: a List of byte values, ): a List of byte values
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let execution be the [[CandidateExecution]] field of the
surrounding agent's Agent Record. 1. Let eventsRecord be the Agent
Events Record of execution.[[EventsRecords]] whose
[[AgentSignifier]] is AgentSignifier(). 1. Let rawBytesRead be a
List of length elementSize whose elements are nondeterministically
chosen byte values. 1. NOTE: In implementations, rawBytesRead is the
result of a load-link, of a load-exclusive, or of an operand of a
read-modify-write instruction on the underlying hardware. The
nondeterminism is a semantic prescription of the memory model to
describe observable behaviour of hardware with weak consistency. 1.
NOTE: The comparison of the expected value and the read value is
performed outside of the read-modify-write modification function to
avoid needlessly strong synchronization when the expected value is not
equal to the read value. 1. If ByteListEqual(rawBytesRead,
expectedBytes) is `true`, then 1. Let second be a new
read-modify-write modification function with parameters (oldBytes,
newBytes) that captures nothing and performs the following steps
atomically when called: 1. Return newBytes. 1. Let event be
ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]:
`true`, [[Block]]: block, [[ByteIndex]]: byteIndexInBuffer,
[[ElementSize]]: elementSize, [[Payload]]: replacementBytes,
[[ModifyOp]]: second }. 1. Else, 1. Let event be
ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: `true`,
[[Block]]: block, [[ByteIndex]]: byteIndexInBuffer,
[[ElementSize]]: elementSize }. 1. Append event to
eventsRecord.[[EventList]]. 1. Append Chosen Value Record {
[[Event]]: event, [[ChosenValue]]: rawBytesRead } to
execution.[[ChosenValues]]. 1. Return rawBytesRead.

AtomicReadModifyWrite ( typedArray, index, value, op: a read-modify-write modification function, )
--------------------------------------------------------------------------------------------------

description
   op takes two List of byte values arguments and returns a List of
   byte values. This operation atomically loads a value, combines it
   with another value, and stores the combination. It returns the loaded
   value.

1. Let byteIndexInBuffer be ?
ValidateAtomicAccessOnIntegerTypedArray(typedArray, index). 1.
If typedArray.[[ContentType]] is ~bigint~, let v be ?
ToBigInt(value). 1. Otherwise, let v be 𝔽(?
ToIntegerOrInfinity(value)). 1. Perform ?
RevalidateAtomicAccess(typedArray, byteIndexInBuffer). 1. Let
buffer be typedArray.[[ViewedArrayBuffer]]. 1. Let
elementType be TypedArrayElementType(typedArray). 1. Return
GetModifySetValueInBuffer(buffer, byteIndexInBuffer,
elementType, v, op).

ByteListBitwiseOp ( op: `&`, `^`, or `|`, xBytes: a List of byte values, yBytes: a List of byte values, ): a List of byte values
--------------------------------------------------------------------------------------------------------------------------------------------------

description
   The operation atomically performs a bitwise operation on all byte
   values of the arguments and returns a List of byte values.

1. Assert: xBytes and yBytes have the same number of elements.
1. Let result be a new empty List. 1. Let i be 0. 1. For each
element xByte of xBytes, do 1. Let yByte be
yBytes[i]. 1. If op is `&`, then 1. Let resultByte be
the result of applying the bitwise AND operation to xByte and
yByte. 1. Else if op is `^`, then 1. Let resultByte be the
result of applying the bitwise exclusive OR (XOR) operation to xByte
and yByte. 1. Else, 1. Assert: op is `|`. 1. Let
resultByte be the result of applying the bitwise inclusive OR
operation to xByte and yByte. 1. Set i to i + 1. 1.
Append resultByte to result. 1. Return result.

ByteListEqual ( xBytes: a List of byte values, yBytes: a List of byte values, ): a Boolean
--------------------------------------------------------------------------------------------------

1. If xBytes and yBytes do not have the same number of elements,
return `false`. 1. Let i be 0. 1. For each element xByte of
xBytes, do 1. Let yByte be yBytes[i]. 1. If xByte ≠
yByte, return `false`. 1. Set i to i + 1. 1. Return
`true`.

Atomics.add ( typedArray, index, value )
----------------------------------------------------

This function performs the following steps when called:

1. Let type be TypedArrayElementType(typedArray). 1. Let
isLittleEndian be the value of the [[LittleEndian]] field of the
surrounding agent's Agent Record. 1. Let add be a new
read-modify-write modification function with parameters (xBytes,
yBytes) that captures type and isLittleEndian and performs
the following steps atomically when called: 1. Let x be
RawBytesToNumeric(type, xBytes, isLittleEndian). 1. Let
y be RawBytesToNumeric(type, yBytes, isLittleEndian). 1.
If x is a Number, then 1. Let sum be Number::add(x, y).
1. Else, 1. Assert: x is a BigInt. 1. Let sum be
BigInt::add(x, y). 1. Let sumBytes be
NumericToRawBytes(type, sum, isLittleEndian). 1. Assert:
sumBytes, xBytes, and yBytes have the same number of
elements. 1. Return sumBytes. 1. Return ?
AtomicReadModifyWrite(typedArray, index, value, add).

Atomics.and ( typedArray, index, value )
----------------------------------------------------

This function performs the following steps when called:

1. Let and be a new read-modify-write modification function with
parameters (xBytes, yBytes) that captures nothing and performs
the following steps atomically when called: 1. Return
ByteListBitwiseOp(`&`, xBytes, yBytes). 1. Return ?
AtomicReadModifyWrite(typedArray, index, value, and).

Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )
----------------------------------------------------------------------------------------------

This function performs the following steps when called:

1. Let byteIndexInBuffer be ?
ValidateAtomicAccessOnIntegerTypedArray(typedArray, index). 1.
Let buffer be typedArray.[[ViewedArrayBuffer]]. 1. Let block
be buffer.[[ArrayBufferData]]. 1. If typedArray.[[ContentType]]
is ~bigint~, then 1. Let expected be ? ToBigInt(expectedValue).
1. Let replacement be ? ToBigInt(replacementValue). 1. Else, 1.
Let expected be 𝔽(? ToIntegerOrInfinity(expectedValue)). 1. Let
replacement be 𝔽(? ToIntegerOrInfinity(replacementValue)). 1.
Perform ? RevalidateAtomicAccess(typedArray, byteIndexInBuffer).
1. Let elementType be TypedArrayElementType(typedArray). 1. Let
elementSize be TypedArrayElementSize(typedArray). 1. Let
isLittleEndian be the value of the [[LittleEndian]] field of the
surrounding agent's Agent Record. 1. Let expectedBytes be
NumericToRawBytes(elementType, expected, isLittleEndian). 1.
Let replacementBytes be NumericToRawBytes(elementType,
replacement, isLittleEndian). 1. If
IsSharedArrayBuffer(buffer) is `true`, then 1. Let
rawBytesRead be AtomicCompareExchangeInSharedBlock(block,
byteIndexInBuffer, elementSize, expectedBytes,
replacementBytes). 1. Else, 1. Let rawBytesRead be a List of
length elementSize whose elements are the sequence of
elementSize bytes starting with block[byteIndexInBuffer]. 1.
If ByteListEqual(rawBytesRead, expectedBytes) is `true`, then
1. Store the individual bytes of replacementBytes into block,
starting at block[byteIndexInBuffer]. 1. Return
RawBytesToNumeric(elementType, rawBytesRead,
isLittleEndian).

Atomics.exchange ( typedArray, index, value )
---------------------------------------------------------

This function performs the following steps when called:

1. Let second be a new read-modify-write modification function with
parameters (oldBytes, newBytes) that captures nothing and
performs the following steps atomically when called: 1. Return
newBytes. 1. Return ? AtomicReadModifyWrite(typedArray,
index, value, second).

Atomics.isLockFree ( size )
-------------------------------

This function performs the following steps when called:

1. Let n be ? ToIntegerOrInfinity(size). 1. Let AR be the
Agent Record of the surrounding agent. 1. If n = 1, return
AR.[[IsLockFree1]]. 1. If n = 2, return AR.[[IsLockFree2]].
1. If n = 4, return `true`. 1. If n = 8, return
AR.[[IsLockFree8]]. 1. Return `false`.

This function is an optimization primitive. The intuition is that if the
atomic step of an atomic primitive (`compareExchange`, `load`,
`store`, `add`, `sub`, `and`, `or`, `xor`, or `exchange`)
on a datum of size n bytes will be performed without the surrounding
agent acquiring a lock outside the n bytes comprising the datum,
then `Atomics.isLockFree`(n) will return `true`. High-performance
algorithms will use this function to determine whether to use locks or
atomic operations in critical sections. If an atomic primitive is not
lock-free then it is often more efficient for an algorithm to provide
its own locking.

`Atomics.isLockFree`(4) always returns `true` as that can be
supported on all known relevant hardware. Being able to assume this will
generally simplify programs.

Regardless of the value returned by this function, all atomic operations
are guaranteed to be atomic. For example, they will never have a visible
operation take place in the middle of the operation (e.g., "tearing").

Atomics.load ( typedArray, index )
------------------------------------------

This function performs the following steps when called:

1. Let byteIndexInBuffer be ?
ValidateAtomicAccessOnIntegerTypedArray(typedArray, index). 1.
Perform ? RevalidateAtomicAccess(typedArray, byteIndexInBuffer).
1. Let buffer be typedArray.[[ViewedArrayBuffer]]. 1. Let
elementType be TypedArrayElementType(typedArray). 1. Return
GetValueFromBuffer(buffer, byteIndexInBuffer, elementType,
`true`, ~seq-cst~).

Atomics.or ( typedArray, index, value )
---------------------------------------------------

This function performs the following steps when called:

1. Let or be a new read-modify-write modification function with
parameters (xBytes, yBytes) that captures nothing and performs
the following steps atomically when called: 1. Return
ByteListBitwiseOp(`|`, xBytes, yBytes). 1. Return ?
AtomicReadModifyWrite(typedArray, index, value, or).

Atomics.store ( typedArray, index, value )
------------------------------------------------------

This function performs the following steps when called:

1. Let byteIndexInBuffer be ?
ValidateAtomicAccessOnIntegerTypedArray(typedArray, index). 1.
If typedArray.[[ContentType]] is ~bigint~, let v be ?
ToBigInt(value). 1. Otherwise, let v be 𝔽(?
ToIntegerOrInfinity(value)). 1. Perform ?
RevalidateAtomicAccess(typedArray, byteIndexInBuffer). 1. Let
buffer be typedArray.[[ViewedArrayBuffer]]. 1. Let
elementType be TypedArrayElementType(typedArray). 1. Perform
SetValueInBuffer(buffer, byteIndexInBuffer, elementType,
v, `true`, ~seq-cst~). 1. Return v.

Atomics.sub ( typedArray, index, value )
----------------------------------------------------

This function performs the following steps when called:

1. Let type be TypedArrayElementType(typedArray). 1. Let
isLittleEndian be the value of the [[LittleEndian]] field of the
surrounding agent's Agent Record. 1. Let subtract be a new
read-modify-write modification function with parameters (xBytes,
yBytes) that captures type and isLittleEndian and performs
the following steps atomically when called: 1. Let x be
RawBytesToNumeric(type, xBytes, isLittleEndian). 1. Let
y be RawBytesToNumeric(type, yBytes, isLittleEndian). 1.
If x is a Number, then 1. Let difference be
Number::subtract(x, y). 1. Else, 1. Assert: x is a BigInt.
1. Let difference be BigInt::subtract(x, y). 1. Let
differenceBytes be NumericToRawBytes(type, difference,
isLittleEndian). 1. Assert: differenceBytes, xBytes, and
yBytes have the same number of elements. 1. Return
differenceBytes. 1. Return ? AtomicReadModifyWrite(typedArray,
index, value, subtract).

Atomics.wait ( typedArray, index, value, timeout )
------------------------------------------------------------------

This function puts the surrounding agent in a wait queue and suspends it
until notified or until the wait times out, returning a String
differentiating those cases.

It performs the following steps when called:

1. Return ? DoWait(~sync~, typedArray, index, value,
timeout).

Atomics.waitAsync ( typedArray, index, value, timeout )
-----------------------------------------------------------------------

This function returns a Promise that is resolved when the calling agent
is notified or the timeout is reached.

It performs the following steps when called:

1. Return ? DoWait(~async~, typedArray, index, value,
timeout).

Atomics.notify ( typedArray, index, count )
-------------------------------------------------------

This function notifies some agents that are sleeping in the wait queue.

It performs the following steps when called:

1. Let byteIndexInBuffer be ?
ValidateAtomicAccessOnIntegerTypedArray(typedArray, index,
`true`). 1. If count is `undefined`, then 1. Let c be +∞. 1.
Else, 1. Let intCount be ? ToIntegerOrInfinity(count). 1. Let
c be max(intCount, 0). 1. Let buffer be
typedArray.[[ViewedArrayBuffer]]. 1. Let block be
buffer.[[ArrayBufferData]]. 1. If IsSharedArrayBuffer(buffer) is
`false`, return `+0`\ :sub:`𝔽`. 1. Let WL be
GetWaiterList(block, byteIndexInBuffer). 1. Perform
EnterCriticalSection(WL). 1. Let S be RemoveWaiters(WL,
c). 1. For each element W of S, do 1. Perform
NotifyWaiter(WL, W). 1. Perform LeaveCriticalSection(WL). 1.
Let n be the number of elements in S. 1. Return 𝔽(n).

Atomics.xor ( typedArray, index, value )
----------------------------------------------------

This function performs the following steps when called:

1. Let xor be a new read-modify-write modification function with
parameters (xBytes, yBytes) that captures nothing and performs
the following steps atomically when called: 1. Return
ByteListBitwiseOp(`^`, xBytes, yBytes). 1. Return ?
AtomicReadModifyWrite(typedArray, index, value, xor).

Atomics [ %Symbol.toStringTag% ]
--------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Atomics"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

The JSON Object
---------------

The JSON object:

- is %JSON%.
- is the initial value of the `"JSON"` property of the global object.
- is an ordinary object.
- contains two functions, `parse` and `stringify`, that are used to
  parse and construct JSON texts.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- does not have a [[Construct]] internal method; it cannot be used as a
  constructor with the `new` operator.
- does not have a [[Call]] internal method; it cannot be invoked as a
  function.

The JSON Data Interchange Format is defined in ECMA-404. The JSON
interchange format used in this specification is exactly that described
by ECMA-404. Conforming implementations of `JSON.parse` and
`JSON.stringify` must support the exact interchange format described
in the ECMA-404 specification without any deletions or extensions to the
format.

JSON.parse ( text [ , reviver ] )
-----------------------------------------

This function parses a JSON text (a JSON-formatted String) and produces
an ECMAScript language value. The JSON format represents literals,
arrays, and objects with a syntax similar to the syntax for ECMAScript
literals, Array Initializers, and Object Initializers. After parsing,
JSON objects are realized as ECMAScript objects. JSON arrays are
realized as ECMAScript Array instances. JSON strings, numbers, booleans,
and null are realized as ECMAScript Strings, Numbers, Booleans, and
`null`.

The optional reviver parameter is a function that takes two
parameters, key and value. It can filter and transform the
results. It is called with each of the key/value pairs produced
by the parse, and its return value is used instead of the original
value. If it returns what it received, the structure is not modified. If
it returns `undefined` then the property is deleted from the result.

1. Let jsonString be ? ToString(text). 1.
[id="step-json-parse-validate"] Parse StringToCodePoints(jsonString)
as a JSON text as specified in ECMA-404. Throw a `SyntaxError`
exception if it is not a valid JSON text as defined in that
specification. 1. Let scriptString be the string-concatenation of
`"("`, jsonString, and `");"`. 1. [id="step-json-parse-parse"]
Let script be ParseText(scriptString, `Script`). 1. NOTE: The
early error rules defined in have special handling for the above
invocation of ParseText. 1. Assert: script is a Parse Node. 1.
[id="step-json-parse-eval"] Let completion be Completion(Evaluation
of script). 1. NOTE: The PropertyDefinitionEvaluation semantics
defined in have special handling for the above evaluation. 1. Let
unfiltered be completion.[[Value]]. 1.
[id="step-json-parse-assert-type"] Assert: unfiltered is either a
String, a Number, a Boolean, an Object that is defined by either an
`ArrayLiteral` or an `ObjectLiteral`, or `null`. 1. If
IsCallable(reviver) is `true`, then 1. Let root be
OrdinaryObjectCreate(%Object.prototype%). 1. Let rootName be the
empty String. 1. Perform ! CreateDataPropertyOrThrow(root,
rootName, unfiltered). 1. Return ?
InternalizeJSONProperty(root, rootName, reviver). 1. Else,
1. Return unfiltered.

The `"length"` property of this function is `2`\ :sub:`𝔽`.

Valid JSON text is a subset of the ECMAScript `PrimaryExpression`
syntax. Step verifies that jsonString conforms to that subset, and
step asserts that that parsing and evaluation returns a value of an
appropriate type.

However, because behaves differently during `JSON.parse`, the same
source text can produce different results when evaluated as a
`PrimaryExpression` rather than as JSON. Furthermore, the Early Error
for duplicate `"_proto"` properties in object literals, which
likewise does not apply during `JSON.parse`, means that not all texts
accepted by `JSON.parse` are valid as a `PrimaryExpression`, despite
matching the grammar.

InternalizeJSONProperty ( holder: an Object, name: a String, reviver: a function object, )
------------------------------------------------------------------------------------------

This algorithm intentionally does not throw an exception if either
[[Delete]] or CreateDataProperty return `false`.

It performs the following steps when called:

1. Let val be ? Get(holder, name). 1. If val is an
Object, then 1. Let isArray be ? IsArray(val). 1. If isArray
is `true`, then 1. Let len be ? LengthOfArrayLike(val). 1. Let
I be 0. 1. Repeat, while I < len, 1. Let prop be !
ToString(𝔽(I)). 1. Let newElement be ?
InternalizeJSONProperty(val, prop, reviver). 1. If
newElement is `undefined`, then 1. Perform ?
val.[[Delete]](prop). 1. Else, 1. Perform ?
CreateDataProperty(val, prop, newElement). 1. Set I to
I + 1. 1. Else, 1. Let keys be ?
EnumerableOwnProperties(val, ~key~). 1. For each String P of
keys, do 1. Let newElement be ? InternalizeJSONProperty(val,
P, reviver). 1. If newElement is `undefined`, then 1.
Perform ? val.[[Delete]](P). 1. Else, 1. Perform ?
CreateDataProperty(val, P, newElement). 1. Return ?
Call(reviver, holder, « name, val »).

It is not permitted for a conforming implementation of `JSON.parse` to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

In the case where there are duplicate name Strings within an object,
lexically preceding values for the same key shall be overwritten.

JSON.stringify ( value [ , replacer [ , space ] ] )
---------------------------------------------------------------

This function returns a String in UTF-16 encoded JSON format
representing an ECMAScript language value, or `undefined`. It can take
three parameters. The value parameter is an ECMAScript language
value, which is usually an object or array, although it can also be a
String, Boolean, Number or `null`. The optional replacer parameter
is either a function that alters the way objects and arrays are
stringified, or an array of Strings and Numbers that acts as an
inclusion list for selecting the object properties that will be
stringified. The optional space parameter is a String or Number that
allows the result to have white space injected into it to improve human
readability.

It performs the following steps when called:

1. Let stack be a new empty List. 1. Let indent be the empty
String. 1. Let PropertyList be `undefined`. 1. Let
ReplacerFunction be `undefined`. 1. If replacer is an Object,
then 1. If IsCallable(replacer) is `true`, then 1. Set
ReplacerFunction to replacer. 1. Else, 1. Let isArray be ?
IsArray(replacer). 1. If isArray is `true`, then 1. Set
PropertyList to a new empty List. 1. Let len be ?
LengthOfArrayLike(replacer). 1. Let k be 0. 1. Repeat, while
k < len, 1. Let prop be ! ToString(𝔽(k)). 1. Let v
be ? Get(replacer, prop). 1. Let item be `undefined`. 1.
If v is a String, then 1. Set item to v. 1. Else if v is
a Number, then 1. Set item to ! ToString(v). 1. Else if v is
an Object, then 1. If v has a [[StringData]] or [[NumberData]]
internal slot, set item to ? ToString(v). 1. If item is not
`undefined` and PropertyList does not contain item, then 1.
Append item to PropertyList. 1. Set k to k + 1. 1. If
space is an Object, then 1. If space has a [[NumberData]]
internal slot, then 1. Set space to ? ToNumber(space). 1. Else
if space has a [[StringData]] internal slot, then 1. Set space
to ? ToString(space). 1. If space is a Number, then 1. Let
spaceMV be ! ToIntegerOrInfinity(space). 1. Set spaceMV to
min(10, spaceMV). 1. If spaceMV < 1, let gap be the empty
String; otherwise let gap be the String value containing spaceMV
occurrences of the code unit 0x0020 (SPACE). 1. Else if space is a
String, then 1. If the length of space ≤ 10, let gap be
space; otherwise let gap be the substring of space from 0 to
10. 1. Else, 1. Let gap be the empty String. 1. Let wrapper be
OrdinaryObjectCreate(%Object.prototype%). 1. Perform !
CreateDataPropertyOrThrow(wrapper, the empty String, value). 1.
Let state be the JSON Serialization Record { [[ReplacerFunction]]:
ReplacerFunction, [[Stack]]: stack, [[Indent]]: indent,
[[Gap]]: gap, [[PropertyList]]: PropertyList }. 1. Return ?
SerializeJSONProperty(state, the empty String, wrapper).

The `"length"` property of this function is `3`\ :sub:`𝔽`.

JSON structures are allowed to be nested to any depth, but they must be
acyclic. If value is or contains a cyclic structure, then this
function must throw a `TypeError` exception. This is an example of a
value that cannot be stringified:

.. code:: javascript

             a = [];
             a[0] = a;
             my_text = JSON.stringify(a); // This must throw a TypeError.
           

Symbolic primitive values are rendered as follows:

- The `null` value is rendered in JSON text as the String value
  `"null"`.
- The `undefined` value is not rendered.
- The `true` value is rendered in JSON text as the String value
  `"true"`.
- The `false` value is rendered in JSON text as the String value
  `"false"`.

String values are wrapped in QUOTATION MARK (`"`) code units. The code
units `"` and `\\\\` are escaped with `\\\\` prefixes. Control
characters code units are replaced with escape sequences `\\\\u`HHHH,
or with the shorter forms, `\\\\b` (BACKSPACE), `\\\\f` (FORM FEED),
`\\\\n` (LINE FEED), `\\\\r` (CARRIAGE RETURN), `\\\\t` (CHARACTER
TABULATION).

Finite numbers are stringified as if by calling ToString(number).
`NaN` and `Infinity` regardless of sign are represented as the
String value `"null"`.

Values that do not have a JSON representation (such as `undefined` and
functions) do not produce a String. Instead they produce the
`undefined` value. In arrays these values are represented as the
String value `"null"`. In objects an unrepresentable value causes the
property to be excluded from stringification.

An object is rendered as U+007B (LEFT CURLY BRACKET) followed by zero or
more properties, separated with a U+002C (COMMA), closed with a U+007D
(RIGHT CURLY BRACKET). A property is a quoted String representing the
property name, a U+003A (COLON), and then the stringified property
value. An array is rendered as an opening U+005B (LEFT SQUARE BRACKET)
followed by zero or more values, separated with a U+002C (COMMA), closed
with a U+005D (RIGHT SQUARE BRACKET).

JSON Serialization Record
-------------------------

A JSON Serialization Record is a Record value used to enable
serialization to the JSON format.

JSON Serialization Records have the fields listed in .

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[ReplacerFunction]] | a function object or | A function that can  |
|                      | `undefined`        | supply replacement   |
|                      |                      | values for object    |
|                      |                      | properties (from     |
|                      |                      | JSON.stringify's     |
|                      |                      | replacer         |
|                      |                      | parameter).          |
+----------------------+----------------------+----------------------+
| [[PropertyList]]     | either a List of     | The names of         |
|                      | Strings or           | properties to        |
|                      | `undefined`        | include when         |
|                      |                      | serializing a        |
|                      |                      | non-array object     |
|                      |                      | (from                |
|                      |                      | JSON.stringify's     |
|                      |                      | replacer         |
|                      |                      | parameter).          |
+----------------------+----------------------+----------------------+
| [[Gap]]              | a String             | The unit of          |
|                      |                      | indentation (from    |
|                      |                      | JSON.stringify's     |
|                      |                      | space            |
|                      |                      | parameter).          |
+----------------------+----------------------+----------------------+
| [[Stack]]            | a List of Objects    | The set of nested    |
|                      |                      | objects that are in  |
|                      |                      | the process of being |
|                      |                      | serialized. Used to  |
|                      |                      | detect cyclic        |
|                      |                      | structures.          |
+----------------------+----------------------+----------------------+
| [[Indent]]           | a String             | The current          |
|                      |                      | indentation.         |
+----------------------+----------------------+----------------------+

SerializeJSONProperty ( state: a JSON Serialization Record, key: a String, holder: an Object, )
-----------------------------------------------------------------------------------------------

1. Let value be ? Get(holder, key). 1. If value is an
Object or value is a BigInt, then 1. Let toJSON be ?
GetV(value, `"toJSON"`). 1. If IsCallable(toJSON) is `true`,
then 1. Set value to ? Call(toJSON, value, « key »). 1.
If state.[[ReplacerFunction]] is not `undefined`, then 1. Set
value to ? Call(state.[[ReplacerFunction]], holder, «
key, value »). 1. If value is an Object, then 1. If
value has a [[NumberData]] internal slot, then 1. Set value to ?
ToNumber(value). 1. Else if value has a [[StringData]] internal
slot, then 1. Set value to ? ToString(value). 1. Else if
value has a [[BooleanData]] internal slot, then 1. Set value to
value.[[BooleanData]]. 1. Else if value has a [[BigIntData]]
internal slot, then 1. Set value to value.[[BigIntData]]. 1. If
value is `null`, return `"null"`. 1. If value is `true`,
return `"true"`. 1. If value is `false`, return `"false"`. 1.
If value is a String, return QuoteJSONString(value). 1. If
value is a Number, then 1. If value is finite, return !
ToString(value). 1. Return `"null"`. 1. If value is a BigInt,
throw a `TypeError` exception. 1. If value is an Object and
IsCallable(value) is `false`, then 1. Let isArray be ?
IsArray(value). 1. If isArray is `true`, return ?
SerializeJSONArray(state, value). 1. Return ?
SerializeJSONObject(state, value). 1. Return `undefined`.

QuoteJSONString ( value: a String, ): a String
--------------------------------------------------

description
   It wraps value in 0x0022 (QUOTATION MARK) code units and escapes
   certain other code units within it. This operation interprets
   value as a sequence of UTF-16 encoded code points, as described
   in .

1. Let product be the String value consisting solely of the code
unit 0x0022 (QUOTATION MARK). 1. For each code point C of
StringToCodePoints(value), do 1. If C is listed in the “Code
Point” column of , then 1. Set product to the string-concatenation
of product and the escape sequence for C as specified in the
“Escape Sequence” column of the corresponding row. 1. Else if C has
a numeric value less than 0x0020 (SPACE) or C has the same numeric
value as a leading surrogate or trailing surrogate, then 1. Let unit
be the code unit whose numeric value is the numeric value of C. 1.
Set product to the string-concatenation of product and
UnicodeEscape(unit). 1. Else, 1. Set product to the
string-concatenation of product and UTF16EncodeCodePoint(C). 1.
Set product to the string-concatenation of product and the code
unit 0x0022 (QUOTATION MARK). 1. Return product.

========== ====================== ===============
Code Point Unicode Character Name Escape Sequence
========== ====================== ===============
U+0008     BACKSPACE              `\\\\b`
U+0009     CHARACTER TABULATION   `\\\\t`
U+000A     LINE FEED (LF)         `\\\\n`
U+000C     FORM FEED (FF)         `\\\\f`
U+000D     CARRIAGE RETURN (CR)   `\\\\r`
U+0022     QUOTATION MARK         `\\\\"`
U+005C     REVERSE SOLIDUS        `\\\\\\\\`
========== ====================== ===============

UnicodeEscape ( C: a code unit, ): a String
-----------------------------------------------

description
   It represents C as a Unicode escape sequence.

1. Let n be the numeric value of C. 1. Assert: n ≤ 0xFFFF.
1. Let hex be the String representation of n, formatted as a
lowercase hexadecimal number. 1. Return the string-concatenation of the
code unit 0x005C (REVERSE SOLIDUS), `"u"`, and StringPad(hex, 4,
`"0"`, ~start~).

SerializeJSONObject ( state: a JSON Serialization Record, value: an Object, )
-----------------------------------------------------------------------------

description
   It serializes an object.

1. If state.[[Stack]] contains value, throw a `TypeError`
exception because the structure is cyclical. 1. Append value to
state.[[Stack]]. 1. Let stepBack be state.[[Indent]]. 1. Set
state.[[Indent]] to the string-concatenation of state.[[Indent]]
and state.[[Gap]]. 1. If state.[[PropertyList]] is not
`undefined`, then 1. Let K be state.[[PropertyList]]. 1. Else,
1. Let K be ? EnumerableOwnProperties(value, ~key~). 1. Let
partial be a new empty List. 1. For each element P of K, do
1. Let strP be ? SerializeJSONProperty(state, P, value).
1. If strP is not `undefined`, then 1. Let member be
QuoteJSONString(P). 1. Set member to the string-concatenation of
member and `":"`. 1. If state.[[Gap]] is not the empty String,
then 1. Set member to the string-concatenation of member and the
code unit 0x0020 (SPACE). 1. Set member to the string-concatenation
of member and strP. 1. Append member to partial. 1. If
partial is empty, then 1. Let final be `"{}"`. 1. Else, 1. If
state.[[Gap]] is the empty String, then 1. Let properties be the
String value formed by concatenating all the element Strings of
partial with each adjacent pair of Strings separated with the code
unit 0x002C (COMMA). A comma is not inserted either before the first
String or after the last String. 1. Let final be the
string-concatenation of `"{"`, properties, and `"}"`. 1. Else,
1. Let separator be the string-concatenation of the code unit 0x002C
(COMMA), the code unit 0x000A (LINE FEED), and state.[[Indent]]. 1.
Let properties be the String value formed by concatenating all the
element Strings of partial with each adjacent pair of Strings
separated with separator. The separator String is not inserted
either before the first String or after the last String. 1. Let
final be the string-concatenation of `"{"`, the code unit 0x000A
(LINE FEED), state.[[Indent]], properties, the code unit 0x000A
(LINE FEED), stepBack, and `"}"`. 1. Remove the last element of
state.[[Stack]]. 1. Set state.[[Indent]] to stepBack. 1.
Return final.

SerializeJSONArray ( state: a JSON Serialization Record, value, )
-----------------------------------------------------------------

description
   It serializes an array.

1. If state.[[Stack]] contains value, throw a `TypeError`
exception because the structure is cyclical. 1. Append value to
state.[[Stack]]. 1. Let stepBack be state.[[Indent]]. 1. Set
state.[[Indent]] to the string-concatenation of state.[[Indent]]
and state.[[Gap]]. 1. Let partial be a new empty List. 1. Let
len be ? LengthOfArrayLike(value). 1. Let index be 0. 1.
Repeat, while index < len, 1. Let strP be ?
SerializeJSONProperty(state, ! ToString(𝔽(index)), value).
1. If strP is `undefined`, then 1. Append `"null"` to
partial. 1. Else, 1. Append strP to partial. 1. Set
index to index + 1. 1. If partial is empty, then 1. Let
final be `"[]"`. 1. Else, 1. If state.[[Gap]] is the empty
String, then 1. Let properties be the String value formed by
concatenating all the element Strings of partial with each adjacent
pair of Strings separated with the code unit 0x002C (COMMA). A comma is
not inserted either before the first String or after the last String. 1.
Let final be the string-concatenation of `"["`, properties,
and `"]"`. 1. Else, 1. Let separator be the string-concatenation
of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and
state.[[Indent]]. 1. Let properties be the String value formed
by concatenating all the element Strings of partial with each
adjacent pair of Strings separated with separator. The separator
String is not inserted either before the first String or after the last
String. 1. Let final be the string-concatenation of `"["`, the
code unit 0x000A (LINE FEED), state.[[Indent]], properties, the
code unit 0x000A (LINE FEED), stepBack, and `"]"`. 1. Remove the
last element of state.[[Stack]]. 1. Set state.[[Indent]] to
stepBack. 1. Return final.

The representation of arrays includes only the elements in the interval
from `+0`\ :sub:`𝔽` (inclusive) to `array.length` (exclusive).
Properties whose keys are not array indices are excluded from the
stringification. An array is stringified as an opening LEFT SQUARE
BRACKET, elements separated by COMMA, and a closing RIGHT SQUARE
BRACKET.

JSON [ %Symbol.toStringTag% ]
-----------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"JSON"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

26. Managing Memory
===================

https://tc39.es/ecma262/multipage/managing-memory.html
::

    26.1 WeakRef Objects
        26.1.1 The WeakRef Constructor
            26.1.1.1 WeakRef ( target )
        26.1.2 Properties of the WeakRef Constructor
            26.1.2.1 WeakRef.prototype
        26.1.3 Properties of the WeakRef Prototype Object
            26.1.3.1 WeakRef.prototype.constructor
            26.1.3.2 WeakRef.prototype.deref ( )
            26.1.3.3 WeakRef.prototype [ %Symbol.toStringTag% ]
        26.1.4 WeakRef Abstract Operations
            26.1.4.1 WeakRefDeref ( weakRef )
        26.1.5 Properties of WeakRef Instances
    26.2 FinalizationRegistry Objects
        26.2.1 The FinalizationRegistry Constructor
            26.2.1.1 FinalizationRegistry ( cleanupCallback )
        26.2.2 Properties of the FinalizationRegistry Constructor
            26.2.2.1 FinalizationRegistry.prototype
        26.2.3 Properties of the FinalizationRegistry Prototype Object
            26.2.3.1 FinalizationRegistry.prototype.constructor
            26.2.3.2 FinalizationRegistry.prototype.register ( target, heldValue [ , unregisterToken ] )
            26.2.3.3 FinalizationRegistry.prototype.unregister ( unregisterToken )
            26.2.3.4 FinalizationRegistry.prototype [ %Symbol.toStringTag% ]
        26.2.4 Properties of FinalizationRegistry Instances


WeakRef Objects
---------------

A WeakRef is an object that is used to refer to a target object or
symbol without preserving it from garbage collection. WeakRefs can be
dereferenced to allow access to the target value, if the target hasn't
been reclaimed by garbage collection.

The WeakRef Constructor
-----------------------

The WeakRef constructor:

- is %WeakRef%.
- is the initial value of the `"WeakRef"` property of the global
  object.
- creates and initializes a new WeakRef when called as a constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value in an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  `WeakRef` behaviour must include a `super` call to the `WeakRef`
  constructor to create and initialize the subclass instance with the
  internal state necessary to support the `WeakRef.prototype` built-in
  methods.

WeakRef ( target )
----------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1. If
CanBeHeldWeakly(target) is `false`, throw a `TypeError`
exception. 1. Let weakRef be ?
OrdinaryCreateFromConstructor(NewTarget, `"%WeakRef.prototype%"`, «
[[WeakRefTarget]] »). 1. Perform AddToKeptObjects(target). 1. Set
weakRef.[[WeakRefTarget]] to target. 1. Return weakRef.

Properties of the WeakRef Constructor
-------------------------------------

The WeakRef constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

WeakRef.prototype
-----------------

The initial value of `WeakRef.prototype` is the WeakRef prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the WeakRef Prototype Object
------------------------------------------

The WeakRef prototype object:

- is %WeakRef.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have a [[WeakRefTarget]] internal slot.

WeakRef.prototype.constructor
-----------------------------

The initial value of `WeakRef.prototype.constructor` is %WeakRef%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

WeakRef.prototype.deref ( )
---------------------------

This method performs the following steps when called:

1. Let weakRef be the `this` value. 1. Perform ?
RequireInternalSlot(weakRef, [[WeakRefTarget]]). 1. Return
WeakRefDeref(weakRef).

If the WeakRef returns a target value that is not `undefined`,
then this target value should not be garbage collected until the
current execution of ECMAScript code has completed. The AddToKeptObjects
operation makes sure read consistency is maintained.

.. code:: javascript

               let target = { foo() {} };
               let weakRef = new WeakRef(target);

               // ... later ...

               if (weakRef.deref()) {
                 weakRef.deref().foo();
               }
             

In the above example, if the first deref does not evaluate to
`undefined` then the second deref cannot either.

WeakRef.prototype [ %Symbol.toStringTag% ]
------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"WeakRef"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

WeakRef Abstract Operations
---------------------------

WeakRefDeref ( weakRef: a WeakRef, )
----------------------------------------------------------------------

1. Let target be weakRef.[[WeakRefTarget]]. 1. If target is
not ~empty~, then 1. Perform AddToKeptObjects(target). 1. Return
target. 1. Return `undefined`.

This abstract operation is defined separately from
WeakRef.prototype.deref strictly to make it possible to succinctly
define liveness.

Properties of WeakRef Instances
-------------------------------

WeakRef instances are ordinary objects that inherit properties from the
WeakRef prototype. WeakRef instances also have a [[WeakRefTarget]]
internal slot.

FinalizationRegistry Objects
----------------------------

A FinalizationRegistry is an object that manages registration and
unregistration of cleanup operations that are performed when target
objects and symbols are garbage collected.

The FinalizationRegistry Constructor
------------------------------------

The FinalizationRegistry constructor:

- is %FinalizationRegistry%.
- is the initial value of the `"FinalizationRegistry"` property of the
  global object.
- creates and initializes a new FinalizationRegistry when called as a
  constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value in an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  `FinalizationRegistry` behaviour must include a `super` call to
  the `FinalizationRegistry` constructor to create and initialize the
  subclass instance with the internal state necessary to support the
  `FinalizationRegistry.prototype` built-in methods.

FinalizationRegistry ( cleanupCallback )
--------------------------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1. If
IsCallable(cleanupCallback) is `false`, throw a `TypeError`
exception. 1. Let finalizationRegistry be ?
OrdinaryCreateFromConstructor(NewTarget,
`"%FinalizationRegistry.prototype%"`, « [[Realm]],
[[CleanupCallback]], [[Cells]] »). 1. Let fn be the active function
object. 1. Set finalizationRegistry.[[Realm]] to fn.[[Realm]].
1. Set finalizationRegistry.[[CleanupCallback]] to
HostMakeJobCallback(cleanupCallback). 1. Set
finalizationRegistry.[[Cells]] to a new empty List. 1. Return
finalizationRegistry.

Properties of the FinalizationRegistry Constructor
--------------------------------------------------

The FinalizationRegistry constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

FinalizationRegistry.prototype
------------------------------

The initial value of `FinalizationRegistry.prototype` is the
FinalizationRegistry prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the FinalizationRegistry Prototype Object
-------------------------------------------------------

The FinalizationRegistry prototype object:

- is %FinalizationRegistry.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have [[Cells]] and [[CleanupCallback]] internal slots.

FinalizationRegistry.prototype.constructor
------------------------------------------

The initial value of `FinalizationRegistry.prototype.constructor` is
%FinalizationRegistry%.

FinalizationRegistry.prototype.register ( target, heldValue [ , unregisterToken ] )
-----------------------------------------------------------------------------------------------

This method performs the following steps when called:

1. Let finalizationRegistry be the `this` value. 1. Perform ?
RequireInternalSlot(finalizationRegistry, [[Cells]]). 1. If
CanBeHeldWeakly(target) is `false`, throw a `TypeError`
exception. 1. If SameValue(target, heldValue) is `true`, throw
a `TypeError` exception. 1. If CanBeHeldWeakly(unregisterToken) is
`false`, then 1. If unregisterToken is not `undefined`, throw a
`TypeError` exception. 1. Set unregisterToken to ~empty~. 1. Let
cell be the Record { [[WeakRefTarget]]: target, [[HeldValue]]:
heldValue, [[UnregisterToken]]: unregisterToken }. 1. Append
cell to finalizationRegistry.[[Cells]]. 1. Return `undefined`.

Based on the algorithms and definitions in this specification,
cell.[[HeldValue]] is live when finalizationRegistry.[[Cells]]
contains cell; however, this does not necessarily mean that
cell.[[UnregisterToken]] or cell.[[Target]] are live. For
example, registering an object with itself as its unregister token would
not keep the object alive forever.

FinalizationRegistry.prototype.unregister ( unregisterToken )
-----------------------------------------------------------------

This method performs the following steps when called:

1. Let finalizationRegistry be the `this` value. 1. Perform ?
RequireInternalSlot(finalizationRegistry, [[Cells]]). 1. If
CanBeHeldWeakly(unregisterToken) is `false`, throw a `TypeError`
exception. 1. Let removed be `false`. 1. For each Record {
[[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } cell of
finalizationRegistry.[[Cells]], do 1. If
cell.[[UnregisterToken]] is not ~empty~ and
SameValue(cell.[[UnregisterToken]], unregisterToken) is
`true`, then 1. Remove cell from
finalizationRegistry.[[Cells]]. 1. Set removed to `true`. 1.
Return removed.

FinalizationRegistry.prototype [ %Symbol.toStringTag% ]
-------------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"FinalizationRegistry"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of FinalizationRegistry Instances
--------------------------------------------

FinalizationRegistry instances are ordinary objects that inherit
properties from the FinalizationRegistry prototype. FinalizationRegistry
instances also have [[Cells]] and [[CleanupCallback]] internal slots.

27. Control Abstraction Objects
===============================

https://tc39.es/ecma262/multipage/control-abstraction-objects.html
::

    27.1 Iteration
        27.1.1 Common Iteration Interfaces
            27.1.1.1 The Iterable Interface
            27.1.1.2 The Iterator Interface
            27.1.1.3 The Async Iterable Interface
            27.1.1.4 The Async Iterator Interface
            27.1.1.5 The IteratorResult Interface
        27.1.2 Iterator Helper Objects
            27.1.2.1 The %IteratorHelperPrototype% Object
                27.1.2.1.1 %IteratorHelperPrototype%.next ( )
                27.1.2.1.2 %IteratorHelperPrototype%.return ( )
                27.1.2.1.3 %IteratorHelperPrototype% [ %Symbol.toStringTag% ]
        27.1.3 Iterator Objects
            27.1.3.1 The Iterator Constructor
                27.1.3.1.1 Iterator ( )
            27.1.3.2 Properties of the Iterator Constructor
                27.1.3.2.1 Iterator.from ( O )
                    27.1.3.2.1.1 The %WrapForValidIteratorPrototype% Object
                        27.1.3.2.1.1.1 %WrapForValidIteratorPrototype%.next ( )
                        27.1.3.2.1.1.2 %WrapForValidIteratorPrototype%.return ( )
                27.1.3.2.2 Iterator.prototype
        27.1.4 The %Iterator.prototype% Object
            27.1.4.1 Iterator.prototype.constructor
                27.1.4.1.1 get Iterator.prototype.constructor
                27.1.4.1.2 set Iterator.prototype.constructor
            27.1.4.2 Iterator.prototype.drop ( limit )
            27.1.4.3 Iterator.prototype.every ( predicate )
            27.1.4.4 Iterator.prototype.filter ( predicate )
            27.1.4.5 Iterator.prototype.find ( predicate )
            27.1.4.6 Iterator.prototype.flatMap ( mapper )
            27.1.4.7 Iterator.prototype.forEach ( procedure )
            27.1.4.8 Iterator.prototype.map ( mapper )
            27.1.4.9 Iterator.prototype.reduce ( reducer [ , initialValue ] )
            27.1.4.10 Iterator.prototype.some ( predicate )
            27.1.4.11 Iterator.prototype.take ( limit )
            27.1.4.12 Iterator.prototype.toArray ( )
            27.1.4.13 Iterator.prototype [ %Symbol.iterator% ] ( )
            27.1.4.14 Iterator.prototype [ %Symbol.toStringTag% ]
                27.1.4.14.1 get Iterator.prototype [ %Symbol.toStringTag% ]
                27.1.4.14.2 set Iterator.prototype [ %Symbol.toStringTag% ]
        27.1.5 The %AsyncIteratorPrototype% Object
            27.1.5.1 %AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )
        27.1.6 Async-from-Sync Iterator Objects
            27.1.6.1 CreateAsyncFromSyncIterator ( syncIteratorRecord )
            27.1.6.2 The %AsyncFromSyncIteratorPrototype% Object
                27.1.6.2.1 %AsyncFromSyncIteratorPrototype%.next ( [ value ] )
                27.1.6.2.2 %AsyncFromSyncIteratorPrototype%.return ( [ value ] )
                27.1.6.2.3 %AsyncFromSyncIteratorPrototype%.throw ( [ value ] )
            27.1.6.3 Properties of Async-from-Sync Iterator Instances
            27.1.6.4 AsyncFromSyncIteratorContinuation ( result, promiseCapability )
    27.2 Promise Objects
        27.2.1 Promise Abstract Operations
            27.2.1.1 PromiseCapability Records
                27.2.1.1.1 IfAbruptRejectPromise ( value, capability )
            27.2.1.2 PromiseReaction Records
            27.2.1.3 CreateResolvingFunctions ( promise )
                27.2.1.3.1 Promise Reject Functions
                27.2.1.3.2 Promise Resolve Functions
            27.2.1.4 FulfillPromise ( promise, value )
            27.2.1.5 NewPromiseCapability ( C )
            27.2.1.6 IsPromise ( x )
            27.2.1.7 RejectPromise ( promise, reason )
            27.2.1.8 TriggerPromiseReactions ( reactions, argument )
            27.2.1.9 HostPromiseRejectionTracker ( promise, operation )
        27.2.2 Promise Jobs
            27.2.2.1 NewPromiseReactionJob ( reaction, argument )
            27.2.2.2 NewPromiseResolveThenableJob ( promiseToResolve, thenable, then )
        27.2.3 The Promise Constructor
            27.2.3.1 Promise ( executor )
        27.2.4 Properties of the Promise Constructor
            27.2.4.1 Promise.all ( iterable )
                27.2.4.1.1 GetPromiseResolve ( promiseConstructor )
                27.2.4.1.2 PerformPromiseAll ( iteratorRecord, constructor, resultCapability, promiseResolve )
                27.2.4.1.3 <code>Promise.all</code> Resolve Element Functions
            27.2.4.2 Promise.allSettled ( iterable )
                27.2.4.2.1 PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability, promiseResolve )
                27.2.4.2.2 <code>Promise.allSettled</code> Resolve Element Functions
                27.2.4.2.3 <code>Promise.allSettled</code> Reject Element Functions
            27.2.4.3 Promise.any ( iterable )
                27.2.4.3.1 PerformPromiseAny ( iteratorRecord, constructor, resultCapability, promiseResolve )
                27.2.4.3.2 <code>Promise.any</code> Reject Element Functions
            27.2.4.4 Promise.prototype
            27.2.4.5 Promise.race ( iterable )
                27.2.4.5.1 PerformPromiseRace ( iteratorRecord, constructor, resultCapability, promiseResolve )
            27.2.4.6 Promise.reject ( r )
            27.2.4.7 Promise.resolve ( x )
                27.2.4.7.1 PromiseResolve ( C, x )
            27.2.4.8 Promise.try ( callback, ...args )
            27.2.4.9 Promise.withResolvers ( )
            27.2.4.10 get Promise [ %Symbol.species% ]
        27.2.5 Properties of the Promise Prototype Object
            27.2.5.1 Promise.prototype.catch ( onRejected )
            27.2.5.2 Promise.prototype.constructor
            27.2.5.3 Promise.prototype.finally ( onFinally )
            27.2.5.4 Promise.prototype.then ( onFulfilled, onRejected )
                27.2.5.4.1 PerformPromiseThen ( promise, onFulfilled, onRejected [ , resultCapability ] )
            27.2.5.5 Promise.prototype [ %Symbol.toStringTag% ]
        27.2.6 Properties of Promise Instances
    27.3 GeneratorFunction Objects
        27.3.1 The GeneratorFunction Constructor
            27.3.1.1 GeneratorFunction ( ...parameterArgs, bodyArg )
        27.3.2 Properties of the GeneratorFunction Constructor
            27.3.2.1 GeneratorFunction.prototype
        27.3.3 Properties of the GeneratorFunction Prototype Object
            27.3.3.1 GeneratorFunction.prototype.constructor
            27.3.3.2 GeneratorFunction.prototype.prototype
            27.3.3.3 GeneratorFunction.prototype [ %Symbol.toStringTag% ]
        27.3.4 GeneratorFunction Instances
            27.3.4.1 length
            27.3.4.2 name
            27.3.4.3 prototype
    27.4 AsyncGeneratorFunction Objects
        27.4.1 The AsyncGeneratorFunction Constructor
            27.4.1.1 AsyncGeneratorFunction ( ...parameterArgs, bodyArg )
        27.4.2 Properties of the AsyncGeneratorFunction Constructor
            27.4.2.1 AsyncGeneratorFunction.prototype
        27.4.3 Properties of the AsyncGeneratorFunction Prototype Object
            27.4.3.1 AsyncGeneratorFunction.prototype.constructor
            27.4.3.2 AsyncGeneratorFunction.prototype.prototype
            27.4.3.3 AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]
        27.4.4 AsyncGeneratorFunction Instances
            27.4.4.1 length
            27.4.4.2 name
            27.4.4.3 prototype
    27.5 Generator Objects
        27.5.1 The %GeneratorPrototype% Object
            27.5.1.1 %GeneratorPrototype%.constructor
            27.5.1.2 %GeneratorPrototype%.next ( value )
            27.5.1.3 %GeneratorPrototype%.return ( value )
            27.5.1.4 %GeneratorPrototype%.throw ( exception )
            27.5.1.5 %GeneratorPrototype% [ %Symbol.toStringTag% ]
        27.5.2 Properties of Generator Instances
        27.5.3 Generator Abstract Operations
            27.5.3.1 GeneratorStart ( generator, generatorBody )
            27.5.3.2 GeneratorValidate ( generator, generatorBrand )
            27.5.3.3 GeneratorResume ( generator, value, generatorBrand
              )
            27.5.3.4 GeneratorResumeAbrupt ( generator, abruptCompletion,
              generatorBrand )
            27.5.3.5 GetGeneratorKind ( )
            27.5.3.6 GeneratorYield ( iteratorResult )
            27.5.3.7 Yield ( value )
            27.5.3.8 CreateIteratorFromClosure ( closure, generatorBrand, generatorPrototype [ , extraSlots ] )
    27.6 AsyncGenerator Objects
        27.6.1 The %AsyncGeneratorPrototype% Object
            27.6.1.1 %AsyncGeneratorPrototype%.constructor
            27.6.1.2 %AsyncGeneratorPrototype%.next ( value )
            27.6.1.3 %AsyncGeneratorPrototype%.return ( value )
            27.6.1.4 %AsyncGeneratorPrototype%.throw ( exception )
            27.6.1.5 %AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]
        27.6.2 Properties of AsyncGenerator Instances
        27.6.3 AsyncGenerator Abstract Operations
            27.6.3.1 AsyncGeneratorRequest Records
            27.6.3.2 AsyncGeneratorStart ( generator, generatorBody )
            27.6.3.3 AsyncGeneratorValidate ( generator, generatorBrand )
            27.6.3.4 AsyncGeneratorEnqueue ( generator, completion, promiseCapability )
            27.6.3.5 AsyncGeneratorCompleteStep ( generator, completion, done [ , realm ] )
            27.6.3.6 AsyncGeneratorResume ( generator, completion )
            27.6.3.7 AsyncGeneratorUnwrapYieldResumption ( resumptionValue )
            27.6.3.8 AsyncGeneratorYield ( value )
            27.6.3.9 AsyncGeneratorAwaitReturn ( generator )
            27.6.3.10 AsyncGeneratorDrainQueue ( generator )
            27.6.3.11 CreateAsyncIteratorFromClosure ( closure, generatorBrand, generatorPrototype )
    27.7 AsyncFunction Objects
        27.7.1 The AsyncFunction Constructor
            27.7.1.1 AsyncFunction ( ...parameterArgs, bodyArg )
        27.7.2 Properties of the AsyncFunction Constructor
            27.7.2.1 AsyncFunction.prototype
        27.7.3 Properties of the AsyncFunction Prototype Object
            27.7.3.1 AsyncFunction.prototype.constructor
            27.7.3.2 AsyncFunction.prototype [ %Symbol.toStringTag% ]
        27.7.4 AsyncFunction Instances
            27.7.4.1 length
            27.7.4.2 name
        27.7.5 Async Functions Abstract Operations
            27.7.5.1 AsyncFunctionStart ( promiseCapability, asyncFunctionBody )
            27.7.5.2 AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )
            27.7.5.3 Await ( value )


Iteration
---------

Common Iteration Interfaces
---------------------------

An interface is a set of property keys whose associated values match a
specific specification. Any object that provides all the properties as
described by an interface's specification *conforms* to that interface.
An interface is not represented by a distinct object. There may be many
separately implemented objects that conform to any interface. An
individual object may conform to multiple interfaces.

The Iterable Interface
----------------------

The iterable interface includes the property described in :

+----------------------+----------------------+----------------------+
| Property             | Value                | Requirements         |
+======================+======================+======================+
| \                    | a function that      | The returned object  |
| `%Symbol.iterator%` | returns an iterator  | must conform to the  |
|                      | object               | iterator interface.  |
+----------------------+----------------------+----------------------+

The Iterator Interface
----------------------

An object that implements the iterator interface must include the
property in . Such objects may also implement the properties in .

+------------+---------------------------+---------------------------+
| Property   | Value                     | Requirements              |
+============+===========================+===========================+
| `"next"` | a function that returns   | The returned object must  |
|            | an IteratorResult object  | conform to the            |
|            |                           | IteratorResult interface. |
|            |                           | If a previous call to the |
|            |                           | `next` method of an     |
|            |                           | iterator has returned an  |
|            |                           | IteratorResult object     |
|            |                           | whose `"done"` property |
|            |                           | is `true`, then all     |
|            |                           | subsequent calls to the   |
|            |                           | `next` method of that   |
|            |                           | object should also return |
|            |                           | an IteratorResult object  |
|            |                           | whose `"done"` property |
|            |                           | is `true`. However,     |
|            |                           | this requirement is not   |
|            |                           | enforced.                 |
+------------+---------------------------+---------------------------+

Arguments may be passed to the `next` function but their
interpretation and validity is dependent upon the target iterator. The
for-of statement and other common users of *Iterators* do not pass any
arguments, so iterator objects that expect to be used in such a manner
must be prepared to deal with being called with no arguments.

+--------------+--------------------------+--------------------------+
| Property     | Value                    | Requirements             |
+==============+==========================+==========================+
| `"return"` | a function that returns  | The returned object must |
|              | an IteratorResult object | conform to the           |
|              |                          | IteratorResult           |
|              |                          | interface. Invoking this |
|              |                          | method notifies the      |
|              |                          | iterator object that the |
|              |                          | caller does not intend   |
|              |                          | to make any more         |
|              |                          | `next` method calls to |
|              |                          | the iterator. The        |
|              |                          | returned IteratorResult  |
|              |                          | object will typically    |
|              |                          | have a `"done"`        |
|              |                          | property whose value is  |
|              |                          | `true`, and a          |
|              |                          | `"value"` property     |
|              |                          | with the value passed as |
|              |                          | the argument of the      |
|              |                          | `return` method.       |
|              |                          | However, this            |
|              |                          | requirement is not       |
|              |                          | enforced.                |
+--------------+--------------------------+--------------------------+
| `"throw"`  | a function that returns  | The returned object must |
|              | an IteratorResult object | conform to the           |
|              |                          | IteratorResult           |
|              |                          | interface. Invoking this |
|              |                          | method notifies the      |
|              |                          | iterator object that the |
|              |                          | caller has detected an   |
|              |                          | error condition. The     |
|              |                          | argument may be used to  |
|              |                          | identify the error       |
|              |                          | condition and typically  |
|              |                          | will be an exception     |
|              |                          | object. A typical        |
|              |                          | response is to `throw` |
|              |                          | the value passed as the  |
|              |                          | argument. If the method  |
|              |                          | does not `throw`, the  |
|              |                          | returned IteratorResult  |
|              |                          | object will typically    |
|              |                          | have a `"done"`        |
|              |                          | property whose value is  |
|              |                          | `true`.                |
+--------------+--------------------------+--------------------------+

Typically callers of these methods should check for their existence
before invoking them. Certain ECMAScript language features including
`for`-`of`, `yield*`, and array destructuring call these methods
after performing an existence check. Most ECMAScript library functions
that accept iterable objects as arguments also conditionally call them.

The Async Iterable Interface
----------------------------

The async iterable interface includes the properties described in :

+----------------------+----------------------+----------------------+
| Property             | Value                | Requirements         |
+======================+======================+======================+
| `%Sym               | a function that      | The returned object  |
| bol.asyncIterator%` | returns an async     | must conform to the  |
|                      | iterator object      | async iterator       |
|                      |                      | interface.           |
+----------------------+----------------------+----------------------+

The Async Iterator Interface
----------------------------

An object that implements the async iterator interface must include the
properties in . Such objects may also implement the properties in .

+-----------------------+-----------------------+-----------------------+
| Property              | Value                 | Requirements          |
+=======================+=======================+=======================+
| `"next"`            | a function that       | The returned promise, |
|                       | returns a promise for | when fulfilled, must  |
|                       | an IteratorResult     | fulfill with an       |
|                       | object                | object that conforms  |
|                       |                       | to the IteratorResult |
|                       |                       | interface. If a       |
|                       |                       | previous call to the  |
|                       |                       | `next` method of an |
|                       |                       | async iterator has    |
|                       |                       | returned a promise    |
|                       |                       | for an IteratorResult |
|                       |                       | object whose          |
|                       |                       | `"done"` property   |
|                       |                       | is `true`, then all |
|                       |                       | subsequent calls to   |
|                       |                       | the `next` method   |
|                       |                       | of that object should |
|                       |                       | also return a promise |
|                       |                       | for an IteratorResult |
|                       |                       | object whose          |
|                       |                       | `"done"` property   |
|                       |                       | is `true`. However, |
|                       |                       | this requirement is   |
|                       |                       | not enforced.         |
|                       |                       |                       |
|                       |                       | Additionally, the     |
|                       |                       | IteratorResult object |
|                       |                       | that serves as a      |
|                       |                       | fulfillment value     |
|                       |                       | should have a         |
|                       |                       | `"value"` property  |
|                       |                       | whose value is not a  |
|                       |                       | promise (or           |
|                       |                       | "thenable"). However, |
|                       |                       | this requirement is   |
|                       |                       | also not enforced.    |
+-----------------------+-----------------------+-----------------------+

Arguments may be passed to the `next` function but their
interpretation and validity is dependent upon the target async iterator.
The `for`-`await`-`of` statement and other common users of
*AsyncIterators* do not pass any arguments, so async iterator objects
that expect to be used in such a manner must be prepared to deal with
being called with no arguments.

+-----------------------+-----------------------+-----------------------+
| Property              | Value                 | Requirements          |
+=======================+=======================+=======================+
| `"return"`          | a function that       | The returned promise, |
|                       | returns a promise for | when fulfilled, must  |
|                       | an IteratorResult     | fulfill with an       |
|                       | object                | object that conforms  |
|                       |                       | to the IteratorResult |
|                       |                       | interface. Invoking   |
|                       |                       | this method notifies  |
|                       |                       | the async iterator    |
|                       |                       | object that the       |
|                       |                       | caller does not       |
|                       |                       | intend to make any    |
|                       |                       | more `next` method  |
|                       |                       | calls to the async    |
|                       |                       | iterator. The         |
|                       |                       | returned promise will |
|                       |                       | fulfill with an       |
|                       |                       | IteratorResult object |
|                       |                       | which will typically  |
|                       |                       | have a `"done"`     |
|                       |                       | property whose value  |
|                       |                       | is `true`, and a    |
|                       |                       | `"value"` property  |
|                       |                       | with the value passed |
|                       |                       | as the argument of    |
|                       |                       | the `return`        |
|                       |                       | method. However, this |
|                       |                       | requirement is not    |
|                       |                       | enforced.             |
|                       |                       |                       |
|                       |                       | Additionally, the     |
|                       |                       | IteratorResult object |
|                       |                       | that serves as a      |
|                       |                       | fulfillment value     |
|                       |                       | should have a         |
|                       |                       | `"value"` property  |
|                       |                       | whose value is not a  |
|                       |                       | promise (or           |
|                       |                       | "thenable"). If the   |
|                       |                       | argument value is     |
|                       |                       | used in the typical   |
|                       |                       | manner, then if it is |
|                       |                       | a rejected promise, a |
|                       |                       | promise rejected with |
|                       |                       | the same reason       |
|                       |                       | should be returned;   |
|                       |                       | if it is a fulfilled  |
|                       |                       | promise, then its     |
|                       |                       | fulfillment value     |
|                       |                       | should be used as the |
|                       |                       | `"value"` property  |
|                       |                       | of the returned       |
|                       |                       | promise's             |
|                       |                       | IteratorResult object |
|                       |                       | fulfillment value.    |
|                       |                       | However, these        |
|                       |                       | requirements are also |
|                       |                       | not enforced.         |
+-----------------------+-----------------------+-----------------------+
| `"throw"`           | a function that       | The returned promise, |
|                       | returns a promise for | when fulfilled, must  |
|                       | an IteratorResult     | fulfill with an       |
|                       | object                | object that conforms  |
|                       |                       | to the IteratorResult |
|                       |                       | interface. Invoking   |
|                       |                       | this method notifies  |
|                       |                       | the async iterator    |
|                       |                       | object that the       |
|                       |                       | caller has detected   |
|                       |                       | an error condition.   |
|                       |                       | The argument may be   |
|                       |                       | used to identify the  |
|                       |                       | error condition and   |
|                       |                       | typically will be an  |
|                       |                       | exception object. A   |
|                       |                       | typical response is   |
|                       |                       | to return a rejected  |
|                       |                       | promise which rejects |
|                       |                       | with the value passed |
|                       |                       | as the argument.      |
|                       |                       |                       |
|                       |                       | If the returned       |
|                       |                       | promise is fulfilled, |
|                       |                       | the IteratorResult    |
|                       |                       | object fulfillment    |
|                       |                       | value will typically  |
|                       |                       | have a `"done"`     |
|                       |                       | property whose value  |
|                       |                       | is `true`.          |
|                       |                       | Additionally, it      |
|                       |                       | should have a         |
|                       |                       | `"value"` property  |
|                       |                       | whose value is not a  |
|                       |                       | promise (or           |
|                       |                       | "thenable"), but this |
|                       |                       | requirement is not    |
|                       |                       | enforced.             |
+-----------------------+-----------------------+-----------------------+

Typically callers of these methods should check for their existence
before invoking them. Certain ECMAScript language features including
`for`-`await`-`of` and `yield*` call these methods after
performing an existence check.

The IteratorResult Interface
----------------------------

The IteratorResult interface includes the properties listed in :

+-------------+--------------------------+--------------------------+
| Property    | Value                    | Requirements             |
+=============+==========================+==========================+
| `"done"`  | a Boolean                | This is the result       |
|             |                          | status of an *iterator*  |
|             |                          | `next` method call. If |
|             |                          | the end of the iterator  |
|             |                          | was reached `"done"`   |
|             |                          | is `true`. If the end  |
|             |                          | was not reached          |
|             |                          | `"done"` is `false`  |
|             |                          | and a value is           |
|             |                          | available. If a          |
|             |                          | `"done"` property      |
|             |                          | (either own or           |
|             |                          | inherited) does not      |
|             |                          | exist, it is considered  |
|             |                          | to have the value        |
|             |                          | `false`.               |
+-------------+--------------------------+--------------------------+
| `"value"` | an ECMAScript language   | If done is `false`,    |
|             | value                    | this is the current      |
|             |                          | iteration element value. |
|             |                          | If done is `true`,     |
|             |                          | this is the return value |
|             |                          | of the iterator, if it   |
|             |                          | supplied one. If the     |
|             |                          | iterator does not have a |
|             |                          | return value,            |
|             |                          | `"value"` is           |
|             |                          | `undefined`. In that   |
|             |                          | case, the `"value"`    |
|             |                          | property may be absent   |
|             |                          | from the conforming      |
|             |                          | object if it does not    |
|             |                          | inherit an explicit      |
|             |                          | `"value"` property.    |
+-------------+--------------------------+--------------------------+

Iterator Helper Objects
-----------------------

An Iterator Helper object is an ordinary object that represents a lazy
transformation of some specific source iterator object. There is not a
named constructor for Iterator Helper objects. Instead, Iterator Helper
objects are created by calling certain methods of Iterator instance
objects.

The %IteratorHelperPrototype% Object
------------------------------------

The %IteratorHelperPrototype% object:

- has properties that are inherited by all Iterator Helper objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- has the following properties:

%IteratorHelperPrototype%.next ( )
----------------------------------

1. Return ? GeneratorResume(`this` value, `undefined`, `"Iterator
Helper"`).

%IteratorHelperPrototype%.return ( )
------------------------------------

1. Let O be `this` value. 1. Perform ? RequireInternalSlot(O,
[[UnderlyingIterator]]). 1. Assert: O has a [[GeneratorState]]
internal slot. 1. If O.[[GeneratorState]] is ~suspended-start~, then
1. Set O.[[GeneratorState]] to ~completed~. 1. NOTE: Once a
generator enters the completed state it never leaves it and its
associated execution context is never resumed. Any execution state
associated with O can be discarded at this point. 1. Perform ?
IteratorClose(O.[[UnderlyingIterator]],
ReturnCompletion(`undefined`)). 1. Return
CreateIteratorResultObject(`undefined`, `true`). 1. Let C be
ReturnCompletion(`undefined`). 1. Return ?
GeneratorResumeAbrupt(O, C, `"Iterator Helper"`).

%IteratorHelperPrototype% [ %Symbol.toStringTag% ]
--------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Iterator Helper"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Iterator Objects
----------------

The Iterator Constructor
------------------------

The Iterator constructor:

- is %Iterator%.
- is the initial value of the `"Iterator"` property of the global
  object.
- is designed to be subclassable. It may be used as the value of an
  `extends` clause of a class definition.

Iterator ( )
------------

This function performs the following steps when called:

1. If NewTarget is either `undefined` or the active function object,
throw a `TypeError` exception. 1. Return ?
OrdinaryCreateFromConstructor(NewTarget, `"%Iterator.prototype%"`).

Properties of the Iterator Constructor
--------------------------------------

The Iterator constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Iterator.from ( O )
-----------------------

1. Let iteratorRecord be ? GetIteratorFlattenable(O,
~iterate-string-primitives~). 1. Let hasInstance be ?
OrdinaryHasInstance(%Iterator%, iteratorRecord.[[Iterator]]). 1. If
hasInstance is `true`, then 1. Return
iteratorRecord.[[Iterator]]. 1. Let wrapper be
OrdinaryObjectCreate(%WrapForValidIteratorPrototype%, « [[Iterated]] »).
1. Set wrapper.[[Iterated]] to iteratorRecord. 1. Return
wrapper.

The %WrapForValidIteratorPrototype% Object
------------------------------------------

The %WrapForValidIteratorPrototype% object:

- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.

%WrapForValidIteratorPrototype%.next ( )
----------------------------------------

1. Let O be `this` value. 1. Perform ? RequireInternalSlot(O,
[[Iterated]]). 1. Let iteratorRecord be O.[[Iterated]]. 1.
Return ? Call(iteratorRecord.[[NextMethod]],
iteratorRecord.[[Iterator]]).

%WrapForValidIteratorPrototype%.return ( )
------------------------------------------

1. Let O be `this` value. 1. Perform ? RequireInternalSlot(O,
[[Iterated]]). 1. Let iterator be O.[[Iterated]].[[Iterator]].
1. Assert: iterator is an Object. 1. Let returnMethod be ?
GetMethod(iterator, `"return"`). 1. If returnMethod is
`undefined`, then 1. Return CreateIteratorResultObject(`undefined`,
`true`). 1. Return ? Call(returnMethod, iterator).

Iterator.prototype
------------------

The initial value of Iterator.prototype is %Iterator.prototype%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

The %Iterator.prototype% Object
-------------------------------

The %Iterator.prototype% object:

- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.

All objects defined in this specification that implement the Iterator
interface also inherit from %Iterator.prototype%. ECMAScript code may
also define objects that inherit from %Iterator.prototype%. The
%Iterator.prototype% object provides a place where additional methods
that are applicable to all iterator objects may be added.

The following expression is one way that ECMAScript code can access the
%Iterator.prototype% object:

.. code:: javascript

   Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))

Iterator.prototype.constructor
------------------------------

`Iterator.prototype.constructor` is an accessor property with
attributes { [[Enumerable]]: `false`, [[Configurable]]: `true` }.
The [[Get]] and [[Set]] attributes are defined as follows:

get Iterator.prototype.constructor
----------------------------------

The value of the [[Get]] attribute is a built-in function that requires
no arguments. It performs the following steps when called:

1. Return %Iterator%.

set Iterator.prototype.constructor
----------------------------------

The value of the [[Set]] attribute is a built-in function that takes an
argument v. It performs the following steps when called:

1. Perform ? SetterThatIgnoresPrototypeProperties(`this` value,
%Iterator.prototype%, `"constructor"`, v). 1. Return
`undefined`.

Unlike the `"constructor"` property on most built-in prototypes, for
web-compatibility reasons this property must be an accessor.

Iterator.prototype.drop ( limit )
-------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. Let numLimit be ? ToNumber(limit).
1. If numLimit is `NaN`, throw a `RangeError` exception. 1. Let
integerLimit be ! ToIntegerOrInfinity(numLimit). 1. If
integerLimit < 0, throw a `RangeError` exception. 1. Let
iterated be ? GetIteratorDirect(O). 1. Let closure be a new
Abstract Closure with no parameters that captures iterated and
integerLimit and performs the following steps when called: 1. Let
remaining be integerLimit. 1. Repeat, while remaining > 0,
1. If remaining ≠ +∞, then 1. Set remaining to remaining -
1. 1. Let next be ? IteratorStep(iterated). 1. If next is
~done~, return ReturnCompletion(`undefined`). 1. Repeat, 1. Let
value be ? IteratorStepValue(iterated). 1. If value is
~done~, return ReturnCompletion(`undefined`). 1. Let completion be
Completion(Yield(value)). 1. IfAbruptCloseIterator(completion,
iterated). 1. Let result be
CreateIteratorFromClosure(closure, `"Iterator Helper"`,
%IteratorHelperPrototype%, « [[UnderlyingIterator]] »). 1. Set
result.[[UnderlyingIterator]] to iterated. 1. Return result.

Iterator.prototype.every ( predicate )
------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(predicate) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let counter be 0. 1. Repeat, 1. Let
value be ? IteratorStepValue(iterated). 1. If value is
~done~, return `true`. 1. Let result be
Completion(Call(predicate, `undefined`, « value,
𝔽(counter) »)). 1. IfAbruptCloseIterator(result, iterated).
1. If ToBoolean(result) is `false`, return ?
IteratorClose(iterated, NormalCompletion(`false`)). 1. Set
counter to counter + 1.

Iterator.prototype.filter ( predicate )
-------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(predicate) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let closure be a new Abstract Closure
with no parameters that captures iterated and predicate and
performs the following steps when called: 1. Let counter be 0. 1.
Repeat, 1. Let value be ? IteratorStepValue(iterated). 1. If
value is ~done~, return ReturnCompletion(`undefined`). 1. Let
selected be Completion(Call(predicate, `undefined`, «
value, 𝔽(counter) »)). 1. IfAbruptCloseIterator(selected,
iterated). 1. If ToBoolean(selected) is `true`, then 1. Let
completion be Completion(Yield(value)). 1.
IfAbruptCloseIterator(completion, iterated). 1. Set counter
to counter + 1. 1. Let result be
CreateIteratorFromClosure(closure, `"Iterator Helper"`,
%IteratorHelperPrototype%, « [[UnderlyingIterator]] »). 1. Set
result.[[UnderlyingIterator]] to iterated. 1. Return result.

Iterator.prototype.find ( predicate )
-----------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(predicate) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let counter be 0. 1. Repeat, 1. Let
value be ? IteratorStepValue(iterated). 1. If value is
~done~, return `undefined`. 1. Let result be
Completion(Call(predicate, `undefined`, « value,
𝔽(counter) »)). 1. IfAbruptCloseIterator(result, iterated).
1. If ToBoolean(result) is `true`, return ?
IteratorClose(iterated, NormalCompletion(value)). 1. Set
counter to counter + 1.

Iterator.prototype.flatMap ( mapper )
-----------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(mapper) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let closure be a new Abstract Closure
with no parameters that captures iterated and mapper and
performs the following steps when called: 1. Let counter be 0. 1.
Repeat, 1. Let value be ? IteratorStepValue(iterated). 1. If
value is ~done~, return ReturnCompletion(`undefined`). 1. Let
mapped be Completion(Call(mapper, `undefined`, « value,
𝔽(counter) »)). 1. IfAbruptCloseIterator(mapped, iterated).
1. Let innerIterator be
Completion(GetIteratorFlattenable(mapped, ~reject-primitives~)). 1.
IfAbruptCloseIterator(innerIterator, iterated). 1. Let
innerAlive be `true`. 1. Repeat, while innerAlive is `true`,
1. Let innerValue be
Completion(IteratorStepValue(innerIterator)). 1.
IfAbruptCloseIterator(innerValue, iterated). 1. If
innerValue is ~done~, then 1. Set innerAlive to `false`. 1.
Else, 1. Let completion be Completion(Yield(innerValue)). 1. If
completion is an abrupt completion, then 1. Let backupCompletion
be Completion(IteratorClose(innerIterator, completion)). 1.
IfAbruptCloseIterator(backupCompletion, iterated). 1. Return ?
IteratorClose(iterated, completion). 1. Set counter to
counter + 1. 1. Let result be
CreateIteratorFromClosure(closure, `"Iterator Helper"`,
%IteratorHelperPrototype%, « [[UnderlyingIterator]] »). 1. Set
result.[[UnderlyingIterator]] to iterated. 1. Return result.

Iterator.prototype.forEach ( procedure )
--------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(procedure) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let counter be 0. 1. Repeat, 1. Let
value be ? IteratorStepValue(iterated). 1. If value is
~done~, return `undefined`. 1. Let result be
Completion(Call(procedure, `undefined`, « value,
𝔽(counter) »)). 1. IfAbruptCloseIterator(result, iterated).
1. Set counter to counter + 1.

Iterator.prototype.map ( mapper )
-------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(mapper) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let closure be a new Abstract Closure
with no parameters that captures iterated and mapper and
performs the following steps when called: 1. Let counter be 0. 1.
Repeat, 1. Let value be ? IteratorStepValue(iterated). 1. If
value is ~done~, return ReturnCompletion(`undefined`). 1. Let
mapped be Completion(Call(mapper, `undefined`, « value,
𝔽(counter) »)). 1. IfAbruptCloseIterator(mapped, iterated).
1. Let completion be Completion(Yield(mapped)). 1.
IfAbruptCloseIterator(completion, iterated). 1. Set counter
to counter + 1. 1. Let result be
CreateIteratorFromClosure(closure, `"Iterator Helper"`,
%IteratorHelperPrototype%, « [[UnderlyingIterator]] »). 1. Set
result.[[UnderlyingIterator]] to iterated. 1. Return result.

Iterator.prototype.reduce ( reducer [ , initialValue ] )
----------------------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(reducer) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. If initialValue is not present, then 1.
Let accumulator be ? IteratorStepValue(iterated). 1. If
accumulator is ~done~, throw a `TypeError` exception. 1. Let
counter be 1. 1. Else, 1. Let accumulator be initialValue.
1. Let counter be 0. 1. Repeat, 1. Let value be ?
IteratorStepValue(iterated). 1. If value is ~done~, return
accumulator. 1. Let result be Completion(Call(reducer,
`undefined`, « accumulator, value, 𝔽(counter) »)). 1.
IfAbruptCloseIterator(result, iterated). 1. Set accumulator
to result. 1. Set counter to counter + 1.

Iterator.prototype.some ( predicate )
-----------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. If IsCallable(predicate) is `false`,
throw a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let counter be 0. 1. Repeat, 1. Let
value be ? IteratorStepValue(iterated). 1. If value is
~done~, return `false`. 1. Let result be
Completion(Call(predicate, `undefined`, « value,
𝔽(counter) »)). 1. IfAbruptCloseIterator(result, iterated).
1. If ToBoolean(result) is `true`, return ?
IteratorClose(iterated, NormalCompletion(`true`)). 1. Set
counter to counter + 1.

Iterator.prototype.take ( limit )
-------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. Let numLimit be ? ToNumber(limit).
1. If numLimit is `NaN`, throw a `RangeError` exception. 1. Let
integerLimit be ! ToIntegerOrInfinity(numLimit). 1. If
integerLimit < 0, throw a `RangeError` exception. 1. Let
iterated be ? GetIteratorDirect(O). 1. Let closure be a new
Abstract Closure with no parameters that captures iterated and
integerLimit and performs the following steps when called: 1. Let
remaining be integerLimit. 1. Repeat, 1. If remaining = 0,
then 1. Return ? IteratorClose(iterated,
ReturnCompletion(`undefined`)). 1. If remaining ≠ +∞, then 1. Set
remaining to remaining - 1. 1. Let value be ?
IteratorStepValue(iterated). 1. If value is ~done~, return
ReturnCompletion(`undefined`). 1. Let completion be
Completion(Yield(value)). 1. IfAbruptCloseIterator(completion,
iterated). 1. Let result be
CreateIteratorFromClosure(closure, `"Iterator Helper"`,
%IteratorHelperPrototype%, « [[UnderlyingIterator]] »). 1. Set
result.[[UnderlyingIterator]] to iterated. 1. Return result.

Iterator.prototype.toArray ( )
------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. If O is not an Object, throw
a `TypeError` exception. 1. Let iterated be ?
GetIteratorDirect(O). 1. Let items be a new empty List. 1.
Repeat, 1. Let value be ? IteratorStepValue(iterated). 1. If
value is ~done~, return CreateArrayFromList(items). 1. Append
value to items.

Iterator.prototype [ %Symbol.iterator% ] ( )
--------------------------------------------

This function performs the following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is
`"[Symbol.iterator]"`.

Iterator.prototype [ %Symbol.toStringTag% ]
-------------------------------------------

`Iterator.prototype[%Symbol.toStringTag%]` is an accessor property
with attributes { [[Enumerable]]: `false`, [[Configurable]]: `true`
}. The [[Get]] and [[Set]] attributes are defined as follows:

get Iterator.prototype [ %Symbol.toStringTag% ]
-----------------------------------------------

The value of the [[Get]] attribute is a built-in function that requires
no arguments. It performs the following steps when called:

1. Return `"Iterator"`.

set Iterator.prototype [ %Symbol.toStringTag% ]
-----------------------------------------------

The value of the [[Set]] attribute is a built-in function that takes an
argument v. It performs the following steps when called:

1. Perform ? SetterThatIgnoresPrototypeProperties(`this` value,
%Iterator.prototype%, %Symbol.toStringTag%, v). 1. Return
`undefined`.

Unlike the %Symbol.toStringTag% property on most built-in prototypes,
for web-compatibility reasons this property must be an accessor.

The %AsyncIteratorPrototype% Object
-----------------------------------

The %AsyncIteratorPrototype% object:

- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.

All objects defined in this specification that implement the async
iterator interface also inherit from %AsyncIteratorPrototype%.
ECMAScript code may also define objects that inherit from
%AsyncIteratorPrototype%. The %AsyncIteratorPrototype% object provides a
place where additional methods that are applicable to all async iterator
objects may be added.

%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )
-------------------------------------------------------

This function performs the following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is
`"[Symbol.asyncIterator]"`.

Async-from-Sync Iterator Objects
--------------------------------

An Async-from-Sync Iterator object is an async iterator that adapts a
specific synchronous iterator. Async-from-Sync Iterator objects are
never directly accessible to ECMAScript code. There is not a named
constructor for Async-from-Sync Iterator objects. Instead,
Async-from-Sync Iterator objects are created by the
CreateAsyncFromSyncIterator abstract operation as needed.

CreateAsyncFromSyncIterator ( syncIteratorRecord: an Iterator Record, ): an Iterator Record
-----------------------------------------------------------------------------------------------

description
   It is used to create an async Iterator Record from a synchronous
   Iterator Record.

1. Let asyncIterator be
OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, «
[[SyncIteratorRecord]] »). 1. Set
asyncIterator.[[SyncIteratorRecord]] to syncIteratorRecord. 1.
Let nextMethod be ! Get(asyncIterator, `"next"`). 1. Let
iteratorRecord be the Iterator Record { [[Iterator]]:
asyncIterator, [[NextMethod]]: nextMethod, [[Done]]: `false`
}. 1. Return iteratorRecord.

The %AsyncFromSyncIteratorPrototype% Object
-------------------------------------------

The %AsyncFromSyncIteratorPrototype% object:

- has properties that are inherited by all Async-from-Sync Iterator
  objects.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is
  %AsyncIteratorPrototype%.
- is never directly accessible to ECMAScript code.
- has the following properties:

%AsyncFromSyncIteratorPrototype%.next ( [ value ] )
-------------------------------------------------------

1. Let O be the `this` value. 1. Assert: O is an Object that
has a [[SyncIteratorRecord]] internal slot. 1. Let promiseCapability
be ! NewPromiseCapability(%Promise%). 1. Let syncIteratorRecord be
O.[[SyncIteratorRecord]]. 1. If value is present, then 1. Let
result be Completion(IteratorNext(syncIteratorRecord,
value)). 1. Else, 1. Let result be
Completion(IteratorNext(syncIteratorRecord)). 1.
IfAbruptRejectPromise(result, promiseCapability). 1. Return
AsyncFromSyncIteratorContinuation(result, promiseCapability).

%AsyncFromSyncIteratorPrototype%.return ( [ value ] )
---------------------------------------------------------

1. Let O be the `this` value. 1. Assert: O is an Object that
has a [[SyncIteratorRecord]] internal slot. 1. Let promiseCapability
be ! NewPromiseCapability(%Promise%). 1. Let syncIterator be
O.[[SyncIteratorRecord]].[[Iterator]]. 1. Let return be
Completion(GetMethod(syncIterator, `"return"`)). 1.
IfAbruptRejectPromise(return, promiseCapability). 1. If
return is `undefined`, then 1. Let iteratorResult be
CreateIteratorResultObject(value, `true`). 1. Perform !
Call(promiseCapability.[[Resolve]], `undefined`, «
iteratorResult »). 1. Return promiseCapability.[[Promise]]. 1.
If value is present, then 1. Let result be
Completion(Call(return, syncIterator, « value »)). 1. Else,
1. Let result be Completion(Call(return, syncIterator)). 1.
IfAbruptRejectPromise(result, promiseCapability). 1. If
result is not an Object, then 1. Perform !
Call(promiseCapability.[[Reject]], `undefined`, « a newly created
`TypeError` object »). 1. Return promiseCapability.[[Promise]]. 1.
Return AsyncFromSyncIteratorContinuation(result,
promiseCapability).

%AsyncFromSyncIteratorPrototype%.throw ( [ value ] )
--------------------------------------------------------

In this specification, value is always provided, but is left
optional for consistency with . 1. Let O be the `this` value. 1.
Assert: O is an Object that has a [[SyncIteratorRecord]] internal
slot. 1. Let promiseCapability be ! NewPromiseCapability(%Promise%).
1. Let syncIterator be O.[[SyncIteratorRecord]].[[Iterator]]. 1.
Let throw be Completion(GetMethod(syncIterator, `"throw"`)).
1. IfAbruptRejectPromise(throw, promiseCapability). 1. If
throw is `undefined`, then 1. Perform !
Call(promiseCapability.[[Reject]], `undefined`, « value »). 1.
Return promiseCapability.[[Promise]]. 1. If value is present,
then 1. Let result be Completion(Call(throw, syncIterator, «
value »)). 1. Else, 1. Let result be Completion(Call(throw,
syncIterator)). 1. IfAbruptRejectPromise(result,
promiseCapability). 1. If result is not an Object, then 1.
Perform ! Call(promiseCapability.[[Reject]], `undefined`, « a
newly created `TypeError` object »). 1. Return
promiseCapability.[[Promise]]. 1. Return
AsyncFromSyncIteratorContinuation(result, promiseCapability).

Properties of Async-from-Sync Iterator Instances
------------------------------------------------

Async-from-Sync Iterator instances are ordinary objects that inherit
properties from the %AsyncFromSyncIteratorPrototype% intrinsic object.
Async-from-Sync Iterator instances are initially created with the
internal slots listed in .

+-----------------------+--------------------+-----------------------+
| Internal Slot         | Type               | Description           |
+=======================+====================+=======================+
| [                     | an Iterator Record | Represents the        |
| [SyncIteratorRecord]] |                    | original synchronous  |
|                       |                    | iterator which is     |
|                       |                    | being adapted.        |
+-----------------------+--------------------+-----------------------+

AsyncFromSyncIteratorContinuation ( result: an Object, promiseCapability: a PromiseCapability Record for an intrinsic %Promise%, ): a Promise
-----------------------------------------------------------------------------------------------------------------------------------------------------

1. NOTE: Because promiseCapability is derived from the intrinsic
%Promise%, the calls to promiseCapability.[[Reject]] entailed by the
use IfAbruptRejectPromise below are guaranteed not to throw. 1. Let
done be Completion(IteratorComplete(result)). 1.
IfAbruptRejectPromise(done, promiseCapability). 1. Let value
be Completion(IteratorValue(result)). 1.
IfAbruptRejectPromise(value, promiseCapability). 1. Let
valueWrapper be Completion(PromiseResolve(%Promise%, value)). 1.
IfAbruptRejectPromise(valueWrapper, promiseCapability). 1. Let
unwrap be a new Abstract Closure with parameters (v) that
captures done and performs the following steps when called: 1.
Return CreateIteratorResultObject(v, done). 1. Let
onFulfilled be CreateBuiltinFunction(unwrap, 1, `""`, « »). 1.
NOTE: onFulfilled is used when processing the `"value"` property
of an IteratorResult object in order to wait for its value if it is a
promise and re-package the result in a new "unwrapped" IteratorResult
object. 1. Perform PerformPromiseThen(valueWrapper, onFulfilled,
`undefined`, promiseCapability). 1. Return
promiseCapability.[[Promise]].

Promise Objects
---------------

A Promise is an object that is used as a placeholder for the eventual
results of a deferred (and possibly asynchronous) computation.

Any Promise is in one of three mutually exclusive states: *fulfilled*,
*rejected*, and *pending*:

- A promise `p` is fulfilled if `p.then(f, r)` will immediately
  enqueue a Job to call the function `f`.
- A promise `p` is rejected if `p.then(f, r)` will immediately
  enqueue a Job to call the function `r`.
- A promise is pending if it is neither fulfilled nor rejected.

A promise is said to be *settled* if it is not pending, i.e. if it is
either fulfilled or rejected.

A promise is *resolved* if it is settled or if it has been “locked in”
to match the state of another promise. Attempting to resolve or reject a
resolved promise has no effect. A promise is *unresolved* if it is not
resolved. An unresolved promise is always in the pending state. A
resolved promise may be pending, fulfilled or rejected.

Promise Abstract Operations
---------------------------

PromiseCapability Records
-------------------------

A PromiseCapability Record is a Record value used to encapsulate a
Promise or promise-like object along with the functions that are capable
of resolving or rejecting that promise. PromiseCapability Records are
produced by the NewPromiseCapability abstract operation.

PromiseCapability Records have the fields listed in .

+-------------+-------------------+----------------------------------+
| Field Name  | Value             | Meaning                          |
+=============+===================+==================================+
| [[Promise]] | an Object         | An object that is usable as a    |
|             |                   | promise.                         |
+-------------+-------------------+----------------------------------+
| [[Resolve]] | a function object | The function that is used to     |
|             |                   | resolve the given promise.       |
+-------------+-------------------+----------------------------------+
| [[Reject]]  | a function object | The function that is used to     |
|             |                   | reject the given promise.        |
+-------------+-------------------+----------------------------------+

IfAbruptRejectPromise ( value, capability )
---------------------------------------------------

IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps
that use a PromiseCapability Record. An algorithm step of the form:

1. IfAbruptRejectPromise(value, capability).

means the same thing as:

1. Assert: value is a Completion Record. 1. If value is an
abrupt completion, then 1. Perform ? Call(capability.[[Reject]],
`undefined`, « value.[[Value]] »). 1. Return
capability.[[Promise]]. 1. Else, 1. Set value to ! value.

PromiseReaction Records
-----------------------

A PromiseReaction Record is a Record value used to store information
about how a promise should react when it becomes resolved or rejected
with a given value. PromiseReaction Records are created by the
PerformPromiseThen abstract operation, and are used by the Abstract
Closure returned by NewPromiseReactionJob.

PromiseReaction Records have the fields listed in .

+----------------+-------------------------+-------------------------+
| Field Name     | Value                   | Meaning                 |
+================+=========================+=========================+
| [[Capability]] | a PromiseCapability     | The capabilities of the |
|                | Record or `undefined` | promise for which this  |
|                |                         | record provides a       |
|                |                         | reaction handler.       |
+----------------+-------------------------+-------------------------+
| [[Type]]       | ~fulfill~ or ~reject~   | The [[Type]] is used    |
|                |                         | when [[Handler]] is     |
|                |                         | ~empty~ to allow for    |
|                |                         | behaviour specific to   |
|                |                         | the settlement type.    |
+----------------+-------------------------+-------------------------+
| [[Handler]]    | a JobCallback Record or | The function that       |
|                | ~empty~                 | should be applied to    |
|                |                         | the incoming value, and |
|                |                         | whose return value will |
|                |                         | govern what happens to  |
|                |                         | the derived promise. If |
|                |                         | [[Handler]] is ~empty~, |
|                |                         | a function that depends |
|                |                         | on the value of         |
|                |                         | [[Type]] will be used   |
|                |                         | instead.                |
+----------------+-------------------------+-------------------------+

CreateResolvingFunctions ( promise: a Promise, ): a Record with fields [[Resolve]] (a function object) and [[Reject]] (a function object)
---------------------------------------------------------------------------------------------------------------------------------------------

1. Let alreadyResolved be the Record { [[Value]]: `false` }. 1.
Let stepsResolve be the algorithm steps defined in . 1. Let
lengthResolve be the number of non-optional parameters of the
function definition in . 1. Let resolve be
CreateBuiltinFunction(stepsResolve, lengthResolve, `""`, «
[[Promise]], [[AlreadyResolved]] »). 1. Set resolve.[[Promise]] to
promise. 1. Set resolve.[[AlreadyResolved]] to
alreadyResolved. 1. Let stepsReject be the algorithm steps
defined in . 1. Let lengthReject be the number of non-optional
parameters of the function definition in . 1. Let reject be
CreateBuiltinFunction(stepsReject, lengthReject, `""`, «
[[Promise]], [[AlreadyResolved]] »). 1. Set reject.[[Promise]] to
promise. 1. Set reject.[[AlreadyResolved]] to
alreadyResolved. 1. Return the Record { [[Resolve]]: resolve,
[[Reject]]: reject }.

Promise Reject Functions
------------------------

A promise reject function is an anonymous built-in function that has
[[Promise]] and [[AlreadyResolved]] internal slots.

When a promise reject function is called with argument reason, the
following steps are taken:

1. Let F be the active function object. 1. Assert: F has a
[[Promise]] internal slot whose value is an Object. 1. Let promise
be F.[[Promise]]. 1. Let alreadyResolved be
F.[[AlreadyResolved]]. 1. If alreadyResolved.[[Value]] is
`true`, return `undefined`. 1. Set alreadyResolved.[[Value]] to
`true`. 1. Perform RejectPromise(promise, reason). 1. Return
`undefined`.

The `"length"` property of a promise reject function is
`1`\ :sub:`𝔽`.

Promise Resolve Functions
-------------------------

A promise resolve function is an anonymous built-in function that has
[[Promise]] and [[AlreadyResolved]] internal slots.

When a promise resolve function is called with argument resolution,
the following steps are taken:

1. Let F be the active function object. 1. Assert: F has a
[[Promise]] internal slot whose value is an Object. 1. Let promise
be F.[[Promise]]. 1. Let alreadyResolved be
F.[[AlreadyResolved]]. 1. If alreadyResolved.[[Value]] is
`true`, return `undefined`. 1. Set alreadyResolved.[[Value]] to
`true`. 1. If SameValue(resolution, promise) is `true`, then
1. Let selfResolutionError be a newly created `TypeError` object.
1. Perform RejectPromise(promise, selfResolutionError). 1.
Return `undefined`. 1. If resolution is not an Object, then 1.
Perform FulfillPromise(promise, resolution). 1. Return
`undefined`. 1. Let then be Completion(Get(resolution,
`"then"`)). 1. If then is an abrupt completion, then 1. Perform
RejectPromise(promise, then.[[Value]]). 1. Return `undefined`.
1. Let thenAction be then.[[Value]]. 1. If
IsCallable(thenAction) is `false`, then 1. Perform
FulfillPromise(promise, resolution). 1. Return `undefined`. 1.
Let thenJobCallback be HostMakeJobCallback(thenAction). 1. Let
job be NewPromiseResolveThenableJob(promise, resolution,
thenJobCallback). 1. Perform HostEnqueuePromiseJob(job.[[Job]],
job.[[Realm]]). 1. Return `undefined`.

The `"length"` property of a promise resolve function is
`1`\ :sub:`𝔽`.

FulfillPromise ( promise: a Promise, value, ): ~unused~
---------------------------------------------------------------------------------------------

1. Assert: The value of promise.[[PromiseState]] is ~pending~. 1.
Let reactions be promise.[[PromiseFulfillReactions]]. 1. Set
promise.[[PromiseResult]] to value. 1. Set
promise.[[PromiseFulfillReactions]] to `undefined`. 1. Set
promise.[[PromiseRejectReactions]] to `undefined`. 1. Set
promise.[[PromiseState]] to ~fulfilled~. 1. Perform
TriggerPromiseReactions(reactions, value). 1. Return ~unused~.

NewPromiseCapability ( C, )
---------------------------

description
   It attempts to use C as a constructor in the fashion of the
   built-in Promise constructor to create a promise and extract its
   `resolve` and `reject` functions. The promise plus the
   `resolve` and `reject` functions are used to initialize a new
   PromiseCapability Record.

1. If IsConstructor(C) is `false`, throw a `TypeError`
exception. 1. NOTE: C is assumed to be a constructor function that
supports the parameter conventions of the Promise constructor (see ). 1.
Let resolvingFunctions be the Record { [[Resolve]]: `undefined`,
[[Reject]]: `undefined` }. 1. Let executorClosure be a new
Abstract Closure with parameters (resolve, reject) that captures
resolvingFunctions and performs the following steps when called: 1.
If resolvingFunctions.[[Resolve]] is not `undefined`, throw a
`TypeError` exception. 1. If resolvingFunctions.[[Reject]] is not
`undefined`, throw a `TypeError` exception. 1. Set
resolvingFunctions.[[Resolve]] to resolve. 1. Set
resolvingFunctions.[[Reject]] to reject. 1. Return
`undefined`. 1. Let executor be
CreateBuiltinFunction(executorClosure, 2, `""`, « »). 1. Let
promise be ? Construct(C, « executor »). 1. If
IsCallable(resolvingFunctions.[[Resolve]]) is `false`, throw a
`TypeError` exception. 1. If
IsCallable(resolvingFunctions.[[Reject]]) is `false`, throw a
`TypeError` exception. 1. Return the PromiseCapability Record {
[[Promise]]: promise, [[Resolve]]:
resolvingFunctions.[[Resolve]], [[Reject]]:
resolvingFunctions.[[Reject]] }.

This abstract operation supports Promise subclassing, as it is generic
on any constructor that calls a passed executor function argument in the
same way as the Promise constructor. It is used to generalize static
methods of the Promise constructor to any subclass.

IsPromise ( x, ): a Boolean
-------------------------------------------------------------

description
   It checks for the promise brand on an object.

1. If x is not an Object, return `false`. 1. If x does not
have a [[PromiseState]] internal slot, return `false`. 1. Return
`true`.

RejectPromise ( promise: a Promise, reason, ): ~unused~
---------------------------------------------------------------------------------------------

1. Assert: The value of promise.[[PromiseState]] is ~pending~. 1.
Let reactions be promise.[[PromiseRejectReactions]]. 1. Set
promise.[[PromiseResult]] to reason. 1. Set
promise.[[PromiseFulfillReactions]] to `undefined`. 1. Set
promise.[[PromiseRejectReactions]] to `undefined`. 1. Set
promise.[[PromiseState]] to ~rejected~. 1. If
promise.[[PromiseIsHandled]] is `false`, perform
HostPromiseRejectionTracker(promise, `"reject"`). 1. Perform
TriggerPromiseReactions(reactions, reason). 1. Return ~unused~.

TriggerPromiseReactions ( reactions: a List of PromiseReaction Records, argument, ): ~unused~
-----------------------------------------------------------------------------------------------------------------------------------

description
   It enqueues a new Job for each record in reactions. Each such Job
   processes the [[Type]] and [[Handler]] of the PromiseReaction Record,
   and if the [[Handler]] is not ~empty~, calls it passing the given
   argument. If the [[Handler]] is ~empty~, the behaviour is determined
   by the [[Type]].

1. For each element reaction of reactions, do 1. Let job be
NewPromiseReactionJob(reaction, argument). 1. Perform
HostEnqueuePromiseJob(job.[[Job]], job.[[Realm]]). 1. Return
~unused~.

HostPromiseRejectionTracker ( promise: a Promise, operation: `"reject"` or `"handle"`, ): ~unused~
--------------------------------------------------------------------------------------------------------------

description
   It allows host environments to track promise rejections.

The default implementation of HostPromiseRejectionTracker is to return
~unused~.

HostPromiseRejectionTracker is called in two scenarios:

- When a promise is rejected without any handlers, it is called with its
  operation argument set to `"reject"`.
- When a handler is added to a rejected promise for the first time, it
  is called with its operation argument set to `"handle"`.

A typical implementation of HostPromiseRejectionTracker might try to
notify developers of unhandled rejections, while also being careful to
notify them if such previous notifications are later invalidated by new
handlers being attached.

If operation is `"handle"`, an implementation should not hold a
reference to promise in a way that would interfere with garbage
collection. An implementation may hold a reference to promise if
operation is `"reject"`, since it is expected that rejections will
be rare and not on hot code paths.

Promise Jobs
------------

NewPromiseReactionJob ( reaction: a PromiseReaction Record, argument, ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record or `null`)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It returns a new Job Abstract Closure that applies the appropriate
   handler to the incoming value, and uses the handler's return value to
   resolve or reject the derived promise associated with that handler.

1. Let job be a new Job Abstract Closure with no parameters that
captures reaction and argument and performs the following steps
when called: 1. Let promiseCapability be
reaction.[[Capability]]. 1. Let type be reaction.[[Type]].
1. Let handler be reaction.[[Handler]]. 1. If handler is
~empty~, then 1. If type is ~fulfill~, then 1. Let handlerResult
be NormalCompletion(argument). 1. Else, 1. Assert: type is
~reject~. 1. Let handlerResult be ThrowCompletion(argument). 1.
Else, 1. Let handlerResult be
Completion(HostCallJobCallback(handler, `undefined`, «
argument »)). 1. If promiseCapability is `undefined`, then 1.
Assert: handlerResult is not an abrupt completion. 1. Return
~empty~. 1. Assert: promiseCapability is a PromiseCapability Record.
1. If handlerResult is an abrupt completion, then 1. Return ?
Call(promiseCapability.[[Reject]], `undefined`, «
handlerResult.[[Value]] »). 1. Else, 1. Return ?
Call(promiseCapability.[[Resolve]], `undefined`, «
handlerResult.[[Value]] »). 1. Let handlerRealm be `null`. 1.
If reaction.[[Handler]] is not ~empty~, then 1. Let
getHandlerRealmResult be
Completion(GetFunctionRealm(reaction.[[Handler]].[[Callback]])). 1.
If getHandlerRealmResult is a normal completion, set
handlerRealm to getHandlerRealmResult.[[Value]]. 1. Else, set
handlerRealm to the current Realm Record. 1. NOTE: handlerRealm
is never `null` unless the handler is `undefined`. When the handler
is a revoked Proxy and no ECMAScript code runs, handlerRealm is used
to create error objects. 1. Return the Record { [[Job]]: job,
[[Realm]]: handlerRealm }.

NewPromiseResolveThenableJob ( promiseToResolve: a Promise, thenable: an Object, then: a JobCallback Record, ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let job be a new Job Abstract Closure with no parameters that
captures promiseToResolve, thenable, and then and performs
the following steps when called: 1. Let resolvingFunctions be
CreateResolvingFunctions(promiseToResolve). 1. Let
thenCallResult be Completion(HostCallJobCallback(then,
thenable, « resolvingFunctions.[[Resolve]],
resolvingFunctions.[[Reject]] »)). 1. If thenCallResult is an
abrupt completion, then 1. Return ?
Call(resolvingFunctions.[[Reject]], `undefined`, «
thenCallResult.[[Value]] »). 1. Return ? thenCallResult. 1. Let
getThenRealmResult be
Completion(GetFunctionRealm(then.[[Callback]])). 1. If
getThenRealmResult is a normal completion, let thenRealm be
getThenRealmResult.[[Value]]. 1. Else, let thenRealm be the
current Realm Record. 1. NOTE: thenRealm is never `null`. When
then.[[Callback]] is a revoked Proxy and no code runs, thenRealm
is used to create error objects. 1. Return the Record { [[Job]]:
job, [[Realm]]: thenRealm }.

This Job uses the supplied thenable and its `then` method to resolve
the given promise. This process must take place as a Job to ensure that
the evaluation of the `then` method occurs after evaluation of any
surrounding code has completed.

The Promise Constructor
-----------------------

The Promise constructor:

- is %Promise%.
- is the initial value of the `"Promise"` property of the global
  object.
- creates and initializes a new Promise when called as a constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.
- may be used as the value in an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  Promise behaviour must include a `super` call to the Promise
  constructor to create and initialize the subclass instance with the
  internal state necessary to support the `Promise` and
  `Promise.prototype` built-in methods.

Promise ( executor )
------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1. If
IsCallable(executor) is `false`, throw a `TypeError` exception.
1. Let promise be ? OrdinaryCreateFromConstructor(NewTarget,
`"%Promise.prototype%"`, « [[PromiseState]], [[PromiseResult]],
[[PromiseFulfillReactions]], [[PromiseRejectReactions]],
[[PromiseIsHandled]] »). 1. Set promise.[[PromiseState]] to
~pending~. 1. Set promise.[[PromiseFulfillReactions]] to a new empty
List. 1. Set promise.[[PromiseRejectReactions]] to a new empty List.
1. Set promise.[[PromiseIsHandled]] to `false`. 1. Let
resolvingFunctions be CreateResolvingFunctions(promise). 1. Let
completion be Completion(Call(executor, `undefined`, «
resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]]
»)). 1. If completion is an abrupt completion, then 1. Perform ?
Call(resolvingFunctions.[[Reject]], `undefined`, «
completion.[[Value]] »). 1. Return promise.

The executor argument must be a function object. It is called for
initiating and reporting completion of the possibly deferred action
represented by this Promise. The executor is called with two arguments:
resolve and reject. These are functions that may be used by the
executor function to report eventual completion or failure of the
deferred computation. Returning from the executor function does not mean
that the deferred action has been completed but only that the request to
eventually perform the deferred action has been accepted.

The resolve function that is passed to an executor function
accepts a single argument. The executor code may eventually call the
resolve function to indicate that it wishes to resolve the
associated Promise. The argument passed to the resolve function
represents the eventual value of the deferred action and can be either
the actual fulfillment value or another promise which will provide the
value if it is fulfilled.

The reject function that is passed to an executor function
accepts a single argument. The executor code may eventually call the
reject function to indicate that the associated Promise is rejected
and will never be fulfilled. The argument passed to the reject
function is used as the rejection value of the promise. Typically it
will be an Error object.

The resolve and reject functions passed to an executor function by
the Promise constructor have the capability to actually resolve and
reject the associated promise. Subclasses may have different constructor
behaviour that passes in customized values for resolve and reject.

Properties of the Promise Constructor
-------------------------------------

The Promise constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- has the following properties:

Promise.all ( iterable )
----------------------------

This function returns a new promise which is fulfilled with an array of
fulfillment values for the passed promises, or rejects with the reason
of the first passed promise that rejects. It resolves all elements of
the passed iterable to promises as it runs this algorithm.

1. Let C be the `this` value. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Let promiseResolve be
Completion(GetPromiseResolve(C)). 1.
IfAbruptRejectPromise(promiseResolve, promiseCapability). 1. Let
iteratorRecord be Completion(GetIterator(iterable, ~sync~)). 1.
IfAbruptRejectPromise(iteratorRecord, promiseCapability). 1. Let
result be Completion(PerformPromiseAll(iteratorRecord, C,
promiseCapability, promiseResolve)). 1. If result is an
abrupt completion, then 1. If iteratorRecord.[[Done]] is `false`,
set result to Completion(IteratorClose(iteratorRecord,
result)). 1. IfAbruptRejectPromise(result,
promiseCapability). 1. Return ? result.

This function requires its `this` value to be a constructor function
that supports the parameter conventions of the Promise constructor.

GetPromiseResolve ( promiseConstructor: a constructor, )
--------------------------------------------------------

1. Let promiseResolve be ? Get(promiseConstructor,
`"resolve"`). 1. If IsCallable(promiseResolve) is `false`, throw
a `TypeError` exception. 1. Return promiseResolve.

PerformPromiseAll ( iteratorRecord: an Iterator Record, constructor: a constructor, resultCapability: a PromiseCapability Record, promiseResolve: a function object, )
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let values be a new empty List. 1. Let remainingElementsCount
be the Record { [[Value]]: 1 }. 1. Let index be 0. 1. Repeat, 1. Let
next be ? IteratorStepValue(iteratorRecord). 1. If next is
~done~, then 1. Set remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] - 1. 1. If
remainingElementsCount.[[Value]] = 0, then 1. Let valuesArray be
CreateArrayFromList(values). 1. Perform ?
Call(resultCapability.[[Resolve]], `undefined`, « valuesArray
»). 1. Return resultCapability.[[Promise]]. 1. Append `undefined`
to values. 1. Let nextPromise be ? Call(promiseResolve,
constructor, « next »). 1. Let steps be the algorithm steps
defined in . 1. Let length be the number of non-optional parameters
of the function definition in . 1. Let onFulfilled be
CreateBuiltinFunction(steps, length, `""`, «
[[AlreadyCalled]], [[Index]], [[Values]], [[Capability]],
[[RemainingElements]] »). 1. Set onFulfilled.[[AlreadyCalled]] to
`false`. 1. Set onFulfilled.[[Index]] to index. 1. Set
onFulfilled.[[Values]] to values. 1. Set
onFulfilled.[[Capability]] to resultCapability. 1. Set
onFulfilled.[[RemainingElements]] to remainingElementsCount. 1.
Set remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] + 1. 1. Perform ?
Invoke(nextPromise, `"then"`, « onFulfilled,
resultCapability.[[Reject]] »). 1. Set index to index + 1.

`Promise.all` Resolve Element Functions
-----------------------------------------

A `Promise.all` resolve element function is an anonymous built-in
function that is used to resolve a specific `Promise.all` element.
Each `Promise.all` resolve element function has [[Index]], [[Values]],
[[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal
slots.

When a `Promise.all` resolve element function is called with argument
x, the following steps are taken:

1. Let F be the active function object. 1. If
F.[[AlreadyCalled]] is `true`, return `undefined`. 1. Set
F.[[AlreadyCalled]] to `true`. 1. Let index be
F.[[Index]]. 1. Let values be F.[[Values]]. 1. Let
promiseCapability be F.[[Capability]]. 1. Let
remainingElementsCount be F.[[RemainingElements]]. 1. Set
values[index] to x. 1. Set
remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] - 1. 1. If
remainingElementsCount.[[Value]] = 0, then 1. Let valuesArray be
CreateArrayFromList(values). 1. Return ?
Call(promiseCapability.[[Resolve]], `undefined`, « valuesArray
»). 1. Return `undefined`.

The `"length"` property of a `Promise.all` resolve element function
is `1`\ :sub:`𝔽`.

Promise.allSettled ( iterable )
-----------------------------------

This function returns a promise that is fulfilled with an array of
promise state snapshots, but only after all the original promises have
settled, i.e. become either fulfilled or rejected. It resolves all
elements of the passed iterable to promises as it runs this algorithm.

1. Let C be the `this` value. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Let promiseResolve be
Completion(GetPromiseResolve(C)). 1.
IfAbruptRejectPromise(promiseResolve, promiseCapability). 1. Let
iteratorRecord be Completion(GetIterator(iterable, ~sync~)). 1.
IfAbruptRejectPromise(iteratorRecord, promiseCapability). 1. Let
result be Completion(PerformPromiseAllSettled(iteratorRecord,
C, promiseCapability, promiseResolve)). 1. If result is
an abrupt completion, then 1. If iteratorRecord.[[Done]] is
`false`, set result to
Completion(IteratorClose(iteratorRecord, result)). 1.
IfAbruptRejectPromise(result, promiseCapability). 1. Return ?
result.

This function requires its `this` value to be a constructor function
that supports the parameter conventions of the Promise constructor.

PerformPromiseAllSettled ( iteratorRecord: an Iterator Record, constructor: a constructor, resultCapability: a PromiseCapability Record, promiseResolve: a function object, )
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let values be a new empty List. 1. Let remainingElementsCount
be the Record { [[Value]]: 1 }. 1. Let index be 0. 1. Repeat, 1. Let
next be ? IteratorStepValue(iteratorRecord). 1. If next is
~done~, then 1. Set remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] - 1. 1. If
remainingElementsCount.[[Value]] = 0, then 1. Let valuesArray be
CreateArrayFromList(values). 1. Perform ?
Call(resultCapability.[[Resolve]], `undefined`, « valuesArray
»). 1. Return resultCapability.[[Promise]]. 1. Append `undefined`
to values. 1. Let nextPromise be ? Call(promiseResolve,
constructor, « next »). 1. Let stepsFulfilled be the
algorithm steps defined in . 1. Let lengthFulfilled be the number of
non-optional parameters of the function definition in . 1. Let
onFulfilled be CreateBuiltinFunction(stepsFulfilled,
lengthFulfilled, `""`, « [[AlreadyCalled]], [[Index]], [[Values]],
[[Capability]], [[RemainingElements]] »). 1. Let alreadyCalled be
the Record { [[Value]]: `false` }. 1. Set
onFulfilled.[[AlreadyCalled]] to alreadyCalled. 1. Set
onFulfilled.[[Index]] to index. 1. Set
onFulfilled.[[Values]] to values. 1. Set
onFulfilled.[[Capability]] to resultCapability. 1. Set
onFulfilled.[[RemainingElements]] to remainingElementsCount. 1.
Let stepsRejected be the algorithm steps defined in . 1. Let
lengthRejected be the number of non-optional parameters of the
function definition in . 1. Let onRejected be
CreateBuiltinFunction(stepsRejected, lengthRejected, `""`, «
[[AlreadyCalled]], [[Index]], [[Values]], [[Capability]],
[[RemainingElements]] »). 1. Set onRejected.[[AlreadyCalled]] to
alreadyCalled. 1. Set onRejected.[[Index]] to index. 1. Set
onRejected.[[Values]] to values. 1. Set
onRejected.[[Capability]] to resultCapability. 1. Set
onRejected.[[RemainingElements]] to remainingElementsCount. 1.
Set remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] + 1. 1. Perform ?
Invoke(nextPromise, `"then"`, « onFulfilled, onRejected
»). 1. Set index to index + 1.

`Promise.allSettled` Resolve Element Functions
------------------------------------------------

A `Promise.allSettled` resolve element function is an anonymous
built-in function that is used to resolve a specific
`Promise.allSettled` element. Each `Promise.allSettled` resolve
element function has [[Index]], [[Values]], [[Capability]],
[[RemainingElements]], and [[AlreadyCalled]] internal slots.

When a `Promise.allSettled` resolve element function is called with
argument x, the following steps are taken:

1. Let F be the active function object. 1. Let alreadyCalled be
F.[[AlreadyCalled]]. 1. If alreadyCalled.[[Value]] is `true`,
return `undefined`. 1. Set alreadyCalled.[[Value]] to `true`. 1.
Let index be F.[[Index]]. 1. Let values be F.[[Values]].
1. Let promiseCapability be F.[[Capability]]. 1. Let
remainingElementsCount be F.[[RemainingElements]]. 1. Let
obj be OrdinaryObjectCreate(%Object.prototype%). 1. Perform !
CreateDataPropertyOrThrow(obj, `"status"`, `"fulfilled"`). 1.
Perform ! CreateDataPropertyOrThrow(obj, `"value"`, x). 1. Set
values[index] to obj. 1. Set
remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] - 1. 1. If
remainingElementsCount.[[Value]] = 0, then 1. Let valuesArray be
CreateArrayFromList(values). 1. Return ?
Call(promiseCapability.[[Resolve]], `undefined`, « valuesArray
»). 1. Return `undefined`.

The `"length"` property of a `Promise.allSettled` resolve element
function is `1`\ :sub:`𝔽`.

`Promise.allSettled` Reject Element Functions
-----------------------------------------------

A `Promise.allSettled` reject element function is an anonymous
built-in function that is used to reject a specific
`Promise.allSettled` element. Each `Promise.allSettled` reject
element function has [[Index]], [[Values]], [[Capability]],
[[RemainingElements]], and [[AlreadyCalled]] internal slots.

When a `Promise.allSettled` reject element function is called with
argument x, the following steps are taken:

1. Let F be the active function object. 1. Let alreadyCalled be
F.[[AlreadyCalled]]. 1. If alreadyCalled.[[Value]] is `true`,
return `undefined`. 1. Set alreadyCalled.[[Value]] to `true`. 1.
Let index be F.[[Index]]. 1. Let values be F.[[Values]].
1. Let promiseCapability be F.[[Capability]]. 1. Let
remainingElementsCount be F.[[RemainingElements]]. 1. Let
obj be OrdinaryObjectCreate(%Object.prototype%). 1. Perform !
CreateDataPropertyOrThrow(obj, `"status"`, `"rejected"`). 1.
Perform ! CreateDataPropertyOrThrow(obj, `"reason"`, x). 1.
Set values[index] to obj. 1. Set
remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] - 1. 1. If
remainingElementsCount.[[Value]] = 0, then 1. Let valuesArray be
CreateArrayFromList(values). 1. Return ?
Call(promiseCapability.[[Resolve]], `undefined`, « valuesArray
»). 1. Return `undefined`.

The `"length"` property of a `Promise.allSettled` reject element
function is `1`\ :sub:`𝔽`.

Promise.any ( iterable )
----------------------------

This function returns a promise that is fulfilled by the first given
promise to be fulfilled, or rejected with an `AggregateError` holding
the rejection reasons if all of the given promises are rejected. It
resolves all elements of the passed iterable to promises as it runs this
algorithm.

1. Let C be the `this` value. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Let promiseResolve be
Completion(GetPromiseResolve(C)). 1.
IfAbruptRejectPromise(promiseResolve, promiseCapability). 1. Let
iteratorRecord be Completion(GetIterator(iterable, ~sync~)). 1.
IfAbruptRejectPromise(iteratorRecord, promiseCapability). 1. Let
result be Completion(PerformPromiseAny(iteratorRecord, C,
promiseCapability, promiseResolve)). 1. If result is an
abrupt completion, then 1. If iteratorRecord.[[Done]] is `false`,
set result to Completion(IteratorClose(iteratorRecord,
result)). 1. IfAbruptRejectPromise(result,
promiseCapability). 1. Return ? result.

This function requires its `this` value to be a constructor function
that supports the parameter conventions of the `Promise` constructor.

PerformPromiseAny ( iteratorRecord: an Iterator Record, constructor: a constructor, resultCapability: a PromiseCapability Record, promiseResolve: a function object, )
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let errors be a new empty List. 1. Let remainingElementsCount
be the Record { [[Value]]: 1 }. 1. Let index be 0. 1. Repeat, 1. Let
next be ? IteratorStepValue(iteratorRecord). 1. If next is
~done~, then 1. Set remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] - 1. 1. If
remainingElementsCount.[[Value]] = 0, then 1. Let error be a
newly created `AggregateError` object. 1. Perform !
DefinePropertyOrThrow(error, `"errors"`, PropertyDescriptor {
[[Configurable]]: `true`, [[Enumerable]]: `false`, [[Writable]]:
`true`, [[Value]]: CreateArrayFromList(errors) }). 1. Return
ThrowCompletion(error). 1. Return resultCapability.[[Promise]].
1. Append `undefined` to errors. 1. Let nextPromise be ?
Call(promiseResolve, constructor, « next »). 1. Let
stepsRejected be the algorithm steps defined in . 1. Let
lengthRejected be the number of non-optional parameters of the
function definition in . 1. Let onRejected be
CreateBuiltinFunction(stepsRejected, lengthRejected, `""`, «
[[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]],
[[RemainingElements]] »). 1. Set onRejected.[[AlreadyCalled]] to
`false`. 1. Set onRejected.[[Index]] to index. 1. Set
onRejected.[[Errors]] to errors. 1. Set
onRejected.[[Capability]] to resultCapability. 1. Set
onRejected.[[RemainingElements]] to remainingElementsCount. 1.
Set remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] + 1. 1. Perform ?
Invoke(nextPromise, `"then"`, « resultCapability.[[Resolve]],
onRejected »). 1. Set index to index + 1.

`Promise.any` Reject Element Functions
----------------------------------------

A `Promise.any` reject element function is an anonymous built-in
function that is used to reject a specific `Promise.any` element. Each
`Promise.any` reject element function has [[Index]], [[Errors]],
[[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal
slots.

When a `Promise.any` reject element function is called with argument
x, the following steps are taken:

1. Let F be the active function object. 1. If
F.[[AlreadyCalled]] is `true`, return `undefined`. 1. Set
F.[[AlreadyCalled]] to `true`. 1. Let index be
F.[[Index]]. 1. Let errors be F.[[Errors]]. 1. Let
promiseCapability be F.[[Capability]]. 1. Let
remainingElementsCount be F.[[RemainingElements]]. 1. Set
errors[index] to x. 1. Set
remainingElementsCount.[[Value]] to
remainingElementsCount.[[Value]] - 1. 1. If
remainingElementsCount.[[Value]] = 0, then 1. Let error be a
newly created `AggregateError` object. 1. Perform !
DefinePropertyOrThrow(error, `"errors"`, PropertyDescriptor {
[[Configurable]]: `true`, [[Enumerable]]: `false`, [[Writable]]:
`true`, [[Value]]: CreateArrayFromList(errors) }). 1. Return ?
Call(promiseCapability.[[Reject]], `undefined`, « error »). 1.
Return `undefined`.

The `"length"` property of a `Promise.any` reject element function
is `1`\ :sub:`𝔽`.

Promise.prototype
-----------------

The initial value of `Promise.prototype` is the Promise prototype
object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Promise.race ( iterable )
-----------------------------

This function returns a new promise which is settled in the same way as
the first passed promise to settle. It resolves all elements of the
passed iterable to promises as it runs this algorithm.

1. Let C be the `this` value. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Let promiseResolve be
Completion(GetPromiseResolve(C)). 1.
IfAbruptRejectPromise(promiseResolve, promiseCapability). 1. Let
iteratorRecord be Completion(GetIterator(iterable, ~sync~)). 1.
IfAbruptRejectPromise(iteratorRecord, promiseCapability). 1. Let
result be Completion(PerformPromiseRace(iteratorRecord, C,
promiseCapability, promiseResolve)). 1. If result is an
abrupt completion, then 1. If iteratorRecord.[[Done]] is `false`,
set result to Completion(IteratorClose(iteratorRecord,
result)). 1. IfAbruptRejectPromise(result,
promiseCapability). 1. Return ? result.

If the iterable argument yields no values or if none of the promises
yielded by iterable ever settle, then the pending promise returned
by this method will never be settled.

This function expects its `this` value to be a constructor function
that supports the parameter conventions of the Promise constructor. It
also expects that its `this` value provides a `resolve` method.

PerformPromiseRace ( iteratorRecord: an Iterator Record, constructor: a constructor, resultCapability: a PromiseCapability Record, promiseResolve: a function object, )
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Repeat, 1. Let next be ? IteratorStepValue(iteratorRecord).
1. If next is ~done~, then 1. Return
resultCapability.[[Promise]]. 1. Let nextPromise be ?
Call(promiseResolve, constructor, « next »). 1. Perform ?
Invoke(nextPromise, `"then"`, « resultCapability.[[Resolve]],
resultCapability.[[Reject]] »).

Promise.reject ( r )
------------------------

This function returns a new promise rejected with the passed argument.

1. Let C be the `this` value. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Perform ?
Call(promiseCapability.[[Reject]], `undefined`, « r »). 1.
Return promiseCapability.[[Promise]].

This function expects its `this` value to be a constructor function
that supports the parameter conventions of the Promise constructor.

Promise.resolve ( x )
-------------------------

This function returns either a new promise resolved with the passed
argument, or the argument itself if the argument is a promise produced
by this constructor.

1. Let C be the `this` value. 1. If C is not an Object, throw
a `TypeError` exception. 1. Return ? PromiseResolve(C, x).

This function expects its `this` value to be a constructor function
that supports the parameter conventions of the Promise constructor.

PromiseResolve ( C: an Object, x, )
-----------------------------------

description
   It returns a new promise resolved with x.

1. If IsPromise(x) is `true`, then 1. Let xConstructor be ?
Get(x, `"constructor"`). 1. If SameValue(xConstructor, C)
is `true`, return x. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Perform ?
Call(promiseCapability.[[Resolve]], `undefined`, « x »). 1.
Return promiseCapability.[[Promise]].

Promise.try ( callback, ..._args )
----------------------------------------

This function performs the following steps when called:

1. Let C be the `this` value. 1. If C is not an Object, throw
a `TypeError` exception. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Let status be
Completion(Call(callback, `undefined`, args)). 1. If
status is an abrupt completion, then 1. Perform ?
Call(promiseCapability.[[Reject]], `undefined`, «
status.[[Value]] »). 1. Else, 1. Perform ?
Call(promiseCapability.[[Resolve]], `undefined`, «
status.[[Value]] »). 1. Return promiseCapability.[[Promise]].

This function expects its `this` value to be a constructor function
that supports the parameter conventions of the Promise constructor.

Promise.withResolvers ( )
-------------------------

This function returns an object with three properties: a new promise
together with the `resolve` and `reject` functions associated with
it.

1. Let C be the `this` value. 1. Let promiseCapability be ?
NewPromiseCapability(C). 1. Let obj be
OrdinaryObjectCreate(%Object.prototype%). 1. Perform !
CreateDataPropertyOrThrow(obj, `"promise"`,
promiseCapability.[[Promise]]). 1. Perform !
CreateDataPropertyOrThrow(obj, `"resolve"`,
promiseCapability.[[Resolve]]). 1. Perform !
CreateDataPropertyOrThrow(obj, `"reject"`,
promiseCapability.[[Reject]]). 1. Return obj.

get Promise [ %Symbol.species% ]
--------------------------------

`Promise[%Symbol.species%]` is an accessor property whose set accessor
function is `undefined`. Its get accessor function performs the
following steps when called:

1. Return the `this` value.

The value of the `"name"` property of this function is `"get
[Symbol.species]"`.

Promise prototype methods normally use their `this` value's
constructor to create a derived object. However, a subclass constructor
may over-ride that default behaviour by redefining its %Symbol.species%
property.

Properties of the Promise Prototype Object
------------------------------------------

The Promise prototype object:

- is %Promise.prototype%.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is an ordinary object.
- does not have a [[PromiseState]] internal slot or any of the other
  internal slots of Promise instances.

Promise.prototype.catch ( onRejected )
------------------------------------------

This method performs the following steps when called:

1. Let promise be the `this` value. 1. Return ?
Invoke(promise, `"then"`, « `undefined`, onRejected »).

Promise.prototype.constructor
-----------------------------

The initial value of `Promise.prototype.constructor` is %Promise%.

Promise.prototype.finally ( onFinally )
-------------------------------------------

This method performs the following steps when called:

1. Let promise be the `this` value. 1. If promise is not an
Object, throw a `TypeError` exception. 1. Let C be ?
SpeciesConstructor(promise, %Promise%). 1. Assert:
IsConstructor(C) is `true`. 1. If IsCallable(onFinally) is
`false`, then 1. Let thenFinally be onFinally. 1. Let
catchFinally be onFinally. 1. Else, 1. Let
thenFinallyClosure be a new Abstract Closure with parameters
(value) that captures onFinally and C and performs the
following steps when called: 1. Let result be ? Call(onFinally,
`undefined`). 1. Let p be ? PromiseResolve(C, result). 1.
Let returnValue be a new Abstract Closure with no parameters that
captures value and performs the following steps when called: 1.
Return value. 1. Let valueThunk be
CreateBuiltinFunction(returnValue, 0, `""`, « »). 1. Return ?
Invoke(p, `"then"`, « valueThunk »). 1. Let thenFinally be
CreateBuiltinFunction(thenFinallyClosure, 1, `""`, « »). 1. Let
catchFinallyClosure be a new Abstract Closure with parameters
(reason) that captures onFinally and C and performs the
following steps when called: 1. Let result be ? Call(onFinally,
`undefined`). 1. Let p be ? PromiseResolve(C, result). 1.
Let throwReason be a new Abstract Closure with no parameters that
captures reason and performs the following steps when called: 1.
Return ThrowCompletion(reason). 1. Let thrower be
CreateBuiltinFunction(throwReason, 0, `""`, « »). 1. Return ?
Invoke(p, `"then"`, « thrower »). 1. Let catchFinally be
CreateBuiltinFunction(catchFinallyClosure, 1, `""`, « »). 1.
Return ? Invoke(promise, `"then"`, « thenFinally,
catchFinally »).

Promise.prototype.then ( onFulfilled, onRejected )
----------------------------------------------------------

This method performs the following steps when called:

1. Let promise be the `this` value. 1. If IsPromise(promise)
is `false`, throw a `TypeError` exception. 1. Let C be ?
SpeciesConstructor(promise, %Promise%). 1. Let resultCapability
be ? NewPromiseCapability(C). 1. Return
PerformPromiseThen(promise, onFulfilled, onRejected,
resultCapability).

PerformPromiseThen ( promise: a Promise, onFulfilled, onRejected, optional resultCapability: a PromiseCapability Record, )
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

description
   It performs the “then” operation on promise using onFulfilled
   and onRejected as its settlement actions. If resultCapability
   is passed, the result is stored by updating resultCapability's
   promise. If it is not passed, then PerformPromiseThen is being called
   by a specification-internal operation where the result does not
   matter.

1. Assert: IsPromise(promise) is `true`. 1. If
resultCapability is not present, then 1. Set resultCapability to
`undefined`. 1. If IsCallable(onFulfilled) is `false`, then 1.
Let onFulfilledJobCallback be ~empty~. 1. Else, 1. Let
onFulfilledJobCallback be HostMakeJobCallback(onFulfilled). 1.
If IsCallable(onRejected) is `false`, then 1. Let
onRejectedJobCallback be ~empty~. 1. Else, 1. Let
onRejectedJobCallback be HostMakeJobCallback(onRejected). 1. Let
fulfillReaction be the PromiseReaction Record { [[Capability]]:
resultCapability, [[Type]]: ~fulfill~, [[Handler]]:
onFulfilledJobCallback }. 1. Let rejectReaction be the
PromiseReaction Record { [[Capability]]: resultCapability, [[Type]]:
~reject~, [[Handler]]: onRejectedJobCallback }. 1. If
promise.[[PromiseState]] is ~pending~, then 1. Append
fulfillReaction to promise.[[PromiseFulfillReactions]]. 1.
Append rejectReaction to promise.[[PromiseRejectReactions]]. 1.
Else if promise.[[PromiseState]] is ~fulfilled~, then 1. Let
value be promise.[[PromiseResult]]. 1. Let fulfillJob be
NewPromiseReactionJob(fulfillReaction, value). 1. Perform
HostEnqueuePromiseJob(fulfillJob.[[Job]], fulfillJob.[[Realm]]).
1. Else, 1. Assert: The value of promise.[[PromiseState]] is
~rejected~. 1. Let reason be promise.[[PromiseResult]]. 1. If
promise.[[PromiseIsHandled]] is `false`, perform
HostPromiseRejectionTracker(promise, `"handle"`). 1. Let
rejectJob be NewPromiseReactionJob(rejectReaction, reason).
1. Perform HostEnqueuePromiseJob(rejectJob.[[Job]],
rejectJob.[[Realm]]). 1. Set promise.[[PromiseIsHandled]] to
`true`. 1. If resultCapability is `undefined`, then 1. Return
`undefined`. 1. Else, 1. Return resultCapability.[[Promise]].

Promise.prototype [ %Symbol.toStringTag% ]
------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Promise"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of Promise Instances
-------------------------------

Promise instances are ordinary objects that inherit properties from the
Promise prototype object (the intrinsic, %Promise.prototype%). Promise
instances are initially created with the internal slots described in .

+----------------------+----------------------+----------------------+
| Internal Slot        | Type                 | Description          |
+======================+======================+======================+
| [[PromiseState]]     | ~pending~,           | Governs how a        |
|                      | ~fulfilled~, or      | promise will react   |
|                      | ~rejected~           | to incoming calls to |
|                      |                      | its `then` method. |
+----------------------+----------------------+----------------------+
| [[PromiseResult]]    | an ECMAScript        | The value with which |
|                      | language value       | the promise has been |
|                      |                      | fulfilled or         |
|                      |                      | rejected, if any.    |
|                      |                      | Only meaningful if   |
|                      |                      | [[PromiseState]] is  |
|                      |                      | not ~pending~.       |
+----------------------+----------------------+----------------------+
| [[Promi              | a List of            | Records to be        |
| seFulfillReactions]] | PromiseReaction      | processed when/if    |
|                      | Records              | the promise          |
|                      |                      | transitions from the |
|                      |                      | ~pending~ state to   |
|                      |                      | the ~fulfilled~      |
|                      |                      | state.               |
+----------------------+----------------------+----------------------+
| [[Prom               | a List of            | Records to be        |
| iseRejectReactions]] | PromiseReaction      | processed when/if    |
|                      | Records              | the promise          |
|                      |                      | transitions from the |
|                      |                      | ~pending~ state to   |
|                      |                      | the ~rejected~       |
|                      |                      | state.               |
+----------------------+----------------------+----------------------+
| [[PromiseIsHandled]] | a Boolean            | Indicates whether    |
|                      |                      | the promise has ever |
|                      |                      | had a fulfillment or |
|                      |                      | rejection handler;   |
|                      |                      | used in unhandled    |
|                      |                      | rejection tracking.  |
+----------------------+----------------------+----------------------+

GeneratorFunction Objects
-------------------------

GeneratorFunctions are functions that are usually created by evaluating
\|GeneratorDeclaration|s, \|GeneratorExpression|s, and
\|GeneratorMethod|s. They may also be created by calling the
%GeneratorFunction% intrinsic.

.. figure:: https://tc39.es/ecma262/img/figure-2.svg
   :width: 900px
   :height: 700px

   A staggering variety of boxes and arrows.


The GeneratorFunction Constructor
---------------------------------

The GeneratorFunction constructor:

- is %GeneratorFunction%.
- is a subclass of `Function`.
- creates and initializes a new GeneratorFunction when called as a
  function rather than as a constructor. Thus the function call
  `GeneratorFunction (…)` is equivalent to the object creation
  expression `new GeneratorFunction (…)` with the same arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  GeneratorFunction behaviour must include a `super` call to the
  GeneratorFunction constructor to create and initialize subclass
  instances with the internal slots necessary for built-in
  GeneratorFunction behaviour. All ECMAScript syntactic forms for
  defining generator function objects create direct instances of
  GeneratorFunction. There is no syntactic means to create instances of
  GeneratorFunction subclasses.

GeneratorFunction ( ..._parameterArgs, bodyArg )
------------------------------------------------------

The last argument (if any) specifies the body (executable code) of a
generator function; any preceding arguments specify formal parameters.

This function performs the following steps when called:

1. Let C be the active function object. 1. If bodyArg is not
present, set bodyArg to the empty String. 1. Return ?
CreateDynamicFunction(C, NewTarget, ~generator~, parameterArgs,
bodyArg).

See NOTE for .

Properties of the GeneratorFunction Constructor
-----------------------------------------------

The GeneratorFunction constructor:

- is a standard built-in function object that inherits from the Function
  constructor.
- has a [[Prototype]] internal slot whose value is %Function%.
- has a `"length"` property whose value is `1`\ :sub:`𝔽`.
- has a `"name"` property whose value is `"GeneratorFunction"`.
- has the following properties:

GeneratorFunction.prototype
---------------------------

The initial value of `GeneratorFunction.prototype` is the
GeneratorFunction prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the GeneratorFunction Prototype Object
----------------------------------------------------

The GeneratorFunction prototype object:

- is %GeneratorFunction.prototype% (see ).
- is an ordinary object.
- is not a function object and does not have an [[ECMAScriptCode]]
  internal slot or any other of the internal slots listed in or .
- has a [[Prototype]] internal slot whose value is %Function.prototype%.

GeneratorFunction.prototype.constructor
---------------------------------------

The initial value of `GeneratorFunction.prototype.constructor` is
%GeneratorFunction%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

GeneratorFunction.prototype.prototype
-------------------------------------

The initial value of `GeneratorFunction.prototype.prototype` is
%GeneratorPrototype%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

GeneratorFunction.prototype [ %Symbol.toStringTag% ]
----------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"GeneratorFunction"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

GeneratorFunction Instances
---------------------------

Every GeneratorFunction instance is an ECMAScript function object and
has the internal slots listed in . The value of the
[[IsClassConstructor]] internal slot for all such instances is
`false`.

Each GeneratorFunction instance has the following own properties:

.. _length-3:

length
------

The specification for the `"length"` property of Function instances
given in also applies to GeneratorFunction instances.

.. _name-1:

name
----

The specification for the `"name"` property of Function instances
given in also applies to GeneratorFunction instances.

.. _prototype-2:

prototype
---------

Whenever a GeneratorFunction instance is created another ordinary object
is also created and is the initial value of the generator function's
`"prototype"` property. The value of the prototype property is used to
initialize the [[Prototype]] internal slot of a newly created Generator
when the generator function object is invoked using [[Call]].

This property has the attributes { [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Unlike Function instances, the object that is the value of a
GeneratorFunction's `"prototype"` property does not have a
`"constructor"` property whose value is the GeneratorFunction
instance.

AsyncGeneratorFunction Objects
------------------------------

AsyncGeneratorFunctions are functions that are usually created by
evaluating `AsyncGeneratorDeclaration`, `AsyncGeneratorExpression`,
and `AsyncGeneratorMethod` syntactic productions. They may also be
created by calling the %AsyncGeneratorFunction% intrinsic.

The AsyncGeneratorFunction Constructor
--------------------------------------

The AsyncGeneratorFunction constructor:

- is %AsyncGeneratorFunction%.
- is a subclass of `Function`.
- creates and initializes a new AsyncGeneratorFunction when called as a
  function rather than as a constructor. Thus the function call
  `AsyncGeneratorFunction (...)` is equivalent to the object creation
  expression `new AsyncGeneratorFunction (...)` with the same
  arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  AsyncGeneratorFunction behaviour must include a `super` call to the
  AsyncGeneratorFunction constructor to create and initialize subclass
  instances with the internal slots necessary for built-in
  AsyncGeneratorFunction behaviour. All ECMAScript syntactic forms for
  defining async generator function objects create direct instances of
  AsyncGeneratorFunction. There is no syntactic means to create
  instances of AsyncGeneratorFunction subclasses.

AsyncGeneratorFunction ( ..._parameterArgs, bodyArg )
-----------------------------------------------------------

The last argument (if any) specifies the body (executable code) of an
async generator function; any preceding arguments specify formal
parameters.

This function performs the following steps when called:

1. Let C be the active function object. 1. If bodyArg is not
present, set bodyArg to the empty String. 1. Return ?
CreateDynamicFunction(C, NewTarget, ~async-generator~,
parameterArgs, bodyArg).

See NOTE for .

Properties of the AsyncGeneratorFunction Constructor
----------------------------------------------------

The AsyncGeneratorFunction constructor:

- is a standard built-in function object that inherits from the Function
  constructor.
- has a [[Prototype]] internal slot whose value is %Function%.
- has a `"length"` property whose value is `1`\ :sub:`𝔽`.
- has a `"name"` property whose value is `"AsyncGeneratorFunction"`.
- has the following properties:

AsyncGeneratorFunction.prototype
--------------------------------

The initial value of `AsyncGeneratorFunction.prototype` is the
AsyncGeneratorFunction prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the AsyncGeneratorFunction Prototype Object
---------------------------------------------------------

The AsyncGeneratorFunction prototype object:

- is %AsyncGeneratorFunction.prototype%.
- is an ordinary object.
- is not a function object and does not have an [[ECMAScriptCode]]
  internal slot or any other of the internal slots listed in or .
- has a [[Prototype]] internal slot whose value is %Function.prototype%.

AsyncGeneratorFunction.prototype.constructor
--------------------------------------------

The initial value of `AsyncGeneratorFunction.prototype.constructor` is
%AsyncGeneratorFunction%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

AsyncGeneratorFunction.prototype.prototype
------------------------------------------

The initial value of `AsyncGeneratorFunction.prototype.prototype` is
%AsyncGeneratorPrototype%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]
---------------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"AsyncGeneratorFunction"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

AsyncGeneratorFunction Instances
--------------------------------

Every AsyncGeneratorFunction instance is an ECMAScript function object
and has the internal slots listed in . The value of the
[[IsClassConstructor]] internal slot for all such instances is
`false`.

Each AsyncGeneratorFunction instance has the following own properties:

.. _length-4:

length
------

The value of the `"length"` property is an integral Number that
indicates the typical number of arguments expected by the
AsyncGeneratorFunction. However, the language permits the function to be
invoked with some other number of arguments. The behaviour of an
AsyncGeneratorFunction when invoked on a number of arguments other than
the number specified by its `"length"` property depends on the
function.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

.. _name-2:

name
----

The specification for the `"name"` property of Function instances
given in also applies to AsyncGeneratorFunction instances.

.. _prototype-3:

prototype
---------

Whenever an AsyncGeneratorFunction instance is created, another ordinary
object is also created and is the initial value of the async generator
function's `"prototype"` property. The value of the prototype property
is used to initialize the [[Prototype]] internal slot of a newly created
AsyncGenerator when the generator function object is invoked using
[[Call]].

This property has the attributes { [[Writable]]: `true`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Unlike function instances, the object that is the value of an
AsyncGeneratorFunction's `"prototype"` property does not have a
`"constructor"` property whose value is the AsyncGeneratorFunction
instance.

Generator Objects
-----------------

A Generator is created by calling a generator function and conforms to
both the iterator interface and the iterable interface.

Generator instances directly inherit properties from the initial value
of the `"prototype"` property of the generator function that created
the instance. Generator instances indirectly inherit properties from
%GeneratorPrototype%.

The %GeneratorPrototype% Object
-------------------------------

The %GeneratorPrototype% object:

- is %GeneratorFunction.prototype.prototype%.
- is an ordinary object.
- is not a Generator instance and does not have a [[GeneratorState]]
  internal slot.
- has a [[Prototype]] internal slot whose value is %Iterator.prototype%.
- has properties that are indirectly inherited by all Generator
  instances.

%GeneratorPrototype%.constructor
--------------------------------

The initial value of %GeneratorPrototype%`.constructor` is
%GeneratorFunction.prototype%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

%GeneratorPrototype%.next ( value )
---------------------------------------

1. Return ? GeneratorResume(`this` value, value, ~empty~).

%GeneratorPrototype%.return ( value )
-----------------------------------------

This method performs the following steps when called:

1. Let g be the `this` value. 1. Let C be
ReturnCompletion(value). 1. Return ? GeneratorResumeAbrupt(g,
C, ~empty~).

%GeneratorPrototype%.throw ( exception )
--------------------------------------------

This method performs the following steps when called:

1. Let g be the `this` value. 1. Let C be
ThrowCompletion(exception). 1. Return ? GeneratorResumeAbrupt(g,
C, ~empty~).

%GeneratorPrototype% [ %Symbol.toStringTag% ]
---------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Generator"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of Generator Instances
---------------------------------

Generator instances are initially created with the internal slots
described in .

+----------------------+----------------------+----------------------+
| Internal Slot        | Type                 | Description          |
+======================+======================+======================+
| [[GeneratorState]]   | ~suspended-start~,   | The current          |
|                      | ~suspended-yield~,   | execution state of   |
|                      | ~executing~, or      | the generator.       |
|                      | ~completed~          |                      |
+----------------------+----------------------+----------------------+
| [[GeneratorContext]] | an execution context | The execution        |
|                      |                      | context that is used |
|                      |                      | when executing the   |
|                      |                      | code of this         |
|                      |                      | generator.           |
+----------------------+----------------------+----------------------+
| [[GeneratorBrand]]   | a String or ~empty~  | A brand used to      |
|                      |                      | distinguish          |
|                      |                      | different kinds of   |
|                      |                      | generators. The      |
|                      |                      | [[GeneratorBrand]]   |
|                      |                      | of generators        |
|                      |                      | declared by          |
|                      |                      | ECMAScript source    |
|                      |                      | text is always       |
|                      |                      | ~empty~.             |
+----------------------+----------------------+----------------------+

Generator Abstract Operations
-----------------------------

GeneratorStart ( generator: a Generator, generatorBody: a `FunctionBody` Parse Node or an Abstract Closure with no parameters, ): ~unused~
----------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: The value of generator.[[GeneratorState]] is
~suspended-start~. 1. Let genContext be the running execution
context. 1. Set the Generator component of genContext to
generator. 1. Let closure be a new Abstract Closure with no
parameters that captures generatorBody and performs the following
steps when called: 1. Let acGenContext be the running execution
context. 1. Let acGenerator be the Generator component of
acGenContext. 1. If generatorBody is a Parse Node, then 1. Let
result be Completion(Evaluation of generatorBody). 1. Else, 1.
Assert: generatorBody is an Abstract Closure with no parameters. 1.
Let result be generatorBody(). 1. Assert: If we return here, the
generator either threw an exception or performed either an implicit or
explicit return. 1. Remove acGenContext from the execution context
stack and restore the execution context that is at the top of the
execution context stack as the running execution context. 1. Set
acGenerator.[[GeneratorState]] to ~completed~. 1. NOTE: Once a
generator enters the ~completed~ state it never leaves it and its
associated execution context is never resumed. Any execution state
associated with acGenerator can be discarded at this point. 1. If
result is a normal completion, then 1. Let resultValue be
`undefined`. 1. Else if result is a return completion, then 1. Let
resultValue be result.[[Value]]. 1. Else, 1. Assert: result
is a throw completion. 1. Return ? result. 1. Return
CreateIteratorResultObject(resultValue, `true`). 1. Set the code
evaluation state of genContext such that when evaluation is resumed
for that execution context, closure will be called with no
arguments. 1. Set generator.[[GeneratorContext]] to genContext.
1. Return ~unused~.

GeneratorValidate ( generator, generatorBrand: a String or ~empty~, )
---------------------------------------------------------------------

1. Perform ? RequireInternalSlot(generator, [[GeneratorState]]). 1.
Perform ? RequireInternalSlot(generator, [[GeneratorBrand]]). 1. If
generator.[[GeneratorBrand]] is not generatorBrand, throw a
`TypeError` exception. 1. Assert: generator also has a
[[GeneratorContext]] internal slot. 1. Let state be
generator.[[GeneratorState]]. 1. If state is ~executing~, throw
a `TypeError` exception. 1. Return state.

GeneratorResume ( generator, value or ~empty~, generatorBrand: a String or ~empty~, )
-------------------------------------------------------------------------------------

1. Let state be ? GeneratorValidate(generator,
generatorBrand). 1. If state is ~completed~, return
CreateIteratorResultObject(`undefined`, `true`). 1. Assert:
state is either ~suspended-start~ or ~suspended-yield~. 1. Let
genContext be generator.[[GeneratorContext]]. 1. Let
methodContext be the running execution context. 1. Suspend
methodContext. 1. Set generator.[[GeneratorState]] to
~executing~. 1. Push genContext onto the execution context stack;
genContext is now the running execution context. 1. Resume the
suspended evaluation of genContext using NormalCompletion(value)
as the result of the operation that suspended it. Let result be the
value returned by the resumed computation. 1. Assert: When we return
here, genContext has already been removed from the execution context
stack and methodContext is the currently running execution context.
1. Return ? result.

GeneratorResumeAbrupt ( generator, abruptCompletion: a return completion or a throw completion, generatorBrand: a String or ~empty~, )
--------------------------------------------------------------------------------------------------------------------------------------

1. Let state be ? GeneratorValidate(generator,
generatorBrand). 1. If state is ~suspended-start~, then 1. Set
generator.[[GeneratorState]] to ~completed~. 1. NOTE: Once a
generator enters the ~completed~ state it never leaves it and its
associated execution context is never resumed. Any execution state
associated with generator can be discarded at this point. 1. Set
state to ~completed~. 1. If state is ~completed~, then 1. If
abruptCompletion is a return completion, then 1. Return
CreateIteratorResultObject(abruptCompletion.[[Value]], `true`). 1.
Return ? abruptCompletion. 1. Assert: state is
~suspended-yield~. 1. Let genContext be
generator.[[GeneratorContext]]. 1. Let methodContext be the
running execution context. 1. Suspend methodContext. 1. Set
generator.[[GeneratorState]] to ~executing~. 1. Push genContext
onto the execution context stack; genContext is now the running
execution context. 1. Resume the suspended evaluation of genContext
using abruptCompletion as the result of the operation that suspended
it. Let result be the Completion Record returned by the resumed
computation. 1. Assert: When we return here, genContext has already
been removed from the execution context stack and methodContext is
the currently running execution context. 1. Return ? result.

GetGeneratorKind ( ): ~non-generator~, ~sync~, or ~async~
---------------------------------------------------------

1. Let genContext be the running execution context. 1. If
genContext does not have a Generator component, return
~non-generator~. 1. Let generator be the Generator component of
genContext. 1. If generator has an [[AsyncGeneratorState]]
internal slot, return ~async~. 1. Else, return ~sync~.

GeneratorYield ( iteratorResult: an Object that conforms to the IteratorResult interface, )
-------------------------------------------------------------------------------------------

1. Let genContext be the running execution context. 1. Assert:
genContext is the execution context of a generator. 1. Let
generator be the value of the Generator component of genContext.
1. Assert: GetGeneratorKind() is ~sync~. 1. Set
generator.[[GeneratorState]] to ~suspended-yield~. 1. Remove
genContext from the execution context stack and restore the
execution context that is at the top of the execution context stack as
the running execution context. 1. Let callerContext be the running
execution context. 1. Resume callerContext passing
NormalCompletion(iteratorResult). If genContext is ever resumed
again, let resumptionValue be the Completion Record with which it is
resumed. 1. Assert: If control reaches here, then genContext is the
running execution context again. 1. Return resumptionValue.

Yield ( value, )
----------------

1. Let generatorKind be GetGeneratorKind(). 1. If generatorKind
is ~async~, return ? AsyncGeneratorYield(? Await(value)). 1.
Otherwise, return ? GeneratorYield(CreateIteratorResultObject(value,
`false`)).

CreateIteratorFromClosure ( closure: an Abstract Closure with no parameters, generatorBrand: a String or ~empty~, generatorPrototype: an Object, optional extraSlots: a List of names of internal slots, ): a Generator
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. NOTE: closure can contain uses of the Yield operation to yield an
IteratorResult object. 1. If extraSlots is not present, set
extraSlots to a new empty List. 1. Let internalSlotsList be the
list-concatenation of extraSlots and « [[GeneratorState]],
[[GeneratorContext]], [[GeneratorBrand]] ». 1. Let generator be
OrdinaryObjectCreate(generatorPrototype, internalSlotsList). 1.
Set generator.[[GeneratorBrand]] to generatorBrand. 1. Set
generator.[[GeneratorState]] to ~suspended-start~. 1. Let
callerContext be the running execution context. 1. Let
calleeContext be a new execution context. 1. Set the Function of
calleeContext to `null`. 1. Set the Realm of calleeContext to
the current Realm Record. 1. Set the ScriptOrModule of calleeContext
to callerContext's ScriptOrModule. 1. If callerContext is not
already suspended, suspend callerContext. 1. Push calleeContext
onto the execution context stack; calleeContext is now the running
execution context. 1. Perform GeneratorStart(generator,
closure). 1. Remove calleeContext from the execution context
stack and restore callerContext as the running execution context. 1.
Return generator.

AsyncGenerator Objects
----------------------

An AsyncGenerator is created by calling an async generator function and
conforms to both the async iterator interface and the async iterable
interface.

AsyncGenerator instances directly inherit properties from the initial
value of the `"prototype"` property of the async generator function
that created the instance. AsyncGenerator instances indirectly inherit
properties from %AsyncGeneratorPrototype%.

The %AsyncGeneratorPrototype% Object
------------------------------------

The %AsyncGeneratorPrototype% object:

- is %AsyncGeneratorFunction.prototype.prototype%.
- is an ordinary object.
- is not an AsyncGenerator instance and does not have an
  [[AsyncGeneratorState]] internal slot.
- has a [[Prototype]] internal slot whose value is
  %AsyncIteratorPrototype%.
- has properties that are indirectly inherited by all AsyncGenerator
  instances.

%AsyncGeneratorPrototype%.constructor
-------------------------------------

The initial value of %AsyncGeneratorPrototype%`.constructor` is
%AsyncGeneratorFunction.prototype%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

%AsyncGeneratorPrototype%.next ( value )
--------------------------------------------

1. Let generator be the `this` value. 1. Let promiseCapability
be ! NewPromiseCapability(%Promise%). 1. Let result be
Completion(AsyncGeneratorValidate(generator, ~empty~)). 1.
IfAbruptRejectPromise(result, promiseCapability). 1. Let
state be generator.[[AsyncGeneratorState]]. 1. If state is
~completed~, then 1. Let iteratorResult be
CreateIteratorResultObject(`undefined`, `true`). 1. Perform !
Call(promiseCapability.[[Resolve]], `undefined`, «
iteratorResult »). 1. Return promiseCapability.[[Promise]]. 1.
Let completion be NormalCompletion(value). 1. Perform
AsyncGeneratorEnqueue(generator, completion,
promiseCapability). 1. If state is either ~suspended-start~ or
~suspended-yield~, then 1. Perform AsyncGeneratorResume(generator,
completion). 1. Else, 1. Assert: state is either ~executing~ or
~draining-queue~. 1. Return promiseCapability.[[Promise]].

%AsyncGeneratorPrototype%.return ( value )
----------------------------------------------

1. Let generator be the `this` value. 1. Let promiseCapability
be ! NewPromiseCapability(%Promise%). 1. Let result be
Completion(AsyncGeneratorValidate(generator, ~empty~)). 1.
IfAbruptRejectPromise(result, promiseCapability). 1. Let
completion be ReturnCompletion(value). 1. Perform
AsyncGeneratorEnqueue(generator, completion,
promiseCapability). 1. Let state be
generator.[[AsyncGeneratorState]]. 1. If state is either
~suspended-start~ or ~completed~, then 1. Set
generator.[[AsyncGeneratorState]] to ~draining-queue~. 1. Perform
AsyncGeneratorAwaitReturn(generator). 1. Else if state is
~suspended-yield~, then 1. Perform AsyncGeneratorResume(generator,
completion). 1. Else, 1. Assert: state is either ~executing~ or
~draining-queue~. 1. Return promiseCapability.[[Promise]].

%AsyncGeneratorPrototype%.throw ( exception )
-------------------------------------------------

1. Let generator be the `this` value. 1. Let promiseCapability
be ! NewPromiseCapability(%Promise%). 1. Let result be
Completion(AsyncGeneratorValidate(generator, ~empty~)). 1.
IfAbruptRejectPromise(result, promiseCapability). 1. Let
state be generator.[[AsyncGeneratorState]]. 1. If state is
~suspended-start~, then 1. Set generator.[[AsyncGeneratorState]] to
~completed~. 1. Set state to ~completed~. 1. If state is
~completed~, then 1. Perform ! Call(promiseCapability.[[Reject]],
`undefined`, « exception »). 1. Return
promiseCapability.[[Promise]]. 1. Let completion be
ThrowCompletion(exception). 1. Perform
AsyncGeneratorEnqueue(generator, completion,
promiseCapability). 1. If state is ~suspended-yield~, then 1.
Perform AsyncGeneratorResume(generator, completion). 1. Else, 1.
Assert: state is either ~executing~ or ~draining-queue~. 1. Return
promiseCapability.[[Promise]].

%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]
--------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"AsyncGenerator"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Properties of AsyncGenerator Instances
--------------------------------------

AsyncGenerator instances are initially created with the internal slots
described below:

+----------------------+----------------------+----------------------+
| Internal Slot        | Type                 | Description          |
+======================+======================+======================+
| [[A                  | ~suspended-start~,   | The current          |
| syncGeneratorState]] | ~suspended-yield~,   | execution state of   |
|                      | ~executing~,         | the async generator. |
|                      | ~draining-queue~, or |                      |
|                      | ~completed~          |                      |
+----------------------+----------------------+----------------------+
| [[Asy                | an execution context | The execution        |
| ncGeneratorContext]] |                      | context that is used |
|                      |                      | when executing the   |
|                      |                      | code of this async   |
|                      |                      | generator.           |
+----------------------+----------------------+----------------------+
| [[A                  | a List of            | Records which        |
| syncGeneratorQueue]] | A                    | represent requests   |
|                      | syncGeneratorRequest | to resume the async  |
|                      | Records              | generator. Except    |
|                      |                      | during state         |
|                      |                      | transitions, it is   |
|                      |                      | non-empty if and     |
|                      |                      | only if              |
|                      |                      | [[A                  |
|                      |                      | syncGeneratorState]] |
|                      |                      | is either            |
|                      |                      | ~executing~ or       |
|                      |                      | ~draining-queue~.    |
+----------------------+----------------------+----------------------+
| [[GeneratorBrand]]   | a String or ~empty~  | A brand used to      |
|                      |                      | distinguish          |
|                      |                      | different kinds of   |
|                      |                      | async generators.    |
|                      |                      | The                  |
|                      |                      | [[GeneratorBrand]]   |
|                      |                      | of async generators  |
|                      |                      | declared by          |
|                      |                      | ECMAScript source    |
|                      |                      | text is always       |
|                      |                      | ~empty~.             |
+----------------------+----------------------+----------------------+

AsyncGenerator Abstract Operations
----------------------------------

AsyncGeneratorRequest Records
-----------------------------

An AsyncGeneratorRequest is a Record value used to store information
about how an async generator should be resumed and contains capabilities
for fulfilling or rejecting the corresponding promise.

They have the following fields:

+----------------+-------------------------+-------------------------+
| Field Name     | Value                   | Meaning                 |
+================+=========================+=========================+
| [[Completion]] | a Completion Record     | The Completion Record   |
|                |                         | which should be used to |
|                |                         | resume the async        |
|                |                         | generator.              |
+----------------+-------------------------+-------------------------+
| [[Capability]] | a PromiseCapability     | The promise             |
|                | Record                  | capabilities associated |
|                |                         | with this request.      |
+----------------+-------------------------+-------------------------+

AsyncGeneratorStart ( generator: an AsyncGenerator, generatorBody: a `FunctionBody` Parse Node or an Abstract Closure with no parameters, ): ~unused~
---------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: generator.[[AsyncGeneratorState]] is ~suspended-start~.
1. Let genContext be the running execution context. 1. Set the
Generator component of genContext to generator. 1. Let
closure be a new Abstract Closure with no parameters that captures
generatorBody and performs the following steps when called: 1. Let
acGenContext be the running execution context. 1. Let
acGenerator be the Generator component of acGenContext. 1. If
generatorBody is a Parse Node, then 1. Let result be
Completion(Evaluation of generatorBody). 1. Else, 1. Assert:
generatorBody is an Abstract Closure with no parameters. 1. Let
result be Completion(generatorBody()). 1. Assert: If we return
here, the async generator either threw an exception or performed either
an implicit or explicit return. 1. Remove acGenContext from the
execution context stack and restore the execution context that is at the
top of the execution context stack as the running execution context. 1.
Set acGenerator.[[AsyncGeneratorState]] to ~draining-queue~. 1. If
result is a normal completion, set result to
NormalCompletion(`undefined`). 1. If result is a return
completion, set result to NormalCompletion(result.[[Value]]). 1.
Perform AsyncGeneratorCompleteStep(acGenerator, result,
`true`). 1. Perform AsyncGeneratorDrainQueue(acGenerator). 1.
Return `undefined`. 1. Set the code evaluation state of genContext
such that when evaluation is resumed for that execution context,
closure will be called with no arguments. 1. Set
generator.[[AsyncGeneratorContext]] to genContext. 1. Set
generator.[[AsyncGeneratorQueue]] to a new empty List. 1. Return
~unused~.

AsyncGeneratorValidate ( generator, generatorBrand: a String or ~empty~, )
--------------------------------------------------------------------------

1. Perform ? RequireInternalSlot(generator,
[[AsyncGeneratorContext]]). 1. Perform ?
RequireInternalSlot(generator, [[AsyncGeneratorState]]). 1. Perform
? RequireInternalSlot(generator, [[AsyncGeneratorQueue]]). 1. If
generator.[[GeneratorBrand]] is not generatorBrand, throw a
`TypeError` exception. 1. Return ~unused~.

AsyncGeneratorEnqueue ( generator: an AsyncGenerator, completion: a Completion Record, promiseCapability: a PromiseCapability Record, ): ~unused~
-------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let request be AsyncGeneratorRequest { [[Completion]]:
completion, [[Capability]]: promiseCapability }. 1. Append
request to generator.[[AsyncGeneratorQueue]]. 1. Return
~unused~.

AsyncGeneratorCompleteStep ( generator: an AsyncGenerator, completion: a Completion Record, done: a Boolean, optional realm: a Realm Record, ): ~unused~
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Assert: generator.[[AsyncGeneratorQueue]] is not empty. 1. Let
next be the first element of generator.[[AsyncGeneratorQueue]].
1. Remove the first element from generator.[[AsyncGeneratorQueue]].
1. Let promiseCapability be next.[[Capability]]. 1. Let
value be completion.[[Value]]. 1. If completion is a throw
completion, then 1. Perform ! Call(promiseCapability.[[Reject]],
`undefined`, « value »). 1. Else, 1. Assert: completion is a
normal completion. 1. If realm is present, then 1. Let oldRealm
be the running execution context's Realm. 1. Set the running execution
context's Realm to realm. 1. Let iteratorResult be
CreateIteratorResultObject(value, done). 1. Set the running
execution context's Realm to oldRealm. 1. Else, 1. Let
iteratorResult be CreateIteratorResultObject(value, done).
1. Perform ! Call(promiseCapability.[[Resolve]], `undefined`, «
iteratorResult »). 1. Return ~unused~.

AsyncGeneratorResume ( generator: an AsyncGenerator, completion: a Completion Record, ): ~unused~
---------------------------------------------------------------------------------------------------------

1. Assert: generator.[[AsyncGeneratorState]] is either
~suspended-start~ or ~suspended-yield~. 1. Let genContext be
generator.[[AsyncGeneratorContext]]. 1. Let callerContext be the
running execution context. 1. Suspend callerContext. 1. Set
generator.[[AsyncGeneratorState]] to ~executing~. 1. Push
genContext onto the execution context stack; genContext is now
the running execution context. 1. Resume the suspended evaluation of
genContext using completion as the result of the operation that
suspended it. Let result be the Completion Record returned by the
resumed computation. 1. Assert: result is never an abrupt
completion. 1. Assert: When we return here, genContext has already
been removed from the execution context stack and callerContext is
the currently running execution context. 1. Return ~unused~.

AsyncGeneratorUnwrapYieldResumption ( resumptionValue: a Completion Record, )
-----------------------------------------------------------------------------

1. If resumptionValue is not a return completion, return ?
resumptionValue. 1. Let awaited be
Completion(Await(resumptionValue.[[Value]])). 1. If awaited is a
throw completion, return ? awaited. 1. Assert: awaited is a
normal completion. 1. Return ReturnCompletion(awaited.[[Value]]).

AsyncGeneratorYield ( value, )
------------------------------

1. Let genContext be the running execution context. 1. Assert:
genContext is the execution context of a generator. 1. Let
generator be the value of the Generator component of genContext.
1. Assert: GetGeneratorKind() is ~async~. 1. Let completion be
NormalCompletion(value). 1. Assert: The execution context stack has
at least two elements. 1. Let previousContext be the second to top
element of the execution context stack. 1. Let previousRealm be
previousContext's Realm. 1. Perform
AsyncGeneratorCompleteStep(generator, completion, `false`,
previousRealm). 1. Let queue be
generator.[[AsyncGeneratorQueue]]. 1. If queue is not empty,
then 1. NOTE: Execution continues without suspending the generator. 1.
Let toYield be the first element of queue. 1. Let
resumptionValue be Completion(toYield.[[Completion]]). 1. Return
? AsyncGeneratorUnwrapYieldResumption(resumptionValue). 1. Else, 1.
Set generator.[[AsyncGeneratorState]] to ~suspended-yield~. 1.
Remove genContext from the execution context stack and restore the
execution context that is at the top of the execution context stack as
the running execution context. 1. Let callerContext be the running
execution context. 1. Resume callerContext passing `undefined`. If
genContext is ever resumed again, let resumptionValue be the
Completion Record with which it is resumed. 1. Assert: If control
reaches here, then genContext is the running execution context
again. 1. Return ?
AsyncGeneratorUnwrapYieldResumption(resumptionValue).

AsyncGeneratorAwaitReturn ( generator: an AsyncGenerator, ): ~unused~
-------------------------------------------------------------------------

1. Assert: generator.[[AsyncGeneratorState]] is ~draining-queue~. 1.
Let queue be generator.[[AsyncGeneratorQueue]]. 1. Assert:
queue is not empty. 1. Let next be the first element of
queue. 1. Let completion be Completion(next.[[Completion]]).
1. Assert: completion is a return completion. 1. Let
promiseCompletion be Completion(PromiseResolve(%Promise%,
completion.[[Value]])). 1. If promiseCompletion is an abrupt
completion, then 1. Perform AsyncGeneratorCompleteStep(generator,
promiseCompletion, `true`). 1. Perform
AsyncGeneratorDrainQueue(generator). 1. Return ~unused~. 1. Assert:
promiseCompletion is a normal completion. 1. Let promise be
promiseCompletion.[[Value]]. 1. Let fulfilledClosure be a new
Abstract Closure with parameters (value) that captures generator
and performs the following steps when called: 1. Assert:
generator.[[AsyncGeneratorState]] is ~draining-queue~. 1. Let
result be NormalCompletion(value). 1. Perform
AsyncGeneratorCompleteStep(generator, result, `true`). 1.
Perform AsyncGeneratorDrainQueue(generator). 1. Return
`undefined`. 1. Let onFulfilled be
CreateBuiltinFunction(fulfilledClosure, 1, `""`, « »). 1. Let
rejectedClosure be a new Abstract Closure with parameters
(reason) that captures generator and performs the following
steps when called: 1. Assert: generator.[[AsyncGeneratorState]] is
~draining-queue~. 1. Let result be ThrowCompletion(reason). 1.
Perform AsyncGeneratorCompleteStep(generator, result, `true`).
1. Perform AsyncGeneratorDrainQueue(generator). 1. Return
`undefined`. 1. Let onRejected be
CreateBuiltinFunction(rejectedClosure, 1, `""`, « »). 1. Perform
PerformPromiseThen(promise, onFulfilled, onRejected). 1.
Return ~unused~.

AsyncGeneratorDrainQueue ( generator: an AsyncGenerator, ): ~unused~
------------------------------------------------------------------------

description
   It drains the generator's AsyncGeneratorQueue until it encounters an
   AsyncGeneratorRequest which holds a return completion.

1. Assert: generator.[[AsyncGeneratorState]] is ~draining-queue~. 1.
Let queue be generator.[[AsyncGeneratorQueue]]. 1. If queue
is empty, then 1. Set generator.[[AsyncGeneratorState]] to
~completed~. 1. Return ~unused~. 1. Let done be `false`. 1.
Repeat, while done is `false`, 1. Let next be the first
element of queue. 1. Let completion be
Completion(next.[[Completion]]). 1. If completion is a return
completion, then 1. Perform AsyncGeneratorAwaitReturn(generator). 1.
Set done to `true`. 1. Else, 1. If completion is a normal
completion, then 1. Set completion to
NormalCompletion(`undefined`). 1. Perform
AsyncGeneratorCompleteStep(generator, completion, `true`). 1.
If queue is empty, then 1. Set generator.[[AsyncGeneratorState]]
to ~completed~. 1. Set done to `true`. 1. Return ~unused~.

CreateAsyncIteratorFromClosure ( closure: an Abstract Closure with no parameters, generatorBrand: a String or ~empty~, generatorPrototype: an Object, ): an AsyncGenerator
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. NOTE: closure can contain uses of the Await operation and uses of
the Yield operation to yield an IteratorResult object. 1. Let
internalSlotsList be « [[AsyncGeneratorState]],
[[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]]
». 1. Let generator be OrdinaryObjectCreate(generatorPrototype,
internalSlotsList). 1. Set generator.[[GeneratorBrand]] to
generatorBrand. 1. Set generator.[[AsyncGeneratorState]] to
`undefined`. 1. Let callerContext be the running execution
context. 1. Let calleeContext be a new execution context. 1. Set the
Function of calleeContext to `null`. 1. Set the Realm of
calleeContext to the current Realm Record. 1. Set the ScriptOrModule
of calleeContext to callerContext's ScriptOrModule. 1. If
callerContext is not already suspended, suspend callerContext.
1. Push calleeContext onto the execution context stack;
calleeContext is now the running execution context. 1. Perform
AsyncGeneratorStart(generator, closure). 1. Remove
calleeContext from the execution context stack and restore
callerContext as the running execution context. 1. Return
generator.

AsyncFunction Objects
---------------------

AsyncFunctions are functions that are usually created by evaluating
\|AsyncFunctionDeclaration|s, \|AsyncFunctionExpression|s,
\|AsyncMethod|s, and \|AsyncArrowFunction|s. They may also be created by
calling the %AsyncFunction% intrinsic.

The AsyncFunction Constructor
-----------------------------

The AsyncFunction constructor:

- is %AsyncFunction%.
- is a subclass of `Function`.
- creates and initializes a new AsyncFunction when called as a function
  rather than as a constructor. Thus the function call
  `AsyncFunction(…)` is equivalent to the object creation expression
  `new AsyncFunction(…)` with the same arguments.
- may be used as the value of an `extends` clause of a class
  definition. Subclass constructors that intend to inherit the specified
  AsyncFunction behaviour must include a `super` call to the
  AsyncFunction constructor to create and initialize a subclass instance
  with the internal slots necessary for built-in async function
  behaviour. All ECMAScript syntactic forms for defining async function
  objects create direct instances of AsyncFunction. There is no
  syntactic means to create instances of AsyncFunction subclasses.

AsyncFunction ( ..._parameterArgs, bodyArg )
--------------------------------------------------

The last argument (if any) specifies the body (executable code) of an
async function. Any preceding arguments specify formal parameters.

This function performs the following steps when called:

1. Let C be the active function object. 1. If bodyArg is not
present, set bodyArg to the empty String. 1. Return ?
CreateDynamicFunction(C, NewTarget, ~async~, parameterArgs,
bodyArg). See NOTE for .

Properties of the AsyncFunction Constructor
-------------------------------------------

The AsyncFunction constructor:

- is a standard built-in function object that inherits from the Function
  constructor.
- has a [[Prototype]] internal slot whose value is %Function%.
- has a `"length"` property whose value is `1`\ :sub:`𝔽`.
- has a `"name"` property whose value is `"AsyncFunction"`.
- has the following properties:

AsyncFunction.prototype
-----------------------

The initial value of `AsyncFunction.prototype` is the AsyncFunction
prototype object.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

Properties of the AsyncFunction Prototype Object
------------------------------------------------

The AsyncFunction prototype object:

- is %AsyncFunction.prototype%.
- is an ordinary object.
- is not a function object and does not have an [[ECMAScriptCode]]
  internal slot or any other of the internal slots listed in .
- has a [[Prototype]] internal slot whose value is %Function.prototype%.

AsyncFunction.prototype.constructor
-----------------------------------

The initial value of `AsyncFunction.prototype.constructor` is
%AsyncFunction%.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

AsyncFunction.prototype [ %Symbol.toStringTag% ]
------------------------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"AsyncFunction"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

AsyncFunction Instances
-----------------------

Every AsyncFunction instance is an ECMAScript function object and has
the internal slots listed in . The value of the [[IsClassConstructor]]
internal slot for all such instances is `false`. AsyncFunction
instances are not constructors and do not have a [[Construct]] internal
method. AsyncFunction instances do not have a prototype property as they
are not constructable.

Each AsyncFunction instance has the following own properties:

.. _length-5:

length
------

The specification for the `"length"` property of Function instances
given in also applies to AsyncFunction instances.

.. _name-3:

name
----

The specification for the `"name"` property of Function instances
given in also applies to AsyncFunction instances.

Async Functions Abstract Operations
-----------------------------------

AsyncFunctionStart ( promiseCapability: a PromiseCapability Record, asyncFunctionBody: a `FunctionBody` Parse Node, an `ExpressionBody` Parse Node, or an Abstract Closure with no parameters, ): ~unused~
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let runningContext be the running execution context. 1. Let
asyncContext be a copy of runningContext. 1. NOTE: Copying the
execution state is required for AsyncBlockStart to resume its execution.
It is ill-defined to resume a currently executing context. 1. Perform
AsyncBlockStart(promiseCapability, asyncFunctionBody,
asyncContext). 1. Return ~unused~.

AsyncBlockStart ( promiseCapability: a PromiseCapability Record, asyncBody: a Parse Node or an Abstract Closure with no parameters, asyncContext: an execution context, ): ~unused~
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let runningContext be the running execution context. 1. Let
closure be a new Abstract Closure with no parameters that captures
promiseCapability and asyncBody and performs the following steps
when called: 1. Let acAsyncContext be the running execution context.
1. If asyncBody is a Parse Node, then 1. Let result be
Completion(Evaluation of asyncBody). 1. Else, 1. Assert:
asyncBody is an Abstract Closure with no parameters. 1. Let
result be asyncBody(). 1. Assert: If we return here, the async
function either threw an exception or performed an implicit or explicit
return; all awaiting is done. 1. Remove acAsyncContext from the
execution context stack and restore the execution context that is at the
top of the execution context stack as the running execution context. 1.
If result is a normal completion, then 1. Perform !
Call(promiseCapability.[[Resolve]], `undefined`, « `undefined`
»). 1. Else if result is a return completion, then 1. Perform !
Call(promiseCapability.[[Resolve]], `undefined`, «
result.[[Value]] »). 1. Else, 1. Assert: result is a throw
completion. 1. Perform ! Call(promiseCapability.[[Reject]],
`undefined`, « result.[[Value]] »). 1.
[id="step-asyncblockstart-return-undefined"] Return ~unused~. 1. Set the
code evaluation state of asyncContext such that when evaluation is
resumed for that execution context, closure will be called with no
arguments. 1. Push asyncContext onto the execution context stack;
asyncContext is now the running execution context. 1. Resume the
suspended evaluation of asyncContext. Let result be the value
returned by the resumed computation. 1. Assert: When we return here,
asyncContext has already been removed from the execution context
stack and runningContext is the currently running execution context.
1. Assert: result is a normal completion with a value of ~unused~.
The possible sources of this value are Await or, if the async function
doesn't await anything, step above. 1. Return ~unused~.

Await ( value, )
----------------

1. Let asyncContext be the running execution context. 1. Let
promise be ? PromiseResolve(%Promise%, value). 1. Let
fulfilledClosure be a new Abstract Closure with parameters (v)
that captures asyncContext and performs the following steps when
called: 1. Let prevContext be the running execution context. 1.
Suspend prevContext. 1. Push asyncContext onto the execution
context stack; asyncContext is now the running execution context. 1.
Resume the suspended evaluation of asyncContext using
NormalCompletion(v) as the result of the operation that suspended
it. 1. Assert: When we reach this step, asyncContext has already
been removed from the execution context stack and prevContext is the
currently running execution context. 1. Return `undefined`. 1. Let
onFulfilled be CreateBuiltinFunction(fulfilledClosure, 1,
`""`, « »). 1. Let rejectedClosure be a new Abstract Closure with
parameters (reason) that captures asyncContext and performs the
following steps when called: 1. Let prevContext be the running
execution context. 1. Suspend prevContext. 1. Push asyncContext
onto the execution context stack; asyncContext is now the running
execution context. 1. Resume the suspended evaluation of
asyncContext using ThrowCompletion(reason) as the result of the
operation that suspended it. 1. Assert: When we reach this step,
asyncContext has already been removed from the execution context
stack and prevContext is the currently running execution context. 1.
Return `undefined`. 1. Let onRejected be
CreateBuiltinFunction(rejectedClosure, 1, `""`, « »). 1. Perform
PerformPromiseThen(promise, onFulfilled, onRejected). 1.
Remove asyncContext from the execution context stack and restore the
execution context that is at the top of the execution context stack as
the running execution context. 1. Let callerContext be the running
execution context. 1. Resume callerContext passing ~empty~. If
asyncContext is ever resumed again, let completion be the
Completion Record with which it is resumed. 1. Assert: If control
reaches here, then asyncContext is the running execution context
again. 1. Return completion.

28. Reflection
==============

https://tc39.es/ecma262/multipage/reflection.html
::

    28.1 The Reflect Object
        28.1.1 Reflect.apply ( target, thisArgument, argumentsList )
        28.1.2 Reflect.construct ( target, argumentsList [ , newTarget ] )
        28.1.3 Reflect.defineProperty ( target, propertyKey, attributes )
        28.1.4 Reflect.deleteProperty ( target, propertyKey )
        28.1.5 Reflect.get ( target, propertyKey [ , receiver ] )
        28.1.6 Reflect.getOwnPropertyDescriptor ( target, propertyKey )
        28.1.7 Reflect.getPrototypeOf ( target )
        28.1.8 Reflect.has ( target, propertyKey )
        28.1.9 Reflect.isExtensible ( target )
        28.1.10 Reflect.ownKeys ( target )
        28.1.11 Reflect.preventExtensions ( target )
        28.1.12 Reflect.set ( target, propertyKey, V [ , receiver ] )
        28.1.13 Reflect.setPrototypeOf ( target, proto )
        28.1.14 Reflect [ %Symbol.toStringTag% ]
    28.2 Proxy Objects
        28.2.1 The Proxy Constructor
            28.2.1.1 Proxy ( target, handler )
        28.2.2 Properties of the Proxy Constructor
            28.2.2.1 Proxy.revocable ( target, handler )
    28.3 Module Namespace Objects
        28.3.1 %Symbol.toStringTag%


The Reflect Object
------------------

The Reflect object:

- is %Reflect%.
- is the initial value of the `"Reflect"` property of the global
  object.
- is an ordinary object.
- has a [[Prototype]] internal slot whose value is %Object.prototype%.
- is not a function object.
- does not have a [[Construct]] internal method; it cannot be used as a
  constructor with the `new` operator.
- does not have a [[Call]] internal method; it cannot be invoked as a
  function.

Reflect.apply ( target, thisArgument, argumentsList )
-----------------------------------------------------------------

This function performs the following steps when called:

1. If IsCallable(target) is `false`, throw a `TypeError`
exception. 1. Let args be ?
CreateListFromArrayLike(argumentsList). 1. Perform
PrepareForTailCall(). 1. Return ? Call(target, thisArgument,
args).

Reflect.construct ( target, argumentsList [ , newTarget ] )
-----------------------------------------------------------------------

This function performs the following steps when called:

1. If IsConstructor(target) is `false`, throw a `TypeError`
exception. 1. If newTarget is not present, set newTarget to
target. 1. Else if IsConstructor(newTarget) is `false`, throw
a `TypeError` exception. 1. Let args be ?
CreateListFromArrayLike(argumentsList). 1. Return ?
Construct(target, args, newTarget).

Reflect.defineProperty ( target, propertyKey, attributes )
----------------------------------------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Let key be ? ToPropertyKey(propertyKey). 1. Let desc be ?
ToPropertyDescriptor(attributes). 1. Return ?
target.[[DefineOwnProperty]](key, desc).

Reflect.deleteProperty ( target, propertyKey )
------------------------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Let key be ? ToPropertyKey(propertyKey). 1. Return ?
target.[[Delete]](key).

Reflect.get ( target, propertyKey [ , receiver ] )
--------------------------------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Let key be ? ToPropertyKey(propertyKey). 1. If receiver is
not present, then 1. Set receiver to target. 1. Return ?
target.[[Get]](key, receiver).

Reflect.getOwnPropertyDescriptor ( target, propertyKey )
----------------------------------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Let key be ? ToPropertyKey(propertyKey). 1. Let desc be ?
target.[[GetOwnProperty]](key). 1. Return
FromPropertyDescriptor(desc).

Reflect.getPrototypeOf ( target )
-------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Return ? target.[[GetPrototypeOf]]().

Reflect.has ( target, propertyKey )
-------------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Let key be ? ToPropertyKey(propertyKey). 1. Return ?
target.[[HasProperty]](key).

Reflect.isExtensible ( target )
-----------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Return ? target.[[IsExtensible]]().

Reflect.ownKeys ( target )
------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Let keys be ? target.[[OwnPropertyKeys]](). 1. Return
CreateArrayFromList(keys).

Reflect.preventExtensions ( target )
----------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Return ? target.[[PreventExtensions]]().

Reflect.set ( target, propertyKey, V [ , receiver ] )
---------------------------------------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
Let key be ? ToPropertyKey(propertyKey). 1. If receiver is
not present, then 1. Set receiver to target. 1. Return ?
target.[[Set]](key, V, receiver).

Reflect.setPrototypeOf ( target, proto )
------------------------------------------------

This function performs the following steps when called:

1. If target is not an Object, throw a `TypeError` exception. 1.
If proto is not an Object and proto is not `null`, throw a
`TypeError` exception. 1. Return ?
target.[[SetPrototypeOf]](proto).

Reflect [ %Symbol.toStringTag% ]
--------------------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Reflect"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `true` }.

Proxy Objects
-------------

The Proxy Constructor
---------------------

The Proxy constructor:

- is %Proxy%.
- is the initial value of the `"Proxy"` property of the global object.
- creates and initializes a new Proxy object when called as a
  constructor.
- is not intended to be called as a function and will throw an exception
  when called in that manner.

Proxy ( target, handler )
---------------------------------

This function performs the following steps when called:

1. If NewTarget is `undefined`, throw a `TypeError` exception. 1.
Return ? ProxyCreate(target, handler).

Properties of the Proxy Constructor
-----------------------------------

The Proxy constructor:

- has a [[Prototype]] internal slot whose value is %Function.prototype%.
- does not have a `"prototype"` property because Proxy objects do not
  have a [[Prototype]] internal slot that requires initialization.
- has the following properties:

Proxy.revocable ( target, handler )
-------------------------------------------

This function creates a revocable Proxy object.

It performs the following steps when called:

1. Let proxy be ? ProxyCreate(target, handler). 1. Let
revokerClosure be a new Abstract Closure with no parameters that
captures nothing and performs the following steps when called: 1. Let
F be the active function object. 1. Let p be
F.[[RevocableProxy]]. 1. If p is `null`, return `undefined`.
1. Set F.[[RevocableProxy]] to `null`. 1. Assert: p is a Proxy
exotic object. 1. Set p.[[ProxyTarget]] to `null`. 1. Set
p.[[ProxyHandler]] to `null`. 1. Return `undefined`. 1. Let
revoker be CreateBuiltinFunction(revokerClosure, 0, `""`, «
[[RevocableProxy]] »). 1. Set revoker.[[RevocableProxy]] to
proxy. 1. Let result be
OrdinaryObjectCreate(%Object.prototype%). 1. Perform !
CreateDataPropertyOrThrow(result, `"proxy"`, proxy). 1.
Perform ! CreateDataPropertyOrThrow(result, `"revoke"`,
revoker). 1. Return result.

Module Namespace Objects
------------------------

A Module Namespace Object is a module namespace exotic object that
provides runtime property-based access to a module's exported bindings.
There is no constructor function for Module Namespace Objects. Instead,
such an object is created for each module that is imported by an
`ImportDeclaration` that contains a `NameSpaceImport`.

In addition to the properties specified in each Module Namespace Object
has the following own property:

.. _symbol.tostringtag-1:

%Symbol.toStringTag%
--------------------

The initial value of the %Symbol.toStringTag% property is the String
value `"Module"`.

This property has the attributes { [[Writable]]: `false`,
[[Enumerable]]: `false`, [[Configurable]]: `false` }.

29. Memory Model
================

https://tc39.es/ecma262/multipage/memory-model.html
::

    29.1 Memory Model Fundamentals
    29.2 Agent Events Records
    29.3 Chosen Value Records
    29.4 Candidate Executions
    29.5 Abstract Operations for the Memory Model
        29.5.1 EventSet ( execution )
        29.5.2 SharedDataBlockEventSet ( execution )
        29.5.3 HostEventSet ( execution )
        29.5.4 ComposeWriteEventBytes ( execution, byteIndex, Ws )
        29.5.5 ValueOfReadEvent ( execution, R )
    29.6 Relations of Candidate Executions
        29.6.1 is-agent-order-before
        29.6.2 reads-bytes-from
        29.6.3 reads-from
        29.6.4 host-synchronizes-with
        29.6.5 synchronizes-with
        29.6.6 happens-before
    29.7 Properties of Valid Executions
        29.7.1 Valid Chosen Reads
        29.7.2 Coherent Reads
        29.7.3 Tear Free Reads
        29.7.4 Sequentially Consistent Atomics
        29.7.5 Valid Executions
    29.8 Races
    29.9 Data Races
    29.10 Data Race Freedom
    29.11 Shared Memory Guidelines


The memory consistency model, or memory model, specifies the possible
orderings of Shared Data Block events, arising via accessing TypedArray
instances backed by a SharedArrayBuffer and via methods on the Atomics
object. When the program has no data races (defined below), the ordering
of events appears as sequentially consistent, i.e., as an interleaving
of actions from each agent. When the program has data races, shared
memory operations may appear sequentially inconsistent. For example,
programs may exhibit causality-violating behaviour and other
astonishments. These astonishments arise from compiler transforms and
the design of CPUs (e.g., out-of-order execution and speculation). The
memory model defines both the precise conditions under which a program
exhibits sequentially consistent behaviour as well as the possible
values read from data races. To wit, there is no undefined behaviour.

The memory model is defined as relational constraints on events
introduced by abstract operations on SharedArrayBuffer or by methods on
the Atomics object during an evaluation.

This section provides an axiomatic model on events introduced by the
abstract operations on SharedArrayBuffers. It bears stressing that the
model is not expressible algorithmically, unlike the rest of this
specification. The nondeterministic introduction of events by abstract
operations is the interface between the operational semantics of
ECMAScript evaluation and the axiomatic semantics of the memory model.
The semantics of these events is defined by considering graphs of all
events in an evaluation. These are neither Static Semantics nor Runtime
Semantics. There is no demonstrated algorithmic implementation, but
instead a set of constraints that determine if a particular event graph
is allowed or disallowed.

Memory Model Fundamentals
-------------------------

Shared memory accesses (reads and writes) are divided into two groups,
atomic accesses and data accesses, defined below. Atomic accesses are
sequentially consistent, i.e., there is a strict total ordering of
events agreed upon by all agents in an agent cluster. Non-atomic
accesses do not have a strict total ordering agreed upon by all agents,
i.e., unordered.

No orderings weaker than sequentially consistent and stronger than
unordered, such as release-acquire, are supported.

A Shared Data Block event is either a ReadSharedMemory,
WriteSharedMemory, or ReadModifyWriteSharedMemory Record.

+-----------------+------------------------+------------------------+
| Field Name      | Value                  | Meaning                |
+=================+========================+========================+
| [[Order]]       | ~seq-cst~ or           | The weakest ordering   |
|                 | ~unordered~            | guaranteed by the      |
|                 |                        | memory model for the   |
|                 |                        | event.                 |
+-----------------+------------------------+------------------------+
| [[NoTear]]      | a Boolean              | Whether this event is  |
|                 |                        | allowed to read from   |
|                 |                        | multiple write events  |
|                 |                        | with equal range as    |
|                 |                        | this event.            |
+-----------------+------------------------+------------------------+
| [[Block]]       | a Shared Data Block    | The block the event    |
|                 |                        | operates on.           |
+-----------------+------------------------+------------------------+
| [[ByteIndex]]   | a non-negative integer | The byte address of    |
|                 |                        | the read in [[Block]]. |
+-----------------+------------------------+------------------------+
| [[ElementSize]] | a non-negative integer | The size of the read.  |
+-----------------+------------------------+------------------------+

+-----------------+------------------------+------------------------+
| Field Name      | Value                  | Meaning                |
+=================+========================+========================+
| [[Order]]       | ~seq-cst~,             | The weakest ordering   |
|                 | ~unordered~, or ~init~ | guaranteed by the      |
|                 |                        | memory model for the   |
|                 |                        | event.                 |
+-----------------+------------------------+------------------------+
| [[NoTear]]      | a Boolean              | Whether this event is  |
|                 |                        | allowed to be read     |
|                 |                        | from multiple read     |
|                 |                        | events with equal      |
|                 |                        | range as this event.   |
+-----------------+------------------------+------------------------+
| [[Block]]       | a Shared Data Block    | The block the event    |
|                 |                        | operates on.           |
+-----------------+------------------------+------------------------+
| [[ByteIndex]]   | a non-negative integer | The byte address of    |
|                 |                        | the write in           |
|                 |                        | [[Block]].             |
+-----------------+------------------------+------------------------+
| [[ElementSize]] | a non-negative integer | The size of the write. |
+-----------------+------------------------+------------------------+
| [[Payload]]     | a List of byte values  | The List of byte       |
|                 |                        | values to be read by   |
|                 |                        | other events.          |
+-----------------+------------------------+------------------------+

+-----------------+------------------------+------------------------+
| Field Name      | Value                  | Meaning                |
+=================+========================+========================+
| [[Order]]       | ~seq-cst~              | Read-modify-write      |
|                 |                        | events are always      |
|                 |                        | sequentially           |
|                 |                        | consistent.            |
+-----------------+------------------------+------------------------+
| [[NoTear]]      | `true`               | Read-modify-write      |
|                 |                        | events cannot tear.    |
+-----------------+------------------------+------------------------+
| [[Block]]       | a Shared Data Block    | The block the event    |
|                 |                        | operates on.           |
+-----------------+------------------------+------------------------+
| [[ByteIndex]]   | a non-negative integer | The byte address of    |
|                 |                        | the read-modify-write  |
|                 |                        | in [[Block]].          |
+-----------------+------------------------+------------------------+
| [[ElementSize]] | a non-negative integer | The size of the        |
|                 |                        | read-modify-write.     |
+-----------------+------------------------+------------------------+
| [[Payload]]     | a List of byte values  | The List of byte       |
|                 |                        | values to be passed to |
|                 |                        | [[ModifyOp]].          |
+-----------------+------------------------+------------------------+
| [[ModifyOp]]    | a read-modify-write    | An abstract closure    |
|                 | modification function  | that returns a         |
|                 |                        | modified List of byte  |
|                 |                        | values from a read     |
|                 |                        | List of byte values    |
|                 |                        | and [[Payload]].       |
+-----------------+------------------------+------------------------+

These events are introduced by abstract operations or by methods on the
Atomics object.

Some operations may also introduce Synchronize events. A Synchronize
event has no fields, and exists purely to directly constrain the
permitted orderings of other events.

In addition to Shared Data Block and Synchronize events, there are
host-specific events.

Let the range of a ReadSharedMemory, WriteSharedMemory, or
ReadModifyWriteSharedMemory event be the Set of contiguous integers from
its [[ByteIndex]] to [[ByteIndex]] + [[ElementSize]] - 1. Two events'
ranges are equal when the events have the same [[Block]], and the ranges
are element-wise equal. Two events' ranges are overlapping when the
events have the same [[Block]], the ranges are not equal and their
intersection is non-empty. Two events' ranges are disjoint when the
events do not have the same [[Block]] or their ranges are neither equal
nor overlapping.

Examples of host-specific synchronizing events that should be accounted
for are: sending a SharedArrayBuffer from one agent to another (e.g., by
`postMessage` in a browser), starting and stopping agents, and
communicating within the agent cluster via channels other than shared
memory. For a particular execution execution, those events are
provided by the host via the host-synchronizes-with strict partial
order. Additionally, hosts can add host-specific synchronizing events to
execution.[[EventList]] so as to participate in the
is-agent-order-before Relation.

Events are ordered within candidate executions by the relations defined
below.

Agent Events Records
--------------------

An Agent Events Record is a Record with the following fields.

+----------------------+----------------------+----------------------+
| Field Name           | Value                | Meaning              |
+======================+======================+======================+
| [[AgentSignifier]]   | an agent signifier   | The agent whose      |
|                      |                      | evaluation resulted  |
|                      |                      | in this ordering.    |
+----------------------+----------------------+----------------------+
| [[EventList]]        | a List of events     | Events are appended  |
|                      |                      | to the list during   |
|                      |                      | evaluation.          |
+----------------------+----------------------+----------------------+
| [[Age                | a List of pairs of   | Synchronize          |
| ntSynchronizesWith]] | Synchronize events   | relationships        |
|                      |                      | introduced by the    |
|                      |                      | operational          |
|                      |                      | semantics.           |
+----------------------+----------------------+----------------------+

Chosen Value Records
--------------------

A Chosen Value Record is a Record with the following fields.

+-----------------+------------------------+------------------------+
| Field Name      | Value                  | Meaning                |
+=================+========================+========================+
| [[Event]]       | a Shared Data Block    | The ReadSharedMemory   |
|                 | event                  | or                     |
|                 |                        | ReadM                  |
|                 |                        | odifyWriteSharedMemory |
|                 |                        | event that was         |
|                 |                        | introduced for this    |
|                 |                        | chosen value.          |
+-----------------+------------------------+------------------------+
| [[ChosenValue]] | a List of byte values  | The bytes that were    |
|                 |                        | nondeterministically   |
|                 |                        | chosen during          |
|                 |                        | evaluation.            |
+-----------------+------------------------+------------------------+

Candidate Executions
--------------------

A candidate execution of the evaluation of an agent cluster is a Record
with the following fields.

+-------------------+-----------------------+-----------------------+
| Field Name        | Value                 | Meaning               |
+===================+=======================+=======================+
| [[EventsRecords]] | a List of Agent       | Maps an agent to      |
|                   | Events Records        | Lists of events       |
|                   |                       | appended during the   |
|                   |                       | evaluation.           |
+-------------------+-----------------------+-----------------------+
| [[ChosenValues]]  | a List of Chosen      | Maps ReadSharedMemory |
|                   | Value Records         | or                    |
|                   |                       | ReadMo                |
|                   |                       | difyWriteSharedMemory |
|                   |                       | events to the List of |
|                   |                       | byte values chosen    |
|                   |                       | during the            |
|                   |                       | evaluation.           |
+-------------------+-----------------------+-----------------------+

An empty candidate execution is a candidate execution Record whose
fields are empty Lists.

Abstract Operations for the Memory Model
----------------------------------------

EventSet ( execution: a candidate execution, ): a Set of events
-------------------------------------------------------------------

1. Let events be an empty Set. 1. For each Agent Events Record
aer of execution.[[EventsRecords]], do 1. For each event E
of aer.[[EventList]], do 1. Add E to events. 1. Return
events.

SharedDataBlockEventSet ( execution: a candidate execution, ): a Set of events
----------------------------------------------------------------------------------

1. Let events be an empty Set. 1. For each event E of
EventSet(execution), do 1. If E is a ReadSharedMemory,
WriteSharedMemory, or ReadModifyWriteSharedMemory event, add E to
events. 1. Return events.

HostEventSet ( execution: a candidate execution, ): a Set of events
-----------------------------------------------------------------------

1. Let events be an empty Set. 1. For each event E of
EventSet(execution), do 1. If E is not in
SharedDataBlockEventSet(execution), add E to events. 1.
Return events.

ComposeWriteEventBytes ( execution: a candidate execution, byteIndex: a non-negative integer, Ws: a List of either WriteSharedMemory or ReadModifyWriteSharedMemory events, ): a List of byte values
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Let byteLocation be byteIndex. 1. Let bytesRead be a new
empty List. 1. For each element W of Ws, do 1. Assert: W has
byteLocation in its range. 1. Let payloadIndex be
byteLocation - W.[[ByteIndex]]. 1. If W is a
WriteSharedMemory event, then 1. Let byte be
W.[[Payload]][payloadIndex]. 1. Else, 1. Assert: W is a
ReadModifyWriteSharedMemory event. 1. Let bytes be
ValueOfReadEvent(execution, W). 1. Let bytesModified be
W.[[ModifyOp]](bytes, W.[[Payload]]). 1. Let byte be
bytesModified[payloadIndex]. 1. Append byte to
bytesRead. 1. Set byteLocation to byteLocation + 1. 1.
Return bytesRead.

The read-modify-write modification [[ModifyOp]] is given by the function
properties on the Atomics object that introduce
ReadModifyWriteSharedMemory events.

This abstract operation composes a List of write events into a List of
byte values. It is used in the event semantics of ReadSharedMemory and
ReadModifyWriteSharedMemory events.

ValueOfReadEvent ( execution: a candidate execution, R: a ReadSharedMemory or ReadModifyWriteSharedMemory event, ): a List of byte values
-------------------------------------------------------------------------------------------------------------------------------------------------

1. Let Ws be reads-bytes-from(R) in execution. 1. Assert:
Ws is a List of WriteSharedMemory or ReadModifyWriteSharedMemory
events with length equal to R.[[ElementSize]]. 1. Return
ComposeWriteEventBytes(execution, R.[[ByteIndex]], Ws).

Relations of Candidate Executions
---------------------------------

The following relations and mathematical functions are parameterized
over a particular candidate execution and order its events.

is-agent-order-before
---------------------

For a candidate execution execution, its is-agent-order-before
Relation is the least Relation on events that satisfies the following.

- For events E and D, E is-agent-order-before D in
  execution if there is some Agent Events Record aer in
  execution.[[EventsRecords]] such that aer.[[EventList]]
  contains both E and D and E is before D in List order
  of aer.[[EventList]].

Each agent introduces events in a per-agent strict total order during
the evaluation. This is the union of those strict total orders.

reads-bytes-from
----------------

For a candidate execution execution, its *reads-bytes-from* function
is a mathematical function mapping events in
SharedDataBlockEventSet(execution) to Lists of events in
SharedDataBlockEventSet(execution) that satisfies the following
conditions.

- For each ReadSharedMemory or ReadModifyWriteSharedMemory event R
  in SharedDataBlockEventSet(execution), reads-bytes-from(R) in
  execution is a List of length R.[[ElementSize]] whose elements
  are WriteSharedMemory or ReadModifyWriteSharedMemory events Ws
  such that all of the following are true.

  - Each event W with index i in Ws has R.[[ByteIndex]]
    + i in its range.
  - R is not in Ws.

A candidate execution always admits a reads-bytes-from function.

reads-from
----------

For a candidate execution execution, its reads-from Relation is the
least Relation on events that satisfies the following.

- For events R and W, R reads-from W in execution if
  SharedDataBlockEventSet(execution) contains both R and W,
  and reads-bytes-from(R) in execution contains W.

host-synchronizes-with
----------------------

For a candidate execution execution, its host-synchronizes-with
Relation is a host-provided strict partial order on host-specific events
that satisfies at least the following.

- If E host-synchronizes-with D in execution,
  HostEventSet(execution) contains E and D.
- There is no cycle in the union of host-synchronizes-with and
  is-agent-order-before in execution.

For two host-specific events E and D in a candidate execution
execution, E host-synchronizes-with D in execution
implies E happens-before D in execution.

This Relation allows the host to provide additional synchronization
mechanisms, such as `postMessage` between HTML workers.

synchronizes-with
-----------------

For a candidate execution execution, its synchronizes-with Relation
is the least Relation on events that satisfies the following.

- For events R and W, W synchronizes-with R in
  execution if R reads-from W in execution,
  R.[[Order]] is ~seq-cst~, W.[[Order]] is ~seq-cst~, and R
  and W have equal ranges.
- For each element eventsRecord of execution.[[EventsRecords]],
  the following is true.

  - For events S and Sw, S synchronizes-with Sw in
    execution if eventsRecord.[[AgentSynchronizesWith]] contains
    (S, Sw).

- For events E and D, E synchronizes-with D in
  execution if execution.[[HostSynchronizesWith]] contains
  (E, D).

Owing to convention in memory model literature, in a candidate execution
execution, write events synchronizes-with read events, instead of
read events synchronizes-with write events.

In a candidate execution execution, ~init~ events do not participate
in this Relation and are instead constrained directly by happens-before.

In a candidate execution execution, not all ~seq-cst~ events related
by reads-from are related by synchronizes-with. Only events that also
have equal ranges are related by synchronizes-with.

For Shared Data Block events R and W in a candidate execution
execution such that W synchronizes-with R, R may
reads-from other writes than W.

happens-before
--------------

For a candidate execution execution, its happens-before Relation is
the least Relation on events that satisfies the following.

- For events E and D, E happens-before D in
  execution if any of the following conditions are true.

  - E is-agent-order-before D in execution.
  - E synchronizes-with D in execution.
  - SharedDataBlockEventSet(execution) contains both E and
    D, E.[[Order]] is ~init~, and E and D have
    overlapping ranges.
  - There is an event F such that E happens-before F and
    F happens-before D in execution.

Because happens-before is a superset of agent-order, a candidate
execution is consistent with the single-thread evaluation semantics of
ECMAScript.

Properties of Valid Executions
------------------------------

Valid Chosen Reads
------------------

A candidate execution execution has valid chosen reads if the
following algorithm returns `true`.

1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event R
of SharedDataBlockEventSet(execution), do 1. Let
chosenValueRecord be the element of execution.[[ChosenValues]]
whose [[Event]] field is R. 1. Let chosenValue be
chosenValueRecord.[[ChosenValue]]. 1. Let readValue be
ValueOfReadEvent(execution, R). 1. Let chosenLen be the
number of elements in chosenValue. 1. Let readLen be the number
of elements in readValue. 1. If chosenLen ≠ readLen, then 1.
Return `false`. 1. If chosenValue[i] ≠ readValue[i]
for some integer i in the interval from 0 (inclusive) to
chosenLen (exclusive), then 1. Return `false`. 1. Return `true`.

Coherent Reads
--------------

A candidate execution execution has coherent reads if the following
algorithm returns `true`.

1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event R
of SharedDataBlockEventSet(execution), do 1. Let Ws be
reads-bytes-from(R) in execution. 1. Let byteLocation be
R.[[ByteIndex]]. 1. For each element W of Ws, do 1. If R
happens-before W in execution, then 1. Return `false`. 1. If
there exists a WriteSharedMemory or ReadModifyWriteSharedMemory event
V that has byteLocation in its range such that W
happens-before V in execution and V happens-before R in
execution, then 1. Return `false`. 1. Set byteLocation to
byteLocation + 1. 1. Return `true`.

Tear Free Reads
---------------

A candidate execution execution has tear free reads if the following
algorithm returns `true`.

1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event R
of SharedDataBlockEventSet(execution), do 1. If R.[[NoTear]] is
`true`, then 1. Assert: The remainder of dividing R.[[ByteIndex]]
by R.[[ElementSize]] is 0. 1. For each event W such that R
reads-from W in execution and W.[[NoTear]] is `true`, do
1. If R and W have equal ranges and there exists an event V
such that V and W have equal ranges, V.[[NoTear]] is
`true`, W and V are not the same Shared Data Block event, and
R reads-from V in execution, then 1. Return `false`. 1.
Return `true`.

An event's [[NoTear]] field is `true` when that event was introduced
via accessing an integer TypedArray, and `false` when introduced via
accessing a floating point TypedArray or DataView.

Intuitively, this requirement says when a memory range is accessed in an
aligned fashion via an integer TypedArray, a single write event on that
range must "win" when in a data race with other write events with equal
ranges. More precisely, this requirement says an aligned read event
cannot read a value composed of bytes from multiple, different write
events all with equal ranges. It is possible, however, for an aligned
read event to read from multiple write events with overlapping ranges.

Sequentially Consistent Atomics
-------------------------------

For a candidate execution execution, is-memory-order-before is a
strict total order of all events in EventSet(execution) that
satisfies the following.

- For events E and D, E is-memory-order-before D in
  execution if E happens-before D in execution.

- For events R and W such that R reads-from W in
  execution, there is no WriteSharedMemory or
  ReadModifyWriteSharedMemory event V in
  SharedDataBlockEventSet(execution) such that V.[[Order]] is
  ~seq-cst~, W is-memory-order-before V in execution, V
  is-memory-order-before R in execution, and any of the
  following conditions are true.

  - W synchronizes-with R in execution, and V and R
    have equal ranges.
  - W happens-before R and V happens-before R in
    execution, W.[[Order]] is ~seq-cst~, and W and V
    have equal ranges.
  - W happens-before R and W happens-before V in
    execution, R.[[Order]] is ~seq-cst~, and V and R
    have equal ranges.

  This clause additionally constrains ~seq-cst~ events on equal ranges.

- For each WriteSharedMemory or ReadModifyWriteSharedMemory event W
  in SharedDataBlockEventSet(execution), if W.[[Order]] is
  ~seq-cst~, then it is not the case that there is an infinite number of
  ReadSharedMemory or ReadModifyWriteSharedMemory events in
  SharedDataBlockEventSet(execution) with equal range that is
  memory-order before W.

  This clause together with the forward progress guarantee on agents
  ensure the liveness condition that ~seq-cst~ writes become visible to
  ~seq-cst~ reads with equal range in finite time.

A candidate execution has sequentially consistent atomics if it admits
an is-memory-order-before Relation.

While is-memory-order-before includes all events in
EventSet(execution), those that are not constrained by
happens-before or synchronizes-with in execution are allowed to
occur anywhere in the order.

Valid Executions
----------------

A candidate execution execution is a valid execution (or simply an
execution) if all of the following are true.

- The host provides a host-synchronizes-with Relation for execution.
- execution admits a happens-before Relation that is a strict
  partial order.
- execution has valid chosen reads.
- execution has coherent reads.
- execution has tear free reads.
- execution has sequentially consistent atomics.

All programs have at least one valid execution.

Races
-----

For an execution execution and events E and D that are
contained in SharedDataBlockEventSet(execution), E and D are
in a *race* if the following algorithm returns `true`.

1. If E and D are not the same Shared Data Block event, then 1.
If it is not the case that both E happens-before D in
execution and D happens-before E in execution, then 1.
If E and D are both WriteSharedMemory or
ReadModifyWriteSharedMemory events and E and D do not have
disjoint ranges, then 1. Return `true`. 1. If E reads-from D
in execution or D reads-from E in execution, then 1.
Return `true`. 1. Return `false`.

Data Races
----------

For an execution execution and events E and D that are
contained in SharedDataBlockEventSet(execution), E and D are
in a data race if the following algorithm returns `true`.

1. If E and D are in a race in execution, then 1. If
E.[[Order]] is not ~seq-cst~ or D.[[Order]] is not ~seq-cst~,
then 1. Return `true`. 1. If E and D have overlapping ranges,
then 1. Return `true`. 1. Return `false`.

Data Race Freedom
-----------------

An execution execution is data race free if there are no two events
in SharedDataBlockEventSet(execution) that are in a data race.

A program is data race free if all its executions are data race free.

The memory model guarantees sequential consistency of all events for
data race free programs.

Shared Memory Guidelines
------------------------

The following are guidelines for ECMAScript programmers working with
shared memory.

We recommend programs be kept data race free, i.e., make it so that it
is impossible for there to be concurrent non-atomic operations on the
same memory location. Data race free programs have interleaving
semantics where each step in the evaluation semantics of each agent are
interleaved with each other. For data race free programs, it is not
necessary to understand the details of the memory model. The details are
unlikely to build intuition that will help one to better write
ECMAScript.

More generally, even if a program is not data race free it may have
predictable behaviour, so long as atomic operations are not involved in
any data races and the operations that race all have the same access
size. The simplest way to arrange for atomics not to be involved in
races is to ensure that different memory cells are used by atomic and
non-atomic operations and that atomic accesses of different sizes are
not used to access the same cells at the same time. Effectively, the
program should treat shared memory as strongly typed as much as
possible. One still cannot depend on the ordering and timing of
non-atomic accesses that race, but if memory is treated as strongly
typed the racing accesses will not "tear" (bits of their values will not
be mixed).

The following are guidelines for ECMAScript implementers writing
compiler transformations for programs using shared memory.

It is desirable to allow most program transformations that are valid in
a single-agent setting in a multi-agent setting, to ensure that the
performance of each agent in a multi-agent program is as good as it
would be in a single-agent setting. Frequently these transformations are
hard to judge. We outline some rules about program transformations that
are intended to be taken as normative (in that they are implied by the
memory model or stronger than what the memory model implies) but which
are likely not exhaustive. These rules are intended to apply to program
transformations that precede the introductions of the events that make
up the is-agent-order-before Relation.

Let an agent-order slice be the subset of the is-agent-order-before
Relation pertaining to a single agent.

Let possible read values of a read event be the set of all values of
ValueOfReadEvent for that event across all valid executions.

Any transformation of an agent-order slice that is valid in the absence
of shared memory is valid in the presence of shared memory, with the
following exceptions.

- *Atomics are carved in stone*: Program transformations must not cause
  the ~seq-cst~ events in an agent-order slice to be reordered with its
  ~unordered~ operations, nor its ~seq-cst~ operations to be reordered
  with each other, nor may a program transformation remove a ~seq-cst~
  operation from the is-agent-order-before Relation.

  (In practice, the prohibition on reorderings forces a compiler to
  assume that every ~seq-cst~ operation is a synchronization and
  included in the final is-memory-order-before Relation, which it would
  usually have to assume anyway in the absence of inter-agent program
  analysis. It also forces the compiler to assume that every call where
  the callee's effects on the memory-order are unknown may contain
  ~seq-cst~ operations.)

- *Reads must be stable*: Any given shared memory read must only observe
  a single value in an execution.

  (For example, if what is semantically a single read in the program is
  executed multiple times then the program is subsequently allowed to
  observe only one of the values read. A transformation known as
  rematerialization can violate this rule.)

- *Writes must be stable*: All observable writes to shared memory must
  follow from program semantics in an execution.

  (For example, a transformation may not introduce certain observable
  writes, such as by using read-modify-write operations on a larger
  location to write a smaller datum, writing a value to memory that the
  program could not have written, or writing a just-read value back to
  the location it was read from, if that location could have been
  overwritten by another agent after the read.)

- *Possible read values must be non-empty*: Program transformations
  cannot cause the possible read values of a shared memory read to
  become empty.

  (Counterintuitively, this rule in effect restricts transformations on
  writes, because writes have force in memory model insofar as to be
  read by read events. For example, writes may be moved and coalesced
  and sometimes reordered between two ~seq-cst~ operations, but the
  transformation may not remove every write that updates a location;
  some write must be preserved.)

Examples of transformations that remain valid are: merging multiple
non-atomic reads from the same location, reordering non-atomic reads,
introducing speculative non-atomic reads, merging multiple non-atomic
writes to the same location, reordering non-atomic writes to different
locations, and hoisting non-atomic reads out of loops even if that
affects termination. Note in general that aliased TypedArrays make it
hard to prove that locations are different.

The following are guidelines for ECMAScript implementers generating
machine code for shared memory accesses.

For architectures with memory models no weaker than those of ARM or
Power, non-atomic stores and loads may be compiled to bare stores and
loads on the target architecture. Atomic stores and loads may be
compiled down to instructions that guarantee sequential consistency. If
no such instructions exist, memory barriers are to be employed, such as
placing barriers on both sides of a bare store or load.
Read-modify-write operations may be compiled to read-modify-write
instructions on the target architecture, such as ``LOCK``-prefixed
instructions on x86, load-exclusive/store-exclusive instructions on ARM,
and load-link/store-conditional instructions on Power.

Specifically, the memory model is intended to allow code generation as
follows.

- Every atomic operation in the program is assumed to be necessary.
- Atomic operations are never rearranged with each other or with
  non-atomic operations.
- Functions are always assumed to perform atomic operations.
- Atomic operations are never implemented as read-modify-write
  operations on larger data, but as non-lock-free atomics if the
  platform does not have atomic operations of the appropriate size. (We
  already assume that every platform has normal memory access operations
  of every interesting size.)

Naive code generation uses these patterns:

- Regular loads and stores compile to single load and store
  instructions.
- Lock-free atomic loads and stores compile to a full (sequentially
  consistent) fence, a regular load or store, and a full fence.
- Lock-free atomic read-modify-write accesses compile to a full fence,
  an atomic read-modify-write instruction sequence, and a full fence.
- Non-lock-free atomics compile to a spinlock acquire, a full fence, a
  series of non-atomic load and store instructions, a full fence, and a
  spinlock release.

That mapping is correct so long as an atomic operation on an address
range does not race with a non-atomic write or with an atomic operation
of different size. However, that is all we need: the memory model
effectively demotes the atomic operations involved in a race to
non-atomic status. On the other hand, the naive mapping is quite strong:
it allows atomic operations to be used as sequentially consistent
fences, which the memory model does not actually guarantee.

Local improvements to those basic patterns are also allowed, subject to
the constraints of the memory model. For example:

- There are obvious platform-dependent improvements that remove
  redundant fences. For example, on x86 the fences around lock-free
  atomic loads and stores can always be omitted except for the fence
  following a store, and no fence is needed for lock-free
  read-modify-write instructions, as these all use ``LOCK``-prefixed
  instructions. On many platforms there are fences of several strengths,
  and weaker fences can be used in certain contexts without destroying
  sequential consistency.
- Most modern platforms support lock-free atomics for all the data sizes
  required by ECMAScript atomics. Should non-lock-free atomics be
  needed, the fences surrounding the body of the atomic operation can
  usually be folded into the lock and unlock steps. The simplest
  solution for non-lock-free atomics is to have a single lock word per
  SharedArrayBuffer.
- There are also more complicated platform-dependent local improvements,
  requiring some code analysis. For example, two back-to-back fences
  often have the same effect as a single fence, so if code is generated
  for two atomic operations in sequence, only a single fence need
  separate them. On x86, even a single fence separating atomic stores
  can be omitted, as the fence following a store is only needed to
  separate the store from a subsequent load.

A Grammar Summary
=================

https://tc39.es/ecma262/multipage/grammar-summary.html
::

   A.1 Lexical Grammar
   A.2 Expressions
   A.3 Statements
   A.4 Functions and Classes
   A.5 Scripts and Modules
   A.6 Number Conversions
   A.7 Time Zone Offset String Format
   A.8 Regular Expressions

A.1 Lexical Grammar
-------------------


    SourceCharacter :: 
        | any Unicode code point

    InputElementDiv :: 
        | WhiteSpace
        | LineTerminator
        | Comment
        | CommonToken
        | DivPunctuator
        | RightBracePunctuator

    InputElementRegExp :: 
        | WhiteSpace
        | LineTerminator
        | Comment
        | CommonToken
        | RightBracePunctuator
        | RegularExpressionLiteral

    InputElementRegExpOrTemplateTail :: 
        | WhiteSpace
        | LineTerminator
        | Comment
        | CommonToken
        | RegularExpressionLiteral
        | TemplateSubstitutionTail

    InputElementTemplateTail :: 
        | WhiteSpace
        | LineTerminator
        | Comment
        | CommonToken
        | DivPunctuator
        | TemplateSubstitutionTail

    InputElementHashbangOrRegExp :: 
        | WhiteSpace
        | LineTerminator
        | Comment
        | CommonToken
        | HashbangComment
        | RegularExpressionLiteral

    WhiteSpace :: 
        | <TAB>
        | <VT>
        | <FF>
        | <ZWNBSP>
        | <USP>

    LineTerminator :: 
        | <LF>
        | <CR>
        | <LS>
        | <PS>

    LineTerminatorSequence :: 
        | <LF>
        | <CR>
        | [lookahead ≠ <LF>]
        | <LS>
        | <PS>
        | <CR>
        | <LF>

    Comment :: 
        | MultiLineComment
        | SingleLineComment

    MultiLineComment :: 
        | ``/* MultiLineCommentChars\ :sub:`opt` */``

    MultiLineCommentChars :: 
        | MultiLineNotAsteriskChar
        | MultiLineCommentChars\ :sub:`opt`
        | * PostAsteriskCommentChars\ :sub:`opt`

    PostAsteriskCommentChars :: 
        | MultiLineNotForwardSlashOrAsteriskChar
        | MultiLineCommentChars\ :sub:`opt`
        | * PostAsteriskCommentChars\ :sub:`opt`

    MultiLineNotAsteriskChar :: 
        | SourceCharacter but not *

    MultiLineNotForwardSlashOrAsteriskChar :: 
        | SourceCharacter but not one of / or *

    SingleLineComment :: 
        | // SingleLineCommentChars\ :sub:`opt`

    SingleLineCommentChars :: 
        | SingleLineCommentChar
        | SingleLineCommentChars\ :sub:`opt`

    SingleLineCommentChar :: 
        | SourceCharacter but not LineTerminator

    HashbangComment :: 
        | #! SingleLineCommentChars\ :sub:`opt`

    CommonToken :: 
        | IdentifierName
        | PrivateIdentifier
        | Punctuator
        | NumericLiteral
        | StringLiteral
        | Template

    PrivateIdentifier :: 
        | # IdentifierName

    IdentifierName :: 
        | IdentifierStart
        | IdentifierName
        | IdentifierPart

    IdentifierStart :: 
        | IdentifierStartChar
        | \\ UnicodeEscapeSequence

    IdentifierPart :: 
        | IdentifierPartChar
        | \\ UnicodeEscapeSequence

    IdentifierStartChar :: 
        | UnicodeIDStart
        | $
        | _

    IdentifierPartChar :: 
        | UnicodeIDContinue
        | $

    AsciiLetter :: one of 
        | a b c d e f g h i j k l m n o p q r s t u v w x y z 
        | A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

    UnicodeIDStart :: 
        | any Unicode code point with the Unicode property “ID_Start”

    UnicodeIDContinue :: 
        | any Unicode code point with the Unicode property “ID_Continue”

    ReservedWord :: one of 
        | await break case catch class const continue debugger default delete 
        |     do else enum export extends false finally for function if import in 
        |     instanceof new null return super switch this throw true try typeof 
        |     var void while with yield

    Punctuator :: 
        | OptionalChainingPunctuator
        | OtherPunctuator

    OptionalChainingPunctuator :: 
        | ?. [lookahead ∉ DecimalDigit]

    OtherPunctuator :: one of
        | ``{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & |``
        |     ``^ ! ~ && || ?? ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= &&= ||= ??= =>``

    DivPunctuator :: 
        | /
        | /=

    RightBracePunctuator :: 
        | }

    NullLiteral :: 
        | null

    BooleanLiteral :: 
        | true
        | false

    NumericLiteralSeparator :: 
        | _

    NumericLiteral :: 
        | DecimalLiteral
        | DecimalBigIntegerLiteral
        | NonDecimalIntegerLiteral[+Sep]
        | NonDecimalIntegerLiteral[+Sep]
        | BigIntLiteralSuffix
        | LegacyOctalIntegerLiteral

    DecimalBigIntegerLiteral :: 
        | 0
        | BigIntLiteralSuffix
        | NonZeroDigit
        | DecimalDigits[+Sep]\ :sub:`opt`
        | BigIntLiteralSuffix
        | NonZeroDigit
        | NumericLiteralSeparator
        | DecimalDigits[+Sep]
        | BigIntLiteralSuffix

    NonDecimalIntegerLiteral[Sep] :: 
        | BinaryIntegerLiteral[?Sep]
        | OctalIntegerLiteral[?Sep]
        | HexIntegerLiteral[?Sep]

    BigIntLiteralSuffix :: 
        | n

    DecimalLiteral :: 
        | DecimalIntegerLiteral . DecimalDigits[+Sep]\ :sub:`opt`
        | ExponentPart[+Sep]\ :sub:`opt`
        | . DecimalDigits[+Sep]
        | ExponentPart[+Sep]\ :sub:`opt`
        | DecimalIntegerLiteral
        | ExponentPart[+Sep]\ :sub:`opt`

    DecimalIntegerLiteral :: 
        | 0
        | NonZeroDigit
        | NonZeroDigit NumericLiteralSeparator\ :sub:`opt`
        | DecimalDigits[+Sep]
        | NonOctalDecimalIntegerLiteral

    DecimalDigits[Sep] :: 
        | DecimalDigit
        | DecimalDigits[?Sep] DecimalDigit
        | [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

    DecimalDigit :: one of
        | 0 1 2 3 4 5 6 7 8 9

    NonZeroDigit :: one of
        | 1 2 3 4 5 6 7 8 9

    ExponentPart[Sep] :: 
        | ExponentIndicator SignedInteger[?Sep]

    ExponentIndicator :: one of
        | e E

    SignedInteger[Sep] :: 
        | DecimalDigits[?Sep]
        | + DecimalDigits[?Sep]
        | - DecimalDigits[?Sep]

    BinaryIntegerLiteral[Sep] :: 
        | 0b BinaryDigits[?Sep]
        | 0B BinaryDigits[?Sep]

    BinaryDigits[Sep] :: 
        | BinaryDigit
        | BinaryDigits[?Sep] BinaryDigit
        | [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

    BinaryDigit :: one of
        | 0 1

    OctalIntegerLiteral[Sep] :: 
        | 0o OctalDigits[?Sep]
        | 0O OctalDigits[?Sep]

    OctalDigits[Sep] :: 
        | OctalDigit
        | OctalDigits[?Sep] OctalDigit
        | [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

    LegacyOctalIntegerLiteral :: 
        | 0 OctalDigit
        | LegacyOctalIntegerLiteral OctalDigit

    NonOctalDecimalIntegerLiteral :: 
        | 0 NonOctalDigit
        | LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
        | NonOctalDecimalIntegerLiteral DecimalDigit

    LegacyOctalLikeDecimalIntegerLiteral :: 
        | 0
        | OctalDigit
        | LegacyOctalLikeDecimalIntegerLiteral OctalDigit

    OctalDigit :: one of
        | 0 1 2 3 4 5 6 7

    NonOctalDigit :: one of
        | 8 9

    HexIntegerLiteral[Sep] :: 
        | 0x HexDigits[?Sep]
        | 0X HexDigits[?Sep]

    HexDigits[Sep] :: 
        | HexDigit
        | HexDigits[?Sep] HexDigit
        | [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

    HexDigit :: one of
        | 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

    StringLiteral :: 
        | " DoubleStringCharacters\ :sub:`opt` "
        | ' SingleStringCharacters\ :sub:`opt` '

    DoubleStringCharacters :: 
        | DoubleStringCharacter DoubleStringCharacters\ :sub:`opt`

    SingleStringCharacters :: 
        | SingleStringCharacter SingleStringCharacters\ :sub:`opt`

    DoubleStringCharacter :: 
        | SourceCharacter but not one of " or \ or LineTerminator
        | <LS>
        | <PS>
        | \\
        | EscapeSequence
        | LineContinuation

    SingleStringCharacter :: 
        | SourceCharacter but not one of ' or \\ or LineTerminator
        | <LS>
        | <PS>
        | \\ EscapeSequence
        | LineContinuation

    LineContinuation :: 
        | \\ LineTerminatorSequence

    EscapeSequence :: 
        | CharacterEscapeSequence
        | 0 [lookahead ∉ DecimalDigit]
        | LegacyOctalEscapeSequence
        | NonOctalDecimalEscapeSequence
        | HexEscapeSequence
        | UnicodeEscapeSequence

    CharacterEscapeSequence :: 
        | SingleEscapeCharacter
        | NonEscapeCharacter

    SingleEscapeCharacter :: one of
        | ' " \\ b f n r t v

    NonEscapeCharacter :: 
        | SourceCharacter but not one of EscapeCharacter or LineTerminator

    EscapeCharacter :: 
        | SingleEscapeCharacter
        | DecimalDigit
        | x
        | u

    LegacyOctalEscapeSequence :: 
        | 0 [lookahead ∈ { 8, 9 }]
        | NonZeroOctalDigit [lookahead ∉ OctalDigit]
        | ZeroToThree OctalDigit [lookahead ∉ OctalDigit]
        | FourToSeven OctalDigit
        | ZeroToThree OctalDigit OctalDigit

    NonZeroOctalDigit :: 
        | OctalDigit but not 0

    ZeroToThree :: one of
        | 0 1 2 3

    FourToSeven :: one of
        | 4 5 6 7

    NonOctalDecimalEscapeSequence :: one of
        | 8 9

    HexEscapeSequence :: 
        | x HexDigit HexDigit

    UnicodeEscapeSequence :: 
        | u Hex4Digits
        | u{ CodePoint }

    Hex4Digits :: 
        | HexDigit HexDigit HexDigit HexDigit

    RegularExpressionLiteral :: 
        | / RegularExpressionBody / RegularExpressionFlags

    RegularExpressionBody :: 
        | RegularExpressionFirstChar RegularExpressionChars

    RegularExpressionChars :: 
        | [empty]
        | RegularExpressionChars RegularExpressionChar

    RegularExpressionFirstChar :: 
        | RegularExpressionNonTerminator but not one of * or \\ or / or [
        | RegularExpressionBackslashSequence
        | RegularExpressionClass

    RegularExpressionChar :: 
        | RegularExpressionNonTerminator but not one of \\ or / or [
        | RegularExpressionBackslashSequence
        | RegularExpressionClass

    RegularExpressionBackslashSequence :: 
        | \\ RegularExpressionNonTerminator

    RegularExpressionNonTerminator :: 
        | SourceCharacter but not LineTerminator

    RegularExpressionClass :: 
        | [ RegularExpressionClassChars ]

    RegularExpressionClassChars :: 
        | [empty]
        | RegularExpressionClassChars RegularExpressionClassChar

    RegularExpressionClassChar :: 
        | RegularExpressionNonTerminator but not one of ] or \\
        | RegularExpressionBackslashSequence

    RegularExpressionFlags :: 
        | [empty]
        | RegularExpressionFlags IdentifierPartChar

    Template :: 
        | NoSubstitutionTemplate
        | TemplateHead

    NoSubstitutionTemplate :: 
        | ` TemplateCharacters\ :sub:`opt` `

    TemplateHead :: 
        | ` TemplateCharacters\ :sub:`opt` ${

    TemplateSubstitutionTail :: 
        | TemplateMiddle
        | TemplateTail

    TemplateMiddle :: 
        | } TemplateCharacters\ :sub:`opt` ${

    TemplateTail :: 
        | } TemplateCharacters\ :sub:`opt` `

    TemplateCharacters :: 
        | TemplateCharacter
        | TemplateCharacters\ :sub:`opt`

    TemplateCharacter :: 
        | $ [lookahead ≠ {]
        | \\ TemplateEscapeSequence
        | \\ NotEscapeSequence
        | LineContinuation
        | LineTerminatorSequence
        | SourceCharacter but not one of ` or \\ or $ or LineTerminator

    TemplateEscapeSequence :: 
        | CharacterEscapeSequence
        | 0 [lookahead ∉ DecimalDigit]
        | HexEscapeSequence
        | UnicodeEscapeSequence

    NotEscapeSequence :: 
        | 0 DecimalDigit
        | DecimalDigit but not 0
        | x [lookahead ∉ HexDigit]
        | x HexDigit
        | [lookahead ∉ HexDigit]
        | u [lookahead ∉ HexDigit] [lookahead ≠ {]
        | u HexDigit [lookahead ∉ HexDigit]
        | u HexDigit HexDigit [lookahead ∉ HexDigit]
        | u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit]
        | u { [lookahead ∉ HexDigit]
        | u { NotCodePoint [lookahead ∉ HexDigit]
        | u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ }]

    NotCodePoint :: 
        | HexDigits[~Sep] but only if the MV of HexDigits > 0x10FFFF

    CodePoint :: 
        | HexDigits[~Sep] but only if the MV of HexDigits ≤ 0x10FFFF

A.2 Expressions
---------------

    IdentifierReference[Yield, Await] : 
        | Identifier
        | [~Yield] yield
        | [~Await] await

    BindingIdentifier[Yield, Await] : 
        | Identifier
        | yield
        | await

    LabelIdentifier[Yield, Await] : 
        | Identifier
        | [~Yield] yield
        | [~Await] await

    Identifier : 
        | IdentifierName but not ReservedWord

    PrimaryExpression[Yield, Await] : 
        | this
        | IdentifierReference[?Yield, ?Await]
        | Literal
        | ArrayLiteral[?Yield, ?Await]
        | ObjectLiteral[?Yield, ?Await]
        | FunctionExpression
        | ClassExpression[?Yield, ?Await]
        | GeneratorExpression
        | AsyncFunctionExpression
        | AsyncGeneratorExpression
        | RegularExpressionLiteral
        | TemplateLiteral[?Yield, ?Await, ~Tagged]
        | CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

    CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] : 
        | ( Expression[+In, ?Yield, ?Await] )
        | ( Expression[+In, ?Yield, ?Await] , )
        | ( )
        | ( ... BindingIdentifier[?Yield, ?Await] )
        | ( ... BindingPattern[?Yield, ?Await] )
        | ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] )
        | ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] )


    When processing an instance of the production

    |    PrimaryExpression[Yield, Await] : 
    |        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

    the interpretation of CoverParenthesizedExpressionAndArrowParameterList is 
    refined using the following grammar:

    ParenthesizedExpression[Yield, Await] : 
        | ( Expression[+In, ?Yield, ?Await] )

    Literal : 
        | NullLiteral
        | BooleanLiteral
        | NumericLiteral
        | StringLiteral

    ArrayLiteral[Yield, Await] : 
        | [ Elision\ :sub:`opt` ]
        | [ ElementList[?Yield, ?Await] ]
        | [ ElementList[?Yield, ?Await] , Elision\ :sub:`opt` ]

    ElementList[Yield, Await] : 
        | Elision\ :sub:`opt` AssignmentExpression[+In, ?Yield, ?Await]
        | Elision\ :sub:`opt` SpreadElement[?Yield, ?Await]
        | ElementList[?Yield, ?Await] , Elision\ :sub:`opt` AssignmentExpression[+In, ?Yield, ?Await]
        | ElementList[?Yield, ?Await] , Elision\ :sub:`opt` SpreadElement[?Yield, ?Await]

    Elision : 
        | ,
        | Elision ,

    SpreadElement[Yield, Await] : 
        | ... AssignmentExpression[+In, ?Yield, ?Await]

    ObjectLiteral[Yield, Await] : 
        | { }
        | { PropertyDefinitionList[?Yield, ?Await] }
        | { PropertyDefinitionList[?Yield, ?Await] , }

    PropertyDefinitionList[Yield, Await] : 
        | PropertyDefinition[?Yield, ?Await]
        | PropertyDefinitionList[?Yield, ?Await] , PropertyDefinition[?Yield, ?Await]

    PropertyDefinition[Yield, Await] : 
        | IdentifierReference[?Yield, ?Await]
        | CoverInitializedName[?Yield, ?Await]
        | PropertyName[?Yield, ?Await] : AssignmentExpression[+In, ?Yield, ?Await]
        | MethodDefinition[?Yield, ?Await]
        | ... AssignmentExpression[+In, ?Yield, ?Await]

    PropertyName[Yield, Await] : 
        | LiteralPropertyName
        | ComputedPropertyName[?Yield, ?Await]

    LiteralPropertyName : 
        | IdentifierName
        | StringLiteral
        | NumericLiteral

    ComputedPropertyName[Yield, Await] : 
        | [ AssignmentExpression[+In, ?Yield, ?Await] ]

    CoverInitializedName[Yield, Await] : 
        | IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

    Initializer[In, Yield, Await] : 
        | = AssignmentExpression[?In, ?Yield, ?Await]

    TemplateLiteral[Yield, Await, Tagged] : 
        | NoSubstitutionTemplate
        | SubstitutionTemplate[?Yield, ?Await, ?Tagged]

    SubstitutionTemplate[Yield, Await, Tagged] : 
        | TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

    TemplateSpans[Yield, Await, Tagged] : 
        | TemplateTail
        | TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

    TemplateMiddleList[Yield, Await, Tagged] : 
        | TemplateMiddle Expression[+In, ?Yield, ?Await]
        | TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]

    MemberExpression[Yield, Await] : 
        | PrimaryExpression[?Yield, ?Await]
        | MemberExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
        | MemberExpression[?Yield, ?Await] . IdentifierName
        | MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        | SuperProperty[?Yield, ?Await]
        | MetaProperty
        | new MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        | MemberExpression[?Yield, ?Await] . PrivateIdentifier

    SuperProperty[Yield, Await] : 
        | super [ Expression[+In, ?Yield, ?Await] ]
        | super . IdentifierName

    MetaProperty : 
        | NewTarget
        | ImportMeta

    NewTarget : 
        | new . target

    ImportMeta : 
        | import . meta

    NewExpression[Yield, Await] : 
        | MemberExpression[?Yield, ?Await]
        | new NewExpression[?Yield, ?Await]

    CallExpression[Yield, Await] : 
        | CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]
        | SuperCall[?Yield, ?Await]
        | ImportCall[?Yield, ?Await]
        | CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        | CallExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
        | CallExpression[?Yield, ?Await] . IdentifierName
        | CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        | CallExpression[?Yield, ?Await] . PrivateIdentifier


    When processing an instance of the production

    |   CallExpression[Yield, Await] : 
    |       CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]

    the interpretation of CoverCallExpressionAndAsyncArrowHead is refined 
    using the following grammar:

    CallMemberExpression[Yield, Await] : 
        | MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]

    SuperCall[Yield, Await] : 
        | super Arguments[?Yield, ?Await]

    ImportCall[Yield, Await] : 
        | import ( AssignmentExpression[+In, ?Yield, ?Await] )

    Arguments[Yield, Await] : 
        | ( )
        | ( ArgumentList[?Yield, ?Await] )
        | ( ArgumentList[?Yield, ?Await] , )

    ArgumentList[Yield, Await] : 
        | AssignmentExpression[+In, ?Yield, ?Await]
        | ... AssignmentExpression[+In, ?Yield, ?Await]
        | ArgumentList[?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await]
        | ArgumentList[?Yield, ?Await] , ... AssignmentExpression[+In, ?Yield, ?Await]

    OptionalExpression[Yield, Await] : 
        | MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        | CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        | OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

    OptionalChain[Yield, Await] : 
        | ?. Arguments[?Yield, ?Await]
        | ?. [ Expression[+In, ?Yield, ?Await] ]
        | ?. IdentifierName 
        | ?. TemplateLiteral[?Yield, ?Await, +Tagged]
        | ?. PrivateIdentifier 
        | OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
        | OptionalChain[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
        | OptionalChain[?Yield, ?Await] . IdentifierName
        | OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        | OptionalChain[?Yield, ?Await] . PrivateIdentifier

    LeftHandSideExpression[Yield, Await] : 
        | NewExpression[?Yield, ?Await]
        | CallExpression[?Yield, ?Await]
        | OptionalExpression[?Yield, ?Await]

    UpdateExpression[Yield, Await] : 
        | LeftHandSideExpression[?Yield, ?Await]
        | LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
        | LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
        | ++ UnaryExpression[?Yield, ?Await]
        | -- UnaryExpression[?Yield, ?Await]

    UnaryExpression[Yield, Await] : 
        | UpdateExpression[?Yield, ?Await]
        | delete UnaryExpression[?Yield, ?Await]
        | void UnaryExpression[?Yield, ?Await]
        | typeof UnaryExpression[?Yield, ?Await]
        | + UnaryExpression[?Yield, ?Await]
        | - UnaryExpression[?Yield, ?Await]
        | ~ UnaryExpression[?Yield, ?Await]
        | ! UnaryExpression[?Yield, ?Await]
        | [+Await] AwaitExpression[?Yield]

    ExponentiationExpression[Yield, Await] : 
        | UnaryExpression[?Yield, ?Await]
        | UpdateExpression[?Yield, ?Await] \** ExponentiationExpression[?Yield, ?Await]

    MultiplicativeExpression[Yield, Await] : 
        | ExponentiationExpression[?Yield, ?Await]
        | MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

    MultiplicativeOperator : one of 
        | * / %

    AdditiveExpression[Yield, Await] : 
        | MultiplicativeExpression[?Yield, ?Await]
        | AdditiveExpression[?Yield, ?Await] + MultiplicativeExpression[?Yield, ?Await]
        | AdditiveExpression[?Yield, ?Await] - MultiplicativeExpression[?Yield, ?Await]

    ShiftExpression[Yield, Await] : 
        | AdditiveExpression[?Yield, ?Await]
        | ShiftExpression[?Yield, ?Await] << AdditiveExpression[?Yield, ?Await]
        | ShiftExpression[?Yield, ?Await] > AdditiveExpression[?Yield, ?Await]
        | ShiftExpression[?Yield, ?Await] > AdditiveExpression[?Yield, ?Await]

    RelationalExpression[In, Yield, Await] : 
        | ShiftExpression[?Yield, ?Await]
        | RelationalExpression[?In, ?Yield, ?Await] < ShiftExpression[?Yield, ?Await]
        | RelationalExpression[?In, ?Yield, ?Await] > ShiftExpression[?Yield, ?Await]
        | RelationalExpression[?In, ?Yield, ?Await] <= ShiftExpression[?Yield, ?Await]
        | RelationalExpression[?In, ?Yield, ?Await] >= ShiftExpression[?Yield, ?Await]
        | RelationalExpression[?In, ?Yield, ?Await] instanceof ShiftExpression[?Yield, ?Await]
        | [+In] RelationalExpression[+In, ?Yield, ?Await] in ShiftExpression[?Yield, ?Await]
        | [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]

    EqualityExpression[In, Yield, Await] : 
        | RelationalExpression[?In, ?Yield, ?Await]
        | EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await]
        | EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await]
        | EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await]
        | EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await]

    BitwiseANDExpression[In, Yield, Await] : 
        | EqualityExpression[?In, ?Yield, ?Await]
        | BitwiseANDExpression[?In, ?Yield, ?Await] & EqualityExpression[?In, ?Yield, ?Await]

    BitwiseXORExpression[In, Yield, Await] : 
        | BitwiseANDExpression[?In, ?Yield, ?Await]
        | BitwiseXORExpression[?In, ?Yield, ?Await] ^ BitwiseANDExpression[?In, ?Yield, ?Await]

    BitwiseORExpression[In, Yield, Await] : 
        | BitwiseXORExpression[?In, ?Yield, ?Await]
        | BitwiseORExpression[?In, ?Yield, ?Await] | BitwiseXORExpression[?In, ?Yield, ?Await]

        | LogicalANDExpression[In, Yield, Await] : 
        | BitwiseORExpression[?In, ?Yield, ?Await]
        | LogicalANDExpression[?In, ?Yield, ?Await] && BitwiseORExpression[?In, ?Yield, ?Await]

    LogicalORExpression[In, Yield, Await] : 
        | LogicalANDExpression[?In, ?Yield, ?Await]
        | LogicalORExpression[?In, ?Yield, ?Await] || LogicalANDExpression[?In, ?Yield, ?Await]

    CoalesceExpression[In, Yield, Await] : 
        | CoalesceExpressionHead[?In, ?Yield, ?Await] ?? BitwiseORExpression[?In, ?Yield, ?Await]

    CoalesceExpressionHead[In, Yield, Await] : 
        | CoalesceExpression[?In, ?Yield, ?Await]
        | BitwiseORExpression[?In, ?Yield, ?Await]

    ShortCircuitExpression[In, Yield, Await] : 
        | LogicalORExpression[?In, ?Yield, ?Await]
        | CoalesceExpression[?In, ?Yield, ?Await]

    ConditionalExpression[In, Yield, Await] : 
        | ShortCircuitExpression[?In, ?Yield, ?Await]
        | ShortCircuitExpression[?In, ?Yield, ?Await] ? AssignmentExpression[+In, ?Yield, ?Await] :
        | AssignmentExpression[?In, ?Yield, ?Await]

    AssignmentExpression[In, Yield, Await] : 
        | ConditionalExpression[?In, ?Yield, ?Await]
        | [+Yield] YieldExpression[?In, ?Await]
        | ArrowFunction[?In, ?Yield, ?Await]
        | AsyncArrowFunction[?In, ?Yield, ?Await]
        | LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]
        | LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
        | LeftHandSideExpression[?Yield, ?Await] &&= AssignmentExpression[?In, ?Yield, ?Await]
        | LeftHandSideExpression[?Yield, ?Await] ||= AssignmentExpression[?In, ?Yield, ?Await]
        | LeftHandSideExpression[?Yield, ?Await] ??= AssignmentExpression[?In, ?Yield, ?Await]

    AssignmentOperator : one of 
        | ``*= /= %= += -= <<= >= >= &= ^= |= **=``

    In certain circumstances when processing an instance of the production

    |   AssignmentExpression[In, Yield, Await] : LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]

    the interpretation of LeftHandSideExpression is refined using the following grammar:

    AssignmentPattern[Yield, Await] : 
        | ObjectAssignmentPattern[?Yield, ?Await]
        | ArrayAssignmentPattern[?Yield, ?Await]

    ObjectAssignmentPattern[Yield, Await] : 
        | { }
        | { AssignmentRestProperty[?Yield, ?Await] }
        | { AssignmentPropertyList[?Yield, ?Await] }
        | { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await]\ :sub:`opt` }

    ArrayAssignmentPattern[Yield, Await] : 
        | [ Elision\ :sub:`opt` AssignmentRestElement[?Yield, ?Await]\ :sub:`opt` ]
        | [ AssignmentElementList[?Yield, ?Await] ]
        | [ AssignmentElementList[?Yield, ?Await] , Elision\ :sub:`opt` AssignmentRestElement[?Yield, ?Await]\ :sub:`opt` ]

    AssignmentRestProperty[Yield, Await] : 
        | ... DestructuringAssignmentTarget[?Yield, ?Await]

    AssignmentPropertyList[Yield, Await] : 
        | AssignmentProperty[?Yield, ?Await]
        | AssignmentPropertyList[?Yield, ?Await] , AssignmentProperty[?Yield, ?Await]

    AssignmentElementList[Yield, Await] : 
        | AssignmentElisionElement[?Yield, ?Await]
        | AssignmentElementList[?Yield, ?Await] , AssignmentElisionElement[?Yield, ?Await]

    AssignmentElisionElement[Yield, Await] : 
        | Elision\ :sub:`opt` AssignmentElement[?Yield, ?Await]

    AssignmentProperty[Yield, Await] : 
        | IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]\ :sub:`opt`
        | PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await]

    AssignmentElement[Yield, Await] : 
        | DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]\ :sub:`opt`

    AssignmentRestElement[Yield, Await] : 
        | ... DestructuringAssignmentTarget[?Yield, ?Await]

    DestructuringAssignmentTarget[Yield, Await] : 
        | LeftHandSideExpression[?Yield, ?Await]

    Expression[In, Yield, Await] : 
        | AssignmentExpression[?In, ?Yield, ?Await]
        | Expression[?In, ?Yield, ?Await] , AssignmentExpression[?In, ?Yield, ?Await]

 

A.3 Statements
--------------


    Statement[Yield, Await, Return] : 
        | BlockStatement[?Yield, ?Await, ?Return]
        | VariableStatement[?Yield, ?Await]
        | EmptyStatement
        | ExpressionStatement[?Yield, ?Await]
        | IfStatement[?Yield, ?Await, ?Return]
        | BreakableStatement[?Yield, ?Await, ?Return]
        | ContinueStatement[?Yield, ?Await]
        | BreakStatement[?Yield, ?Await]
        | [+Return] ReturnStatement[?Yield, ?Await]
        | WithStatement[?Yield, ?Await, ?Return]
        | LabelledStatement[?Yield, ?Await, ?Return]
        | ThrowStatement[?Yield, ?Await]
        | TryStatement[?Yield, ?Await, ?Return]
        | DebuggerStatement

    Declaration[Yield, Await] : 
        | HoistableDeclaration[?Yield, ?Await, ~Default]
        | ClassDeclaration[?Yield, ?Await, ~Default]
        | LexicalDeclaration[+In, ?Yield, ?Await]

    HoistableDeclaration[Yield, Await, Default] : 
        | FunctionDeclaration[?Yield, ?Await, ?Default]
        | GeneratorDeclaration[?Yield, ?Await, ?Default]
        | AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
        | AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

    BreakableStatement[Yield, Await, Return] : 
        | IterationStatement[?Yield, ?Await, ?Return]
        | SwitchStatement[?Yield, ?Await, ?Return]

    BlockStatement[Yield, Await, Return] : 
        | Block[?Yield, ?Await, ?Return]

    Block[Yield, Await, Return] : 
        | { StatementList[?Yield, ?Await, ?Return]\ :sub:`opt` }

    StatementList[Yield, Await, Return] : 
        | StatementListItem[?Yield, ?Await, ?Return]
        | StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

    StatementListItem[Yield, Await, Return] : 
        | Statement[?Yield, ?Await, ?Return]
        | Declaration[?Yield, ?Await]

    LexicalDeclaration[In, Yield, Await] : 
        | LetOrConst BindingList[?In, ?Yield, ?Await] ;

    LetOrConst : 
        | let
        | const

    BindingList[In, Yield, Await] : 
        | LexicalBinding[?In, ?Yield, ?Await]
        | BindingList[?In, ?Yield, ?Await] , LexicalBinding[?In, ?Yield, ?Await]

    LexicalBinding[In, Yield, Await] : 
        | BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]\ :sub:`opt`
        | BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]

    VariableStatement[Yield, Await] : 
        | var VariableDeclarationList[+In, ?Yield, ?Await] ;

    VariableDeclarationList[In, Yield, Await] : 
        | VariableDeclaration[?In, ?Yield, ?Await]
        | VariableDeclarationList[?In, ?Yield, ?Await] , VariableDeclaration[?In, ?Yield, ?Await]

    VariableDeclaration[In, Yield, Await] : 
        | BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]\ :sub:`opt`
        | BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]

    BindingPattern[Yield, Await] : 
        | ObjectBindingPattern[?Yield, ?Await]
        | ArrayBindingPattern[?Yield, ?Await]

    ObjectBindingPattern[Yield, Await] : 
        | { }
        | { BindingRestProperty[?Yield, ?Await] }
        | { BindingPropertyList[?Yield, ?Await] }
        | { BindingPropertyList[?Yield, ?Await] , BindingRestProperty[?Yield, ?Await]\ :sub:`opt` }

    ArrayBindingPattern[Yield, Await] : 
        | [ Elision\ :sub:`opt` BindingRestElement[?Yield, ?Await]\ :sub:`opt` ]
        | [ BindingElementList[?Yield, ?Await] ]
        | [ BindingElementList[?Yield, ?Await] , Elision\ :sub:`opt` BindingRestElement[?Yield, ?Await]\ :sub:`opt` ]

    BindingRestProperty[Yield, Await] : 
        | ... BindingIdentifier[?Yield, ?Await]

    BindingPropertyList[Yield, Await] : 
        | BindingProperty[?Yield, ?Await]
        | BindingPropertyList[?Yield, ?Await] , BindingProperty[?Yield, ?Await]

    BindingElementList[Yield, Await] : 
        | BindingElisionElement[?Yield, ?Await]
        | BindingElementList[?Yield, ?Await] , BindingElisionElement[?Yield, ?Await]

    BindingElisionElement[Yield, Await] : 
        | Elision\ :sub:`opt` BindingElement[?Yield, ?Await]

    BindingProperty[Yield, Await] : 
        | SingleNameBinding[?Yield, ?Await]
        | PropertyName[?Yield, ?Await] : BindingElement[?Yield, ?Await]

    BindingElement[Yield, Await] : 
        | SingleNameBinding[?Yield, ?Await]
        | BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]\ :sub:`opt`

    SingleNameBinding[Yield, Await] : 
        | BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]\ :sub:`opt`

    BindingRestElement[Yield, Await] : 
        | ... BindingIdentifier[?Yield, ?Await]
        | ... BindingPattern[?Yield, ?Await]

    EmptyStatement : 
        | ;

    ExpressionStatement[Yield, Await] : 
        | [lookahead ∉ { {, function, async [no LineTerminator here] function, class, let [ }] Expression[+In, ?Yield, ?Await] ;

    IfStatement[Yield, Await, Return] : 
        | if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] else Statement[?Yield, ?Await, ?Return]
        | if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] [lookahead ≠ else]

    IterationStatement[Yield, Await, Return] : 
        | DoWhileStatement[?Yield, ?Await, ?Return]
        | WhileStatement[?Yield, ?Await, ?Return]
        | ForStatement[?Yield, ?Await, ?Return]
        | ForInOfStatement[?Yield, ?Await, ?Return]

    DoWhileStatement[Yield, Await, Return] : 
        | do Statement[?Yield, ?Await, ?Return] while ( Expression[+In, ?Yield, ?Await] ) ;

    WhileStatement[Yield, Await, Return] : 
        | while ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]

    ForStatement[Yield, Await, Return] : 
        | for ( [lookahead ≠ let [] Expression[~In, ?Yield, ?Await]\ :sub:`opt` ; Expression[+In, ?Yield, ?Await]\ :sub:`opt` ;
        |     Expression[+In, ?Yield, ?Await]\ :sub:`opt` ) Statement[?Yield, ?Await, ?Return]
        | for ( var VariableDeclarationList[~In, ?Yield, ?Await] ; Expression[+In, ?Yield, ?Await]\ :sub:`opt` ; 
        |     Expression[+In, ?Yield, ?Await]\ :sub:`opt` ) Statement[?Yield, ?Await, ?Return]
        | for ( LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]\ :sub:`opt` ;
        |     Expression[+In, ?Yield, ?Await]\ :sub:`opt` ) Statement[?Yield, ?Await, ?Return]

    ForInOfStatement[Yield, Await, Return] : 
        | for ( [lookahead ≠ let [] LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | for ( var ForBinding[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | for ( ForDeclaration[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | for ( [lookahead ∉ { let, async of }] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | for ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | for ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | [+Await] for await ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | [+Await] for await ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]
        | [+Await] for await ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] )
        |     Statement[?Yield, ?Await, ?Return]

    ForDeclaration[Yield, Await] : 
        | LetOrConst ForBinding[?Yield, ?Await]

    ForBinding[Yield, Await] : 
        | BindingIdentifier[?Yield, ?Await]
        | BindingPattern[?Yield, ?Await]

    ContinueStatement[Yield, Await] : 
        | continue ;
        | continue [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;

    BreakStatement[Yield, Await] : 
        | break ;
        | break [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;

    ReturnStatement[Yield, Await] : 
        | return ;
        | return [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;

    WithStatement[Yield, Await, Return] : 
        | with ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]

    SwitchStatement[Yield, Await, Return] : 
        | switch ( Expression[+In, ?Yield, ?Await] ) CaseBlock[?Yield, ?Await, ?Return]

    CaseBlock[Yield, Await, Return] : 
        | { CaseClauses[?Yield, ?Await, ?Return]\ :sub:`opt` }
        | { CaseClauses[?Yield, ?Await, ?Return]\ :sub:`opt` DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]\ :sub:`opt` }

    CaseClauses[Yield, Await, Return] : 
        | CaseClause[?Yield, ?Await, ?Return]
        | CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]

    CaseClause[Yield, Await, Return] : 
        | case Expression[+In, ?Yield, ?Await] : StatementList[?Yield, ?Await, ?Return]\ :sub:`opt`

    DefaultClause[Yield, Await, Return] : 
        | default : StatementList[?Yield, ?Await, ?Return]\ :sub:`opt`

    LabelledStatement[Yield, Await, Return] : 
        | LabelIdentifier[?Yield, ?Await] : LabelledItem[?Yield, ?Await, ?Return]

    LabelledItem[Yield, Await, Return] : 
        | Statement[?Yield, ?Await, ?Return] FunctionDeclaration[?Yield, ?Await, ~Default]

    ThrowStatement[Yield, Await] : 
        | throw [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;

    TryStatement[Yield, Await, Return] : 
        | try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
        | try Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
        | try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]

    Catch[Yield, Await, Return] : 
        | catch ( CatchParameter[?Yield, ?Await] ) Block[?Yield, ?Await, ?Return]
        | catch Block[?Yield, ?Await, ?Return]

    Finally[Yield, Await, Return] : 
        | finally Block[?Yield, ?Await, ?Return]

    CatchParameter[Yield, Await] : 
        | BindingIdentifier[?Yield, ?Await]
        | BindingPattern[?Yield, ?Await]

    DebuggerStatement : 
        | debugger ;


A.4 Functions and Classes
-------------------------


    UniqueFormalParameters[Yield, Await] : 
        | FormalParameters[?Yield, ?Await]

    FormalParameters[Yield, Await] : 
        | [empty]
        | FunctionRestParameter[?Yield, ?Await]
        | FormalParameterList[?Yield, ?Await]
        | FormalParameterList[?Yield, ?Await] , 
        | FormalParameterList[?Yield, ?Await] , FunctionRestParameter[?Yield, ?Await]

    FormalParameterList[Yield, Await] : 
        | FormalParameter[?Yield, ?Await]
        | FormalParameterList[?Yield, ?Await] , FormalParameter[?Yield, ?Await]

    FunctionRestParameter[Yield, Await] : 
        | BindingRestElement[?Yield, ?Await]

    FormalParameter[Yield, Await] : 
        | BindingElement[?Yield, ?Await]

    FunctionDeclaration[Yield, Await, Default] : 
        | function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
        | [+Default] function ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }

    FunctionExpression : 
        | function BindingIdentifier[~Yield, ~Await]\ :sub:`opt` ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }

    FunctionBody[Yield, Await] : 
        | FunctionStatementList[?Yield, ?Await]

    FunctionStatementList[Yield, Await] : 
        | StatementList[?Yield, ?Await, +Return]\ :sub:`opt`

    ArrowFunction[In, Yield, Await] : 
        | ArrowParameters[?Yield, ?Await] [no LineTerminator here] => ConciseBody[?In]

    ArrowParameters[Yield, Await] : 
        | BindingIdentifier[?Yield, ?Await]
        | CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

    ConciseBody[In] : 
        | [lookahead ≠ {] ExpressionBody[?In, ~Await]
        | { FunctionBody[~Yield, ~Await] }

    ExpressionBody[In, Await] : 
        | AssignmentExpression[?In, ~Yield, ?Await]

    When processing an instance of the production

    |   ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

    the interpretation of CoverParenthesizedExpressionAndArrowParameterList is refined 
    using the following grammar:

    ArrowFormalParameters[Yield, Await] : 
        | ( UniqueFormalParameters[?Yield, ?Await] )

    AsyncArrowFunction[In, Yield, Await] : 
        | async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]
        | CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]

    AsyncConciseBody[In] : 
        | [lookahead ≠ {] ExpressionBody[?In, +Await]
        | { AsyncFunctionBody }

    AsyncArrowBindingIdentifier[Yield] : 
        | BindingIdentifier[?Yield, +Await]

    CoverCallExpressionAndAsyncArrowHead[Yield, Await] : 
        | MemberExpression[?Yield, ?Await]
        | Arguments[?Yield, ?Await]

    When processing an instance of the production

    |    AsyncArrowFunction[In, Yield, Await] : CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]

    the interpretation of CoverCallExpressionAndAsyncArrowHead is refined using the following grammar:

    AsyncArrowHead : 
        | async [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]

    MethodDefinition[Yield, Await] : 
        | ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
        | GeneratorMethod[?Yield, ?Await]
        | AsyncMethod[?Yield, ?Await]
        | AsyncGeneratorMethod[?Yield, ?Await]
        | get ClassElementName[?Yield, ?Await] ( ) { FunctionBody[~Yield, ~Await] }
        | set ClassElementName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }

    PropertySetParameterList : 
        | FormalParameter[~Yield, ~Await]

    GeneratorDeclaration[Yield, Await, Default] : 
        | function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
        | [+Default] function * ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }

    GeneratorExpression : 
        | function * BindingIdentifier[+Yield, ~Await]\ :sub:`opt` ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }

    GeneratorMethod[Yield, Await] : 
        | * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, ~Await] ) { GeneratorBody }

    GeneratorBody : 
        | FunctionBody[+Yield, ~Await]

    YieldExpression[In, Await] : 
        | yield
        | yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        | yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await]

    AsyncGeneratorDeclaration[Yield, Await, Default] : 
        | async [no LineTerminator here] function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }
        | [+Default] async [no LineTerminator here] function * ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }

    AsyncGeneratorExpression : 
        | async [no LineTerminator here] function * BindingIdentifier[+Yield, +Await]\ :sub:`opt` ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }

    AsyncGeneratorMethod[Yield, Await] : 
        | async [no LineTerminator here] * ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, +Await] ) { AsyncGeneratorBody }

    AsyncGeneratorBody : 
        | FunctionBody[+Yield, +Await]

    AsyncFunctionDeclaration[Yield, Await, Default] : 
        | async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }
        | [+Default] async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }

    AsyncFunctionExpression : 
        | async [no LineTerminator here] function BindingIdentifier[~Yield, +Await]\ :sub:`opt` ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }

    AsyncMethod[Yield, Await] : 
        | async [no LineTerminator here] ClassElementName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, +Await] ) { AsyncFunctionBody }

    AsyncFunctionBody : 
        | FunctionBody[~Yield, +Await]

    AwaitExpression[Yield] : 
        | await UnaryExpression[?Yield, +Await]

    ClassDeclaration[Yield, Await, Default] : 
        | class BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        | [+Default] class ClassTail[?Yield, ?Await]

    ClassExpression[Yield, Await] : 
        | class BindingIdentifier[?Yield, ?Await]\ :sub:`opt` ClassTail[?Yield, ?Await]

    ClassTail[Yield, Await] : 
        | ClassHeritage[?Yield, ?Await]\ :sub:`opt` { ClassBody[?Yield, ?Await]\ :sub:`opt` }

    ClassHeritage[Yield, Await] : 
        | extends LeftHandSideExpression[?Yield, ?Await]

    ClassBody[Yield, Await] : 
        | ClassElementList[?Yield, ?Await]

    ClassElementList[Yield, Await] : 
        | ClassElement[?Yield, ?Await]
        | ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

    ClassElement[Yield, Await] : 
        | MethodDefinition[?Yield, ?Await]
        | static MethodDefinition[?Yield, ?Await]
        | FieldDefinition[?Yield, ?Await] ;
        | static FieldDefinition[?Yield, ?Await] ;
        | ClassStaticBlock
        | ;

    FieldDefinition[Yield, Await] : 
        | ClassElementName[?Yield, ?Await]
        | Initializer[+In, ?Yield, ?Await]\ :sub:`opt`

    ClassElementName[Yield, Await] : 
        | PropertyName[?Yield, ?Await]
        | PrivateIdentifier

    ClassStaticBlock : 
        | static { ClassStaticBlockBody }

    ClassStaticBlockBody : 
        | ClassStaticBlockStatementList

    ClassStaticBlockStatementList : 
        | StatementList[~Yield, +Await, ~Return]\ :sub:`opt`

 

A.5 Scripts and Modules
-----------------------


    Script : 
        | ScriptBody\ :sub:`opt`

    ScriptBody : 
        | StatementList[~Yield, ~Await, ~Return]

    Module : 
        | ModuleBody\ :sub:`opt`

    ModuleBody : 
        | ModuleItemList

    ModuleItemList : 
        | ModuleItem
        | ModuleItemList ModuleItem

    ModuleItem : 
        | ImportDeclaration
        | ExportDeclaration
        | StatementListItem[~Yield, +Await, ~Return]

    ModuleExportName : 
        | IdentifierName
        | StringLiteral

    ImportDeclaration : 
        | import ImportClause FromClause ;
        | import ModuleSpecifier ;

    ImportClause : 
        | ImportedDefaultBinding
        | NameSpaceImport
        | NamedImports
        | ImportedDefaultBinding , NameSpaceImport
        | ImportedDefaultBinding , NamedImports

    ImportedDefaultBinding : 
        | ImportedBinding

    NameSpaceImport : 
        | * as ImportedBinding

    NamedImports : 
        | { }
        | { ImportsList }
        | { ImportsList , }

    FromClause : 
        | from ModuleSpecifier

    ImportsList : 
        | ImportSpecifier
        | ImportsList , ImportSpecifier

    ImportSpecifier : 
        | ImportedBinding
        | ModuleExportName as ImportedBinding

    ModuleSpecifier : 
        | StringLiteral

    ImportedBinding : 
        | BindingIdentifier[~Yield, +Await]

    ExportDeclaration : 
        | export ExportFromClause FromClause ;
        | export NamedExports ;
        | export VariableStatement[~Yield, +Await]
        | export Declaration[~Yield, +Await]
        | export default HoistableDeclaration[~Yield, +Await, +Default]
        | export default ClassDeclaration[~Yield, +Await, +Default]
        | export default [lookahead ∉ { function, async [no LineTerminator here] function, class }] 
        |     AssignmentExpression[+In, ~Yield, +Await] ;

    ExportFromClause : 
        | *
        | * as ModuleExportName
        | NamedExports

    NamedExports : 
        | { }
        | { ExportsList }
        | { ExportsList , }

    ExportsList : 
        | ExportSpecifier
        | ExportsList , ExportSpecifier

    ExportSpecifier : 
        | ModuleExportName
        | ModuleExportName as ModuleExportName


A.6 Number Conversions
----------------------


    StringNumericLiteral ::: 
        | StrWhiteSpace\ :sub:`opt`
        | StrWhiteSpace\ :sub:`opt` StrNumericLiteral StrWhiteSpace\ :sub:`opt`

    StrWhiteSpace ::: 
        | StrWhiteSpaceChar StrWhiteSpace\ :sub:`opt`

    StrWhiteSpaceChar ::: 
        | WhiteSpace
        | LineTerminator

    StrNumericLiteral ::: 
        | StrDecimalLiteral
        | NonDecimalIntegerLiteral[~Sep]

    StrDecimalLiteral ::: 
        | StrUnsignedDecimalLiteral
        | + StrUnsignedDecimalLiteral
        | - StrUnsignedDecimalLiteral

    StrUnsignedDecimalLiteral ::: 
        | Infinity
        | DecimalDigits[~Sep] . DecimalDigits[~Sep]\ :sub:`opt` ExponentPart[~Sep]\ :sub:`opt` 
        | . DecimalDigits[~Sep] ExponentPart[~Sep]\ :sub:`opt`
        | DecimalDigits[~Sep] ExponentPart[~Sep]\ :sub:`opt`

    All grammar symbols not explicitly defined by the StringNumericLiteral grammar 
    have the definitions used in the Lexical Grammar for numeric literals.

    StringIntegerLiteral ::: 
        | StrWhiteSpace\ :sub:`opt`
        | StrWhiteSpace\ :sub:`opt` StrIntegerLiteral StrWhiteSpace\ :sub:`opt`

    StrIntegerLiteral ::: 
        | SignedInteger[~Sep]
        | NonDecimalIntegerLiteral[~Sep]


A.7 Time Zone Offset String Format
----------------------------------

    UTCOffset ::: 
        | ASCIISign Hour
        | ASCIISign Hour HourSubcomponents[+Extended]
        | ASCIISign Hour HourSubcomponents[~Extended]

    ASCIISign ::: one of + -

    Hour ::: 
        | 0 DecimalDigit
        | 1 DecimalDigit
        | 20
        | 21
        | 22
        | 23

    HourSubcomponents[Extended] ::: 
        | TimeSeparator[?Extended] MinuteSecond
        | TimeSeparator[?Extended] MinuteSecond TimeSeparator[?Extended] MinuteSecond TemporalDecimalFraction\ :sub:`opt`

    TimeSeparator[Extended] ::: 
        | [+Extended] :
        | [~Extended] [empty]

    MinuteSecond ::: 
        | 0 DecimalDigit
        | 1 DecimalDigit
        | 2 DecimalDigit
        | 3 DecimalDigit
        | 4 DecimalDigit
        | 5 DecimalDigit

    TemporalDecimalFraction ::: 
        | TemporalDecimalSeparator DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
        | TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

    TemporalDecimalSeparator ::: one of 
        | . ,


A.8 Regular Expressions
-----------------------


    Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: 
        | Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

    Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: 
        | Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
        | Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] | Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

    Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: 
        | [empty]
        | Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

    Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: 
        | Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
        | Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
        | Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier

    Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: 
        | ^
        | $
        | \\b
        | \\B
        | (?= Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
        | (?! Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
        | (?<= Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
        | (?<! Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )

    Quantifier :: 
        | QuantifierPrefix
        | QuantifierPrefix ?

    QuantifierPrefix :: 
        | *
        | +
        | ?
        | { DecimalDigits[~Sep] }
        | { DecimalDigits[~Sep] ,}
        | { DecimalDigits[~Sep] , DecimalDigits[~Sep] }

    Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: 
        | PatternCharacter
        | .
        | \\ AtomEscape[?UnicodeMode, ?NamedCaptureGroups]
        | CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
        | ( GroupSpecifier[?UnicodeMode]\ :sub:`opt` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )
        | (?: Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] )

    SyntaxCharacter :: one of 
        | ^ $ \\ . * + ? ( ) [ ] { } |

    PatternCharacter :: 
        | SourceCharacter but not SyntaxCharacter

    AtomEscape[UnicodeMode, NamedCaptureGroups] :: 
        | DecimalEscape
        | CharacterClassEscape[?UnicodeMode]
        | CharacterEscape[?UnicodeMode]
        | [+NamedCaptureGroups] k GroupName[?UnicodeMode]

    CharacterEscape[UnicodeMode] :: 
        | ControlEscape
        | c AsciiLetter
        | 0 [lookahead ∉ DecimalDigit]
        | HexEscapeSequence
        | RegExpUnicodeEscapeSequence[?UnicodeMode]
        | IdentityEscape[?UnicodeMode]

    ControlEscape :: one of 
        | f n r t v

    GroupSpecifier[UnicodeMode] :: 
        | ? GroupName[?UnicodeMode]

    GroupName[UnicodeMode] :: 
        | < RegExpIdentifierName[?UnicodeMode] >

    RegExpIdentifierName[UnicodeMode] :: 
        | RegExpIdentifierStart[?UnicodeMode]
        | RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]

    RegExpIdentifierStart[UnicodeMode] :: 
        | IdentifierStartChar
        | \\ RegExpUnicodeEscapeSequence[+UnicodeMode]
        | [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

    RegExpIdentifierPart[UnicodeMode] :: 
        | IdentifierPartChar
        | \\ RegExpUnicodeEscapeSequence[+UnicodeMode]
        | [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

    RegExpUnicodeEscapeSequence[UnicodeMode] :: 
        | [+UnicodeMode] u HexLeadSurrogate \\u HexTrailSurrogate
        | [+UnicodeMode] u HexLeadSurrogate
        | [+UnicodeMode] u HexTrailSurrogate
        | [+UnicodeMode] u HexNonSurrogate
        | [~UnicodeMode] u Hex4Digits
        | [+UnicodeMode] u{ CodePoint }

    UnicodeLeadSurrogate :: 
        | any Unicode code point in the inclusive interval from U+D800 to U+DBFF

    UnicodeTrailSurrogate :: 
        | any Unicode code point in the inclusive interval from U+DC00 to U+DFFF

    Each \\u HexTrailSurrogate for which the choice of associated u HexLeadSurrogate 
    is ambiguous shall be associated with the nearest possible u HexLeadSurrogate 
    that would otherwise have no corresponding \\u HexTrailSurrogate.

    HexLeadSurrogate :: 
        | Hex4Digits but only if the MV of Hex4Digits is in the inclusive interval from 0xD800 to 0xDBFF

    HexTrailSurrogate :: 
        | Hex4Digits but only if the MV of Hex4Digits is in the inclusive interval from 0xDC00 to 0xDFFF

    HexNonSurrogate :: 
        | Hex4Digits but only if the MV of Hex4Digits is not in the inclusive interval from 0xD800 to 0xDFFF

    IdentityEscape[UnicodeMode] :: 
        | [+UnicodeMode] SyntaxCharacter
        | [+UnicodeMode] /
        | [~UnicodeMode] SourceCharacter but not UnicodeIDContinue

    DecimalEscape :: 
        | NonZeroDigit DecimalDigits[~Sep]\ :sub:`opt` [lookahead ∉ DecimalDigit]

    CharacterClassEscape[UnicodeMode] :: 
        | d
        | D
        | s
        | S
        | w
        | W
        | [+UnicodeMode] p{ UnicodePropertyValueExpression }
        | [+UnicodeMode] P{ UnicodePropertyValueExpression }

    UnicodePropertyValueExpression :: 
        | UnicodePropertyName = UnicodePropertyValue
        | LoneUnicodePropertyNameOrValue

    UnicodePropertyName :: 
        | UnicodePropertyNameCharacters

    UnicodePropertyNameCharacters :: 
        | UnicodePropertyNameCharacter UnicodePropertyNameCharacters\ :sub:`opt`

    UnicodePropertyValue :: 
        | UnicodePropertyValueCharacters

    LoneUnicodePropertyNameOrValue :: 
        | UnicodePropertyValueCharacters

    UnicodePropertyValueCharacters :: 
        | UnicodePropertyValueCharacter UnicodePropertyValueCharacters\ :sub:`opt`

    UnicodePropertyValueCharacter :: 
        | UnicodePropertyNameCharacter
        | DecimalDigit

    UnicodePropertyNameCharacter :: 
        | AsciiLetter
        | _

    CharacterClass[UnicodeMode, UnicodeSetsMode] :: 
        | [ [lookahead ≠ ^] ClassContents[?UnicodeMode, ?UnicodeSetsMode] ]
        | [^ ClassContents[?UnicodeMode, ?UnicodeSetsMode] ]

    ClassContents[UnicodeMode, UnicodeSetsMode] :: 
        | [empty]
        | [~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode]
        | [+UnicodeSetsMode] ClassSetExpression

    NonemptyClassRanges[UnicodeMode] :: 
        | ClassAtom[?UnicodeMode]
        | ClassAtom[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
        | ClassAtom[?UnicodeMode] - ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

    NonemptyClassRangesNoDash[UnicodeMode] :: 
        | ClassAtom[?UnicodeMode]
        | ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
        | ClassAtomNoDash[?UnicodeMode] - ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

    ClassAtom[UnicodeMode] :: 
        | -
        | ClassAtomNoDash[?UnicodeMode]

    ClassAtomNoDash[UnicodeMode] :: 
        | SourceCharacter but not one of \\ or ] or -
        | \\ ClassEscape[?UnicodeMode]

    ClassEscape[UnicodeMode] :: 
        | b
        | [+UnicodeMode] -
        | CharacterClassEscape[?UnicodeMode]
        | CharacterEscape[?UnicodeMode]

    ClassSetExpression :: 
        | ClassUnion
        | ClassIntersection
        | ClassSubtraction

    ClassUnion :: 
        | ClassSetRange ClassUnion\ :sub:`opt`
        | ClassSetOperand ClassUnion\ :sub:`opt`

    ClassIntersection :: 
        | ClassSetOperand && [lookahead ≠ &] ClassSetOperand
        | ClassIntersection && [lookahead ≠ &] ClassSetOperand

    ClassSubtraction :: 
        | ClassSetOperand -- ClassSetOperand
        | ClassSubtraction -- ClassSetOperand

    ClassSetRange :: 
        | ClassSetCharacter - ClassSetCharacter

    ClassSetOperand :: 
        | NestedClass
        | ClassStringDisjunction
        | ClassSetCharacter

    NestedClass :: 
        | [ [lookahead ≠ ^] ClassContents[+UnicodeMode, +UnicodeSetsMode] ]
        | [^ ClassContents[+UnicodeMode, +UnicodeSetsMode] ]
        | \\ CharacterClassEscape[+UnicodeMode]

    ClassStringDisjunction :: 
        | \\q{ ClassStringDisjunctionContents }

    ClassStringDisjunctionContents :: 
        | ClassString
        | ClassString | ClassStringDisjunctionContents

    ClassString :: 
        | [empty]
        | NonEmptyClassString

    NonEmptyClassString :: 
        | ClassSetCharacter
        | NonEmptyClassString\ :sub:`opt`

    ClassSetCharacter :: 
        | [lookahead ∉ ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
        | \\ CharacterEscape[+UnicodeMode]
        | \\ ClassSetReservedPunctuator
        | \\b

    ClassSetReservedDoublePunctuator :: one of 
        | ``&& !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~``

    ClassSetSyntaxCharacter :: one of 
        | ( ) [ ] { } / - \\ |

    ClassSetReservedPunctuator :: one of
        | & - ! # % , : ; < = > @ ` ~

 

B Additional ECMAScript Features for Web Browsers
=================================================

https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html
::

   B.1 Additional Syntax
      B.1.1 HTML-like Comments
      B.1.2 Regular Expressions Patterns
         B.1.2.1 SS: Early Errors
         B.1.2.2 SS: CountLeftCapturingParensWithin and CountLeftCapturingParensBefore
         B.1.2.3 SS: IsCharacterClass
         B.1.2.4 SS: CharacterValue
         B.1.2.5 RS: CompileSubpattern
         B.1.2.6 RS: CompileAssertion
         B.1.2.7 RS: CompileAtom
         B.1.2.8 RS: CompileToCharSet
            B.1.2.8.1 CharacterRangeOrUnion ( rer, A, B )
         B.1.2.9 SS: ParsePattern ( patternText, u, v )
   B.2 Additional Built-in Properties
      B.2.1 Additional Properties of the Global Object
         B.2.1.1 escape ( string )
         B.2.1.2 unescape ( string )
      B.2.2 Additional Properties of the String.prototype Object
         B.2.2.1 String.prototype.substr ( start, length )
         B.2.2.2 String.prototype.anchor ( name )
            B.2.2.2.1 CreateHTML ( string, tag, attribute, value )
         B.2.2.3 String.prototype.big ( )
         B.2.2.4 String.prototype.blink ( )
         B.2.2.5 String.prototype.bold ( )
         B.2.2.6 String.prototype.fixed ( )
         B.2.2.7 String.prototype.fontcolor ( colour )
         B.2.2.8 String.prototype.fontsize ( size )
         B.2.2.9 String.prototype.italics ( )
         B.2.2.10 String.prototype.link ( url )
         B.2.2.11 String.prototype.small ( )
         B.2.2.12 String.prototype.strike ( )
         B.2.2.13 String.prototype.sub ( )
         B.2.2.14 String.prototype.sup ( )
         B.2.2.15 String.prototype.trimLeft ( )
         B.2.2.16 String.prototype.trimRight ( )
      B.2.3 Additional Properties of the Date.prototype Object
         B.2.3.1 Date.prototype.getYear ( )
         B.2.3.2 Date.prototype.setYear ( year )
         B.2.3.3 Date.prototype.toGMTString ( )
      B.2.4 Additional Properties of the RegExp.prototype Object
         B.2.4.1 RegExp.prototype.compile ( pattern, flags )
   B.3 Other Additional Features
      B.3.1 Labelled Function Declarations
      B.3.2 Block-Level Function Declarations Web Legacy Compatibility Semantics
         B.3.2.1 Changes to FunctionDeclarationInstantiation
         B.3.2.2 Changes to GlobalDeclarationInstantiation
         B.3.2.3 Changes to EvalDeclarationInstantiation
         B.3.2.4 Changes to Block SS: Early Errors
         B.3.2.5 Changes to switch Statement SS: Early Errors
         B.3.2.6 Changes to BlockDeclarationInstantiation
      B.3.3 FunctionDeclarations in IfStatement Statement Clauses
      B.3.4 VariableStatements in Catch Blocks
      B.3.5 Initializers in ForIn Statement Heads
      B.3.6 The <var class="field">[[IsHTMLDDA]] Internal Slot
         B.3.6.1 Changes to ToBoolean
         B.3.6.2 Changes to IsLooselyEqual
         B.3.6.3 Changes to the typeof Operator
      B.3.7 Non-default behaviour in HostMakeJobCallback
      B.3.8 Non-default behaviour in HostEnsureCanAddPrivateElement

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.

.. Note::

   This annex describes various legacy features and other characteristics
   of web browser ECMAScript hosts. All of the language features and
   behaviours specified in this annex have one or more undesirable
   characteristics and in the absence of legacy usage would be removed from
   this specification. However, the usage of these features by large
   numbers of existing web pages means that web browsers must continue to
   support them. The specifications in this annex define the requirements
   for interoperable implementations of these legacy features.

   These features are not considered part of the core ECMAScript language.
   Programmers should not use or assume the existence of these features and
   behaviours when writing new ECMAScript code. ECMAScript implementations
   are discouraged from implementing these features unless the
   implementation is part of a web browser or is required to run the same
   legacy ECMAScript code that web browsers encounter.

Additional Syntax
''''''-----------

HTML-like Comments
------------------

The syntax and semantics of is extended as follows except that this
extension is not allowed when parsing source text using the goal symbol
`Module`:


**Syntax**


InputElementHashbangOrRegExp :: WhiteSpace LineTerminator Comment
CommonToken HashbangComment RegularExpressionLiteral HTMLCloseComment
Comment :: MultiLineComment SingleLineComment SingleLineHTMLOpenComment
SingleLineHTMLCloseComment SingleLineDelimitedComment MultiLineComment
:: `/`` FirstCommentLine? LineTerminator MultiLineCommentChars?
`*/` HTMLCloseComment? FirstCommentLine ::
SingleLineDelimitedCommentChars SingleLineHTMLOpenComment :: `<!--`
SingleLineCommentChars? SingleLineHTMLCloseComment ::
LineTerminatorSequence HTMLCloseComment SingleLineDelimitedComment ::
`/`` SingleLineDelimitedCommentChars? `*/` HTMLCloseComment ::
WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `-->`
SingleLineCommentChars? SingleLineDelimitedCommentChars ::
SingleLineNotAsteriskChar SingleLineDelimitedCommentChars? `*`
SingleLinePostAsteriskCommentChars? SingleLineNotAsteriskChar ::
SourceCharacter but not one of `*` or LineTerminator
SingleLinePostAsteriskCommentChars ::
SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
`*` SingleLinePostAsteriskCommentChars?
SingleLineNotForwardSlashOrAsteriskChar :: SourceCharacter but not one
of `/` or `*` or LineTerminator WhiteSpaceSequence :: WhiteSpace
WhiteSpaceSequence? SingleLineDelimitedCommentSequence ::
SingleLineDelimitedComment WhiteSpaceSequence?
SingleLineDelimitedCommentSequence?

Similar to a `MultiLineComment` that contains a line terminator code
point, a \|SingleLineHTMLCloseComment\| is considered to be a
`LineTerminator` for purposes of parsing by the syntactic grammar.

Regular Expressions Patterns
----------------------------

The syntax of is modified and extended as follows. These changes
introduce ambiguities that are broken by the ordering of grammar
productions and by contextual information. When parsing using the
following grammar, each alternative is considered only if previous
production alternatives do not match.

This alternative pattern grammar and semantics only changes the syntax
and semantics of BMP patterns. The following grammar extensions include
productions parameterized with the [UnicodeMode] parameter. However,
none of these extensions change the syntax of Unicode patterns
recognized when parsing with the [UnicodeMode] parameter present on the
goal symbol.


**Syntax**


Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] :: [+UnicodeMode]
Assertion[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
[+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Quantifier [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode,
?NamedCaptureGroups] [~UnicodeMode]
QuantifiableAssertion[?NamedCaptureGroups] Quantifier [~UnicodeMode]
Assertion[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
[~UnicodeMode] ExtendedAtom[?NamedCaptureGroups] Quantifier
[~UnicodeMode] ExtendedAtom[?NamedCaptureGroups] Assertion[UnicodeMode,
UnicodeSetsMode, NamedCaptureGroups] :: `^` `$` `\\b` `\\B`
[+UnicodeMode] `(?=` Disjunction[+UnicodeMode, ?UnicodeSetsMode,
?NamedCaptureGroups] `)` [+UnicodeMode] `(?!`
Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
[~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups] `(?<=`
Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
`(?<!` Disjunction[?UnicodeMode, ?UnicodeSetsMode,
?NamedCaptureGroups] `)` QuantifiableAssertion[NamedCaptureGroups] ::
`(?=` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
`)` `(?!` Disjunction[~UnicodeMode, ~UnicodeSetsMode,
?NamedCaptureGroups] `)` ExtendedAtom[NamedCaptureGroups] :: `.`
`\\` AtomEscape[~UnicodeMode, ?NamedCaptureGroups] `\\` [lookahead
== `c`] CharacterClass[~UnicodeMode, ~UnicodeSetsMode] `(`
GroupSpecifier[~UnicodeMode]? Disjunction[~UnicodeMode,
~UnicodeSetsMode, ?NamedCaptureGroups] `)` `(?:`
Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
InvalidBracedQuantifier ExtendedPatternCharacter InvalidBracedQuantifier
:: `{` DecimalDigits[~Sep] `}` `{` DecimalDigits[~Sep] `,}`
`{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`
ExtendedPatternCharacter :: SourceCharacter but not one of `^` `$`
`\\` `.` `*` `+` `?` `(` `)` `[` `|`
AtomEscape[UnicodeMode, NamedCaptureGroups] :: [+UnicodeMode]
DecimalEscape [~UnicodeMode] DecimalEscape [> but only if the
CapturingGroupNumber of `DecimalEscape` is ≤
CountLeftCapturingParensWithin(the `Pattern` containing
`DecimalEscape`)] CharacterClassEscape[?UnicodeMode]
CharacterEscape[?UnicodeMode, ?NamedCaptureGroups] [+NamedCaptureGroups]
`k` GroupName[?UnicodeMode] CharacterEscape[UnicodeMode,
NamedCaptureGroups] :: ControlEscape `c` AsciiLetter `0` [lookahead
∉ DecimalDigit] HexEscapeSequence
RegExpUnicodeEscapeSequence[?UnicodeMode] [~UnicodeMode]
LegacyOctalEscapeSequence IdentityEscape[?UnicodeMode,
?NamedCaptureGroups] IdentityEscape[UnicodeMode, NamedCaptureGroups] ::
[+UnicodeMode] SyntaxCharacter [+UnicodeMode] `/` [~UnicodeMode]
SourceCharacterIdentityEscape[?NamedCaptureGroups]
SourceCharacterIdentityEscape[NamedCaptureGroups] ::
[~NamedCaptureGroups] SourceCharacter but not `c`
[+NamedCaptureGroups] SourceCharacter but not one of `c` or `k`
ClassAtomNoDash[UnicodeMode, NamedCaptureGroups] :: SourceCharacter but
not one of `\\` or `]` or `-` `\\` ClassEscape[?UnicodeMode,
?NamedCaptureGroups] `\\` [lookahead == `c`]
ClassEscape[UnicodeMode, NamedCaptureGroups] :: `b` [+UnicodeMode]
`-` [~UnicodeMode] `c` ClassControlLetter
CharacterClassEscape[?UnicodeMode] CharacterEscape[?UnicodeMode,
?NamedCaptureGroups] ClassControlLetter :: DecimalDigit ``

When the same left-hand sides occurs with both [+UnicodeMode] and
[\\~UnicodeMode] guards it is to control the disambiguation priority.


Static Semantics: Early Errors
------------------------------

The semantics of is extended as follows:

ExtendedAtom :: InvalidBracedQuantifier

- It is a Syntax Error if any source text is matched by this production.

Additionally, the rules for the following productions are modified with
the addition of the *highlighted* text:

NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents

- It is a Syntax Error if IsCharacterClass of the first `ClassAtom` is
  `true` or IsCharacterClass of the second `ClassAtom` is `true`
  *and this production has a [UnicodeMode] parameter*.
- It is a Syntax Error if IsCharacterClass of the first `ClassAtom` is
  `false`, IsCharacterClass of the second `ClassAtom` is `false`,
  and the CharacterValue of the first `ClassAtom` is strictly greater
  than the CharacterValue of the second `ClassAtom`.

NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom
ClassContents

- It is a Syntax Error if IsCharacterClass of `ClassAtomNoDash` is
  `true` or IsCharacterClass of `ClassAtom` is `true` *and this
  production has a [UnicodeMode] parameter*.
- It is a Syntax Error if IsCharacterClass of `ClassAtomNoDash` is
  `false`, IsCharacterClass of `ClassAtom` is `false`, and the
  CharacterValue of `ClassAtomNoDash` is strictly greater than the
  CharacterValue of `ClassAtom`.

Static Semantics: CountLeftCapturingParensWithin and CountLeftCapturingParensBefore
-----------------------------------------------------------------------------------

In the definitions of CountLeftCapturingParensWithin and
CountLeftCapturingParensBefore, references to “Atom :: `(`
GroupSpecifier? Disjunction `)` ” are to be interpreted as meaning
“Atom :: `(` GroupSpecifier? Disjunction `)` ” or “ExtendedAtom ::
`(` GroupSpecifier? Disjunction `)` ”.

Static Semantics: IsCharacterClass
----------------------------------

The semantics of is extended as follows:

ClassAtomNoDash :: `\\` [lookahead == `c`] 1. Return `false`.

Static Semantics: CharacterValue
--------------------------------

The semantics of is extended as follows:

ClassAtomNoDash :: `\\` [lookahead == `c`] 1. Return the numeric
value of U+005C (REVERSE SOLIDUS). ClassEscape :: `c`
ClassControlLetter 1. Let ch be the code point matched by
`ClassControlLetter`. 1. Let i be the numeric value of ch. 1.
Return the remainder of dividing i by 32. CharacterEscape ::
LegacyOctalEscapeSequence 1. Return the MV of
`LegacyOctalEscapeSequence` (see ).

Runtime Semantics: CompileSubpattern
------------------------------------

The semantics of CompileSubpattern is extended as follows:

The rule for Term :: QuantifiableAssertion Quantifier is the same as for
Term :: Atom Quantifier but with `QuantifiableAssertion` substituted
for `Atom`.

The rule for Term :: ExtendedAtom Quantifier is the same as for Term ::
Atom Quantifier but with `ExtendedAtom` substituted for `Atom`.

The rule for Term :: ExtendedAtom is the same as for Term :: Atom but
with `ExtendedAtom` substituted for `Atom`.

Runtime Semantics: CompileAssertion
-----------------------------------

CompileAssertion rules for the Assertion :: `(?=` Disjunction `)`
and Assertion :: `(?!` Disjunction `)` productions are also used for
the `QuantifiableAssertion` productions, but with
`QuantifiableAssertion` substituted for `Assertion`.

Runtime Semantics: CompileAtom
------------------------------

CompileAtom rules for the `Atom` productions except for Atom ::
PatternCharacter are also used for the `ExtendedAtom` productions, but
with `ExtendedAtom` substituted for `Atom`. The following rules,
with parameter direction, are also added:

ExtendedAtom :: `\\` [lookahead == `c`] 1. Let A be the CharSet
containing the single character `\\\\` U+005C (REVERSE SOLIDUS). 1.
Return CharacterSetMatcher(rer, A, `false`, direction).
ExtendedAtom :: ExtendedPatternCharacter 1. Let ch be the character
represented by `ExtendedPatternCharacter`. 1. Let A be a
one-element CharSet containing the character ch. 1. Return
CharacterSetMatcher(rer, A, `false`, direction).

Runtime Semantics: CompileToCharSet
-----------------------------------

The semantics of is extended as follows:

The following two rules replace the corresponding rules of
CompileToCharSet.

NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents 1. Let
A be CompileToCharSet of the first `ClassAtom` with argument
rer. 1. Let B be CompileToCharSet of the second `ClassAtom`
with argument rer. 1. Let C be CompileToCharSet of
`ClassContents` with argument rer. 1. Let D be
CharacterRangeOrUnion(rer, A, B). 1. Return the union of
D and C. NonemptyClassRangesNoDash :: ClassAtomNoDash `-`
ClassAtom ClassContents 1. Let A be CompileToCharSet of
`ClassAtomNoDash` with argument rer. 1. Let B be
CompileToCharSet of `ClassAtom` with argument rer. 1. Let C be
CompileToCharSet of `ClassContents` with argument rer. 1. Let
D be CharacterRangeOrUnion(rer, A, B). 1. Return the
union of D and C.

In addition, the following rules are added to CompileToCharSet.

ClassEscape :: `c` ClassControlLetter 1. Let cv be the
CharacterValue of this `ClassEscape`. 1. Let c be the character
whose character value is cv. 1. Return the CharSet containing the
single character c. ClassAtomNoDash :: `\\` [lookahead == `c`]
1. Return the CharSet containing the single character `\\\\` U+005C
(REVERSE SOLIDUS). This production can only be reached from the sequence
`\\c` within a character class where it is not followed by an
acceptable control character.

CharacterRangeOrUnion ( rer: a RegExp Record, A: a CharSet, B: a CharSet, ): a CharSet
--------------------------------------------------------------------------------------------------

1. If HasEitherUnicodeFlag(rer) is `false`, then 1. If A does
not contain exactly one character or B does not contain exactly one
character, then 1. Let C be the CharSet containing the single
character `-` U+002D (HYPHEN-MINUS). 1. Return the union of CharSets
A, B and C. 1. Return CharacterRange(A, B).

Static Semantics: ParsePattern ( patternText, u, v )
----------------------------------------------------------------

The semantics of is extended as follows:

The abstract operation ParsePattern takes arguments patternText (a
sequence of Unicode code points), u (a Boolean), and v (a
Boolean). It performs the following steps when called:

1. If v is `true` and u is `true`, then 1. Let
parseResult be a List containing one or more `SyntaxError`
objects. 1. Else if v is `true`, then 1. Let parseResult be
ParseText(patternText, \|Pattern[+UnicodeMode, +UnicodeSetsMode,
+NamedCaptureGroups]\|). 1. Else if u is `true`, then 1. Let
parseResult be ParseText(patternText, \|Pattern[+UnicodeMode,
~UnicodeSetsMode, +NamedCaptureGroups]\|). 1. Else, 1. Let
parseResult be ParseText(patternText, \|Pattern[~UnicodeMode,
~UnicodeSetsMode, ~NamedCaptureGroups]\|). 1. If parseResult is a
Parse Node and parseResult contains a `GroupName`, then 1. Set
parseResult to ParseText(patternText, \|Pattern[~UnicodeMode,
~UnicodeSetsMode, +NamedCaptureGroups]\|). 1. Return parseResult.

Additional Built-in Properties
------------------------------

When the ECMAScript host is a web browser the following additional
properties of the standard built-in objects are defined.

Additional Properties of the Global Object
------------------------------------------

The entries in are added to .

============== ============ ===============================
Intrinsic Name Global Name  ECMAScript Language Association
============== ============ ===============================
%escape%       `escape`   The `escape` function ()
%unescape%     `unescape` The `unescape` function ()
============== ============ ===============================

escape ( string )
---------------------

This function is a property of the global object. It computes a new
version of a String value in which certain code units have been replaced
by a hexadecimal escape sequence.

When replacing a code unit of numeric value less than or equal to
0x00FF, a two-digit escape sequence of the form ``%``\ ``xx`` is used.
When replacing a code unit of numeric value strictly greater than
0x00FF, a four-digit escape sequence of the form ``%u``\ ``xxxx`` is
used.

It is the %escape% intrinsic object.

It performs the following steps when called:

1. Set string to ? ToString(string). 1. Let len be the
length of string. 1. Let R be the empty String. 1. Let
unescapedSet be the string-concatenation of the ASCII word
characters and `"@\`+-./"`. 1. Let k be 0. 1. Repeat, while k
< len, 1. Let C be the code unit at index k within
string. 1. If unescapedSet contains C, then 1. Let S be
C. 1. Else, 1. Let n be the numeric value of C. 1. If n
< 256, then 1. Let hex be the String representation of n,
formatted as an uppercase hexadecimal number. 1. Let S be the
string-concatenation of `"%"` and StringPad(hex, 2, `"0"`,
~start~). 1. Else, 1. Let hex be the String representation of n,
formatted as an uppercase hexadecimal number. 1. Let S be the
string-concatenation of `"%u"` and StringPad(hex, 4, `"0"`,
~start~). 1. Set R to the string-concatenation of R and S.
1. Set k to k + 1. 1. Return R.

The encoding is partly based on the encoding described in RFC 1738, but
the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape ( string )
-----------------------

This function is a property of the global object. It computes a new
version of a String value in which each escape sequence of the sort that
might be introduced by the `escape` function is replaced with the code
unit that it represents.

It is the %unescape% intrinsic object.

It performs the following steps when called:

1. Set string to ? ToString(string). 1. Let len be the
length of string. 1. Let R be the empty String. 1. Let k be
0. 1. Repeat, while k < len, 1. Let C be the code unit at
index k within string. 1. If C is the code unit 0x0025
(PERCENT SIGN), then 1. Let hexDigits be the empty String. 1. Let
optionalAdvance be 0. 1. If k + 5 < len and the code unit at
index k + 1 within string is the code unit 0x0075 (LATIN SMALL
LETTER U), then 1. Set hexDigits to the substring of string from
k + 2 to k + 6. 1. Set optionalAdvance to 5. 1. Else if
k + 3 ≤ len, then 1. Set hexDigits to the substring of
string from k + 1 to k + 3. 1. Set optionalAdvance to 2.
1. Let parseResult be ParseText(hexDigits, \|HexDigits[~Sep]\|).
1. If parseResult is a Parse Node, then 1. Let n be the MV of
parseResult. 1. Set C to the code unit whose numeric value is
n. 1. Set k to k + optionalAdvance. 1. Set R to the
string-concatenation of R and C. 1. Set k to k + 1. 1.
Return R.

Additional Properties of the String.prototype Object
----------------------------------------------------

String.prototype.substr ( start, length )
-------------------------------------------------

This method returns a substring of the result of converting the `this`
value to a String, starting from index start and running for
length code units (or through the end of the String if length is
`undefined`). If start is negative, it is treated as
sourceLength + start where sourceLength is the length of the
String. The result is a String value, not a String object.

It performs the following steps when called:

1. Let O be ? RequireObjectCoercible(`this` value). 1. Let S
be ? ToString(O). 1. Let size be the length of S. 1. Let
intStart be ? ToIntegerOrInfinity(start). 1. If intStart =
-∞, set intStart to 0. 1. Else if intStart < 0, set intStart
to max(size + intStart, 0). 1. Else, set intStart to
min(intStart, size). 1. If length is `undefined`, let
intLength be size; otherwise let intLength be ?
ToIntegerOrInfinity(length). 1. Set intLength to the result of
clamping intLength between 0 and size. 1. Let intEnd be
min(intStart + intLength, size). 1. Return the substring of
S from intStart to intEnd.

This method is intentionally generic; it does not require that its
`this` value be a String object. Therefore it can be transferred to
other kinds of objects for use as a method.

String.prototype.anchor ( name )
------------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"a"`, `"name"`, name).

CreateHTML ( string, tag: a String, attribute: a String, value, )
-----------------------------------------------------------------

1. Let str be ? RequireObjectCoercible(string). 1. Let S be
? ToString(str). 1. Let p1 be the string-concatenation of
`"<"` and tag. 1. If attribute is not the empty String, then
1. Let V be ? ToString(value). 1. Let escapedV be the String
value that is the same as V except that each occurrence of the code
unit 0x0022 (QUOTATION MARK) in V has been replaced with the six
code unit sequence `"&quot;"`. 1. Set p1 to the
string-concatenation of: ` p1 ` the code unit 0x0020 (SPACE) `
attribute ` the code unit 0x003D (EQUALS SIGN) ` the code unit
0x0022 (QUOTATION MARK) ` escapedV ` the code unit 0x0022
(QUOTATION MARK) 1. Let p2 be the string-concatenation of p1 and
`">"`. 1. Let p3 be the string-concatenation of p2 and S.
1. Let p4 be the string-concatenation of p3, `"</"`, tag,
and `">"`. 1. Return p4.

String.prototype.big ( )
------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"big"`, `""`, `""`).

String.prototype.blink ( )
--------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"blink"`, `""`, `""`).

String.prototype.bold ( )
-------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"b"`, `""`, `""`).

String.prototype.fixed ( )
--------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"tt"`, `""`, `""`).

String.prototype.fontcolor ( colour )
-----------------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"font"`, `"color"`, colour).

String.prototype.fontsize ( size )
--------------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"font"`, `"size"`, size).

String.prototype.italics ( )
----------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"i"`, `""`, `""`).

String.prototype.link ( url )
---------------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"a"`, `"href"`, url).

String.prototype.small ( )
--------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"small"`, `""`, `""`).

String.prototype.strike ( )
---------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"strike"`, `""`, `""`).

String.prototype.sub ( )
------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"sub"`, `""`, `""`).

String.prototype.sup ( )
------------------------

This method performs the following steps when called:

1. Let S be the `this` value. 1. Return ? CreateHTML(S,
`"sup"`, `""`, `""`).

String.prototype.trimLeft ( )
-----------------------------

The property `"trimStart"` is preferred. The `"trimLeft"` property
is provided principally for compatibility with old code. It is
recommended that the `"trimStart"` property be used in new ECMAScript
code.

The initial value of the `"trimLeft"` property is
%String.prototype.trimStart%, defined in .

String.prototype.trimRight ( )
------------------------------

The property `"trimEnd"` is preferred. The `"trimRight"` property is
provided principally for compatibility with old code. It is recommended
that the `"trimEnd"` property be used in new ECMAScript code.

The initial value of the `"trimRight"` property is
%String.prototype.trimEnd%, defined in .

Additional Properties of the Date.prototype Object
--------------------------------------------------

Date.prototype.getYear ( )
--------------------------

The `getFullYear` method is preferred for nearly all purposes, because
it avoids the “year 2000 problem.”

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. If t is `NaN`, return `NaN`. 1.
Return YearFromTime(LocalTime(t)) - `1900`\ :sub:`𝔽`.

Date.prototype.setYear ( year )
-----------------------------------

The `setFullYear` method is preferred for nearly all purposes, because
it avoids the “year 2000 problem.”

This method performs the following steps when called:

1. Let dateObject be the `this` value. 1. Perform ?
RequireInternalSlot(dateObject, [[DateValue]]). 1. Let t be
dateObject.[[DateValue]]. 1. Let y be ? ToNumber(year). 1.
If t is `NaN`, set t to `+0`\ :sub:`𝔽`; otherwise, set t
to LocalTime(t). 1. Let yyyy be MakeFullYear(y). 1. Let
d be MakeDay(yyyy, MonthFromTime(t), DateFromTime(t)).
1. Let date be MakeDate(d, TimeWithinDay(t)). 1. Let u
be TimeClip(UTC(date)). 1. Set dateObject.[[DateValue]] to
u. 1. Return u.

Date.prototype.toGMTString ( )
------------------------------

The `toUTCString` method is preferred. This method is provided
principally for compatibility with old code.

The initial value of the `"toGMTString"` property is
%Date.prototype.toUTCString%, defined in .

Additional Properties of the RegExp.prototype Object
----------------------------------------------------

RegExp.prototype.compile ( pattern, flags )
---------------------------------------------------

This method performs the following steps when called:

1. Let O be the `this` value. 1. Perform ?
RequireInternalSlot(O, [[RegExpMatcher]]). 1. If pattern is an
Object and pattern has a [[RegExpMatcher]] internal slot, then 1. If
flags is not `undefined`, throw a `TypeError` exception. 1. Let
P be pattern.[[OriginalSource]]. 1. Let F be
pattern.[[OriginalFlags]]. 1. Else, 1. Let P be pattern. 1.
Let F be flags. 1. Return ? RegExpInitialize(O, P,
F).

This method completely reinitializes the `this` value RegExp with a
new pattern and flags. An implementation may interpret use of this
method as an assertion that the resulting RegExp object will be used
multiple times and hence is a candidate for extra optimization.

Other Additional Features
-------------------------

Labelled Function Declarations
------------------------------

Prior to ECMAScript 2015, the specification of `LabelledStatement` did
not allow for the association of a statement label with a
`FunctionDeclaration`. However, a labelled `FunctionDeclaration` was
an allowable extension for non-strict code and most browser-hosted
ECMAScript implementations supported that extension. In ECMAScript 2015
and later, the grammar production for `LabelledStatement` permits use
of `FunctionDeclaration` as a `LabelledItem` but includes an Early
Error rule that produces a Syntax Error if that occurs. That rule is
modified with the addition of the *highlighted* text:

LabelledItem : FunctionDeclaration

- It is a Syntax Error if any source text *that is strict mode code* is
  matched by this production.

The early error rules for `WithStatement`, `IfStatement`, and
`IterationStatement` prevent these statements from containing a
labelled `FunctionDeclaration` in non-strict code.

Block-Level Function Declarations Web Legacy Compatibility Semantics
--------------------------------------------------------------------

Prior to ECMAScript 2015, the ECMAScript specification did not define
the occurrence of a `FunctionDeclaration` as an element of a `Block`
statement's `StatementList`. However, support for that form of
`FunctionDeclaration` was an allowable extension and most
browser-hosted ECMAScript implementations permitted them. Unfortunately,
the semantics of such declarations differ among those implementations.
Because of these semantic differences, existing web ECMAScript source
text that uses `Block` level function declarations is only portable
among browser implementations if the usage only depends upon the
semantic intersection of all of the browser implementations for such
declarations. The following are the use cases that fall within that
intersection semantics:

#. A function is declared and only referenced within a single block.

   - One or more \|FunctionDeclaration|s whose `BindingIdentifier` is
     the name f occur within the function code of an enclosing
     function g and that declaration is nested within a `Block`.
   - No other declaration of f that is not a `var` declaration
     occurs within the function code of g.
   - All occurrences of f as an `IdentifierReference` are within
     the `StatementList` of the `Block` containing the declaration
     of f.

#. A function is declared and possibly used within a single `Block`
   but also referenced by an inner function definition that is not
   contained within that same `Block`.

   - One or more \|FunctionDeclaration|s whose `BindingIdentifier` is
     the name f occur within the function code of an enclosing
     function g and that declaration is nested within a `Block`.
   - No other declaration of f that is not a `var` declaration
     occurs within the function code of g.
   - There may be occurrences of f as an `IdentifierReference`
     within the `StatementList` of the `Block` containing the
     declaration of f.
   - There is at least one occurrence of f as an
     `IdentifierReference` within another function h that is
     nested within g and no other declaration of f shadows the
     references to f from within h.
   - All invocations of h occur after the declaration of f has
     been evaluated.

#. A function is declared and possibly used within a single block but
   also referenced within subsequent blocks.

   - One or more `FunctionDeclaration` whose `BindingIdentifier` is
     the name f occur within the function code of an enclosing
     function g and that declaration is nested within a `Block`.
   - No other declaration of f that is not a `var` declaration
     occurs within the function code of g.
   - There may be occurrences of f as an `IdentifierReference`
     within the `StatementList` of the `Block` containing the
     declaration of f.
   - There is at least one occurrence of f as an
     `IdentifierReference` within the function code of g that
     lexically follows the `Block` containing the declaration of
     f.

The first use case is interoperable with the semantics of `Block`
level function declarations provided by ECMAScript 2015. Any
pre-existing ECMAScript source text that employs that use case will
operate using the Block level function declarations semantics defined by
clauses , , and .

ECMAScript 2015 interoperability for the second and third use cases
requires the following extensions to the clause , clause , clause and
clause semantics.

If an ECMAScript implementation has a mechanism for reporting diagnostic
warning messages, a warning should be produced when code contains a
`FunctionDeclaration` for which these compatibility semantics are
applied and introduce observable differences from non-compatibility
semantics. For example, if a var binding is not introduced because its
introduction would create an early error, a warning message should not
be produced.

Changes to FunctionDeclarationInstantiation
-------------------------------------------

During FunctionDeclarationInstantiation the following steps are
performed in place of step :

1. If strict is `false`, then 1. For each `FunctionDeclaration`
f that is directly contained in the `StatementList` of any
`Block`, `CaseClause`, or `DefaultClause` x such that code
Contains x is `true`, do 1. Let F be the StringValue of the
`BindingIdentifier` of f. 1. If replacing the
`FunctionDeclaration` f with a `VariableStatement` that has
F as a `BindingIdentifier` would not produce any Early Errors for
func and parameterNames does not contain F, then 1. NOTE: A
var binding for F is only instantiated here if it is neither a
VarDeclaredName, the name of a formal parameter, or another
`FunctionDeclaration`. 1. If instantiatedVarNames does not contain
F and F is not `"arguments"`, then 1. Perform !
varEnv.CreateMutableBinding(F, `false`). 1. Perform !
varEnv.InitializeBinding(F, `undefined`). 1. Append F to
instantiatedVarNames. 1. When the `FunctionDeclaration` f is
evaluated, perform the following steps in place of the
`FunctionDeclaration` Evaluation algorithm provided in : 1. Let
fEnv be the running execution context's VariableEnvironment. 1. Let
bEnv be the running execution context's LexicalEnvironment. 1. Let
fObj be ! bEnv.GetBindingValue(F, `false`). 1. Perform !
fEnv.SetMutableBinding(F, fObj, `false`). 1. Return
~unused~.

Changes to GlobalDeclarationInstantiation
-----------------------------------------

During GlobalDeclarationInstantiation the following steps are performed
in place of step :

1. Perform the following steps: 1. Let strict be ScriptIsStrict of
script. 1. If strict is `false`, then 1. Let
declaredFunctionOrVarNames be the list-concatenation of
declaredFunctionNames and declaredVarNames. 1. For each
`FunctionDeclaration` f that is directly contained in the
`StatementList` of any `Block`, `CaseClause`, or `DefaultClause`
x such that script Contains x is `true`, do 1. Let F
be the StringValue of the `BindingIdentifier` of f. 1. If
replacing the `FunctionDeclaration` f with a `VariableStatement`
that has F as a `BindingIdentifier` would not produce any Early
Errors for script, then 1. If env.HasLexicalDeclaration(F)
is `false`, then 1. Let fnDefinable be ?
env.CanDeclareGlobalVar(F). 1. If fnDefinable is `true`,
then 1. NOTE: A var binding for F is only instantiated here if it is
neither a VarDeclaredName nor the name of another
`FunctionDeclaration`. 1. If declaredFunctionOrVarNames does not
contain F, then 1. Perform ? env.CreateGlobalVarBinding(F,
`false`). 1. Append F to declaredFunctionOrVarNames. 1. When
the `FunctionDeclaration` f is evaluated, perform the following
steps in place of the `FunctionDeclaration` Evaluation algorithm
provided in : 1. Let gEnv be the running execution context's
VariableEnvironment. 1. Let bEnv be the running execution context's
LexicalEnvironment. 1. Let fObj be ! bEnv.GetBindingValue(F,
`false`). 1. Perform ? gEnv.SetMutableBinding(F, fObj,
`false`). 1. Return ~unused~.

Changes to EvalDeclarationInstantiation
---------------------------------------

During EvalDeclarationInstantiation the following steps are performed in
place of step :

1. If strict is `false`, then 1. Let
declaredFunctionOrVarNames be the list-concatenation of
declaredFunctionNames and declaredVarNames. 1. For each
`FunctionDeclaration` f that is directly contained in the
`StatementList` of any `Block`, `CaseClause`, or `DefaultClause`
x such that body Contains x is `true`, do 1. Let F be
the StringValue of the `BindingIdentifier` of f. 1. If replacing
the `FunctionDeclaration` f with a `VariableStatement` that has
F as a `BindingIdentifier` would not produce any Early Errors for
body, then 1. Let bindingExists be `false`. 1. Let thisEnv
be lexEnv. 1. Assert: The following loop will terminate. 1. Repeat,
while thisEnv is not varEnv, 1. If thisEnv is not an Object
Environment Record, then 1. If ! thisEnv.HasBinding(F) is
`true`, then 1.
[id="step-evaldeclarationinstantiation-web-compat-bindingexists"] Let
bindingExists be `true`. 1. Set thisEnv to
thisEnv.[[OuterEnv]]. 1. If bindingExists is `false` and
varEnv is a Global Environment Record, then 1. If
varEnv.HasLexicalDeclaration(F) is `false`, then 1. Let
fnDefinable be ? varEnv.CanDeclareGlobalVar(F). 1. Else, 1.
Let fnDefinable be `false`. 1. Else, 1. Let fnDefinable be
`true`. 1. If bindingExists is `false` and fnDefinable is
`true`, then 1. If declaredFunctionOrVarNames does not contain
F, then 1. If varEnv is a Global Environment Record, then 1.
Perform ? varEnv.CreateGlobalVarBinding(F, `true`). 1. Else,
1. Let bindingExists be ! varEnv.HasBinding(F). 1. If
bindingExists is `false`, then 1. Perform !
varEnv.CreateMutableBinding(F, `true`). 1. Perform !
varEnv.InitializeBinding(F, `undefined`). 1. Append F to
declaredFunctionOrVarNames. 1. When the `FunctionDeclaration`
f is evaluated, perform the following steps in place of the
`FunctionDeclaration` Evaluation algorithm provided in : 1. Let
gEnv be the running execution context's VariableEnvironment. 1. Let
bEnv be the running execution context's LexicalEnvironment. 1. Let
fObj be ! bEnv.GetBindingValue(F, `false`). 1. Perform ?
gEnv.SetMutableBinding(F, fObj, `false`). 1. Return
~unused~.

Changes to Block Static Semantics: Early Errors
-----------------------------------------------

The rules for the following production in are modified with the addition
of the *highlighted* text:

Block : `{` StatementList `}`

- It is a Syntax Error if the LexicallyDeclaredNames of
  `StatementList` contains any duplicate entries\ *, unless
  IsStrict(this production) is `false` and the duplicate entries are
  only bound by FunctionDeclarations*.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `StatementList` also occurs in the VarDeclaredNames of
  `StatementList`.

Changes to `switch` Statement Static Semantics: Early Errors
--------------------------------------------------------------

The rules for the following production in are modified with the addition
of the *highlighted* text:

SwitchStatement : `switch` `(` Expression `)` CaseBlock

- It is a Syntax Error if the LexicallyDeclaredNames of `CaseBlock`
  contains any duplicate entries\ *, unless IsStrict(this production) is
  `false` and the duplicate entries are only bound by
  FunctionDeclarations*.
- It is a Syntax Error if any element of the LexicallyDeclaredNames of
  `CaseBlock` also occurs in the VarDeclaredNames of `CaseBlock`.

Changes to BlockDeclarationInstantiation
----------------------------------------

During BlockDeclarationInstantiation the following steps are performed
in place of step :

1. If ! env.HasBinding(dn) is `false`, then 1. Perform !
env.CreateMutableBinding(dn, `false`).

During BlockDeclarationInstantiation the following steps are performed
in place of step :

1. Perform the following steps: 1. If the binding for fn in env
is an uninitialized binding, then 1. Perform !
env.InitializeBinding(fn, fo). 1. Else, 1. Assert: d is
a `FunctionDeclaration`. 1. Perform !
env.SetMutableBinding(fn, fo, `false`).

FunctionDeclarations in IfStatement Statement Clauses
-----------------------------------------------------

The following augments the `IfStatement` production in :

IfStatement[Yield, Await, Return] : `if` `(` Expression[+In, ?Yield,
?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else`
Statement[?Yield, ?Await, ?Return] `if` `(` Expression[+In, ?Yield,
?Await] `)` Statement[?Yield, ?Await, ?Return] `else`
FunctionDeclaration[?Yield, ?Await, ~Default] `if` `(`
Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield,
?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
`if` `(` Expression[+In, ?Yield, ?Await] `)`
FunctionDeclaration[?Yield, ?Await, ~Default] [lookahead != `else`]

This production only applies when parsing non-strict code. Source text
matched by this production is processed as if each matching occurrence
of \|FunctionDeclaration[?Yield, ?Await, ~Default]\| was the sole
`StatementListItem` of a `BlockStatement` occupying that position in
the source text. The semantics of such a synthetic `BlockStatement`
includes the web legacy compatibility semantics specified in .

VariableStatements in Catch Blocks
----------------------------------

The content of subclause is replaced with the following:

Catch : `catch` `(` CatchParameter `)` Block

- It is a Syntax Error if the BoundNames of `CatchParameter` contains
  any duplicate elements.
- It is a Syntax Error if any element of the BoundNames of
  `CatchParameter` also occurs in the LexicallyDeclaredNames of
  `Block`.
- It is a Syntax Error if any element of the BoundNames of
  `CatchParameter` also occurs in the VarDeclaredNames of `Block`
  unless `CatchParameter` is CatchParameter : BindingIdentifier.

The `Block` of a `Catch` clause may contain `var` declarations
that bind a name that is also bound by the `CatchParameter`. At
runtime, such bindings are instantiated in the
VariableDeclarationEnvironment. They do not shadow the same-named
bindings introduced by the `CatchParameter` and hence the
`Initializer` for such `var` declarations will assign to the
corresponding catch parameter rather than the `var` binding.

This modified behaviour also applies to `var` and `function`
declarations introduced by direct eval calls contained within the
`Block` of a `Catch` clause. This change is accomplished by
modifying the algorithm of as follows:

Step is replaced by:

1. If thisEnv is not the Environment Record for a `Catch` clause,
throw a `SyntaxError` exception.

Step is replaced by:

1. If thisEnv is not the Environment Record for a `Catch` clause,
let bindingExists be `true`.

Initializers in ForIn Statement Heads
-------------------------------------

The following augments the `ForInOfStatement` production in :

ForInOfStatement[Yield, Await, Return] : `for` `(` `var`
BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await]
`in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await,
?Return]

This production only applies when parsing non-strict code.

The static semantics of ContainsDuplicateLabels in are augmented with
the following:

ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer
`in` Expression `)` Statement 1. Return ContainsDuplicateLabels of
`Statement` with argument labelSet.

The static semantics of ContainsUndefinedBreakTarget in are augmented
with the following:

ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer
`in` Expression `)` Statement 1. Return ContainsUndefinedBreakTarget
of `Statement` with argument labelSet.

The static semantics of ContainsUndefinedContinueTarget in are augmented
with the following:

ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer
`in` Expression `)` Statement 1. Return
ContainsUndefinedContinueTarget of `Statement` with arguments
iterationSet and « ».

The static semantics of IsDestructuring in are augmented with the
following:

BindingIdentifier : Identifier `yield` `await` 1. Return `false`.

The static semantics of VarDeclaredNames in are augmented with the
following:

ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer
`in` Expression `)` Statement 1. Let names1 be the BoundNames of
`BindingIdentifier`. 1. Let names2 be the VarDeclaredNames of
`Statement`. 1. Return the list-concatenation of names1 and
names2.

The static semantics of VarScopedDeclarations in are augmented with the
following:

ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer
`in` Expression `)` Statement 1. Let declarations1 be «
`BindingIdentifier` ». 1. Let declarations2 be the
VarScopedDeclarations of `Statement`. 1. Return the list-concatenation
of declarations1 and declarations2.

The runtime semantics of ForInOfLoopEvaluation in are augmented with the
following:

ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer
`in` Expression `)` Statement 1. Let bindingId be the
StringValue of `BindingIdentifier`. 1. Let lhs be ?
ResolveBinding(bindingId). 1. If
IsAnonymousFunctionDefinition(`Initializer`) is `true`, then 1. Let
value be ? NamedEvaluation of `Initializer` with argument
bindingId. 1. Else, 1. Let rhs be ? Evaluation of
`Initializer`. 1. Let value be ? GetValue(rhs). 1. Perform ?
PutValue(lhs, value). 1. Let keyResult be ?
ForIn/OfHeadEvaluation(« », `Expression`, ~enumerate~). 1. Return ?
ForIn/OfBodyEvaluation(`BindingIdentifier`, `Statement`,
keyResult, ~enumerate~, ~var-binding~, labelSet).

The [[IsHTMLDDA]] Internal Slot
-------------------------------

An [[IsHTMLDDA]] internal slot may exist on host-defined objects.
Objects with an [[IsHTMLDDA]] internal slot behave like `undefined` in
the ToBoolean and IsLooselyEqual abstract operations and when used as an
operand for the `typeof` operator.

Objects with an [[IsHTMLDDA]] internal slot are never created by this
specification. However, the ```document.all``
object <https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all>`__
in web browsers is a host-defined exotic object with this slot that
exists for web compatibility purposes. There are no other known examples
of this type of object and implementations should not create any with
the exception of `document.all`.

Changes to ToBoolean
--------------------

The following step replaces step of ToBoolean:

1. If argument is an Object and argument has an [[IsHTMLDDA]]
internal slot, return `false`.

Changes to IsLooselyEqual
-------------------------

The following steps replace step of IsLooselyEqual:

1. Perform the following steps: 1. If x is an Object, x has an
[[IsHTMLDDA]] internal slot, and y is either `undefined` or
`null`, return `true`. 1. If x is either `undefined` or
`null`, y is an Object, and y has an [[IsHTMLDDA]] internal
slot, return `true`.

Changes to the `typeof` Operator
----------------------------------

The following step replaces step of the evaluation semantics for
`typeof`:

1. If val has an [[IsHTMLDDA]] internal slot, return
`"undefined"`.

Non-default behaviour in HostMakeJobCallback
--------------------------------------------

The HostMakeJobCallback abstract operation allows hosts which are web
browsers to specify non-default behaviour.

Non-default behaviour in HostEnsureCanAddPrivateElement
-------------------------------------------------------

The HostEnsureCanAddPrivateElement abstract operation allows hosts which
are web browsers to specify non-default behaviour.


C The Strict Mode of ECMAScript
===============================

https://tc39.es/ecma262/multipage/strict-mode-of-ecmascript.html

**The strict mode restriction and exceptions**

- `implements`, `interface`, `let`, `package`, `private`,
  `protected`, `public`, `static`, and `yield` are reserved
  words within strict mode code. ().
- A conforming implementation, when processing strict mode code, must
  disallow instances of the productions NumericLiteral ::
  LegacyOctalIntegerLiteral and DecimalIntegerLiteral ::
  NonOctalDecimalIntegerLiteral.
- A conforming implementation, when processing strict mode code, must
  disallow instances of the productions EscapeSequence ::
  LegacyOctalEscapeSequence and EscapeSequence ::
  NonOctalDecimalEscapeSequence.
- Assignment to an undeclared identifier or otherwise unresolvable
  reference does not create a property in the global object. When a
  simple assignment occurs within strict mode code, its
  `LeftHandSideExpression` must not evaluate to an unresolvable
  Reference. If it does a `ReferenceError` exception is thrown (). The
  `LeftHandSideExpression` also may not be a reference to a data
  property with the attribute value { [[Writable]]: `false` }, to an
  accessor property with the attribute value { [[Set]]: `undefined` },
  nor to a non-existent property of an object whose [[Extensible]]
  internal slot is `false`. In these cases a `TypeError` exception
  is thrown ().
- An `IdentifierReference` with the StringValue `"eval"` or
  `"arguments"` may not appear as the `LeftHandSideExpression` of an
  Assignment operator () or of an `UpdateExpression` () or as the
  `UnaryExpression` operated upon by a Prefix Increment () or a Prefix
  Decrement () operator.
- Arguments objects for strict functions define a non-configurable
  accessor property `"callee"` which throws a `TypeError` exception
  on access ().
- Arguments objects for strict functions do not dynamically share their
  array-indexed property values with the corresponding formal parameter
  bindings of their functions. ().
- For strict functions, if an arguments object is created the binding of
  the local identifier `arguments` to the arguments object is
  immutable and hence may not be the target of an assignment expression.
  ().
- It is a `SyntaxError` if the StringValue of a `BindingIdentifier`
  is either `"eval"` or `"arguments"` within strict mode code ().
- Strict mode eval code cannot instantiate variables or functions in the
  variable environment of the caller to eval. Instead, a new variable
  environment is created and that environment is used for declaration
  binding instantiation for the eval code ().
- If `this` is evaluated within strict mode code, then the `this`
  value is not coerced to an object. A `this` value of either
  `undefined` or `null` is not converted to the global object and
  primitive values are not converted to wrapper objects. The `this`
  value passed via a function call (including calls made using
  `Function.prototype.apply` and `Function.prototype.call`) do not
  coerce the passed `this` value to an object (, , ).
- When a `delete` operator occurs within strict mode code, a
  `SyntaxError` is thrown if its `UnaryExpression` is a direct
  reference to a variable, function argument, or function name ().
- When a `delete` operator occurs within strict mode code, a
  `TypeError` is thrown if the property to be deleted has the
  attribute { [[Configurable]]: `false` } or otherwise cannot be
  deleted ().
- Strict mode code may not include a `WithStatement`. The occurrence
  of a `WithStatement` in such a context is a `SyntaxError` ().
- It is a `SyntaxError` if a `CatchParameter` occurs within strict
  mode code and the BoundNames of `CatchParameter` contains either
  `eval` or `arguments` ().
- It is a `SyntaxError` if the same `BindingIdentifier` appears more
  than once in the `FormalParameters` of a strict function. An attempt
  to create such a function using a Function, Generator, or
  AsyncFunction constructor is a `SyntaxError` (, ).
- An implementation may not extend, beyond that defined in this
  specification, the meanings within strict functions of properties
  named `"caller"` or `"arguments"` of function instances.

D Host Layering Points
======================

https://tc39.es/ecma262/multipage/host-layering-points.html
::

   D.1 Host Hooks
   D.2 Host-defined Fields
   D.3 Host-defined Objects
   D.4 Running Jobs
   D.5 Internal Methods of Exotic Objects
   D.6 Built-in Objects and Methods

See for the definition of host.


D.1 Host Hooks
--------------

**HostCallJobCallback(...)**

**HostEnqueueFinalizationRegistryCleanupJob(...)**

**HostEnqueueGenericJob(...)**

**HostEnqueuePromiseJob(...)**

**HostEnqueueTimeoutJob(...)**

**HostEnsureCanCompileStrings(...)**

**HostFinalizeImportMeta(...)**

**HostGetImportMetaProperties(...)**

**HostGrowSharedArrayBuffer(...)**

**HostHasSourceTextAvailable(...)**

**HostLoadImportedModule(...)**

**HostMakeJobCallback(...)**

**HostPromiseRejectionTracker(...)**

**HostResizeArrayBuffer(...)**

**InitializeHostDefinedRealm(...)**

D.2 Host-defined Fields
-----------------------

[[HostDefined]] on Realm Records: See .

[[HostDefined]] on Script Records: See .

[[HostDefined]] on Module Records: See .

[[HostDefined]] on JobCallback Records: See .

[[HostSynchronizesWith]] on Candidate Executions: See .

[[IsHTMLDDA]]: See .

D.3 Host-defined Objects
------------------------

The global object: See clause .

D.4 Running Jobs
----------------

Preparation steps before, and cleanup steps after, invocation of Job
Abstract Closures. See .

D.5 Internal Methods of Exotic Objects
--------------------------------------

Any of the essential internal methods in for any exotic object not
specified within this specification.

D.6 Built-in Objects and Methods
--------------------------------

Any built-in objects and methods not defined within this specification,
except as restricted in .

E Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact
======================================================================================

https://tc39.es/ecma262/multipage/corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact.html

9.1.1.4.15-9.1.1.4.18 Edition 5 and 5.1 used a property existence test to 
determine whether a global object property corresponding to a new global 
declaration already existed. ECMAScript 2015 uses an own property existence test.
This corresponds to what has been most commonly implemented by web browsers.

10.4.2.1: The 5\ :sup:`th` Edition moved the capture of the current array length
prior to the integer conversion of the array index or new length value.
However, the captured length value could become invalid if the
conversion process has the side-effect of changing the array length.
ECMAScript 2015 specifies that the current array length must be captured
after the possible occurrence of such side-effects.

21.4.1.31: Previous editions permitted the TimeClip abstract operation to 
return either `+0`\ :sub:`𝔽` or `-0`\ :sub:`𝔽` as the representation of a 0
time value. ECMAScript 2015 specifies that `+0`\ :sub:`𝔽` always
returned. This means that for ECMAScript 2015 the time value of a Date
is never observably `-0`\ :sub:`𝔽` and methods that return time values
never return `-0`\ :sub:`𝔽`.

21.4.1.32: If a UTC offset representation is not present, the local time zone 
is used. Edition 5.1 incorrectly stated that a missing time zone should be
interpreted as `"z"`.

21.4.4.36: If the year cannot be represented using the Date Time String Format
specified in a RangeError exception is thrown. Previous editions did not
specify the behaviour for that case.

21.4.4.41: Previous editions did not specify the value returned by
`Date.prototype.toString` when the time value is `NaN`. ECMAScript
2015 specifies the result to be the String value `"Invalid Date"`.

22.2.4.1, 22.2.6.13.1: Any LineTerminator code points in the value of the 
`"source"` property of a RegExp instance must be expressed using an escape
sequence. Edition 5.1 only required the escaping of `/`.

22.2.6.8, 22.2.6.11: In previous editions, the specifications for
`String.prototype.match` and `String.prototype.replace` was
incorrect for cases where the pattern argument was a RegExp value whose
`global` flag is set. The previous specifications stated that for each
attempt to match the pattern, if `lastIndex` did not change, it should
be incremented by 1. The correct behaviour is that `lastIndex` should
be incremented by 1 only if the pattern matched the empty String.

23.1.3.30: Previous editions did not specify how a `NaN` value returned by 
a comparator was interpreted by `Array.prototype.sort`. ECMAScript
2015 specifies that such as value is treated as if `+0`\ :sub:`𝔽` was
returned from the comparator. ECMAScript 2015 also specifies that
ToNumber is applied to the result returned by a comparator. In
previous editions, the effect of a comparator result that is not a
Number value was implementation-defined. In practice, implementations
call ToNumber.

F Additions and Changes That Introduce Incompatibilities with Prior Editions
============================================================================

https://tc39.es/ecma262/multipage/additions-and-changes-that-introduce-incompatibilities-with-prior-editions.html

6.2.5: In ECMAScript 2015, Function calls are not allowed to return a Reference Record.

7.1.4.1: In ECMAScript 2015, ToNumber applied to a String value now recognizes and 
converts BinaryIntegerLiteral and OctalIntegerLiteral numeric strings. In previous 
editions such strings were converted to **NaN**.

9.3: In ECMAScript 2018, Template objects are canonicalized based on Parse Node 
(source location), instead of across all occurrences of that template literal or 
tagged template in a Realm in previous editions.

12.2: In ECMAScript 2016, Unicode 8.0.0 or higher is mandated, as opposed to 
ECMAScript 2015 which mandated Unicode 5.1. In particular, this caused U+180E 
MONGOLIAN VOWEL SEPARATOR, which was in the **Space_Separator (Zs)** category 
and thus treated as whitespace in ECMAScript 2015, to be moved to the **Format (Cf)** 
category (as of Unicode 6.3.0). This causes whitespace-sensitive methods to behave 
differently. For example, **"\u180E".trim().length** was 0 in previous editions, 
but 1 in ECMAScript 2016 and later. Additionally, ECMAScript 2017 mandated always 
using the latest version of the Unicode Standard.

12.7: In ECMAScript 2015, the valid code points for an IdentifierName are specified 
in terms of the Unicode properties “ID_Start” and “ID_Continue”. In previous editions, 
the valid IdentifierName or Identifier code points were specified by enumerating 
various Unicode code point categories.

12.10.1: In ECMAScript 2015, Automatic Semicolon Insertion adds a semicolon at the 
end of a do-while statement if the semicolon is missing. This change aligns the 
specification with the actual behaviour of most existing implementations.

13.2.5.1: In ECMAScript 2015, it is no longer an early error to have duplicate 
property names in Object Initializers.

13.15.1: In ECMAScript 2015, strict mode code containing an assignment to an 
immutable binding such as the function name of a FunctionExpression does not 
produce an early error. Instead it produces a runtime error.

14.2: In ECMAScript 2015, a StatementList beginning with the token let followed 
by the input elements LineTerminator then Identifier is the start of a 
LexicalDeclaration. In previous editions, automatic semicolon insertion would 
always insert a semicolon before the Identifier input element.

14.5: In ECMAScript 2015, a StatementListItem beginning with the token `let` 
followed by the token [ is the start of a LexicalDeclaration. In previous 
editions such a sequence would be the start of an ExpressionStatement.

14.6.2: In ECMAScript 2015, the normal result of an `IfStatement` is never the 
value EMPTY. If no Statement part is evaluated or if the evaluated Statement 
part produces a normal completion containing EMPTY, the result of the `IfStatement` 
is **undefined**.

14.7: In ECMAScript 2015, if the ( token of a for statement is immediately 
followed by the token sequence `let [` then the `let` is treated as the start 
of a LexicalDeclaration. In previous editions such a token sequence would be 
the start of an Expression.

14.7: In ECMAScript 2015, if the ( token of a for-in statement is immediately 
followed by the token sequence `let [` then the `let` is treated as the start of 
a ForDeclaration. In previous editions such a token sequence would be the start of 
an LeftHandSideExpression.

14.7: Prior to ECMAScript 2015, an initialization expression could appear as 
part of the VariableDeclaration that precedes the **in** keyword. In ECMAScript 2015, 
the ForBinding in that same position does not allow the occurrence of such an 
initializer. In ECMAScript 2017, such an initializer is permitted only in non-strict code.

14.7: In ECMAScript 2015, the result of evaluating an IterationStatement is never 
a normal completion whose [[Value]] is EMPTY. If the Statement part of an 
IterationStatement is not evaluated or if the final evaluation of the Statement 
part produces a normal completion whose [[Value]] is EMPTY, the result of 
evaluating the IterationStatement is a normal completion whose [[Value]] is **undefined**.

14.11.2: In ECMAScript 2015, the result of evaluating a WithStatement is never a 
normal completion whose [[Value]] is EMPTY. If evaluation of the Statement part of 
a WithStatement produces a normal completion whose [[Value]] is EMPTY, the result 
of evaluating the WithStatement is a normal completion whose [[Value]] is **undefined**.

14.12.4: In ECMAScript 2015, the result of evaluating a SwitchStatement is never a 
normal completion whose [[Value]] is EMPTY. If evaluation of the CaseBlock part of 
a SwitchStatement produces a normal completion whose [[Value]] is EMPTY, the result 
of evaluating the SwitchStatement is a normal completion whose [[Value]] is **undefined**.

14.15: In ECMAScript 2015, it is an early error for a Catch clause to contain a 
**var** declaration for the same Identifier that appears as the Catch clause parameter. 
In previous editions, such a variable declaration would be instantiated in the 
enclosing variable environment but the declaration's Initializer value would be 
assigned to the Catch parameter.

14.15, 19.2.1.3: In ECMAScript 2015, a runtime **SyntaxError** is thrown if a Catch 
clause evaluates a non-strict direct **eval** whose eval code includes a **var** or 
**FunctionDeclaration** declaration that binds the same Identifier that appears as 
the Catch clause parameter.

14.15.3: In ECMAScript 2015, the result of a TryStatement is never the value EMPTY. 
If the Block part of a TryStatement evaluates to a normal completion containing 
EMPTY, the result of the TryStatement is **undefined**. If the Block part of a 
TryStatement evaluates to a throw completion and it has a Catch part that evaluates 
to a normal completion containing EMPTY, the result of the TryStatement is 
**undefined** if there is no Finally clause or if its Finally clause evaluates to 
an EMPTY normal completion.

15.4.5 In ECMAScript 2015, the function objects that are created as the values of 
the [[Get]] or [[Set]] attribute of accessor properties in an ObjectLiteral are not 
constructor functions and they do not have a **"prototype"** own property. In the 
previous edition, they were constructors and had a **"prototype"** property.

20.1.2.6: In ECMAScript 2015, if the argument to **Object.freeze** is not an object it 
is treated as if it was a non-extensible ordinary object with no own properties. In 
the previous edition, a non-object argument always causes a **TypeError** to be thrown.

20.1.2.8: In ECMAScript 2015, if the argument to **Object.getOwnPropertyDescriptor** 
is not an object an attempt is made to coerce the argument using `ToObject`. If the 
coercion is successful the result is used in place of the original argument value. 
In the previous edition, a non-object argument always causes a **TypeError** to be thrown.

20.1.2.10: In ECMAScript 2015, if the argument to **Object.getOwnPropertyNames** is 
not an object an attempt is made to coerce the argument using `ToObject`. If the 
coercion is successful the result is used in place of the original argument value. 
In the previous edition, a non-object argument always causes a **TypeError** to be thrown.

20.1.2.12: In ECMAScript 2015, if the argument to **Object.getPrototypeOf** is not 
an object an attempt is made to coerce the argument using `ToObject`. If the 
coercion is successful the result is used in place of the original argument value. 
In the previous edition, a non-object argument always causes a **TypeError** to be thrown.

20.1.2.16: In ECMAScript 2015, if the argument to **Object.isExtensible** is not an 
object it is treated as if it was a non-extensible ordinary object with no own 
properties. In the previous edition, a non-object argument always causes a 
**TypeError** to be thrown.

20.1.2.17: In ECMAScript 2015, if the argument to **Object.isFrozen** is not an 
object it is treated as if it was a non-extensible ordinary object with no own 
properties. In the previous edition, a non-object argument always causes a 
**TypeError** to be thrown.

20.1.2.18: In ECMAScript 2015, if the argument to **Object.isSealed** is not an 
object it is treated as if it was a non-extensible ordinary object with no own 
properties. In the previous edition, a non-object argument always causes a **TypeError** to be thrown.

20.1.2.19: In ECMAScript 2015, if the argument to **Object.keys** is not an object 
an attempt is made to coerce the argument using `ToObject`. If the coercion is 
successful the result is used in place of the original argument value. In the 
previous edition, a non-object argument always causes a **TypeError** to be thrown.

20.1.2.20: In ECMAScript 2015, if the argument to **Object.preventExtensions** is 
not an object it is treated as if it was a non-extensible ordinary object with no 
own properties. In the previous edition, a non-object argument always causes a 
**TypeError** to be thrown.

20.1.2.22: In ECMAScript 2015, if the argument to **Object.seal** is not an object 
it is treated as if it was a non-extensible ordinary object with no own properties. 
In the previous edition, a non-object argument always causes a **TypeError** to be thrown.

20.2.3.2: In ECMAScript 2015, the [[Prototype]] internal slot of a bound function 
is set to the [[GetPrototypeOf]] value of its target function. In the previous 
edition, [[Prototype]] was always set to %Function.prototype%.

20.2.4.1: In ECMAScript 2015, the **"length"** property of function instances is 
configurable. In previous editions it was non-configurable.

20.5.6.2: In ECMAScript 2015, the [[Prototype]] internal slot of a NativeError 
constructor is the Error constructor. In previous editions it was the Function 
prototype object.

21.4.4 In ECMAScript 2015, the Date prototype object is not a Date instance. 
In previous editions it was a Date instance whose TimeValue was **NaN**.

22.1.3.12 In ECMAScript 2015, the **String.prototype.localeCompare** function must 
treat Strings that are canonically equivalent according to the Unicode Standard as 
being identical. In previous editions implementations were permitted to ignore 
canonical equivalence and could instead use a bit-wise comparison.

22.1.3.28 and 22.1.3.30 In ECMAScript 2015, lowercase/upper conversion processing 
operates on code points. In previous editions such the conversion processing was 
only applied to individual code units. The only affected code points are those in 
the Deseret block of Unicode.

22.1.3.32 In ECMAScript 2015, the **String.prototype.trim** method is defined to 
recognize white space code points that may exist outside of the Unicode BMP. 
However, as of Unicode 7 no such code points are defined. In previous editions such 
code points would not have been recognized as white space.

22.2.4.1 In ECMAScript 2015, If the `pattern` argument is a RegExp instance and the 
`flags` argument is not undefined, a new RegExp instance is created just like pattern 
except that pattern's `flags` are replaced by the argument `flags`. In previous 
editions a **TypeError** exception was thrown when pattern was a RegExp instance 
and `flags` was not undefined.

22.2.6 In ECMAScript 2015, the RegExp prototype object is not a RegExp instance. In 
previous editions it was a RegExp instance whose pattern is the empty String.

22.2.6 In ECMAScript 2015, "source", "global", "ignoreCase", and "multiline" are 
accessor properties defined on the RegExp prototype object. In previous editions 
they were data properties defined on RegExp instances.

25.4.15: In ECMAScript 2019, Atomics.wake has been renamed to Atomics.notify to 
prevent confusion with Atomics.wait.

27.1.6.4, 27.6.3.6: In ECMAScript 2019, the number of Jobs enqueued by await was 
reduced, which could create an observable difference in resolution order between 
a then() call and an await expression.


G Colophon
==========

https://tc39.es/ecma262/multipage/colophon.html

This specification is authored on `GitHub <https://github.com/tc39/ecma262>`__ 
in a plaintext source format called `Ecmarkup <https://github.com/bterlson/ecmarkup>`__.
Ecmarkup is an HTML and Markdown dialect that provides a framework and
toolset for authoring ECMAScript specifications in plaintext and
processing the specification into a full-featured HTML rendering that
follows the editorial conventions for this document. Ecmarkup builds on
and integrates a number of other formats and technologies including
`Grammarkdown <https://github.com/rbuckton/grammarkdown>`__ for defining
syntax and `Ecmarkdown <https://github.com/domenic/ecmarkdown>`__ for
authoring algorithm steps. PDF renderings of this specification are
produced by printing the HTML rendering to a PDF.

Prior editions of this specification were authored using Word—the
Ecmarkup source text that formed the basis of this edition was produced
by converting the ECMAScript 2015 Word document to Ecmarkup using an
automated conversion tool.

H Bibliography
==============

https://tc39.es/ecma262/multipage/bibliography.html

#. IEEE 754-2019: *IEEE Standard for Floating-Point Arithmetic*.
   Institute of Electrical and Electronic Engineers, New York (2019)

   .. Note::

      There are no normative changes between IEEE 754-2008 and IEEE
      754-2019 that affect the ECMA-262 specification.

#. *The Unicode Standard*, available at <https://unicode.org/versions/latest>

#. *Unicode Technical Note #5: Canonical Equivalence in Applications*,
   available at <https://unicode.org/notes/tn5/>

#. *Unicode Technical Standard #10: Unicode Collation Algorithm*,
   available at <https://unicode.org/reports/tr10/>

#. *Unicode Standard Annex #15, Unicode Normalization Forms*, available
   at <https://unicode.org/reports/tr15/>

#. *Unicode Standard Annex #18: Unicode Regular Expressions*, available
   at <https://unicode.org/reports/tr18/>

#. *Unicode Standard Annex #24: Unicode `Script` Property*, available
   at <https://unicode.org/reports/tr24/>

#. *Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax*,
   available at <https://unicode.org/reports/tr31/>

#. *Unicode Standard Annex #44: Unicode Character Database*, available
   at <https://unicode.org/reports/tr44/>

#. *Unicode Technical Standard #51: Unicode Emoji*, available at
   <https://unicode.org/reports/tr51/>

#. *IANA Time Zone Database*, available at <https://www.iana.org/time-zones>

#. ISO 8601:2004(E) *Data elements and interchange formats — Information
   interchange — Representation of dates and times*

#. *RFC 1738 “Uniform Resource Locators (URL)”*, available at
   <https://tools.ietf.org/html/rfc1738>

#. *RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”*,
   available at <https://tools.ietf.org/html/rfc2396>

#. *RFC 3629 “UTF-8, a transformation format of ISO 10646”*, available
   at <https://tools.ietf.org/html/rfc3629>

#. *RFC 7231 “Hypertext Transfer Protocol (HTTP/1.1): Semantics and
   Content”*, available at <https://tools.ietf.org/html/rfc7231>


I Copyright & Software License
==============================

https://tc39.es/ecma262/multipage/copyright-and-software-license.html

Ecma International

Rue du Rhone 114

CH-1204 Geneva

Tel: +41 22 849 6000

Fax: +41 22 849 6001

Web: https://ecma-international.org/

Copyright Notice
----------------

© 2024 Ecma International

This draft document may be copied and furnished to others, and derivative works 
that comment on or otherwise explain it or assist in its implementation may be 
prepared, copied, published, and distributed, in whole or in part, without 
restriction of any kind, provided that the above copyright notice and this 
section are included on all such copies and derivative works. However, this 
document itself may not be modified in any way, including by removing the 
copyright notice or references to Ecma International, except as needed for 
the purpose of developing any document or deliverable produced by Ecma International.

This disclaimer is valid only prior to final version of this document. After 
approval all rights on the standard are reserved by Ecma International.

The limited permissions are granted through the standardization phase and will 
not be revoked by Ecma International or its successors or assigns during this time.

This document and the information contained herein is provided on an "AS IS" 
basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION 
HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF 
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Software License
----------------

All Software contained in this document ("Software") is protected by copyright 
and is being made available under the "BSD License", included below. This Software 
may be subject to third party rights (rights from parties other than Ecma 
International), including patent rights, and no licenses under such third party 
rights are granted under this license even if the third party concerned is a 
member of Ecma International. SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS 
AVAILABLE AT https://ecma-international.org/memento/codeofconduct.htm FOR 
INFORMATION REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO 
IMPLEMENT ECMA INTERNATIONAL STANDARDS.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright notice, 
      this list of conditions and the following disclaimer in the documentation 
      and/or other materials provided with the distribution.

   3. Neither the name of the authors nor Ecma International may be used to 
      endorse or promote products derived from this software without specific 
      prior written permission.

THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS OR 
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO 
EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
OF SUCH DAMAGE.

